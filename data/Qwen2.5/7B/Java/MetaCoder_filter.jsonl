{"task_id": "Java/0", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Check if in given list of numbers, are any two numbers closer to each other than given threshold.\n     *\n     * @param numbers List of Double values.\n     * @param threshold The threshold value for closeness.\n     * @return true if there exist at least two elements whose difference is less than the threshold; false otherwise.\n     */\n    public boolean has_close_elements(List<Double> numbers, double threshold) {\n        // Sort the list to make it easier to find close elements\n        Collections.sort(numbers);\n        \n        for (int i = 0; i < numbers.size() - 1; i++) {\n            if (numbers.get(i + 1) - numbers.get(i) < threshold) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.has_close_elements(Arrays.asList(1.0, 2.0, 3.0), 0.5)); // Expected: false\n        System.out.println(solution.has_close_elements(Arrays.asList(1.0, 2.8, 3.0, 4.0, 5.0, 2.0), 0.3)); // Expected: true\n        System.out.println(solution.has_close_elements(Arrays.asList(-1.0, -2.0, -3.0), 1.5)); // Expected: false\n        System.out.println(solution.has_close_elements(Arrays.asList(10.0, 10.1, 10.2, 10.3), 0.05)); // Expected: true\n    }\n}\n"}
{"task_id": "Java/1", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n     * separate those group into separate strings and return the list of those.\n     * Separate groups are balanced (each open brace is properly closed) and not nested within each other\n     * Ignore any spaces in the input string.\n     *\n     * @param paren_string The input string containing multiple groups of nested parentheses.\n     * @return A List of separate strings, each representing a group of balanced parentheses.\n     */\n    public List<String> separate_paren_groups(String paren_string) {\n        List<String> result = new ArrayList<>();\n        int balance = 0;\n        StringBuilder currentGroup = new StringBuilder();\n\n        for (char c : paren_string.toCharArray()) {\n            if (c == ' ') continue; // Ignore spaces\n\n            if (c == '(') {\n                balance++;\n                currentGroup.append(c);\n            } else if (c == ')') {\n                balance--;\n                currentGroup.append(c);\n\n                if (balance == 0) { // A complete group is found\n                    result.add(currentGroup.toString());\n                    currentGroup = new StringBuilder(); // Reset for the next group\n                }\n            }\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(\"Test Case 1: ( ) (( )) (( )( ))\");\n        List<String> test1 = solution.separate_paren_groups(\"( ) (( )) (( )( ))\");\n        for (String group : test1) {\n            System.out.println(group);\n        }\n\n        System.out.println(\"\\nTest Case 2: (()())(())\");\n        List<String> test2 = solution.separate_paren_groups(\"(()())(())\");\n        for (String group : test2) {\n            System.out.println(group);\n        }\n\n        System.out.println(\"\\nTest Case 3: ((()))((()))\");\n        List<String> test3 = solution.separate_paren_groups(\"((()))((()))\");\n        for (String group : test3) {\n            System.out.println(group);\n        }\n    }\n}\n"}
{"task_id": "Java/2", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     Given a positive floating point number, it can be decomposed into\n     and integer part (largest integer smaller than given number) and decimals\n     (leftover part always smaller than 1).\n\n     Return the decimal part of the number.\n     >>> truncate_number(3.5)\n     0.5\n     */\n    public double truncate_number(double number) {\n        return number - Math.floor(number);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(\"Truncate 3.5: \" + solution.truncate_number(3.5)); // Expected output: 0.5\n        System.out.println(\"Truncate 123.456: \" + solution.truncate_number(123.456)); // Expected output: 0.456\n        System.out.println(\"Truncate -1.234: \" + solution.truncate_number(-1.234)); // Expected output: -0.234 (Note: floor of negative numbers is less than the number itself)\n        System.out.println(\"Truncate 0.999: \" + solution.truncate_number(0.999)); // Expected output: 0.999\n        System.out.println(\"Truncate 10.0: \" + solution.truncate_number(10.0)); // Expected output: 0.0\n    }\n}\n"}
{"task_id": "Java/3", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * You're given a list of deposit and withdrawal operations on a bank account that starts with\n     * zero balance. Your task is to detect if at any point the balance of the account falls below zero,\n     * and at that point, the function should return true. Otherwise, it should return false.\n     *\n     * @param operations List of integers representing deposits (positive) and withdrawals (negative).\n     * @return boolean indicating whether the balance ever goes below zero.\n     */\n    public boolean below_zero(List<Integer> operations) {\n        int balance = 0;\n        for (int op : operations) {\n            balance += op;\n            if (balance < 0) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        List<Integer> test1 = Arrays.asList(1, 2, 3);\n        System.out.println(\"Test Case 1: \" + (solution.below_zero(test1) == false)); // Expected: true\n\n        List<Integer> test2 = Arrays.asList(1, 2, -4, 5);\n        System.out.println(\"Test Case 2: \" + (solution.below_zero(test2) == true)); // Expected: true\n\n        List<Integer> test3 = Arrays.asList(-1, 2, -1, 3);\n        System.out.println(\"Test Case 3: \" + (solution.below_zero(test3) == false)); // Expected: false\n\n        List<Integer> test4 = Arrays.asList(5, -6, 7, -8, 9);\n        System.out.println(\"Test Case 4: \" + (solution.below_zero(test4) == true)); // Expected: true\n    }\n}\n"}
{"task_id": "Java/4", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * For a given list of input numbers, calculate Mean Absolute Deviation around the mean of this dataset.\n     * Mean Absolute Deviation is the average absolute difference between each element and a centerpoint (mean in this case):\n     * MAD = average | x - x_mean |\n     *\n     * @param numbers List of Double values\n     * @return Mean Absolute Deviation as a double\n     */\n    public double mean_absolute_deviation(List<Double> numbers) {\n        if (numbers == null || numbers.isEmpty()) {\n            throw new IllegalArgumentException(\"Input list cannot be null or empty\");\n        }\n\n        // Calculate the mean of the dataset\n        double sum = 0.0;\n        for (Double num : numbers) {\n            sum += num;\n        }\n        double mean = sum / numbers.size();\n\n        // Calculate the Mean Absolute Deviation\n        double mad = 0.0;\n        for (Double num : numbers) {\n            mad += Math.abs(num - mean);\n        }\n        return mad / numbers.size();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.mean_absolute_deviation(Arrays.asList(1.0, 2.0, 3.0, 4.0))); // Expected output: 1.0\n        System.out.println(solution.mean_absolute_deviation(Arrays.asList(5.0, 7.0, 9.0, 11.0, 13.0))); // Expected output: 2.8\n        System.out.println(solution.mean_absolute_deviation(Arrays.asList(-1.0, -2.0, -3.0, -4.0))); // Expected output: 1.5\n        System.out.println(solution.mean_absolute_deviation(Arrays.asList(10.0))); // Expected output: 0.0 (single element)\n    }\n}\n"}
{"task_id": "Java/5", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Insert a number 'delimiter' between every two consecutive elements of input list `numbers`\n     *\n     * @param numbers The input list of integers.\n     * @param delimiter The integer to be inserted as a delimiter.\n     * @return A new list with the delimiter interspersed.\n     */\n    public List<Integer> intersperse(List<Integer> numbers, int delimiter) {\n        if (numbers == null || numbers.size() <= 1) {\n            return numbers;\n        }\n\n        List<Integer> result = new ArrayList<>();\n        for (int i = 0; i < numbers.size(); i++) {\n            result.add(numbers.get(i));\n            if (i < numbers.size() - 1) {\n                result.add(delimiter);\n            }\n        }\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.intersperse(List.of(), 4)); // Expected: []\n        System.out.println(solution.intersperse(Arrays.asList(1, 2, 3), 4)); // Expected: [1, 4, 2, 4, 3]\n        System.out.println(solution.intersperse(Arrays.asList(5, 6, 7, 8), -1)); // Expected: [5, -1, 6, -1, 7, -1, 8]\n    }\n}\n"}
{"task_id": "Java/6", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n     * For each of the group, output the deepest level of nesting of parentheses.\n     * E.g. (()()) has maximum two levels of nesting while ((())) has three.\n     *\n     * >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n     * [2, 3, 1, 3]\n     */\n    public List<Integer> parse_nested_parens(String paren_string) {\n        String[] groups = paren_string.split(\"\\\\s+\");\n        List<Integer> depths = new ArrayList<>();\n        \n        for (String group : groups) {\n            int maxDepth = 0;\n            int currentDepth = 0;\n            \n            for (char c : group.toCharArray()) {\n                if (c == '(') {\n                    currentDepth++;\n                    maxDepth = Math.max(maxDepth, currentDepth);\n                } else if (c == ')') {\n                    currentDepth--;\n                }\n            }\n            \n            depths.add(maxDepth);\n        }\n        \n        return depths;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        String test1 = \"(()()) ((())) () ((())()())\";\n        List<Integer> result1 = solution.parse_nested_parens(test1);\n        System.out.println(result1); // Expected output: [2, 3, 1, 3]\n        \n        String test2 = \"(()) (()) (((())))\";\n        List<Integer> result2 = solution.parse_nested_parens(test2);\n        System.out.println(result2); // Expected output: [2, 2, 4]\n        \n        String test3 = \"((())) () (((())))\";\n        List<Integer> result3 = solution.parse_nested_parens(test3);\n        System.out.println(result3); // Expected output: [3, 1, 4]\n    }\n}\n"}
{"task_id": "Java/7", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Filter an input list of strings only for ones that contain given substring\n     *\n     * @param strings The input list of strings\n     * @param substring The substring to filter by\n     * @return A list of strings containing the specified substring\n     */\n    public List<String> filter_by_substring(List<String> strings, String substring) {\n        List<String> filteredList = new ArrayList<>();\n        for (String str : strings) {\n            if (str.contains(substring)) {\n                filteredList.add(str);\n            }\n        }\n        return filteredList;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(\"Test Case 1: Empty List\");\n        System.out.println(solution.filter_by_substring(List.of(), \"a\")); // Expected output: []\n\n        System.out.println(\"\\nTest Case 2: Normal List with 'a'\");\n        System.out.println(solution.filter_by_substring(Arrays.asList(\"abc\", \"bacd\", \"cde\", \"array\"), \"a\"));\n        // Expected output: [abc, bacd, array]\n\n        System.out.println(\"\\nTest Case 3: List without the substring\");\n        System.out.println(solution.filter_by_substring(Arrays.asList(\"hello\", \"world\", \"java\"), \"python\"));\n        // Expected output: []\n\n        System.out.println(\"\\nTest Case 4: List with multiple occurrences of the substring\");\n        System.out.println(solution.filter_by_substring(Arrays.asList(\"aaa\", \"baa\", \"aab\", \"bba\"), \"aa\"));\n        // Expected output: [aaa, aab]\n    }\n}\n"}
{"task_id": "Java/8", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> sum_product(List<Integer> numbers) {\n        if (numbers.isEmpty()) {\n            return Arrays.asList(0, 1);\n        }\n        \n        int totalSum = 0;\n        int totalProduct = 1;\n        \n        for (int num : numbers) {\n            totalSum += num;\n            totalProduct *= num;\n        }\n        \n        List<Integer> result = new ArrayList<>();\n        result.add(totalSum);\n        result.add(totalProduct);\n        \n        return result;\n    }\n}\n"}
{"task_id": "Java/9", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * From a given list of integers, generate a list of rolling maximum element found until given moment in the sequence.\n     *\n     * @param numbers The input list of integers.\n     * @return A list containing the rolling maximum elements.\n     */\n    public List<Integer> rolling_max(List<Integer> numbers) {\n        if (numbers == null || numbers.isEmpty()) {\n            return Collections.emptyList();\n        }\n\n        List<Integer> result = new ArrayList<>();\n        int maxSoFar = Integer.MIN_VALUE;\n\n        for (int num : numbers) {\n            if (num > maxSoFar) {\n                maxSoFar = num;\n            }\n            result.add(maxSoFar);\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.rolling_max(Arrays.asList(1, 2, 3, 2, 3, 4, 2))); // [1, 2, 3, 3, 3, 4, 4]\n        System.out.println(solution.rolling_max(Arrays.asList()));                   // []\n        System.out.println(solution.rolling_max(Arrays.asList(5)));                  // [5]\n        System.out.println(solution.rolling_max(Arrays.asList(-1, -2, -3, -2, -3, -4, -2))); // [-1, -1, -1, -1, -1, -1, -1]\n    }\n}\n"}
{"task_id": "Java/10", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n    Test if given string is a palindrome\n     */\n    public boolean isPalindrome(String string) {\n        int i = 0;\n        int j = string.length() - 1;\n        while (i < j) {\n            if (string.charAt(i) != string.charAt(j)) {\n                return false;\n            }\n            i++;\n            j--;\n        }\n        return true;\n    }\n\n    /**\n    Find the shortest palindrome that begins with a supplied string.\n     */\n    public String make_palindrome(String string) {\n        for (int i = 0; i < string.length(); i++) {\n            if (isPalindrome(string.substring(i))) {\n                return string + new StringBuilder(string.substring(0, i)).reverse().toString();\n            }\n        }\n        return string + new StringBuilder(string).reverse().toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.make_palindrome(\"\")); // \"\"\n        System.out.println(solution.make_palindrome(\"cat\")); // \"catac\"\n        System.out.println(solution.make_palindrome(\"cata\")); // \"catac\"\n    }\n}\n"}
{"task_id": "Java/11", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Input are two strings a and b consisting only of 1s and 0s.\n     * Perform binary XOR on these inputs and return result also as a string.\n     *\n     * @param a the first binary string\n     * @param b the second binary string\n     * @return the result of binary XOR operation as a string\n     */\n    public String string_xor(String a, String b) {\n        StringBuilder result = new StringBuilder();\n        int maxLength = Math.max(a.length(), b.length());\n        \n        // Pad both strings to have equal length\n        a = padStringToLength(a, maxLength);\n        b = padStringToLength(b, maxLength);\n\n        for (int i = 0; i < maxLength; i++) {\n            char bitA = a.charAt(i);\n            char bitB = b.charAt(i);\n            \n            // Perform XOR operation and append to result\n            if (bitA == bitB) {\n                result.append('0');\n            } else {\n                result.append('1');\n            }\n        }\n\n        return result.toString();\n    }\n\n    /**\n     * Pads the given string with '0's at the beginning to make it of specified length.\n     *\n     * @param str the input string\n     * @param length the desired length\n     * @return the padded string\n     */\n    private String padStringToLength(String str, int length) {\n        StringBuilder sb = new StringBuilder(str);\n        while (sb.length() < length) {\n            sb.insert(0, '0');\n        }\n        return sb.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.string_xor(\"010\", \"110\")); // Expected output: \"100\"\n        System.out.println(solution.string_xor(\"10101\", \"00111\")); // Expected output: \"10010\"\n        System.out.println(solution.string_xor(\"1111\", \"0000\")); // Expected output: \"1111\"\n        System.out.println(solution.string_xor(\"0000\", \"0000\")); // Expected output: \"0000\"\n        System.out.println(solution.string_xor(\"11111111\", \"00000000\")); // Expected output: \"11111111\"\n    }\n}\n"}
{"task_id": "Java/12", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     Out of list of strings, return the longest one. Return the first one in case of multiple\n     strings of the same length. Return Optional.empty() in case the input list is empty.\n     >>> longest(List.of())\n     Optional.empty\n     >>> longest(Arrays.asList(\"a\", \"b\", \"c\"))\n     Optional[a]\n     >>> longest(Arrays.asList(\"a\", \"bb\", \"ccc\"))\n     Optional[ccc]\n     */\n    public Optional<String> longest(List<String> strings) {\n        if (strings.isEmpty()) {\n            return Optional.empty();\n        }\n\n        String longestString = strings.get(0);\n        for (String str : strings) {\n            if (str.length() > longestString.length()) {\n                longestString = str;\n            }\n        }\n        \n        return Optional.of(longestString);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(\"Test Case 1: Empty List\");\n        System.out.println(solution.longest(List.of())); // Expected: Optional.empty\n\n        System.out.println(\"\\nTest Case 2: Single Element\");\n        System.out.println(solution.longest(Arrays.asList(\"a\"))); // Expected: Optional[a]\n\n        System.out.println(\"\\nTest Case 3: Multiple Elements with Different Lengths\");\n        System.out.println(solution.longest(Arrays.asList(\"a\", \"bb\", \"ccc\"))); // Expected: Optional[ccc]\n\n        System.out.println(\"\\nTest Case 4: Multiple Elements with Same Length\");\n        System.out.println(solution.longest(Arrays.asList(\"aa\", \"bbb\", \"cccc\"))); // Expected: Optional[cccc]\n    }\n}\n"}
{"task_id": "Java/13", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return a greatest common divisor of two integers a and b\n     *\n     * @param a first integer\n     * @param b second integer\n     * @return the greatest common divisor of a and b\n     */\n    public int greatest_common_divisor(int a, int b) {\n        while (b != 0) {\n            int temp = b;\n            b = a % b;\n            a = temp;\n        }\n        return a;\n    }\n\n    // Test cases to verify the correctness of the method\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1: GCD of 3 and 5 is 1\n        System.out.println(\"GCD of 3 and 5: \" + solution.greatest_common_divisor(3, 5)); // Expected output: 1\n\n        // Test case 2: GCD of 25 and 15 is 5\n        System.out.println(\"GCD of 25 and 15: \" + solution.greatest_common_divisor(25, 15)); // Expected output: 5\n\n        // Test case 3: GCD of 100 and 80 is 20\n        System.out.println(\"GCD of 100 and 80: \" + solution.greatest_common_divisor(100, 80)); // Expected output: 20\n\n        // Test case 4: GCD of 7 and 13 (both prime) is 1\n        System.out.println(\"GCD of 7 and 13: \" + solution.greatest_common_divisor(7, 13)); // Expected output: 1\n\n        // Test case 5: GCD of 0 and any number is that number (since gcd(0, b) = b)\n        System.out.println(\"GCD of 0 and 24: \" + solution.greatest_common_divisor(0, 24)); // Expected output: 24\n    }\n}\n"}
{"task_id": "Java/14", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Return list of all prefixes from shortest to longest of the input string\n     *\n     * @param string The input string\n     * @return A List containing all prefixes of the input string, ordered from shortest to longest\n     */\n    public List<String> all_prefixes(String string) {\n        List<String> prefixes = new ArrayList<>();\n        if (string == null || string.isEmpty()) {\n            return prefixes;\n        }\n        \n        for (int i = 1; i <= string.length(); i++) {\n            prefixes.add(string.substring(0, i));\n        }\n        \n        return prefixes;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(\"Testing all_prefixes(\\\"abc\\\"): \" + solution.all_prefixes(\"abc\")); // [\"a\", \"ab\", \"abc\"]\n        System.out.println(\"Testing all_prefixes(\\\"\\\"): \" + solution.all_prefixes(\"\")); // []\n        System.out.println(\"Testing all_prefixes(null): \" + solution.all_prefixes(null)); // []\n\n        // Additional test cases\n        System.out.println(\"Testing all_prefixes(\\\"hello\\\"): \" + solution.all_prefixes(\"hello\")); // [\"h\", \"he\", \"hel\", \"hell\", \"hello\"]\n        System.out.println(\"Testing all_prefixes(\\\"java\\\"): \" + solution.all_prefixes(\"java\")); // [\"j\", \"ja\", \"jav\", \"java\"]\n    }\n}\n"}
{"task_id": "Java/15", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Return a string containing space-delimited numbers starting from 0 up to n inclusive.\n     *\n     * @param n The upper limit of the sequence (inclusive).\n     * @return A string with space-separated numbers from 0 to n.\n     */\n    public String string_sequence(int n) {\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i <= n; i++) {\n            if (i > 0) {\n                sb.append(\" \");\n            }\n            sb.append(i);\n        }\n        return sb.toString();\n    }\n\n    // Test cases to verify the correctness of the string_sequence method\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1: n = 0\n        System.out.println(solution.string_sequence(0).equals(\"0\") ? \"Test 1 Passed\" : \"Test 1 Failed\");\n\n        // Test case 2: n = 5\n        System.out.println(solution.string_sequence(5).equals(\"0 1 2 3 4 5\") ? \"Test 2 Passed\" : \"Test 2 Failed\");\n\n        // Additional test cases\n        System.out.println(solution.string_sequence(10).equals(\"0 1 2 3 4 5 6 7 8 9 10\") ? \"Test 3 Passed\" : \"Test 3 Failed\");\n        System.out.println(solution.string_sequence(-1).equals(\"\") ? \"Test 4 Passed\" : \"Test 4 Failed\"); // Edge case: n < 0\n    }\n}\n"}
{"task_id": "Java/16", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given a string, find out how many distinct characters (regardless of case) does it consist of.\n     *\n     * @param string The input string to analyze.\n     * @return The number of distinct characters in the string, ignoring case.\n     */\n    public int count_distinct_characters(String string) {\n        // Convert the string to lowercase to ignore case\n        String lowerCaseString = string.toLowerCase();\n        \n        // Use a HashSet to store unique characters\n        Set<Character> uniqueChars = new HashSet<>();\n        \n        // Iterate through each character in the string and add it to the set\n        for (char c : lowerCaseString.toCharArray()) {\n            uniqueChars.add(c);\n        }\n        \n        // The size of the set is the number of distinct characters\n        return uniqueChars.size();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.count_distinct_characters(\"xyzXYZ\")); // Expected output: 3\n        System.out.println(solution.count_distinct_characters(\"Jerry\"));   // Expected output: 4\n        System.out.println(solution.count_distinct_characters(\"HelloWorld\")); // Expected output: 7\n        System.out.println(solution.count_distinct_characters(\"AAAaaa\"));    // Expected output: 1\n        System.out.println(solution.count_distinct_characters(\"\"));          // Expected output: 0\n        System.out.println(solution.count_distinct_characters(\"aAaAaA\"));    // Expected output: 1\n    }\n}\n"}
{"task_id": "Java/17", "generation": "import java.util.*;\n\nclass Solution {\n    public List<Integer> parse_music(String string) {\n        String[] notes = string.split(\" \");\n        List<Integer> beats = new ArrayList<>();\n        \n        for (String note : notes) {\n            if (\"o\".equals(note)) {\n                beats.add(4);\n            } else if (\"o|\".equals(note)) {\n                beats.add(2);\n            } else if (\".|\".equals(note)) {\n                beats.add(1);\n            }\n        }\n        \n        return beats;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        List<Integer> result = solution.parse_music(\"o o| .| o| o| .| .| .| .| o o\");\n        System.out.println(result); // Expected output: [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    }\n}\n"}
{"task_id": "Java/18", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Find how many times a given substring can be found in the original string. Count overlapping cases.\n     *\n     * @param string The original string.\n     * @param substring The substring to find.\n     * @return The number of times the substring appears in the original string, including overlaps.\n     */\n    public int how_many_times(String string, String substring) {\n        if (substring.isEmpty()) return 0;\n        \n        int count = 0;\n        int index = 0;\n        \n        while ((index = string.indexOf(substring, index)) != -1) {\n            count++;\n            index++; // Move to the next character after the found substring to allow for overlapping matches\n        }\n        \n        return count;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.how_many_times(\"\", \"a\")); // Expected output: 0\n        System.out.println(solution.how_many_times(\"aaa\", \"a\")); // Expected output: 3\n        System.out.println(solution.how_many_times(\"aaaa\", \"aa\")); // Expected output: 3\n        System.out.println(solution.how_many_times(\"abababa\", \"aba\")); // Expected output: 3\n        System.out.println(solution.how_many_times(\"testtest\", \"test\")); // Expected output: 2\n    }\n}\n"}
{"task_id": "Java/19", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Input is a space-delimited string of numberals from 'zero' to 'nine'.\n     * Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n     * Return the string with numbers sorted from smallest to largest\n     *\n     * >>> sort_numbers(\"three one five\")\n     * \"one three five\"\n     */\n    public String sort_numbers(String numbers) {\n        Map<String, Integer> numeralMap = new HashMap<>();\n        numeralMap.put(\"zero\", 0);\n        numeralMap.put(\"one\", 1);\n        numeralMap.put(\"two\", 2);\n        numeralMap.put(\"three\", 3);\n        numeralMap.put(\"four\", 4);\n        numeralMap.put(\"five\", 5);\n        numeralMap.put(\"six\", 6);\n        numeralMap.put(\"seven\", 7);\n        numeralMap.put(\"eight\", 8);\n        numeralMap.put(\"nine\", 9);\n\n        String[] words = numbers.split(\" \");\n        List<Integer> sortedNumbers = new ArrayList<>();\n        \n        for (String word : words) {\n            sortedNumbers.add(numeralMap.get(word));\n        }\n        \n        Collections.sort(sortedNumbers);\n        \n        StringBuilder result = new StringBuilder();\n        for (int num : sortedNumbers) {\n            result.append(getNumeral(num)).append(\" \");\n        }\n        \n        return result.toString().trim();\n    }\n\n    private String getNumeral(int number) {\n        Map<Integer, String> reverseMap = new HashMap<>();\n        reverseMap.put(0, \"zero\");\n        reverseMap.put(1, \"one\");\n        reverseMap.put(2, \"two\");\n        reverseMap.put(3, \"three\");\n        reverseMap.put(4, \"four\");\n        reverseMap.put(5, \"five\");\n        reverseMap.put(6, \"six\");\n        reverseMap.put(7, \"seven\");\n        reverseMap.put(8, \"eight\");\n        reverseMap.put(9, \"nine\");\n\n        return reverseMap.get(number);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.sort_numbers(\"three one five\"));  // Output: \"one three five\"\n    }\n}\n"}
{"task_id": "Java/20", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * From a supplied list of numbers (of length at least two) select and return two that are the closest to each other and return them in order (smaller number, larger number).\n     */\n    public List<Double> find_closest_elements(List<Double> numbers) {\n        if (numbers == null || numbers.size() < 2) {\n            throw new IllegalArgumentException(\"List must contain at least two elements.\");\n        }\n\n        double minDiff = Double.MAX_VALUE;\n        List<Double> closestElements = new ArrayList<>();\n\n        for (int i = 0; i < numbers.size(); i++) {\n            for (int j = i + 1; j < numbers.size(); j++) {\n                double diff = Math.abs(numbers.get(i) - numbers.get(j));\n                if (diff < minDiff) {\n                    minDiff = diff;\n                    closestElements.clear();\n                    closestElements.add(Math.min(numbers.get(i), numbers.get(j)));\n                    closestElements.add(Math.max(numbers.get(i), numbers.get(j)));\n                }\n            }\n        }\n\n        return closestElements;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.find_closest_elements(Arrays.asList(1.0, 2.0, 3.0, 4.0, 5.0, 2.2))); // [2.0, 2.2]\n        System.out.println(solution.find_closest_elements(Arrays.asList(1.0, 2.0, 3.0, 4.0, 5.0, 2.0)));  // [2.0, 2.0]\n        System.out.println(solution.find_closest_elements(Arrays.asList(-1.0, -2.0, -3.0, -4.0, -5.0, -2.2))); // [-2.2, -2.0]\n        System.out.println(solution.find_closest_elements(Arrays.asList(10.5, 10.6, 10.7, 10.8, 10.9))); // [10.5, 10.6]\n    }\n}\n"}
{"task_id": "Java/21", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given list of numbers (of at least two elements), apply a linear transform to that list,\n     * such that the smallest number will become 0 and the largest will become 1.\n     *\n     * @param numbers List of Double values\n     * @return A new list where each element is rescaled to the range [0, 1]\n     */\n    public List<Double> rescale_to_unit(List<Double> numbers) {\n        if (numbers == null || numbers.size() < 2) {\n            throw new IllegalArgumentException(\"List must contain at least two elements\");\n        }\n\n        double min = Collections.min(numbers);\n        double max = Collections.max(numbers);\n\n        List<Double> result = new ArrayList<>();\n        for (Double num : numbers) {\n            double scaledValue = (num - min) / (max - min);\n            result.add(scaledValue);\n        }\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        List<Double> test1 = Arrays.asList(1.0, 2.0, 3.0, 4.0, 5.0);\n        System.out.println(\"Test Case 1: \" + solution.rescale_to_unit(test1));\n        \n        List<Double> test2 = Arrays.asList(-1.0, -2.0, -3.0, -4.0, -5.0);\n        System.out.println(\"Test Case 2: \" + solution.rescale_to_unit(test2));\n        \n        List<Double> test3 = Arrays.asList(10.0, 20.0, 30.0, 40.0, 50.0);\n        System.out.println(\"Test Case 3: \" + solution.rescale_to_unit(test3));\n    }\n}\n"}
{"task_id": "Java/22", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Filter given list of any values only for integers\n    >>> filter_integers(Arrays.asList('a', 3.14, 5))\n    [5]\n    >>> filter_integers(Arrays.asList(1, 2, 3, \"abc\", Map.of(), List.of()))\n    [1, 2, 3]\n     */\n    public List<Integer> filter_integers(List<Object> values) {\n        List<Integer> result = new ArrayList<>();\n        for (Object value : values) {\n            if (value instanceof Integer) {\n                result.add((Integer) value);\n            }\n        }\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case 1\n        List<Object> list1 = Arrays.asList('a', 3.14, 5);\n        System.out.println(solution.filter_integers(list1)); // Output: [5]\n        \n        // Test case 2\n        List<Object> list2 = Arrays.asList(1, 2, 3, \"abc\", Map.of(), List.of());\n        System.out.println(solution.filter_integers(list2)); // Output: [1, 2, 3]\n    }\n}\n"}
{"task_id": "Java/23", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Return length of given string\n     * >>> strlen(\"\")\n     * 0\n     * >>> strlen(\"abc\")\n     * 3\n     */\n    public int strlen(String string) {\n        return string.length();\n    }\n\n    public static void main(String[] args) {\n        // Create an instance of Solution\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(\"Test Case 1: Empty String\");\n        System.out.println(\"Expected Output: 0\");\n        System.out.println(\"Actual Output: \" + solution.strlen(\"\"));\n        System.out.println();\n\n        System.out.println(\"Test Case 2: Single Character String\");\n        System.out.println(\"Expected Output: 1\");\n        System.out.println(\"Actual Output: \" + solution.strlen(\"a\"));\n        System.out.println();\n\n        System.out.println(\"Test Case 3: Multiple Characters String\");\n        System.out.println(\"Expected Output: 5\");\n        System.out.println(\"Actual Output: \" + solution.strlen(\"hello\"));\n        System.out.println();\n\n        System.out.println(\"Test Case 4: Longer String with Spaces and Special Characters\");\n        System.out.println(\"Expected Output: 12\");\n        System.out.println(\"Actual Output: \" + solution.strlen(\"Hello, world!\"));\n    }\n}\n"}
{"task_id": "Java/24", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * For a given number n, find the largest number that divides n evenly, smaller than n.\n     *\n     * @param n The input number.\n     * @return The largest divisor of n that is smaller than n.\n     */\n    public int largest_divisor(int n) {\n        for (int i = n / 2; i >= 1; i--) {\n            if (n % i == 0) {\n                return i;\n            }\n        }\n        // If no divisor found, which should not happen for positive integers,\n        // we return -1 as an error indicator.\n        return -1;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.largest_divisor(15));  // Expected output: 5\n        System.out.println(solution.largest_divisor(28));  // Expected output: 14\n        System.out.println(solution.largest_divisor(37));  // Expected output: -1 (since 37 is prime)\n        System.out.println(solution.largest_divisor(100)); // Expected output: 50\n    }\n}\n"}
{"task_id": "Java/25", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Return list of prime factors of given integer in the order from smallest to largest.\n     * Each of the factors should be listed number of times corresponding to how many times it appears in factorization.\n     * Input number should be equal to the product of all factors\n     *\n     * @param n the integer to factorize\n     * @return a list of prime factors\n     */\n    public List<Integer> factorize(int n) {\n        List<Integer> factors = new ArrayList<>();\n        for (int factor = 2; factor <= n; factor++) {\n            while (n % factor == 0) {\n                factors.add(factor);\n                n /= factor;\n            }\n        }\n        return factors;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(\"Factorize(8): \" + solution.factorize(8));   // Expected: [2, 2, 2]\n        System.out.println(\"Factorize(25): \" + solution.factorize(25));  // Expected: [5, 5]\n        System.out.println(\"Factorize(70): \" + solution.factorize(70));  // Expected: [2, 5, 7]\n        System.out.println(\"Factorize(49): \" + solution.factorize(49));  // Expected: [7, 7]\n        System.out.println(\"Factorize(1): \" + solution.factorize(1));    // Expected: []\n        System.out.println(\"Factorize(2): \" + solution.factorize(2));    // Expected: [2]\n    }\n}\n"}
{"task_id": "Java/26", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> remove_duplicates(List<Integer> numbers) {\n        Set<Integer> seen = new LinkedHashSet<>();\n        for (Integer num : numbers) {\n            seen.add(num);\n        }\n        return new ArrayList<>(seen);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.remove_duplicates(Arrays.asList(1, 2, 3, 2, 4))); // [1, 3, 4]\n    }\n}\n"}
{"task_id": "Java/27", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n     *\n     * @param string The input string to be flipped.\n     * @return A new string with the case of each character flipped.\n     */\n    public String flip_case(String string) {\n        StringBuilder result = new StringBuilder();\n        for (char c : string.toCharArray()) {\n            if (Character.isUpperCase(c)) {\n                result.append(Character.toLowerCase(c));\n            } else {\n                result.append(Character.toUpperCase(c));\n            }\n        }\n        return result.toString();\n    }\n\n    // Test method to verify the correctness of flip_case\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.flip_case(\"Hello\"));  // Expected: \"hELLO\"\n        System.out.println(solution.flip_case(\"WORLD\"));  // Expected: \"world\"\n        System.out.println(solution.flip_case(\"Java\"));   // Expected: \"jAVA\"\n        System.out.println(solution.flip_case(\"123abcABC\"));  // Expected: \"123ABCabc\"\n        System.out.println(solution.flip_case(\"\"));       // Expected: \"\"\n    }\n}\n"}
{"task_id": "Java/28", "generation": "import java.util.Arrays;\nimport java.util.List;\n\nclass Solution {\n    /**\n     * Concatenate list of strings into a single string\n     *\n     * @param strings List of strings to concatenate\n     * @return A single concatenated string\n     */\n    public String concatenate(List<String> strings) {\n        StringBuilder sb = new StringBuilder();\n        for (String str : strings) {\n            sb.append(str);\n        }\n        return sb.toString();\n    }\n}\n\nclass TestSolution {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1: Empty list\n        List<String> emptyList = Arrays.asList();\n        System.out.println(\"Expected: '', Actual: '\" + solution.concatenate(emptyList) + \"'\");\n\n        // Test case 2: Single element list\n        List<String> singleElementList = Arrays.asList(\"a\");\n        System.out.println(\"Expected: 'a', Actual: '\" + solution.concatenate(singleElementList) + \"'\");\n\n        // Test case 3: Multiple elements list\n        List<String> multipleElementsList = Arrays.asList(\"a\", \"b\", \"c\");\n        System.out.println(\"Expected: 'abc', Actual: '\" + solution.concatenate(multipleElementsList) + \"'\");\n    }\n}\n"}
{"task_id": "Java/29", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Filter an input list of strings only for ones that start with a given prefix.\n     *\n     * @param strings The input list of strings.\n     * @param prefix  The prefix to filter the strings by.\n     * @return A list of strings that start with the given prefix.\n     */\n    public List<String> filter_by_prefix(List<String> strings, String prefix) {\n        return strings.stream()\n                      .filter(s -> s.startsWith(prefix))\n                      .collect(Collectors.toList());\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.filter_by_prefix(new ArrayList<>(), \"a\"));  // []\n        System.out.println(solution.filter_by_prefix(Arrays.asList(\"abc\", \"bcd\", \"cde\", \"array\"), \"a\"));  // [abc, array]\n        System.out.println(solution.filter_by_prefix(Arrays.asList(\"apple\", \"banana\", \"apricot\", \"cherry\"), \"a\"));  // [apple, apricot]\n    }\n}\n"}
{"task_id": "Java/30", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return only positive numbers in the list.\n     */\n    public List<Integer> get_positive(List<Integer> l) {\n        return l.stream()\n                .filter(num -> num > 0)\n                .collect(Collectors.toList());\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(\"Test Case 1: \" + testGetPositive(Arrays.asList(-1, 2, -4, 5, 6), Arrays.asList(2, 5, 6)));\n        System.out.println(\"Test Case 2: \" + testGetPositive(Arrays.asList(5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10), Arrays.asList(5, 3, 2, 3, 9, 123, 1)));\n    }\n\n    private static boolean testGetPositive(List<Integer> input, List<Integer> expected) {\n        Solution solution = new Solution();\n        List<Integer> result = solution.get_positive(input);\n        return result.equals(expected);\n    }\n}\n"}
{"task_id": "Java/31", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Return true if a given number is prime, and false otherwise.\n     */\n    public boolean is_prime(int n) {\n        // Handle edge cases for 0, 1, and negative numbers\n        if (n <= 1) {\n            return false;\n        }\n        \n        // Check divisibility from 2 to the square root of n\n        for (int i = 2; i <= Math.sqrt(n); i++) {\n            if (n % i == 0) {\n                return false;\n            }\n        }\n        \n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(\"is_prime(6): \" + !solution.is_prime(6));   // Expected: false\n        System.out.println(\"is_prime(101): \" + solution.is_prime(101)); // Expected: true\n        System.out.println(\"is_prime(11): \" + solution.is_prime(11));   // Expected: true\n        System.out.println(\"is_prime(13441): \" + !solution.is_prime(13441)); // Expected: false (13441 is not prime)\n        System.out.println(\"is_prime(61): \" + solution.is_prime(61));   // Expected: true\n        System.out.println(\"is_prime(4): \" + !solution.is_prime(4));    // Expected: false\n        System.out.println(\"is_prime(1): \" + !solution.is_prime(1));    // Expected: false\n    }\n}\n"}
{"task_id": "Java/32", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Evaluates polynomial with coefficients xs at point x.\n     * return xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n\n     */\n    public double poly(List<Double> xs, double x) {\n        double result = 0;\n        for (int i = 0; i < xs.size(); i++) {\n            result += xs.get(i) * Math.pow(x, i);\n        }\n        return result;\n    }\n\n    /**\n     * xs are coefficients of a polynomial.\n     * find_zero finds x such that poly(x) = 0.\n     * find_zero returns only one zero point, even if there are many.\n     * Moreover, find_zero only takes list xs having an even number of coefficients\n     * and largest non-zero coefficient as it guarantees a solution.\n     */\n    public double find_zero(List<Double> xs) {\n        if (xs.size() % 2 != 0) {\n            throw new IllegalArgumentException(\"The list of coefficients must have an even number of elements.\");\n        }\n\n        // Ensure the largest non-zero coefficient is at the end\n        List<Double> nonZeroCoefficients = getNonZeroCoefficients(xs);\n        if (nonZeroCoefficients.isEmpty() || Math.abs(nonZeroCoefficients.get(nonZeroCoefficients.size() - 1)) == 0) {\n            throw new IllegalArgumentException(\"The list of coefficients must contain a non-zero element.\");\n        }\n\n        // Initial interval based on the sign change of the polynomial at endpoints\n        if (!hasOppositeSigns(xs)) {\n            throw new IllegalArgumentException(\"The list must contain an even number of non-zero coefficients with opposite signs for a root to exist.\");\n        }\n\n        return bisection(xs, -10, 10); // Initial interval [-10, 10]\n    }\n\n    private double bisection(List<Double> xs, double a, double b) {\n        while (Math.abs(b - a) > 1e-6) { // Tolerance for floating point comparison\n            double c = (a + b) / 2.0;\n            if (poly(xs, c) == 0) {\n                return c;\n            } else if (poly(xs, a) * poly(xs, c) < 0) {\n                b = c;\n            } else {\n                a = c;\n            }\n        }\n        return (a + b) / 2.0;\n    }\n\n    private List<Double> getNonZeroCoefficients(List<Double> xs) {\n        List<Double> nonZeroCoefficients = new ArrayList<>();\n        for (Double c : xs) {\n            if (!c.equals(0)) {\n                nonZeroCoefficients.add(c);\n            }\n        }\n        return nonZeroCoefficients;\n    }\n\n    private boolean hasOppositeSigns(List<Double> xs) {\n        double firstCoefficient = xs.get(0);\n        double lastCoefficient = xs.get(xs.size() - 1);\n        return (firstCoefficient > 0 && lastCoefficient < 0) || (firstCoefficient < 0 && lastCoefficient > 0);\n    }\n}\n"}
{"task_id": "Java/33", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> sort_third(List<Integer> l) {\n        // Extract elements at indices divisible by 3\n        List<Integer> thirdIndices = new ArrayList<>();\n        for (int i = 0; i < l.size(); i += 3) {\n            thirdIndices.add(l.get(i));\n        }\n        \n        // Sort the extracted elements\n        Collections.sort(thirdIndices);\n        \n        // Replace elements at indices divisible by 3 with sorted values\n        int index = 0;\n        for (int i = 0; i < l.size(); i += 3) {\n            l.set(i, thirdIndices.get(index++));\n        }\n        \n        return l;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        List<Integer> list1 = Arrays.asList(1, 2, 3);\n        System.out.println(solution.sort_third(list1)); // [1, 2, 3]\n        \n        List<Integer> list2 = Arrays.asList(5, 6, 3, 4, 8, 9, 2);\n        System.out.println(solution.sort_third(list2)); // [2, 6, 3, 4, 8, 9, 5]\n    }\n}\n"}
{"task_id": "Java/34", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return sorted unique elements in a list\n     *\n     * @param l input list of integers\n     * @return a List containing sorted unique elements from the input list\n     */\n    public List<Integer> unique(List<Integer> l) {\n        Set<Integer> set = new TreeSet<>(l);\n        return new ArrayList<>(set);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.unique(Arrays.asList(5, 3, 5, 2, 3, 3, 9, 0, 123))); // [0, 2, 3, 5, 9, 123]\n        System.out.println(solution.unique(Arrays.asList())); // []\n        System.out.println(solution.unique(Arrays.asList(1, 2, 3))); // [1, 2, 3]\n        System.out.println(solution.unique(Arrays.asList(-1, -2, -3, -4, -5))); // [-5, -4, -3, -2, -1]\n        System.out.println(solution.unique(Arrays.asList(7, 8, 9, 7, 8, 9, 10))); // [7, 8, 9, 10]\n    }\n}\n"}
{"task_id": "Java/35", "generation": "import java.util.Arrays;\nimport java.util.List;\n\nclass Solution {\n\n    /**\n     * Return maximum element in the list.\n     */\n    public int max_element(List<Integer> l) {\n        if (l == null || l.isEmpty()) {\n            throw new IllegalArgumentException(\"List cannot be null or empty\");\n        }\n        \n        return l.stream().max(Integer::compare).get();\n    }\n\n    // Test cases to verify the correctness of the function\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        List<Integer> list1 = Arrays.asList(1, 2, 3);\n        System.out.println(\"Max element in \" + list1 + \": \" + solution.max_element(list1)); // Expected: 3\n\n        // Test case 2\n        List<Integer> list2 = Arrays.asList(5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10);\n        System.out.println(\"Max element in \" + list2 + \": \" + solution.max_element(list2)); // Expected: 123\n\n        // Test case 3\n        List<Integer> list3 = Arrays.asList(-1, -2, -3, -4);\n        System.out.println(\"Max element in \" + list3 + \": \" + solution.max_element(list3)); // Expected: -1\n\n        // Test case 4\n        List<Integer> list4 = Arrays.asList(0);\n        System.out.println(\"Max element in \" + list4 + \": \" + solution.max_element(list4)); // Expected: 0\n\n        // Test case 5 (edge case)\n        List<Integer> list5 = Arrays.asList();\n        try {\n            System.out.println(\"Max element in empty list: \" + solution.max_element(list5));\n        } catch (IllegalArgumentException e) {\n            System.out.println(e.getMessage()); // Expected: List cannot be null or empty\n        }\n    }\n}\n"}
{"task_id": "Java/36", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n\n    /**\n     * Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n     */\n    public int fizz_buzz(int n) {\n        int count = 0;\n        for (int i = 1; i < n; i++) {\n            if (i % 11 == 0 || i % 13 == 0) {\n                String numStr = Integer.toString(i);\n                for (char c : numStr.toCharArray()) {\n                    if (c == '7') {\n                        count++;\n                    }\n                }\n            }\n        }\n        return count;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(\"fizz_buzz(50): \" + solution.fizz_buzz(50)); // Expected: 0\n        System.out.println(\"fizz_buzz(78): \" + solution.fizz_buzz(78)); // Expected: 2\n        System.out.println(\"fizz_buzz(79): \" + solution.fizz_buzz(79)); // Expected: 3\n        System.out.println(\"fizz_buzz(100): \" + solution.fizz_buzz(100)); // Expected: 4 (77, 781, 782, 783)\n        System.out.println(\"fizz_buzz(150): \" + solution.fizz_buzz(150)); // Expected: 6\n    }\n}\n"}
{"task_id": "Java/37", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * This function takes a list l and returns a list l' such that\n     * l' is identical to l in the odd indicies, while its values at the even indicies are equal\n     * to the values of the even indicies of l, but sorted.\n     */\n    public List<Integer> sort_even(List<Integer> l) {\n        List<Integer> result = new ArrayList<>(l);\n        List<Integer> evenIndicesValues = new ArrayList<>();\n        \n        // Extract values at even indices\n        for (int i = 0; i < result.size(); i += 2) {\n            evenIndicesValues.add(result.get(i));\n        }\n        \n        // Sort the extracted values\n        Collections.sort(evenIndicesValues);\n        \n        // Place sorted values back into their original positions\n        int evenIndex = 0;\n        for (int i = 0; i < result.size(); i += 2) {\n            result.set(i, evenIndicesValues.get(evenIndex++));\n        }\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.sort_even(Arrays.asList(1, 2, 3))); // Expected: [1, 2, 3]\n        System.out.println(solution.sort_even(Arrays.asList(5, 6, 3, 4))); // Expected: [3, 6, 5, 4]\n        System.out.println(solution.sort_even(Arrays.asList(9, 8, 7, 6, 5, 4, 3, 2, 1))); // Expected: [3, 8, 7, 6, 5, 4, 9, 2, 1]\n        System.out.println(solution.sort_even(Arrays.asList())); // Expected: []\n    }\n}\n"}
{"task_id": "Java/38", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * returns encoded string by cycling groups of three characters.\n     */\n    public String encodeCyclic(String s) {\n        // split string into groups. Each group has a length of 3.\n        List<String> groups = new ArrayList<>();\n        for (int i = 0; i < s.length(); i += 3) {\n            groups.add(s.substring(i, Math.min(i + 3, s.length())));\n        }\n        \n        // cycle elements in each group. Unless the group has fewer than 3 characters.\n        for (int i = 0; i < groups.size(); i++) {\n            if (groups.get(i).length() == 3) {\n                groups.set(i, groups.get(i).substring(1) + groups.get(i).charAt(0));\n            }\n        }\n        \n        return String.join(\"\", groups);\n    }\n\n    /**\n     * takes as input a string encoded with the encodeCyclic function. Returns decoded string.\n     */\n    public String decodeCyclic(String s) {\n        // split string into groups. Each group has a length of 3.\n        List<String> groups = new ArrayList<>();\n        for (int i = 0; i < s.length(); i += 3) {\n            groups.add(s.substring(i, Math.min(i + 3, s.length())));\n        }\n        \n        // reverse the cycling process in each group. Unless the group has fewer than 3 characters.\n        for (int i = 0; i < groups.size(); i++) {\n            if (groups.get(i).length() == 3) {\n                groups.set(i, groups.get(i).charAt(2) + groups.get(i).substring(0, 2));\n            }\n        }\n        \n        return String.join(\"\", groups);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.decodeCyclic(\"bcaefdhgi\"));\n    }\n}\n"}
{"task_id": "Java/39", "generation": "import java.util.*;\n\nclass Solution {\n    public int prime_fib(int n) {\n        return helper(n).get(n - 1);\n    }\n\n    private List<Integer> helper(int n) {\n        List<Integer> primes = new ArrayList<>();\n        int i = 0;\n        while (primes.size() < n) {\n            if (isPrime(fib(i))) {\n                primes.add(fib(i));\n            }\n            i++;\n        }\n        return primes;\n    }\n\n    private boolean isPrime(int num) {\n        if (num <= 1) return false;\n        for (int j = 2; j * j <= num; j++) {\n            if (num % j == 0) return false;\n        }\n        return true;\n    }\n\n    private int fib(int i) {\n        if (i == 0) return 0;\n        if (i == 1) return 1;\n        return fib(i - 1) + fib(i - 2);\n    }\n}\n"}
{"task_id": "Java/40", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * triples_sum_to_zero takes a list of integers as an input.\n     * it returns True if there are three distinct elements in the list that\n     * sum to zero, and False otherwise.\n     */\n    public boolean triples_sum_to_zero(List<Integer> l) {\n        // Sort the list to make it easier to find triplets that sum to zero\n        Collections.sort(l);\n        \n        for (int i = 0; i < l.size() - 2; i++) {\n            int left = i + 1;\n            int right = l.size() - 1;\n            \n            while (left < right) {\n                int sum = l.get(i) + l.get(left) + l.get(right);\n                \n                if (sum == 0) {\n                    return true;\n                } else if (sum < 0) {\n                    left++;\n                } else {\n                    right--;\n                }\n            }\n        }\n        \n        return false;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.triples_sum_to_zero(Arrays.asList(1, 3, 5, 0))); // false\n        System.out.println(solution.triples_sum_to_zero(Arrays.asList(1, 3, -2, 1))); // true\n        System.out.println(solution.triples_sum_to_zero(Arrays.asList(1, 2, 3, 7))); // false\n        System.out.println(solution.triples_sum_to_zero(Arrays.asList(2, 4, -5, 3, 9, 7))); // true\n        System.out.println(solution.triples_sum_to_zero(Arrays.asList(1))); // false\n    }\n}\n"}
{"task_id": "Java/41", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Imagine a road that's a perfectly straight infinitely long line.\n    n cars are driving left to right; simultaneously, a different set of n cars\n    are driving right to left. The two sets of cars start out being very far from each other.\n    All cars move at the same speed. Two cars are said to collide when a car that's moving left to right hits a car that's moving right to left.\n    However, the cars are infinitely sturdy and strong; as a result, they continue moving in their trajectory as if they did not collide.\n\n    This function outputs the number of such collisions.\n     */\n    public int car_race_collision(int n) {\n        // Since all cars are moving at the same speed and start far apart,\n        // each car from one direction will collide with exactly one car from the opposite direction.\n        return n;\n    }\n}\n"}
{"task_id": "Java/42", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return list with elements incremented by 1.\n     *\n     * @param l The input list of integers.\n     * @return A new list where each element is incremented by 1.\n     */\n    public List<Integer> incr_list(List<Integer> l) {\n        return l.stream().map(i -> i + 1).collect(Collectors.toList());\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        List<Integer> list1 = Arrays.asList(1, 2, 3);\n        System.out.println(\"Original: \" + list1);\n        System.out.println(\"Incremented: \" + solution.incr_list(list1));\n\n        // Test case 2\n        List<Integer> list2 = Arrays.asList(5, 3, 5, 2, 3, 3, 9, 0, 123);\n        System.out.println(\"Original: \" + list2);\n        System.out.println(\"Incremented: \" + solution.incr_list(list2));\n    }\n}\n"}
{"task_id": "Java/43", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * pairs_sum_to_zero takes a list of integers as an input.\n     * it returns True if there are two distinct elements in the list that\n     * sum to zero, and False otherwise.\n     */\n    public boolean pairs_sum_to_zero(List<Integer> l) {\n        Set<Integer> seen = new HashSet<>();\n        for (int num : l) {\n            if (seen.contains(-num)) {\n                return true;\n            }\n            seen.add(num);\n        }\n        return false;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.pairs_sum_to_zero(Arrays.asList(1, 3, 5, 0))); // false\n        System.out.println(solution.pairs_sum_to_zero(Arrays.asList(1, 3, -2, 1))); // false\n        System.out.println(solution.pairs_sum_to_zero(Arrays.asList(1, 2, 3, 7))); // false\n        System.out.println(solution.pairs_sum_to_zero(Arrays.asList(2, 4, -5, 3, 5, 7))); // true\n        System.out.println(solution.pairs_sum_to_zero(Arrays.asList(1))); // false\n    }\n}\n"}
{"task_id": "Java/44", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Change numerical base of input number x to base.\n     * return string representation after the conversion.\n     * base numbers are less than 10.\n     *\n     * @param x The number to be converted.\n     * @param base The target base for conversion (less than 10).\n     * @return String representation of the converted number.\n     */\n    public String change_base(int x, int base) {\n        if (x == 0) return \"0\";\n        \n        StringBuilder result = new StringBuilder();\n        while (x > 0) {\n            int remainder = x % base;\n            result.insert(0, remainder);\n            x /= base;\n        }\n        \n        return result.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.change_base(8, 3));  // Expected output: \"22\"\n        System.out.println(solution.change_base(8, 2));  // Expected output: \"1000\"\n        System.out.println(solution.change_base(7, 2));  // Expected output: \"111\"\n        System.out.println(solution.change_base(255, 16)); // Expected output: \"FF\" (for base 16)\n        System.out.println(solution.change_base(10, 8));  // Expected output: \"12\"\n    }\n}\n"}
{"task_id": "Java/45", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given length of a side (base) and height, return area for a triangle.\n     *\n     * @param a The base of the triangle.\n     * @param h The height of the triangle.\n     * @return The area of the triangle.\n     */\n    public double triangle_area(double a, double h) {\n        return 0.5 * a * h;\n    }\n\n    /**\n     * Main method to run test cases for the triangle_area function.\n     *\n     * @param args Command line arguments (not used).\n     */\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(\"Test Case 1: Base = 5, Height = 3\");\n        double result1 = solution.triangle_area(5, 3);\n        System.out.println(\"Expected: 7.5, Actual: \" + result1);\n\n        System.out.println(\"\\nTest Case 2: Base = 10, Height = 4\");\n        double result2 = solution.triangle_area(10, 4);\n        System.out.println(\"Expected: 20.0, Actual: \" + result2);\n\n        System.out.println(\"\\nTest Case 3: Base = 7, Height = 8\");\n        double result3 = solution.triangle_area(7, 8);\n        System.out.println(\"Expected: 28.0, Actual: \" + result3);\n\n        // Add more test cases as needed\n    }\n}\n"}
{"task_id": "Java/46", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n    The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n    fib4(0) -> 0\n    fib4(1) -> 0\n    fib4(2) -> 2\n    fib4(3) -> 0\n    fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n    Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.\n    >>> fib4(5)\n    4\n    >>> fib4(6)\n    8\n    >>> fib4(7)\n    14\n     */\n    public int fib4(int n) {\n        if (n == 0 || n == 1) return 0;\n        if (n == 2) return 2;\n        if (n == 3) return 0;\n\n        int[] dp = new int[n + 1];\n        dp[0] = 0;\n        dp[1] = 0;\n        dp[2] = 2;\n        dp[3] = 0;\n\n        for (int i = 4; i <= n; i++) {\n            dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3] + dp[i - 4];\n        }\n\n        return dp[n];\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.fib4(5)); // Expected output: 4\n        System.out.println(solution.fib4(6)); // Expected output: 8\n        System.out.println(solution.fib4(7)); // Expected output: 14\n        System.out.println(solution.fib4(8)); // Expected output: 24\n        System.out.println(solution.fib4(9)); // Expected output: 44\n    }\n}\n"}
{"task_id": "Java/47", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return median of elements in the list l.\n     */\n    public double median(List<Integer> l) {\n        if (l == null || l.isEmpty()) {\n            throw new IllegalArgumentException(\"List cannot be null or empty\");\n        }\n\n        Collections.sort(l);\n        int size = l.size();\n        if (size % 2 == 0) {\n            return (l.get(size / 2 - 1) + l.get(size / 2)) / 2.0;\n        } else {\n            return l.get(size / 2);\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        List<Integer> testList1 = Arrays.asList(3, 1, 2, 4, 5);\n        System.out.println(\"Median of [3, 1, 2, 4, 5]: \" + solution.median(testList1)); // Expected: 3\n\n        List<Integer> testList2 = Arrays.asList(-10, 4, 6, 1000, 10, 20);\n        System.out.println(\"Median of [-10, 4, 6, 1000, 10, 20]: \" + solution.median(testList2)); // Expected: 8.0\n\n        List<Integer> testList3 = Arrays.asList(1, 2, 3, 4);\n        System.out.println(\"Median of [1, 2, 3, 4]: \" + solution.median(testList3)); // Expected: 2.5\n\n        List<Integer> testList4 = Arrays.asList(-5, -3, -1, 0, 2, 4, 6);\n        System.out.println(\"Median of [-5, -3, -1, 0, 2, 4, 6]: \" + solution.median(testList4)); // Expected: 0.0\n\n        List<Integer> testList5 = Arrays.asList();\n        try {\n            System.out.println(\"Median of []: \" + solution.median(testList5));\n        } catch (IllegalArgumentException e) {\n            System.out.println(\"Caught expected exception for empty list: \" + e.getMessage());\n        }\n\n        List<Integer> testList6 = null;\n        try {\n            System.out.println(\"Median of null: \" + solution.median(testList6));\n        } catch (IllegalArgumentException e) {\n            System.out.println(\"Caught expected exception for null list: \" + e.getMessage());\n        }\n    }\n}\n"}
{"task_id": "Java/48", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     Checks if given string is a palindrome\n     >>> is_palindrome(\"\")\n     true\n     >>> is_palindrome(\"aba\")\n     true\n     >>> is_palindrome(\"aaaaa\")\n     true\n     >>> is_palindrome(\"zbcd\")\n     false\n     */\n    public boolean is_palindrome(String text) {\n        int left = 0;\n        int right = text.length() - 1;\n\n        while (left < right) {\n            if (text.charAt(left) != text.charAt(right)) {\n                return false;\n            }\n            left++;\n            right--;\n        }\n\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.is_palindrome(\"\"));       // true\n        System.out.println(solution.is_palindrome(\"aba\"));    // true\n        System.out.println(solution.is_palindrome(\"aaaaa\"));  // true\n        System.out.println(solution.is_palindrome(\"zbcd\"));   // false\n        System.out.println(solution.is_palindrome(\"level\"));  // true\n        System.out.println(solution.is_palindrome(\"noon\"));   // true\n        System.out.println(solution.is_palindrome(\"abcde\"));  // false\n    }\n}\n"}
{"task_id": "Java/49", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return 2^n modulo p (be aware of numerics).\n     */\n    public int modp(int n, int p) {\n        if (n == 0) return 1; // Base case: 2^0 = 1\n        long result = 1;\n        for (int i = 0; i < n; i++) {\n            result = (result * 2) % p;\n        }\n        return (int) result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.modp(3, 5));   // Expected output: 3\n        System.out.println(solution.modp(1101, 101)); // Expected output: 2\n        System.out.println(solution.modp(0, 101));  // Expected output: 1\n        System.out.println(solution.modp(3, 11));   // Expected output: 8\n        System.out.println(solution.modp(100, 101)); // Expected output: 1\n    }\n}\n"}
{"task_id": "Java/50", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    returns encoded string by shifting every character by 5 in the alphabet.\n     */\n    public String encodeShift(String s) {\n        StringBuilder sb = new StringBuilder();\n        for (char ch : s.toCharArray()) {\n            // Shift character by 5 positions\n            char shiftedChar = (char) ('a' + ((ch - 'a' + 5) % 26));\n            sb.append(shiftedChar);\n        }\n        return sb.toString();\n    }\n\n    /**\n    takes as input string encoded with encodeShift function. Returns decoded string.\n     */\n    public String decode_shift(String s) {\n        StringBuilder sb = new StringBuilder();\n        for (char ch : s.toCharArray()) {\n            // Shift character back by 5 positions\n            char shiftedChar = (char) ('a' + ((ch - 'a' - 5 + 26) % 26));\n            sb.append(shiftedChar);\n        }\n        return sb.toString();\n    }\n}\n"}
{"task_id": "Java/51", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * remove_vowels is a function that takes string and returns string without vowels.\n     */\n    public String remove_vowels(String text) {\n        if (text == null || text.isEmpty()) {\n            return text;\n        }\n        \n        StringBuilder result = new StringBuilder();\n        for (char c : text.toCharArray()) {\n            if (!isVowel(c)) {\n                result.append(c);\n            }\n        }\n        return result.toString();\n    }\n\n    private boolean isVowel(char c) {\n        return \"AEIOUaeiou\".indexOf(c) != -1;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.remove_vowels(\"\")); // Output: \"\"\n        System.out.println(solution.remove_vowels(\"abcdef\\nghijklm\")); // Output: \"bcdf\\nghjklm\"\n        System.out.println(solution.remove_vowels(\"abcdef\")); // Output: \"bcdf\"\n        System.out.println(solution.remove_vowels(\"aaaaa\")); // Output: \"\"\n        System.out.println(solution.remove_vowels(\"aaBAA\")); // Output: \"B\"\n        System.out.println(solution.remove_vowels(\"zbcd\")); // Output: \"zbcd\"\n    }\n}\n"}
{"task_id": "Java/52", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return True if all numbers in the list l are below threshold t.\n     */\n    public boolean below_threshold(List<Integer> l, int t) {\n        for (int num : l) {\n            if (num >= t) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.below_threshold(Arrays.asList(1, 2, 4, 10), 100)); // Expected: true\n        System.out.println(solution.below_threshold(Arrays.asList(1, 20, 4, 10), 5));  // Expected: false\n        System.out.println(solution.below_threshold(Arrays.asList(-1, -2, -3), 0));    // Expected: true\n        System.out.println(solution.below_threshold(Arrays.asList(), 100));            // Expected: true (empty list)\n        System.out.println(solution.below_threshold(Arrays.asList(99, 100, 101), 100)); // Expected: false\n    }\n}\n"}
{"task_id": "Java/53", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Add two numbers x and y\n     *\n     * @param x the first number\n     * @param y the second number\n     * @return the sum of x and y\n     */\n    public int add(int x, int y) {\n        return x + y;\n    }\n}\n"}
{"task_id": "Java/54", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Check if two words have the same kind of characters.\n     */\n    public boolean same_chars(String s0, String s1) {\n        // Convert both strings to sets of characters\n        Set<Character> set0 = new HashSet<>();\n        for (char c : s0.toCharArray()) {\n            set0.add(c);\n        }\n        \n        Set<Character> set1 = new HashSet<>();\n        for (char c : s1.toCharArray()) {\n            set1.add(c);\n        }\n        \n        // Compare the sets\n        return set0.equals(set1);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.same_chars(\"eabcdzzzz\", \"dddzzzzzzzddeddabc\")); // true\n        System.out.println(solution.same_chars(\"abcd\", \"dddddddabc\"));              // true\n        System.out.println(solution.same_chars(\"dddddddabc\", \"abcd\"));              // true\n        System.out.println(solution.same_chars(\"eabcd\", \"dddddddabc\"));             // false\n        System.out.println(solution.same_chars(\"abcd\", \"dddddddabce\"));             // false\n        System.out.println(solution.same_chars(\"eabcdzzzz\", \"dddzzzzzzzddddabc\"));  // false\n    }\n}\n"}
{"task_id": "Java/55", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return n-th Fibonacci number.\n     * >>> fib(10)\n     * 55\n     * >>> fib(1)\n     * 1\n     * >>> fib(8)\n     * 21\n     */\n    public int fib(int n) {\n        if (n <= 0) {\n            return 0;\n        } else if (n == 1) {\n            return 1;\n        }\n        \n        int a = 0, b = 1, c = 0;\n        for (int i = 2; i <= n; i++) {\n            c = a + b;\n            a = b;\n            b = c;\n        }\n        return b;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(\"fib(10): \" + solution.fib(10)); // Expected: 55\n        System.out.println(\"fib(1): \" + solution.fib(1));   // Expected: 1\n        System.out.println(\"fib(8): \" + solution.fib(8));   // Expected: 21\n        System.out.println(\"fib(0): \" + solution.fib(0));   // Expected: 0\n        System.out.println(\"fib(-5): \" + solution.fib(-5)); // Expected: 0 (or handle as an error)\n    }\n}\n"}
{"task_id": "Java/56", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * brackets is a string of \"<\" and \">\".\n     * return True if every opening bracket has a corresponding closing bracket.\n     *\n     * >>> correct_bracketing(\"<\")\n     * false\n     * >>> correct_bracketing(\"<>\")\n     * true\n     * >>> correct_bracketing(\"<<><>>\")\n     * true\n     * >>> correct_bracketing(\"><<>\")\n     * false\n     */\n    public boolean correct_bracketing(String brackets) {\n        int balance = 0;\n        for (char c : brackets.toCharArray()) {\n            if (c == '<') {\n                balance++;\n            } else if (c == '>') {\n                balance--;\n            }\n            // If at any point the balance is negative, it means there's a closing bracket without an opening one\n            if (balance < 0) {\n                return false;\n            }\n        }\n        // If the balance is zero, all brackets are correctly matched\n        return balance == 0;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.correct_bracketing(\"<\"));      // false\n        System.out.println(solution.correct_bracketing(\"<>\"));     // true\n        System.out.println(solution.correct_bracketing(\"<<><>>\")); // true\n        System.out.println(solution.correct_bracketing(\"><<>\"));   // false\n    }\n}\n"}
{"task_id": "Java/57", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public boolean monotonic(List<Integer> l) {\n        boolean increasing = true;\n        boolean decreasing = true;\n\n        for (int i = 1; i < l.size(); i++) {\n            if (!increasing && !decreasing) {\n                break;\n            }\n            if (l.get(i) < l.get(i - 1)) {\n                increasing = false;\n            }\n            if (l.get(i) > l.get(i - 1)) {\n                decreasing = false;\n            }\n        }\n\n        return increasing || decreasing;\n    }\n}\n"}
{"task_id": "Java/58", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return sorted unique common elements for two lists.\n     */\n    public List<Integer> common(List<Integer> l1, List<Integer> l2) {\n        Set<Integer> set1 = new HashSet<>(l1);\n        Set<Integer> set2 = new HashSet<>(l2);\n\n        // Retain only the elements that are present in both sets\n        set1.retainAll(set2);\n\n        // Convert the resulting set to a sorted list\n        List<Integer> result = new ArrayList<>(set1);\n        Collections.sort(result);\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        List<Integer> l1 = Arrays.asList(1, 4, 3, 34, 653, 2, 5);\n        List<Integer> l2 = Arrays.asList(5, 7, 1, 5, 9, 653, 121);\n        System.out.println(\"Common elements (Test case 1): \" + solution.common(l1, l2)); // Expected: [1, 5, 653]\n\n        // Test case 2\n        List<Integer> l3 = Arrays.asList(5, 3, 2, 8);\n        List<Integer> l4 = Arrays.asList(3, 2);\n        System.out.println(\"Common elements (Test case 2): \" + solution.common(l3, l4)); // Expected: [2, 3]\n\n        // Test case 3\n        List<Integer> l5 = Arrays.asList(10, 20, 30, 40);\n        List<Integer> l6 = Arrays.asList(50, 60, 70);\n        System.out.println(\"Common elements (Test case 3): \" + solution.common(l5, l6)); // Expected: []\n\n        // Test case 4\n        List<Integer> l7 = Arrays.asList(1, 2, 3, 4, 5);\n        List<Integer> l8 = Arrays.asList(3, 4, 5, 6, 7);\n        System.out.println(\"Common elements (Test case 4): \" + solution.common(l7, l8)); // Expected: [3, 4, 5]\n    }\n}\n"}
{"task_id": "Java/59", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return the largest prime factor of n. Assume n > 1 and is not a prime.\n     * \n     * @param n The input number to find the largest prime factor for.\n     * @return The largest prime factor of n.\n     */\n    public int largest_prime_factor(int n) {\n        boolean isPrime;\n        \n        // Declare largest_factor as an instance variable\n        int largest_factor = 1;\n\n        // Helper function to check if a number is prime\n        int factor = 2;\n        while (factor * factor <= n) {\n            isPrime = true;\n            for (int i = 2; i <= Math.sqrt(factor); i++) {\n                if (factor % i == 0) {\n                    isPrime = false;\n                    break;\n                }\n            }\n            \n            // Check if the current factor divides n and is prime\n            while (n % factor == 0 && isPrime) {\n                n /= factor;\n                largest_factor = factor; // Update largest_factor here\n            }\n            \n            factor++;\n        }\n        \n        // If n is greater than 1, then it is a prime number itself\n        if (n > 1) {\n            largest_factor = n; // Update largest_factor here\n        }\n        \n        return largest_factor;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.largest_prime_factor(13195)); // Output: 29\n        System.out.println(solution.largest_prime_factor(2048));  // Output: 2\n    }\n}\n"}
{"task_id": "Java/60", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * sum_to_n is a function that sums numbers from 1 to n.\n     */\n    public int sum_to_n(int n) {\n        return (n * (n + 1)) / 2;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(\"sum_to_n(30): \" + solution.sum_to_n(30)); // Expected: 465\n        System.out.println(\"sum_to_n(100): \" + solution.sum_to_n(100)); // Expected: 5050\n        System.out.println(\"sum_to_n(5): \" + solution.sum_to_n(5)); // Expected: 15\n        System.out.println(\"sum_to_n(10): \" + solution.sum_to_n(10)); // Expected: 55\n        System.out.println(\"sum_to_n(1): \" + solution.sum_to_n(1)); // Expected: 1\n    }\n}\n"}
{"task_id": "Java/61", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * brackets is a string of \"(\" and \")\".\n     * return True if every opening bracket has a corresponding closing bracket.\n     *\n     * >>> correct_bracketing(\"(\")\n     * false\n     * >>> correct_bracketing(\"()\")\n     * true\n     * >>> correct_bracketing(\"(()())\")\n     * true\n     * >>> correct_bracketing(\")(()\")\n     * false\n     */\n    public boolean correct_bracketing(String brackets) {\n        Stack<Character> stack = new Stack<>();\n        \n        for (char c : brackets.toCharArray()) {\n            if (c == '(') {\n                stack.push(c);\n            } else if (c == ')') {\n                if (stack.isEmpty()) {\n                    return false;\n                }\n                stack.pop();\n            }\n        }\n        \n        return stack.isEmpty();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.correct_bracketing(\"(\"));       // Output: false\n        System.out.println(solution.correct_bracketing(\"()\"));      // Output: true\n        System.out.println(solution.correct_bracketing(\"(()())\"));  // Output: true\n        System.out.println(solution.correct_bracketing(\")(()\"));    // Output: false\n        System.out.println(solution.correct_bracketing(\"(())\"));    // Output: true\n        System.out.println(solution.correct_bracketing(\"()()\"));    // Output: true\n        System.out.println(solution.correct_bracketing(\"(()\"));     // Output: false\n        System.out.println(solution.correct_bracketing(\")(\"));      // Output: false\n    }\n}\n"}
{"task_id": "Java/62", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * xs represent coefficients of a polynomial.\n     * xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     * Return derivative of this polynomial in the same form.\n     */\n    public List<Integer> derivative(List<Integer> xs) {\n        if (xs == null || xs.isEmpty()) {\n            return Collections.emptyList();\n        }\n        \n        List<Integer> result = new ArrayList<>();\n        for (int i = 1; i < xs.size(); i++) {\n            result.add(xs.get(i) * i);\n        }\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(\"Derivative of [3, 1, 2, 4, 5]: \" + solution.derivative(Arrays.asList(3, 1, 2, 4, 5)));\n        System.out.println(\"Derivative of [1, 2, 3]: \" + solution.derivative(Arrays.asList(1, 2, 3)));\n\n        // Additional test cases\n        System.out.println(\"Derivative of [0, 1, 2, 3]: \" + solution.derivative(Arrays.asList(0, 1, 2, 3)));\n        System.out.println(\"Derivative of [5]: \" + solution.derivative(Arrays.asList(5)));\n        System.out.println(\"Derivative of []: \" + solution.derivative(new ArrayList<>()));\n    }\n}\n"}
{"task_id": "Java/63", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     The FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n     fibfib(0) == 0\n     fibfib(1) == 0\n     fibfib(2) == 1\n     fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n     Please write a function to efficiently compute the n-th element of the fibfib number sequence.\n     >>> fibfib(1)\n     0\n     >>> fibfib(5)\n     4\n     >>> fibfib(8)\n     24\n      */\n    public int fibfib(int n) {\n        if (n == 0 || n == 1) return 0;\n        if (n == 2) return 1;\n\n        int a = 0, b = 0, c = 1;\n        for (int i = 3; i <= n; i++) {\n            int temp = a + b + c;\n            a = b;\n            b = c;\n            c = temp;\n        }\n        return c;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.fibfib(1));  // Expected output: 0\n        System.out.println(solution.fibfib(5));  // Expected output: 4\n        System.out.println(solution.fibfib(8));  // Expected output: 24\n        System.out.println(solution.fibfib(10)); // Expected output: 76\n    }\n}\n"}
{"task_id": "Java/64", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Write a function vowels_count which takes a string representing\n     * a word as input and returns the number of vowels in the string.\n     * Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n     * vowel, but only when it is at the end of the given word.\n     *\n     * Example:\n     * >>> vowels_count(\"abcde\")\n     * 2\n     * >>> vowels_count(\"ACEDY\")\n     * 3\n     */\n    public int vowels_count(String s) {\n        int count = 0;\n        for (int i = 0; i < s.length(); i++) {\n            char c = Character.toLowerCase(s.charAt(i));\n            if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n                count++;\n            } else if (c == 'y' && i == s.length() - 1) {\n                count++;\n            }\n        }\n        return count;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.vowels_count(\"abcde\")); // Expected output: 2\n        System.out.println(solution.vowels_count(\"ACEDY\")); // Expected output: 3\n        System.out.println(solution.vowels_count(\"rhythm\")); // Expected output: 0\n        System.out.println(solution.vowels_count(\"encyclopedia\")); // Expected output: 6\n        System.out.println(solution.vowels_count(\"quickly\")); // Expected output: 1\n    }\n}\n"}
{"task_id": "Java/65", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n     */\n    public String circular_shift(int x, int shift) {\n        // Convert the integer to a string\n        String numStr = Integer.toString(x);\n        int numLength = numStr.length();\n\n        // If shift is greater than or equal to the number of digits, reverse the string\n        if (shift >= numLength) {\n            return new StringBuilder(numStr).reverse().toString();\n        }\n\n        // Perform circular right shift by slicing and concatenating\n        String shiftedStr = numStr.substring(numLength - shift) + numStr.substring(0, numLength - shift);\n        return shiftedStr;\n    }\n}\n"}
{"task_id": "Java/66", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Write a function that takes a string as input and returns the sum of the upper characters only ASCII codes.\n     *\n     * Examples:\n     * digitSum(\"\") => 0\n     * digitSum(\"abAB\") => 131\n     * digitSum(\"abcCd\") => 67\n     * digitSum(\"helloE\") => 69\n     * digitSum(\"woArBld\") => 131\n     * digitSum(\"aAaaaXa\") => 153\n     */\n    public int digitSum(String s) {\n        int sum = 0;\n        for (char c : s.toCharArray()) {\n            if (Character.isUpperCase(c)) {\n                sum += c;\n            }\n        }\n        return sum;\n    }\n\n    // Test cases to verify the correctness of the method\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.digitSum(\"\")); // Expected output: 0\n        System.out.println(solution.digitSum(\"abAB\")); // Expected output: 131 ('A' + 'B')\n        System.out.println(solution.digitSum(\"abcCd\")); // Expected output: 67 ('C' + 'D')\n        System.out.println(solution.digitSum(\"helloE\")); // Expected output: 69 ('E')\n        System.out.println(solution.digitSum(\"woArBld\")); // Expected output: 131 ('A' + 'B' + 'L' + 'D')\n        System.out.println(solution.digitSum(\"aAaaaXa\")); // Expected output: 153 ('A' * 4 + 'X')\n    }\n}\n"}
{"task_id": "Java/67", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * In this task, you will be given a string that represents a number of apples and oranges\n     * that are distributed in a basket of fruit. The basket contains apples, oranges, and mango fruits.\n     * Given the string that represents the total number of the oranges and apples and an integer that represent the total number of the fruits\n     * in the basket return the number of the mango fruits in the basket.\n     *\n     * @param s a string representing the number of apples and oranges (e.g., \"5 apples and 6 oranges\")\n     * @param n the total number of fruits in the basket\n     * @return the number of mango fruits in the basket\n     */\n    public int fruit_distribution(String s, int n) {\n        // Extract the numbers from the string\n        String[] parts = s.split(\" \");\n        int apples = Integer.parseInt(parts[0]);\n        int oranges = Integer.parseInt(parts[3]);\n\n        // Calculate the number of mangoes\n        return n - (apples + oranges);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.fruit_distribution(\"5 apples and 6 oranges\", 19)); // Expected output: 8\n        System.out.println(solution.fruit_distribution(\"0 apples and 1 oranges\", 3));   // Expected output: 2\n        System.out.println(solution.fruit_distribution(\"2 apples and 3 oranges\", 100)); // Expected output: 95\n        System.out.println(solution.fruit_distribution(\"100 apples and 1 oranges\", 120)); // Expected output: 19\n    }\n}\n"}
{"task_id": "Java/68", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given an array representing a branch of a tree that has non-negative integer nodes,\n     * your task is to pluck one of the nodes and return it.\n     * The plucked node should be the node with the smallest even value.\n     * If multiple nodes with the same smallest even value are found, return the node that has the smallest index.\n     *\n     * @param arr the list of integer values representing tree branch nodes\n     * @return a list containing the smallest even value and its index, or an empty list if no valid node is found\n     */\n    public List<Integer> pluck(List<Integer> arr) {\n        int minEvenValue = Integer.MAX_VALUE;\n        int minIndex = -1;\n\n        for (int i = 0; i < arr.size(); i++) {\n            int value = arr.get(i);\n            if (value % 2 == 0 && value <= minEvenValue) {\n                if (value < minEvenValue || (value == minEvenValue && i < minIndex)) {\n                    minEvenValue = value;\n                    minIndex = i;\n                }\n            }\n        }\n\n        if (minIndex == -1) {\n            return new ArrayList<>();\n        } else {\n            return Arrays.asList(minEvenValue, minIndex);\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.pluck(Arrays.asList(4, 2, 3))); // Output: [2, 1]\n        System.out.println(solution.pluck(Arrays.asList(1, 2, 3))); // Output: [2, 1]\n        System.out.println(solution.pluck(Arrays.asList()));       // Output: []\n        System.out.println(solution.pluck(Arrays.asList(5, 0, 3, 0, 4, 2))); // Output: [0, 1]\n    }\n}\n"}
{"task_id": "Java/69", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * You are given a non-empty list of positive integers. Return the greatest integer that is greater than\n     * zero, and has a frequency greater than or equal to the value of the integer itself.\n     * The frequency of an integer is the number of times it appears in the list.\n     * If no such a value exist, return -1.\n     *\n     * Examples:\n     * search(Arrays.asList(4, 1, 2, 2, 3, 1)) == 2\n     * search(Arrays.asList(1, 2, 2, 3, 3, 3, 4, 4, 4)) == 3\n     * search(Arrays.asList(5, 5, 4, 4, 4)) == -1\n     */\n    public int search(List<Integer> lst) {\n        Map<Integer, Integer> frequencyMap = new HashMap<>();\n        \n        // Count the frequency of each integer in the list\n        for (int num : lst) {\n            frequencyMap.put(num, frequencyMap.getOrDefault(num, 0) + 1);\n        }\n        \n        int result = -1;\n        \n        // Check which integers meet the criteria and find the greatest one\n        for (Map.Entry<Integer, Integer> entry : frequencyMap.entrySet()) {\n            if (entry.getKey() <= entry.getValue()) {\n                result = Math.max(result, entry.getKey());\n            }\n        }\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.search(Arrays.asList(4, 1, 2, 2, 3, 1))); // Expected output: 2\n        System.out.println(solution.search(Arrays.asList(1, 2, 2, 3, 3, 3, 4, 4, 4))); // Expected output: 3\n        System.out.println(solution.search(Arrays.asList(5, 5, 4, 4, 4))); // Expected output: -1\n        System.out.println(solution.search(Arrays.asList(6, 6, 6, 7, 7, 8, 8, 8, 8))); // Expected output: 8\n    }\n}\n"}
{"task_id": "Java/70", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given list of integers, return list in strange order.\n     * Strange sorting, is when you start with the minimum value,\n     * then maximum of the remaining integers, then minimum and so on.\n     *\n     * Examples:\n     * strange_sort_list(Arrays.asList(1, 2, 3, 4)) == Arrays.asList(1, 4, 2, 3)\n     * strange_sort_list(Arrays.asList(5, 5, 5, 5)) == Arrays.asList(5, 5, 5, 5)\n     * strange_sort_list(Arrays.asList()) == Arrays.asList()\n     */\n    public List<Integer> strange_sort_list(List<Integer> lst) {\n        List<Integer> result = new ArrayList<>();\n        while (!lst.isEmpty()) {\n            // Add the minimum value\n            int minVal = Collections.min(lst);\n            result.add(minVal);\n            lst.remove(Integer.valueOf(minVal));\n            \n            if (lst.isEmpty()) break;\n            \n            // Add the maximum value\n            int maxVal = Collections.max(lst);\n            result.add(maxVal);\n            lst.remove(Integer.valueOf(maxVal));\n        }\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.strange_sort_list(Arrays.asList(1, 2, 3, 4))); // Expected: [1, 4, 2, 3]\n        System.out.println(solution.strange_sort_list(Arrays.asList(5, 5, 5, 5))); // Expected: [5, 5, 5, 5]\n        System.out.println(solution.strange_sort_list(Arrays.asList()));           // Expected: []\n        System.out.println(solution.strange_sort_list(Arrays.asList(10, 20, 30, 40, 50))); // Expected: [10, 50, 20, 40, 30]\n    }\n}\n"}
{"task_id": "Java/71", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n\n    /**\n     * Given the lengths of the three sides of a triangle. Return the area of\n     * the triangle rounded to 2 decimal points if the three sides form a valid triangle.\n     * Otherwise return -1.\n     * Three sides make a valid triangle when the sum of any two sides is greater\n     * than the third side.\n     * Example:\n     * triangle_area(3, 4, 5) == 6.00\n     * triangle_area(1, 2, 10) == -1\n     */\n    public double triangle_area(double a, double b, double c) {\n        // Check if the sides form a valid triangle\n        if (a + b <= c || a + c <= b || b + c <= a) {\n            return -1;\n        }\n        \n        // Calculate the semi-perimeter\n        double s = (a + b + c) / 2.0;\n\n        // Calculate the area using Heron's formula\n        double area = Math.sqrt(s * (s - a) * (s - b) * (s - c));\n        \n        // Round to 2 decimal points\n        return Math.round(area * 100.0) / 100.0;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.triangle_area(3, 4, 5)); // Expected output: 6.00\n        System.out.println(solution.triangle_area(1, 2, 10)); // Expected output: -1\n        System.out.println(solution.triangle_area(7, 8, 9)); // Expected output: ~26.83\n        System.out.println(solution.triangle_area(5, 5, 5)); // Expected output: 10.83\n    }\n}\n"}
{"task_id": "Java/72", "generation": "import java.util.*;\n\nclass Solution {\n\n    /**\n     * Write a function that returns True if the object q will fly, and False otherwise.\n     * The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal to the maximum possible weight w.\n     *\n     * @param q A List<Integer> representing the object\n     * @param w An integer representing the maximum possible weight\n     * @return boolean indicating if the object will fly\n     */\n    public boolean will_it_fly(List<Integer> q, int w) {\n        // Check if the list is a palindrome\n        for (int i = 0; i < q.size() / 2; i++) {\n            if (!q.get(i).equals(q.get(q.size() - 1 - i))) {\n                return false;\n            }\n        }\n\n        // Calculate the sum of elements in the list\n        int sum = q.stream().mapToInt(Integer::intValue).sum();\n\n        // Check if the sum is less than or equal to w\n        return sum <= w;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.will_it_fly(Arrays.asList(1, 2), 5));   // false\n        System.out.println(solution.will_it_fly(Arrays.asList(3, 2, 3), 1)); // false\n        System.out.println(solution.will_it_fly(Arrays.asList(3, 2, 3), 9)); // true\n        System.out.println(solution.will_it_fly(Arrays.asList(3), 5));      // true\n    }\n}\n"}
{"task_id": "Java/73", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given an array arr of integers, find the minimum number of elements that\n     * need to be changed to make the array palindromic. A palindromic array is an array that\n     * is read the same backwards and forwards. In one change, you can change one element to any other element.\n     *\n     * For example:\n     * smallest_change(Arrays.asList(1,2,3,5,4,7,9,6)) == 4\n     * smallest_change(Arrays.asList(1, 2, 3, 4, 3, 2, 2)) == 1\n     * smallest_change(Arrays.asList(1, 2, 3, 2, 1)) == 0\n     */\n    public int smallest_change(List<Integer> arr) {\n        int left = 0;\n        int right = arr.size() - 1;\n        int changes = 0;\n\n        while (left < right) {\n            if (!arr.get(left).equals(arr.get(right))) {\n                changes++;\n            }\n            left++;\n            right--;\n        }\n\n        return changes;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.smallest_change(Arrays.asList(1, 2, 3, 5, 4, 7, 9, 6))); // Output: 4\n        System.out.println(solution.smallest_change(Arrays.asList(1, 2, 3, 4, 3, 2, 2)));    // Output: 1\n        System.out.println(solution.smallest_change(Arrays.asList(1, 2, 3, 2, 1)));          // Output: 0\n        System.out.println(solution.smallest_change(Arrays.asList(1, 2, 3, 4, 5, 6, 7)));    // Output: 3\n        System.out.println(solution.smallest_change(Arrays.asList(8, 9, 8, 9, 8, 9, 8)));   // Output: 0\n    }\n}\n"}
{"task_id": "Java/74", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Write a function that accepts two lists of strings and returns the list that has\n     * total number of chars in the all strings of the list less than the other list.\n     *\n     * if the two lists have the same number of chars, return the first list.\n     */\n    public List<String> total_match(List<String> lst1, List<String> lst2) {\n        int count1 = 0;\n        for (String s : lst1) {\n            count1 += s.length();\n        }\n        \n        int count2 = 0;\n        for (String s : lst2) {\n            count2 += s.length();\n        }\n\n        if (count1 <= count2) {\n            return lst1;\n        } else {\n            return lst2;\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.total_match(new ArrayList<>(), new ArrayList<>())); // []\n        System.out.println(solution.total_match(Arrays.asList(\"hi\", \"admin\"), Arrays.asList(\"hI\", \"Hi\"))); // [\"hI\", \"Hi\"]\n        System.out.println(solution.total_match(Arrays.asList(\"hi\", \"admin\"), Arrays.asList(\"hi\", \"hi\", \"admin\", \"project\"))); // [\"hi\", \"admin\"]\n        System.out.println(solution.total_match(Arrays.asList(\"hi\", \"admin\"), Arrays.asList(\"hI\", \"hi\", \"hi\"))); // [\"hI\", \"hi\", \"hi\"]\n        System.out.println(solution.total_match(Arrays.asList(\"4\"), Arrays.asList(\"1\", \"2\", \"3\", \"4\", \"5\"))); // [\"4\"]\n    }\n}\n"}
{"task_id": "Java/75", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Write a function that returns true if the given number is the multiplication of 3 prime numbers\n     * and false otherwise.\n     * Knowing that the prime number is less than 100.\n     * Example:\n     * is_multiply_prime(30) == true\n     * 30 = 2 * 3 * 5\n     */\n    public boolean is_multiply_prime(int a) {\n        if (a < 2) return false;\n\n        int count = 0;\n        for (int i = 2; i <= Math.sqrt(a); i++) {\n            while (a % i == 0 && isPrime(i)) {\n                count++;\n                a /= i;\n            }\n        }\n\n        // Check if the remaining number is also prime and part of the product\n        if (a > 1 && isPrime(a)) {\n            count++;\n        }\n\n        return count == 3;\n    }\n\n    private boolean isPrime(int n) {\n        if (n <= 1) return false;\n        for (int i = 2; i * i <= n; i++) {\n            if (n % i == 0) return false;\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.is_multiply_prime(30)); // true, because 30 = 2 * 3 * 5\n        System.out.println(solution.is_multiply_prime(60)); // false, because 60 = 2 * 2 * 3 * 5 (more than 3 primes)\n        System.out.println(solution.is_multiply_prime(100)); // false, because 100 is not a product of exactly 3 primes\n        System.out.println(solution.is_multiply_prime(30030)); // true, because 30030 = 2 * 3 * 5 * 7 * 11 * 13 (more than 3 primes)\n        System.out.println(solution.is_multiply_prime(2 * 3 * 7)); // true, because 42 = 2 * 3 * 7\n    }\n}\n"}
{"task_id": "Java/76", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Your task is to write a function that returns true if a number x is a simple\n     * power of n and false in other cases.\n     * x is a simple power of n if n**int=x\n     * For example:\n     * is_simple_power(1, 4) => true\n     * is_simple_power(2, 2) => true\n     * is_simple_power(8, 2) => true\n     * is_simple_power(3, 2) => false\n     * is_simple_power(3, 1) => false\n     * is_simple_power(5, 3) => false\n     */\n    public boolean is_simple_power(int x, int n) {\n        if (n == 1) {\n            return x == 1;\n        }\n        \n        double power = Math.pow(n, Math.round(Math.log(x) / Math.log(n)));\n        return Math.abs(power - x) < 0.0001; // Allowing a small floating point tolerance\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.is_simple_power(1, 4));   // true\n        System.out.println(solution.is_simple_power(2, 2));   // true\n        System.out.println(solution.is_simple_power(8, 2));   // true\n        System.out.println(solution.is_simple_power(3, 2));   // false\n        System.out.println(solution.is_simple_power(3, 1));   // false\n        System.out.println(solution.is_simple_power(5, 3));   // false\n        System.out.println(solution.is_simple_power(16, 2));  // true\n        System.out.println(solution.is_simple_power(81, 3));  // true\n        System.out.println(solution.is_simple_power(27, 3));  // true\n        System.out.println(solution.is_simple_power(49, 7));  // true\n    }\n}\n"}
{"task_id": "Java/77", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Write a function that takes an integer a and returns true\n     * if this integer is a cube of some integer number.\n     * Note: you may assume the input is always valid.\n     * Examples:\n     * iscube(1) ==> true\n     * iscube(2) ==> false\n     * iscube(-1) ==> true\n     * iscube(64) ==> true\n     * iscube(0) ==> true\n     * iscube(180) ==> false\n     */\n    public boolean iscube(int a) {\n        if (a == 0) return true;\n        \n        // Handle negative numbers by checking the cube root and squaring it back\n        double cubeRoot = Math.cbrt(a);\n        int roundedCubeRoot = (int) Math.round(cubeRoot);\n        \n        return Math.pow(roundedCubeRoot, 3) == a;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.iscube(1));   // true\n        System.out.println(solution.iscube(2));   // false\n        System.out.println(solution.iscube(-1));  // true\n        System.out.println(solution.iscube(64));  // true\n        System.out.println(solution.iscube(0));   // true\n        System.out.println(solution.iscube(180)); // false\n    }\n}\n"}
{"task_id": "Java/78", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * You have been tasked to write a function that receives\n     * a hexadecimal number as a string and counts the number of hexadecimal\n     * digits that are primes (prime number, or a prime, is a natural number\n     * greater than 1 that is not a product of two smaller natural numbers).\n     * Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n     * Prime numbers are 2, 3, 5, 7, B (=decimal 11), D (=decimal 13).\n     * So you have to determine a number of the following digits: 2, 3, 5, 7,\n     * B (=decimal 11), D (=decimal 13).\n     * Note: you may assume the input is always correct or empty string,\n     * and symbols A,B,C,D,E,F are always uppercase.\n     * Examples:\n     * For num = \"AB\" the output should be 1.\n     * For num = \"1077E\" the output should be 2.\n     * For num = \"ABED1A33\" the output should be 4.\n     * For num = \"123456789ABCDEF0\" the output should be 6.\n     * For num = \"2020\" the output should be 2.\n     */\n    public int hex_key(String num) {\n        // Define a set of prime hexadecimal digits\n        Set<Character> primes = new HashSet<>(Arrays.asList('2', '3', '5', '7', 'B', 'D'));\n        \n        // Count the number of prime hexadecimal digits in the input string\n        int count = 0;\n        for (char c : num.toCharArray()) {\n            if (primes.contains(c)) {\n                count++;\n            }\n        }\n        \n        return count;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.hex_key(\"AB\")); // Expected output: 1\n        System.out.println(solution.hex_key(\"1077E\")); // Expected output: 2\n        System.out.println(solution.hex_key(\"ABED1A33\")); // Expected output: 4\n        System.out.println(solution.hex_key(\"123456789ABCDEF0\")); // Expected output: 6\n        System.out.println(solution.hex_key(\"2020\")); // Expected output: 2\n    }\n}\n"}
{"task_id": "Java/79", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * You will be given a number in decimal form and your task is to convert it to\n     * binary format. The function should return a string, with each character representing a binary\n     * number. Each character in the string will be '0' or '1'.\n     *\n     * There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n     * The extra characters are there to help with the format.\n     *\n     * Examples:\n     * decimal_to_binary(15)   // returns \"db1111db\"\n     * decimal_to_binary(32)   // returns \"db100000db\"\n     */\n    public String decimal_to_binary(int decimal) {\n        if (decimal == 0) return \"db0db\";\n        \n        StringBuilder binary = new StringBuilder();\n        while (decimal > 0) {\n            binary.insert(0, decimal % 2);\n            decimal /= 2;\n        }\n        \n        return \"db\" + binary.toString() + \"db\";\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.decimal_to_binary(15));   // Expected: db1111db\n        System.out.println(solution.decimal_to_binary(32));   // Expected: db100000db\n        System.out.println(solution.decimal_to_binary(0));    // Expected: db0db\n        System.out.println(solution.decimal_to_binary(456));  // Expected: db111001000db\n        System.out.println(solution.decimal_to_binary(255));  // Expected: db11111111db\n    }\n}\n"}
{"task_id": "Java/80", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * You are given a string s.\n     * Your task is to check if the string is happy or not.\n     * A string is happy if its length is at least 3 and every 3 consecutive letters are distinct\n     * For example:\n     * is_happy(a) => false\n     * is_happy(aa) => false\n     * is_happy(abcd) => true\n     * is_happy(aabb) => false\n     * is_happy(adb) => true\n     * is_happy(xyy) => false\n     */\n    public boolean is_happy(String s) {\n        if (s.length() < 3) return false;\n        \n        for (int i = 0; i <= s.length() - 3; i++) {\n            char first = s.charAt(i);\n            char second = s.charAt(i + 1);\n            char third = s.charAt(i + 2);\n            \n            if (first == second || second == third || first == third) {\n                return false;\n            }\n        }\n        \n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.is_happy(\"a\"));       // Output: false\n        System.out.println(solution.is_happy(\"aa\"));      // Output: false\n        System.out.println(solution.is_happy(\"abcd\"));    // Output: true\n        System.out.println(solution.is_happy(\"aabb\"));    // Output: false\n        System.out.println(solution.is_happy(\"adb\"));     // Output: true\n        System.out.println(solution.is_happy(\"xyy\"));     // Output: false\n        System.out.println(solution.is_happy(\"abcabc\"));  // Output: true\n        System.out.println(solution.is_happy(\"abacaba\")); // Output: false\n    }\n}\n"}
{"task_id": "Java/81", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * It is the last week of the semester and the teacher has to give the grades\n     * to students. The teacher has been making her own algorithm for grading.\n     * The only problem is, she has lost the code she used for grading.\n     * She has given you a list of GPAs for some students and you have to write\n     * a function that can output a list of letter grades using the following table:\n     *\n     * GPA       |    Letter grade\n     * 4.0                A+\n     * >3.7               A\n     * >3.3               A-\n     * >3.0               B+\n     * >2.7               B\n     * >2.3               B-\n     * >2.0               C+\n     * >1.7               C\n     * >1.3               C-\n     * >1.0               D+\n     * >0.7               D\n     * >0.0               D-\n     * 0.0                E\n\n     * Example:\n     * numerical_letter_grade(Arrays.asList(4.0, 3, 1.7, 2, 3.5)) ==> [\"A+\", \"B\", \"C-\", \"C\", \"A-\"]\n     */\n    public List<String> numerical_letter_grade(List<Double> grades) {\n        List<String> letterGrades = new ArrayList<>();\n        \n        for (double gpa : grades) {\n            if (gpa == 4.0) {\n                letterGrades.add(\"A+\");\n            } else if (gpa > 3.7) {\n                letterGrades.add(\"A\");\n            } else if (gpa > 3.3) {\n                letterGrades.add(\"A-\");\n            } else if (gpa > 3.0) {\n                letterGrades.add(\"B+\");\n            } else if (gpa > 2.7) {\n                letterGrades.add(\"B\");\n            } else if (gpa > 2.3) {\n                letterGrades.add(\"B-\");\n            } else if (gpa > 2.0) {\n                letterGrades.add(\"C+\");\n            } else if (gpa > 1.7) {\n                letterGrades.add(\"C\");\n            } else if (gpa > 1.3) {\n                letterGrades.add(\"C-\");\n            } else if (gpa > 1.0) {\n                letterGrades.add(\"D+\");\n            } else if (gpa > 0.7) {\n                letterGrades.add(\"D\");\n            } else if (gpa > 0.0) {\n                letterGrades.add(\"D-\");\n            } else {\n                letterGrades.add(\"E\");\n            }\n        }\n\n        return letterGrades;\n    }\n}\n"}
{"task_id": "Java/82", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Write a function that takes a string and returns true if the string\n     * length is a prime number or false otherwise\n     * Examples:\n     * prime_length(\"Hello\") == true\n     * prime_length(\"abcdcba\") == true\n     * prime_length(\"kittens\") == true\n     * prime_length(\"orange\") == false\n     */\n    public boolean prime_length(String string) {\n        int length = string.length();\n        return isPrime(length);\n    }\n\n    private boolean isPrime(int number) {\n        if (number <= 1) {\n            return false;\n        }\n        for (int i = 2; i * i <= number; i++) {\n            if (number % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.prime_length(\"Hello\"));   // true\n        System.out.println(solution.prime_length(\"abcdcba\")); // true\n        System.out.println(solution.prime_length(\"kittens\")); // true\n        System.out.println(solution.prime_length(\"orange\"));  // false\n    }\n}\n"}
{"task_id": "Java/83", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a positive integer n, return the count of the numbers of n-digit\n     * positive integers that start or end with 1.\n     */\n    public int starts_one_ends(int n) {\n        if (n == 1) {\n            // Only one 1-digit number that starts and ends with 1\n            return 1;\n        }\n        \n        // For n > 1, calculate the count of numbers starting or ending with 1\n        long total_count = 17 * (long)Math.pow(10, n - 2);\n        \n        return (int) total_count;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.starts_one_ends(1)); // Expected output: 1\n        System.out.println(solution.starts_one_ends(2)); // Expected output: 170\n        System.out.println(solution.starts_one_ends(3)); // Expected output: 1700\n    }\n}\n"}
{"task_id": "Java/84", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     Given a positive integer N, return in binary the total sum of its digits.\n\n     Example\n         For N = 1000, the sum of digits will be 1 the output should be \"1\".\n         For N = 150, the sum of digits will be 6 the output should be \"110\".\n         For N = 147, the sum of digits will be 12 the output should be \"1100\".\n\n     Variables:\n         @N integer\n              Constraints: 0 <= N <= 10000.\n     Output:\n          a string of binary number\n      */\n    public String solve(int N) {\n        int sum = 0;\n        \n        // Calculate the sum of digits\n        while (N > 0) {\n            sum += N % 10;\n            N /= 10;\n        }\n        \n        // Convert the sum to binary and return as a string\n        return Integer.toBinaryString(sum);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.solve(1000)); // Expected output: \"1\"\n        System.out.println(solution.solve(150));  // Expected output: \"110\"\n        System.out.println(solution.solve(147));  // Expected output: \"1100\"\n        System.out.println(solution.solve(9999)); // Expected output: \"11110001111\"\n    }\n}\n"}
{"task_id": "Java/85", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a non-empty list of integers lst. add the even elements that are at odd indices.\n     *\n     * Examples:\n     * - add(Arrays.asList(4, 2, 6, 7)) should return 2 (since only 2 is an even number at an odd index)\n     */\n    public int add(List<Integer> lst) {\n        if (lst == null || lst.isEmpty()) {\n            throw new IllegalArgumentException(\"List cannot be null or empty\");\n        }\n\n        int sum = 0;\n        for (int i = 1; i < lst.size(); i += 2) { // Start from index 1 and increment by 2\n            Integer value = lst.get(i);\n            if (value % 2 == 0) {\n                sum += value;\n            }\n        }\n\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.add(Arrays.asList(4, 2, 6, 7))); // Should print 2\n        System.out.println(solution.add(Arrays.asList(1, 3, 5, 7, 9))); // Should print 0 (no even numbers at odd indices)\n        System.out.println(solution.add(Arrays.asList(8, 4, 2, 6, 10, 12))); // Should print 16 (4 + 12)\n    }\n}\n"}
{"task_id": "Java/86", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Write a function that takes a string and returns an ordered version of it.\n     * Ordered version of string, is a string where all words (separated by space)\n     * are replaced by a new word where all the characters arranged in\n     * ascending order based on ascii value.\n     * Note: You should keep the order of words and blank spaces in the sentence.\n     *\n     * For example:\n     * anti_shuffle(\"Hi\") returns \"Hi\"\n     * anti_shuffle(\"hello\") returns \"ehllo\"\n     * anti_shuffle(\"Hello World!!!\") returns \"Hello !!!Wdlor\"\n     */\n    public String anti_shuffle(String s) {\n        if (s == null || s.isEmpty()) {\n            return s;\n        }\n\n        StringBuilder result = new StringBuilder();\n        int wordStartIndex = 0;\n\n        for (int i = 0; i < s.length(); i++) {\n            char c = s.charAt(i);\n            if (c == ' ') {\n                // Process the current word\n                String word = s.substring(wordStartIndex, i);\n                result.append(orderedWord(word));\n                result.append(c); // Append the space character\n                wordStartIndex = i + 1;\n            }\n        }\n\n        // Process the last word in the string\n        if (wordStartIndex < s.length()) {\n            String lastWord = s.substring(wordStartIndex);\n            result.append(orderedWord(lastWord));\n        }\n\n        return result.toString();\n    }\n\n    private String orderedWord(String word) {\n        char[] chars = word.toCharArray();\n        Arrays.sort(chars);\n        return new String(chars);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.anti_shuffle(\"Hi\")); // Expected: \"Hi\"\n        System.out.println(solution.anti_shuffle(\"hello\")); // Expected: \"ehllo\"\n        System.out.println(solution.anti_shuffle(\"Hello World!!!\")); // Expected: \"Hello !!!Wdlor\"\n        System.out.println(solution.anti_shuffle(\"Programming is fun!\")); // Expected: \"Pamgimnig is fnu!\"\n    }\n}\n"}
{"task_id": "Java/87", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<List<Integer>> get_row(List<List<Integer>> lst, int x) {\n        List<List<Integer>> coordinates = new ArrayList<>();\n        \n        for (int i = 0; i < lst.size(); i++) {\n            List<Integer> row = lst.get(i);\n            for (int j = 0; j < row.size(); j++) {\n                if (row.get(j).equals(x)) {\n                    coordinates.add(Arrays.asList(i, row.size() - 1 - j));\n                }\n            }\n        }\n\n        // Sort by rows in ascending order\n        Collections.sort(coordinates, (a, b) -> a.get(0) - b.get(0));\n\n        // Sort by columns in descending order within the same row\n        for (int i = 0; i < coordinates.size(); i++) {\n            for (int j = i + 1; j < coordinates.size(); j++) {\n                if (coordinates.get(i).get(0) == coordinates.get(j).get(0)) {\n                    if (coordinates.get(i).get(1) < coordinates.get(j).get(1)) {\n                        Collections.swap(coordinates, i, j);\n                    }\n                }\n            }\n        }\n\n        return coordinates;\n    }\n}\n"}
{"task_id": "Java/88", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n\n    /**\n     * Given an array of non-negative integers, return a copy of the given array after sorting,\n     * you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n     * or sort it in descending order if the sum( first index value, last index value) is even.\n     *\n     * Note:\n     * * don't change the given array.\n     */\n    public List<Integer> sort_array(List<Integer> array) {\n        if (array == null || array.isEmpty()) {\n            return new ArrayList<>();\n        }\n\n        int sum = array.get(0) + array.get(array.size() - 1);\n        List<Integer> sortedArray = new ArrayList<>(array);\n\n        if (sum % 2 == 0) {\n            // Sort in descending order\n            sortedArray.sort(Collections.reverseOrder());\n        } else {\n            // Sort in ascending order\n            Collections.sort(sortedArray);\n        }\n\n        return sortedArray;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.sort_array(Arrays.asList())); // []\n        System.out.println(solution.sort_array(Arrays.asList(5))); // [5]\n        System.out.println(solution.sort_array(Arrays.asList(2, 4, 3, 0, 1, 5))); // [0, 1, 2, 3, 4, 5]\n        System.out.println(solution.sort_array(Arrays.asList(2, 4, 3, 0, 1, 5, 6))); // [6, 5, 4, 3, 2, 1, 0]\n    }\n}\n"}
{"task_id": "Java/89", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Create a function encrypt that takes a string as an argument and\n     * returns a string encrypted with the alphabet being rotated.\n     * The alphabet should be rotated in a manner such that the letters\n     * shift down by two multiplied to two places.\n     * For example:\n     * encrypt(\"hi\") returns \"lm\"\n     * encrypt(\"asdfghjkl\") returns \"ewhjklnop\"\n     * encrypt(\"gf\") returns \"kj\"\n     * encrypt(\"et\") returns \"ix\"\n     */\n    public String encrypt(String s) {\n        StringBuilder encrypted = new StringBuilder();\n        for (char c : s.toCharArray()) {\n            if (Character.isLetter(c)) {\n                char base = Character.isUpperCase(c) ? 'A' : 'a';\n                int offset = ((c - base + 4) % 26);\n                encrypted.append((char) (base + offset));\n            } else {\n                encrypted.append(c);\n            }\n        }\n        return encrypted.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.encrypt(\"hi\"));       // Should print \"lm\"\n        System.out.println(solution.encrypt(\"asdfghjkl\")); // Should print \"ewhjklnop\"\n        System.out.println(solution.encrypt(\"gf\"));       // Should print \"kj\"\n        System.out.println(solution.encrypt(\"et\"));       // Should print \"ix\"\n\n        // Additional test cases\n        System.out.println(solution.encrypt(\"Hello, World!\")); // Should print \"Lipps, Asvph!\"\n        System.out.println(solution.encrypt(\"Zebra123\"));     // Should print \"Difve123\"\n    }\n}\n"}
{"task_id": "Java/90", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * You are given a list of integers.\n     * Write a function next_smallest() that returns the 2nd smallest element of the list.\n     * Return null if there is no such element.\n     *\n     * @param lst The input list of integers\n     * @return Optional containing the 2nd smallest integer, or Optional.empty() if not available\n     */\n    public Optional<Integer> next_smallest(List<Integer> lst) {\n        // Remove duplicates and sort the list\n        Set<Integer> uniqueElements = new TreeSet<>(lst);\n        \n        // If there are less than 2 elements after removing duplicates, return Optional.empty()\n        if (uniqueElements.size() < 2) {\n            return Optional.empty();\n        }\n        \n        // Return the second element in the sorted set\n        Integer[] array = uniqueElements.toArray(new Integer[0]);\n        return Optional.of(array[1]);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.next_smallest(Arrays.asList(1, 2, 3, 4, 5))); // Expected: Optional[2]\n        System.out.println(solution.next_smallest(Arrays.asList(5, 1, 4, 3, 2))); // Expected: Optional[2]\n        System.out.println(solution.next_smallest(Arrays.asList()));             // Expected: Optional.empty\n        System.out.println(solution.next_smallest(Arrays.asList(1, 1)));         // Expected: Optional.empty\n        System.out.println(solution.next_smallest(Arrays.asList(5, 4, 3, 2, 1))); // Expected: Optional[2]\n    }\n}\n"}
{"task_id": "Java/91", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int is_bored(String S) {\n        String[] sentences = S.split(\"[.?!]\");\n        int count = 0;\n        for (String sentence : sentences) {\n            if (!sentence.trim().isEmpty() && sentence.trim().startsWith(\"I\")) {\n                count++;\n            }\n        }\n        return count;\n    }\n}\n"}
{"task_id": "Java/92", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Create a function that takes 3 numbers.\n     * Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n     * Returns false in any other cases.\n     *\n     * Examples\n     * any_int(5, 2, 7) -> true\n     * any_int(3, 2, 2) -> false\n     * any_int(3, -2, 1) -> true\n     * any_int(3.6, -2.2, 2) -> false\n     */\n    public boolean any_int(Object x, Object y, Object z) {\n        if (x instanceof Integer && y instanceof Integer && z instanceof Integer) {\n            int a = (Integer) x;\n            int b = (Integer) y;\n            int c = (Integer) z;\n\n            return a == b + c || b == a + c || c == a + b;\n        }\n        return false;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.any_int(5, 2, 7));   // true\n        System.out.println(solution.any_int(3, 2, 2));   // false\n        System.out.println(solution.any_int(3, -2, 1));  // true\n        System.out.println(solution.any_int(3.6, -2.2, 2)); // false (should return false)\n    }\n}\n"}
{"task_id": "Java/93", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Write a function that takes a message, and encodes in such a way that it swaps case of all letters,\n     * replaces all vowels in the message with the letter that appears 2 places ahead of that vowel in the\n     * English alphabet.\n     *\n     * Examples:\n     * >>> encode(\"test\")\n     * \"TGST\"\n     * >>> encode(\"This is a message\")\n     * \"tHKS KS C MGSSCGG\"\n     */\n    public String encode(String message) {\n        StringBuilder encodedMessage = new StringBuilder();\n        \n        for (char c : message.toCharArray()) {\n            if (Character.isLetter(c)) {\n                // Swap case\n                char swappedCaseChar = Character.isLowerCase(c) ? Character.toUpperCase(c) : Character.toLowerCase(c);\n                \n                // Replace vowels with the letter 2 places ahead in the alphabet\n                switch (swappedCaseChar) {\n                    case 'A':\n                        encodedMessage.append('C');\n                        break;\n                    case 'E':\n                        encodedMessage.append('G');\n                        break;\n                    case 'I':\n                        encodedMessage.append('K');\n                        break;\n                    case 'O':\n                        encodedMessage.append('Q');\n                        break;\n                    case 'U':\n                        encodedMessage.append('W');\n                        break;\n                    case 'a':\n                        encodedMessage.append('c');\n                        break;\n                    case 'e':\n                        encodedMessage.append('g');\n                        break;\n                    case 'i':\n                        encodedMessage.append('k');\n                        break;\n                    case 'o':\n                        encodedMessage.append('q');\n                        break;\n                    case 'u':\n                        encodedMessage.append('w');\n                        break;\n                    default:\n                        // If it's not a vowel, just append the swapped case character\n                        encodedMessage.append(swappedCaseChar);\n                }\n            } else {\n                // Non-letter characters are appended as is\n                encodedMessage.append(c);\n            }\n        }\n        \n        return encodedMessage.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.encode(\"test\"));  // Expected: \"TGST\"\n        System.out.println(solution.encode(\"This is a message\"));  // Expected: \"tHKS KS C MGSSCGG\"\n        System.out.println(solution.encode(\"Hello World!\"));  // Expected: \"hKLLQ wOrld!\"\n    }\n}\n"}
{"task_id": "Java/94", "generation": "import java.util.List;\n\nclass Solution {\n    /**\n     * You are given a list of integers.\n     * You need to find the largest prime value and return the sum of its digits.\n     */\n    public int skjkasdkd(List<Integer> lst) {\n        if (lst == null || lst.isEmpty()) {\n            return 0;\n        }\n\n        int maxPrime = -1;\n\n        for (int num : lst) {\n            if (isPrime(num)) {\n                maxPrime = Math.max(maxPrime, num);\n            }\n        }\n\n        if (maxPrime == -1) {\n            return 0;\n        }\n\n        return sumOfDigits(maxPrime);\n    }\n\n    private boolean isPrime(int num) {\n        if (num <= 1) {\n            return false;\n        }\n        for (int i = 2; i <= Math.sqrt(num); i++) {\n            if (num % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private int sumOfDigits(int num) {\n        int sum = 0;\n        while (num > 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        List<Integer> lst1 = Arrays.asList(0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3);\n        System.out.println(solution.skjkasdkd(lst1)); // Output: 10\n\n        List<Integer> lst2 = Arrays.asList(1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1);\n        System.out.println(solution.skjkasdkd(lst2)); // Output: 25\n\n        List<Integer> lst3 = Arrays.asList(1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3);\n        System.out.println(solution.skjkasdkd(lst3)); // Output: 13\n\n        List<Integer> lst4 = Arrays.asList(0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6);\n        System.out.println(solution.skjkasdkd(lst4)); // Output: 11\n\n        List<Integer> lst5 = Arrays.asList(0, 81, 12, 3, 1, 21);\n        System.out.println(solution.skjkasdkd(lst5)); // Output: 3\n\n        List<Integer> lst6 = Arrays.asList(0, 8, 1, 2, 1, 7);\n        System.out.println(solution.skjkasdkd(lst6)); // Output: 7\n    }\n}\n"}
{"task_id": "Java/95", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given a map, return True if all keys are strings and all keys are in lower case or in upper case, else return False.\n     * The function should return False is the given map is empty.\n     */\n    public boolean check_dict_case(Map<Object, Object> dict) {\n        if (dict.isEmpty()) {\n            return false;\n        }\n\n        boolean allLowerCase = true;\n        boolean allUpperCase = true;\n\n        for (Object key : dict.keySet()) {\n            if (!(key instanceof String)) {\n                return false;\n            }\n            String strKey = (String) key;\n            if (!strKey.equals(strKey.toLowerCase())) {\n                allLowerCase = false;\n            }\n            if (!strKey.equals(strKey.toUpperCase())) {\n                allUpperCase = false;\n            }\n        }\n\n        return allLowerCase || allUpperCase;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.check_dict_case(Map.of(\"a\", \"apple\", \"b\", \"banana\"))); // True\n        System.out.println(solution.check_dict_case(Map.of(\"a\", \"apple\", \"A\", \"banana\", \"B\", \"banana\"))); // False\n        System.out.println(solution.check_dict_case(Map.of(\"a\", \"apple\", 8, \"banana\", \"a\", \"apple\"))); // False\n        System.out.println(solution.check_dict_case(Map.of(\"Name\", \"John\", \"Age\", \"36\", \"City\", \"Houston\"))); // False\n        System.out.println(solution.check_dict_case(Map.of(\"STATE\", \"NC\", \"ZIP\", \"12345\"))); // True\n    }\n}\n"}
{"task_id": "Java/96", "generation": "import java.util.ArrayList;\nimport java.util.List;\n\nclass Solution {\n\n    /**\n     * Implement a function that takes an non-negative integer and returns an array of the first n\n     * integers that are prime numbers and less than n.\n     *\n     * @param n The upper limit (non-inclusive) to find prime numbers up to.\n     * @return A List containing prime numbers less than n.\n     */\n    public List<Integer> count_up_to(int n) {\n        List<Integer> primes = new ArrayList<>();\n        \n        for (int i = 2; i < n && primes.size() < n; i++) {\n            if (isPrime(i)) {\n                primes.add(i);\n            }\n        }\n        \n        return primes;\n    }\n\n    /**\n     * Helper method to check if a number is prime.\n     *\n     * @param num The number to check.\n     * @return true if the number is prime, false otherwise.\n     */\n    private boolean isPrime(int num) {\n        if (num <= 1) {\n            return false;\n        }\n        for (int i = 2; i <= Math.sqrt(num); i++) {\n            if (num % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.count_up_to(5));   // Output: [2, 3]\n        System.out.println(solution.count_up_to(11));  // Output: [2, 3, 5, 7]\n        System.out.println(solution.count_up_to(0));   // Output: []\n        System.out.println(solution.count_up_to(20));  // Output: [2, 3, 5, 7, 11, 13, 17, 19]\n        System.out.println(solution.count_up_to(1));   // Output: []\n        System.out.println(solution.count_up_to(18));  // Output: [2, 3, 5, 7, 11, 13, 17]\n    }\n}\n"}
{"task_id": "Java/97", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Complete the function that takes two integers and returns\n     * the product of their unit digits.\n     * Assume the input is always valid.\n     * Examples:\n     * multiply(148, 412) should return 16.\n     * multiply(19, 28) should return 72.\n     * multiply(2020, 1851) should return 0.\n     * multiply(14,-15) should return 20.\n     */\n    public int multiply(int a, int b) {\n        // Extract the unit digits of both numbers\n        int unitDigitA = Math.abs(a % 10);\n        int unitDigitB = Math.abs(b % 10);\n\n        // Return the product of the unit digits\n        return unitDigitA * unitDigitB;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.multiply(148, 412)); // Expected output: 16\n        System.out.println(solution.multiply(19, 28));   // Expected output: 72\n        System.out.println(solution.multiply(2020, 1851)); // Expected output: 0\n        System.out.println(solution.multiply(14, -15));  // Expected output: 20\n    }\n}\n"}
{"task_id": "Java/98", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a string s, count the number of uppercase vowels in even indices.\n     *\n     * For example:\n     * count_upper(\"aBCdEf\") returns 1\n     * count_upper(\"abcdefg\") returns 0\n     * count_upper(\"dBBE\") returns 0\n     */\n    public int count_upper(String s) {\n        int count = 0;\n        for (int i = 0; i < s.length(); i += 2) { // Iterate over even indices\n            char c = s.charAt(i);\n            if (isUppercaseVowel(c)) {\n                count++;\n            }\n        }\n        return count;\n    }\n\n    private boolean isUppercaseVowel(char c) {\n        return c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U';\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.count_upper(\"aBCdEf\")); // Expected output: 1\n        System.out.println(solution.count_upper(\"abcdefg\")); // Expected output: 0\n        System.out.println(solution.count_upper(\"dBBE\")); // Expected output: 0\n        System.out.println(solution.count_upper(\"AeIoUc\")); // Expected output: 3\n        System.out.println(solution.count_upper(\"zYxWvUt\")); // Expected output: 2\n    }\n}\n"}
{"task_id": "Java/99", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Create a function that takes a value (string) representing a number\n     * and returns the closest integer to it. If the number is equidistant\n     * from two integers, round it away from zero.\n     *\n     * Examples:\n     * >>> closest_integer(\"10\")\n     * 10\n     * >>> closest_integer(\"15.3\")\n     * 15\n     * >>> closest_integer(\"14.5\")\n     * 15\n     * >>> closest_integer(\"-14.5\")\n     * -15\n     */\n    public int closest_integer(String value) {\n        double num = Double.parseDouble(value);\n        double floorValue = Math.floor(num);\n        double ceilValue = Math.ceil(num);\n\n        if (num - floorValue == 0.5 || ceilValue - num == 0.5) {\n            return (int)(num > 0 ? ceilValue : floorValue);\n        } else {\n            return (int)Math.round(num);\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.closest_integer(\"10\"));   // Output: 10\n        System.out.println(solution.closest_integer(\"15.3\")); // Output: 15\n        System.out.println(solution.closest_integer(\"14.5\")); // Output: 15\n        System.out.println(solution.closest_integer(\"-14.5\"));// Output: -15\n        System.out.println(solution.closest_integer(\"0.5\"));  // Output: 1\n        System.out.println(solution.closest_integer(\"-0.5\")); // Output: -1\n    }\n}\n"}
{"task_id": "Java/100", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given a positive integer n, you have to make a pile of n levels of stones.\n     * The first level has n stones.\n     * The number of stones in the next level is:\n     * - the next odd number if n is odd.\n     * - the next even number if n is even.\n     * Return the number of stones in each level in a list, where element at index\n     * i represents the number of stones in the level (i+1).\n     *\n     * Examples:\n     * >>> make_a_pile(3)\n     * [3, 5, 7]\n     */\n    public List<Integer> make_a_pile(int n) {\n        List<Integer> result = new ArrayList<>();\n        int currentStones = n;\n        \n        for (int i = 0; i < n; i++) {\n            result.add(currentStones);\n            // Determine the next number of stones\n            if (currentStones % 2 == 0) {\n                currentStones += 2; // Next even number\n            } else {\n                currentStones += 2; // Next odd number\n            }\n        }\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.make_a_pile(3)); // Expected: [3, 5, 7]\n        System.out.println(solution.make_a_pile(4)); // Expected: [4, 6, 8, 10]\n        System.out.println(solution.make_a_pile(1)); // Expected: [1, 3]\n    }\n}\n"}
{"task_id": "Java/101", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * You will be given a string of words separated by commas or spaces. Your task is\n     * to split the string into words and return an array of the words.\n     *\n     * For example:\n     * words_string(\"Hi, my name is John\").equals(Arrays.asList(\"Hi\", \"my\", \"name\", \"is\", \"John\"])\n     * words_string(\"One, two, three, four, five, six\").equals(Arrays.asList(\"One\", \"two\", \"three\", \"four\", \"five\", \"six])\n     */\n    public List<String> words_string(String s) {\n        // Use regular expression to split the string by commas and spaces\n        String[] words = s.split(\"[,\\s]+\");\n        return Arrays.asList(words);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        List<String> result1 = solution.words_string(\"Hi, my name is John\");\n        System.out.println(result1.equals(Arrays.asList(\"Hi\", \"my\", \"name\", \"is\", \"John\"))); // Expected: true\n        \n        List<String> result2 = solution.words_string(\"One, two, three, four, five, six\");\n        System.out.println(result2.equals(Arrays.asList(\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"))); // Expected: true\n    }\n}\n"}
{"task_id": "Java/102", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * This function takes two positive numbers x and y and returns the\n     * biggest even integer number that is in the range [x, y] inclusive. If\n     * there's no such number, then the function should return -1.\n     *\n     * For example:\n     * choose_num(12, 15) = 14\n     * choose_num(13, 12) = -1\n     */\n    public int choose_num(int x, int y) {\n        // If the range is invalid or there's no even number in the range\n        if (x > y || (x % 2 != 0 && y % 2 != 0)) {\n            return -1;\n        }\n\n        // Find the biggest even number in the range [x, y]\n        for (int i = y; i >= x; i--) {\n            if (i % 2 == 0) {\n                return i;\n            }\n        }\n\n        // If no even number is found\n        return -1;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.choose_num(12, 15)); // Expected output: 14\n        System.out.println(solution.choose_num(13, 12)); // Expected output: -1\n        System.out.println(solution.choose_num(10, 20)); // Expected output: 20\n        System.out.println(solution.choose_num(17, 19)); // Expected output: -1\n        System.out.println(solution.choose_num(8, 8));   // Expected output: 8\n    }\n}\n"}
{"task_id": "Java/103", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * You are given two positive integers n and m, and your task is to compute the\n     * average of the integers from n through m (including n and m).\n     * Round the answer to the nearest integer and convert that to binary.\n     * If n is greater than m, return -1.\n     * Example:\n     * rounded_avg(1, 5) => \"11\"\n     * rounded_avg(7, 5) => -1\n     * rounded_avg(10, 20) => \"1111\"\n     * rounded_avg(20, 33) => \"11011\"\n     */\n    public Object rounded_avg(int n, int m) {\n        if (n > m) {\n            return -1;\n        }\n        \n        long sum = 0;\n        for (int i = n; i <= m; i++) {\n            sum += i;\n        }\n        \n        double average = Math.round((double) sum / (m - n + 1));\n        String binary = Long.toBinaryString((long) average);\n        \n        return binary;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.rounded_avg(1, 5));   // Expected output: \"11\"\n        System.out.println(solution.rounded_avg(7, 5));   // Expected output: -1\n        System.out.println(solution.rounded_avg(10, 20)); // Expected output: \"1111\"\n        System.out.println(solution.rounded_avg(20, 33)); // Expected output: \"11011\"\n    }\n}\n"}
{"task_id": "Java/104", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> unique_digits(List<Integer> x) {\n        List<Integer> result = new ArrayList<>();\n        \n        for (int num : x) {\n            if (!hasEvenDigit(num)) {\n                result.add(num);\n            }\n        }\n        \n        Collections.sort(result);\n        return result;\n    }\n\n    private boolean hasEvenDigit(int n) {\n        while (n > 0) {\n            int digit = n % 10;\n            if (digit % 2 == 0) {\n                return true;\n            }\n            n /= 10;\n        }\n        return false;\n    }\n}\n"}
{"task_id": "Java/105", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given an array of integers, sort the integers that are between 1 and 9 inclusive,\n     * reverse the resulting array, and then replace each digit by its corresponding name from\n     * \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n     *\n     * @param arr input list of integers\n     * @return a list of strings representing the names of the digits in reverse sorted order\n     */\n    public List<String> by_length(List<Integer> arr) {\n        // Filter out numbers not between 1 and 9 inclusive\n        List<Integer> filtered = arr.stream()\n                                     .filter(num -> num >= 1 && num <= 9)\n                                     .sorted()\n                                     .collect(Collectors.toList());\n        \n        // Reverse the list\n        Collections.reverse(filtered);\n        \n        // Map each digit to its corresponding name\n        return filtered.stream()\n                       .map(digit -> switch (digit) {\n                           case 1 -> \"One\";\n                           case 2 -> \"Two\";\n                           case 3 -> \"Three\";\n                           case 4 -> \"Four\";\n                           case 5 -> \"Five\";\n                           case 6 -> \"Six\";\n                           case 7 -> \"Seven\";\n                           case 8 -> \"Eight\";\n                           case 9 -> \"Nine\";\n                           default -> \"\";\n                       })\n                       .collect(Collectors.toList());\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.by_length(Arrays.asList(2, 1, 1, 4, 5, 8, 2, 3))); // [Eight, Five, Four, Three, Two, Two, One, One]\n        System.out.println(solution.by_length(Arrays.asList())); // []\n        System.out.println(solution.by_length(Arrays.asList(1, -1, 55))); // [One]\n        System.out.println(solution.by_length(Arrays.asList(9, 7, 3, 2, 4, 8, 6, 5, 1))); // [Nine, Eight, Seven, Six, Five, Four, Three, Two, One]\n    }\n}\n"}
{"task_id": "Java/106", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Implement the function f that takes n as a parameter,\n     * and returns a list of size n, such that the value of the element at index i is the factorial of i if i is even\n     * or the sum of numbers from 1 to i otherwise.\n     * i starts from 1.\n     * the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).\n     * Example:\n     * f(5) == [1, 2, 6, 24, 15]\n     */\n    public List<Integer> f(int n) {\n        List<Integer> result = new ArrayList<>();\n        \n        for (int i = 1; i <= n; i++) {\n            if (i % 2 == 0) {\n                // Calculate factorial of even index\n                int factorial = calculateFactorial(i);\n                result.add(factorial);\n            } else {\n                // Calculate sum from 1 to odd index\n                int sum = calculateSum(i);\n                result.add(sum);\n            }\n        }\n        \n        return result;\n    }\n\n    private int calculateFactorial(int n) {\n        if (n == 0 || n == 1) {\n            return 1;\n        }\n        int factorial = 1;\n        for (int i = 2; i <= n; i++) {\n            factorial *= i;\n        }\n        return factorial;\n    }\n\n    private int calculateSum(int n) {\n        int sum = 0;\n        for (int i = 1; i <= n; i++) {\n            sum += i;\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.f(5));  // Expected output: [1, 2, 6, 24, 15]\n        System.out.println(solution.f(3));  // Expected output: [1, 2, 6]\n        System.out.println(solution.f(0));  // Expected output: []\n    }\n}\n"}
{"task_id": "Java/107", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given a positive integer n, return a tuple that has the number of even and odd\n     * integer palindromes that fall within the range(1, n), inclusive.\n     *\n     * @param n The upper limit (inclusive) to check for palindromic numbers.\n     * @return A List containing two integers: the first is the count of even palindromes,\n     *         and the second is the count of odd palindromes.\n     */\n    public List<Integer> even_odd_palindrome(int n) {\n        int evenCount = 0;\n        int oddCount = 0;\n\n        for (int i = 1; i <= n; i++) {\n            if (isPalindrome(i)) {\n                if (i % 2 == 0) {\n                    evenCount++;\n                } else {\n                    oddCount++;\n                }\n            }\n        }\n\n        return Arrays.asList(evenCount, oddCount);\n    }\n\n    /**\n     * Helper method to check if a number is a palindrome.\n     *\n     * @param num The number to check.\n     * @return true if the number is a palindrome, false otherwise.\n     */\n    private boolean isPalindrome(int num) {\n        String str = Integer.toString(num);\n        int left = 0;\n        int right = str.length() - 1;\n\n        while (left < right) {\n            if (str.charAt(left) != str.charAt(right)) {\n                return false;\n            }\n            left++;\n            right--;\n        }\n\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.even_odd_palindrome(3));  // Output: [1, 2]\n        System.out.println(solution.even_odd_palindrome(12)); // Output: [4, 6]\n        System.out.println(solution.even_odd_palindrome(10)); // Output: [2, 5]\n    }\n}\n"}
{"task_id": "Java/108", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int count_nums(List<Integer> arr) {\n        return (int) arr.stream()\n                        .filter(num -> sumOfDigits(num) > 0)\n                        .count();\n    }\n\n    private int sumOfDigits(int num) {\n        int sum = 0;\n        boolean isNegative = num < 0;\n        while (num != 0) {\n            int digit = Math.abs(num % 10);\n            if (isNegative && digit == -num % 10) {\n                digit *= -1; // Make the first signed digit negative\n            }\n            sum += digit;\n            num /= 10;\n        }\n        return sum;\n    }\n}\n"}
{"task_id": "Java/109", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N]. The\n     * numbers in the array will be randomly ordered. Your task is to determine if\n     * it is possible to get an array sorted in non-decreasing order by performing\n     * the following operation on the given array:\n     *      You are allowed to perform right shift operation any number of times.\n     *\n     * One right shift operation means shifting all elements of the array by one\n     * position in the right direction. The last element of the array will be moved to\n     * the starting position in the array i.e. 0th index.\n     *\n     * If it is possible to obtain the sorted array by performing the above operation\n     * then return true else return False.\n     * If the given array is empty then return true.\n     *\n     * Note: The given list is guaranteed to have unique elements.\n     */\n    public boolean move_one_ball(List<Integer> arr) {\n        if (arr.isEmpty()) {\n            return true;\n        }\n\n        int n = arr.size();\n        for (int i = 0; i < n - 1; i++) {\n            if (arr.get(i) > arr.get(i + 1)) {\n                // Check if the array can be sorted by a single right shift\n                List<Integer> shiftedArr = new ArrayList<>(arr.subList(i + 1, n));\n                shiftedArr.addAll(arr.subList(0, i + 1));\n                boolean isSorted = true;\n                for (int j = 0; j < n - 1; j++) {\n                    if (shiftedArr.get(j) > shiftedArr.get(j + 1)) {\n                        isSorted = false;\n                        break;\n                    }\n                }\n                return isSorted;\n            }\n        }\n\n        // If no out-of-order pair found, the array is already sorted\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.move_one_ball(Arrays.asList(3, 4, 5, 1, 2))); // true\n        System.out.println(solution.move_one_ball(Arrays.asList(3, 5, 4, 1, 2))); // false\n        System.out.println(solution.move_one_ball(Arrays.asList()));             // true\n        System.out.println(solution.move_one_ball(Arrays.asList(1, 2, 3, 4, 5))); // true\n        System.out.println(solution.move_one_ball(Arrays.asList(2, 1, 3, 4, 5))); // false (requires more than one shift)\n    }\n}\n"}
{"task_id": "Java/110", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * In this problem, you will implement a function that takes two lists of numbers,\n     * and determines whether it is possible to perform an exchange of elements\n     * between them to make lst1 a list of only even numbers.\n     * There is no limit on the number of exchanged elements between lst1 and lst2.\n     * If it is possible to exchange elements between the lst1 and lst2 to make\n     * all the elements of lst1 to be even, return \"YES\".\n     * Otherwise, return \"NO\".\n     * For example:\n     * exchange(Arrays.asList(1, 2, 3, 4), Arrays.asList(1, 2, 3, 4)) => \"YES\"\n     * exchange(Arrays.asList(1, 2, 3, 4), Arrays.asList(1, 5, 3, 4)) => \"NO\"\n     * It is assumed that the input lists will be non-empty.\n     */\n    public String exchange(List<Integer> lst1, List<Integer> lst2) {\n        // Count odd numbers in lst1 and even numbers in lst2\n        int oddCount = 0;\n        for (int num : lst1) {\n            if (num % 2 != 0) {\n                oddCount++;\n            }\n        }\n\n        int evenCount = 0;\n        for (int num : lst2) {\n            if (num % 2 == 0) {\n                evenCount++;\n            }\n        }\n\n        // If there are enough even numbers in lst2 to replace all odd numbers in lst1, return \"YES\"\n        return oddCount <= evenCount ? \"YES\" : \"NO\";\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.exchange(Arrays.asList(1, 2, 3, 4), Arrays.asList(1, 2, 3, 4))); // Expected: YES\n        System.out.println(solution.exchange(Arrays.asList(1, 2, 3, 4), Arrays.asList(1, 5, 3, 4))); // Expected: NO\n        System.out.println(solution.exchange(Arrays.asList(1, 3, 5, 7), Arrays.asList(2, 4, 6, 8))); // Expected: YES\n        System.out.println(solution.exchange(Arrays.asList(1, 3, 5, 7), Arrays.asList(1, 3, 5, 7))); // Expected: NO\n    }\n}\n"}
{"task_id": "Java/111", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public Map<String, Integer> histogram(String test) {\n        Map<String, Integer> letterCounts = new HashMap<>();\n        \n        // Split the input string into individual letters\n        String[] letters = test.split(\" \");\n        \n        // Count occurrences of each letter\n        for (String letter : letters) {\n            if (!letter.isEmpty()) { // Ensure non-empty strings are processed\n                letterCounts.put(letter, letterCounts.getOrDefault(letter, 0) + 1);\n            }\n        }\n        \n        // Find the maximum count\n        int maxCount = letterCounts.values().stream()\n                                   .max(Integer::compare)\n                                   .orElse(0);\n        \n        // Filter and return letters with the maximum count\n        Map<String, Integer> result = new HashMap<>();\n        for (Map.Entry<String, Integer> entry : letterCounts.entrySet()) {\n            if (entry.getValue() == maxCount) {\n                result.put(entry.getKey(), entry.getValue());\n            }\n        }\n        \n        return result;\n    }\n}\n"}
{"task_id": "Java/112", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Task\n     * We are given two strings s and c, you have to deleted all the characters in s that are equal to any character in c\n     * then check if the result string is palindrome.\n     * A string is called palindrome if it reads the same backward as forward.\n     * You should return a tuple containing the result string and true/false for the check.\n     * Example\n     * For s = \"abcde\", c = \"ae\", the result should be (\"bcd\",false)\n     * For s = \"abcdef\", c = \"b\"  the result should be (\"acdef\",false)\n     * For s = \"abcdedcba\", c = \"ab\", the result should be (\"cdedc\",true)\n     */\n    public List<Object> reverse_delete(String s, String c) {\n        Set<Character> charsToRemove = new HashSet<>();\n        for (char ch : c.toCharArray()) {\n            charsToRemove.add(ch);\n        }\n\n        StringBuilder sb = new StringBuilder();\n        for (char ch : s.toCharArray()) {\n            if (!charsToRemove.contains(ch)) {\n                sb.append(ch);\n            }\n        }\n\n        String resultString = sb.toString();\n        boolean isPalindrome = isPalindrome(resultString);\n\n        return Arrays.asList(resultString, isPalindrome);\n    }\n\n    private boolean isPalindrome(String str) {\n        int left = 0;\n        int right = str.length() - 1;\n\n        while (left < right) {\n            if (str.charAt(left) != str.charAt(right)) {\n                return false;\n            }\n            left++;\n            right--;\n        }\n\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.reverse_delete(\"abcde\", \"ae\"));  // Expected: [bcd, false]\n        System.out.println(solution.reverse_delete(\"abcdef\", \"b\"));  // Expected: [acdef, false]\n        System.out.println(solution.reverse_delete(\"abcdedcba\", \"ab\"));  // Expected: [cdedc, true]\n    }\n}\n"}
{"task_id": "Java/113", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a list of strings, where each string consists of only digits,\n     * return a list. Each element i of the output should be \"the number of odd elements in the\n     * string i of the input.\" where all the i's should be replaced by the number\n     * of odd digits in the i\"th string of the input.\n     *\n     * @param lst The input list of strings consisting only of digits.\n     * @return A list of formatted strings indicating the count of odd elements in each input string.\n     */\n    public List<String> odd_count(List<String> lst) {\n        List<String> result = new ArrayList<>();\n        for (String str : lst) {\n            int oddCount = 0;\n            for (char c : str.toCharArray()) {\n                if ((c - '0') % 2 != 0) {\n                    oddCount++;\n                }\n            }\n            String formattedStr = \"the number of odd elements \" + oddCount + \"n the str\" + oddCount + \"ng \" + oddCount + \" of the \" + oddCount + \"nput.\";\n            result.add(formattedStr);\n        }\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        List<String> test1 = Arrays.asList(\"1234567\");\n        System.out.println(solution.odd_count(test1));  // Expected: [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n\n        List<String> test2 = Arrays.asList(\"3\", \"11111111\");\n        System.out.println(solution.odd_count(test2));  // Expected: [\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    }\n}\n"}
{"task_id": "Java/114", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given an array of integers nums, find the minimum sum of any non-empty sub-array\n     * of nums.\n     *\n     * Example:\n     * minSubArraySum(Arrays.asList(2, 3, 4, 1, 2, 4)) == 1\n     * minSubArraySum(Arrays.asList(-1, -2, -3)) == -6\n     */\n    public int minSubArraySum(List<Integer> nums) {\n        if (nums == null || nums.isEmpty()) {\n            throw new IllegalArgumentException(\"Input list cannot be null or empty\");\n        }\n        \n        int currentMin = nums.get(0);\n        int globalMin = nums.get(0);\n\n        for (int i = 1; i < nums.size(); i++) {\n            currentMin = Math.min(nums.get(i), currentMin + nums.get(i));\n            globalMin = Math.min(globalMin, currentMin);\n        }\n\n        return globalMin;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.minSubArraySum(Arrays.asList(2, 3, 4, 1, 2, 4))); // Expected output: 1\n        System.out.println(solution.minSubArraySum(Arrays.asList(-1, -2, -3)));       // Expected output: -6\n        System.out.println(solution.minSubArraySum(Arrays.asList(1, 2, 3, -6, 1)));   // Expected output: -6\n        System.out.println(solution.minSubArraySum(Arrays.asList(-1, -1, -2, 1)));    // Expected output: -4\n        System.out.println(solution.minSubArraySum(Arrays.asList(1, 2, 3, 4, 5)));    // Expected output: 1\n    }\n}\n"}
{"task_id": "Java/115", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * You are given a rectangular grid of wells. Each row represents a single well,\n     * and each 1 in a row represents a single unit of water.\n     * Each well has a corresponding bucket that can be used to extract water from it,\n     * and all buckets have the same capacity. Can't use buckets from other wells to extract water from one well.\n     * Your task is to use the buckets to empty the wells.\n     * Output the number of times you need to lower the buckets.\n     *\n     * Example 1:\n     * Input:\n     *      grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n     *      bucket_capacity : 1\n     * Output: 6\n     *\n     * Example 2:\n     * Input:\n     *      grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n     *      bucket_capacity : 2\n     * Output: 5\n     *\n     * Example 3:\n     * Input:\n     *      grid : [[0,0,0], [0,0,0]]\n     *      bucket_capacity : 5\n     * Output: 0\n     */\n    public int max_fill(List<List<Integer>> grid, int capacity) {\n        int totalDrops = 0;\n        for (List<Integer> well : grid) {\n            int waterUnits = 0;\n            for (int unit : well) {\n                waterUnits += unit;\n            }\n            totalDrops += Math.ceil((double) waterUnits / capacity);\n        }\n        return totalDrops;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test Case 1\n        List<List<Integer>> grid1 = Arrays.asList(\n                Arrays.asList(0, 0, 1, 0),\n                Arrays.asList(0, 1, 0, 0),\n                Arrays.asList(1, 1, 1, 1)\n        );\n        int capacity1 = 1;\n        System.out.println(\"Test Case 1: \" + solution.max_fill(grid1, capacity1)); // Expected output: 6\n\n        // Test Case 2\n        List<List<Integer>> grid2 = Arrays.asList(\n                Arrays.asList(0, 0, 1, 1),\n                Arrays.asList(0, 0, 0, 0),\n                Arrays.asList(1, 1, 1, 1),\n                Arrays.asList(0, 1, 1, 1)\n        );\n        int capacity2 = 2;\n        System.out.println(\"Test Case 2: \" + solution.max_fill(grid2, capacity2)); // Expected output: 5\n\n        // Test Case 3\n        List<List<Integer>> grid3 = Arrays.asList(\n                Arrays.asList(0, 0, 0),\n                Arrays.asList(0, 0, 0)\n        );\n        int capacity3 = 5;\n        System.out.println(\"Test Case 3: \" + solution.max_fill(grid3, capacity3)); // Expected output: 0\n    }\n}\n"}
{"task_id": "Java/116", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * In this Kata, you have to sort an array of integers according to\n     * number of ones in their binary representation in ascending order.\n     * For similar number of ones, sort based on decimal value.\n     *\n     * It must be implemented like this:\n     * >>> sort_array(Arrays.asList(1, 5, 2, 3, 4)).equals(Arrays.asList(1, 2, 4, 3, 5))\n     * >>> sort_array(Arrays.asList(-2, -3, -4, -5, -6)).equals(Arrays.asList(-4, -2, -6, -5, -3))\n     * >>> sort_array(Arrays.asList(1, 0, 2, 3, 4)).equals(Arrays.asList(0, 1, 2, 4, 3))\n     */\n    public List<Integer> sort_array(List<Integer> arr) {\n        return arr.stream()\n                  .sorted(Comparator.comparingInt(this::countOnes)\n                                    .thenComparingInt(i -> i))\n                  .collect(Collectors.toList());\n    }\n\n    private int countOnes(int num) {\n        if (num < 0) {\n            num = ~num + 1; // Convert negative number to its positive equivalent\n        }\n        int onesCount = 0;\n        while (num > 0) {\n            onesCount += num & 1;\n            num >>= 1;\n        }\n        return onesCount;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        List<Integer> test1 = Arrays.asList(1, 5, 2, 3, 4);\n        System.out.println(\"Test Case 1: \" + solution.sort_array(test1).equals(Arrays.asList(1, 2, 4, 3, 5)));\n\n        List<Integer> test2 = Arrays.asList(-2, -3, -4, -5, -6);\n        System.out.println(\"Test Case 2: \" + solution.sort_array(test2).equals(Arrays.asList(-4, -2, -6, -5, -3)));\n\n        List<Integer> test3 = Arrays.asList(1, 0, 2, 3, 4);\n        System.out.println(\"Test Case 3: \" + solution.sort_array(test3).equals(Arrays.asList(0, 1, 2, 4, 3)));\n    }\n}\n"}
{"task_id": "Java/117", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a string s and a natural number n, you have been tasked to implement\n     * a function that returns a list of all words from string s that contain exactly\n     * n consonants, in order these words appear in the string s.\n     * If the string s is empty then the function should return an empty list.\n     * Note: you may assume the input string contains only letters and spaces.\n     * Examples:\n     * select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n     * select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n     * select_words(\"simple white space\", 2) ==> []\n     * select_words(\"Hello world\", 4) ==> [\"world\"]\n     * select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\n     */\n    public List<String> select_words(String s, int n) {\n        if (s == null || s.isEmpty()) {\n            return new ArrayList<>();\n        }\n\n        String[] words = s.split(\"\\\\s+\");\n        List<String> result = new ArrayList<>();\n\n        for (String word : words) {\n            long consonantCount = word.toLowerCase().chars()\n                    .filter(c -> \"bcdfghjklmnpqrstvwxyz\".indexOf(c) != -1)\n                    .count();\n\n            if (consonantCount == n) {\n                result.add(word);\n            }\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.select_words(\"Mary had a little lamb\", 4)); // [\"little\"]\n        System.out.println(solution.select_words(\"Mary had a little lamb\", 3)); // [\"Mary\", \"lamb\"]\n        System.out.println(solution.select_words(\"simple white space\", 2));     // []\n        System.out.println(solution.select_words(\"Hello world\", 4));            // [\"world\"]\n        System.out.println(solution.select_words(\"Uncle sam\", 3));              // [\"Uncle\"]\n    }\n}\n"}
{"task_id": "Java/118", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * You are given a word. Your task is to find the closest vowel that stands between\n     * two consonants from the right side of the word (case sensitive).\n     *\n     * Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n     * find any vowel met the above condition.\n     *\n     * You may assume that the given string contains English letter only.\n     */\n    public String get_closest_vowel(String word) {\n        // Convert the input to a character array for easier manipulation\n        char[] chars = word.toCharArray();\n        \n        // Iterate from right to left, looking for vowels between consonants\n        for (int i = chars.length - 2; i > 0; i--) {\n            if (isVowel(chars[i]) && isConsonant(chars[i-1]) && isConsonant(chars[i+1])) {\n                return String.valueOf(chars[i]);\n            }\n        }\n        \n        // If no vowel found, return an empty string\n        return \"\";\n    }\n\n    private boolean isVowel(char c) {\n        return \"AEIOUaeiou\".indexOf(c) != -1;\n    }\n\n    private boolean isConsonant(char c) {\n        return !isVowel(c);\n    }\n    \n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.get_closest_vowel(\"yogurt\"));  // Output: \"u\"\n        System.out.println(solution.get_closest_vowel(\"FULL\"));    // Output: \"U\"\n        System.out.println(solution.get_closest_vowel(\"quick\"));   // Output: \"\"\n        System.out.println(solution.get_closest_vowel(\"ab\"));      // Output: \"\"\n        System.out.println(solution.get_closest_vowel(\"aBcDeFgHiJkLmNoPqRsTuVwXyZ\"));  // Output: \"u\"\n    }\n}\n"}
{"task_id": "Java/119", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    You are given a list of two strings, both strings consist of open\n    parentheses \"(\" or close parentheses \")\" only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string \"(())()\" is good, while the string\n    \"())\" is not.\n    Return \"Yes\" if there's a way to make a good string, and return \"No\" otherwise.\n\n    Examples:\n    match_parens(Arrays.asList(\"()(\", \")\")) == \"Yes\"\n    match_parens(Arrays.asList(\")\", \")\")) == \"No\"\n     */\n    public String match_parens(List<String> lst) {\n        // Helper function to check if a string is balanced\n        boolean isBalanced(String s) {\n            int balance = 0;\n            for (char c : s.toCharArray()) {\n                if (c == '(') {\n                    balance++;\n                } else if (c == ')') {\n                    balance--;\n                }\n                if (balance < 0) {\n                    return false; // Early return if unbalanced\n                }\n            }\n            return balance == 0;\n        }\n\n        // Check both possible concatenations\n        String concat1 = lst.get(0) + lst.get(1);\n        String concat2 = lst.get(1) + lst.get(0);\n\n        // Return \"Yes\" if either concatenation is balanced, otherwise \"No\"\n        return isBalanced(concat1) || isBalanced(concat2) ? \"Yes\" : \"No\";\n    }\n}\n"}
{"task_id": "Java/120", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     Given an array arr of integers and a positive integer k, return a sorted list\n     of length k with the maximum k numbers in arr, in ascending order.\n     */\n    public List<Integer> maximum(List<Integer> arr, int k) {\n        // Sort the array in descending order\n        Collections.sort(arr, Collections.reverseOrder());\n        \n        // Create a new list to store the top k elements\n        List<Integer> result = new ArrayList<>();\n        \n        // Add the first k elements from the sorted array to the result list\n        for (int i = 0; i < Math.min(k, arr.size()); i++) {\n            result.add(arr.get(i));\n        }\n        \n        // Sort the result list in ascending order before returning\n        Collections.sort(result);\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        List<Integer> arr1 = Arrays.asList(-3, -4, 5);\n        int k1 = 3;\n        System.out.println(\"Test Case 1: \" + solution.maximum(arr1, k1)); // Expected: [-4, -3, 5]\n\n        // Test case 2\n        List<Integer> arr2 = Arrays.asList(4, -4, 4);\n        int k2 = 2;\n        System.out.println(\"Test Case 2: \" + solution.maximum(arr2, k2)); // Expected: [4, 4]\n\n        // Test case 3\n        List<Integer> arr3 = Arrays.asList(-3, 2, 1, 2, -1, -2, 1);\n        int k3 = 1;\n        System.out.println(\"Test Case 3: \" + solution.maximum(arr3, k3)); // Expected: [2]\n    }\n}\n"}
{"task_id": "Java/121", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n     *\n     * Examples:\n     * solution(Arrays.asList(5, 8, 7, 1)) ==> 12\n     * solution(Arrays.asList(3, 3, 3, 3, 3)) ==> 9\n     * solution(Arrays.asList(30, 13, 24, 321)) ==> 0\n     */\n    public int solution(List<Integer> lst) {\n        int sum = 0;\n        for (int i = 0; i < lst.size(); i += 2) {\n            if (lst.get(i) % 2 != 0) {\n                sum += lst.get(i);\n            }\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.solution(Arrays.asList(5, 8, 7, 1))); // Expected output: 12\n        System.out.println(solution.solution(Arrays.asList(3, 3, 3, 3, 3))); // Expected output: 9\n        System.out.println(solution.solution(Arrays.asList(30, 13, 24, 321))); // Expected output: 0\n    }\n}\n"}
{"task_id": "Java/122", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     Given a non-empty array of integers arr and an integer k, return\n     the sum of the elements with at most two digits from the first k elements of arr.\n     \n     Example:\n     \n         Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n         Output: 24 # sum of 21 + 3\n     \n     Constraints:\n         1. 1 <= len(arr) <= 100\n         2. 1 <= k <= len(arr)\n      */\n    public int add_elements(List<Integer> arr, int k) {\n        int sum = 0;\n        for (int i = 0; i < Math.min(k, arr.size()); i++) {\n            if (arr.get(i).toString().length() <= 2) {\n                sum += arr.get(i);\n            }\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        List<Integer> arr1 = Arrays.asList(111, 21, 3, 4000, 5, 6, 7, 8, 9);\n        int k1 = 4;\n        System.out.println(\"Test Case 1: \" + solution.add_elements(arr1, k1)); // Expected output: 24\n\n        // Test case 2\n        List<Integer> arr2 = Arrays.asList(10, 20, 30, 40, 50);\n        int k2 = 3;\n        System.out.println(\"Test Case 2: \" + solution.add_elements(arr2, k2)); // Expected output: 60\n\n        // Test case 3\n        List<Integer> arr3 = Arrays.asList(1, 2, 3, 4, 5);\n        int k3 = 5;\n        System.out.println(\"Test Case 3: \" + solution.add_elements(arr3, k3)); // Expected output: 15\n\n        // Test case 4\n        List<Integer> arr4 = Arrays.asList(100, 200, 300);\n        int k4 = 2;\n        System.out.println(\"Test Case 4: \" + solution.add_elements(arr4, k4)); // Expected output: 0\n\n        // Test case 5\n        List<Integer> arr5 = Arrays.asList(1, 11, 111, 1111);\n        int k5 = 3;\n        System.out.println(\"Test Case 5: \" + solution.add_elements(arr5, k5)); // Expected output: 12\n\n    }\n}\n"}
{"task_id": "Java/123", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n     *\n     * @param n The starting positive integer for the Collatz sequence.\n     * @return A List of Integer containing the odd numbers in the Collatz sequence, sorted in increasing order.\n     */\n    public List<Integer> get_odd_collatz(int n) {\n        List<Integer> result = new ArrayList<>();\n        while (n != 1) {\n            if (n % 2 == 1) { // Check if n is odd\n                result.add(n);\n            }\n            n = n % 2 == 0 ? n / 2 : 3 * n + 1; // Apply Collatz rules\n        }\n        result.add(1); // Add the final term, which is always 1\n        Collections.sort(result); // Sort the list in increasing order\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.get_odd_collatz(5)); // Expected: [1, 5]\n        System.out.println(solution.get_odd_collatz(7)); // Expected: [1, 7, 11, 22]\n        System.out.println(solution.get_odd_collatz(10)); // Expected: [1, 5, 13]\n        System.out.println(solution.get_odd_collatz(1)); // Expected: [1]\n    }\n}\n"}
{"task_id": "Java/124", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * You have to write a function which validates a given date string and\n     * returns true if the date is valid otherwise false.\n     * The date is valid if all of the following rules are satisfied:\n     * 1. The date string is not empty.\n     * 2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.\n     * 3. The months should not be less than 1 or higher than 12.\n     * 4. The date should be in the format: mm-dd-yyyy\n     *\n     * for example:\n     * valid_date(\"03-11-2000\") => true\n     * valid_date(\"15-01-2012\") => false\n     * valid_date(\"04-0-2040\") => false\n     * valid_date(\"06-04-2020\") => true\n     * valid_date(\"06/04/2020\") => false\n     */\n    public boolean valid_date(String date) {\n        if (date == null || date.isEmpty()) return false;\n\n        String[] parts = date.split(\"-\");\n        if (parts.length != 3) return false;\n\n        int month = Integer.parseInt(parts[0]);\n        int day = Integer.parseInt(parts[1]);\n        int year = Integer.parseInt(parts[2]);\n\n        if (month < 1 || month > 12) return false;\n        if (day < 1 || day > 31) return false;\n\n        // Check for months with 30 days\n        if ((month == 4 || month == 6 || month == 9 || month == 11) && day > 30) return false;\n\n        // Check for February and leap years\n        if (month == 2) {\n            if (day > 29) return false;\n            if (day == 29 && !isLeapYear(year)) return false;\n        }\n\n        return true;\n    }\n\n    private boolean isLeapYear(int year) {\n        return (year % 4 == 0 && (year % 100 != 0 || year % 400 == 0));\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.valid_date(\"03-11-2000\")); // true\n        System.out.println(solution.valid_date(\"15-01-2012\")); // false\n        System.out.println(solution.valid_date(\"04-0-2040\"));  // false\n        System.out.println(solution.valid_date(\"06-04-2020\")); // true\n        System.out.println(solution.valid_date(\"06/04/2020\")); // false\n    }\n}\n"}
{"task_id": "Java/125", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n     should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n     alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n     Examples:\n     split_words(\"Hello world!\") == [\"Hello\", \"world!\"]\n     split_words(\"Hello,world!\") == [\"Hello\", \"world!\"]\n     split_words(\"abcdef\") == 3\n     */\n    public Object split_words(String txt) {\n        if (txt.contains(\" \")) {\n            return Arrays.asList(txt.split(\"\\\\s+\"));\n        } else if (txt.contains(\",\")) {\n            return Arrays.asList(txt.split(\",\"));\n        } else {\n            int count = 0;\n            for (char c : txt.toCharArray()) {\n                if (Character.isLowerCase(c) && ((c - 'a') % 2 == 1)) {\n                    count++;\n                }\n            }\n            return count;\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.split_words(\"Hello world!\")); // [\"Hello\", \"world!\"]\n        System.out.println(solution.split_words(\"Hello,world!\")); // [\"Hello\", \"world!\"]\n        System.out.println(solution.split_words(\"abcdef\"));      // 3\n\n        // Additional test cases\n        System.out.println(solution.split_words(\"a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z\")); // 13\n        System.out.println(solution.split_words(\"A quick, brown fox!\")); // [\"A\", \"quick,\", \"brown\", \"fox!\"]\n        System.out.println(solution.split_words(\"noSpacesOrCommas\")); // 5\n    }\n}\n"}
{"task_id": "Java/126", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given a list of numbers, return whether or not they are sorted in ascending order.\n     * If the number appears more than twice, return false. Assume no negative numbers and only integers.\n     *\n     * Examples:\n     * is_sorted(Arrays.asList(5)) -> true\n     * is_sorted(Arrays.asList(1, 2, 3, 4, 5)) -> true\n     * is_sorted(Arrays.asList(1, 3, 2, 4, 5)) -> false\n     * is_sorted(Arrays.asList(1, 2, 3, 4, 5, 6)) -> true\n     * is_sorted(Arrays.asList(1, 2, 3, 4, 5, 6, 7)) -> true\n     * is_sorted(Arrays.asList(1, 3, 2, 4, 5, 6, 7)) -> false\n     * is_sorted(Arrays.asList(1, 2, 2, 3, 3, 4)) -> true\n     * is_sorted(Arrays.asList(1, 2, 2, 2, 3, 4)) -> false\n     */\n    public boolean is_sorted(List<Integer> lst) {\n        if (lst == null || lst.size() <= 1) {\n            return true;\n        }\n\n        int count = 1; // To keep track of consecutive duplicates\n\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i).equals(lst.get(i - 1))) {\n                count++;\n                if (count > 2) {\n                    return false;\n                }\n            } else {\n                count = 1;\n            }\n\n            if (lst.get(i) < lst.get(i - 1)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.is_sorted(Arrays.asList(5))); // true\n        System.out.println(solution.is_sorted(Arrays.asList(1, 2, 3, 4, 5))); // true\n        System.out.println(solution.is_sorted(Arrays.asList(1, 3, 2, 4, 5))); // false\n        System.out.println(solution.is_sorted(Arrays.asList(1, 2, 3, 4, 5, 6))); // true\n        System.out.println(solution.is_sorted(Arrays.asList(1, 2, 3, 4, 5, 6, 7))); // true\n        System.out.println(solution.is_sorted(Arrays.asList(1, 3, 2, 4, 5, 6, 7))); // false\n        System.out.println(solution.is_sorted(Arrays.asList(1, 2, 2, 3, 3, 4))); // true\n        System.out.println(solution.is_sorted(Arrays.asList(1, 2, 2, 2, 3, 4))); // false\n    }\n}\n"}
{"task_id": "Java/127", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public String intersection(List<Integer> interval1, List<Integer> interval2) {\n        int start = Math.max(interval1.get(0), interval2.get(0));\n        int end = Math.min(interval1.get(1), interval2.get(1));\n\n        if (start > end) {\n            return \"NO\";\n        }\n\n        int length = end - start + 1;\n        boolean isPrime = isPrime(length);\n        \n        if (isPrime) {\n            return \"YES\";\n        } else {\n            return \"NO\";\n        }\n    }\n\n    private boolean isPrime(int n) {\n        if (n <= 1) {\n            return false;\n        }\n        for (int i = 2; i * i <= n; i++) {\n            if (n % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n"}
{"task_id": "Java/128", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * You are given an array arr of integers and you need to return\n     * sum of magnitudes of integers multiplied by product of all signs\n     * of each number in the array, represented by 1, -1 or 0.\n     * Note: return None for empty arr.\n     *\n     * Example:\n     * >>> prod_signs(Arrays.asList(1, 2, 2, -4)) == -9\n     * >>> prod_signs(Arrays.asList(0, 1)) == 0\n     * >>> prod_signs(Arrays.asList()) == Optional.empty()\n     */\n    public Optional<Integer> prod_signs(List<Integer> arr) {\n        if (arr.isEmpty()) {\n            return Optional.empty();\n        }\n\n        int sumOfMagnitudes = 0;\n        int productOfSigns = 1;\n\n        for (Integer num : arr) {\n            sumOfMagnitudes += Math.abs(num);\n            if (num == 0) {\n                productOfSigns = 0;\n                break;\n            } else if (num < 0) {\n                productOfSigns *= -1;\n            }\n        }\n\n        return Optional.of(sumOfMagnitudes * productOfSigns);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.prod_signs(Arrays.asList(1, 2, 2, -4))); // Expected output: Optional[-9]\n        System.out.println(solution.prod_signs(Arrays.asList(0, 1)));        // Expected output: Optional[0]\n        System.out.println(solution.prod_signs(Arrays.asList()));           // Expected output: Optional.empty\n    }\n}\n"}
{"task_id": "Java/129", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> minPath(List<List<Integer>> grid, int k) {\n        int n = grid.size();\n        \n        // Initialize a priority queue (min-heap)\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> Integer.compare(a[0], b[0]));\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                pq.offer(new int[]{grid.get(i).get(j), i, j});\n            }\n        }\n\n        // Directions: up, down, left, right\n        int[][] directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n        Set<String> visited = new HashSet<>();\n        \n        List<Integer> path = new ArrayList<>();\n        while (!pq.isEmpty() && path.size() < k) {\n            int[] top = pq.poll();\n            int value = top[0];\n            int x = top[1];\n            int y = top[2];\n            \n            if (visited.contains(x + \",\" + y)) {\n                continue;\n            }\n            visited.add(x + \",\" + y);\n            path.add(value);\n            \n            for (int[] dir : directions) {\n                int nx = x + dir[0];\n                int ny = y + dir[1];\n                \n                if (nx >= 0 && nx < n && ny >= 0 && ny < n && !visited.contains(nx + \",\" + ny)) {\n                    pq.offer(new int[]{grid.get(nx).get(ny), nx, ny});\n                }\n            }\n        }\n        \n        return path;\n    }\n}\n"}
{"task_id": "Java/130", "generation": "import java.util.ArrayList;\nimport java.util.List;\n\nclass Solution {\n    public List<Integer> tri(int n) {\n        if (n == 0) {\n            return new ArrayList<>();\n        }\n        \n        List<Integer> sequence = new ArrayList<>();\n        sequence.add(3); // tri(1)\n        \n        for (int i = 2; i <= n + 1; i++) {\n            int nextValue;\n            if (i % 2 == 0) {\n                nextValue = 1 + (i / 2);\n            } else {\n                nextValue = sequence.get(i - 2) + sequence.get(i - 3) + sequence.get(0);\n            }\n            sequence.add(nextValue);\n        }\n        \n        return sequence;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.tri(3)); // Output: [3, 2, 8]\n    }\n}\n"}
{"task_id": "Java/131", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     Given a positive integer n, return the product of the odd digits.\n     Return 0 if all digits are even.\n     For example:\n     digits(1)  == 1\n     digits(4)  == 0\n     digits(235) == 15\n     */\n    public int digits(int n) {\n        int product = 1;\n        boolean hasOddDigit = false;\n\n        while (n > 0) {\n            int digit = n % 10;\n            if (digit % 2 != 0) {\n                product *= digit;\n                hasOddDigit = true;\n            }\n            n /= 10;\n        }\n\n        return hasOddDigit ? product : 0;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.digits(1));   // Output: 1\n        System.out.println(solution.digits(4));   // Output: 0\n        System.out.println(solution.digits(235)); // Output: 15\n        System.out.println(solution.digits(2468)); // Output: 0\n        System.out.println(solution.digits(13579)); // Output: 945\n    }\n}\n"}
{"task_id": "Java/132", "generation": "import java.util.*;\n\nclass Solution {\n    public boolean is_nested(String string) {\n        Deque<Character> stack = new ArrayDeque<>();\n        boolean nested = false;\n        \n        for (char c : string.toCharArray()) {\n            if (c == '[') {\n                stack.push(c);\n            } else if (c == ']') {\n                if (!stack.isEmpty()) {\n                    stack.pop();\n                    nested = true;\n                } else {\n                    return false;\n                }\n            }\n        }\n        \n        return nested && stack.isEmpty();\n    }\n}\n"}
{"task_id": "Java/133", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int sum_squares(List<Double> lst) {\n        int sum = 0;\n        for (Double num : lst) {\n            // Round up to the nearest integer\n            double roundedNum = Math.ceil(num);\n            // Square the rounded number and add it to the sum\n            sum += (int) Math.pow(roundedNum, 2);\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.sum_squares(Arrays.asList(1.0, 2.0, 3.0))); // Output: 14\n        System.out.println(solution.sum_squares(Arrays.asList(1.0, 4.0, 9.0))); // Output: 98\n        System.out.println(solution.sum_squares(Arrays.asList(1.0, 3.0, 5.0, 7.0))); // Output: 84\n        System.out.println(solution.sum_squares(Arrays.asList(1.4, 4.2, 0.0))); // Output: 29\n        System.out.println(solution.sum_squares(Arrays.asList(-2.4, 1.0, 1.0))); // Output: 6\n    }\n}\n"}
{"task_id": "Java/134", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Create a function that returns true if the last character\n    of a given string is an alphabetical character and is not\n    a part of a word, and false otherwise.\n    Note: \"word\" is a group of characters separated by space.\n\n    Examples:\n    check_if_last_char_is_a_letter(\"apple pie\") -> false\n    check_if_last_char_is_a_letter(\"apple pi e\") -> true\n    check_if_last_char_is_a_letter(\"apple pi e \") -> false\n    check_if_last_char_is_a_letter(\"\") -> false\n     */\n    public boolean check_if_last_char_is_a_letter(String txt) {\n        if (txt == null || txt.isEmpty()) {\n            return false;\n        }\n\n        char lastChar = txt.charAt(txt.length() - 1);\n\n        // Check if the last character is an alphabetical letter and either:\n        // 1. The last character itself is a space.\n        // 2. The second-to-last character is a space.\n        boolean isLastCharAlphabetical = Character.isLetter(lastChar);\n        boolean isLastCharSpaceOrPrecededBySpace = (lastChar == ' ') || (txt.length() > 1 && txt.charAt(txt.length() - 2) == ' ');\n\n        return isLastCharAlphabetical && isLastCharSpaceOrPrecededBySpace;\n    }\n}\n"}
{"task_id": "Java/135", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Create a function which returns the largest index of an element which\n    is not greater than or equal to the element immediately preceding it. If\n    no such element exists then return -1. The given array will not contain\n    duplicate values.\n\n    Examples:\n    can_arrange(Arrays.asList(1,2,4,3,5)) = 3\n    can_arrange(Arrays.asList(1,2,3)) = -1\n     */\n    public int can_arrange(List<Integer> arr) {\n        int n = arr.size();\n        for (int i = 1; i < n; i++) {\n            if (arr.get(i) < arr.get(i - 1)) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.can_arrange(Arrays.asList(1, 2, 4, 3, 5))); // Expected output: 3\n        System.out.println(solution.can_arrange(Arrays.asList(1, 2, 3)));       // Expected output: -1\n    }\n}\n"}
{"task_id": "Java/136", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Create a function that returns a tuple (a, b), where 'a' is\n     * the largest of negative integers, and 'b' is the smallest\n     * of positive integers in a list.\n     * If there is no negative or positive integers, return them as None.\n     *\n     * Examples:\n     * largest_smallest_integers(Arrays.asList(2, 4, 1, 3, 5, 7)) == (Optional.empty(), Optional.of(1))\n     * largest_smallest_integers(Arrays.asList()) == (Optional.empty(), Optional.empty())\n     * largest_smallest_integers(Arrays.asList(0)) == (Optional.empty(), Optional.empty())\n     */\n    public List<Optional<Integer>> largest_smallest_integers(List<Integer> lst) {\n        if (lst.isEmpty()) {\n            return Arrays.asList(Optional.empty(), Optional.empty());\n        }\n\n        Optional<Integer> smallestPositive = lst.stream()\n                .filter(n -> n > 0)\n                .min(Integer::compare);\n\n        Optional<Integer> largestNegative = lst.stream()\n                .filter(n -> n < 0)\n                .max(Integer::compare);\n\n        return Arrays.asList(largestNegative, smallestPositive);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.largest_smallest_integers(Arrays.asList(2, 4, 1, 3, 5, 7))); // (Optional.empty(), Optional.of(1))\n        System.out.println(solution.largest_smallest_integers(Arrays.asList()));                // (Optional.empty(), Optional.empty())\n        System.out.println(solution.largest_smallest_integers(Arrays.asList(0)));               // (Optional.empty(), Optional.empty())\n        System.out.println(solution.largest_smallest_integers(Arrays.asList(-2, -4, -1, -3)));  // (Optional.of(-1), Optional.empty())\n        System.out.println(solution.largest_smallest_integers(Arrays.asList(2, -4, 1, -3, 5))); // (Optional.empty(), Optional.of(1))\n    }\n}\n"}
{"task_id": "Java/137", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public Optional<Object> compare_one(Object a, Object b) {\n        if (a instanceof Integer && b instanceof Integer) {\n            int ai = (Integer) a;\n            int bi = (Integer) b;\n            return Optional.of(ai > bi ? a : null);\n        } else if (a instanceof Double && b instanceof Double) {\n            double ad = (Double) a;\n            double bd = (Double) b;\n            return Optional.of(ad > bd ? a : null);\n        } else if (a instanceof String && b instanceof String) {\n            String astr = ((String) a).replace(',', '.');\n            String bstr = ((String) b).replace(',', '.');\n            double ad = Double.parseDouble(astr);\n            double bd = Double.parseDouble(bstr);\n            return Optional.of(ad > bd ? a : null);\n        } else {\n            throw new IllegalArgumentException(\"Both values must be of the same type (Integer, Double, or String)\");\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.compare_one(1, 2.5)); // Optional[2.5]\n        System.out.println(solution.compare_one(1, \"2,3\")); // Optional[\"2,3\"]\n        System.out.println(solution.compare_one(\"5,1\", \"6\")); // Optional[\"6\"]\n        System.out.println(solution.compare_one(\"1\", 1)); // Optional.empty\n    }\n}\n"}
{"task_id": "Java/138", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers\n     * Example:\n     * is_equal_to_sum_even(4) == false\n     * is_equal_to_sum_even(6) == false\n     * is_equal_to_sum_even(8) == true\n     */\n    public boolean is_equal_to_sum_even(int n) {\n        // The smallest sum of 4 positive even numbers is 2 + 2 + 2 + 2 = 8.\n        if (n < 8 || n % 2 != 0) {\n            return false;\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(\"is_equal_to_sum_even(4): \" + solution.is_equal_to_sum_even(4)); // false\n        System.out.println(\"is_equal_to_sum_even(6): \" + solution.is_equal_to_sum_even(6)); // false\n        System.out.println(\"is_equal_to_sum_even(8): \" + solution.is_equal_to_sum_even(8)); // true\n        System.out.println(\"is_equal_to_sum_even(10): \" + solution.is_equal_to_sum_even(10)); // true\n        System.out.println(\"is_equal_to_sum_even(12): \" + solution.is_equal_to_sum_even(12)); // true\n        System.out.println(\"is_equal_to_sum_even(14): \" + solution.is_equal_to_sum_even(14)); // true\n        System.out.println(\"is_equal_to_sum_even(16): \" + solution.is_equal_to_sum_even(16)); // true\n        System.out.println(\"is_equal_to_sum_even(7): \" + solution.is_equal_to_sum_even(7)); // false\n    }\n}\n"}
{"task_id": "Java/139", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * The Brazilian factorial is defined as:\n     * brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n     * where n > 0\n     *\n     * For example:\n     * >>> special_factorial(4)\n     * 288\n     *\n     * The function will receive an integer as input and should return the special factorial of this integer.\n     */\n    public long special_factorial(int n) {\n        if (n == 0 || n == 1) {\n            return 1;\n        }\n        \n        long result = 1;\n        for (int i = 1; i <= n; i++) {\n            result *= factorial(i);\n        }\n        return result;\n    }\n\n    private long factorial(int num) {\n        if (num == 0 || num == 1) {\n            return 1;\n        }\n        \n        long fact = 1;\n        for (int i = 2; i <= num; i++) {\n            fact *= i;\n        }\n        return fact;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(\"special_factorial(4): \" + solution.special_factorial(4)); // Expected: 288\n        System.out.println(\"special_factorial(3): \" + solution.special_factorial(3)); // Expected: 12\n        System.out.println(\"special_factorial(5): \" + solution.special_factorial(5)); // Expected: 34560\n        System.out.println(\"special_factorial(1): \" + solution.special_factorial(1)); // Expected: 1\n    }\n}\n"}
{"task_id": "Java/140", "generation": "import java.util.*;\n\nclass Solution {\n    public String fix_spaces(String text) {\n        StringBuilder result = new StringBuilder();\n        int spaceCount = 0;\n        \n        for (char c : text.toCharArray()) {\n            if (c == ' ') {\n                spaceCount++;\n            } else {\n                if (spaceCount > 2) {\n                    result.append('-');\n                } else if (spaceCount >= 1) {\n                    for (int i = 0; i < spaceCount; i++) {\n                        result.append('_');\n                    }\n                }\n                result.append(c);\n                spaceCount = 0;\n            }\n        }\n\n        // Handle trailing spaces\n        if (spaceCount > 2) {\n            result.append('-');\n        } else if (spaceCount >= 1) {\n            for (int i = 0; i < spaceCount; i++) {\n                result.append('_');\n            }\n        }\n\n        return result.toString();\n    }\n}\n"}
{"task_id": "Java/141", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Create a function which takes a string representing a file's name, and returns\n     * \"Yes\" if the the file's name is valid, and returns \"No\" otherwise.\n     * A file's name is considered to be valid if and only if all the following conditions\n     * are met:\n     * - There should not be more than three digits ('0'-'9') in the file's name.\n     * - The file's name contains exactly one dot '.'\n     * - The substring before the dot should not be empty, and it starts with a letter from\n     *   the latin alphapet ('a'-'z' and 'A'-'Z').\n     * - The substring after the dot should be one of these: [\"txt\", \"exe\", \"dll\"]\n     * Examples:\n     * file_name_check(\"example.txt\") # => \"Yes\"\n     * file_name_check(\"1example.dll\") # => \"No\" (the name should start with a latin alphapet letter)\n     */\n    public String file_name_check(String file_name) {\n        // Check for exactly one dot\n        int dotCount = 0;\n        for (char c : file_name.toCharArray()) {\n            if (c == '.') {\n                dotCount++;\n            }\n        }\n        if (dotCount != 1) return \"No\";\n\n        // Split the filename into two parts: before and after the dot\n        String[] parts = file_name.split(\"\\\\.\");\n        if (parts.length != 2) return \"No\"; // Should have exactly one dot\n\n        // Check for empty part before the dot\n        if (parts[0].isEmpty()) return \"No\";\n\n        // Check if the first character is a letter\n        char firstChar = parts[0].charAt(0);\n        if (!Character.isLetter(firstChar)) return \"No\";\n\n        // Check for more than three digits in the file name\n        int digitCount = 0;\n        for (char c : file_name.toCharArray()) {\n            if (Character.isDigit(c)) {\n                digitCount++;\n            }\n        }\n        if (digitCount > 3) return \"No\";\n\n        // Check the extension part after the dot\n        String ext = parts[1];\n        if (!ext.equals(\"txt\") && !ext.equals(\"exe\") && !ext.equals(\"dll\")) return \"No\";\n\n        return \"Yes\";\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.file_name_check(\"example.txt\"));  // Expected: Yes\n        System.out.println(solution.file_name_check(\"1example.dll\")); // Expected: No (starts with a digit)\n        System.out.println(solution.file_name_check(\".txt\"));         // Expected: No (empty part before the dot)\n        System.out.println(solution.file_name_check(\"example.exe\"));  // Expected: Yes\n        System.out.println(solution.file_name_check(\"example123.dll\"));// Expected: Yes\n        System.out.println(solution.file_name_check(\"example4567.dll\"));// Expected: No (more than three digits)\n    }\n}\n"}
{"task_id": "Java/142", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    This function will take a list of integers. For all entries in the list, the function shall square the integer entry if its index is a\n    multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not\n    change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries.\n\n    Examples:\n    For lst = [1,2,3] the output should be 6\n    For lst = []  the output should be 0\n    For lst = [-1,-5,2,-1,-5]  the output should be -126\n     */\n    public int sumSquares(List<Integer> lst) {\n        int totalSum = 0;\n        for (int i = 0; i < lst.size(); i++) {\n            if (i % 3 == 0 && i != 0) {\n                totalSum += Math.pow(lst.get(i), 2);\n            } else if (i % 4 == 0 && i % 3 != 0) {\n                totalSum += Math.pow(lst.get(i), 3);\n            } else {\n                totalSum += lst.get(i);\n            }\n        }\n        return totalSum;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.sumSquares(Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12)));\n    }\n}\n"}
{"task_id": "Java/143", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * You are given a string representing a sentence,\n     * the sentence contains some words separated by a space,\n     * and you have to return a string that contains the words from the original sentence,\n     * whose lengths are prime numbers,\n     * the order of the words in the new string should be the same as the original one.\n     *\n     * Example 1:\n     * Input: sentence = \"This is a test\"\n     * Output: \"is\"\n     *\n     * Example 2:\n     * Input: sentence = \"lets go for swimming\"\n     * Output: \"go for\"\n     *\n     * Constraints:\n     * * 1 <= len(sentence) <= 100\n     * * sentence contains only letters\n     */\n    public String words_in_sentence(String sentence) {\n        List<String> words = Arrays.asList(sentence.split(\" \"));\n        StringBuilder result = new StringBuilder();\n        \n        for (String word : words) {\n            if (isPrime(word.length())) {\n                if (result.length() > 0) {\n                    result.append(\" \");\n                }\n                result.append(word);\n            }\n        }\n        \n        return result.toString();\n    }\n\n    private boolean isPrime(int number) {\n        if (number <= 1) {\n            return false;\n        }\n        for (int i = 2; i * i <= number; i++) {\n            if (number % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.words_in_sentence(\"This is a test\")); // Output: \"is\"\n        System.out.println(solution.words_in_sentence(\"lets go for swimming\")); // Output: \"go for\"\n        System.out.println(solution.words_in_sentence(\"one two three four five six seven eight nine ten\")); // Output: \"three five seven\"\n    }\n}\n"}
{"task_id": "Java/144", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Your task is to implement a function that will simplify the expression\n     * x * n. The function returns true if x * n evaluates to a whole number and false\n     * otherwise. Both x and n, are string representation of a fraction, and have the following format,\n     * <numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n     *\n     * You can assume that x, and n are valid fractions, and do not have zero as denominator.\n     */\n    public boolean simplify(String x, String n) {\n        // Split the strings into numerator and denominator\n        String[] xParts = x.split(\"/\");\n        String[] nParts = n.split(\"/\");\n\n        int xNumerator = Integer.parseInt(xParts[0]);\n        int xDenominator = Integer.parseInt(xParts[1]);\n        int nNumerator = Integer.parseInt(nParts[0]);\n        int nDenominator = Integer.parseInt(nParts[1]);\n\n        // Simplify the expression (x * n) / 1\n        int resultNumerator = xNumerator * nNumerator;\n        int resultDenominator = xDenominator * nDenominator;\n\n        // Check if the result is a whole number\n        return resultNumerator % resultDenominator == 0;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.simplify(\"1/5\", \"5/1\")); // true\n        System.out.println(solution.simplify(\"1/6\", \"2/1\")); // false\n        System.out.println(solution.simplify(\"7/10\", \"10/2\")); // false\n        System.out.println(solution.simplify(\"3/4\", \"4/3\")); // true\n        System.out.println(solution.simplify(\"5/8\", \"8/5\")); // true\n        System.out.println(solution.simplify(\"9/16\", \"16/9\")); // true\n    }\n}\n"}
{"task_id": "Java/145", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> order_by_points(List<Integer> nums) {\n        Collections.sort(nums, new Comparator<Integer>() {\n            @Override\n            public int compare(Integer o1, Integer o2) {\n                int sum1 = digitSum(o1);\n                int sum2 = digitSum(o2);\n                \n                if (sum1 == sum2) {\n                    return nums.indexOf(o1) - nums.indexOf(o2);\n                }\n                return sum1 - sum2;\n            }\n        });\n        return nums;\n    }\n\n    private int digitSum(Integer n) {\n        boolean isNegative = n < 0;\n        String numStr = Integer.toString(n);\n        int sum = 0;\n        for (int i = 0; i < numStr.length(); i++) {\n            if (i == 0 && isNegative) {\n                continue; // Skip the negative sign\n            }\n            sum += Character.getNumericValue(numStr.charAt(i));\n        }\n        return sum + (isNegative ? 1 : 0);\n    }\n}\n"}
{"task_id": "Java/146", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Write a function that takes an array of numbers as input and returns\n     * the number of elements in the array that are greater than 10 and both\n     * first and last digits of a number are odd (1, 3, 5, 7, 9).\n     * For example:\n     * specialFilter(Arrays.asList(15, -73, 14, -15)) => 1\n     * specialFilter(Arrays.asList(33, -2, -3, 45, 21, 109)) => 2\n     */\n    public int specialFilter(List<Integer> nums) {\n        int count = 0;\n        for (int num : nums) {\n            if (num > 10 && isFirstAndLastDigitOdd(num)) {\n                count++;\n            }\n        }\n        return count;\n    }\n\n    private boolean isFirstAndLastDigitOdd(int num) {\n        String strNum = Integer.toString(Math.abs(num));\n        int firstDigit = Character.digit(strNum.charAt(0), 10);\n        int lastDigit = Character.digit(strNum.charAt(strNum.length() - 1), 10);\n\n        return (firstDigit % 2 != 0) && (lastDigit % 2 != 0);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.specialFilter(Arrays.asList(15, -73, 14, -15))); // Expected output: 1\n        System.out.println(solution.specialFilter(Arrays.asList(33, -2, -3, 45, 21, 109))); // Expected output: 2\n        System.out.println(solution.specialFilter(Arrays.asList(-73, 14, 15, -15, 33, 45, 21, 109))); // Expected output: 3\n    }\n}\n"}
{"task_id": "Java/147", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * You are given a positive integer n. You have to create an integer array a of length n.\n     * For each i (1 <= i <= n), the value of a[i] = i * i - i + 1.\n     * Return the number of triples (a[i], a[j], a[k]) of a where i < j < k,\n     * and a[i] + a[j] + a[k] is a multiple of 3.\n     *\n     * Example :\n     * Input: n = 5\n     * Output: 1\n     * Explanation:\n     * a = [1, 3, 7, 13, 21]\n     * The only valid triple is (1, 7, 13).\n     */\n    public int get_max_triples(int n) {\n        List<Integer> a = new ArrayList<>();\n        \n        // Generate the array a\n        for (int i = 1; i <= n; i++) {\n            a.add(i * i - i + 1);\n        }\n        \n        int count = 0;\n        \n        // Iterate through all possible triples (i, j, k) where i < j < k\n        for (int i = 0; i < n - 2; i++) {\n            for (int j = i + 1; j < n - 1; j++) {\n                for (int k = j + 1; k < n; k++) {\n                    if ((a.get(i) + a.get(j) + a.get(k)) % 3 == 0) {\n                        count++;\n                    }\n                }\n            }\n        }\n        \n        return count;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.get_max_triples(5)); // Expected output: 1\n        System.out.println(solution.get_max_triples(6)); // Expected output: 2\n        System.out.println(solution.get_max_triples(7)); // Expected output: 3\n    }\n}\n"}
{"task_id": "Java/148", "generation": "import java.util.*;\n\nclass Solution {\n    public List<String> bf(String planet1, String planet2) {\n        List<String> planets = Arrays.asList(\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\");\n        \n        if (!planets.contains(planet1) || !planets.contains(planet2)) {\n            return new ArrayList<>();\n        }\n        \n        int start = planets.indexOf(planet1);\n        int end = planets.indexOf(planet2);\n        \n        // Ensure the correct order\n        if (start > end) {\n            Collections.swap(planets, start, end);\n            Collections.sort(planets.subList(start + 1, end));\n        }\n        \n        List<String> result = new ArrayList<>();\n        for (int i = start + 1; i < end; i++) {\n            result.add(planets.get(i));\n        }\n        \n        return result;\n    }\n}\n"}
{"task_id": "Java/149", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Write a function that accepts a list of strings as a parameter,\n     * deletes the strings that have odd lengths from it,\n     * and returns the resulted list with a sorted order.\n     * The list is always a list of strings and never an array of numbers,\n     * and it may contain duplicates.\n     * The order of the list should be ascending by length of each word, and you\n     * should return the list sorted by that rule.\n     * If two words have the same length, sort the list alphabetically.\n     * The function should return a list of strings in sorted order.\n     * You may assume that all words will have the same length.\n     * For example:\n     * assert sorted_list_sum(Arrays.asList(\"aa\", \"a\", \"aaa\")) => [\"aa\"]\n     * assert sorted_list_sum(Arrays.asList(\"ab\", \"a\", \"aaa\", \"cd\")) => [\"ab\", \"cd\"]\n     */\n    public List<String> sorted_list_sum(List<String> lst) {\n        // Remove strings with odd lengths\n        lst.removeIf(s -> s.length() % 2 != 0);\n\n        // Sort the list by length, then alphabetically if lengths are equal\n        Collections.sort(lst, (s1, s2) -> {\n            int lenCompare = Integer.compare(s1.length(), s2.length());\n            return lenCompare == 0 ? s1.compareTo(s2) : lenCompare;\n        });\n\n        return lst;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        List<String> test1 = Arrays.asList(\"aa\", \"a\", \"aaa\");\n        System.out.println(solution.sorted_list_sum(test1)); // Expected: [aa]\n\n        List<String> test2 = Arrays.asList(\"ab\", \"a\", \"aaa\", \"cd\");\n        System.out.println(solution.sorted_list_sum(test2)); // Expected: [ab, cd]\n\n        List<String> test3 = Arrays.asList(\"hello\", \"world\", \"hi\", \"bye\");\n        System.out.println(solution.sorted_list_sum(test3)); // Expected: [hi, bye]\n    }\n}\n"}
{"task_id": "Java/150", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * A simple program which should return the value of x if n is\n     * a prime number and should return the value of y otherwise.\n     *\n     * Examples:\n     * for x_or_y(7, 34, 12) == 34\n     * for x_or_y(15, 8, 5) == 5\n     */\n    public int x_or_y(int n, int x, int y) {\n        if (isPrime(n)) {\n            return x;\n        } else {\n            return y;\n        }\n    }\n\n    /**\n     * Helper method to check if a number is prime.\n     *\n     * @param num the number to check\n     * @return true if the number is prime, false otherwise\n     */\n    private boolean isPrime(int num) {\n        if (num <= 1) return false;\n        for (int i = 2; i <= Math.sqrt(num); i++) {\n            if (num % i == 0) return false;\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.x_or_y(7, 34, 12)); // Expected output: 34 (since 7 is prime)\n        System.out.println(solution.x_or_y(15, 8, 5));  // Expected output: 5 (since 15 is not prime)\n        System.out.println(solution.x_or_y(2, 10, 20)); // Expected output: 10 (since 2 is prime)\n        System.out.println(solution.x_or_y(4, 30, 40)); // Expected output: 40 (since 4 is not prime)\n    }\n}\n"}
{"task_id": "Java/151", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     Given a list of numbers, return the sum of squares of the numbers\n     in the list that are odd. Ignore numbers that are negative or not integers.\n     */\n    public int double_the_difference(List<Object> lst) {\n        int result = 0;\n        for (Object obj : lst) {\n            if (obj instanceof Integer) {\n                int num = (Integer) obj;\n                if (num > 0 && num % 2 != 0) {\n                    result += num * num;\n                }\n            }\n        }\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.double_the_difference(Arrays.asList(1, 3, 2, 0))); // Expected output: 10\n        System.out.println(solution.double_the_difference(Arrays.asList(-1, -2, 0))); // Expected output: 0\n        System.out.println(solution.double_the_difference(Arrays.asList(9, -2)));      // Expected output: 81\n        System.out.println(solution.double_the_difference(Arrays.asList(0)));          // Expected output: 0\n        System.out.println(solution.double_the_difference(new ArrayList<>()));         // Expected output: 0\n    }\n}\n"}
{"task_id": "Java/152", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Compares the game scores with the guesses and returns an array of how far off each guess was.\n     *\n     * @param game  A list of integers representing the actual game scores.\n     * @param guess A list of integers representing the guessed scores.\n     * @return A list of integers where each element is the absolute difference between the guess and the score, or 0 if they are equal.\n     */\n    public List<Integer> compare(List<Integer> game, List<Integer> guess) {\n        List<Integer> result = new ArrayList<>();\n        for (int i = 0; i < game.size(); i++) {\n            int diff = Math.abs(game.get(i) - guess.get(i));\n            result.add(diff);\n        }\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        List<Integer> test1Game = Arrays.asList(1, 2, 3, 4, 5, 1);\n        List<Integer> test1Guess = Arrays.asList(1, 2, 3, 4, 2, -2);\n        System.out.println(solution.compare(test1Game, test1Guess)); // Expected: [0, 0, 0, 0, 3, 3]\n\n        List<Integer> test2Game = Arrays.asList(0, 5, 0, 0, 0, 4);\n        List<Integer> test2Guess = Arrays.asList(4, 1, 1, 0, 0, -2);\n        System.out.println(solution.compare(test2Game, test2Guess)); // Expected: [4, 4, 1, 0, 0, 6]\n    }\n}\n"}
{"task_id": "Java/153", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * You will be given the name of a class (a string) and a list of extensions.\n     * The extensions are to be used to load additional classes to the class. The\n     * strength of the extension is as follows: Let CAP be the number of the uppercase\n     * letters in the extension's name, and let SM be the number of lowercase letters\n     * in the extension's name, the strength is given by the fraction CAP - SM.\n     * You should find the strongest extension and return a string in this\n     * format: ClassName.Strongest_Extension.\n     * If there are two or more extensions with the same strength, you should\n     * choose the one that comes first in the list.\n     * For example, if you are given \"Slices\" as the class and a list of the\n     * extensions: [\"SErviNGSliCes\", \"Cheese\", \"StuFfed\"] then you should\n     * return \"Slices.SErviNGSliCes\" since \"SErviNGSliCes\" is the strongest extension\n     * (its strength is -1).\n     * Example:\n     * for Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"]) == \"my_class.AA\"\n     */\n    public String Strongest_Extension(String class_name, List<String> extensions) {\n        int maxStrength = Integer.MIN_VALUE;\n        String strongestExtension = \"\";\n        \n        for (String extension : extensions) {\n            int cap = 0, sm = 0;\n            for (char c : extension.toCharArray()) {\n                if (Character.isUpperCase(c)) {\n                    cap++;\n                } else if (Character.isLowerCase(c)) {\n                    sm++;\n                }\n            }\n            \n            int strength = cap - sm;\n            if (strength > maxStrength) {\n                maxStrength = strength;\n                strongestExtension = extension;\n            }\n        }\n        \n        return class_name + \".\" + strongestExtension;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.Strongest_Extension(\"Slices\", Arrays.asList(\"SErviNGSliCes\", \"Cheese\", \"StuFfed\"))); // Should print: Slices.SErviNGSliCes\n        System.out.println(solution.Strongest_Extension(\"my_class\", Arrays.asList(\"AA\", \"Be\", \"CC\"))); // Should print: my_class.AA\n        System.out.println(solution.Strongest_Extension(\"DataProcessor\", Arrays.asList(\"dataIO\", \"DATAIO\", \"dataio\"))); // Should print: DataProcessor.DATAIO\n    }\n}\n"}
{"task_id": "Java/154", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * You are given 2 words. You need to return true if the second word or any of its rotations is a substring in the first word.\n     * cycpattern_check(\"abcd\",\"abd\") => false\n     * cycpattern_check(\"hello\",\"ell\") => true\n     * cycpattern_check(\"whassup\",\"psus\") => false\n     * cycpattern_check(\"abab\",\"baa\") => true\n     * cycpattern_check(\"efef\",\"eeff\") => false\n     * cycpattern_check(\"himenss\",\"simen\") => true\n     */\n    public boolean cycpattern_check(String a, String b) {\n        if (b.length() > a.length()) {\n            return false;\n        }\n        \n        // Generate all rotations of the second word\n        for (int i = 0; i < b.length(); i++) {\n            String rotated = rotateString(b, i);\n            if (a.contains(rotated)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private String rotateString(String s, int k) {\n        int n = s.length();\n        k = k % n; // In case the rotation is greater than the length of the string\n        return s.substring(n - k) + s.substring(0, n - k);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.cycpattern_check(\"abcd\", \"abd\")); // false\n        System.out.println(solution.cycpattern_check(\"hello\", \"ell\")); // true\n        System.out.println(solution.cycpattern_check(\"whassup\", \"psus\")); // false\n        System.out.println(solution.cycpattern_check(\"abab\", \"baa\")); // true\n        System.out.println(solution.cycpattern_check(\"efef\", \"eeff\")); // false\n        System.out.println(solution.cycpattern_check(\"himenss\", \"simen\")); // true\n    }\n}\n"}
{"task_id": "Java/155", "generation": "import java.util.*;\n\nclass Solution {\n    public List<Integer> even_odd_count(int num) {\n        // Convert number to string to easily iterate over digits\n        String strNum = Integer.toString(Math.abs(num));\n        \n        // Initialize counters for even and odd digits\n        int evenCount = 0;\n        int oddCount = 0;\n        \n        // Iterate through each character in the string representation of the number\n        for (char digit : strNum.toCharArray()) {\n            if ((digit - '0') % 2 == 0) {\n                evenCount++;\n            } else {\n                oddCount++;\n            }\n        }\n        \n        // Create and return a list containing the counts of even and odd digits\n        List<Integer> result = new ArrayList<>();\n        result.add(evenCount);\n        result.add(oddCount);\n        return result;\n    }\n}\n"}
{"task_id": "Java/156", "generation": "import java.util.*;\n\nclass Solution {\n    public String int_to_mini_roman(int number) {\n        List<RomanNumeral> romanNumerals = Arrays.asList(\n            new RomanNumeral(1000, \"m\"), new RomanNumeral(900, \"cm\"),\n            new RomanNumeral(500, \"d\"), new RomanNumeral(400, \"cd\"),\n            new RomanNumeral(100, \"c\"), new RomanNumeral(90, \"xc\"),\n            new RomanNumeral(50, \"l\"), new RomanNumeral(40, \"xl\"),\n            new RomanNumeral(10, \"x\"), new RomanNumeral(9, \"ix\"),\n            new RomanNumeral(5, \"v\"), new RomanNumeral(4, \"iv\"),\n            new RomanNumeral(1, \"i\")\n        );\n\n        StringBuilder roman = new StringBuilder();\n        \n        for (RomanNumeral numeral : romanNumerals) {\n            while (number >= numeral.getValue()) {\n                roman.append(numeral.getSymbol());\n                number -= numeral.getValue();\n            }\n        }\n\n        return roman.toString().toLowerCase();\n    }\n\n    private static class RomanNumeral {\n        private final int value;\n        private final String symbol;\n\n        public RomanNumeral(int value, String symbol) {\n            this.value = value;\n            this.symbol = symbol;\n        }\n\n        public int getValue() {\n            return value;\n        }\n\n        public String getSymbol() {\n            return symbol;\n        }\n    }\n}\n"}
{"task_id": "Java/157", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given the lengths of the three sides of a triangle. Return true if the three\n     * sides form a right-angled triangle, false otherwise.\n     * A right-angled triangle is a triangle in which one angle is a right angle or 90 degrees.\n     * Example:\n     * right_angle_triangle(3, 4, 5) == true\n     * right_angle_triangle(1, 2, 3) == false\n     */\n    public boolean right_angle_triangle(int a, int b, int c) {\n        // Sort the sides to ensure the longest side is last\n        int[] sides = {a, b, c};\n        Arrays.sort(sides);\n        \n        // Check if the square of the longest side equals the sum of squares of other two sides\n        return Math.pow(sides[0], 2) + Math.pow(sides[1], 2) == Math.pow(sides[2], 2);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.right_angle_triangle(3, 4, 5)); // true\n        System.out.println(solution.right_angle_triangle(1, 2, 3)); // false\n        System.out.println(solution.right_angle_triangle(5, 12, 13)); // true\n        System.out.println(solution.right_angle_triangle(6, 8, 10)); // true\n        System.out.println(solution.right_angle_triangle(7, 10, 12)); // false\n    }\n}\n"}
{"task_id": "Java/158", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Write a function that accepts a list of strings.\n     * The list contains different words. Return the word with maximum number\n     * of unique characters. If multiple strings have maximum number of unique\n     * characters, return the one which comes first in lexicographical order.\n     *\n     * find_max([\"name\", \"of\", \"string\"]) == \"string\"\n     * find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n     * find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"aaaaaaa\"\n     */\n    public String find_max(List<String> words) {\n        if (words == null || words.isEmpty()) {\n            return \"\";\n        }\n\n        // Sort the list lexicographically\n        Collections.sort(words);\n\n        String maxWord = \"\";\n        int maxUniqueChars = 0;\n\n        for (String word : words) {\n            Set<Character> uniqueChars = new HashSet<>();\n            for (char c : word.toCharArray()) {\n                uniqueChars.add(c);\n            }\n\n            if (uniqueChars.size() > maxUniqueChars) {\n                maxUniqueChars = uniqueChars.size();\n                maxWord = word;\n            }\n        }\n\n        return maxWord;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.find_max(Arrays.asList(\"name\", \"of\", \"string\"))); // Output: string\n        System.out.println(solution.find_max(Arrays.asList(\"name\", \"enam\", \"game\"))); // Output: enam\n        System.out.println(solution.find_max(Arrays.asList(\"aaaaaaa\", \"bb\", \"cc\")));  // Output: aaaaaaa\n        System.out.println(solution.find_max(new ArrayList<>()));                     // Output: (empty string)\n        System.out.println(solution.find_max(Arrays.asList(\"abc\", \"defg\", \"hijk\")));  // Output: defg\n    }\n}\n"}
{"task_id": "Java/159", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * You're a hungry rabbit, and you already have eaten a certain number of carrots,\n     * but now you need to eat more carrots to complete the day's meals.\n     * return an array of [ total number of eaten carrots after your meals,\n     *                     the number of carrots left after your meals ]\n     * if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n     *\n     * Example:\n     * * eat(5, 6, 10) -> [11, 4]\n     * * eat(4, 8, 9) -> [12, 1]\n     * * eat(1, 10, 10) -> [11, 0]\n     * * eat(2, 11, 5) -> [7, 0]\n     *\n     * Variables:\n     * @number : integer\n     *        the number of carrots that you have eaten.\n     * @need : integer\n     *        the number of carrots that you need to eat.\n     * @remaining : integer\n     *        the number of remaining carrots thet exist in stock\n     *\n     * Constrain:\n     * * 0 <= number <= 1000\n     * * 0 <= need <= 1000\n     * * 0 <= remaining <= 1000\n     */\n    public List<Integer> eat(int number, int need, int remaining) {\n        // Calculate the total number of carrots to be eaten\n        int totalToEat = Math.min(need, remaining);\n        \n        // Update the number of carrots eaten and remaining\n        int newNumberEaten = number + totalToEat;\n        int newRemainingCarrots = remaining - totalToEat;\n\n        return Arrays.asList(newNumberEaten, newRemainingCarrots);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.eat(5, 6, 10)); // Expected: [11, 4]\n        System.out.println(solution.eat(4, 8, 9));  // Expected: [12, 1]\n        System.out.println(solution.eat(1, 10, 10)); // Expected: [11, 0]\n        System.out.println(solution.eat(2, 11, 5));  // Expected: [7, 0]\n    }\n}\n"}
{"task_id": "Java/160", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int do_algebra(List<String> operator, List<Integer> operand) {\n        StringBuilder expression = new StringBuilder();\n        expression.append(operand.get(0));\n        \n        for (int i = 0; i < operator.size(); i++) {\n            expression.append(\" \").append(operator.get(i)).append(\" \").append(operand.get(i + 1));\n        }\n        \n        // Evaluate the constructed expression\n        int result = evaluateExpression(expression.toString());\n        return result;\n    }\n\n    private int evaluateExpression(String expression) {\n        // Using a simple approach to handle basic arithmetic operations\n        String[] parts = expression.split(\" \");\n        int num1 = Integer.parseInt(parts[0]);\n        String operator = parts[1];\n        int num2 = Integer.parseInt(parts[2]);\n\n        switch (operator) {\n            case \"+\":\n                return num1 + num2;\n            case \"-\":\n                return num1 - num2;\n            case \"*\":\n                return num1 * num2;\n            case \"/\":\n                if (num2 == 0) throw new ArithmeticException(\"Division by zero\");\n                return num1 / num2;\n            case \"**\":\n                return (int) Math.pow(num1, num2);\n            default:\n                throw new IllegalArgumentException(\"Unsupported operator: \" + operator);\n        }\n    }\n}\n"}
{"task_id": "Java/161", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * You are given a string s.\n     * if s[i] is a letter, reverse its case from lower to upper or vise versa,\n     * otherwise keep it as it is.\n     * If the string contains no letters, reverse the string.\n     * The function should return the resulted string.\n     * Examples\n     * solve(\"1234\") = \"4321\"\n     * solve(\"ab\") = \"AB\"\n     * solve(\"#a@C\") = \"#A@c\"\n     */\n    public String solve(String s) {\n        if (s == null || s.isEmpty()) {\n            return s;\n        }\n\n        boolean containsLetters = false;\n        StringBuilder result = new StringBuilder();\n\n        for (char c : s.toCharArray()) {\n            if (Character.isLetter(c)) {\n                containsLetters = true;\n                result.append(Character.isLowerCase(c) ? Character.toUpperCase(c) : Character.toLowerCase(c));\n            } else {\n                result.append(c);\n            }\n        }\n\n        return containsLetters ? result.toString() : new StringBuilder(s).reverse().toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.solve(\"1234\"));  // Expected: \"4321\"\n        System.out.println(solution.solve(\"ab\"));    // Expected: \"AB\"\n        System.out.println(solution.solve(\"#a@C\"));  // Expected: \"#A@c\"\n        System.out.println(solution.solve(\"\"));      // Expected: \"\"\n        System.out.println(solution.solve(\"123!@#\")); // Expected: \"#@!321\"\n        System.out.println(solution.solve(\"Hello World!\")); // Expected: \"hELLO wORLD!\"\n    }\n}\n"}
{"task_id": "Java/162", "generation": "import java.math.BigInteger;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.Optional;\n\nclass Solution {\n    /**\n     * Given a string \"text\", return its md5 hash equivalent string with length being 32.\n     * If \"text\" is an empty string, return Optional.empty().\n     */\n    public static Optional<String> string_to_md5(String text) throws NoSuchAlgorithmException {\n        if (text.isEmpty()) {\n            return Optional.empty();\n        }\n\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        byte[] messageDigest = md.digest(text.getBytes());\n        BigInteger no = new BigInteger(1, messageDigest);\n\n        // Convert message digest into hex value\n        String hashtext = no.toString(16);\n        while (hashtext.length() < 32) {\n            hashtext = \"0\" + hashtext;\n        }\n        return Optional.of(hashtext);\n    }\n\n    public static void main(String[] args) {\n        try {\n            System.out.println(string_to_md5(\"Hello world\")); // Expected output: 3e25960a79dbc69b674cd4ec6d5fb8d\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n    }\n}\n"}
{"task_id": "Java/163", "generation": "import java.util.List;\n\nclass Solution {\n\n    /**\n     * Given two positive integers a and b, return the even digits between a\n     * and b, in ascending order.\n     *\n     * @param a the lower bound (inclusive)\n     * @param b the upper bound (inclusive)\n     * @return a List of Integer containing even digits between a and b\n     */\n    public List<Integer> generate_integers(int a, int b) {\n        List<Integer> result = new ArrayList<>();\n        \n        // Ensure a is less than or equal to b for simplicity in iteration\n        if (a > b) {\n            int temp = a;\n            a = b;\n            b = temp;\n        }\n        \n        for (int i = a; i <= b; i++) {\n            if (i % 2 == 0 && i < 10) {\n                result.add(i);\n            }\n        }\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(\"generate_integers(2, 8): \" + solution.generate_integers(2, 8)); // [2, 4, 6, 8]\n        System.out.println(\"generate_integers(8, 2): \" + solution.generate_integers(8, 2)); // [2, 4, 6, 8]\n        System.out.println(\"generate_integers(10, 14): \" + solution.generate_integers(10, 14)); // []\n        System.out.println(\"generate_integers(1, 5): \" + solution.generate_integers(1, 5)); // [2, 4]\n        System.out.println(\"generate_integers(3, 7): \" + solution.generate_integers(3, 7)); // [4, 6]\n    }\n}\n"}
{"task_id": "Java/0", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Check if in given list of numbers, are any two numbers closer to each other than given threshold.\n     *\n     * @param numbers List of Double values.\n     * @param threshold The threshold value for closeness.\n     * @return true if there exist at least two elements whose difference is less than the threshold; false otherwise.\n     */\n    public boolean has_close_elements(List<Double> numbers, double threshold) {\n        // Sort the list to make it easier to find close elements\n        Collections.sort(numbers);\n        \n        for (int i = 0; i < numbers.size() - 1; i++) {\n            if (numbers.get(i + 1) - numbers.get(i) < threshold) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.has_close_elements(Arrays.asList(1.0, 2.0, 3.0), 0.5)); // Expected: false\n        System.out.println(solution.has_close_elements(Arrays.asList(1.0, 2.8, 3.0, 4.0, 5.0, 2.0), 0.3)); // Expected: true\n        System.out.println(solution.has_close_elements(Arrays.asList(-1.0, -2.0, -3.0), 1.5)); // Expected: false\n        System.out.println(solution.has_close_elements(Arrays.asList(10.0, 10.1, 10.2, 10.3), 0.05)); // Expected: true\n    }\n}\n"}
{"task_id": "Java/1", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n     * separate those group into separate strings and return the list of those.\n     * Separate groups are balanced (each open brace is properly closed) and not nested within each other\n     * Ignore any spaces in the input string.\n     *\n     * @param paren_string The input string containing multiple groups of nested parentheses.\n     * @return A List of separate strings, each representing a group of balanced parentheses.\n     */\n    public List<String> separate_paren_groups(String paren_string) {\n        List<String> result = new ArrayList<>();\n        int balance = 0;\n        StringBuilder currentGroup = new StringBuilder();\n\n        for (char c : paren_string.toCharArray()) {\n            if (c == ' ') continue; // Ignore spaces\n\n            if (c == '(') {\n                balance++;\n                currentGroup.append(c);\n            } else if (c == ')') {\n                balance--;\n                currentGroup.append(c);\n\n                if (balance == 0) { // A complete group is found\n                    result.add(currentGroup.toString());\n                    currentGroup = new StringBuilder(); // Reset for the next group\n                }\n            }\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(\"Test Case 1: ( ) (( )) (( )( ))\");\n        List<String> test1 = solution.separate_paren_groups(\"( ) (( )) (( )( ))\");\n        for (String group : test1) {\n            System.out.println(group);\n        }\n\n        System.out.println(\"\\nTest Case 2: (()())(())\");\n        List<String> test2 = solution.separate_paren_groups(\"(()())(())\");\n        for (String group : test2) {\n            System.out.println(group);\n        }\n\n        System.out.println(\"\\nTest Case 3: ((()))((()))\");\n        List<String> test3 = solution.separate_paren_groups(\"((()))((()))\");\n        for (String group : test3) {\n            System.out.println(group);\n        }\n    }\n}\n"}
{"task_id": "Java/2", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     Given a positive floating point number, it can be decomposed into\n     and integer part (largest integer smaller than given number) and decimals\n     (leftover part always smaller than 1).\n\n     Return the decimal part of the number.\n     >>> truncate_number(3.5)\n     0.5\n     */\n    public double truncate_number(double number) {\n        return number - Math.floor(number);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(\"Truncate 3.5: \" + solution.truncate_number(3.5)); // Expected output: 0.5\n        System.out.println(\"Truncate 123.456: \" + solution.truncate_number(123.456)); // Expected output: 0.456\n        System.out.println(\"Truncate -1.234: \" + solution.truncate_number(-1.234)); // Expected output: -0.234 (Note: floor of negative numbers is less than the number itself)\n        System.out.println(\"Truncate 0.999: \" + solution.truncate_number(0.999)); // Expected output: 0.999\n        System.out.println(\"Truncate 10.0: \" + solution.truncate_number(10.0)); // Expected output: 0.0\n    }\n}\n"}
{"task_id": "Java/3", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * You're given a list of deposit and withdrawal operations on a bank account that starts with\n     * zero balance. Your task is to detect if at any point the balance of the account falls below zero,\n     * and at that point, the function should return true. Otherwise, it should return false.\n     *\n     * @param operations List of integers representing deposits (positive) and withdrawals (negative).\n     * @return boolean indicating whether the balance ever goes below zero.\n     */\n    public boolean below_zero(List<Integer> operations) {\n        int balance = 0;\n        for (int op : operations) {\n            balance += op;\n            if (balance < 0) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        List<Integer> test1 = Arrays.asList(1, 2, 3);\n        System.out.println(\"Test Case 1: \" + (solution.below_zero(test1) == false)); // Expected: true\n\n        List<Integer> test2 = Arrays.asList(1, 2, -4, 5);\n        System.out.println(\"Test Case 2: \" + (solution.below_zero(test2) == true)); // Expected: true\n\n        List<Integer> test3 = Arrays.asList(-1, 2, -1, 3);\n        System.out.println(\"Test Case 3: \" + (solution.below_zero(test3) == false)); // Expected: false\n\n        List<Integer> test4 = Arrays.asList(5, -6, 7, -8, 9);\n        System.out.println(\"Test Case 4: \" + (solution.below_zero(test4) == true)); // Expected: true\n    }\n}\n"}
{"task_id": "Java/4", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * For a given list of input numbers, calculate Mean Absolute Deviation around the mean of this dataset.\n     * Mean Absolute Deviation is the average absolute difference between each element and a centerpoint (mean in this case):\n     * MAD = average | x - x_mean |\n     *\n     * @param numbers List of Double values\n     * @return Mean Absolute Deviation as a double\n     */\n    public double mean_absolute_deviation(List<Double> numbers) {\n        if (numbers == null || numbers.isEmpty()) {\n            throw new IllegalArgumentException(\"Input list cannot be null or empty\");\n        }\n\n        // Calculate the mean of the dataset\n        double sum = 0.0;\n        for (Double num : numbers) {\n            sum += num;\n        }\n        double mean = sum / numbers.size();\n\n        // Calculate the Mean Absolute Deviation\n        double mad = 0.0;\n        for (Double num : numbers) {\n            mad += Math.abs(num - mean);\n        }\n        return mad / numbers.size();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.mean_absolute_deviation(Arrays.asList(1.0, 2.0, 3.0, 4.0))); // Expected output: 1.0\n        System.out.println(solution.mean_absolute_deviation(Arrays.asList(5.0, 7.0, 9.0, 11.0, 13.0))); // Expected output: 2.8\n        System.out.println(solution.mean_absolute_deviation(Arrays.asList(-1.0, -2.0, -3.0, -4.0))); // Expected output: 1.5\n        System.out.println(solution.mean_absolute_deviation(Arrays.asList(10.0))); // Expected output: 0.0 (single element)\n    }\n}\n"}
{"task_id": "Java/5", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Insert a number 'delimiter' between every two consecutive elements of input list `numbers`\n     *\n     * @param numbers The input list of integers.\n     * @param delimiter The integer to be inserted as a delimiter.\n     * @return A new list with the delimiter interspersed.\n     */\n    public List<Integer> intersperse(List<Integer> numbers, int delimiter) {\n        if (numbers == null || numbers.size() <= 1) {\n            return numbers;\n        }\n\n        List<Integer> result = new ArrayList<>();\n        for (int i = 0; i < numbers.size(); i++) {\n            result.add(numbers.get(i));\n            if (i < numbers.size() - 1) {\n                result.add(delimiter);\n            }\n        }\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.intersperse(List.of(), 4)); // Expected: []\n        System.out.println(solution.intersperse(Arrays.asList(1, 2, 3), 4)); // Expected: [1, 4, 2, 4, 3]\n        System.out.println(solution.intersperse(Arrays.asList(5, 6, 7, 8), -1)); // Expected: [5, -1, 6, -1, 7, -1, 8]\n    }\n}\n"}
{"task_id": "Java/6", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n     * For each of the group, output the deepest level of nesting of parentheses.\n     * E.g. (()()) has maximum two levels of nesting while ((())) has three.\n     *\n     * >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n     * [2, 3, 1, 3]\n     */\n    public List<Integer> parse_nested_parens(String paren_string) {\n        String[] groups = paren_string.split(\"\\\\s+\");\n        List<Integer> depths = new ArrayList<>();\n        \n        for (String group : groups) {\n            int maxDepth = 0;\n            int currentDepth = 0;\n            \n            for (char c : group.toCharArray()) {\n                if (c == '(') {\n                    currentDepth++;\n                    maxDepth = Math.max(maxDepth, currentDepth);\n                } else if (c == ')') {\n                    currentDepth--;\n                }\n            }\n            \n            depths.add(maxDepth);\n        }\n        \n        return depths;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        String test1 = \"(()()) ((())) () ((())()())\";\n        List<Integer> result1 = solution.parse_nested_parens(test1);\n        System.out.println(result1); // Expected output: [2, 3, 1, 3]\n        \n        String test2 = \"(()) (()) (((())))\";\n        List<Integer> result2 = solution.parse_nested_parens(test2);\n        System.out.println(result2); // Expected output: [2, 2, 4]\n        \n        String test3 = \"((())) () (((())))\";\n        List<Integer> result3 = solution.parse_nested_parens(test3);\n        System.out.println(result3); // Expected output: [3, 1, 4]\n    }\n}\n"}
{"task_id": "Java/7", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Filter an input list of strings only for ones that contain given substring\n     *\n     * @param strings The input list of strings\n     * @param substring The substring to filter by\n     * @return A list of strings containing the specified substring\n     */\n    public List<String> filter_by_substring(List<String> strings, String substring) {\n        List<String> filteredList = new ArrayList<>();\n        for (String str : strings) {\n            if (str.contains(substring)) {\n                filteredList.add(str);\n            }\n        }\n        return filteredList;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(\"Test Case 1: Empty List\");\n        System.out.println(solution.filter_by_substring(List.of(), \"a\")); // Expected output: []\n\n        System.out.println(\"\\nTest Case 2: Normal List with 'a'\");\n        System.out.println(solution.filter_by_substring(Arrays.asList(\"abc\", \"bacd\", \"cde\", \"array\"), \"a\"));\n        // Expected output: [abc, bacd, array]\n\n        System.out.println(\"\\nTest Case 3: List without the substring\");\n        System.out.println(solution.filter_by_substring(Arrays.asList(\"hello\", \"world\", \"java\"), \"python\"));\n        // Expected output: []\n\n        System.out.println(\"\\nTest Case 4: List with multiple occurrences of the substring\");\n        System.out.println(solution.filter_by_substring(Arrays.asList(\"aaa\", \"baa\", \"aab\", \"bba\"), \"aa\"));\n        // Expected output: [aaa, aab]\n    }\n}\n"}
{"task_id": "Java/8", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> sum_product(List<Integer> numbers) {\n        if (numbers.isEmpty()) {\n            return Arrays.asList(0, 1);\n        }\n        \n        int totalSum = 0;\n        int totalProduct = 1;\n        \n        for (int num : numbers) {\n            totalSum += num;\n            totalProduct *= num;\n        }\n        \n        List<Integer> result = new ArrayList<>();\n        result.add(totalSum);\n        result.add(totalProduct);\n        \n        return result;\n    }\n}\n"}
{"task_id": "Java/9", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * From a given list of integers, generate a list of rolling maximum element found until given moment in the sequence.\n     *\n     * @param numbers The input list of integers.\n     * @return A list containing the rolling maximum elements.\n     */\n    public List<Integer> rolling_max(List<Integer> numbers) {\n        if (numbers == null || numbers.isEmpty()) {\n            return Collections.emptyList();\n        }\n\n        List<Integer> result = new ArrayList<>();\n        int maxSoFar = Integer.MIN_VALUE;\n\n        for (int num : numbers) {\n            if (num > maxSoFar) {\n                maxSoFar = num;\n            }\n            result.add(maxSoFar);\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.rolling_max(Arrays.asList(1, 2, 3, 2, 3, 4, 2))); // [1, 2, 3, 3, 3, 4, 4]\n        System.out.println(solution.rolling_max(Arrays.asList()));                   // []\n        System.out.println(solution.rolling_max(Arrays.asList(5)));                  // [5]\n        System.out.println(solution.rolling_max(Arrays.asList(-1, -2, -3, -2, -3, -4, -2))); // [-1, -1, -1, -1, -1, -1, -1]\n    }\n}\n"}
{"task_id": "Java/10", "generation": "import java.util.*;\n\nclass Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0;\n        int j = s.length() - 1;\n        while (i < j) {\n            if (s.charAt(i) != s.charAt(j)) {\n                return false;\n            }\n            i++;\n            j--;\n        }\n        return true;\n    }\n\n    public String longestPalindromicSuffix(String s) {\n        for (int i = s.length(); i > 0; i--) {\n            if (isPalindrome(s.substring(i - 1))) {\n                return s.substring(i - 1);\n            }\n        }\n        return \"\";\n    }\n\n    public String make_palindrome(String string) {\n        String palindromicSuffix = longestPalindromicSuffix(string);\n        int prefixLength = string.length() - palindromicSuffix.length();\n        if (prefixLength == 0) {\n            return string;\n        }\n        String prefixToReverse = string.substring(0, prefixLength);\n        String reversedPrefix = new StringBuilder(prefixToReverse).reverse().toString();\n        return string + reversedPrefix;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.make_palindrome(\"\")); // \"\"\n        System.out.println(solution.make_palindrome(\"cat\")); // \"catac\"\n        System.out.println(solution.make_palindrome(\"cata\")); // \"catac\"\n    }\n}\n"}
{"task_id": "Java/11", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Input are two strings a and b consisting only of 1s and 0s.\n     * Perform binary XOR on these inputs and return result also as a string.\n     *\n     * @param a the first binary string\n     * @param b the second binary string\n     * @return the result of binary XOR operation as a string\n     */\n    public String string_xor(String a, String b) {\n        StringBuilder result = new StringBuilder();\n        int maxLength = Math.max(a.length(), b.length());\n        \n        // Pad both strings to have equal length\n        a = padStringToLength(a, maxLength);\n        b = padStringToLength(b, maxLength);\n\n        for (int i = 0; i < maxLength; i++) {\n            char bitA = a.charAt(i);\n            char bitB = b.charAt(i);\n            \n            // Perform XOR operation and append to result\n            if (bitA == bitB) {\n                result.append('0');\n            } else {\n                result.append('1');\n            }\n        }\n\n        return result.toString();\n    }\n\n    /**\n     * Pads the given string with '0's at the beginning to make it of specified length.\n     *\n     * @param str the input string\n     * @param length the desired length\n     * @return the padded string\n     */\n    private String padStringToLength(String str, int length) {\n        StringBuilder sb = new StringBuilder(str);\n        while (sb.length() < length) {\n            sb.insert(0, '0');\n        }\n        return sb.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.string_xor(\"010\", \"110\")); // Expected output: \"100\"\n        System.out.println(solution.string_xor(\"10101\", \"00111\")); // Expected output: \"10010\"\n        System.out.println(solution.string_xor(\"1111\", \"0000\")); // Expected output: \"1111\"\n        System.out.println(solution.string_xor(\"0000\", \"0000\")); // Expected output: \"0000\"\n        System.out.println(solution.string_xor(\"11111111\", \"00000000\")); // Expected output: \"11111111\"\n    }\n}\n"}
{"task_id": "Java/12", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     Out of list of strings, return the longest one. Return the first one in case of multiple\n     strings of the same length. Return Optional.empty() in case the input list is empty.\n     >>> longest(List.of())\n     Optional.empty\n     >>> longest(Arrays.asList(\"a\", \"b\", \"c\"))\n     Optional[a]\n     >>> longest(Arrays.asList(\"a\", \"bb\", \"ccc\"))\n     Optional[ccc]\n     */\n    public Optional<String> longest(List<String> strings) {\n        if (strings.isEmpty()) {\n            return Optional.empty();\n        }\n\n        String longestString = strings.get(0);\n        for (String str : strings) {\n            if (str.length() > longestString.length()) {\n                longestString = str;\n            }\n        }\n        \n        return Optional.of(longestString);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(\"Test Case 1: Empty List\");\n        System.out.println(solution.longest(List.of())); // Expected: Optional.empty\n\n        System.out.println(\"\\nTest Case 2: Single Element\");\n        System.out.println(solution.longest(Arrays.asList(\"a\"))); // Expected: Optional[a]\n\n        System.out.println(\"\\nTest Case 3: Multiple Elements with Different Lengths\");\n        System.out.println(solution.longest(Arrays.asList(\"a\", \"bb\", \"ccc\"))); // Expected: Optional[ccc]\n\n        System.out.println(\"\\nTest Case 4: Multiple Elements with Same Length\");\n        System.out.println(solution.longest(Arrays.asList(\"aa\", \"bbb\", \"cccc\"))); // Expected: Optional[cccc]\n    }\n}\n"}
{"task_id": "Java/13", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return a greatest common divisor of two integers a and b\n     *\n     * @param a first integer\n     * @param b second integer\n     * @return the greatest common divisor of a and b\n     */\n    public int greatest_common_divisor(int a, int b) {\n        while (b != 0) {\n            int temp = b;\n            b = a % b;\n            a = temp;\n        }\n        return a;\n    }\n\n    // Test cases to verify the correctness of the method\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1: GCD of 3 and 5 is 1\n        System.out.println(\"GCD of 3 and 5: \" + solution.greatest_common_divisor(3, 5)); // Expected output: 1\n\n        // Test case 2: GCD of 25 and 15 is 5\n        System.out.println(\"GCD of 25 and 15: \" + solution.greatest_common_divisor(25, 15)); // Expected output: 5\n\n        // Test case 3: GCD of 100 and 80 is 20\n        System.out.println(\"GCD of 100 and 80: \" + solution.greatest_common_divisor(100, 80)); // Expected output: 20\n\n        // Test case 4: GCD of 7 and 13 (both prime) is 1\n        System.out.println(\"GCD of 7 and 13: \" + solution.greatest_common_divisor(7, 13)); // Expected output: 1\n\n        // Test case 5: GCD of 0 and any number is that number (since gcd(0, b) = b)\n        System.out.println(\"GCD of 0 and 24: \" + solution.greatest_common_divisor(0, 24)); // Expected output: 24\n    }\n}\n"}
{"task_id": "Java/14", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Return list of all prefixes from shortest to longest of the input string\n     *\n     * @param string The input string\n     * @return A List containing all prefixes of the input string, ordered from shortest to longest\n     */\n    public List<String> all_prefixes(String string) {\n        List<String> prefixes = new ArrayList<>();\n        if (string == null || string.isEmpty()) {\n            return prefixes;\n        }\n        \n        for (int i = 1; i <= string.length(); i++) {\n            prefixes.add(string.substring(0, i));\n        }\n        \n        return prefixes;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(\"Testing all_prefixes(\\\"abc\\\"): \" + solution.all_prefixes(\"abc\")); // [\"a\", \"ab\", \"abc\"]\n        System.out.println(\"Testing all_prefixes(\\\"\\\"): \" + solution.all_prefixes(\"\")); // []\n        System.out.println(\"Testing all_prefixes(null): \" + solution.all_prefixes(null)); // []\n\n        // Additional test cases\n        System.out.println(\"Testing all_prefixes(\\\"hello\\\"): \" + solution.all_prefixes(\"hello\")); // [\"h\", \"he\", \"hel\", \"hell\", \"hello\"]\n        System.out.println(\"Testing all_prefixes(\\\"java\\\"): \" + solution.all_prefixes(\"java\")); // [\"j\", \"ja\", \"jav\", \"java\"]\n    }\n}\n"}
{"task_id": "Java/15", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Return a string containing space-delimited numbers starting from 0 up to n inclusive.\n     *\n     * @param n The upper limit of the sequence (inclusive).\n     * @return A string with space-separated numbers from 0 to n.\n     */\n    public String string_sequence(int n) {\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i <= n; i++) {\n            if (i > 0) {\n                sb.append(\" \");\n            }\n            sb.append(i);\n        }\n        return sb.toString();\n    }\n\n    // Test cases to verify the correctness of the string_sequence method\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1: n = 0\n        System.out.println(solution.string_sequence(0).equals(\"0\") ? \"Test 1 Passed\" : \"Test 1 Failed\");\n\n        // Test case 2: n = 5\n        System.out.println(solution.string_sequence(5).equals(\"0 1 2 3 4 5\") ? \"Test 2 Passed\" : \"Test 2 Failed\");\n\n        // Additional test cases\n        System.out.println(solution.string_sequence(10).equals(\"0 1 2 3 4 5 6 7 8 9 10\") ? \"Test 3 Passed\" : \"Test 3 Failed\");\n        System.out.println(solution.string_sequence(-1).equals(\"\") ? \"Test 4 Passed\" : \"Test 4 Failed\"); // Edge case: n < 0\n    }\n}\n"}
{"task_id": "Java/16", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given a string, find out how many distinct characters (regardless of case) does it consist of.\n     *\n     * @param string The input string to analyze.\n     * @return The number of distinct characters in the string, ignoring case.\n     */\n    public int count_distinct_characters(String string) {\n        // Convert the string to lowercase to ignore case\n        String lowerCaseString = string.toLowerCase();\n        \n        // Use a HashSet to store unique characters\n        Set<Character> uniqueChars = new HashSet<>();\n        \n        // Iterate through each character in the string and add it to the set\n        for (char c : lowerCaseString.toCharArray()) {\n            uniqueChars.add(c);\n        }\n        \n        // The size of the set is the number of distinct characters\n        return uniqueChars.size();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.count_distinct_characters(\"xyzXYZ\")); // Expected output: 3\n        System.out.println(solution.count_distinct_characters(\"Jerry\"));   // Expected output: 4\n        System.out.println(solution.count_distinct_characters(\"HelloWorld\")); // Expected output: 7\n        System.out.println(solution.count_distinct_characters(\"AAAaaa\"));    // Expected output: 1\n        System.out.println(solution.count_distinct_characters(\"\"));          // Expected output: 0\n        System.out.println(solution.count_distinct_characters(\"aAaAaA\"));    // Expected output: 1\n    }\n}\n"}
{"task_id": "Java/17", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n    Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    note last.\n\n    Here is a legend:\n    \"o\" - whole note, lasts four beats\n    \"o|\" - half note, lasts two beats\n    \".|\" - quater note, lasts one beat\n\n    >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n     */\n    public List<Integer> parse_music(String string) {\n        // Define the mapping of notes to their corresponding beat counts\n        Map<String, Integer> noteToBeats = new HashMap<>();\n        noteToBeats.put(\"o\", 4);\n        noteToBeats.put(\"o|\", 2);\n        noteToBeats.put(\".|\", 1);\n\n        // Split the input string into individual notes\n        String[] notes = string.split(\" \");\n\n        // Create a list to store the beat counts\n        List<Integer> beats = new ArrayList<>();\n\n        // Parse each note and add its corresponding beat count to the list\n        for (String note : notes) {\n            if (noteToBeats.containsKey(note)) {\n                beats.add(noteToBeats.get(note));\n            }\n        }\n\n        return beats;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        List<Integer> result = solution.parse_music(\"o o| .| o| o| .| .| .| .| o o\");\n        System.out.println(result); // Output: [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    }\n}\n"}
{"task_id": "Java/18", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Find how many times a given substring can be found in the original string. Count overlapping cases.\n     *\n     * @param string The original string.\n     * @param substring The substring to find.\n     * @return The number of times the substring appears in the original string, including overlaps.\n     */\n    public int how_many_times(String string, String substring) {\n        if (substring.isEmpty()) return 0;\n        \n        int count = 0;\n        int index = 0;\n        \n        while ((index = string.indexOf(substring, index)) != -1) {\n            count++;\n            index++; // Move to the next character after the found substring to allow for overlapping matches\n        }\n        \n        return count;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.how_many_times(\"\", \"a\")); // Expected output: 0\n        System.out.println(solution.how_many_times(\"aaa\", \"a\")); // Expected output: 3\n        System.out.println(solution.how_many_times(\"aaaa\", \"aa\")); // Expected output: 3\n        System.out.println(solution.how_many_times(\"abababa\", \"aba\")); // Expected output: 3\n        System.out.println(solution.how_many_times(\"testtest\", \"test\")); // Expected output: 2\n    }\n}\n"}
{"task_id": "Java/19", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Input is a space-delimited string of numberals from 'zero' to 'nine'.\n    Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n    Return the string with numbers sorted from smallest to largest\n    >>> sort_numbers(\"three one five\")\n    \"one three five\"\n     */\n    public String sort_numbers(String numbers) {\n        // Map of number words to their corresponding integer values\n        Map<String, Integer> numMap = new HashMap<>();\n        numMap.put(\"zero\", 0);\n        numMap.put(\"one\", 1);\n        numMap.put(\"two\", 2);\n        numMap.put(\"three\", 3);\n        numMap.put(\"four\", 4);\n        numMap.put(\"five\", 5);\n        numMap.put(\"six\", 6);\n        numMap.put(\"seven\", 7);\n        numMap.put(\"eight\", 8);\n        numMap.put(\"nine\", 9);\n\n        // Split the input string into an array of number words\n        String[] words = numbers.split(\" \");\n        \n        // Sort the array based on their integer values using the map\n        Arrays.sort(words, (a, b) -> numMap.get(a) - numMap.get(b));\n        \n        // Join the sorted array back into a single string\n        return String.join(\" \", words);\n    }\n}\n"}
{"task_id": "Java/20", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * From a supplied list of numbers (of length at least two) select and return two that are the closest to each other and return them in order (smaller number, larger number).\n     */\n    public List<Double> find_closest_elements(List<Double> numbers) {\n        if (numbers == null || numbers.size() < 2) {\n            throw new IllegalArgumentException(\"List must contain at least two elements.\");\n        }\n\n        double minDiff = Double.MAX_VALUE;\n        List<Double> closestElements = new ArrayList<>();\n\n        for (int i = 0; i < numbers.size(); i++) {\n            for (int j = i + 1; j < numbers.size(); j++) {\n                double diff = Math.abs(numbers.get(i) - numbers.get(j));\n                if (diff < minDiff) {\n                    minDiff = diff;\n                    closestElements.clear();\n                    closestElements.add(Math.min(numbers.get(i), numbers.get(j)));\n                    closestElements.add(Math.max(numbers.get(i), numbers.get(j)));\n                }\n            }\n        }\n\n        return closestElements;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.find_closest_elements(Arrays.asList(1.0, 2.0, 3.0, 4.0, 5.0, 2.2))); // [2.0, 2.2]\n        System.out.println(solution.find_closest_elements(Arrays.asList(1.0, 2.0, 3.0, 4.0, 5.0, 2.0)));  // [2.0, 2.0]\n        System.out.println(solution.find_closest_elements(Arrays.asList(-1.0, -2.0, -3.0, -4.0, -5.0, -2.2))); // [-2.2, -2.0]\n        System.out.println(solution.find_closest_elements(Arrays.asList(10.5, 10.6, 10.7, 10.8, 10.9))); // [10.5, 10.6]\n    }\n}\n"}
{"task_id": "Java/21", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given list of numbers (of at least two elements), apply a linear transform to that list,\n     * such that the smallest number will become 0 and the largest will become 1.\n     *\n     * @param numbers List of Double values\n     * @return A new list where each element is rescaled to the range [0, 1]\n     */\n    public List<Double> rescale_to_unit(List<Double> numbers) {\n        if (numbers == null || numbers.size() < 2) {\n            throw new IllegalArgumentException(\"List must contain at least two elements\");\n        }\n\n        double min = Collections.min(numbers);\n        double max = Collections.max(numbers);\n\n        List<Double> result = new ArrayList<>();\n        for (Double num : numbers) {\n            double scaledValue = (num - min) / (max - min);\n            result.add(scaledValue);\n        }\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        List<Double> test1 = Arrays.asList(1.0, 2.0, 3.0, 4.0, 5.0);\n        System.out.println(\"Test Case 1: \" + solution.rescale_to_unit(test1));\n        \n        List<Double> test2 = Arrays.asList(-1.0, -2.0, -3.0, -4.0, -5.0);\n        System.out.println(\"Test Case 2: \" + solution.rescale_to_unit(test2));\n        \n        List<Double> test3 = Arrays.asList(10.0, 20.0, 30.0, 40.0, 50.0);\n        System.out.println(\"Test Case 3: \" + solution.rescale_to_unit(test3));\n    }\n}\n"}
{"task_id": "Java/22", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> filter_integers(List<Object> values) {\n        List<Integer> integers = new ArrayList<>();\n        for (Object value : values) {\n            if (value instanceof Integer) {\n                integers.add((Integer) value);\n            }\n        }\n        return integers;\n    }\n}\n"}
{"task_id": "Java/23", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Return length of given string\n     * >>> strlen(\"\")\n     * 0\n     * >>> strlen(\"abc\")\n     * 3\n     */\n    public int strlen(String string) {\n        return string.length();\n    }\n\n    public static void main(String[] args) {\n        // Create an instance of Solution\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(\"Test Case 1: Empty String\");\n        System.out.println(\"Expected Output: 0\");\n        System.out.println(\"Actual Output: \" + solution.strlen(\"\"));\n        System.out.println();\n\n        System.out.println(\"Test Case 2: Single Character String\");\n        System.out.println(\"Expected Output: 1\");\n        System.out.println(\"Actual Output: \" + solution.strlen(\"a\"));\n        System.out.println();\n\n        System.out.println(\"Test Case 3: Multiple Characters String\");\n        System.out.println(\"Expected Output: 5\");\n        System.out.println(\"Actual Output: \" + solution.strlen(\"hello\"));\n        System.out.println();\n\n        System.out.println(\"Test Case 4: Longer String with Spaces and Special Characters\");\n        System.out.println(\"Expected Output: 12\");\n        System.out.println(\"Actual Output: \" + solution.strlen(\"Hello, world!\"));\n    }\n}\n"}
{"task_id": "Java/24", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * For a given number n, find the largest number that divides n evenly, smaller than n.\n     *\n     * @param n The input number.\n     * @return The largest divisor of n that is smaller than n.\n     */\n    public int largest_divisor(int n) {\n        for (int i = n / 2; i >= 1; i--) {\n            if (n % i == 0) {\n                return i;\n            }\n        }\n        // If no divisor found, which should not happen for positive integers,\n        // we return -1 as an error indicator.\n        return -1;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.largest_divisor(15));  // Expected output: 5\n        System.out.println(solution.largest_divisor(28));  // Expected output: 14\n        System.out.println(solution.largest_divisor(37));  // Expected output: -1 (since 37 is prime)\n        System.out.println(solution.largest_divisor(100)); // Expected output: 50\n    }\n}\n"}
{"task_id": "Java/25", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Return list of prime factors of given integer in the order from smallest to largest.\n     * Each of the factors should be listed number of times corresponding to how many times it appears in factorization.\n     * Input number should be equal to the product of all factors\n     *\n     * @param n the integer to factorize\n     * @return a list of prime factors\n     */\n    public List<Integer> factorize(int n) {\n        List<Integer> factors = new ArrayList<>();\n        for (int factor = 2; factor <= n; factor++) {\n            while (n % factor == 0) {\n                factors.add(factor);\n                n /= factor;\n            }\n        }\n        return factors;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(\"Factorize(8): \" + solution.factorize(8));   // Expected: [2, 2, 2]\n        System.out.println(\"Factorize(25): \" + solution.factorize(25));  // Expected: [5, 5]\n        System.out.println(\"Factorize(70): \" + solution.factorize(70));  // Expected: [2, 5, 7]\n        System.out.println(\"Factorize(49): \" + solution.factorize(49));  // Expected: [7, 7]\n        System.out.println(\"Factorize(1): \" + solution.factorize(1));    // Expected: []\n        System.out.println(\"Factorize(2): \" + solution.factorize(2));    // Expected: [2]\n    }\n}\n"}
{"task_id": "Java/26", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> remove_duplicates(List<Integer> numbers) {\n        Set<Integer> seen = new HashSet<>();\n        List<Integer> result = new ArrayList<>();\n        \n        for (Integer num : numbers) {\n            if (!seen.contains(num)) {\n                seen.add(num);\n                result.add(num);\n            }\n        }\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        List<Integer> input = Arrays.asList(1, 2, 3, 2, 4);\n        List<Integer> output = solution.remove_duplicates(input);\n        System.out.println(output); // Output: [1, 3, 4]\n    }\n}\n"}
{"task_id": "Java/27", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n     *\n     * @param string The input string to be flipped.\n     * @return A new string with the case of each character flipped.\n     */\n    public String flip_case(String string) {\n        StringBuilder result = new StringBuilder();\n        for (char c : string.toCharArray()) {\n            if (Character.isUpperCase(c)) {\n                result.append(Character.toLowerCase(c));\n            } else {\n                result.append(Character.toUpperCase(c));\n            }\n        }\n        return result.toString();\n    }\n\n    // Test method to verify the correctness of flip_case\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.flip_case(\"Hello\"));  // Expected: \"hELLO\"\n        System.out.println(solution.flip_case(\"WORLD\"));  // Expected: \"world\"\n        System.out.println(solution.flip_case(\"Java\"));   // Expected: \"jAVA\"\n        System.out.println(solution.flip_case(\"123abcABC\"));  // Expected: \"123ABCabc\"\n        System.out.println(solution.flip_case(\"\"));       // Expected: \"\"\n    }\n}\n"}
{"task_id": "Java/28", "generation": "import java.util.Arrays;\nimport java.util.List;\n\nclass Solution {\n    /**\n     * Concatenate list of strings into a single string\n     *\n     * @param strings List of strings to concatenate\n     * @return A single concatenated string\n     */\n    public String concatenate(List<String> strings) {\n        StringBuilder sb = new StringBuilder();\n        for (String str : strings) {\n            sb.append(str);\n        }\n        return sb.toString();\n    }\n}\n\nclass TestSolution {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1: Empty list\n        List<String> emptyList = Arrays.asList();\n        System.out.println(\"Expected: '', Actual: '\" + solution.concatenate(emptyList) + \"'\");\n\n        // Test case 2: Single element list\n        List<String> singleElementList = Arrays.asList(\"a\");\n        System.out.println(\"Expected: 'a', Actual: '\" + solution.concatenate(singleElementList) + \"'\");\n\n        // Test case 3: Multiple elements list\n        List<String> multipleElementsList = Arrays.asList(\"a\", \"b\", \"c\");\n        System.out.println(\"Expected: 'abc', Actual: '\" + solution.concatenate(multipleElementsList) + \"'\");\n    }\n}\n"}
{"task_id": "Java/29", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Filter an input list of strings only for ones that start with a given prefix.\n     *\n     * @param strings The input list of strings.\n     * @param prefix  The prefix to filter the strings by.\n     * @return A list of strings that start with the given prefix.\n     */\n    public List<String> filter_by_prefix(List<String> strings, String prefix) {\n        return strings.stream()\n                      .filter(s -> s.startsWith(prefix))\n                      .collect(Collectors.toList());\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.filter_by_prefix(new ArrayList<>(), \"a\"));  // []\n        System.out.println(solution.filter_by_prefix(Arrays.asList(\"abc\", \"bcd\", \"cde\", \"array\"), \"a\"));  // [abc, array]\n        System.out.println(solution.filter_by_prefix(Arrays.asList(\"apple\", \"banana\", \"apricot\", \"cherry\"), \"a\"));  // [apple, apricot]\n    }\n}\n"}
{"task_id": "Java/30", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return only positive numbers in the list.\n     */\n    public List<Integer> get_positive(List<Integer> l) {\n        return l.stream()\n                .filter(num -> num > 0)\n                .collect(Collectors.toList());\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(\"Test Case 1: \" + testGetPositive(Arrays.asList(-1, 2, -4, 5, 6), Arrays.asList(2, 5, 6)));\n        System.out.println(\"Test Case 2: \" + testGetPositive(Arrays.asList(5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10), Arrays.asList(5, 3, 2, 3, 9, 123, 1)));\n    }\n\n    private static boolean testGetPositive(List<Integer> input, List<Integer> expected) {\n        Solution solution = new Solution();\n        List<Integer> result = solution.get_positive(input);\n        return result.equals(expected);\n    }\n}\n"}
{"task_id": "Java/31", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Return true if a given number is prime, and false otherwise.\n     */\n    public boolean is_prime(int n) {\n        // Handle edge cases for 0, 1, and negative numbers\n        if (n <= 1) {\n            return false;\n        }\n        \n        // Check divisibility from 2 to the square root of n\n        for (int i = 2; i <= Math.sqrt(n); i++) {\n            if (n % i == 0) {\n                return false;\n            }\n        }\n        \n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(\"is_prime(6): \" + !solution.is_prime(6));   // Expected: false\n        System.out.println(\"is_prime(101): \" + solution.is_prime(101)); // Expected: true\n        System.out.println(\"is_prime(11): \" + solution.is_prime(11));   // Expected: true\n        System.out.println(\"is_prime(13441): \" + !solution.is_prime(13441)); // Expected: false (13441 is not prime)\n        System.out.println(\"is_prime(61): \" + solution.is_prime(61));   // Expected: true\n        System.out.println(\"is_prime(4): \" + !solution.is_prime(4));    // Expected: false\n        System.out.println(\"is_prime(1): \" + !solution.is_prime(1));    // Expected: false\n    }\n}\n"}
{"task_id": "Java/32", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Evaluates polynomial with coefficients xs at point x.\n     */\n    public double poly(List<Double> xs, double x) {\n        double result = 0;\n        for (int i = 0; i < xs.size(); i++) {\n            result += xs.get(i) * Math.pow(x, i);\n        }\n        return result;\n    }\n\n    /**\n     * find_zero finds x such that poly(x) = 0.\n     */\n    public double find_zero(List<Double> xs) {\n        if (xs.size() % 2 != 0) {\n            throw new IllegalArgumentException(\"The list of coefficients must have an even number of elements.\");\n        }\n        \n        // Ensure the largest non-zero coefficient is at the end\n        List<Double> nonZeroCoefficients = new ArrayList<>();\n        for (double c : xs) {\n            if (c != 0) {\n                nonZeroCoefficients.add(c);\n            }\n        }\n        if (nonZeroCoefficients.isEmpty() || Math.abs(nonZeroCoefficients.get(nonZeroCoefficients.size() - 1)) == 0) {\n            throw new IllegalArgumentException(\"There should be a non-zero coefficient to guarantee a solution.\");\n        }\n\n        double x = 0.0;\n        for (int i = 0; i < 100; i++) { // Limiting the number of iterations\n            if (Math.abs(poly(xs, x)) < 1e-6) {\n                break; // Assuming we have found a root within acceptable precision\n            }\n            double derivative = poly_derivative(xs, x);\n            x -= poly(xs, x) / derivative;\n        }\n\n        return x;\n    }\n\n    /**\n     * Computes the derivative of the polynomial.\n     */\n    private double poly_derivative(List<Double> xs, double x) {\n        List<Double> derivatives = new ArrayList<>();\n        for (int i = 1; i < xs.size(); i++) { // Skip the first coefficient as its derivative is zero\n            derivatives.add(i * xs.get(i));\n        }\n        return poly(derivatives, x);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.find_zero(Arrays.asList(1.0, 2.0))); // Should print -0.5\n        System.out.println(solution.find_zero(Arrays.asList(-6.0, 11.0, -6.0, 1.0))); // Should print 1.0\n    }\n}\n"}
{"task_id": "Java/33", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> sort_third(List<Integer> l) {\n        List<Integer> sortedList = new ArrayList<>(l);\n        int size = l.size();\n        \n        // Identify indices divisible by 3 (1-based index)\n        List<Integer> thirdIndices = new ArrayList<>();\n        for (int i = 2; i < size; i += 3) {\n            thirdIndices.add(i);\n        }\n        \n        // Extract and sort the values at these indices\n        List<Integer> valuesToSort = new ArrayList<>();\n        for (Integer index : thirdIndices) {\n            valuesToSort.add(sortedList.get(index));\n        }\n        Collections.sort(valuesToSort);\n        \n        // Replace the original values with sorted ones\n        int valueIndex = 0;\n        for (int i = 2; i < size && valueIndex < valuesToSort.size(); i += 3) {\n            sortedList.set(i, valuesToSort.get(valueIndex++));\n        }\n        \n        return sortedList;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.sort_third(Arrays.asList(1, 2, 3))); // [1, 2, 3]\n        System.out.println(solution.sort_third(Arrays.asList(5, 6, 3, 4, 8, 9, 2))); // [2, 6, 3, 4, 8, 9, 5]\n    }\n}\n"}
{"task_id": "Java/34", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return sorted unique elements in a list\n     *\n     * @param l input list of integers\n     * @return a List containing sorted unique elements from the input list\n     */\n    public List<Integer> unique(List<Integer> l) {\n        Set<Integer> set = new TreeSet<>(l);\n        return new ArrayList<>(set);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.unique(Arrays.asList(5, 3, 5, 2, 3, 3, 9, 0, 123))); // [0, 2, 3, 5, 9, 123]\n        System.out.println(solution.unique(Arrays.asList())); // []\n        System.out.println(solution.unique(Arrays.asList(1, 2, 3))); // [1, 2, 3]\n        System.out.println(solution.unique(Arrays.asList(-1, -2, -3, -4, -5))); // [-5, -4, -3, -2, -1]\n        System.out.println(solution.unique(Arrays.asList(7, 8, 9, 7, 8, 9, 10))); // [7, 8, 9, 10]\n    }\n}\n"}
{"task_id": "Java/35", "generation": "import java.util.Arrays;\nimport java.util.List;\n\nclass Solution {\n\n    /**\n     * Return maximum element in the list.\n     */\n    public int max_element(List<Integer> l) {\n        if (l == null || l.isEmpty()) {\n            throw new IllegalArgumentException(\"List cannot be null or empty\");\n        }\n        \n        return l.stream().max(Integer::compare).get();\n    }\n\n    // Test cases to verify the correctness of the function\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        List<Integer> list1 = Arrays.asList(1, 2, 3);\n        System.out.println(\"Max element in \" + list1 + \": \" + solution.max_element(list1)); // Expected: 3\n\n        // Test case 2\n        List<Integer> list2 = Arrays.asList(5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10);\n        System.out.println(\"Max element in \" + list2 + \": \" + solution.max_element(list2)); // Expected: 123\n\n        // Test case 3\n        List<Integer> list3 = Arrays.asList(-1, -2, -3, -4);\n        System.out.println(\"Max element in \" + list3 + \": \" + solution.max_element(list3)); // Expected: -1\n\n        // Test case 4\n        List<Integer> list4 = Arrays.asList(0);\n        System.out.println(\"Max element in \" + list4 + \": \" + solution.max_element(list4)); // Expected: 0\n\n        // Test case 5 (edge case)\n        List<Integer> list5 = Arrays.asList();\n        try {\n            System.out.println(\"Max element in empty list: \" + solution.max_element(list5));\n        } catch (IllegalArgumentException e) {\n            System.out.println(e.getMessage()); // Expected: List cannot be null or empty\n        }\n    }\n}\n"}
{"task_id": "Java/36", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n\n    /**\n     * Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n     */\n    public int fizz_buzz(int n) {\n        int count = 0;\n        for (int i = 1; i < n; i++) {\n            if (i % 11 == 0 || i % 13 == 0) {\n                String numStr = Integer.toString(i);\n                for (char c : numStr.toCharArray()) {\n                    if (c == '7') {\n                        count++;\n                    }\n                }\n            }\n        }\n        return count;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(\"fizz_buzz(50): \" + solution.fizz_buzz(50)); // Expected: 0\n        System.out.println(\"fizz_buzz(78): \" + solution.fizz_buzz(78)); // Expected: 2\n        System.out.println(\"fizz_buzz(79): \" + solution.fizz_buzz(79)); // Expected: 3\n        System.out.println(\"fizz_buzz(100): \" + solution.fizz_buzz(100)); // Expected: 4 (77, 781, 782, 783)\n        System.out.println(\"fizz_buzz(150): \" + solution.fizz_buzz(150)); // Expected: 6\n    }\n}\n"}
{"task_id": "Java/37", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * This function takes a list l and returns a list l' such that\n     * l' is identical to l in the odd indicies, while its values at the even indicies are equal\n     * to the values of the even indicies of l, but sorted.\n     */\n    public List<Integer> sort_even(List<Integer> l) {\n        List<Integer> result = new ArrayList<>(l);\n        List<Integer> evenIndicesValues = new ArrayList<>();\n        \n        // Extract values at even indices\n        for (int i = 0; i < result.size(); i += 2) {\n            evenIndicesValues.add(result.get(i));\n        }\n        \n        // Sort the extracted values\n        Collections.sort(evenIndicesValues);\n        \n        // Place sorted values back into their original positions\n        int evenIndex = 0;\n        for (int i = 0; i < result.size(); i += 2) {\n            result.set(i, evenIndicesValues.get(evenIndex++));\n        }\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.sort_even(Arrays.asList(1, 2, 3))); // Expected: [1, 2, 3]\n        System.out.println(solution.sort_even(Arrays.asList(5, 6, 3, 4))); // Expected: [3, 6, 5, 4]\n        System.out.println(solution.sort_even(Arrays.asList(9, 8, 7, 6, 5, 4, 3, 2, 1))); // Expected: [3, 8, 7, 6, 5, 4, 9, 2, 1]\n        System.out.println(solution.sort_even(Arrays.asList())); // Expected: []\n    }\n}\n"}
{"task_id": "Java/38", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    returns encoded string by cycling groups of three characters.\n     */\n    public String encodeCyclic(String s) {\n        // split string to groups. Each of length 3.\n        List<String> groups = new ArrayList<>();\n        for (int i = 0; i < s.length(); i += 3) {\n            groups.add(s.substring(i, Math.min(i + 3, s.length())));\n        }\n        // cycle elements in each group. Unless group has fewer elements than 3.\n        for (int i = 0; i < groups.size(); i++) {\n            if (groups.get(i).length() == 3) {\n                groups.set(i, groups.get(i).substring(1) + groups.get(i).charAt(0));\n            }\n        }\n        return String.join(\"\", groups);\n    }\n\n    /**\n    takes as input string encoded with encodeCyclic function. Returns decoded string.\n     */\n    public String decodeCyclic(String s) {\n        // split string to groups. Each of length 3.\n        List<String> groups = new ArrayList<>();\n        for (int i = 0; i < s.length(); i += 3) {\n            groups.add(s.substring(i, Math.min(i + 3, s.length())));\n        }\n        // reverse the cycling process in each group.\n        for (int i = 0; i < groups.size(); i++) {\n            if (groups.get(i).length() == 3) {\n                groups.set(i, groups.get(i).substring(2) + groups.get(i).charAt(0) + groups.get(i).charAt(1));\n            }\n        }\n        return String.join(\"\", groups);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.decodeCyclic(\"bcaefdhgi\"));\n    }\n}\n"}
{"task_id": "Java/39", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * prime_fib returns n-th number that is a Fibonacci number and it's also prime.\n     */\n    public int prime_fib(int n) {\n        List<Integer> primes = new ArrayList<>();\n        \n        // Generate Fibonacci numbers until we find the nth prime one\n        for (int i = 0; ; i++) {\n            int fibNum = fibonacci(i);\n            if (isPrime(fibNum)) {\n                primes.add(fibNum);\n                if (primes.size() == n) {\n                    return fibNum;\n                }\n            }\n        }\n    }\n\n    private int fibonacci(int num) {\n        if (num == 0) {\n            return 0;\n        } else if (num == 1) {\n            return 1;\n        } else {\n            int a = 0, b = 1;\n            for (int i = 2; i <= num; i++) {\n                int next = a + b;\n                a = b;\n                b = next;\n            }\n            return b;\n        }\n    }\n\n    private boolean isPrime(int number) {\n        if (number < 2) {\n            return false;\n        }\n        for (int i = 2; i <= Math.sqrt(number); i++) {\n            if (number % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n"}
{"task_id": "Java/40", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * triples_sum_to_zero takes a list of integers as an input.\n     * it returns True if there are three distinct elements in the list that\n     * sum to zero, and False otherwise.\n     */\n    public boolean triples_sum_to_zero(List<Integer> l) {\n        // Sort the list to make it easier to find triplets that sum to zero\n        Collections.sort(l);\n        \n        for (int i = 0; i < l.size() - 2; i++) {\n            int left = i + 1;\n            int right = l.size() - 1;\n            \n            while (left < right) {\n                int sum = l.get(i) + l.get(left) + l.get(right);\n                \n                if (sum == 0) {\n                    return true;\n                } else if (sum < 0) {\n                    left++;\n                } else {\n                    right--;\n                }\n            }\n        }\n        \n        return false;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.triples_sum_to_zero(Arrays.asList(1, 3, 5, 0))); // false\n        System.out.println(solution.triples_sum_to_zero(Arrays.asList(1, 3, -2, 1))); // true\n        System.out.println(solution.triples_sum_to_zero(Arrays.asList(1, 2, 3, 7))); // false\n        System.out.println(solution.triples_sum_to_zero(Arrays.asList(2, 4, -5, 3, 9, 7))); // true\n        System.out.println(solution.triples_sum_to_zero(Arrays.asList(1))); // false\n    }\n}\n"}
{"task_id": "Java/41", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Imagine a road that's a perfectly straight infinitely long line.\n    n cars are driving left to right; simultaneously, a different set of n cars\n    are driving right to left. The two sets of cars start out being very far from each other.\n    All cars move at the same speed. Two cars are said to collide when a car that's moving left to right hits a car that's moving right to left.\n    However, the cars are infinitely sturdy and strong; as a result, they continue moving in their trajectory as if they did not collide.\n\n    This function outputs the number of such collisions.\n     */\n    public int car_race_collision(int n) {\n        // Each car moving left-to-right will collide with one car moving right-to-left.\n        return n;\n    }\n}\n"}
{"task_id": "Java/42", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return list with elements incremented by 1.\n     *\n     * @param l The input list of integers.\n     * @return A new list where each element is incremented by 1.\n     */\n    public List<Integer> incr_list(List<Integer> l) {\n        return l.stream().map(i -> i + 1).collect(Collectors.toList());\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        List<Integer> list1 = Arrays.asList(1, 2, 3);\n        System.out.println(\"Original: \" + list1);\n        System.out.println(\"Incremented: \" + solution.incr_list(list1));\n\n        // Test case 2\n        List<Integer> list2 = Arrays.asList(5, 3, 5, 2, 3, 3, 9, 0, 123);\n        System.out.println(\"Original: \" + list2);\n        System.out.println(\"Incremented: \" + solution.incr_list(list2));\n    }\n}\n"}
{"task_id": "Java/43", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * pairs_sum_to_zero takes a list of integers as an input.\n     * it returns True if there are two distinct elements in the list that\n     * sum to zero, and False otherwise.\n     */\n    public boolean pairs_sum_to_zero(List<Integer> l) {\n        Set<Integer> seen = new HashSet<>();\n        for (int num : l) {\n            if (seen.contains(-num)) {\n                return true;\n            }\n            seen.add(num);\n        }\n        return false;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.pairs_sum_to_zero(Arrays.asList(1, 3, 5, 0))); // false\n        System.out.println(solution.pairs_sum_to_zero(Arrays.asList(1, 3, -2, 1))); // false\n        System.out.println(solution.pairs_sum_to_zero(Arrays.asList(1, 2, 3, 7))); // false\n        System.out.println(solution.pairs_sum_to_zero(Arrays.asList(2, 4, -5, 3, 5, 7))); // true\n        System.out.println(solution.pairs_sum_to_zero(Arrays.asList(1))); // false\n    }\n}\n"}
{"task_id": "Java/44", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Change numerical base of input number x to base.\n     * return string representation after the conversion.\n     * base numbers are less than 10.\n     *\n     * @param x The number to be converted.\n     * @param base The target base for conversion (less than 10).\n     * @return String representation of the converted number.\n     */\n    public String change_base(int x, int base) {\n        if (x == 0) return \"0\";\n        \n        StringBuilder result = new StringBuilder();\n        while (x > 0) {\n            int remainder = x % base;\n            result.insert(0, remainder);\n            x /= base;\n        }\n        \n        return result.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.change_base(8, 3));  // Expected output: \"22\"\n        System.out.println(solution.change_base(8, 2));  // Expected output: \"1000\"\n        System.out.println(solution.change_base(7, 2));  // Expected output: \"111\"\n        System.out.println(solution.change_base(255, 16)); // Expected output: \"FF\" (for base 16)\n        System.out.println(solution.change_base(10, 8));  // Expected output: \"12\"\n    }\n}\n"}
{"task_id": "Java/45", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given length of a side (base) and height, return area for a triangle.\n     *\n     * @param a The base of the triangle.\n     * @param h The height of the triangle.\n     * @return The area of the triangle.\n     */\n    public double triangle_area(double a, double h) {\n        return 0.5 * a * h;\n    }\n\n    /**\n     * Main method to run test cases for the triangle_area function.\n     *\n     * @param args Command line arguments (not used).\n     */\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(\"Test Case 1: Base = 5, Height = 3\");\n        double result1 = solution.triangle_area(5, 3);\n        System.out.println(\"Expected: 7.5, Actual: \" + result1);\n\n        System.out.println(\"\\nTest Case 2: Base = 10, Height = 4\");\n        double result2 = solution.triangle_area(10, 4);\n        System.out.println(\"Expected: 20.0, Actual: \" + result2);\n\n        System.out.println(\"\\nTest Case 3: Base = 7, Height = 8\");\n        double result3 = solution.triangle_area(7, 8);\n        System.out.println(\"Expected: 28.0, Actual: \" + result3);\n\n        // Add more test cases as needed\n    }\n}\n"}
{"task_id": "Java/46", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n    The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n    fib4(0) -> 0\n    fib4(1) -> 0\n    fib4(2) -> 2\n    fib4(3) -> 0\n    fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n    Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.\n    >>> fib4(5)\n    4\n    >>> fib4(6)\n    8\n    >>> fib4(7)\n    14\n     */\n    public int fib4(int n) {\n        if (n == 0 || n == 1) return 0;\n        if (n == 2) return 2;\n        if (n == 3) return 0;\n\n        int[] dp = new int[n + 1];\n        dp[0] = 0;\n        dp[1] = 0;\n        dp[2] = 2;\n        dp[3] = 0;\n\n        for (int i = 4; i <= n; i++) {\n            dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3] + dp[i - 4];\n        }\n\n        return dp[n];\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.fib4(5)); // Expected output: 4\n        System.out.println(solution.fib4(6)); // Expected output: 8\n        System.out.println(solution.fib4(7)); // Expected output: 14\n        System.out.println(solution.fib4(8)); // Expected output: 24\n        System.out.println(solution.fib4(9)); // Expected output: 44\n    }\n}\n"}
{"task_id": "Java/47", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return median of elements in the list l.\n     */\n    public double median(List<Integer> l) {\n        if (l == null || l.isEmpty()) {\n            throw new IllegalArgumentException(\"List cannot be null or empty\");\n        }\n\n        Collections.sort(l);\n        int size = l.size();\n        if (size % 2 == 0) {\n            return (l.get(size / 2 - 1) + l.get(size / 2)) / 2.0;\n        } else {\n            return l.get(size / 2);\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        List<Integer> testList1 = Arrays.asList(3, 1, 2, 4, 5);\n        System.out.println(\"Median of [3, 1, 2, 4, 5]: \" + solution.median(testList1)); // Expected: 3\n\n        List<Integer> testList2 = Arrays.asList(-10, 4, 6, 1000, 10, 20);\n        System.out.println(\"Median of [-10, 4, 6, 1000, 10, 20]: \" + solution.median(testList2)); // Expected: 8.0\n\n        List<Integer> testList3 = Arrays.asList(1, 2, 3, 4);\n        System.out.println(\"Median of [1, 2, 3, 4]: \" + solution.median(testList3)); // Expected: 2.5\n\n        List<Integer> testList4 = Arrays.asList(-5, -3, -1, 0, 2, 4, 6);\n        System.out.println(\"Median of [-5, -3, -1, 0, 2, 4, 6]: \" + solution.median(testList4)); // Expected: 0.0\n\n        List<Integer> testList5 = Arrays.asList();\n        try {\n            System.out.println(\"Median of []: \" + solution.median(testList5));\n        } catch (IllegalArgumentException e) {\n            System.out.println(\"Caught expected exception for empty list: \" + e.getMessage());\n        }\n\n        List<Integer> testList6 = null;\n        try {\n            System.out.println(\"Median of null: \" + solution.median(testList6));\n        } catch (IllegalArgumentException e) {\n            System.out.println(\"Caught expected exception for null list: \" + e.getMessage());\n        }\n    }\n}\n"}
{"task_id": "Java/48", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     Checks if given string is a palindrome\n     >>> is_palindrome(\"\")\n     true\n     >>> is_palindrome(\"aba\")\n     true\n     >>> is_palindrome(\"aaaaa\")\n     true\n     >>> is_palindrome(\"zbcd\")\n     false\n     */\n    public boolean is_palindrome(String text) {\n        int left = 0;\n        int right = text.length() - 1;\n\n        while (left < right) {\n            if (text.charAt(left) != text.charAt(right)) {\n                return false;\n            }\n            left++;\n            right--;\n        }\n\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.is_palindrome(\"\"));       // true\n        System.out.println(solution.is_palindrome(\"aba\"));    // true\n        System.out.println(solution.is_palindrome(\"aaaaa\"));  // true\n        System.out.println(solution.is_palindrome(\"zbcd\"));   // false\n        System.out.println(solution.is_palindrome(\"level\"));  // true\n        System.out.println(solution.is_palindrome(\"noon\"));   // true\n        System.out.println(solution.is_palindrome(\"abcde\"));  // false\n    }\n}\n"}
{"task_id": "Java/49", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return 2^n modulo p (be aware of numerics).\n     */\n    public int modp(int n, int p) {\n        if (n == 0) return 1; // Base case: 2^0 = 1\n        long result = 1;\n        for (int i = 0; i < n; i++) {\n            result = (result * 2) % p;\n        }\n        return (int) result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.modp(3, 5));   // Expected output: 3\n        System.out.println(solution.modp(1101, 101)); // Expected output: 2\n        System.out.println(solution.modp(0, 101));  // Expected output: 1\n        System.out.println(solution.modp(3, 11));   // Expected output: 8\n        System.out.println(solution.modp(100, 101)); // Expected output: 1\n    }\n}\n"}
{"task_id": "Java/50", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    returns encoded string by shifting every character by 5 in the alphabet.\n     */\n    public String encodeShift(String s) {\n        StringBuilder sb = new StringBuilder();\n        for (char ch : s.toCharArray()) {\n            sb.append((char) ('a' + ((ch - 'a' + 5) % 26)));\n        }\n        return sb.toString();\n    }\n\n    /**\n    takes as input string encoded with encodeShift function. Returns decoded string.\n     */\n    public String decode_shift(String s) {\n        StringBuilder sb = new StringBuilder();\n        for (char ch : s.toCharArray()) {\n            sb.append((char) ('a' + ((ch - 'a' - 5 + 26) % 26)));\n        }\n        return sb.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        String encodedString = solution.encodeShift(\"hello\");\n        System.out.println(\"Encoded: \" + encodedString);\n        String decodedString = solution.decode_shift(encodedString);\n        System.out.println(\"Decoded: \" + decodedString);\n    }\n}\n"}
{"task_id": "Java/51", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * remove_vowels is a function that takes string and returns string without vowels.\n     */\n    public String remove_vowels(String text) {\n        if (text == null || text.isEmpty()) {\n            return text;\n        }\n        \n        StringBuilder result = new StringBuilder();\n        for (char c : text.toCharArray()) {\n            if (!isVowel(c)) {\n                result.append(c);\n            }\n        }\n        return result.toString();\n    }\n\n    private boolean isVowel(char c) {\n        return \"AEIOUaeiou\".indexOf(c) != -1;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.remove_vowels(\"\")); // Output: \"\"\n        System.out.println(solution.remove_vowels(\"abcdef\\nghijklm\")); // Output: \"bcdf\\nghjklm\"\n        System.out.println(solution.remove_vowels(\"abcdef\")); // Output: \"bcdf\"\n        System.out.println(solution.remove_vowels(\"aaaaa\")); // Output: \"\"\n        System.out.println(solution.remove_vowels(\"aaBAA\")); // Output: \"B\"\n        System.out.println(solution.remove_vowels(\"zbcd\")); // Output: \"zbcd\"\n    }\n}\n"}
{"task_id": "Java/52", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return True if all numbers in the list l are below threshold t.\n     */\n    public boolean below_threshold(List<Integer> l, int t) {\n        for (int num : l) {\n            if (num >= t) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.below_threshold(Arrays.asList(1, 2, 4, 10), 100)); // Expected: true\n        System.out.println(solution.below_threshold(Arrays.asList(1, 20, 4, 10), 5));  // Expected: false\n        System.out.println(solution.below_threshold(Arrays.asList(-1, -2, -3), 0));    // Expected: true\n        System.out.println(solution.below_threshold(Arrays.asList(), 100));            // Expected: true (empty list)\n        System.out.println(solution.below_threshold(Arrays.asList(99, 100, 101), 100)); // Expected: false\n    }\n}\n"}
{"task_id": "Java/53", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Add two numbers x and y\n     *\n     * @param x the first integer\n     * @param y the second integer\n     * @return the sum of x and y\n     */\n    public int add(int x, int y) {\n        return x + y;\n    }\n}\n"}
{"task_id": "Java/54", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Check if two words have the same kind of characters.\n     */\n    public boolean same_chars(String s0, String s1) {\n        // Convert both strings to sets of characters\n        Set<Character> set0 = new HashSet<>();\n        for (char c : s0.toCharArray()) {\n            set0.add(c);\n        }\n        \n        Set<Character> set1 = new HashSet<>();\n        for (char c : s1.toCharArray()) {\n            set1.add(c);\n        }\n        \n        // Compare the sets\n        return set0.equals(set1);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.same_chars(\"eabcdzzzz\", \"dddzzzzzzzddeddabc\")); // true\n        System.out.println(solution.same_chars(\"abcd\", \"dddddddabc\"));              // true\n        System.out.println(solution.same_chars(\"dddddddabc\", \"abcd\"));              // true\n        System.out.println(solution.same_chars(\"eabcd\", \"dddddddabc\"));             // false\n        System.out.println(solution.same_chars(\"abcd\", \"dddddddabce\"));             // false\n        System.out.println(solution.same_chars(\"eabcdzzzz\", \"dddzzzzzzzddddabc\"));  // false\n    }\n}\n"}
{"task_id": "Java/55", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return n-th Fibonacci number.\n     * >>> fib(10)\n     * 55\n     * >>> fib(1)\n     * 1\n     * >>> fib(8)\n     * 21\n     */\n    public int fib(int n) {\n        if (n <= 0) {\n            return 0;\n        } else if (n == 1) {\n            return 1;\n        }\n        \n        int a = 0, b = 1, c = 0;\n        for (int i = 2; i <= n; i++) {\n            c = a + b;\n            a = b;\n            b = c;\n        }\n        return b;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(\"fib(10): \" + solution.fib(10)); // Expected: 55\n        System.out.println(\"fib(1): \" + solution.fib(1));   // Expected: 1\n        System.out.println(\"fib(8): \" + solution.fib(8));   // Expected: 21\n        System.out.println(\"fib(0): \" + solution.fib(0));   // Expected: 0\n        System.out.println(\"fib(-5): \" + solution.fib(-5)); // Expected: 0 (or handle as an error)\n    }\n}\n"}
{"task_id": "Java/56", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * brackets is a string of \"<\" and \">\".\n     * return True if every opening bracket has a corresponding closing bracket.\n     *\n     * >>> correct_bracketing(\"<\")\n     * false\n     * >>> correct_bracketing(\"<>\")\n     * true\n     * >>> correct_bracketing(\"<<><>>\")\n     * true\n     * >>> correct_bracketing(\"><<>\")\n     * false\n     */\n    public boolean correct_bracketing(String brackets) {\n        int balance = 0;\n        for (char c : brackets.toCharArray()) {\n            if (c == '<') {\n                balance++;\n            } else if (c == '>') {\n                balance--;\n            }\n            // If at any point the balance is negative, it means there's a closing bracket without an opening one\n            if (balance < 0) {\n                return false;\n            }\n        }\n        // If the balance is zero, all brackets are correctly matched\n        return balance == 0;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.correct_bracketing(\"<\"));      // false\n        System.out.println(solution.correct_bracketing(\"<>\"));     // true\n        System.out.println(solution.correct_bracketing(\"<<><>>\")); // true\n        System.out.println(solution.correct_bracketing(\"><<>\"));   // false\n    }\n}\n"}
{"task_id": "Java/57", "generation": "import java.util.List;\n\nclass Solution {\n    public boolean monotonic(List<Integer> l) {\n        boolean increasing = true;\n        boolean decreasing = true;\n        \n        for (int i = 1; i < l.size(); i++) {\n            if (!increasing && !decreasing) {\n                break;\n            }\n            \n            if (l.get(i) < l.get(i - 1)) {\n                increasing = false;\n            }\n            if (l.get(i) > l.get(i - 1)) {\n                decreasing = false;\n            }\n        }\n        \n        return increasing || decreasing;\n    }\n}\n"}
{"task_id": "Java/58", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return sorted unique common elements for two lists.\n     */\n    public List<Integer> common(List<Integer> l1, List<Integer> l2) {\n        Set<Integer> set1 = new HashSet<>(l1);\n        Set<Integer> set2 = new HashSet<>(l2);\n\n        // Retain only the elements that are present in both sets\n        set1.retainAll(set2);\n\n        // Convert the resulting set to a sorted list\n        List<Integer> result = new ArrayList<>(set1);\n        Collections.sort(result);\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        List<Integer> l1 = Arrays.asList(1, 4, 3, 34, 653, 2, 5);\n        List<Integer> l2 = Arrays.asList(5, 7, 1, 5, 9, 653, 121);\n        System.out.println(\"Common elements (Test case 1): \" + solution.common(l1, l2)); // Expected: [1, 5, 653]\n\n        // Test case 2\n        List<Integer> l3 = Arrays.asList(5, 3, 2, 8);\n        List<Integer> l4 = Arrays.asList(3, 2);\n        System.out.println(\"Common elements (Test case 2): \" + solution.common(l3, l4)); // Expected: [2, 3]\n\n        // Test case 3\n        List<Integer> l5 = Arrays.asList(10, 20, 30, 40);\n        List<Integer> l6 = Arrays.asList(50, 60, 70);\n        System.out.println(\"Common elements (Test case 3): \" + solution.common(l5, l6)); // Expected: []\n\n        // Test case 4\n        List<Integer> l7 = Arrays.asList(1, 2, 3, 4, 5);\n        List<Integer> l8 = Arrays.asList(3, 4, 5, 6, 7);\n        System.out.println(\"Common elements (Test case 4): \" + solution.common(l7, l8)); // Expected: [3, 4, 5]\n    }\n}\n"}
{"task_id": "Java/59", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Return the largest prime factor of n. Assume n > 1 and is not a prime.\n     *\n     * @param n The number to find the largest prime factor for.\n     * @return The largest prime factor of n.\n     */\n    public int largest_prime_factor(int n) {\n        boolean[] isPrime = new boolean[n + 1];\n        \n        // Initialize all numbers as prime\n        Arrays.fill(isPrime, true);\n        isPrime[0] = false;\n        isPrime[1] = false;\n\n        // Sieve of Eratosthenes to mark non-prime numbers\n        for (int factor = 2; factor * factor <= n; factor++) {\n            if (isPrime[factor]) {\n                for (int multiple = factor * factor; multiple <= n; multiple += factor) {\n                    isPrime[multiple] = false;\n                }\n            }\n        }\n\n        int largestFactor = 2;\n\n        // Find the largest prime factor\n        for (int i = 2; i * i <= n; i++) {\n            if (isPrime[i]) {\n                while (n % i == 0) {\n                    largestFactor = i;\n                    n /= i;\n                }\n            }\n        }\n\n        // If n is still greater than 1, then it must be a prime number\n        if (n > 1) {\n            largestFactor = n;\n        }\n\n        return largestFactor;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.largest_prime_factor(13195)); // Output: 29\n        System.out.println(solution.largest_prime_factor(2048));  // Output: 2\n    }\n}\n"}
{"task_id": "Java/60", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * sum_to_n is a function that sums numbers from 1 to n.\n     */\n    public int sum_to_n(int n) {\n        return (n * (n + 1)) / 2;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(\"sum_to_n(30): \" + solution.sum_to_n(30)); // Expected: 465\n        System.out.println(\"sum_to_n(100): \" + solution.sum_to_n(100)); // Expected: 5050\n        System.out.println(\"sum_to_n(5): \" + solution.sum_to_n(5)); // Expected: 15\n        System.out.println(\"sum_to_n(10): \" + solution.sum_to_n(10)); // Expected: 55\n        System.out.println(\"sum_to_n(1): \" + solution.sum_to_n(1)); // Expected: 1\n    }\n}\n"}
{"task_id": "Java/61", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * brackets is a string of \"(\" and \")\".\n     * return True if every opening bracket has a corresponding closing bracket.\n     *\n     * >>> correct_bracketing(\"(\")\n     * false\n     * >>> correct_bracketing(\"()\")\n     * true\n     * >>> correct_bracketing(\"(()())\")\n     * true\n     * >>> correct_bracketing(\")(()\")\n     * false\n     */\n    public boolean correct_bracketing(String brackets) {\n        Stack<Character> stack = new Stack<>();\n        \n        for (char c : brackets.toCharArray()) {\n            if (c == '(') {\n                stack.push(c);\n            } else if (c == ')') {\n                if (stack.isEmpty()) {\n                    return false;\n                }\n                stack.pop();\n            }\n        }\n        \n        return stack.isEmpty();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.correct_bracketing(\"(\"));       // Output: false\n        System.out.println(solution.correct_bracketing(\"()\"));      // Output: true\n        System.out.println(solution.correct_bracketing(\"(()())\"));  // Output: true\n        System.out.println(solution.correct_bracketing(\")(()\"));    // Output: false\n        System.out.println(solution.correct_bracketing(\"(())\"));    // Output: true\n        System.out.println(solution.correct_bracketing(\"()()\"));    // Output: true\n        System.out.println(solution.correct_bracketing(\"(()\"));     // Output: false\n        System.out.println(solution.correct_bracketing(\")(\"));      // Output: false\n    }\n}\n"}
{"task_id": "Java/62", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * xs represent coefficients of a polynomial.\n     * xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     * Return derivative of this polynomial in the same form.\n     */\n    public List<Integer> derivative(List<Integer> xs) {\n        if (xs == null || xs.isEmpty()) {\n            return Collections.emptyList();\n        }\n        \n        List<Integer> result = new ArrayList<>();\n        for (int i = 1; i < xs.size(); i++) {\n            result.add(xs.get(i) * i);\n        }\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(\"Derivative of [3, 1, 2, 4, 5]: \" + solution.derivative(Arrays.asList(3, 1, 2, 4, 5)));\n        System.out.println(\"Derivative of [1, 2, 3]: \" + solution.derivative(Arrays.asList(1, 2, 3)));\n\n        // Additional test cases\n        System.out.println(\"Derivative of [0, 1, 2, 3]: \" + solution.derivative(Arrays.asList(0, 1, 2, 3)));\n        System.out.println(\"Derivative of [5]: \" + solution.derivative(Arrays.asList(5)));\n        System.out.println(\"Derivative of []: \" + solution.derivative(new ArrayList<>()));\n    }\n}\n"}
{"task_id": "Java/63", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     The FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n     fibfib(0) == 0\n     fibfib(1) == 0\n     fibfib(2) == 1\n     fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n     Please write a function to efficiently compute the n-th element of the fibfib number sequence.\n     >>> fibfib(1)\n     0\n     >>> fibfib(5)\n     4\n     >>> fibfib(8)\n     24\n      */\n    public int fibfib(int n) {\n        if (n == 0 || n == 1) return 0;\n        if (n == 2) return 1;\n\n        int a = 0, b = 0, c = 1;\n        for (int i = 3; i <= n; i++) {\n            int temp = a + b + c;\n            a = b;\n            b = c;\n            c = temp;\n        }\n        return c;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.fibfib(1));  // Expected output: 0\n        System.out.println(solution.fibfib(5));  // Expected output: 4\n        System.out.println(solution.fibfib(8));  // Expected output: 24\n        System.out.println(solution.fibfib(10)); // Expected output: 76\n    }\n}\n"}
{"task_id": "Java/64", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Write a function vowels_count which takes a string representing\n     * a word as input and returns the number of vowels in the string.\n     * Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n     * vowel, but only when it is at the end of the given word.\n     *\n     * Example:\n     * >>> vowels_count(\"abcde\")\n     * 2\n     * >>> vowels_count(\"ACEDY\")\n     * 3\n     */\n    public int vowels_count(String s) {\n        int count = 0;\n        for (int i = 0; i < s.length(); i++) {\n            char c = Character.toLowerCase(s.charAt(i));\n            if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n                count++;\n            } else if (c == 'y' && i == s.length() - 1) {\n                count++;\n            }\n        }\n        return count;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.vowels_count(\"abcde\")); // Expected output: 2\n        System.out.println(solution.vowels_count(\"ACEDY\")); // Expected output: 3\n        System.out.println(solution.vowels_count(\"rhythm\")); // Expected output: 0\n        System.out.println(solution.vowels_count(\"encyclopedia\")); // Expected output: 6\n        System.out.println(solution.vowels_count(\"quickly\")); // Expected output: 1\n    }\n}\n"}
{"task_id": "Java/65", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public String circular_shift(int x, int shift) {\n        // Convert the integer to a string to easily manipulate digits\n        String strX = Integer.toString(x);\n        int numDigits = strX.length();\n\n        // If shift is greater than the number of digits, reverse the string\n        if (shift > numDigits) {\n            return new StringBuilder(strX).reverse().toString();\n        }\n\n        // Perform the circular shift\n        shift %= numDigits;  // Handle cases where shift is larger than the number of digits\n        String shiftedStr = strX.substring(numDigits - shift) + strX.substring(0, numDigits - shift);\n        return shiftedStr;\n    }\n}\n"}
{"task_id": "Java/66", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Write a function that takes a string as input and returns the sum of the upper characters only ASCII codes.\n     *\n     * Examples:\n     * digitSum(\"\") => 0\n     * digitSum(\"abAB\") => 131\n     * digitSum(\"abcCd\") => 67\n     * digitSum(\"helloE\") => 69\n     * digitSum(\"woArBld\") => 131\n     * digitSum(\"aAaaaXa\") => 153\n     */\n    public int digitSum(String s) {\n        int sum = 0;\n        for (char c : s.toCharArray()) {\n            if (Character.isUpperCase(c)) {\n                sum += c;\n            }\n        }\n        return sum;\n    }\n\n    // Test cases to verify the correctness of the method\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.digitSum(\"\")); // Expected output: 0\n        System.out.println(solution.digitSum(\"abAB\")); // Expected output: 131 ('A' + 'B')\n        System.out.println(solution.digitSum(\"abcCd\")); // Expected output: 67 ('C' + 'D')\n        System.out.println(solution.digitSum(\"helloE\")); // Expected output: 69 ('E')\n        System.out.println(solution.digitSum(\"woArBld\")); // Expected output: 131 ('A' + 'B' + 'L' + 'D')\n        System.out.println(solution.digitSum(\"aAaaaXa\")); // Expected output: 153 ('A' * 4 + 'X')\n    }\n}\n"}
{"task_id": "Java/67", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * In this task, you will be given a string that represents a number of apples and oranges\n     * that are distributed in a basket of fruit. The basket contains apples, oranges, and mango fruits.\n     * Given the string that represents the total number of the oranges and apples and an integer that represent the total number of the fruits\n     * in the basket return the number of the mango fruits in the basket.\n     *\n     * @param s a string representing the number of apples and oranges (e.g., \"5 apples and 6 oranges\")\n     * @param n the total number of fruits in the basket\n     * @return the number of mango fruits in the basket\n     */\n    public int fruit_distribution(String s, int n) {\n        // Extract the numbers from the string\n        String[] parts = s.split(\" \");\n        int apples = Integer.parseInt(parts[0]);\n        int oranges = Integer.parseInt(parts[3]);\n\n        // Calculate the number of mangoes\n        return n - (apples + oranges);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.fruit_distribution(\"5 apples and 6 oranges\", 19)); // Expected output: 8\n        System.out.println(solution.fruit_distribution(\"0 apples and 1 oranges\", 3));   // Expected output: 2\n        System.out.println(solution.fruit_distribution(\"2 apples and 3 oranges\", 100)); // Expected output: 95\n        System.out.println(solution.fruit_distribution(\"100 apples and 1 oranges\", 120)); // Expected output: 19\n    }\n}\n"}
{"task_id": "Java/68", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given an array representing a branch of a tree that has non-negative integer nodes,\n     * your task is to pluck one of the nodes and return it.\n     * The plucked node should be the node with the smallest even value.\n     * If multiple nodes with the same smallest even value are found, return the node that has the smallest index.\n     *\n     * @param arr the list of integer values representing tree branch nodes\n     * @return a list containing the smallest even value and its index, or an empty list if no valid node is found\n     */\n    public List<Integer> pluck(List<Integer> arr) {\n        int minEvenValue = Integer.MAX_VALUE;\n        int minIndex = -1;\n\n        for (int i = 0; i < arr.size(); i++) {\n            int value = arr.get(i);\n            if (value % 2 == 0 && value <= minEvenValue) {\n                if (value < minEvenValue || (value == minEvenValue && i < minIndex)) {\n                    minEvenValue = value;\n                    minIndex = i;\n                }\n            }\n        }\n\n        if (minIndex == -1) {\n            return new ArrayList<>();\n        } else {\n            return Arrays.asList(minEvenValue, minIndex);\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.pluck(Arrays.asList(4, 2, 3))); // Output: [2, 1]\n        System.out.println(solution.pluck(Arrays.asList(1, 2, 3))); // Output: [2, 1]\n        System.out.println(solution.pluck(Arrays.asList()));       // Output: []\n        System.out.println(solution.pluck(Arrays.asList(5, 0, 3, 0, 4, 2))); // Output: [0, 1]\n    }\n}\n"}
{"task_id": "Java/69", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * You are given a non-empty list of positive integers. Return the greatest integer that is greater than\n     * zero, and has a frequency greater than or equal to the value of the integer itself.\n     * The frequency of an integer is the number of times it appears in the list.\n     * If no such a value exist, return -1.\n     *\n     * Examples:\n     * search(Arrays.asList(4, 1, 2, 2, 3, 1)) == 2\n     * search(Arrays.asList(1, 2, 2, 3, 3, 3, 4, 4, 4)) == 3\n     * search(Arrays.asList(5, 5, 4, 4, 4)) == -1\n     */\n    public int search(List<Integer> lst) {\n        Map<Integer, Integer> frequencyMap = new HashMap<>();\n        \n        // Count the frequency of each integer in the list\n        for (int num : lst) {\n            frequencyMap.put(num, frequencyMap.getOrDefault(num, 0) + 1);\n        }\n        \n        int result = -1;\n        \n        // Check which integers meet the criteria and find the greatest one\n        for (Map.Entry<Integer, Integer> entry : frequencyMap.entrySet()) {\n            if (entry.getKey() <= entry.getValue()) {\n                result = Math.max(result, entry.getKey());\n            }\n        }\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.search(Arrays.asList(4, 1, 2, 2, 3, 1))); // Expected output: 2\n        System.out.println(solution.search(Arrays.asList(1, 2, 2, 3, 3, 3, 4, 4, 4))); // Expected output: 3\n        System.out.println(solution.search(Arrays.asList(5, 5, 4, 4, 4))); // Expected output: -1\n        System.out.println(solution.search(Arrays.asList(6, 6, 6, 7, 7, 8, 8, 8, 8))); // Expected output: 8\n    }\n}\n"}
{"task_id": "Java/70", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given list of integers, return list in strange order.\n     * Strange sorting, is when you start with the minimum value,\n     * then maximum of the remaining integers, then minimum and so on.\n     *\n     * Examples:\n     * strange_sort_list(Arrays.asList(1, 2, 3, 4)) == Arrays.asList(1, 4, 2, 3)\n     * strange_sort_list(Arrays.asList(5, 5, 5, 5)) == Arrays.asList(5, 5, 5, 5)\n     * strange_sort_list(Arrays.asList()) == Arrays.asList()\n     */\n    public List<Integer> strange_sort_list(List<Integer> lst) {\n        List<Integer> result = new ArrayList<>();\n        while (!lst.isEmpty()) {\n            // Add the minimum value\n            int minVal = Collections.min(lst);\n            result.add(minVal);\n            lst.remove(Integer.valueOf(minVal));\n            \n            if (lst.isEmpty()) break;\n            \n            // Add the maximum value\n            int maxVal = Collections.max(lst);\n            result.add(maxVal);\n            lst.remove(Integer.valueOf(maxVal));\n        }\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.strange_sort_list(Arrays.asList(1, 2, 3, 4))); // Expected: [1, 4, 2, 3]\n        System.out.println(solution.strange_sort_list(Arrays.asList(5, 5, 5, 5))); // Expected: [5, 5, 5, 5]\n        System.out.println(solution.strange_sort_list(Arrays.asList()));           // Expected: []\n        System.out.println(solution.strange_sort_list(Arrays.asList(10, 20, 30, 40, 50))); // Expected: [10, 50, 20, 40, 30]\n    }\n}\n"}
{"task_id": "Java/71", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n\n    /**\n     * Given the lengths of the three sides of a triangle. Return the area of\n     * the triangle rounded to 2 decimal points if the three sides form a valid triangle.\n     * Otherwise return -1.\n     * Three sides make a valid triangle when the sum of any two sides is greater\n     * than the third side.\n     * Example:\n     * triangle_area(3, 4, 5) == 6.00\n     * triangle_area(1, 2, 10) == -1\n     */\n    public double triangle_area(double a, double b, double c) {\n        // Check if the sides form a valid triangle\n        if (a + b <= c || a + c <= b || b + c <= a) {\n            return -1;\n        }\n        \n        // Calculate the semi-perimeter\n        double s = (a + b + c) / 2.0;\n\n        // Calculate the area using Heron's formula\n        double area = Math.sqrt(s * (s - a) * (s - b) * (s - c));\n        \n        // Round to 2 decimal points\n        return Math.round(area * 100.0) / 100.0;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.triangle_area(3, 4, 5)); // Expected output: 6.00\n        System.out.println(solution.triangle_area(1, 2, 10)); // Expected output: -1\n        System.out.println(solution.triangle_area(7, 8, 9)); // Expected output: ~26.83\n        System.out.println(solution.triangle_area(5, 5, 5)); // Expected output: 10.83\n    }\n}\n"}
{"task_id": "Java/72", "generation": "import java.util.*;\n\nclass Solution {\n\n    /**\n     * Write a function that returns True if the object q will fly, and False otherwise.\n     * The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal to the maximum possible weight w.\n     *\n     * @param q A List<Integer> representing the object\n     * @param w An integer representing the maximum possible weight\n     * @return boolean indicating if the object will fly\n     */\n    public boolean will_it_fly(List<Integer> q, int w) {\n        // Check if the list is a palindrome\n        for (int i = 0; i < q.size() / 2; i++) {\n            if (!q.get(i).equals(q.get(q.size() - 1 - i))) {\n                return false;\n            }\n        }\n\n        // Calculate the sum of elements in the list\n        int sum = q.stream().mapToInt(Integer::intValue).sum();\n\n        // Check if the sum is less than or equal to w\n        return sum <= w;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.will_it_fly(Arrays.asList(1, 2), 5));   // false\n        System.out.println(solution.will_it_fly(Arrays.asList(3, 2, 3), 1)); // false\n        System.out.println(solution.will_it_fly(Arrays.asList(3, 2, 3), 9)); // true\n        System.out.println(solution.will_it_fly(Arrays.asList(3), 5));      // true\n    }\n}\n"}
{"task_id": "Java/73", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given an array arr of integers, find the minimum number of elements that\n     * need to be changed to make the array palindromic. A palindromic array is an array that\n     * is read the same backwards and forwards. In one change, you can change one element to any other element.\n     *\n     * For example:\n     * smallest_change(Arrays.asList(1,2,3,5,4,7,9,6)) == 4\n     * smallest_change(Arrays.asList(1, 2, 3, 4, 3, 2, 2)) == 1\n     * smallest_change(Arrays.asList(1, 2, 3, 2, 1)) == 0\n     */\n    public int smallest_change(List<Integer> arr) {\n        int left = 0;\n        int right = arr.size() - 1;\n        int changes = 0;\n\n        while (left < right) {\n            if (!arr.get(left).equals(arr.get(right))) {\n                changes++;\n            }\n            left++;\n            right--;\n        }\n\n        return changes;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.smallest_change(Arrays.asList(1, 2, 3, 5, 4, 7, 9, 6))); // Output: 4\n        System.out.println(solution.smallest_change(Arrays.asList(1, 2, 3, 4, 3, 2, 2)));    // Output: 1\n        System.out.println(solution.smallest_change(Arrays.asList(1, 2, 3, 2, 1)));          // Output: 0\n        System.out.println(solution.smallest_change(Arrays.asList(1, 2, 3, 4, 5, 6, 7)));    // Output: 3\n        System.out.println(solution.smallest_change(Arrays.asList(8, 9, 8, 9, 8, 9, 8)));   // Output: 0\n    }\n}\n"}
{"task_id": "Java/74", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Write a function that accepts two lists of strings and returns the list that has\n     * total number of chars in the all strings of the list less than the other list.\n     *\n     * if the two lists have the same number of chars, return the first list.\n     */\n    public List<String> total_match(List<String> lst1, List<String> lst2) {\n        int count1 = 0;\n        for (String s : lst1) {\n            count1 += s.length();\n        }\n        \n        int count2 = 0;\n        for (String s : lst2) {\n            count2 += s.length();\n        }\n\n        if (count1 <= count2) {\n            return lst1;\n        } else {\n            return lst2;\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.total_match(new ArrayList<>(), new ArrayList<>())); // []\n        System.out.println(solution.total_match(Arrays.asList(\"hi\", \"admin\"), Arrays.asList(\"hI\", \"Hi\"))); // [\"hI\", \"Hi\"]\n        System.out.println(solution.total_match(Arrays.asList(\"hi\", \"admin\"), Arrays.asList(\"hi\", \"hi\", \"admin\", \"project\"))); // [\"hi\", \"admin\"]\n        System.out.println(solution.total_match(Arrays.asList(\"hi\", \"admin\"), Arrays.asList(\"hI\", \"hi\", \"hi\"))); // [\"hI\", \"hi\", \"hi\"]\n        System.out.println(solution.total_match(Arrays.asList(\"4\"), Arrays.asList(\"1\", \"2\", \"3\", \"4\", \"5\"))); // [\"4\"]\n    }\n}\n"}
{"task_id": "Java/75", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Write a function that returns true if the given number is the multiplication of 3 prime numbers\n     * and false otherwise.\n     * Knowing that the prime number is less than 100.\n     * Example:\n     * is_multiply_prime(30) == true\n     * 30 = 2 * 3 * 5\n     */\n    public boolean is_multiply_prime(int a) {\n        if (a < 2) return false;\n\n        int count = 0;\n        for (int i = 2; i <= Math.sqrt(a); i++) {\n            while (a % i == 0 && isPrime(i)) {\n                count++;\n                a /= i;\n            }\n        }\n\n        // Check if the remaining number is also prime and part of the product\n        if (a > 1 && isPrime(a)) {\n            count++;\n        }\n\n        return count == 3;\n    }\n\n    private boolean isPrime(int n) {\n        if (n <= 1) return false;\n        for (int i = 2; i * i <= n; i++) {\n            if (n % i == 0) return false;\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.is_multiply_prime(30)); // true, because 30 = 2 * 3 * 5\n        System.out.println(solution.is_multiply_prime(60)); // false, because 60 = 2 * 2 * 3 * 5 (more than 3 primes)\n        System.out.println(solution.is_multiply_prime(100)); // false, because 100 is not a product of exactly 3 primes\n        System.out.println(solution.is_multiply_prime(30030)); // true, because 30030 = 2 * 3 * 5 * 7 * 11 * 13 (more than 3 primes)\n        System.out.println(solution.is_multiply_prime(2 * 3 * 7)); // true, because 42 = 2 * 3 * 7\n    }\n}\n"}
{"task_id": "Java/76", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Your task is to write a function that returns true if a number x is a simple\n     * power of n and false in other cases.\n     * x is a simple power of n if n**int=x\n     * For example:\n     * is_simple_power(1, 4) => true\n     * is_simple_power(2, 2) => true\n     * is_simple_power(8, 2) => true\n     * is_simple_power(3, 2) => false\n     * is_simple_power(3, 1) => false\n     * is_simple_power(5, 3) => false\n     */\n    public boolean is_simple_power(int x, int n) {\n        if (n == 1) {\n            return x == 1;\n        }\n        \n        double power = Math.pow(n, Math.round(Math.log(x) / Math.log(n)));\n        return Math.abs(power - x) < 0.0001; // Allowing a small floating point tolerance\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.is_simple_power(1, 4));   // true\n        System.out.println(solution.is_simple_power(2, 2));   // true\n        System.out.println(solution.is_simple_power(8, 2));   // true\n        System.out.println(solution.is_simple_power(3, 2));   // false\n        System.out.println(solution.is_simple_power(3, 1));   // false\n        System.out.println(solution.is_simple_power(5, 3));   // false\n        System.out.println(solution.is_simple_power(16, 2));  // true\n        System.out.println(solution.is_simple_power(81, 3));  // true\n        System.out.println(solution.is_simple_power(27, 3));  // true\n        System.out.println(solution.is_simple_power(49, 7));  // true\n    }\n}\n"}
{"task_id": "Java/77", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Write a function that takes an integer a and returns true\n     * if this integer is a cube of some integer number.\n     * Note: you may assume the input is always valid.\n     * Examples:\n     * iscube(1) ==> true\n     * iscube(2) ==> false\n     * iscube(-1) ==> true\n     * iscube(64) ==> true\n     * iscube(0) ==> true\n     * iscube(180) ==> false\n     */\n    public boolean iscube(int a) {\n        if (a == 0) return true;\n        \n        // Handle negative numbers by checking the cube root and squaring it back\n        double cubeRoot = Math.cbrt(a);\n        int roundedCubeRoot = (int) Math.round(cubeRoot);\n        \n        return Math.pow(roundedCubeRoot, 3) == a;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.iscube(1));   // true\n        System.out.println(solution.iscube(2));   // false\n        System.out.println(solution.iscube(-1));  // true\n        System.out.println(solution.iscube(64));  // true\n        System.out.println(solution.iscube(0));   // true\n        System.out.println(solution.iscube(180)); // false\n    }\n}\n"}
{"task_id": "Java/78", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * You have been tasked to write a function that receives\n     * a hexadecimal number as a string and counts the number of hexadecimal\n     * digits that are primes (prime number, or a prime, is a natural number\n     * greater than 1 that is not a product of two smaller natural numbers).\n     * Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n     * Prime numbers are 2, 3, 5, 7, B (=decimal 11), D (=decimal 13).\n     * So you have to determine a number of the following digits: 2, 3, 5, 7,\n     * B (=decimal 11), D (=decimal 13).\n     * Note: you may assume the input is always correct or empty string,\n     * and symbols A,B,C,D,E,F are always uppercase.\n     * Examples:\n     * For num = \"AB\" the output should be 1.\n     * For num = \"1077E\" the output should be 2.\n     * For num = \"ABED1A33\" the output should be 4.\n     * For num = \"123456789ABCDEF0\" the output should be 6.\n     * For num = \"2020\" the output should be 2.\n     */\n    public int hex_key(String num) {\n        // Define a set of prime hexadecimal digits\n        Set<Character> primes = new HashSet<>(Arrays.asList('2', '3', '5', '7', 'B', 'D'));\n        \n        // Count the number of prime hexadecimal digits in the input string\n        int count = 0;\n        for (char c : num.toCharArray()) {\n            if (primes.contains(c)) {\n                count++;\n            }\n        }\n        \n        return count;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.hex_key(\"AB\")); // Expected output: 1\n        System.out.println(solution.hex_key(\"1077E\")); // Expected output: 2\n        System.out.println(solution.hex_key(\"ABED1A33\")); // Expected output: 4\n        System.out.println(solution.hex_key(\"123456789ABCDEF0\")); // Expected output: 6\n        System.out.println(solution.hex_key(\"2020\")); // Expected output: 2\n    }\n}\n"}
{"task_id": "Java/79", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * You will be given a number in decimal form and your task is to convert it to\n     * binary format. The function should return a string, with each character representing a binary\n     * number. Each character in the string will be '0' or '1'.\n     *\n     * There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n     * The extra characters are there to help with the format.\n     *\n     * Examples:\n     * decimal_to_binary(15)   // returns \"db1111db\"\n     * decimal_to_binary(32)   // returns \"db100000db\"\n     */\n    public String decimal_to_binary(int decimal) {\n        if (decimal == 0) return \"db0db\";\n        \n        StringBuilder binary = new StringBuilder();\n        while (decimal > 0) {\n            binary.insert(0, decimal % 2);\n            decimal /= 2;\n        }\n        \n        return \"db\" + binary.toString() + \"db\";\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.decimal_to_binary(15));   // Expected: db1111db\n        System.out.println(solution.decimal_to_binary(32));   // Expected: db100000db\n        System.out.println(solution.decimal_to_binary(0));    // Expected: db0db\n        System.out.println(solution.decimal_to_binary(456));  // Expected: db111001000db\n        System.out.println(solution.decimal_to_binary(255));  // Expected: db11111111db\n    }\n}\n"}
{"task_id": "Java/80", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * You are given a string s.\n     * Your task is to check if the string is happy or not.\n     * A string is happy if its length is at least 3 and every 3 consecutive letters are distinct\n     * For example:\n     * is_happy(a) => false\n     * is_happy(aa) => false\n     * is_happy(abcd) => true\n     * is_happy(aabb) => false\n     * is_happy(adb) => true\n     * is_happy(xyy) => false\n     */\n    public boolean is_happy(String s) {\n        if (s.length() < 3) return false;\n        \n        for (int i = 0; i <= s.length() - 3; i++) {\n            char first = s.charAt(i);\n            char second = s.charAt(i + 1);\n            char third = s.charAt(i + 2);\n            \n            if (first == second || second == third || first == third) {\n                return false;\n            }\n        }\n        \n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.is_happy(\"a\"));       // Output: false\n        System.out.println(solution.is_happy(\"aa\"));      // Output: false\n        System.out.println(solution.is_happy(\"abcd\"));    // Output: true\n        System.out.println(solution.is_happy(\"aabb\"));    // Output: false\n        System.out.println(solution.is_happy(\"adb\"));     // Output: true\n        System.out.println(solution.is_happy(\"xyy\"));     // Output: false\n        System.out.println(solution.is_happy(\"abcabc\"));  // Output: true\n        System.out.println(solution.is_happy(\"abacaba\")); // Output: false\n    }\n}\n"}
{"task_id": "Java/81", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * It is the last week of the semester and the teacher has to give the grades\n     * to students. The teacher has been making her own algorithm for grading.\n     * The only problem is, she has lost the code she used for grading.\n     * She has given you a list of GPAs for some students and you have to write\n     * a function that can output a list of letter grades using the following table:\n     *             GPA       |    Letter grade\n     *              4.0                A+\n     *            > 3.7                A\n     *            > 3.3                A-\n     *            > 3.0                B+\n     *            > 2.7                B\n     *            > 2.3                B-\n     *            > 2.0                C+\n     *            > 1.7                C\n     *            > 1.3                C-\n     *            > 1.0                D+\n     *            > 0.7                D\n     *            > 0.0                D-\n     *              0.0                E\n\n     * Example:\n     * numerical_letter_grade(Arrays.asList(4.0, 3, 1.7, 2, 3.5)) ==> [\"A+\", \"B\", \"C-\", \"C\", \"A-\"]\n     */\n    public List<String> numerical_letter_grade(List<Double> grades) {\n        List<String> letterGrades = new ArrayList<>();\n        \n        for (double gpa : grades) {\n            if (gpa >= 4.0) {\n                letterGrades.add(\"A+\");\n            } else if (gpa > 3.7) {\n                letterGrades.add(\"A\");\n            } else if (gpa > 3.3) {\n                letterGrades.add(\"A-\");\n            } else if (gpa > 3.0) {\n                letterGrades.add(\"B+\");\n            } else if (gpa > 2.7) {\n                letterGrades.add(\"B\");\n            } else if (gpa > 2.3) {\n                letterGrades.add(\"B-\");\n            } else if (gpa > 2.0) {\n                letterGrades.add(\"C+\");\n            } else if (gpa > 1.7) {\n                letterGrades.add(\"C\");\n            } else if (gpa > 1.3) {\n                letterGrades.add(\"C-\");\n            } else if (gpa > 1.0) {\n                letterGrades.add(\"D+\");\n            } else if (gpa > 0.7) {\n                letterGrades.add(\"D\");\n            } else if (gpa > 0.0) {\n                letterGrades.add(\"D-\");\n            } else {\n                letterGrades.add(\"E\");\n            }\n        }\n\n        return letterGrades;\n    }\n}\n"}
{"task_id": "Java/82", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Write a function that takes a string and returns true if the string\n     * length is a prime number or false otherwise\n     * Examples:\n     * prime_length(\"Hello\") == true\n     * prime_length(\"abcdcba\") == true\n     * prime_length(\"kittens\") == true\n     * prime_length(\"orange\") == false\n     */\n    public boolean prime_length(String string) {\n        int length = string.length();\n        return isPrime(length);\n    }\n\n    private boolean isPrime(int number) {\n        if (number <= 1) {\n            return false;\n        }\n        for (int i = 2; i * i <= number; i++) {\n            if (number % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.prime_length(\"Hello\"));   // true\n        System.out.println(solution.prime_length(\"abcdcba\")); // true\n        System.out.println(solution.prime_length(\"kittens\")); // true\n        System.out.println(solution.prime_length(\"orange\"));  // false\n    }\n}\n"}
{"task_id": "Java/83", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a positive integer n, return the count of the numbers of n-digit\n     * positive integers that start or end with 1.\n     */\n    public int starts_one_ends(int n) {\n        if (n == 1) {\n            return 1; // Only one 1-digit number that starts and ends with 1\n        }\n        \n        // For n > 1, calculate the count of numbers starting or ending with 1\n        long totalCount = ((9 * (long)Math.pow(10, n - 2)) * 2) - (long)Math.pow(10, n - 2);\n        return (int) totalCount;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.starts_one_ends(1)); // Output: 1\n        System.out.println(solution.starts_one_ends(2)); // Output: 18\n        System.out.println(solution.starts_one_ends(3)); // Output: 180\n    }\n}\n"}
{"task_id": "Java/84", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     Given a positive integer N, return in binary the total sum of its digits.\n\n     Example\n         For N = 1000, the sum of digits will be 1 the output should be \"1\".\n         For N = 150, the sum of digits will be 6 the output should be \"110\".\n         For N = 147, the sum of digits will be 12 the output should be \"1100\".\n\n     Variables:\n         @N integer\n              Constraints: 0 <= N <= 10000.\n     Output:\n          a string of binary number\n      */\n    public String solve(int N) {\n        int sum = 0;\n        \n        // Calculate the sum of digits\n        while (N > 0) {\n            sum += N % 10;\n            N /= 10;\n        }\n        \n        // Convert the sum to binary and return as a string\n        return Integer.toBinaryString(sum);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.solve(1000)); // Expected output: \"1\"\n        System.out.println(solution.solve(150));  // Expected output: \"110\"\n        System.out.println(solution.solve(147));  // Expected output: \"1100\"\n        System.out.println(solution.solve(9999)); // Expected output: \"11110001111\"\n    }\n}\n"}
{"task_id": "Java/85", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a non-empty list of integers lst. add the even elements that are at odd indices.\n     *\n     * Examples:\n     * - add(Arrays.asList(4, 2, 6, 7)) should return 2 (since only 2 is an even number at an odd index)\n     */\n    public int add(List<Integer> lst) {\n        if (lst == null || lst.isEmpty()) {\n            throw new IllegalArgumentException(\"List cannot be null or empty\");\n        }\n\n        int sum = 0;\n        for (int i = 1; i < lst.size(); i += 2) { // Start from index 1 and increment by 2\n            Integer value = lst.get(i);\n            if (value % 2 == 0) {\n                sum += value;\n            }\n        }\n\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.add(Arrays.asList(4, 2, 6, 7))); // Should print 2\n        System.out.println(solution.add(Arrays.asList(1, 3, 5, 7, 9))); // Should print 0 (no even numbers at odd indices)\n        System.out.println(solution.add(Arrays.asList(8, 4, 2, 6, 10, 12))); // Should print 16 (4 + 12)\n    }\n}\n"}
{"task_id": "Java/86", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Write a function that takes a string and returns an ordered version of it.\n     * Ordered version of string, is a string where all words (separated by space)\n     * are replaced by a new word where all the characters arranged in\n     * ascending order based on ascii value.\n     * Note: You should keep the order of words and blank spaces in the sentence.\n     *\n     * For example:\n     * anti_shuffle(\"Hi\") returns \"Hi\"\n     * anti_shuffle(\"hello\") returns \"ehllo\"\n     * anti_shuffle(\"Hello World!!!\") returns \"Hello !!!Wdlor\"\n     */\n    public String anti_shuffle(String s) {\n        if (s == null || s.isEmpty()) {\n            return s;\n        }\n\n        StringBuilder result = new StringBuilder();\n        int wordStartIndex = 0;\n\n        for (int i = 0; i < s.length(); i++) {\n            char c = s.charAt(i);\n            if (c == ' ') {\n                // Process the current word\n                String word = s.substring(wordStartIndex, i);\n                result.append(orderedWord(word));\n                result.append(c); // Append the space character\n                wordStartIndex = i + 1;\n            }\n        }\n\n        // Process the last word in the string\n        if (wordStartIndex < s.length()) {\n            String lastWord = s.substring(wordStartIndex);\n            result.append(orderedWord(lastWord));\n        }\n\n        return result.toString();\n    }\n\n    private String orderedWord(String word) {\n        char[] chars = word.toCharArray();\n        Arrays.sort(chars);\n        return new String(chars);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.anti_shuffle(\"Hi\")); // Expected: \"Hi\"\n        System.out.println(solution.anti_shuffle(\"hello\")); // Expected: \"ehllo\"\n        System.out.println(solution.anti_shuffle(\"Hello World!!!\")); // Expected: \"Hello !!!Wdlor\"\n        System.out.println(solution.anti_shuffle(\"Programming is fun!\")); // Expected: \"Pamgimnig is fnu!\"\n    }\n}\n"}
{"task_id": "Java/87", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<List<Integer>> get_row(List<List<Integer>> lst, int x) {\n        List<List<Integer>> coordinates = new ArrayList<>();\n        \n        // Find all occurrences of x and store their coordinates\n        for (int i = 0; i < lst.size(); i++) {\n            List<Integer> row = lst.get(i);\n            for (int j = 0; j < row.size(); j++) {\n                if (row.get(j).equals(x)) {\n                    // Store the coordinate as [row_index, column_index]\n                    coordinates.add(Arrays.asList(i, row.size() - 1 - j));\n                }\n            }\n        }\n        \n        // Sort by rows in ascending order\n        Collections.sort(coordinates, new Comparator<List<Integer>>() {\n            @Override\n            public int compare(List<Integer> o1, List<Integer> o2) {\n                return o1.get(0).compareTo(o2.get(0));\n            }\n        });\n        \n        // Sort by columns in descending order within the same row\n        for (int i = 0; i < coordinates.size(); i++) {\n            for (int j = i + 1; j < coordinates.size(); j++) {\n                if (coordinates.get(i).get(0) == coordinates.get(j).get(0)) {\n                    int colI = coordinates.get(i).get(1);\n                    int colJ = coordinates.get(j).get(1);\n                    if (colI < colJ) {\n                        Collections.swap(coordinates, i, j);\n                    }\n                }\n            }\n        }\n        \n        return coordinates;\n    }\n}\n"}
{"task_id": "Java/88", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n\n    /**\n     * Given an array of non-negative integers, return a copy of the given array after sorting,\n     * you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n     * or sort it in descending order if the sum( first index value, last index value) is even.\n     *\n     * Note:\n     * * don't change the given array.\n     */\n    public List<Integer> sort_array(List<Integer> array) {\n        if (array == null || array.isEmpty()) {\n            return new ArrayList<>();\n        }\n\n        int sum = array.get(0) + array.get(array.size() - 1);\n        List<Integer> sortedArray = new ArrayList<>(array);\n\n        if (sum % 2 == 0) {\n            // Sort in descending order\n            sortedArray.sort(Collections.reverseOrder());\n        } else {\n            // Sort in ascending order\n            Collections.sort(sortedArray);\n        }\n\n        return sortedArray;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.sort_array(Arrays.asList())); // []\n        System.out.println(solution.sort_array(Arrays.asList(5))); // [5]\n        System.out.println(solution.sort_array(Arrays.asList(2, 4, 3, 0, 1, 5))); // [0, 1, 2, 3, 4, 5]\n        System.out.println(solution.sort_array(Arrays.asList(2, 4, 3, 0, 1, 5, 6))); // [6, 5, 4, 3, 2, 1, 0]\n    }\n}\n"}
{"task_id": "Java/89", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Create a function encrypt that takes a string as an argument and\n     * returns a string encrypted with the alphabet being rotated.\n     * The alphabet should be rotated in a manner such that the letters\n     * shift down by two multiplied to two places.\n     * For example:\n     * encrypt(\"hi\") returns \"lm\"\n     * encrypt(\"asdfghjkl\") returns \"ewhjklnop\"\n     * encrypt(\"gf\") returns \"kj\"\n     * encrypt(\"et\") returns \"ix\"\n     */\n    public String encrypt(String s) {\n        StringBuilder encrypted = new StringBuilder();\n        for (char c : s.toCharArray()) {\n            if (Character.isLetter(c)) {\n                char base = Character.isUpperCase(c) ? 'A' : 'a';\n                int offset = ((c - base + 4) % 26);\n                encrypted.append((char) (base + offset));\n            } else {\n                encrypted.append(c);\n            }\n        }\n        return encrypted.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.encrypt(\"hi\"));       // Should print \"lm\"\n        System.out.println(solution.encrypt(\"asdfghjkl\")); // Should print \"ewhjklnop\"\n        System.out.println(solution.encrypt(\"gf\"));       // Should print \"kj\"\n        System.out.println(solution.encrypt(\"et\"));       // Should print \"ix\"\n\n        // Additional test cases\n        System.out.println(solution.encrypt(\"Hello, World!\")); // Should print \"Lipps, Asvph!\"\n        System.out.println(solution.encrypt(\"Zebra123\"));     // Should print \"Difve123\"\n    }\n}\n"}
{"task_id": "Java/90", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * You are given a list of integers.\n     * Write a function next_smallest() that returns the 2nd smallest element of the list.\n     * Return null if there is no such element.\n     *\n     * @param lst The input list of integers\n     * @return Optional containing the 2nd smallest integer, or Optional.empty() if not available\n     */\n    public Optional<Integer> next_smallest(List<Integer> lst) {\n        // Remove duplicates and sort the list\n        Set<Integer> uniqueElements = new TreeSet<>(lst);\n        \n        // If there are less than 2 elements after removing duplicates, return Optional.empty()\n        if (uniqueElements.size() < 2) {\n            return Optional.empty();\n        }\n        \n        // Return the second element in the sorted set\n        Integer[] array = uniqueElements.toArray(new Integer[0]);\n        return Optional.of(array[1]);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.next_smallest(Arrays.asList(1, 2, 3, 4, 5))); // Expected: Optional[2]\n        System.out.println(solution.next_smallest(Arrays.asList(5, 1, 4, 3, 2))); // Expected: Optional[2]\n        System.out.println(solution.next_smallest(Arrays.asList()));             // Expected: Optional.empty\n        System.out.println(solution.next_smallest(Arrays.asList(1, 1)));         // Expected: Optional.empty\n        System.out.println(solution.next_smallest(Arrays.asList(5, 4, 3, 2, 1))); // Expected: Optional[2]\n    }\n}\n"}
{"task_id": "Java/91", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int is_bored(String S) {\n        String[] sentences = S.split(\"[.?!]\");\n        int count = 0;\n        for (String sentence : sentences) {\n            if (!sentence.trim().isEmpty() && sentence.trim().startsWith(\"I\")) {\n                count++;\n            }\n        }\n        return count;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.is_bored(\"Hello world\")); // Output: 0\n        System.out.println(solution.is_bored(\"The sky is blue. The sun is shining. I love this weather\")); // Output: 1\n    }\n}\n"}
{"task_id": "Java/92", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Create a function that takes 3 numbers.\n     * Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n     * Returns false in any other cases.\n     *\n     * Examples\n     * any_int(5, 2, 7) -> true\n     * any_int(3, 2, 2) -> false\n     * any_int(3, -2, 1) -> true\n     * any_int(3.6, -2.2, 2) -> false\n     */\n    public boolean any_int(Object x, Object y, Object z) {\n        if (x instanceof Integer && y instanceof Integer && z instanceof Integer) {\n            int a = (Integer) x;\n            int b = (Integer) y;\n            int c = (Integer) z;\n\n            return a == b + c || b == a + c || c == a + b;\n        }\n        return false;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.any_int(5, 2, 7));   // true\n        System.out.println(solution.any_int(3, 2, 2));   // false\n        System.out.println(solution.any_int(3, -2, 1));  // true\n        System.out.println(solution.any_int(3.6, -2.2, 2)); // false (should return false)\n    }\n}\n"}
{"task_id": "Java/93", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Write a function that takes a message, and encodes in such a way that it swaps case of all letters,\n     * replaces all vowels in the message with the letter that appears 2 places ahead of that vowel in the\n     * English alphabet.\n     *\n     * Examples:\n     * >>> encode(\"test\")\n     * \"TGST\"\n     * >>> encode(\"This is a message\")\n     * \"tHKS KS C MGSSCGG\"\n     */\n    public String encode(String message) {\n        StringBuilder encodedMessage = new StringBuilder();\n        \n        for (char c : message.toCharArray()) {\n            if (Character.isLetter(c)) {\n                // Swap case\n                char swappedCaseChar = Character.isLowerCase(c) ? Character.toUpperCase(c) : Character.toLowerCase(c);\n                \n                // Replace vowels with the letter 2 places ahead in the alphabet\n                switch (swappedCaseChar) {\n                    case 'A':\n                        encodedMessage.append('C');\n                        break;\n                    case 'E':\n                        encodedMessage.append('G');\n                        break;\n                    case 'I':\n                        encodedMessage.append('K');\n                        break;\n                    case 'O':\n                        encodedMessage.append('Q');\n                        break;\n                    case 'U':\n                        encodedMessage.append('W');\n                        break;\n                    case 'a':\n                        encodedMessage.append('c');\n                        break;\n                    case 'e':\n                        encodedMessage.append('g');\n                        break;\n                    case 'i':\n                        encodedMessage.append('k');\n                        break;\n                    case 'o':\n                        encodedMessage.append('q');\n                        break;\n                    case 'u':\n                        encodedMessage.append('w');\n                        break;\n                    default:\n                        // If it's not a vowel, just append the swapped case character\n                        encodedMessage.append(swappedCaseChar);\n                }\n            } else {\n                // Non-letter characters are appended as is\n                encodedMessage.append(c);\n            }\n        }\n        \n        return encodedMessage.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.encode(\"test\"));  // Expected: \"TGST\"\n        System.out.println(solution.encode(\"This is a message\"));  // Expected: \"tHKS KS C MGSSCGG\"\n        System.out.println(solution.encode(\"Hello World!\"));  // Expected: \"hKLLQ wOrld!\"\n    }\n}\n"}
{"task_id": "Java/94", "generation": "import java.util.List;\n\nclass Solution {\n    /**\n     * You are given a list of integers.\n     * You need to find the largest prime value and return the sum of its digits.\n     */\n    public int skjkasdkd(List<Integer> lst) {\n        if (lst == null || lst.isEmpty()) {\n            return 0;\n        }\n\n        int maxPrime = -1;\n\n        for (int num : lst) {\n            if (isPrime(num)) {\n                maxPrime = Math.max(maxPrime, num);\n            }\n        }\n\n        if (maxPrime == -1) {\n            return 0;\n        }\n\n        return sumOfDigits(maxPrime);\n    }\n\n    private boolean isPrime(int num) {\n        if (num <= 1) {\n            return false;\n        }\n        for (int i = 2; i <= Math.sqrt(num); i++) {\n            if (num % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private int sumOfDigits(int num) {\n        int sum = 0;\n        while (num > 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        List<Integer> lst1 = Arrays.asList(0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3);\n        System.out.println(solution.skjkasdkd(lst1)); // Output: 10\n\n        List<Integer> lst2 = Arrays.asList(1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1);\n        System.out.println(solution.skjkasdkd(lst2)); // Output: 25\n\n        List<Integer> lst3 = Arrays.asList(1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3);\n        System.out.println(solution.skjkasdkd(lst3)); // Output: 13\n\n        List<Integer> lst4 = Arrays.asList(0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6);\n        System.out.println(solution.skjkasdkd(lst4)); // Output: 11\n\n        List<Integer> lst5 = Arrays.asList(0, 81, 12, 3, 1, 21);\n        System.out.println(solution.skjkasdkd(lst5)); // Output: 3\n\n        List<Integer> lst6 = Arrays.asList(0, 8, 1, 2, 1, 7);\n        System.out.println(solution.skjkasdkd(lst6)); // Output: 7\n    }\n}\n"}
{"task_id": "Java/95", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given a map, return True if all keys are strings and all keys are in lower case or in upper case, else return False.\n     * The function should return False is the given map is empty.\n     */\n    public boolean check_dict_case(Map<Object, Object> dict) {\n        if (dict.isEmpty()) {\n            return false;\n        }\n\n        boolean allLowerCase = true;\n        boolean allUpperCase = true;\n\n        for (Object key : dict.keySet()) {\n            if (!(key instanceof String)) {\n                return false;\n            }\n            String strKey = (String) key;\n            if (!strKey.equals(strKey.toLowerCase())) {\n                allLowerCase = false;\n            }\n            if (!strKey.equals(strKey.toUpperCase())) {\n                allUpperCase = false;\n            }\n        }\n\n        return allLowerCase || allUpperCase;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.check_dict_case(Map.of(\"a\", \"apple\", \"b\", \"banana\"))); // True\n        System.out.println(solution.check_dict_case(Map.of(\"a\", \"apple\", \"A\", \"banana\", \"B\", \"banana\"))); // False\n        System.out.println(solution.check_dict_case(Map.of(\"a\", \"apple\", 8, \"banana\", \"a\", \"apple\"))); // False\n        System.out.println(solution.check_dict_case(Map.of(\"Name\", \"John\", \"Age\", \"36\", \"City\", \"Houston\"))); // False\n        System.out.println(solution.check_dict_case(Map.of(\"STATE\", \"NC\", \"ZIP\", \"12345\"))); // True\n    }\n}\n"}
{"task_id": "Java/96", "generation": "import java.util.ArrayList;\nimport java.util.List;\n\nclass Solution {\n\n    /**\n     * Implement a function that takes an non-negative integer and returns an array of the first n\n     * integers that are prime numbers and less than n.\n     *\n     * @param n The upper limit (non-inclusive) to find prime numbers up to.\n     * @return A List containing prime numbers less than n.\n     */\n    public List<Integer> count_up_to(int n) {\n        List<Integer> primes = new ArrayList<>();\n        \n        for (int i = 2; i < n && primes.size() < n; i++) {\n            if (isPrime(i)) {\n                primes.add(i);\n            }\n        }\n        \n        return primes;\n    }\n\n    /**\n     * Helper method to check if a number is prime.\n     *\n     * @param num The number to check.\n     * @return true if the number is prime, false otherwise.\n     */\n    private boolean isPrime(int num) {\n        if (num <= 1) {\n            return false;\n        }\n        for (int i = 2; i <= Math.sqrt(num); i++) {\n            if (num % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.count_up_to(5));   // Output: [2, 3]\n        System.out.println(solution.count_up_to(11));  // Output: [2, 3, 5, 7]\n        System.out.println(solution.count_up_to(0));   // Output: []\n        System.out.println(solution.count_up_to(20));  // Output: [2, 3, 5, 7, 11, 13, 17, 19]\n        System.out.println(solution.count_up_to(1));   // Output: []\n        System.out.println(solution.count_up_to(18));  // Output: [2, 3, 5, 7, 11, 13, 17]\n    }\n}\n"}
{"task_id": "Java/97", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Complete the function that takes two integers and returns\n     * the product of their unit digits.\n     * Assume the input is always valid.\n     * Examples:\n     * multiply(148, 412) should return 16.\n     * multiply(19, 28) should return 72.\n     * multiply(2020, 1851) should return 0.\n     * multiply(14,-15) should return 20.\n     */\n    public int multiply(int a, int b) {\n        // Extract the unit digits of both numbers\n        int unitDigitA = Math.abs(a % 10);\n        int unitDigitB = Math.abs(b % 10);\n\n        // Return the product of the unit digits\n        return unitDigitA * unitDigitB;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.multiply(148, 412)); // Expected output: 16\n        System.out.println(solution.multiply(19, 28));   // Expected output: 72\n        System.out.println(solution.multiply(2020, 1851)); // Expected output: 0\n        System.out.println(solution.multiply(14, -15));  // Expected output: 20\n    }\n}\n"}
{"task_id": "Java/98", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a string s, count the number of uppercase vowels in even indices.\n     *\n     * For example:\n     * count_upper(\"aBCdEf\") returns 1\n     * count_upper(\"abcdefg\") returns 0\n     * count_upper(\"dBBE\") returns 0\n     */\n    public int count_upper(String s) {\n        int count = 0;\n        for (int i = 0; i < s.length(); i += 2) { // Iterate over even indices\n            char c = s.charAt(i);\n            if (isUppercaseVowel(c)) {\n                count++;\n            }\n        }\n        return count;\n    }\n\n    private boolean isUppercaseVowel(char c) {\n        return c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U';\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.count_upper(\"aBCdEf\")); // Expected output: 1\n        System.out.println(solution.count_upper(\"abcdefg\")); // Expected output: 0\n        System.out.println(solution.count_upper(\"dBBE\")); // Expected output: 0\n        System.out.println(solution.count_upper(\"AeIoUc\")); // Expected output: 3\n        System.out.println(solution.count_upper(\"zYxWvUt\")); // Expected output: 2\n    }\n}\n"}
{"task_id": "Java/99", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Create a function that takes a value (string) representing a number\n     * and returns the closest integer to it. If the number is equidistant\n     * from two integers, round it away from zero.\n     *\n     * Examples:\n     * >>> closest_integer(\"10\")\n     * 10\n     * >>> closest_integer(\"15.3\")\n     * 15\n     * >>> closest_integer(\"14.5\")\n     * 15\n     * >>> closest_integer(\"-14.5\")\n     * -15\n     */\n    public int closest_integer(String value) {\n        double num = Double.parseDouble(value);\n        double floorValue = Math.floor(num);\n        double ceilValue = Math.ceil(num);\n\n        if (num - floorValue == 0.5 || ceilValue - num == 0.5) {\n            return (int)(num > 0 ? ceilValue : floorValue);\n        } else {\n            return (int)Math.round(num);\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.closest_integer(\"10\"));   // Output: 10\n        System.out.println(solution.closest_integer(\"15.3\")); // Output: 15\n        System.out.println(solution.closest_integer(\"14.5\")); // Output: 15\n        System.out.println(solution.closest_integer(\"-14.5\"));// Output: -15\n        System.out.println(solution.closest_integer(\"0.5\"));  // Output: 1\n        System.out.println(solution.closest_integer(\"-0.5\")); // Output: -1\n    }\n}\n"}
{"task_id": "Java/100", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given a positive integer n, you have to make a pile of n levels of stones.\n     * The first level has n stones.\n     * The number of stones in the next level is:\n     * - the next odd number if n is odd.\n     * - the next even number if n is even.\n     * Return the number of stones in each level in a list, where element at index\n     * i represents the number of stones in the level (i+1).\n     *\n     * Examples:\n     * >>> make_a_pile(3)\n     * [3, 5, 7]\n     */\n    public List<Integer> make_a_pile(int n) {\n        List<Integer> result = new ArrayList<>();\n        int currentStones = n;\n        \n        for (int i = 0; i < n; i++) {\n            result.add(currentStones);\n            // Determine the next number of stones\n            if (currentStones % 2 == 0) {\n                currentStones += 2; // Next even number\n            } else {\n                currentStones += 2; // Next odd number\n            }\n        }\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.make_a_pile(3)); // Expected: [3, 5, 7]\n        System.out.println(solution.make_a_pile(4)); // Expected: [4, 6, 8, 10]\n        System.out.println(solution.make_a_pile(1)); // Expected: [1, 3]\n    }\n}\n"}
{"task_id": "Java/101", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<String> words_string(String s) {\n        // Use regular expression to split the string by commas and spaces\n        String[] words = s.split(\"[,\\s]+\");\n        List<String> wordList = new ArrayList<>();\n        for (String word : words) {\n            if (!word.isEmpty()) {\n                wordList.add(word);\n            }\n        }\n        return wordList;\n    }\n}\n"}
{"task_id": "Java/102", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * This function takes two positive numbers x and y and returns the\n     * biggest even integer number that is in the range [x, y] inclusive. If\n     * there's no such number, then the function should return -1.\n     *\n     * For example:\n     * choose_num(12, 15) = 14\n     * choose_num(13, 12) = -1\n     */\n    public int choose_num(int x, int y) {\n        // If the range is invalid or there's no even number in the range\n        if (x > y || (x % 2 != 0 && y % 2 != 0)) {\n            return -1;\n        }\n\n        // Find the biggest even number in the range [x, y]\n        for (int i = y; i >= x; i--) {\n            if (i % 2 == 0) {\n                return i;\n            }\n        }\n\n        // If no even number is found\n        return -1;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.choose_num(12, 15)); // Expected output: 14\n        System.out.println(solution.choose_num(13, 12)); // Expected output: -1\n        System.out.println(solution.choose_num(10, 20)); // Expected output: 20\n        System.out.println(solution.choose_num(17, 19)); // Expected output: -1\n        System.out.println(solution.choose_num(8, 8));   // Expected output: 8\n    }\n}\n"}
{"task_id": "Java/103", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * You are given two positive integers n and m, and your task is to compute the\n     * average of the integers from n through m (including n and m).\n     * Round the answer to the nearest integer and convert that to binary.\n     * If n is greater than m, return -1.\n     * Example:\n     * rounded_avg(1, 5) => \"11\"\n     * rounded_avg(7, 5) => -1\n     * rounded_avg(10, 20) => \"1111\"\n     * rounded_avg(20, 33) => \"11011\"\n     */\n    public Object rounded_avg(int n, int m) {\n        if (n > m) {\n            return -1;\n        }\n        \n        long sum = 0;\n        for (int i = n; i <= m; i++) {\n            sum += i;\n        }\n        \n        double average = Math.round((double) sum / (m - n + 1));\n        String binary = Long.toBinaryString((long) average);\n        \n        return binary;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.rounded_avg(1, 5));   // Expected output: \"11\"\n        System.out.println(solution.rounded_avg(7, 5));   // Expected output: -1\n        System.out.println(solution.rounded_avg(10, 20)); // Expected output: \"1111\"\n        System.out.println(solution.rounded_avg(20, 33)); // Expected output: \"11011\"\n    }\n}\n"}
{"task_id": "Java/104", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> unique_digits(List<Integer> x) {\n        List<Integer> result = new ArrayList<>();\n        \n        for (int num : x) {\n            if (!hasEvenDigit(num)) {\n                result.add(num);\n            }\n        }\n        \n        Collections.sort(result);\n        return result;\n    }\n\n    private boolean hasEvenDigit(int n) {\n        while (n > 0) {\n            int digit = n % 10;\n            if (digit % 2 == 0) {\n                return true;\n            }\n            n /= 10;\n        }\n        return false;\n    }\n}\n"}
{"task_id": "Java/105", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given an array of integers, sort the integers that are between 1 and 9 inclusive,\n     * reverse the resulting array, and then replace each digit by its corresponding name from\n     * \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n     *\n     * @param arr input list of integers\n     * @return a list of strings representing the names of the digits in reverse sorted order\n     */\n    public List<String> by_length(List<Integer> arr) {\n        // Filter out numbers not between 1 and 9 inclusive\n        List<Integer> filtered = arr.stream()\n                                     .filter(num -> num >= 1 && num <= 9)\n                                     .sorted()\n                                     .collect(Collectors.toList());\n        \n        // Reverse the list\n        Collections.reverse(filtered);\n        \n        // Map each digit to its corresponding name\n        return filtered.stream()\n                       .map(digit -> switch (digit) {\n                           case 1 -> \"One\";\n                           case 2 -> \"Two\";\n                           case 3 -> \"Three\";\n                           case 4 -> \"Four\";\n                           case 5 -> \"Five\";\n                           case 6 -> \"Six\";\n                           case 7 -> \"Seven\";\n                           case 8 -> \"Eight\";\n                           case 9 -> \"Nine\";\n                           default -> \"\";\n                       })\n                       .collect(Collectors.toList());\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.by_length(Arrays.asList(2, 1, 1, 4, 5, 8, 2, 3))); // [Eight, Five, Four, Three, Two, Two, One, One]\n        System.out.println(solution.by_length(Arrays.asList())); // []\n        System.out.println(solution.by_length(Arrays.asList(1, -1, 55))); // [One]\n        System.out.println(solution.by_length(Arrays.asList(9, 7, 3, 2, 4, 8, 6, 5, 1))); // [Nine, Eight, Seven, Six, Five, Four, Three, Two, One]\n    }\n}\n"}
{"task_id": "Java/106", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Implement the function f that takes n as a parameter,\n     * and returns a list of size n, such that the value of the element at index i is the factorial of i if i is even\n     * or the sum of numbers from 1 to i otherwise.\n     * i starts from 1.\n     * the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).\n     * Example:\n     * f(5) == [1, 2, 6, 24, 15]\n     */\n    public List<Integer> f(int n) {\n        List<Integer> result = new ArrayList<>();\n        \n        for (int i = 1; i <= n; i++) {\n            if (i % 2 == 0) {\n                // Calculate factorial of even index\n                int factorial = calculateFactorial(i);\n                result.add(factorial);\n            } else {\n                // Calculate sum from 1 to odd index\n                int sum = calculateSum(i);\n                result.add(sum);\n            }\n        }\n        \n        return result;\n    }\n\n    private int calculateFactorial(int n) {\n        if (n == 0 || n == 1) {\n            return 1;\n        }\n        int factorial = 1;\n        for (int i = 2; i <= n; i++) {\n            factorial *= i;\n        }\n        return factorial;\n    }\n\n    private int calculateSum(int n) {\n        int sum = 0;\n        for (int i = 1; i <= n; i++) {\n            sum += i;\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.f(5));  // Expected output: [1, 2, 6, 24, 15]\n        System.out.println(solution.f(3));  // Expected output: [1, 2, 6]\n        System.out.println(solution.f(0));  // Expected output: []\n    }\n}\n"}
{"task_id": "Java/107", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given a positive integer n, return a tuple that has the number of even and odd\n     * integer palindromes that fall within the range(1, n), inclusive.\n     *\n     * @param n The upper limit (inclusive) to check for palindromic numbers.\n     * @return A List containing two integers: the first is the count of even palindromes,\n     *         and the second is the count of odd palindromes.\n     */\n    public List<Integer> even_odd_palindrome(int n) {\n        int evenCount = 0;\n        int oddCount = 0;\n\n        for (int i = 1; i <= n; i++) {\n            if (isPalindrome(i)) {\n                if (i % 2 == 0) {\n                    evenCount++;\n                } else {\n                    oddCount++;\n                }\n            }\n        }\n\n        return Arrays.asList(evenCount, oddCount);\n    }\n\n    /**\n     * Helper method to check if a number is a palindrome.\n     *\n     * @param num The number to check.\n     * @return true if the number is a palindrome, false otherwise.\n     */\n    private boolean isPalindrome(int num) {\n        String str = Integer.toString(num);\n        int left = 0;\n        int right = str.length() - 1;\n\n        while (left < right) {\n            if (str.charAt(left) != str.charAt(right)) {\n                return false;\n            }\n            left++;\n            right--;\n        }\n\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.even_odd_palindrome(3));  // Output: [1, 2]\n        System.out.println(solution.even_odd_palindrome(12)); // Output: [4, 6]\n        System.out.println(solution.even_odd_palindrome(10)); // Output: [2, 5]\n    }\n}\n"}
{"task_id": "Java/108", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums(Arrays.asList()) == 0\n    >>> count_nums(Arrays.asList(-1, 11, -11)) == 1\n    >>> count_nums(Arrays.asList(1, 1, 2)) == 3\n     */\n    public int count_nums(List<Integer> arr) {\n        // Use a stream to filter numbers with a positive sum of digits and count them.\n        return (int) arr.stream()\n                        .filter(num -> sumOfDigits(num) > 0)\n                        .count();\n    }\n\n    private int sumOfDigits(int num) {\n        if (num == 0) return 0;\n        // Determine if the number is negative to handle signed digits correctly.\n        boolean isNegative = num < 0;\n        int sum = 0;\n        while (num != 0) {\n            // Get the last digit and add it to the sum.\n            int digit = Math.abs(num % 10);\n            sum += digit;\n            // Remove the last digit from the number.\n            num /= 10;\n        }\n        return isNegative ? -sum : sum;\n    }\n}\n"}
{"task_id": "Java/109", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N]. The\n     * numbers in the array will be randomly ordered. Your task is to determine if\n     * it is possible to get an array sorted in non-decreasing order by performing\n     * the following operation on the given array:\n     *      You are allowed to perform right shift operation any number of times.\n     *\n     * One right shift operation means shifting all elements of the array by one\n     * position in the right direction. The last element of the array will be moved to\n     * the starting position in the array i.e. 0th index.\n     *\n     * If it is possible to obtain the sorted array by performing the above operation\n     * then return true else return False.\n     * If the given array is empty then return true.\n     *\n     * Note: The given list is guaranteed to have unique elements.\n     */\n    public boolean move_one_ball(List<Integer> arr) {\n        if (arr.isEmpty()) {\n            return true;\n        }\n\n        int n = arr.size();\n        for (int i = 0; i < n - 1; i++) {\n            if (arr.get(i) > arr.get(i + 1)) {\n                // Check if the array can be sorted by a single right shift\n                List<Integer> shiftedArr = new ArrayList<>(arr.subList(i + 1, n));\n                shiftedArr.addAll(arr.subList(0, i + 1));\n                boolean isSorted = true;\n                for (int j = 0; j < n - 1; j++) {\n                    if (shiftedArr.get(j) > shiftedArr.get(j + 1)) {\n                        isSorted = false;\n                        break;\n                    }\n                }\n                return isSorted;\n            }\n        }\n\n        // If no out-of-order pair found, the array is already sorted\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.move_one_ball(Arrays.asList(3, 4, 5, 1, 2))); // true\n        System.out.println(solution.move_one_ball(Arrays.asList(3, 5, 4, 1, 2))); // false\n        System.out.println(solution.move_one_ball(Arrays.asList()));             // true\n        System.out.println(solution.move_one_ball(Arrays.asList(1, 2, 3, 4, 5))); // true\n        System.out.println(solution.move_one_ball(Arrays.asList(2, 1, 3, 4, 5))); // false (requires more than one shift)\n    }\n}\n"}
{"task_id": "Java/110", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * In this problem, you will implement a function that takes two lists of numbers,\n     * and determines whether it is possible to perform an exchange of elements\n     * between them to make lst1 a list of only even numbers.\n     * There is no limit on the number of exchanged elements between lst1 and lst2.\n     * If it is possible to exchange elements between the lst1 and lst2 to make\n     * all the elements of lst1 to be even, return \"YES\".\n     * Otherwise, return \"NO\".\n     * For example:\n     * exchange(Arrays.asList(1, 2, 3, 4), Arrays.asList(1, 2, 3, 4)) => \"YES\"\n     * exchange(Arrays.asList(1, 2, 3, 4), Arrays.asList(1, 5, 3, 4)) => \"NO\"\n     * It is assumed that the input lists will be non-empty.\n     */\n    public String exchange(List<Integer> lst1, List<Integer> lst2) {\n        // Count odd numbers in lst1 and even numbers in lst2\n        int oddCount = 0;\n        for (int num : lst1) {\n            if (num % 2 != 0) {\n                oddCount++;\n            }\n        }\n\n        int evenCount = 0;\n        for (int num : lst2) {\n            if (num % 2 == 0) {\n                evenCount++;\n            }\n        }\n\n        // If there are enough even numbers in lst2 to replace all odd numbers in lst1, return \"YES\"\n        return oddCount <= evenCount ? \"YES\" : \"NO\";\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.exchange(Arrays.asList(1, 2, 3, 4), Arrays.asList(1, 2, 3, 4))); // Expected: YES\n        System.out.println(solution.exchange(Arrays.asList(1, 2, 3, 4), Arrays.asList(1, 5, 3, 4))); // Expected: NO\n        System.out.println(solution.exchange(Arrays.asList(1, 3, 5, 7), Arrays.asList(2, 4, 6, 8))); // Expected: YES\n        System.out.println(solution.exchange(Arrays.asList(1, 3, 5, 7), Arrays.asList(1, 3, 5, 7))); // Expected: NO\n    }\n}\n"}
{"task_id": "Java/111", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public Map<String, Integer> histogram(String test) {\n        // Split the input string into words (letters)\n        String[] letters = test.split(\" \");\n        \n        // Create a map to count occurrences of each letter\n        Map<String, Integer> counts = new HashMap<>();\n        for (String letter : letters) {\n            if (!letter.isEmpty()) { // Ignore empty strings\n                counts.put(letter, counts.getOrDefault(letter, 0) + 1);\n            }\n        }\n        \n        // Find the maximum count\n        int maxCount = Collections.max(counts.values());\n        \n        // Create a result map containing only letters with the maximum count\n        Map<String, Integer> result = new HashMap<>();\n        for (Map.Entry<String, Integer> entry : counts.entrySet()) {\n            if (entry.getValue() == maxCount) {\n                result.put(entry.getKey(), entry.getValue());\n            }\n        }\n        \n        return result;\n    }\n}\n"}
{"task_id": "Java/112", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Task\n     * We are given two strings s and c, you have to deleted all the characters in s that are equal to any character in c\n     * then check if the result string is palindrome.\n     * A string is called palindrome if it reads the same backward as forward.\n     * You should return a tuple containing the result string and true/false for the check.\n     * Example\n     * For s = \"abcde\", c = \"ae\", the result should be (\"bcd\",false)\n     * For s = \"abcdef\", c = \"b\"  the result should be (\"acdef\",false)\n     * For s = \"abcdedcba\", c = \"ab\", the result should be (\"cdedc\",true)\n     */\n    public List<Object> reverse_delete(String s, String c) {\n        Set<Character> charsToRemove = new HashSet<>();\n        for (char ch : c.toCharArray()) {\n            charsToRemove.add(ch);\n        }\n\n        StringBuilder sb = new StringBuilder();\n        for (char ch : s.toCharArray()) {\n            if (!charsToRemove.contains(ch)) {\n                sb.append(ch);\n            }\n        }\n\n        String resultString = sb.toString();\n        boolean isPalindrome = isPalindrome(resultString);\n\n        return Arrays.asList(resultString, isPalindrome);\n    }\n\n    private boolean isPalindrome(String str) {\n        int left = 0;\n        int right = str.length() - 1;\n\n        while (left < right) {\n            if (str.charAt(left) != str.charAt(right)) {\n                return false;\n            }\n            left++;\n            right--;\n        }\n\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.reverse_delete(\"abcde\", \"ae\"));  // Expected: [bcd, false]\n        System.out.println(solution.reverse_delete(\"abcdef\", \"b\"));  // Expected: [acdef, false]\n        System.out.println(solution.reverse_delete(\"abcdedcba\", \"ab\"));  // Expected: [cdedc, true]\n    }\n}\n"}
{"task_id": "Java/113", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a list of strings, where each string consists of only digits,\n     * return a list. Each element i of the output should be \"the number of odd elements in the\n     * string i of the input.\" where all the i's should be replaced by the number\n     * of odd digits in the i\"th string of the input.\n     *\n     * @param lst The input list of strings consisting only of digits.\n     * @return A list of formatted strings indicating the count of odd elements in each input string.\n     */\n    public List<String> odd_count(List<String> lst) {\n        List<String> result = new ArrayList<>();\n        for (String str : lst) {\n            int oddCount = 0;\n            for (char c : str.toCharArray()) {\n                if ((c - '0') % 2 != 0) {\n                    oddCount++;\n                }\n            }\n            String formattedStr = \"the number of odd elements \" + oddCount + \"n the str\" + oddCount + \"ng \" + oddCount + \" of the \" + oddCount + \"nput.\";\n            result.add(formattedStr);\n        }\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        List<String> test1 = Arrays.asList(\"1234567\");\n        System.out.println(solution.odd_count(test1));  // Expected: [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n\n        List<String> test2 = Arrays.asList(\"3\", \"11111111\");\n        System.out.println(solution.odd_count(test2));  // Expected: [\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    }\n}\n"}
{"task_id": "Java/114", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given an array of integers nums, find the minimum sum of any non-empty sub-array\n     * of nums.\n     *\n     * Example:\n     * minSubArraySum(Arrays.asList(2, 3, 4, 1, 2, 4)) == 1\n     * minSubArraySum(Arrays.asList(-1, -2, -3)) == -6\n     */\n    public int minSubArraySum(List<Integer> nums) {\n        if (nums == null || nums.isEmpty()) {\n            throw new IllegalArgumentException(\"Input list cannot be null or empty\");\n        }\n        \n        int currentMin = nums.get(0);\n        int globalMin = nums.get(0);\n\n        for (int i = 1; i < nums.size(); i++) {\n            currentMin = Math.min(nums.get(i), currentMin + nums.get(i));\n            globalMin = Math.min(globalMin, currentMin);\n        }\n\n        return globalMin;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.minSubArraySum(Arrays.asList(2, 3, 4, 1, 2, 4))); // Expected output: 1\n        System.out.println(solution.minSubArraySum(Arrays.asList(-1, -2, -3)));       // Expected output: -6\n        System.out.println(solution.minSubArraySum(Arrays.asList(1, 2, 3, -6, 1)));   // Expected output: -6\n        System.out.println(solution.minSubArraySum(Arrays.asList(-1, -1, -2, 1)));    // Expected output: -4\n        System.out.println(solution.minSubArraySum(Arrays.asList(1, 2, 3, 4, 5)));    // Expected output: 1\n    }\n}\n"}
{"task_id": "Java/115", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * You are given a rectangular grid of wells. Each row represents a single well,\n     * and each 1 in a row represents a single unit of water.\n     * Each well has a corresponding bucket that can be used to extract water from it,\n     * and all buckets have the same capacity. Can't use buckets from other wells to extract water from one well.\n     * Your task is to use the buckets to empty the wells.\n     * Output the number of times you need to lower the buckets.\n     *\n     * Example 1:\n     * Input:\n     *      grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n     *      bucket_capacity : 1\n     * Output: 6\n     *\n     * Example 2:\n     * Input:\n     *      grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n     *      bucket_capacity : 2\n     * Output: 5\n     *\n     * Example 3:\n     * Input:\n     *      grid : [[0,0,0], [0,0,0]]\n     *      bucket_capacity : 5\n     * Output: 0\n     */\n    public int max_fill(List<List<Integer>> grid, int capacity) {\n        int totalDrops = 0;\n        for (List<Integer> well : grid) {\n            int waterUnits = 0;\n            for (int unit : well) {\n                waterUnits += unit;\n            }\n            totalDrops += Math.ceil((double) waterUnits / capacity);\n        }\n        return totalDrops;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test Case 1\n        List<List<Integer>> grid1 = Arrays.asList(\n                Arrays.asList(0, 0, 1, 0),\n                Arrays.asList(0, 1, 0, 0),\n                Arrays.asList(1, 1, 1, 1)\n        );\n        int capacity1 = 1;\n        System.out.println(\"Test Case 1: \" + solution.max_fill(grid1, capacity1)); // Expected output: 6\n\n        // Test Case 2\n        List<List<Integer>> grid2 = Arrays.asList(\n                Arrays.asList(0, 0, 1, 1),\n                Arrays.asList(0, 0, 0, 0),\n                Arrays.asList(1, 1, 1, 1),\n                Arrays.asList(0, 1, 1, 1)\n        );\n        int capacity2 = 2;\n        System.out.println(\"Test Case 2: \" + solution.max_fill(grid2, capacity2)); // Expected output: 5\n\n        // Test Case 3\n        List<List<Integer>> grid3 = Arrays.asList(\n                Arrays.asList(0, 0, 0),\n                Arrays.asList(0, 0, 0)\n        );\n        int capacity3 = 5;\n        System.out.println(\"Test Case 3: \" + solution.max_fill(grid3, capacity3)); // Expected output: 0\n    }\n}\n"}
{"task_id": "Java/116", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * In this Kata, you have to sort an array of integers according to\n     * number of ones in their binary representation in ascending order.\n     * For similar number of ones, sort based on decimal value.\n     *\n     * It must be implemented like this:\n     * >>> sort_array(Arrays.asList(1, 5, 2, 3, 4)).equals(Arrays.asList(1, 2, 4, 3, 5))\n     * >>> sort_array(Arrays.asList(-2, -3, -4, -5, -6)).equals(Arrays.asList(-4, -2, -6, -5, -3))\n     * >>> sort_array(Arrays.asList(1, 0, 2, 3, 4)).equals(Arrays.asList(0, 1, 2, 4, 3))\n     */\n    public List<Integer> sort_array(List<Integer> arr) {\n        return arr.stream()\n                  .sorted(Comparator.comparingInt(this::countOnes)\n                                    .thenComparingInt(i -> i))\n                  .collect(Collectors.toList());\n    }\n\n    private int countOnes(int num) {\n        if (num < 0) {\n            num = ~num + 1; // Convert negative number to its positive equivalent\n        }\n        int onesCount = 0;\n        while (num > 0) {\n            onesCount += num & 1;\n            num >>= 1;\n        }\n        return onesCount;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        List<Integer> test1 = Arrays.asList(1, 5, 2, 3, 4);\n        System.out.println(\"Test Case 1: \" + solution.sort_array(test1).equals(Arrays.asList(1, 2, 4, 3, 5)));\n\n        List<Integer> test2 = Arrays.asList(-2, -3, -4, -5, -6);\n        System.out.println(\"Test Case 2: \" + solution.sort_array(test2).equals(Arrays.asList(-4, -2, -6, -5, -3)));\n\n        List<Integer> test3 = Arrays.asList(1, 0, 2, 3, 4);\n        System.out.println(\"Test Case 3: \" + solution.sort_array(test3).equals(Arrays.asList(0, 1, 2, 4, 3)));\n    }\n}\n"}
{"task_id": "Java/117", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a string s and a natural number n, you have been tasked to implement\n     * a function that returns a list of all words from string s that contain exactly\n     * n consonants, in order these words appear in the string s.\n     * If the string s is empty then the function should return an empty list.\n     * Note: you may assume the input string contains only letters and spaces.\n     * Examples:\n     * select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n     * select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n     * select_words(\"simple white space\", 2) ==> []\n     * select_words(\"Hello world\", 4) ==> [\"world\"]\n     * select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\n     */\n    public List<String> select_words(String s, int n) {\n        if (s == null || s.isEmpty()) {\n            return new ArrayList<>();\n        }\n\n        String[] words = s.split(\"\\\\s+\");\n        List<String> result = new ArrayList<>();\n\n        for (String word : words) {\n            long consonantCount = word.toLowerCase().chars()\n                    .filter(c -> \"bcdfghjklmnpqrstvwxyz\".indexOf(c) != -1)\n                    .count();\n\n            if (consonantCount == n) {\n                result.add(word);\n            }\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.select_words(\"Mary had a little lamb\", 4)); // [\"little\"]\n        System.out.println(solution.select_words(\"Mary had a little lamb\", 3)); // [\"Mary\", \"lamb\"]\n        System.out.println(solution.select_words(\"simple white space\", 2));     // []\n        System.out.println(solution.select_words(\"Hello world\", 4));            // [\"world\"]\n        System.out.println(solution.select_words(\"Uncle sam\", 3));              // [\"Uncle\"]\n    }\n}\n"}
{"task_id": "Java/118", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * You are given a word. Your task is to find the closest vowel that stands between\n     * two consonants from the right side of the word (case sensitive).\n     *\n     * Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n     * find any vowel met the above condition.\n     *\n     * You may assume that the given string contains English letter only.\n     */\n    public String get_closest_vowel(String word) {\n        // Convert the input to a character array for easier manipulation\n        char[] chars = word.toCharArray();\n        \n        // Iterate from right to left, looking for vowels between consonants\n        for (int i = chars.length - 2; i > 0; i--) {\n            if (isVowel(chars[i]) && isConsonant(chars[i-1]) && isConsonant(chars[i+1])) {\n                return String.valueOf(chars[i]);\n            }\n        }\n        \n        // If no vowel found, return an empty string\n        return \"\";\n    }\n\n    private boolean isVowel(char c) {\n        return \"AEIOUaeiou\".indexOf(c) != -1;\n    }\n\n    private boolean isConsonant(char c) {\n        return !isVowel(c);\n    }\n    \n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.get_closest_vowel(\"yogurt\"));  // Output: \"u\"\n        System.out.println(solution.get_closest_vowel(\"FULL\"));    // Output: \"U\"\n        System.out.println(solution.get_closest_vowel(\"quick\"));   // Output: \"\"\n        System.out.println(solution.get_closest_vowel(\"ab\"));      // Output: \"\"\n        System.out.println(solution.get_closest_vowel(\"aBcDeFgHiJkLmNoPqRsTuVwXyZ\"));  // Output: \"u\"\n    }\n}\n"}
{"task_id": "Java/119", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public String match_parens(List<String> lst) {\n        // Helper method to check if a string is balanced\n        boolean isBalanced(String s) {\n            int balance = 0;\n            for (char c : s.toCharArray()) {\n                if (c == '(') {\n                    balance++;\n                } else if (c == ')') {\n                    balance--;\n                }\n                if (balance < 0) {\n                    return false;\n                }\n            }\n            return balance == 0;\n        }\n\n        // Check both possible concatenations\n        String firstConcat = lst.get(0) + lst.get(1);\n        String secondConcat = lst.get(1) + lst.get(0);\n\n        if (isBalanced(firstConcat) || isBalanced(secondConcat)) {\n            return \"Yes\";\n        } else {\n            return \"No\";\n        }\n    }\n}\n"}
{"task_id": "Java/120", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     Given an array arr of integers and a positive integer k, return a sorted list\n     of length k with the maximum k numbers in arr, in ascending order.\n     */\n    public List<Integer> maximum(List<Integer> arr, int k) {\n        // Sort the array in descending order\n        Collections.sort(arr, Collections.reverseOrder());\n        \n        // Create a new list to store the top k elements\n        List<Integer> result = new ArrayList<>();\n        \n        // Add the first k elements from the sorted array to the result list\n        for (int i = 0; i < Math.min(k, arr.size()); i++) {\n            result.add(arr.get(i));\n        }\n        \n        // Sort the result list in ascending order before returning\n        Collections.sort(result);\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        List<Integer> arr1 = Arrays.asList(-3, -4, 5);\n        int k1 = 3;\n        System.out.println(\"Test Case 1: \" + solution.maximum(arr1, k1)); // Expected: [-4, -3, 5]\n\n        // Test case 2\n        List<Integer> arr2 = Arrays.asList(4, -4, 4);\n        int k2 = 2;\n        System.out.println(\"Test Case 2: \" + solution.maximum(arr2, k2)); // Expected: [4, 4]\n\n        // Test case 3\n        List<Integer> arr3 = Arrays.asList(-3, 2, 1, 2, -1, -2, 1);\n        int k3 = 1;\n        System.out.println(\"Test Case 3: \" + solution.maximum(arr3, k3)); // Expected: [2]\n    }\n}\n"}
{"task_id": "Java/121", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n     *\n     * Examples:\n     * solution(Arrays.asList(5, 8, 7, 1)) ==> 12\n     * solution(Arrays.asList(3, 3, 3, 3, 3)) ==> 9\n     * solution(Arrays.asList(30, 13, 24, 321)) ==> 0\n     */\n    public int solution(List<Integer> lst) {\n        int sum = 0;\n        for (int i = 0; i < lst.size(); i += 2) {\n            if (lst.get(i) % 2 != 0) {\n                sum += lst.get(i);\n            }\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.solution(Arrays.asList(5, 8, 7, 1))); // Expected output: 12\n        System.out.println(solution.solution(Arrays.asList(3, 3, 3, 3, 3))); // Expected output: 9\n        System.out.println(solution.solution(Arrays.asList(30, 13, 24, 321))); // Expected output: 0\n    }\n}\n"}
{"task_id": "Java/122", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     Given a non-empty array of integers arr and an integer k, return\n     the sum of the elements with at most two digits from the first k elements of arr.\n     \n     Example:\n     \n         Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n         Output: 24 # sum of 21 + 3\n     \n     Constraints:\n         1. 1 <= len(arr) <= 100\n         2. 1 <= k <= len(arr)\n      */\n    public int add_elements(List<Integer> arr, int k) {\n        int sum = 0;\n        for (int i = 0; i < Math.min(k, arr.size()); i++) {\n            if (arr.get(i).toString().length() <= 2) {\n                sum += arr.get(i);\n            }\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        List<Integer> arr1 = Arrays.asList(111, 21, 3, 4000, 5, 6, 7, 8, 9);\n        int k1 = 4;\n        System.out.println(\"Test Case 1: \" + solution.add_elements(arr1, k1)); // Expected output: 24\n\n        // Test case 2\n        List<Integer> arr2 = Arrays.asList(10, 20, 30, 40, 50);\n        int k2 = 3;\n        System.out.println(\"Test Case 2: \" + solution.add_elements(arr2, k2)); // Expected output: 60\n\n        // Test case 3\n        List<Integer> arr3 = Arrays.asList(1, 2, 3, 4, 5);\n        int k3 = 5;\n        System.out.println(\"Test Case 3: \" + solution.add_elements(arr3, k3)); // Expected output: 15\n\n        // Test case 4\n        List<Integer> arr4 = Arrays.asList(100, 200, 300);\n        int k4 = 2;\n        System.out.println(\"Test Case 4: \" + solution.add_elements(arr4, k4)); // Expected output: 0\n\n        // Test case 5\n        List<Integer> arr5 = Arrays.asList(1, 11, 111, 1111);\n        int k5 = 3;\n        System.out.println(\"Test Case 5: \" + solution.add_elements(arr5, k5)); // Expected output: 12\n\n    }\n}\n"}
{"task_id": "Java/123", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n     *\n     * @param n The starting positive integer for the Collatz sequence.\n     * @return A List of Integer containing the odd numbers in the Collatz sequence, sorted in increasing order.\n     */\n    public List<Integer> get_odd_collatz(int n) {\n        List<Integer> result = new ArrayList<>();\n        while (n != 1) {\n            if (n % 2 == 1) { // Check if n is odd\n                result.add(n);\n            }\n            n = n % 2 == 0 ? n / 2 : 3 * n + 1; // Apply Collatz rules\n        }\n        result.add(1); // Add the final term, which is always 1\n        Collections.sort(result); // Sort the list in increasing order\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.get_odd_collatz(5)); // Expected: [1, 5]\n        System.out.println(solution.get_odd_collatz(7)); // Expected: [1, 7, 11, 22]\n        System.out.println(solution.get_odd_collatz(10)); // Expected: [1, 5, 13]\n        System.out.println(solution.get_odd_collatz(1)); // Expected: [1]\n    }\n}\n"}
{"task_id": "Java/124", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * You have to write a function which validates a given date string and\n     * returns true if the date is valid otherwise false.\n     * The date is valid if all of the following rules are satisfied:\n     * 1. The date string is not empty.\n     * 2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.\n     * 3. The months should not be less than 1 or higher than 12.\n     * 4. The date should be in the format: mm-dd-yyyy\n     *\n     * for example:\n     * valid_date(\"03-11-2000\") => true\n     * valid_date(\"15-01-2012\") => false\n     * valid_date(\"04-0-2040\") => false\n     * valid_date(\"06-04-2020\") => true\n     * valid_date(\"06/04/2020\") => false\n     */\n    public boolean valid_date(String date) {\n        if (date == null || date.isEmpty()) return false;\n\n        String[] parts = date.split(\"-\");\n        if (parts.length != 3) return false;\n\n        int month = Integer.parseInt(parts[0]);\n        int day = Integer.parseInt(parts[1]);\n        int year = Integer.parseInt(parts[2]);\n\n        if (month < 1 || month > 12) return false;\n        if (day < 1 || day > 31) return false;\n\n        // Check for months with 30 days\n        if ((month == 4 || month == 6 || month == 9 || month == 11) && day > 30) return false;\n\n        // Check for February and leap years\n        if (month == 2) {\n            if (day > 29) return false;\n            if (day == 29 && !isLeapYear(year)) return false;\n        }\n\n        return true;\n    }\n\n    private boolean isLeapYear(int year) {\n        return (year % 4 == 0 && (year % 100 != 0 || year % 400 == 0));\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.valid_date(\"03-11-2000\")); // true\n        System.out.println(solution.valid_date(\"15-01-2012\")); // false\n        System.out.println(solution.valid_date(\"04-0-2040\"));  // false\n        System.out.println(solution.valid_date(\"06-04-2020\")); // true\n        System.out.println(solution.valid_date(\"06/04/2020\")); // false\n    }\n}\n"}
{"task_id": "Java/125", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n     should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n     alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n     Examples:\n     split_words(\"Hello world!\") == [\"Hello\", \"world!\"]\n     split_words(\"Hello,world!\") == [\"Hello\", \"world!\"]\n     split_words(\"abcdef\") == 3\n     */\n    public Object split_words(String txt) {\n        if (txt.contains(\" \")) {\n            return Arrays.asList(txt.split(\"\\\\s+\"));\n        } else if (txt.contains(\",\")) {\n            return Arrays.asList(txt.split(\",\"));\n        } else {\n            int count = 0;\n            for (char c : txt.toCharArray()) {\n                if (Character.isLowerCase(c) && ((c - 'a') % 2 == 1)) {\n                    count++;\n                }\n            }\n            return count;\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.split_words(\"Hello world!\")); // [\"Hello\", \"world!\"]\n        System.out.println(solution.split_words(\"Hello,world!\")); // [\"Hello\", \"world!\"]\n        System.out.println(solution.split_words(\"abcdef\"));      // 3\n\n        // Additional test cases\n        System.out.println(solution.split_words(\"a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z\")); // 13\n        System.out.println(solution.split_words(\"A quick, brown fox!\")); // [\"A\", \"quick,\", \"brown\", \"fox!\"]\n        System.out.println(solution.split_words(\"noSpacesOrCommas\")); // 5\n    }\n}\n"}
{"task_id": "Java/126", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given a list of numbers, return whether or not they are sorted in ascending order.\n     * If the number appears more than twice, return false. Assume no negative numbers and only integers.\n     *\n     * Examples:\n     * is_sorted(Arrays.asList(5)) -> true\n     * is_sorted(Arrays.asList(1, 2, 3, 4, 5)) -> true\n     * is_sorted(Arrays.asList(1, 3, 2, 4, 5)) -> false\n     * is_sorted(Arrays.asList(1, 2, 3, 4, 5, 6)) -> true\n     * is_sorted(Arrays.asList(1, 2, 3, 4, 5, 6, 7)) -> true\n     * is_sorted(Arrays.asList(1, 3, 2, 4, 5, 6, 7)) -> false\n     * is_sorted(Arrays.asList(1, 2, 2, 3, 3, 4)) -> true\n     * is_sorted(Arrays.asList(1, 2, 2, 2, 3, 4)) -> false\n     */\n    public boolean is_sorted(List<Integer> lst) {\n        if (lst == null || lst.size() <= 1) {\n            return true;\n        }\n\n        int count = 1; // To keep track of consecutive duplicates\n\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i).equals(lst.get(i - 1))) {\n                count++;\n                if (count > 2) {\n                    return false;\n                }\n            } else {\n                count = 1;\n            }\n\n            if (lst.get(i) < lst.get(i - 1)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.is_sorted(Arrays.asList(5))); // true\n        System.out.println(solution.is_sorted(Arrays.asList(1, 2, 3, 4, 5))); // true\n        System.out.println(solution.is_sorted(Arrays.asList(1, 3, 2, 4, 5))); // false\n        System.out.println(solution.is_sorted(Arrays.asList(1, 2, 3, 4, 5, 6))); // true\n        System.out.println(solution.is_sorted(Arrays.asList(1, 2, 3, 4, 5, 6, 7))); // true\n        System.out.println(solution.is_sorted(Arrays.asList(1, 3, 2, 4, 5, 6, 7))); // false\n        System.out.println(solution.is_sorted(Arrays.asList(1, 2, 2, 3, 3, 4))); // true\n        System.out.println(solution.is_sorted(Arrays.asList(1, 2, 2, 2, 3, 4))); // false\n    }\n}\n"}
{"task_id": "Java/127", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public String intersection(List<Integer> interval1, List<Integer> interval2) {\n        int start = Math.max(interval1.get(0), interval2.get(0));\n        int end = Math.min(interval1.get(1), interval2.get(1));\n\n        if (start > end) {\n            return \"NO\";\n        }\n\n        int length = end - start + 1;\n\n        if (isPrime(length)) {\n            return \"YES\";\n        } else {\n            return \"NO\";\n        }\n    }\n\n    private boolean isPrime(int n) {\n        if (n <= 1) {\n            return false;\n        }\n        for (int i = 2; i * i <= n; i++) {\n            if (n % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n"}
{"task_id": "Java/128", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * You are given an array arr of integers and you need to return\n     * sum of magnitudes of integers multiplied by product of all signs\n     * of each number in the array, represented by 1, -1 or 0.\n     * Note: return None for empty arr.\n     *\n     * Example:\n     * >>> prod_signs(Arrays.asList(1, 2, 2, -4)) == -9\n     * >>> prod_signs(Arrays.asList(0, 1)) == 0\n     * >>> prod_signs(Arrays.asList()) == Optional.empty()\n     */\n    public Optional<Integer> prod_signs(List<Integer> arr) {\n        if (arr.isEmpty()) {\n            return Optional.empty();\n        }\n\n        int sumOfMagnitudes = 0;\n        int productOfSigns = 1;\n\n        for (Integer num : arr) {\n            sumOfMagnitudes += Math.abs(num);\n            if (num == 0) {\n                productOfSigns = 0;\n                break;\n            } else if (num < 0) {\n                productOfSigns *= -1;\n            }\n        }\n\n        return Optional.of(sumOfMagnitudes * productOfSigns);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.prod_signs(Arrays.asList(1, 2, 2, -4))); // Expected output: Optional[-9]\n        System.out.println(solution.prod_signs(Arrays.asList(0, 1)));        // Expected output: Optional[0]\n        System.out.println(solution.prod_signs(Arrays.asList()));           // Expected output: Optional.empty\n    }\n}\n"}
{"task_id": "Java/129", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> minPath(List<List<Integer>> grid, int k) {\n        int n = grid.size();\n        \n        // Initialize a priority queue (min-heap)\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> Integer.compare(a[0], b[0]));\n        pq.offer(new int[]{grid.get(0).get(0), 0, 0});\n        \n        // Directions for moving to neighboring cells\n        int[][] directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n        \n        Set<String> visited = new HashSet<>();\n        List<Integer> pathValues = new ArrayList<>();\n        \n        while (!pq.isEmpty() && pathValues.size() < k) {\n            int[] current = pq.poll();\n            int value = current[0];\n            int x = current[1];\n            int y = current[2];\n            \n            if (visited.contains(x + \",\" + y)) {\n                continue;\n            }\n            \n            visited.add(x + \",\" + y);\n            pathValues.add(value);\n            \n            for (int[] dir : directions) {\n                int nx = x + dir[0];\n                int ny = y + dir[1];\n                \n                if (nx >= 0 && nx < n && ny >= 0 && ny < n) {\n                    pq.offer(new int[]{grid.get(nx).get(ny), nx, ny});\n                }\n            }\n        }\n        \n        return pathValues;\n    }\n}\n"}
{"task_id": "Java/130", "generation": "import java.util.*;\n\nclass Solution {\n    public List<Integer> tri(int n) {\n        if (n == 0) {\n            return new ArrayList<>();\n        }\n        \n        List<Integer> sequence = new ArrayList<>();\n        sequence.add(3); // tri(1)\n        \n        for (int i = 2; i <= n + 1; i++) {\n            int nextValue;\n            if (i % 2 == 0) {\n                nextValue = 1 + (i / 2);\n            } else {\n                nextValue = sequence.get(i - 2) + sequence.get(i - 3) + 3;\n            }\n            sequence.add(nextValue);\n        }\n        \n        return sequence;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.tri(3)); // Output: [3, 2, 8]\n    }\n}\n"}
{"task_id": "Java/131", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     Given a positive integer n, return the product of the odd digits.\n     Return 0 if all digits are even.\n     For example:\n     digits(1)  == 1\n     digits(4)  == 0\n     digits(235) == 15\n     */\n    public int digits(int n) {\n        int product = 1;\n        boolean hasOddDigit = false;\n\n        while (n > 0) {\n            int digit = n % 10;\n            if (digit % 2 != 0) {\n                product *= digit;\n                hasOddDigit = true;\n            }\n            n /= 10;\n        }\n\n        return hasOddDigit ? product : 0;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.digits(1));   // Output: 1\n        System.out.println(solution.digits(4));   // Output: 0\n        System.out.println(solution.digits(235)); // Output: 15\n        System.out.println(solution.digits(2468)); // Output: 0\n        System.out.println(solution.digits(13579)); // Output: 945\n    }\n}\n"}
{"task_id": "Java/132", "generation": "import java.util.*;\n\nclass Solution {\n    public boolean is_nested(String string) {\n        Deque<Character> stack = new ArrayDeque<>();\n        boolean nested = false;\n        \n        for (char c : string.toCharArray()) {\n            if (c == '[') {\n                stack.push(c);\n            } else if (c == ']') {\n                if (!stack.isEmpty()) {\n                    stack.pop();\n                    nested = true;\n                } else {\n                    return false;\n                }\n            }\n        }\n        \n        return nested && stack.isEmpty();\n    }\n}\n"}
{"task_id": "Java/133", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int sum_squares(List<Double> lst) {\n        int sum = 0;\n        for (Double num : lst) {\n            // Round up to the nearest integer\n            double roundedNum = Math.ceil(num);\n            // Square the rounded number and add it to the sum\n            sum += (int) Math.pow(roundedNum, 2);\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.sum_squares(Arrays.asList(1.0, 2.0, 3.0))); // Output: 14\n        System.out.println(solution.sum_squares(Arrays.asList(1.0, 4.0, 9.0))); // Output: 98\n        System.out.println(solution.sum_squares(Arrays.asList(1.0, 3.0, 5.0, 7.0))); // Output: 84\n        System.out.println(solution.sum_squares(Arrays.asList(1.4, 4.2, 0.0))); // Output: 29\n        System.out.println(solution.sum_squares(Arrays.asList(-2.4, 1.0, 1.0))); // Output: 6\n    }\n}\n"}
{"task_id": "Java/134", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public boolean check_if_last_char_is_a_letter(String txt) {\n        if (txt == null || txt.isEmpty()) {  // Check if the string is empty or null\n            return false;\n        }\n        \n        char lastChar = txt.charAt(txt.length() - 1);\n        \n        // Check if the last character is an alphabetical character and it's at the end of a word\n        return Character.isLetter(lastChar) && (txt.length() == 1 || !Character.isLetterOrDigit(txt.charAt(txt.length() - 2)));\n    }\n}\n"}
{"task_id": "Java/135", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int can_arrange(List<Integer> arr) {\n        int n = arr.size();\n        for (int i = 1; i < n; i++) {\n            if (arr.get(i).compareTo(arr.get(i - 1)) < 0) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.can_arrange(Arrays.asList(1, 2, 4, 3, 5))); // Output: 3\n        System.out.println(solution.can_arrange(Arrays.asList(1, 2, 3)));       // Output: -1\n    }\n}\n"}
{"task_id": "Java/136", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Create a function that returns a tuple (a, b), where 'a' is\n     * the largest of negative integers, and 'b' is the smallest\n     * of positive integers in a list.\n     * If there is no negative or positive integers, return them as None.\n     *\n     * Examples:\n     * largest_smallest_integers(Arrays.asList(2, 4, 1, 3, 5, 7)) == (Optional.empty(), Optional.of(1))\n     * largest_smallest_integers(Arrays.asList()) == (Optional.empty(), Optional.empty())\n     * largest_smallest_integers(Arrays.asList(0)) == (Optional.empty(), Optional.empty())\n     */\n    public List<Optional<Integer>> largest_smallest_integers(List<Integer> lst) {\n        if (lst.isEmpty()) {\n            return Arrays.asList(Optional.empty(), Optional.empty());\n        }\n\n        Optional<Integer> smallestPositive = lst.stream()\n                .filter(n -> n > 0)\n                .min(Integer::compare);\n\n        Optional<Integer> largestNegative = lst.stream()\n                .filter(n -> n < 0)\n                .max(Integer::compare);\n\n        return Arrays.asList(largestNegative, smallestPositive);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.largest_smallest_integers(Arrays.asList(2, 4, 1, 3, 5, 7))); // (Optional.empty(), Optional.of(1))\n        System.out.println(solution.largest_smallest_integers(Arrays.asList()));                // (Optional.empty(), Optional.empty())\n        System.out.println(solution.largest_smallest_integers(Arrays.asList(0)));               // (Optional.empty(), Optional.empty())\n        System.out.println(solution.largest_smallest_integers(Arrays.asList(-2, -4, -1, -3)));  // (Optional.of(-1), Optional.empty())\n        System.out.println(solution.largest_smallest_integers(Arrays.asList(2, -4, 1, -3, 5))); // (Optional.empty(), Optional.of(1))\n    }\n}\n"}
{"task_id": "Java/137", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public Optional<Object> compare_one(Object a, Object b) {\n        if (a instanceof Integer && b instanceof Integer) {\n            return Optional.of(Math.max((Integer) a, (Integer) b));\n        } else if (a instanceof Double && b instanceof Double) {\n            return Optional.of(Math.max((Double) a, (Double) b));\n        } else if (a instanceof String && b instanceof String) {\n            double aVal = Double.parseDouble(((String) a).replace(',', '.'));\n            double bVal = Double.parseDouble(((String) b).replace(',', '.'));\n            return Optional.of(aVal > bVal ? a : b);\n        } else if (a instanceof Integer || a instanceof Double) {\n            double aVal = a instanceof Integer ? ((Integer) a) : ((Double) a);\n            double bVal = b instanceof Integer ? ((Integer) b) : ((Double) b);\n            return Optional.of(aVal > bVal ? a : b);\n        } else if (a instanceof String) {\n            double aVal = Double.parseDouble(((String) a).replace(',', '.'));\n            double bVal = b instanceof Integer || b instanceof Double ? \n                          (b instanceof Integer ? ((Integer) b) : ((Double) b)) : \n                          Double.parseDouble(((String) b).replace(',', '.'));\n            return Optional.of(aVal > bVal ? a : b);\n        } else {\n            return Optional.empty();\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.compare_one(1, 2.5));       // Optional[2.5]\n        System.out.println(solution.compare_one(1, \"2,3\"));     // Optional[\"2,3\"]\n        System.out.println(solution.compare_one(\"5,1\", \"6\"));   // Optional[\"6\"]\n        System.out.println(solution.compare_one(\"1\", 1));       // Optional.empty\n    }\n}\n"}
{"task_id": "Java/138", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers\n     * Example:\n     * is_equal_to_sum_even(4) == false\n     * is_equal_to_sum_even(6) == false\n     * is_equal_to_sum_even(8) == true\n     */\n    public boolean is_equal_to_sum_even(int n) {\n        // The smallest sum of 4 positive even numbers is 2 + 2 + 2 + 2 = 8.\n        if (n < 8 || n % 2 != 0) {\n            return false;\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(\"is_equal_to_sum_even(4): \" + solution.is_equal_to_sum_even(4)); // false\n        System.out.println(\"is_equal_to_sum_even(6): \" + solution.is_equal_to_sum_even(6)); // false\n        System.out.println(\"is_equal_to_sum_even(8): \" + solution.is_equal_to_sum_even(8)); // true\n        System.out.println(\"is_equal_to_sum_even(10): \" + solution.is_equal_to_sum_even(10)); // true\n        System.out.println(\"is_equal_to_sum_even(12): \" + solution.is_equal_to_sum_even(12)); // true\n        System.out.println(\"is_equal_to_sum_even(14): \" + solution.is_equal_to_sum_even(14)); // true\n        System.out.println(\"is_equal_to_sum_even(16): \" + solution.is_equal_to_sum_even(16)); // true\n        System.out.println(\"is_equal_to_sum_even(7): \" + solution.is_equal_to_sum_even(7)); // false\n    }\n}\n"}
{"task_id": "Java/139", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * The Brazilian factorial is defined as:\n     * brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n     * where n > 0\n     *\n     * For example:\n     * >>> special_factorial(4)\n     * 288\n     *\n     * The function will receive an integer as input and should return the special factorial of this integer.\n     */\n    public long special_factorial(int n) {\n        if (n == 0 || n == 1) {\n            return 1;\n        }\n        \n        long result = 1;\n        for (int i = 1; i <= n; i++) {\n            result *= factorial(i);\n        }\n        return result;\n    }\n\n    private long factorial(int num) {\n        if (num == 0 || num == 1) {\n            return 1;\n        }\n        \n        long fact = 1;\n        for (int i = 2; i <= num; i++) {\n            fact *= i;\n        }\n        return fact;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(\"special_factorial(4): \" + solution.special_factorial(4)); // Expected: 288\n        System.out.println(\"special_factorial(3): \" + solution.special_factorial(3)); // Expected: 12\n        System.out.println(\"special_factorial(5): \" + solution.special_factorial(5)); // Expected: 34560\n        System.out.println(\"special_factorial(1): \" + solution.special_factorial(1)); // Expected: 1\n    }\n}\n"}
{"task_id": "Java/140", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n    Given a string text, replace all spaces in it with underscores,\n    and if a string has more than 2 consecutive spaces,\n    then replace all consecutive spaces with -\n\n    fix_spaces(\"Example\") == \"Example\"\n    fix_spaces(\"Example 1\") == \"Example_1\"\n    fix_spaces(\" Example 2\") == \"_Example_2\"\n    fix_spaces(\" Example   3\") == \"_Example-3\"\n     */\n    public String fix_spaces(String text) {\n        List<Character> result = new ArrayList<>();\n        int consecutiveSpacesCount = 0;\n\n        for (char c : text.toCharArray()) {\n            if (c == ' ') {\n                consecutiveSpacesCount++;\n            } else {\n                if (consecutiveSpacesCount > 2) {\n                    // Append hyphen\n                    result.add('-');\n                } else if (consecutiveSpacesCount >= 1) {\n                    // Replace spaces with underscores\n                    for (int i = 0; i < consecutiveSpacesCount; i++) {\n                        result.add('_');\n                    }\n                }\n                consecutiveSpacesCount = 0;\n                result.add(c);\n            }\n        }\n\n        // Handle trailing spaces if any\n        if (consecutiveSpacesCount > 2) {\n            result.add('-');\n        } else if (consecutiveSpacesCount >= 1) {\n            for (int i = 0; i < consecutiveSpacesCount; i++) {\n                result.add('_');\n            }\n        }\n\n        // Convert the list to a string\n        StringBuilder sb = new StringBuilder();\n        for (char c : result) {\n            sb.append(c);\n        }\n        return sb.toString();\n    }\n}\n"}
{"task_id": "Java/141", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Create a function which takes a string representing a file's name, and returns\n     * \"Yes\" if the the file's name is valid, and returns \"No\" otherwise.\n     * A file's name is considered to be valid if and only if all the following conditions\n     * are met:\n     * - There should not be more than three digits ('0'-'9') in the file's name.\n     * - The file's name contains exactly one dot '.'\n     * - The substring before the dot should not be empty, and it starts with a letter from\n     *   the latin alphapet ('a'-'z' and 'A'-'Z').\n     * - The substring after the dot should be one of these: [\"txt\", \"exe\", \"dll\"]\n     * Examples:\n     * file_name_check(\"example.txt\") # => \"Yes\"\n     * file_name_check(\"1example.dll\") # => \"No\" (the name should start with a latin alphapet letter)\n     */\n    public String file_name_check(String file_name) {\n        // Check for exactly one dot\n        int dotCount = 0;\n        for (char c : file_name.toCharArray()) {\n            if (c == '.') {\n                dotCount++;\n            }\n        }\n        if (dotCount != 1) return \"No\";\n\n        // Split the filename into two parts: before and after the dot\n        String[] parts = file_name.split(\"\\\\.\");\n        if (parts.length != 2) return \"No\"; // Should have exactly one dot\n\n        // Check for empty part before the dot\n        if (parts[0].isEmpty()) return \"No\";\n\n        // Check if the first character is a letter\n        char firstChar = parts[0].charAt(0);\n        if (!Character.isLetter(firstChar)) return \"No\";\n\n        // Check for more than three digits in the file name\n        int digitCount = 0;\n        for (char c : file_name.toCharArray()) {\n            if (Character.isDigit(c)) {\n                digitCount++;\n            }\n        }\n        if (digitCount > 3) return \"No\";\n\n        // Check the extension part after the dot\n        String ext = parts[1];\n        if (!ext.equals(\"txt\") && !ext.equals(\"exe\") && !ext.equals(\"dll\")) return \"No\";\n\n        return \"Yes\";\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.file_name_check(\"example.txt\"));  // Expected: Yes\n        System.out.println(solution.file_name_check(\"1example.dll\")); // Expected: No (starts with a digit)\n        System.out.println(solution.file_name_check(\".txt\"));         // Expected: No (empty part before the dot)\n        System.out.println(solution.file_name_check(\"example.exe\"));  // Expected: Yes\n        System.out.println(solution.file_name_check(\"example123.dll\"));// Expected: Yes\n        System.out.println(solution.file_name_check(\"example4567.dll\"));// Expected: No (more than three digits)\n    }\n}\n"}
{"task_id": "Java/142", "generation": "import java.util.List;\nimport java.util.Arrays;\n\nclass Solution {\n    /**\n    This function will take a list of integers. For all entries in the list, the function shall square the integer entry if its index is a\n    multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not\n    change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries.\n\n    Examples:\n    For lst = [1,2,3] the output should be 6\n    For lst = []  the output should be 0\n    For lst = [-1,-5,2,-1,-5]  the output should be -126\n     */\n    public int sumSquares(List<Integer> lst) {\n        int totalSum = 0;\n        \n        for (int i = 0; i < lst.size(); i++) {\n            if ((i + 1) % 3 == 0) {\n                totalSum += Math.pow(lst.get(i), 2);\n            } else if ((i + 1) % 4 == 0 && (i + 1) % 3 != 0) {\n                totalSum += Math.pow(lst.get(i), 3);\n            }\n        }\n        \n        return totalSum;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.sumSquares(Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12)));\n    }\n}\n"}
{"task_id": "Java/143", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * You are given a string representing a sentence,\n     * the sentence contains some words separated by a space,\n     * and you have to return a string that contains the words from the original sentence,\n     * whose lengths are prime numbers,\n     * the order of the words in the new string should be the same as the original one.\n     *\n     * Example 1:\n     * Input: sentence = \"This is a test\"\n     * Output: \"is\"\n     *\n     * Example 2:\n     * Input: sentence = \"lets go for swimming\"\n     * Output: \"go for\"\n     *\n     * Constraints:\n     * * 1 <= len(sentence) <= 100\n     * * sentence contains only letters\n     */\n    public String words_in_sentence(String sentence) {\n        List<String> words = Arrays.asList(sentence.split(\" \"));\n        StringBuilder result = new StringBuilder();\n        \n        for (String word : words) {\n            if (isPrime(word.length())) {\n                if (result.length() > 0) {\n                    result.append(\" \");\n                }\n                result.append(word);\n            }\n        }\n        \n        return result.toString();\n    }\n\n    private boolean isPrime(int number) {\n        if (number <= 1) {\n            return false;\n        }\n        for (int i = 2; i * i <= number; i++) {\n            if (number % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.words_in_sentence(\"This is a test\")); // Output: \"is\"\n        System.out.println(solution.words_in_sentence(\"lets go for swimming\")); // Output: \"go for\"\n        System.out.println(solution.words_in_sentence(\"one two three four five six seven eight nine ten\")); // Output: \"three five seven\"\n    }\n}\n"}
{"task_id": "Java/144", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Your task is to implement a function that will simplify the expression\n     * x * n. The function returns true if x * n evaluates to a whole number and false\n     * otherwise. Both x and n, are string representation of a fraction, and have the following format,\n     * <numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n     *\n     * You can assume that x, and n are valid fractions, and do not have zero as denominator.\n     */\n    public boolean simplify(String x, String n) {\n        // Split the strings into numerator and denominator\n        String[] xParts = x.split(\"/\");\n        String[] nParts = n.split(\"/\");\n\n        int xNumerator = Integer.parseInt(xParts[0]);\n        int xDenominator = Integer.parseInt(xParts[1]);\n        int nNumerator = Integer.parseInt(nParts[0]);\n        int nDenominator = Integer.parseInt(nParts[1]);\n\n        // Simplify the expression (x * n) / 1\n        int resultNumerator = xNumerator * nNumerator;\n        int resultDenominator = xDenominator * nDenominator;\n\n        // Check if the result is a whole number\n        return resultNumerator % resultDenominator == 0;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.simplify(\"1/5\", \"5/1\")); // true\n        System.out.println(solution.simplify(\"1/6\", \"2/1\")); // false\n        System.out.println(solution.simplify(\"7/10\", \"10/2\")); // false\n        System.out.println(solution.simplify(\"3/4\", \"4/3\")); // true\n        System.out.println(solution.simplify(\"5/8\", \"8/5\")); // true\n        System.out.println(solution.simplify(\"9/16\", \"16/9\")); // true\n    }\n}\n"}
{"task_id": "Java/145", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> order_by_points(List<Integer> nums) {\n        Collections.sort(nums, new Comparator<Integer>() {\n            @Override\n            public int compare(Integer o1, Integer o2) {\n                int sum1 = digitSum(o1);\n                int sum2 = digitSum(o2);\n                \n                if (sum1 != sum2) {\n                    return sum1 - sum2;\n                } else {\n                    return nums.indexOf(o1) - nums.indexOf(o2);\n                }\n            }\n        });\n        return nums;\n    }\n\n    private int digitSum(Integer n) {\n        boolean isNegative = n < 0;\n        String strNum = Integer.toString(Math.abs(n));\n        int sum = 0;\n        for (char c : strNum.toCharArray()) {\n            sum += Character.getNumericValue(c);\n        }\n        return isNegative ? sum + 1 : sum;\n    }\n}\n"}
{"task_id": "Java/146", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Write a function that takes an array of numbers as input and returns\n     * the number of elements in the array that are greater than 10 and both\n     * first and last digits of a number are odd (1, 3, 5, 7, 9).\n     * For example:\n     * specialFilter(Arrays.asList(15, -73, 14, -15)) => 1\n     * specialFilter(Arrays.asList(33, -2, -3, 45, 21, 109)) => 2\n     */\n    public int specialFilter(List<Integer> nums) {\n        int count = 0;\n        for (int num : nums) {\n            if (num > 10 && isFirstAndLastDigitOdd(num)) {\n                count++;\n            }\n        }\n        return count;\n    }\n\n    private boolean isFirstAndLastDigitOdd(int num) {\n        String strNum = Integer.toString(Math.abs(num));\n        int firstDigit = Character.digit(strNum.charAt(0), 10);\n        int lastDigit = Character.digit(strNum.charAt(strNum.length() - 1), 10);\n\n        return (firstDigit % 2 != 0) && (lastDigit % 2 != 0);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.specialFilter(Arrays.asList(15, -73, 14, -15))); // Expected output: 1\n        System.out.println(solution.specialFilter(Arrays.asList(33, -2, -3, 45, 21, 109))); // Expected output: 2\n        System.out.println(solution.specialFilter(Arrays.asList(-73, 14, 15, -15, 33, 45, 21, 109))); // Expected output: 3\n    }\n}\n"}
{"task_id": "Java/147", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * You are given a positive integer n. You have to create an integer array a of length n.\n     * For each i (1 <= i <= n), the value of a[i] = i * i - i + 1.\n     * Return the number of triples (a[i], a[j], a[k]) of a where i < j < k,\n     * and a[i] + a[j] + a[k] is a multiple of 3.\n     *\n     * Example :\n     * Input: n = 5\n     * Output: 1\n     * Explanation:\n     * a = [1, 3, 7, 13, 21]\n     * The only valid triple is (1, 7, 13).\n     */\n    public int get_max_triples(int n) {\n        List<Integer> a = new ArrayList<>();\n        \n        // Generate the array a\n        for (int i = 1; i <= n; i++) {\n            a.add(i * i - i + 1);\n        }\n        \n        int count = 0;\n        \n        // Iterate through all possible triples (i, j, k) where i < j < k\n        for (int i = 0; i < n - 2; i++) {\n            for (int j = i + 1; j < n - 1; j++) {\n                for (int k = j + 1; k < n; k++) {\n                    if ((a.get(i) + a.get(j) + a.get(k)) % 3 == 0) {\n                        count++;\n                    }\n                }\n            }\n        }\n        \n        return count;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.get_max_triples(5)); // Expected output: 1\n        System.out.println(solution.get_max_triples(6)); // Expected output: 2\n        System.out.println(solution.get_max_triples(7)); // Expected output: 3\n    }\n}\n"}
{"task_id": "Java/148", "generation": "import java.util.*;\n\nclass Solution {\n    public List<String> bf(String planet1, String planet2) {\n        List<String> planets = Arrays.asList(\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\");\n        \n        if (!planets.contains(planet1) || !planets.contains(planet2)) {\n            return new ArrayList<>();\n        }\n        \n        int start = planets.indexOf(planet1);\n        int end = planets.indexOf(planet2);\n        \n        // Ensure the indices are in ascending order\n        if (start > end) {\n            Collections.swap(planets, start, end);\n            start = planets.indexOf(planet1);\n            end = planets.indexOf(planet2);\n        }\n        \n        return new ArrayList<>(planets.subList(start + 1, end));\n    }\n}\n"}
{"task_id": "Java/149", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Write a function that accepts a list of strings as a parameter,\n     * deletes the strings that have odd lengths from it,\n     * and returns the resulted list with a sorted order.\n     * The list is always a list of strings and never an array of numbers,\n     * and it may contain duplicates.\n     * The order of the list should be ascending by length of each word, and you\n     * should return the list sorted by that rule.\n     * If two words have the same length, sort the list alphabetically.\n     * The function should return a list of strings in sorted order.\n     * You may assume that all words will have the same length.\n     * For example:\n     * assert sorted_list_sum(Arrays.asList(\"aa\", \"a\", \"aaa\")) => [\"aa\"]\n     * assert sorted_list_sum(Arrays.asList(\"ab\", \"a\", \"aaa\", \"cd\")) => [\"ab\", \"cd\"]\n     */\n    public List<String> sorted_list_sum(List<String> lst) {\n        // Remove strings with odd lengths\n        lst.removeIf(s -> s.length() % 2 != 0);\n\n        // Sort the list by length, then alphabetically if lengths are equal\n        Collections.sort(lst, (s1, s2) -> {\n            int lenCompare = Integer.compare(s1.length(), s2.length());\n            return lenCompare == 0 ? s1.compareTo(s2) : lenCompare;\n        });\n\n        return lst;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        List<String> test1 = Arrays.asList(\"aa\", \"a\", \"aaa\");\n        System.out.println(solution.sorted_list_sum(test1)); // Expected: [aa]\n\n        List<String> test2 = Arrays.asList(\"ab\", \"a\", \"aaa\", \"cd\");\n        System.out.println(solution.sorted_list_sum(test2)); // Expected: [ab, cd]\n\n        List<String> test3 = Arrays.asList(\"hello\", \"world\", \"hi\", \"bye\");\n        System.out.println(solution.sorted_list_sum(test3)); // Expected: [hi, bye]\n    }\n}\n"}
{"task_id": "Java/150", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * A simple program which should return the value of x if n is\n     * a prime number and should return the value of y otherwise.\n     *\n     * Examples:\n     * for x_or_y(7, 34, 12) == 34\n     * for x_or_y(15, 8, 5) == 5\n     */\n    public int x_or_y(int n, int x, int y) {\n        if (isPrime(n)) {\n            return x;\n        } else {\n            return y;\n        }\n    }\n\n    /**\n     * Helper method to check if a number is prime.\n     *\n     * @param num the number to check\n     * @return true if the number is prime, false otherwise\n     */\n    private boolean isPrime(int num) {\n        if (num <= 1) return false;\n        for (int i = 2; i <= Math.sqrt(num); i++) {\n            if (num % i == 0) return false;\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.x_or_y(7, 34, 12)); // Expected output: 34 (since 7 is prime)\n        System.out.println(solution.x_or_y(15, 8, 5));  // Expected output: 5 (since 15 is not prime)\n        System.out.println(solution.x_or_y(2, 10, 20)); // Expected output: 10 (since 2 is prime)\n        System.out.println(solution.x_or_y(4, 30, 40)); // Expected output: 40 (since 4 is not prime)\n    }\n}\n"}
{"task_id": "Java/151", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     Given a list of numbers, return the sum of squares of the numbers\n     in the list that are odd. Ignore numbers that are negative or not integers.\n     */\n    public int double_the_difference(List<Object> lst) {\n        int result = 0;\n        for (Object obj : lst) {\n            if (obj instanceof Integer) {\n                int num = (Integer) obj;\n                if (num > 0 && num % 2 != 0) {\n                    result += num * num;\n                }\n            }\n        }\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.double_the_difference(Arrays.asList(1, 3, 2, 0))); // Expected output: 10\n        System.out.println(solution.double_the_difference(Arrays.asList(-1, -2, 0))); // Expected output: 0\n        System.out.println(solution.double_the_difference(Arrays.asList(9, -2)));      // Expected output: 81\n        System.out.println(solution.double_the_difference(Arrays.asList(0)));          // Expected output: 0\n        System.out.println(solution.double_the_difference(new ArrayList<>()));         // Expected output: 0\n    }\n}\n"}
{"task_id": "Java/152", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Compares the game scores with the guesses and returns an array of how far off each guess was.\n     *\n     * @param game  A list of integers representing the actual game scores.\n     * @param guess A list of integers representing the guessed scores.\n     * @return A list of integers where each element is the absolute difference between the guess and the score, or 0 if they are equal.\n     */\n    public List<Integer> compare(List<Integer> game, List<Integer> guess) {\n        List<Integer> result = new ArrayList<>();\n        for (int i = 0; i < game.size(); i++) {\n            int diff = Math.abs(game.get(i) - guess.get(i));\n            result.add(diff);\n        }\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        List<Integer> test1Game = Arrays.asList(1, 2, 3, 4, 5, 1);\n        List<Integer> test1Guess = Arrays.asList(1, 2, 3, 4, 2, -2);\n        System.out.println(solution.compare(test1Game, test1Guess)); // Expected: [0, 0, 0, 0, 3, 3]\n\n        List<Integer> test2Game = Arrays.asList(0, 5, 0, 0, 0, 4);\n        List<Integer> test2Guess = Arrays.asList(4, 1, 1, 0, 0, -2);\n        System.out.println(solution.compare(test2Game, test2Guess)); // Expected: [4, 4, 1, 0, 0, 6]\n    }\n}\n"}
{"task_id": "Java/153", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * You will be given the name of a class (a string) and a list of extensions.\n     * The extensions are to be used to load additional classes to the class. The\n     * strength of the extension is as follows: Let CAP be the number of the uppercase\n     * letters in the extension's name, and let SM be the number of lowercase letters\n     * in the extension's name, the strength is given by the fraction CAP - SM.\n     * You should find the strongest extension and return a string in this\n     * format: ClassName.Strongest_Extension.\n     * If there are two or more extensions with the same strength, you should\n     * choose the one that comes first in the list.\n     * For example, if you are given \"Slices\" as the class and a list of the\n     * extensions: [\"SErviNGSliCes\", \"Cheese\", \"StuFfed\"] then you should\n     * return \"Slices.SErviNGSliCes\" since \"SErviNGSliCes\" is the strongest extension\n     * (its strength is -1).\n     * Example:\n     * for Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"]) == \"my_class.AA\"\n     */\n    public String Strongest_Extension(String class_name, List<String> extensions) {\n        int maxStrength = Integer.MIN_VALUE;\n        String strongestExtension = \"\";\n        \n        for (String extension : extensions) {\n            int cap = 0, sm = 0;\n            for (char c : extension.toCharArray()) {\n                if (Character.isUpperCase(c)) {\n                    cap++;\n                } else if (Character.isLowerCase(c)) {\n                    sm++;\n                }\n            }\n            \n            int strength = cap - sm;\n            if (strength > maxStrength) {\n                maxStrength = strength;\n                strongestExtension = extension;\n            }\n        }\n        \n        return class_name + \".\" + strongestExtension;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.Strongest_Extension(\"Slices\", Arrays.asList(\"SErviNGSliCes\", \"Cheese\", \"StuFfed\"))); // Should print: Slices.SErviNGSliCes\n        System.out.println(solution.Strongest_Extension(\"my_class\", Arrays.asList(\"AA\", \"Be\", \"CC\"))); // Should print: my_class.AA\n        System.out.println(solution.Strongest_Extension(\"DataProcessor\", Arrays.asList(\"dataIO\", \"DATAIO\", \"dataio\"))); // Should print: DataProcessor.DATAIO\n    }\n}\n"}
{"task_id": "Java/154", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * You are given 2 words. You need to return true if the second word or any of its rotations is a substring in the first word.\n     * cycpattern_check(\"abcd\",\"abd\") => false\n     * cycpattern_check(\"hello\",\"ell\") => true\n     * cycpattern_check(\"whassup\",\"psus\") => false\n     * cycpattern_check(\"abab\",\"baa\") => true\n     * cycpattern_check(\"efef\",\"eeff\") => false\n     * cycpattern_check(\"himenss\",\"simen\") => true\n     */\n    public boolean cycpattern_check(String a, String b) {\n        if (b.length() > a.length()) {\n            return false;\n        }\n        \n        // Generate all rotations of the second word\n        for (int i = 0; i < b.length(); i++) {\n            String rotated = rotateString(b, i);\n            if (a.contains(rotated)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private String rotateString(String s, int k) {\n        int n = s.length();\n        k = k % n; // In case the rotation is greater than the length of the string\n        return s.substring(n - k) + s.substring(0, n - k);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.cycpattern_check(\"abcd\", \"abd\")); // false\n        System.out.println(solution.cycpattern_check(\"hello\", \"ell\")); // true\n        System.out.println(solution.cycpattern_check(\"whassup\", \"psus\")); // false\n        System.out.println(solution.cycpattern_check(\"abab\", \"baa\")); // true\n        System.out.println(solution.cycpattern_check(\"efef\", \"eeff\")); // false\n        System.out.println(solution.cycpattern_check(\"himenss\", \"simen\")); // true\n    }\n}\n"}
{"task_id": "Java/155", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> even_odd_count(int num) {\n        // Convert number to string to easily iterate over each digit\n        String strNum = Integer.toString(Math.abs(num));\n        \n        // Initialize counters for even and odd digits\n        int evenCount = 0;\n        int oddCount = 0;\n        \n        // Iterate through each character in the string representation of the number\n        for (char c : strNum.toCharArray()) {\n            int digit = Character.getNumericValue(c);\n            if (digit % 2 == 0) {\n                evenCount++;\n            } else {\n                oddCount++;\n            }\n        }\n        \n        // Create and return a list containing the counts of even and odd digits\n        List<Integer> result = new ArrayList<>();\n        result.add(evenCount);\n        result.add(oddCount);\n        return result;\n    }\n}\n"}
{"task_id": "Java/156", "generation": "import java.util.*;\n\nclass Solution {\n    public String int_to_mini_roman(int number) {\n        List<Map.Entry<Integer, String>> romanNumerals = new ArrayList<>();\n        romanNumerals.add(Map.entry(1000, \"m\"));\n        romanNumerals.add(Map.entry(900, \"cm\"));\n        romanNumerals.add(Map.entry(500, \"d\"));\n        romanNumerals.add(Map.entry(400, \"cd\"));\n        romanNumerals.add(Map.entry(100, \"c\"));\n        romanNumerals.add(Map.entry(90, \"xc\"));\n        romanNumerals.add(Map.entry(50, \"l\"));\n        romanNumerals.add(Map.entry(40, \"xl\"));\n        romanNumerals.add(Map.entry(10, \"x\"));\n        romanNumerals.add(Map.entry(9, \"ix\"));\n        romanNumerals.add(Map.entry(5, \"v\"));\n        romanNumerals.add(Map.entry(4, \"iv\"));\n        romanNumerals.add(Map.entry(1, \"i\"));\n\n        StringBuilder result = new StringBuilder();\n        \n        for (Map.Entry<Integer, String> entry : romanNumerals) {\n            while (number >= entry.getKey()) {\n                result.append(entry.getValue());\n                number -= entry.getKey();\n            }\n        }\n\n        return result.toString().toLowerCase();\n    }\n}\n"}
{"task_id": "Java/157", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given the lengths of the three sides of a triangle. Return true if the three\n     * sides form a right-angled triangle, false otherwise.\n     * A right-angled triangle is a triangle in which one angle is a right angle or 90 degrees.\n     * Example:\n     * right_angle_triangle(3, 4, 5) == true\n     * right_angle_triangle(1, 2, 3) == false\n     */\n    public boolean right_angle_triangle(int a, int b, int c) {\n        // Sort the sides to ensure the longest side is last\n        int[] sides = {a, b, c};\n        Arrays.sort(sides);\n        \n        // Check if the square of the longest side equals the sum of squares of other two sides\n        return Math.pow(sides[0], 2) + Math.pow(sides[1], 2) == Math.pow(sides[2], 2);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.right_angle_triangle(3, 4, 5)); // true\n        System.out.println(solution.right_angle_triangle(1, 2, 3)); // false\n        System.out.println(solution.right_angle_triangle(5, 12, 13)); // true\n        System.out.println(solution.right_angle_triangle(6, 8, 10)); // true\n        System.out.println(solution.right_angle_triangle(7, 10, 12)); // false\n    }\n}\n"}
{"task_id": "Java/158", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Write a function that accepts a list of strings.\n     * The list contains different words. Return the word with maximum number\n     * of unique characters. If multiple strings have maximum number of unique\n     * characters, return the one which comes first in lexicographical order.\n     *\n     * find_max([\"name\", \"of\", \"string\"]) == \"string\"\n     * find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n     * find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"aaaaaaa\"\n     */\n    public String find_max(List<String> words) {\n        if (words == null || words.isEmpty()) {\n            return \"\";\n        }\n\n        // Sort the list lexicographically\n        Collections.sort(words);\n\n        String maxWord = \"\";\n        int maxUniqueChars = 0;\n\n        for (String word : words) {\n            Set<Character> uniqueChars = new HashSet<>();\n            for (char c : word.toCharArray()) {\n                uniqueChars.add(c);\n            }\n\n            if (uniqueChars.size() > maxUniqueChars) {\n                maxUniqueChars = uniqueChars.size();\n                maxWord = word;\n            }\n        }\n\n        return maxWord;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.find_max(Arrays.asList(\"name\", \"of\", \"string\"))); // Output: string\n        System.out.println(solution.find_max(Arrays.asList(\"name\", \"enam\", \"game\"))); // Output: enam\n        System.out.println(solution.find_max(Arrays.asList(\"aaaaaaa\", \"bb\", \"cc\")));  // Output: aaaaaaa\n        System.out.println(solution.find_max(new ArrayList<>()));                     // Output: (empty string)\n        System.out.println(solution.find_max(Arrays.asList(\"abc\", \"defg\", \"hijk\")));  // Output: defg\n    }\n}\n"}
{"task_id": "Java/159", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * You're a hungry rabbit, and you already have eaten a certain number of carrots,\n     * but now you need to eat more carrots to complete the day's meals.\n     * return an array of [ total number of eaten carrots after your meals,\n     *                     the number of carrots left after your meals ]\n     * if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n     *\n     * Example:\n     * * eat(5, 6, 10) -> [11, 4]\n     * * eat(4, 8, 9) -> [12, 1]\n     * * eat(1, 10, 10) -> [11, 0]\n     * * eat(2, 11, 5) -> [7, 0]\n     *\n     * Variables:\n     * @number : integer\n     *        the number of carrots that you have eaten.\n     * @need : integer\n     *        the number of carrots that you need to eat.\n     * @remaining : integer\n     *        the number of remaining carrots thet exist in stock\n     *\n     * Constrain:\n     * * 0 <= number <= 1000\n     * * 0 <= need <= 1000\n     * * 0 <= remaining <= 1000\n     */\n    public List<Integer> eat(int number, int need, int remaining) {\n        // Calculate the total number of carrots to be eaten\n        int totalToEat = Math.min(need, remaining);\n        \n        // Update the number of carrots eaten and remaining\n        int newNumberEaten = number + totalToEat;\n        int newRemainingCarrots = remaining - totalToEat;\n\n        return Arrays.asList(newNumberEaten, newRemainingCarrots);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.eat(5, 6, 10)); // Expected: [11, 4]\n        System.out.println(solution.eat(4, 8, 9));  // Expected: [12, 1]\n        System.out.println(solution.eat(1, 10, 10)); // Expected: [11, 0]\n        System.out.println(solution.eat(2, 11, 5));  // Expected: [7, 0]\n    }\n}\n"}
{"task_id": "Java/160", "generation": "import java.util.*;\nimport javax.script.ScriptEngineManager;\nimport javax.script.ScriptEngine;\nimport javax.script.ScriptException;\n\nclass Solution {\n    public int do_algebra(List<String> operator, List<Integer> operand) throws ScriptException {\n        StringBuilder expression = new StringBuilder();\n        expression.append(operand.get(0));\n        \n        for (int i = 0; i < operator.size(); i++) {\n            expression.append(\" \").append(operator.get(i)).append(\" \").append(operand.get(i + 1));\n        }\n        \n        return evaluateExpression(expression.toString());\n    }\n\n    private int evaluateExpression(String expression) throws ScriptException {\n        // Using Java's ScriptEngine to evaluate the expression\n        ScriptEngineManager manager = new ScriptEngineManager();\n        ScriptEngine engine = manager.getEngineByName(\"JavaScript\");\n        return (Integer) engine.eval(expression);\n    }\n}\n"}
{"task_id": "Java/161", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * You are given a string s.\n     * if s[i] is a letter, reverse its case from lower to upper or vise versa,\n     * otherwise keep it as it is.\n     * If the string contains no letters, reverse the string.\n     * The function should return the resulted string.\n     * Examples\n     * solve(\"1234\") = \"4321\"\n     * solve(\"ab\") = \"AB\"\n     * solve(\"#a@C\") = \"#A@c\"\n     */\n    public String solve(String s) {\n        if (s == null || s.isEmpty()) {\n            return s;\n        }\n\n        boolean containsLetters = false;\n        StringBuilder result = new StringBuilder();\n\n        for (char c : s.toCharArray()) {\n            if (Character.isLetter(c)) {\n                containsLetters = true;\n                result.append(Character.isLowerCase(c) ? Character.toUpperCase(c) : Character.toLowerCase(c));\n            } else {\n                result.append(c);\n            }\n        }\n\n        return containsLetters ? result.toString() : new StringBuilder(s).reverse().toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.solve(\"1234\"));  // Expected: \"4321\"\n        System.out.println(solution.solve(\"ab\"));    // Expected: \"AB\"\n        System.out.println(solution.solve(\"#a@C\"));  // Expected: \"#A@c\"\n        System.out.println(solution.solve(\"\"));      // Expected: \"\"\n        System.out.println(solution.solve(\"123!@#\")); // Expected: \"#@!321\"\n        System.out.println(solution.solve(\"Hello World!\")); // Expected: \"hELLO wORLD!\"\n    }\n}\n"}
{"task_id": "Java/162", "generation": "import java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.Optional;\n\nclass Solution {\n    /**\n     Given a string \"text\", return its md5 hash equivalent string with length being 32.\n     If \"text\" is an empty string, return Optional.empty().\n     \n     >>> string_to_md5(\"Hello world\") == \"3e25960a79dbc69b674cd4ec67a72c62\"\n      */\n    public Optional<String> string_to_md5(String text) throws NoSuchAlgorithmException {\n        if (text.isEmpty()) {\n            return Optional.empty();\n        }\n        \n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        byte[] messageDigest = md.digest(text.getBytes());\n        BigInteger no = new BigInteger(1, messageDigest);\n        String hashtext = no.toString(16);\n        \n        // Make hash text 32 characters long\n        while (hashtext.length() < 32) {\n            hashtext = \"0\" + hashtext;\n        }\n        \n        return Optional.of(hashtext);\n    }\n}\n"}
{"task_id": "Java/163", "generation": "import java.util.List;\n\nclass Solution {\n\n    /**\n     * Given two positive integers a and b, return the even digits between a\n     * and b, in ascending order.\n     *\n     * @param a the lower bound (inclusive)\n     * @param b the upper bound (inclusive)\n     * @return a List of Integer containing even digits between a and b\n     */\n    public List<Integer> generate_integers(int a, int b) {\n        List<Integer> result = new ArrayList<>();\n        \n        // Ensure a is less than or equal to b for simplicity in iteration\n        if (a > b) {\n            int temp = a;\n            a = b;\n            b = temp;\n        }\n        \n        for (int i = a; i <= b; i++) {\n            if (i % 2 == 0 && i < 10) {\n                result.add(i);\n            }\n        }\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(\"generate_integers(2, 8): \" + solution.generate_integers(2, 8)); // [2, 4, 6, 8]\n        System.out.println(\"generate_integers(8, 2): \" + solution.generate_integers(8, 2)); // [2, 4, 6, 8]\n        System.out.println(\"generate_integers(10, 14): \" + solution.generate_integers(10, 14)); // []\n        System.out.println(\"generate_integers(1, 5): \" + solution.generate_integers(1, 5)); // [2, 4]\n        System.out.println(\"generate_integers(3, 7): \" + solution.generate_integers(3, 7)); // [4, 6]\n    }\n}\n"}
{"task_id": "Java/0", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Check if in given list of numbers, are any two numbers closer to each other than given threshold.\n     *\n     * @param numbers List of Double values.\n     * @param threshold The threshold value for closeness.\n     * @return true if there exist at least two elements whose difference is less than the threshold; false otherwise.\n     */\n    public boolean has_close_elements(List<Double> numbers, double threshold) {\n        // Sort the list to make it easier to find close elements\n        Collections.sort(numbers);\n        \n        for (int i = 0; i < numbers.size() - 1; i++) {\n            if (numbers.get(i + 1) - numbers.get(i) < threshold) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.has_close_elements(Arrays.asList(1.0, 2.0, 3.0), 0.5)); // Expected: false\n        System.out.println(solution.has_close_elements(Arrays.asList(1.0, 2.8, 3.0, 4.0, 5.0, 2.0), 0.3)); // Expected: true\n        System.out.println(solution.has_close_elements(Arrays.asList(-1.0, -2.0, -3.0), 1.5)); // Expected: false\n        System.out.println(solution.has_close_elements(Arrays.asList(10.0, 10.1, 10.2, 10.3), 0.05)); // Expected: true\n    }\n}\n"}
{"task_id": "Java/1", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n     * separate those group into separate strings and return the list of those.\n     * Separate groups are balanced (each open brace is properly closed) and not nested within each other\n     * Ignore any spaces in the input string.\n     *\n     * @param paren_string The input string containing multiple groups of nested parentheses.\n     * @return A List of separate strings, each representing a group of balanced parentheses.\n     */\n    public List<String> separate_paren_groups(String paren_string) {\n        List<String> result = new ArrayList<>();\n        int balance = 0;\n        StringBuilder currentGroup = new StringBuilder();\n\n        for (char c : paren_string.toCharArray()) {\n            if (c == ' ') continue; // Ignore spaces\n\n            if (c == '(') {\n                balance++;\n                currentGroup.append(c);\n            } else if (c == ')') {\n                balance--;\n                currentGroup.append(c);\n\n                if (balance == 0) { // A complete group is found\n                    result.add(currentGroup.toString());\n                    currentGroup = new StringBuilder(); // Reset for the next group\n                }\n            }\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(\"Test Case 1: ( ) (( )) (( )( ))\");\n        List<String> test1 = solution.separate_paren_groups(\"( ) (( )) (( )( ))\");\n        for (String group : test1) {\n            System.out.println(group);\n        }\n\n        System.out.println(\"\\nTest Case 2: (()())(())\");\n        List<String> test2 = solution.separate_paren_groups(\"(()())(())\");\n        for (String group : test2) {\n            System.out.println(group);\n        }\n\n        System.out.println(\"\\nTest Case 3: ((()))((()))\");\n        List<String> test3 = solution.separate_paren_groups(\"((()))((()))\");\n        for (String group : test3) {\n            System.out.println(group);\n        }\n    }\n}\n"}
{"task_id": "Java/2", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     Given a positive floating point number, it can be decomposed into\n     and integer part (largest integer smaller than given number) and decimals\n     (leftover part always smaller than 1).\n\n     Return the decimal part of the number.\n     >>> truncate_number(3.5)\n     0.5\n     */\n    public double truncate_number(double number) {\n        return number - Math.floor(number);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(\"Truncate 3.5: \" + solution.truncate_number(3.5)); // Expected output: 0.5\n        System.out.println(\"Truncate 123.456: \" + solution.truncate_number(123.456)); // Expected output: 0.456\n        System.out.println(\"Truncate -1.234: \" + solution.truncate_number(-1.234)); // Expected output: -0.234 (Note: floor of negative numbers is less than the number itself)\n        System.out.println(\"Truncate 0.999: \" + solution.truncate_number(0.999)); // Expected output: 0.999\n        System.out.println(\"Truncate 10.0: \" + solution.truncate_number(10.0)); // Expected output: 0.0\n    }\n}\n"}
{"task_id": "Java/3", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * You're given a list of deposit and withdrawal operations on a bank account that starts with\n     * zero balance. Your task is to detect if at any point the balance of the account falls below zero,\n     * and at that point, the function should return true. Otherwise, it should return false.\n     *\n     * @param operations List of integers representing deposits (positive) and withdrawals (negative).\n     * @return boolean indicating whether the balance ever goes below zero.\n     */\n    public boolean below_zero(List<Integer> operations) {\n        int balance = 0;\n        for (int op : operations) {\n            balance += op;\n            if (balance < 0) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        List<Integer> test1 = Arrays.asList(1, 2, 3);\n        System.out.println(\"Test Case 1: \" + (solution.below_zero(test1) == false)); // Expected: true\n\n        List<Integer> test2 = Arrays.asList(1, 2, -4, 5);\n        System.out.println(\"Test Case 2: \" + (solution.below_zero(test2) == true)); // Expected: true\n\n        List<Integer> test3 = Arrays.asList(-1, 2, -1, 3);\n        System.out.println(\"Test Case 3: \" + (solution.below_zero(test3) == false)); // Expected: false\n\n        List<Integer> test4 = Arrays.asList(5, -6, 7, -8, 9);\n        System.out.println(\"Test Case 4: \" + (solution.below_zero(test4) == true)); // Expected: true\n    }\n}\n"}
{"task_id": "Java/4", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * For a given list of input numbers, calculate Mean Absolute Deviation around the mean of this dataset.\n     * Mean Absolute Deviation is the average absolute difference between each element and a centerpoint (mean in this case):\n     * MAD = average | x - x_mean |\n     *\n     * @param numbers List of Double values\n     * @return Mean Absolute Deviation as a double\n     */\n    public double mean_absolute_deviation(List<Double> numbers) {\n        if (numbers == null || numbers.isEmpty()) {\n            throw new IllegalArgumentException(\"Input list cannot be null or empty\");\n        }\n\n        // Calculate the mean of the dataset\n        double sum = 0.0;\n        for (Double num : numbers) {\n            sum += num;\n        }\n        double mean = sum / numbers.size();\n\n        // Calculate the Mean Absolute Deviation\n        double mad = 0.0;\n        for (Double num : numbers) {\n            mad += Math.abs(num - mean);\n        }\n        return mad / numbers.size();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.mean_absolute_deviation(Arrays.asList(1.0, 2.0, 3.0, 4.0))); // Expected output: 1.0\n        System.out.println(solution.mean_absolute_deviation(Arrays.asList(5.0, 7.0, 9.0, 11.0, 13.0))); // Expected output: 2.8\n        System.out.println(solution.mean_absolute_deviation(Arrays.asList(-1.0, -2.0, -3.0, -4.0))); // Expected output: 1.5\n        System.out.println(solution.mean_absolute_deviation(Arrays.asList(10.0))); // Expected output: 0.0 (single element)\n    }\n}\n"}
{"task_id": "Java/5", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Insert a number 'delimiter' between every two consecutive elements of input list `numbers`\n     *\n     * @param numbers The input list of integers.\n     * @param delimiter The integer to be inserted as a delimiter.\n     * @return A new list with the delimiter interspersed.\n     */\n    public List<Integer> intersperse(List<Integer> numbers, int delimiter) {\n        if (numbers == null || numbers.size() <= 1) {\n            return numbers;\n        }\n\n        List<Integer> result = new ArrayList<>();\n        for (int i = 0; i < numbers.size(); i++) {\n            result.add(numbers.get(i));\n            if (i < numbers.size() - 1) {\n                result.add(delimiter);\n            }\n        }\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.intersperse(List.of(), 4)); // Expected: []\n        System.out.println(solution.intersperse(Arrays.asList(1, 2, 3), 4)); // Expected: [1, 4, 2, 4, 3]\n        System.out.println(solution.intersperse(Arrays.asList(5, 6, 7, 8), -1)); // Expected: [5, -1, 6, -1, 7, -1, 8]\n    }\n}\n"}
{"task_id": "Java/6", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n     * For each of the group, output the deepest level of nesting of parentheses.\n     * E.g. (()()) has maximum two levels of nesting while ((())) has three.\n     *\n     * >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n     * [2, 3, 1, 3]\n     */\n    public List<Integer> parse_nested_parens(String paren_string) {\n        String[] groups = paren_string.split(\"\\\\s+\");\n        List<Integer> depths = new ArrayList<>();\n        \n        for (String group : groups) {\n            int maxDepth = 0;\n            int currentDepth = 0;\n            \n            for (char c : group.toCharArray()) {\n                if (c == '(') {\n                    currentDepth++;\n                    maxDepth = Math.max(maxDepth, currentDepth);\n                } else if (c == ')') {\n                    currentDepth--;\n                }\n            }\n            \n            depths.add(maxDepth);\n        }\n        \n        return depths;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        String test1 = \"(()()) ((())) () ((())()())\";\n        List<Integer> result1 = solution.parse_nested_parens(test1);\n        System.out.println(result1); // Expected output: [2, 3, 1, 3]\n        \n        String test2 = \"(()) (()) (((())))\";\n        List<Integer> result2 = solution.parse_nested_parens(test2);\n        System.out.println(result2); // Expected output: [2, 2, 4]\n        \n        String test3 = \"((())) () (((())))\";\n        List<Integer> result3 = solution.parse_nested_parens(test3);\n        System.out.println(result3); // Expected output: [3, 1, 4]\n    }\n}\n"}
{"task_id": "Java/7", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Filter an input list of strings only for ones that contain given substring\n     *\n     * @param strings The input list of strings\n     * @param substring The substring to filter by\n     * @return A list of strings containing the specified substring\n     */\n    public List<String> filter_by_substring(List<String> strings, String substring) {\n        List<String> filteredList = new ArrayList<>();\n        for (String str : strings) {\n            if (str.contains(substring)) {\n                filteredList.add(str);\n            }\n        }\n        return filteredList;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(\"Test Case 1: Empty List\");\n        System.out.println(solution.filter_by_substring(List.of(), \"a\")); // Expected output: []\n\n        System.out.println(\"\\nTest Case 2: Normal List with 'a'\");\n        System.out.println(solution.filter_by_substring(Arrays.asList(\"abc\", \"bacd\", \"cde\", \"array\"), \"a\"));\n        // Expected output: [abc, bacd, array]\n\n        System.out.println(\"\\nTest Case 3: List without the substring\");\n        System.out.println(solution.filter_by_substring(Arrays.asList(\"hello\", \"world\", \"java\"), \"python\"));\n        // Expected output: []\n\n        System.out.println(\"\\nTest Case 4: List with multiple occurrences of the substring\");\n        System.out.println(solution.filter_by_substring(Arrays.asList(\"aaa\", \"baa\", \"aab\", \"bba\"), \"aa\"));\n        // Expected output: [aaa, aab]\n    }\n}\n"}
{"task_id": "Java/8", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product(List.of())\n    [0, 1]\n    >>> sum_product(Arrays.asList(1, 2, 3, 4))\n    [10, 24]\n     */\n    public List<Integer> sum_product(List<Integer> numbers) {\n        if (numbers.isEmpty()) {\n            return Arrays.asList(0, 1);\n        }\n        \n        int totalSum = 0;\n        int totalProduct = 1;\n        \n        for (int num : numbers) {\n            totalSum += num;\n            totalProduct *= num;\n        }\n        \n        List<Integer> result = new ArrayList<>();\n        result.add(totalSum);\n        result.add(totalProduct);\n        \n        return result;\n    }\n}\n"}
{"task_id": "Java/9", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * From a given list of integers, generate a list of rolling maximum element found until given moment in the sequence.\n     *\n     * @param numbers The input list of integers.\n     * @return A list containing the rolling maximum elements.\n     */\n    public List<Integer> rolling_max(List<Integer> numbers) {\n        if (numbers == null || numbers.isEmpty()) {\n            return Collections.emptyList();\n        }\n\n        List<Integer> result = new ArrayList<>();\n        int maxSoFar = Integer.MIN_VALUE;\n\n        for (int num : numbers) {\n            if (num > maxSoFar) {\n                maxSoFar = num;\n            }\n            result.add(maxSoFar);\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.rolling_max(Arrays.asList(1, 2, 3, 2, 3, 4, 2))); // [1, 2, 3, 3, 3, 4, 4]\n        System.out.println(solution.rolling_max(Arrays.asList()));                   // []\n        System.out.println(solution.rolling_max(Arrays.asList(5)));                  // [5]\n        System.out.println(solution.rolling_max(Arrays.asList(-1, -2, -3, -2, -3, -4, -2))); // [-1, -1, -1, -1, -1, -1, -1]\n    }\n}\n"}
{"task_id": "Java/10", "generation": "import java.util.*;\n\nclass Solution {\n    public boolean isPalindrome(String string) {\n        int i = 0;\n        int j = string.length() - 1;\n        while (i < j) {\n            if (string.charAt(i) != string.charAt(j)) {\n                return false;\n            }\n            i++;\n            j--;\n        }\n        return true;\n    }\n\n    public String longestPalindromicSuffix(String s) {\n        for (int i = s.length(); i > 0; i--) {\n            if (isPalindrome(s.substring(i - 1))) {\n                return s.substring(i - 1);\n            }\n        }\n        return \"\";\n    }\n\n    public String make_palindrome(String string) {\n        String palindromicSuffix = longestPalindromicSuffix(string);\n        String prefixToReverse = string.substring(0, string.length() - palindromicSuffix.length());\n        String reversedPrefix = new StringBuilder(prefixToReverse).reverse().toString();\n        return string + reversedPrefix;\n    }\n}\n"}
{"task_id": "Java/11", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Input are two strings a and b consisting only of 1s and 0s.\n     * Perform binary XOR on these inputs and return result also as a string.\n     *\n     * @param a the first binary string\n     * @param b the second binary string\n     * @return the result of binary XOR operation as a string\n     */\n    public String string_xor(String a, String b) {\n        StringBuilder result = new StringBuilder();\n        int maxLength = Math.max(a.length(), b.length());\n        \n        // Pad both strings to have equal length\n        a = padStringToLength(a, maxLength);\n        b = padStringToLength(b, maxLength);\n\n        for (int i = 0; i < maxLength; i++) {\n            char bitA = a.charAt(i);\n            char bitB = b.charAt(i);\n            \n            // Perform XOR operation and append to result\n            if (bitA == bitB) {\n                result.append('0');\n            } else {\n                result.append('1');\n            }\n        }\n\n        return result.toString();\n    }\n\n    /**\n     * Pads the given string with '0's at the beginning to make it of specified length.\n     *\n     * @param str the input string\n     * @param length the desired length\n     * @return the padded string\n     */\n    private String padStringToLength(String str, int length) {\n        StringBuilder sb = new StringBuilder(str);\n        while (sb.length() < length) {\n            sb.insert(0, '0');\n        }\n        return sb.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.string_xor(\"010\", \"110\")); // Expected output: \"100\"\n        System.out.println(solution.string_xor(\"10101\", \"00111\")); // Expected output: \"10010\"\n        System.out.println(solution.string_xor(\"1111\", \"0000\")); // Expected output: \"1111\"\n        System.out.println(solution.string_xor(\"0000\", \"0000\")); // Expected output: \"0000\"\n        System.out.println(solution.string_xor(\"11111111\", \"00000000\")); // Expected output: \"11111111\"\n    }\n}\n"}
{"task_id": "Java/12", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     Out of list of strings, return the longest one. Return the first one in case of multiple\n     strings of the same length. Return Optional.empty() in case the input list is empty.\n     >>> longest(List.of())\n     Optional.empty\n     >>> longest(Arrays.asList(\"a\", \"b\", \"c\"))\n     Optional[a]\n     >>> longest(Arrays.asList(\"a\", \"bb\", \"ccc\"))\n     Optional[ccc]\n     */\n    public Optional<String> longest(List<String> strings) {\n        if (strings.isEmpty()) {\n            return Optional.empty();\n        }\n\n        String longestString = strings.get(0);\n        for (String str : strings) {\n            if (str.length() > longestString.length()) {\n                longestString = str;\n            }\n        }\n        \n        return Optional.of(longestString);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(\"Test Case 1: Empty List\");\n        System.out.println(solution.longest(List.of())); // Expected: Optional.empty\n\n        System.out.println(\"\\nTest Case 2: Single Element\");\n        System.out.println(solution.longest(Arrays.asList(\"a\"))); // Expected: Optional[a]\n\n        System.out.println(\"\\nTest Case 3: Multiple Elements with Different Lengths\");\n        System.out.println(solution.longest(Arrays.asList(\"a\", \"bb\", \"ccc\"))); // Expected: Optional[ccc]\n\n        System.out.println(\"\\nTest Case 4: Multiple Elements with Same Length\");\n        System.out.println(solution.longest(Arrays.asList(\"aa\", \"bbb\", \"cccc\"))); // Expected: Optional[cccc]\n    }\n}\n"}
{"task_id": "Java/13", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return a greatest common divisor of two integers a and b\n     *\n     * @param a first integer\n     * @param b second integer\n     * @return the greatest common divisor of a and b\n     */\n    public int greatest_common_divisor(int a, int b) {\n        while (b != 0) {\n            int temp = b;\n            b = a % b;\n            a = temp;\n        }\n        return a;\n    }\n\n    // Test cases to verify the correctness of the method\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1: GCD of 3 and 5 is 1\n        System.out.println(\"GCD of 3 and 5: \" + solution.greatest_common_divisor(3, 5)); // Expected output: 1\n\n        // Test case 2: GCD of 25 and 15 is 5\n        System.out.println(\"GCD of 25 and 15: \" + solution.greatest_common_divisor(25, 15)); // Expected output: 5\n\n        // Test case 3: GCD of 100 and 80 is 20\n        System.out.println(\"GCD of 100 and 80: \" + solution.greatest_common_divisor(100, 80)); // Expected output: 20\n\n        // Test case 4: GCD of 7 and 13 (both prime) is 1\n        System.out.println(\"GCD of 7 and 13: \" + solution.greatest_common_divisor(7, 13)); // Expected output: 1\n\n        // Test case 5: GCD of 0 and any number is that number (since gcd(0, b) = b)\n        System.out.println(\"GCD of 0 and 24: \" + solution.greatest_common_divisor(0, 24)); // Expected output: 24\n    }\n}\n"}
{"task_id": "Java/14", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Return list of all prefixes from shortest to longest of the input string\n     *\n     * @param string The input string\n     * @return A List containing all prefixes of the input string, ordered from shortest to longest\n     */\n    public List<String> all_prefixes(String string) {\n        List<String> prefixes = new ArrayList<>();\n        if (string == null || string.isEmpty()) {\n            return prefixes;\n        }\n        \n        for (int i = 1; i <= string.length(); i++) {\n            prefixes.add(string.substring(0, i));\n        }\n        \n        return prefixes;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(\"Testing all_prefixes(\\\"abc\\\"): \" + solution.all_prefixes(\"abc\")); // [\"a\", \"ab\", \"abc\"]\n        System.out.println(\"Testing all_prefixes(\\\"\\\"): \" + solution.all_prefixes(\"\")); // []\n        System.out.println(\"Testing all_prefixes(null): \" + solution.all_prefixes(null)); // []\n\n        // Additional test cases\n        System.out.println(\"Testing all_prefixes(\\\"hello\\\"): \" + solution.all_prefixes(\"hello\")); // [\"h\", \"he\", \"hel\", \"hell\", \"hello\"]\n        System.out.println(\"Testing all_prefixes(\\\"java\\\"): \" + solution.all_prefixes(\"java\")); // [\"j\", \"ja\", \"jav\", \"java\"]\n    }\n}\n"}
{"task_id": "Java/15", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Return a string containing space-delimited numbers starting from 0 up to n inclusive.\n     *\n     * @param n The upper limit of the sequence (inclusive).\n     * @return A string with space-separated numbers from 0 to n.\n     */\n    public String string_sequence(int n) {\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i <= n; i++) {\n            if (i > 0) {\n                sb.append(\" \");\n            }\n            sb.append(i);\n        }\n        return sb.toString();\n    }\n\n    // Test cases to verify the correctness of the string_sequence method\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1: n = 0\n        System.out.println(solution.string_sequence(0).equals(\"0\") ? \"Test 1 Passed\" : \"Test 1 Failed\");\n\n        // Test case 2: n = 5\n        System.out.println(solution.string_sequence(5).equals(\"0 1 2 3 4 5\") ? \"Test 2 Passed\" : \"Test 2 Failed\");\n\n        // Additional test cases\n        System.out.println(solution.string_sequence(10).equals(\"0 1 2 3 4 5 6 7 8 9 10\") ? \"Test 3 Passed\" : \"Test 3 Failed\");\n        System.out.println(solution.string_sequence(-1).equals(\"\") ? \"Test 4 Passed\" : \"Test 4 Failed\"); // Edge case: n < 0\n    }\n}\n"}
{"task_id": "Java/16", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given a string, find out how many distinct characters (regardless of case) does it consist of.\n     *\n     * @param string The input string to analyze.\n     * @return The number of distinct characters in the string, ignoring case.\n     */\n    public int count_distinct_characters(String string) {\n        // Convert the string to lowercase to ignore case\n        String lowerCaseString = string.toLowerCase();\n        \n        // Use a HashSet to store unique characters\n        Set<Character> uniqueChars = new HashSet<>();\n        \n        // Iterate through each character in the string and add it to the set\n        for (char c : lowerCaseString.toCharArray()) {\n            uniqueChars.add(c);\n        }\n        \n        // The size of the set is the number of distinct characters\n        return uniqueChars.size();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.count_distinct_characters(\"xyzXYZ\")); // Expected output: 3\n        System.out.println(solution.count_distinct_characters(\"Jerry\"));   // Expected output: 4\n        System.out.println(solution.count_distinct_characters(\"HelloWorld\")); // Expected output: 7\n        System.out.println(solution.count_distinct_characters(\"AAAaaa\"));    // Expected output: 1\n        System.out.println(solution.count_distinct_characters(\"\"));          // Expected output: 0\n        System.out.println(solution.count_distinct_characters(\"aAaAaA\"));    // Expected output: 1\n    }\n}\n"}
{"task_id": "Java/17", "generation": "import java.util.*;\n\nclass Solution {\n    public List<Integer> parse_music(String string) {\n        String[] notes = string.split(\" \");\n        List<Integer> beats = new ArrayList<>();\n        \n        for (String note : notes) {\n            if (\"o\".equals(note)) {\n                beats.add(4);\n            } else if (\"o|\".equals(note)) {\n                beats.add(2);\n            } else if (\".|\".equals(note)) {\n                beats.add(1);\n            }\n        }\n        \n        return beats;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        List<Integer> result = solution.parse_music(\"o o| .| o| o| .| .| .| .| o o\");\n        System.out.println(result); // Expected output: [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    }\n}\n"}
{"task_id": "Java/18", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Find how many times a given substring can be found in the original string. Count overlapping cases.\n     *\n     * @param string The original string.\n     * @param substring The substring to find.\n     * @return The number of times the substring appears in the original string, including overlaps.\n     */\n    public int how_many_times(String string, String substring) {\n        if (substring.isEmpty()) return 0;\n        \n        int count = 0;\n        int index = 0;\n        \n        while ((index = string.indexOf(substring, index)) != -1) {\n            count++;\n            index++; // Move to the next character after the found substring to allow for overlapping matches\n        }\n        \n        return count;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.how_many_times(\"\", \"a\")); // Expected output: 0\n        System.out.println(solution.how_many_times(\"aaa\", \"a\")); // Expected output: 3\n        System.out.println(solution.how_many_times(\"aaaa\", \"aa\")); // Expected output: 3\n        System.out.println(solution.how_many_times(\"abababa\", \"aba\")); // Expected output: 3\n        System.out.println(solution.how_many_times(\"testtest\", \"test\")); // Expected output: 2\n    }\n}\n"}
{"task_id": "Java/19", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Input is a space-delimited string of numberals from 'zero' to 'nine'.\n     * Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n     * Return the string with numbers sorted from smallest to largest\n     * >>> sort_numbers(\"three one five\")\n     * \"one three five\"\n     */\n    public String sort_numbers(String numbers) {\n        // Convert the input string to an array of words\n        String[] words = numbers.split(\" \");\n        \n        // Map the words to their corresponding numerical values\n        int[] nums = new int[words.length];\n        for (int i = 0; i < words.length; i++) {\n            switch (words[i]) {\n                case \"zero\":\n                    nums[i] = 0;\n                    break;\n                case \"one\":\n                    nums[i] = 1;\n                    break;\n                case \"two\":\n                    nums[i] = 2;\n                    break;\n                case \"three\":\n                    nums[i] = 3;\n                    break;\n                case \"four\":\n                    nums[i] = 4;\n                    break;\n                case \"five\":\n                    nums[i] = 5;\n                    break;\n                case \"six\":\n                    nums[i] = 6;\n                    break;\n                case \"seven\":\n                    nums[i] = 7;\n                    break;\n                case \"eight\":\n                    nums[i] = 8;\n                    break;\n                case \"nine\":\n                    nums[i] = 9;\n                    break;\n            }\n        }\n        \n        // Sort the array of numerical values\n        Arrays.sort(nums);\n        \n        // Map the sorted numerical values back to words\n        String[] sortedWords = new String[nums.length];\n        for (int i = 0; i < nums.length; i++) {\n            switch (nums[i]) {\n                case 0:\n                    sortedWords[i] = \"zero\";\n                    break;\n                case 1:\n                    sortedWords[i] = \"one\";\n                    break;\n                case 2:\n                    sortedWords[i] = \"two\";\n                    break;\n                case 3:\n                    sortedWords[i] = \"three\";\n                    break;\n                case 4:\n                    sortedWords[i] = \"four\";\n                    break;\n                case 5:\n                    sortedWords[i] = \"five\";\n                    break;\n                case 6:\n                    sortedWords[i] = \"six\";\n                    break;\n                case 7:\n                    sortedWords[i] = \"seven\";\n                    break;\n                case 8:\n                    sortedWords[i] = \"eight\";\n                    break;\n                case 9:\n                    sortedWords[i] = \"nine\";\n                    break;\n            }\n        }\n        \n        // Join the words back into a single string\n        return String.join(\" \", sortedWords);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.sort_numbers(\"three one five\"));  // Output: \"one three five\"\n    }\n}\n"}
{"task_id": "Java/20", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * From a supplied list of numbers (of length at least two) select and return two that are the closest to each other and return them in order (smaller number, larger number).\n     */\n    public List<Double> find_closest_elements(List<Double> numbers) {\n        if (numbers == null || numbers.size() < 2) {\n            throw new IllegalArgumentException(\"List must contain at least two elements.\");\n        }\n\n        double minDiff = Double.MAX_VALUE;\n        List<Double> closestElements = new ArrayList<>();\n\n        for (int i = 0; i < numbers.size(); i++) {\n            for (int j = i + 1; j < numbers.size(); j++) {\n                double diff = Math.abs(numbers.get(i) - numbers.get(j));\n                if (diff < minDiff) {\n                    minDiff = diff;\n                    closestElements.clear();\n                    closestElements.add(Math.min(numbers.get(i), numbers.get(j)));\n                    closestElements.add(Math.max(numbers.get(i), numbers.get(j)));\n                }\n            }\n        }\n\n        return closestElements;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.find_closest_elements(Arrays.asList(1.0, 2.0, 3.0, 4.0, 5.0, 2.2))); // [2.0, 2.2]\n        System.out.println(solution.find_closest_elements(Arrays.asList(1.0, 2.0, 3.0, 4.0, 5.0, 2.0)));  // [2.0, 2.0]\n        System.out.println(solution.find_closest_elements(Arrays.asList(-1.0, -2.0, -3.0, -4.0, -5.0, -2.2))); // [-2.2, -2.0]\n        System.out.println(solution.find_closest_elements(Arrays.asList(10.5, 10.6, 10.7, 10.8, 10.9))); // [10.5, 10.6]\n    }\n}\n"}
{"task_id": "Java/21", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given list of numbers (of at least two elements), apply a linear transform to that list,\n     * such that the smallest number will become 0 and the largest will become 1.\n     *\n     * @param numbers List of Double values\n     * @return A new list where each element is rescaled to the range [0, 1]\n     */\n    public List<Double> rescale_to_unit(List<Double> numbers) {\n        if (numbers == null || numbers.size() < 2) {\n            throw new IllegalArgumentException(\"List must contain at least two elements\");\n        }\n\n        double min = Collections.min(numbers);\n        double max = Collections.max(numbers);\n\n        List<Double> result = new ArrayList<>();\n        for (Double num : numbers) {\n            double scaledValue = (num - min) / (max - min);\n            result.add(scaledValue);\n        }\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        List<Double> test1 = Arrays.asList(1.0, 2.0, 3.0, 4.0, 5.0);\n        System.out.println(\"Test Case 1: \" + solution.rescale_to_unit(test1));\n        \n        List<Double> test2 = Arrays.asList(-1.0, -2.0, -3.0, -4.0, -5.0);\n        System.out.println(\"Test Case 2: \" + solution.rescale_to_unit(test2));\n        \n        List<Double> test3 = Arrays.asList(10.0, 20.0, 30.0, 40.0, 50.0);\n        System.out.println(\"Test Case 3: \" + solution.rescale_to_unit(test3));\n    }\n}\n"}
{"task_id": "Java/22", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> filter_integers(List<Object> values) {\n        List<Integer> integers = new ArrayList<>();\n        for (Object value : values) {\n            if (value instanceof Integer) {\n                integers.add((Integer) value);\n            }\n        }\n        return integers;\n    }\n}\n"}
{"task_id": "Java/23", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Return length of given string\n     * >>> strlen(\"\")\n     * 0\n     * >>> strlen(\"abc\")\n     * 3\n     */\n    public int strlen(String string) {\n        return string.length();\n    }\n\n    public static void main(String[] args) {\n        // Create an instance of Solution\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(\"Test Case 1: Empty String\");\n        System.out.println(\"Expected Output: 0\");\n        System.out.println(\"Actual Output: \" + solution.strlen(\"\"));\n        System.out.println();\n\n        System.out.println(\"Test Case 2: Single Character String\");\n        System.out.println(\"Expected Output: 1\");\n        System.out.println(\"Actual Output: \" + solution.strlen(\"a\"));\n        System.out.println();\n\n        System.out.println(\"Test Case 3: Multiple Characters String\");\n        System.out.println(\"Expected Output: 5\");\n        System.out.println(\"Actual Output: \" + solution.strlen(\"hello\"));\n        System.out.println();\n\n        System.out.println(\"Test Case 4: Longer String with Spaces and Special Characters\");\n        System.out.println(\"Expected Output: 12\");\n        System.out.println(\"Actual Output: \" + solution.strlen(\"Hello, world!\"));\n    }\n}\n"}
{"task_id": "Java/24", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * For a given number n, find the largest number that divides n evenly, smaller than n.\n     *\n     * @param n The input number.\n     * @return The largest divisor of n that is smaller than n.\n     */\n    public int largest_divisor(int n) {\n        for (int i = n / 2; i >= 1; i--) {\n            if (n % i == 0) {\n                return i;\n            }\n        }\n        // If no divisor found, which should not happen for positive integers,\n        // we return -1 as an error indicator.\n        return -1;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.largest_divisor(15));  // Expected output: 5\n        System.out.println(solution.largest_divisor(28));  // Expected output: 14\n        System.out.println(solution.largest_divisor(37));  // Expected output: -1 (since 37 is prime)\n        System.out.println(solution.largest_divisor(100)); // Expected output: 50\n    }\n}\n"}
{"task_id": "Java/25", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Return list of prime factors of given integer in the order from smallest to largest.\n     * Each of the factors should be listed number of times corresponding to how many times it appears in factorization.\n     * Input number should be equal to the product of all factors\n     *\n     * @param n the integer to factorize\n     * @return a list of prime factors\n     */\n    public List<Integer> factorize(int n) {\n        List<Integer> factors = new ArrayList<>();\n        for (int factor = 2; factor <= n; factor++) {\n            while (n % factor == 0) {\n                factors.add(factor);\n                n /= factor;\n            }\n        }\n        return factors;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(\"Factorize(8): \" + solution.factorize(8));   // Expected: [2, 2, 2]\n        System.out.println(\"Factorize(25): \" + solution.factorize(25));  // Expected: [5, 5]\n        System.out.println(\"Factorize(70): \" + solution.factorize(70));  // Expected: [2, 5, 7]\n        System.out.println(\"Factorize(49): \" + solution.factorize(49));  // Expected: [7, 7]\n        System.out.println(\"Factorize(1): \" + solution.factorize(1));    // Expected: []\n        System.out.println(\"Factorize(2): \" + solution.factorize(2));    // Expected: [2]\n    }\n}\n"}
{"task_id": "Java/26", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> remove_duplicates(List<Integer> numbers) {\n        Set<Integer> seen = new HashSet<>();\n        List<Integer> result = new ArrayList<>();\n        \n        for (Integer num : numbers) {\n            if (!seen.contains(num)) {\n                seen.add(num);\n                result.add(num);\n            }\n        }\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        List<Integer> input1 = Arrays.asList(1, 2, 3, 2, 4);\n        System.out.println(solution.remove_duplicates(input1)); // Output: [1, 3, 4]\n        \n        List<Integer> input2 = Arrays.asList(5, 6, 7, 8, 9, 7, 10);\n        System.out.println(solution.remove_duplicates(input2)); // Output: [5, 6, 8, 9, 10]\n    }\n}\n"}
{"task_id": "Java/27", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n     *\n     * @param string The input string to be flipped.\n     * @return A new string with the case of each character flipped.\n     */\n    public String flip_case(String string) {\n        StringBuilder result = new StringBuilder();\n        for (char c : string.toCharArray()) {\n            if (Character.isUpperCase(c)) {\n                result.append(Character.toLowerCase(c));\n            } else {\n                result.append(Character.toUpperCase(c));\n            }\n        }\n        return result.toString();\n    }\n\n    // Test method to verify the correctness of flip_case\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.flip_case(\"Hello\"));  // Expected: \"hELLO\"\n        System.out.println(solution.flip_case(\"WORLD\"));  // Expected: \"world\"\n        System.out.println(solution.flip_case(\"Java\"));   // Expected: \"jAVA\"\n        System.out.println(solution.flip_case(\"123abcABC\"));  // Expected: \"123ABCabc\"\n        System.out.println(solution.flip_case(\"\"));       // Expected: \"\"\n    }\n}\n"}
{"task_id": "Java/28", "generation": "import java.util.Arrays;\nimport java.util.List;\n\nclass Solution {\n    /**\n     * Concatenate list of strings into a single string\n     *\n     * @param strings List of strings to concatenate\n     * @return A single concatenated string\n     */\n    public String concatenate(List<String> strings) {\n        StringBuilder sb = new StringBuilder();\n        for (String str : strings) {\n            sb.append(str);\n        }\n        return sb.toString();\n    }\n}\n\nclass TestSolution {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1: Empty list\n        List<String> emptyList = Arrays.asList();\n        System.out.println(\"Expected: '', Actual: '\" + solution.concatenate(emptyList) + \"'\");\n\n        // Test case 2: Single element list\n        List<String> singleElementList = Arrays.asList(\"a\");\n        System.out.println(\"Expected: 'a', Actual: '\" + solution.concatenate(singleElementList) + \"'\");\n\n        // Test case 3: Multiple elements list\n        List<String> multipleElementsList = Arrays.asList(\"a\", \"b\", \"c\");\n        System.out.println(\"Expected: 'abc', Actual: '\" + solution.concatenate(multipleElementsList) + \"'\");\n    }\n}\n"}
{"task_id": "Java/29", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Filter an input list of strings only for ones that start with a given prefix.\n     *\n     * @param strings The input list of strings.\n     * @param prefix  The prefix to filter the strings by.\n     * @return A list of strings that start with the given prefix.\n     */\n    public List<String> filter_by_prefix(List<String> strings, String prefix) {\n        return strings.stream()\n                      .filter(s -> s.startsWith(prefix))\n                      .collect(Collectors.toList());\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.filter_by_prefix(new ArrayList<>(), \"a\"));  // []\n        System.out.println(solution.filter_by_prefix(Arrays.asList(\"abc\", \"bcd\", \"cde\", \"array\"), \"a\"));  // [abc, array]\n        System.out.println(solution.filter_by_prefix(Arrays.asList(\"apple\", \"banana\", \"apricot\", \"cherry\"), \"a\"));  // [apple, apricot]\n    }\n}\n"}
{"task_id": "Java/30", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return only positive numbers in the list.\n     */\n    public List<Integer> get_positive(List<Integer> l) {\n        return l.stream()\n                .filter(num -> num > 0)\n                .collect(Collectors.toList());\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(\"Test Case 1: \" + testGetPositive(Arrays.asList(-1, 2, -4, 5, 6), Arrays.asList(2, 5, 6)));\n        System.out.println(\"Test Case 2: \" + testGetPositive(Arrays.asList(5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10), Arrays.asList(5, 3, 2, 3, 9, 123, 1)));\n    }\n\n    private static boolean testGetPositive(List<Integer> input, List<Integer> expected) {\n        Solution solution = new Solution();\n        List<Integer> result = solution.get_positive(input);\n        return result.equals(expected);\n    }\n}\n"}
{"task_id": "Java/31", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Return true if a given number is prime, and false otherwise.\n     */\n    public boolean is_prime(int n) {\n        // Handle edge cases for 0, 1, and negative numbers\n        if (n <= 1) {\n            return false;\n        }\n        \n        // Check divisibility from 2 to the square root of n\n        for (int i = 2; i <= Math.sqrt(n); i++) {\n            if (n % i == 0) {\n                return false;\n            }\n        }\n        \n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(\"is_prime(6): \" + !solution.is_prime(6));   // Expected: false\n        System.out.println(\"is_prime(101): \" + solution.is_prime(101)); // Expected: true\n        System.out.println(\"is_prime(11): \" + solution.is_prime(11));   // Expected: true\n        System.out.println(\"is_prime(13441): \" + !solution.is_prime(13441)); // Expected: false (13441 is not prime)\n        System.out.println(\"is_prime(61): \" + solution.is_prime(61));   // Expected: true\n        System.out.println(\"is_prime(4): \" + !solution.is_prime(4));    // Expected: false\n        System.out.println(\"is_prime(1): \" + !solution.is_prime(1));    // Expected: false\n    }\n}\n"}
{"task_id": "Java/32", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     Evaluates polynomial with coefficients xs at point x.\n     return xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n\n      */\n    public double poly(List<Double> xs, double x) {\n        double result = 0;\n        for (int i = 0; i < xs.size(); i++) {\n            result += xs.get(i) * Math.pow(x, i);\n        }\n        return result;\n    }\n\n    /**\n     xs are coefficients of a polynomial.\n     find_zero finds x such that poly(x) = 0.\n     find_zero returns only one zero point, even if there are many.\n     Moreover, find_zero only takes list xs having an even number of coefficients\n     and guarantees a solution by ensuring the largest non-zero coefficient is at the end.\n      */\n    public double find_zero(List<Double> xs) {\n        if (xs.size() % 2 != 0) {\n            throw new IllegalArgumentException(\"The list of coefficients must have an even number of elements.\");\n        }\n\n        // Ensure the largest non-zero coefficient is at the end\n        List<Double> nonZeroCoefficients = new ArrayList<>();\n        for (double c : xs) {\n            if (c != 0) {\n                nonZeroCoefficients.add(c);\n            }\n        }\n        \n        if (nonZeroCoefficients.isEmpty() || Math.abs(nonZeroCoefficients.get(0)) == 0) {\n            throw new IllegalArgumentException(\"There must be a non-zero coefficient to guarantee a solution.\");\n        }\n\n        double x = 0.5 * (nonZeroCoefficients.get(0) / nonZeroCoefficients.get(nonZeroCoefficients.size() - 1));\n        \n        for (int i = 0; i < 100; i++) { // Limit iterations to prevent infinite loops\n            double polyValue = poly(xs, x);\n            if (Math.abs(polyValue) < 1e-6) {\n                break;\n            }\n            x -= polyValue / derivative(xs, x); // Newton's method update step\n        }\n\n        return x;\n    }\n\n    private double derivative(List<Double> xs, double x) {\n        double result = 0;\n        for (int i = 1; i < xs.size(); i++) {\n            result += i * xs.get(i) * Math.pow(x, i - 1);\n        }\n        return result;\n    }\n}\n"}
{"task_id": "Java/33", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> sort_third(List<Integer> l) {\n        List<Integer> result = new ArrayList<>(l);\n        List<Integer> thirdIndicesValues = new ArrayList<>();\n        \n        // Collect values at indices divisible by three\n        for (int i = 2; i < l.size(); i += 3) {\n            thirdIndicesValues.add(l.get(i));\n        }\n        \n        // Sort the collected values\n        Collections.sort(thirdIndicesValues);\n        \n        // Update the result list with sorted values at appropriate positions\n        int index = 0;\n        for (int i = 2; i < l.size(); i += 3) {\n            result.set(i, thirdIndicesValues.get(index++));\n        }\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.sort_third(Arrays.asList(1, 2, 3))); // [1, 2, 3]\n        System.out.println(solution.sort_third(Arrays.asList(5, 6, 3, 4, 8, 9, 2))); // [2, 6, 3, 4, 8, 9, 5]\n    }\n}\n"}
{"task_id": "Java/34", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return sorted unique elements in a list\n     *\n     * @param l input list of integers\n     * @return a List containing sorted unique elements from the input list\n     */\n    public List<Integer> unique(List<Integer> l) {\n        Set<Integer> set = new TreeSet<>(l);\n        return new ArrayList<>(set);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.unique(Arrays.asList(5, 3, 5, 2, 3, 3, 9, 0, 123))); // [0, 2, 3, 5, 9, 123]\n        System.out.println(solution.unique(Arrays.asList())); // []\n        System.out.println(solution.unique(Arrays.asList(1, 2, 3))); // [1, 2, 3]\n        System.out.println(solution.unique(Arrays.asList(-1, -2, -3, -4, -5))); // [-5, -4, -3, -2, -1]\n        System.out.println(solution.unique(Arrays.asList(7, 8, 9, 7, 8, 9, 10))); // [7, 8, 9, 10]\n    }\n}\n"}
{"task_id": "Java/35", "generation": "import java.util.Arrays;\nimport java.util.List;\n\nclass Solution {\n\n    /**\n     * Return maximum element in the list.\n     */\n    public int max_element(List<Integer> l) {\n        if (l == null || l.isEmpty()) {\n            throw new IllegalArgumentException(\"List cannot be null or empty\");\n        }\n        \n        return l.stream().max(Integer::compare).get();\n    }\n\n    // Test cases to verify the correctness of the function\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        List<Integer> list1 = Arrays.asList(1, 2, 3);\n        System.out.println(\"Max element in \" + list1 + \": \" + solution.max_element(list1)); // Expected: 3\n\n        // Test case 2\n        List<Integer> list2 = Arrays.asList(5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10);\n        System.out.println(\"Max element in \" + list2 + \": \" + solution.max_element(list2)); // Expected: 123\n\n        // Test case 3\n        List<Integer> list3 = Arrays.asList(-1, -2, -3, -4);\n        System.out.println(\"Max element in \" + list3 + \": \" + solution.max_element(list3)); // Expected: -1\n\n        // Test case 4\n        List<Integer> list4 = Arrays.asList(0);\n        System.out.println(\"Max element in \" + list4 + \": \" + solution.max_element(list4)); // Expected: 0\n\n        // Test case 5 (edge case)\n        List<Integer> list5 = Arrays.asList();\n        try {\n            System.out.println(\"Max element in empty list: \" + solution.max_element(list5));\n        } catch (IllegalArgumentException e) {\n            System.out.println(e.getMessage()); // Expected: List cannot be null or empty\n        }\n    }\n}\n"}
{"task_id": "Java/36", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n\n    /**\n     * Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n     */\n    public int fizz_buzz(int n) {\n        int count = 0;\n        for (int i = 1; i < n; i++) {\n            if (i % 11 == 0 || i % 13 == 0) {\n                String numStr = Integer.toString(i);\n                for (char c : numStr.toCharArray()) {\n                    if (c == '7') {\n                        count++;\n                    }\n                }\n            }\n        }\n        return count;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(\"fizz_buzz(50): \" + solution.fizz_buzz(50)); // Expected: 0\n        System.out.println(\"fizz_buzz(78): \" + solution.fizz_buzz(78)); // Expected: 2\n        System.out.println(\"fizz_buzz(79): \" + solution.fizz_buzz(79)); // Expected: 3\n        System.out.println(\"fizz_buzz(100): \" + solution.fizz_buzz(100)); // Expected: 4 (77, 781, 782, 783)\n        System.out.println(\"fizz_buzz(150): \" + solution.fizz_buzz(150)); // Expected: 6\n    }\n}\n"}
{"task_id": "Java/37", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * This function takes a list l and returns a list l' such that\n     * l' is identical to l in the odd indicies, while its values at the even indicies are equal\n     * to the values of the even indicies of l, but sorted.\n     */\n    public List<Integer> sort_even(List<Integer> l) {\n        List<Integer> result = new ArrayList<>(l);\n        List<Integer> evenIndicesValues = new ArrayList<>();\n        \n        // Extract values at even indices\n        for (int i = 0; i < result.size(); i += 2) {\n            evenIndicesValues.add(result.get(i));\n        }\n        \n        // Sort the extracted values\n        Collections.sort(evenIndicesValues);\n        \n        // Place sorted values back into their original positions\n        int evenIndex = 0;\n        for (int i = 0; i < result.size(); i += 2) {\n            result.set(i, evenIndicesValues.get(evenIndex++));\n        }\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.sort_even(Arrays.asList(1, 2, 3))); // Expected: [1, 2, 3]\n        System.out.println(solution.sort_even(Arrays.asList(5, 6, 3, 4))); // Expected: [3, 6, 5, 4]\n        System.out.println(solution.sort_even(Arrays.asList(9, 8, 7, 6, 5, 4, 3, 2, 1))); // Expected: [3, 8, 7, 6, 5, 4, 9, 2, 1]\n        System.out.println(solution.sort_even(Arrays.asList())); // Expected: []\n    }\n}\n"}
{"task_id": "Java/38", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     returns encoded string by cycling groups of three characters.\n     */\n    public String encodeCyclic(String s) {\n        // split string into groups. Each group has a length of 3.\n        List<String> groups = new ArrayList<>();\n        for (int i = 0; i < s.length(); i += 3) {\n            groups.add(s.substring(i, Math.min(i + 3, s.length())));\n        }\n        \n        // cycle elements in each group. Unless the group has fewer than 3 characters.\n        for (int i = 0; i < groups.size(); i++) {\n            if (groups.get(i).length() == 3) {\n                groups.set(i, groups.get(i).substring(1) + groups.get(i).charAt(0));\n            }\n        }\n        \n        return String.join(\"\", groups);\n    }\n\n    /**\n     takes as input a string encoded with encodeCyclic function. Returns decoded string.\n     */\n    public String decodeCyclic(String s) {\n        // split string into groups. Each group has a length of 3.\n        List<String> groups = new ArrayList<>();\n        for (int i = 0; i < s.length(); i += 3) {\n            groups.add(s.substring(i, Math.min(i + 3, s.length())));\n        }\n        \n        // cycle elements in each group. Unless the group has fewer than 3 characters.\n        for (int i = 0; i < groups.size(); i++) {\n            if (groups.get(i).length() == 3) {\n                groups.set(i, groups.get(i).substring(groups.get(i).length() - 1) + groups.get(i).substring(0, groups.get(i).length() - 1));\n            }\n        }\n        \n        return String.join(\"\", groups);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        String encoded = solution.encodeCyclic(\"abcdef\");\n        System.out.println(\"Encoded: \" + encoded); // Expected output: \"bcaef\"\n\n        String decoded = solution.decodeCyclic(encoded);\n        System.out.println(\"Decoded: \" + decoded); // Expected output: \"abcde\"\n    }\n}\n"}
{"task_id": "Java/39", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * prime_fib returns n-th number that is a Fibonacci number and it's also prime.\n     *\n     * >>> prime_fib(1)\n     * 2\n     * >>> prime_fib(2)\n     * 3\n     * >>> prime_fib(3)\n     * 5\n     * >>> prime_fib(4)\n     * 13\n     * >>> prime_fib(5)\n     * 89\n     */\n    public long prime_fib(int n) {\n        return findPrimeFibonacci(n);\n    }\n\n    private boolean isPrime(long num) {\n        if (num <= 1) return false;\n        for (long i = 2; i * i <= num; i++) {\n            if (num % i == 0) return false;\n        }\n        return true;\n    }\n\n    private long findFibonacci(int n, long a, long b) {\n        if (n == 1) return a;\n        return findFibonacci(n - 1, b, a + b);\n    }\n\n    private long findPrimeFibonacci(int n) {\n        int count = 0;\n        long a = 0, b = 1;\n        while (true) {\n            long fibNum = findFibonacci(n, a, b);\n            if (isPrime(fibNum)) {\n                count++;\n                if (count == n) return fibNum;\n            }\n            a = b;\n            b = fibNum;\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.prime_fib(1));  // Output: 2\n        System.out.println(solution.prime_fib(2));  // Output: 3\n        System.out.println(solution.prime_fib(3));  // Output: 5\n        System.out.println(solution.prime_fib(4));  // Output: 13\n        System.out.println(solution.prime_fib(5));  // Output: 89\n    }\n}\n"}
{"task_id": "Java/40", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * triples_sum_to_zero takes a list of integers as an input.\n     * it returns True if there are three distinct elements in the list that\n     * sum to zero, and False otherwise.\n     */\n    public boolean triples_sum_to_zero(List<Integer> l) {\n        // Sort the list to make it easier to find triplets that sum to zero\n        Collections.sort(l);\n        \n        for (int i = 0; i < l.size() - 2; i++) {\n            int left = i + 1;\n            int right = l.size() - 1;\n            \n            while (left < right) {\n                int sum = l.get(i) + l.get(left) + l.get(right);\n                \n                if (sum == 0) {\n                    return true;\n                } else if (sum < 0) {\n                    left++;\n                } else {\n                    right--;\n                }\n            }\n        }\n        \n        return false;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.triples_sum_to_zero(Arrays.asList(1, 3, 5, 0))); // false\n        System.out.println(solution.triples_sum_to_zero(Arrays.asList(1, 3, -2, 1))); // true\n        System.out.println(solution.triples_sum_to_zero(Arrays.asList(1, 2, 3, 7))); // false\n        System.out.println(solution.triples_sum_to_zero(Arrays.asList(2, 4, -5, 3, 9, 7))); // true\n        System.out.println(solution.triples_sum_to_zero(Arrays.asList(1))); // false\n    }\n}\n"}
{"task_id": "Java/41", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Imagine a road that's a perfectly straight infinitely long line.\n    n cars are driving left to right; simultaneously, a different set of n cars\n    are driving right to left. The two sets of cars start out being very far from each other.\n    All cars move in the same speed. Two cars are said to collide when a car that's moving left to right hits a car that's moving right to left.\n    However, the cars are infinitely sturdy and strong; as a result, they continue moving\n    in their trajectory as if they did not collide.\n\n    This function outputs the number of such collisions.\n     */\n    public int car_race_collision(int n) {\n        // Since all cars are moving at the same speed and start far apart,\n        // each car moving left-to-right will eventually collide with each car moving right-to-left.\n        // Therefore, the total number of collisions is simply n * n.\n        return n * n;\n    }\n}\n"}
{"task_id": "Java/42", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return list with elements incremented by 1.\n     *\n     * @param l The input list of integers.\n     * @return A new list where each element is incremented by 1.\n     */\n    public List<Integer> incr_list(List<Integer> l) {\n        return l.stream().map(i -> i + 1).collect(Collectors.toList());\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        List<Integer> list1 = Arrays.asList(1, 2, 3);\n        System.out.println(\"Original: \" + list1);\n        System.out.println(\"Incremented: \" + solution.incr_list(list1));\n\n        // Test case 2\n        List<Integer> list2 = Arrays.asList(5, 3, 5, 2, 3, 3, 9, 0, 123);\n        System.out.println(\"Original: \" + list2);\n        System.out.println(\"Incremented: \" + solution.incr_list(list2));\n    }\n}\n"}
{"task_id": "Java/43", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * pairs_sum_to_zero takes a list of integers as an input.\n     * it returns True if there are two distinct elements in the list that\n     * sum to zero, and False otherwise.\n     */\n    public boolean pairs_sum_to_zero(List<Integer> l) {\n        Set<Integer> seen = new HashSet<>();\n        for (int num : l) {\n            if (seen.contains(-num)) {\n                return true;\n            }\n            seen.add(num);\n        }\n        return false;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.pairs_sum_to_zero(Arrays.asList(1, 3, 5, 0))); // false\n        System.out.println(solution.pairs_sum_to_zero(Arrays.asList(1, 3, -2, 1))); // false\n        System.out.println(solution.pairs_sum_to_zero(Arrays.asList(1, 2, 3, 7))); // false\n        System.out.println(solution.pairs_sum_to_zero(Arrays.asList(2, 4, -5, 3, 5, 7))); // true\n        System.out.println(solution.pairs_sum_to_zero(Arrays.asList(1))); // false\n    }\n}\n"}
{"task_id": "Java/44", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Change numerical base of input number x to base.\n     * return string representation after the conversion.\n     * base numbers are less than 10.\n     *\n     * @param x The number to be converted.\n     * @param base The target base for conversion (less than 10).\n     * @return String representation of the converted number.\n     */\n    public String change_base(int x, int base) {\n        if (x == 0) return \"0\";\n        \n        StringBuilder result = new StringBuilder();\n        while (x > 0) {\n            int remainder = x % base;\n            result.insert(0, remainder);\n            x /= base;\n        }\n        \n        return result.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.change_base(8, 3));  // Expected output: \"22\"\n        System.out.println(solution.change_base(8, 2));  // Expected output: \"1000\"\n        System.out.println(solution.change_base(7, 2));  // Expected output: \"111\"\n        System.out.println(solution.change_base(255, 16)); // Expected output: \"FF\" (for base 16)\n        System.out.println(solution.change_base(10, 8));  // Expected output: \"12\"\n    }\n}\n"}
{"task_id": "Java/45", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given length of a side (base) and height, return area for a triangle.\n     *\n     * @param a The base of the triangle.\n     * @param h The height of the triangle.\n     * @return The area of the triangle.\n     */\n    public double triangle_area(double a, double h) {\n        return 0.5 * a * h;\n    }\n\n    /**\n     * Main method to run test cases for the triangle_area function.\n     *\n     * @param args Command line arguments (not used).\n     */\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(\"Test Case 1: Base = 5, Height = 3\");\n        double result1 = solution.triangle_area(5, 3);\n        System.out.println(\"Expected: 7.5, Actual: \" + result1);\n\n        System.out.println(\"\\nTest Case 2: Base = 10, Height = 4\");\n        double result2 = solution.triangle_area(10, 4);\n        System.out.println(\"Expected: 20.0, Actual: \" + result2);\n\n        System.out.println(\"\\nTest Case 3: Base = 7, Height = 8\");\n        double result3 = solution.triangle_area(7, 8);\n        System.out.println(\"Expected: 28.0, Actual: \" + result3);\n\n        // Add more test cases as needed\n    }\n}\n"}
{"task_id": "Java/46", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n    The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n    fib4(0) -> 0\n    fib4(1) -> 0\n    fib4(2) -> 2\n    fib4(3) -> 0\n    fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n    Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.\n    >>> fib4(5)\n    4\n    >>> fib4(6)\n    8\n    >>> fib4(7)\n    14\n     */\n    public int fib4(int n) {\n        if (n == 0 || n == 1) return 0;\n        if (n == 2) return 2;\n        if (n == 3) return 0;\n\n        int[] dp = new int[n + 1];\n        dp[0] = 0;\n        dp[1] = 0;\n        dp[2] = 2;\n        dp[3] = 0;\n\n        for (int i = 4; i <= n; i++) {\n            dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3] + dp[i - 4];\n        }\n\n        return dp[n];\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.fib4(5)); // Expected output: 4\n        System.out.println(solution.fib4(6)); // Expected output: 8\n        System.out.println(solution.fib4(7)); // Expected output: 14\n        System.out.println(solution.fib4(8)); // Expected output: 24\n        System.out.println(solution.fib4(9)); // Expected output: 44\n    }\n}\n"}
{"task_id": "Java/47", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return median of elements in the list l.\n     */\n    public double median(List<Integer> l) {\n        if (l == null || l.isEmpty()) {\n            throw new IllegalArgumentException(\"List cannot be null or empty\");\n        }\n\n        Collections.sort(l);\n        int size = l.size();\n        if (size % 2 == 0) {\n            return (l.get(size / 2 - 1) + l.get(size / 2)) / 2.0;\n        } else {\n            return l.get(size / 2);\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        List<Integer> testList1 = Arrays.asList(3, 1, 2, 4, 5);\n        System.out.println(\"Median of [3, 1, 2, 4, 5]: \" + solution.median(testList1)); // Expected: 3\n\n        List<Integer> testList2 = Arrays.asList(-10, 4, 6, 1000, 10, 20);\n        System.out.println(\"Median of [-10, 4, 6, 1000, 10, 20]: \" + solution.median(testList2)); // Expected: 8.0\n\n        List<Integer> testList3 = Arrays.asList(1, 2, 3, 4);\n        System.out.println(\"Median of [1, 2, 3, 4]: \" + solution.median(testList3)); // Expected: 2.5\n\n        List<Integer> testList4 = Arrays.asList(-5, -3, -1, 0, 2, 4, 6);\n        System.out.println(\"Median of [-5, -3, -1, 0, 2, 4, 6]: \" + solution.median(testList4)); // Expected: 0.0\n\n        List<Integer> testList5 = Arrays.asList();\n        try {\n            System.out.println(\"Median of []: \" + solution.median(testList5));\n        } catch (IllegalArgumentException e) {\n            System.out.println(\"Caught expected exception for empty list: \" + e.getMessage());\n        }\n\n        List<Integer> testList6 = null;\n        try {\n            System.out.println(\"Median of null: \" + solution.median(testList6));\n        } catch (IllegalArgumentException e) {\n            System.out.println(\"Caught expected exception for null list: \" + e.getMessage());\n        }\n    }\n}\n"}
{"task_id": "Java/48", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     Checks if given string is a palindrome\n     >>> is_palindrome(\"\")\n     true\n     >>> is_palindrome(\"aba\")\n     true\n     >>> is_palindrome(\"aaaaa\")\n     true\n     >>> is_palindrome(\"zbcd\")\n     false\n     */\n    public boolean is_palindrome(String text) {\n        int left = 0;\n        int right = text.length() - 1;\n\n        while (left < right) {\n            if (text.charAt(left) != text.charAt(right)) {\n                return false;\n            }\n            left++;\n            right--;\n        }\n\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.is_palindrome(\"\"));       // true\n        System.out.println(solution.is_palindrome(\"aba\"));    // true\n        System.out.println(solution.is_palindrome(\"aaaaa\"));  // true\n        System.out.println(solution.is_palindrome(\"zbcd\"));   // false\n        System.out.println(solution.is_palindrome(\"level\"));  // true\n        System.out.println(solution.is_palindrome(\"noon\"));   // true\n        System.out.println(solution.is_palindrome(\"abcde\"));  // false\n    }\n}\n"}
{"task_id": "Java/49", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return 2^n modulo p (be aware of numerics).\n     */\n    public int modp(int n, int p) {\n        if (n == 0) return 1; // Base case: 2^0 = 1\n        long result = 1;\n        for (int i = 0; i < n; i++) {\n            result = (result * 2) % p;\n        }\n        return (int) result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.modp(3, 5));   // Expected output: 3\n        System.out.println(solution.modp(1101, 101)); // Expected output: 2\n        System.out.println(solution.modp(0, 101));  // Expected output: 1\n        System.out.println(solution.modp(3, 11));   // Expected output: 8\n        System.out.println(solution.modp(100, 101)); // Expected output: 1\n    }\n}\n"}
{"task_id": "Java/50", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    returns encoded string by shifting every character by 5 in the alphabet.\n     */\n    public String encodeShift(String s) {\n        StringBuilder sb = new StringBuilder();\n        for (char ch : s.toCharArray()) {\n            if (ch >= 'a' && ch <= 'z') {\n                sb.append((char) ('a' + ((ch - 'a' + 5) % 26)));\n            } else if (ch >= 'A' && ch <= 'Z') {\n                sb.append((char) ('A' + ((ch - 'A' + 5) % 26)));\n            } else {\n                sb.append(ch);\n            }\n        }\n        return sb.toString();\n    }\n\n    /**\n    takes as input string encoded with encodeShift function. Returns decoded string.\n     */\n    public String decode_shift(String s) {\n        StringBuilder sb = new StringBuilder();\n        for (char ch : s.toCharArray()) {\n            if (ch >= 'a' && ch <= 'z') {\n                sb.append((char) ('a' + ((ch - 'a' - 5 + 26) % 26)));\n            } else if (ch >= 'A' && ch <= 'Z') {\n                sb.append((char) ('A' + ((ch - 'A' - 5 + 26) % 26)));\n            } else {\n                sb.append(ch);\n            }\n        }\n        return sb.toString();\n    }\n}\n"}
{"task_id": "Java/51", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * remove_vowels is a function that takes string and returns string without vowels.\n     */\n    public String remove_vowels(String text) {\n        if (text == null || text.isEmpty()) {\n            return text;\n        }\n        \n        StringBuilder result = new StringBuilder();\n        for (char c : text.toCharArray()) {\n            if (!isVowel(c)) {\n                result.append(c);\n            }\n        }\n        return result.toString();\n    }\n\n    private boolean isVowel(char c) {\n        return \"AEIOUaeiou\".indexOf(c) != -1;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.remove_vowels(\"\")); // Output: \"\"\n        System.out.println(solution.remove_vowels(\"abcdef\\nghijklm\")); // Output: \"bcdf\\nghjklm\"\n        System.out.println(solution.remove_vowels(\"abcdef\")); // Output: \"bcdf\"\n        System.out.println(solution.remove_vowels(\"aaaaa\")); // Output: \"\"\n        System.out.println(solution.remove_vowels(\"aaBAA\")); // Output: \"B\"\n        System.out.println(solution.remove_vowels(\"zbcd\")); // Output: \"zbcd\"\n    }\n}\n"}
{"task_id": "Java/52", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return True if all numbers in the list l are below threshold t.\n     */\n    public boolean below_threshold(List<Integer> l, int t) {\n        for (int num : l) {\n            if (num >= t) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.below_threshold(Arrays.asList(1, 2, 4, 10), 100)); // Expected: true\n        System.out.println(solution.below_threshold(Arrays.asList(1, 20, 4, 10), 5));  // Expected: false\n        System.out.println(solution.below_threshold(Arrays.asList(-1, -2, -3), 0));    // Expected: true\n        System.out.println(solution.below_threshold(Arrays.asList(), 100));            // Expected: true (empty list)\n        System.out.println(solution.below_threshold(Arrays.asList(99, 100, 101), 100)); // Expected: false\n    }\n}\n"}
{"task_id": "Java/53", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n     */\n    public int add(int x, int y) {\n        return x + y;\n    }\n}\n"}
{"task_id": "Java/54", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Check if two words have the same kind of characters.\n     */\n    public boolean same_chars(String s0, String s1) {\n        // Convert both strings to sets of characters\n        Set<Character> set0 = new HashSet<>();\n        for (char c : s0.toCharArray()) {\n            set0.add(c);\n        }\n        \n        Set<Character> set1 = new HashSet<>();\n        for (char c : s1.toCharArray()) {\n            set1.add(c);\n        }\n        \n        // Compare the sets\n        return set0.equals(set1);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.same_chars(\"eabcdzzzz\", \"dddzzzzzzzddeddabc\")); // true\n        System.out.println(solution.same_chars(\"abcd\", \"dddddddabc\"));              // true\n        System.out.println(solution.same_chars(\"dddddddabc\", \"abcd\"));              // true\n        System.out.println(solution.same_chars(\"eabcd\", \"dddddddabc\"));             // false\n        System.out.println(solution.same_chars(\"abcd\", \"dddddddabce\"));             // false\n        System.out.println(solution.same_chars(\"eabcdzzzz\", \"dddzzzzzzzddddabc\"));  // false\n    }\n}\n"}
{"task_id": "Java/55", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return n-th Fibonacci number.\n     * >>> fib(10)\n     * 55\n     * >>> fib(1)\n     * 1\n     * >>> fib(8)\n     * 21\n     */\n    public int fib(int n) {\n        if (n <= 0) {\n            return 0;\n        } else if (n == 1) {\n            return 1;\n        }\n        \n        int a = 0, b = 1, c = 0;\n        for (int i = 2; i <= n; i++) {\n            c = a + b;\n            a = b;\n            b = c;\n        }\n        return b;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(\"fib(10): \" + solution.fib(10)); // Expected: 55\n        System.out.println(\"fib(1): \" + solution.fib(1));   // Expected: 1\n        System.out.println(\"fib(8): \" + solution.fib(8));   // Expected: 21\n        System.out.println(\"fib(0): \" + solution.fib(0));   // Expected: 0\n        System.out.println(\"fib(-5): \" + solution.fib(-5)); // Expected: 0 (or handle as an error)\n    }\n}\n"}
{"task_id": "Java/56", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * brackets is a string of \"<\" and \">\".\n     * return True if every opening bracket has a corresponding closing bracket.\n     *\n     * >>> correct_bracketing(\"<\")\n     * false\n     * >>> correct_bracketing(\"<>\")\n     * true\n     * >>> correct_bracketing(\"<<><>>\")\n     * true\n     * >>> correct_bracketing(\"><<>\")\n     * false\n     */\n    public boolean correct_bracketing(String brackets) {\n        int balance = 0;\n        for (char c : brackets.toCharArray()) {\n            if (c == '<') {\n                balance++;\n            } else if (c == '>') {\n                balance--;\n            }\n            // If at any point the balance is negative, it means there's a closing bracket without an opening one\n            if (balance < 0) {\n                return false;\n            }\n        }\n        // If the balance is zero, all brackets are correctly matched\n        return balance == 0;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.correct_bracketing(\"<\"));      // false\n        System.out.println(solution.correct_bracketing(\"<>\"));     // true\n        System.out.println(solution.correct_bracketing(\"<<><>>\")); // true\n        System.out.println(solution.correct_bracketing(\"><<>\"));   // false\n    }\n}\n"}
{"task_id": "Java/57", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Return True if list elements are monotonically increasing or decreasing.\n    >>> monotonic(Arrays.asList(1, 2, 4, 20))\n    true\n    >>> monotonic(Arrays.asList(1, 20, 4, 10))\n    false\n    >>> monotonic(Arrays.asList(4, 1, 0, -10))\n    true\n     */\n    public boolean monotonic(List<Integer> l) {\n        boolean increasing = true;\n        boolean decreasing = true;\n\n        for (int i = 1; i < l.size(); i++) {\n            if (l.get(i) < l.get(i - 1)) {\n                increasing = false;\n            }\n            if (l.get(i) > l.get(i - 1)) {\n                decreasing = false;\n            }\n        }\n\n        return increasing || decreasing;\n    }\n}\n"}
{"task_id": "Java/58", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return sorted unique common elements for two lists.\n     */\n    public List<Integer> common(List<Integer> l1, List<Integer> l2) {\n        Set<Integer> set1 = new HashSet<>(l1);\n        Set<Integer> set2 = new HashSet<>(l2);\n\n        // Retain only the elements that are present in both sets\n        set1.retainAll(set2);\n\n        // Convert the resulting set to a sorted list\n        List<Integer> result = new ArrayList<>(set1);\n        Collections.sort(result);\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        List<Integer> l1 = Arrays.asList(1, 4, 3, 34, 653, 2, 5);\n        List<Integer> l2 = Arrays.asList(5, 7, 1, 5, 9, 653, 121);\n        System.out.println(\"Common elements (Test case 1): \" + solution.common(l1, l2)); // Expected: [1, 5, 653]\n\n        // Test case 2\n        List<Integer> l3 = Arrays.asList(5, 3, 2, 8);\n        List<Integer> l4 = Arrays.asList(3, 2);\n        System.out.println(\"Common elements (Test case 2): \" + solution.common(l3, l4)); // Expected: [2, 3]\n\n        // Test case 3\n        List<Integer> l5 = Arrays.asList(10, 20, 30, 40);\n        List<Integer> l6 = Arrays.asList(50, 60, 70);\n        System.out.println(\"Common elements (Test case 3): \" + solution.common(l5, l6)); // Expected: []\n\n        // Test case 4\n        List<Integer> l7 = Arrays.asList(1, 2, 3, 4, 5);\n        List<Integer> l8 = Arrays.asList(3, 4, 5, 6, 7);\n        System.out.println(\"Common elements (Test case 4): \" + solution.common(l7, l8)); // Expected: [3, 4, 5]\n    }\n}\n"}
{"task_id": "Java/59", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return the largest prime factor of n. Assume n > 1 and is not a prime.\n     *\n     * @param n The number to find the largest prime factor for.\n     * @return The largest prime factor of n.\n     */\n    public int largest_prime_factor(int n) {\n        int i = 2;\n        while (i * i <= n) {\n            if (n % i != 0) {\n                i += 1;\n            } else {\n                n /= i;\n            }\n        }\n        return n;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.largest_prime_factor(13195)); // Output: 29\n        System.out.println(solution.largest_prime_factor(2048));  // Output: 2\n    }\n}\n"}
{"task_id": "Java/60", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * sum_to_n is a function that sums numbers from 1 to n.\n     */\n    public int sum_to_n(int n) {\n        return (n * (n + 1)) / 2;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(\"sum_to_n(30): \" + solution.sum_to_n(30)); // Expected: 465\n        System.out.println(\"sum_to_n(100): \" + solution.sum_to_n(100)); // Expected: 5050\n        System.out.println(\"sum_to_n(5): \" + solution.sum_to_n(5)); // Expected: 15\n        System.out.println(\"sum_to_n(10): \" + solution.sum_to_n(10)); // Expected: 55\n        System.out.println(\"sum_to_n(1): \" + solution.sum_to_n(1)); // Expected: 1\n    }\n}\n"}
{"task_id": "Java/61", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * brackets is a string of \"(\" and \")\".\n     * return True if every opening bracket has a corresponding closing bracket.\n     *\n     * >>> correct_bracketing(\"(\")\n     * false\n     * >>> correct_bracketing(\"()\")\n     * true\n     * >>> correct_bracketing(\"(()())\")\n     * true\n     * >>> correct_bracketing(\")(()\")\n     * false\n     */\n    public boolean correct_bracketing(String brackets) {\n        Stack<Character> stack = new Stack<>();\n        \n        for (char c : brackets.toCharArray()) {\n            if (c == '(') {\n                stack.push(c);\n            } else if (c == ')') {\n                if (stack.isEmpty()) {\n                    return false;\n                }\n                stack.pop();\n            }\n        }\n        \n        return stack.isEmpty();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.correct_bracketing(\"(\"));       // Output: false\n        System.out.println(solution.correct_bracketing(\"()\"));      // Output: true\n        System.out.println(solution.correct_bracketing(\"(()())\"));  // Output: true\n        System.out.println(solution.correct_bracketing(\")(()\"));    // Output: false\n        System.out.println(solution.correct_bracketing(\"(())\"));    // Output: true\n        System.out.println(solution.correct_bracketing(\"()()\"));    // Output: true\n        System.out.println(solution.correct_bracketing(\"(()\"));     // Output: false\n        System.out.println(solution.correct_bracketing(\")(\"));      // Output: false\n    }\n}\n"}
{"task_id": "Java/62", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * xs represent coefficients of a polynomial.\n     * xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     * Return derivative of this polynomial in the same form.\n     */\n    public List<Integer> derivative(List<Integer> xs) {\n        if (xs == null || xs.isEmpty()) {\n            return Collections.emptyList();\n        }\n        \n        List<Integer> result = new ArrayList<>();\n        for (int i = 1; i < xs.size(); i++) {\n            result.add(xs.get(i) * i);\n        }\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(\"Derivative of [3, 1, 2, 4, 5]: \" + solution.derivative(Arrays.asList(3, 1, 2, 4, 5)));\n        System.out.println(\"Derivative of [1, 2, 3]: \" + solution.derivative(Arrays.asList(1, 2, 3)));\n\n        // Additional test cases\n        System.out.println(\"Derivative of [0, 1, 2, 3]: \" + solution.derivative(Arrays.asList(0, 1, 2, 3)));\n        System.out.println(\"Derivative of [5]: \" + solution.derivative(Arrays.asList(5)));\n        System.out.println(\"Derivative of []: \" + solution.derivative(new ArrayList<>()));\n    }\n}\n"}
{"task_id": "Java/63", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     The FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n     fibfib(0) == 0\n     fibfib(1) == 0\n     fibfib(2) == 1\n     fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n     Please write a function to efficiently compute the n-th element of the fibfib number sequence.\n     >>> fibfib(1)\n     0\n     >>> fibfib(5)\n     4\n     >>> fibfib(8)\n     24\n      */\n    public int fibfib(int n) {\n        if (n == 0 || n == 1) return 0;\n        if (n == 2) return 1;\n\n        int a = 0, b = 0, c = 1;\n        for (int i = 3; i <= n; i++) {\n            int temp = a + b + c;\n            a = b;\n            b = c;\n            c = temp;\n        }\n        return c;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.fibfib(1));  // Expected output: 0\n        System.out.println(solution.fibfib(5));  // Expected output: 4\n        System.out.println(solution.fibfib(8));  // Expected output: 24\n        System.out.println(solution.fibfib(10)); // Expected output: 76\n    }\n}\n"}
{"task_id": "Java/64", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Write a function vowels_count which takes a string representing\n     * a word as input and returns the number of vowels in the string.\n     * Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n     * vowel, but only when it is at the end of the given word.\n     *\n     * Example:\n     * >>> vowels_count(\"abcde\")\n     * 2\n     * >>> vowels_count(\"ACEDY\")\n     * 3\n     */\n    public int vowels_count(String s) {\n        int count = 0;\n        for (int i = 0; i < s.length(); i++) {\n            char c = Character.toLowerCase(s.charAt(i));\n            if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n                count++;\n            } else if (c == 'y' && i == s.length() - 1) {\n                count++;\n            }\n        }\n        return count;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.vowels_count(\"abcde\")); // Expected output: 2\n        System.out.println(solution.vowels_count(\"ACEDY\")); // Expected output: 3\n        System.out.println(solution.vowels_count(\"rhythm\")); // Expected output: 0\n        System.out.println(solution.vowels_count(\"encyclopedia\")); // Expected output: 6\n        System.out.println(solution.vowels_count(\"quickly\")); // Expected output: 1\n    }\n}\n"}
{"task_id": "Java/65", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public String circular_shift(int x, int shift) {\n        String strX = Integer.toString(x);\n        int n = strX.length();\n        \n        if (shift >= n) {\n            return new StringBuilder(strX).reverse().toString();\n        }\n        \n        shift %= n;  // To handle cases where shift is greater than the number of digits\n        \n        String shiftedStr = strX.substring(n - shift) + strX.substring(0, n - shift);\n        return shiftedStr;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.circular_shift(12, 1)); // Output: \"21\"\n        System.out.println(solution.circular_shift(12, 2)); // Output: \"12\"\n    }\n}\n"}
{"task_id": "Java/66", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Write a function that takes a string as input and returns the sum of the upper characters only ASCII codes.\n     *\n     * Examples:\n     * digitSum(\"\") => 0\n     * digitSum(\"abAB\") => 131\n     * digitSum(\"abcCd\") => 67\n     * digitSum(\"helloE\") => 69\n     * digitSum(\"woArBld\") => 131\n     * digitSum(\"aAaaaXa\") => 153\n     */\n    public int digitSum(String s) {\n        int sum = 0;\n        for (char c : s.toCharArray()) {\n            if (Character.isUpperCase(c)) {\n                sum += c;\n            }\n        }\n        return sum;\n    }\n\n    // Test cases to verify the correctness of the method\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.digitSum(\"\")); // Expected output: 0\n        System.out.println(solution.digitSum(\"abAB\")); // Expected output: 131 ('A' + 'B')\n        System.out.println(solution.digitSum(\"abcCd\")); // Expected output: 67 ('C' + 'D')\n        System.out.println(solution.digitSum(\"helloE\")); // Expected output: 69 ('E')\n        System.out.println(solution.digitSum(\"woArBld\")); // Expected output: 131 ('A' + 'B' + 'L' + 'D')\n        System.out.println(solution.digitSum(\"aAaaaXa\")); // Expected output: 153 ('A' * 4 + 'X')\n    }\n}\n"}
{"task_id": "Java/67", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * In this task, you will be given a string that represents a number of apples and oranges\n     * that are distributed in a basket of fruit. The basket contains apples, oranges, and mango fruits.\n     * Given the string that represents the total number of the oranges and apples and an integer that represent the total number of the fruits\n     * in the basket return the number of the mango fruits in the basket.\n     *\n     * @param s a string representing the number of apples and oranges (e.g., \"5 apples and 6 oranges\")\n     * @param n the total number of fruits in the basket\n     * @return the number of mango fruits in the basket\n     */\n    public int fruit_distribution(String s, int n) {\n        // Extract the numbers from the string\n        String[] parts = s.split(\" \");\n        int apples = Integer.parseInt(parts[0]);\n        int oranges = Integer.parseInt(parts[3]);\n\n        // Calculate the number of mangoes\n        return n - (apples + oranges);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.fruit_distribution(\"5 apples and 6 oranges\", 19)); // Expected output: 8\n        System.out.println(solution.fruit_distribution(\"0 apples and 1 oranges\", 3));   // Expected output: 2\n        System.out.println(solution.fruit_distribution(\"2 apples and 3 oranges\", 100)); // Expected output: 95\n        System.out.println(solution.fruit_distribution(\"100 apples and 1 oranges\", 120)); // Expected output: 19\n    }\n}\n"}
{"task_id": "Java/68", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given an array representing a branch of a tree that has non-negative integer nodes,\n     * your task is to pluck one of the nodes and return it.\n     * The plucked node should be the node with the smallest even value.\n     * If multiple nodes with the same smallest even value are found, return the node that has the smallest index.\n     *\n     * @param arr the list of integer values representing tree branch nodes\n     * @return a list containing the smallest even value and its index, or an empty list if no valid node is found\n     */\n    public List<Integer> pluck(List<Integer> arr) {\n        int minEvenValue = Integer.MAX_VALUE;\n        int minIndex = -1;\n\n        for (int i = 0; i < arr.size(); i++) {\n            int value = arr.get(i);\n            if (value % 2 == 0 && value <= minEvenValue) {\n                if (value < minEvenValue || (value == minEvenValue && i < minIndex)) {\n                    minEvenValue = value;\n                    minIndex = i;\n                }\n            }\n        }\n\n        if (minIndex == -1) {\n            return new ArrayList<>();\n        } else {\n            return Arrays.asList(minEvenValue, minIndex);\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.pluck(Arrays.asList(4, 2, 3))); // Output: [2, 1]\n        System.out.println(solution.pluck(Arrays.asList(1, 2, 3))); // Output: [2, 1]\n        System.out.println(solution.pluck(Arrays.asList()));       // Output: []\n        System.out.println(solution.pluck(Arrays.asList(5, 0, 3, 0, 4, 2))); // Output: [0, 1]\n    }\n}\n"}
{"task_id": "Java/69", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * You are given a non-empty list of positive integers. Return the greatest integer that is greater than\n     * zero, and has a frequency greater than or equal to the value of the integer itself.\n     * The frequency of an integer is the number of times it appears in the list.\n     * If no such a value exist, return -1.\n     *\n     * Examples:\n     * search(Arrays.asList(4, 1, 2, 2, 3, 1)) == 2\n     * search(Arrays.asList(1, 2, 2, 3, 3, 3, 4, 4, 4)) == 3\n     * search(Arrays.asList(5, 5, 4, 4, 4)) == -1\n     */\n    public int search(List<Integer> lst) {\n        Map<Integer, Integer> frequencyMap = new HashMap<>();\n        \n        // Count the frequency of each integer in the list\n        for (int num : lst) {\n            frequencyMap.put(num, frequencyMap.getOrDefault(num, 0) + 1);\n        }\n        \n        int result = -1;\n        \n        // Check which integers meet the criteria and find the greatest one\n        for (Map.Entry<Integer, Integer> entry : frequencyMap.entrySet()) {\n            if (entry.getKey() <= entry.getValue()) {\n                result = Math.max(result, entry.getKey());\n            }\n        }\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.search(Arrays.asList(4, 1, 2, 2, 3, 1))); // Expected output: 2\n        System.out.println(solution.search(Arrays.asList(1, 2, 2, 3, 3, 3, 4, 4, 4))); // Expected output: 3\n        System.out.println(solution.search(Arrays.asList(5, 5, 4, 4, 4))); // Expected output: -1\n        System.out.println(solution.search(Arrays.asList(6, 6, 6, 7, 7, 8, 8, 8, 8))); // Expected output: 8\n    }\n}\n"}
{"task_id": "Java/70", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given list of integers, return list in strange order.\n     * Strange sorting, is when you start with the minimum value,\n     * then maximum of the remaining integers, then minimum and so on.\n     *\n     * Examples:\n     * strange_sort_list(Arrays.asList(1, 2, 3, 4)) == Arrays.asList(1, 4, 2, 3)\n     * strange_sort_list(Arrays.asList(5, 5, 5, 5)) == Arrays.asList(5, 5, 5, 5)\n     * strange_sort_list(Arrays.asList()) == Arrays.asList()\n     */\n    public List<Integer> strange_sort_list(List<Integer> lst) {\n        List<Integer> result = new ArrayList<>();\n        while (!lst.isEmpty()) {\n            // Add the minimum value\n            int minVal = Collections.min(lst);\n            result.add(minVal);\n            lst.remove(Integer.valueOf(minVal));\n            \n            if (lst.isEmpty()) break;\n            \n            // Add the maximum value\n            int maxVal = Collections.max(lst);\n            result.add(maxVal);\n            lst.remove(Integer.valueOf(maxVal));\n        }\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.strange_sort_list(Arrays.asList(1, 2, 3, 4))); // Expected: [1, 4, 2, 3]\n        System.out.println(solution.strange_sort_list(Arrays.asList(5, 5, 5, 5))); // Expected: [5, 5, 5, 5]\n        System.out.println(solution.strange_sort_list(Arrays.asList()));           // Expected: []\n        System.out.println(solution.strange_sort_list(Arrays.asList(10, 20, 30, 40, 50))); // Expected: [10, 50, 20, 40, 30]\n    }\n}\n"}
{"task_id": "Java/71", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n\n    /**\n     * Given the lengths of the three sides of a triangle. Return the area of\n     * the triangle rounded to 2 decimal points if the three sides form a valid triangle.\n     * Otherwise return -1.\n     * Three sides make a valid triangle when the sum of any two sides is greater\n     * than the third side.\n     * Example:\n     * triangle_area(3, 4, 5) == 6.00\n     * triangle_area(1, 2, 10) == -1\n     */\n    public double triangle_area(double a, double b, double c) {\n        // Check if the sides form a valid triangle\n        if (a + b <= c || a + c <= b || b + c <= a) {\n            return -1;\n        }\n        \n        // Calculate the semi-perimeter\n        double s = (a + b + c) / 2.0;\n\n        // Calculate the area using Heron's formula\n        double area = Math.sqrt(s * (s - a) * (s - b) * (s - c));\n        \n        // Round to 2 decimal points\n        return Math.round(area * 100.0) / 100.0;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.triangle_area(3, 4, 5)); // Expected output: 6.00\n        System.out.println(solution.triangle_area(1, 2, 10)); // Expected output: -1\n        System.out.println(solution.triangle_area(7, 8, 9)); // Expected output: ~26.83\n        System.out.println(solution.triangle_area(5, 5, 5)); // Expected output: 10.83\n    }\n}\n"}
{"task_id": "Java/72", "generation": "import java.util.*;\n\nclass Solution {\n\n    /**\n     * Write a function that returns True if the object q will fly, and False otherwise.\n     * The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal to the maximum possible weight w.\n     *\n     * @param q A List<Integer> representing the object\n     * @param w An integer representing the maximum possible weight\n     * @return boolean indicating if the object will fly\n     */\n    public boolean will_it_fly(List<Integer> q, int w) {\n        // Check if the list is a palindrome\n        for (int i = 0; i < q.size() / 2; i++) {\n            if (!q.get(i).equals(q.get(q.size() - 1 - i))) {\n                return false;\n            }\n        }\n\n        // Calculate the sum of elements in the list\n        int sum = q.stream().mapToInt(Integer::intValue).sum();\n\n        // Check if the sum is less than or equal to w\n        return sum <= w;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.will_it_fly(Arrays.asList(1, 2), 5));   // false\n        System.out.println(solution.will_it_fly(Arrays.asList(3, 2, 3), 1)); // false\n        System.out.println(solution.will_it_fly(Arrays.asList(3, 2, 3), 9)); // true\n        System.out.println(solution.will_it_fly(Arrays.asList(3), 5));      // true\n    }\n}\n"}
{"task_id": "Java/73", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given an array arr of integers, find the minimum number of elements that\n     * need to be changed to make the array palindromic. A palindromic array is an array that\n     * is read the same backwards and forwards. In one change, you can change one element to any other element.\n     *\n     * For example:\n     * smallest_change(Arrays.asList(1,2,3,5,4,7,9,6)) == 4\n     * smallest_change(Arrays.asList(1, 2, 3, 4, 3, 2, 2)) == 1\n     * smallest_change(Arrays.asList(1, 2, 3, 2, 1)) == 0\n     */\n    public int smallest_change(List<Integer> arr) {\n        int left = 0;\n        int right = arr.size() - 1;\n        int changes = 0;\n\n        while (left < right) {\n            if (!arr.get(left).equals(arr.get(right))) {\n                changes++;\n            }\n            left++;\n            right--;\n        }\n\n        return changes;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.smallest_change(Arrays.asList(1, 2, 3, 5, 4, 7, 9, 6))); // Output: 4\n        System.out.println(solution.smallest_change(Arrays.asList(1, 2, 3, 4, 3, 2, 2)));    // Output: 1\n        System.out.println(solution.smallest_change(Arrays.asList(1, 2, 3, 2, 1)));          // Output: 0\n        System.out.println(solution.smallest_change(Arrays.asList(1, 2, 3, 4, 5, 6, 7)));    // Output: 3\n        System.out.println(solution.smallest_change(Arrays.asList(8, 9, 8, 9, 8, 9, 8)));   // Output: 0\n    }\n}\n"}
{"task_id": "Java/74", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Write a function that accepts two lists of strings and returns the list that has\n     * total number of chars in the all strings of the list less than the other list.\n     *\n     * if the two lists have the same number of chars, return the first list.\n     */\n    public List<String> total_match(List<String> lst1, List<String> lst2) {\n        int count1 = 0;\n        for (String s : lst1) {\n            count1 += s.length();\n        }\n        \n        int count2 = 0;\n        for (String s : lst2) {\n            count2 += s.length();\n        }\n\n        if (count1 <= count2) {\n            return lst1;\n        } else {\n            return lst2;\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.total_match(new ArrayList<>(), new ArrayList<>())); // []\n        System.out.println(solution.total_match(Arrays.asList(\"hi\", \"admin\"), Arrays.asList(\"hI\", \"Hi\"))); // [\"hI\", \"Hi\"]\n        System.out.println(solution.total_match(Arrays.asList(\"hi\", \"admin\"), Arrays.asList(\"hi\", \"hi\", \"admin\", \"project\"))); // [\"hi\", \"admin\"]\n        System.out.println(solution.total_match(Arrays.asList(\"hi\", \"admin\"), Arrays.asList(\"hI\", \"hi\", \"hi\"))); // [\"hI\", \"hi\", \"hi\"]\n        System.out.println(solution.total_match(Arrays.asList(\"4\"), Arrays.asList(\"1\", \"2\", \"3\", \"4\", \"5\"))); // [\"4\"]\n    }\n}\n"}
{"task_id": "Java/75", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Write a function that returns true if the given number is the multiplication of 3 prime numbers\n     * and false otherwise.\n     * Knowing that the prime number is less than 100.\n     * Example:\n     * is_multiply_prime(30) == true\n     * 30 = 2 * 3 * 5\n     */\n    public boolean is_multiply_prime(int a) {\n        if (a < 2) return false;\n\n        int count = 0;\n        for (int i = 2; i <= Math.sqrt(a); i++) {\n            while (a % i == 0 && isPrime(i)) {\n                count++;\n                a /= i;\n            }\n        }\n\n        // Check if the remaining number is also prime and part of the product\n        if (a > 1 && isPrime(a)) {\n            count++;\n        }\n\n        return count == 3;\n    }\n\n    private boolean isPrime(int n) {\n        if (n <= 1) return false;\n        for (int i = 2; i * i <= n; i++) {\n            if (n % i == 0) return false;\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.is_multiply_prime(30)); // true, because 30 = 2 * 3 * 5\n        System.out.println(solution.is_multiply_prime(60)); // false, because 60 = 2 * 2 * 3 * 5 (more than 3 primes)\n        System.out.println(solution.is_multiply_prime(100)); // false, because 100 is not a product of exactly 3 primes\n        System.out.println(solution.is_multiply_prime(30030)); // true, because 30030 = 2 * 3 * 5 * 7 * 11 * 13 (more than 3 primes)\n        System.out.println(solution.is_multiply_prime(2 * 3 * 7)); // true, because 42 = 2 * 3 * 7\n    }\n}\n"}
{"task_id": "Java/76", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Your task is to write a function that returns true if a number x is a simple\n     * power of n and false in other cases.\n     * x is a simple power of n if n**int=x\n     * For example:\n     * is_simple_power(1, 4) => true\n     * is_simple_power(2, 2) => true\n     * is_simple_power(8, 2) => true\n     * is_simple_power(3, 2) => false\n     * is_simple_power(3, 1) => false\n     * is_simple_power(5, 3) => false\n     */\n    public boolean is_simple_power(int x, int n) {\n        if (n == 1) {\n            return x == 1;\n        }\n        \n        double power = Math.pow(n, Math.round(Math.log(x) / Math.log(n)));\n        return Math.abs(power - x) < 0.0001; // Allowing a small floating point tolerance\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.is_simple_power(1, 4));   // true\n        System.out.println(solution.is_simple_power(2, 2));   // true\n        System.out.println(solution.is_simple_power(8, 2));   // true\n        System.out.println(solution.is_simple_power(3, 2));   // false\n        System.out.println(solution.is_simple_power(3, 1));   // false\n        System.out.println(solution.is_simple_power(5, 3));   // false\n        System.out.println(solution.is_simple_power(16, 2));  // true\n        System.out.println(solution.is_simple_power(81, 3));  // true\n        System.out.println(solution.is_simple_power(27, 3));  // true\n        System.out.println(solution.is_simple_power(49, 7));  // true\n    }\n}\n"}
{"task_id": "Java/77", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Write a function that takes an integer a and returns true\n     * if this integer is a cube of some integer number.\n     * Note: you may assume the input is always valid.\n     * Examples:\n     * iscube(1) ==> true\n     * iscube(2) ==> false\n     * iscube(-1) ==> true\n     * iscube(64) ==> true\n     * iscube(0) ==> true\n     * iscube(180) ==> false\n     */\n    public boolean iscube(int a) {\n        if (a == 0) return true;\n        \n        // Handle negative numbers by checking the cube root and squaring it back\n        double cubeRoot = Math.cbrt(a);\n        int roundedCubeRoot = (int) Math.round(cubeRoot);\n        \n        return Math.pow(roundedCubeRoot, 3) == a;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.iscube(1));   // true\n        System.out.println(solution.iscube(2));   // false\n        System.out.println(solution.iscube(-1));  // true\n        System.out.println(solution.iscube(64));  // true\n        System.out.println(solution.iscube(0));   // true\n        System.out.println(solution.iscube(180)); // false\n    }\n}\n"}
{"task_id": "Java/78", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * You have been tasked to write a function that receives\n     * a hexadecimal number as a string and counts the number of hexadecimal\n     * digits that are primes (prime number, or a prime, is a natural number\n     * greater than 1 that is not a product of two smaller natural numbers).\n     * Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n     * Prime numbers are 2, 3, 5, 7, B (=decimal 11), D (=decimal 13).\n     * So you have to determine a number of the following digits: 2, 3, 5, 7,\n     * B (=decimal 11), D (=decimal 13).\n     * Note: you may assume the input is always correct or empty string,\n     * and symbols A,B,C,D,E,F are always uppercase.\n     * Examples:\n     * For num = \"AB\" the output should be 1.\n     * For num = \"1077E\" the output should be 2.\n     * For num = \"ABED1A33\" the output should be 4.\n     * For num = \"123456789ABCDEF0\" the output should be 6.\n     * For num = \"2020\" the output should be 2.\n     */\n    public int hex_key(String num) {\n        // Define a set of prime hexadecimal digits\n        Set<Character> primes = new HashSet<>(Arrays.asList('2', '3', '5', '7', 'B', 'D'));\n        \n        // Count the number of prime hexadecimal digits in the input string\n        int count = 0;\n        for (char c : num.toCharArray()) {\n            if (primes.contains(c)) {\n                count++;\n            }\n        }\n        \n        return count;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.hex_key(\"AB\")); // Expected output: 1\n        System.out.println(solution.hex_key(\"1077E\")); // Expected output: 2\n        System.out.println(solution.hex_key(\"ABED1A33\")); // Expected output: 4\n        System.out.println(solution.hex_key(\"123456789ABCDEF0\")); // Expected output: 6\n        System.out.println(solution.hex_key(\"2020\")); // Expected output: 2\n    }\n}\n"}
{"task_id": "Java/79", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * You will be given a number in decimal form and your task is to convert it to\n     * binary format. The function should return a string, with each character representing a binary\n     * number. Each character in the string will be '0' or '1'.\n     *\n     * There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n     * The extra characters are there to help with the format.\n     *\n     * Examples:\n     * decimal_to_binary(15)   // returns \"db1111db\"\n     * decimal_to_binary(32)   // returns \"db100000db\"\n     */\n    public String decimal_to_binary(int decimal) {\n        if (decimal == 0) return \"db0db\";\n        \n        StringBuilder binary = new StringBuilder();\n        while (decimal > 0) {\n            binary.insert(0, decimal % 2);\n            decimal /= 2;\n        }\n        \n        return \"db\" + binary.toString() + \"db\";\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.decimal_to_binary(15));   // Expected: db1111db\n        System.out.println(solution.decimal_to_binary(32));   // Expected: db100000db\n        System.out.println(solution.decimal_to_binary(0));    // Expected: db0db\n        System.out.println(solution.decimal_to_binary(456));  // Expected: db111001000db\n        System.out.println(solution.decimal_to_binary(255));  // Expected: db11111111db\n    }\n}\n"}
{"task_id": "Java/80", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * You are given a string s.\n     * Your task is to check if the string is happy or not.\n     * A string is happy if its length is at least 3 and every 3 consecutive letters are distinct\n     * For example:\n     * is_happy(a) => false\n     * is_happy(aa) => false\n     * is_happy(abcd) => true\n     * is_happy(aabb) => false\n     * is_happy(adb) => true\n     * is_happy(xyy) => false\n     */\n    public boolean is_happy(String s) {\n        if (s.length() < 3) return false;\n        \n        for (int i = 0; i <= s.length() - 3; i++) {\n            char first = s.charAt(i);\n            char second = s.charAt(i + 1);\n            char third = s.charAt(i + 2);\n            \n            if (first == second || second == third || first == third) {\n                return false;\n            }\n        }\n        \n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.is_happy(\"a\"));       // Output: false\n        System.out.println(solution.is_happy(\"aa\"));      // Output: false\n        System.out.println(solution.is_happy(\"abcd\"));    // Output: true\n        System.out.println(solution.is_happy(\"aabb\"));    // Output: false\n        System.out.println(solution.is_happy(\"adb\"));     // Output: true\n        System.out.println(solution.is_happy(\"xyy\"));     // Output: false\n        System.out.println(solution.is_happy(\"abcabc\"));  // Output: true\n        System.out.println(solution.is_happy(\"abacaba\")); // Output: false\n    }\n}\n"}
{"task_id": "Java/81", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * It is the last week of the semester and the teacher has to give the grades\n     * to students. The teacher has been making her own algorithm for grading.\n     * The only problem is, she has lost the code she used for grading.\n     * She has given you a list of GPAs for some students and you have to write\n     * a function that can output a list of letter grades using the following table:\n     *             GPA       |    Letter grade\n     *              4.0                A+\n     *            > 3.7                A\n     *            > 3.3                A-\n     *            > 3.0                B+\n     *            > 2.7                B\n     *            > 2.3                B-\n     *            > 2.0                C+\n     *            > 1.7                C\n     *            > 1.3                C-\n     *            > 1.0                D+\n     *            > 0.7                D\n     *            > 0.0                D-\n     *              0.0                E\n\n     * Example:\n     * numerical_letter_grade(Arrays.asList(4.0, 3, 1.7, 2, 3.5)) ==> [\"A+\", \"B\", \"C-\", \"C\", \"A-\"]\n     */\n    public List<String> numerical_letter_grade(List<Double> grades) {\n        List<String> letterGrades = new ArrayList<>();\n        \n        for (double gpa : grades) {\n            if (gpa == 4.0) {\n                letterGrades.add(\"A+\");\n            } else if (gpa > 3.7) {\n                letterGrades.add(\"A\");\n            } else if (gpa > 3.3) {\n                letterGrades.add(\"A-\");\n            } else if (gpa > 3.0) {\n                letterGrades.add(\"B+\");\n            } else if (gpa > 2.7) {\n                letterGrades.add(\"B\");\n            } else if (gpa > 2.3) {\n                letterGrades.add(\"B-\");\n            } else if (gpa > 2.0) {\n                letterGrades.add(\"C+\");\n            } else if (gpa > 1.7) {\n                letterGrades.add(\"C\");\n            } else if (gpa > 1.3) {\n                letterGrades.add(\"C-\");\n            } else if (gpa > 1.0) {\n                letterGrades.add(\"D+\");\n            } else if (gpa > 0.7) {\n                letterGrades.add(\"D\");\n            } else if (gpa > 0.0) {\n                letterGrades.add(\"D-\");\n            } else {\n                letterGrades.add(\"E\");\n            }\n        }\n\n        return letterGrades;\n    }\n}\n"}
{"task_id": "Java/82", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Write a function that takes a string and returns true if the string\n     * length is a prime number or false otherwise\n     * Examples:\n     * prime_length(\"Hello\") == true\n     * prime_length(\"abcdcba\") == true\n     * prime_length(\"kittens\") == true\n     * prime_length(\"orange\") == false\n     */\n    public boolean prime_length(String string) {\n        int length = string.length();\n        return isPrime(length);\n    }\n\n    private boolean isPrime(int number) {\n        if (number <= 1) {\n            return false;\n        }\n        for (int i = 2; i * i <= number; i++) {\n            if (number % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.prime_length(\"Hello\"));   // true\n        System.out.println(solution.prime_length(\"abcdcba\")); // true\n        System.out.println(solution.prime_length(\"kittens\")); // true\n        System.out.println(solution.prime_length(\"orange\"));  // false\n    }\n}\n"}
{"task_id": "Java/83", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a positive integer n, return the count of the numbers of n-digit\n     * positive integers that start or end with 1.\n     */\n    public int starts_one_ends(int n) {\n        if (n == 1) {\n            return 1; // Only one 1-digit number that starts and ends with 1\n        }\n        \n        // For n > 1, calculate the count of numbers starting or ending with 1\n        long total_count = (long) Math.pow(10, n - 1) * 2 - (long) Math.pow(10, n - 2);\n        \n        return (int) total_count;\n    }\n}\n"}
{"task_id": "Java/84", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     Given a positive integer N, return in binary the total sum of its digits.\n\n     Example\n         For N = 1000, the sum of digits will be 1 the output should be \"1\".\n         For N = 150, the sum of digits will be 6 the output should be \"110\".\n         For N = 147, the sum of digits will be 12 the output should be \"1100\".\n\n     Variables:\n         @N integer\n              Constraints: 0 <= N <= 10000.\n     Output:\n          a string of binary number\n      */\n    public String solve(int N) {\n        int sum = 0;\n        \n        // Calculate the sum of digits\n        while (N > 0) {\n            sum += N % 10;\n            N /= 10;\n        }\n        \n        // Convert the sum to binary and return as a string\n        return Integer.toBinaryString(sum);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.solve(1000)); // Expected output: \"1\"\n        System.out.println(solution.solve(150));  // Expected output: \"110\"\n        System.out.println(solution.solve(147));  // Expected output: \"1100\"\n        System.out.println(solution.solve(9999)); // Expected output: \"11110001111\"\n    }\n}\n"}
{"task_id": "Java/85", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a non-empty list of integers lst. add the even elements that are at odd indices.\n     *\n     * Examples:\n     * - add(Arrays.asList(4, 2, 6, 7)) should return 2 (since only 2 is an even number at an odd index)\n     */\n    public int add(List<Integer> lst) {\n        if (lst == null || lst.isEmpty()) {\n            throw new IllegalArgumentException(\"List cannot be null or empty\");\n        }\n\n        int sum = 0;\n        for (int i = 1; i < lst.size(); i += 2) { // Start from index 1 and increment by 2\n            Integer value = lst.get(i);\n            if (value % 2 == 0) {\n                sum += value;\n            }\n        }\n\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.add(Arrays.asList(4, 2, 6, 7))); // Should print 2\n        System.out.println(solution.add(Arrays.asList(1, 3, 5, 7, 9))); // Should print 0 (no even numbers at odd indices)\n        System.out.println(solution.add(Arrays.asList(8, 4, 2, 6, 10, 12))); // Should print 16 (4 + 12)\n    }\n}\n"}
{"task_id": "Java/86", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Write a function that takes a string and returns an ordered version of it.\n     * Ordered version of string, is a string where all words (separated by space)\n     * are replaced by a new word where all the characters arranged in\n     * ascending order based on ascii value.\n     * Note: You should keep the order of words and blank spaces in the sentence.\n     *\n     * For example:\n     * anti_shuffle(\"Hi\") returns \"Hi\"\n     * anti_shuffle(\"hello\") returns \"ehllo\"\n     * anti_shuffle(\"Hello World!!!\") returns \"Hello !!!Wdlor\"\n     */\n    public String anti_shuffle(String s) {\n        if (s == null || s.isEmpty()) {\n            return s;\n        }\n\n        StringBuilder result = new StringBuilder();\n        int wordStartIndex = 0;\n\n        for (int i = 0; i < s.length(); i++) {\n            char c = s.charAt(i);\n            if (c == ' ') {\n                // Process the current word\n                String word = s.substring(wordStartIndex, i);\n                result.append(orderedWord(word));\n                result.append(c); // Append the space character\n                wordStartIndex = i + 1;\n            }\n        }\n\n        // Process the last word in the string\n        if (wordStartIndex < s.length()) {\n            String lastWord = s.substring(wordStartIndex);\n            result.append(orderedWord(lastWord));\n        }\n\n        return result.toString();\n    }\n\n    private String orderedWord(String word) {\n        char[] chars = word.toCharArray();\n        Arrays.sort(chars);\n        return new String(chars);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.anti_shuffle(\"Hi\")); // Expected: \"Hi\"\n        System.out.println(solution.anti_shuffle(\"hello\")); // Expected: \"ehllo\"\n        System.out.println(solution.anti_shuffle(\"Hello World!!!\")); // Expected: \"Hello !!!Wdlor\"\n        System.out.println(solution.anti_shuffle(\"Programming is fun!\")); // Expected: \"Pamgimnig is fnu!\"\n    }\n}\n"}
{"task_id": "Java/87", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<List<Integer>> get_row(List<List<Integer>> lst, int x) {\n        List<List<Integer>> coordinates = new ArrayList<>();\n        \n        // Iterate through the nested list to find all occurrences of 'x'\n        for (int row_idx = 0; row_idx < lst.size(); row_idx++) {\n            List<Integer> row = lst.get(row_idx);\n            for (int col_idx = 0; col_idx < row.size(); col_idx++) {\n                if (row.get(col_idx).equals(x)) {\n                    coordinates.add(Arrays.asList(row_idx, col_idx));\n                }\n            }\n        }\n\n        // Sort by rows in ascending order and then by columns in descending order within the same row\n        Collections.sort(coordinates, new Comparator<List<Integer>>() {\n            @Override\n            public int compare(List<Integer> o1, List<Integer> o2) {\n                if (o1.get(0).equals(o2.get(0))) { // Same row\n                    return Integer.compare(o2.get(1), o1.get(1)); // Descending order for columns\n                }\n                return Integer.compare(o1.get(0), o2.get(0)); // Ascending order for rows\n            }\n        });\n\n        return coordinates;\n    }\n}\n"}
{"task_id": "Java/88", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n\n    /**\n     * Given an array of non-negative integers, return a copy of the given array after sorting,\n     * you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n     * or sort it in descending order if the sum( first index value, last index value) is even.\n     *\n     * Note:\n     * * don't change the given array.\n     */\n    public List<Integer> sort_array(List<Integer> array) {\n        if (array == null || array.isEmpty()) {\n            return new ArrayList<>();\n        }\n\n        int sum = array.get(0) + array.get(array.size() - 1);\n        List<Integer> sortedArray = new ArrayList<>(array);\n\n        if (sum % 2 == 0) {\n            // Sort in descending order\n            sortedArray.sort(Collections.reverseOrder());\n        } else {\n            // Sort in ascending order\n            Collections.sort(sortedArray);\n        }\n\n        return sortedArray;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.sort_array(Arrays.asList())); // []\n        System.out.println(solution.sort_array(Arrays.asList(5))); // [5]\n        System.out.println(solution.sort_array(Arrays.asList(2, 4, 3, 0, 1, 5))); // [0, 1, 2, 3, 4, 5]\n        System.out.println(solution.sort_array(Arrays.asList(2, 4, 3, 0, 1, 5, 6))); // [6, 5, 4, 3, 2, 1, 0]\n    }\n}\n"}
{"task_id": "Java/89", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Create a function encrypt that takes a string as an argument and\n     * returns a string encrypted with the alphabet being rotated.\n     * The alphabet should be rotated in a manner such that the letters\n     * shift down by two multiplied to two places.\n     * For example:\n     * encrypt(\"hi\") returns \"lm\"\n     * encrypt(\"asdfghjkl\") returns \"ewhjklnop\"\n     * encrypt(\"gf\") returns \"kj\"\n     * encrypt(\"et\") returns \"ix\"\n     */\n    public String encrypt(String s) {\n        StringBuilder encrypted = new StringBuilder();\n        for (char c : s.toCharArray()) {\n            if (Character.isLetter(c)) {\n                char base = Character.isUpperCase(c) ? 'A' : 'a';\n                int offset = ((c - base + 4) % 26);\n                encrypted.append((char) (base + offset));\n            } else {\n                encrypted.append(c);\n            }\n        }\n        return encrypted.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.encrypt(\"hi\"));       // Should print \"lm\"\n        System.out.println(solution.encrypt(\"asdfghjkl\")); // Should print \"ewhjklnop\"\n        System.out.println(solution.encrypt(\"gf\"));       // Should print \"kj\"\n        System.out.println(solution.encrypt(\"et\"));       // Should print \"ix\"\n\n        // Additional test cases\n        System.out.println(solution.encrypt(\"Hello, World!\")); // Should print \"Lipps, Asvph!\"\n        System.out.println(solution.encrypt(\"Zebra123\"));     // Should print \"Difve123\"\n    }\n}\n"}
{"task_id": "Java/90", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * You are given a list of integers.\n     * Write a function next_smallest() that returns the 2nd smallest element of the list.\n     * Return null if there is no such element.\n     *\n     * @param lst The input list of integers\n     * @return Optional containing the 2nd smallest integer, or Optional.empty() if not available\n     */\n    public Optional<Integer> next_smallest(List<Integer> lst) {\n        // Remove duplicates and sort the list\n        Set<Integer> uniqueElements = new TreeSet<>(lst);\n        \n        // If there are less than 2 elements after removing duplicates, return Optional.empty()\n        if (uniqueElements.size() < 2) {\n            return Optional.empty();\n        }\n        \n        // Return the second element in the sorted set\n        Integer[] array = uniqueElements.toArray(new Integer[0]);\n        return Optional.of(array[1]);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.next_smallest(Arrays.asList(1, 2, 3, 4, 5))); // Expected: Optional[2]\n        System.out.println(solution.next_smallest(Arrays.asList(5, 1, 4, 3, 2))); // Expected: Optional[2]\n        System.out.println(solution.next_smallest(Arrays.asList()));             // Expected: Optional.empty\n        System.out.println(solution.next_smallest(Arrays.asList(1, 1)));         // Expected: Optional.empty\n        System.out.println(solution.next_smallest(Arrays.asList(5, 4, 3, 2, 1))); // Expected: Optional[2]\n    }\n}\n"}
{"task_id": "Java/91", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int is_bored(String S) {\n        // Split the input string into sentences based on '.', '?', or '!'\n        String[] sentences = S.split(\"[.?!]\");\n        \n        int count = 0;\n        for (String sentence : sentences) {\n            // Trim leading and trailing whitespace\n            String trimmedSentence = sentence.trim();\n            \n            // Check if the sentence starts with \"I\"\n            if (!trimmedSentence.isEmpty() && trimmedSentence.startsWith(\"I\")) {\n                count++;\n            }\n        }\n        \n        return count;\n    }\n}\n"}
{"task_id": "Java/92", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Create a function that takes 3 numbers.\n     * Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n     * Returns false in any other cases.\n     *\n     * Examples\n     * any_int(5, 2, 7) -> true\n     * any_int(3, 2, 2) -> false\n     * any_int(3, -2, 1) -> true\n     * any_int(3.6, -2.2, 2) -> false\n     */\n    public boolean any_int(Object x, Object y, Object z) {\n        if (x instanceof Integer && y instanceof Integer && z instanceof Integer) {\n            int a = (Integer) x;\n            int b = (Integer) y;\n            int c = (Integer) z;\n\n            return a == b + c || b == a + c || c == a + b;\n        }\n        return false;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.any_int(5, 2, 7));   // true\n        System.out.println(solution.any_int(3, 2, 2));   // false\n        System.out.println(solution.any_int(3, -2, 1));  // true\n        System.out.println(solution.any_int(3.6, -2.2, 2)); // false (should return false)\n    }\n}\n"}
{"task_id": "Java/93", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Write a function that takes a message, and encodes in such a way that it swaps case of all letters,\n     * replaces all vowels in the message with the letter that appears 2 places ahead of that vowel in the\n     * English alphabet.\n     *\n     * Examples:\n     * >>> encode(\"test\")\n     * \"TGST\"\n     * >>> encode(\"This is a message\")\n     * \"tHKS KS C MGSSCGG\"\n     */\n    public String encode(String message) {\n        StringBuilder encodedMessage = new StringBuilder();\n        \n        for (char c : message.toCharArray()) {\n            if (Character.isLetter(c)) {\n                // Swap case\n                char swappedCaseChar = Character.isLowerCase(c) ? Character.toUpperCase(c) : Character.toLowerCase(c);\n                \n                // Replace vowels with the letter 2 places ahead in the alphabet\n                switch (swappedCaseChar) {\n                    case 'A':\n                        encodedMessage.append('C');\n                        break;\n                    case 'E':\n                        encodedMessage.append('G');\n                        break;\n                    case 'I':\n                        encodedMessage.append('K');\n                        break;\n                    case 'O':\n                        encodedMessage.append('Q');\n                        break;\n                    case 'U':\n                        encodedMessage.append('W');\n                        break;\n                    case 'a':\n                        encodedMessage.append('c');\n                        break;\n                    case 'e':\n                        encodedMessage.append('g');\n                        break;\n                    case 'i':\n                        encodedMessage.append('k');\n                        break;\n                    case 'o':\n                        encodedMessage.append('q');\n                        break;\n                    case 'u':\n                        encodedMessage.append('w');\n                        break;\n                    default:\n                        // If it's not a vowel, just append the swapped case character\n                        encodedMessage.append(swappedCaseChar);\n                }\n            } else {\n                // Non-letter characters are appended as is\n                encodedMessage.append(c);\n            }\n        }\n        \n        return encodedMessage.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.encode(\"test\"));  // Expected: \"TGST\"\n        System.out.println(solution.encode(\"This is a message\"));  // Expected: \"tHKS KS C MGSSCGG\"\n        System.out.println(solution.encode(\"Hello World!\"));  // Expected: \"hKLLQ wOrld!\"\n    }\n}\n"}
{"task_id": "Java/94", "generation": "import java.util.List;\n\nclass Solution {\n    /**\n     * You are given a list of integers.\n     * You need to find the largest prime value and return the sum of its digits.\n     */\n    public int skjkasdkd(List<Integer> lst) {\n        if (lst == null || lst.isEmpty()) {\n            return 0;\n        }\n\n        int maxPrime = -1;\n\n        for (int num : lst) {\n            if (isPrime(num)) {\n                maxPrime = Math.max(maxPrime, num);\n            }\n        }\n\n        if (maxPrime == -1) {\n            return 0;\n        }\n\n        return sumOfDigits(maxPrime);\n    }\n\n    private boolean isPrime(int num) {\n        if (num <= 1) {\n            return false;\n        }\n        for (int i = 2; i <= Math.sqrt(num); i++) {\n            if (num % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private int sumOfDigits(int num) {\n        int sum = 0;\n        while (num > 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        List<Integer> lst1 = Arrays.asList(0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3);\n        System.out.println(solution.skjkasdkd(lst1)); // Output: 10\n\n        List<Integer> lst2 = Arrays.asList(1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1);\n        System.out.println(solution.skjkasdkd(lst2)); // Output: 25\n\n        List<Integer> lst3 = Arrays.asList(1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3);\n        System.out.println(solution.skjkasdkd(lst3)); // Output: 13\n\n        List<Integer> lst4 = Arrays.asList(0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6);\n        System.out.println(solution.skjkasdkd(lst4)); // Output: 11\n\n        List<Integer> lst5 = Arrays.asList(0, 81, 12, 3, 1, 21);\n        System.out.println(solution.skjkasdkd(lst5)); // Output: 3\n\n        List<Integer> lst6 = Arrays.asList(0, 8, 1, 2, 1, 7);\n        System.out.println(solution.skjkasdkd(lst6)); // Output: 7\n    }\n}\n"}
{"task_id": "Java/95", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given a map, return True if all keys are strings and all keys are in lower case or in upper case, else return False.\n     * The function should return False is the given map is empty.\n     */\n    public boolean check_dict_case(Map<Object, Object> dict) {\n        if (dict.isEmpty()) {\n            return false;\n        }\n\n        boolean allLowerCase = true;\n        boolean allUpperCase = true;\n\n        for (Object key : dict.keySet()) {\n            if (!(key instanceof String)) {\n                return false;\n            }\n            String strKey = (String) key;\n            if (!strKey.equals(strKey.toLowerCase())) {\n                allLowerCase = false;\n            }\n            if (!strKey.equals(strKey.toUpperCase())) {\n                allUpperCase = false;\n            }\n        }\n\n        return allLowerCase || allUpperCase;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.check_dict_case(Map.of(\"a\", \"apple\", \"b\", \"banana\"))); // True\n        System.out.println(solution.check_dict_case(Map.of(\"a\", \"apple\", \"A\", \"banana\", \"B\", \"banana\"))); // False\n        System.out.println(solution.check_dict_case(Map.of(\"a\", \"apple\", 8, \"banana\", \"a\", \"apple\"))); // False\n        System.out.println(solution.check_dict_case(Map.of(\"Name\", \"John\", \"Age\", \"36\", \"City\", \"Houston\"))); // False\n        System.out.println(solution.check_dict_case(Map.of(\"STATE\", \"NC\", \"ZIP\", \"12345\"))); // True\n    }\n}\n"}
{"task_id": "Java/96", "generation": "import java.util.ArrayList;\nimport java.util.List;\n\nclass Solution {\n\n    /**\n     * Implement a function that takes an non-negative integer and returns an array of the first n\n     * integers that are prime numbers and less than n.\n     *\n     * @param n The upper limit (non-inclusive) to find prime numbers up to.\n     * @return A List containing prime numbers less than n.\n     */\n    public List<Integer> count_up_to(int n) {\n        List<Integer> primes = new ArrayList<>();\n        \n        for (int i = 2; i < n && primes.size() < n; i++) {\n            if (isPrime(i)) {\n                primes.add(i);\n            }\n        }\n        \n        return primes;\n    }\n\n    /**\n     * Helper method to check if a number is prime.\n     *\n     * @param num The number to check.\n     * @return true if the number is prime, false otherwise.\n     */\n    private boolean isPrime(int num) {\n        if (num <= 1) {\n            return false;\n        }\n        for (int i = 2; i <= Math.sqrt(num); i++) {\n            if (num % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.count_up_to(5));   // Output: [2, 3]\n        System.out.println(solution.count_up_to(11));  // Output: [2, 3, 5, 7]\n        System.out.println(solution.count_up_to(0));   // Output: []\n        System.out.println(solution.count_up_to(20));  // Output: [2, 3, 5, 7, 11, 13, 17, 19]\n        System.out.println(solution.count_up_to(1));   // Output: []\n        System.out.println(solution.count_up_to(18));  // Output: [2, 3, 5, 7, 11, 13, 17]\n    }\n}\n"}
{"task_id": "Java/97", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Complete the function that takes two integers and returns\n     * the product of their unit digits.\n     * Assume the input is always valid.\n     * Examples:\n     * multiply(148, 412) should return 16.\n     * multiply(19, 28) should return 72.\n     * multiply(2020, 1851) should return 0.\n     * multiply(14,-15) should return 20.\n     */\n    public int multiply(int a, int b) {\n        // Extract the unit digits of both numbers\n        int unitDigitA = Math.abs(a % 10);\n        int unitDigitB = Math.abs(b % 10);\n\n        // Return the product of the unit digits\n        return unitDigitA * unitDigitB;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.multiply(148, 412)); // Expected output: 16\n        System.out.println(solution.multiply(19, 28));   // Expected output: 72\n        System.out.println(solution.multiply(2020, 1851)); // Expected output: 0\n        System.out.println(solution.multiply(14, -15));  // Expected output: 20\n    }\n}\n"}
{"task_id": "Java/98", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a string s, count the number of uppercase vowels in even indices.\n     *\n     * For example:\n     * count_upper(\"aBCdEf\") returns 1\n     * count_upper(\"abcdefg\") returns 0\n     * count_upper(\"dBBE\") returns 0\n     */\n    public int count_upper(String s) {\n        int count = 0;\n        for (int i = 0; i < s.length(); i += 2) { // Iterate over even indices\n            char c = s.charAt(i);\n            if (isUppercaseVowel(c)) {\n                count++;\n            }\n        }\n        return count;\n    }\n\n    private boolean isUppercaseVowel(char c) {\n        return c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U';\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.count_upper(\"aBCdEf\")); // Expected output: 1\n        System.out.println(solution.count_upper(\"abcdefg\")); // Expected output: 0\n        System.out.println(solution.count_upper(\"dBBE\")); // Expected output: 0\n        System.out.println(solution.count_upper(\"AeIoUc\")); // Expected output: 3\n        System.out.println(solution.count_upper(\"zYxWvUt\")); // Expected output: 2\n    }\n}\n"}
{"task_id": "Java/99", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Create a function that takes a value (string) representing a number\n     * and returns the closest integer to it. If the number is equidistant\n     * from two integers, round it away from zero.\n     *\n     * Examples:\n     * >>> closest_integer(\"10\")\n     * 10\n     * >>> closest_integer(\"15.3\")\n     * 15\n     * >>> closest_integer(\"14.5\")\n     * 15\n     * >>> closest_integer(\"-14.5\")\n     * -15\n     */\n    public int closest_integer(String value) {\n        double num = Double.parseDouble(value);\n        double floorValue = Math.floor(num);\n        double ceilValue = Math.ceil(num);\n\n        if (num - floorValue == 0.5 || ceilValue - num == 0.5) {\n            return (int)(num > 0 ? ceilValue : floorValue);\n        } else {\n            return (int)Math.round(num);\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.closest_integer(\"10\"));   // Output: 10\n        System.out.println(solution.closest_integer(\"15.3\")); // Output: 15\n        System.out.println(solution.closest_integer(\"14.5\")); // Output: 15\n        System.out.println(solution.closest_integer(\"-14.5\"));// Output: -15\n        System.out.println(solution.closest_integer(\"0.5\"));  // Output: 1\n        System.out.println(solution.closest_integer(\"-0.5\")); // Output: -1\n    }\n}\n"}
{"task_id": "Java/100", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given a positive integer n, you have to make a pile of n levels of stones.\n     * The first level has n stones.\n     * The number of stones in the next level is:\n     * - the next odd number if n is odd.\n     * - the next even number if n is even.\n     * Return the number of stones in each level in a list, where element at index\n     * i represents the number of stones in the level (i+1).\n     *\n     * Examples:\n     * >>> make_a_pile(3)\n     * [3, 5, 7]\n     */\n    public List<Integer> make_a_pile(int n) {\n        List<Integer> result = new ArrayList<>();\n        int currentStones = n;\n        \n        for (int i = 0; i < n; i++) {\n            result.add(currentStones);\n            // Determine the next number of stones\n            if (currentStones % 2 == 0) {\n                currentStones += 2; // Next even number\n            } else {\n                currentStones += 2; // Next odd number\n            }\n        }\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.make_a_pile(3)); // Expected: [3, 5, 7]\n        System.out.println(solution.make_a_pile(4)); // Expected: [4, 6, 8, 10]\n        System.out.println(solution.make_a_pile(1)); // Expected: [1, 3]\n    }\n}\n"}
{"task_id": "Java/101", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    You will be given a string of words separated by commas or spaces. Your task is\n    to split the string into words and return an array of the words.\n    \n    For example:\n    words_string(\"Hi, my name is John\").equals(Arrays.asList(\"Hi\", \"my\", \"name\", \"is\", \"John\"])\n    words_string(\"One, two, three, four, five, six\").equals(Arrays.asList(\"One\", \"two\", \"three\", \"four\", \"five\", \"six])\n     */\n    public List<String> words_string(String s) {\n        // Use regular expression to split the string by commas and spaces\n        String[] wordsArray = s.split(\"[,\\s]+\");\n        \n        // Create a list from the array of words\n        List<String> wordsList = new ArrayList<>();\n        for (String word : wordsArray) {\n            if (!word.isEmpty()) {  // Filter out any empty strings\n                wordsList.add(word);\n            }\n        }\n        \n        return wordsList;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.words_string(\"Hi, my name is John\"));  // Expected: [Hi, my, name, is, John]\n        System.out.println(solution.words_string(\"One, two, three, four, five, six\"));  // Expected: [One, two, three, four, five, six]\n    }\n}\n"}
{"task_id": "Java/102", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * This function takes two positive numbers x and y and returns the\n     * biggest even integer number that is in the range [x, y] inclusive. If\n     * there's no such number, then the function should return -1.\n     *\n     * For example:\n     * choose_num(12, 15) = 14\n     * choose_num(13, 12) = -1\n     */\n    public int choose_num(int x, int y) {\n        // If the range is invalid or there's no even number in the range\n        if (x > y || (x % 2 != 0 && y % 2 != 0)) {\n            return -1;\n        }\n\n        // Find the biggest even number in the range [x, y]\n        for (int i = y; i >= x; i--) {\n            if (i % 2 == 0) {\n                return i;\n            }\n        }\n\n        // If no even number is found\n        return -1;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.choose_num(12, 15)); // Expected output: 14\n        System.out.println(solution.choose_num(13, 12)); // Expected output: -1\n        System.out.println(solution.choose_num(10, 20)); // Expected output: 20\n        System.out.println(solution.choose_num(17, 19)); // Expected output: -1\n        System.out.println(solution.choose_num(8, 8));   // Expected output: 8\n    }\n}\n"}
{"task_id": "Java/103", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * You are given two positive integers n and m, and your task is to compute the\n     * average of the integers from n through m (including n and m).\n     * Round the answer to the nearest integer and convert that to binary.\n     * If n is greater than m, return -1.\n     * Example:\n     * rounded_avg(1, 5) => \"11\"\n     * rounded_avg(7, 5) => -1\n     * rounded_avg(10, 20) => \"1111\"\n     * rounded_avg(20, 33) => \"11011\"\n     */\n    public Object rounded_avg(int n, int m) {\n        if (n > m) {\n            return -1;\n        }\n        \n        long sum = 0;\n        for (int i = n; i <= m; i++) {\n            sum += i;\n        }\n        \n        double average = Math.round((double) sum / (m - n + 1));\n        String binary = Long.toBinaryString((long) average);\n        \n        return binary;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.rounded_avg(1, 5));   // Expected output: \"11\"\n        System.out.println(solution.rounded_avg(7, 5));   // Expected output: -1\n        System.out.println(solution.rounded_avg(10, 20)); // Expected output: \"1111\"\n        System.out.println(solution.rounded_avg(20, 33)); // Expected output: \"11011\"\n    }\n}\n"}
{"task_id": "Java/104", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> unique_digits(List<Integer> x) {\n        List<Integer> result = new ArrayList<>();\n        \n        for (int num : x) {\n            if (!hasEvenDigit(num)) {\n                result.add(num);\n            }\n        }\n        \n        Collections.sort(result);\n        return result;\n    }\n\n    private boolean hasEvenDigit(int n) {\n        while (n > 0) {\n            int digit = n % 10;\n            if (digit % 2 == 0) {\n                return true;\n            }\n            n /= 10;\n        }\n        return false;\n    }\n}\n"}
{"task_id": "Java/105", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given an array of integers, sort the integers that are between 1 and 9 inclusive,\n     * reverse the resulting array, and then replace each digit by its corresponding name from\n     * \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n     *\n     * @param arr input list of integers\n     * @return a list of strings representing the names of the digits in reverse sorted order\n     */\n    public List<String> by_length(List<Integer> arr) {\n        // Filter out numbers not between 1 and 9 inclusive\n        List<Integer> filtered = arr.stream()\n                                     .filter(num -> num >= 1 && num <= 9)\n                                     .sorted()\n                                     .collect(Collectors.toList());\n        \n        // Reverse the list\n        Collections.reverse(filtered);\n        \n        // Map each digit to its corresponding name\n        return filtered.stream()\n                       .map(digit -> switch (digit) {\n                           case 1 -> \"One\";\n                           case 2 -> \"Two\";\n                           case 3 -> \"Three\";\n                           case 4 -> \"Four\";\n                           case 5 -> \"Five\";\n                           case 6 -> \"Six\";\n                           case 7 -> \"Seven\";\n                           case 8 -> \"Eight\";\n                           case 9 -> \"Nine\";\n                           default -> \"\";\n                       })\n                       .collect(Collectors.toList());\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.by_length(Arrays.asList(2, 1, 1, 4, 5, 8, 2, 3))); // [Eight, Five, Four, Three, Two, Two, One, One]\n        System.out.println(solution.by_length(Arrays.asList())); // []\n        System.out.println(solution.by_length(Arrays.asList(1, -1, 55))); // [One]\n        System.out.println(solution.by_length(Arrays.asList(9, 7, 3, 2, 4, 8, 6, 5, 1))); // [Nine, Eight, Seven, Six, Five, Four, Three, Two, One]\n    }\n}\n"}
{"task_id": "Java/106", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Implement the function f that takes n as a parameter,\n     * and returns a list of size n, such that the value of the element at index i is the factorial of i if i is even\n     * or the sum of numbers from 1 to i otherwise.\n     * i starts from 1.\n     * the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).\n     * Example:\n     * f(5) == [1, 2, 6, 24, 15]\n     */\n    public List<Integer> f(int n) {\n        List<Integer> result = new ArrayList<>();\n        \n        for (int i = 1; i <= n; i++) {\n            if (i % 2 == 0) {\n                // Calculate factorial of even index\n                int factorial = calculateFactorial(i);\n                result.add(factorial);\n            } else {\n                // Calculate sum from 1 to odd index\n                int sum = calculateSum(i);\n                result.add(sum);\n            }\n        }\n        \n        return result;\n    }\n\n    private int calculateFactorial(int n) {\n        if (n == 0 || n == 1) {\n            return 1;\n        }\n        int factorial = 1;\n        for (int i = 2; i <= n; i++) {\n            factorial *= i;\n        }\n        return factorial;\n    }\n\n    private int calculateSum(int n) {\n        int sum = 0;\n        for (int i = 1; i <= n; i++) {\n            sum += i;\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.f(5));  // Expected output: [1, 2, 6, 24, 15]\n        System.out.println(solution.f(3));  // Expected output: [1, 2, 6]\n        System.out.println(solution.f(0));  // Expected output: []\n    }\n}\n"}
{"task_id": "Java/107", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given a positive integer n, return a tuple that has the number of even and odd\n     * integer palindromes that fall within the range(1, n), inclusive.\n     *\n     * @param n The upper limit (inclusive) to check for palindromic numbers.\n     * @return A List containing two integers: the first is the count of even palindromes,\n     *         and the second is the count of odd palindromes.\n     */\n    public List<Integer> even_odd_palindrome(int n) {\n        int evenCount = 0;\n        int oddCount = 0;\n\n        for (int i = 1; i <= n; i++) {\n            if (isPalindrome(i)) {\n                if (i % 2 == 0) {\n                    evenCount++;\n                } else {\n                    oddCount++;\n                }\n            }\n        }\n\n        return Arrays.asList(evenCount, oddCount);\n    }\n\n    /**\n     * Helper method to check if a number is a palindrome.\n     *\n     * @param num The number to check.\n     * @return true if the number is a palindrome, false otherwise.\n     */\n    private boolean isPalindrome(int num) {\n        String str = Integer.toString(num);\n        int left = 0;\n        int right = str.length() - 1;\n\n        while (left < right) {\n            if (str.charAt(left) != str.charAt(right)) {\n                return false;\n            }\n            left++;\n            right--;\n        }\n\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.even_odd_palindrome(3));  // Output: [1, 2]\n        System.out.println(solution.even_odd_palindrome(12)); // Output: [4, 6]\n        System.out.println(solution.even_odd_palindrome(10)); // Output: [2, 5]\n    }\n}\n"}
{"task_id": "Java/108", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int count_nums(List<Integer> arr) {\n        return (int) arr.stream()\n                        .filter(num -> sumOfDigits(num) > 0)\n                        .count();\n    }\n\n    private int sumOfDigits(int num) {\n        if (num == 0) return 0;\n        boolean isNegative = num < 0;\n        int absNum = Math.abs(num);\n        int sum = 0;\n        while (absNum > 0) {\n            sum += absNum % 10;\n            absNum /= 10;\n        }\n        if (isNegative) {\n            return -sum + 9 * ((int) Math.log10(Math.abs(num)) + 1);\n        } else {\n            return sum;\n        }\n    }\n}\n"}
{"task_id": "Java/109", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N]. The\n     * numbers in the array will be randomly ordered. Your task is to determine if\n     * it is possible to get an array sorted in non-decreasing order by performing\n     * the following operation on the given array:\n     *      You are allowed to perform right shift operation any number of times.\n     *\n     * One right shift operation means shifting all elements of the array by one\n     * position in the right direction. The last element of the array will be moved to\n     * the starting position in the array i.e. 0th index.\n     *\n     * If it is possible to obtain the sorted array by performing the above operation\n     * then return true else return False.\n     * If the given array is empty then return true.\n     *\n     * Note: The given list is guaranteed to have unique elements.\n     */\n    public boolean move_one_ball(List<Integer> arr) {\n        if (arr.isEmpty()) {\n            return true;\n        }\n\n        int n = arr.size();\n        for (int i = 0; i < n - 1; i++) {\n            if (arr.get(i) > arr.get(i + 1)) {\n                // Check if the array can be sorted by a single right shift\n                List<Integer> shiftedArr = new ArrayList<>(arr.subList(i + 1, n));\n                shiftedArr.addAll(arr.subList(0, i + 1));\n                boolean isSorted = true;\n                for (int j = 0; j < n - 1; j++) {\n                    if (shiftedArr.get(j) > shiftedArr.get(j + 1)) {\n                        isSorted = false;\n                        break;\n                    }\n                }\n                return isSorted;\n            }\n        }\n\n        // If no out-of-order pair found, the array is already sorted\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.move_one_ball(Arrays.asList(3, 4, 5, 1, 2))); // true\n        System.out.println(solution.move_one_ball(Arrays.asList(3, 5, 4, 1, 2))); // false\n        System.out.println(solution.move_one_ball(Arrays.asList()));             // true\n        System.out.println(solution.move_one_ball(Arrays.asList(1, 2, 3, 4, 5))); // true\n        System.out.println(solution.move_one_ball(Arrays.asList(2, 1, 3, 4, 5))); // false (requires more than one shift)\n    }\n}\n"}
{"task_id": "Java/110", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * In this problem, you will implement a function that takes two lists of numbers,\n     * and determines whether it is possible to perform an exchange of elements\n     * between them to make lst1 a list of only even numbers.\n     * There is no limit on the number of exchanged elements between lst1 and lst2.\n     * If it is possible to exchange elements between the lst1 and lst2 to make\n     * all the elements of lst1 to be even, return \"YES\".\n     * Otherwise, return \"NO\".\n     * For example:\n     * exchange(Arrays.asList(1, 2, 3, 4), Arrays.asList(1, 2, 3, 4)) => \"YES\"\n     * exchange(Arrays.asList(1, 2, 3, 4), Arrays.asList(1, 5, 3, 4)) => \"NO\"\n     * It is assumed that the input lists will be non-empty.\n     */\n    public String exchange(List<Integer> lst1, List<Integer> lst2) {\n        // Count odd numbers in lst1 and even numbers in lst2\n        int oddCount = 0;\n        for (int num : lst1) {\n            if (num % 2 != 0) {\n                oddCount++;\n            }\n        }\n\n        int evenCount = 0;\n        for (int num : lst2) {\n            if (num % 2 == 0) {\n                evenCount++;\n            }\n        }\n\n        // If there are enough even numbers in lst2 to replace all odd numbers in lst1, return \"YES\"\n        return oddCount <= evenCount ? \"YES\" : \"NO\";\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.exchange(Arrays.asList(1, 2, 3, 4), Arrays.asList(1, 2, 3, 4))); // Expected: YES\n        System.out.println(solution.exchange(Arrays.asList(1, 2, 3, 4), Arrays.asList(1, 5, 3, 4))); // Expected: NO\n        System.out.println(solution.exchange(Arrays.asList(1, 3, 5, 7), Arrays.asList(2, 4, 6, 8))); // Expected: YES\n        System.out.println(solution.exchange(Arrays.asList(1, 3, 5, 7), Arrays.asList(1, 3, 5, 7))); // Expected: NO\n    }\n}\n"}
{"task_id": "Java/111", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public Map<String, Integer> histogram(String test) {\n        // Split the string into individual letters and count their occurrences\n        String[] words = test.split(\" \");\n        HashMap<String, Integer> letterCounts = new HashMap<>();\n        \n        for (String word : words) {\n            if (!word.isEmpty()) { // Ensure that only non-empty strings are counted\n                letterCounts.put(word, letterCounts.getOrDefault(word, 0) + 1);\n            }\n        }\n\n        int maxCount = Collections.max(letterCounts.values());\n        Map<String, Integer> result = new HashMap<>();\n        \n        for (Map.Entry<String, Integer> entry : letterCounts.entrySet()) {\n            if (entry.getValue() == maxCount) {\n                result.put(entry.getKey(), entry.getValue());\n            }\n        }\n\n        return result;\n    }\n}\n"}
{"task_id": "Java/112", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Task\n     * We are given two strings s and c, you have to deleted all the characters in s that are equal to any character in c\n     * then check if the result string is palindrome.\n     * A string is called palindrome if it reads the same backward as forward.\n     * You should return a tuple containing the result string and true/false for the check.\n     * Example\n     * For s = \"abcde\", c = \"ae\", the result should be (\"bcd\",false)\n     * For s = \"abcdef\", c = \"b\"  the result should be (\"acdef\",false)\n     * For s = \"abcdedcba\", c = \"ab\", the result should be (\"cdedc\",true)\n     */\n    public List<Object> reverse_delete(String s, String c) {\n        Set<Character> charsToRemove = new HashSet<>();\n        for (char ch : c.toCharArray()) {\n            charsToRemove.add(ch);\n        }\n\n        StringBuilder sb = new StringBuilder();\n        for (char ch : s.toCharArray()) {\n            if (!charsToRemove.contains(ch)) {\n                sb.append(ch);\n            }\n        }\n\n        String resultString = sb.toString();\n        boolean isPalindrome = isPalindrome(resultString);\n\n        return Arrays.asList(resultString, isPalindrome);\n    }\n\n    private boolean isPalindrome(String str) {\n        int left = 0;\n        int right = str.length() - 1;\n\n        while (left < right) {\n            if (str.charAt(left) != str.charAt(right)) {\n                return false;\n            }\n            left++;\n            right--;\n        }\n\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.reverse_delete(\"abcde\", \"ae\"));  // Expected: [bcd, false]\n        System.out.println(solution.reverse_delete(\"abcdef\", \"b\"));  // Expected: [acdef, false]\n        System.out.println(solution.reverse_delete(\"abcdedcba\", \"ab\"));  // Expected: [cdedc, true]\n    }\n}\n"}
{"task_id": "Java/113", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a list of strings, where each string consists of only digits,\n     * return a list. Each element i of the output should be \"the number of odd elements in the\n     * string i of the input.\" where all the i's should be replaced by the number\n     * of odd digits in the i\"th string of the input.\n     *\n     * @param lst The input list of strings consisting only of digits.\n     * @return A list of formatted strings indicating the count of odd elements in each input string.\n     */\n    public List<String> odd_count(List<String> lst) {\n        List<String> result = new ArrayList<>();\n        for (String str : lst) {\n            int oddCount = 0;\n            for (char c : str.toCharArray()) {\n                if ((c - '0') % 2 != 0) {\n                    oddCount++;\n                }\n            }\n            String formattedStr = \"the number of odd elements \" + oddCount + \"n the str\" + oddCount + \"ng \" + oddCount + \" of the \" + oddCount + \"nput.\";\n            result.add(formattedStr);\n        }\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        List<String> test1 = Arrays.asList(\"1234567\");\n        System.out.println(solution.odd_count(test1));  // Expected: [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n\n        List<String> test2 = Arrays.asList(\"3\", \"11111111\");\n        System.out.println(solution.odd_count(test2));  // Expected: [\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    }\n}\n"}
{"task_id": "Java/114", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given an array of integers nums, find the minimum sum of any non-empty sub-array\n     * of nums.\n     *\n     * Example:\n     * minSubArraySum(Arrays.asList(2, 3, 4, 1, 2, 4)) == 1\n     * minSubArraySum(Arrays.asList(-1, -2, -3)) == -6\n     */\n    public int minSubArraySum(List<Integer> nums) {\n        if (nums == null || nums.isEmpty()) {\n            throw new IllegalArgumentException(\"Input list cannot be null or empty\");\n        }\n        \n        int currentMin = nums.get(0);\n        int globalMin = nums.get(0);\n\n        for (int i = 1; i < nums.size(); i++) {\n            currentMin = Math.min(nums.get(i), currentMin + nums.get(i));\n            globalMin = Math.min(globalMin, currentMin);\n        }\n\n        return globalMin;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.minSubArraySum(Arrays.asList(2, 3, 4, 1, 2, 4))); // Expected output: 1\n        System.out.println(solution.minSubArraySum(Arrays.asList(-1, -2, -3)));       // Expected output: -6\n        System.out.println(solution.minSubArraySum(Arrays.asList(1, 2, 3, -6, 1)));   // Expected output: -6\n        System.out.println(solution.minSubArraySum(Arrays.asList(-1, -1, -2, 1)));    // Expected output: -4\n        System.out.println(solution.minSubArraySum(Arrays.asList(1, 2, 3, 4, 5)));    // Expected output: 1\n    }\n}\n"}
{"task_id": "Java/115", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * You are given a rectangular grid of wells. Each row represents a single well,\n     * and each 1 in a row represents a single unit of water.\n     * Each well has a corresponding bucket that can be used to extract water from it,\n     * and all buckets have the same capacity. Can't use buckets from other wells to extract water from one well.\n     * Your task is to use the buckets to empty the wells.\n     * Output the number of times you need to lower the buckets.\n     *\n     * Example 1:\n     * Input:\n     *      grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n     *      bucket_capacity : 1\n     * Output: 6\n     *\n     * Example 2:\n     * Input:\n     *      grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n     *      bucket_capacity : 2\n     * Output: 5\n     *\n     * Example 3:\n     * Input:\n     *      grid : [[0,0,0], [0,0,0]]\n     *      bucket_capacity : 5\n     * Output: 0\n     */\n    public int max_fill(List<List<Integer>> grid, int capacity) {\n        int totalDrops = 0;\n        for (List<Integer> well : grid) {\n            int waterUnits = 0;\n            for (int unit : well) {\n                waterUnits += unit;\n            }\n            totalDrops += Math.ceil((double) waterUnits / capacity);\n        }\n        return totalDrops;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test Case 1\n        List<List<Integer>> grid1 = Arrays.asList(\n                Arrays.asList(0, 0, 1, 0),\n                Arrays.asList(0, 1, 0, 0),\n                Arrays.asList(1, 1, 1, 1)\n        );\n        int capacity1 = 1;\n        System.out.println(\"Test Case 1: \" + solution.max_fill(grid1, capacity1)); // Expected output: 6\n\n        // Test Case 2\n        List<List<Integer>> grid2 = Arrays.asList(\n                Arrays.asList(0, 0, 1, 1),\n                Arrays.asList(0, 0, 0, 0),\n                Arrays.asList(1, 1, 1, 1),\n                Arrays.asList(0, 1, 1, 1)\n        );\n        int capacity2 = 2;\n        System.out.println(\"Test Case 2: \" + solution.max_fill(grid2, capacity2)); // Expected output: 5\n\n        // Test Case 3\n        List<List<Integer>> grid3 = Arrays.asList(\n                Arrays.asList(0, 0, 0),\n                Arrays.asList(0, 0, 0)\n        );\n        int capacity3 = 5;\n        System.out.println(\"Test Case 3: \" + solution.max_fill(grid3, capacity3)); // Expected output: 0\n    }\n}\n"}
{"task_id": "Java/116", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * In this Kata, you have to sort an array of integers according to\n     * number of ones in their binary representation in ascending order.\n     * For similar number of ones, sort based on decimal value.\n     *\n     * It must be implemented like this:\n     * >>> sort_array(Arrays.asList(1, 5, 2, 3, 4)).equals(Arrays.asList(1, 2, 4, 3, 5))\n     * >>> sort_array(Arrays.asList(-2, -3, -4, -5, -6)).equals(Arrays.asList(-4, -2, -6, -5, -3))\n     * >>> sort_array(Arrays.asList(1, 0, 2, 3, 4)).equals(Arrays.asList(0, 1, 2, 4, 3))\n     */\n    public List<Integer> sort_array(List<Integer> arr) {\n        return arr.stream()\n                  .sorted(Comparator.comparingInt(this::countOnes)\n                                    .thenComparingInt(i -> i))\n                  .collect(Collectors.toList());\n    }\n\n    private int countOnes(int num) {\n        if (num < 0) {\n            num = ~num + 1; // Convert negative number to its positive equivalent\n        }\n        int onesCount = 0;\n        while (num > 0) {\n            onesCount += num & 1;\n            num >>= 1;\n        }\n        return onesCount;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        List<Integer> test1 = Arrays.asList(1, 5, 2, 3, 4);\n        System.out.println(\"Test Case 1: \" + solution.sort_array(test1).equals(Arrays.asList(1, 2, 4, 3, 5)));\n\n        List<Integer> test2 = Arrays.asList(-2, -3, -4, -5, -6);\n        System.out.println(\"Test Case 2: \" + solution.sort_array(test2).equals(Arrays.asList(-4, -2, -6, -5, -3)));\n\n        List<Integer> test3 = Arrays.asList(1, 0, 2, 3, 4);\n        System.out.println(\"Test Case 3: \" + solution.sort_array(test3).equals(Arrays.asList(0, 1, 2, 4, 3)));\n    }\n}\n"}
{"task_id": "Java/117", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a string s and a natural number n, you have been tasked to implement\n     * a function that returns a list of all words from string s that contain exactly\n     * n consonants, in order these words appear in the string s.\n     * If the string s is empty then the function should return an empty list.\n     * Note: you may assume the input string contains only letters and spaces.\n     * Examples:\n     * select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n     * select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n     * select_words(\"simple white space\", 2) ==> []\n     * select_words(\"Hello world\", 4) ==> [\"world\"]\n     * select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\n     */\n    public List<String> select_words(String s, int n) {\n        if (s == null || s.isEmpty()) {\n            return new ArrayList<>();\n        }\n\n        String[] words = s.split(\"\\\\s+\");\n        List<String> result = new ArrayList<>();\n\n        for (String word : words) {\n            long consonantCount = word.toLowerCase().chars()\n                    .filter(c -> \"bcdfghjklmnpqrstvwxyz\".indexOf(c) != -1)\n                    .count();\n\n            if (consonantCount == n) {\n                result.add(word);\n            }\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.select_words(\"Mary had a little lamb\", 4)); // [\"little\"]\n        System.out.println(solution.select_words(\"Mary had a little lamb\", 3)); // [\"Mary\", \"lamb\"]\n        System.out.println(solution.select_words(\"simple white space\", 2));     // []\n        System.out.println(solution.select_words(\"Hello world\", 4));            // [\"world\"]\n        System.out.println(solution.select_words(\"Uncle sam\", 3));              // [\"Uncle\"]\n    }\n}\n"}
{"task_id": "Java/118", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * You are given a word. Your task is to find the closest vowel that stands between\n     * two consonants from the right side of the word (case sensitive).\n     *\n     * Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n     * find any vowel met the above condition.\n     *\n     * You may assume that the given string contains English letter only.\n     */\n    public String get_closest_vowel(String word) {\n        // Convert the input to a character array for easier manipulation\n        char[] chars = word.toCharArray();\n        \n        // Iterate from right to left, looking for vowels between consonants\n        for (int i = chars.length - 2; i > 0; i--) {\n            if (isVowel(chars[i]) && isConsonant(chars[i-1]) && isConsonant(chars[i+1])) {\n                return String.valueOf(chars[i]);\n            }\n        }\n        \n        // If no vowel found, return an empty string\n        return \"\";\n    }\n\n    private boolean isVowel(char c) {\n        return \"AEIOUaeiou\".indexOf(c) != -1;\n    }\n\n    private boolean isConsonant(char c) {\n        return !isVowel(c);\n    }\n    \n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.get_closest_vowel(\"yogurt\"));  // Output: \"u\"\n        System.out.println(solution.get_closest_vowel(\"FULL\"));    // Output: \"U\"\n        System.out.println(solution.get_closest_vowel(\"quick\"));   // Output: \"\"\n        System.out.println(solution.get_closest_vowel(\"ab\"));      // Output: \"\"\n        System.out.println(solution.get_closest_vowel(\"aBcDeFgHiJkLmNoPqRsTuVwXyZ\"));  // Output: \"u\"\n    }\n}\n"}
{"task_id": "Java/119", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public String match_parens(List<String> lst) {\n        // Helper function to check if a string has balanced parentheses\n        boolean isBalanced(String s) {\n            int balance = 0;\n            for (char c : s.toCharArray()) {\n                if (c == '(') {\n                    balance++;\n                } else if (c == ')') {\n                    balance--;\n                }\n                if (balance < 0) {\n                    return false;\n                }\n            }\n            return balance == 0;\n        }\n\n        // Check both possible concatenations\n        String combined1 = lst.get(0) + lst.get(1);\n        String combined2 = lst.get(1) + lst.get(0);\n\n        if (isBalanced(combined1) || isBalanced(combined2)) {\n            return \"Yes\";\n        } else {\n            return \"No\";\n        }\n    }\n}\n"}
{"task_id": "Java/120", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     Given an array arr of integers and a positive integer k, return a sorted list\n     of length k with the maximum k numbers in arr, in ascending order.\n     */\n    public List<Integer> maximum(List<Integer> arr, int k) {\n        // Sort the array in descending order\n        Collections.sort(arr, Collections.reverseOrder());\n        \n        // Create a new list to store the top k elements\n        List<Integer> result = new ArrayList<>();\n        \n        // Add the first k elements from the sorted array to the result list\n        for (int i = 0; i < Math.min(k, arr.size()); i++) {\n            result.add(arr.get(i));\n        }\n        \n        // Sort the result list in ascending order before returning\n        Collections.sort(result);\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        List<Integer> arr1 = Arrays.asList(-3, -4, 5);\n        int k1 = 3;\n        System.out.println(\"Test Case 1: \" + solution.maximum(arr1, k1)); // Expected: [-4, -3, 5]\n\n        // Test case 2\n        List<Integer> arr2 = Arrays.asList(4, -4, 4);\n        int k2 = 2;\n        System.out.println(\"Test Case 2: \" + solution.maximum(arr2, k2)); // Expected: [4, 4]\n\n        // Test case 3\n        List<Integer> arr3 = Arrays.asList(-3, 2, 1, 2, -1, -2, 1);\n        int k3 = 1;\n        System.out.println(\"Test Case 3: \" + solution.maximum(arr3, k3)); // Expected: [2]\n    }\n}\n"}
{"task_id": "Java/121", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n     *\n     * Examples:\n     * solution(Arrays.asList(5, 8, 7, 1)) ==> 12\n     * solution(Arrays.asList(3, 3, 3, 3, 3)) ==> 9\n     * solution(Arrays.asList(30, 13, 24, 321)) ==> 0\n     */\n    public int solution(List<Integer> lst) {\n        int sum = 0;\n        for (int i = 0; i < lst.size(); i += 2) {\n            if (lst.get(i) % 2 != 0) {\n                sum += lst.get(i);\n            }\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.solution(Arrays.asList(5, 8, 7, 1))); // Expected output: 12\n        System.out.println(solution.solution(Arrays.asList(3, 3, 3, 3, 3))); // Expected output: 9\n        System.out.println(solution.solution(Arrays.asList(30, 13, 24, 321))); // Expected output: 0\n    }\n}\n"}
{"task_id": "Java/122", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     Given a non-empty array of integers arr and an integer k, return\n     the sum of the elements with at most two digits from the first k elements of arr.\n     \n     Example:\n     \n         Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n         Output: 24 # sum of 21 + 3\n     \n     Constraints:\n         1. 1 <= len(arr) <= 100\n         2. 1 <= k <= len(arr)\n      */\n    public int add_elements(List<Integer> arr, int k) {\n        int sum = 0;\n        for (int i = 0; i < Math.min(k, arr.size()); i++) {\n            if (arr.get(i).toString().length() <= 2) {\n                sum += arr.get(i);\n            }\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        List<Integer> arr1 = Arrays.asList(111, 21, 3, 4000, 5, 6, 7, 8, 9);\n        int k1 = 4;\n        System.out.println(\"Test Case 1: \" + solution.add_elements(arr1, k1)); // Expected output: 24\n\n        // Test case 2\n        List<Integer> arr2 = Arrays.asList(10, 20, 30, 40, 50);\n        int k2 = 3;\n        System.out.println(\"Test Case 2: \" + solution.add_elements(arr2, k2)); // Expected output: 60\n\n        // Test case 3\n        List<Integer> arr3 = Arrays.asList(1, 2, 3, 4, 5);\n        int k3 = 5;\n        System.out.println(\"Test Case 3: \" + solution.add_elements(arr3, k3)); // Expected output: 15\n\n        // Test case 4\n        List<Integer> arr4 = Arrays.asList(100, 200, 300);\n        int k4 = 2;\n        System.out.println(\"Test Case 4: \" + solution.add_elements(arr4, k4)); // Expected output: 0\n\n        // Test case 5\n        List<Integer> arr5 = Arrays.asList(1, 11, 111, 1111);\n        int k5 = 3;\n        System.out.println(\"Test Case 5: \" + solution.add_elements(arr5, k5)); // Expected output: 12\n\n    }\n}\n"}
{"task_id": "Java/123", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n     *\n     * @param n The starting positive integer for the Collatz sequence.\n     * @return A List of Integer containing the odd numbers in the Collatz sequence, sorted in increasing order.\n     */\n    public List<Integer> get_odd_collatz(int n) {\n        List<Integer> result = new ArrayList<>();\n        while (n != 1) {\n            if (n % 2 == 1) { // Check if n is odd\n                result.add(n);\n            }\n            n = n % 2 == 0 ? n / 2 : 3 * n + 1; // Apply Collatz rules\n        }\n        result.add(1); // Add the final term, which is always 1\n        Collections.sort(result); // Sort the list in increasing order\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.get_odd_collatz(5)); // Expected: [1, 5]\n        System.out.println(solution.get_odd_collatz(7)); // Expected: [1, 7, 11, 22]\n        System.out.println(solution.get_odd_collatz(10)); // Expected: [1, 5, 13]\n        System.out.println(solution.get_odd_collatz(1)); // Expected: [1]\n    }\n}\n"}
{"task_id": "Java/124", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * You have to write a function which validates a given date string and\n     * returns true if the date is valid otherwise false.\n     * The date is valid if all of the following rules are satisfied:\n     * 1. The date string is not empty.\n     * 2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.\n     * 3. The months should not be less than 1 or higher than 12.\n     * 4. The date should be in the format: mm-dd-yyyy\n     *\n     * for example:\n     * valid_date(\"03-11-2000\") => true\n     * valid_date(\"15-01-2012\") => false\n     * valid_date(\"04-0-2040\") => false\n     * valid_date(\"06-04-2020\") => true\n     * valid_date(\"06/04/2020\") => false\n     */\n    public boolean valid_date(String date) {\n        if (date == null || date.isEmpty()) return false;\n\n        String[] parts = date.split(\"-\");\n        if (parts.length != 3) return false;\n\n        int month = Integer.parseInt(parts[0]);\n        int day = Integer.parseInt(parts[1]);\n        int year = Integer.parseInt(parts[2]);\n\n        if (month < 1 || month > 12) return false;\n        if (day < 1 || day > 31) return false;\n\n        // Check for months with 30 days\n        if ((month == 4 || month == 6 || month == 9 || month == 11) && day > 30) return false;\n\n        // Check for February and leap years\n        if (month == 2) {\n            if (day > 29) return false;\n            if (day == 29 && !isLeapYear(year)) return false;\n        }\n\n        return true;\n    }\n\n    private boolean isLeapYear(int year) {\n        return (year % 4 == 0 && (year % 100 != 0 || year % 400 == 0));\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.valid_date(\"03-11-2000\")); // true\n        System.out.println(solution.valid_date(\"15-01-2012\")); // false\n        System.out.println(solution.valid_date(\"04-0-2040\"));  // false\n        System.out.println(solution.valid_date(\"06-04-2020\")); // true\n        System.out.println(solution.valid_date(\"06/04/2020\")); // false\n    }\n}\n"}
{"task_id": "Java/125", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n     should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n     alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n     Examples:\n     split_words(\"Hello world!\") == [\"Hello\", \"world!\"]\n     split_words(\"Hello,world!\") == [\"Hello\", \"world!\"]\n     split_words(\"abcdef\") == 3\n     */\n    public Object split_words(String txt) {\n        if (txt.contains(\" \")) {\n            return Arrays.asList(txt.split(\"\\\\s+\"));\n        } else if (txt.contains(\",\")) {\n            return Arrays.asList(txt.split(\",\"));\n        } else {\n            int count = 0;\n            for (char c : txt.toCharArray()) {\n                if (Character.isLowerCase(c) && ((c - 'a') % 2 == 1)) {\n                    count++;\n                }\n            }\n            return count;\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.split_words(\"Hello world!\")); // [\"Hello\", \"world!\"]\n        System.out.println(solution.split_words(\"Hello,world!\")); // [\"Hello\", \"world!\"]\n        System.out.println(solution.split_words(\"abcdef\"));      // 3\n\n        // Additional test cases\n        System.out.println(solution.split_words(\"a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z\")); // 13\n        System.out.println(solution.split_words(\"A quick, brown fox!\")); // [\"A\", \"quick,\", \"brown\", \"fox!\"]\n        System.out.println(solution.split_words(\"noSpacesOrCommas\")); // 5\n    }\n}\n"}
{"task_id": "Java/126", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given a list of numbers, return whether or not they are sorted in ascending order.\n     * If the number appears more than twice, return false. Assume no negative numbers and only integers.\n     *\n     * Examples:\n     * is_sorted(Arrays.asList(5)) -> true\n     * is_sorted(Arrays.asList(1, 2, 3, 4, 5)) -> true\n     * is_sorted(Arrays.asList(1, 3, 2, 4, 5)) -> false\n     * is_sorted(Arrays.asList(1, 2, 3, 4, 5, 6)) -> true\n     * is_sorted(Arrays.asList(1, 2, 3, 4, 5, 6, 7)) -> true\n     * is_sorted(Arrays.asList(1, 3, 2, 4, 5, 6, 7)) -> false\n     * is_sorted(Arrays.asList(1, 2, 2, 3, 3, 4)) -> true\n     * is_sorted(Arrays.asList(1, 2, 2, 2, 3, 4)) -> false\n     */\n    public boolean is_sorted(List<Integer> lst) {\n        if (lst == null || lst.size() <= 1) {\n            return true;\n        }\n\n        int count = 1; // To keep track of consecutive duplicates\n\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i).equals(lst.get(i - 1))) {\n                count++;\n                if (count > 2) {\n                    return false;\n                }\n            } else {\n                count = 1;\n            }\n\n            if (lst.get(i) < lst.get(i - 1)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.is_sorted(Arrays.asList(5))); // true\n        System.out.println(solution.is_sorted(Arrays.asList(1, 2, 3, 4, 5))); // true\n        System.out.println(solution.is_sorted(Arrays.asList(1, 3, 2, 4, 5))); // false\n        System.out.println(solution.is_sorted(Arrays.asList(1, 2, 3, 4, 5, 6))); // true\n        System.out.println(solution.is_sorted(Arrays.asList(1, 2, 3, 4, 5, 6, 7))); // true\n        System.out.println(solution.is_sorted(Arrays.asList(1, 3, 2, 4, 5, 6, 7))); // false\n        System.out.println(solution.is_sorted(Arrays.asList(1, 2, 2, 3, 3, 4))); // true\n        System.out.println(solution.is_sorted(Arrays.asList(1, 2, 2, 2, 3, 4))); // false\n    }\n}\n"}
{"task_id": "Java/127", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public String intersection(List<Integer> interval1, List<Integer> interval2) {\n        int start = Math.max(interval1.get(0), interval2.get(0));\n        int end = Math.min(interval1.get(1), interval2.get(1));\n\n        if (start > end) {\n            return \"NO\";\n        }\n\n        int length = end - start + 1;\n\n        if (isPrime(length)) {\n            return \"YES\";\n        } else {\n            return \"NO\";\n        }\n    }\n\n    private boolean isPrime(int n) {\n        if (n <= 1) {\n            return false;\n        }\n        for (int i = 2; i <= Math.sqrt(n); i++) {\n            if (n % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n"}
{"task_id": "Java/128", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * You are given an array arr of integers and you need to return\n     * sum of magnitudes of integers multiplied by product of all signs\n     * of each number in the array, represented by 1, -1 or 0.\n     * Note: return None for empty arr.\n     *\n     * Example:\n     * >>> prod_signs(Arrays.asList(1, 2, 2, -4)) == -9\n     * >>> prod_signs(Arrays.asList(0, 1)) == 0\n     * >>> prod_signs(Arrays.asList()) == Optional.empty()\n     */\n    public Optional<Integer> prod_signs(List<Integer> arr) {\n        if (arr.isEmpty()) {\n            return Optional.empty();\n        }\n\n        int sumOfMagnitudes = 0;\n        int productOfSigns = 1;\n\n        for (Integer num : arr) {\n            sumOfMagnitudes += Math.abs(num);\n            if (num == 0) {\n                productOfSigns = 0;\n                break;\n            } else if (num < 0) {\n                productOfSigns *= -1;\n            }\n        }\n\n        return Optional.of(sumOfMagnitudes * productOfSigns);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.prod_signs(Arrays.asList(1, 2, 2, -4))); // Expected output: Optional[-9]\n        System.out.println(solution.prod_signs(Arrays.asList(0, 1)));        // Expected output: Optional[0]\n        System.out.println(solution.prod_signs(Arrays.asList()));           // Expected output: Optional.empty\n    }\n}\n"}
{"task_id": "Java/129", "generation": "import java.util.*;\n\nclass Solution {\n    private int[][] grid;\n    private int n;\n    private List<Integer> minPath = new ArrayList<>();\n    \n    public List<Integer> minPath(List<List<Integer>> grid, int k) {\n        this.grid = new int[n][n];\n        \n        // Convert the list of lists to a 2D array\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                this.grid[i][j] = grid.get(i).get(j);\n            }\n        }\n        \n        this.n = grid.size();\n        \n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                dfs(i, j, new ArrayList<>(), k);\n            }\n        }\n        \n        Collections.sort(minPath);\n        return minPath;\n    }\n    \n    private void dfs(int x, int y, List<Integer> path, int k) {\n        if (path.size() == k) {\n            minPath = new ArrayList<>(path);\n            return;\n        }\n        \n        for (int[] dir : directions) {\n            int nx = x + dir[0];\n            int ny = y + dir[1];\n            if (nx >= 0 && nx < n && ny >= 0 && ny < n) {\n                path.add(grid[nx][ny]);\n                dfs(nx, ny, path, k);\n                path.remove(path.size() - 1); // Backtrack\n            }\n        }\n    }\n    \n    private final int[][] directions = {{0, 1}, {1, 0}, {-1, 0}, {0, -1}};\n}\n"}
{"task_id": "Java/130", "generation": "import java.util.ArrayList;\nimport java.util.List;\n\nclass Solution {\n    public List<Integer> tri(int n) {\n        if (n == 0) {\n            return new ArrayList<>();\n        }\n\n        List<Integer> sequence = new ArrayList<>();\n        sequence.add(3); // Initialize with the first value based on given recurrence relation\n        if (n > 0) {\n            sequence.add(2); // Add second value as per the problem statement\n        }\n\n        for (int i = 2; i <= n; i++) {\n            int nextValue;\n            if (i % 2 == 0) {\n                nextValue = 1 + i / 2;\n            } else {\n                nextValue = sequence.get(i - 1) + sequence.get(i - 2) + (i > 1 ? sequence.get(0) : 0);\n            }\n            sequence.add(nextValue);\n        }\n\n        return sequence;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.tri(3)); // Output: [3, 2, 8]\n    }\n}\n"}
{"task_id": "Java/131", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     Given a positive integer n, return the product of the odd digits.\n     Return 0 if all digits are even.\n     For example:\n     digits(1)  == 1\n     digits(4)  == 0\n     digits(235) == 15\n     */\n    public int digits(int n) {\n        int product = 1;\n        boolean hasOddDigit = false;\n\n        while (n > 0) {\n            int digit = n % 10;\n            if (digit % 2 != 0) {\n                product *= digit;\n                hasOddDigit = true;\n            }\n            n /= 10;\n        }\n\n        return hasOddDigit ? product : 0;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.digits(1));   // Output: 1\n        System.out.println(solution.digits(4));   // Output: 0\n        System.out.println(solution.digits(235)); // Output: 15\n        System.out.println(solution.digits(2468)); // Output: 0\n        System.out.println(solution.digits(13579)); // Output: 945\n    }\n}\n"}
{"task_id": "Java/132", "generation": "import java.util.*;\n\nclass Solution {\n    public boolean is_nested(String string) {\n        Deque<Character> stack = new ArrayDeque<>();\n        boolean nested = false;\n        \n        for (char c : string.toCharArray()) {\n            if (c == '[') {\n                stack.push(c);\n            } else if (c == ']') {\n                if (!stack.isEmpty()) {\n                    stack.pop();\n                    nested = true;\n                }\n            }\n        }\n        \n        return nested && stack.isEmpty();\n    }\n}\n"}
{"task_id": "Java/133", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int sum_squares(List<Double> lst) {\n        int sum = 0;\n        for (Double num : lst) {\n            double roundedNum = Math.ceil(num);\n            sum += (int) Math.pow(roundedNum, 2);\n        }\n        return sum;\n    }\n}\n"}
{"task_id": "Java/134", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Create a function that returns true if the last character\n     * of a given string is an alphabetical character and is not\n     * a part of a word, and false otherwise.\n     * Note: \"word\" is a group of characters separated by space.\n     *\n     * Examples:\n     * check_if_last_char_is_a_letter(\"apple pie\") -> false\n     * check_if_last_char_is_a_letter(\"apple pi e\") -> true\n     * check_if_last_char_is_a_letter(\"apple pi e \") -> false\n     * check_if_last_char_is_a_letter(\"\") -> false\n     */\n    public boolean check_if_last_char_is_a_letter(String txt) {\n        if (txt == null || txt.isEmpty()) {\n            return false;\n        }\n        \n        char lastChar = txt.charAt(txt.length() - 1);\n        if (!Character.isLetter(lastChar)) {\n            return false;\n        }\n        \n        // Check if the second-to-last character is not alphanumeric\n        if (txt.length() <= 1 || !Character.isLetterOrDigit(txt.charAt(txt.length() - 2))) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n"}
{"task_id": "Java/135", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Create a function which returns the largest index of an element which\n     * is not greater than or equal to the element immediately preceding it. If\n     * no such element exists then return -1. The given array will not contain\n     * duplicate values.\n     *\n     * Examples:\n     * canArrange(Arrays.asList(1,2,4,3,5)) = 3\n     * canArrange(Arrays.asList(1,2,3)) = -1\n     */\n    public int canArrange(List<Integer> arr) {\n        for (int i = 1; i < arr.size(); i++) {\n            if (arr.get(i) < arr.get(i - 1)) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.canArrange(Arrays.asList(1, 2, 4, 3, 5))); // Output: 3\n        System.out.println(solution.canArrange(Arrays.asList(1, 2, 3)));       // Output: -1\n    }\n}\n"}
{"task_id": "Java/136", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Create a function that returns a tuple (a, b), where 'a' is\n     * the largest of negative integers, and 'b' is the smallest\n     * of positive integers in a list.\n     * If there is no negative or positive integers, return them as None.\n     *\n     * Examples:\n     * largest_smallest_integers(Arrays.asList(2, 4, 1, 3, 5, 7)) == (Optional.empty(), Optional.of(1))\n     * largest_smallest_integers(Arrays.asList()) == (Optional.empty(), Optional.empty())\n     * largest_smallest_integers(Arrays.asList(0)) == (Optional.empty(), Optional.empty())\n     */\n    public List<Optional<Integer>> largest_smallest_integers(List<Integer> lst) {\n        if (lst.isEmpty()) {\n            return Arrays.asList(Optional.empty(), Optional.empty());\n        }\n\n        Optional<Integer> smallestPositive = lst.stream()\n                .filter(n -> n > 0)\n                .min(Integer::compare);\n\n        Optional<Integer> largestNegative = lst.stream()\n                .filter(n -> n < 0)\n                .max(Integer::compare);\n\n        return Arrays.asList(largestNegative, smallestPositive);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.largest_smallest_integers(Arrays.asList(2, 4, 1, 3, 5, 7))); // (Optional.empty(), Optional.of(1))\n        System.out.println(solution.largest_smallest_integers(Arrays.asList()));                // (Optional.empty(), Optional.empty())\n        System.out.println(solution.largest_smallest_integers(Arrays.asList(0)));               // (Optional.empty(), Optional.empty())\n        System.out.println(solution.largest_smallest_integers(Arrays.asList(-2, -4, -1, -3)));  // (Optional.of(-1), Optional.empty())\n        System.out.println(solution.largest_smallest_integers(Arrays.asList(2, -4, 1, -3, 5))); // (Optional.empty(), Optional.of(1))\n    }\n}\n"}
{"task_id": "Java/137", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public Optional<Object> compare_one(Object a, Object b) {\n        if (a instanceof Integer && b instanceof Integer) {\n            int ai = (Integer) a;\n            int bi = (Integer) b;\n            return ai > bi ? Optional.of(ai) : Optional.empty();\n        } else if (a instanceof Double && b instanceof Double) {\n            double ad = (Double) a;\n            double bd = (Double) b;\n            return ad > bd ? Optional.of(ad) : Optional.empty();\n        } else if (a instanceof String && b instanceof String) {\n            String astr = ((String) a).replace(',', '.');\n            String bstr = ((String) b).replace(',', '.');\n            double ad = Double.parseDouble(astr);\n            double bd = Double.parseDouble(bstr);\n            return ad > bd ? Optional.of(ad) : Optional.empty();\n        } else if (a instanceof Integer && b instanceof String) {\n            int ai = (Integer) a;\n            String astr = ((String) b).replace(',', '.');\n            double bd = Double.parseDouble(astr);\n            return ai > bd ? Optional.of(ai) : Optional.empty();\n        } else if (a instanceof String && b instanceof Integer) {\n            String astr = ((String) a).replace(',', '.');\n            int bi = (Integer) b;\n            double ad = Double.parseDouble(astr);\n            return ad > bi ? Optional.of(ad) : Optional.empty();\n        } else {\n            throw new IllegalArgumentException(\"Unsupported types for comparison\");\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.compare_one(1, 2.5)); // Optional[2.5]\n        System.out.println(solution.compare_one(1, \"2,3\")); // Optional[2.3]\n        System.out.println(solution.compare_one(\"5,1\", \"6\")); // Optional[6.0]\n        System.out.println(solution.compare_one(\"1\", 1)); // Optional.empty\n    }\n}\n"}
{"task_id": "Java/138", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers\n     * Example:\n     * is_equal_to_sum_even(4) == false\n     * is_equal_to_sum_even(6) == false\n     * is_equal_to_sum_even(8) == true\n     */\n    public boolean is_equal_to_sum_even(int n) {\n        // The smallest sum of 4 positive even numbers is 2 + 2 + 2 + 2 = 8.\n        if (n < 8 || n % 2 != 0) {\n            return false;\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(\"is_equal_to_sum_even(4): \" + solution.is_equal_to_sum_even(4)); // false\n        System.out.println(\"is_equal_to_sum_even(6): \" + solution.is_equal_to_sum_even(6)); // false\n        System.out.println(\"is_equal_to_sum_even(8): \" + solution.is_equal_to_sum_even(8)); // true\n        System.out.println(\"is_equal_to_sum_even(10): \" + solution.is_equal_to_sum_even(10)); // true\n        System.out.println(\"is_equal_to_sum_even(12): \" + solution.is_equal_to_sum_even(12)); // true\n        System.out.println(\"is_equal_to_sum_even(14): \" + solution.is_equal_to_sum_even(14)); // true\n        System.out.println(\"is_equal_to_sum_even(16): \" + solution.is_equal_to_sum_even(16)); // true\n        System.out.println(\"is_equal_to_sum_even(7): \" + solution.is_equal_to_sum_even(7)); // false\n    }\n}\n"}
{"task_id": "Java/139", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * The Brazilian factorial is defined as:\n     * brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n     * where n > 0\n     *\n     * For example:\n     * >>> special_factorial(4)\n     * 288\n     *\n     * The function will receive an integer as input and should return the special factorial of this integer.\n     */\n    public long special_factorial(int n) {\n        if (n == 0 || n == 1) {\n            return 1;\n        }\n        \n        long result = 1;\n        for (int i = 1; i <= n; i++) {\n            result *= factorial(i);\n        }\n        return result;\n    }\n\n    private long factorial(int num) {\n        if (num == 0 || num == 1) {\n            return 1;\n        }\n        \n        long fact = 1;\n        for (int i = 2; i <= num; i++) {\n            fact *= i;\n        }\n        return fact;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(\"special_factorial(4): \" + solution.special_factorial(4)); // Expected: 288\n        System.out.println(\"special_factorial(3): \" + solution.special_factorial(3)); // Expected: 12\n        System.out.println(\"special_factorial(5): \" + solution.special_factorial(5)); // Expected: 34560\n        System.out.println(\"special_factorial(1): \" + solution.special_factorial(1)); // Expected: 1\n    }\n}\n"}
{"task_id": "Java/140", "generation": "import java.util.*;\n\nclass Solution {\n    public String fix_spaces(String text) {\n        StringBuilder result = new StringBuilder();\n        int spaceCount = 0;\n        \n        for (char c : text.toCharArray()) {\n            if (c == ' ') {\n                spaceCount++;\n            } else {\n                if (spaceCount > 2) {\n                    result.append('-');\n                } else if (spaceCount >= 1) {\n                    for (int i = 0; i < spaceCount; i++) {\n                        result.append('_');\n                    }\n                }\n                result.append(c);\n                spaceCount = 0;\n            }\n        }\n        \n        // Handle trailing spaces\n        if (spaceCount > 2) {\n            result.append('-');\n        } else if (spaceCount >= 1) {\n            for (int i = 0; i < spaceCount; i++) {\n                result.append('_');\n            }\n        }\n        \n        return result.toString();\n    }\n}\n"}
{"task_id": "Java/141", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Create a function which takes a string representing a file's name, and returns\n     * \"Yes\" if the the file's name is valid, and returns \"No\" otherwise.\n     * A file's name is considered to be valid if and only if all the following conditions\n     * are met:\n     * - There should not be more than three digits ('0'-'9') in the file's name.\n     * - The file's name contains exactly one dot '.'\n     * - The substring before the dot should not be empty, and it starts with a letter from\n     *   the latin alphapet ('a'-'z' and 'A'-'Z').\n     * - The substring after the dot should be one of these: [\"txt\", \"exe\", \"dll\"]\n     * Examples:\n     * file_name_check(\"example.txt\") # => \"Yes\"\n     * file_name_check(\"1example.dll\") # => \"No\" (the name should start with a latin alphapet letter)\n     */\n    public String file_name_check(String file_name) {\n        // Check for exactly one dot\n        int dotCount = 0;\n        for (char c : file_name.toCharArray()) {\n            if (c == '.') {\n                dotCount++;\n            }\n        }\n        if (dotCount != 1) return \"No\";\n\n        // Split the filename into two parts: before and after the dot\n        String[] parts = file_name.split(\"\\\\.\");\n        if (parts.length != 2) return \"No\"; // Should have exactly one dot\n\n        // Check for empty part before the dot\n        if (parts[0].isEmpty()) return \"No\";\n\n        // Check if the first character is a letter\n        char firstChar = parts[0].charAt(0);\n        if (!Character.isLetter(firstChar)) return \"No\";\n\n        // Check for more than three digits in the file name\n        int digitCount = 0;\n        for (char c : file_name.toCharArray()) {\n            if (Character.isDigit(c)) {\n                digitCount++;\n            }\n        }\n        if (digitCount > 3) return \"No\";\n\n        // Check the extension part after the dot\n        String ext = parts[1];\n        if (!ext.equals(\"txt\") && !ext.equals(\"exe\") && !ext.equals(\"dll\")) return \"No\";\n\n        return \"Yes\";\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.file_name_check(\"example.txt\"));  // Expected: Yes\n        System.out.println(solution.file_name_check(\"1example.dll\")); // Expected: No (starts with a digit)\n        System.out.println(solution.file_name_check(\".txt\"));         // Expected: No (empty part before the dot)\n        System.out.println(solution.file_name_check(\"example.exe\"));  // Expected: Yes\n        System.out.println(solution.file_name_check(\"example123.dll\"));// Expected: Yes\n        System.out.println(solution.file_name_check(\"example4567.dll\"));// Expected: No (more than three digits)\n    }\n}\n"}
{"task_id": "Java/142", "generation": "import java.util.List;\n\npublic class Solution {\n    public int sumSquares(List<Integer> lst) {\n        int totalSum = 0;\n        for (int i = 0; i < lst.size(); i++) {\n            if (i % 3 == 0 && i != 0) {\n                totalSum += Math.pow(lst.get(i), 2);\n            } else if (i % 4 == 0 && i % 3 != 0) {\n                totalSum += Math.pow(lst.get(i), 3);\n            } else {\n                totalSum += lst.get(i);\n            }\n        }\n        return totalSum;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.sumSquares(List.of(1, 2, 3))); // Output: 6\n        System.out.println(solution.sumSquares(List.of())); // Output: 0\n        System.out.println(solution.sumSquares(List.of(-1, -5, 2, -1, -5))); // Output: -126\n    }\n}\n"}
{"task_id": "Java/143", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * You are given a string representing a sentence,\n     * the sentence contains some words separated by a space,\n     * and you have to return a string that contains the words from the original sentence,\n     * whose lengths are prime numbers,\n     * the order of the words in the new string should be the same as the original one.\n     *\n     * Example 1:\n     * Input: sentence = \"This is a test\"\n     * Output: \"is\"\n     *\n     * Example 2:\n     * Input: sentence = \"lets go for swimming\"\n     * Output: \"go for\"\n     *\n     * Constraints:\n     * * 1 <= len(sentence) <= 100\n     * * sentence contains only letters\n     */\n    public String words_in_sentence(String sentence) {\n        List<String> words = Arrays.asList(sentence.split(\" \"));\n        StringBuilder result = new StringBuilder();\n        \n        for (String word : words) {\n            if (isPrime(word.length())) {\n                if (result.length() > 0) {\n                    result.append(\" \");\n                }\n                result.append(word);\n            }\n        }\n        \n        return result.toString();\n    }\n\n    private boolean isPrime(int number) {\n        if (number <= 1) {\n            return false;\n        }\n        for (int i = 2; i * i <= number; i++) {\n            if (number % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.words_in_sentence(\"This is a test\")); // Output: \"is\"\n        System.out.println(solution.words_in_sentence(\"lets go for swimming\")); // Output: \"go for\"\n        System.out.println(solution.words_in_sentence(\"one two three four five six seven eight nine ten\")); // Output: \"three five seven\"\n    }\n}\n"}
{"task_id": "Java/144", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Your task is to implement a function that will simplify the expression\n     * x * n. The function returns true if x * n evaluates to a whole number and false\n     * otherwise. Both x and n, are string representation of a fraction, and have the following format,\n     * <numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n     *\n     * You can assume that x, and n are valid fractions, and do not have zero as denominator.\n     */\n    public boolean simplify(String x, String n) {\n        // Split the strings into numerator and denominator\n        String[] xParts = x.split(\"/\");\n        String[] nParts = n.split(\"/\");\n\n        int xNumerator = Integer.parseInt(xParts[0]);\n        int xDenominator = Integer.parseInt(xParts[1]);\n        int nNumerator = Integer.parseInt(nParts[0]);\n        int nDenominator = Integer.parseInt(nParts[1]);\n\n        // Simplify the expression (x * n) / 1\n        int resultNumerator = xNumerator * nNumerator;\n        int resultDenominator = xDenominator * nDenominator;\n\n        // Check if the result is a whole number\n        return resultNumerator % resultDenominator == 0;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.simplify(\"1/5\", \"5/1\")); // true\n        System.out.println(solution.simplify(\"1/6\", \"2/1\")); // false\n        System.out.println(solution.simplify(\"7/10\", \"10/2\")); // false\n        System.out.println(solution.simplify(\"3/4\", \"4/3\")); // true\n        System.out.println(solution.simplify(\"5/8\", \"8/5\")); // true\n        System.out.println(solution.simplify(\"9/16\", \"16/9\")); // true\n    }\n}\n"}
{"task_id": "Java/145", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> order_by_points(List<Integer> nums) {\n        Collections.sort(nums, new Comparator<Integer>() {\n            @Override\n            public int compare(Integer o1, Integer o2) {\n                int sum1 = digitSum(o1);\n                int sum2 = digitSum(o2);\n\n                if (sum1 == sum2) {\n                    return nums.indexOf(o1) - nums.indexOf(o2);\n                }\n\n                return sum1 - sum2;\n            }\n        });\n\n        return nums;\n    }\n\n    private int digitSum(Integer n) {\n        boolean isNegative = n < 0;\n        String strN = Integer.toString(Math.abs(n));\n        int sum = 0;\n\n        for (int i = 0; i < strN.length(); i++) {\n            if (i == 0 && isNegative) {\n                // First digit is negative\n                sum -= Character.getNumericValue(strN.charAt(i));\n            } else {\n                sum += Character.getNumericValue(strN.charAt(i));\n            }\n        }\n\n        return sum;\n    }\n}\n"}
{"task_id": "Java/146", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Write a function that takes an array of numbers as input and returns\n     * the number of elements in the array that are greater than 10 and both\n     * first and last digits of a number are odd (1, 3, 5, 7, 9).\n     * For example:\n     * specialFilter(Arrays.asList(15, -73, 14, -15)) => 1\n     * specialFilter(Arrays.asList(33, -2, -3, 45, 21, 109)) => 2\n     */\n    public int specialFilter(List<Integer> nums) {\n        int count = 0;\n        for (int num : nums) {\n            if (num > 10 && isFirstAndLastDigitOdd(num)) {\n                count++;\n            }\n        }\n        return count;\n    }\n\n    private boolean isFirstAndLastDigitOdd(int num) {\n        String strNum = Integer.toString(Math.abs(num));\n        int firstDigit = Character.digit(strNum.charAt(0), 10);\n        int lastDigit = Character.digit(strNum.charAt(strNum.length() - 1), 10);\n\n        return (firstDigit % 2 != 0) && (lastDigit % 2 != 0);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.specialFilter(Arrays.asList(15, -73, 14, -15))); // Expected output: 1\n        System.out.println(solution.specialFilter(Arrays.asList(33, -2, -3, 45, 21, 109))); // Expected output: 2\n        System.out.println(solution.specialFilter(Arrays.asList(-73, 14, 15, -15, 33, 45, 21, 109))); // Expected output: 3\n    }\n}\n"}
{"task_id": "Java/147", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * You are given a positive integer n. You have to create an integer array a of length n.\n     * For each i (1 <= i <= n), the value of a[i] = i * i - i + 1.\n     * Return the number of triples (a[i], a[j], a[k]) of a where i < j < k,\n     * and a[i] + a[j] + a[k] is a multiple of 3.\n     *\n     * Example :\n     * Input: n = 5\n     * Output: 1\n     * Explanation:\n     * a = [1, 3, 7, 13, 21]\n     * The only valid triple is (1, 7, 13).\n     */\n    public int get_max_triples(int n) {\n        List<Integer> a = new ArrayList<>();\n        \n        // Generate the array a\n        for (int i = 1; i <= n; i++) {\n            a.add(i * i - i + 1);\n        }\n        \n        int count = 0;\n        \n        // Iterate through all possible triples (i, j, k) where i < j < k\n        for (int i = 0; i < n - 2; i++) {\n            for (int j = i + 1; j < n - 1; j++) {\n                for (int k = j + 1; k < n; k++) {\n                    if ((a.get(i) + a.get(j) + a.get(k)) % 3 == 0) {\n                        count++;\n                    }\n                }\n            }\n        }\n        \n        return count;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.get_max_triples(5)); // Expected output: 1\n        System.out.println(solution.get_max_triples(6)); // Expected output: 2\n        System.out.println(solution.get_max_triples(7)); // Expected output: 3\n    }\n}\n"}
{"task_id": "Java/148", "generation": "import java.util.*;\n\nclass Solution {\n    public List<String> bf(String planet1, String planet2) {\n        List<String> planets = Arrays.asList(\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\");\n        \n        if (!planets.contains(planet1) || !planets.contains(planet2)) {\n            return new ArrayList<>();\n        }\n        \n        int start = planets.indexOf(planet1);\n        int end = planets.indexOf(planet2);\n        \n        // Ensure the indices are in ascending order\n        if (start > end) {\n            Collections.swap(planets, start, end);\n            start = planets.indexOf(planet1);\n            end = planets.indexOf(planet2);\n        }\n        \n        return new ArrayList<>(planets.subList(start + 1, end));\n    }\n}\n"}
{"task_id": "Java/149", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Write a function that accepts a list of strings as a parameter,\n     * deletes the strings that have odd lengths from it,\n     * and returns the resulted list with a sorted order.\n     * The list is always a list of strings and never an array of numbers,\n     * and it may contain duplicates.\n     * The order of the list should be ascending by length of each word, and you\n     * should return the list sorted by that rule.\n     * If two words have the same length, sort the list alphabetically.\n     * The function should return a list of strings in sorted order.\n     * You may assume that all words will have the same length.\n     * For example:\n     * assert sorted_list_sum(Arrays.asList(\"aa\", \"a\", \"aaa\")) => [\"aa\"]\n     * assert sorted_list_sum(Arrays.asList(\"ab\", \"a\", \"aaa\", \"cd\")) => [\"ab\", \"cd\"]\n     */\n    public List<String> sorted_list_sum(List<String> lst) {\n        // Remove strings with odd lengths\n        lst.removeIf(s -> s.length() % 2 != 0);\n\n        // Sort the list by length, then alphabetically if lengths are equal\n        Collections.sort(lst, (s1, s2) -> {\n            int lenCompare = Integer.compare(s1.length(), s2.length());\n            return lenCompare == 0 ? s1.compareTo(s2) : lenCompare;\n        });\n\n        return lst;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        List<String> test1 = Arrays.asList(\"aa\", \"a\", \"aaa\");\n        System.out.println(solution.sorted_list_sum(test1)); // Expected: [aa]\n\n        List<String> test2 = Arrays.asList(\"ab\", \"a\", \"aaa\", \"cd\");\n        System.out.println(solution.sorted_list_sum(test2)); // Expected: [ab, cd]\n\n        List<String> test3 = Arrays.asList(\"hello\", \"world\", \"hi\", \"bye\");\n        System.out.println(solution.sorted_list_sum(test3)); // Expected: [hi, bye]\n    }\n}\n"}
{"task_id": "Java/150", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * A simple program which should return the value of x if n is\n     * a prime number and should return the value of y otherwise.\n     *\n     * Examples:\n     * for x_or_y(7, 34, 12) == 34\n     * for x_or_y(15, 8, 5) == 5\n     */\n    public int x_or_y(int n, int x, int y) {\n        if (isPrime(n)) {\n            return x;\n        } else {\n            return y;\n        }\n    }\n\n    /**\n     * Helper method to check if a number is prime.\n     *\n     * @param num the number to check\n     * @return true if the number is prime, false otherwise\n     */\n    private boolean isPrime(int num) {\n        if (num <= 1) return false;\n        for (int i = 2; i <= Math.sqrt(num); i++) {\n            if (num % i == 0) return false;\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.x_or_y(7, 34, 12)); // Expected output: 34 (since 7 is prime)\n        System.out.println(solution.x_or_y(15, 8, 5));  // Expected output: 5 (since 15 is not prime)\n        System.out.println(solution.x_or_y(2, 10, 20)); // Expected output: 10 (since 2 is prime)\n        System.out.println(solution.x_or_y(4, 30, 40)); // Expected output: 40 (since 4 is not prime)\n    }\n}\n"}
{"task_id": "Java/151", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     Given a list of numbers, return the sum of squares of the numbers\n     in the list that are odd. Ignore numbers that are negative or not integers.\n     */\n    public int double_the_difference(List<Object> lst) {\n        int result = 0;\n        for (Object obj : lst) {\n            if (obj instanceof Integer) {\n                int num = (Integer) obj;\n                if (num > 0 && num % 2 != 0) {\n                    result += num * num;\n                }\n            }\n        }\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.double_the_difference(Arrays.asList(1, 3, 2, 0))); // Expected output: 10\n        System.out.println(solution.double_the_difference(Arrays.asList(-1, -2, 0))); // Expected output: 0\n        System.out.println(solution.double_the_difference(Arrays.asList(9, -2)));      // Expected output: 81\n        System.out.println(solution.double_the_difference(Arrays.asList(0)));          // Expected output: 0\n        System.out.println(solution.double_the_difference(new ArrayList<>()));         // Expected output: 0\n    }\n}\n"}
{"task_id": "Java/152", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Compares the game scores with the guesses and returns an array of how far off each guess was.\n     *\n     * @param game  A list of integers representing the actual game scores.\n     * @param guess A list of integers representing the guessed scores.\n     * @return A list of integers where each element is the absolute difference between the guess and the score, or 0 if they are equal.\n     */\n    public List<Integer> compare(List<Integer> game, List<Integer> guess) {\n        List<Integer> result = new ArrayList<>();\n        for (int i = 0; i < game.size(); i++) {\n            int diff = Math.abs(game.get(i) - guess.get(i));\n            result.add(diff);\n        }\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        List<Integer> test1Game = Arrays.asList(1, 2, 3, 4, 5, 1);\n        List<Integer> test1Guess = Arrays.asList(1, 2, 3, 4, 2, -2);\n        System.out.println(solution.compare(test1Game, test1Guess)); // Expected: [0, 0, 0, 0, 3, 3]\n\n        List<Integer> test2Game = Arrays.asList(0, 5, 0, 0, 0, 4);\n        List<Integer> test2Guess = Arrays.asList(4, 1, 1, 0, 0, -2);\n        System.out.println(solution.compare(test2Game, test2Guess)); // Expected: [4, 4, 1, 0, 0, 6]\n    }\n}\n"}
{"task_id": "Java/153", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * You will be given the name of a class (a string) and a list of extensions.\n     * The extensions are to be used to load additional classes to the class. The\n     * strength of the extension is as follows: Let CAP be the number of the uppercase\n     * letters in the extension's name, and let SM be the number of lowercase letters\n     * in the extension's name, the strength is given by the fraction CAP - SM.\n     * You should find the strongest extension and return a string in this\n     * format: ClassName.Strongest_Extension.\n     * If there are two or more extensions with the same strength, you should\n     * choose the one that comes first in the list.\n     * For example, if you are given \"Slices\" as the class and a list of the\n     * extensions: [\"SErviNGSliCes\", \"Cheese\", \"StuFfed\"] then you should\n     * return \"Slices.SErviNGSliCes\" since \"SErviNGSliCes\" is the strongest extension\n     * (its strength is -1).\n     * Example:\n     * for Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"]) == \"my_class.AA\"\n     */\n    public String Strongest_Extension(String class_name, List<String> extensions) {\n        int maxStrength = Integer.MIN_VALUE;\n        String strongestExtension = \"\";\n        \n        for (String extension : extensions) {\n            int cap = 0, sm = 0;\n            for (char c : extension.toCharArray()) {\n                if (Character.isUpperCase(c)) {\n                    cap++;\n                } else if (Character.isLowerCase(c)) {\n                    sm++;\n                }\n            }\n            \n            int strength = cap - sm;\n            if (strength > maxStrength) {\n                maxStrength = strength;\n                strongestExtension = extension;\n            }\n        }\n        \n        return class_name + \".\" + strongestExtension;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.Strongest_Extension(\"Slices\", Arrays.asList(\"SErviNGSliCes\", \"Cheese\", \"StuFfed\"))); // Should print: Slices.SErviNGSliCes\n        System.out.println(solution.Strongest_Extension(\"my_class\", Arrays.asList(\"AA\", \"Be\", \"CC\"))); // Should print: my_class.AA\n        System.out.println(solution.Strongest_Extension(\"DataProcessor\", Arrays.asList(\"dataIO\", \"DATAIO\", \"dataio\"))); // Should print: DataProcessor.DATAIO\n    }\n}\n"}
{"task_id": "Java/154", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * You are given 2 words. You need to return true if the second word or any of its rotations is a substring in the first word.\n     * cycpattern_check(\"abcd\",\"abd\") => false\n     * cycpattern_check(\"hello\",\"ell\") => true\n     * cycpattern_check(\"whassup\",\"psus\") => false\n     * cycpattern_check(\"abab\",\"baa\") => true\n     * cycpattern_check(\"efef\",\"eeff\") => false\n     * cycpattern_check(\"himenss\",\"simen\") => true\n     */\n    public boolean cycpattern_check(String a, String b) {\n        if (b.length() > a.length()) {\n            return false;\n        }\n        \n        // Generate all rotations of the second word\n        for (int i = 0; i < b.length(); i++) {\n            String rotated = rotateString(b, i);\n            if (a.contains(rotated)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private String rotateString(String s, int k) {\n        int n = s.length();\n        k = k % n; // In case the rotation is greater than the length of the string\n        return s.substring(n - k) + s.substring(0, n - k);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.cycpattern_check(\"abcd\", \"abd\")); // false\n        System.out.println(solution.cycpattern_check(\"hello\", \"ell\")); // true\n        System.out.println(solution.cycpattern_check(\"whassup\", \"psus\")); // false\n        System.out.println(solution.cycpattern_check(\"abab\", \"baa\")); // true\n        System.out.println(solution.cycpattern_check(\"efef\", \"eeff\")); // false\n        System.out.println(solution.cycpattern_check(\"himenss\", \"simen\")); // true\n    }\n}\n"}
{"task_id": "Java/155", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> even_odd_count(int num) {\n        // Convert number to string to iterate over each digit\n        String strNum = Integer.toString(Math.abs(num));\n        \n        // Initialize counters for even and odd digits\n        int evenCount = 0, oddCount = 0;\n        \n        // Iterate through each character in the string representation of the number\n        for (char c : strNum.toCharArray()) {\n            int digit = Character.getNumericValue(c);\n            \n            // Check if the digit is even or odd\n            if (digit % 2 == 0) {\n                evenCount++;\n            } else {\n                oddCount++;\n            }\n        }\n        \n        // Return a list containing the counts of even and odd digits\n        List<Integer> result = new ArrayList<>();\n        result.add(evenCount);\n        result.add(oddCount);\n        return result;\n    }\n}\n"}
{"task_id": "Java/156", "generation": "import java.util.*;\n\nclass Solution {\n    public String int_to_mini_roman(int number) {\n        List<RomanNumeral> romanNumerals = Arrays.asList(\n            new RomanNumeral(1000, \"m\"), new RomanNumeral(900, \"cm\"),\n            new RomanNumeral(500, \"d\"), new RomanNumeral(400, \"cd\"),\n            new RomanNumeral(100, \"c\"), new RomanNumeral(90, \"xc\"),\n            new RomanNumeral(50, \"l\"), new RomanNumeral(40, \"xl\"),\n            new RomanNumeral(10, \"x\"), new RomanNumeral(9, \"ix\"),\n            new RomanNumeral(5, \"v\"), new RomanNumeral(4, \"iv\"),\n            new RomanNumeral(1, \"i\")\n        );\n\n        StringBuilder romanString = new StringBuilder();\n        for (RomanNumeral numeral : romanNumerals) {\n            while (number >= numeral.getValue()) {\n                romanString.append(numeral.getSymbol());\n                number -= numeral.getValue();\n            }\n        }\n\n        return romanString.toString().toLowerCase();\n    }\n\n    private static class RomanNumeral {\n        private final int value;\n        private final String symbol;\n\n        public RomanNumeral(int value, String symbol) {\n            this.value = value;\n            this.symbol = symbol;\n        }\n\n        public int getValue() {\n            return value;\n        }\n\n        public String getSymbol() {\n            return symbol;\n        }\n    }\n}\n"}
{"task_id": "Java/157", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given the lengths of the three sides of a triangle. Return true if the three\n     * sides form a right-angled triangle, false otherwise.\n     * A right-angled triangle is a triangle in which one angle is a right angle or 90 degrees.\n     * Example:\n     * right_angle_triangle(3, 4, 5) == true\n     * right_angle_triangle(1, 2, 3) == false\n     */\n    public boolean right_angle_triangle(int a, int b, int c) {\n        // Sort the sides to ensure the longest side is last\n        int[] sides = {a, b, c};\n        Arrays.sort(sides);\n        \n        // Check if the square of the longest side equals the sum of squares of other two sides\n        return Math.pow(sides[0], 2) + Math.pow(sides[1], 2) == Math.pow(sides[2], 2);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.right_angle_triangle(3, 4, 5)); // true\n        System.out.println(solution.right_angle_triangle(1, 2, 3)); // false\n        System.out.println(solution.right_angle_triangle(5, 12, 13)); // true\n        System.out.println(solution.right_angle_triangle(6, 8, 10)); // true\n        System.out.println(solution.right_angle_triangle(7, 10, 12)); // false\n    }\n}\n"}
{"task_id": "Java/158", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Write a function that accepts a list of strings.\n     * The list contains different words. Return the word with maximum number\n     * of unique characters. If multiple strings have maximum number of unique\n     * characters, return the one which comes first in lexicographical order.\n     *\n     * find_max([\"name\", \"of\", \"string\"]) == \"string\"\n     * find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n     * find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"aaaaaaa\"\n     */\n    public String find_max(List<String> words) {\n        if (words == null || words.isEmpty()) {\n            return \"\";\n        }\n\n        // Sort the list lexicographically\n        Collections.sort(words);\n\n        String maxWord = \"\";\n        int maxUniqueChars = 0;\n\n        for (String word : words) {\n            Set<Character> uniqueChars = new HashSet<>();\n            for (char c : word.toCharArray()) {\n                uniqueChars.add(c);\n            }\n\n            if (uniqueChars.size() > maxUniqueChars) {\n                maxUniqueChars = uniqueChars.size();\n                maxWord = word;\n            }\n        }\n\n        return maxWord;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.find_max(Arrays.asList(\"name\", \"of\", \"string\"))); // Output: string\n        System.out.println(solution.find_max(Arrays.asList(\"name\", \"enam\", \"game\"))); // Output: enam\n        System.out.println(solution.find_max(Arrays.asList(\"aaaaaaa\", \"bb\", \"cc\")));  // Output: aaaaaaa\n        System.out.println(solution.find_max(new ArrayList<>()));                     // Output: (empty string)\n        System.out.println(solution.find_max(Arrays.asList(\"abc\", \"defg\", \"hijk\")));  // Output: defg\n    }\n}\n"}
{"task_id": "Java/159", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * You're a hungry rabbit, and you already have eaten a certain number of carrots,\n     * but now you need to eat more carrots to complete the day's meals.\n     * return an array of [ total number of eaten carrots after your meals,\n     *                     the number of carrots left after your meals ]\n     * if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n     *\n     * Example:\n     * * eat(5, 6, 10) -> [11, 4]\n     * * eat(4, 8, 9) -> [12, 1]\n     * * eat(1, 10, 10) -> [11, 0]\n     * * eat(2, 11, 5) -> [7, 0]\n     *\n     * Variables:\n     * @number : integer\n     *        the number of carrots that you have eaten.\n     * @need : integer\n     *        the number of carrots that you need to eat.\n     * @remaining : integer\n     *        the number of remaining carrots thet exist in stock\n     *\n     * Constrain:\n     * * 0 <= number <= 1000\n     * * 0 <= need <= 1000\n     * * 0 <= remaining <= 1000\n     */\n    public List<Integer> eat(int number, int need, int remaining) {\n        // Calculate the total number of carrots to be eaten\n        int totalToEat = Math.min(need, remaining);\n        \n        // Update the number of carrots eaten and remaining\n        int newNumberEaten = number + totalToEat;\n        int newRemainingCarrots = remaining - totalToEat;\n\n        return Arrays.asList(newNumberEaten, newRemainingCarrots);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.eat(5, 6, 10)); // Expected: [11, 4]\n        System.out.println(solution.eat(4, 8, 9));  // Expected: [12, 1]\n        System.out.println(solution.eat(1, 10, 10)); // Expected: [11, 0]\n        System.out.println(solution.eat(2, 11, 5));  // Expected: [7, 0]\n    }\n}\n"}
{"task_id": "Java/160", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int do_algebra(List<String> operator, List<Integer> operand) {\n        StringBuilder expression = new StringBuilder();\n        expression.append(operand.get(0));\n        \n        for (int i = 0; i < operator.size(); i++) {\n            expression.append(\" \").append(operator.get(i)).append(\" \").append(operand.get(i + 1));\n        }\n        \n        return evaluateExpression(expression.toString());\n    }\n\n    private int evaluateExpression(String expression) {\n        // Java does not have a built-in eval function, so we need to parse and evaluate the expression manually.\n        // For simplicity, let's assume that the expression is well-formed and contains only basic arithmetic operations.\n        String[] parts = expression.split(\" \");\n        Stack<Integer> numbers = new Stack<>();\n        Stack<String> operators = new Stack<>();\n\n        for (String part : parts) {\n            if (\"+\".equals(part) || \"-\".equals(part) || \"*\".equals(part) || \"/\".equals(part)) {\n                operators.push(part);\n            } else {\n                numbers.push(Integer.parseInt(part));\n            }\n        }\n\n        while (!operators.isEmpty()) {\n            String op = operators.pop();\n            int b = numbers.pop();\n            int a = numbers.pop();\n\n            switch (op) {\n                case \"+\":\n                    numbers.push(a + b);\n                    break;\n                case \"-\":\n                    numbers.push(a - b);\n                    break;\n                case \"*\":\n                    numbers.push(a * b);\n                    break;\n                case \"/\":\n                    numbers.push(a / b); // Note: This is integer division\n                    break;\n            }\n        }\n\n        return numbers.pop();\n    }\n}\n"}
{"task_id": "Java/161", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * You are given a string s.\n     * if s[i] is a letter, reverse its case from lower to upper or vise versa,\n     * otherwise keep it as it is.\n     * If the string contains no letters, reverse the string.\n     * The function should return the resulted string.\n     * Examples\n     * solve(\"1234\") = \"4321\"\n     * solve(\"ab\") = \"AB\"\n     * solve(\"#a@C\") = \"#A@c\"\n     */\n    public String solve(String s) {\n        if (s == null || s.isEmpty()) {\n            return s;\n        }\n\n        boolean containsLetters = false;\n        StringBuilder result = new StringBuilder();\n\n        for (char c : s.toCharArray()) {\n            if (Character.isLetter(c)) {\n                containsLetters = true;\n                result.append(Character.isLowerCase(c) ? Character.toUpperCase(c) : Character.toLowerCase(c));\n            } else {\n                result.append(c);\n            }\n        }\n\n        return containsLetters ? result.toString() : new StringBuilder(s).reverse().toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.solve(\"1234\"));  // Expected: \"4321\"\n        System.out.println(solution.solve(\"ab\"));    // Expected: \"AB\"\n        System.out.println(solution.solve(\"#a@C\"));  // Expected: \"#A@c\"\n        System.out.println(solution.solve(\"\"));      // Expected: \"\"\n        System.out.println(solution.solve(\"123!@#\")); // Expected: \"#@!321\"\n        System.out.println(solution.solve(\"Hello World!\")); // Expected: \"hELLO wORLD!\"\n    }\n}\n"}
{"task_id": "Java/162", "generation": "import java.math.BigInteger;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.Optional;\n\nclass Solution {\n    public Optional<String> string_to_md5(String text) throws NoSuchAlgorithmException {\n        if (text == null || text.isEmpty()) {\n            return Optional.empty();\n        }\n        \n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        byte[] hashBytes = md.digest(text.getBytes());\n        BigInteger number = new BigInteger(1, hashBytes);\n        String hexString = number.toString(16);\n        \n        // Ensure the length is 32 characters\n        while (hexString.length() < 32) {\n            hexString = \"0\" + hexString;\n        }\n        \n        return Optional.of(hexString);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        try {\n            System.out.println(solution.string_to_md5(\"Hello world\")); // Expected: 3e25960a79dbc69b674cd4ec67a72c62\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n    }\n}\n"}
{"task_id": "Java/163", "generation": "import java.util.List;\n\nclass Solution {\n\n    /**\n     * Given two positive integers a and b, return the even digits between a\n     * and b, in ascending order.\n     *\n     * @param a the lower bound (inclusive)\n     * @param b the upper bound (inclusive)\n     * @return a List of Integer containing even digits between a and b\n     */\n    public List<Integer> generate_integers(int a, int b) {\n        List<Integer> result = new ArrayList<>();\n        \n        // Ensure a is less than or equal to b for simplicity in iteration\n        if (a > b) {\n            int temp = a;\n            a = b;\n            b = temp;\n        }\n        \n        for (int i = a; i <= b; i++) {\n            if (i % 2 == 0 && i < 10) {\n                result.add(i);\n            }\n        }\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(\"generate_integers(2, 8): \" + solution.generate_integers(2, 8)); // [2, 4, 6, 8]\n        System.out.println(\"generate_integers(8, 2): \" + solution.generate_integers(8, 2)); // [2, 4, 6, 8]\n        System.out.println(\"generate_integers(10, 14): \" + solution.generate_integers(10, 14)); // []\n        System.out.println(\"generate_integers(1, 5): \" + solution.generate_integers(1, 5)); // [2, 4]\n        System.out.println(\"generate_integers(3, 7): \" + solution.generate_integers(3, 7)); // [4, 6]\n    }\n}\n"}
{"task_id": "Java/0", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Check if in given list of numbers, are any two numbers closer to each other than given threshold.\n     *\n     * @param numbers List of Double values.\n     * @param threshold The threshold value for closeness.\n     * @return true if there exist at least two elements whose difference is less than the threshold; false otherwise.\n     */\n    public boolean has_close_elements(List<Double> numbers, double threshold) {\n        // Sort the list to make it easier to find close elements\n        Collections.sort(numbers);\n        \n        for (int i = 0; i < numbers.size() - 1; i++) {\n            if (numbers.get(i + 1) - numbers.get(i) < threshold) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.has_close_elements(Arrays.asList(1.0, 2.0, 3.0), 0.5)); // Expected: false\n        System.out.println(solution.has_close_elements(Arrays.asList(1.0, 2.8, 3.0, 4.0, 5.0, 2.0), 0.3)); // Expected: true\n        System.out.println(solution.has_close_elements(Arrays.asList(-1.0, -2.0, -3.0), 1.5)); // Expected: false\n        System.out.println(solution.has_close_elements(Arrays.asList(10.0, 10.1, 10.2, 10.3), 0.05)); // Expected: true\n    }\n}\n"}
{"task_id": "Java/1", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n     * separate those group into separate strings and return the list of those.\n     * Separate groups are balanced (each open brace is properly closed) and not nested within each other\n     * Ignore any spaces in the input string.\n     *\n     * @param paren_string The input string containing multiple groups of nested parentheses.\n     * @return A List of separate strings, each representing a group of balanced parentheses.\n     */\n    public List<String> separate_paren_groups(String paren_string) {\n        List<String> result = new ArrayList<>();\n        int balance = 0;\n        StringBuilder currentGroup = new StringBuilder();\n\n        for (char c : paren_string.toCharArray()) {\n            if (c == ' ') continue; // Ignore spaces\n\n            if (c == '(') {\n                balance++;\n                currentGroup.append(c);\n            } else if (c == ')') {\n                balance--;\n                currentGroup.append(c);\n\n                if (balance == 0) { // A complete group is found\n                    result.add(currentGroup.toString());\n                    currentGroup = new StringBuilder(); // Reset for the next group\n                }\n            }\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(\"Test Case 1: ( ) (( )) (( )( ))\");\n        List<String> test1 = solution.separate_paren_groups(\"( ) (( )) (( )( ))\");\n        for (String group : test1) {\n            System.out.println(group);\n        }\n\n        System.out.println(\"\\nTest Case 2: (()())(())\");\n        List<String> test2 = solution.separate_paren_groups(\"(()())(())\");\n        for (String group : test2) {\n            System.out.println(group);\n        }\n\n        System.out.println(\"\\nTest Case 3: ((()))((()))\");\n        List<String> test3 = solution.separate_paren_groups(\"((()))((()))\");\n        for (String group : test3) {\n            System.out.println(group);\n        }\n    }\n}\n"}
{"task_id": "Java/2", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     Given a positive floating point number, it can be decomposed into\n     and integer part (largest integer smaller than given number) and decimals\n     (leftover part always smaller than 1).\n\n     Return the decimal part of the number.\n     >>> truncate_number(3.5)\n     0.5\n     */\n    public double truncate_number(double number) {\n        return number - Math.floor(number);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(\"Truncate 3.5: \" + solution.truncate_number(3.5)); // Expected output: 0.5\n        System.out.println(\"Truncate 123.456: \" + solution.truncate_number(123.456)); // Expected output: 0.456\n        System.out.println(\"Truncate -1.234: \" + solution.truncate_number(-1.234)); // Expected output: -0.234 (Note: floor of negative numbers is less than the number itself)\n        System.out.println(\"Truncate 0.999: \" + solution.truncate_number(0.999)); // Expected output: 0.999\n        System.out.println(\"Truncate 10.0: \" + solution.truncate_number(10.0)); // Expected output: 0.0\n    }\n}\n"}
{"task_id": "Java/3", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * You're given a list of deposit and withdrawal operations on a bank account that starts with\n     * zero balance. Your task is to detect if at any point the balance of the account falls below zero,\n     * and at that point, the function should return true. Otherwise, it should return false.\n     *\n     * @param operations List of integers representing deposits (positive) and withdrawals (negative).\n     * @return boolean indicating whether the balance ever goes below zero.\n     */\n    public boolean below_zero(List<Integer> operations) {\n        int balance = 0;\n        for (int op : operations) {\n            balance += op;\n            if (balance < 0) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        List<Integer> test1 = Arrays.asList(1, 2, 3);\n        System.out.println(\"Test Case 1: \" + (solution.below_zero(test1) == false)); // Expected: true\n\n        List<Integer> test2 = Arrays.asList(1, 2, -4, 5);\n        System.out.println(\"Test Case 2: \" + (solution.below_zero(test2) == true)); // Expected: true\n\n        List<Integer> test3 = Arrays.asList(-1, 2, -1, 3);\n        System.out.println(\"Test Case 3: \" + (solution.below_zero(test3) == false)); // Expected: false\n\n        List<Integer> test4 = Arrays.asList(5, -6, 7, -8, 9);\n        System.out.println(\"Test Case 4: \" + (solution.below_zero(test4) == true)); // Expected: true\n    }\n}\n"}
{"task_id": "Java/4", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * For a given list of input numbers, calculate Mean Absolute Deviation around the mean of this dataset.\n     * Mean Absolute Deviation is the average absolute difference between each element and a centerpoint (mean in this case):\n     * MAD = average | x - x_mean |\n     *\n     * @param numbers List of Double values\n     * @return Mean Absolute Deviation as a double\n     */\n    public double mean_absolute_deviation(List<Double> numbers) {\n        if (numbers == null || numbers.isEmpty()) {\n            throw new IllegalArgumentException(\"Input list cannot be null or empty\");\n        }\n\n        // Calculate the mean of the dataset\n        double sum = 0.0;\n        for (Double num : numbers) {\n            sum += num;\n        }\n        double mean = sum / numbers.size();\n\n        // Calculate the Mean Absolute Deviation\n        double mad = 0.0;\n        for (Double num : numbers) {\n            mad += Math.abs(num - mean);\n        }\n        return mad / numbers.size();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.mean_absolute_deviation(Arrays.asList(1.0, 2.0, 3.0, 4.0))); // Expected output: 1.0\n        System.out.println(solution.mean_absolute_deviation(Arrays.asList(5.0, 7.0, 9.0, 11.0, 13.0))); // Expected output: 2.8\n        System.out.println(solution.mean_absolute_deviation(Arrays.asList(-1.0, -2.0, -3.0, -4.0))); // Expected output: 1.5\n        System.out.println(solution.mean_absolute_deviation(Arrays.asList(10.0))); // Expected output: 0.0 (single element)\n    }\n}\n"}
{"task_id": "Java/5", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Insert a number 'delimiter' between every two consecutive elements of input list `numbers`\n     *\n     * @param numbers The input list of integers.\n     * @param delimiter The integer to be inserted as a delimiter.\n     * @return A new list with the delimiter interspersed.\n     */\n    public List<Integer> intersperse(List<Integer> numbers, int delimiter) {\n        if (numbers == null || numbers.size() <= 1) {\n            return numbers;\n        }\n\n        List<Integer> result = new ArrayList<>();\n        for (int i = 0; i < numbers.size(); i++) {\n            result.add(numbers.get(i));\n            if (i < numbers.size() - 1) {\n                result.add(delimiter);\n            }\n        }\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.intersperse(List.of(), 4)); // Expected: []\n        System.out.println(solution.intersperse(Arrays.asList(1, 2, 3), 4)); // Expected: [1, 4, 2, 4, 3]\n        System.out.println(solution.intersperse(Arrays.asList(5, 6, 7, 8), -1)); // Expected: [5, -1, 6, -1, 7, -1, 8]\n    }\n}\n"}
{"task_id": "Java/6", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n     * For each of the group, output the deepest level of nesting of parentheses.\n     * E.g. (()()) has maximum two levels of nesting while ((())) has three.\n     *\n     * >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n     * [2, 3, 1, 3]\n     */\n    public List<Integer> parse_nested_parens(String paren_string) {\n        String[] groups = paren_string.split(\"\\\\s+\");\n        List<Integer> depths = new ArrayList<>();\n        \n        for (String group : groups) {\n            int maxDepth = 0;\n            int currentDepth = 0;\n            \n            for (char c : group.toCharArray()) {\n                if (c == '(') {\n                    currentDepth++;\n                    maxDepth = Math.max(maxDepth, currentDepth);\n                } else if (c == ')') {\n                    currentDepth--;\n                }\n            }\n            \n            depths.add(maxDepth);\n        }\n        \n        return depths;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        String test1 = \"(()()) ((())) () ((())()())\";\n        List<Integer> result1 = solution.parse_nested_parens(test1);\n        System.out.println(result1); // Expected output: [2, 3, 1, 3]\n        \n        String test2 = \"(()) (()) (((())))\";\n        List<Integer> result2 = solution.parse_nested_parens(test2);\n        System.out.println(result2); // Expected output: [2, 2, 4]\n        \n        String test3 = \"((())) () (((())))\";\n        List<Integer> result3 = solution.parse_nested_parens(test3);\n        System.out.println(result3); // Expected output: [3, 1, 4]\n    }\n}\n"}
{"task_id": "Java/7", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Filter an input list of strings only for ones that contain given substring\n     *\n     * @param strings The input list of strings\n     * @param substring The substring to filter by\n     * @return A list of strings containing the specified substring\n     */\n    public List<String> filter_by_substring(List<String> strings, String substring) {\n        List<String> filteredList = new ArrayList<>();\n        for (String str : strings) {\n            if (str.contains(substring)) {\n                filteredList.add(str);\n            }\n        }\n        return filteredList;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(\"Test Case 1: Empty List\");\n        System.out.println(solution.filter_by_substring(List.of(), \"a\")); // Expected output: []\n\n        System.out.println(\"\\nTest Case 2: Normal List with 'a'\");\n        System.out.println(solution.filter_by_substring(Arrays.asList(\"abc\", \"bacd\", \"cde\", \"array\"), \"a\"));\n        // Expected output: [abc, bacd, array]\n\n        System.out.println(\"\\nTest Case 3: List without the substring\");\n        System.out.println(solution.filter_by_substring(Arrays.asList(\"hello\", \"world\", \"java\"), \"python\"));\n        // Expected output: []\n\n        System.out.println(\"\\nTest Case 4: List with multiple occurrences of the substring\");\n        System.out.println(solution.filter_by_substring(Arrays.asList(\"aaa\", \"baa\", \"aab\", \"bba\"), \"aa\"));\n        // Expected output: [aaa, aab]\n    }\n}\n"}
{"task_id": "Java/8", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> sum_product(List<Integer> numbers) {\n        if (numbers.isEmpty()) {\n            return Arrays.asList(0, 1);\n        }\n\n        int totalSum = 0;\n        int totalProduct = 1;\n\n        for (int num : numbers) {\n            totalSum += num;\n            totalProduct *= num;\n        }\n\n        List<Integer> result = new ArrayList<>();\n        result.add(totalSum);\n        result.add(totalProduct);\n\n        return result;\n    }\n}\n"}
{"task_id": "Java/9", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * From a given list of integers, generate a list of rolling maximum element found until given moment in the sequence.\n     *\n     * @param numbers The input list of integers.\n     * @return A list containing the rolling maximum elements.\n     */\n    public List<Integer> rolling_max(List<Integer> numbers) {\n        if (numbers == null || numbers.isEmpty()) {\n            return Collections.emptyList();\n        }\n\n        List<Integer> result = new ArrayList<>();\n        int maxSoFar = Integer.MIN_VALUE;\n\n        for (int num : numbers) {\n            if (num > maxSoFar) {\n                maxSoFar = num;\n            }\n            result.add(maxSoFar);\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.rolling_max(Arrays.asList(1, 2, 3, 2, 3, 4, 2))); // [1, 2, 3, 3, 3, 4, 4]\n        System.out.println(solution.rolling_max(Arrays.asList()));                   // []\n        System.out.println(solution.rolling_max(Arrays.asList(5)));                  // [5]\n        System.out.println(solution.rolling_max(Arrays.asList(-1, -2, -3, -2, -3, -4, -2))); // [-1, -1, -1, -1, -1, -1, -1]\n    }\n}\n"}
{"task_id": "Java/10", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Test if given string is a palindrome\n     */\n    public boolean isPalindrome(String string) {\n        int i = 0;\n        int j = string.length() - 1;\n        while (i < j) {\n            if (string.charAt(i) != string.charAt(j)) {\n                return false;\n            }\n            i++;\n            j--;\n        }\n        return true;\n    }\n\n    /**\n     * Find the shortest palindrome that begins with a supplied string.\n     * Algorithm idea is simple:\n     * - Find the longest postfix of supplied string that is a palindrome.\n     * - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n     */\n    public String make_palindrome(String string) {\n        for (int i = 0; i < string.length(); i++) {\n            if (isPalindrome(string.substring(i))) {\n                String prefix = string.substring(0, i);\n                return string + new StringBuilder(prefix).reverse().toString();\n            }\n        }\n        return string;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.make_palindrome(\"\")); // \"\"\n        System.out.println(solution.make_palindrome(\"cat\")); // \"catac\"\n        System.out.println(solution.make_palindrome(\"cata\")); // \"catac\"\n    }\n}\n"}
{"task_id": "Java/11", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Input are two strings a and b consisting only of 1s and 0s.\n     * Perform binary XOR on these inputs and return result also as a string.\n     *\n     * @param a the first binary string\n     * @param b the second binary string\n     * @return the result of binary XOR operation as a string\n     */\n    public String string_xor(String a, String b) {\n        StringBuilder result = new StringBuilder();\n        int maxLength = Math.max(a.length(), b.length());\n        \n        // Pad both strings to have equal length\n        a = padStringToLength(a, maxLength);\n        b = padStringToLength(b, maxLength);\n\n        for (int i = 0; i < maxLength; i++) {\n            char bitA = a.charAt(i);\n            char bitB = b.charAt(i);\n            \n            // Perform XOR operation and append to result\n            if (bitA == bitB) {\n                result.append('0');\n            } else {\n                result.append('1');\n            }\n        }\n\n        return result.toString();\n    }\n\n    /**\n     * Pads the given string with '0's at the beginning to make it of specified length.\n     *\n     * @param str the input string\n     * @param length the desired length\n     * @return the padded string\n     */\n    private String padStringToLength(String str, int length) {\n        StringBuilder sb = new StringBuilder(str);\n        while (sb.length() < length) {\n            sb.insert(0, '0');\n        }\n        return sb.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.string_xor(\"010\", \"110\")); // Expected output: \"100\"\n        System.out.println(solution.string_xor(\"10101\", \"00111\")); // Expected output: \"10010\"\n        System.out.println(solution.string_xor(\"1111\", \"0000\")); // Expected output: \"1111\"\n        System.out.println(solution.string_xor(\"0000\", \"0000\")); // Expected output: \"0000\"\n        System.out.println(solution.string_xor(\"11111111\", \"00000000\")); // Expected output: \"11111111\"\n    }\n}\n"}
{"task_id": "Java/12", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     Out of list of strings, return the longest one. Return the first one in case of multiple\n     strings of the same length. Return Optional.empty() in case the input list is empty.\n     >>> longest(List.of())\n     Optional.empty\n     >>> longest(Arrays.asList(\"a\", \"b\", \"c\"))\n     Optional[a]\n     >>> longest(Arrays.asList(\"a\", \"bb\", \"ccc\"))\n     Optional[ccc]\n     */\n    public Optional<String> longest(List<String> strings) {\n        if (strings.isEmpty()) {\n            return Optional.empty();\n        }\n\n        String longestString = strings.get(0);\n        for (String str : strings) {\n            if (str.length() > longestString.length()) {\n                longestString = str;\n            }\n        }\n        \n        return Optional.of(longestString);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(\"Test Case 1: Empty List\");\n        System.out.println(solution.longest(List.of())); // Expected: Optional.empty\n\n        System.out.println(\"\\nTest Case 2: Single Element\");\n        System.out.println(solution.longest(Arrays.asList(\"a\"))); // Expected: Optional[a]\n\n        System.out.println(\"\\nTest Case 3: Multiple Elements with Different Lengths\");\n        System.out.println(solution.longest(Arrays.asList(\"a\", \"bb\", \"ccc\"))); // Expected: Optional[ccc]\n\n        System.out.println(\"\\nTest Case 4: Multiple Elements with Same Length\");\n        System.out.println(solution.longest(Arrays.asList(\"aa\", \"bbb\", \"cccc\"))); // Expected: Optional[cccc]\n    }\n}\n"}
{"task_id": "Java/13", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return a greatest common divisor of two integers a and b\n     *\n     * @param a first integer\n     * @param b second integer\n     * @return the greatest common divisor of a and b\n     */\n    public int greatest_common_divisor(int a, int b) {\n        while (b != 0) {\n            int temp = b;\n            b = a % b;\n            a = temp;\n        }\n        return a;\n    }\n\n    // Test cases to verify the correctness of the method\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1: GCD of 3 and 5 is 1\n        System.out.println(\"GCD of 3 and 5: \" + solution.greatest_common_divisor(3, 5)); // Expected output: 1\n\n        // Test case 2: GCD of 25 and 15 is 5\n        System.out.println(\"GCD of 25 and 15: \" + solution.greatest_common_divisor(25, 15)); // Expected output: 5\n\n        // Test case 3: GCD of 100 and 80 is 20\n        System.out.println(\"GCD of 100 and 80: \" + solution.greatest_common_divisor(100, 80)); // Expected output: 20\n\n        // Test case 4: GCD of 7 and 13 (both prime) is 1\n        System.out.println(\"GCD of 7 and 13: \" + solution.greatest_common_divisor(7, 13)); // Expected output: 1\n\n        // Test case 5: GCD of 0 and any number is that number (since gcd(0, b) = b)\n        System.out.println(\"GCD of 0 and 24: \" + solution.greatest_common_divisor(0, 24)); // Expected output: 24\n    }\n}\n"}
{"task_id": "Java/14", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Return list of all prefixes from shortest to longest of the input string\n     *\n     * @param string The input string\n     * @return A List containing all prefixes of the input string, ordered from shortest to longest\n     */\n    public List<String> all_prefixes(String string) {\n        List<String> prefixes = new ArrayList<>();\n        if (string == null || string.isEmpty()) {\n            return prefixes;\n        }\n        \n        for (int i = 1; i <= string.length(); i++) {\n            prefixes.add(string.substring(0, i));\n        }\n        \n        return prefixes;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(\"Testing all_prefixes(\\\"abc\\\"): \" + solution.all_prefixes(\"abc\")); // [\"a\", \"ab\", \"abc\"]\n        System.out.println(\"Testing all_prefixes(\\\"\\\"): \" + solution.all_prefixes(\"\")); // []\n        System.out.println(\"Testing all_prefixes(null): \" + solution.all_prefixes(null)); // []\n\n        // Additional test cases\n        System.out.println(\"Testing all_prefixes(\\\"hello\\\"): \" + solution.all_prefixes(\"hello\")); // [\"h\", \"he\", \"hel\", \"hell\", \"hello\"]\n        System.out.println(\"Testing all_prefixes(\\\"java\\\"): \" + solution.all_prefixes(\"java\")); // [\"j\", \"ja\", \"jav\", \"java\"]\n    }\n}\n"}
{"task_id": "Java/15", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Return a string containing space-delimited numbers starting from 0 up to n inclusive.\n     *\n     * @param n The upper limit of the sequence (inclusive).\n     * @return A string with space-separated numbers from 0 to n.\n     */\n    public String string_sequence(int n) {\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i <= n; i++) {\n            if (i > 0) {\n                sb.append(\" \");\n            }\n            sb.append(i);\n        }\n        return sb.toString();\n    }\n\n    // Test cases to verify the correctness of the string_sequence method\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1: n = 0\n        System.out.println(solution.string_sequence(0).equals(\"0\") ? \"Test 1 Passed\" : \"Test 1 Failed\");\n\n        // Test case 2: n = 5\n        System.out.println(solution.string_sequence(5).equals(\"0 1 2 3 4 5\") ? \"Test 2 Passed\" : \"Test 2 Failed\");\n\n        // Additional test cases\n        System.out.println(solution.string_sequence(10).equals(\"0 1 2 3 4 5 6 7 8 9 10\") ? \"Test 3 Passed\" : \"Test 3 Failed\");\n        System.out.println(solution.string_sequence(-1).equals(\"\") ? \"Test 4 Passed\" : \"Test 4 Failed\"); // Edge case: n < 0\n    }\n}\n"}
{"task_id": "Java/16", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given a string, find out how many distinct characters (regardless of case) does it consist of.\n     *\n     * @param string The input string to analyze.\n     * @return The number of distinct characters in the string, ignoring case.\n     */\n    public int count_distinct_characters(String string) {\n        // Convert the string to lowercase to ignore case\n        String lowerCaseString = string.toLowerCase();\n        \n        // Use a HashSet to store unique characters\n        Set<Character> uniqueChars = new HashSet<>();\n        \n        // Iterate through each character in the string and add it to the set\n        for (char c : lowerCaseString.toCharArray()) {\n            uniqueChars.add(c);\n        }\n        \n        // The size of the set is the number of distinct characters\n        return uniqueChars.size();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.count_distinct_characters(\"xyzXYZ\")); // Expected output: 3\n        System.out.println(solution.count_distinct_characters(\"Jerry\"));   // Expected output: 4\n        System.out.println(solution.count_distinct_characters(\"HelloWorld\")); // Expected output: 7\n        System.out.println(solution.count_distinct_characters(\"AAAaaa\"));    // Expected output: 1\n        System.out.println(solution.count_distinct_characters(\"\"));          // Expected output: 0\n        System.out.println(solution.count_distinct_characters(\"aAaAaA\"));    // Expected output: 1\n    }\n}\n"}
{"task_id": "Java/17", "generation": "import java.util.*;\n\nclass Solution {\n    public List<Integer> parse_music(String string) {\n        String[] notes = string.split(\" \");\n        List<Integer> beats = new ArrayList<>();\n        \n        for (String note : notes) {\n            switch (note) {\n                case \"o\":\n                    beats.add(4);\n                    break;\n                case \"o|\":\n                    beats.add(2);\n                    break;\n                case \".|\":\n                    beats.add(1);\n                    break;\n                default:\n                    // Handle any unexpected notes\n                    throw new IllegalArgumentException(\"Unexpected note: \" + note);\n            }\n        }\n        \n        return beats;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        List<Integer> result = solution.parse_music(\"o o| .| o| o| .| .| .| .| o o\");\n        System.out.println(result); // Expected output: [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    }\n}\n"}
{"task_id": "Java/18", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Find how many times a given substring can be found in the original string. Count overlapping cases.\n     *\n     * @param string The original string.\n     * @param substring The substring to find.\n     * @return The number of times the substring appears in the original string, including overlaps.\n     */\n    public int how_many_times(String string, String substring) {\n        if (substring.isEmpty()) return 0;\n        \n        int count = 0;\n        int index = 0;\n        \n        while ((index = string.indexOf(substring, index)) != -1) {\n            count++;\n            index++; // Move to the next character after the found substring to allow for overlapping matches\n        }\n        \n        return count;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.how_many_times(\"\", \"a\")); // Expected output: 0\n        System.out.println(solution.how_many_times(\"aaa\", \"a\")); // Expected output: 3\n        System.out.println(solution.how_many_times(\"aaaa\", \"aa\")); // Expected output: 3\n        System.out.println(solution.how_many_times(\"abababa\", \"aba\")); // Expected output: 3\n        System.out.println(solution.how_many_times(\"testtest\", \"test\")); // Expected output: 2\n    }\n}\n"}
{"task_id": "Java/19", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public String sort_numbers(String numbers) {\n        // Mapping of words to their corresponding numeric values\n        Map<String, Integer> wordToNum = new HashMap<>();\n        wordToNum.put(\"zero\", 0);\n        wordToNum.put(\"one\", 1);\n        wordToNum.put(\"two\", 2);\n        wordToNum.put(\"three\", 3);\n        wordToNum.put(\"four\", 4);\n        wordToNum.put(\"five\", 5);\n        wordToNum.put(\"six\", 6);\n        wordToNum.put(\"seven\", 7);\n        wordToNum.put(\"eight\", 8);\n        wordToNum.put(\"nine\", 9);\n\n        // Split the input string into words and convert them to their numeric values\n        String[] words = numbers.split(\" \");\n        List<Integer> nums = new ArrayList<>();\n        for (String word : words) {\n            nums.add(wordToNum.get(word));\n        }\n\n        // Sort the list of numeric values\n        Collections.sort(nums);\n\n        // Convert the sorted numeric values back to words\n        StringBuilder sortedWords = new StringBuilder();\n        for (int num : nums) {\n            for (Map.Entry<String, Integer> entry : wordToNum.entrySet()) {\n                if (entry.getValue() == num) {\n                    if (sortedWords.length() > 0) {\n                        sortedWords.append(\" \");\n                    }\n                    sortedWords.append(entry.getKey());\n                    break;\n                }\n            }\n        }\n\n        // Return the sorted string\n        return sortedWords.toString();\n    }\n}\n"}
{"task_id": "Java/20", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * From a supplied list of numbers (of length at least two) select and return two that are the closest to each other and return them in order (smaller number, larger number).\n     */\n    public List<Double> find_closest_elements(List<Double> numbers) {\n        if (numbers == null || numbers.size() < 2) {\n            throw new IllegalArgumentException(\"List must contain at least two elements.\");\n        }\n\n        double minDiff = Double.MAX_VALUE;\n        List<Double> closestElements = new ArrayList<>();\n\n        for (int i = 0; i < numbers.size(); i++) {\n            for (int j = i + 1; j < numbers.size(); j++) {\n                double diff = Math.abs(numbers.get(i) - numbers.get(j));\n                if (diff < minDiff) {\n                    minDiff = diff;\n                    closestElements.clear();\n                    closestElements.add(Math.min(numbers.get(i), numbers.get(j)));\n                    closestElements.add(Math.max(numbers.get(i), numbers.get(j)));\n                }\n            }\n        }\n\n        return closestElements;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.find_closest_elements(Arrays.asList(1.0, 2.0, 3.0, 4.0, 5.0, 2.2))); // [2.0, 2.2]\n        System.out.println(solution.find_closest_elements(Arrays.asList(1.0, 2.0, 3.0, 4.0, 5.0, 2.0)));  // [2.0, 2.0]\n        System.out.println(solution.find_closest_elements(Arrays.asList(-1.0, -2.0, -3.0, -4.0, -5.0, -2.2))); // [-2.2, -2.0]\n        System.out.println(solution.find_closest_elements(Arrays.asList(10.5, 10.6, 10.7, 10.8, 10.9))); // [10.5, 10.6]\n    }\n}\n"}
{"task_id": "Java/21", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given list of numbers (of at least two elements), apply a linear transform to that list,\n     * such that the smallest number will become 0 and the largest will become 1.\n     *\n     * @param numbers List of Double values\n     * @return A new list where each element is rescaled to the range [0, 1]\n     */\n    public List<Double> rescale_to_unit(List<Double> numbers) {\n        if (numbers == null || numbers.size() < 2) {\n            throw new IllegalArgumentException(\"List must contain at least two elements\");\n        }\n\n        double min = Collections.min(numbers);\n        double max = Collections.max(numbers);\n\n        List<Double> result = new ArrayList<>();\n        for (Double num : numbers) {\n            double scaledValue = (num - min) / (max - min);\n            result.add(scaledValue);\n        }\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        List<Double> test1 = Arrays.asList(1.0, 2.0, 3.0, 4.0, 5.0);\n        System.out.println(\"Test Case 1: \" + solution.rescale_to_unit(test1));\n        \n        List<Double> test2 = Arrays.asList(-1.0, -2.0, -3.0, -4.0, -5.0);\n        System.out.println(\"Test Case 2: \" + solution.rescale_to_unit(test2));\n        \n        List<Double> test3 = Arrays.asList(10.0, 20.0, 30.0, 40.0, 50.0);\n        System.out.println(\"Test Case 3: \" + solution.rescale_to_unit(test3));\n    }\n}\n"}
{"task_id": "Java/22", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> filter_integers(List<Object> values) {\n        List<Integer> integers = new ArrayList<>();\n        for (Object value : values) {\n            if (value instanceof Integer) {\n                integers.add((Integer) value);\n            }\n        }\n        return integers;\n    }\n}\n"}
{"task_id": "Java/23", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Return length of given string\n     * >>> strlen(\"\")\n     * 0\n     * >>> strlen(\"abc\")\n     * 3\n     */\n    public int strlen(String string) {\n        return string.length();\n    }\n\n    public static void main(String[] args) {\n        // Create an instance of Solution\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(\"Test Case 1: Empty String\");\n        System.out.println(\"Expected Output: 0\");\n        System.out.println(\"Actual Output: \" + solution.strlen(\"\"));\n        System.out.println();\n\n        System.out.println(\"Test Case 2: Single Character String\");\n        System.out.println(\"Expected Output: 1\");\n        System.out.println(\"Actual Output: \" + solution.strlen(\"a\"));\n        System.out.println();\n\n        System.out.println(\"Test Case 3: Multiple Characters String\");\n        System.out.println(\"Expected Output: 5\");\n        System.out.println(\"Actual Output: \" + solution.strlen(\"hello\"));\n        System.out.println();\n\n        System.out.println(\"Test Case 4: Longer String with Spaces and Special Characters\");\n        System.out.println(\"Expected Output: 12\");\n        System.out.println(\"Actual Output: \" + solution.strlen(\"Hello, world!\"));\n    }\n}\n"}
{"task_id": "Java/24", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * For a given number n, find the largest number that divides n evenly, smaller than n.\n     *\n     * @param n The input number.\n     * @return The largest divisor of n that is smaller than n.\n     */\n    public int largest_divisor(int n) {\n        for (int i = n / 2; i >= 1; i--) {\n            if (n % i == 0) {\n                return i;\n            }\n        }\n        // If no divisor found, which should not happen for positive integers,\n        // we return -1 as an error indicator.\n        return -1;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.largest_divisor(15));  // Expected output: 5\n        System.out.println(solution.largest_divisor(28));  // Expected output: 14\n        System.out.println(solution.largest_divisor(37));  // Expected output: -1 (since 37 is prime)\n        System.out.println(solution.largest_divisor(100)); // Expected output: 50\n    }\n}\n"}
{"task_id": "Java/25", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Return list of prime factors of given integer in the order from smallest to largest.\n     * Each of the factors should be listed number of times corresponding to how many times it appears in factorization.\n     * Input number should be equal to the product of all factors\n     *\n     * @param n the integer to factorize\n     * @return a list of prime factors\n     */\n    public List<Integer> factorize(int n) {\n        List<Integer> factors = new ArrayList<>();\n        for (int factor = 2; factor <= n; factor++) {\n            while (n % factor == 0) {\n                factors.add(factor);\n                n /= factor;\n            }\n        }\n        return factors;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(\"Factorize(8): \" + solution.factorize(8));   // Expected: [2, 2, 2]\n        System.out.println(\"Factorize(25): \" + solution.factorize(25));  // Expected: [5, 5]\n        System.out.println(\"Factorize(70): \" + solution.factorize(70));  // Expected: [2, 5, 7]\n        System.out.println(\"Factorize(49): \" + solution.factorize(49));  // Expected: [7, 7]\n        System.out.println(\"Factorize(1): \" + solution.factorize(1));    // Expected: []\n        System.out.println(\"Factorize(2): \" + solution.factorize(2));    // Expected: [2]\n    }\n}\n"}
{"task_id": "Java/26", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> remove_duplicates(List<Integer> numbers) {\n        Set<Integer> seen = new LinkedHashSet<>();\n        for (Integer num : numbers) {\n            seen.add(num);\n        }\n        return new ArrayList<>(seen);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.remove_duplicates(Arrays.asList(1, 2, 3, 2, 4))); // [1, 2, 3, 4]\n    }\n}\n"}
{"task_id": "Java/27", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n     *\n     * @param string The input string to be flipped.\n     * @return A new string with the case of each character flipped.\n     */\n    public String flip_case(String string) {\n        StringBuilder result = new StringBuilder();\n        for (char c : string.toCharArray()) {\n            if (Character.isUpperCase(c)) {\n                result.append(Character.toLowerCase(c));\n            } else {\n                result.append(Character.toUpperCase(c));\n            }\n        }\n        return result.toString();\n    }\n\n    // Test method to verify the correctness of flip_case\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.flip_case(\"Hello\"));  // Expected: \"hELLO\"\n        System.out.println(solution.flip_case(\"WORLD\"));  // Expected: \"world\"\n        System.out.println(solution.flip_case(\"Java\"));   // Expected: \"jAVA\"\n        System.out.println(solution.flip_case(\"123abcABC\"));  // Expected: \"123ABCabc\"\n        System.out.println(solution.flip_case(\"\"));       // Expected: \"\"\n    }\n}\n"}
{"task_id": "Java/28", "generation": "import java.util.Arrays;\nimport java.util.List;\n\nclass Solution {\n    /**\n     * Concatenate list of strings into a single string\n     *\n     * @param strings List of strings to concatenate\n     * @return A single concatenated string\n     */\n    public String concatenate(List<String> strings) {\n        StringBuilder sb = new StringBuilder();\n        for (String str : strings) {\n            sb.append(str);\n        }\n        return sb.toString();\n    }\n}\n\nclass TestSolution {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1: Empty list\n        List<String> emptyList = Arrays.asList();\n        System.out.println(\"Expected: '', Actual: '\" + solution.concatenate(emptyList) + \"'\");\n\n        // Test case 2: Single element list\n        List<String> singleElementList = Arrays.asList(\"a\");\n        System.out.println(\"Expected: 'a', Actual: '\" + solution.concatenate(singleElementList) + \"'\");\n\n        // Test case 3: Multiple elements list\n        List<String> multipleElementsList = Arrays.asList(\"a\", \"b\", \"c\");\n        System.out.println(\"Expected: 'abc', Actual: '\" + solution.concatenate(multipleElementsList) + \"'\");\n    }\n}\n"}
{"task_id": "Java/29", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Filter an input list of strings only for ones that start with a given prefix.\n     *\n     * @param strings The input list of strings.\n     * @param prefix  The prefix to filter the strings by.\n     * @return A list of strings that start with the given prefix.\n     */\n    public List<String> filter_by_prefix(List<String> strings, String prefix) {\n        return strings.stream()\n                      .filter(s -> s.startsWith(prefix))\n                      .collect(Collectors.toList());\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.filter_by_prefix(new ArrayList<>(), \"a\"));  // []\n        System.out.println(solution.filter_by_prefix(Arrays.asList(\"abc\", \"bcd\", \"cde\", \"array\"), \"a\"));  // [abc, array]\n        System.out.println(solution.filter_by_prefix(Arrays.asList(\"apple\", \"banana\", \"apricot\", \"cherry\"), \"a\"));  // [apple, apricot]\n    }\n}\n"}
{"task_id": "Java/30", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return only positive numbers in the list.\n     */\n    public List<Integer> get_positive(List<Integer> l) {\n        return l.stream()\n                .filter(num -> num > 0)\n                .collect(Collectors.toList());\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(\"Test Case 1: \" + testGetPositive(Arrays.asList(-1, 2, -4, 5, 6), Arrays.asList(2, 5, 6)));\n        System.out.println(\"Test Case 2: \" + testGetPositive(Arrays.asList(5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10), Arrays.asList(5, 3, 2, 3, 9, 123, 1)));\n    }\n\n    private static boolean testGetPositive(List<Integer> input, List<Integer> expected) {\n        Solution solution = new Solution();\n        List<Integer> result = solution.get_positive(input);\n        return result.equals(expected);\n    }\n}\n"}
{"task_id": "Java/31", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Return true if a given number is prime, and false otherwise.\n     */\n    public boolean is_prime(int n) {\n        // Handle edge cases for 0, 1, and negative numbers\n        if (n <= 1) {\n            return false;\n        }\n        \n        // Check divisibility from 2 to the square root of n\n        for (int i = 2; i <= Math.sqrt(n); i++) {\n            if (n % i == 0) {\n                return false;\n            }\n        }\n        \n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(\"is_prime(6): \" + !solution.is_prime(6));   // Expected: false\n        System.out.println(\"is_prime(101): \" + solution.is_prime(101)); // Expected: true\n        System.out.println(\"is_prime(11): \" + solution.is_prime(11));   // Expected: true\n        System.out.println(\"is_prime(13441): \" + !solution.is_prime(13441)); // Expected: false (13441 is not prime)\n        System.out.println(\"is_prime(61): \" + solution.is_prime(61));   // Expected: true\n        System.out.println(\"is_prime(4): \" + !solution.is_prime(4));    // Expected: false\n        System.out.println(\"is_prime(1): \" + !solution.is_prime(1));    // Expected: false\n    }\n}\n"}
{"task_id": "Java/32", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Evaluates polynomial with coefficients xs at point x.\n     * return xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n\n     */\n    public double poly(List<Double> xs, double x) {\n        double result = 0;\n        for (int i = 0; i < xs.size(); i++) {\n            result += xs.get(i) * Math.pow(x, i);\n        }\n        return result;\n    }\n\n    /**\n     * xs are coefficients of a polynomial.\n     * find_zero finds x such that poly(x) = 0.\n     * find_zero returns only one zero point, even if there are many.\n     * Moreover, find_zero only takes list xs having an even number of coefficients\n     * and guarantees a solution by ensuring the largest non-zero coefficient is at the end.\n     */\n    public double find_zero(List<Double> xs) {\n        if (xs.size() % 2 != 0) {\n            throw new IllegalArgumentException(\"The list of coefficients must have an even number of elements.\");\n        }\n\n        // Ensure the largest non-zero coefficient is at the end\n        List<Double> nonZeroCoefficients = new ArrayList<>();\n        for (double c : xs) {\n            if (c != 0) {\n                nonZeroCoefficients.add(c);\n            }\n        }\n        Collections.sort(nonZeroCoefficients, Comparator.comparingDouble(Math::abs).reversed());\n        \n        if (nonZeroCoefficients.isEmpty() || Math.abs(nonZeroCoefficients.get(0)) == 0) {\n            throw new IllegalArgumentException(\"There should be a non-zero coefficient to guarantee a solution.\");\n        }\n\n        double x = 0.5; // Initial guess\n        for (int i = 0; i < 100; i++) { // Run for a fixed number of iterations\n            double f_x = poly(xs, x);\n            double df_x = derivative(poly, xs, x); // Compute the derivative using Horner's method\n            x -= f_x / df_x;\n        }\n\n        return x;\n    }\n\n    private double derivative(Function<List<Double>, Double> poly, List<Double> coefficients, double x) {\n        double result = 0;\n        for (int i = 1; i < coefficients.size(); i++) {\n            result += i * coefficients.get(i) * Math.pow(x, i - 1);\n        }\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.find_zero(Arrays.asList(1.0, 2.0))); // f(x) = 1 + 2x\n        System.out.println(solution.find_zero(Arrays.asList(-6.0, 11.0, -6.0, 1.0))); // (x - 1) * (x - 2) * (x - 3)\n    }\n}\n"}
{"task_id": "Java/33", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * This function takes a list `l` and returns a list `l'` such that\n     * `l'` is identical to `l` in the indices that are not divisible by three, while its values at the indices that are divisible by three are equal\n     * to the values of the corresponding indices of `l`, but sorted in ascending order.\n     *\n     * @param l The input list.\n     * @return A new list with elements at indices divisible by three sorted.\n     */\n    public List<Integer> sort_third(List<Integer> l) {\n        // Extract elements at indices divisible by 3\n        List<Integer> third_indices = new ArrayList<>();\n        for (int i = 0; i < l.size(); i++) {\n            if ((i + 1) % 3 == 0) {\n                third_indices.add(l.get(i));\n            }\n        }\n\n        // Sort the extracted elements\n        Collections.sort(third_indices);\n\n        // Create a new list to store the result\n        List<Integer> l_prime = new ArrayList<>(l);\n\n        // Replace elements at indices divisible by three with sorted values\n        for (int i = 0, j = 0; i < l.size(); i++) {\n            if ((i + 1) % 3 == 0) {\n                l_prime.set(i, third_indices.get(j++));\n            }\n        }\n\n        return l_prime;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.sort_third(Arrays.asList(1, 2, 3))); // [1, 2, 3]\n        System.out.println(solution.sort_third(Arrays.asList(5, 6, 3, 4, 8, 9, 2))); // [2, 6, 3, 4, 8, 9, 5]\n    }\n}\n"}
{"task_id": "Java/34", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return sorted unique elements in a list\n     *\n     * @param l input list of integers\n     * @return a List containing sorted unique elements from the input list\n     */\n    public List<Integer> unique(List<Integer> l) {\n        Set<Integer> set = new TreeSet<>(l);\n        return new ArrayList<>(set);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.unique(Arrays.asList(5, 3, 5, 2, 3, 3, 9, 0, 123))); // [0, 2, 3, 5, 9, 123]\n        System.out.println(solution.unique(Arrays.asList())); // []\n        System.out.println(solution.unique(Arrays.asList(1, 2, 3))); // [1, 2, 3]\n        System.out.println(solution.unique(Arrays.asList(-1, -2, -3, -4, -5))); // [-5, -4, -3, -2, -1]\n        System.out.println(solution.unique(Arrays.asList(7, 8, 9, 7, 8, 9, 10))); // [7, 8, 9, 10]\n    }\n}\n"}
{"task_id": "Java/35", "generation": "import java.util.Arrays;\nimport java.util.List;\n\nclass Solution {\n\n    /**\n     * Return maximum element in the list.\n     */\n    public int max_element(List<Integer> l) {\n        if (l == null || l.isEmpty()) {\n            throw new IllegalArgumentException(\"List cannot be null or empty\");\n        }\n        \n        return l.stream().max(Integer::compare).get();\n    }\n\n    // Test cases to verify the correctness of the function\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        List<Integer> list1 = Arrays.asList(1, 2, 3);\n        System.out.println(\"Max element in \" + list1 + \": \" + solution.max_element(list1)); // Expected: 3\n\n        // Test case 2\n        List<Integer> list2 = Arrays.asList(5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10);\n        System.out.println(\"Max element in \" + list2 + \": \" + solution.max_element(list2)); // Expected: 123\n\n        // Test case 3\n        List<Integer> list3 = Arrays.asList(-1, -2, -3, -4);\n        System.out.println(\"Max element in \" + list3 + \": \" + solution.max_element(list3)); // Expected: -1\n\n        // Test case 4\n        List<Integer> list4 = Arrays.asList(0);\n        System.out.println(\"Max element in \" + list4 + \": \" + solution.max_element(list4)); // Expected: 0\n\n        // Test case 5 (edge case)\n        List<Integer> list5 = Arrays.asList();\n        try {\n            System.out.println(\"Max element in empty list: \" + solution.max_element(list5));\n        } catch (IllegalArgumentException e) {\n            System.out.println(e.getMessage()); // Expected: List cannot be null or empty\n        }\n    }\n}\n"}
{"task_id": "Java/36", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n\n    /**\n     * Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n     */\n    public int fizz_buzz(int n) {\n        int count = 0;\n        for (int i = 1; i < n; i++) {\n            if (i % 11 == 0 || i % 13 == 0) {\n                String numStr = Integer.toString(i);\n                for (char c : numStr.toCharArray()) {\n                    if (c == '7') {\n                        count++;\n                    }\n                }\n            }\n        }\n        return count;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(\"fizz_buzz(50): \" + solution.fizz_buzz(50)); // Expected: 0\n        System.out.println(\"fizz_buzz(78): \" + solution.fizz_buzz(78)); // Expected: 2\n        System.out.println(\"fizz_buzz(79): \" + solution.fizz_buzz(79)); // Expected: 3\n        System.out.println(\"fizz_buzz(100): \" + solution.fizz_buzz(100)); // Expected: 4 (77, 781, 782, 783)\n        System.out.println(\"fizz_buzz(150): \" + solution.fizz_buzz(150)); // Expected: 6\n    }\n}\n"}
{"task_id": "Java/37", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * This function takes a list l and returns a list l' such that\n     * l' is identical to l in the odd indicies, while its values at the even indicies are equal\n     * to the values of the even indicies of l, but sorted.\n     */\n    public List<Integer> sort_even(List<Integer> l) {\n        List<Integer> result = new ArrayList<>(l);\n        List<Integer> evenIndicesValues = new ArrayList<>();\n        \n        // Extract values at even indices\n        for (int i = 0; i < result.size(); i += 2) {\n            evenIndicesValues.add(result.get(i));\n        }\n        \n        // Sort the extracted values\n        Collections.sort(evenIndicesValues);\n        \n        // Place sorted values back into their original positions\n        int evenIndex = 0;\n        for (int i = 0; i < result.size(); i += 2) {\n            result.set(i, evenIndicesValues.get(evenIndex++));\n        }\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.sort_even(Arrays.asList(1, 2, 3))); // Expected: [1, 2, 3]\n        System.out.println(solution.sort_even(Arrays.asList(5, 6, 3, 4))); // Expected: [3, 6, 5, 4]\n        System.out.println(solution.sort_even(Arrays.asList(9, 8, 7, 6, 5, 4, 3, 2, 1))); // Expected: [3, 8, 7, 6, 5, 4, 9, 2, 1]\n        System.out.println(solution.sort_even(Arrays.asList())); // Expected: []\n    }\n}\n"}
{"task_id": "Java/38", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Encodes a string by cycling groups of three characters.\n     */\n    public String encodeCyclic(String s) {\n        // Split string into groups. Each group has length 3.\n        List<String> groups = new ArrayList<>();\n        for (int i = 0; i < s.length(); i += 3) {\n            groups.add(s.substring(i, Math.min(i + 3, s.length())));\n        }\n        // Cycle elements in each group unless the group has fewer than 3 characters.\n        for (int i = 0; i < groups.size(); i++) {\n            if (groups.get(i).length() == 3) {\n                groups.set(i, groups.get(i).substring(1) + groups.get(i).charAt(0));\n            }\n        }\n        return String.join(\"\", groups);\n    }\n\n    /**\n     * Takes a string encoded with `encodeCyclic` and returns the decoded string.\n     */\n    public String decodeCyclic(String s) {\n        // Split string into groups. Each group has length 3.\n        List<String> groups = new ArrayList<>();\n        for (int i = 0; i < s.length(); i += 3) {\n            groups.add(s.substring(i, Math.min(i + 3, s.length())));\n        }\n        // Reverse the cycling process in each group unless the group has fewer than 3 characters.\n        for (int i = 0; i < groups.size(); i++) {\n            if (groups.get(i).length() == 3) {\n                groups.set(i, groups.get(i).substring(groups.get(i).length() - 1) + groups.get(i).substring(0, groups.get(i).length() - 1));\n            }\n        }\n        return String.join(\"\", groups);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.encodeCyclic(\"hello\")); // Expected: \"elhlo\"\n        System.out.println(solution.decodeCyclic(\"elhlo\")); // Expected: \"hello\"\n    }\n}\n"}
{"task_id": "Java/39", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * prime_fib returns n-th number that is a Fibonacci number and it's also prime.\n     *\n     * @param n The position of the prime Fibonacci number to find.\n     * @return The n-th prime Fibonacci number.\n     */\n    public int prime_fib(int n) {\n        List<Integer> fibSequence = new ArrayList<>();\n        fibSequence.add(0); // 0th Fibonacci\n        fibSequence.add(1); // 1st Fibonacci\n\n        int primeCount = 0;\n        while (primeCount < n) {\n            int nextFib = fibSequence.get(fibSequence.size() - 1) + fibSequence.get(fibSequence.size() - 2);\n            fibSequence.add(nextFib);\n\n            if (isPrime(nextFib)) {\n                primeCount++;\n            }\n        }\n\n        return fibSequence.get(fibSequence.size() - 1);\n    }\n\n    /**\n     * isPrime checks if a given number is prime.\n     *\n     * @param num The number to check for primality.\n     * @return true if the number is prime, false otherwise.\n     */\n    private boolean isPrime(int num) {\n        if (num <= 1) {\n            return false;\n        }\n        for (int i = 2; i <= Math.sqrt(num); i++) {\n            if (num % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.prime_fib(1)); // Output: 2\n        System.out.println(solution.prime_fib(2)); // Output: 3\n        System.out.println(solution.prime_fib(3)); // Output: 5\n        System.out.println(solution.prime_fib(4)); // Output: 13\n        System.out.println(solution.prime_fib(5)); // Output: 89\n    }\n}\n"}
{"task_id": "Java/40", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * triples_sum_to_zero takes a list of integers as an input.\n     * it returns True if there are three distinct elements in the list that\n     * sum to zero, and False otherwise.\n     */\n    public boolean triples_sum_to_zero(List<Integer> l) {\n        // Sort the list to make it easier to find triplets that sum to zero\n        Collections.sort(l);\n        \n        for (int i = 0; i < l.size() - 2; i++) {\n            int left = i + 1;\n            int right = l.size() - 1;\n            \n            while (left < right) {\n                int sum = l.get(i) + l.get(left) + l.get(right);\n                \n                if (sum == 0) {\n                    return true;\n                } else if (sum < 0) {\n                    left++;\n                } else {\n                    right--;\n                }\n            }\n        }\n        \n        return false;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.triples_sum_to_zero(Arrays.asList(1, 3, 5, 0))); // false\n        System.out.println(solution.triples_sum_to_zero(Arrays.asList(1, 3, -2, 1))); // true\n        System.out.println(solution.triples_sum_to_zero(Arrays.asList(1, 2, 3, 7))); // false\n        System.out.println(solution.triples_sum_to_zero(Arrays.asList(2, 4, -5, 3, 9, 7))); // true\n        System.out.println(solution.triples_sum_to_zero(Arrays.asList(1))); // false\n    }\n}\n"}
{"task_id": "Java/41", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Imagine a road that's a perfectly straight infinitely long line.\n    n cars are driving left to right; simultaneously, a different set of n cars\n    are driving right to left. The two sets of cars start out being very far from each other.\n    All cars move in the same speed. Two cars are said to collide when a car that's moving left to right hits a car that's moving right to left.\n    However, the cars are infinitely sturdy and strong; as a result, they continue moving in their trajectory as if they did not collide.\n\n    This function outputs the number of such collisions.\n     */\n    public int car_race_collision(int n) {\n        // Since all cars are moving at the same speed and start far apart,\n        // each car from one direction will collide with exactly one car from the opposite direction.\n        return n;\n    }\n}\n"}
{"task_id": "Java/42", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return list with elements incremented by 1.\n     *\n     * @param l The input list of integers.\n     * @return A new list where each element is incremented by 1.\n     */\n    public List<Integer> incr_list(List<Integer> l) {\n        return l.stream().map(i -> i + 1).collect(Collectors.toList());\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        List<Integer> list1 = Arrays.asList(1, 2, 3);\n        System.out.println(\"Original: \" + list1);\n        System.out.println(\"Incremented: \" + solution.incr_list(list1));\n\n        // Test case 2\n        List<Integer> list2 = Arrays.asList(5, 3, 5, 2, 3, 3, 9, 0, 123);\n        System.out.println(\"Original: \" + list2);\n        System.out.println(\"Incremented: \" + solution.incr_list(list2));\n    }\n}\n"}
{"task_id": "Java/43", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * pairs_sum_to_zero takes a list of integers as an input.\n     * it returns True if there are two distinct elements in the list that\n     * sum to zero, and False otherwise.\n     */\n    public boolean pairs_sum_to_zero(List<Integer> l) {\n        Set<Integer> seen = new HashSet<>();\n        for (int num : l) {\n            if (seen.contains(-num)) {\n                return true;\n            }\n            seen.add(num);\n        }\n        return false;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.pairs_sum_to_zero(Arrays.asList(1, 3, 5, 0))); // false\n        System.out.println(solution.pairs_sum_to_zero(Arrays.asList(1, 3, -2, 1))); // false\n        System.out.println(solution.pairs_sum_to_zero(Arrays.asList(1, 2, 3, 7))); // false\n        System.out.println(solution.pairs_sum_to_zero(Arrays.asList(2, 4, -5, 3, 5, 7))); // true\n        System.out.println(solution.pairs_sum_to_zero(Arrays.asList(1))); // false\n    }\n}\n"}
{"task_id": "Java/44", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Change numerical base of input number x to base.\n     * return string representation after the conversion.\n     * base numbers are less than 10.\n     *\n     * @param x The number to be converted.\n     * @param base The target base for conversion (less than 10).\n     * @return String representation of the converted number.\n     */\n    public String change_base(int x, int base) {\n        if (x == 0) return \"0\";\n        \n        StringBuilder result = new StringBuilder();\n        while (x > 0) {\n            int remainder = x % base;\n            result.insert(0, remainder);\n            x /= base;\n        }\n        \n        return result.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.change_base(8, 3));  // Expected output: \"22\"\n        System.out.println(solution.change_base(8, 2));  // Expected output: \"1000\"\n        System.out.println(solution.change_base(7, 2));  // Expected output: \"111\"\n        System.out.println(solution.change_base(255, 16)); // Expected output: \"FF\" (for base 16)\n        System.out.println(solution.change_base(10, 8));  // Expected output: \"12\"\n    }\n}\n"}
{"task_id": "Java/45", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given length of a side (base) and height, return area for a triangle.\n     *\n     * @param a The base of the triangle.\n     * @param h The height of the triangle.\n     * @return The area of the triangle.\n     */\n    public double triangle_area(double a, double h) {\n        return 0.5 * a * h;\n    }\n\n    /**\n     * Main method to run test cases for the triangle_area function.\n     *\n     * @param args Command line arguments (not used).\n     */\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(\"Test Case 1: Base = 5, Height = 3\");\n        double result1 = solution.triangle_area(5, 3);\n        System.out.println(\"Expected: 7.5, Actual: \" + result1);\n\n        System.out.println(\"\\nTest Case 2: Base = 10, Height = 4\");\n        double result2 = solution.triangle_area(10, 4);\n        System.out.println(\"Expected: 20.0, Actual: \" + result2);\n\n        System.out.println(\"\\nTest Case 3: Base = 7, Height = 8\");\n        double result3 = solution.triangle_area(7, 8);\n        System.out.println(\"Expected: 28.0, Actual: \" + result3);\n\n        // Add more test cases as needed\n    }\n}\n"}
{"task_id": "Java/46", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n    The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n    fib4(0) -> 0\n    fib4(1) -> 0\n    fib4(2) -> 2\n    fib4(3) -> 0\n    fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n    Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.\n    >>> fib4(5)\n    4\n    >>> fib4(6)\n    8\n    >>> fib4(7)\n    14\n     */\n    public int fib4(int n) {\n        if (n == 0 || n == 1) return 0;\n        if (n == 2) return 2;\n        if (n == 3) return 0;\n\n        int[] dp = new int[n + 1];\n        dp[0] = 0;\n        dp[1] = 0;\n        dp[2] = 2;\n        dp[3] = 0;\n\n        for (int i = 4; i <= n; i++) {\n            dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3] + dp[i - 4];\n        }\n\n        return dp[n];\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.fib4(5)); // Expected output: 4\n        System.out.println(solution.fib4(6)); // Expected output: 8\n        System.out.println(solution.fib4(7)); // Expected output: 14\n        System.out.println(solution.fib4(8)); // Expected output: 24\n        System.out.println(solution.fib4(9)); // Expected output: 44\n    }\n}\n"}
{"task_id": "Java/47", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return median of elements in the list l.\n     */\n    public double median(List<Integer> l) {\n        if (l == null || l.isEmpty()) {\n            throw new IllegalArgumentException(\"List cannot be null or empty\");\n        }\n\n        Collections.sort(l);\n        int size = l.size();\n        if (size % 2 == 0) {\n            return (l.get(size / 2 - 1) + l.get(size / 2)) / 2.0;\n        } else {\n            return l.get(size / 2);\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        List<Integer> testList1 = Arrays.asList(3, 1, 2, 4, 5);\n        System.out.println(\"Median of [3, 1, 2, 4, 5]: \" + solution.median(testList1)); // Expected: 3\n\n        List<Integer> testList2 = Arrays.asList(-10, 4, 6, 1000, 10, 20);\n        System.out.println(\"Median of [-10, 4, 6, 1000, 10, 20]: \" + solution.median(testList2)); // Expected: 8.0\n\n        List<Integer> testList3 = Arrays.asList(1, 2, 3, 4);\n        System.out.println(\"Median of [1, 2, 3, 4]: \" + solution.median(testList3)); // Expected: 2.5\n\n        List<Integer> testList4 = Arrays.asList(-5, -3, -1, 0, 2, 4, 6);\n        System.out.println(\"Median of [-5, -3, -1, 0, 2, 4, 6]: \" + solution.median(testList4)); // Expected: 0.0\n\n        List<Integer> testList5 = Arrays.asList();\n        try {\n            System.out.println(\"Median of []: \" + solution.median(testList5));\n        } catch (IllegalArgumentException e) {\n            System.out.println(\"Caught expected exception for empty list: \" + e.getMessage());\n        }\n\n        List<Integer> testList6 = null;\n        try {\n            System.out.println(\"Median of null: \" + solution.median(testList6));\n        } catch (IllegalArgumentException e) {\n            System.out.println(\"Caught expected exception for null list: \" + e.getMessage());\n        }\n    }\n}\n"}
{"task_id": "Java/48", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     Checks if given string is a palindrome\n     >>> is_palindrome(\"\")\n     true\n     >>> is_palindrome(\"aba\")\n     true\n     >>> is_palindrome(\"aaaaa\")\n     true\n     >>> is_palindrome(\"zbcd\")\n     false\n     */\n    public boolean is_palindrome(String text) {\n        int left = 0;\n        int right = text.length() - 1;\n\n        while (left < right) {\n            if (text.charAt(left) != text.charAt(right)) {\n                return false;\n            }\n            left++;\n            right--;\n        }\n\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.is_palindrome(\"\"));       // true\n        System.out.println(solution.is_palindrome(\"aba\"));    // true\n        System.out.println(solution.is_palindrome(\"aaaaa\"));  // true\n        System.out.println(solution.is_palindrome(\"zbcd\"));   // false\n        System.out.println(solution.is_palindrome(\"level\"));  // true\n        System.out.println(solution.is_palindrome(\"noon\"));   // true\n        System.out.println(solution.is_palindrome(\"abcde\"));  // false\n    }\n}\n"}
{"task_id": "Java/49", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return 2^n modulo p (be aware of numerics).\n     */\n    public int modp(int n, int p) {\n        if (n == 0) return 1; // Base case: 2^0 = 1\n        long result = 1;\n        for (int i = 0; i < n; i++) {\n            result = (result * 2) % p;\n        }\n        return (int) result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.modp(3, 5));   // Expected output: 3\n        System.out.println(solution.modp(1101, 101)); // Expected output: 2\n        System.out.println(solution.modp(0, 101));  // Expected output: 1\n        System.out.println(solution.modp(3, 11));   // Expected output: 8\n        System.out.println(solution.modp(100, 101)); // Expected output: 1\n    }\n}\n"}
{"task_id": "Java/50", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    returns encoded string by shifting every character by 5 in the alphabet.\n     */\n    public String encodeShift(String s) {\n        StringBuilder sb = new StringBuilder();\n        for (char ch : s.toCharArray()) {\n            sb.append((char) ('a' + ((ch - 'a' + 5) % 26)));\n        }\n        return sb.toString();\n    }\n\n    /**\n    takes as input string encoded with encodeShift function. Returns decoded string.\n     */\n    public String decode_shift(String s) {\n        StringBuilder sb = new StringBuilder();\n        for (char ch : s.toCharArray()) {\n            sb.append((char) ('a' + ((ch - 'a' - 5 + 26) % 26)));\n        }\n        return sb.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        String encoded = solution.encodeShift(\"hello\");\n        System.out.println(\"Encoded: \" + encoded);\n        String decoded = solution.decode_shift(encoded);\n        System.out.println(\"Decoded: \" + decoded);\n    }\n}\n"}
{"task_id": "Java/51", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * remove_vowels is a function that takes string and returns string without vowels.\n     */\n    public String remove_vowels(String text) {\n        if (text == null || text.isEmpty()) {\n            return text;\n        }\n        \n        StringBuilder result = new StringBuilder();\n        for (char c : text.toCharArray()) {\n            if (!isVowel(c)) {\n                result.append(c);\n            }\n        }\n        return result.toString();\n    }\n\n    private boolean isVowel(char c) {\n        return \"AEIOUaeiou\".indexOf(c) != -1;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.remove_vowels(\"\")); // Output: \"\"\n        System.out.println(solution.remove_vowels(\"abcdef\\nghijklm\")); // Output: \"bcdf\\nghjklm\"\n        System.out.println(solution.remove_vowels(\"abcdef\")); // Output: \"bcdf\"\n        System.out.println(solution.remove_vowels(\"aaaaa\")); // Output: \"\"\n        System.out.println(solution.remove_vowels(\"aaBAA\")); // Output: \"B\"\n        System.out.println(solution.remove_vowels(\"zbcd\")); // Output: \"zbcd\"\n    }\n}\n"}
{"task_id": "Java/52", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return True if all numbers in the list l are below threshold t.\n     */\n    public boolean below_threshold(List<Integer> l, int t) {\n        for (int num : l) {\n            if (num >= t) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.below_threshold(Arrays.asList(1, 2, 4, 10), 100)); // Expected: true\n        System.out.println(solution.below_threshold(Arrays.asList(1, 20, 4, 10), 5));  // Expected: false\n        System.out.println(solution.below_threshold(Arrays.asList(-1, -2, -3), 0));    // Expected: true\n        System.out.println(solution.below_threshold(Arrays.asList(), 100));            // Expected: true (empty list)\n        System.out.println(solution.below_threshold(Arrays.asList(99, 100, 101), 100)); // Expected: false\n    }\n}\n"}
{"task_id": "Java/53", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Add two numbers x and y\n     *\n     * @param x the first number\n     * @param y the second number\n     * @return the sum of x and y\n     */\n    public int add(int x, int y) {\n        return x + y;\n    }\n}\n"}
{"task_id": "Java/54", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Check if two words have the same kind of characters.\n     */\n    public boolean same_chars(String s0, String s1) {\n        // Convert both strings to sets of characters\n        Set<Character> set0 = new HashSet<>();\n        for (char c : s0.toCharArray()) {\n            set0.add(c);\n        }\n        \n        Set<Character> set1 = new HashSet<>();\n        for (char c : s1.toCharArray()) {\n            set1.add(c);\n        }\n        \n        // Compare the sets\n        return set0.equals(set1);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.same_chars(\"eabcdzzzz\", \"dddzzzzzzzddeddabc\")); // true\n        System.out.println(solution.same_chars(\"abcd\", \"dddddddabc\"));              // true\n        System.out.println(solution.same_chars(\"dddddddabc\", \"abcd\"));              // true\n        System.out.println(solution.same_chars(\"eabcd\", \"dddddddabc\"));             // false\n        System.out.println(solution.same_chars(\"abcd\", \"dddddddabce\"));             // false\n        System.out.println(solution.same_chars(\"eabcdzzzz\", \"dddzzzzzzzddddabc\"));  // false\n    }\n}\n"}
{"task_id": "Java/55", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return n-th Fibonacci number.\n     * >>> fib(10)\n     * 55\n     * >>> fib(1)\n     * 1\n     * >>> fib(8)\n     * 21\n     */\n    public int fib(int n) {\n        if (n <= 0) {\n            return 0;\n        } else if (n == 1) {\n            return 1;\n        }\n        \n        int a = 0, b = 1, c = 0;\n        for (int i = 2; i <= n; i++) {\n            c = a + b;\n            a = b;\n            b = c;\n        }\n        return b;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(\"fib(10): \" + solution.fib(10)); // Expected: 55\n        System.out.println(\"fib(1): \" + solution.fib(1));   // Expected: 1\n        System.out.println(\"fib(8): \" + solution.fib(8));   // Expected: 21\n        System.out.println(\"fib(0): \" + solution.fib(0));   // Expected: 0\n        System.out.println(\"fib(-5): \" + solution.fib(-5)); // Expected: 0 (or handle as an error)\n    }\n}\n"}
{"task_id": "Java/56", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * brackets is a string of \"<\" and \">\".\n     * return True if every opening bracket has a corresponding closing bracket.\n     *\n     * >>> correct_bracketing(\"<\")\n     * false\n     * >>> correct_bracketing(\"<>\")\n     * true\n     * >>> correct_bracketing(\"<<><>>\")\n     * true\n     * >>> correct_bracketing(\"><<>\")\n     * false\n     */\n    public boolean correct_bracketing(String brackets) {\n        int balance = 0;\n        for (char c : brackets.toCharArray()) {\n            if (c == '<') {\n                balance++;\n            } else if (c == '>') {\n                balance--;\n            }\n            // If at any point the balance is negative, it means there's a closing bracket without an opening one\n            if (balance < 0) {\n                return false;\n            }\n        }\n        // If the balance is zero, all brackets are correctly matched\n        return balance == 0;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.correct_bracketing(\"<\"));      // false\n        System.out.println(solution.correct_bracketing(\"<>\"));     // true\n        System.out.println(solution.correct_bracketing(\"<<><>>\")); // true\n        System.out.println(solution.correct_bracketing(\"><<>\"));   // false\n    }\n}\n"}
{"task_id": "Java/57", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public boolean monotonic(List<Integer> l) {\n        boolean increasing = true;\n        boolean decreasing = true;\n\n        for (int i = 1; i < l.size(); i++) {\n            if (!increasing && !decreasing) {\n                break;\n            }\n            if (l.get(i) < l.get(i - 1)) {\n                increasing = false;\n            }\n            if (l.get(i) > l.get(i - 1)) {\n                decreasing = false;\n            }\n        }\n\n        return increasing || decreasing;\n    }\n}\n"}
{"task_id": "Java/58", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return sorted unique common elements for two lists.\n     */\n    public List<Integer> common(List<Integer> l1, List<Integer> l2) {\n        Set<Integer> set1 = new HashSet<>(l1);\n        Set<Integer> set2 = new HashSet<>(l2);\n\n        // Retain only the elements that are present in both sets\n        set1.retainAll(set2);\n\n        // Convert the resulting set to a sorted list\n        List<Integer> result = new ArrayList<>(set1);\n        Collections.sort(result);\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        List<Integer> l1 = Arrays.asList(1, 4, 3, 34, 653, 2, 5);\n        List<Integer> l2 = Arrays.asList(5, 7, 1, 5, 9, 653, 121);\n        System.out.println(\"Common elements (Test case 1): \" + solution.common(l1, l2)); // Expected: [1, 5, 653]\n\n        // Test case 2\n        List<Integer> l3 = Arrays.asList(5, 3, 2, 8);\n        List<Integer> l4 = Arrays.asList(3, 2);\n        System.out.println(\"Common elements (Test case 2): \" + solution.common(l3, l4)); // Expected: [2, 3]\n\n        // Test case 3\n        List<Integer> l5 = Arrays.asList(10, 20, 30, 40);\n        List<Integer> l6 = Arrays.asList(50, 60, 70);\n        System.out.println(\"Common elements (Test case 3): \" + solution.common(l5, l6)); // Expected: []\n\n        // Test case 4\n        List<Integer> l7 = Arrays.asList(1, 2, 3, 4, 5);\n        List<Integer> l8 = Arrays.asList(3, 4, 5, 6, 7);\n        System.out.println(\"Common elements (Test case 4): \" + solution.common(l7, l8)); // Expected: [3, 4, 5]\n    }\n}\n"}
{"task_id": "Java/59", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int largest_prime_factor(int n) {\n        int i = 2;\n        while (i * i <= n) {\n            if (n % i != 0) {\n                i += 1;\n            } else {\n                n /= i;\n            }\n        }\n        return n;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.largest_prime_factor(13195)); // Output: 29\n        System.out.println(solution.largest_prime_factor(2048));  // Output: 2\n    }\n}\n"}
{"task_id": "Java/60", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * sum_to_n is a function that sums numbers from 1 to n.\n     */\n    public int sum_to_n(int n) {\n        return (n * (n + 1)) / 2;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(\"sum_to_n(30): \" + solution.sum_to_n(30)); // Expected: 465\n        System.out.println(\"sum_to_n(100): \" + solution.sum_to_n(100)); // Expected: 5050\n        System.out.println(\"sum_to_n(5): \" + solution.sum_to_n(5)); // Expected: 15\n        System.out.println(\"sum_to_n(10): \" + solution.sum_to_n(10)); // Expected: 55\n        System.out.println(\"sum_to_n(1): \" + solution.sum_to_n(1)); // Expected: 1\n    }\n}\n"}
{"task_id": "Java/61", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * brackets is a string of \"(\" and \")\".\n     * return True if every opening bracket has a corresponding closing bracket.\n     *\n     * >>> correct_bracketing(\"(\")\n     * false\n     * >>> correct_bracketing(\"()\")\n     * true\n     * >>> correct_bracketing(\"(()())\")\n     * true\n     * >>> correct_bracketing(\")(()\")\n     * false\n     */\n    public boolean correct_bracketing(String brackets) {\n        Stack<Character> stack = new Stack<>();\n        \n        for (char c : brackets.toCharArray()) {\n            if (c == '(') {\n                stack.push(c);\n            } else if (c == ')') {\n                if (stack.isEmpty()) {\n                    return false;\n                }\n                stack.pop();\n            }\n        }\n        \n        return stack.isEmpty();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.correct_bracketing(\"(\"));       // Output: false\n        System.out.println(solution.correct_bracketing(\"()\"));      // Output: true\n        System.out.println(solution.correct_bracketing(\"(()())\"));  // Output: true\n        System.out.println(solution.correct_bracketing(\")(()\"));    // Output: false\n        System.out.println(solution.correct_bracketing(\"(())\"));    // Output: true\n        System.out.println(solution.correct_bracketing(\"()()\"));    // Output: true\n        System.out.println(solution.correct_bracketing(\"(()\"));     // Output: false\n        System.out.println(solution.correct_bracketing(\")(\"));      // Output: false\n    }\n}\n"}
{"task_id": "Java/62", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * xs represent coefficients of a polynomial.\n     * xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     * Return derivative of this polynomial in the same form.\n     */\n    public List<Integer> derivative(List<Integer> xs) {\n        if (xs == null || xs.isEmpty()) {\n            return Collections.emptyList();\n        }\n        \n        List<Integer> result = new ArrayList<>();\n        for (int i = 1; i < xs.size(); i++) {\n            result.add(xs.get(i) * i);\n        }\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(\"Derivative of [3, 1, 2, 4, 5]: \" + solution.derivative(Arrays.asList(3, 1, 2, 4, 5)));\n        System.out.println(\"Derivative of [1, 2, 3]: \" + solution.derivative(Arrays.asList(1, 2, 3)));\n\n        // Additional test cases\n        System.out.println(\"Derivative of [0, 1, 2, 3]: \" + solution.derivative(Arrays.asList(0, 1, 2, 3)));\n        System.out.println(\"Derivative of [5]: \" + solution.derivative(Arrays.asList(5)));\n        System.out.println(\"Derivative of []: \" + solution.derivative(new ArrayList<>()));\n    }\n}\n"}
{"task_id": "Java/63", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     The FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n     fibfib(0) == 0\n     fibfib(1) == 0\n     fibfib(2) == 1\n     fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n     Please write a function to efficiently compute the n-th element of the fibfib number sequence.\n     >>> fibfib(1)\n     0\n     >>> fibfib(5)\n     4\n     >>> fibfib(8)\n     24\n      */\n    public int fibfib(int n) {\n        if (n == 0 || n == 1) return 0;\n        if (n == 2) return 1;\n\n        int a = 0, b = 0, c = 1;\n        for (int i = 3; i <= n; i++) {\n            int temp = a + b + c;\n            a = b;\n            b = c;\n            c = temp;\n        }\n        return c;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.fibfib(1));  // Expected output: 0\n        System.out.println(solution.fibfib(5));  // Expected output: 4\n        System.out.println(solution.fibfib(8));  // Expected output: 24\n        System.out.println(solution.fibfib(10)); // Expected output: 76\n    }\n}\n"}
{"task_id": "Java/64", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Write a function vowels_count which takes a string representing\n     * a word as input and returns the number of vowels in the string.\n     * Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n     * vowel, but only when it is at the end of the given word.\n     *\n     * Example:\n     * >>> vowels_count(\"abcde\")\n     * 2\n     * >>> vowels_count(\"ACEDY\")\n     * 3\n     */\n    public int vowels_count(String s) {\n        int count = 0;\n        for (int i = 0; i < s.length(); i++) {\n            char c = Character.toLowerCase(s.charAt(i));\n            if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n                count++;\n            } else if (c == 'y' && i == s.length() - 1) {\n                count++;\n            }\n        }\n        return count;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.vowels_count(\"abcde\")); // Expected output: 2\n        System.out.println(solution.vowels_count(\"ACEDY\")); // Expected output: 3\n        System.out.println(solution.vowels_count(\"rhythm\")); // Expected output: 0\n        System.out.println(solution.vowels_count(\"encyclopedia\")); // Expected output: 6\n        System.out.println(solution.vowels_count(\"quickly\")); // Expected output: 1\n    }\n}\n"}
{"task_id": "Java/65", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public String circular_shift(int x, int shift) {\n        String strX = Integer.toString(x);\n        int n = strX.length();\n        \n        if (shift >= n) {\n            return new StringBuilder(strX).reverse().toString();\n        }\n        \n        shift %= n;  // In case shift is larger than the number of digits\n        \n        String shiftedStr = strX.substring(n - shift) + strX.substring(0, n - shift);\n        return shiftedStr;\n    }\n}\n"}
{"task_id": "Java/66", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Write a function that takes a string as input and returns the sum of the upper characters only ASCII codes.\n     *\n     * Examples:\n     * digitSum(\"\") => 0\n     * digitSum(\"abAB\") => 131\n     * digitSum(\"abcCd\") => 67\n     * digitSum(\"helloE\") => 69\n     * digitSum(\"woArBld\") => 131\n     * digitSum(\"aAaaaXa\") => 153\n     */\n    public int digitSum(String s) {\n        int sum = 0;\n        for (char c : s.toCharArray()) {\n            if (Character.isUpperCase(c)) {\n                sum += c;\n            }\n        }\n        return sum;\n    }\n\n    // Test cases to verify the correctness of the method\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.digitSum(\"\")); // Expected output: 0\n        System.out.println(solution.digitSum(\"abAB\")); // Expected output: 131 ('A' + 'B')\n        System.out.println(solution.digitSum(\"abcCd\")); // Expected output: 67 ('C' + 'D')\n        System.out.println(solution.digitSum(\"helloE\")); // Expected output: 69 ('E')\n        System.out.println(solution.digitSum(\"woArBld\")); // Expected output: 131 ('A' + 'B' + 'L' + 'D')\n        System.out.println(solution.digitSum(\"aAaaaXa\")); // Expected output: 153 ('A' * 4 + 'X')\n    }\n}\n"}
{"task_id": "Java/67", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * In this task, you will be given a string that represents a number of apples and oranges\n     * that are distributed in a basket of fruit. The basket contains apples, oranges, and mango fruits.\n     * Given the string that represents the total number of the oranges and apples and an integer that represent the total number of the fruits\n     * in the basket return the number of the mango fruits in the basket.\n     *\n     * @param s a string representing the number of apples and oranges (e.g., \"5 apples and 6 oranges\")\n     * @param n the total number of fruits in the basket\n     * @return the number of mango fruits in the basket\n     */\n    public int fruit_distribution(String s, int n) {\n        // Extract the numbers from the string\n        String[] parts = s.split(\" \");\n        int apples = Integer.parseInt(parts[0]);\n        int oranges = Integer.parseInt(parts[3]);\n\n        // Calculate the number of mangoes\n        return n - (apples + oranges);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.fruit_distribution(\"5 apples and 6 oranges\", 19)); // Expected output: 8\n        System.out.println(solution.fruit_distribution(\"0 apples and 1 oranges\", 3));   // Expected output: 2\n        System.out.println(solution.fruit_distribution(\"2 apples and 3 oranges\", 100)); // Expected output: 95\n        System.out.println(solution.fruit_distribution(\"100 apples and 1 oranges\", 120)); // Expected output: 19\n    }\n}\n"}
{"task_id": "Java/68", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given an array representing a branch of a tree that has non-negative integer nodes,\n     * your task is to pluck one of the nodes and return it.\n     * The plucked node should be the node with the smallest even value.\n     * If multiple nodes with the same smallest even value are found, return the node that has the smallest index.\n     *\n     * @param arr the list of integer values representing tree branch nodes\n     * @return a list containing the smallest even value and its index, or an empty list if no valid node is found\n     */\n    public List<Integer> pluck(List<Integer> arr) {\n        int minEvenValue = Integer.MAX_VALUE;\n        int minIndex = -1;\n\n        for (int i = 0; i < arr.size(); i++) {\n            int value = arr.get(i);\n            if (value % 2 == 0 && value <= minEvenValue) {\n                if (value < minEvenValue || (value == minEvenValue && i < minIndex)) {\n                    minEvenValue = value;\n                    minIndex = i;\n                }\n            }\n        }\n\n        if (minIndex == -1) {\n            return new ArrayList<>();\n        } else {\n            return Arrays.asList(minEvenValue, minIndex);\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.pluck(Arrays.asList(4, 2, 3))); // Output: [2, 1]\n        System.out.println(solution.pluck(Arrays.asList(1, 2, 3))); // Output: [2, 1]\n        System.out.println(solution.pluck(Arrays.asList()));       // Output: []\n        System.out.println(solution.pluck(Arrays.asList(5, 0, 3, 0, 4, 2))); // Output: [0, 1]\n    }\n}\n"}
{"task_id": "Java/69", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * You are given a non-empty list of positive integers. Return the greatest integer that is greater than\n     * zero, and has a frequency greater than or equal to the value of the integer itself.\n     * The frequency of an integer is the number of times it appears in the list.\n     * If no such a value exist, return -1.\n     *\n     * Examples:\n     * search(Arrays.asList(4, 1, 2, 2, 3, 1)) == 2\n     * search(Arrays.asList(1, 2, 2, 3, 3, 3, 4, 4, 4)) == 3\n     * search(Arrays.asList(5, 5, 4, 4, 4)) == -1\n     */\n    public int search(List<Integer> lst) {\n        Map<Integer, Integer> frequencyMap = new HashMap<>();\n        \n        // Count the frequency of each integer in the list\n        for (int num : lst) {\n            frequencyMap.put(num, frequencyMap.getOrDefault(num, 0) + 1);\n        }\n        \n        int result = -1;\n        \n        // Check which integers meet the criteria and find the greatest one\n        for (Map.Entry<Integer, Integer> entry : frequencyMap.entrySet()) {\n            if (entry.getKey() <= entry.getValue()) {\n                result = Math.max(result, entry.getKey());\n            }\n        }\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.search(Arrays.asList(4, 1, 2, 2, 3, 1))); // Expected output: 2\n        System.out.println(solution.search(Arrays.asList(1, 2, 2, 3, 3, 3, 4, 4, 4))); // Expected output: 3\n        System.out.println(solution.search(Arrays.asList(5, 5, 4, 4, 4))); // Expected output: -1\n        System.out.println(solution.search(Arrays.asList(6, 6, 6, 7, 7, 8, 8, 8, 8))); // Expected output: 8\n    }\n}\n"}
{"task_id": "Java/70", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given list of integers, return list in strange order.\n     * Strange sorting, is when you start with the minimum value,\n     * then maximum of the remaining integers, then minimum and so on.\n     *\n     * Examples:\n     * strange_sort_list(Arrays.asList(1, 2, 3, 4)) == Arrays.asList(1, 4, 2, 3)\n     * strange_sort_list(Arrays.asList(5, 5, 5, 5)) == Arrays.asList(5, 5, 5, 5)\n     * strange_sort_list(Arrays.asList()) == Arrays.asList()\n     */\n    public List<Integer> strange_sort_list(List<Integer> lst) {\n        List<Integer> result = new ArrayList<>();\n        while (!lst.isEmpty()) {\n            // Add the minimum value\n            int minVal = Collections.min(lst);\n            result.add(minVal);\n            lst.remove(Integer.valueOf(minVal));\n            \n            if (lst.isEmpty()) break;\n            \n            // Add the maximum value\n            int maxVal = Collections.max(lst);\n            result.add(maxVal);\n            lst.remove(Integer.valueOf(maxVal));\n        }\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.strange_sort_list(Arrays.asList(1, 2, 3, 4))); // Expected: [1, 4, 2, 3]\n        System.out.println(solution.strange_sort_list(Arrays.asList(5, 5, 5, 5))); // Expected: [5, 5, 5, 5]\n        System.out.println(solution.strange_sort_list(Arrays.asList()));           // Expected: []\n        System.out.println(solution.strange_sort_list(Arrays.asList(10, 20, 30, 40, 50))); // Expected: [10, 50, 20, 40, 30]\n    }\n}\n"}
{"task_id": "Java/71", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n\n    /**\n     * Given the lengths of the three sides of a triangle. Return the area of\n     * the triangle rounded to 2 decimal points if the three sides form a valid triangle.\n     * Otherwise return -1.\n     * Three sides make a valid triangle when the sum of any two sides is greater\n     * than the third side.\n     * Example:\n     * triangle_area(3, 4, 5) == 6.00\n     * triangle_area(1, 2, 10) == -1\n     */\n    public double triangle_area(double a, double b, double c) {\n        // Check if the sides form a valid triangle\n        if (a + b <= c || a + c <= b || b + c <= a) {\n            return -1;\n        }\n        \n        // Calculate the semi-perimeter\n        double s = (a + b + c) / 2.0;\n\n        // Calculate the area using Heron's formula\n        double area = Math.sqrt(s * (s - a) * (s - b) * (s - c));\n        \n        // Round to 2 decimal points\n        return Math.round(area * 100.0) / 100.0;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.triangle_area(3, 4, 5)); // Expected output: 6.00\n        System.out.println(solution.triangle_area(1, 2, 10)); // Expected output: -1\n        System.out.println(solution.triangle_area(7, 8, 9)); // Expected output: ~26.83\n        System.out.println(solution.triangle_area(5, 5, 5)); // Expected output: 10.83\n    }\n}\n"}
{"task_id": "Java/72", "generation": "import java.util.*;\n\nclass Solution {\n\n    /**\n     * Write a function that returns True if the object q will fly, and False otherwise.\n     * The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal to the maximum possible weight w.\n     *\n     * @param q A List<Integer> representing the object\n     * @param w An integer representing the maximum possible weight\n     * @return boolean indicating if the object will fly\n     */\n    public boolean will_it_fly(List<Integer> q, int w) {\n        // Check if the list is a palindrome\n        for (int i = 0; i < q.size() / 2; i++) {\n            if (!q.get(i).equals(q.get(q.size() - 1 - i))) {\n                return false;\n            }\n        }\n\n        // Calculate the sum of elements in the list\n        int sum = q.stream().mapToInt(Integer::intValue).sum();\n\n        // Check if the sum is less than or equal to w\n        return sum <= w;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.will_it_fly(Arrays.asList(1, 2), 5));   // false\n        System.out.println(solution.will_it_fly(Arrays.asList(3, 2, 3), 1)); // false\n        System.out.println(solution.will_it_fly(Arrays.asList(3, 2, 3), 9)); // true\n        System.out.println(solution.will_it_fly(Arrays.asList(3), 5));      // true\n    }\n}\n"}
{"task_id": "Java/73", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given an array arr of integers, find the minimum number of elements that\n     * need to be changed to make the array palindromic. A palindromic array is an array that\n     * is read the same backwards and forwards. In one change, you can change one element to any other element.\n     *\n     * For example:\n     * smallest_change(Arrays.asList(1,2,3,5,4,7,9,6)) == 4\n     * smallest_change(Arrays.asList(1, 2, 3, 4, 3, 2, 2)) == 1\n     * smallest_change(Arrays.asList(1, 2, 3, 2, 1)) == 0\n     */\n    public int smallest_change(List<Integer> arr) {\n        int left = 0;\n        int right = arr.size() - 1;\n        int changes = 0;\n\n        while (left < right) {\n            if (!arr.get(left).equals(arr.get(right))) {\n                changes++;\n            }\n            left++;\n            right--;\n        }\n\n        return changes;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.smallest_change(Arrays.asList(1, 2, 3, 5, 4, 7, 9, 6))); // Output: 4\n        System.out.println(solution.smallest_change(Arrays.asList(1, 2, 3, 4, 3, 2, 2)));    // Output: 1\n        System.out.println(solution.smallest_change(Arrays.asList(1, 2, 3, 2, 1)));          // Output: 0\n        System.out.println(solution.smallest_change(Arrays.asList(1, 2, 3, 4, 5, 6, 7)));    // Output: 3\n        System.out.println(solution.smallest_change(Arrays.asList(8, 9, 8, 9, 8, 9, 8)));   // Output: 0\n    }\n}\n"}
{"task_id": "Java/74", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Write a function that accepts two lists of strings and returns the list that has\n     * total number of chars in the all strings of the list less than the other list.\n     *\n     * if the two lists have the same number of chars, return the first list.\n     */\n    public List<String> total_match(List<String> lst1, List<String> lst2) {\n        int count1 = 0;\n        for (String s : lst1) {\n            count1 += s.length();\n        }\n        \n        int count2 = 0;\n        for (String s : lst2) {\n            count2 += s.length();\n        }\n\n        if (count1 <= count2) {\n            return lst1;\n        } else {\n            return lst2;\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.total_match(new ArrayList<>(), new ArrayList<>())); // []\n        System.out.println(solution.total_match(Arrays.asList(\"hi\", \"admin\"), Arrays.asList(\"hI\", \"Hi\"))); // [\"hI\", \"Hi\"]\n        System.out.println(solution.total_match(Arrays.asList(\"hi\", \"admin\"), Arrays.asList(\"hi\", \"hi\", \"admin\", \"project\"))); // [\"hi\", \"admin\"]\n        System.out.println(solution.total_match(Arrays.asList(\"hi\", \"admin\"), Arrays.asList(\"hI\", \"hi\", \"hi\"))); // [\"hI\", \"hi\", \"hi\"]\n        System.out.println(solution.total_match(Arrays.asList(\"4\"), Arrays.asList(\"1\", \"2\", \"3\", \"4\", \"5\"))); // [\"4\"]\n    }\n}\n"}
{"task_id": "Java/75", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Write a function that returns true if the given number is the multiplication of 3 prime numbers\n     * and false otherwise.\n     * Knowing that the prime number is less than 100.\n     * Example:\n     * is_multiply_prime(30) == true\n     * 30 = 2 * 3 * 5\n     */\n    public boolean is_multiply_prime(int a) {\n        if (a < 2) return false;\n\n        int count = 0;\n        for (int i = 2; i <= Math.sqrt(a); i++) {\n            while (a % i == 0 && isPrime(i)) {\n                count++;\n                a /= i;\n            }\n        }\n\n        // Check if the remaining number is also prime and part of the product\n        if (a > 1 && isPrime(a)) {\n            count++;\n        }\n\n        return count == 3;\n    }\n\n    private boolean isPrime(int n) {\n        if (n <= 1) return false;\n        for (int i = 2; i * i <= n; i++) {\n            if (n % i == 0) return false;\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.is_multiply_prime(30)); // true, because 30 = 2 * 3 * 5\n        System.out.println(solution.is_multiply_prime(60)); // false, because 60 = 2 * 2 * 3 * 5 (more than 3 primes)\n        System.out.println(solution.is_multiply_prime(100)); // false, because 100 is not a product of exactly 3 primes\n        System.out.println(solution.is_multiply_prime(30030)); // true, because 30030 = 2 * 3 * 5 * 7 * 11 * 13 (more than 3 primes)\n        System.out.println(solution.is_multiply_prime(2 * 3 * 7)); // true, because 42 = 2 * 3 * 7\n    }\n}\n"}
{"task_id": "Java/76", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Your task is to write a function that returns true if a number x is a simple\n     * power of n and false in other cases.\n     * x is a simple power of n if n**int=x\n     * For example:\n     * is_simple_power(1, 4) => true\n     * is_simple_power(2, 2) => true\n     * is_simple_power(8, 2) => true\n     * is_simple_power(3, 2) => false\n     * is_simple_power(3, 1) => false\n     * is_simple_power(5, 3) => false\n     */\n    public boolean is_simple_power(int x, int n) {\n        if (n == 1) {\n            return x == 1;\n        }\n        \n        double power = Math.pow(n, Math.round(Math.log(x) / Math.log(n)));\n        return Math.abs(power - x) < 0.0001; // Allowing a small floating point tolerance\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.is_simple_power(1, 4));   // true\n        System.out.println(solution.is_simple_power(2, 2));   // true\n        System.out.println(solution.is_simple_power(8, 2));   // true\n        System.out.println(solution.is_simple_power(3, 2));   // false\n        System.out.println(solution.is_simple_power(3, 1));   // false\n        System.out.println(solution.is_simple_power(5, 3));   // false\n        System.out.println(solution.is_simple_power(16, 2));  // true\n        System.out.println(solution.is_simple_power(81, 3));  // true\n        System.out.println(solution.is_simple_power(27, 3));  // true\n        System.out.println(solution.is_simple_power(49, 7));  // true\n    }\n}\n"}
{"task_id": "Java/77", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Write a function that takes an integer a and returns true\n     * if this integer is a cube of some integer number.\n     * Note: you may assume the input is always valid.\n     * Examples:\n     * iscube(1) ==> true\n     * iscube(2) ==> false\n     * iscube(-1) ==> true\n     * iscube(64) ==> true\n     * iscube(0) ==> true\n     * iscube(180) ==> false\n     */\n    public boolean iscube(int a) {\n        if (a == 0) return true;\n        \n        // Handle negative numbers by checking the cube root and squaring it back\n        double cubeRoot = Math.cbrt(a);\n        int roundedCubeRoot = (int) Math.round(cubeRoot);\n        \n        return Math.pow(roundedCubeRoot, 3) == a;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.iscube(1));   // true\n        System.out.println(solution.iscube(2));   // false\n        System.out.println(solution.iscube(-1));  // true\n        System.out.println(solution.iscube(64));  // true\n        System.out.println(solution.iscube(0));   // true\n        System.out.println(solution.iscube(180)); // false\n    }\n}\n"}
{"task_id": "Java/78", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * You have been tasked to write a function that receives\n     * a hexadecimal number as a string and counts the number of hexadecimal\n     * digits that are primes (prime number, or a prime, is a natural number\n     * greater than 1 that is not a product of two smaller natural numbers).\n     * Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n     * Prime numbers are 2, 3, 5, 7, B (=decimal 11), D (=decimal 13).\n     * So you have to determine a number of the following digits: 2, 3, 5, 7,\n     * B (=decimal 11), D (=decimal 13).\n     * Note: you may assume the input is always correct or empty string,\n     * and symbols A,B,C,D,E,F are always uppercase.\n     * Examples:\n     * For num = \"AB\" the output should be 1.\n     * For num = \"1077E\" the output should be 2.\n     * For num = \"ABED1A33\" the output should be 4.\n     * For num = \"123456789ABCDEF0\" the output should be 6.\n     * For num = \"2020\" the output should be 2.\n     */\n    public int hex_key(String num) {\n        // Define a set of prime hexadecimal digits\n        Set<Character> primes = new HashSet<>(Arrays.asList('2', '3', '5', '7', 'B', 'D'));\n        \n        // Count the number of prime hexadecimal digits in the input string\n        int count = 0;\n        for (char c : num.toCharArray()) {\n            if (primes.contains(c)) {\n                count++;\n            }\n        }\n        \n        return count;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.hex_key(\"AB\")); // Expected output: 1\n        System.out.println(solution.hex_key(\"1077E\")); // Expected output: 2\n        System.out.println(solution.hex_key(\"ABED1A33\")); // Expected output: 4\n        System.out.println(solution.hex_key(\"123456789ABCDEF0\")); // Expected output: 6\n        System.out.println(solution.hex_key(\"2020\")); // Expected output: 2\n    }\n}\n"}
{"task_id": "Java/79", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * You will be given a number in decimal form and your task is to convert it to\n     * binary format. The function should return a string, with each character representing a binary\n     * number. Each character in the string will be '0' or '1'.\n     *\n     * There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n     * The extra characters are there to help with the format.\n     *\n     * Examples:\n     * decimal_to_binary(15)   // returns \"db1111db\"\n     * decimal_to_binary(32)   // returns \"db100000db\"\n     */\n    public String decimal_to_binary(int decimal) {\n        if (decimal == 0) return \"db0db\";\n        \n        StringBuilder binary = new StringBuilder();\n        while (decimal > 0) {\n            binary.insert(0, decimal % 2);\n            decimal /= 2;\n        }\n        \n        return \"db\" + binary.toString() + \"db\";\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.decimal_to_binary(15));   // Expected: db1111db\n        System.out.println(solution.decimal_to_binary(32));   // Expected: db100000db\n        System.out.println(solution.decimal_to_binary(0));    // Expected: db0db\n        System.out.println(solution.decimal_to_binary(456));  // Expected: db111001000db\n        System.out.println(solution.decimal_to_binary(255));  // Expected: db11111111db\n    }\n}\n"}
{"task_id": "Java/80", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * You are given a string s.\n     * Your task is to check if the string is happy or not.\n     * A string is happy if its length is at least 3 and every 3 consecutive letters are distinct\n     * For example:\n     * is_happy(a) => false\n     * is_happy(aa) => false\n     * is_happy(abcd) => true\n     * is_happy(aabb) => false\n     * is_happy(adb) => true\n     * is_happy(xyy) => false\n     */\n    public boolean is_happy(String s) {\n        if (s.length() < 3) return false;\n        \n        for (int i = 0; i <= s.length() - 3; i++) {\n            char first = s.charAt(i);\n            char second = s.charAt(i + 1);\n            char third = s.charAt(i + 2);\n            \n            if (first == second || second == third || first == third) {\n                return false;\n            }\n        }\n        \n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.is_happy(\"a\"));       // Output: false\n        System.out.println(solution.is_happy(\"aa\"));      // Output: false\n        System.out.println(solution.is_happy(\"abcd\"));    // Output: true\n        System.out.println(solution.is_happy(\"aabb\"));    // Output: false\n        System.out.println(solution.is_happy(\"adb\"));     // Output: true\n        System.out.println(solution.is_happy(\"xyy\"));     // Output: false\n        System.out.println(solution.is_happy(\"abcabc\"));  // Output: true\n        System.out.println(solution.is_happy(\"abacaba\")); // Output: false\n    }\n}\n"}
{"task_id": "Java/81", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * It is the last week of the semester and the teacher has to give the grades\n     * to students. The teacher has been making her own algorithm for grading.\n     * The only problem is, she has lost the code she used for grading.\n     * She has given you a list of GPAs for some students and you have to write\n     * a function that can output a list of letter grades using the following table:\n             GPA       |    Letter grade\n              4.0                A+\n            > 3.7                A\n            > 3.3                A-\n            > 3.0                B+\n            > 2.7                B\n            > 2.3                B-\n            > 2.0                C+\n            > 1.7                C\n            > 1.3                C-\n            > 1.0                D+\n            > 0.7                D\n            > 0.0                D-\n              0.0                E\n\n     * Example:\n     * numerical_letter_grade(Arrays.asList(4.0, 3, 1.7, 2, 3.5)) ==> [\"A+\", \"B\", \"C-\", \"C\", \"A-\"]\n     */\n    public List<String> numerical_letter_grade(List<Double> grades) {\n        List<String> letterGrades = new ArrayList<>();\n        \n        for (double gpa : grades) {\n            if (gpa == 4.0) {\n                letterGrades.add(\"A+\");\n            } else if (gpa > 3.7) {\n                letterGrades.add(\"A\");\n            } else if (gpa > 3.3) {\n                letterGrades.add(\"A-\");\n            } else if (gpa > 3.0) {\n                letterGrades.add(\"B+\");\n            } else if (gpa > 2.7) {\n                letterGrades.add(\"B\");\n            } else if (gpa > 2.3) {\n                letterGrades.add(\"B-\");\n            } else if (gpa > 2.0) {\n                letterGrades.add(\"C+\");\n            } else if (gpa > 1.7) {\n                letterGrades.add(\"C\");\n            } else if (gpa > 1.3) {\n                letterGrades.add(\"C-\");\n            } else if (gpa > 1.0) {\n                letterGrades.add(\"D+\");\n            } else if (gpa > 0.7) {\n                letterGrades.add(\"D\");\n            } else if (gpa > 0.0) {\n                letterGrades.add(\"D-\");\n            } else {\n                letterGrades.add(\"E\");\n            }\n        }\n\n        return letterGrades;\n    }\n}\n"}
{"task_id": "Java/82", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Write a function that takes a string and returns true if the string\n     * length is a prime number or false otherwise\n     * Examples:\n     * prime_length(\"Hello\") == true\n     * prime_length(\"abcdcba\") == true\n     * prime_length(\"kittens\") == true\n     * prime_length(\"orange\") == false\n     */\n    public boolean prime_length(String string) {\n        int length = string.length();\n        return isPrime(length);\n    }\n\n    private boolean isPrime(int number) {\n        if (number <= 1) {\n            return false;\n        }\n        for (int i = 2; i * i <= number; i++) {\n            if (number % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.prime_length(\"Hello\"));   // true\n        System.out.println(solution.prime_length(\"abcdcba\")); // true\n        System.out.println(solution.prime_length(\"kittens\")); // true\n        System.out.println(solution.prime_length(\"orange\"));  // false\n    }\n}\n"}
{"task_id": "Java/83", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int starts_one_ends(int n) {\n        if (n == 1) {\n            return 1;\n        }\n        // For n-digit numbers, there are 2 * (10^(n-1)) - 10^(n-2) such numbers.\n        long count = (long)(2 * Math.pow(10, n - 1) - Math.pow(10, n - 2));\n        return (int) count;\n    }\n}\n"}
{"task_id": "Java/84", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     Given a positive integer N, return in binary the total sum of its digits.\n\n     Example\n         For N = 1000, the sum of digits will be 1 the output should be \"1\".\n         For N = 150, the sum of digits will be 6 the output should be \"110\".\n         For N = 147, the sum of digits will be 12 the output should be \"1100\".\n\n     Variables:\n         @N integer\n              Constraints: 0 <= N <= 10000.\n     Output:\n          a string of binary number\n      */\n    public String solve(int N) {\n        int sum = 0;\n        \n        // Calculate the sum of digits\n        while (N > 0) {\n            sum += N % 10;\n            N /= 10;\n        }\n        \n        // Convert the sum to binary and return as a string\n        return Integer.toBinaryString(sum);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.solve(1000)); // Expected output: \"1\"\n        System.out.println(solution.solve(150));  // Expected output: \"110\"\n        System.out.println(solution.solve(147));  // Expected output: \"1100\"\n        System.out.println(solution.solve(9999)); // Expected output: \"11110001111\"\n    }\n}\n"}
{"task_id": "Java/85", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a non-empty list of integers lst. add the even elements that are at odd indices.\n     *\n     * Examples:\n     * - add(Arrays.asList(4, 2, 6, 7)) should return 2 (since only 2 is an even number at an odd index)\n     */\n    public int add(List<Integer> lst) {\n        if (lst == null || lst.isEmpty()) {\n            throw new IllegalArgumentException(\"List cannot be null or empty\");\n        }\n\n        int sum = 0;\n        for (int i = 1; i < lst.size(); i += 2) { // Start from index 1 and increment by 2\n            Integer value = lst.get(i);\n            if (value % 2 == 0) {\n                sum += value;\n            }\n        }\n\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.add(Arrays.asList(4, 2, 6, 7))); // Should print 2\n        System.out.println(solution.add(Arrays.asList(1, 3, 5, 7, 9))); // Should print 0 (no even numbers at odd indices)\n        System.out.println(solution.add(Arrays.asList(8, 4, 2, 6, 10, 12))); // Should print 16 (4 + 12)\n    }\n}\n"}
{"task_id": "Java/86", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Write a function that takes a string and returns an ordered version of it.\n     * Ordered version of string, is a string where all words (separated by space)\n     * are replaced by a new word where all the characters arranged in\n     * ascending order based on ascii value.\n     * Note: You should keep the order of words and blank spaces in the sentence.\n     *\n     * For example:\n     * anti_shuffle(\"Hi\") returns \"Hi\"\n     * anti_shuffle(\"hello\") returns \"ehllo\"\n     * anti_shuffle(\"Hello World!!!\") returns \"Hello !!!Wdlor\"\n     */\n    public String anti_shuffle(String s) {\n        if (s == null || s.isEmpty()) {\n            return s;\n        }\n\n        StringBuilder result = new StringBuilder();\n        int wordStartIndex = 0;\n\n        for (int i = 0; i < s.length(); i++) {\n            char c = s.charAt(i);\n            if (c == ' ') {\n                // Process the current word\n                String word = s.substring(wordStartIndex, i);\n                result.append(orderedWord(word));\n                result.append(c); // Append the space character\n                wordStartIndex = i + 1;\n            }\n        }\n\n        // Process the last word in the string\n        if (wordStartIndex < s.length()) {\n            String lastWord = s.substring(wordStartIndex);\n            result.append(orderedWord(lastWord));\n        }\n\n        return result.toString();\n    }\n\n    private String orderedWord(String word) {\n        char[] chars = word.toCharArray();\n        Arrays.sort(chars);\n        return new String(chars);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.anti_shuffle(\"Hi\")); // Expected: \"Hi\"\n        System.out.println(solution.anti_shuffle(\"hello\")); // Expected: \"ehllo\"\n        System.out.println(solution.anti_shuffle(\"Hello World!!!\")); // Expected: \"Hello !!!Wdlor\"\n        System.out.println(solution.anti_shuffle(\"Programming is fun!\")); // Expected: \"Pamgimnig is fnu!\"\n    }\n}\n"}
{"task_id": "Java/87", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<List<Integer>> get_row(List<List<Integer>> lst, int x) {\n        List<List<Integer>> coordinates = new ArrayList<>();\n        \n        for (int i = 0; i < lst.size(); i++) {\n            List<Integer> row = lst.get(i);\n            for (int j = 0; j < row.size(); j++) {\n                if (row.get(j).equals(x)) {\n                    coordinates.add(Arrays.asList(i, j));\n                }\n            }\n        }\n\n        // Sort by rows in ascending order\n        Collections.sort(coordinates, new Comparator<List<Integer>>() {\n            @Override\n            public int compare(List<Integer> o1, List<Integer> o2) {\n                return o1.get(0).compareTo(o2.get(0));\n            }\n        });\n\n        // For each row, sort the coordinates by columns in descending order\n        for (int i = 0; i < coordinates.size(); i++) {\n            if (i > 0 && coordinates.get(i).get(0) == coordinates.get(i - 1).get(0)) {\n                Collections.sort(coordinates.subList(i - 1, i + 1), new Comparator<List<Integer>>() {\n                    @Override\n                    public int compare(List<Integer> o1, List<Integer> o2) {\n                        return o2.get(1).compareTo(o1.get(1));\n                    }\n                });\n            }\n        }\n\n        return coordinates;\n    }\n}\n"}
{"task_id": "Java/88", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n\n    /**\n     * Given an array of non-negative integers, return a copy of the given array after sorting,\n     * you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n     * or sort it in descending order if the sum( first index value, last index value) is even.\n     *\n     * Note:\n     * * don't change the given array.\n     */\n    public List<Integer> sort_array(List<Integer> array) {\n        if (array == null || array.isEmpty()) {\n            return new ArrayList<>();\n        }\n\n        int sum = array.get(0) + array.get(array.size() - 1);\n        List<Integer> sortedArray = new ArrayList<>(array);\n\n        if (sum % 2 == 0) {\n            // Sort in descending order\n            sortedArray.sort(Collections.reverseOrder());\n        } else {\n            // Sort in ascending order\n            Collections.sort(sortedArray);\n        }\n\n        return sortedArray;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.sort_array(Arrays.asList())); // []\n        System.out.println(solution.sort_array(Arrays.asList(5))); // [5]\n        System.out.println(solution.sort_array(Arrays.asList(2, 4, 3, 0, 1, 5))); // [0, 1, 2, 3, 4, 5]\n        System.out.println(solution.sort_array(Arrays.asList(2, 4, 3, 0, 1, 5, 6))); // [6, 5, 4, 3, 2, 1, 0]\n    }\n}\n"}
{"task_id": "Java/89", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Create a function encrypt that takes a string as an argument and\n     * returns a string encrypted with the alphabet being rotated.\n     * The alphabet should be rotated in a manner such that the letters\n     * shift down by two multiplied to two places.\n     * For example:\n     * encrypt(\"hi\") returns \"lm\"\n     * encrypt(\"asdfghjkl\") returns \"ewhjklnop\"\n     * encrypt(\"gf\") returns \"kj\"\n     * encrypt(\"et\") returns \"ix\"\n     */\n    public String encrypt(String s) {\n        StringBuilder encrypted = new StringBuilder();\n        for (char c : s.toCharArray()) {\n            if (Character.isLetter(c)) {\n                char base = Character.isUpperCase(c) ? 'A' : 'a';\n                int offset = ((c - base + 4) % 26);\n                encrypted.append((char) (base + offset));\n            } else {\n                encrypted.append(c);\n            }\n        }\n        return encrypted.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.encrypt(\"hi\"));       // Should print \"lm\"\n        System.out.println(solution.encrypt(\"asdfghjkl\")); // Should print \"ewhjklnop\"\n        System.out.println(solution.encrypt(\"gf\"));       // Should print \"kj\"\n        System.out.println(solution.encrypt(\"et\"));       // Should print \"ix\"\n\n        // Additional test cases\n        System.out.println(solution.encrypt(\"Hello, World!\")); // Should print \"Lipps, Asvph!\"\n        System.out.println(solution.encrypt(\"Zebra123\"));     // Should print \"Difve123\"\n    }\n}\n"}
{"task_id": "Java/90", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * You are given a list of integers.\n     * Write a function next_smallest() that returns the 2nd smallest element of the list.\n     * Return null if there is no such element.\n     *\n     * @param lst The input list of integers\n     * @return Optional containing the 2nd smallest integer, or Optional.empty() if not available\n     */\n    public Optional<Integer> next_smallest(List<Integer> lst) {\n        // Remove duplicates and sort the list\n        Set<Integer> uniqueElements = new TreeSet<>(lst);\n        \n        // If there are less than 2 elements after removing duplicates, return Optional.empty()\n        if (uniqueElements.size() < 2) {\n            return Optional.empty();\n        }\n        \n        // Return the second element in the sorted set\n        Integer[] array = uniqueElements.toArray(new Integer[0]);\n        return Optional.of(array[1]);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.next_smallest(Arrays.asList(1, 2, 3, 4, 5))); // Expected: Optional[2]\n        System.out.println(solution.next_smallest(Arrays.asList(5, 1, 4, 3, 2))); // Expected: Optional[2]\n        System.out.println(solution.next_smallest(Arrays.asList()));             // Expected: Optional.empty\n        System.out.println(solution.next_smallest(Arrays.asList(1, 1)));         // Expected: Optional.empty\n        System.out.println(solution.next_smallest(Arrays.asList(5, 4, 3, 2, 1))); // Expected: Optional[2]\n    }\n}\n"}
{"task_id": "Java/91", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int is_bored(String S) {\n        String[] sentences = S.split(\"[.?!]\");\n        int count = 0;\n        \n        for (String sentence : sentences) {\n            if (!sentence.trim().isEmpty() && sentence.trim().startsWith(\"I\")) {\n                count++;\n            }\n        }\n        \n        return count;\n    }\n}\n"}
{"task_id": "Java/92", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Create a function that takes 3 numbers.\n     * Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n     * Returns false in any other cases.\n     *\n     * Examples\n     * any_int(5, 2, 7) -> true\n     * any_int(3, 2, 2) -> false\n     * any_int(3, -2, 1) -> true\n     * any_int(3.6, -2.2, 2) -> false\n     */\n    public boolean any_int(Object x, Object y, Object z) {\n        if (x instanceof Integer && y instanceof Integer && z instanceof Integer) {\n            int a = (Integer) x;\n            int b = (Integer) y;\n            int c = (Integer) z;\n\n            return a == b + c || b == a + c || c == a + b;\n        }\n        return false;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.any_int(5, 2, 7));   // true\n        System.out.println(solution.any_int(3, 2, 2));   // false\n        System.out.println(solution.any_int(3, -2, 1));  // true\n        System.out.println(solution.any_int(3.6, -2.2, 2)); // false (should return false)\n    }\n}\n"}
{"task_id": "Java/93", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Write a function that takes a message, and encodes in such a way that it swaps case of all letters,\n     * replaces all vowels in the message with the letter that appears 2 places ahead of that vowel in the\n     * English alphabet.\n     *\n     * Examples:\n     * >>> encode(\"test\")\n     * \"TGST\"\n     * >>> encode(\"This is a message\")\n     * \"tHKS KS C MGSSCGG\"\n     */\n    public String encode(String message) {\n        StringBuilder encodedMessage = new StringBuilder();\n        \n        for (char c : message.toCharArray()) {\n            if (Character.isLetter(c)) {\n                // Swap case\n                char swappedCaseChar = Character.isLowerCase(c) ? Character.toUpperCase(c) : Character.toLowerCase(c);\n                \n                // Replace vowels with the letter 2 places ahead in the alphabet\n                switch (swappedCaseChar) {\n                    case 'A':\n                        encodedMessage.append('C');\n                        break;\n                    case 'E':\n                        encodedMessage.append('G');\n                        break;\n                    case 'I':\n                        encodedMessage.append('K');\n                        break;\n                    case 'O':\n                        encodedMessage.append('Q');\n                        break;\n                    case 'U':\n                        encodedMessage.append('W');\n                        break;\n                    case 'a':\n                        encodedMessage.append('c');\n                        break;\n                    case 'e':\n                        encodedMessage.append('g');\n                        break;\n                    case 'i':\n                        encodedMessage.append('k');\n                        break;\n                    case 'o':\n                        encodedMessage.append('q');\n                        break;\n                    case 'u':\n                        encodedMessage.append('w');\n                        break;\n                    default:\n                        // If it's not a vowel, just append the swapped case character\n                        encodedMessage.append(swappedCaseChar);\n                }\n            } else {\n                // Non-letter characters are appended as is\n                encodedMessage.append(c);\n            }\n        }\n        \n        return encodedMessage.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.encode(\"test\"));  // Expected: \"TGST\"\n        System.out.println(solution.encode(\"This is a message\"));  // Expected: \"tHKS KS C MGSSCGG\"\n        System.out.println(solution.encode(\"Hello World!\"));  // Expected: \"hKLLQ wOrld!\"\n    }\n}\n"}
{"task_id": "Java/94", "generation": "import java.util.List;\n\nclass Solution {\n    /**\n     * You are given a list of integers.\n     * You need to find the largest prime value and return the sum of its digits.\n     */\n    public int skjkasdkd(List<Integer> lst) {\n        if (lst == null || lst.isEmpty()) {\n            return 0;\n        }\n\n        int maxPrime = -1;\n\n        for (int num : lst) {\n            if (isPrime(num)) {\n                maxPrime = Math.max(maxPrime, num);\n            }\n        }\n\n        if (maxPrime == -1) {\n            return 0;\n        }\n\n        return sumOfDigits(maxPrime);\n    }\n\n    private boolean isPrime(int num) {\n        if (num <= 1) {\n            return false;\n        }\n        for (int i = 2; i <= Math.sqrt(num); i++) {\n            if (num % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private int sumOfDigits(int num) {\n        int sum = 0;\n        while (num > 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        List<Integer> lst1 = Arrays.asList(0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3);\n        System.out.println(solution.skjkasdkd(lst1)); // Output: 10\n\n        List<Integer> lst2 = Arrays.asList(1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1);\n        System.out.println(solution.skjkasdkd(lst2)); // Output: 25\n\n        List<Integer> lst3 = Arrays.asList(1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3);\n        System.out.println(solution.skjkasdkd(lst3)); // Output: 13\n\n        List<Integer> lst4 = Arrays.asList(0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6);\n        System.out.println(solution.skjkasdkd(lst4)); // Output: 11\n\n        List<Integer> lst5 = Arrays.asList(0, 81, 12, 3, 1, 21);\n        System.out.println(solution.skjkasdkd(lst5)); // Output: 3\n\n        List<Integer> lst6 = Arrays.asList(0, 8, 1, 2, 1, 7);\n        System.out.println(solution.skjkasdkd(lst6)); // Output: 7\n    }\n}\n"}
{"task_id": "Java/95", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given a map, return True if all keys are strings and all keys are in lower case or in upper case, else return False.\n     * The function should return False is the given map is empty.\n     */\n    public boolean check_dict_case(Map<Object, Object> dict) {\n        if (dict.isEmpty()) {\n            return false;\n        }\n\n        boolean allLowerCase = true;\n        boolean allUpperCase = true;\n\n        for (Object key : dict.keySet()) {\n            if (!(key instanceof String)) {\n                return false;\n            }\n            String strKey = (String) key;\n            if (!strKey.equals(strKey.toLowerCase())) {\n                allLowerCase = false;\n            }\n            if (!strKey.equals(strKey.toUpperCase())) {\n                allUpperCase = false;\n            }\n        }\n\n        return allLowerCase || allUpperCase;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.check_dict_case(Map.of(\"a\", \"apple\", \"b\", \"banana\"))); // True\n        System.out.println(solution.check_dict_case(Map.of(\"a\", \"apple\", \"A\", \"banana\", \"B\", \"banana\"))); // False\n        System.out.println(solution.check_dict_case(Map.of(\"a\", \"apple\", 8, \"banana\", \"a\", \"apple\"))); // False\n        System.out.println(solution.check_dict_case(Map.of(\"Name\", \"John\", \"Age\", \"36\", \"City\", \"Houston\"))); // False\n        System.out.println(solution.check_dict_case(Map.of(\"STATE\", \"NC\", \"ZIP\", \"12345\"))); // True\n    }\n}\n"}
{"task_id": "Java/96", "generation": "import java.util.ArrayList;\nimport java.util.List;\n\nclass Solution {\n\n    /**\n     * Implement a function that takes an non-negative integer and returns an array of the first n\n     * integers that are prime numbers and less than n.\n     *\n     * @param n The upper limit (non-inclusive) to find prime numbers up to.\n     * @return A List containing prime numbers less than n.\n     */\n    public List<Integer> count_up_to(int n) {\n        List<Integer> primes = new ArrayList<>();\n        \n        for (int i = 2; i < n && primes.size() < n; i++) {\n            if (isPrime(i)) {\n                primes.add(i);\n            }\n        }\n        \n        return primes;\n    }\n\n    /**\n     * Helper method to check if a number is prime.\n     *\n     * @param num The number to check.\n     * @return true if the number is prime, false otherwise.\n     */\n    private boolean isPrime(int num) {\n        if (num <= 1) {\n            return false;\n        }\n        for (int i = 2; i <= Math.sqrt(num); i++) {\n            if (num % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.count_up_to(5));   // Output: [2, 3]\n        System.out.println(solution.count_up_to(11));  // Output: [2, 3, 5, 7]\n        System.out.println(solution.count_up_to(0));   // Output: []\n        System.out.println(solution.count_up_to(20));  // Output: [2, 3, 5, 7, 11, 13, 17, 19]\n        System.out.println(solution.count_up_to(1));   // Output: []\n        System.out.println(solution.count_up_to(18));  // Output: [2, 3, 5, 7, 11, 13, 17]\n    }\n}\n"}
{"task_id": "Java/97", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Complete the function that takes two integers and returns\n     * the product of their unit digits.\n     * Assume the input is always valid.\n     * Examples:\n     * multiply(148, 412) should return 16.\n     * multiply(19, 28) should return 72.\n     * multiply(2020, 1851) should return 0.\n     * multiply(14,-15) should return 20.\n     */\n    public int multiply(int a, int b) {\n        // Extract the unit digits of both numbers\n        int unitDigitA = Math.abs(a % 10);\n        int unitDigitB = Math.abs(b % 10);\n\n        // Return the product of the unit digits\n        return unitDigitA * unitDigitB;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.multiply(148, 412)); // Expected output: 16\n        System.out.println(solution.multiply(19, 28));   // Expected output: 72\n        System.out.println(solution.multiply(2020, 1851)); // Expected output: 0\n        System.out.println(solution.multiply(14, -15));  // Expected output: 20\n    }\n}\n"}
{"task_id": "Java/98", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a string s, count the number of uppercase vowels in even indices.\n     *\n     * For example:\n     * count_upper(\"aBCdEf\") returns 1\n     * count_upper(\"abcdefg\") returns 0\n     * count_upper(\"dBBE\") returns 0\n     */\n    public int count_upper(String s) {\n        int count = 0;\n        for (int i = 0; i < s.length(); i += 2) { // Iterate over even indices\n            char c = s.charAt(i);\n            if (isUppercaseVowel(c)) {\n                count++;\n            }\n        }\n        return count;\n    }\n\n    private boolean isUppercaseVowel(char c) {\n        return c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U';\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.count_upper(\"aBCdEf\")); // Expected output: 1\n        System.out.println(solution.count_upper(\"abcdefg\")); // Expected output: 0\n        System.out.println(solution.count_upper(\"dBBE\")); // Expected output: 0\n        System.out.println(solution.count_upper(\"AeIoUc\")); // Expected output: 3\n        System.out.println(solution.count_upper(\"zYxWvUt\")); // Expected output: 2\n    }\n}\n"}
{"task_id": "Java/99", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Create a function that takes a value (string) representing a number\n     * and returns the closest integer to it. If the number is equidistant\n     * from two integers, round it away from zero.\n     *\n     * Examples:\n     * >>> closest_integer(\"10\")\n     * 10\n     * >>> closest_integer(\"15.3\")\n     * 15\n     * >>> closest_integer(\"14.5\")\n     * 15\n     * >>> closest_integer(\"-14.5\")\n     * -15\n     */\n    public int closest_integer(String value) {\n        double num = Double.parseDouble(value);\n        double floorValue = Math.floor(num);\n        double ceilValue = Math.ceil(num);\n\n        if (num - floorValue == 0.5 || ceilValue - num == 0.5) {\n            return (int)(num > 0 ? ceilValue : floorValue);\n        } else {\n            return (int)Math.round(num);\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.closest_integer(\"10\"));   // Output: 10\n        System.out.println(solution.closest_integer(\"15.3\")); // Output: 15\n        System.out.println(solution.closest_integer(\"14.5\")); // Output: 15\n        System.out.println(solution.closest_integer(\"-14.5\"));// Output: -15\n        System.out.println(solution.closest_integer(\"0.5\"));  // Output: 1\n        System.out.println(solution.closest_integer(\"-0.5\")); // Output: -1\n    }\n}\n"}
{"task_id": "Java/100", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given a positive integer n, you have to make a pile of n levels of stones.\n     * The first level has n stones.\n     * The number of stones in the next level is:\n     * - the next odd number if n is odd.\n     * - the next even number if n is even.\n     * Return the number of stones in each level in a list, where element at index\n     * i represents the number of stones in the level (i+1).\n     *\n     * Examples:\n     * >>> make_a_pile(3)\n     * [3, 5, 7]\n     */\n    public List<Integer> make_a_pile(int n) {\n        List<Integer> result = new ArrayList<>();\n        int currentStones = n;\n        \n        for (int i = 0; i < n; i++) {\n            result.add(currentStones);\n            // Determine the next number of stones\n            if (currentStones % 2 == 0) {\n                currentStones += 2; // Next even number\n            } else {\n                currentStones += 2; // Next odd number\n            }\n        }\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.make_a_pile(3)); // Expected: [3, 5, 7]\n        System.out.println(solution.make_a_pile(4)); // Expected: [4, 6, 8, 10]\n        System.out.println(solution.make_a_pile(1)); // Expected: [1, 3]\n    }\n}\n"}
{"task_id": "Java/101", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<String> words_string(String s) {\n        // Use regular expression to split the string by commas and spaces\n        String[] words = s.split(\"[,\\s]+\");\n        return Arrays.asList(words);\n    }\n}\n"}
{"task_id": "Java/102", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * This function takes two positive numbers x and y and returns the\n     * biggest even integer number that is in the range [x, y] inclusive. If\n     * there's no such number, then the function should return -1.\n     *\n     * For example:\n     * choose_num(12, 15) = 14\n     * choose_num(13, 12) = -1\n     */\n    public int choose_num(int x, int y) {\n        // If the range is invalid or there's no even number in the range\n        if (x > y || (x % 2 != 0 && y % 2 != 0)) {\n            return -1;\n        }\n\n        // Find the biggest even number in the range [x, y]\n        for (int i = y; i >= x; i--) {\n            if (i % 2 == 0) {\n                return i;\n            }\n        }\n\n        // If no even number is found\n        return -1;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.choose_num(12, 15)); // Expected output: 14\n        System.out.println(solution.choose_num(13, 12)); // Expected output: -1\n        System.out.println(solution.choose_num(10, 20)); // Expected output: 20\n        System.out.println(solution.choose_num(17, 19)); // Expected output: -1\n        System.out.println(solution.choose_num(8, 8));   // Expected output: 8\n    }\n}\n"}
{"task_id": "Java/103", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * You are given two positive integers n and m, and your task is to compute the\n     * average of the integers from n through m (including n and m).\n     * Round the answer to the nearest integer and convert that to binary.\n     * If n is greater than m, return -1.\n     * Example:\n     * rounded_avg(1, 5) => \"11\"\n     * rounded_avg(7, 5) => -1\n     * rounded_avg(10, 20) => \"1111\"\n     * rounded_avg(20, 33) => \"11011\"\n     */\n    public Object rounded_avg(int n, int m) {\n        if (n > m) {\n            return -1;\n        }\n        \n        long sum = 0;\n        for (int i = n; i <= m; i++) {\n            sum += i;\n        }\n        \n        double average = Math.round((double) sum / (m - n + 1));\n        String binary = Long.toBinaryString((long) average);\n        \n        return binary;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.rounded_avg(1, 5));   // Expected output: \"11\"\n        System.out.println(solution.rounded_avg(7, 5));   // Expected output: -1\n        System.out.println(solution.rounded_avg(10, 20)); // Expected output: \"1111\"\n        System.out.println(solution.rounded_avg(20, 33)); // Expected output: \"11011\"\n    }\n}\n"}
{"task_id": "Java/104", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> unique_digits(List<Integer> x) {\n        List<Integer> result = new ArrayList<>();\n        \n        for (int num : x) {\n            if (!hasEvenDigit(num)) {\n                result.add(num);\n            }\n        }\n        \n        Collections.sort(result);\n        return result;\n    }\n\n    private boolean hasEvenDigit(int n) {\n        while (n > 0) {\n            int digit = n % 10;\n            if (digit % 2 == 0) {\n                return true;\n            }\n            n /= 10;\n        }\n        return false;\n    }\n}\n"}
{"task_id": "Java/105", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given an array of integers, sort the integers that are between 1 and 9 inclusive,\n     * reverse the resulting array, and then replace each digit by its corresponding name from\n     * \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n     *\n     * @param arr input list of integers\n     * @return a list of strings representing the names of the digits in reverse sorted order\n     */\n    public List<String> by_length(List<Integer> arr) {\n        // Filter out numbers not between 1 and 9 inclusive\n        List<Integer> filtered = arr.stream()\n                                     .filter(num -> num >= 1 && num <= 9)\n                                     .sorted()\n                                     .collect(Collectors.toList());\n        \n        // Reverse the list\n        Collections.reverse(filtered);\n        \n        // Map each digit to its corresponding name\n        return filtered.stream()\n                       .map(digit -> switch (digit) {\n                           case 1 -> \"One\";\n                           case 2 -> \"Two\";\n                           case 3 -> \"Three\";\n                           case 4 -> \"Four\";\n                           case 5 -> \"Five\";\n                           case 6 -> \"Six\";\n                           case 7 -> \"Seven\";\n                           case 8 -> \"Eight\";\n                           case 9 -> \"Nine\";\n                           default -> \"\";\n                       })\n                       .collect(Collectors.toList());\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.by_length(Arrays.asList(2, 1, 1, 4, 5, 8, 2, 3))); // [Eight, Five, Four, Three, Two, Two, One, One]\n        System.out.println(solution.by_length(Arrays.asList())); // []\n        System.out.println(solution.by_length(Arrays.asList(1, -1, 55))); // [One]\n        System.out.println(solution.by_length(Arrays.asList(9, 7, 3, 2, 4, 8, 6, 5, 1))); // [Nine, Eight, Seven, Six, Five, Four, Three, Two, One]\n    }\n}\n"}
{"task_id": "Java/106", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Implement the function f that takes n as a parameter,\n     * and returns a list of size n, such that the value of the element at index i is the factorial of i if i is even\n     * or the sum of numbers from 1 to i otherwise.\n     * i starts from 1.\n     * the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).\n     * Example:\n     * f(5) == [1, 2, 6, 24, 15]\n     */\n    public List<Integer> f(int n) {\n        List<Integer> result = new ArrayList<>();\n        \n        for (int i = 1; i <= n; i++) {\n            if (i % 2 == 0) {\n                // Calculate factorial of even index\n                int factorial = calculateFactorial(i);\n                result.add(factorial);\n            } else {\n                // Calculate sum from 1 to odd index\n                int sum = calculateSum(i);\n                result.add(sum);\n            }\n        }\n        \n        return result;\n    }\n\n    private int calculateFactorial(int n) {\n        if (n == 0 || n == 1) {\n            return 1;\n        }\n        int factorial = 1;\n        for (int i = 2; i <= n; i++) {\n            factorial *= i;\n        }\n        return factorial;\n    }\n\n    private int calculateSum(int n) {\n        int sum = 0;\n        for (int i = 1; i <= n; i++) {\n            sum += i;\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.f(5));  // Expected output: [1, 2, 6, 24, 15]\n        System.out.println(solution.f(3));  // Expected output: [1, 2, 6]\n        System.out.println(solution.f(0));  // Expected output: []\n    }\n}\n"}
{"task_id": "Java/107", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given a positive integer n, return a tuple that has the number of even and odd\n     * integer palindromes that fall within the range(1, n), inclusive.\n     *\n     * @param n The upper limit (inclusive) to check for palindromic numbers.\n     * @return A List containing two integers: the first is the count of even palindromes,\n     *         and the second is the count of odd palindromes.\n     */\n    public List<Integer> even_odd_palindrome(int n) {\n        int evenCount = 0;\n        int oddCount = 0;\n\n        for (int i = 1; i <= n; i++) {\n            if (isPalindrome(i)) {\n                if (i % 2 == 0) {\n                    evenCount++;\n                } else {\n                    oddCount++;\n                }\n            }\n        }\n\n        return Arrays.asList(evenCount, oddCount);\n    }\n\n    /**\n     * Helper method to check if a number is a palindrome.\n     *\n     * @param num The number to check.\n     * @return true if the number is a palindrome, false otherwise.\n     */\n    private boolean isPalindrome(int num) {\n        String str = Integer.toString(num);\n        int left = 0;\n        int right = str.length() - 1;\n\n        while (left < right) {\n            if (str.charAt(left) != str.charAt(right)) {\n                return false;\n            }\n            left++;\n            right--;\n        }\n\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.even_odd_palindrome(3));  // Output: [1, 2]\n        System.out.println(solution.even_odd_palindrome(12)); // Output: [4, 6]\n        System.out.println(solution.even_odd_palindrome(10)); // Output: [2, 5]\n    }\n}\n"}
{"task_id": "Java/108", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int count_nums(List<Integer> arr) {\n        int count = 0;\n        \n        for (int num : arr) {\n            if (sum_of_digits(num) > 0) {\n                count++;\n            }\n        }\n        \n        return count;\n    }\n\n    private int sum_of_digits(int n) {\n        int sum = 0;\n        boolean isNegative = n < 0;\n        while (n != 0) {\n            int digit = Math.abs(n % 10);\n            sum += digit;\n            n /= 10;\n        }\n        \n        return isNegative ? -sum : sum;\n    }\n}\n"}
{"task_id": "Java/109", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N]. The\n     * numbers in the array will be randomly ordered. Your task is to determine if\n     * it is possible to get an array sorted in non-decreasing order by performing\n     * the following operation on the given array:\n     *      You are allowed to perform right shift operation any number of times.\n     *\n     * One right shift operation means shifting all elements of the array by one\n     * position in the right direction. The last element of the array will be moved to\n     * the starting position in the array i.e. 0th index.\n     *\n     * If it is possible to obtain the sorted array by performing the above operation\n     * then return true else return False.\n     * If the given array is empty then return true.\n     *\n     * Note: The given list is guaranteed to have unique elements.\n     */\n    public boolean move_one_ball(List<Integer> arr) {\n        if (arr.isEmpty()) {\n            return true;\n        }\n\n        int n = arr.size();\n        for (int i = 0; i < n - 1; i++) {\n            if (arr.get(i) > arr.get(i + 1)) {\n                // Check if the array can be sorted by a single right shift\n                List<Integer> shiftedArr = new ArrayList<>(arr.subList(i + 1, n));\n                shiftedArr.addAll(arr.subList(0, i + 1));\n                boolean isSorted = true;\n                for (int j = 0; j < n - 1; j++) {\n                    if (shiftedArr.get(j) > shiftedArr.get(j + 1)) {\n                        isSorted = false;\n                        break;\n                    }\n                }\n                return isSorted;\n            }\n        }\n\n        // If no out-of-order pair found, the array is already sorted\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.move_one_ball(Arrays.asList(3, 4, 5, 1, 2))); // true\n        System.out.println(solution.move_one_ball(Arrays.asList(3, 5, 4, 1, 2))); // false\n        System.out.println(solution.move_one_ball(Arrays.asList()));             // true\n        System.out.println(solution.move_one_ball(Arrays.asList(1, 2, 3, 4, 5))); // true\n        System.out.println(solution.move_one_ball(Arrays.asList(2, 1, 3, 4, 5))); // false (requires more than one shift)\n    }\n}\n"}
{"task_id": "Java/110", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * In this problem, you will implement a function that takes two lists of numbers,\n     * and determines whether it is possible to perform an exchange of elements\n     * between them to make lst1 a list of only even numbers.\n     * There is no limit on the number of exchanged elements between lst1 and lst2.\n     * If it is possible to exchange elements between the lst1 and lst2 to make\n     * all the elements of lst1 to be even, return \"YES\".\n     * Otherwise, return \"NO\".\n     * For example:\n     * exchange(Arrays.asList(1, 2, 3, 4), Arrays.asList(1, 2, 3, 4)) => \"YES\"\n     * exchange(Arrays.asList(1, 2, 3, 4), Arrays.asList(1, 5, 3, 4)) => \"NO\"\n     * It is assumed that the input lists will be non-empty.\n     */\n    public String exchange(List<Integer> lst1, List<Integer> lst2) {\n        // Count odd numbers in lst1 and even numbers in lst2\n        int oddCount = 0;\n        for (int num : lst1) {\n            if (num % 2 != 0) {\n                oddCount++;\n            }\n        }\n\n        int evenCount = 0;\n        for (int num : lst2) {\n            if (num % 2 == 0) {\n                evenCount++;\n            }\n        }\n\n        // If there are enough even numbers in lst2 to replace all odd numbers in lst1, return \"YES\"\n        return oddCount <= evenCount ? \"YES\" : \"NO\";\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.exchange(Arrays.asList(1, 2, 3, 4), Arrays.asList(1, 2, 3, 4))); // Expected: YES\n        System.out.println(solution.exchange(Arrays.asList(1, 2, 3, 4), Arrays.asList(1, 5, 3, 4))); // Expected: NO\n        System.out.println(solution.exchange(Arrays.asList(1, 3, 5, 7), Arrays.asList(2, 4, 6, 8))); // Expected: YES\n        System.out.println(solution.exchange(Arrays.asList(1, 3, 5, 7), Arrays.asList(1, 3, 5, 7))); // Expected: NO\n    }\n}\n"}
{"task_id": "Java/111", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public Map<String, Integer> histogram(String test) {\n        // Split the input string into words (letters)\n        String[] letters = test.split(\" \");\n        \n        // Use a HashMap to count occurrences of each letter\n        Map<String, Integer> letterCounts = new HashMap<>();\n        for (String letter : letters) {\n            if (!letter.isEmpty()) {  // Ensure non-empty strings are processed\n                letterCounts.put(letter, letterCounts.getOrDefault(letter, 0) + 1);\n            }\n        }\n        \n        // Find the maximum count of any letter\n        int maxCount = Collections.max(letterCounts.values());\n        \n        // Create a result map containing only letters with the maximum count\n        Map<String, Integer> result = new HashMap<>();\n        for (Map.Entry<String, Integer> entry : letterCounts.entrySet()) {\n            if (entry.getValue() == maxCount) {\n                result.put(entry.getKey(), entry.getValue());\n            }\n        }\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.histogram(\"a b c\"));  // {\"a\": 1, \"b\": 1, \"c\": 1}\n        System.out.println(solution.histogram(\"a b b a\"));  // {\"a\": 2, \"b\": 2}\n        System.out.println(solution.histogram(\"a b c a b\"));  // {\"a\": 2, \"b\": 2}\n        System.out.println(solution.histogram(\"b b b b a\"));  // {\"b\": 4}\n        System.out.println(solution.histogram(\"\"));  // {}\n    }\n}\n"}
{"task_id": "Java/112", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Task\n     * We are given two strings s and c, you have to deleted all the characters in s that are equal to any character in c\n     * then check if the result string is palindrome.\n     * A string is called palindrome if it reads the same backward as forward.\n     * You should return a tuple containing the result string and true/false for the check.\n     * Example\n     * For s = \"abcde\", c = \"ae\", the result should be (\"bcd\",false)\n     * For s = \"abcdef\", c = \"b\"  the result should be (\"acdef\",false)\n     * For s = \"abcdedcba\", c = \"ab\", the result should be (\"cdedc\",true)\n     */\n    public List<Object> reverse_delete(String s, String c) {\n        Set<Character> charsToRemove = new HashSet<>();\n        for (char ch : c.toCharArray()) {\n            charsToRemove.add(ch);\n        }\n\n        StringBuilder sb = new StringBuilder();\n        for (char ch : s.toCharArray()) {\n            if (!charsToRemove.contains(ch)) {\n                sb.append(ch);\n            }\n        }\n\n        String resultString = sb.toString();\n        boolean isPalindrome = isPalindrome(resultString);\n\n        return Arrays.asList(resultString, isPalindrome);\n    }\n\n    private boolean isPalindrome(String str) {\n        int left = 0;\n        int right = str.length() - 1;\n\n        while (left < right) {\n            if (str.charAt(left) != str.charAt(right)) {\n                return false;\n            }\n            left++;\n            right--;\n        }\n\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.reverse_delete(\"abcde\", \"ae\"));  // Expected: [bcd, false]\n        System.out.println(solution.reverse_delete(\"abcdef\", \"b\"));  // Expected: [acdef, false]\n        System.out.println(solution.reverse_delete(\"abcdedcba\", \"ab\"));  // Expected: [cdedc, true]\n    }\n}\n"}
{"task_id": "Java/113", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a list of strings, where each string consists of only digits,\n     * return a list. Each element i of the output should be \"the number of odd elements in the\n     * string i of the input.\" where all the i's should be replaced by the number\n     * of odd digits in the i\"th string of the input.\n     *\n     * @param lst The input list of strings consisting only of digits.\n     * @return A list of formatted strings indicating the count of odd elements in each input string.\n     */\n    public List<String> odd_count(List<String> lst) {\n        List<String> result = new ArrayList<>();\n        for (String str : lst) {\n            int oddCount = 0;\n            for (char c : str.toCharArray()) {\n                if ((c - '0') % 2 != 0) {\n                    oddCount++;\n                }\n            }\n            String formattedStr = \"the number of odd elements \" + oddCount + \"n the str\" + oddCount + \"ng \" + oddCount + \" of the \" + oddCount + \"nput.\";\n            result.add(formattedStr);\n        }\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        List<String> test1 = Arrays.asList(\"1234567\");\n        System.out.println(solution.odd_count(test1));  // Expected: [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n\n        List<String> test2 = Arrays.asList(\"3\", \"11111111\");\n        System.out.println(solution.odd_count(test2));  // Expected: [\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    }\n}\n"}
{"task_id": "Java/114", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given an array of integers nums, find the minimum sum of any non-empty sub-array\n     * of nums.\n     *\n     * Example:\n     * minSubArraySum(Arrays.asList(2, 3, 4, 1, 2, 4)) == 1\n     * minSubArraySum(Arrays.asList(-1, -2, -3)) == -6\n     */\n    public int minSubArraySum(List<Integer> nums) {\n        if (nums == null || nums.isEmpty()) {\n            throw new IllegalArgumentException(\"Input list cannot be null or empty\");\n        }\n        \n        int currentMin = nums.get(0);\n        int globalMin = nums.get(0);\n\n        for (int i = 1; i < nums.size(); i++) {\n            currentMin = Math.min(nums.get(i), currentMin + nums.get(i));\n            globalMin = Math.min(globalMin, currentMin);\n        }\n\n        return globalMin;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.minSubArraySum(Arrays.asList(2, 3, 4, 1, 2, 4))); // Expected output: 1\n        System.out.println(solution.minSubArraySum(Arrays.asList(-1, -2, -3)));       // Expected output: -6\n        System.out.println(solution.minSubArraySum(Arrays.asList(1, 2, 3, -6, 1)));   // Expected output: -6\n        System.out.println(solution.minSubArraySum(Arrays.asList(-1, -1, -2, 1)));    // Expected output: -4\n        System.out.println(solution.minSubArraySum(Arrays.asList(1, 2, 3, 4, 5)));    // Expected output: 1\n    }\n}\n"}
{"task_id": "Java/115", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * You are given a rectangular grid of wells. Each row represents a single well,\n     * and each 1 in a row represents a single unit of water.\n     * Each well has a corresponding bucket that can be used to extract water from it,\n     * and all buckets have the same capacity. Can't use buckets from other wells to extract water from one well.\n     * Your task is to use the buckets to empty the wells.\n     * Output the number of times you need to lower the buckets.\n     *\n     * Example 1:\n     * Input:\n     *      grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n     *      bucket_capacity : 1\n     * Output: 6\n     *\n     * Example 2:\n     * Input:\n     *      grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n     *      bucket_capacity : 2\n     * Output: 5\n     *\n     * Example 3:\n     * Input:\n     *      grid : [[0,0,0], [0,0,0]]\n     *      bucket_capacity : 5\n     * Output: 0\n     */\n    public int max_fill(List<List<Integer>> grid, int capacity) {\n        int totalDrops = 0;\n        for (List<Integer> well : grid) {\n            int waterUnits = 0;\n            for (int unit : well) {\n                waterUnits += unit;\n            }\n            totalDrops += Math.ceil((double) waterUnits / capacity);\n        }\n        return totalDrops;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test Case 1\n        List<List<Integer>> grid1 = Arrays.asList(\n                Arrays.asList(0, 0, 1, 0),\n                Arrays.asList(0, 1, 0, 0),\n                Arrays.asList(1, 1, 1, 1)\n        );\n        int capacity1 = 1;\n        System.out.println(\"Test Case 1: \" + solution.max_fill(grid1, capacity1)); // Expected output: 6\n\n        // Test Case 2\n        List<List<Integer>> grid2 = Arrays.asList(\n                Arrays.asList(0, 0, 1, 1),\n                Arrays.asList(0, 0, 0, 0),\n                Arrays.asList(1, 1, 1, 1),\n                Arrays.asList(0, 1, 1, 1)\n        );\n        int capacity2 = 2;\n        System.out.println(\"Test Case 2: \" + solution.max_fill(grid2, capacity2)); // Expected output: 5\n\n        // Test Case 3\n        List<List<Integer>> grid3 = Arrays.asList(\n                Arrays.asList(0, 0, 0),\n                Arrays.asList(0, 0, 0)\n        );\n        int capacity3 = 5;\n        System.out.println(\"Test Case 3: \" + solution.max_fill(grid3, capacity3)); // Expected output: 0\n    }\n}\n"}
{"task_id": "Java/116", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * In this Kata, you have to sort an array of integers according to\n     * number of ones in their binary representation in ascending order.\n     * For similar number of ones, sort based on decimal value.\n     *\n     * It must be implemented like this:\n     * >>> sort_array(Arrays.asList(1, 5, 2, 3, 4)).equals(Arrays.asList(1, 2, 4, 3, 5))\n     * >>> sort_array(Arrays.asList(-2, -3, -4, -5, -6)).equals(Arrays.asList(-4, -2, -6, -5, -3))\n     * >>> sort_array(Arrays.asList(1, 0, 2, 3, 4)).equals(Arrays.asList(0, 1, 2, 4, 3))\n     */\n    public List<Integer> sort_array(List<Integer> arr) {\n        return arr.stream()\n                  .sorted(Comparator.comparingInt(this::countOnes)\n                                    .thenComparingInt(i -> i))\n                  .collect(Collectors.toList());\n    }\n\n    private int countOnes(int num) {\n        if (num < 0) {\n            num = ~num + 1; // Convert negative number to its positive equivalent\n        }\n        int onesCount = 0;\n        while (num > 0) {\n            onesCount += num & 1;\n            num >>= 1;\n        }\n        return onesCount;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        List<Integer> test1 = Arrays.asList(1, 5, 2, 3, 4);\n        System.out.println(\"Test Case 1: \" + solution.sort_array(test1).equals(Arrays.asList(1, 2, 4, 3, 5)));\n\n        List<Integer> test2 = Arrays.asList(-2, -3, -4, -5, -6);\n        System.out.println(\"Test Case 2: \" + solution.sort_array(test2).equals(Arrays.asList(-4, -2, -6, -5, -3)));\n\n        List<Integer> test3 = Arrays.asList(1, 0, 2, 3, 4);\n        System.out.println(\"Test Case 3: \" + solution.sort_array(test3).equals(Arrays.asList(0, 1, 2, 4, 3)));\n    }\n}\n"}
{"task_id": "Java/117", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a string s and a natural number n, you have been tasked to implement\n     * a function that returns a list of all words from string s that contain exactly\n     * n consonants, in order these words appear in the string s.\n     * If the string s is empty then the function should return an empty list.\n     * Note: you may assume the input string contains only letters and spaces.\n     * Examples:\n     * select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n     * select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n     * select_words(\"simple white space\", 2) ==> []\n     * select_words(\"Hello world\", 4) ==> [\"world\"]\n     * select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\n     */\n    public List<String> select_words(String s, int n) {\n        if (s == null || s.isEmpty()) {\n            return new ArrayList<>();\n        }\n\n        String[] words = s.split(\"\\\\s+\");\n        List<String> result = new ArrayList<>();\n\n        for (String word : words) {\n            long consonantCount = word.toLowerCase().chars()\n                    .filter(c -> \"bcdfghjklmnpqrstvwxyz\".indexOf(c) != -1)\n                    .count();\n\n            if (consonantCount == n) {\n                result.add(word);\n            }\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.select_words(\"Mary had a little lamb\", 4)); // [\"little\"]\n        System.out.println(solution.select_words(\"Mary had a little lamb\", 3)); // [\"Mary\", \"lamb\"]\n        System.out.println(solution.select_words(\"simple white space\", 2));     // []\n        System.out.println(solution.select_words(\"Hello world\", 4));            // [\"world\"]\n        System.out.println(solution.select_words(\"Uncle sam\", 3));              // [\"Uncle\"]\n    }\n}\n"}
{"task_id": "Java/118", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * You are given a word. Your task is to find the closest vowel that stands between\n     * two consonants from the right side of the word (case sensitive).\n     *\n     * Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n     * find any vowel met the above condition.\n     *\n     * You may assume that the given string contains English letter only.\n     */\n    public String get_closest_vowel(String word) {\n        // Convert the input to a character array for easier manipulation\n        char[] chars = word.toCharArray();\n        \n        // Iterate from right to left, looking for vowels between consonants\n        for (int i = chars.length - 2; i > 0; i--) {\n            if (isVowel(chars[i]) && isConsonant(chars[i-1]) && isConsonant(chars[i+1])) {\n                return String.valueOf(chars[i]);\n            }\n        }\n        \n        // If no vowel found, return an empty string\n        return \"\";\n    }\n\n    private boolean isVowel(char c) {\n        return \"AEIOUaeiou\".indexOf(c) != -1;\n    }\n\n    private boolean isConsonant(char c) {\n        return !isVowel(c);\n    }\n    \n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.get_closest_vowel(\"yogurt\"));  // Output: \"u\"\n        System.out.println(solution.get_closest_vowel(\"FULL\"));    // Output: \"U\"\n        System.out.println(solution.get_closest_vowel(\"quick\"));   // Output: \"\"\n        System.out.println(solution.get_closest_vowel(\"ab\"));      // Output: \"\"\n        System.out.println(solution.get_closest_vowel(\"aBcDeFgHiJkLmNoPqRsTuVwXyZ\"));  // Output: \"u\"\n    }\n}\n"}
{"task_id": "Java/119", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public String match_parens(List<String> lst) {\n        // Helper method to check if a given string is balanced\n        boolean isBalanced(String s) {\n            int balance = 0;\n            for (char c : s.toCharArray()) {\n                if (c == '(') {\n                    balance++;\n                } else {\n                    balance--;\n                }\n                if (balance < 0) {\n                    return false;\n                }\n            }\n            return balance == 0;\n        }\n\n        // Check both possible concatenations\n        if (isBalanced(lst.get(0) + lst.get(1)) || isBalanced(lst.get(1) + lst.get(0))) {\n            return \"Yes\";\n        } else {\n            return \"No\";\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.match_parens(Arrays.asList(\"()(\", \")\")));  // Output: Yes\n        System.out.println(solution.match_parens(Arrays.asList(\")\", \")\")));    // Output: No\n    }\n}\n"}
{"task_id": "Java/120", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     Given an array arr of integers and a positive integer k, return a sorted list\n     of length k with the maximum k numbers in arr, in ascending order.\n     */\n    public List<Integer> maximum(List<Integer> arr, int k) {\n        // Sort the array in descending order\n        Collections.sort(arr, Collections.reverseOrder());\n        \n        // Create a new list to store the top k elements\n        List<Integer> result = new ArrayList<>();\n        \n        // Add the first k elements from the sorted array to the result list\n        for (int i = 0; i < Math.min(k, arr.size()); i++) {\n            result.add(arr.get(i));\n        }\n        \n        // Sort the result list in ascending order before returning\n        Collections.sort(result);\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        List<Integer> arr1 = Arrays.asList(-3, -4, 5);\n        int k1 = 3;\n        System.out.println(\"Test Case 1: \" + solution.maximum(arr1, k1)); // Expected: [-4, -3, 5]\n\n        // Test case 2\n        List<Integer> arr2 = Arrays.asList(4, -4, 4);\n        int k2 = 2;\n        System.out.println(\"Test Case 2: \" + solution.maximum(arr2, k2)); // Expected: [4, 4]\n\n        // Test case 3\n        List<Integer> arr3 = Arrays.asList(-3, 2, 1, 2, -1, -2, 1);\n        int k3 = 1;\n        System.out.println(\"Test Case 3: \" + solution.maximum(arr3, k3)); // Expected: [2]\n    }\n}\n"}
{"task_id": "Java/121", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n     *\n     * Examples:\n     * solution(Arrays.asList(5, 8, 7, 1)) ==> 12\n     * solution(Arrays.asList(3, 3, 3, 3, 3)) ==> 9\n     * solution(Arrays.asList(30, 13, 24, 321)) ==> 0\n     */\n    public int solution(List<Integer> lst) {\n        int sum = 0;\n        for (int i = 0; i < lst.size(); i += 2) {\n            if (lst.get(i) % 2 != 0) {\n                sum += lst.get(i);\n            }\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.solution(Arrays.asList(5, 8, 7, 1))); // Expected output: 12\n        System.out.println(solution.solution(Arrays.asList(3, 3, 3, 3, 3))); // Expected output: 9\n        System.out.println(solution.solution(Arrays.asList(30, 13, 24, 321))); // Expected output: 0\n    }\n}\n"}
{"task_id": "Java/122", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     Given a non-empty array of integers arr and an integer k, return\n     the sum of the elements with at most two digits from the first k elements of arr.\n     \n     Example:\n     \n         Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n         Output: 24 # sum of 21 + 3\n     \n     Constraints:\n         1. 1 <= len(arr) <= 100\n         2. 1 <= k <= len(arr)\n      */\n    public int add_elements(List<Integer> arr, int k) {\n        int sum = 0;\n        for (int i = 0; i < Math.min(k, arr.size()); i++) {\n            if (arr.get(i).toString().length() <= 2) {\n                sum += arr.get(i);\n            }\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        List<Integer> arr1 = Arrays.asList(111, 21, 3, 4000, 5, 6, 7, 8, 9);\n        int k1 = 4;\n        System.out.println(\"Test Case 1: \" + solution.add_elements(arr1, k1)); // Expected output: 24\n\n        // Test case 2\n        List<Integer> arr2 = Arrays.asList(10, 20, 30, 40, 50);\n        int k2 = 3;\n        System.out.println(\"Test Case 2: \" + solution.add_elements(arr2, k2)); // Expected output: 60\n\n        // Test case 3\n        List<Integer> arr3 = Arrays.asList(1, 2, 3, 4, 5);\n        int k3 = 5;\n        System.out.println(\"Test Case 3: \" + solution.add_elements(arr3, k3)); // Expected output: 15\n\n        // Test case 4\n        List<Integer> arr4 = Arrays.asList(100, 200, 300);\n        int k4 = 2;\n        System.out.println(\"Test Case 4: \" + solution.add_elements(arr4, k4)); // Expected output: 0\n\n        // Test case 5\n        List<Integer> arr5 = Arrays.asList(1, 11, 111, 1111);\n        int k5 = 3;\n        System.out.println(\"Test Case 5: \" + solution.add_elements(arr5, k5)); // Expected output: 12\n\n    }\n}\n"}
{"task_id": "Java/123", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n     *\n     * @param n The starting positive integer for the Collatz sequence.\n     * @return A List of Integer containing the odd numbers in the Collatz sequence, sorted in increasing order.\n     */\n    public List<Integer> get_odd_collatz(int n) {\n        List<Integer> result = new ArrayList<>();\n        while (n != 1) {\n            if (n % 2 == 1) { // Check if n is odd\n                result.add(n);\n            }\n            n = n % 2 == 0 ? n / 2 : 3 * n + 1; // Apply Collatz rules\n        }\n        result.add(1); // Add the final term, which is always 1\n        Collections.sort(result); // Sort the list in increasing order\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.get_odd_collatz(5)); // Expected: [1, 5]\n        System.out.println(solution.get_odd_collatz(7)); // Expected: [1, 7, 11, 22]\n        System.out.println(solution.get_odd_collatz(10)); // Expected: [1, 5, 13]\n        System.out.println(solution.get_odd_collatz(1)); // Expected: [1]\n    }\n}\n"}
{"task_id": "Java/124", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * You have to write a function which validates a given date string and\n     * returns true if the date is valid otherwise false.\n     * The date is valid if all of the following rules are satisfied:\n     * 1. The date string is not empty.\n     * 2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.\n     * 3. The months should not be less than 1 or higher than 12.\n     * 4. The date should be in the format: mm-dd-yyyy\n     *\n     * for example:\n     * valid_date(\"03-11-2000\") => true\n     * valid_date(\"15-01-2012\") => false\n     * valid_date(\"04-0-2040\") => false\n     * valid_date(\"06-04-2020\") => true\n     * valid_date(\"06/04/2020\") => false\n     */\n    public boolean valid_date(String date) {\n        if (date == null || date.isEmpty()) return false;\n\n        String[] parts = date.split(\"-\");\n        if (parts.length != 3) return false;\n\n        int month = Integer.parseInt(parts[0]);\n        int day = Integer.parseInt(parts[1]);\n        int year = Integer.parseInt(parts[2]);\n\n        if (month < 1 || month > 12) return false;\n        if (day < 1 || day > 31) return false;\n\n        // Check for months with 30 days\n        if ((month == 4 || month == 6 || month == 9 || month == 11) && day > 30) return false;\n\n        // Check for February and leap years\n        if (month == 2) {\n            if (day > 29) return false;\n            if (day == 29 && !isLeapYear(year)) return false;\n        }\n\n        return true;\n    }\n\n    private boolean isLeapYear(int year) {\n        return (year % 4 == 0 && (year % 100 != 0 || year % 400 == 0));\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.valid_date(\"03-11-2000\")); // true\n        System.out.println(solution.valid_date(\"15-01-2012\")); // false\n        System.out.println(solution.valid_date(\"04-0-2040\"));  // false\n        System.out.println(solution.valid_date(\"06-04-2020\")); // true\n        System.out.println(solution.valid_date(\"06/04/2020\")); // false\n    }\n}\n"}
{"task_id": "Java/125", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n     should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n     alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n     Examples:\n     split_words(\"Hello world!\") == [\"Hello\", \"world!\"]\n     split_words(\"Hello,world!\") == [\"Hello\", \"world!\"]\n     split_words(\"abcdef\") == 3\n     */\n    public Object split_words(String txt) {\n        if (txt.contains(\" \")) {\n            return Arrays.asList(txt.split(\"\\\\s+\"));\n        } else if (txt.contains(\",\")) {\n            return Arrays.asList(txt.split(\",\"));\n        } else {\n            int count = 0;\n            for (char c : txt.toCharArray()) {\n                if (Character.isLowerCase(c) && ((c - 'a') % 2 == 1)) {\n                    count++;\n                }\n            }\n            return count;\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.split_words(\"Hello world!\")); // [\"Hello\", \"world!\"]\n        System.out.println(solution.split_words(\"Hello,world!\")); // [\"Hello\", \"world!\"]\n        System.out.println(solution.split_words(\"abcdef\"));      // 3\n\n        // Additional test cases\n        System.out.println(solution.split_words(\"a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z\")); // 13\n        System.out.println(solution.split_words(\"A quick, brown fox!\")); // [\"A\", \"quick,\", \"brown\", \"fox!\"]\n        System.out.println(solution.split_words(\"noSpacesOrCommas\")); // 5\n    }\n}\n"}
{"task_id": "Java/126", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given a list of numbers, return whether or not they are sorted in ascending order.\n     * If the number appears more than twice, return false. Assume no negative numbers and only integers.\n     *\n     * Examples:\n     * is_sorted(Arrays.asList(5)) -> true\n     * is_sorted(Arrays.asList(1, 2, 3, 4, 5)) -> true\n     * is_sorted(Arrays.asList(1, 3, 2, 4, 5)) -> false\n     * is_sorted(Arrays.asList(1, 2, 3, 4, 5, 6)) -> true\n     * is_sorted(Arrays.asList(1, 2, 3, 4, 5, 6, 7)) -> true\n     * is_sorted(Arrays.asList(1, 3, 2, 4, 5, 6, 7)) -> false\n     * is_sorted(Arrays.asList(1, 2, 2, 3, 3, 4)) -> true\n     * is_sorted(Arrays.asList(1, 2, 2, 2, 3, 4)) -> false\n     */\n    public boolean is_sorted(List<Integer> lst) {\n        if (lst == null || lst.size() <= 1) {\n            return true;\n        }\n\n        int count = 1; // To keep track of consecutive duplicates\n\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i).equals(lst.get(i - 1))) {\n                count++;\n                if (count > 2) {\n                    return false;\n                }\n            } else {\n                count = 1;\n            }\n\n            if (lst.get(i) < lst.get(i - 1)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.is_sorted(Arrays.asList(5))); // true\n        System.out.println(solution.is_sorted(Arrays.asList(1, 2, 3, 4, 5))); // true\n        System.out.println(solution.is_sorted(Arrays.asList(1, 3, 2, 4, 5))); // false\n        System.out.println(solution.is_sorted(Arrays.asList(1, 2, 3, 4, 5, 6))); // true\n        System.out.println(solution.is_sorted(Arrays.asList(1, 2, 3, 4, 5, 6, 7))); // true\n        System.out.println(solution.is_sorted(Arrays.asList(1, 3, 2, 4, 5, 6, 7))); // false\n        System.out.println(solution.is_sorted(Arrays.asList(1, 2, 2, 3, 3, 4))); // true\n        System.out.println(solution.is_sorted(Arrays.asList(1, 2, 2, 2, 3, 4))); // false\n    }\n}\n"}
{"task_id": "Java/127", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public String intersection(List<Integer> interval1, List<Integer> interval2) {\n        int start = Math.max(interval1.get(0), interval2.get(0));\n        int end = Math.min(interval1.get(1), interval2.get(1));\n\n        if (start > end) {\n            return \"NO\";\n        }\n\n        int length = end - start + 1;\n\n        if (isPrime(length)) {\n            return \"YES\";\n        } else {\n            return \"NO\";\n        }\n    }\n\n    private boolean isPrime(int n) {\n        if (n <= 1) {\n            return false;\n        }\n        for (int i = 2; i * i <= n; i++) {\n            if (n % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n"}
{"task_id": "Java/128", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * You are given an array arr of integers and you need to return\n     * sum of magnitudes of integers multiplied by product of all signs\n     * of each number in the array, represented by 1, -1 or 0.\n     * Note: return None for empty arr.\n     *\n     * Example:\n     * >>> prod_signs(Arrays.asList(1, 2, 2, -4)) == -9\n     * >>> prod_signs(Arrays.asList(0, 1)) == 0\n     * >>> prod_signs(Arrays.asList()) == Optional.empty()\n     */\n    public Optional<Integer> prod_signs(List<Integer> arr) {\n        if (arr.isEmpty()) {\n            return Optional.empty();\n        }\n\n        int sumOfMagnitudes = 0;\n        int productOfSigns = 1;\n\n        for (Integer num : arr) {\n            sumOfMagnitudes += Math.abs(num);\n            if (num == 0) {\n                productOfSigns = 0;\n                break;\n            } else if (num < 0) {\n                productOfSigns *= -1;\n            }\n        }\n\n        return Optional.of(sumOfMagnitudes * productOfSigns);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.prod_signs(Arrays.asList(1, 2, 2, -4))); // Expected output: Optional[-9]\n        System.out.println(solution.prod_signs(Arrays.asList(0, 1)));        // Expected output: Optional[0]\n        System.out.println(solution.prod_signs(Arrays.asList()));           // Expected output: Optional.empty\n    }\n}\n"}
{"task_id": "Java/129", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> minPath(List<List<Integer>> grid, int k) {\n        int n = grid.size();\n        int[][] directions = {{0, 1}, {1, 0}, {-1, 0}, {0, -1}};\n        Set<String> visited = new HashSet<>();\n        PriorityQueue<int[]> heap = new PriorityQueue<>((a, b) -> a[0] - b[0]);\n        heap.offer(new int[]{grid.get(0).get(0), 0, 0}); // (value, x, y)\n\n        while (!heap.isEmpty() && k > 0) {\n            int[] current = heap.poll();\n            int value = current[0];\n            int x = current[1];\n            int y = current[2];\n\n            if (visited.contains(x + \",\" + y)) {\n                continue;\n            }\n            visited.add(x + \",\" + y);\n            k--;\n\n            if (k == 0) {\n                break;\n            }\n\n            for (int[] dir : directions) {\n                int nx = x + dir[0];\n                int ny = y + dir[1];\n\n                if (nx >= 0 && nx < n && ny >= 0 && ny < n && !visited.contains(nx + \",\" + ny)) {\n                    heap.offer(new int[]{grid.get(nx).get(ny), nx, ny});\n                }\n            }\n        }\n\n        List<Integer> result = new ArrayList<>();\n        while (!heap.isEmpty()) {\n            result.add(heap.poll()[0]);\n        }\n        return result;\n    }\n}\n"}
{"task_id": "Java/130", "generation": "import java.util.ArrayList;\nimport java.util.List;\n\nclass Solution {\n    public List<Integer> tri(int n) {\n        if (n == 0) {\n            return new ArrayList<>();\n        } else if (n == 1) {\n            List<Integer> sequence = new ArrayList<>();\n            sequence.add(3);\n            return sequence;\n        }\n\n        List<Integer> sequence = new ArrayList<>();\n        sequence.add(3); // tri(1)\n\n        for (int i = 2; i <= n; i++) {\n            int nextValue;\n            if (i % 2 == 0) {\n                nextValue = 1 + (i / 2);\n            } else {\n                nextValue = sequence.get(i - 1) + sequence.get(i - 2) + sequence.get(0);\n            }\n            sequence.add(nextValue);\n        }\n\n        return sequence;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        List<Integer> result = solution.tri(3);\n        System.out.println(result); // Output: [3, 2, 8, 4]\n    }\n}\n"}
{"task_id": "Java/131", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     Given a positive integer n, return the product of the odd digits.\n     Return 0 if all digits are even.\n     For example:\n     digits(1)  == 1\n     digits(4)  == 0\n     digits(235) == 15\n     */\n    public int digits(int n) {\n        int product = 1;\n        boolean hasOddDigit = false;\n\n        while (n > 0) {\n            int digit = n % 10;\n            if (digit % 2 != 0) {\n                product *= digit;\n                hasOddDigit = true;\n            }\n            n /= 10;\n        }\n\n        return hasOddDigit ? product : 0;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.digits(1));   // Output: 1\n        System.out.println(solution.digits(4));   // Output: 0\n        System.out.println(solution.digits(235)); // Output: 15\n        System.out.println(solution.digits(2468)); // Output: 0\n        System.out.println(solution.digits(13579)); // Output: 945\n    }\n}\n"}
{"task_id": "Java/132", "generation": "import java.util.*;\n\nclass Solution {\n    public boolean is_nested(String string) {\n        Deque<Character> stack = new ArrayDeque<>();\n        boolean nested = false;\n        \n        for (char bracket : string.toCharArray()) {\n            if (bracket == '[') {\n                stack.push(bracket);\n            } else if (bracket == ']' && !stack.isEmpty()) {\n                stack.pop();\n                nested = true;\n            }\n        }\n        \n        return nested && stack.isEmpty();\n    }\n}\n"}
{"task_id": "Java/133", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int sum_squares(List<Double> lst) {\n        List<Integer> roundedList = new ArrayList<>();\n        \n        // Round each element to the nearest upper integer (ceiling)\n        for (Double num : lst) {\n            double ceilValue = Math.ceil(num);\n            roundedList.add((int) ceilValue);\n        }\n        \n        int sumOfSquares = 0;\n        \n        // Calculate the sum of squares of the rounded elements\n        for (Integer num : roundedList) {\n            sumOfSquares += num * num;\n        }\n        \n        return sumOfSquares;\n    }\n}\n"}
{"task_id": "Java/134", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public boolean check_if_last_char_is_a_letter(String txt) {\n        // Check if the string is empty\n        if (txt == null || txt.isEmpty()) {\n            return false;\n        }\n        \n        // Get the last character of the string\n        char lastChar = txt.charAt(txt.length() - 1);\n        \n        // Check if the last character is an alphabetical character and not part of a word\n        if (Character.isLetter(lastChar) && \n            (txt.length() == 1 || !Character.isLetterOrDigit(txt.charAt(txt.length() - 2)))) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.check_if_last_char_is_a_letter(\"apple pie\")); // false\n        System.out.println(solution.check_if_last_char_is_a_letter(\"apple pi e\")); // true\n        System.out.println(solution.check_if_last_char_is_a_letter(\"apple pi e \")); // false\n        System.out.println(solution.check_if_last_char_is_a_letter(\"\")); // false\n    }\n}\n"}
{"task_id": "Java/135", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Create a function which returns the largest index of an element which\n     * is not greater than or equal to the element immediately preceding it. If\n     * no such element exists then return -1. The given array will not contain\n     * duplicate values.\n     *\n     * Examples:\n     * can_arrange(Arrays.asList(1,2,4,3,5)) = 3\n     * can_arrange(Arrays.asList(1,2,3)) = -1\n     */\n    public int can_arrange(List<Integer> arr) {\n        int n = arr.size();\n        for (int i = 1; i < n; i++) {\n            if (arr.get(i) < arr.get(i - 1)) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.can_arrange(Arrays.asList(1, 2, 4, 3, 5))); // Expected output: 3\n        System.out.println(solution.can_arrange(Arrays.asList(1, 2, 3)));       // Expected output: -1\n    }\n}\n"}
{"task_id": "Java/136", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Create a function that returns a tuple (a, b), where 'a' is\n     * the largest of negative integers, and 'b' is the smallest\n     * of positive integers in a list.\n     * If there is no negative or positive integers, return them as None.\n     *\n     * Examples:\n     * largest_smallest_integers(Arrays.asList(2, 4, 1, 3, 5, 7)) == (Optional.empty(), Optional.of(1))\n     * largest_smallest_integers(Arrays.asList()) == (Optional.empty(), Optional.empty())\n     * largest_smallest_integers(Arrays.asList(0)) == (Optional.empty(), Optional.empty())\n     */\n    public List<Optional<Integer>> largest_smallest_integers(List<Integer> lst) {\n        if (lst.isEmpty()) {\n            return Arrays.asList(Optional.empty(), Optional.empty());\n        }\n\n        Optional<Integer> smallestPositive = lst.stream()\n                .filter(n -> n > 0)\n                .min(Integer::compare);\n\n        Optional<Integer> largestNegative = lst.stream()\n                .filter(n -> n < 0)\n                .max(Integer::compare);\n\n        return Arrays.asList(largestNegative, smallestPositive);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.largest_smallest_integers(Arrays.asList(2, 4, 1, 3, 5, 7))); // (Optional.empty(), Optional.of(1))\n        System.out.println(solution.largest_smallest_integers(Arrays.asList()));                // (Optional.empty(), Optional.empty())\n        System.out.println(solution.largest_smallest_integers(Arrays.asList(0)));               // (Optional.empty(), Optional.empty())\n        System.out.println(solution.largest_smallest_integers(Arrays.asList(-2, -4, -1, -3)));  // (Optional.of(-1), Optional.empty())\n        System.out.println(solution.largest_smallest_integers(Arrays.asList(2, -4, 1, -3, 5))); // (Optional.empty(), Optional.of(1))\n    }\n}\n"}
{"task_id": "Java/137", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public Optional<Object> compare_one(Object a, Object b) {\n        if (a instanceof Integer && b instanceof Integer) {\n            int ai = (Integer) a;\n            int bi = (Integer) b;\n            return ai > bi ? Optional.of(a) : Optional.empty();\n        } else if (a instanceof Double && b instanceof Double) {\n            double ad = (Double) a;\n            double bd = (Double) b;\n            return ad > bd ? Optional.of(a) : Optional.empty();\n        } else if (a instanceof String && b instanceof String) {\n            String astr = ((String) a).replace(',', '.');\n            String bstr = ((String) b).replace(',', '.');\n            double ad = Double.parseDouble(astr);\n            double bd = Double.parseDouble(bstr);\n            return ad > bd ? Optional.of(a) : Optional.empty();\n        } else {\n            return Optional.empty();\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.compare_one(1, 2.5)); // Optional[2.5]\n        System.out.println(solution.compare_one(1, \"2,3\")); // Optional[\"2,3\"]\n        System.out.println(solution.compare_one(\"5,1\", \"6\")); // Optional[\"6\"]\n        System.out.println(solution.compare_one(\"1\", 1)); // Optional.empty\n    }\n}\n"}
{"task_id": "Java/138", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers\n     * Example:\n     * is_equal_to_sum_even(4) == false\n     * is_equal_to_sum_even(6) == false\n     * is_equal_to_sum_even(8) == true\n     */\n    public boolean is_equal_to_sum_even(int n) {\n        // The smallest sum of 4 positive even numbers is 2 + 2 + 2 + 2 = 8.\n        if (n < 8 || n % 2 != 0) {\n            return false;\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(\"is_equal_to_sum_even(4): \" + solution.is_equal_to_sum_even(4)); // false\n        System.out.println(\"is_equal_to_sum_even(6): \" + solution.is_equal_to_sum_even(6)); // false\n        System.out.println(\"is_equal_to_sum_even(8): \" + solution.is_equal_to_sum_even(8)); // true\n        System.out.println(\"is_equal_to_sum_even(10): \" + solution.is_equal_to_sum_even(10)); // true\n        System.out.println(\"is_equal_to_sum_even(12): \" + solution.is_equal_to_sum_even(12)); // true\n        System.out.println(\"is_equal_to_sum_even(14): \" + solution.is_equal_to_sum_even(14)); // true\n        System.out.println(\"is_equal_to_sum_even(16): \" + solution.is_equal_to_sum_even(16)); // true\n        System.out.println(\"is_equal_to_sum_even(7): \" + solution.is_equal_to_sum_even(7)); // false\n    }\n}\n"}
{"task_id": "Java/139", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * The Brazilian factorial is defined as:\n     * brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n     * where n > 0\n     *\n     * For example:\n     * >>> special_factorial(4)\n     * 288\n     *\n     * The function will receive an integer as input and should return the special factorial of this integer.\n     */\n    public long special_factorial(int n) {\n        if (n == 0 || n == 1) {\n            return 1;\n        }\n        \n        long result = 1;\n        for (int i = 1; i <= n; i++) {\n            result *= factorial(i);\n        }\n        return result;\n    }\n\n    private long factorial(int num) {\n        if (num == 0 || num == 1) {\n            return 1;\n        }\n        \n        long fact = 1;\n        for (int i = 2; i <= num; i++) {\n            fact *= i;\n        }\n        return fact;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(\"special_factorial(4): \" + solution.special_factorial(4)); // Expected: 288\n        System.out.println(\"special_factorial(3): \" + solution.special_factorial(3)); // Expected: 12\n        System.out.println(\"special_factorial(5): \" + solution.special_factorial(5)); // Expected: 34560\n        System.out.println(\"special_factorial(1): \" + solution.special_factorial(1)); // Expected: 1\n    }\n}\n"}
{"task_id": "Java/140", "generation": "import java.util.*;\n\nclass Solution {\n    public String fix_spaces(String text) {\n        StringBuilder result = new StringBuilder();\n        int spaceCount = 0;\n\n        for (char c : text.toCharArray()) {\n            if (c == ' ') {\n                spaceCount++;\n            } else {\n                if (spaceCount > 2) {\n                    result.append('-');\n                } else if (spaceCount >= 1) {\n                    for (int i = 0; i < spaceCount; i++) {\n                        result.append('_');\n                    }\n                }\n                spaceCount = 0;\n                result.append(c);\n            }\n        }\n\n        // Handle trailing spaces\n        if (spaceCount > 2) {\n            result.append('-');\n        } else if (spaceCount >= 1) {\n            for (int i = 0; i < spaceCount; i++) {\n                result.append('_');\n            }\n        }\n\n        return result.toString();\n    }\n}\n"}
{"task_id": "Java/141", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Create a function which takes a string representing a file's name, and returns\n     * \"Yes\" if the the file's name is valid, and returns \"No\" otherwise.\n     * A file's name is considered to be valid if and only if all the following conditions\n     * are met:\n     * - There should not be more than three digits ('0'-'9') in the file's name.\n     * - The file's name contains exactly one dot '.'\n     * - The substring before the dot should not be empty, and it starts with a letter from\n     *   the latin alphapet ('a'-'z' and 'A'-'Z').\n     * - The substring after the dot should be one of these: [\"txt\", \"exe\", \"dll\"]\n     * Examples:\n     * file_name_check(\"example.txt\") # => \"Yes\"\n     * file_name_check(\"1example.dll\") # => \"No\" (the name should start with a latin alphapet letter)\n     */\n    public String file_name_check(String file_name) {\n        // Check for exactly one dot\n        int dotCount = 0;\n        for (char c : file_name.toCharArray()) {\n            if (c == '.') {\n                dotCount++;\n            }\n        }\n        if (dotCount != 1) return \"No\";\n\n        // Split the filename into two parts: before and after the dot\n        String[] parts = file_name.split(\"\\\\.\");\n        if (parts.length != 2) return \"No\"; // Should have exactly one dot\n\n        // Check for empty part before the dot\n        if (parts[0].isEmpty()) return \"No\";\n\n        // Check if the first character is a letter\n        char firstChar = parts[0].charAt(0);\n        if (!Character.isLetter(firstChar)) return \"No\";\n\n        // Check for more than three digits in the file name\n        int digitCount = 0;\n        for (char c : file_name.toCharArray()) {\n            if (Character.isDigit(c)) {\n                digitCount++;\n            }\n        }\n        if (digitCount > 3) return \"No\";\n\n        // Check the extension part after the dot\n        String ext = parts[1];\n        if (!ext.equals(\"txt\") && !ext.equals(\"exe\") && !ext.equals(\"dll\")) return \"No\";\n\n        return \"Yes\";\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.file_name_check(\"example.txt\"));  // Expected: Yes\n        System.out.println(solution.file_name_check(\"1example.dll\")); // Expected: No (starts with a digit)\n        System.out.println(solution.file_name_check(\".txt\"));         // Expected: No (empty part before the dot)\n        System.out.println(solution.file_name_check(\"example.exe\"));  // Expected: Yes\n        System.out.println(solution.file_name_check(\"example123.dll\"));// Expected: Yes\n        System.out.println(solution.file_name_check(\"example4567.dll\"));// Expected: No (more than three digits)\n    }\n}\n"}
{"task_id": "Java/142", "generation": "import java.util.List;\nimport java.util.Arrays;\n\nclass Solution {\n    /**\n    This function will take a list of integers. For all entries in the list, the function shall square the integer entry if its index is a multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not\n    change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries.\n\n    Examples:\n    For lst = [1,2,3] the output should be 6\n    For lst = []  the output should be 0\n    For lst = [-1,-5,2,-1,-5]  the output should be -126\n     */\n    public int sumSquares(List<Integer> lst) {\n        int totalSum = 0;\n        \n        for (int i = 0; i < lst.size(); i++) {\n            int num = lst.get(i);\n            if ((i + 1) % 3 == 0) {\n                totalSum += num * num; // Square the number\n            } else if ((i + 1) % 4 == 0 && (i + 1) % 3 != 0) {\n                totalSum += num * num * num; // Cube the number\n            }\n        }\n        \n        return totalSum;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.sumSquares(Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12)));\n    }\n}\n"}
{"task_id": "Java/143", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * You are given a string representing a sentence,\n     * the sentence contains some words separated by a space,\n     * and you have to return a string that contains the words from the original sentence,\n     * whose lengths are prime numbers,\n     * the order of the words in the new string should be the same as the original one.\n     *\n     * Example 1:\n     * Input: sentence = \"This is a test\"\n     * Output: \"is\"\n     *\n     * Example 2:\n     * Input: sentence = \"lets go for swimming\"\n     * Output: \"go for\"\n     *\n     * Constraints:\n     * * 1 <= len(sentence) <= 100\n     * * sentence contains only letters\n     */\n    public String words_in_sentence(String sentence) {\n        List<String> words = Arrays.asList(sentence.split(\" \"));\n        StringBuilder result = new StringBuilder();\n        \n        for (String word : words) {\n            if (isPrime(word.length())) {\n                if (result.length() > 0) {\n                    result.append(\" \");\n                }\n                result.append(word);\n            }\n        }\n        \n        return result.toString();\n    }\n\n    private boolean isPrime(int number) {\n        if (number <= 1) {\n            return false;\n        }\n        for (int i = 2; i * i <= number; i++) {\n            if (number % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.words_in_sentence(\"This is a test\")); // Output: \"is\"\n        System.out.println(solution.words_in_sentence(\"lets go for swimming\")); // Output: \"go for\"\n        System.out.println(solution.words_in_sentence(\"one two three four five six seven eight nine ten\")); // Output: \"three five seven\"\n    }\n}\n"}
{"task_id": "Java/144", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Your task is to implement a function that will simplify the expression\n     * x * n. The function returns true if x * n evaluates to a whole number and false\n     * otherwise. Both x and n, are string representation of a fraction, and have the following format,\n     * <numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n     *\n     * You can assume that x, and n are valid fractions, and do not have zero as denominator.\n     */\n    public boolean simplify(String x, String n) {\n        // Split the strings into numerator and denominator\n        String[] xParts = x.split(\"/\");\n        String[] nParts = n.split(\"/\");\n\n        int xNumerator = Integer.parseInt(xParts[0]);\n        int xDenominator = Integer.parseInt(xParts[1]);\n        int nNumerator = Integer.parseInt(nParts[0]);\n        int nDenominator = Integer.parseInt(nParts[1]);\n\n        // Simplify the expression (x * n) / 1\n        int resultNumerator = xNumerator * nNumerator;\n        int resultDenominator = xDenominator * nDenominator;\n\n        // Check if the result is a whole number\n        return resultNumerator % resultDenominator == 0;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.simplify(\"1/5\", \"5/1\")); // true\n        System.out.println(solution.simplify(\"1/6\", \"2/1\")); // false\n        System.out.println(solution.simplify(\"7/10\", \"10/2\")); // false\n        System.out.println(solution.simplify(\"3/4\", \"4/3\")); // true\n        System.out.println(solution.simplify(\"5/8\", \"8/5\")); // true\n        System.out.println(solution.simplify(\"9/16\", \"16/9\")); // true\n    }\n}\n"}
{"task_id": "Java/145", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> order_by_points(List<Integer> nums) {\n        Collections.sort(nums, new Comparator<Integer>() {\n            @Override\n            public int compare(Integer o1, Integer o2) {\n                int sum1 = digitSum(o1);\n                int sum2 = digitSum(o2);\n\n                if (sum1 == sum2) {\n                    return nums.indexOf(o1) - nums.indexOf(o2);\n                }\n\n                return Integer.compare(sum1, sum2);\n            }\n        });\n\n        return nums;\n    }\n\n    private int digitSum(Integer n) {\n        if (n >= 0) {\n            return sumDigits(n.toString());\n        } else {\n            return -sumDigits(\"-\" + n.toString().substring(1));\n        }\n    }\n\n    private int sumDigits(String numberStr) {\n        int sum = 0;\n        for (char c : numberStr.toCharArray()) {\n            if (c != '-') {\n                sum += Character.getNumericValue(c);\n            }\n        }\n        return sum;\n    }\n}\n"}
{"task_id": "Java/146", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Write a function that takes an array of numbers as input and returns\n     * the number of elements in the array that are greater than 10 and both\n     * first and last digits of a number are odd (1, 3, 5, 7, 9).\n     * For example:\n     * specialFilter(Arrays.asList(15, -73, 14, -15)) => 1\n     * specialFilter(Arrays.asList(33, -2, -3, 45, 21, 109)) => 2\n     */\n    public int specialFilter(List<Integer> nums) {\n        int count = 0;\n        for (int num : nums) {\n            if (num > 10 && isFirstAndLastDigitOdd(num)) {\n                count++;\n            }\n        }\n        return count;\n    }\n\n    private boolean isFirstAndLastDigitOdd(int num) {\n        String strNum = Integer.toString(Math.abs(num));\n        int firstDigit = Character.digit(strNum.charAt(0), 10);\n        int lastDigit = Character.digit(strNum.charAt(strNum.length() - 1), 10);\n\n        return (firstDigit % 2 != 0) && (lastDigit % 2 != 0);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.specialFilter(Arrays.asList(15, -73, 14, -15))); // Expected output: 1\n        System.out.println(solution.specialFilter(Arrays.asList(33, -2, -3, 45, 21, 109))); // Expected output: 2\n        System.out.println(solution.specialFilter(Arrays.asList(-73, 14, 15, -15, 33, 45, 21, 109))); // Expected output: 3\n    }\n}\n"}
{"task_id": "Java/147", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * You are given a positive integer n. You have to create an integer array a of length n.\n     * For each i (1 <= i <= n), the value of a[i] = i * i - i + 1.\n     * Return the number of triples (a[i], a[j], a[k]) of a where i < j < k,\n     * and a[i] + a[j] + a[k] is a multiple of 3.\n     *\n     * Example :\n     * Input: n = 5\n     * Output: 1\n     * Explanation:\n     * a = [1, 3, 7, 13, 21]\n     * The only valid triple is (1, 7, 13).\n     */\n    public int get_max_triples(int n) {\n        List<Integer> a = new ArrayList<>();\n        \n        // Generate the array a\n        for (int i = 1; i <= n; i++) {\n            a.add(i * i - i + 1);\n        }\n        \n        int count = 0;\n        \n        // Iterate through all possible triples (i, j, k) where i < j < k\n        for (int i = 0; i < n - 2; i++) {\n            for (int j = i + 1; j < n - 1; j++) {\n                for (int k = j + 1; k < n; k++) {\n                    if ((a.get(i) + a.get(j) + a.get(k)) % 3 == 0) {\n                        count++;\n                    }\n                }\n            }\n        }\n        \n        return count;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.get_max_triples(5)); // Expected output: 1\n        System.out.println(solution.get_max_triples(6)); // Expected output: 2\n        System.out.println(solution.get_max_triples(7)); // Expected output: 3\n    }\n}\n"}
{"task_id": "Java/148", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * There are eight planets in our solar system: the closest to the Sun\n     * is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\n     * Uranus, Neptune.\n     * Write a function that takes two planet names as strings planet1 and planet2.\n     * The function should return a list containing all planets whose orbits are\n     * located between the orbit of planet1 and the orbit of planet2, sorted by\n     * the proximity to the Sun.\n     * The function should return an empty list if planet1 or planet2\n     * are not correct planet names.\n     * Examples:\n     * bf(\"Jupiter\", \"Neptune\") ==> [\"Saturn\", \"Uranus\"]\n     * bf(\"Earth\", \"Mercury\") ==> [\"Venus\"]\n     * bf(\"Mercury\", \"Uranus\") ==> [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"]\n     */\n    public List<String> bf(String planet1, String planet2) {\n        // Define the list of planets in order from closest to farthest from the Sun\n        List<String> planets = Arrays.asList(\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\");\n\n        // Check if both planet1 and planet2 are valid planet names\n        int index1 = planets.indexOf(planet1);\n        int index2 = planets.indexOf(planet2);\n\n        if (index1 == -1 || index2 == -1) {\n            return new ArrayList<>();\n        }\n\n        // Ensure that index1 is less than or equal to index2\n        if (index1 > index2) {\n            int temp = index1;\n            index1 = index2;\n            index2 = temp;\n        }\n\n        // Return the sublist of planets between the two given indices\n        return planets.subList(index1 + 1, index2);\n    }\n}\n"}
{"task_id": "Java/149", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Write a function that accepts a list of strings as a parameter,\n     * deletes the strings that have odd lengths from it,\n     * and returns the resulted list with a sorted order.\n     * The list is always a list of strings and never an array of numbers,\n     * and it may contain duplicates.\n     * The order of the list should be ascending by length of each word, and you\n     * should return the list sorted by that rule.\n     * If two words have the same length, sort the list alphabetically.\n     * The function should return a list of strings in sorted order.\n     * You may assume that all words will have the same length.\n     * For example:\n     * assert sorted_list_sum(Arrays.asList(\"aa\", \"a\", \"aaa\")) => [\"aa\"]\n     * assert sorted_list_sum(Arrays.asList(\"ab\", \"a\", \"aaa\", \"cd\")) => [\"ab\", \"cd\"]\n     */\n    public List<String> sorted_list_sum(List<String> lst) {\n        // Remove strings with odd lengths\n        lst.removeIf(s -> s.length() % 2 != 0);\n\n        // Sort the list by length, then alphabetically if lengths are equal\n        Collections.sort(lst, (s1, s2) -> {\n            int lenCompare = Integer.compare(s1.length(), s2.length());\n            return lenCompare == 0 ? s1.compareTo(s2) : lenCompare;\n        });\n\n        return lst;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        List<String> test1 = Arrays.asList(\"aa\", \"a\", \"aaa\");\n        System.out.println(solution.sorted_list_sum(test1)); // Expected: [aa]\n\n        List<String> test2 = Arrays.asList(\"ab\", \"a\", \"aaa\", \"cd\");\n        System.out.println(solution.sorted_list_sum(test2)); // Expected: [ab, cd]\n\n        List<String> test3 = Arrays.asList(\"hello\", \"world\", \"hi\", \"bye\");\n        System.out.println(solution.sorted_list_sum(test3)); // Expected: [hi, bye]\n    }\n}\n"}
{"task_id": "Java/150", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * A simple program which should return the value of x if n is\n     * a prime number and should return the value of y otherwise.\n     *\n     * Examples:\n     * for x_or_y(7, 34, 12) == 34\n     * for x_or_y(15, 8, 5) == 5\n     */\n    public int x_or_y(int n, int x, int y) {\n        if (isPrime(n)) {\n            return x;\n        } else {\n            return y;\n        }\n    }\n\n    /**\n     * Helper method to check if a number is prime.\n     *\n     * @param num the number to check\n     * @return true if the number is prime, false otherwise\n     */\n    private boolean isPrime(int num) {\n        if (num <= 1) return false;\n        for (int i = 2; i <= Math.sqrt(num); i++) {\n            if (num % i == 0) return false;\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.x_or_y(7, 34, 12)); // Expected output: 34 (since 7 is prime)\n        System.out.println(solution.x_or_y(15, 8, 5));  // Expected output: 5 (since 15 is not prime)\n        System.out.println(solution.x_or_y(2, 10, 20)); // Expected output: 10 (since 2 is prime)\n        System.out.println(solution.x_or_y(4, 30, 40)); // Expected output: 40 (since 4 is not prime)\n    }\n}\n"}
{"task_id": "Java/151", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     Given a list of numbers, return the sum of squares of the numbers\n     in the list that are odd. Ignore numbers that are negative or not integers.\n     */\n    public int double_the_difference(List<Object> lst) {\n        int result = 0;\n        for (Object obj : lst) {\n            if (obj instanceof Integer) {\n                int num = (Integer) obj;\n                if (num > 0 && num % 2 != 0) {\n                    result += num * num;\n                }\n            }\n        }\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.double_the_difference(Arrays.asList(1, 3, 2, 0))); // Expected output: 10\n        System.out.println(solution.double_the_difference(Arrays.asList(-1, -2, 0))); // Expected output: 0\n        System.out.println(solution.double_the_difference(Arrays.asList(9, -2)));      // Expected output: 81\n        System.out.println(solution.double_the_difference(Arrays.asList(0)));          // Expected output: 0\n        System.out.println(solution.double_the_difference(new ArrayList<>()));         // Expected output: 0\n    }\n}\n"}
{"task_id": "Java/152", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Compares the game scores with the guesses and returns an array of how far off each guess was.\n     *\n     * @param game  A list of integers representing the actual game scores.\n     * @param guess A list of integers representing the guessed scores.\n     * @return A list of integers where each element is the absolute difference between the guess and the score, or 0 if they are equal.\n     */\n    public List<Integer> compare(List<Integer> game, List<Integer> guess) {\n        List<Integer> result = new ArrayList<>();\n        for (int i = 0; i < game.size(); i++) {\n            int diff = Math.abs(game.get(i) - guess.get(i));\n            result.add(diff);\n        }\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        List<Integer> test1Game = Arrays.asList(1, 2, 3, 4, 5, 1);\n        List<Integer> test1Guess = Arrays.asList(1, 2, 3, 4, 2, -2);\n        System.out.println(solution.compare(test1Game, test1Guess)); // Expected: [0, 0, 0, 0, 3, 3]\n\n        List<Integer> test2Game = Arrays.asList(0, 5, 0, 0, 0, 4);\n        List<Integer> test2Guess = Arrays.asList(4, 1, 1, 0, 0, -2);\n        System.out.println(solution.compare(test2Game, test2Guess)); // Expected: [4, 4, 1, 0, 0, 6]\n    }\n}\n"}
{"task_id": "Java/153", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * You will be given the name of a class (a string) and a list of extensions.\n     * The extensions are to be used to load additional classes to the class. The\n     * strength of the extension is as follows: Let CAP be the number of the uppercase\n     * letters in the extension's name, and let SM be the number of lowercase letters\n     * in the extension's name, the strength is given by the fraction CAP - SM.\n     * You should find the strongest extension and return a string in this\n     * format: ClassName.Strongest_Extension.\n     * If there are two or more extensions with the same strength, you should\n     * choose the one that comes first in the list.\n     * For example, if you are given \"Slices\" as the class and a list of the\n     * extensions: [\"SErviNGSliCes\", \"Cheese\", \"StuFfed\"] then you should\n     * return \"Slices.SErviNGSliCes\" since \"SErviNGSliCes\" is the strongest extension\n     * (its strength is -1).\n     * Example:\n     * for Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"]) == \"my_class.AA\"\n     */\n    public String Strongest_Extension(String class_name, List<String> extensions) {\n        int maxStrength = Integer.MIN_VALUE;\n        String strongestExtension = \"\";\n        \n        for (String extension : extensions) {\n            int cap = 0, sm = 0;\n            for (char c : extension.toCharArray()) {\n                if (Character.isUpperCase(c)) {\n                    cap++;\n                } else if (Character.isLowerCase(c)) {\n                    sm++;\n                }\n            }\n            \n            int strength = cap - sm;\n            if (strength > maxStrength) {\n                maxStrength = strength;\n                strongestExtension = extension;\n            }\n        }\n        \n        return class_name + \".\" + strongestExtension;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.Strongest_Extension(\"Slices\", Arrays.asList(\"SErviNGSliCes\", \"Cheese\", \"StuFfed\"))); // Should print: Slices.SErviNGSliCes\n        System.out.println(solution.Strongest_Extension(\"my_class\", Arrays.asList(\"AA\", \"Be\", \"CC\"))); // Should print: my_class.AA\n        System.out.println(solution.Strongest_Extension(\"DataProcessor\", Arrays.asList(\"dataIO\", \"DATAIO\", \"dataio\"))); // Should print: DataProcessor.DATAIO\n    }\n}\n"}
{"task_id": "Java/154", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * You are given 2 words. You need to return true if the second word or any of its rotations is a substring in the first word.\n     * cycpattern_check(\"abcd\",\"abd\") => false\n     * cycpattern_check(\"hello\",\"ell\") => true\n     * cycpattern_check(\"whassup\",\"psus\") => false\n     * cycpattern_check(\"abab\",\"baa\") => true\n     * cycpattern_check(\"efef\",\"eeff\") => false\n     * cycpattern_check(\"himenss\",\"simen\") => true\n     */\n    public boolean cycpattern_check(String a, String b) {\n        if (b.length() > a.length()) {\n            return false;\n        }\n        \n        // Generate all rotations of the second word\n        for (int i = 0; i < b.length(); i++) {\n            String rotated = rotateString(b, i);\n            if (a.contains(rotated)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private String rotateString(String s, int k) {\n        int n = s.length();\n        k = k % n; // In case the rotation is greater than the length of the string\n        return s.substring(n - k) + s.substring(0, n - k);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.cycpattern_check(\"abcd\", \"abd\")); // false\n        System.out.println(solution.cycpattern_check(\"hello\", \"ell\")); // true\n        System.out.println(solution.cycpattern_check(\"whassup\", \"psus\")); // false\n        System.out.println(solution.cycpattern_check(\"abab\", \"baa\")); // true\n        System.out.println(solution.cycpattern_check(\"efef\", \"eeff\")); // false\n        System.out.println(solution.cycpattern_check(\"himenss\", \"simen\")); // true\n    }\n}\n"}
{"task_id": "Java/155", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> even_odd_count(int num) {\n        // Convert number to string to easily iterate over digits\n        String strNum = Integer.toString(Math.abs(num));\n        \n        // Initialize counters for even and odd digits\n        int evenCount = 0, oddCount = 0;\n        \n        // Iterate through each character in the string representation of the number\n        for (int i = 0; i < strNum.length(); i++) {\n            char digit = strNum.charAt(i);\n            if ((digit - '0') % 2 == 0) {\n                evenCount++;\n            } else {\n                oddCount++;\n            }\n        }\n        \n        // Create and return a list containing the counts of even and odd digits\n        List<Integer> result = new ArrayList<>();\n        result.add(evenCount);\n        result.add(oddCount);\n        return result;\n    }\n}\n"}
{"task_id": "Java/156", "generation": "import java.util.*;\n\nclass Solution {\n    public String int_to_mini_roman(int number) {\n        List<RomanNumeral> romanNumerals = Arrays.asList(\n            new RomanNumeral(1000, \"m\"), new RomanNumeral(900, \"cm\"),\n            new RomanNumeral(500, \"d\"), new RomanNumeral(400, \"cd\"),\n            new RomanNumeral(100, \"c\"), new RomanNumeral(90, \"xc\"),\n            new RomanNumeral(50, \"l\"), new RomanNumeral(40, \"xl\"),\n            new RomanNumeral(10, \"x\"), new RomanNumeral(9, \"ix\"),\n            new RomanNumeral(5, \"v\"), new RomanNumeral(4, \"iv\"),\n            new RomanNumeral(1, \"i\")\n        );\n\n        StringBuilder roman = new StringBuilder();\n        \n        for (RomanNumeral numeral : romanNumerals) {\n            while (number >= numeral.getValue()) {\n                roman.append(numeral.getSymbol());\n                number -= numeral.getValue();\n            }\n        }\n\n        return roman.toString().toLowerCase();\n    }\n\n    private static class RomanNumeral {\n        private final int value;\n        private final String symbol;\n\n        public RomanNumeral(int value, String symbol) {\n            this.value = value;\n            this.symbol = symbol;\n        }\n\n        public int getValue() {\n            return value;\n        }\n\n        public String getSymbol() {\n            return symbol;\n        }\n    }\n}\n"}
{"task_id": "Java/157", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given the lengths of the three sides of a triangle. Return true if the three\n     * sides form a right-angled triangle, false otherwise.\n     * A right-angled triangle is a triangle in which one angle is a right angle or 90 degrees.\n     * Example:\n     * right_angle_triangle(3, 4, 5) == true\n     * right_angle_triangle(1, 2, 3) == false\n     */\n    public boolean right_angle_triangle(int a, int b, int c) {\n        // Sort the sides to ensure the longest side is last\n        int[] sides = {a, b, c};\n        Arrays.sort(sides);\n        \n        // Check if the square of the longest side equals the sum of squares of other two sides\n        return Math.pow(sides[0], 2) + Math.pow(sides[1], 2) == Math.pow(sides[2], 2);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.right_angle_triangle(3, 4, 5)); // true\n        System.out.println(solution.right_angle_triangle(1, 2, 3)); // false\n        System.out.println(solution.right_angle_triangle(5, 12, 13)); // true\n        System.out.println(solution.right_angle_triangle(6, 8, 10)); // true\n        System.out.println(solution.right_angle_triangle(7, 10, 12)); // false\n    }\n}\n"}
{"task_id": "Java/158", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Write a function that accepts a list of strings.\n     * The list contains different words. Return the word with maximum number\n     * of unique characters. If multiple strings have maximum number of unique\n     * characters, return the one which comes first in lexicographical order.\n     *\n     * find_max([\"name\", \"of\", \"string\"]) == \"string\"\n     * find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n     * find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"aaaaaaa\"\n     */\n    public String find_max(List<String> words) {\n        if (words == null || words.isEmpty()) {\n            return \"\";\n        }\n\n        // Sort the list lexicographically\n        Collections.sort(words);\n\n        String maxWord = \"\";\n        int maxUniqueChars = 0;\n\n        for (String word : words) {\n            Set<Character> uniqueChars = new HashSet<>();\n            for (char c : word.toCharArray()) {\n                uniqueChars.add(c);\n            }\n\n            if (uniqueChars.size() > maxUniqueChars) {\n                maxUniqueChars = uniqueChars.size();\n                maxWord = word;\n            }\n        }\n\n        return maxWord;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.find_max(Arrays.asList(\"name\", \"of\", \"string\"))); // Output: string\n        System.out.println(solution.find_max(Arrays.asList(\"name\", \"enam\", \"game\"))); // Output: enam\n        System.out.println(solution.find_max(Arrays.asList(\"aaaaaaa\", \"bb\", \"cc\")));  // Output: aaaaaaa\n        System.out.println(solution.find_max(new ArrayList<>()));                     // Output: (empty string)\n        System.out.println(solution.find_max(Arrays.asList(\"abc\", \"defg\", \"hijk\")));  // Output: defg\n    }\n}\n"}
{"task_id": "Java/159", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * You're a hungry rabbit, and you already have eaten a certain number of carrots,\n     * but now you need to eat more carrots to complete the day's meals.\n     * return an array of [ total number of eaten carrots after your meals,\n     *                     the number of carrots left after your meals ]\n     * if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n     *\n     * Example:\n     * * eat(5, 6, 10) -> [11, 4]\n     * * eat(4, 8, 9) -> [12, 1]\n     * * eat(1, 10, 10) -> [11, 0]\n     * * eat(2, 11, 5) -> [7, 0]\n     *\n     * Variables:\n     * @number : integer\n     *        the number of carrots that you have eaten.\n     * @need : integer\n     *        the number of carrots that you need to eat.\n     * @remaining : integer\n     *        the number of remaining carrots thet exist in stock\n     *\n     * Constrain:\n     * * 0 <= number <= 1000\n     * * 0 <= need <= 1000\n     * * 0 <= remaining <= 1000\n     */\n    public List<Integer> eat(int number, int need, int remaining) {\n        // Calculate the total number of carrots to be eaten\n        int totalToEat = Math.min(need, remaining);\n        \n        // Update the number of carrots eaten and remaining\n        int newNumberEaten = number + totalToEat;\n        int newRemainingCarrots = remaining - totalToEat;\n\n        return Arrays.asList(newNumberEaten, newRemainingCarrots);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.eat(5, 6, 10)); // Expected: [11, 4]\n        System.out.println(solution.eat(4, 8, 9));  // Expected: [12, 1]\n        System.out.println(solution.eat(1, 10, 10)); // Expected: [11, 0]\n        System.out.println(solution.eat(2, 11, 5));  // Expected: [7, 0]\n    }\n}\n"}
{"task_id": "Java/160", "generation": "import java.util.*;\nimport javax.script.ScriptEngineManager;\nimport javax.script.ScriptEngine;\n\nclass Solution {\n    /**\n    Given two lists operator, and operand. The first list has basic algebra operations, and\n    the second list is a list of integers. Use the two given lists to build the algebric\n    expression and return the evaluation of this expression.\n\n    The basic algebra operations:\n    Addition ( + )\n    Subtraction ( - )\n    Multiplication ( * )\n    Floor division ( / )\n    Exponentiation ( ** )\n\n    Example:\n    operator[\"+\", \"*\", \"-\"]\n    array = [2, 3, 4, 5]\n    result = 2 + 3 * 4 - 5\n    => result = 9\n\n    Note:\n        The length of operator list is equal to the length of operand list minus one.\n        Operand is a list of non-negative integers.\n        Operator list has at least one operator, and operand list has at least two operands.\n     */\n    public int do_algebra(List<String> operator, List<Integer> operand) {\n        // Initialize the expression with the first operand\n        StringBuilder expression = new StringBuilder();\n        expression.append(operand.get(0));\n\n        // Iterate through the operators and operands to build the expression\n        for (int i = 0; i < operator.size(); i++) {\n            expression.append(\" \").append(operator.get(i)).append(\" \").append(operand.get(i + 1));\n        }\n\n        // Evaluate the constructed expression using Java's ScriptEngineManager\n        try {\n            ScriptEngineManager manager = new ScriptEngineManager();\n            ScriptEngine engine = manager.getEngineByName(\"JavaScript\");\n            Object result = engine.eval(expression.toString());\n            return (int) result;\n        } catch (Exception e) {\n            throw new RuntimeException(\"Error evaluating expression: \" + e.getMessage());\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        List<String> operator = Arrays.asList(\"+\", \"*\", \"-\");\n        List<Integer> operand = Arrays.asList(2, 3, 4, 5);\n        int result = solution.do_algebra(operator, operand);\n        System.out.println(\"Result: \" + result); // Output should be 9\n    }\n}\n"}
{"task_id": "Java/161", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * You are given a string s.\n     * if s[i] is a letter, reverse its case from lower to upper or vise versa,\n     * otherwise keep it as it is.\n     * If the string contains no letters, reverse the string.\n     * The function should return the resulted string.\n     * Examples\n     * solve(\"1234\") = \"4321\"\n     * solve(\"ab\") = \"AB\"\n     * solve(\"#a@C\") = \"#A@c\"\n     */\n    public String solve(String s) {\n        if (s == null || s.isEmpty()) {\n            return s;\n        }\n\n        boolean containsLetters = false;\n        StringBuilder result = new StringBuilder();\n\n        for (char c : s.toCharArray()) {\n            if (Character.isLetter(c)) {\n                containsLetters = true;\n                result.append(Character.isLowerCase(c) ? Character.toUpperCase(c) : Character.toLowerCase(c));\n            } else {\n                result.append(c);\n            }\n        }\n\n        return containsLetters ? result.toString() : new StringBuilder(s).reverse().toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.solve(\"1234\"));  // Expected: \"4321\"\n        System.out.println(solution.solve(\"ab\"));    // Expected: \"AB\"\n        System.out.println(solution.solve(\"#a@C\"));  // Expected: \"#A@c\"\n        System.out.println(solution.solve(\"\"));      // Expected: \"\"\n        System.out.println(solution.solve(\"123!@#\")); // Expected: \"#@!321\"\n        System.out.println(solution.solve(\"Hello World!\")); // Expected: \"hELLO wORLD!\"\n    }\n}\n"}
{"task_id": "Java/162", "generation": "import java.math.BigInteger;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.Optional;\n\nclass Solution {\n    /**\n     * Given a string \"text\", return its md5 hash equivalent string with length being 32.\n     * If \"text\" is an empty string, return Optional.empty().\n     *\n     * >>> string_to_md5(\"Hello world\") == \"3e25960a79dbc69b674cd4ec67a72c62\"\n     */\n    public Optional<String> string_to_md5(String text) throws NoSuchAlgorithmException {\n        if (text.isEmpty()) {\n            return Optional.empty();\n        }\n\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        byte[] hashBytes = md.digest(text.getBytes());\n\n        // Convert the byte array to a hexadecimal string\n        StringBuilder hexString = new StringBuilder();\n        for (byte b : hashBytes) {\n            String hex = Integer.toHexString(0xff & b);\n            if (hex.length() == 1) {\n                hexString.append('0');\n            }\n            hexString.append(hex);\n        }\n\n        return Optional.of(hexString.toString());\n    }\n}\n"}
{"task_id": "Java/163", "generation": "import java.util.List;\n\nclass Solution {\n\n    /**\n     * Given two positive integers a and b, return the even digits between a\n     * and b, in ascending order.\n     *\n     * @param a the lower bound (inclusive)\n     * @param b the upper bound (inclusive)\n     * @return a List of Integer containing even digits between a and b\n     */\n    public List<Integer> generate_integers(int a, int b) {\n        List<Integer> result = new ArrayList<>();\n        \n        // Ensure a is less than or equal to b for simplicity in iteration\n        if (a > b) {\n            int temp = a;\n            a = b;\n            b = temp;\n        }\n        \n        for (int i = a; i <= b; i++) {\n            if (i % 2 == 0 && i < 10) {\n                result.add(i);\n            }\n        }\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(\"generate_integers(2, 8): \" + solution.generate_integers(2, 8)); // [2, 4, 6, 8]\n        System.out.println(\"generate_integers(8, 2): \" + solution.generate_integers(8, 2)); // [2, 4, 6, 8]\n        System.out.println(\"generate_integers(10, 14): \" + solution.generate_integers(10, 14)); // []\n        System.out.println(\"generate_integers(1, 5): \" + solution.generate_integers(1, 5)); // [2, 4]\n        System.out.println(\"generate_integers(3, 7): \" + solution.generate_integers(3, 7)); // [4, 6]\n    }\n}\n"}
{"task_id": "Java/0", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Check if in given list of numbers, are any two numbers closer to each other than given threshold.\n     *\n     * @param numbers List of Double values.\n     * @param threshold The threshold value for closeness.\n     * @return true if there exist at least two elements whose difference is less than the threshold; false otherwise.\n     */\n    public boolean has_close_elements(List<Double> numbers, double threshold) {\n        // Sort the list to make it easier to find close elements\n        Collections.sort(numbers);\n        \n        for (int i = 0; i < numbers.size() - 1; i++) {\n            if (numbers.get(i + 1) - numbers.get(i) < threshold) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.has_close_elements(Arrays.asList(1.0, 2.0, 3.0), 0.5)); // Expected: false\n        System.out.println(solution.has_close_elements(Arrays.asList(1.0, 2.8, 3.0, 4.0, 5.0, 2.0), 0.3)); // Expected: true\n        System.out.println(solution.has_close_elements(Arrays.asList(-1.0, -2.0, -3.0), 1.5)); // Expected: false\n        System.out.println(solution.has_close_elements(Arrays.asList(10.0, 10.1, 10.2, 10.3), 0.05)); // Expected: true\n    }\n}\n"}
{"task_id": "Java/1", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n     * separate those group into separate strings and return the list of those.\n     * Separate groups are balanced (each open brace is properly closed) and not nested within each other\n     * Ignore any spaces in the input string.\n     *\n     * @param paren_string The input string containing multiple groups of nested parentheses.\n     * @return A List of separate strings, each representing a group of balanced parentheses.\n     */\n    public List<String> separate_paren_groups(String paren_string) {\n        List<String> result = new ArrayList<>();\n        int balance = 0;\n        StringBuilder currentGroup = new StringBuilder();\n\n        for (char c : paren_string.toCharArray()) {\n            if (c == ' ') continue; // Ignore spaces\n\n            if (c == '(') {\n                balance++;\n                currentGroup.append(c);\n            } else if (c == ')') {\n                balance--;\n                currentGroup.append(c);\n\n                if (balance == 0) { // A complete group is found\n                    result.add(currentGroup.toString());\n                    currentGroup = new StringBuilder(); // Reset for the next group\n                }\n            }\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(\"Test Case 1: ( ) (( )) (( )( ))\");\n        List<String> test1 = solution.separate_paren_groups(\"( ) (( )) (( )( ))\");\n        for (String group : test1) {\n            System.out.println(group);\n        }\n\n        System.out.println(\"\\nTest Case 2: (()())(())\");\n        List<String> test2 = solution.separate_paren_groups(\"(()())(())\");\n        for (String group : test2) {\n            System.out.println(group);\n        }\n\n        System.out.println(\"\\nTest Case 3: ((()))((()))\");\n        List<String> test3 = solution.separate_paren_groups(\"((()))((()))\");\n        for (String group : test3) {\n            System.out.println(group);\n        }\n    }\n}\n"}
{"task_id": "Java/2", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     Given a positive floating point number, it can be decomposed into\n     and integer part (largest integer smaller than given number) and decimals\n     (leftover part always smaller than 1).\n\n     Return the decimal part of the number.\n     >>> truncate_number(3.5)\n     0.5\n     */\n    public double truncate_number(double number) {\n        return number - Math.floor(number);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(\"Truncate 3.5: \" + solution.truncate_number(3.5)); // Expected output: 0.5\n        System.out.println(\"Truncate 123.456: \" + solution.truncate_number(123.456)); // Expected output: 0.456\n        System.out.println(\"Truncate -1.234: \" + solution.truncate_number(-1.234)); // Expected output: -0.234 (Note: floor of negative numbers is less than the number itself)\n        System.out.println(\"Truncate 0.999: \" + solution.truncate_number(0.999)); // Expected output: 0.999\n        System.out.println(\"Truncate 10.0: \" + solution.truncate_number(10.0)); // Expected output: 0.0\n    }\n}\n"}
{"task_id": "Java/3", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * You're given a list of deposit and withdrawal operations on a bank account that starts with\n     * zero balance. Your task is to detect if at any point the balance of the account falls below zero,\n     * and at that point, the function should return true. Otherwise, it should return false.\n     *\n     * @param operations List of integers representing deposits (positive) and withdrawals (negative).\n     * @return boolean indicating whether the balance ever goes below zero.\n     */\n    public boolean below_zero(List<Integer> operations) {\n        int balance = 0;\n        for (int op : operations) {\n            balance += op;\n            if (balance < 0) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        List<Integer> test1 = Arrays.asList(1, 2, 3);\n        System.out.println(\"Test Case 1: \" + (solution.below_zero(test1) == false)); // Expected: true\n\n        List<Integer> test2 = Arrays.asList(1, 2, -4, 5);\n        System.out.println(\"Test Case 2: \" + (solution.below_zero(test2) == true)); // Expected: true\n\n        List<Integer> test3 = Arrays.asList(-1, 2, -1, 3);\n        System.out.println(\"Test Case 3: \" + (solution.below_zero(test3) == false)); // Expected: false\n\n        List<Integer> test4 = Arrays.asList(5, -6, 7, -8, 9);\n        System.out.println(\"Test Case 4: \" + (solution.below_zero(test4) == true)); // Expected: true\n    }\n}\n"}
{"task_id": "Java/4", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * For a given list of input numbers, calculate Mean Absolute Deviation around the mean of this dataset.\n     * Mean Absolute Deviation is the average absolute difference between each element and a centerpoint (mean in this case):\n     * MAD = average | x - x_mean |\n     *\n     * @param numbers List of Double values\n     * @return Mean Absolute Deviation as a double\n     */\n    public double mean_absolute_deviation(List<Double> numbers) {\n        if (numbers == null || numbers.isEmpty()) {\n            throw new IllegalArgumentException(\"Input list cannot be null or empty\");\n        }\n\n        // Calculate the mean of the dataset\n        double sum = 0.0;\n        for (Double num : numbers) {\n            sum += num;\n        }\n        double mean = sum / numbers.size();\n\n        // Calculate the Mean Absolute Deviation\n        double mad = 0.0;\n        for (Double num : numbers) {\n            mad += Math.abs(num - mean);\n        }\n        return mad / numbers.size();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.mean_absolute_deviation(Arrays.asList(1.0, 2.0, 3.0, 4.0))); // Expected output: 1.0\n        System.out.println(solution.mean_absolute_deviation(Arrays.asList(5.0, 7.0, 9.0, 11.0, 13.0))); // Expected output: 2.8\n        System.out.println(solution.mean_absolute_deviation(Arrays.asList(-1.0, -2.0, -3.0, -4.0))); // Expected output: 1.5\n        System.out.println(solution.mean_absolute_deviation(Arrays.asList(10.0))); // Expected output: 0.0 (single element)\n    }\n}\n"}
{"task_id": "Java/5", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Insert a number 'delimiter' between every two consecutive elements of input list `numbers`\n     *\n     * @param numbers The input list of integers.\n     * @param delimiter The integer to be inserted as a delimiter.\n     * @return A new list with the delimiter interspersed.\n     */\n    public List<Integer> intersperse(List<Integer> numbers, int delimiter) {\n        if (numbers == null || numbers.size() <= 1) {\n            return numbers;\n        }\n\n        List<Integer> result = new ArrayList<>();\n        for (int i = 0; i < numbers.size(); i++) {\n            result.add(numbers.get(i));\n            if (i < numbers.size() - 1) {\n                result.add(delimiter);\n            }\n        }\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.intersperse(List.of(), 4)); // Expected: []\n        System.out.println(solution.intersperse(Arrays.asList(1, 2, 3), 4)); // Expected: [1, 4, 2, 4, 3]\n        System.out.println(solution.intersperse(Arrays.asList(5, 6, 7, 8), -1)); // Expected: [5, -1, 6, -1, 7, -1, 8]\n    }\n}\n"}
{"task_id": "Java/6", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n     * For each of the group, output the deepest level of nesting of parentheses.\n     * E.g. (()()) has maximum two levels of nesting while ((())) has three.\n     *\n     * >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n     * [2, 3, 1, 3]\n     */\n    public List<Integer> parse_nested_parens(String paren_string) {\n        String[] groups = paren_string.split(\"\\\\s+\");\n        List<Integer> depths = new ArrayList<>();\n        \n        for (String group : groups) {\n            int maxDepth = 0;\n            int currentDepth = 0;\n            \n            for (char c : group.toCharArray()) {\n                if (c == '(') {\n                    currentDepth++;\n                    maxDepth = Math.max(maxDepth, currentDepth);\n                } else if (c == ')') {\n                    currentDepth--;\n                }\n            }\n            \n            depths.add(maxDepth);\n        }\n        \n        return depths;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        String test1 = \"(()()) ((())) () ((())()())\";\n        List<Integer> result1 = solution.parse_nested_parens(test1);\n        System.out.println(result1); // Expected output: [2, 3, 1, 3]\n        \n        String test2 = \"(()) (()) (((())))\";\n        List<Integer> result2 = solution.parse_nested_parens(test2);\n        System.out.println(result2); // Expected output: [2, 2, 4]\n        \n        String test3 = \"((())) () (((())))\";\n        List<Integer> result3 = solution.parse_nested_parens(test3);\n        System.out.println(result3); // Expected output: [3, 1, 4]\n    }\n}\n"}
{"task_id": "Java/7", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Filter an input list of strings only for ones that contain given substring\n     *\n     * @param strings The input list of strings\n     * @param substring The substring to filter by\n     * @return A list of strings containing the specified substring\n     */\n    public List<String> filter_by_substring(List<String> strings, String substring) {\n        List<String> filteredList = new ArrayList<>();\n        for (String str : strings) {\n            if (str.contains(substring)) {\n                filteredList.add(str);\n            }\n        }\n        return filteredList;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(\"Test Case 1: Empty List\");\n        System.out.println(solution.filter_by_substring(List.of(), \"a\")); // Expected output: []\n\n        System.out.println(\"\\nTest Case 2: Normal List with 'a'\");\n        System.out.println(solution.filter_by_substring(Arrays.asList(\"abc\", \"bacd\", \"cde\", \"array\"), \"a\"));\n        // Expected output: [abc, bacd, array]\n\n        System.out.println(\"\\nTest Case 3: List without the substring\");\n        System.out.println(solution.filter_by_substring(Arrays.asList(\"hello\", \"world\", \"java\"), \"python\"));\n        // Expected output: []\n\n        System.out.println(\"\\nTest Case 4: List with multiple occurrences of the substring\");\n        System.out.println(solution.filter_by_substring(Arrays.asList(\"aaa\", \"baa\", \"aab\", \"bba\"), \"aa\"));\n        // Expected output: [aaa, aab]\n    }\n}\n"}
{"task_id": "Java/8", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> sum_product(List<Integer> numbers) {\n        if (numbers.isEmpty()) {\n            return Arrays.asList(0, 1);\n        }\n\n        int totalSum = 0;\n        int totalProduct = 1;\n\n        for (int num : numbers) {\n            totalSum += num;\n            totalProduct *= num;\n        }\n\n        List<Integer> result = new ArrayList<>();\n        result.add(totalSum);\n        result.add(totalProduct);\n\n        return result;\n    }\n}\n"}
{"task_id": "Java/9", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * From a given list of integers, generate a list of rolling maximum element found until given moment in the sequence.\n     *\n     * @param numbers The input list of integers.\n     * @return A list containing the rolling maximum elements.\n     */\n    public List<Integer> rolling_max(List<Integer> numbers) {\n        if (numbers == null || numbers.isEmpty()) {\n            return Collections.emptyList();\n        }\n\n        List<Integer> result = new ArrayList<>();\n        int maxSoFar = Integer.MIN_VALUE;\n\n        for (int num : numbers) {\n            if (num > maxSoFar) {\n                maxSoFar = num;\n            }\n            result.add(maxSoFar);\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.rolling_max(Arrays.asList(1, 2, 3, 2, 3, 4, 2))); // [1, 2, 3, 3, 3, 4, 4]\n        System.out.println(solution.rolling_max(Arrays.asList()));                   // []\n        System.out.println(solution.rolling_max(Arrays.asList(5)));                  // [5]\n        System.out.println(solution.rolling_max(Arrays.asList(-1, -2, -3, -2, -3, -4, -2))); // [-1, -1, -1, -1, -1, -1, -1]\n    }\n}\n"}
{"task_id": "Java/10", "generation": "import java.util.*;\n\nclass Solution {\n    public boolean isPalindrome(String string) {\n        int i = 0;\n        int j = string.length() - 1;\n        while (i < j) {\n            if (string.charAt(i) != string.charAt(j)) {\n                return false;\n            }\n            i++;\n            j--;\n        }\n        return true;\n    }\n\n    public String findLongestPalindromicSuffix(String s) {\n        int n = s.length();\n        for (int i = n - 1; i >= 0; i--) {\n            if (isPalindrome(s.substring(i))) {\n                return s.substring(i);\n            }\n        }\n        return \"\";\n    }\n\n    public String make_palindrome(String string) {\n        String palindromicSuffix = findLongestPalindromicSuffix(string);\n        String prefix = string.substring(0, string.length() - palindromicSuffix.length());\n        return string + new StringBuilder(prefix).reverse().toString();\n    }\n}\n"}
{"task_id": "Java/11", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Input are two strings a and b consisting only of 1s and 0s.\n     * Perform binary XOR on these inputs and return result also as a string.\n     *\n     * @param a the first binary string\n     * @param b the second binary string\n     * @return the result of binary XOR operation as a string\n     */\n    public String string_xor(String a, String b) {\n        StringBuilder result = new StringBuilder();\n        int maxLength = Math.max(a.length(), b.length());\n        \n        // Pad both strings to have equal length\n        a = padStringToLength(a, maxLength);\n        b = padStringToLength(b, maxLength);\n\n        for (int i = 0; i < maxLength; i++) {\n            char bitA = a.charAt(i);\n            char bitB = b.charAt(i);\n            \n            // Perform XOR operation and append to result\n            if (bitA == bitB) {\n                result.append('0');\n            } else {\n                result.append('1');\n            }\n        }\n\n        return result.toString();\n    }\n\n    /**\n     * Pads the given string with '0's at the beginning to make it of specified length.\n     *\n     * @param str the input string\n     * @param length the desired length\n     * @return the padded string\n     */\n    private String padStringToLength(String str, int length) {\n        StringBuilder sb = new StringBuilder(str);\n        while (sb.length() < length) {\n            sb.insert(0, '0');\n        }\n        return sb.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.string_xor(\"010\", \"110\")); // Expected output: \"100\"\n        System.out.println(solution.string_xor(\"10101\", \"00111\")); // Expected output: \"10010\"\n        System.out.println(solution.string_xor(\"1111\", \"0000\")); // Expected output: \"1111\"\n        System.out.println(solution.string_xor(\"0000\", \"0000\")); // Expected output: \"0000\"\n        System.out.println(solution.string_xor(\"11111111\", \"00000000\")); // Expected output: \"11111111\"\n    }\n}\n"}
{"task_id": "Java/12", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     Out of list of strings, return the longest one. Return the first one in case of multiple\n     strings of the same length. Return Optional.empty() in case the input list is empty.\n     >>> longest(List.of())\n     Optional.empty\n     >>> longest(Arrays.asList(\"a\", \"b\", \"c\"))\n     Optional[a]\n     >>> longest(Arrays.asList(\"a\", \"bb\", \"ccc\"))\n     Optional[ccc]\n     */\n    public Optional<String> longest(List<String> strings) {\n        if (strings.isEmpty()) {\n            return Optional.empty();\n        }\n\n        String longestString = strings.get(0);\n        for (String str : strings) {\n            if (str.length() > longestString.length()) {\n                longestString = str;\n            }\n        }\n        \n        return Optional.of(longestString);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(\"Test Case 1: Empty List\");\n        System.out.println(solution.longest(List.of())); // Expected: Optional.empty\n\n        System.out.println(\"\\nTest Case 2: Single Element\");\n        System.out.println(solution.longest(Arrays.asList(\"a\"))); // Expected: Optional[a]\n\n        System.out.println(\"\\nTest Case 3: Multiple Elements with Different Lengths\");\n        System.out.println(solution.longest(Arrays.asList(\"a\", \"bb\", \"ccc\"))); // Expected: Optional[ccc]\n\n        System.out.println(\"\\nTest Case 4: Multiple Elements with Same Length\");\n        System.out.println(solution.longest(Arrays.asList(\"aa\", \"bbb\", \"cccc\"))); // Expected: Optional[cccc]\n    }\n}\n"}
{"task_id": "Java/13", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return a greatest common divisor of two integers a and b\n     *\n     * @param a first integer\n     * @param b second integer\n     * @return the greatest common divisor of a and b\n     */\n    public int greatest_common_divisor(int a, int b) {\n        while (b != 0) {\n            int temp = b;\n            b = a % b;\n            a = temp;\n        }\n        return a;\n    }\n\n    // Test cases to verify the correctness of the method\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1: GCD of 3 and 5 is 1\n        System.out.println(\"GCD of 3 and 5: \" + solution.greatest_common_divisor(3, 5)); // Expected output: 1\n\n        // Test case 2: GCD of 25 and 15 is 5\n        System.out.println(\"GCD of 25 and 15: \" + solution.greatest_common_divisor(25, 15)); // Expected output: 5\n\n        // Test case 3: GCD of 100 and 80 is 20\n        System.out.println(\"GCD of 100 and 80: \" + solution.greatest_common_divisor(100, 80)); // Expected output: 20\n\n        // Test case 4: GCD of 7 and 13 (both prime) is 1\n        System.out.println(\"GCD of 7 and 13: \" + solution.greatest_common_divisor(7, 13)); // Expected output: 1\n\n        // Test case 5: GCD of 0 and any number is that number (since gcd(0, b) = b)\n        System.out.println(\"GCD of 0 and 24: \" + solution.greatest_common_divisor(0, 24)); // Expected output: 24\n    }\n}\n"}
{"task_id": "Java/14", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Return list of all prefixes from shortest to longest of the input string\n     *\n     * @param string The input string\n     * @return A List containing all prefixes of the input string, ordered from shortest to longest\n     */\n    public List<String> all_prefixes(String string) {\n        List<String> prefixes = new ArrayList<>();\n        if (string == null || string.isEmpty()) {\n            return prefixes;\n        }\n        \n        for (int i = 1; i <= string.length(); i++) {\n            prefixes.add(string.substring(0, i));\n        }\n        \n        return prefixes;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(\"Testing all_prefixes(\\\"abc\\\"): \" + solution.all_prefixes(\"abc\")); // [\"a\", \"ab\", \"abc\"]\n        System.out.println(\"Testing all_prefixes(\\\"\\\"): \" + solution.all_prefixes(\"\")); // []\n        System.out.println(\"Testing all_prefixes(null): \" + solution.all_prefixes(null)); // []\n\n        // Additional test cases\n        System.out.println(\"Testing all_prefixes(\\\"hello\\\"): \" + solution.all_prefixes(\"hello\")); // [\"h\", \"he\", \"hel\", \"hell\", \"hello\"]\n        System.out.println(\"Testing all_prefixes(\\\"java\\\"): \" + solution.all_prefixes(\"java\")); // [\"j\", \"ja\", \"jav\", \"java\"]\n    }\n}\n"}
{"task_id": "Java/15", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Return a string containing space-delimited numbers starting from 0 up to n inclusive.\n     *\n     * @param n The upper limit of the sequence (inclusive).\n     * @return A string with space-separated numbers from 0 to n.\n     */\n    public String string_sequence(int n) {\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i <= n; i++) {\n            if (i > 0) {\n                sb.append(\" \");\n            }\n            sb.append(i);\n        }\n        return sb.toString();\n    }\n\n    // Test cases to verify the correctness of the string_sequence method\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1: n = 0\n        System.out.println(solution.string_sequence(0).equals(\"0\") ? \"Test 1 Passed\" : \"Test 1 Failed\");\n\n        // Test case 2: n = 5\n        System.out.println(solution.string_sequence(5).equals(\"0 1 2 3 4 5\") ? \"Test 2 Passed\" : \"Test 2 Failed\");\n\n        // Additional test cases\n        System.out.println(solution.string_sequence(10).equals(\"0 1 2 3 4 5 6 7 8 9 10\") ? \"Test 3 Passed\" : \"Test 3 Failed\");\n        System.out.println(solution.string_sequence(-1).equals(\"\") ? \"Test 4 Passed\" : \"Test 4 Failed\"); // Edge case: n < 0\n    }\n}\n"}
{"task_id": "Java/16", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given a string, find out how many distinct characters (regardless of case) does it consist of.\n     *\n     * @param string The input string to analyze.\n     * @return The number of distinct characters in the string, ignoring case.\n     */\n    public int count_distinct_characters(String string) {\n        // Convert the string to lowercase to ignore case\n        String lowerCaseString = string.toLowerCase();\n        \n        // Use a HashSet to store unique characters\n        Set<Character> uniqueChars = new HashSet<>();\n        \n        // Iterate through each character in the string and add it to the set\n        for (char c : lowerCaseString.toCharArray()) {\n            uniqueChars.add(c);\n        }\n        \n        // The size of the set is the number of distinct characters\n        return uniqueChars.size();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.count_distinct_characters(\"xyzXYZ\")); // Expected output: 3\n        System.out.println(solution.count_distinct_characters(\"Jerry\"));   // Expected output: 4\n        System.out.println(solution.count_distinct_characters(\"HelloWorld\")); // Expected output: 7\n        System.out.println(solution.count_distinct_characters(\"AAAaaa\"));    // Expected output: 1\n        System.out.println(solution.count_distinct_characters(\"\"));          // Expected output: 0\n        System.out.println(solution.count_distinct_characters(\"aAaAaA\"));    // Expected output: 1\n    }\n}\n"}
{"task_id": "Java/17", "generation": "import java.util.*;\n\nclass Solution {\n    public List<Integer> parse_music(String string) {\n        String[] notes = string.split(\" \");\n        List<Integer> beats = new ArrayList<>();\n        \n        for (String note : notes) {\n            if (\"o\".equals(note)) {\n                beats.add(4);\n            } else if (\"o|\".equals(note)) {\n                beats.add(2);\n            } else if (\".|\".equals(note)) {\n                beats.add(1);\n            }\n        }\n        \n        return beats;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        List<Integer> result = solution.parse_music(\"o o| .| o| o| .| .| .| .| o o\");\n        System.out.println(result); // Expected output: [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    }\n}\n"}
{"task_id": "Java/18", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Find how many times a given substring can be found in the original string. Count overlapping cases.\n     *\n     * @param string The original string.\n     * @param substring The substring to find.\n     * @return The number of times the substring appears in the original string, including overlaps.\n     */\n    public int how_many_times(String string, String substring) {\n        if (substring.isEmpty()) return 0;\n        \n        int count = 0;\n        int index = 0;\n        \n        while ((index = string.indexOf(substring, index)) != -1) {\n            count++;\n            index++; // Move to the next character after the found substring to allow for overlapping matches\n        }\n        \n        return count;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.how_many_times(\"\", \"a\")); // Expected output: 0\n        System.out.println(solution.how_many_times(\"aaa\", \"a\")); // Expected output: 3\n        System.out.println(solution.how_many_times(\"aaaa\", \"aa\")); // Expected output: 3\n        System.out.println(solution.how_many_times(\"abababa\", \"aba\")); // Expected output: 3\n        System.out.println(solution.how_many_times(\"testtest\", \"test\")); // Expected output: 2\n    }\n}\n"}
{"task_id": "Java/19", "generation": "import java.util.*;\n\nclass Solution {\n    public String sort_numbers(String numbers) {\n        Map<String, Integer> numberMap = new HashMap<>();\n        numberMap.put(\"zero\", 0);\n        numberMap.put(\"one\", 1);\n        numberMap.put(\"two\", 2);\n        numberMap.put(\"three\", 3);\n        numberMap.put(\"four\", 4);\n        numberMap.put(\"five\", 5);\n        numberMap.put(\"six\", 6);\n        numberMap.put(\"seven\", 7);\n        numberMap.put(\"eight\", 8);\n        numberMap.put(\"nine\", 9);\n\n        // Convert the string to a list of numbers based on the map\n        List<Integer> numList = new ArrayList<>();\n        for (String num : numbers.split(\" \")) {\n            numList.add(numberMap.get(num));\n        }\n\n        // Sort the list of numbers\n        Collections.sort(numList);\n\n        // Create an inverse map for number words\n        Map<Integer, String> numberMapInverse = new HashMap<>();\n        for (Map.Entry<String, Integer> entry : numberMap.entrySet()) {\n            numberMapInverse.put(entry.getValue(), entry.getKey());\n        }\n\n        // Convert the sorted list back to words and join them into a string\n        StringBuilder result = new StringBuilder();\n        for (Integer num : numList) {\n            if (result.length() > 0) {\n                result.append(\" \");\n            }\n            result.append(numberMapInverse.get(num));\n        }\n\n        return result.toString();\n    }\n}\n"}
{"task_id": "Java/20", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * From a supplied list of numbers (of length at least two) select and return two that are the closest to each other and return them in order (smaller number, larger number).\n     */\n    public List<Double> find_closest_elements(List<Double> numbers) {\n        if (numbers == null || numbers.size() < 2) {\n            throw new IllegalArgumentException(\"List must contain at least two elements.\");\n        }\n\n        double minDiff = Double.MAX_VALUE;\n        List<Double> closestElements = new ArrayList<>();\n\n        for (int i = 0; i < numbers.size(); i++) {\n            for (int j = i + 1; j < numbers.size(); j++) {\n                double diff = Math.abs(numbers.get(i) - numbers.get(j));\n                if (diff < minDiff) {\n                    minDiff = diff;\n                    closestElements.clear();\n                    closestElements.add(Math.min(numbers.get(i), numbers.get(j)));\n                    closestElements.add(Math.max(numbers.get(i), numbers.get(j)));\n                }\n            }\n        }\n\n        return closestElements;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.find_closest_elements(Arrays.asList(1.0, 2.0, 3.0, 4.0, 5.0, 2.2))); // [2.0, 2.2]\n        System.out.println(solution.find_closest_elements(Arrays.asList(1.0, 2.0, 3.0, 4.0, 5.0, 2.0)));  // [2.0, 2.0]\n        System.out.println(solution.find_closest_elements(Arrays.asList(-1.0, -2.0, -3.0, -4.0, -5.0, -2.2))); // [-2.2, -2.0]\n        System.out.println(solution.find_closest_elements(Arrays.asList(10.5, 10.6, 10.7, 10.8, 10.9))); // [10.5, 10.6]\n    }\n}\n"}
{"task_id": "Java/21", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given list of numbers (of at least two elements), apply a linear transform to that list,\n     * such that the smallest number will become 0 and the largest will become 1.\n     *\n     * @param numbers List of Double values\n     * @return A new list where each element is rescaled to the range [0, 1]\n     */\n    public List<Double> rescale_to_unit(List<Double> numbers) {\n        if (numbers == null || numbers.size() < 2) {\n            throw new IllegalArgumentException(\"List must contain at least two elements\");\n        }\n\n        double min = Collections.min(numbers);\n        double max = Collections.max(numbers);\n\n        List<Double> result = new ArrayList<>();\n        for (Double num : numbers) {\n            double scaledValue = (num - min) / (max - min);\n            result.add(scaledValue);\n        }\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        List<Double> test1 = Arrays.asList(1.0, 2.0, 3.0, 4.0, 5.0);\n        System.out.println(\"Test Case 1: \" + solution.rescale_to_unit(test1));\n        \n        List<Double> test2 = Arrays.asList(-1.0, -2.0, -3.0, -4.0, -5.0);\n        System.out.println(\"Test Case 2: \" + solution.rescale_to_unit(test2));\n        \n        List<Double> test3 = Arrays.asList(10.0, 20.0, 30.0, 40.0, 50.0);\n        System.out.println(\"Test Case 3: \" + solution.rescale_to_unit(test3));\n    }\n}\n"}
{"task_id": "Java/22", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Filter given list of any values only for integers\n    >>> filter_integers(Arrays.asList('a', 3.14, 5))\n    [5]\n    >>> filter_integers(Arrays.asList(1, 2, 3, \"abc\", Map.of(), List.of()))\n    [1, 2, 3]\n     */\n    public List<Integer> filter_integers(List<Object> values) {\n        List<Integer> result = new ArrayList<>();\n        for (Object value : values) {\n            if (value instanceof Integer) {\n                result.add((Integer) value);\n            }\n        }\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.filter_integers(Arrays.asList('a', 3.14, 5))); // [5]\n        System.out.println(solution.filter_integers(Arrays.asList(1, 2, 3, \"abc\", Map.of(), List.of()))); // [1, 2, 3]\n    }\n}\n"}
{"task_id": "Java/23", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Return length of given string\n     * >>> strlen(\"\")\n     * 0\n     * >>> strlen(\"abc\")\n     * 3\n     */\n    public int strlen(String string) {\n        return string.length();\n    }\n\n    public static void main(String[] args) {\n        // Create an instance of Solution\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(\"Test Case 1: Empty String\");\n        System.out.println(\"Expected Output: 0\");\n        System.out.println(\"Actual Output: \" + solution.strlen(\"\"));\n        System.out.println();\n\n        System.out.println(\"Test Case 2: Single Character String\");\n        System.out.println(\"Expected Output: 1\");\n        System.out.println(\"Actual Output: \" + solution.strlen(\"a\"));\n        System.out.println();\n\n        System.out.println(\"Test Case 3: Multiple Characters String\");\n        System.out.println(\"Expected Output: 5\");\n        System.out.println(\"Actual Output: \" + solution.strlen(\"hello\"));\n        System.out.println();\n\n        System.out.println(\"Test Case 4: Longer String with Spaces and Special Characters\");\n        System.out.println(\"Expected Output: 12\");\n        System.out.println(\"Actual Output: \" + solution.strlen(\"Hello, world!\"));\n    }\n}\n"}
{"task_id": "Java/24", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * For a given number n, find the largest number that divides n evenly, smaller than n.\n     *\n     * @param n The input number.\n     * @return The largest divisor of n that is smaller than n.\n     */\n    public int largest_divisor(int n) {\n        for (int i = n / 2; i >= 1; i--) {\n            if (n % i == 0) {\n                return i;\n            }\n        }\n        // If no divisor found, which should not happen for positive integers,\n        // we return -1 as an error indicator.\n        return -1;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.largest_divisor(15));  // Expected output: 5\n        System.out.println(solution.largest_divisor(28));  // Expected output: 14\n        System.out.println(solution.largest_divisor(37));  // Expected output: -1 (since 37 is prime)\n        System.out.println(solution.largest_divisor(100)); // Expected output: 50\n    }\n}\n"}
{"task_id": "Java/25", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Return list of prime factors of given integer in the order from smallest to largest.\n     * Each of the factors should be listed number of times corresponding to how many times it appears in factorization.\n     * Input number should be equal to the product of all factors\n     *\n     * @param n the integer to factorize\n     * @return a list of prime factors\n     */\n    public List<Integer> factorize(int n) {\n        List<Integer> factors = new ArrayList<>();\n        for (int factor = 2; factor <= n; factor++) {\n            while (n % factor == 0) {\n                factors.add(factor);\n                n /= factor;\n            }\n        }\n        return factors;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(\"Factorize(8): \" + solution.factorize(8));   // Expected: [2, 2, 2]\n        System.out.println(\"Factorize(25): \" + solution.factorize(25));  // Expected: [5, 5]\n        System.out.println(\"Factorize(70): \" + solution.factorize(70));  // Expected: [2, 5, 7]\n        System.out.println(\"Factorize(49): \" + solution.factorize(49));  // Expected: [7, 7]\n        System.out.println(\"Factorize(1): \" + solution.factorize(1));    // Expected: []\n        System.out.println(\"Factorize(2): \" + solution.factorize(2));    // Expected: [2]\n    }\n}\n"}
{"task_id": "Java/26", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> remove_duplicates(List<Integer> numbers) {\n        Set<Integer> seen = new HashSet<>();\n        List<Integer> result = new ArrayList<>();\n        \n        for (Integer num : numbers) {\n            if (!seen.contains(num)) {\n                seen.add(num);\n                result.add(num);\n            }\n        }\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        List<Integer> input = Arrays.asList(1, 2, 3, 2, 4);\n        List<Integer> output = solution.remove_duplicates(input);\n        System.out.println(output); // Expected output: [1, 3, 4]\n    }\n}\n"}
{"task_id": "Java/27", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n     *\n     * @param string The input string to be flipped.\n     * @return A new string with the case of each character flipped.\n     */\n    public String flip_case(String string) {\n        StringBuilder result = new StringBuilder();\n        for (char c : string.toCharArray()) {\n            if (Character.isUpperCase(c)) {\n                result.append(Character.toLowerCase(c));\n            } else {\n                result.append(Character.toUpperCase(c));\n            }\n        }\n        return result.toString();\n    }\n\n    // Test method to verify the correctness of flip_case\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.flip_case(\"Hello\"));  // Expected: \"hELLO\"\n        System.out.println(solution.flip_case(\"WORLD\"));  // Expected: \"world\"\n        System.out.println(solution.flip_case(\"Java\"));   // Expected: \"jAVA\"\n        System.out.println(solution.flip_case(\"123abcABC\"));  // Expected: \"123ABCabc\"\n        System.out.println(solution.flip_case(\"\"));       // Expected: \"\"\n    }\n}\n"}
{"task_id": "Java/28", "generation": "import java.util.Arrays;\nimport java.util.List;\n\nclass Solution {\n    /**\n     * Concatenate list of strings into a single string\n     *\n     * @param strings List of strings to concatenate\n     * @return A single concatenated string\n     */\n    public String concatenate(List<String> strings) {\n        StringBuilder sb = new StringBuilder();\n        for (String str : strings) {\n            sb.append(str);\n        }\n        return sb.toString();\n    }\n}\n\nclass TestSolution {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1: Empty list\n        List<String> emptyList = Arrays.asList();\n        System.out.println(\"Expected: '', Actual: '\" + solution.concatenate(emptyList) + \"'\");\n\n        // Test case 2: Single element list\n        List<String> singleElementList = Arrays.asList(\"a\");\n        System.out.println(\"Expected: 'a', Actual: '\" + solution.concatenate(singleElementList) + \"'\");\n\n        // Test case 3: Multiple elements list\n        List<String> multipleElementsList = Arrays.asList(\"a\", \"b\", \"c\");\n        System.out.println(\"Expected: 'abc', Actual: '\" + solution.concatenate(multipleElementsList) + \"'\");\n    }\n}\n"}
{"task_id": "Java/29", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Filter an input list of strings only for ones that start with a given prefix.\n     *\n     * @param strings The input list of strings.\n     * @param prefix  The prefix to filter the strings by.\n     * @return A list of strings that start with the given prefix.\n     */\n    public List<String> filter_by_prefix(List<String> strings, String prefix) {\n        return strings.stream()\n                      .filter(s -> s.startsWith(prefix))\n                      .collect(Collectors.toList());\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.filter_by_prefix(new ArrayList<>(), \"a\"));  // []\n        System.out.println(solution.filter_by_prefix(Arrays.asList(\"abc\", \"bcd\", \"cde\", \"array\"), \"a\"));  // [abc, array]\n        System.out.println(solution.filter_by_prefix(Arrays.asList(\"apple\", \"banana\", \"apricot\", \"cherry\"), \"a\"));  // [apple, apricot]\n    }\n}\n"}
{"task_id": "Java/30", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return only positive numbers in the list.\n     */\n    public List<Integer> get_positive(List<Integer> l) {\n        return l.stream()\n                .filter(num -> num > 0)\n                .collect(Collectors.toList());\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(\"Test Case 1: \" + testGetPositive(Arrays.asList(-1, 2, -4, 5, 6), Arrays.asList(2, 5, 6)));\n        System.out.println(\"Test Case 2: \" + testGetPositive(Arrays.asList(5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10), Arrays.asList(5, 3, 2, 3, 9, 123, 1)));\n    }\n\n    private static boolean testGetPositive(List<Integer> input, List<Integer> expected) {\n        Solution solution = new Solution();\n        List<Integer> result = solution.get_positive(input);\n        return result.equals(expected);\n    }\n}\n"}
{"task_id": "Java/31", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Return true if a given number is prime, and false otherwise.\n     */\n    public boolean is_prime(int n) {\n        // Handle edge cases for 0, 1, and negative numbers\n        if (n <= 1) {\n            return false;\n        }\n        \n        // Check divisibility from 2 to the square root of n\n        for (int i = 2; i <= Math.sqrt(n); i++) {\n            if (n % i == 0) {\n                return false;\n            }\n        }\n        \n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(\"is_prime(6): \" + !solution.is_prime(6));   // Expected: false\n        System.out.println(\"is_prime(101): \" + solution.is_prime(101)); // Expected: true\n        System.out.println(\"is_prime(11): \" + solution.is_prime(11));   // Expected: true\n        System.out.println(\"is_prime(13441): \" + !solution.is_prime(13441)); // Expected: false (13441 is not prime)\n        System.out.println(\"is_prime(61): \" + solution.is_prime(61));   // Expected: true\n        System.out.println(\"is_prime(4): \" + !solution.is_prime(4));    // Expected: false\n        System.out.println(\"is_prime(1): \" + !solution.is_prime(1));    // Expected: false\n    }\n}\n"}
{"task_id": "Java/32", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Evaluates polynomial with coefficients xs at point x.\n     * return xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n\n     */\n    public double poly(List<Double> xs, double x) {\n        double result = 0;\n        for (int i = 0; i < xs.size(); i++) {\n            result += xs.get(i) * Math.pow(x, i);\n        }\n        return result;\n    }\n\n    /**\n     * xs are coefficients of a polynomial.\n     * find_zero finds x such that poly(x) = 0.\n     * find_zero returns only one zero point, even if there are many.\n     * Moreover, find_zero only takes list xs having an even number of coefficients\n     * and largest non-zero coefficient as it guarantees a solution.\n     */\n    public double find_zero(List<Double> xs) {\n        if (xs.size() % 2 != 0) {\n            throw new IllegalArgumentException(\"The list of coefficients must have an even number of elements.\");\n        }\n\n        // Ensure the largest non-zero coefficient is at the end\n        List<Double> nonZeroCoefficients = new ArrayList<>();\n        for (double c : xs) {\n            if (c != 0) {\n                nonZeroCoefficients.add(c);\n            }\n        }\n        if (nonZeroCoefficients.isEmpty() || Math.abs(nonZeroCoefficients.get(nonZeroCoefficients.size() - 1)) == 0) {\n            throw new IllegalArgumentException(\"The list of coefficients must contain a non-zero element.\");\n        }\n\n        double[] coefficients = new double[nonZeroCoefficients.size()];\n        for (int i = 0; i < nonZeroCoefficients.size(); i++) {\n            coefficients[i] = nonZeroCoefficients.get(i);\n        }\n\n        // Initial guess based on the largest coefficient\n        double x = 0.5 * (coefficients[coefficients.length - 1] / coefficients[0]);\n\n        for (int iteration = 0; iteration < 100; iteration++) { // Limiting iterations to avoid infinite loops\n            double polyVal = poly(Arrays.asList(coefficients), x);\n            if (Math.abs(polyVal) < 1e-6) { // Tolerance level\n                return x;\n            }\n            double derivative = 0;\n            for (int i = 1; i < coefficients.length; i++) {\n                derivative += i * coefficients[i] * Math.pow(x, i - 1);\n            }\n            x -= polyVal / derivative;\n        }\n\n        throw new IllegalArgumentException(\"Failed to converge to a root within the given iterations.\");\n    }\n}\n"}
{"task_id": "Java/33", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> sort_third(List<Integer> l) {\n        List<Integer> result = new ArrayList<>(l);\n        List<Integer> thirdIndicesValues = new ArrayList<>();\n        \n        // Collect values at indices divisible by three\n        for (int i = 2; i < l.size(); i += 3) {\n            thirdIndicesValues.add(l.get(i));\n        }\n        \n        // Sort the collected values\n        Collections.sort(thirdIndicesValues);\n        \n        // Update the result list with sorted values at appropriate positions\n        int index = 0;\n        for (int i = 2; i < l.size(); i += 3) {\n            result.set(i, thirdIndicesValues.get(index++));\n        }\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.sort_third(Arrays.asList(1, 2, 3))); // [1, 2, 3]\n        System.out.println(solution.sort_third(Arrays.asList(5, 6, 3, 4, 8, 9, 2))); // [2, 6, 3, 4, 8, 9, 5]\n    }\n}\n"}
{"task_id": "Java/34", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return sorted unique elements in a list\n     *\n     * @param l input list of integers\n     * @return a List containing sorted unique elements from the input list\n     */\n    public List<Integer> unique(List<Integer> l) {\n        Set<Integer> set = new TreeSet<>(l);\n        return new ArrayList<>(set);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.unique(Arrays.asList(5, 3, 5, 2, 3, 3, 9, 0, 123))); // [0, 2, 3, 5, 9, 123]\n        System.out.println(solution.unique(Arrays.asList())); // []\n        System.out.println(solution.unique(Arrays.asList(1, 2, 3))); // [1, 2, 3]\n        System.out.println(solution.unique(Arrays.asList(-1, -2, -3, -4, -5))); // [-5, -4, -3, -2, -1]\n        System.out.println(solution.unique(Arrays.asList(7, 8, 9, 7, 8, 9, 10))); // [7, 8, 9, 10]\n    }\n}\n"}
{"task_id": "Java/35", "generation": "import java.util.Arrays;\nimport java.util.List;\n\nclass Solution {\n\n    /**\n     * Return maximum element in the list.\n     */\n    public int max_element(List<Integer> l) {\n        if (l == null || l.isEmpty()) {\n            throw new IllegalArgumentException(\"List cannot be null or empty\");\n        }\n        \n        return l.stream().max(Integer::compare).get();\n    }\n\n    // Test cases to verify the correctness of the function\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        List<Integer> list1 = Arrays.asList(1, 2, 3);\n        System.out.println(\"Max element in \" + list1 + \": \" + solution.max_element(list1)); // Expected: 3\n\n        // Test case 2\n        List<Integer> list2 = Arrays.asList(5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10);\n        System.out.println(\"Max element in \" + list2 + \": \" + solution.max_element(list2)); // Expected: 123\n\n        // Test case 3\n        List<Integer> list3 = Arrays.asList(-1, -2, -3, -4);\n        System.out.println(\"Max element in \" + list3 + \": \" + solution.max_element(list3)); // Expected: -1\n\n        // Test case 4\n        List<Integer> list4 = Arrays.asList(0);\n        System.out.println(\"Max element in \" + list4 + \": \" + solution.max_element(list4)); // Expected: 0\n\n        // Test case 5 (edge case)\n        List<Integer> list5 = Arrays.asList();\n        try {\n            System.out.println(\"Max element in empty list: \" + solution.max_element(list5));\n        } catch (IllegalArgumentException e) {\n            System.out.println(e.getMessage()); // Expected: List cannot be null or empty\n        }\n    }\n}\n"}
{"task_id": "Java/36", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n\n    /**\n     * Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n     */\n    public int fizz_buzz(int n) {\n        int count = 0;\n        for (int i = 1; i < n; i++) {\n            if (i % 11 == 0 || i % 13 == 0) {\n                String numStr = Integer.toString(i);\n                for (char c : numStr.toCharArray()) {\n                    if (c == '7') {\n                        count++;\n                    }\n                }\n            }\n        }\n        return count;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(\"fizz_buzz(50): \" + solution.fizz_buzz(50)); // Expected: 0\n        System.out.println(\"fizz_buzz(78): \" + solution.fizz_buzz(78)); // Expected: 2\n        System.out.println(\"fizz_buzz(79): \" + solution.fizz_buzz(79)); // Expected: 3\n        System.out.println(\"fizz_buzz(100): \" + solution.fizz_buzz(100)); // Expected: 4 (77, 781, 782, 783)\n        System.out.println(\"fizz_buzz(150): \" + solution.fizz_buzz(150)); // Expected: 6\n    }\n}\n"}
{"task_id": "Java/37", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * This function takes a list l and returns a list l' such that\n     * l' is identical to l in the odd indicies, while its values at the even indicies are equal\n     * to the values of the even indicies of l, but sorted.\n     */\n    public List<Integer> sort_even(List<Integer> l) {\n        List<Integer> result = new ArrayList<>(l);\n        List<Integer> evenIndicesValues = new ArrayList<>();\n        \n        // Extract values at even indices\n        for (int i = 0; i < result.size(); i += 2) {\n            evenIndicesValues.add(result.get(i));\n        }\n        \n        // Sort the extracted values\n        Collections.sort(evenIndicesValues);\n        \n        // Place sorted values back into their original positions\n        int evenIndex = 0;\n        for (int i = 0; i < result.size(); i += 2) {\n            result.set(i, evenIndicesValues.get(evenIndex++));\n        }\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.sort_even(Arrays.asList(1, 2, 3))); // Expected: [1, 2, 3]\n        System.out.println(solution.sort_even(Arrays.asList(5, 6, 3, 4))); // Expected: [3, 6, 5, 4]\n        System.out.println(solution.sort_even(Arrays.asList(9, 8, 7, 6, 5, 4, 3, 2, 1))); // Expected: [3, 8, 7, 6, 5, 4, 9, 2, 1]\n        System.out.println(solution.sort_even(Arrays.asList())); // Expected: []\n    }\n}\n"}
{"task_id": "Java/38", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Encodes a string by cycling groups of three characters.\n     */\n    public String encodeCyclic(String s) {\n        // Split string to groups. Each of length 3.\n        List<String> groups = new ArrayList<>();\n        for (int i = 0; i < s.length(); i += 3) {\n            groups.add(s.substring(i, Math.min(i + 3, s.length())));\n        }\n        \n        // Cycle elements in each group unless the group has fewer than 3 characters.\n        for (int i = 0; i < groups.size(); i++) {\n            if (groups.get(i).length() == 3) {\n                groups.set(i, groups.get(i).substring(1) + groups.get(i).charAt(0));\n            }\n        }\n        \n        return String.join(\"\", groups);\n    }\n\n    /**\n     * Decodes a string that was encoded with the encodeCyclic function.\n     */\n    public String decodeCyclic(String s) {\n        // Split string to groups. Each of length 3.\n        List<String> groups = new ArrayList<>();\n        for (int i = 0; i < s.length(); i += 3) {\n            groups.add(s.substring(i, Math.min(i + 3, s.length())));\n        }\n        \n        // Reverse the cycling process in each group unless the group has fewer than 3 characters.\n        for (int i = 0; i < groups.size(); i++) {\n            if (groups.get(i).length() == 3) {\n                groups.set(i, \"\" + groups.get(i).charAt(1) + groups.get(i).charAt(2) + groups.get(i).charAt(0));\n            }\n        }\n        \n        return String.join(\"\", groups);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        String encoded = solution.encodeCyclic(\"hello\");\n        System.out.println(\"Encoded: \" + encoded); // Should print the encoded string\n        String decoded = solution.decodeCyclic(encoded);\n        System.out.println(\"Decoded: \" + decoded); // Should print the original string\n    }\n}\n"}
{"task_id": "Java/39", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * prime_fib returns n-th number that is a Fibonacci number and it's also prime.\n     *\n     * >>> prime_fib(1)\n     * 2\n     * >>> prime_fib(2)\n     * 3\n     * >>> prime_fib(3)\n     * 5\n     * >>> prime_fib(4)\n     * 13\n     * >>> prime_fib(5)\n     * 89\n     */\n    public boolean isPrime(int num) {\n        if (num <= 1) return false;\n        for (int i = 2; i * i <= num; i++) {\n            if (num % i == 0) return false;\n        }\n        return true;\n    }\n\n    public int fib(int n) {\n        if (n == 0) return 0;\n        else if (n == 1) return 1;\n        else {\n            int a = 0, b = 1;\n            for (int i = 2; i <= n; i++) {\n                int temp = a + b;\n                a = b;\n                b = temp;\n            }\n            return b;\n        }\n    }\n\n    public int prime_fib(int n) {\n        int count = 0;\n        int i = 0;\n        while (true) {\n            int fibNum = fib(i);\n            if (isPrime(fibNum)) {\n                count++;\n                if (count == n) {\n                    return fibNum;\n                }\n            }\n            i++;\n        }\n    }\n}\n"}
{"task_id": "Java/40", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * triples_sum_to_zero takes a list of integers as an input.\n     * it returns True if there are three distinct elements in the list that\n     * sum to zero, and False otherwise.\n     */\n    public boolean triples_sum_to_zero(List<Integer> l) {\n        // Sort the list to make it easier to find triplets that sum to zero\n        Collections.sort(l);\n        \n        for (int i = 0; i < l.size() - 2; i++) {\n            int left = i + 1;\n            int right = l.size() - 1;\n            \n            while (left < right) {\n                int sum = l.get(i) + l.get(left) + l.get(right);\n                \n                if (sum == 0) {\n                    return true;\n                } else if (sum < 0) {\n                    left++;\n                } else {\n                    right--;\n                }\n            }\n        }\n        \n        return false;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.triples_sum_to_zero(Arrays.asList(1, 3, 5, 0))); // false\n        System.out.println(solution.triples_sum_to_zero(Arrays.asList(1, 3, -2, 1))); // true\n        System.out.println(solution.triples_sum_to_zero(Arrays.asList(1, 2, 3, 7))); // false\n        System.out.println(solution.triples_sum_to_zero(Arrays.asList(2, 4, -5, 3, 9, 7))); // true\n        System.out.println(solution.triples_sum_to_zero(Arrays.asList(1))); // false\n    }\n}\n"}
{"task_id": "Java/41", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Imagine a road that's a perfectly straight infinitely long line.\n     * n cars are driving left to right; simultaneously, a different set of n cars\n     * are driving right to left. The two sets of cars start out being very far from each other.\n     * All cars move in the same speed. Two cars are said to collide when a car that's moving left to right hits a car that's moving right to left.\n     * However, the cars are infinitely sturdy and strong; as a result, they continue moving in their trajectory as if they did not collide.\n     *\n     * This function outputs the number of such collisions.\n     */\n    public int car_race_collision(int n) {\n        // Since all cars are moving at the same speed and start far apart,\n        // each car traveling left-to-right will eventually collide with each car traveling right-to-left.\n        // The number of collisions is simply the product of the number of cars in each direction.\n        return n * n;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int n = 5; // Example input\n        System.out.println(\"Number of collisions: \" + solution.car_race_collision(n));\n    }\n}\n"}
{"task_id": "Java/42", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return list with elements incremented by 1.\n     *\n     * @param l The input list of integers.\n     * @return A new list where each element is incremented by 1.\n     */\n    public List<Integer> incr_list(List<Integer> l) {\n        return l.stream().map(i -> i + 1).collect(Collectors.toList());\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        List<Integer> list1 = Arrays.asList(1, 2, 3);\n        System.out.println(\"Original: \" + list1);\n        System.out.println(\"Incremented: \" + solution.incr_list(list1));\n\n        // Test case 2\n        List<Integer> list2 = Arrays.asList(5, 3, 5, 2, 3, 3, 9, 0, 123);\n        System.out.println(\"Original: \" + list2);\n        System.out.println(\"Incremented: \" + solution.incr_list(list2));\n    }\n}\n"}
{"task_id": "Java/43", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * pairs_sum_to_zero takes a list of integers as an input.\n     * it returns True if there are two distinct elements in the list that\n     * sum to zero, and False otherwise.\n     */\n    public boolean pairs_sum_to_zero(List<Integer> l) {\n        Set<Integer> seen = new HashSet<>();\n        for (int num : l) {\n            if (seen.contains(-num)) {\n                return true;\n            }\n            seen.add(num);\n        }\n        return false;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.pairs_sum_to_zero(Arrays.asList(1, 3, 5, 0))); // false\n        System.out.println(solution.pairs_sum_to_zero(Arrays.asList(1, 3, -2, 1))); // false\n        System.out.println(solution.pairs_sum_to_zero(Arrays.asList(1, 2, 3, 7))); // false\n        System.out.println(solution.pairs_sum_to_zero(Arrays.asList(2, 4, -5, 3, 5, 7))); // true\n        System.out.println(solution.pairs_sum_to_zero(Arrays.asList(1))); // false\n    }\n}\n"}
{"task_id": "Java/44", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Change numerical base of input number x to base.\n     * return string representation after the conversion.\n     * base numbers are less than 10.\n     *\n     * @param x The number to be converted.\n     * @param base The target base for conversion (less than 10).\n     * @return String representation of the converted number.\n     */\n    public String change_base(int x, int base) {\n        if (x == 0) return \"0\";\n        \n        StringBuilder result = new StringBuilder();\n        while (x > 0) {\n            int remainder = x % base;\n            result.insert(0, remainder);\n            x /= base;\n        }\n        \n        return result.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.change_base(8, 3));  // Expected output: \"22\"\n        System.out.println(solution.change_base(8, 2));  // Expected output: \"1000\"\n        System.out.println(solution.change_base(7, 2));  // Expected output: \"111\"\n        System.out.println(solution.change_base(255, 16)); // Expected output: \"FF\" (for base 16)\n        System.out.println(solution.change_base(10, 8));  // Expected output: \"12\"\n    }\n}\n"}
{"task_id": "Java/45", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given length of a side (base) and height, return area for a triangle.\n     *\n     * @param a The base of the triangle.\n     * @param h The height of the triangle.\n     * @return The area of the triangle.\n     */\n    public double triangle_area(double a, double h) {\n        return 0.5 * a * h;\n    }\n\n    /**\n     * Main method to run test cases for the triangle_area function.\n     *\n     * @param args Command line arguments (not used).\n     */\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(\"Test Case 1: Base = 5, Height = 3\");\n        double result1 = solution.triangle_area(5, 3);\n        System.out.println(\"Expected: 7.5, Actual: \" + result1);\n\n        System.out.println(\"\\nTest Case 2: Base = 10, Height = 4\");\n        double result2 = solution.triangle_area(10, 4);\n        System.out.println(\"Expected: 20.0, Actual: \" + result2);\n\n        System.out.println(\"\\nTest Case 3: Base = 7, Height = 8\");\n        double result3 = solution.triangle_area(7, 8);\n        System.out.println(\"Expected: 28.0, Actual: \" + result3);\n\n        // Add more test cases as needed\n    }\n}\n"}
{"task_id": "Java/46", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n    The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n    fib4(0) -> 0\n    fib4(1) -> 0\n    fib4(2) -> 2\n    fib4(3) -> 0\n    fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n    Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.\n    >>> fib4(5)\n    4\n    >>> fib4(6)\n    8\n    >>> fib4(7)\n    14\n     */\n    public int fib4(int n) {\n        if (n == 0 || n == 1) return 0;\n        if (n == 2) return 2;\n        if (n == 3) return 0;\n\n        int[] dp = new int[n + 1];\n        dp[0] = 0;\n        dp[1] = 0;\n        dp[2] = 2;\n        dp[3] = 0;\n\n        for (int i = 4; i <= n; i++) {\n            dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3] + dp[i - 4];\n        }\n\n        return dp[n];\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.fib4(5)); // Expected output: 4\n        System.out.println(solution.fib4(6)); // Expected output: 8\n        System.out.println(solution.fib4(7)); // Expected output: 14\n        System.out.println(solution.fib4(8)); // Expected output: 24\n        System.out.println(solution.fib4(9)); // Expected output: 44\n    }\n}\n"}
{"task_id": "Java/47", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return median of elements in the list l.\n     */\n    public double median(List<Integer> l) {\n        if (l == null || l.isEmpty()) {\n            throw new IllegalArgumentException(\"List cannot be null or empty\");\n        }\n\n        Collections.sort(l);\n        int size = l.size();\n        if (size % 2 == 0) {\n            return (l.get(size / 2 - 1) + l.get(size / 2)) / 2.0;\n        } else {\n            return l.get(size / 2);\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        List<Integer> testList1 = Arrays.asList(3, 1, 2, 4, 5);\n        System.out.println(\"Median of [3, 1, 2, 4, 5]: \" + solution.median(testList1)); // Expected: 3\n\n        List<Integer> testList2 = Arrays.asList(-10, 4, 6, 1000, 10, 20);\n        System.out.println(\"Median of [-10, 4, 6, 1000, 10, 20]: \" + solution.median(testList2)); // Expected: 8.0\n\n        List<Integer> testList3 = Arrays.asList(1, 2, 3, 4);\n        System.out.println(\"Median of [1, 2, 3, 4]: \" + solution.median(testList3)); // Expected: 2.5\n\n        List<Integer> testList4 = Arrays.asList(-5, -3, -1, 0, 2, 4, 6);\n        System.out.println(\"Median of [-5, -3, -1, 0, 2, 4, 6]: \" + solution.median(testList4)); // Expected: 0.0\n\n        List<Integer> testList5 = Arrays.asList();\n        try {\n            System.out.println(\"Median of []: \" + solution.median(testList5));\n        } catch (IllegalArgumentException e) {\n            System.out.println(\"Caught expected exception for empty list: \" + e.getMessage());\n        }\n\n        List<Integer> testList6 = null;\n        try {\n            System.out.println(\"Median of null: \" + solution.median(testList6));\n        } catch (IllegalArgumentException e) {\n            System.out.println(\"Caught expected exception for null list: \" + e.getMessage());\n        }\n    }\n}\n"}
{"task_id": "Java/48", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     Checks if given string is a palindrome\n     >>> is_palindrome(\"\")\n     true\n     >>> is_palindrome(\"aba\")\n     true\n     >>> is_palindrome(\"aaaaa\")\n     true\n     >>> is_palindrome(\"zbcd\")\n     false\n     */\n    public boolean is_palindrome(String text) {\n        int left = 0;\n        int right = text.length() - 1;\n\n        while (left < right) {\n            if (text.charAt(left) != text.charAt(right)) {\n                return false;\n            }\n            left++;\n            right--;\n        }\n\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.is_palindrome(\"\"));       // true\n        System.out.println(solution.is_palindrome(\"aba\"));    // true\n        System.out.println(solution.is_palindrome(\"aaaaa\"));  // true\n        System.out.println(solution.is_palindrome(\"zbcd\"));   // false\n        System.out.println(solution.is_palindrome(\"level\"));  // true\n        System.out.println(solution.is_palindrome(\"noon\"));   // true\n        System.out.println(solution.is_palindrome(\"abcde\"));  // false\n    }\n}\n"}
{"task_id": "Java/49", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return 2^n modulo p (be aware of numerics).\n     */\n    public int modp(int n, int p) {\n        if (n == 0) return 1; // Base case: 2^0 = 1\n        long result = 1;\n        for (int i = 0; i < n; i++) {\n            result = (result * 2) % p;\n        }\n        return (int) result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.modp(3, 5));   // Expected output: 3\n        System.out.println(solution.modp(1101, 101)); // Expected output: 2\n        System.out.println(solution.modp(0, 101));  // Expected output: 1\n        System.out.println(solution.modp(3, 11));   // Expected output: 8\n        System.out.println(solution.modp(100, 101)); // Expected output: 1\n    }\n}\n"}
{"task_id": "Java/50", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    returns encoded string by shifting every character by 5 in the alphabet.\n     */\n    public String encodeShift(String s) {\n        StringBuilder sb = new StringBuilder();\n        for (char ch : s.toCharArray()) {\n            if (ch >= 'a' && ch <= 'z') {\n                sb.append((char) ('a' + ((ch - 'a' + 5) % 26)));\n            } else if (ch >= 'A' && ch <= 'Z') {\n                sb.append((char) ('A' + ((ch - 'A' + 5) % 26)));\n            } else {\n                sb.append(ch);\n            }\n        }\n        return sb.toString();\n    }\n\n    /**\n    takes as input string encoded with encodeShift function. Returns decoded string.\n     */\n    public String decode_shift(String s) {\n        StringBuilder sb = new StringBuilder();\n        for (char ch : s.toCharArray()) {\n            if (ch >= 'a' && ch <= 'z') {\n                sb.append((char) ('a' + ((ch - 'a' - 5 + 26) % 26)));\n            } else if (ch >= 'A' && ch <= 'Z') {\n                sb.append((char) ('A' + ((ch - 'A' - 5 + 26) % 26)));\n            } else {\n                sb.append(ch);\n            }\n        }\n        return sb.toString();\n    }\n}\n"}
{"task_id": "Java/51", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * remove_vowels is a function that takes string and returns string without vowels.\n     */\n    public String remove_vowels(String text) {\n        if (text == null || text.isEmpty()) {\n            return text;\n        }\n        \n        StringBuilder result = new StringBuilder();\n        for (char c : text.toCharArray()) {\n            if (!isVowel(c)) {\n                result.append(c);\n            }\n        }\n        return result.toString();\n    }\n\n    private boolean isVowel(char c) {\n        return \"AEIOUaeiou\".indexOf(c) != -1;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.remove_vowels(\"\")); // Output: \"\"\n        System.out.println(solution.remove_vowels(\"abcdef\\nghijklm\")); // Output: \"bcdf\\nghjklm\"\n        System.out.println(solution.remove_vowels(\"abcdef\")); // Output: \"bcdf\"\n        System.out.println(solution.remove_vowels(\"aaaaa\")); // Output: \"\"\n        System.out.println(solution.remove_vowels(\"aaBAA\")); // Output: \"B\"\n        System.out.println(solution.remove_vowels(\"zbcd\")); // Output: \"zbcd\"\n    }\n}\n"}
{"task_id": "Java/52", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return True if all numbers in the list l are below threshold t.\n     */\n    public boolean below_threshold(List<Integer> l, int t) {\n        for (int num : l) {\n            if (num >= t) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.below_threshold(Arrays.asList(1, 2, 4, 10), 100)); // Expected: true\n        System.out.println(solution.below_threshold(Arrays.asList(1, 20, 4, 10), 5));  // Expected: false\n        System.out.println(solution.below_threshold(Arrays.asList(-1, -2, -3), 0));    // Expected: true\n        System.out.println(solution.below_threshold(Arrays.asList(), 100));            // Expected: true (empty list)\n        System.out.println(solution.below_threshold(Arrays.asList(99, 100, 101), 100)); // Expected: false\n    }\n}\n"}
{"task_id": "Java/53", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Add two numbers x and y\n     * >>> add(2, 3)\n     * 5\n     * >>> add(5, 7)\n     * 12\n     */\n    public int add(int x, int y) {\n        return x + y;\n    }\n}\n"}
{"task_id": "Java/54", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Check if two words have the same kind of characters.\n     */\n    public boolean same_chars(String s0, String s1) {\n        // Convert both strings to sets of characters\n        Set<Character> set0 = new HashSet<>();\n        for (char c : s0.toCharArray()) {\n            set0.add(c);\n        }\n        \n        Set<Character> set1 = new HashSet<>();\n        for (char c : s1.toCharArray()) {\n            set1.add(c);\n        }\n        \n        // Compare the sets\n        return set0.equals(set1);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.same_chars(\"eabcdzzzz\", \"dddzzzzzzzddeddabc\")); // true\n        System.out.println(solution.same_chars(\"abcd\", \"dddddddabc\"));              // true\n        System.out.println(solution.same_chars(\"dddddddabc\", \"abcd\"));              // true\n        System.out.println(solution.same_chars(\"eabcd\", \"dddddddabc\"));             // false\n        System.out.println(solution.same_chars(\"abcd\", \"dddddddabce\"));             // false\n        System.out.println(solution.same_chars(\"eabcdzzzz\", \"dddzzzzzzzddddabc\"));  // false\n    }\n}\n"}
{"task_id": "Java/55", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return n-th Fibonacci number.\n     * >>> fib(10)\n     * 55\n     * >>> fib(1)\n     * 1\n     * >>> fib(8)\n     * 21\n     */\n    public int fib(int n) {\n        if (n <= 0) {\n            return 0;\n        } else if (n == 1) {\n            return 1;\n        }\n        \n        int a = 0, b = 1, c = 0;\n        for (int i = 2; i <= n; i++) {\n            c = a + b;\n            a = b;\n            b = c;\n        }\n        return b;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(\"fib(10): \" + solution.fib(10)); // Expected: 55\n        System.out.println(\"fib(1): \" + solution.fib(1));   // Expected: 1\n        System.out.println(\"fib(8): \" + solution.fib(8));   // Expected: 21\n        System.out.println(\"fib(0): \" + solution.fib(0));   // Expected: 0\n        System.out.println(\"fib(-5): \" + solution.fib(-5)); // Expected: 0 (or handle as an error)\n    }\n}\n"}
{"task_id": "Java/56", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * brackets is a string of \"<\" and \">\".\n     * return True if every opening bracket has a corresponding closing bracket.\n     *\n     * >>> correct_bracketing(\"<\")\n     * false\n     * >>> correct_bracketing(\"<>\")\n     * true\n     * >>> correct_bracketing(\"<<><>>\")\n     * true\n     * >>> correct_bracketing(\"><<>\")\n     * false\n     */\n    public boolean correct_bracketing(String brackets) {\n        int balance = 0;\n        for (char c : brackets.toCharArray()) {\n            if (c == '<') {\n                balance++;\n            } else if (c == '>') {\n                balance--;\n            }\n            // If at any point the balance is negative, it means there's a closing bracket without an opening one\n            if (balance < 0) {\n                return false;\n            }\n        }\n        // If the balance is zero, all brackets are correctly matched\n        return balance == 0;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.correct_bracketing(\"<\"));      // false\n        System.out.println(solution.correct_bracketing(\"<>\"));     // true\n        System.out.println(solution.correct_bracketing(\"<<><>>\")); // true\n        System.out.println(solution.correct_bracketing(\"><<>\"));   // false\n    }\n}\n"}
{"task_id": "Java/57", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Return True if list elements are monotonically increasing or decreasing.\n    >>> monotonic(Arrays.asList(1, 2, 4, 20))\n    true\n    >>> monotonic(Arrays.asList(1, 20, 4, 10))\n    false\n    >>> monotonic(Arrays.asList(4, 1, 0, -10))\n    true\n     */\n    public boolean monotonic(List<Integer> l) {\n        boolean increasing = true;\n        boolean decreasing = true;\n\n        for (int i = 1; i < l.size(); i++) {\n            if (l.get(i) < l.get(i - 1)) {\n                increasing = false;\n            }\n            if (l.get(i) > l.get(i - 1)) {\n                decreasing = false;\n            }\n        }\n\n        return increasing || decreasing;\n    }\n}\n"}
{"task_id": "Java/58", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return sorted unique common elements for two lists.\n     */\n    public List<Integer> common(List<Integer> l1, List<Integer> l2) {\n        Set<Integer> set1 = new HashSet<>(l1);\n        Set<Integer> set2 = new HashSet<>(l2);\n\n        // Retain only the elements that are present in both sets\n        set1.retainAll(set2);\n\n        // Convert the resulting set to a sorted list\n        List<Integer> result = new ArrayList<>(set1);\n        Collections.sort(result);\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        List<Integer> l1 = Arrays.asList(1, 4, 3, 34, 653, 2, 5);\n        List<Integer> l2 = Arrays.asList(5, 7, 1, 5, 9, 653, 121);\n        System.out.println(\"Common elements (Test case 1): \" + solution.common(l1, l2)); // Expected: [1, 5, 653]\n\n        // Test case 2\n        List<Integer> l3 = Arrays.asList(5, 3, 2, 8);\n        List<Integer> l4 = Arrays.asList(3, 2);\n        System.out.println(\"Common elements (Test case 2): \" + solution.common(l3, l4)); // Expected: [2, 3]\n\n        // Test case 3\n        List<Integer> l5 = Arrays.asList(10, 20, 30, 40);\n        List<Integer> l6 = Arrays.asList(50, 60, 70);\n        System.out.println(\"Common elements (Test case 3): \" + solution.common(l5, l6)); // Expected: []\n\n        // Test case 4\n        List<Integer> l7 = Arrays.asList(1, 2, 3, 4, 5);\n        List<Integer> l8 = Arrays.asList(3, 4, 5, 6, 7);\n        System.out.println(\"Common elements (Test case 4): \" + solution.common(l7, l8)); // Expected: [3, 4, 5]\n    }\n}\n"}
{"task_id": "Java/59", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n     */\n    public int largest_prime_factor(int n) {\n        boolean isPrime(int num) {\n            if (num <= 1) return false;\n            for (int i = 2; i * i <= num; i++) {\n                if (num % i == 0) return false;\n            }\n            return true;\n        }\n\n        int factor = 2;\n        while (factor * factor <= n) {\n            while (n % factor == 0 && isPrime(factor)) {\n                n /= factor;\n            }\n            factor++;\n        }\n        return n;\n    }\n}\n"}
{"task_id": "Java/60", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * sum_to_n is a function that sums numbers from 1 to n.\n     */\n    public int sum_to_n(int n) {\n        return (n * (n + 1)) / 2;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(\"sum_to_n(30): \" + solution.sum_to_n(30)); // Expected: 465\n        System.out.println(\"sum_to_n(100): \" + solution.sum_to_n(100)); // Expected: 5050\n        System.out.println(\"sum_to_n(5): \" + solution.sum_to_n(5)); // Expected: 15\n        System.out.println(\"sum_to_n(10): \" + solution.sum_to_n(10)); // Expected: 55\n        System.out.println(\"sum_to_n(1): \" + solution.sum_to_n(1)); // Expected: 1\n    }\n}\n"}
{"task_id": "Java/61", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * brackets is a string of \"(\" and \")\".\n     * return True if every opening bracket has a corresponding closing bracket.\n     *\n     * >>> correct_bracketing(\"(\")\n     * false\n     * >>> correct_bracketing(\"()\")\n     * true\n     * >>> correct_bracketing(\"(()())\")\n     * true\n     * >>> correct_bracketing(\")(()\")\n     * false\n     */\n    public boolean correct_bracketing(String brackets) {\n        Stack<Character> stack = new Stack<>();\n        \n        for (char c : brackets.toCharArray()) {\n            if (c == '(') {\n                stack.push(c);\n            } else if (c == ')') {\n                if (stack.isEmpty()) {\n                    return false;\n                }\n                stack.pop();\n            }\n        }\n        \n        return stack.isEmpty();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.correct_bracketing(\"(\"));       // Output: false\n        System.out.println(solution.correct_bracketing(\"()\"));      // Output: true\n        System.out.println(solution.correct_bracketing(\"(()())\"));  // Output: true\n        System.out.println(solution.correct_bracketing(\")(()\"));    // Output: false\n        System.out.println(solution.correct_bracketing(\"(())\"));    // Output: true\n        System.out.println(solution.correct_bracketing(\"()()\"));    // Output: true\n        System.out.println(solution.correct_bracketing(\"(()\"));     // Output: false\n        System.out.println(solution.correct_bracketing(\")(\"));      // Output: false\n    }\n}\n"}
{"task_id": "Java/62", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * xs represent coefficients of a polynomial.\n     * xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     * Return derivative of this polynomial in the same form.\n     */\n    public List<Integer> derivative(List<Integer> xs) {\n        if (xs == null || xs.isEmpty()) {\n            return Collections.emptyList();\n        }\n        \n        List<Integer> result = new ArrayList<>();\n        for (int i = 1; i < xs.size(); i++) {\n            result.add(xs.get(i) * i);\n        }\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(\"Derivative of [3, 1, 2, 4, 5]: \" + solution.derivative(Arrays.asList(3, 1, 2, 4, 5)));\n        System.out.println(\"Derivative of [1, 2, 3]: \" + solution.derivative(Arrays.asList(1, 2, 3)));\n\n        // Additional test cases\n        System.out.println(\"Derivative of [0, 1, 2, 3]: \" + solution.derivative(Arrays.asList(0, 1, 2, 3)));\n        System.out.println(\"Derivative of [5]: \" + solution.derivative(Arrays.asList(5)));\n        System.out.println(\"Derivative of []: \" + solution.derivative(new ArrayList<>()));\n    }\n}\n"}
{"task_id": "Java/63", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     The FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n     fibfib(0) == 0\n     fibfib(1) == 0\n     fibfib(2) == 1\n     fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n     Please write a function to efficiently compute the n-th element of the fibfib number sequence.\n     >>> fibfib(1)\n     0\n     >>> fibfib(5)\n     4\n     >>> fibfib(8)\n     24\n      */\n    public int fibfib(int n) {\n        if (n == 0 || n == 1) return 0;\n        if (n == 2) return 1;\n\n        int a = 0, b = 0, c = 1;\n        for (int i = 3; i <= n; i++) {\n            int temp = a + b + c;\n            a = b;\n            b = c;\n            c = temp;\n        }\n        return c;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.fibfib(1));  // Expected output: 0\n        System.out.println(solution.fibfib(5));  // Expected output: 4\n        System.out.println(solution.fibfib(8));  // Expected output: 24\n        System.out.println(solution.fibfib(10)); // Expected output: 76\n    }\n}\n"}
{"task_id": "Java/64", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Write a function vowels_count which takes a string representing\n     * a word as input and returns the number of vowels in the string.\n     * Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n     * vowel, but only when it is at the end of the given word.\n     *\n     * Example:\n     * >>> vowels_count(\"abcde\")\n     * 2\n     * >>> vowels_count(\"ACEDY\")\n     * 3\n     */\n    public int vowels_count(String s) {\n        int count = 0;\n        for (int i = 0; i < s.length(); i++) {\n            char c = Character.toLowerCase(s.charAt(i));\n            if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n                count++;\n            } else if (c == 'y' && i == s.length() - 1) {\n                count++;\n            }\n        }\n        return count;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.vowels_count(\"abcde\")); // Expected output: 2\n        System.out.println(solution.vowels_count(\"ACEDY\")); // Expected output: 3\n        System.out.println(solution.vowels_count(\"rhythm\")); // Expected output: 0\n        System.out.println(solution.vowels_count(\"encyclopedia\")); // Expected output: 6\n        System.out.println(solution.vowels_count(\"quickly\")); // Expected output: 1\n    }\n}\n"}
{"task_id": "Java/65", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public String circular_shift(int x, int shift) {\n        String strX = Integer.toString(x);\n        int numDigits = strX.length();\n        \n        if (shift >= numDigits) {\n            return new StringBuilder(strX).reverse().toString();\n        } else {\n            shift %= numDigits; // Handle shifts greater than the number of digits\n            String shiftedStr = strX.substring(numDigits - shift) + strX.substring(0, numDigits - shift);\n            return shiftedStr;\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.circular_shift(12, 1)); // Output: \"21\"\n        System.out.println(solution.circular_shift(12, 2)); // Output: \"12\"\n    }\n}\n"}
{"task_id": "Java/66", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Write a function that takes a string as input and returns the sum of the upper characters only ASCII codes.\n     *\n     * Examples:\n     * digitSum(\"\") => 0\n     * digitSum(\"abAB\") => 131\n     * digitSum(\"abcCd\") => 67\n     * digitSum(\"helloE\") => 69\n     * digitSum(\"woArBld\") => 131\n     * digitSum(\"aAaaaXa\") => 153\n     */\n    public int digitSum(String s) {\n        int sum = 0;\n        for (char c : s.toCharArray()) {\n            if (Character.isUpperCase(c)) {\n                sum += c;\n            }\n        }\n        return sum;\n    }\n\n    // Test cases to verify the correctness of the method\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.digitSum(\"\")); // Expected output: 0\n        System.out.println(solution.digitSum(\"abAB\")); // Expected output: 131 ('A' + 'B')\n        System.out.println(solution.digitSum(\"abcCd\")); // Expected output: 67 ('C' + 'D')\n        System.out.println(solution.digitSum(\"helloE\")); // Expected output: 69 ('E')\n        System.out.println(solution.digitSum(\"woArBld\")); // Expected output: 131 ('A' + 'B' + 'L' + 'D')\n        System.out.println(solution.digitSum(\"aAaaaXa\")); // Expected output: 153 ('A' * 4 + 'X')\n    }\n}\n"}
{"task_id": "Java/67", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * In this task, you will be given a string that represents a number of apples and oranges\n     * that are distributed in a basket of fruit. The basket contains apples, oranges, and mango fruits.\n     * Given the string that represents the total number of the oranges and apples and an integer that represent the total number of the fruits\n     * in the basket return the number of the mango fruits in the basket.\n     *\n     * @param s a string representing the number of apples and oranges (e.g., \"5 apples and 6 oranges\")\n     * @param n the total number of fruits in the basket\n     * @return the number of mango fruits in the basket\n     */\n    public int fruit_distribution(String s, int n) {\n        // Extract the numbers from the string\n        String[] parts = s.split(\" \");\n        int apples = Integer.parseInt(parts[0]);\n        int oranges = Integer.parseInt(parts[3]);\n\n        // Calculate the number of mangoes\n        return n - (apples + oranges);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.fruit_distribution(\"5 apples and 6 oranges\", 19)); // Expected output: 8\n        System.out.println(solution.fruit_distribution(\"0 apples and 1 oranges\", 3));   // Expected output: 2\n        System.out.println(solution.fruit_distribution(\"2 apples and 3 oranges\", 100)); // Expected output: 95\n        System.out.println(solution.fruit_distribution(\"100 apples and 1 oranges\", 120)); // Expected output: 19\n    }\n}\n"}
{"task_id": "Java/68", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given an array representing a branch of a tree that has non-negative integer nodes,\n     * your task is to pluck one of the nodes and return it.\n     * The plucked node should be the node with the smallest even value.\n     * If multiple nodes with the same smallest even value are found, return the node that has the smallest index.\n     *\n     * @param arr the list of integer values representing tree branch nodes\n     * @return a list containing the smallest even value and its index, or an empty list if no valid node is found\n     */\n    public List<Integer> pluck(List<Integer> arr) {\n        int minEvenValue = Integer.MAX_VALUE;\n        int minIndex = -1;\n\n        for (int i = 0; i < arr.size(); i++) {\n            int value = arr.get(i);\n            if (value % 2 == 0 && value <= minEvenValue) {\n                if (value < minEvenValue || (value == minEvenValue && i < minIndex)) {\n                    minEvenValue = value;\n                    minIndex = i;\n                }\n            }\n        }\n\n        if (minIndex == -1) {\n            return new ArrayList<>();\n        } else {\n            return Arrays.asList(minEvenValue, minIndex);\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.pluck(Arrays.asList(4, 2, 3))); // Output: [2, 1]\n        System.out.println(solution.pluck(Arrays.asList(1, 2, 3))); // Output: [2, 1]\n        System.out.println(solution.pluck(Arrays.asList()));       // Output: []\n        System.out.println(solution.pluck(Arrays.asList(5, 0, 3, 0, 4, 2))); // Output: [0, 1]\n    }\n}\n"}
{"task_id": "Java/69", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * You are given a non-empty list of positive integers. Return the greatest integer that is greater than\n     * zero, and has a frequency greater than or equal to the value of the integer itself.\n     * The frequency of an integer is the number of times it appears in the list.\n     * If no such a value exist, return -1.\n     *\n     * Examples:\n     * search(Arrays.asList(4, 1, 2, 2, 3, 1)) == 2\n     * search(Arrays.asList(1, 2, 2, 3, 3, 3, 4, 4, 4)) == 3\n     * search(Arrays.asList(5, 5, 4, 4, 4)) == -1\n     */\n    public int search(List<Integer> lst) {\n        Map<Integer, Integer> frequencyMap = new HashMap<>();\n        \n        // Count the frequency of each integer in the list\n        for (int num : lst) {\n            frequencyMap.put(num, frequencyMap.getOrDefault(num, 0) + 1);\n        }\n        \n        int result = -1;\n        \n        // Check which integers meet the criteria and find the greatest one\n        for (Map.Entry<Integer, Integer> entry : frequencyMap.entrySet()) {\n            if (entry.getKey() <= entry.getValue()) {\n                result = Math.max(result, entry.getKey());\n            }\n        }\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.search(Arrays.asList(4, 1, 2, 2, 3, 1))); // Expected output: 2\n        System.out.println(solution.search(Arrays.asList(1, 2, 2, 3, 3, 3, 4, 4, 4))); // Expected output: 3\n        System.out.println(solution.search(Arrays.asList(5, 5, 4, 4, 4))); // Expected output: -1\n        System.out.println(solution.search(Arrays.asList(6, 6, 6, 7, 7, 8, 8, 8, 8))); // Expected output: 8\n    }\n}\n"}
{"task_id": "Java/70", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given list of integers, return list in strange order.\n     * Strange sorting, is when you start with the minimum value,\n     * then maximum of the remaining integers, then minimum and so on.\n     *\n     * Examples:\n     * strange_sort_list(Arrays.asList(1, 2, 3, 4)) == Arrays.asList(1, 4, 2, 3)\n     * strange_sort_list(Arrays.asList(5, 5, 5, 5)) == Arrays.asList(5, 5, 5, 5)\n     * strange_sort_list(Arrays.asList()) == Arrays.asList()\n     */\n    public List<Integer> strange_sort_list(List<Integer> lst) {\n        List<Integer> result = new ArrayList<>();\n        while (!lst.isEmpty()) {\n            // Add the minimum value\n            int minVal = Collections.min(lst);\n            result.add(minVal);\n            lst.remove(Integer.valueOf(minVal));\n            \n            if (lst.isEmpty()) break;\n            \n            // Add the maximum value\n            int maxVal = Collections.max(lst);\n            result.add(maxVal);\n            lst.remove(Integer.valueOf(maxVal));\n        }\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.strange_sort_list(Arrays.asList(1, 2, 3, 4))); // Expected: [1, 4, 2, 3]\n        System.out.println(solution.strange_sort_list(Arrays.asList(5, 5, 5, 5))); // Expected: [5, 5, 5, 5]\n        System.out.println(solution.strange_sort_list(Arrays.asList()));           // Expected: []\n        System.out.println(solution.strange_sort_list(Arrays.asList(10, 20, 30, 40, 50))); // Expected: [10, 50, 20, 40, 30]\n    }\n}\n"}
{"task_id": "Java/71", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n\n    /**\n     * Given the lengths of the three sides of a triangle. Return the area of\n     * the triangle rounded to 2 decimal points if the three sides form a valid triangle.\n     * Otherwise return -1.\n     * Three sides make a valid triangle when the sum of any two sides is greater\n     * than the third side.\n     * Example:\n     * triangle_area(3, 4, 5) == 6.00\n     * triangle_area(1, 2, 10) == -1\n     */\n    public double triangle_area(double a, double b, double c) {\n        // Check if the sides form a valid triangle\n        if (a + b <= c || a + c <= b || b + c <= a) {\n            return -1;\n        }\n        \n        // Calculate the semi-perimeter\n        double s = (a + b + c) / 2.0;\n\n        // Calculate the area using Heron's formula\n        double area = Math.sqrt(s * (s - a) * (s - b) * (s - c));\n        \n        // Round to 2 decimal points\n        return Math.round(area * 100.0) / 100.0;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.triangle_area(3, 4, 5)); // Expected output: 6.00\n        System.out.println(solution.triangle_area(1, 2, 10)); // Expected output: -1\n        System.out.println(solution.triangle_area(7, 8, 9)); // Expected output: ~26.83\n        System.out.println(solution.triangle_area(5, 5, 5)); // Expected output: 10.83\n    }\n}\n"}
{"task_id": "Java/72", "generation": "import java.util.*;\n\nclass Solution {\n\n    /**\n     * Write a function that returns True if the object q will fly, and False otherwise.\n     * The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal to the maximum possible weight w.\n     *\n     * @param q A List<Integer> representing the object\n     * @param w An integer representing the maximum possible weight\n     * @return boolean indicating if the object will fly\n     */\n    public boolean will_it_fly(List<Integer> q, int w) {\n        // Check if the list is a palindrome\n        for (int i = 0; i < q.size() / 2; i++) {\n            if (!q.get(i).equals(q.get(q.size() - 1 - i))) {\n                return false;\n            }\n        }\n\n        // Calculate the sum of elements in the list\n        int sum = q.stream().mapToInt(Integer::intValue).sum();\n\n        // Check if the sum is less than or equal to w\n        return sum <= w;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.will_it_fly(Arrays.asList(1, 2), 5));   // false\n        System.out.println(solution.will_it_fly(Arrays.asList(3, 2, 3), 1)); // false\n        System.out.println(solution.will_it_fly(Arrays.asList(3, 2, 3), 9)); // true\n        System.out.println(solution.will_it_fly(Arrays.asList(3), 5));      // true\n    }\n}\n"}
{"task_id": "Java/73", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given an array arr of integers, find the minimum number of elements that\n     * need to be changed to make the array palindromic. A palindromic array is an array that\n     * is read the same backwards and forwards. In one change, you can change one element to any other element.\n     *\n     * For example:\n     * smallest_change(Arrays.asList(1,2,3,5,4,7,9,6)) == 4\n     * smallest_change(Arrays.asList(1, 2, 3, 4, 3, 2, 2)) == 1\n     * smallest_change(Arrays.asList(1, 2, 3, 2, 1)) == 0\n     */\n    public int smallest_change(List<Integer> arr) {\n        int left = 0;\n        int right = arr.size() - 1;\n        int changes = 0;\n\n        while (left < right) {\n            if (!arr.get(left).equals(arr.get(right))) {\n                changes++;\n            }\n            left++;\n            right--;\n        }\n\n        return changes;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.smallest_change(Arrays.asList(1, 2, 3, 5, 4, 7, 9, 6))); // Output: 4\n        System.out.println(solution.smallest_change(Arrays.asList(1, 2, 3, 4, 3, 2, 2)));    // Output: 1\n        System.out.println(solution.smallest_change(Arrays.asList(1, 2, 3, 2, 1)));          // Output: 0\n        System.out.println(solution.smallest_change(Arrays.asList(1, 2, 3, 4, 5, 6, 7)));    // Output: 3\n        System.out.println(solution.smallest_change(Arrays.asList(8, 9, 8, 9, 8, 9, 8)));   // Output: 0\n    }\n}\n"}
{"task_id": "Java/74", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Write a function that accepts two lists of strings and returns the list that has\n     * total number of chars in the all strings of the list less than the other list.\n     *\n     * if the two lists have the same number of chars, return the first list.\n     */\n    public List<String> total_match(List<String> lst1, List<String> lst2) {\n        int count1 = 0;\n        for (String s : lst1) {\n            count1 += s.length();\n        }\n        \n        int count2 = 0;\n        for (String s : lst2) {\n            count2 += s.length();\n        }\n\n        if (count1 <= count2) {\n            return lst1;\n        } else {\n            return lst2;\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.total_match(new ArrayList<>(), new ArrayList<>())); // []\n        System.out.println(solution.total_match(Arrays.asList(\"hi\", \"admin\"), Arrays.asList(\"hI\", \"Hi\"))); // [\"hI\", \"Hi\"]\n        System.out.println(solution.total_match(Arrays.asList(\"hi\", \"admin\"), Arrays.asList(\"hi\", \"hi\", \"admin\", \"project\"))); // [\"hi\", \"admin\"]\n        System.out.println(solution.total_match(Arrays.asList(\"hi\", \"admin\"), Arrays.asList(\"hI\", \"hi\", \"hi\"))); // [\"hI\", \"hi\", \"hi\"]\n        System.out.println(solution.total_match(Arrays.asList(\"4\"), Arrays.asList(\"1\", \"2\", \"3\", \"4\", \"5\"))); // [\"4\"]\n    }\n}\n"}
{"task_id": "Java/75", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Write a function that returns true if the given number is the multiplication of 3 prime numbers\n     * and false otherwise.\n     * Knowing that the prime number is less than 100.\n     * Example:\n     * is_multiply_prime(30) == true\n     * 30 = 2 * 3 * 5\n     */\n    public boolean is_multiply_prime(int a) {\n        if (a < 2) return false;\n\n        int count = 0;\n        for (int i = 2; i <= Math.sqrt(a); i++) {\n            while (a % i == 0 && isPrime(i)) {\n                count++;\n                a /= i;\n            }\n        }\n\n        // Check if the remaining number is also prime and part of the product\n        if (a > 1 && isPrime(a)) {\n            count++;\n        }\n\n        return count == 3;\n    }\n\n    private boolean isPrime(int n) {\n        if (n <= 1) return false;\n        for (int i = 2; i * i <= n; i++) {\n            if (n % i == 0) return false;\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.is_multiply_prime(30)); // true, because 30 = 2 * 3 * 5\n        System.out.println(solution.is_multiply_prime(60)); // false, because 60 = 2 * 2 * 3 * 5 (more than 3 primes)\n        System.out.println(solution.is_multiply_prime(100)); // false, because 100 is not a product of exactly 3 primes\n        System.out.println(solution.is_multiply_prime(30030)); // true, because 30030 = 2 * 3 * 5 * 7 * 11 * 13 (more than 3 primes)\n        System.out.println(solution.is_multiply_prime(2 * 3 * 7)); // true, because 42 = 2 * 3 * 7\n    }\n}\n"}
{"task_id": "Java/76", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Your task is to write a function that returns true if a number x is a simple\n     * power of n and false in other cases.\n     * x is a simple power of n if n**int=x\n     * For example:\n     * is_simple_power(1, 4) => true\n     * is_simple_power(2, 2) => true\n     * is_simple_power(8, 2) => true\n     * is_simple_power(3, 2) => false\n     * is_simple_power(3, 1) => false\n     * is_simple_power(5, 3) => false\n     */\n    public boolean is_simple_power(int x, int n) {\n        if (n == 1) {\n            return x == 1;\n        }\n        \n        double power = Math.pow(n, Math.round(Math.log(x) / Math.log(n)));\n        return Math.abs(power - x) < 0.0001; // Allowing a small floating point tolerance\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.is_simple_power(1, 4));   // true\n        System.out.println(solution.is_simple_power(2, 2));   // true\n        System.out.println(solution.is_simple_power(8, 2));   // true\n        System.out.println(solution.is_simple_power(3, 2));   // false\n        System.out.println(solution.is_simple_power(3, 1));   // false\n        System.out.println(solution.is_simple_power(5, 3));   // false\n        System.out.println(solution.is_simple_power(16, 2));  // true\n        System.out.println(solution.is_simple_power(81, 3));  // true\n        System.out.println(solution.is_simple_power(27, 3));  // true\n        System.out.println(solution.is_simple_power(49, 7));  // true\n    }\n}\n"}
{"task_id": "Java/77", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Write a function that takes an integer a and returns true\n     * if this integer is a cube of some integer number.\n     * Note: you may assume the input is always valid.\n     * Examples:\n     * iscube(1) ==> true\n     * iscube(2) ==> false\n     * iscube(-1) ==> true\n     * iscube(64) ==> true\n     * iscube(0) ==> true\n     * iscube(180) ==> false\n     */\n    public boolean iscube(int a) {\n        if (a == 0) return true;\n        \n        // Handle negative numbers by checking the cube root and squaring it back\n        double cubeRoot = Math.cbrt(a);\n        int roundedCubeRoot = (int) Math.round(cubeRoot);\n        \n        return Math.pow(roundedCubeRoot, 3) == a;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.iscube(1));   // true\n        System.out.println(solution.iscube(2));   // false\n        System.out.println(solution.iscube(-1));  // true\n        System.out.println(solution.iscube(64));  // true\n        System.out.println(solution.iscube(0));   // true\n        System.out.println(solution.iscube(180)); // false\n    }\n}\n"}
{"task_id": "Java/78", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * You have been tasked to write a function that receives\n     * a hexadecimal number as a string and counts the number of hexadecimal\n     * digits that are primes (prime number, or a prime, is a natural number\n     * greater than 1 that is not a product of two smaller natural numbers).\n     * Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n     * Prime numbers are 2, 3, 5, 7, B (=decimal 11), D (=decimal 13).\n     * So you have to determine a number of the following digits: 2, 3, 5, 7,\n     * B (=decimal 11), D (=decimal 13).\n     * Note: you may assume the input is always correct or empty string,\n     * and symbols A,B,C,D,E,F are always uppercase.\n     * Examples:\n     * For num = \"AB\" the output should be 1.\n     * For num = \"1077E\" the output should be 2.\n     * For num = \"ABED1A33\" the output should be 4.\n     * For num = \"123456789ABCDEF0\" the output should be 6.\n     * For num = \"2020\" the output should be 2.\n     */\n    public int hex_key(String num) {\n        // Define a set of prime hexadecimal digits\n        Set<Character> primes = new HashSet<>(Arrays.asList('2', '3', '5', '7', 'B', 'D'));\n        \n        // Count the number of prime hexadecimal digits in the input string\n        int count = 0;\n        for (char c : num.toCharArray()) {\n            if (primes.contains(c)) {\n                count++;\n            }\n        }\n        \n        return count;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.hex_key(\"AB\")); // Expected output: 1\n        System.out.println(solution.hex_key(\"1077E\")); // Expected output: 2\n        System.out.println(solution.hex_key(\"ABED1A33\")); // Expected output: 4\n        System.out.println(solution.hex_key(\"123456789ABCDEF0\")); // Expected output: 6\n        System.out.println(solution.hex_key(\"2020\")); // Expected output: 2\n    }\n}\n"}
{"task_id": "Java/79", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * You will be given a number in decimal form and your task is to convert it to\n     * binary format. The function should return a string, with each character representing a binary\n     * number. Each character in the string will be '0' or '1'.\n     *\n     * There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n     * The extra characters are there to help with the format.\n     *\n     * Examples:\n     * decimal_to_binary(15)   // returns \"db1111db\"\n     * decimal_to_binary(32)   // returns \"db100000db\"\n     */\n    public String decimal_to_binary(int decimal) {\n        if (decimal == 0) return \"db0db\";\n        \n        StringBuilder binary = new StringBuilder();\n        while (decimal > 0) {\n            binary.insert(0, decimal % 2);\n            decimal /= 2;\n        }\n        \n        return \"db\" + binary.toString() + \"db\";\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.decimal_to_binary(15));   // Expected: db1111db\n        System.out.println(solution.decimal_to_binary(32));   // Expected: db100000db\n        System.out.println(solution.decimal_to_binary(0));    // Expected: db0db\n        System.out.println(solution.decimal_to_binary(456));  // Expected: db111001000db\n        System.out.println(solution.decimal_to_binary(255));  // Expected: db11111111db\n    }\n}\n"}
{"task_id": "Java/80", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * You are given a string s.\n     * Your task is to check if the string is happy or not.\n     * A string is happy if its length is at least 3 and every 3 consecutive letters are distinct\n     * For example:\n     * is_happy(a) => false\n     * is_happy(aa) => false\n     * is_happy(abcd) => true\n     * is_happy(aabb) => false\n     * is_happy(adb) => true\n     * is_happy(xyy) => false\n     */\n    public boolean is_happy(String s) {\n        if (s.length() < 3) return false;\n        \n        for (int i = 0; i <= s.length() - 3; i++) {\n            char first = s.charAt(i);\n            char second = s.charAt(i + 1);\n            char third = s.charAt(i + 2);\n            \n            if (first == second || second == third || first == third) {\n                return false;\n            }\n        }\n        \n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.is_happy(\"a\"));       // Output: false\n        System.out.println(solution.is_happy(\"aa\"));      // Output: false\n        System.out.println(solution.is_happy(\"abcd\"));    // Output: true\n        System.out.println(solution.is_happy(\"aabb\"));    // Output: false\n        System.out.println(solution.is_happy(\"adb\"));     // Output: true\n        System.out.println(solution.is_happy(\"xyy\"));     // Output: false\n        System.out.println(solution.is_happy(\"abcabc\"));  // Output: true\n        System.out.println(solution.is_happy(\"abacaba\")); // Output: false\n    }\n}\n"}
{"task_id": "Java/81", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * It is the last week of the semester and the teacher has to give the grades\n     * to students. The teacher has been making her own algorithm for grading.\n     * The only problem is, she has lost the code she used for grading.\n     * She has given you a list of GPAs for some students and you have to write\n     * a function that can output a list of letter grades using the following table:\n     *             GPA       |    Letter grade\n     *              4.0                A+\n     *            > 3.7                A\n     *            > 3.3                A-\n     *            > 3.0                B+\n     *            > 2.7                B\n     *            > 2.3                B-\n     *            > 2.0                C+\n     *            > 1.7                C\n     *            > 1.3                C-\n     *            > 1.0                D+\n     *            > 0.7                D\n     *            > 0.0                D-\n     *              0.0                E\n\n     * Example:\n     * numerical_letter_grade(Arrays.asList(4.0, 3, 1.7, 2, 3.5)) ==> [\"A+\", \"B\", \"C-\", \"C\", \"A-\"]\n     */\n    public List<String> numerical_letter_grade(List<Double> grades) {\n        List<String> letterGrades = new ArrayList<>();\n        \n        for (Double gpa : grades) {\n            if (gpa == 4.0) {\n                letterGrades.add(\"A+\");\n            } else if (gpa > 3.7) {\n                letterGrades.add(\"A\");\n            } else if (gpa > 3.3) {\n                letterGrades.add(\"A-\");\n            } else if (gpa > 3.0) {\n                letterGrades.add(\"B+\");\n            } else if (gpa > 2.7) {\n                letterGrades.add(\"B\");\n            } else if (gpa > 2.3) {\n                letterGrades.add(\"B-\");\n            } else if (gpa > 2.0) {\n                letterGrades.add(\"C+\");\n            } else if (gpa > 1.7) {\n                letterGrades.add(\"C\");\n            } else if (gpa > 1.3) {\n                letterGrades.add(\"C-\");\n            } else if (gpa > 1.0) {\n                letterGrades.add(\"D+\");\n            } else if (gpa > 0.7) {\n                letterGrades.add(\"D\");\n            } else if (gpa > 0.0) {\n                letterGrades.add(\"D-\");\n            } else {\n                letterGrades.add(\"E\");\n            }\n        }\n\n        return letterGrades;\n    }\n}\n"}
{"task_id": "Java/82", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Write a function that takes a string and returns true if the string\n     * length is a prime number or false otherwise\n     * Examples:\n     * prime_length(\"Hello\") == true\n     * prime_length(\"abcdcba\") == true\n     * prime_length(\"kittens\") == true\n     * prime_length(\"orange\") == false\n     */\n    public boolean prime_length(String string) {\n        int length = string.length();\n        return isPrime(length);\n    }\n\n    private boolean isPrime(int number) {\n        if (number <= 1) {\n            return false;\n        }\n        for (int i = 2; i * i <= number; i++) {\n            if (number % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.prime_length(\"Hello\"));   // true\n        System.out.println(solution.prime_length(\"abcdcba\")); // true\n        System.out.println(solution.prime_length(\"kittens\")); // true\n        System.out.println(solution.prime_length(\"orange\"));  // false\n    }\n}\n"}
{"task_id": "Java/83", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a positive integer n, return the count of the numbers of n-digit\n     * positive integers that start or end with 1.\n     */\n    public int starts_one_ends(int n) {\n        if (n == 1) {\n            return 1; // Only one 1-digit number that starts and ends with 1\n        }\n        \n        // For n > 1, we need to count numbers starting or ending with 1.\n        // There are 2 * (10^(n-1)) - 10^(n-2) such numbers.\n        return 2 * (int)Math.pow(10, n - 1) - (int)Math.pow(10, n - 2);\n    }\n    \n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.starts_one_ends(1)); // Expected output: 1\n        System.out.println(solution.starts_one_ends(2)); // Expected output: 19\n        System.out.println(solution.starts_one_ends(3)); // Expected output: 180\n    }\n}\n"}
{"task_id": "Java/84", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     Given a positive integer N, return in binary the total sum of its digits.\n\n     Example\n         For N = 1000, the sum of digits will be 1 the output should be \"1\".\n         For N = 150, the sum of digits will be 6 the output should be \"110\".\n         For N = 147, the sum of digits will be 12 the output should be \"1100\".\n\n     Variables:\n         @N integer\n              Constraints: 0 <= N <= 10000.\n     Output:\n          a string of binary number\n      */\n    public String solve(int N) {\n        int sum = 0;\n        \n        // Calculate the sum of digits\n        while (N > 0) {\n            sum += N % 10;\n            N /= 10;\n        }\n        \n        // Convert the sum to binary and return as a string\n        return Integer.toBinaryString(sum);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.solve(1000)); // Expected output: \"1\"\n        System.out.println(solution.solve(150));  // Expected output: \"110\"\n        System.out.println(solution.solve(147));  // Expected output: \"1100\"\n        System.out.println(solution.solve(9999)); // Expected output: \"11110001111\"\n    }\n}\n"}
{"task_id": "Java/85", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a non-empty list of integers lst. add the even elements that are at odd indices.\n     *\n     * Examples:\n     * - add(Arrays.asList(4, 2, 6, 7)) should return 2 (since only 2 is an even number at an odd index)\n     */\n    public int add(List<Integer> lst) {\n        if (lst == null || lst.isEmpty()) {\n            throw new IllegalArgumentException(\"List cannot be null or empty\");\n        }\n\n        int sum = 0;\n        for (int i = 1; i < lst.size(); i += 2) { // Start from index 1 and increment by 2\n            Integer value = lst.get(i);\n            if (value % 2 == 0) {\n                sum += value;\n            }\n        }\n\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.add(Arrays.asList(4, 2, 6, 7))); // Should print 2\n        System.out.println(solution.add(Arrays.asList(1, 3, 5, 7, 9))); // Should print 0 (no even numbers at odd indices)\n        System.out.println(solution.add(Arrays.asList(8, 4, 2, 6, 10, 12))); // Should print 16 (4 + 12)\n    }\n}\n"}
{"task_id": "Java/86", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Write a function that takes a string and returns an ordered version of it.\n     * Ordered version of string, is a string where all words (separated by space)\n     * are replaced by a new word where all the characters arranged in\n     * ascending order based on ascii value.\n     * Note: You should keep the order of words and blank spaces in the sentence.\n     *\n     * For example:\n     * anti_shuffle(\"Hi\") returns \"Hi\"\n     * anti_shuffle(\"hello\") returns \"ehllo\"\n     * anti_shuffle(\"Hello World!!!\") returns \"Hello !!!Wdlor\"\n     */\n    public String anti_shuffle(String s) {\n        if (s == null || s.isEmpty()) {\n            return s;\n        }\n\n        StringBuilder result = new StringBuilder();\n        int wordStartIndex = 0;\n\n        for (int i = 0; i < s.length(); i++) {\n            char c = s.charAt(i);\n            if (c == ' ') {\n                // Process the current word\n                String word = s.substring(wordStartIndex, i);\n                result.append(orderedWord(word));\n                result.append(c); // Append the space character\n                wordStartIndex = i + 1;\n            }\n        }\n\n        // Process the last word in the string\n        if (wordStartIndex < s.length()) {\n            String lastWord = s.substring(wordStartIndex);\n            result.append(orderedWord(lastWord));\n        }\n\n        return result.toString();\n    }\n\n    private String orderedWord(String word) {\n        char[] chars = word.toCharArray();\n        Arrays.sort(chars);\n        return new String(chars);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.anti_shuffle(\"Hi\")); // Expected: \"Hi\"\n        System.out.println(solution.anti_shuffle(\"hello\")); // Expected: \"ehllo\"\n        System.out.println(solution.anti_shuffle(\"Hello World!!!\")); // Expected: \"Hello !!!Wdlor\"\n        System.out.println(solution.anti_shuffle(\"Programming is fun!\")); // Expected: \"Pamgimnig is fnu!\"\n    }\n}\n"}
{"task_id": "Java/87", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<List<Integer>> get_row(List<List<Integer>> lst, int x) {\n        List<List<Integer>> coordinates = new ArrayList<>();\n        \n        for (int i = 0; i < lst.size(); i++) {\n            List<Integer> row = lst.get(i);\n            for (int j = 0; j < row.size(); j++) {\n                if (row.get(j).equals(x)) {\n                    int colIndex = row.size() - 1 - j;\n                    coordinates.add(Arrays.asList(i, colIndex));\n                }\n            }\n        }\n        \n        // Sort by rows in ascending order\n        Collections.sort(coordinates, (a, b) -> a.get(0) - b.get(0));\n        \n        // Sort by columns in descending order within the same row\n        for (int i = 0; i < coordinates.size(); i++) {\n            for (int j = i + 1; j < coordinates.size(); j++) {\n                if (coordinates.get(i).get(0) == coordinates.get(j).get(0)) {\n                    if (coordinates.get(i).get(1) < coordinates.get(j).get(1)) {\n                        Collections.swap(coordinates, i, j);\n                    }\n                }\n            }\n        }\n        \n        return coordinates;\n    }\n}\n"}
{"task_id": "Java/88", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n\n    /**\n     * Given an array of non-negative integers, return a copy of the given array after sorting,\n     * you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n     * or sort it in descending order if the sum( first index value, last index value) is even.\n     *\n     * Note:\n     * * don't change the given array.\n     */\n    public List<Integer> sort_array(List<Integer> array) {\n        if (array == null || array.isEmpty()) {\n            return new ArrayList<>();\n        }\n\n        int sum = array.get(0) + array.get(array.size() - 1);\n        List<Integer> sortedArray = new ArrayList<>(array);\n\n        if (sum % 2 == 0) {\n            // Sort in descending order\n            sortedArray.sort(Collections.reverseOrder());\n        } else {\n            // Sort in ascending order\n            Collections.sort(sortedArray);\n        }\n\n        return sortedArray;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.sort_array(Arrays.asList())); // []\n        System.out.println(solution.sort_array(Arrays.asList(5))); // [5]\n        System.out.println(solution.sort_array(Arrays.asList(2, 4, 3, 0, 1, 5))); // [0, 1, 2, 3, 4, 5]\n        System.out.println(solution.sort_array(Arrays.asList(2, 4, 3, 0, 1, 5, 6))); // [6, 5, 4, 3, 2, 1, 0]\n    }\n}\n"}
{"task_id": "Java/89", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Create a function encrypt that takes a string as an argument and\n     * returns a string encrypted with the alphabet being rotated.\n     * The alphabet should be rotated in a manner such that the letters\n     * shift down by two multiplied to two places.\n     * For example:\n     * encrypt(\"hi\") returns \"lm\"\n     * encrypt(\"asdfghjkl\") returns \"ewhjklnop\"\n     * encrypt(\"gf\") returns \"kj\"\n     * encrypt(\"et\") returns \"ix\"\n     */\n    public String encrypt(String s) {\n        StringBuilder encrypted = new StringBuilder();\n        for (char c : s.toCharArray()) {\n            if (Character.isLetter(c)) {\n                char base = Character.isUpperCase(c) ? 'A' : 'a';\n                int offset = ((c - base + 4) % 26);\n                encrypted.append((char) (base + offset));\n            } else {\n                encrypted.append(c);\n            }\n        }\n        return encrypted.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.encrypt(\"hi\"));       // Should print \"lm\"\n        System.out.println(solution.encrypt(\"asdfghjkl\")); // Should print \"ewhjklnop\"\n        System.out.println(solution.encrypt(\"gf\"));       // Should print \"kj\"\n        System.out.println(solution.encrypt(\"et\"));       // Should print \"ix\"\n\n        // Additional test cases\n        System.out.println(solution.encrypt(\"Hello, World!\")); // Should print \"Lipps, Asvph!\"\n        System.out.println(solution.encrypt(\"Zebra123\"));     // Should print \"Difve123\"\n    }\n}\n"}
{"task_id": "Java/90", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * You are given a list of integers.\n     * Write a function next_smallest() that returns the 2nd smallest element of the list.\n     * Return null if there is no such element.\n     *\n     * @param lst The input list of integers\n     * @return Optional containing the 2nd smallest integer, or Optional.empty() if not available\n     */\n    public Optional<Integer> next_smallest(List<Integer> lst) {\n        // Remove duplicates and sort the list\n        Set<Integer> uniqueElements = new TreeSet<>(lst);\n        \n        // If there are less than 2 elements after removing duplicates, return Optional.empty()\n        if (uniqueElements.size() < 2) {\n            return Optional.empty();\n        }\n        \n        // Return the second element in the sorted set\n        Integer[] array = uniqueElements.toArray(new Integer[0]);\n        return Optional.of(array[1]);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.next_smallest(Arrays.asList(1, 2, 3, 4, 5))); // Expected: Optional[2]\n        System.out.println(solution.next_smallest(Arrays.asList(5, 1, 4, 3, 2))); // Expected: Optional[2]\n        System.out.println(solution.next_smallest(Arrays.asList()));             // Expected: Optional.empty\n        System.out.println(solution.next_smallest(Arrays.asList(1, 1)));         // Expected: Optional.empty\n        System.out.println(solution.next_smallest(Arrays.asList(5, 4, 3, 2, 1))); // Expected: Optional[2]\n    }\n}\n"}
{"task_id": "Java/91", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int is_bored(String S) {\n        String[] sentences = S.split(\"[.?!]\");\n        int count = 0;\n        for (String sentence : sentences) {\n            if (!sentence.trim().isEmpty() && sentence.trim().startsWith(\"I\")) {\n                count++;\n            }\n        }\n        return count;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.is_bored(\"Hello world\")); // Output: 0\n        System.out.println(solution.is_bored(\"The sky is blue. The sun is shining. I love this weather\")); // Output: 1\n    }\n}\n"}
{"task_id": "Java/92", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Create a function that takes 3 numbers.\n     * Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n     * Returns false in any other cases.\n     *\n     * Examples\n     * any_int(5, 2, 7) -> true\n     * any_int(3, 2, 2) -> false\n     * any_int(3, -2, 1) -> true\n     * any_int(3.6, -2.2, 2) -> false\n     */\n    public boolean any_int(Object x, Object y, Object z) {\n        if (x instanceof Integer && y instanceof Integer && z instanceof Integer) {\n            int a = (Integer) x;\n            int b = (Integer) y;\n            int c = (Integer) z;\n\n            return a == b + c || b == a + c || c == a + b;\n        }\n        return false;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.any_int(5, 2, 7));   // true\n        System.out.println(solution.any_int(3, 2, 2));   // false\n        System.out.println(solution.any_int(3, -2, 1));  // true\n        System.out.println(solution.any_int(3.6, -2.2, 2)); // false (should return false)\n    }\n}\n"}
{"task_id": "Java/93", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Write a function that takes a message, and encodes in such a way that it swaps case of all letters,\n     * replaces all vowels in the message with the letter that appears 2 places ahead of that vowel in the\n     * English alphabet.\n     *\n     * Examples:\n     * >>> encode(\"test\")\n     * \"TGST\"\n     * >>> encode(\"This is a message\")\n     * \"tHKS KS C MGSSCGG\"\n     */\n    public String encode(String message) {\n        StringBuilder encodedMessage = new StringBuilder();\n        \n        for (char c : message.toCharArray()) {\n            if (Character.isLetter(c)) {\n                // Swap case\n                char swappedCaseChar = Character.isLowerCase(c) ? Character.toUpperCase(c) : Character.toLowerCase(c);\n                \n                // Replace vowels with the letter 2 places ahead in the alphabet\n                switch (swappedCaseChar) {\n                    case 'A':\n                        encodedMessage.append('C');\n                        break;\n                    case 'E':\n                        encodedMessage.append('G');\n                        break;\n                    case 'I':\n                        encodedMessage.append('K');\n                        break;\n                    case 'O':\n                        encodedMessage.append('Q');\n                        break;\n                    case 'U':\n                        encodedMessage.append('W');\n                        break;\n                    case 'a':\n                        encodedMessage.append('c');\n                        break;\n                    case 'e':\n                        encodedMessage.append('g');\n                        break;\n                    case 'i':\n                        encodedMessage.append('k');\n                        break;\n                    case 'o':\n                        encodedMessage.append('q');\n                        break;\n                    case 'u':\n                        encodedMessage.append('w');\n                        break;\n                    default:\n                        // If it's not a vowel, just append the swapped case character\n                        encodedMessage.append(swappedCaseChar);\n                }\n            } else {\n                // Non-letter characters are appended as is\n                encodedMessage.append(c);\n            }\n        }\n        \n        return encodedMessage.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.encode(\"test\"));  // Expected: \"TGST\"\n        System.out.println(solution.encode(\"This is a message\"));  // Expected: \"tHKS KS C MGSSCGG\"\n        System.out.println(solution.encode(\"Hello World!\"));  // Expected: \"hKLLQ wOrld!\"\n    }\n}\n"}
{"task_id": "Java/94", "generation": "import java.util.List;\n\nclass Solution {\n    /**\n     * You are given a list of integers.\n     * You need to find the largest prime value and return the sum of its digits.\n     */\n    public int skjkasdkd(List<Integer> lst) {\n        if (lst == null || lst.isEmpty()) {\n            return 0;\n        }\n\n        int maxPrime = -1;\n\n        for (int num : lst) {\n            if (isPrime(num)) {\n                maxPrime = Math.max(maxPrime, num);\n            }\n        }\n\n        if (maxPrime == -1) {\n            return 0;\n        }\n\n        return sumOfDigits(maxPrime);\n    }\n\n    private boolean isPrime(int num) {\n        if (num <= 1) {\n            return false;\n        }\n        for (int i = 2; i <= Math.sqrt(num); i++) {\n            if (num % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private int sumOfDigits(int num) {\n        int sum = 0;\n        while (num > 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        List<Integer> lst1 = Arrays.asList(0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3);\n        System.out.println(solution.skjkasdkd(lst1)); // Output: 10\n\n        List<Integer> lst2 = Arrays.asList(1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1);\n        System.out.println(solution.skjkasdkd(lst2)); // Output: 25\n\n        List<Integer> lst3 = Arrays.asList(1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3);\n        System.out.println(solution.skjkasdkd(lst3)); // Output: 13\n\n        List<Integer> lst4 = Arrays.asList(0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6);\n        System.out.println(solution.skjkasdkd(lst4)); // Output: 11\n\n        List<Integer> lst5 = Arrays.asList(0, 81, 12, 3, 1, 21);\n        System.out.println(solution.skjkasdkd(lst5)); // Output: 3\n\n        List<Integer> lst6 = Arrays.asList(0, 8, 1, 2, 1, 7);\n        System.out.println(solution.skjkasdkd(lst6)); // Output: 7\n    }\n}\n"}
{"task_id": "Java/95", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given a map, return True if all keys are strings and all keys are in lower case or in upper case, else return False.\n     * The function should return False is the given map is empty.\n     */\n    public boolean check_dict_case(Map<Object, Object> dict) {\n        if (dict.isEmpty()) {\n            return false;\n        }\n\n        boolean allLowerCase = true;\n        boolean allUpperCase = true;\n\n        for (Object key : dict.keySet()) {\n            if (!(key instanceof String)) {\n                return false;\n            }\n            String strKey = (String) key;\n            if (!strKey.equals(strKey.toLowerCase())) {\n                allLowerCase = false;\n            }\n            if (!strKey.equals(strKey.toUpperCase())) {\n                allUpperCase = false;\n            }\n        }\n\n        return allLowerCase || allUpperCase;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.check_dict_case(Map.of(\"a\", \"apple\", \"b\", \"banana\"))); // True\n        System.out.println(solution.check_dict_case(Map.of(\"a\", \"apple\", \"A\", \"banana\", \"B\", \"banana\"))); // False\n        System.out.println(solution.check_dict_case(Map.of(\"a\", \"apple\", 8, \"banana\", \"a\", \"apple\"))); // False\n        System.out.println(solution.check_dict_case(Map.of(\"Name\", \"John\", \"Age\", \"36\", \"City\", \"Houston\"))); // False\n        System.out.println(solution.check_dict_case(Map.of(\"STATE\", \"NC\", \"ZIP\", \"12345\"))); // True\n    }\n}\n"}
{"task_id": "Java/96", "generation": "import java.util.ArrayList;\nimport java.util.List;\n\nclass Solution {\n\n    /**\n     * Implement a function that takes an non-negative integer and returns an array of the first n\n     * integers that are prime numbers and less than n.\n     *\n     * @param n The upper limit (non-inclusive) to find prime numbers up to.\n     * @return A List containing prime numbers less than n.\n     */\n    public List<Integer> count_up_to(int n) {\n        List<Integer> primes = new ArrayList<>();\n        \n        for (int i = 2; i < n && primes.size() < n; i++) {\n            if (isPrime(i)) {\n                primes.add(i);\n            }\n        }\n        \n        return primes;\n    }\n\n    /**\n     * Helper method to check if a number is prime.\n     *\n     * @param num The number to check.\n     * @return true if the number is prime, false otherwise.\n     */\n    private boolean isPrime(int num) {\n        if (num <= 1) {\n            return false;\n        }\n        for (int i = 2; i <= Math.sqrt(num); i++) {\n            if (num % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.count_up_to(5));   // Output: [2, 3]\n        System.out.println(solution.count_up_to(11));  // Output: [2, 3, 5, 7]\n        System.out.println(solution.count_up_to(0));   // Output: []\n        System.out.println(solution.count_up_to(20));  // Output: [2, 3, 5, 7, 11, 13, 17, 19]\n        System.out.println(solution.count_up_to(1));   // Output: []\n        System.out.println(solution.count_up_to(18));  // Output: [2, 3, 5, 7, 11, 13, 17]\n    }\n}\n"}
{"task_id": "Java/97", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Complete the function that takes two integers and returns\n     * the product of their unit digits.\n     * Assume the input is always valid.\n     * Examples:\n     * multiply(148, 412) should return 16.\n     * multiply(19, 28) should return 72.\n     * multiply(2020, 1851) should return 0.\n     * multiply(14,-15) should return 20.\n     */\n    public int multiply(int a, int b) {\n        // Extract the unit digits of both numbers\n        int unitDigitA = Math.abs(a % 10);\n        int unitDigitB = Math.abs(b % 10);\n\n        // Return the product of the unit digits\n        return unitDigitA * unitDigitB;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.multiply(148, 412)); // Expected output: 16\n        System.out.println(solution.multiply(19, 28));   // Expected output: 72\n        System.out.println(solution.multiply(2020, 1851)); // Expected output: 0\n        System.out.println(solution.multiply(14, -15));  // Expected output: 20\n    }\n}\n"}
{"task_id": "Java/98", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a string s, count the number of uppercase vowels in even indices.\n     *\n     * For example:\n     * count_upper(\"aBCdEf\") returns 1\n     * count_upper(\"abcdefg\") returns 0\n     * count_upper(\"dBBE\") returns 0\n     */\n    public int count_upper(String s) {\n        int count = 0;\n        for (int i = 0; i < s.length(); i += 2) { // Iterate over even indices\n            char c = s.charAt(i);\n            if (isUppercaseVowel(c)) {\n                count++;\n            }\n        }\n        return count;\n    }\n\n    private boolean isUppercaseVowel(char c) {\n        return c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U';\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.count_upper(\"aBCdEf\")); // Expected output: 1\n        System.out.println(solution.count_upper(\"abcdefg\")); // Expected output: 0\n        System.out.println(solution.count_upper(\"dBBE\")); // Expected output: 0\n        System.out.println(solution.count_upper(\"AeIoUc\")); // Expected output: 3\n        System.out.println(solution.count_upper(\"zYxWvUt\")); // Expected output: 2\n    }\n}\n"}
{"task_id": "Java/99", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Create a function that takes a value (string) representing a number\n     * and returns the closest integer to it. If the number is equidistant\n     * from two integers, round it away from zero.\n     *\n     * Examples:\n     * >>> closest_integer(\"10\")\n     * 10\n     * >>> closest_integer(\"15.3\")\n     * 15\n     * >>> closest_integer(\"14.5\")\n     * 15\n     * >>> closest_integer(\"-14.5\")\n     * -15\n     */\n    public int closest_integer(String value) {\n        double num = Double.parseDouble(value);\n        double floorValue = Math.floor(num);\n        double ceilValue = Math.ceil(num);\n\n        if (num - floorValue == 0.5 || ceilValue - num == 0.5) {\n            return (int)(num > 0 ? ceilValue : floorValue);\n        } else {\n            return (int)Math.round(num);\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.closest_integer(\"10\"));   // Output: 10\n        System.out.println(solution.closest_integer(\"15.3\")); // Output: 15\n        System.out.println(solution.closest_integer(\"14.5\")); // Output: 15\n        System.out.println(solution.closest_integer(\"-14.5\"));// Output: -15\n        System.out.println(solution.closest_integer(\"0.5\"));  // Output: 1\n        System.out.println(solution.closest_integer(\"-0.5\")); // Output: -1\n    }\n}\n"}
{"task_id": "Java/100", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given a positive integer n, you have to make a pile of n levels of stones.\n     * The first level has n stones.\n     * The number of stones in the next level is:\n     * - the next odd number if n is odd.\n     * - the next even number if n is even.\n     * Return the number of stones in each level in a list, where element at index\n     * i represents the number of stones in the level (i+1).\n     *\n     * Examples:\n     * >>> make_a_pile(3)\n     * [3, 5, 7]\n     */\n    public List<Integer> make_a_pile(int n) {\n        List<Integer> result = new ArrayList<>();\n        int currentStones = n;\n        \n        for (int i = 0; i < n; i++) {\n            result.add(currentStones);\n            // Determine the next number of stones\n            if (currentStones % 2 == 0) {\n                currentStones += 2; // Next even number\n            } else {\n                currentStones += 2; // Next odd number\n            }\n        }\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.make_a_pile(3)); // Expected: [3, 5, 7]\n        System.out.println(solution.make_a_pile(4)); // Expected: [4, 6, 8, 10]\n        System.out.println(solution.make_a_pile(1)); // Expected: [1, 3]\n    }\n}\n"}
{"task_id": "Java/101", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<String> words_string(String s) {\n        // Use regular expression to split the string by commas and spaces\n        String[] words = s.split(\"[,\\s]+\");\n        return Arrays.asList(words);\n    }\n}\n"}
{"task_id": "Java/102", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * This function takes two positive numbers x and y and returns the\n     * biggest even integer number that is in the range [x, y] inclusive. If\n     * there's no such number, then the function should return -1.\n     *\n     * For example:\n     * choose_num(12, 15) = 14\n     * choose_num(13, 12) = -1\n     */\n    public int choose_num(int x, int y) {\n        // If the range is invalid or there's no even number in the range\n        if (x > y || (x % 2 != 0 && y % 2 != 0)) {\n            return -1;\n        }\n\n        // Find the biggest even number in the range [x, y]\n        for (int i = y; i >= x; i--) {\n            if (i % 2 == 0) {\n                return i;\n            }\n        }\n\n        // If no even number is found\n        return -1;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.choose_num(12, 15)); // Expected output: 14\n        System.out.println(solution.choose_num(13, 12)); // Expected output: -1\n        System.out.println(solution.choose_num(10, 20)); // Expected output: 20\n        System.out.println(solution.choose_num(17, 19)); // Expected output: -1\n        System.out.println(solution.choose_num(8, 8));   // Expected output: 8\n    }\n}\n"}
{"task_id": "Java/103", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * You are given two positive integers n and m, and your task is to compute the\n     * average of the integers from n through m (including n and m).\n     * Round the answer to the nearest integer and convert that to binary.\n     * If n is greater than m, return -1.\n     * Example:\n     * rounded_avg(1, 5) => \"11\"\n     * rounded_avg(7, 5) => -1\n     * rounded_avg(10, 20) => \"1111\"\n     * rounded_avg(20, 33) => \"11011\"\n     */\n    public Object rounded_avg(int n, int m) {\n        if (n > m) {\n            return -1;\n        }\n        \n        long sum = 0;\n        for (int i = n; i <= m; i++) {\n            sum += i;\n        }\n        \n        double average = Math.round((double) sum / (m - n + 1));\n        String binary = Long.toBinaryString((long) average);\n        \n        return binary;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.rounded_avg(1, 5));   // Expected output: \"11\"\n        System.out.println(solution.rounded_avg(7, 5));   // Expected output: -1\n        System.out.println(solution.rounded_avg(10, 20)); // Expected output: \"1111\"\n        System.out.println(solution.rounded_avg(20, 33)); // Expected output: \"11011\"\n    }\n}\n"}
{"task_id": "Java/104", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> unique_digits(List<Integer> x) {\n        List<Integer> result = new ArrayList<>();\n        \n        for (int num : x) {\n            if (!hasEvenDigit(num)) {\n                result.add(num);\n            }\n        }\n        \n        Collections.sort(result);\n        return result;\n    }\n\n    private boolean hasEvenDigit(int n) {\n        String numStr = Integer.toString(n);\n        for (char digit : numStr.toCharArray()) {\n            int digitValue = Character.getNumericValue(digit);\n            if (digitValue % 2 == 0) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n"}
{"task_id": "Java/105", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given an array of integers, sort the integers that are between 1 and 9 inclusive,\n     * reverse the resulting array, and then replace each digit by its corresponding name from\n     * \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n     *\n     * @param arr input list of integers\n     * @return a list of strings representing the names of the digits in reverse sorted order\n     */\n    public List<String> by_length(List<Integer> arr) {\n        // Filter out numbers not between 1 and 9 inclusive\n        List<Integer> filtered = arr.stream()\n                                     .filter(num -> num >= 1 && num <= 9)\n                                     .sorted()\n                                     .collect(Collectors.toList());\n        \n        // Reverse the list\n        Collections.reverse(filtered);\n        \n        // Map each digit to its corresponding name\n        return filtered.stream()\n                       .map(digit -> switch (digit) {\n                           case 1 -> \"One\";\n                           case 2 -> \"Two\";\n                           case 3 -> \"Three\";\n                           case 4 -> \"Four\";\n                           case 5 -> \"Five\";\n                           case 6 -> \"Six\";\n                           case 7 -> \"Seven\";\n                           case 8 -> \"Eight\";\n                           case 9 -> \"Nine\";\n                           default -> \"\";\n                       })\n                       .collect(Collectors.toList());\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.by_length(Arrays.asList(2, 1, 1, 4, 5, 8, 2, 3))); // [Eight, Five, Four, Three, Two, Two, One, One]\n        System.out.println(solution.by_length(Arrays.asList())); // []\n        System.out.println(solution.by_length(Arrays.asList(1, -1, 55))); // [One]\n        System.out.println(solution.by_length(Arrays.asList(9, 7, 3, 2, 4, 8, 6, 5, 1))); // [Nine, Eight, Seven, Six, Five, Four, Three, Two, One]\n    }\n}\n"}
{"task_id": "Java/106", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Implement the function f that takes n as a parameter,\n     * and returns a list of size n, such that the value of the element at index i is the factorial of i if i is even\n     * or the sum of numbers from 1 to i otherwise.\n     * i starts from 1.\n     * the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).\n     * Example:\n     * f(5) == [1, 2, 6, 24, 15]\n     */\n    public List<Integer> f(int n) {\n        List<Integer> result = new ArrayList<>();\n        \n        for (int i = 1; i <= n; i++) {\n            if (i % 2 == 0) {\n                // Calculate factorial of even index\n                int factorial = calculateFactorial(i);\n                result.add(factorial);\n            } else {\n                // Calculate sum from 1 to odd index\n                int sum = calculateSum(i);\n                result.add(sum);\n            }\n        }\n        \n        return result;\n    }\n\n    private int calculateFactorial(int n) {\n        if (n == 0 || n == 1) {\n            return 1;\n        }\n        int factorial = 1;\n        for (int i = 2; i <= n; i++) {\n            factorial *= i;\n        }\n        return factorial;\n    }\n\n    private int calculateSum(int n) {\n        int sum = 0;\n        for (int i = 1; i <= n; i++) {\n            sum += i;\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.f(5));  // Expected output: [1, 2, 6, 24, 15]\n        System.out.println(solution.f(3));  // Expected output: [1, 2, 6]\n        System.out.println(solution.f(0));  // Expected output: []\n    }\n}\n"}
{"task_id": "Java/107", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given a positive integer n, return a tuple that has the number of even and odd\n     * integer palindromes that fall within the range(1, n), inclusive.\n     *\n     * @param n The upper limit (inclusive) to check for palindromic numbers.\n     * @return A List containing two integers: the first is the count of even palindromes,\n     *         and the second is the count of odd palindromes.\n     */\n    public List<Integer> even_odd_palindrome(int n) {\n        int evenCount = 0;\n        int oddCount = 0;\n\n        for (int i = 1; i <= n; i++) {\n            if (isPalindrome(i)) {\n                if (i % 2 == 0) {\n                    evenCount++;\n                } else {\n                    oddCount++;\n                }\n            }\n        }\n\n        return Arrays.asList(evenCount, oddCount);\n    }\n\n    /**\n     * Helper method to check if a number is a palindrome.\n     *\n     * @param num The number to check.\n     * @return true if the number is a palindrome, false otherwise.\n     */\n    private boolean isPalindrome(int num) {\n        String str = Integer.toString(num);\n        int left = 0;\n        int right = str.length() - 1;\n\n        while (left < right) {\n            if (str.charAt(left) != str.charAt(right)) {\n                return false;\n            }\n            left++;\n            right--;\n        }\n\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.even_odd_palindrome(3));  // Output: [1, 2]\n        System.out.println(solution.even_odd_palindrome(12)); // Output: [4, 6]\n        System.out.println(solution.even_odd_palindrome(10)); // Output: [2, 5]\n    }\n}\n"}
{"task_id": "Java/108", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int count_nums(List<Integer> arr) {\n        return (int) arr.stream()\n                        .filter(num -> sumOfDigits(num) > 0)\n                        .count();\n    }\n\n    private int sumOfDigits(int num) {\n        if (num == 0) {\n            return 0;\n        }\n        boolean isNegative = num < 0;\n        int absNum = Math.abs(num);\n        int sum = 0;\n        while (absNum > 0) {\n            int digit = absNum % 10;\n            sum += digit;\n            absNum /= 10;\n        }\n        return isNegative ? -sum : sum;\n    }\n}\n"}
{"task_id": "Java/109", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N]. The\n     * numbers in the array will be randomly ordered. Your task is to determine if\n     * it is possible to get an array sorted in non-decreasing order by performing\n     * the following operation on the given array:\n     *      You are allowed to perform right shift operation any number of times.\n     *\n     * One right shift operation means shifting all elements of the array by one\n     * position in the right direction. The last element of the array will be moved to\n     * the starting position in the array i.e. 0th index.\n     *\n     * If it is possible to obtain the sorted array by performing the above operation\n     * then return true else return False.\n     * If the given array is empty then return true.\n     *\n     * Note: The given list is guaranteed to have unique elements.\n     */\n    public boolean move_one_ball(List<Integer> arr) {\n        if (arr.isEmpty()) {\n            return true;\n        }\n\n        int n = arr.size();\n        for (int i = 0; i < n - 1; i++) {\n            if (arr.get(i) > arr.get(i + 1)) {\n                // Check if the array can be sorted by a single right shift\n                List<Integer> shiftedArr = new ArrayList<>(arr.subList(i + 1, n));\n                shiftedArr.addAll(arr.subList(0, i + 1));\n                boolean isSorted = true;\n                for (int j = 0; j < n - 1; j++) {\n                    if (shiftedArr.get(j) > shiftedArr.get(j + 1)) {\n                        isSorted = false;\n                        break;\n                    }\n                }\n                return isSorted;\n            }\n        }\n\n        // If no out-of-order pair found, the array is already sorted\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.move_one_ball(Arrays.asList(3, 4, 5, 1, 2))); // true\n        System.out.println(solution.move_one_ball(Arrays.asList(3, 5, 4, 1, 2))); // false\n        System.out.println(solution.move_one_ball(Arrays.asList()));             // true\n        System.out.println(solution.move_one_ball(Arrays.asList(1, 2, 3, 4, 5))); // true\n        System.out.println(solution.move_one_ball(Arrays.asList(2, 1, 3, 4, 5))); // false (requires more than one shift)\n    }\n}\n"}
{"task_id": "Java/110", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * In this problem, you will implement a function that takes two lists of numbers,\n     * and determines whether it is possible to perform an exchange of elements\n     * between them to make lst1 a list of only even numbers.\n     * There is no limit on the number of exchanged elements between lst1 and lst2.\n     * If it is possible to exchange elements between the lst1 and lst2 to make\n     * all the elements of lst1 to be even, return \"YES\".\n     * Otherwise, return \"NO\".\n     * For example:\n     * exchange(Arrays.asList(1, 2, 3, 4), Arrays.asList(1, 2, 3, 4)) => \"YES\"\n     * exchange(Arrays.asList(1, 2, 3, 4), Arrays.asList(1, 5, 3, 4)) => \"NO\"\n     * It is assumed that the input lists will be non-empty.\n     */\n    public String exchange(List<Integer> lst1, List<Integer> lst2) {\n        // Count odd numbers in lst1 and even numbers in lst2\n        int oddCount = 0;\n        for (int num : lst1) {\n            if (num % 2 != 0) {\n                oddCount++;\n            }\n        }\n\n        int evenCount = 0;\n        for (int num : lst2) {\n            if (num % 2 == 0) {\n                evenCount++;\n            }\n        }\n\n        // If there are enough even numbers in lst2 to replace all odd numbers in lst1, return \"YES\"\n        return oddCount <= evenCount ? \"YES\" : \"NO\";\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.exchange(Arrays.asList(1, 2, 3, 4), Arrays.asList(1, 2, 3, 4))); // Expected: YES\n        System.out.println(solution.exchange(Arrays.asList(1, 2, 3, 4), Arrays.asList(1, 5, 3, 4))); // Expected: NO\n        System.out.println(solution.exchange(Arrays.asList(1, 3, 5, 7), Arrays.asList(2, 4, 6, 8))); // Expected: YES\n        System.out.println(solution.exchange(Arrays.asList(1, 3, 5, 7), Arrays.asList(1, 3, 5, 7))); // Expected: NO\n    }\n}\n"}
{"task_id": "Java/111", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public Map<String, Integer> histogram(String test) {\n        Map<String, Integer> letterCounts = new HashMap<>();\n        \n        // Count occurrences of each letter\n        for (String letter : test.split(\" \")) {\n            letterCounts.put(letter, letterCounts.getOrDefault(letter, 0) + 1);\n        }\n        \n        int maxCount = Collections.max(letterCounts.values());\n        \n        // Create result map with letters having the maximum count\n        Map<String, Integer> result = new HashMap<>();\n        for (Map.Entry<String, Integer> entry : letterCounts.entrySet()) {\n            if (entry.getValue() == maxCount) {\n                result.put(entry.getKey(), entry.getValue());\n            }\n        }\n        \n        return result;\n    }\n}\n"}
{"task_id": "Java/112", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Task\n     * We are given two strings s and c, you have to deleted all the characters in s that are equal to any character in c\n     * then check if the result string is palindrome.\n     * A string is called palindrome if it reads the same backward as forward.\n     * You should return a tuple containing the result string and true/false for the check.\n     * Example\n     * For s = \"abcde\", c = \"ae\", the result should be (\"bcd\",false)\n     * For s = \"abcdef\", c = \"b\"  the result should be (\"acdef\",false)\n     * For s = \"abcdedcba\", c = \"ab\", the result should be (\"cdedc\",true)\n     */\n    public List<Object> reverse_delete(String s, String c) {\n        Set<Character> charsToRemove = new HashSet<>();\n        for (char ch : c.toCharArray()) {\n            charsToRemove.add(ch);\n        }\n\n        StringBuilder sb = new StringBuilder();\n        for (char ch : s.toCharArray()) {\n            if (!charsToRemove.contains(ch)) {\n                sb.append(ch);\n            }\n        }\n\n        String resultString = sb.toString();\n        boolean isPalindrome = isPalindrome(resultString);\n\n        return Arrays.asList(resultString, isPalindrome);\n    }\n\n    private boolean isPalindrome(String str) {\n        int left = 0;\n        int right = str.length() - 1;\n\n        while (left < right) {\n            if (str.charAt(left) != str.charAt(right)) {\n                return false;\n            }\n            left++;\n            right--;\n        }\n\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.reverse_delete(\"abcde\", \"ae\"));  // Expected: [bcd, false]\n        System.out.println(solution.reverse_delete(\"abcdef\", \"b\"));  // Expected: [acdef, false]\n        System.out.println(solution.reverse_delete(\"abcdedcba\", \"ab\"));  // Expected: [cdedc, true]\n    }\n}\n"}
{"task_id": "Java/113", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a list of strings, where each string consists of only digits,\n     * return a list. Each element i of the output should be \"the number of odd elements in the\n     * string i of the input.\" where all the i's should be replaced by the number\n     * of odd digits in the i\"th string of the input.\n     *\n     * @param lst The input list of strings consisting only of digits.\n     * @return A list of formatted strings indicating the count of odd elements in each input string.\n     */\n    public List<String> odd_count(List<String> lst) {\n        List<String> result = new ArrayList<>();\n        for (String str : lst) {\n            int oddCount = 0;\n            for (char c : str.toCharArray()) {\n                if ((c - '0') % 2 != 0) {\n                    oddCount++;\n                }\n            }\n            String formattedStr = \"the number of odd elements \" + oddCount + \"n the str\" + oddCount + \"ng \" + oddCount + \" of the \" + oddCount + \"nput.\";\n            result.add(formattedStr);\n        }\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        List<String> test1 = Arrays.asList(\"1234567\");\n        System.out.println(solution.odd_count(test1));  // Expected: [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n\n        List<String> test2 = Arrays.asList(\"3\", \"11111111\");\n        System.out.println(solution.odd_count(test2));  // Expected: [\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    }\n}\n"}
{"task_id": "Java/114", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given an array of integers nums, find the minimum sum of any non-empty sub-array\n     * of nums.\n     *\n     * Example:\n     * minSubArraySum(Arrays.asList(2, 3, 4, 1, 2, 4)) == 1\n     * minSubArraySum(Arrays.asList(-1, -2, -3)) == -6\n     */\n    public int minSubArraySum(List<Integer> nums) {\n        if (nums == null || nums.isEmpty()) {\n            throw new IllegalArgumentException(\"Input list cannot be null or empty\");\n        }\n        \n        int currentMin = nums.get(0);\n        int globalMin = nums.get(0);\n\n        for (int i = 1; i < nums.size(); i++) {\n            currentMin = Math.min(nums.get(i), currentMin + nums.get(i));\n            globalMin = Math.min(globalMin, currentMin);\n        }\n\n        return globalMin;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.minSubArraySum(Arrays.asList(2, 3, 4, 1, 2, 4))); // Expected output: 1\n        System.out.println(solution.minSubArraySum(Arrays.asList(-1, -2, -3)));       // Expected output: -6\n        System.out.println(solution.minSubArraySum(Arrays.asList(1, 2, 3, -6, 1)));   // Expected output: -6\n        System.out.println(solution.minSubArraySum(Arrays.asList(-1, -1, -2, 1)));    // Expected output: -4\n        System.out.println(solution.minSubArraySum(Arrays.asList(1, 2, 3, 4, 5)));    // Expected output: 1\n    }\n}\n"}
{"task_id": "Java/115", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * You are given a rectangular grid of wells. Each row represents a single well,\n     * and each 1 in a row represents a single unit of water.\n     * Each well has a corresponding bucket that can be used to extract water from it,\n     * and all buckets have the same capacity. Can't use buckets from other wells to extract water from one well.\n     * Your task is to use the buckets to empty the wells.\n     * Output the number of times you need to lower the buckets.\n     *\n     * Example 1:\n     * Input:\n     *      grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n     *      bucket_capacity : 1\n     * Output: 6\n     *\n     * Example 2:\n     * Input:\n     *      grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n     *      bucket_capacity : 2\n     * Output: 5\n     *\n     * Example 3:\n     * Input:\n     *      grid : [[0,0,0], [0,0,0]]\n     *      bucket_capacity : 5\n     * Output: 0\n     */\n    public int max_fill(List<List<Integer>> grid, int capacity) {\n        int totalDrops = 0;\n        for (List<Integer> well : grid) {\n            int waterUnits = 0;\n            for (int unit : well) {\n                waterUnits += unit;\n            }\n            totalDrops += Math.ceil((double) waterUnits / capacity);\n        }\n        return totalDrops;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test Case 1\n        List<List<Integer>> grid1 = Arrays.asList(\n                Arrays.asList(0, 0, 1, 0),\n                Arrays.asList(0, 1, 0, 0),\n                Arrays.asList(1, 1, 1, 1)\n        );\n        int capacity1 = 1;\n        System.out.println(\"Test Case 1: \" + solution.max_fill(grid1, capacity1)); // Expected output: 6\n\n        // Test Case 2\n        List<List<Integer>> grid2 = Arrays.asList(\n                Arrays.asList(0, 0, 1, 1),\n                Arrays.asList(0, 0, 0, 0),\n                Arrays.asList(1, 1, 1, 1),\n                Arrays.asList(0, 1, 1, 1)\n        );\n        int capacity2 = 2;\n        System.out.println(\"Test Case 2: \" + solution.max_fill(grid2, capacity2)); // Expected output: 5\n\n        // Test Case 3\n        List<List<Integer>> grid3 = Arrays.asList(\n                Arrays.asList(0, 0, 0),\n                Arrays.asList(0, 0, 0)\n        );\n        int capacity3 = 5;\n        System.out.println(\"Test Case 3: \" + solution.max_fill(grid3, capacity3)); // Expected output: 0\n    }\n}\n"}
{"task_id": "Java/116", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * In this Kata, you have to sort an array of integers according to\n     * number of ones in their binary representation in ascending order.\n     * For similar number of ones, sort based on decimal value.\n     *\n     * It must be implemented like this:\n     * >>> sort_array(Arrays.asList(1, 5, 2, 3, 4)).equals(Arrays.asList(1, 2, 4, 3, 5))\n     * >>> sort_array(Arrays.asList(-2, -3, -4, -5, -6)).equals(Arrays.asList(-4, -2, -6, -5, -3))\n     * >>> sort_array(Arrays.asList(1, 0, 2, 3, 4)).equals(Arrays.asList(0, 1, 2, 4, 3))\n     */\n    public List<Integer> sort_array(List<Integer> arr) {\n        return arr.stream()\n                  .sorted(Comparator.comparingInt(this::countOnes)\n                                    .thenComparingInt(i -> i))\n                  .collect(Collectors.toList());\n    }\n\n    private int countOnes(int num) {\n        if (num < 0) {\n            num = ~num + 1; // Convert negative number to its positive equivalent\n        }\n        int onesCount = 0;\n        while (num > 0) {\n            onesCount += num & 1;\n            num >>= 1;\n        }\n        return onesCount;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        List<Integer> test1 = Arrays.asList(1, 5, 2, 3, 4);\n        System.out.println(\"Test Case 1: \" + solution.sort_array(test1).equals(Arrays.asList(1, 2, 4, 3, 5)));\n\n        List<Integer> test2 = Arrays.asList(-2, -3, -4, -5, -6);\n        System.out.println(\"Test Case 2: \" + solution.sort_array(test2).equals(Arrays.asList(-4, -2, -6, -5, -3)));\n\n        List<Integer> test3 = Arrays.asList(1, 0, 2, 3, 4);\n        System.out.println(\"Test Case 3: \" + solution.sort_array(test3).equals(Arrays.asList(0, 1, 2, 4, 3)));\n    }\n}\n"}
{"task_id": "Java/117", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a string s and a natural number n, you have been tasked to implement\n     * a function that returns a list of all words from string s that contain exactly\n     * n consonants, in order these words appear in the string s.\n     * If the string s is empty then the function should return an empty list.\n     * Note: you may assume the input string contains only letters and spaces.\n     * Examples:\n     * select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n     * select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n     * select_words(\"simple white space\", 2) ==> []\n     * select_words(\"Hello world\", 4) ==> [\"world\"]\n     * select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\n     */\n    public List<String> select_words(String s, int n) {\n        if (s == null || s.isEmpty()) {\n            return new ArrayList<>();\n        }\n\n        String[] words = s.split(\"\\\\s+\");\n        List<String> result = new ArrayList<>();\n\n        for (String word : words) {\n            long consonantCount = word.toLowerCase().chars()\n                    .filter(c -> \"bcdfghjklmnpqrstvwxyz\".indexOf(c) != -1)\n                    .count();\n\n            if (consonantCount == n) {\n                result.add(word);\n            }\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.select_words(\"Mary had a little lamb\", 4)); // [\"little\"]\n        System.out.println(solution.select_words(\"Mary had a little lamb\", 3)); // [\"Mary\", \"lamb\"]\n        System.out.println(solution.select_words(\"simple white space\", 2));     // []\n        System.out.println(solution.select_words(\"Hello world\", 4));            // [\"world\"]\n        System.out.println(solution.select_words(\"Uncle sam\", 3));              // [\"Uncle\"]\n    }\n}\n"}
{"task_id": "Java/118", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * You are given a word. Your task is to find the closest vowel that stands between\n     * two consonants from the right side of the word (case sensitive).\n     *\n     * Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n     * find any vowel met the above condition.\n     *\n     * You may assume that the given string contains English letter only.\n     */\n    public String get_closest_vowel(String word) {\n        // Convert the input to a character array for easier manipulation\n        char[] chars = word.toCharArray();\n        \n        // Iterate from right to left, looking for vowels between consonants\n        for (int i = chars.length - 2; i > 0; i--) {\n            if (isVowel(chars[i]) && isConsonant(chars[i-1]) && isConsonant(chars[i+1])) {\n                return String.valueOf(chars[i]);\n            }\n        }\n        \n        // If no vowel found, return an empty string\n        return \"\";\n    }\n\n    private boolean isVowel(char c) {\n        return \"AEIOUaeiou\".indexOf(c) != -1;\n    }\n\n    private boolean isConsonant(char c) {\n        return !isVowel(c);\n    }\n    \n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.get_closest_vowel(\"yogurt\"));  // Output: \"u\"\n        System.out.println(solution.get_closest_vowel(\"FULL\"));    // Output: \"U\"\n        System.out.println(solution.get_closest_vowel(\"quick\"));   // Output: \"\"\n        System.out.println(solution.get_closest_vowel(\"ab\"));      // Output: \"\"\n        System.out.println(solution.get_closest_vowel(\"aBcDeFgHiJkLmNoPqRsTuVwXyZ\"));  // Output: \"u\"\n    }\n}\n"}
{"task_id": "Java/119", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public String match_parens(List<String> lst) {\n        // Helper method to check if a string is balanced\n        boolean isBalanced(String s) {\n            int balance = 0;\n            for (char c : s.toCharArray()) {\n                if (c == '(') {\n                    balance++;\n                } else {\n                    balance--;\n                }\n                if (balance < 0) {\n                    return false;\n                }\n            }\n            return balance == 0;\n        }\n\n        // Check both possible concatenations\n        if (isBalanced(lst.get(0) + lst.get(1)) || isBalanced(lst.get(1) + lst.get(0))) {\n            return \"Yes\";\n        } else {\n            return \"No\";\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.match_parens(Arrays.asList(\"()\", \")\")));  // Output: \"Yes\"\n        System.out.println(solution.match_parens(Arrays.asList(\")\", \")\")));   // Output: \"No\"\n    }\n}\n"}
{"task_id": "Java/120", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     Given an array arr of integers and a positive integer k, return a sorted list\n     of length k with the maximum k numbers in arr, in ascending order.\n     */\n    public List<Integer> maximum(List<Integer> arr, int k) {\n        // Sort the array in descending order\n        Collections.sort(arr, Collections.reverseOrder());\n        \n        // Create a new list to store the top k elements\n        List<Integer> result = new ArrayList<>();\n        \n        // Add the first k elements from the sorted array to the result list\n        for (int i = 0; i < Math.min(k, arr.size()); i++) {\n            result.add(arr.get(i));\n        }\n        \n        // Sort the result list in ascending order before returning\n        Collections.sort(result);\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        List<Integer> arr1 = Arrays.asList(-3, -4, 5);\n        int k1 = 3;\n        System.out.println(\"Test Case 1: \" + solution.maximum(arr1, k1)); // Expected: [-4, -3, 5]\n\n        // Test case 2\n        List<Integer> arr2 = Arrays.asList(4, -4, 4);\n        int k2 = 2;\n        System.out.println(\"Test Case 2: \" + solution.maximum(arr2, k2)); // Expected: [4, 4]\n\n        // Test case 3\n        List<Integer> arr3 = Arrays.asList(-3, 2, 1, 2, -1, -2, 1);\n        int k3 = 1;\n        System.out.println(\"Test Case 3: \" + solution.maximum(arr3, k3)); // Expected: [2]\n    }\n}\n"}
{"task_id": "Java/121", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n     *\n     * Examples:\n     * solution(Arrays.asList(5, 8, 7, 1)) ==> 12\n     * solution(Arrays.asList(3, 3, 3, 3, 3)) ==> 9\n     * solution(Arrays.asList(30, 13, 24, 321)) ==> 0\n     */\n    public int solution(List<Integer> lst) {\n        int sum = 0;\n        for (int i = 0; i < lst.size(); i += 2) {\n            if (lst.get(i) % 2 != 0) {\n                sum += lst.get(i);\n            }\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.solution(Arrays.asList(5, 8, 7, 1))); // Expected output: 12\n        System.out.println(solution.solution(Arrays.asList(3, 3, 3, 3, 3))); // Expected output: 9\n        System.out.println(solution.solution(Arrays.asList(30, 13, 24, 321))); // Expected output: 0\n    }\n}\n"}
{"task_id": "Java/122", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     Given a non-empty array of integers arr and an integer k, return\n     the sum of the elements with at most two digits from the first k elements of arr.\n     \n     Example:\n     \n         Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n         Output: 24 # sum of 21 + 3\n     \n     Constraints:\n         1. 1 <= len(arr) <= 100\n         2. 1 <= k <= len(arr)\n      */\n    public int add_elements(List<Integer> arr, int k) {\n        int sum = 0;\n        for (int i = 0; i < Math.min(k, arr.size()); i++) {\n            if (arr.get(i).toString().length() <= 2) {\n                sum += arr.get(i);\n            }\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        List<Integer> arr1 = Arrays.asList(111, 21, 3, 4000, 5, 6, 7, 8, 9);\n        int k1 = 4;\n        System.out.println(\"Test Case 1: \" + solution.add_elements(arr1, k1)); // Expected output: 24\n\n        // Test case 2\n        List<Integer> arr2 = Arrays.asList(10, 20, 30, 40, 50);\n        int k2 = 3;\n        System.out.println(\"Test Case 2: \" + solution.add_elements(arr2, k2)); // Expected output: 60\n\n        // Test case 3\n        List<Integer> arr3 = Arrays.asList(1, 2, 3, 4, 5);\n        int k3 = 5;\n        System.out.println(\"Test Case 3: \" + solution.add_elements(arr3, k3)); // Expected output: 15\n\n        // Test case 4\n        List<Integer> arr4 = Arrays.asList(100, 200, 300);\n        int k4 = 2;\n        System.out.println(\"Test Case 4: \" + solution.add_elements(arr4, k4)); // Expected output: 0\n\n        // Test case 5\n        List<Integer> arr5 = Arrays.asList(1, 11, 111, 1111);\n        int k5 = 3;\n        System.out.println(\"Test Case 5: \" + solution.add_elements(arr5, k5)); // Expected output: 12\n\n    }\n}\n"}
{"task_id": "Java/123", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n     *\n     * @param n The starting positive integer for the Collatz sequence.\n     * @return A List of Integer containing the odd numbers in the Collatz sequence, sorted in increasing order.\n     */\n    public List<Integer> get_odd_collatz(int n) {\n        List<Integer> result = new ArrayList<>();\n        while (n != 1) {\n            if (n % 2 == 1) { // Check if n is odd\n                result.add(n);\n            }\n            n = n % 2 == 0 ? n / 2 : 3 * n + 1; // Apply Collatz rules\n        }\n        result.add(1); // Add the final term, which is always 1\n        Collections.sort(result); // Sort the list in increasing order\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.get_odd_collatz(5)); // Expected: [1, 5]\n        System.out.println(solution.get_odd_collatz(7)); // Expected: [1, 7, 11, 22]\n        System.out.println(solution.get_odd_collatz(10)); // Expected: [1, 5, 13]\n        System.out.println(solution.get_odd_collatz(1)); // Expected: [1]\n    }\n}\n"}
{"task_id": "Java/124", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * You have to write a function which validates a given date string and\n     * returns true if the date is valid otherwise false.\n     * The date is valid if all of the following rules are satisfied:\n     * 1. The date string is not empty.\n     * 2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.\n     * 3. The months should not be less than 1 or higher than 12.\n     * 4. The date should be in the format: mm-dd-yyyy\n     *\n     * for example:\n     * valid_date(\"03-11-2000\") => true\n     * valid_date(\"15-01-2012\") => false\n     * valid_date(\"04-0-2040\") => false\n     * valid_date(\"06-04-2020\") => true\n     * valid_date(\"06/04/2020\") => false\n     */\n    public boolean valid_date(String date) {\n        if (date == null || date.isEmpty()) return false;\n\n        String[] parts = date.split(\"-\");\n        if (parts.length != 3) return false;\n\n        int month = Integer.parseInt(parts[0]);\n        int day = Integer.parseInt(parts[1]);\n        int year = Integer.parseInt(parts[2]);\n\n        if (month < 1 || month > 12) return false;\n        if (day < 1 || day > 31) return false;\n\n        // Check for months with 30 days\n        if ((month == 4 || month == 6 || month == 9 || month == 11) && day > 30) return false;\n\n        // Check for February and leap years\n        if (month == 2) {\n            if (day > 29) return false;\n            if (day == 29 && !isLeapYear(year)) return false;\n        }\n\n        return true;\n    }\n\n    private boolean isLeapYear(int year) {\n        return (year % 4 == 0 && (year % 100 != 0 || year % 400 == 0));\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.valid_date(\"03-11-2000\")); // true\n        System.out.println(solution.valid_date(\"15-01-2012\")); // false\n        System.out.println(solution.valid_date(\"04-0-2040\"));  // false\n        System.out.println(solution.valid_date(\"06-04-2020\")); // true\n        System.out.println(solution.valid_date(\"06/04/2020\")); // false\n    }\n}\n"}
{"task_id": "Java/125", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n     should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n     alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n     Examples:\n     split_words(\"Hello world!\") == [\"Hello\", \"world!\"]\n     split_words(\"Hello,world!\") == [\"Hello\", \"world!\"]\n     split_words(\"abcdef\") == 3\n     */\n    public Object split_words(String txt) {\n        if (txt.contains(\" \")) {\n            return Arrays.asList(txt.split(\"\\\\s+\"));\n        } else if (txt.contains(\",\")) {\n            return Arrays.asList(txt.split(\",\"));\n        } else {\n            int count = 0;\n            for (char c : txt.toCharArray()) {\n                if (Character.isLowerCase(c) && ((c - 'a') % 2 == 1)) {\n                    count++;\n                }\n            }\n            return count;\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.split_words(\"Hello world!\")); // [\"Hello\", \"world!\"]\n        System.out.println(solution.split_words(\"Hello,world!\")); // [\"Hello\", \"world!\"]\n        System.out.println(solution.split_words(\"abcdef\"));      // 3\n\n        // Additional test cases\n        System.out.println(solution.split_words(\"a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z\")); // 13\n        System.out.println(solution.split_words(\"A quick, brown fox!\")); // [\"A\", \"quick,\", \"brown\", \"fox!\"]\n        System.out.println(solution.split_words(\"noSpacesOrCommas\")); // 5\n    }\n}\n"}
{"task_id": "Java/126", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given a list of numbers, return whether or not they are sorted in ascending order.\n     * If the number appears more than twice, return false. Assume no negative numbers and only integers.\n     *\n     * Examples:\n     * is_sorted(Arrays.asList(5)) -> true\n     * is_sorted(Arrays.asList(1, 2, 3, 4, 5)) -> true\n     * is_sorted(Arrays.asList(1, 3, 2, 4, 5)) -> false\n     * is_sorted(Arrays.asList(1, 2, 3, 4, 5, 6)) -> true\n     * is_sorted(Arrays.asList(1, 2, 3, 4, 5, 6, 7)) -> true\n     * is_sorted(Arrays.asList(1, 3, 2, 4, 5, 6, 7)) -> false\n     * is_sorted(Arrays.asList(1, 2, 2, 3, 3, 4)) -> true\n     * is_sorted(Arrays.asList(1, 2, 2, 2, 3, 4)) -> false\n     */\n    public boolean is_sorted(List<Integer> lst) {\n        if (lst == null || lst.size() <= 1) {\n            return true;\n        }\n\n        int count = 1; // To keep track of consecutive duplicates\n\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i).equals(lst.get(i - 1))) {\n                count++;\n                if (count > 2) {\n                    return false;\n                }\n            } else {\n                count = 1;\n            }\n\n            if (lst.get(i) < lst.get(i - 1)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.is_sorted(Arrays.asList(5))); // true\n        System.out.println(solution.is_sorted(Arrays.asList(1, 2, 3, 4, 5))); // true\n        System.out.println(solution.is_sorted(Arrays.asList(1, 3, 2, 4, 5))); // false\n        System.out.println(solution.is_sorted(Arrays.asList(1, 2, 3, 4, 5, 6))); // true\n        System.out.println(solution.is_sorted(Arrays.asList(1, 2, 3, 4, 5, 6, 7))); // true\n        System.out.println(solution.is_sorted(Arrays.asList(1, 3, 2, 4, 5, 6, 7))); // false\n        System.out.println(solution.is_sorted(Arrays.asList(1, 2, 2, 3, 3, 4))); // true\n        System.out.println(solution.is_sorted(Arrays.asList(1, 2, 2, 2, 3, 4))); // false\n    }\n}\n"}
{"task_id": "Java/127", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public String intersection(List<Integer> interval1, List<Integer> interval2) {\n        int start = Math.max(interval1.get(0), interval2.get(0));\n        int end = Math.min(interval1.get(1), interval2.get(1));\n\n        if (start > end) {\n            return \"NO\";\n        }\n\n        int length = end - start + 1;\n        if (isPrime(length)) {\n            return \"YES\";\n        } else {\n            return \"NO\";\n        }\n    }\n\n    private boolean isPrime(int n) {\n        if (n <= 1) {\n            return false;\n        }\n        for (int i = 2; i * i <= n; i++) {\n            if (n % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n"}
{"task_id": "Java/128", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * You are given an array arr of integers and you need to return\n     * sum of magnitudes of integers multiplied by product of all signs\n     * of each number in the array, represented by 1, -1 or 0.\n     * Note: return None for empty arr.\n     *\n     * Example:\n     * >>> prod_signs(Arrays.asList(1, 2, 2, -4)) == -9\n     * >>> prod_signs(Arrays.asList(0, 1)) == 0\n     * >>> prod_signs(Arrays.asList()) == Optional.empty()\n     */\n    public Optional<Integer> prod_signs(List<Integer> arr) {\n        if (arr.isEmpty()) {\n            return Optional.empty();\n        }\n\n        int sumOfMagnitudes = 0;\n        int productOfSigns = 1;\n\n        for (Integer num : arr) {\n            sumOfMagnitudes += Math.abs(num);\n            if (num == 0) {\n                productOfSigns = 0;\n                break;\n            } else if (num < 0) {\n                productOfSigns *= -1;\n            }\n        }\n\n        return Optional.of(sumOfMagnitudes * productOfSigns);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.prod_signs(Arrays.asList(1, 2, 2, -4))); // Expected output: Optional[-9]\n        System.out.println(solution.prod_signs(Arrays.asList(0, 1)));        // Expected output: Optional[0]\n        System.out.println(solution.prod_signs(Arrays.asList()));           // Expected output: Optional.empty\n    }\n}\n"}
{"task_id": "Java/129", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> minPath(List<List<Integer>> grid, int k) {\n        int n = grid.size();\n        int[][] directions = {{0, 1}, {1, 0}, {-1, 0}, {0, -1}};\n        Set<String> visited = new HashSet<>();\n        PriorityQueue<int[]> heap = new PriorityQueue<>((a, b) -> a[0] - b[0]);\n        heap.offer(new int[]{grid.get(0).get(0), 0, 0}); // (value, row, col)\n\n        while (k > 0) {\n            int[] current = heap.poll();\n            String key = current[1] + \",\" + current[2];\n            if (visited.contains(key)) {\n                continue;\n            }\n            visited.add(key);\n            k--;\n\n            if (k == 0) {\n                break;\n            }\n\n            for (int[] dir : directions) {\n                int newRow = current[1] + dir[0], newCol = current[2] + dir[1];\n                if (newRow >= 0 && newRow < n && newCol >= 0 && newCol < n) {\n                    heap.offer(new int[]{grid.get(newRow).get(newCol), newRow, newCol});\n                }\n            }\n        }\n\n        List<Integer> result = new ArrayList<>();\n        for (String key : visited) {\n            String[] parts = key.split(\",\");\n            int row = Integer.parseInt(parts[0]);\n            int col = Integer.parseInt(parts[1]);\n            result.add(grid.get(row).get(col));\n        }\n        Collections.sort(result);\n        return result;\n    }\n}\n"}
{"task_id": "Java/130", "generation": "import java.util.ArrayList;\nimport java.util.List;\n\nclass Solution {\n    public List<Integer> tri(int n) {\n        if (n == 0) {\n            return new ArrayList<>();\n        }\n\n        List<Integer> sequence = new ArrayList<>();\n        // Initialize the first value of the Tribonacci sequence\n        sequence.add(3);\n\n        for (int i = 2; i <= n + 1; i++) {\n            int nextValue;\n            if (i % 2 == 0) {\n                nextValue = 1 + (i / 2);\n            } else {\n                // For odd indices, calculate the value based on previous elements\n                nextValue = sequence.get(i - 2) + sequence.get(i - 3) + sequence.get(0);\n            }\n            sequence.add(nextValue);\n        }\n\n        return sequence;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.tri(3)); // Output: [3, 2, 8]\n    }\n}\n"}
{"task_id": "Java/131", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     Given a positive integer n, return the product of the odd digits.\n     Return 0 if all digits are even.\n     For example:\n     digits(1)  == 1\n     digits(4)  == 0\n     digits(235) == 15\n     */\n    public int digits(int n) {\n        int product = 1;\n        boolean hasOddDigit = false;\n\n        while (n > 0) {\n            int digit = n % 10;\n            if (digit % 2 != 0) {\n                product *= digit;\n                hasOddDigit = true;\n            }\n            n /= 10;\n        }\n\n        return hasOddDigit ? product : 0;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.digits(1));   // Output: 1\n        System.out.println(solution.digits(4));   // Output: 0\n        System.out.println(solution.digits(235)); // Output: 15\n        System.out.println(solution.digits(2468)); // Output: 0\n        System.out.println(solution.digits(13579)); // Output: 945\n    }\n}\n"}
{"task_id": "Java/132", "generation": "import java.util.*;\n\nclass Solution {\n    public boolean is_nested(String string) {\n        Stack<Character> stack = new Stack<>();\n        boolean nested = false;\n        \n        for (char bracket : string.toCharArray()) {\n            if (bracket == '[') {\n                stack.push(bracket);\n            } else if (bracket == ']') {\n                if (!stack.isEmpty()) {\n                    stack.pop();\n                    nested = true;\n                } else {\n                    return false;\n                }\n            }\n        }\n        \n        return nested;\n    }\n}\n"}
{"task_id": "Java/133", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int sum_squares(List<Double> lst) {\n        int sum = 0;\n        for (Double num : lst) {\n            // Round up to the nearest integer using Math.ceil and cast to int\n            double roundedNum = Math.ceil(num);\n            sum += (int) Math.pow(roundedNum, 2);\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.sum_squares(Arrays.asList(1.0, 2.0, 3.0))); // Output: 14\n        System.out.println(solution.sum_squares(Arrays.asList(1.0, 4.0, 9.0))); // Output: 98\n        System.out.println(solution.sum_squares(Arrays.asList(1.0, 3.0, 5.0, 7.0))); // Output: 84\n        System.out.println(solution.sum_squares(Arrays.asList(1.4, 4.2, 0.0))); // Output: 29\n        System.out.println(solution.sum_squares(Arrays.asList(-2.4, 1.0, 1.0))); // Output: 6\n    }\n}\n"}
{"task_id": "Java/134", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public boolean check_if_last_char_is_a_letter(String txt) {\n        if (txt == null || txt.isEmpty()) {  // Check if the string is empty or null\n            return false;\n        }\n        \n        char lastChar = txt.charAt(txt.length() - 1);\n        \n        // Check if the last character is an alphabetical character and not part of a word\n        if (Character.isLetter(lastChar) && \n            (txt.length() == 1 || !Character.isLetterOrDigit(txt.charAt(txt.length() - 2)))) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.check_if_last_char_is_a_letter(\"apple pie\")); // false\n        System.out.println(solution.check_if_last_char_is_a_letter(\"apple pi e\")); // true\n        System.out.println(solution.check_if_last_char_is_a_letter(\"apple pi e \")); // false\n        System.out.println(solution.check_if_last_char_is_a_letter(\"\")); // false\n    }\n}\n"}
{"task_id": "Java/135", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Create a function which returns the largest index of an element which\n    is not greater than or equal to the element immediately preceding it. If\n    no such element exists then return -1. The given array will not contain\n    duplicate values.\n\n    Examples:\n    canArrange(Arrays.asList(1,2,4,3,5)) = 3\n    canArrange(Arrays.asList(1,2,3)) = -1\n     */\n    public int canArrange(List<Integer> arr) {\n        int n = arr.size();\n        for (int i = 1; i < n; i++) {\n            if (arr.get(i) < arr.get(i - 1)) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.canArrange(Arrays.asList(1, 2, 4, 3, 5))); // Output: 3\n        System.out.println(solution.canArrange(Arrays.asList(1, 2, 3)));       // Output: -1\n    }\n}\n"}
{"task_id": "Java/136", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Create a function that returns a tuple (a, b), where 'a' is\n     * the largest of negative integers, and 'b' is the smallest\n     * of positive integers in a list.\n     * If there is no negative or positive integers, return them as None.\n     *\n     * Examples:\n     * largest_smallest_integers(Arrays.asList(2, 4, 1, 3, 5, 7)) == (Optional.empty(), Optional.of(1))\n     * largest_smallest_integers(Arrays.asList()) == (Optional.empty(), Optional.empty())\n     * largest_smallest_integers(Arrays.asList(0)) == (Optional.empty(), Optional.empty())\n     */\n    public List<Optional<Integer>> largest_smallest_integers(List<Integer> lst) {\n        if (lst.isEmpty()) {\n            return Arrays.asList(Optional.empty(), Optional.empty());\n        }\n\n        Optional<Integer> smallestPositive = lst.stream()\n                .filter(n -> n > 0)\n                .min(Integer::compare);\n\n        Optional<Integer> largestNegative = lst.stream()\n                .filter(n -> n < 0)\n                .max(Integer::compare);\n\n        return Arrays.asList(largestNegative, smallestPositive);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.largest_smallest_integers(Arrays.asList(2, 4, 1, 3, 5, 7))); // (Optional.empty(), Optional.of(1))\n        System.out.println(solution.largest_smallest_integers(Arrays.asList()));                // (Optional.empty(), Optional.empty())\n        System.out.println(solution.largest_smallest_integers(Arrays.asList(0)));               // (Optional.empty(), Optional.empty())\n        System.out.println(solution.largest_smallest_integers(Arrays.asList(-2, -4, -1, -3)));  // (Optional.of(-1), Optional.empty())\n        System.out.println(solution.largest_smallest_integers(Arrays.asList(2, -4, 1, -3, 5))); // (Optional.empty(), Optional.of(1))\n    }\n}\n"}
{"task_id": "Java/137", "generation": "import java.util.*;\n\nclass Solution {\n    public Optional<Object> compare_one(Object a, Object b) {\n        // Convert strings with ',' as decimal separator to floats\n        if (a instanceof String) {\n            a = Float.parseFloat(((String) a).replace(',', '.'));\n        }\n        if (b instanceof String) {\n            b = Float.parseFloat(((String) b).replace(',', '.'));\n        }\n\n        // Compare the values and return the larger one or None if they are equal\n        if (a instanceof Number && b instanceof Number) {\n            double numA = ((Number) a).doubleValue();\n            double numB = ((Number) b).doubleValue();\n\n            if (numA > numB) {\n                return Optional.of(a);\n            } else if (numB > numA) {\n                return Optional.of(b);\n            }\n        }\n\n        return Optional.empty();\n    }\n}\n"}
{"task_id": "Java/138", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers\n     * Example:\n     * is_equal_to_sum_even(4) == false\n     * is_equal_to_sum_even(6) == false\n     * is_equal_to_sum_even(8) == true\n     */\n    public boolean is_equal_to_sum_even(int n) {\n        // The smallest sum of 4 positive even numbers is 2 + 2 + 2 + 2 = 8.\n        if (n < 8 || n % 2 != 0) {\n            return false;\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(\"is_equal_to_sum_even(4): \" + solution.is_equal_to_sum_even(4)); // false\n        System.out.println(\"is_equal_to_sum_even(6): \" + solution.is_equal_to_sum_even(6)); // false\n        System.out.println(\"is_equal_to_sum_even(8): \" + solution.is_equal_to_sum_even(8)); // true\n        System.out.println(\"is_equal_to_sum_even(10): \" + solution.is_equal_to_sum_even(10)); // true\n        System.out.println(\"is_equal_to_sum_even(12): \" + solution.is_equal_to_sum_even(12)); // true\n        System.out.println(\"is_equal_to_sum_even(14): \" + solution.is_equal_to_sum_even(14)); // true\n        System.out.println(\"is_equal_to_sum_even(16): \" + solution.is_equal_to_sum_even(16)); // true\n        System.out.println(\"is_equal_to_sum_even(7): \" + solution.is_equal_to_sum_even(7)); // false\n    }\n}\n"}
{"task_id": "Java/139", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * The Brazilian factorial is defined as:\n     * brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n     * where n > 0\n     *\n     * For example:\n     * >>> special_factorial(4)\n     * 288\n     *\n     * The function will receive an integer as input and should return the special factorial of this integer.\n     */\n    public long special_factorial(int n) {\n        if (n == 0 || n == 1) {\n            return 1;\n        }\n        \n        long result = 1;\n        for (int i = 1; i <= n; i++) {\n            result *= factorial(i);\n        }\n        return result;\n    }\n\n    private long factorial(int num) {\n        if (num == 0 || num == 1) {\n            return 1;\n        }\n        \n        long fact = 1;\n        for (int i = 2; i <= num; i++) {\n            fact *= i;\n        }\n        return fact;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(\"special_factorial(4): \" + solution.special_factorial(4)); // Expected: 288\n        System.out.println(\"special_factorial(3): \" + solution.special_factorial(3)); // Expected: 12\n        System.out.println(\"special_factorial(5): \" + solution.special_factorial(5)); // Expected: 34560\n        System.out.println(\"special_factorial(1): \" + solution.special_factorial(1)); // Expected: 1\n    }\n}\n"}
{"task_id": "Java/140", "generation": "import java.util.*;\n\nclass Solution {\n    public String fix_spaces(String text) {\n        StringBuilder result = new StringBuilder();\n        int consecutiveSpacesCount = 0;\n\n        for (char c : text.toCharArray()) {\n            if (c == ' ') {\n                consecutiveSpacesCount++;\n            } else {\n                if (consecutiveSpacesCount > 2) {\n                    result.append('-');\n                } else if (consecutiveSpacesCount >= 1) {\n                    for (int i = 0; i < consecutiveSpacesCount; i++) {\n                        result.append('_');\n                    }\n                }\n                consecutiveSpacesCount = 0;\n                result.append(c);\n            }\n        }\n\n        // Handle trailing spaces\n        if (consecutiveSpacesCount > 2) {\n            result.append('-');\n        } else if (consecutiveSpacesCount >= 1) {\n            for (int i = 0; i < consecutiveSpacesCount; i++) {\n                result.append('_');\n            }\n        }\n\n        return result.toString();\n    }\n}\n"}
{"task_id": "Java/141", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Create a function which takes a string representing a file's name, and returns\n     * \"Yes\" if the the file's name is valid, and returns \"No\" otherwise.\n     * A file's name is considered to be valid if and only if all the following conditions\n     * are met:\n     * - There should not be more than three digits ('0'-'9') in the file's name.\n     * - The file's name contains exactly one dot '.'\n     * - The substring before the dot should not be empty, and it starts with a letter from\n     *   the latin alphapet ('a'-'z' and 'A'-'Z').\n     * - The substring after the dot should be one of these: [\"txt\", \"exe\", \"dll\"]\n     * Examples:\n     * file_name_check(\"example.txt\") # => \"Yes\"\n     * file_name_check(\"1example.dll\") # => \"No\" (the name should start with a latin alphapet letter)\n     */\n    public String file_name_check(String file_name) {\n        // Check for exactly one dot\n        int dotCount = 0;\n        for (char c : file_name.toCharArray()) {\n            if (c == '.') {\n                dotCount++;\n            }\n        }\n        if (dotCount != 1) return \"No\";\n\n        // Split the filename into two parts: before and after the dot\n        String[] parts = file_name.split(\"\\\\.\");\n        if (parts.length != 2) return \"No\"; // Should have exactly one dot\n\n        // Check for empty part before the dot\n        if (parts[0].isEmpty()) return \"No\";\n\n        // Check if the first character is a letter\n        char firstChar = parts[0].charAt(0);\n        if (!Character.isLetter(firstChar)) return \"No\";\n\n        // Check for more than three digits in the file name\n        int digitCount = 0;\n        for (char c : file_name.toCharArray()) {\n            if (Character.isDigit(c)) {\n                digitCount++;\n            }\n        }\n        if (digitCount > 3) return \"No\";\n\n        // Check the extension part after the dot\n        String ext = parts[1];\n        if (!ext.equals(\"txt\") && !ext.equals(\"exe\") && !ext.equals(\"dll\")) return \"No\";\n\n        return \"Yes\";\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.file_name_check(\"example.txt\"));  // Expected: Yes\n        System.out.println(solution.file_name_check(\"1example.dll\")); // Expected: No (starts with a digit)\n        System.out.println(solution.file_name_check(\".txt\"));         // Expected: No (empty part before the dot)\n        System.out.println(solution.file_name_check(\"example.exe\"));  // Expected: Yes\n        System.out.println(solution.file_name_check(\"example123.dll\"));// Expected: Yes\n        System.out.println(solution.file_name_check(\"example4567.dll\"));// Expected: No (more than three digits)\n    }\n}\n"}
{"task_id": "Java/142", "generation": "import java.util.List;\nimport java.util.Arrays;\n\nclass Solution {\n    /**\n    This function will take a list of integers. For all entries in the list, the function shall square the integer entry if its index is a\n    multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not\n    change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries.\n\n    Examples:\n    For lst = [1,2,3] the output should be 6\n    For lst = []  the output should be 0\n    For lst = [-1,-5,2,-1,-5]  the output should be -126\n     */\n    public int sum_squares(List<Integer> lst) {\n        int totalSum = 0;\n        \n        for (int i = 0; i < lst.size(); i++) {\n            int num = lst.get(i);\n            if ((i + 1) % 3 == 0) {\n                totalSum += Math.pow(num, 2);\n            } else if ((i + 1) % 4 == 0 && (i + 1) % 3 != 0) {\n                totalSum += Math.pow(num, 3);\n            }\n        }\n        \n        return totalSum;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.sum_squares(Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12)));\n    }\n}\n"}
{"task_id": "Java/143", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * You are given a string representing a sentence,\n     * the sentence contains some words separated by a space,\n     * and you have to return a string that contains the words from the original sentence,\n     * whose lengths are prime numbers,\n     * the order of the words in the new string should be the same as the original one.\n     *\n     * Example 1:\n     * Input: sentence = \"This is a test\"\n     * Output: \"is\"\n     *\n     * Example 2:\n     * Input: sentence = \"lets go for swimming\"\n     * Output: \"go for\"\n     *\n     * Constraints:\n     * * 1 <= len(sentence) <= 100\n     * * sentence contains only letters\n     */\n    public String words_in_sentence(String sentence) {\n        List<String> words = Arrays.asList(sentence.split(\" \"));\n        StringBuilder result = new StringBuilder();\n        \n        for (String word : words) {\n            if (isPrime(word.length())) {\n                if (result.length() > 0) {\n                    result.append(\" \");\n                }\n                result.append(word);\n            }\n        }\n        \n        return result.toString();\n    }\n\n    private boolean isPrime(int number) {\n        if (number <= 1) {\n            return false;\n        }\n        for (int i = 2; i * i <= number; i++) {\n            if (number % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.words_in_sentence(\"This is a test\")); // Output: \"is\"\n        System.out.println(solution.words_in_sentence(\"lets go for swimming\")); // Output: \"go for\"\n        System.out.println(solution.words_in_sentence(\"one two three four five six seven eight nine ten\")); // Output: \"three five seven\"\n    }\n}\n"}
{"task_id": "Java/144", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Your task is to implement a function that will simplify the expression\n     * x * n. The function returns true if x * n evaluates to a whole number and false\n     * otherwise. Both x and n, are string representation of a fraction, and have the following format,\n     * <numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n     *\n     * You can assume that x, and n are valid fractions, and do not have zero as denominator.\n     */\n    public boolean simplify(String x, String n) {\n        // Split the strings into numerator and denominator\n        String[] xParts = x.split(\"/\");\n        String[] nParts = n.split(\"/\");\n\n        int xNumerator = Integer.parseInt(xParts[0]);\n        int xDenominator = Integer.parseInt(xParts[1]);\n        int nNumerator = Integer.parseInt(nParts[0]);\n        int nDenominator = Integer.parseInt(nParts[1]);\n\n        // Simplify the expression (x * n) / 1\n        int resultNumerator = xNumerator * nNumerator;\n        int resultDenominator = xDenominator * nDenominator;\n\n        // Check if the result is a whole number\n        return resultNumerator % resultDenominator == 0;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.simplify(\"1/5\", \"5/1\")); // true\n        System.out.println(solution.simplify(\"1/6\", \"2/1\")); // false\n        System.out.println(solution.simplify(\"7/10\", \"10/2\")); // false\n        System.out.println(solution.simplify(\"3/4\", \"4/3\")); // true\n        System.out.println(solution.simplify(\"5/8\", \"8/5\")); // true\n        System.out.println(solution.simplify(\"9/16\", \"16/9\")); // true\n    }\n}\n"}
{"task_id": "Java/145", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> order_by_points(List<Integer> nums) {\n        Collections.sort(nums, new Comparator<Integer>() {\n            @Override\n            public int compare(Integer o1, Integer o2) {\n                return digitSum(o1) - digitSum(o2);\n            }\n        });\n        \n        // If two numbers have the same digit sum, maintain their original order.\n        for (int i = 0; i < nums.size() - 1; i++) {\n            if (digitSum(nums.get(i)) == digitSum(nums.get(i + 1))) {\n                Collections.swap(nums, i, i + 1);\n            }\n        }\n\n        return nums;\n    }\n\n    private int digitSum(Integer num) {\n        boolean isNegative = num < 0;\n        String strNum = Integer.toString(num);\n        int sum = 0;\n\n        for (int i = 0; i < strNum.length(); i++) {\n            if (i == 0 && isNegative) {\n                // Skip the negative sign\n                continue;\n            }\n            sum += Character.getNumericValue(strNum.charAt(i));\n        }\n\n        return sum;\n    }\n}\n"}
{"task_id": "Java/146", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Write a function that takes an array of numbers as input and returns\n     * the number of elements in the array that are greater than 10 and both\n     * first and last digits of a number are odd (1, 3, 5, 7, 9).\n     * For example:\n     * specialFilter(Arrays.asList(15, -73, 14, -15)) => 1\n     * specialFilter(Arrays.asList(33, -2, -3, 45, 21, 109)) => 2\n     */\n    public int specialFilter(List<Integer> nums) {\n        int count = 0;\n        for (int num : nums) {\n            if (num > 10 && isFirstAndLastDigitOdd(num)) {\n                count++;\n            }\n        }\n        return count;\n    }\n\n    private boolean isFirstAndLastDigitOdd(int num) {\n        String strNum = Integer.toString(Math.abs(num));\n        int firstDigit = Character.digit(strNum.charAt(0), 10);\n        int lastDigit = Character.digit(strNum.charAt(strNum.length() - 1), 10);\n\n        return (firstDigit % 2 != 0) && (lastDigit % 2 != 0);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.specialFilter(Arrays.asList(15, -73, 14, -15))); // Expected output: 1\n        System.out.println(solution.specialFilter(Arrays.asList(33, -2, -3, 45, 21, 109))); // Expected output: 2\n        System.out.println(solution.specialFilter(Arrays.asList(-73, 14, 15, -15, 33, 45, 21, 109))); // Expected output: 3\n    }\n}\n"}
{"task_id": "Java/147", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * You are given a positive integer n. You have to create an integer array a of length n.\n     * For each i (1 <= i <= n), the value of a[i] = i * i - i + 1.\n     * Return the number of triples (a[i], a[j], a[k]) of a where i < j < k,\n     * and a[i] + a[j] + a[k] is a multiple of 3.\n     *\n     * Example :\n     * Input: n = 5\n     * Output: 1\n     * Explanation:\n     * a = [1, 3, 7, 13, 21]\n     * The only valid triple is (1, 7, 13).\n     */\n    public int get_max_triples(int n) {\n        List<Integer> a = new ArrayList<>();\n        \n        // Generate the array a\n        for (int i = 1; i <= n; i++) {\n            a.add(i * i - i + 1);\n        }\n        \n        int count = 0;\n        \n        // Iterate through all possible triples (i, j, k) where i < j < k\n        for (int i = 0; i < n - 2; i++) {\n            for (int j = i + 1; j < n - 1; j++) {\n                for (int k = j + 1; k < n; k++) {\n                    if ((a.get(i) + a.get(j) + a.get(k)) % 3 == 0) {\n                        count++;\n                    }\n                }\n            }\n        }\n        \n        return count;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.get_max_triples(5)); // Expected output: 1\n        System.out.println(solution.get_max_triples(6)); // Expected output: 2\n        System.out.println(solution.get_max_triples(7)); // Expected output: 3\n    }\n}\n"}
{"task_id": "Java/148", "generation": "import java.util.*;\n\nclass Solution {\n    public List<String> bf(String planet1, String planet2) {\n        List<String> planets = Arrays.asList(\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\");\n        \n        if (!planets.contains(planet1) || !planets.contains(planet2)) {\n            return new ArrayList<>();\n        }\n        \n        int start = planets.indexOf(planet1);\n        int end = planets.indexOf(planet2);\n        \n        // Ensure the indices are in ascending order\n        if (start > end) {\n            Collections.swap(planets, start, end);\n            start = planets.indexOf(planet1);\n            end = planets.indexOf(planet2);\n        }\n        \n        List<String> result = new ArrayList<>(planets.subList(start + 1, end));\n        return result;\n    }\n}\n"}
{"task_id": "Java/149", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Write a function that accepts a list of strings as a parameter,\n     * deletes the strings that have odd lengths from it,\n     * and returns the resulted list with a sorted order.\n     * The list is always a list of strings and never an array of numbers,\n     * and it may contain duplicates.\n     * The order of the list should be ascending by length of each word, and you\n     * should return the list sorted by that rule.\n     * If two words have the same length, sort the list alphabetically.\n     * The function should return a list of strings in sorted order.\n     * You may assume that all words will have the same length.\n     * For example:\n     * assert sorted_list_sum(Arrays.asList(\"aa\", \"a\", \"aaa\")) => [\"aa\"]\n     * assert sorted_list_sum(Arrays.asList(\"ab\", \"a\", \"aaa\", \"cd\")) => [\"ab\", \"cd\"]\n     */\n    public List<String> sorted_list_sum(List<String> lst) {\n        // Remove strings with odd lengths\n        lst.removeIf(s -> s.length() % 2 != 0);\n\n        // Sort the list by length, then alphabetically if lengths are equal\n        Collections.sort(lst, (s1, s2) -> {\n            int lenCompare = Integer.compare(s1.length(), s2.length());\n            return lenCompare == 0 ? s1.compareTo(s2) : lenCompare;\n        });\n\n        return lst;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        List<String> test1 = Arrays.asList(\"aa\", \"a\", \"aaa\");\n        System.out.println(solution.sorted_list_sum(test1)); // Expected: [aa]\n\n        List<String> test2 = Arrays.asList(\"ab\", \"a\", \"aaa\", \"cd\");\n        System.out.println(solution.sorted_list_sum(test2)); // Expected: [ab, cd]\n\n        List<String> test3 = Arrays.asList(\"hello\", \"world\", \"hi\", \"bye\");\n        System.out.println(solution.sorted_list_sum(test3)); // Expected: [hi, bye]\n    }\n}\n"}
{"task_id": "Java/150", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * A simple program which should return the value of x if n is\n     * a prime number and should return the value of y otherwise.\n     *\n     * Examples:\n     * for x_or_y(7, 34, 12) == 34\n     * for x_or_y(15, 8, 5) == 5\n     */\n    public int x_or_y(int n, int x, int y) {\n        if (isPrime(n)) {\n            return x;\n        } else {\n            return y;\n        }\n    }\n\n    /**\n     * Helper method to check if a number is prime.\n     *\n     * @param num the number to check\n     * @return true if the number is prime, false otherwise\n     */\n    private boolean isPrime(int num) {\n        if (num <= 1) return false;\n        for (int i = 2; i <= Math.sqrt(num); i++) {\n            if (num % i == 0) return false;\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.x_or_y(7, 34, 12)); // Expected output: 34 (since 7 is prime)\n        System.out.println(solution.x_or_y(15, 8, 5));  // Expected output: 5 (since 15 is not prime)\n        System.out.println(solution.x_or_y(2, 10, 20)); // Expected output: 10 (since 2 is prime)\n        System.out.println(solution.x_or_y(4, 30, 40)); // Expected output: 40 (since 4 is not prime)\n    }\n}\n"}
{"task_id": "Java/151", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     Given a list of numbers, return the sum of squares of the numbers\n     in the list that are odd. Ignore numbers that are negative or not integers.\n     */\n    public int double_the_difference(List<Object> lst) {\n        int result = 0;\n        for (Object obj : lst) {\n            if (obj instanceof Integer) {\n                int num = (Integer) obj;\n                if (num > 0 && num % 2 != 0) {\n                    result += num * num;\n                }\n            }\n        }\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.double_the_difference(Arrays.asList(1, 3, 2, 0))); // Expected output: 10\n        System.out.println(solution.double_the_difference(Arrays.asList(-1, -2, 0))); // Expected output: 0\n        System.out.println(solution.double_the_difference(Arrays.asList(9, -2)));      // Expected output: 81\n        System.out.println(solution.double_the_difference(Arrays.asList(0)));          // Expected output: 0\n        System.out.println(solution.double_the_difference(new ArrayList<>()));         // Expected output: 0\n    }\n}\n"}
{"task_id": "Java/152", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Compares the game scores with the guesses and returns an array of how far off each guess was.\n     *\n     * @param game  A list of integers representing the actual game scores.\n     * @param guess A list of integers representing the guessed scores.\n     * @return A list of integers where each element is the absolute difference between the guess and the score, or 0 if they are equal.\n     */\n    public List<Integer> compare(List<Integer> game, List<Integer> guess) {\n        List<Integer> result = new ArrayList<>();\n        for (int i = 0; i < game.size(); i++) {\n            int diff = Math.abs(game.get(i) - guess.get(i));\n            result.add(diff);\n        }\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        List<Integer> test1Game = Arrays.asList(1, 2, 3, 4, 5, 1);\n        List<Integer> test1Guess = Arrays.asList(1, 2, 3, 4, 2, -2);\n        System.out.println(solution.compare(test1Game, test1Guess)); // Expected: [0, 0, 0, 0, 3, 3]\n\n        List<Integer> test2Game = Arrays.asList(0, 5, 0, 0, 0, 4);\n        List<Integer> test2Guess = Arrays.asList(4, 1, 1, 0, 0, -2);\n        System.out.println(solution.compare(test2Game, test2Guess)); // Expected: [4, 4, 1, 0, 0, 6]\n    }\n}\n"}
{"task_id": "Java/153", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * You will be given the name of a class (a string) and a list of extensions.\n     * The extensions are to be used to load additional classes to the class. The\n     * strength of the extension is as follows: Let CAP be the number of the uppercase\n     * letters in the extension's name, and let SM be the number of lowercase letters\n     * in the extension's name, the strength is given by the fraction CAP - SM.\n     * You should find the strongest extension and return a string in this\n     * format: ClassName.Strongest_Extension.\n     * If there are two or more extensions with the same strength, you should\n     * choose the one that comes first in the list.\n     * For example, if you are given \"Slices\" as the class and a list of the\n     * extensions: [\"SErviNGSliCes\", \"Cheese\", \"StuFfed\"] then you should\n     * return \"Slices.SErviNGSliCes\" since \"SErviNGSliCes\" is the strongest extension\n     * (its strength is -1).\n     * Example:\n     * for Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"]) == \"my_class.AA\"\n     */\n    public String Strongest_Extension(String class_name, List<String> extensions) {\n        int maxStrength = Integer.MIN_VALUE;\n        String strongestExtension = \"\";\n        \n        for (String extension : extensions) {\n            int cap = 0, sm = 0;\n            for (char c : extension.toCharArray()) {\n                if (Character.isUpperCase(c)) {\n                    cap++;\n                } else if (Character.isLowerCase(c)) {\n                    sm++;\n                }\n            }\n            \n            int strength = cap - sm;\n            if (strength > maxStrength) {\n                maxStrength = strength;\n                strongestExtension = extension;\n            }\n        }\n        \n        return class_name + \".\" + strongestExtension;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.Strongest_Extension(\"Slices\", Arrays.asList(\"SErviNGSliCes\", \"Cheese\", \"StuFfed\"))); // Should print: Slices.SErviNGSliCes\n        System.out.println(solution.Strongest_Extension(\"my_class\", Arrays.asList(\"AA\", \"Be\", \"CC\"))); // Should print: my_class.AA\n        System.out.println(solution.Strongest_Extension(\"DataProcessor\", Arrays.asList(\"dataIO\", \"DATAIO\", \"dataio\"))); // Should print: DataProcessor.DATAIO\n    }\n}\n"}
{"task_id": "Java/154", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * You are given 2 words. You need to return true if the second word or any of its rotations is a substring in the first word.\n     * cycpattern_check(\"abcd\",\"abd\") => false\n     * cycpattern_check(\"hello\",\"ell\") => true\n     * cycpattern_check(\"whassup\",\"psus\") => false\n     * cycpattern_check(\"abab\",\"baa\") => true\n     * cycpattern_check(\"efef\",\"eeff\") => false\n     * cycpattern_check(\"himenss\",\"simen\") => true\n     */\n    public boolean cycpattern_check(String a, String b) {\n        if (b.length() > a.length()) {\n            return false;\n        }\n        \n        // Generate all rotations of the second word\n        for (int i = 0; i < b.length(); i++) {\n            String rotated = rotateString(b, i);\n            if (a.contains(rotated)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private String rotateString(String s, int k) {\n        int n = s.length();\n        k = k % n; // In case the rotation is greater than the length of the string\n        return s.substring(n - k) + s.substring(0, n - k);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.cycpattern_check(\"abcd\", \"abd\")); // false\n        System.out.println(solution.cycpattern_check(\"hello\", \"ell\")); // true\n        System.out.println(solution.cycpattern_check(\"whassup\", \"psus\")); // false\n        System.out.println(solution.cycpattern_check(\"abab\", \"baa\")); // true\n        System.out.println(solution.cycpattern_check(\"efef\", \"eeff\")); // false\n        System.out.println(solution.cycpattern_check(\"himenss\", \"simen\")); // true\n    }\n}\n"}
{"task_id": "Java/155", "generation": "import java.util.*;\n\nclass Solution {\n    public List<Integer> even_odd_count(int num) {\n        int evenCount = 0;\n        int oddCount = 0;\n\n        // Convert number to string and iterate through each digit\n        String strNum = Integer.toString(Math.abs(num));\n        for (int i = 0; i < strNum.length(); i++) {\n            char digit = strNum.charAt(i);\n            if ((digit - '0') % 2 == 0) {\n                evenCount++;\n            } else {\n                oddCount++;\n            }\n        }\n\n        // Create and return a list with the counts of even and odd digits\n        List<Integer> result = new ArrayList<>();\n        result.add(evenCount);\n        result.add(oddCount);\n\n        return result;\n    }\n}\n"}
{"task_id": "Java/156", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     Given a positive integer, obtain its roman numeral equivalent as a string,\n     and return it in lowercase.\n     Restrictions: 1 <= num <= 1000\n\n     Examples:\n     >>> int_to_mini_roman(19) == \"xix\"\n     >>> int_to_mini_roman(152) == \"clii\"\n     >>> int_to_mini_roman(426) == \"cdxxvi\"\n     */\n    public String int_to_mini_roman(int number) {\n        // Define the Roman numeral symbols and their corresponding values\n        List<Map.Entry<Integer, String>> romanNumerals = Arrays.asList(\n            Map.entry(1000, \"m\"), \n            Map.entry(900, \"cm\"), \n            Map.entry(500, \"d\"), \n            Map.entry(400, \"cd\"), \n            Map.entry(100, \"c\"), \n            Map.entry(90, \"xc\"), \n            Map.entry(50, \"l\"), \n            Map.entry(40, \"xl\"), \n            Map.entry(10, \"x\"), \n            Map.entry(9, \"ix\"), \n            Map.entry(5, \"v\"), \n            Map.entry(4, \"iv\"), \n            Map.entry(1, \"i\")\n        );\n\n        // Initialize the result string\n        StringBuilder romanString = new StringBuilder();\n\n        // Iterate through the Roman numeral symbols and values in descending order\n        for (Map.Entry<Integer, String> entry : romanNumerals) {\n            while (number >= entry.getKey()) {\n                romanString.append(entry.getValue());\n                number -= entry.getKey();\n            }\n        }\n\n        // Return the result string in lowercase\n        return romanString.toString().toLowerCase();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.int_to_mini_roman(19));  // Output: \"xix\"\n        System.out.println(solution.int_to_mini_roman(152)); // Output: \"clii\"\n        System.out.println(solution.int_to_mini_roman(426)); // Output: \"cdxxvi\"\n    }\n}\n"}
{"task_id": "Java/157", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given the lengths of the three sides of a triangle. Return true if the three\n     * sides form a right-angled triangle, false otherwise.\n     * A right-angled triangle is a triangle in which one angle is a right angle or 90 degrees.\n     * Example:\n     * right_angle_triangle(3, 4, 5) == true\n     * right_angle_triangle(1, 2, 3) == false\n     */\n    public boolean right_angle_triangle(int a, int b, int c) {\n        // Sort the sides to ensure the longest side is last\n        int[] sides = {a, b, c};\n        Arrays.sort(sides);\n        \n        // Check if the square of the longest side equals the sum of squares of other two sides\n        return Math.pow(sides[0], 2) + Math.pow(sides[1], 2) == Math.pow(sides[2], 2);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.right_angle_triangle(3, 4, 5)); // true\n        System.out.println(solution.right_angle_triangle(1, 2, 3)); // false\n        System.out.println(solution.right_angle_triangle(5, 12, 13)); // true\n        System.out.println(solution.right_angle_triangle(6, 8, 10)); // true\n        System.out.println(solution.right_angle_triangle(7, 10, 12)); // false\n    }\n}\n"}
{"task_id": "Java/158", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Write a function that accepts a list of strings.\n     * The list contains different words. Return the word with maximum number\n     * of unique characters. If multiple strings have maximum number of unique\n     * characters, return the one which comes first in lexicographical order.\n     *\n     * find_max([\"name\", \"of\", \"string\"]) == \"string\"\n     * find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n     * find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"aaaaaaa\"\n     */\n    public String find_max(List<String> words) {\n        if (words == null || words.isEmpty()) {\n            return \"\";\n        }\n\n        // Sort the list lexicographically\n        Collections.sort(words);\n\n        String maxWord = \"\";\n        int maxUniqueChars = 0;\n\n        for (String word : words) {\n            Set<Character> uniqueChars = new HashSet<>();\n            for (char c : word.toCharArray()) {\n                uniqueChars.add(c);\n            }\n\n            if (uniqueChars.size() > maxUniqueChars) {\n                maxUniqueChars = uniqueChars.size();\n                maxWord = word;\n            }\n        }\n\n        return maxWord;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.find_max(Arrays.asList(\"name\", \"of\", \"string\"))); // Output: string\n        System.out.println(solution.find_max(Arrays.asList(\"name\", \"enam\", \"game\"))); // Output: enam\n        System.out.println(solution.find_max(Arrays.asList(\"aaaaaaa\", \"bb\", \"cc\")));  // Output: aaaaaaa\n        System.out.println(solution.find_max(new ArrayList<>()));                     // Output: (empty string)\n        System.out.println(solution.find_max(Arrays.asList(\"abc\", \"defg\", \"hijk\")));  // Output: defg\n    }\n}\n"}
{"task_id": "Java/159", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * You're a hungry rabbit, and you already have eaten a certain number of carrots,\n     * but now you need to eat more carrots to complete the day's meals.\n     * return an array of [ total number of eaten carrots after your meals,\n     *                     the number of carrots left after your meals ]\n     * if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n     *\n     * Example:\n     * * eat(5, 6, 10) -> [11, 4]\n     * * eat(4, 8, 9) -> [12, 1]\n     * * eat(1, 10, 10) -> [11, 0]\n     * * eat(2, 11, 5) -> [7, 0]\n     *\n     * Variables:\n     * @number : integer\n     *        the number of carrots that you have eaten.\n     * @need : integer\n     *        the number of carrots that you need to eat.\n     * @remaining : integer\n     *        the number of remaining carrots thet exist in stock\n     *\n     * Constrain:\n     * * 0 <= number <= 1000\n     * * 0 <= need <= 1000\n     * * 0 <= remaining <= 1000\n     */\n    public List<Integer> eat(int number, int need, int remaining) {\n        // Calculate the total number of carrots to be eaten\n        int totalToEat = Math.min(need, remaining);\n        \n        // Update the number of carrots eaten and remaining\n        int newNumberEaten = number + totalToEat;\n        int newRemainingCarrots = remaining - totalToEat;\n\n        return Arrays.asList(newNumberEaten, newRemainingCarrots);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.eat(5, 6, 10)); // Expected: [11, 4]\n        System.out.println(solution.eat(4, 8, 9));  // Expected: [12, 1]\n        System.out.println(solution.eat(1, 10, 10)); // Expected: [11, 0]\n        System.out.println(solution.eat(2, 11, 5));  // Expected: [7, 0]\n    }\n}\n"}
{"task_id": "Java/160", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int do_algebra(List<String> operator, List<Integer> operand) {\n        StringBuilder expression = new StringBuilder();\n        expression.append(operand.get(0));\n        \n        for (int i = 0; i < operator.size(); i++) {\n            expression.append(\" \").append(operator.get(i)).append(\" \").append(operand.get(i + 1));\n        }\n        \n        return eval(expression.toString());\n    }\n\n    private int eval(String expression) {\n        // Since Java does not have a built-in eval function, we need to parse and evaluate the expression manually.\n        // This is a simplified version for demonstration purposes. In practice, you would use a library like JEP or write a custom parser.\n        String[] parts = expression.split(\" \");\n        int result = parts[0].equals(\"\") ? 0 : Integer.parseInt(parts[0]);\n        \n        for (int i = 1; i < parts.length - 2; i += 3) {\n            String op = parts[i + 1];\n            int num = Integer.parseInt(parts[i + 2]);\n            \n            switch (op) {\n                case \"+\":\n                    result += num;\n                    break;\n                case \"-\":\n                    result -= num;\n                    break;\n                case \"*\":\n                    result *= num;\n                    break;\n                case \"/\":\n                    result /= num;\n                    break;\n                case \"**\":\n                    result = (int) Math.pow(result, num);\n                    break;\n            }\n        }\n        \n        return result;\n    }\n}\n"}
{"task_id": "Java/161", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * You are given a string s.\n     * if s[i] is a letter, reverse its case from lower to upper or vise versa,\n     * otherwise keep it as it is.\n     * If the string contains no letters, reverse the string.\n     * The function should return the resulted string.\n     * Examples\n     * solve(\"1234\") = \"4321\"\n     * solve(\"ab\") = \"AB\"\n     * solve(\"#a@C\") = \"#A@c\"\n     */\n    public String solve(String s) {\n        if (s == null || s.isEmpty()) {\n            return s;\n        }\n\n        boolean containsLetters = false;\n        StringBuilder result = new StringBuilder();\n\n        for (char c : s.toCharArray()) {\n            if (Character.isLetter(c)) {\n                containsLetters = true;\n                result.append(Character.isLowerCase(c) ? Character.toUpperCase(c) : Character.toLowerCase(c));\n            } else {\n                result.append(c);\n            }\n        }\n\n        return containsLetters ? result.toString() : new StringBuilder(s).reverse().toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.solve(\"1234\"));  // Expected: \"4321\"\n        System.out.println(solution.solve(\"ab\"));    // Expected: \"AB\"\n        System.out.println(solution.solve(\"#a@C\"));  // Expected: \"#A@c\"\n        System.out.println(solution.solve(\"\"));      // Expected: \"\"\n        System.out.println(solution.solve(\"123!@#\")); // Expected: \"#@!321\"\n        System.out.println(solution.solve(\"Hello World!\")); // Expected: \"hELLO wORLD!\"\n    }\n}\n"}
{"task_id": "Java/162", "generation": "import java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.Optional;\n\nclass Solution {\n    /**\n     Given a string \"text\", return its md5 hash equivalent string with length being 32.\n     If \"text\" is an empty string, return Optional.empty().\n     */\n    public Optional<String> string_to_md5(String text) throws NoSuchAlgorithmException {\n        if (text.isEmpty()) {\n            return Optional.empty();\n        }\n\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        byte[] messageDigest = md.digest(text.getBytes());\n        BigInteger no = new BigInteger(1, messageDigest);\n\n        // Convert message digest into hex value\n        String hashtext = no.toString(16);\n        while (hashtext.length() < 32) {\n            hashtext = \"0\" + hashtext;\n        }\n        return Optional.of(hashtext);\n    }\n\n    public static void main(String[] args) throws NoSuchAlgorithmException {\n        Solution solution = new Solution();\n        System.out.println(solution.string_to_md5(\"Hello world\")); // Should print: 3e25960a79dbc69b674cd4ec6d5fb8d\n    }\n}\n"}
{"task_id": "Java/163", "generation": "import java.util.List;\n\nclass Solution {\n\n    /**\n     * Given two positive integers a and b, return the even digits between a\n     * and b, in ascending order.\n     *\n     * @param a the lower bound (inclusive)\n     * @param b the upper bound (inclusive)\n     * @return a List of Integer containing even digits between a and b\n     */\n    public List<Integer> generate_integers(int a, int b) {\n        List<Integer> result = new ArrayList<>();\n        \n        // Ensure a is less than or equal to b for simplicity in iteration\n        if (a > b) {\n            int temp = a;\n            a = b;\n            b = temp;\n        }\n        \n        for (int i = a; i <= b; i++) {\n            if (i % 2 == 0 && i < 10) {\n                result.add(i);\n            }\n        }\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(\"generate_integers(2, 8): \" + solution.generate_integers(2, 8)); // [2, 4, 6, 8]\n        System.out.println(\"generate_integers(8, 2): \" + solution.generate_integers(8, 2)); // [2, 4, 6, 8]\n        System.out.println(\"generate_integers(10, 14): \" + solution.generate_integers(10, 14)); // []\n        System.out.println(\"generate_integers(1, 5): \" + solution.generate_integers(1, 5)); // [2, 4]\n        System.out.println(\"generate_integers(3, 7): \" + solution.generate_integers(3, 7)); // [4, 6]\n    }\n}\n"}
