{"task_id": "CPP/0", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // For std::sort\n\nbool has_close_elements(const std::vector<float>& numbers, float threshold) {\n    // Sort the vector first\n    std::vector<float> sorted_numbers = numbers;\n    std::sort(sorted_numbers.begin(), sorted_numbers.end());\n\n    // Check adjacent elements in the sorted vector\n    for (size_t i = 0; i < sorted_numbers.size() - 1; ++i) {\n        if (sorted_numbers[i + 1] - sorted_numbers[i] < threshold) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\n"}
{"task_id": "CPP/1", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> separate_paren_groups(string paren_string) {\n    // Remove all spaces from the input string\n    paren_string.erase(remove_if(paren_string.begin(), paren_string.end(), isspace), paren_string.end());\n    \n    vector<string> result;\n    stack<int> parentheses_stack;\n    int start_index = 0;\n\n    for (int i = 0; i < paren_string.length(); ++i) {\n        if (paren_string[i] == '(') {\n            // Push the index of the opening parenthesis onto the stack\n            parentheses_stack.push(i);\n        } else if (paren_string[i] == ')') {\n            // Pop from the stack when a closing parenthesis is found\n            if (!parentheses_stack.empty()) {\n                parentheses_stack.pop();\n            }\n            \n            // If the stack is empty, we have completed a group\n            if (parentheses_stack.empty()) {\n                result.push_back(paren_string.substr(start_index, i - start_index + 1));\n                start_index = i + 1;\n            }\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/2", "generation": "#include <stdio.h>\n#include <math.h>\n\nfloat truncate_number(float number) {\n    float integerPart;\n    modf(number, &integerPart); // modf returns the fractional part and stores the integer part in `integerPart`\n    return number - integerPart; // Subtracting the integer part from the original number gives the decimal part\n}\n\n"}
{"task_id": "CPP/3", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool below_zero(const vector<int>& operations) {\n    int balance = 0; // Start with a zero balance\n\n    for (int op : operations) {\n        balance += op; // Update the balance after each operation\n        \n        if (balance < 0) {\n            return true; // Return true if balance falls below zero\n        }\n    }\n\n    return false; // Return false if balance never goes below zero\n}\n\n// Function to test the below_zero function with provided examples\nvoid check() {\n    vector<int> operations1 = {1, 2, 3};\n    vector<int> operations2 = {1, 2, -4, 5};\n\n    cout << \"Test Case 1: \" << (below_zero(operations1) ? \"true\" : \"false\") << endl;\n    cout << \"Test Case 2: \" << (below_zero(operations2) ? \"true\" : \"false\") << endl;\n}\n\n"}
{"task_id": "CPP/4", "generation": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nfloat mean_absolute_deviation(vector<float> numbers) {\n    // Step 1: Calculate the mean of the dataset\n    float sum = 0.0;\n    for (float num : numbers) {\n        sum += num;\n    }\n    float mean = sum / numbers.size();\n\n    // Step 2: Compute the absolute differences between each element and the mean\n    float mad_sum = 0.0;\n    for (float num : numbers) {\n        mad_sum += abs(num - mean);\n    }\n\n    // Step 3: Calculate the average of these absolute differences\n    return mad_sum / numbers.size();\n}\n\n// Function to test the mean_absolute_deviation function\nvoid test_mean_absolute_deviation() {\n    vector<float> data = {1.0, 2.0, 3.0, 4.0};\n    float result = mean_absolute_deviation(data);\n    cout << \"Mean Absolute Deviation: \" << result << endl;\n}\n\n"}
{"task_id": "CPP/5", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> intersperse(vector<int> numbers, int delimeter) {\n    vector<int> result;\n    \n    // Iterate through the input vector\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        // Insert current element into the result vector\n        result.push_back(numbers[i]);\n        \n        // If it's not the last element, insert the delimiter\n        if (i != numbers.size() - 1) {\n            result.push_back(delimeter);\n        }\n    }\n    \n    return result;\n}\n\n// Function to print the vector for testing purposes\nvoid printVector(const vector<int>& vec) {\n    for (int num : vec) {\n        cout << num << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/6", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to parse a single group of nested parentheses and return its deepest level of nesting.\nint max_depth_of_parens(const string& paren_group) {\n    int current_depth = 0;\n    int max_depth = 0;\n    \n    for (char ch : paren_group) {\n        if (ch == '(') {\n            current_depth++;\n            max_depth = max(max_depth, current_depth);\n        } else if (ch == ')') {\n            current_depth--;\n        }\n    }\n    \n    return max_depth;\n}\n\n// Function to parse multiple groups of nested parentheses separated by spaces.\nvector<int> parse_nested_parens(string paren_string) {\n    vector<int> depths;\n    string group;\n    \n    // Split the input string into individual groups\n    for (char ch : paren_string) {\n        if (ch == ' ') {\n            if (!group.empty()) {\n                depths.push_back(max_depth_of_parens(group));\n                group.clear();\n            }\n        } else {\n            group += ch;\n        }\n    }\n    \n    // Process the last group in case there is no trailing space\n    if (!group.empty()) {\n        depths.push_back(max_depth_of_parens(group));\n    }\n    \n    return depths;\n}\n\n"}
{"task_id": "CPP/7", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> filter_by_substring(vector<string> strings, string substring) {\n    vector<string> filteredStrings;\n    \n    // Iterate through each string in the input vector\n    for (const auto& str : strings) {\n        // Check if the current string contains the given substring\n        if (str.find(substring) != string::npos) {\n            // If it does, add it to the filtered list\n            filteredStrings.push_back(str);\n        }\n    }\n    \n    return filteredStrings;\n}\n\n// Function to test the filter_by_substring function\nvoid test_filter_by_substring() {\n    vector<string> input1 = {};\n    vector<string> expected1 = {};\n    assert(filter_by_substring(input1, \"a\") == expected1);\n\n    vector<string> input2 = {\"abc\", \"bacd\", \"cde\", \"vector\"};\n    vector<string> expected2 = {\"abc\", \"bacd\", \"vector\"};\n    assert(filter_by_substring(input2, \"a\") == expected2);\n\n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/8", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> sum_product(vector<int> numbers) {\n    int sum = 0;\n    int product = 1;\n\n    // Iterate through each number in the vector\n    for (int num : numbers) {\n        sum += num;  // Add the current number to the sum\n        if (num != 0) {  // Avoid division by zero when calculating product\n            product *= num;\n        }\n    }\n\n    return {sum, product};\n}\n\n// Function to print the result for verification\nvoid print_result(const vector<int>& result) {\n    cout << \"(\" << result[0] << \", \" << result[1] << \")\" << endl;\n}\n\n"}
{"task_id": "CPP/9", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvector<int> rolling_max(vector<int> numbers) {\n    vector<int> result;\n    if (numbers.empty()) return result;  // Return an empty vector if input is empty\n\n    int max_so_far = numbers[0];  // Initialize with the first element\n    for (int num : numbers) {\n        if (num > max_so_far) {\n            max_so_far = num;  // Update max_so_far if current number is greater\n        }\n        result.push_back(max_so_far);  // Add the current maximum to the result vector\n    }\n\n    return result;\n}\n\n// Function to print a vector of integers\nvoid print_vector(const vector<int>& vec) {\n    for (int num : vec) {\n        cout << num << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/10", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_palindrome(const string& str) {\n    // Test if given string is a palindrome\n    return str == string(str.rbegin(), str.rend());\n}\n\nstring make_palindrome(string str) {\n    /*\n    Find the shortest palindrome that begins with a supplied string. \n    Algorithm idea is simple: - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    */\n    \n    // Start from the end of the string and move towards the beginning\n    for (int i = str.length(); i > 0; --i) {\n        if (is_palindrome(str.substr(0, i))) {\n            // Found the longest palindromic prefix\n            break;\n        }\n    }\n\n    // If no palindromic suffix is found, it means the entire string is a palindrome\n    if (i == str.length()) {\n        return str;\n    }\n\n    // Calculate the prefix to be reversed and appended\n    string prefix = str.substr(0, i);\n    reverse(prefix.begin(), prefix.end());\n\n    // Append the reversed prefix to the original string\n    return str + prefix;\n}\n\n"}
{"task_id": "CPP/11", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring string_xor(string a, string b) {\n    // Ensure both strings are of the same length\n    if (a.length() != b.length()) {\n        cout << \"Error: Input strings must be of equal length.\" << endl;\n        return \"\";\n    }\n\n    string result = \"\";  // Initialize an empty string to store the result\n\n    // Perform XOR on each bit and append the result to 'result'\n    for (size_t i = 0; i < a.length(); ++i) {\n        if (a[i] == b[i]) {\n            result += \"0\";  // If bits are the same, append '0'\n        } else {\n            result += \"1\";  // If bits are different, append '1'\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/12", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring longest(vector<string> strings) {\n    if (strings.empty()) {\n        return \"None\"; // Return \"None\" for an empty vector\n    }\n\n    string longestString = strings[0]; // Assume the first string is the longest\n\n    for (const auto& str : strings) {\n        if (str.length() > longestString.length()) {\n            longestString = str; // Update the longest string if a longer one is found\n        }\n    }\n\n    return longestString;\n}\n\n"}
{"task_id": "CPP/13", "generation": "#include <stdio.h>\nusing namespace std;\n\nint greatest_common_divisor(int a, int b) {\n    // Ensure a >= b\n    if (a < b) {\n        swap(a, b);\n    }\n\n    // Apply Euclidean algorithm\n    while (b != 0) {\n        int temp = b;\n        b = a % b;\n        a = temp;\n    }\n\n    return a;\n}\n\n"}
{"task_id": "CPP/14", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> all_prefixes(const string& str) {\n    vector<string> prefixes;\n    for (size_t i = 1; i <= str.length(); ++i) {\n        prefixes.push_back(str.substr(0, i));\n    }\n    return prefixes;\n}\n\n"}
{"task_id": "CPP/15", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring string_sequence(int n) {\n    if (n < 0) return \"\"; // Handle negative input gracefully\n\n    string result = \"\";\n    for (int i = 0; i <= n; ++i) {\n        result += to_string(i);\n        if (i != n) {\n            result += \" \";\n        }\n    }\n\n    return result;\n}\n\n// Example usage\n"}
{"task_id": "CPP/16", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm> // For std::tolower\n\nusing namespace std;\n\nint count_distinct_characters(string str) {\n    // Convert the string to lowercase to ignore case sensitivity\n    transform(str.begin(), str.end(), str.begin(), ::tolower);\n\n    // Use a set to store distinct characters\n    std::set<char> distinct_chars;\n\n    // Iterate through each character in the string and add it to the set\n    for (char ch : str) {\n        distinct_chars.insert(ch);\n    }\n\n    // The size of the set is the number of distinct characters\n    return distinct_chars.size();\n}\n\n"}
{"task_id": "CPP/17", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<int> parse_music(string music_string) {\n    vector<int> beats;\n    \n    // Iterate through the string and process each character\n    for (size_t i = 0; i < music_string.length(); ) {\n        if (music_string[i] == 'o') { // Whole note\n            beats.push_back(4);\n            i += 1;\n        } else if (music_string[i] == 'o' && i + 1 < music_string.length() && music_string[i + 1] == '|') { // Half note\n            beats.push_back(2);\n            i += 2;\n        } else if (music_string[i] == '.' && i + 1 < music_string.length() && music_string[i + 1] == '|') { // Quarter note\n            beats.push_back(1);\n            i += 2;\n        }\n    }\n\n    return beats;\n}\n\n"}
{"task_id": "CPP/18", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint how_many_times(string str, string substring) {\n    int count = 0;\n    size_t pos = 0;\n\n    // Loop through the original string to find all occurrences of the substring\n    while ((pos = str.find(substring, pos)) != string::npos) {\n        count++;\n        pos++; // Move one character forward to allow for overlapping matches\n    }\n\n    return count;\n}\n\n"}
{"task_id": "CPP/19", "generation": "#include <iostream>\n#include <string>\n#include <map>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to convert string to integer based on mapping\nint word_to_num(const string& word) {\n    map<string, int> num_map = {{\"zero\", 0}, {\"one\", 1}, {\"two\", 2}, {\"three\", 3},\n                                {\"four\", 4}, {\"five\", 5}, {\"six\", 6}, {\"seven\", 7},\n                                {\"eight\", 8}, {\"nine\", 9}};\n    return num_map[word];\n}\n\n// Function to convert integer back to string\nstring num_to_word(int num) {\n    map<int, string> num_map = {{0, \"zero\"}, {1, \"one\"}, {2, \"two\"}, {3, \"three\"},\n                                {4, \"four\"}, {5, \"five\"}, {6, \"six\"}, {7, \"seven\"},\n                                {8, \"eight\"}, {9, \"nine\"}};\n    return num_map[num];\n}\n\nstring sort_numbers(const string& numbers) {\n    // Split the input string into words\n    vector<string> words;\n    string current_word = \"\";\n    for (char ch : numbers) {\n        if (ch == ' ') {\n            words.push_back(current_word);\n            current_word = \"\";\n        } else {\n            current_word += ch;\n        }\n    }\n    if (!current_word.empty()) {\n        words.push_back(current_word);\n    }\n\n    // Convert each word to its corresponding number\n    vector<int> nums;\n    for (const string& word : words) {\n        nums.push_back(word_to_num(word));\n    }\n\n    // Sort the numbers\n    sort(nums.begin(), nums.end());\n\n    // Convert sorted numbers back to words\n    string result = \"\";\n    for (int num : nums) {\n        if (!result.empty()) {\n            result += \" \";\n        }\n        result += num_to_word(num);\n    }\n\n    return result;\n}\n\n// Function to test the sort_numbers function\nvoid test_sort_numbers() {\n    assert(sort_numbers(\"three one five\") == \"one three five\");\n    assert(sort_numbers(\"nine eight seven six\") == \"six seven eight nine\");\n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/20", "generation": "#include <iostream>\n#include <cmath>\n#include <vector>\n\nusing namespace std;\n\npair<float, float> find_closest_elements(vector<float> numbers) {\n    if (numbers.size() < 2) {\n        throw invalid_argument(\"The vector must contain at least two elements.\");\n    }\n\n    // Initialize the first pair of closest elements\n    float min_diff = abs(numbers[1] - numbers[0]);\n    float closest_pair[2] = {numbers[0], numbers[1]};\n\n    // Iterate through the vector starting from the second element\n    for (size_t i = 1; i < numbers.size() - 1; ++i) {\n        float current_diff = abs(numbers[i + 1] - numbers[i]);\n        if (current_diff < min_diff) {\n            min_diff = current_diff;\n            closest_pair[0] = min(numbers[i], numbers[i + 1]);\n            closest_pair[1] = max(numbers[i], numbers[i + 1]);\n        }\n    }\n\n    return make_pair(closest_pair[0], closest_pair[1]);\n}\n\n"}
{"task_id": "CPP/21", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // For std::min_element and std::max_element\n\nusing namespace std;\n\nvector<float> rescale_to_unit(vector<float> numbers) {\n    if (numbers.size() < 2) {\n        throw invalid_argument(\"Vector must contain at least two elements.\");\n    }\n\n    float min_value = *std::min_element(numbers.begin(), numbers.end());\n    float max_value = *std::max_element(numbers.begin(), numbers.end());\n\n    vector<float> scaled_numbers;\n    for (float num : numbers) {\n        float new_value = (num - min_value) / (max_value - min_value);\n        scaled_numbers.push_back(new_value);\n    }\n\n    return scaled_numbers;\n}\n\n"}
{"task_id": "CPP/22", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <list>\n#include <boost/any.hpp>\n\ntypedef std::list<boost::any> list_any;\nusing namespace std;\n\nvector<int> filter_integers(list_any values) {\n    vector<int> result;\n    for (const auto& value : values) {\n        if (value.type() == typeid(int)) {\n            result.push_back(boost::any_cast<int>(value));\n        }\n    }\n    return result;\n}\n\n// Test cases\n"}
{"task_id": "CPP/23", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\n// Function to calculate the length of a string\nint strlen(const string& str) {\n    return str.length();\n}\n\n"}
{"task_id": "CPP/24", "generation": "#include <iostream>\nusing namespace std;\n\nint largest_divisor(int n) {\n    for (int i = n - 1; i > 0; --i) {\n        if (n % i == 0) {\n            return i;\n        }\n    }\n    // If no divisor is found, which should not happen for positive integers,\n    // we can return a default value or throw an exception.\n    return 1; // This line will never be reached for valid inputs\n}\n\n"}
{"task_id": "CPP/25", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> factorize(int n) {\n    vector<int> factors;\n    \n    // Divide by 2 as many times as possible\n    while (n % 2 == 0) {\n        factors.push_back(2);\n        n /= 2;\n    }\n    \n    // Check for odd factors from 3 to sqrt(n)\n    for (int i = 3; i * i <= n; i += 2) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n    \n    // If n is a prime number greater than 2\n    if (n > 2) {\n        factors.push_back(n);\n    }\n    \n    return factors;\n}\n\n// Example usage:\n"}
{"task_id": "CPP/26", "generation": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nvector<int> remove_duplicates(vector<int> numbers) {\n    // Create a map to count occurrences of each element\n    unordered_map<int, int> counts;\n    \n    // Count the occurrences of each number in the vector\n    for (int num : numbers) {\n        counts[num]++;\n    }\n    \n    // Reserve space in the result vector to improve performance\n    vector<int> result;\n    result.reserve(numbers.size());\n    \n    // Iterate through the original vector and add elements that occur exactly once\n    for (int num : numbers) {\n        if (counts[num] == 1) {\n            result.push_back(num);\n        }\n    }\n    \n    return result;\n}\n\n// Function to check the correctness of the remove_duplicates function\nvoid check() {\n    vector<int> input = {1, 2, 3, 2, 4};\n    vector<int> expected_output = {1, 3, 4};\n    vector<int> output = remove_duplicates(input);\n    \n    if (output == expected_output) {\n        cout << \"Test passed.\" << endl;\n    } else {\n        cout << \"Test failed.\" << endl;\n    }\n}\n\n"}
{"task_id": "CPP/27", "generation": "#include <iostream>\n#include <string>\n#include <cctype>  // For tolower and toupper functions\n\nusing namespace std;\n\nstring flip_case(string str) {\n    for (char &c : str) {\n        if (isupper(c)) {\n            c = tolower(c);\n        } else if (islower(c)) {\n            c = toupper(c);\n        }\n    }\n    return str;\n}\n\n"}
{"task_id": "CPP/28", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <numeric> // For std::accumulate\n\nusing namespace std;\n\nstring concatenate(vector<string> strings) {\n    return accumulate(strings.begin(), strings.end(), string(\"\"));\n}\n\n"}
{"task_id": "CPP/29", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> filter_by_prefix(vector<string> strings, string prefix) {\n    vector<string> filtered_strings;\n    \n    // Iterate through each string in the input vector\n    for (const auto& str : strings) {\n        // Check if the string starts with the given prefix\n        if (str.substr(0, prefix.length()) == prefix) {\n            // If it does, add it to the result vector\n            filtered_strings.push_back(str);\n        }\n    }\n    \n    return filtered_strings;\n}\n\n// Function to test the filter_by_prefix function\nvoid test_filter_by_prefix() {\n    vector<string> input1 = {};\n    string prefix1 = \"a\";\n    vector<string> expected1 = {};\n    assert(filter_by_prefix(input1, prefix1) == expected1);\n\n    vector<string> input2 = {\"abc\", \"bcd\", \"cde\", \"vector\"};\n    string prefix2 = \"a\";\n    vector<string> expected2 = {\"abc\", \"vector\"};\n    assert(filter_by_prefix(input2, prefix2) == expected2);\n\n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/30", "generation": "#include <iostream>\n#include <vector>\n\n// Function to return only positive numbers in the vector.\nstd::vector<float> get_positive(const std::vector<float>& l) {\n    std::vector<float> result;\n    \n    // Iterate through each element in the input vector\n    for (const auto& num : l) {\n        // Check if the number is positive\n        if (num > 0) {\n            // If it's positive, add it to the result vector\n            result.push_back(num);\n        }\n    }\n    \n    return result;\n}\n\n// Function to print the elements of a vector for testing purposes\nvoid print_vector(const std::vector<float>& vec) {\n    for (const auto& num : vec) {\n        std::cout << num << \" \";\n    }\n    std::cout << std::endl;\n}\n\n"}
{"task_id": "CPP/31", "generation": "#include <iostream>\n#include <cmath> // For sqrt function\n\nusing namespace std;\n\nbool is_prime(long long n) {\n    if (n <= 1) {\n        return false; // Numbers less than or equal to 1 are not prime\n    }\n    \n    for (long long i = 2; i <= sqrt(n); ++i) {\n        if (n % i == 0) {\n            return false; // n is divisible by i, so it's not a prime number\n        }\n    }\n    \n    return true; // No divisors found, so n is a prime number\n}\n\n"}
{"task_id": "CPP/32", "generation": "#include <iostream>\n#include <vector>\n#include <cmath>\n\ndouble poly(const std::vector<double>& xs, double x) {\n    double sum = 0;\n    int i;\n    for (i = 0; i < xs.size(); i++) {\n        sum += xs[i] * pow(x, i);\n    }\n    return sum;\n}\n\ndouble find_zero(const std::vector<double>& xs) {\n    // Find the largest non-zero coefficient\n    double max_coeff = -INFINITY;\n    for (auto coeff : xs) {\n        if (coeff != 0 && abs(coeff) > max_coeff) {\n            max_coeff = abs(coeff);\n        }\n    }\n\n    // Initial guess, can be improved based on the polynomial's properties\n    double x = 0.0;\n\n    // Newton-Raphson method to find a root\n    const double tol = 1e-6;  // Tolerance for convergence\n    int max_iter = 1000;      // Maximum number of iterations\n\n    for (int iter = 0; iter < max_iter; ++iter) {\n        double f_x = poly(xs, x);\n        if (abs(f_x) < tol) {\n            return x;\n        }\n\n        double f_prime_x = 0.0;\n        for (size_t i = 1; i < xs.size(); ++i) {\n            f_prime_x += i * xs[i] * pow(x, i - 1);\n        }\n\n        if (abs(f_prime_x) < tol) {\n            std::cerr << \"Derivative is close to zero, no convergence.\" << std::endl;\n            return x;\n        }\n\n        x -= f_x / f_prime_x;\n    }\n\n    // If not converged within max_iter\n    std::cerr << \"Newton-Raphson did not converge after \" << max_iter << \" iterations.\" << std::endl;\n    return x;\n}\n\n"}
{"task_id": "CPP/33", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> sort_third(vector<int> l) {\n    vector<int> third_indices;\n    \n    // Extract elements at indices divisible by three\n    for (size_t i = 2; i < l.size(); i += 3) {\n        third_indices.push_back(l[i]);\n    }\n    \n    // Sort the extracted elements\n    sort(third_indices.begin(), third_indices.end());\n    \n    // Replace original values with sorted ones at indices divisible by three\n    for (size_t i = 2, j = 0; i < l.size(); i += 3, ++j) {\n        l[i] = third_indices[j];\n    }\n    \n    return l;\n}\n\n// Function to test the sort_third function\nvoid test_sort_third() {\n    vector<int> result1 = sort_third({1, 2, 3});\n    for (int num : result1) {\n        cout << num << \" \";\n    }\n    cout << endl;\n\n    vector<int> result2 = sort_third({5, 6, 3, 4, 8, 9, 2});\n    for (int num : result2) {\n        cout << num << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/34", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> unique(vector<int> l) {\n    // Sort the vector\n    sort(l.begin(), l.end());\n    \n    // Remove consecutive duplicates using std::unique\n    auto last = unique(l.begin(), l.end());\n    \n    // Resize the vector to remove the extra elements\n    l.resize(distance(l.begin(), last));\n    \n    return l;\n}\n\n"}
{"task_id": "CPP/35", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nfloat max_element(vector<float> l) {\n    if (l.empty()) {\n        return 0; // or throw an exception, depending on your use case\n    }\n\n    float max_val = l[0]; // Initialize with the first element\n\n    for (size_t i = 1; i < l.size(); ++i) {\n        if (l[i] > max_val) {\n            max_val = l[i];\n        }\n    }\n\n    return max_val;\n}\n\n"}
{"task_id": "CPP/36", "generation": "#include <iostream>\nusing namespace std;\n\nint fizz_buzz(int n) {\n    int count = 0;\n    \n    for (int i = 1; i < n; ++i) {\n        if (i % 11 == 0 || i % 13 == 0) {\n            // Convert the number to a string and count occurrences of '7'\n            string numStr = to_string(i);\n            for (char ch : numStr) {\n                if (ch == '7') {\n                    ++count;\n                }\n            }\n        }\n    }\n    \n    return count;\n}\n\n"}
{"task_id": "CPP/37", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<float> sort_even(vector<float> l) {\n    // Extract elements at even indices (0, 2, 4, ...)\n    vector<float> even_elements;\n    for (size_t i = 0; i < l.size(); i += 2) {\n        even_elements.push_back(l[i]);\n    }\n\n    // Sort the extracted elements\n    sort(even_elements.begin(), even_elements.end());\n\n    // Place sorted elements back into their original positions\n    size_t even_index = 0;\n    for (size_t i = 0; i < l.size(); i += 2) {\n        l[i] = even_elements[even_index++];\n    }\n\n    return l;\n}\n\n// Function to print the vector\nvoid print_vector(const vector<float>& v) {\n    for (const auto& elem : v) {\n        cout << elem << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/38", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring encode_cyclic(string s) {\n    // returns encoded string by cycling groups of three characters.\n    int l = s.length();\n    int num = (l + 2) / 3;\n    string x, output;\n    for (int i = 0; i * 3 < l; i++) {\n        x = s.substr(i * 3, 3);\n        if (x.length() == 3) x = x.substr(1) + x[0];\n        output += x;\n    }\n    return output;\n}\n\nstring decode_cyclic(string s) {\n    /*\n    takes as input string encoded with encode_cyclic function. Returns decoded string.\n    */\n    int l = s.length();\n    int num = (l + 2) / 3;\n    string x, output;\n    for (int i = 0; i * 3 < l; i++) {\n        x = s.substr(i * 3, 3);\n        if (x.length() == 3) x = x.back() + x.substr(0, 2); // Move the last character to the beginning\n        output += x;\n    }\n    return output;\n}\n\n"}
{"task_id": "CPP/39", "generation": "#include <iostream>\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    if (num == 2 || num == 3) return true;\n    if (num % 2 == 0 || num % 3 == 0) return false;\n    for (int i = 5; i * i <= num; i += 6) {\n        if (num % i == 0 || num % (i + 2) == 0)\n            return false;\n    }\n    return true;\n}\n\n// Function to find the n-th Fibonacci number that is also prime\nint prime_fib(int n) {\n    int count = 0; // Counter for prime Fibonacci numbers found\n    int a = 0, b = 1; // First two Fibonacci numbers\n\n    while (true) {\n        int fib = a + b;\n        a = b;\n        b = fib;\n\n        if (is_prime(fib)) {\n            count++;\n            if (count == n) return fib;\n        }\n    }\n}\n\n"}
{"task_id": "CPP/40", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nbool triples_sum_to_zero(vector<int> l) {\n    // First, sort the array to make it easier to find triplets that sum to zero.\n    sort(l.begin(), l.end());\n    \n    int n = l.size();\n    \n    for (int i = 0; i < n - 2; ++i) {\n        // Skip duplicate elements to avoid checking the same triplet multiple times.\n        if (i > 0 && l[i] == l[i-1]) continue;\n        \n        int left = i + 1, right = n - 1;\n        \n        while (left < right) {\n            int sum = l[i] + l[left] + l[right];\n            \n            if (sum == 0) {\n                return true;\n            } else if (sum < 0) {\n                ++left; // Need a larger number\n            } else {\n                --right; // Need a smaller number\n            }\n        }\n    }\n    \n    return false;\n}\n\n// Function to test the solution with provided examples.\nvoid check() {\n    assert(triples_sum_to_zero({1, 3, 5, 0}) == false);\n    assert(triples_sum_to_zero({1, 3, -2, 1}) == true);\n    assert(triples_sum_to_zero({1, 2, 3, 7}) == false);\n    assert(triples_sum_to_zero({2, 4, -5, 3, 9, 7}) == true);\n    assert(triples_sum_to_zero({1}) == false);\n    \n    cout << \"All test cases passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/41", "generation": "#include <iostream>\nusing namespace std;\n\nint car_race_collision(int n) {\n    return n;\n}\n\n"}
{"task_id": "CPP/42", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Function to increment each element in the vector by 1\nvector<int> incr_list(vector<int> l) {\n    for (int &elem : l) {\n        elem += 1;\n    }\n    return l;\n}\n\n// Function to print a vector\nvoid print_vector(const vector<int>& v) {\n    for (const int& elem : v) {\n        cout << elem << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/43", "generation": "#include <iostream>\n#include <vector>\n#include <set>\n\nusing namespace std;\n\nbool pairs_sum_to_zero(vector<int> l) {\n    // Use a set to store the numbers we have seen so far\n    set<int> seen;\n    \n    for (int num : l) {\n        // Check if the negation of the current number exists in the set\n        if (seen.find(-num) != seen.end()) {\n            return true;\n        }\n        // Add the current number to the set\n        seen.insert(num);\n    }\n    \n    // If no such pair is found, return false\n    return false;\n}\n\n// Function to test the pairs_sum_to_zero function with given examples\nvoid test_pairs_sum_to_zero() {\n    assert(pairs_sum_to_zero({1, 3, 5, 0}) == false);\n    assert(pairs_sum_to_zero({1, 3, -2, 1}) == false);\n    assert(pairs_sum_to_zero({1, 2, 3, 7}) == false);\n    assert(pairs_sum_to_zero({2, 4, -5, 3, 5, 7}) == true);\n    assert(pairs_sum_to_zero({1}) == false);\n\n    cout << \"All test cases passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/44", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring change_base(int x, int base) {\n    if (x == 0) {\n        return \"0\";\n    }\n    \n    string result = \"\";\n    while (x > 0) {\n        int digit = x % base;\n        result = to_string(digit) + result;\n        x /= base;\n    }\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/45", "generation": "#include <stdio.h>\nusing namespace std;\n\nfloat triangle_area(float a, float h) {\n    return 0.5 * a * h;\n}\n\n"}
{"task_id": "CPP/46", "generation": "#include <iostream>\nusing namespace std;\n\nint fib4(int n) {\n    if (n == 0 || n == 1 || n == 2) {\n        return n == 2 ? 2 : 0;\n    }\n    \n    // Initialize the first four values of the sequence\n    int a = 0, b = 0, c = 2, d = 0;\n    \n    // Compute fib4(n) iteratively\n    for (int i = 3; i <= n; ++i) {\n        int next = a + b + c + d;\n        a = b;\n        b = c;\n        c = d;\n        d = next;\n    }\n    \n    return d;\n}\n\n"}
{"task_id": "CPP/47", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nfloat median(vector<float> l) {\n    // Sort the vector\n    sort(l.begin(), l.end());\n    \n    int n = l.size();\n    \n    if (n % 2 == 0) {\n        // If even number of elements, return the average of the two middle elements\n        return (l[n / 2 - 1] + l[n / 2]) / 2.0;\n    } else {\n        // If odd number of elements, return the middle element\n        return l[n / 2];\n    }\n}\n\n"}
{"task_id": "CPP/48", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_palindrome(string text) {\n    int start = 0;\n    int end = text.length() - 1;\n\n    while (start < end) {\n        if (text[start] != text[end]) {\n            return false; // If characters at the current positions don't match, it's not a palindrome\n        }\n        start++;\n        end--;\n    }\n\n    return true; // All characters matched correctly, so it is a palindrome\n}\n\n"}
{"task_id": "CPP/49", "generation": "#include <stdio.h>\nusing namespace std;\n\nint modp(int n, int p) {\n    if (n == 0)\n        return 1; // Base case: any number to the power of 0 is 1\n\n    int result = 1;\n    long base = 2;\n\n    while (n > 0) {\n        if (n % 2 == 1) { // If n is odd, multiply the result by the current base\n            result = (result * base) % p;\n        }\n        base = (base * base) % p; // Square the base and reduce modulo p\n        n /= 2; // Halve the exponent\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/50", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nstring encode_shift(string s) {\n    // returns encoded string by shifting every character by 5 in the alphabet.\n    string out;\n    int i;\n    for (i = 0; i < s.length(); i++) {\n        int w = ((int)s[i] + 5 - (int)'a') % 26 + (int)'a';\n        out += (char)w;\n    }\n    return out;\n}\n\nstring decode_shift(string s) {\n    // takes as input string encoded with encode_shift function. Returns decoded string.\n    string out;\n    int i;\n    for (i = 0; i < s.length(); i++) {\n        int w = ((int)s[i] - 5 - (int)'a') % 26 + (int)'a';\n        out += (char)w;\n    }\n    return out;\n}\n\n"}
{"task_id": "CPP/51", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nstring remove_vowels(string text) {\n    // Define the vowels in both lowercase and uppercase\n    string vowels = \"aeiouAEIOU\";\n    \n    // Use a stream iterator to iterate through each character of the input string\n    return remove_if(text.begin(), text.end(), [&vowels](char c) {\n        return vowels.find(c) != string::npos;\n    });\n}\n\n"}
{"task_id": "CPP/52", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Function to check if all elements in the vector are below the threshold\nbool below_threshold(vector<int> l, int t) {\n    // Iterate through each element in the vector\n    for (int num : l) {\n        // If any number is not below the threshold, return false\n        if (num >= t) {\n            return false;\n        }\n    }\n    // If all numbers are below the threshold, return true\n    return true;\n}\n\n// Function to test the below_threshold function with provided examples\nvoid check_function() {\n    cout << boolalpha; // Print bools as true/false instead of 1/0\n    cout << \"Test 1: \" << below_threshold({1, 2, 4, 10}, 100) << endl; // Expected output: true\n    cout << \"Test 2: \" << below_threshold({1, 20, 4, 10}, 5) << endl; // Expected output: false\n}\n\n"}
{"task_id": "CPP/53", "generation": "#include <iostream>  // Include iostream to use cout\n\nusing namespace std;\n\n// Function to add two integers\nint add(int x, int y) {\n    return x + y;  // Return the sum of x and y\n}\n\n"}
{"task_id": "CPP/54", "generation": "#include <iostream>\n#include <string>\n#include <set>\n\nusing namespace std;\n\nbool same_chars(string s0, string s1) {\n    // Create a set for each string to store unique characters\n    set<char> chars_s0(s0.begin(), s0.end());\n    set<char> chars_s1(s1.begin(), s1.end());\n\n    // Compare the sets\n    return chars_s0 == chars_s1;\n}\n\n"}
{"task_id": "CPP/55", "generation": "#include <stdio.h>\nusing namespace std;\n\nint fib(int n) {\n    if (n <= 0) {\n        return 0;\n    } else if (n == 1) {\n        return 1;\n    } else {\n        int a = 0, b = 1, c;\n        for (int i = 2; i <= n; ++i) {\n            c = a + b;\n            a = b;\n            b = c;\n        }\n        return b;\n    }\n}\n\n// Function to test the fib function\nvoid test_fib() {\n    printf(\"fib(10) = %d\\n\", fib(10)); // Should print 55\n    printf(\"fib(1) = %d\\n\", fib(1));   // Should print 1\n    printf(\"fib(8) = %d\\n\", fib(8));   // Should print 21\n}\n\n"}
{"task_id": "CPP/56", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    int balance = 0;\n    \n    for (char bracket : brackets) {\n        if (bracket == '<') {\n            balance++;\n        } else if (bracket == '>') {\n            balance--;\n            if (balance < 0) {\n                // If balance is negative, it means there's a closing bracket without an opening one\n                return false;\n            }\n        }\n    }\n    \n    // The string is correct if the balance is zero at the end\n    return balance == 0;\n}\n\n"}
{"task_id": "CPP/57", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool monotonic(vector<float> l) {\n    // Check for empty or single-element vector\n    if (l.size() <= 1) return true;\n\n    // Determine the initial direction of the sequence\n    bool increasing = l[1] >= l[0];\n\n    for (size_t i = 2; i < l.size(); ++i) {\n        if (increasing && l[i] < l[i - 1]) {\n            return false;\n        } else if (!increasing && l[i] > l[i - 1]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\n"}
{"task_id": "CPP/58", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to remove duplicates and sort the vector\nvoid removeDuplicatesAndSort(vector<int>& vec) {\n    sort(vec.begin(), vec.end());\n    vec.erase(unique(vec.begin(), vec.end()), vec.end());\n}\n\nvector<int> common(vector<int> l1, vector<int> l2) {\n    // Remove duplicates and sort both vectors\n    removeDuplicatesAndSort(l1);\n    removeDuplicatesAndSort(l2);\n\n    vector<int> result;\n    int i = 0, j = 0;\n\n    // Use two-pointer technique to find common elements\n    while (i < l1.size() && j < l2.size()) {\n        if (l1[i] == l2[j]) {\n            result.push_back(l1[i]);\n            i++;\n            j++;\n        } else if (l1[i] < l2[j]) {\n            i++;\n        } else {\n            j++;\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/59", "generation": "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\nint largest_prime_factor(int n) {\n    int max_prime = -1;\n    \n    // Remove all factors of 2\n    while (n % 2 == 0) {\n        max_prime = 2;\n        n /= 2;\n    }\n    \n    // Check for odd factors from 3 to sqrt(n)\n    for (int i = 3; i <= sqrt(n); i += 2) {\n        while (n % i == 0) {\n            max_prime = i;\n            n = n / i;\n        }\n    }\n    \n    // If n is a prime number greater than 2\n    if (n > 2)\n        max_prime = n;\n    \n    return max_prime;\n}\n\n"}
{"task_id": "CPP/60", "generation": "#include <iostream>\nusing namespace std;\n\nint sum_to_n(int n) {\n    int sum = 0;\n    for (int i = 1; i <= n; ++i) {\n        sum += i;\n    }\n    return sum;\n}\n\n"}
{"task_id": "CPP/61", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    int balance = 0;\n    \n    for (char c : brackets) {\n        if (c == '(') {\n            balance++;\n        } else if (c == ')') {\n            balance--;\n        }\n        \n        // If at any point the balance is negative, it means there's a closing bracket without an opening one\n        if (balance < 0) {\n            return false;\n        }\n    }\n    \n    // Finally, check if all brackets are balanced by ensuring the balance is zero\n    return balance == 0;\n}\n\n"}
{"task_id": "CPP/62", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvector<float> derivative(vector<float> xs) {\n    vector<float> result;\n    \n    // Iterate through the coefficients starting from the first non-constant term\n    for (size_t i = 1; i < xs.size(); ++i) {\n        // Multiply the coefficient by its degree and add to the result\n        result.push_back(xs[i] * i);\n    }\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/63", "generation": "#include <iostream>\nusing namespace std;\n\nint fibfib(int n) {\n    // Base cases\n    if (n == 0 || n == 1) return 0;\n    if (n == 2) return 1;\n\n    // Array to store the computed values of FibFib sequence\n    int dp[n + 1];\n    \n    // Initialize base cases\n    dp[0] = 0;\n    dp[1] = 0;\n    dp[2] = 1;\n\n    // Fill the dp array using the recurrence relation\n    for (int i = 3; i <= n; ++i) {\n        dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3];\n    }\n\n    // Return the nth element of the FibFib sequence\n    return dp[n];\n}\n\n// Function to test the fibfib function with provided examples\nvoid check() {\n    cout << \"fibfib(1) = \" << fibfib(1) << endl; // Expected output: 0\n    cout << \"fibfib(5) = \" << fibfib(5) << endl; // Expected output: 4\n    cout << \"fibfib(8) = \" << fibfib(8) << endl; // Expected output: 24\n}\n\n"}
{"task_id": "CPP/64", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint vowels_count(string s) {\n    int count = 0;\n    \n    // Convert the string to lowercase for easier comparison\n    transform(s.begin(), s.end(), s.begin(), ::tolower);\n    \n    // Iterate through each character in the string\n    for (size_t i = 0; i < s.length(); ++i) {\n        char c = s[i];\n        \n        // Check if the current character is a vowel or 'y' at the end of the word\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' || \n            (c == 'y' && i == s.length() - 1)) {\n            count++;\n        }\n    }\n    \n    return count;\n}\n\n"}
{"task_id": "CPP/65", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring circular_shift(int x, int shift) {\n    // Convert the integer to a string for easier manipulation\n    string str = to_string(x);\n    int num_digits = str.length();\n\n    // If shift is greater than or equal to the number of digits, reverse the string\n    if (shift >= num_digits) {\n        return string(str.rbegin(), str.rend());\n    }\n\n    // Perform right circular shift\n    int effective_shift = shift % num_digits;\n    string shifted_str = str.substr(num_digits - effective_shift);\n    shifted_str += str.substr(0, num_digits - effective_shift);\n\n    return shifted_str;\n}\n\n"}
{"task_id": "CPP/66", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint digitSum(string s) {\n    int sum = 0;\n    for (char c : s) {\n        if (isupper(c)) { // Check if the character is uppercase\n            sum += static_cast<int>(c); // Add its ASCII value to the sum\n        }\n    }\n    return sum;\n}\n\n// Function to test the digitSum function with provided examples\nvoid checkFunction() {\n    assert(digitSum(\"\") == 0);\n    assert(digitSum(\"abAB\") == 131);\n    assert(digitSum(\"abcCd\") == 67);\n    assert(digitSum(\"helloE\") == 69);\n    assert(digitSum(\"woArBld\") == 131);\n    assert(digitSum(\"aAaaaXa\") == 153);\n\n    cout << \"All test cases passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/67", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nint fruit_distribution(string s, int n) {\n    // Use stringstream to parse the string\n    stringstream ss(s);\n    string temp;\n    \n    // Extract the number of apples and oranges from the string\n    getline(ss, temp, ' ');\n    getline(ss, temp, ' ');\n\n    int num_apples = stoi(temp);\n    getline(ss, temp, ' ');\n    int num_oranges = stoi(temp);\n\n    // Calculate the number of mangoes\n    int num_mangoes = n - (num_apples + num_oranges);\n    \n    return num_mangoes;\n}\n\n// Function to test the fruit_distribution function with provided examples\nvoid test_fruit_distribution() {\n    cout << \"Testing fruit_distribution...\" << endl;\n    assert(fruit_distribution(\"5 apples and 6 oranges\", 19) == 8);\n    assert(fruit_distribution(\"0 apples and 1 oranges\", 3) == 2);\n    assert(fruit_distribution(\"2 apples and 3 oranges\", 100) == 95);\n    assert(fruit_distribution(\"100 apples and 1 oranges\", 120) == 19);\n\n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/68", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> pluck(vector<int> arr) {\n    int smallest_even_value = -1;\n    int index_of_smallest_even = -1;\n\n    // Iterate through the array to find the smallest even value and its index\n    for (int i = 0; i < arr.size(); ++i) {\n        if (arr[i] % 2 == 0 && (smallest_even_value == -1 || arr[i] < smallest_even_value)) {\n            smallest_even_value = arr[i];\n            index_of_smallest_even = i;\n        }\n    }\n\n    // If no even value was found, return an empty vector\n    if (smallest_even_value == -1) {\n        return {};\n    } else {\n        return {smallest_even_value, index_of_smallest_even};\n    }\n}\n\n// Function to test the pluck function with provided examples\nvoid test_pluck() {\n    cout << \"Test 1: \";\n    vector<int> result = pluck({4, 2, 3});\n    if (result == vector<int>({2, 1})) {\n        cout << \"Passed\" << endl;\n    } else {\n        cout << \"Failed\" << endl;\n    }\n\n    cout << \"Test 2: \";\n    result = pluck({1, 2, 3});\n    if (result == vector<int>({2, 1})) {\n        cout << \"Passed\" << endl;\n    } else {\n        cout << \"Failed\" << endl;\n    }\n\n    cout << \"Test 3: \";\n    result = pluck({});\n    if (result.empty()) {\n        cout << \"Passed\" << endl;\n    } else {\n        cout << \"Failed\" << endl;\n    }\n\n    cout << \"Test 4: \";\n    result = pluck({5, 0, 3, 0, 4, 2});\n    if (result == vector<int>({0, 1})) {\n        cout << \"Passed\" << endl;\n    } else {\n        cout << \"Failed\" << endl;\n    }\n}\n\n"}
{"task_id": "CPP/69", "generation": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nint search(const std::vector<int>& lst) {\n    // Create a map to store the frequency of each element in the vector\n    std::unordered_map<int, int> freqMap;\n\n    // Count the frequency of each integer in the vector\n    for (int num : lst) {\n        freqMap[num]++;\n    }\n\n    // Find the greatest integer that meets the condition\n    int result = -1;\n    for (const auto& pair : freqMap) {\n        if (pair.first <= pair.second && pair.first > result) {\n            result = pair.first;\n        }\n    }\n\n    return result;\n}\n\n// Function to test the search function with provided examples\nvoid check() {\n    assert(search({4, 1, 2, 2, 3, 1}) == 2);\n    assert(search({1, 2, 2, 3, 3, 3, 4, 4, 4}) == 3);\n    assert(search({5, 5, 4, 4, 4}) == -1);\n}\n\n"}
{"task_id": "CPP/70", "generation": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> strange_sort_list(vector<int> lst) {\n    // Sort the vector in ascending order\n    sort(lst.begin(), lst.end());\n    \n    vector<int> result;\n    int start = 0; // Start index for minimum values\n    int end = lst.size() - 1; // End index for maximum values\n    \n    while (start <= end) {\n        if (start == end) {\n            // If there's only one element left, add it to the result\n            result.push_back(lst[start]);\n            break;\n        }\n        \n        // Add minimum value\n        result.push_back(lst[start++]);\n        \n        // Add maximum value\n        result.push_back(lst[end--]);\n    }\n    \n    return result;\n}\n\n// Function to test the strange_sort_list function\nvoid test_strange_sort() {\n    assert(strange_sort_list({1, 2, 3, 4}) == vector<int>({1, 4, 2, 3}));\n    assert(strange_sort_list({5, 5, 5, 5}) == vector<int>({5, 5, 5, 5}));\n    assert(strange_sort_list({}) == vector<int>({}));\n    cout << \"All test cases passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/71", "generation": "#include <stdio.h>\n#include <math.h>\n\nusing namespace std;\n\nfloat triangle_area(float a, float b, float c) {\n    // Check if the sides form a valid triangle\n    if (a + b <= c || a + c <= b || b + c <= a) {\n        return -1;\n    }\n    \n    // Calculate the semi-perimeter\n    float s = (a + b + c) / 2.0;\n\n    // Calculate the area using Heron's formula\n    float area = sqrt(s * (s - a) * (s - b) * (s - c));\n\n    // Round the result to 2 decimal points\n    return round(area * 100) / 100;\n}\n\n"}
{"task_id": "CPP/72", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool is_palindrome(const vector<int>& q) {\n    int n = q.size();\n    for (int i = 0; i < n / 2; ++i) {\n        if (q[i] != q[n - i - 1]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nbool will_it_fly(vector<int> q, int w) {\n    // Check if the vector is a palindrome\n    bool is_balanced = is_palindrome(q);\n    \n    // Calculate the sum of elements in the vector\n    int sum = 0;\n    for (int num : q) {\n        sum += num;\n    }\n    \n    // Check if the sum is less than or equal to w and the vector is balanced\n    return is_balanced && sum <= w;\n}\n\n// Function to test the will_it_fly function with provided examples\nvoid test_will_it_fly() {\n    cout << boolalpha; // Print bools as true/false instead of 1/0\n    cout << \"will_it_fly({1, 2}, 5): \" << will_it_fly({1, 2}, 5) << endl;\n    cout << \"will_it_fly({3, 2, 3}, 1): \" << will_it_fly({3, 2, 3}, 1) << endl;\n    cout << \"will_it_fly({3, 2, 3}, 9): \" << will_it_fly({3, 2, 3}, 9) << endl;\n    cout << \"will_it_fly({3}, 5): \" << will_it_fly({3}, 5) << endl;\n}\n\n"}
{"task_id": "CPP/73", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint smallest_change(vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n    int left = 0, right = n - 1;\n\n    while (left < right) {\n        if (arr[left] != arr[right]) {\n            ++changes; // Increment the change counter\n        }\n        ++left;\n        --right;\n    }\n\n    return changes;\n}\n\n"}
{"task_id": "CPP/74", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to calculate the total number of characters in a vector of strings\nint count_chars(const vector<string>& vec) {\n    int total = 0;\n    for (const auto& str : vec) {\n        total += str.length();\n    }\n    return total;\n}\n\nvector<string> total_match(vector<string> lst1, vector<string> lst2) {\n    // Calculate the total number of characters in both vectors\n    int chars_lst1 = count_chars(lst1);\n    int chars_lst2 = count_chars(lst2);\n\n    // Compare and return the appropriate vector\n    if (chars_lst1 < chars_lst2) {\n        return lst1;\n    } else if (chars_lst2 < chars_lst1) {\n        return lst2;\n    } else {\n        return lst1;  // If they are equal, return the first vector\n    }\n}\n\n// Function to test the total_match function with provided examples\nvoid check() {\n    assert(total_match({}, {}) == vector<string>());\n    assert(total_match({\"hi\", \"admin\"}, {\"hI\", \"Hi\"}) == vector<string>{\"hI\", \"Hi\"});\n    assert(total_match({\"hi\", \"admin\"}, {\"hi\", \"hi\", \"admin\", \"project\"}) == vector<string>{\"hi\", \"admin\"});\n    assert(total_match({\"hi\", \"admin\"}, {\"hI\", \"hi\", \"hi\"}) == vector<string>{\"hI\", \"hi\", \"hi\"});\n    assert(total_match({\"4\"}, {\"1\", \"2\", \"3\", \"4\", \"5\"}) == vector<string>{\"4\"});\n\n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/75", "generation": "#include <iostream>\nusing namespace std;\n\n// Helper function to check if a number is prime\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\n// Main function to check if the number is a product of exactly three prime numbers\nbool is_multiply_prime(int a) {\n    // Check all combinations of three primes less than 100\n    for (int p1 = 2; p1 < 100; ++p1) {\n        if (!is_prime(p1)) continue;\n        for (int p2 = p1; p2 < 100; ++p2) {\n            if (!is_prime(p2)) continue;\n            for (int p3 = p2; p3 < 100; ++p3) {\n                if (!is_prime(p3)) continue;\n                if (p1 * p2 * p3 == a) return true;\n            }\n        }\n    }\n    return false;\n}\n\n// Function to test the is_multiply_prime function\nvoid test() {\n    cout << \"Testing is_multiply_prime...\" << endl;\n    assert(is_multiply_prime(30) == true);  // 2 * 3 * 5 = 30\n    assert(is_multiply_prime(60) == false); // Not a product of exactly three primes\n    assert(is_multiply_prime(105) == true); // 3 * 5 * 7 = 105\n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/76", "generation": "#include <iostream>\n#include <cmath>\n\nbool is_simple_power(int x, int n) {\n    if (n == 1) {\n        return x == 1;\n    }\n    \n    double log_value = log(x) / log(n);\n    // Check if the log value is an integer by comparing it with its rounded version\n    return floor(log_value + 0.5) == log_value;\n}\n\n"}
{"task_id": "CPP/77", "generation": "#include <stdio.h>\n#include <math.h>\n\nusing namespace std;\n\nbool iscube(int a) {\n    // Calculate the cube root of the absolute value of 'a'\n    double cubeRoot = cbrt(fabs(a));\n    \n    // Round the cube root to the nearest integer\n    int roundedCubeRoot = round(cubeRoot);\n    \n    // Check if cubing the rounded value gives back the original number\n    return (roundedCubeRoot * roundedCubeRoot * roundedCubeRoot == a);\n}\n\n"}
{"task_id": "CPP/78", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\n// Function to check if a hexadecimal digit is prime\nbool is_hex_prime(char hex_digit) {\n    switch(hex_digit) {\n        case '2': case '3': case '5': case '7':\n        case 'B': case 'D': return true;\n        default: return false;\n    }\n}\n\n// Main function to count the number of prime hexadecimal digits\nint hex_key(string num) {\n    int count = 0;\n    for (char digit : num) {\n        if (is_hex_prime(digit)) {\n            count++;\n        }\n    }\n    return count;\n}\n\n// Function to test the hex_key function with provided examples\nvoid test_hex_key() {\n    cout << \"Testing hex_key function...\" << endl;\n    assert(hex_key(\"AB\") == 1);\n    assert(hex_key(\"1077E\") == 2);\n    assert(hex_key(\"ABED1A33\") == 4);\n    assert(hex_key(\"123456789ABCDEF0\") == 6);\n    assert(hex_key(\"2020\") == 2);\n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/79", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring decimal_to_binary(int decimal) {\n    if (decimal == 0) return \"db0db\"; // Handle the special case where decimal is 0\n\n    string binary = \"\";\n    while (decimal > 0) {\n        int remainder = decimal % 2;\n        binary = to_string(remainder) + binary; // Prepend the remainder\n        decimal /= 2;\n    }\n\n    return \"db\" + binary + \"db\"; // Add \"db\" at the beginning and end\n}\n\n"}
{"task_id": "CPP/80", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_happy(string s) {\n    // Check if the string length is less than 3\n    if (s.length() < 3) return false;\n\n    // Iterate through the string to check every three consecutive characters\n    for (int i = 0; i <= s.length() - 3; ++i) {\n        // If any three consecutive characters are not distinct, return false\n        if (s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]) {\n            return false;\n        }\n    }\n\n    // If no three consecutive characters are the same, return true\n    return true;\n}\n\n"}
{"task_id": "CPP/81", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to determine the letter grade for a given GPA\nstring get_letter_grade(float gpa) {\n    if (gpa >= 4.0) return \"A+\";\n    else if (gpa > 3.7) return \"A\";\n    else if (gpa > 3.3) return \"A-\";\n    else if (gpa > 3.0) return \"B+\";\n    else if (gpa > 2.7) return \"B\";\n    else if (gpa > 2.3) return \"B-\";\n    else if (gpa > 2.0) return \"C+\";\n    else if (gpa > 1.7) return \"C\";\n    else if (gpa > 1.3) return \"C-\";\n    else if (gpa > 1.0) return \"D+\";\n    else if (gpa > 0.7) return \"D\";\n    else if (gpa > 0.0) return \"D-\";\n    else return \"E\";\n}\n\n// Function to convert a vector of GPAs into a vector of letter grades\nvector<string> numerical_letter_grade(vector<float> grades) {\n    vector<string> letter_grades;\n    for (float gpa : grades) {\n        letter_grades.push_back(get_letter_grade(gpa));\n    }\n    return letter_grades;\n}\n\n// Function to check the correctness of the solution\nvoid check() {\n    vector<float> test_grades = {4.0, 3, 1.7, 2, 3.5};\n    vector<string> expected_output = {\"A+\", \"B\", \"C-\", \"C\", \"A-\"};\n    vector<string> output = numerical_letter_grade(test_grades);\n    \n    if (output == expected_output) {\n        cout << \"Test passed!\" << endl;\n    } else {\n        cout << \"Test failed. Expected: \";\n        for (const auto& grade : expected_output) {\n            cout << grade << \" \";\n        }\n        cout << \"\\nGot: \";\n        for (const auto& grade : output) {\n            cout << grade << \" \";\n        }\n        cout << endl;\n    }\n}\n\n"}
{"task_id": "CPP/82", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    if (n == 2 || n == 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n\n    for (int i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0)\n            return false;\n    }\n    return true;\n}\n\n// Function to check if the length of a string is prime\nbool prime_length(string str) {\n    int len = str.length();\n    return is_prime(len);\n}\n\n"}
{"task_id": "CPP/83", "generation": "#include <iostream>\nusing namespace std;\n\nint starts_one_ends(int n) {\n    // Total number of n-digit numbers is from 10^(n-1) to 10^n - 1\n    int total_n_digit_numbers = (int)pow(10, n) - (int)pow(10, n - 1);\n    \n    // Numbers that start with 1: there are 9 choices for each of the remaining (n-1) digits\n    int starts_with_1 = pow(10, n - 1);\n    \n    // Numbers that end with 1: there are 9 choices for each of the first (n-1) digits\n    int ends_with_1 = pow(10, n - 1);\n    \n    // Numbers that both start and end with 1: there are 9^(n-2) such numbers\n    int starts_and_ends_with_1 = pow(10, n - 2);\n    \n    // Using the principle of inclusion-exclusion to avoid double-counting\n    return starts_with_1 + ends_with_1 - starts_and_ends_with_1;\n}\n\n"}
{"task_id": "CPP/84", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring solve(int N) {\n    int sum = 0;\n    \n    // Calculate the sum of digits\n    while (N > 0) {\n        sum += N % 10;  // Add the last digit to the sum\n        N /= 10;        // Remove the last digit from N\n    }\n    \n    // Convert the sum to binary and return it as a string\n    string result = \"\";\n    if (sum == 0) {\n        result = \"0\";\n    } else {\n        while (sum > 0) {\n            result = to_string(sum % 2) + result;  // Prepend the remainder when divided by 2\n            sum /= 2;                             // Divide the sum by 2\n        }\n    }\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/85", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint add(vector<int> lst) {\n    int sum = 0;\n    // Iterate through the vector starting from index 1 (second element)\n    for (size_t i = 1; i < lst.size(); i += 2) {\n        if (lst[i] % 2 == 0) {  // Check if the element at odd index is even\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n\n"}
{"task_id": "CPP/86", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nstring anti_shuffle(string s) {\n    // Helper function to sort each word\n    auto sort_word = [](const string& word) -> string {\n        string sorted_word = word;\n        sort(sorted_word.begin(), sorted_word.end());\n        return sorted_word;\n    };\n\n    string result;\n    string current_word;\n    for (char ch : s) {\n        if (ch == ' ') {\n            // If we encounter a space, add the sorted word to the result and reset current_word\n            if (!current_word.empty()) {\n                result += sort_word(current_word);\n                result.push_back(' ');\n                current_word.clear();\n            }\n            result.push_back(ch);  // Add the space to the result\n        } else {\n            // Otherwise, append the character to the current word\n            current_word.push_back(ch);\n        }\n    }\n\n    // Add the last word if it exists and is not empty\n    if (!current_word.empty()) {\n        result += sort_word(current_word);\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/87", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to get coordinates of x in lst and return sorted list of coordinates\nvector<vector<int>> get_row(vector<vector<int>> lst, int x) {\n    vector<pair<int, int>> positions;\n    \n    // Find all occurrences of x and store their positions\n    for (int i = 0; i < lst.size(); ++i) {\n        for (int j = 0; j < lst[i].size(); ++j) {\n            if (lst[i][j] == x) {\n                positions.push_back({i, j});\n            }\n        }\n    }\n\n    // Sort by row in ascending order\n    sort(positions.begin(), positions.end());\n\n    vector<vector<int>> result;\n    \n    // For each unique row, sort the columns in descending order and add to result\n    for (auto& pos : positions) {\n        if (result.empty() || result.back()[0] != pos.first) {\n            result.push_back({pos.first, pos.second});\n        } else {\n            result.back().push_back(pos.second);\n        }\n    }\n\n    // Sort columns in descending order within each row\n    for (auto& row : result) {\n        sort(row.begin() + 1, row.end(), greater<int>());\n    }\n\n    return result;\n}\n\n// Helper function to print the result\nvoid print_result(const vector<vector<int>>& result) {\n    for (const auto& row : result) {\n        for (int col : row) {\n            cout << col << \" \";\n        }\n        cout << endl;\n    }\n}\n\n"}
{"task_id": "CPP/88", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> sort_array(vector<int> array) {\n    // Check if the vector is empty or has only one element\n    if (array.empty() || array.size() == 1) {\n        return array;\n    }\n\n    int first = array.front();\n    int last = array.back();\n\n    // Calculate the sum of the first and last elements\n    int sum = first + last;\n\n    // Determine sorting order based on the sum being odd or even\n    vector<int> sorted_array(array);  // Make a copy to avoid modifying the original vector\n\n    if (sum % 2 == 0) {\n        // Sort in descending order\n        sort(sorted_array.begin(), sorted_array.end(), greater<int>());\n    } else {\n        // Sort in ascending order\n        sort(sorted_array.begin(), sorted_array.end());\n    }\n\n    return sorted_array;\n}\n\n// Function to test the correctness of the solution\nvoid check() {\n    assert(sort_array({}) == vector<int>{});\n    assert(sort_array({5}) == vector<int>{5});\n    assert(sort_array({2, 4, 3, 0, 1, 5}) == vector<int>{0, 1, 2, 3, 4, 5});\n    assert(sort_array({2, 4, 3, 0, 1, 5, 6}) == vector<int>{6, 5, 4, 3, 2, 1, 0});\n}\n\n"}
{"task_id": "CPP/89", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\n// Function to rotate a single character by 4 places\nchar rotateChar(char c) {\n    if (c >= 'a' && c <= 'z') {\n        return ((c - 'a' + 4) % 26) + 'a';\n    } else if (c >= 'A' && c <= 'Z') {\n        return ((c - 'A' + 4) % 26) + 'A';\n    }\n    // Non-alphabetic characters remain unchanged\n    return c;\n}\n\n// Function to encrypt the string by rotating each character\nstring encrypt(string s) {\n    for (char &c : s) {\n        c = rotateChar(c);\n    }\n    return s;\n}\n\n"}
{"task_id": "CPP/90", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint next_smallest(vector<int> lst) {\n    // If the vector is empty or has less than 2 unique elements, return None (represented as -1)\n    if (lst.size() < 2 || std::unique(lst.begin(), lst.end()) == lst.begin() + lst.size()) {\n        return -1; // Using -1 to represent None\n    }\n\n    // Sort the vector and remove duplicates\n    sort(lst.begin(), lst.end());\n    \n    // Return the second smallest element\n    return lst[1];\n}\n\n// Function to test the next_smallest function with provided data points\nvoid check() {\n    assert(next_smallest({1, 2, 3, 4, 5}) == 2);\n    assert(next_smallest({5, 1, 4, 3, 2}) == 2);\n    assert(next_smallest({}) == -1); // Using -1 to represent None\n    assert(next_smallest({1, 1}) == -1); // Using -1 to represent None\n}\n\n"}
{"task_id": "CPP/91", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nint is_bored(string S) {\n    int count = 0;\n    stringstream ss(S);\n    string sentence;\n\n    // Split the input string by '.', '?' or '!'\n    while (getline(ss, sentence, '.')) {\n        if (sentence.empty()) continue; // Skip empty sentences\n        getline(ss, sentence, '?');\n        if (sentence.empty()) continue; // Skip empty sentences\n        getline(ss, sentence, '!');\n\n        // Trim leading and trailing spaces\n        size_t start = sentence.find_first_not_of(\" \\t\");\n        size_t end = sentence.find_last_not_of(\" \\t\");\n\n        if (start == string::npos || end == string::npos) {\n            continue; // Skip empty sentences after trimming\n        }\n\n        sentence = sentence.substr(start, end - start + 1);\n\n        // Check if the sentence starts with \"I\"\n        if (!sentence.empty() && sentence[0] == 'I') {\n            count++;\n        }\n    }\n\n    return count;\n}\n\n"}
{"task_id": "CPP/92", "generation": "#include <stdio.h>\nusing namespace std;\n\nbool any_int(float a, float b, float c) {\n    // Cast floats to integers and check if they are equal when converted back to float\n    int ia = static_cast<int>(a);\n    int ib = static_cast<int>(b);\n    int ic = static_cast<int>(c);\n\n    // Check if the sum of any two numbers equals the third number\n    return (ia == (ib + ic)) || (ib == (ia + ic)) || (ic == (ia + ib));\n}\n\n"}
{"task_id": "CPP/93", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to swap case of a character\nchar swapCase(char c) {\n    if (islower(c)) return toupper(c);\n    else if (isupper(c)) return tolower(c);\n    return c;\n}\n\n// Function to replace vowels with the letter 2 places ahead in the alphabet\nstring replaceVowels(string s) {\n    for (char &c : s) {\n        switch (tolower(c)) {\n            case 'a': c = 'C'; break;\n            case 'e': c = 'G'; break;\n            case 'i': c = 'K'; break;\n            case 'o': c = 'Q'; break;\n            case 'u': c = 'W'; break;\n        }\n    }\n    return s;\n}\n\n// Main encode function\nstring encode(string message) {\n    // Swap the case of all letters\n    transform(message.begin(), message.end(), message.begin(), swapCase);\n    \n    // Replace vowels with the letter 2 places ahead in the alphabet\n    replaceVowels(message);\n\n    return message;\n}\n\n"}
{"task_id": "CPP/94", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\n// Function to check if a number is prime\nbool isPrime(int n) {\n    if (n <= 1) return false;\n    if (n == 2 || n == 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    for (int i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0)\n            return false;\n    }\n    return true;\n}\n\n// Function to calculate the sum of digits of a number\nint sumOfDigits(int num) {\n    int sum = 0;\n    while (num > 0) {\n        sum += num % 10;\n        num /= 10;\n    }\n    return sum;\n}\n\n// Main function to find the largest prime and its digit sum\nint findLargestPrimeDigitSum(vector<int> lst) {\n    int maxPrime = -1;\n    for (int num : lst) {\n        if (isPrime(num)) {\n            if (num > maxPrime)\n                maxPrime = num;\n        }\n    }\n    \n    if (maxPrime == -1) return 0; // No prime number found\n    \n    return sumOfDigits(maxPrime);\n}\n\n// Function to test the solution\nvoid test() {\n    vector<int> lst1 = {0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3};\n    cout << \"Test 1: \" << findLargestPrimeDigitSum(lst1) << endl; // Output should be 10\n\n    vector<int> lst2 = {1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1};\n    cout << \"Test 2: \" << findLargestPrimeDigitSum(lst2) << endl; // Output should be 25\n\n    vector<int> lst3 = {1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3};\n    cout << \"Test 3: \" << findLargestPrimeDigitSum(lst3) << endl; // Output should be 13\n\n    vector<int> lst4 = {0,724,32,71,99,32,6,0,5,91,83,0,5,6};\n    cout << \"Test 4: \" << findLargestPrimeDigitSum(lst4) << endl; // Output should be 11\n\n    vector<int> lst5 = {0,81,12,3,1,21};\n    cout << \"Test 5: \" << findLargestPrimeDigitSum(lst5) << endl; // Output should be 3\n\n    vector<int> lst6 = {0,8,1,2,1,7};\n    cout << \"Test 6: \" << findLargestPrimeDigitSum(lst6) << endl; // Output should be 7\n}\n\n"}
{"task_id": "CPP/95", "generation": "#include <iostream>\n#include <string>\n#include <map>\n\nusing namespace std;\n\nbool check_dict_case(map<string, string> dict) {\n    // Check if the map is empty\n    if (dict.empty()) {\n        return false;\n    }\n\n    // Determine the case of the first key\n    bool allLower = true;\n    for (const auto& pair : dict) {\n        if (!islower(pair.first[0])) {\n            allLower = false;\n            break;\n        }\n    }\n\n    if (allLower) {\n        return true;  // All keys are in lowercase\n    }\n\n    // If not all lower, check if they are all uppercase\n    for (const auto& pair : dict) {\n        if (!isupper(pair.first[0])) {\n            return false;\n        }\n    }\n\n    return true;  // All keys are in uppercase\n}\n\n"}
{"task_id": "CPP/96", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Helper function to check if a number is prime\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    for (int i = 2; i * i <= num; ++i) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\n// Function to generate a vector of prime numbers less than n\nvector<int> count_up_to(int n) {\n    vector<int> primes;\n    for (int i = 2; i < n; ++i) {\n        if (is_prime(i)) {\n            primes.push_back(i);\n        }\n    }\n    return primes;\n}\n\n// Function to test the count_up_to function\nvoid test_count_up_to() {\n    assert(count_up_to(5) == vector<int>({2, 3}));\n    assert(count_up_to(11) == vector<int>({2, 3, 5, 7}));\n    assert(count_up_to(0).empty());\n    assert(count_up_to(20) == vector<int>({2, 3, 5, 7, 11, 13, 17, 19}));\n    assert(count_up_to(1).empty());\n    assert(count_up_to(18) == vector<int>({2, 3, 5, 7, 11, 13, 17}));\n\n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/97", "generation": "#include <iostream>\nusing namespace std;\n\nint multiply(int a, int b) {\n    // Extract the unit digits of both numbers\n    int unitDigitA = abs(a % 10);\n    int unitDigitB = abs(b % 10);\n\n    // Multiply the unit digits and return the result\n    return unitDigitA * unitDigitB;\n}\n\n"}
{"task_id": "CPP/98", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint count_upper(const string& s) {\n    int count = 0;\n    \n    // Iterate over the string considering only even indices\n    for (size_t i = 0; i < s.length(); i += 2) {\n        char c = s[i];\n        \n        // Check if the character is an uppercase vowel\n        if (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n            count++;\n        }\n    }\n    \n    return count;\n}\n\n"}
{"task_id": "CPP/99", "generation": "#include <iostream>\n#include <cmath>\n#include <string>\n\nusing namespace std;\n\nint closest_integer(string value) {\n    // Convert string to float\n    float num = stof(value);\n    \n    // Extract the fractional part of the number\n    float fraction = modf(num, &num);\n    \n    // Check if the number is positive or negative\n    bool isPositive = (num > 0.0);\n    \n    // Determine rounding based on the fractional part and sign\n    if (fraction == 0.5 && isPositive) {\n        return static_cast<int>(ceil(num));\n    } else if (fraction == -0.5 && !isPositive) {\n        return static_cast<int>(floor(num));\n    } else {\n        // Standard rounding for other cases\n        return static_cast<int>(round(num));\n    }\n}\n\n"}
{"task_id": "CPP/100", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Function to make a pile of n levels of stones\nvector<int> make_a_pile(int n) {\n    vector<int> result;\n    \n    // Start with the first level having 'n' stones\n    int current_stones = n;\n    for (int i = 0; i < n; ++i) {\n        result.push_back(current_stones);\n        \n        // Determine the next number of stones based on whether the current number is odd or even\n        if (current_stones % 2 == 0) {\n            // If current_stones is even, add the next even number\n            current_stones += 2;\n        } else {\n            // If current_stones is odd, add the next odd number\n            current_stones += 2;\n        }\n    }\n    \n    return result;\n}\n\n// Function to check the correctness of the make_a_pile function\nvoid check() {\n    vector<int> expected = {3, 5, 7};\n    vector<int> result = make_a_pile(3);\n    \n    if (result == expected) {\n        cout << \"Test passed!\" << endl;\n    } else {\n        cout << \"Test failed. Expected: \";\n        for (int num : expected) {\n            cout << num << \" \";\n        }\n        cout << \"\\nGot: \";\n        for (int num : result) {\n            cout << num << \" \";\n        }\n        cout << endl;\n    }\n}\n\n"}
{"task_id": "CPP/101", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nvector<string> words_string(string s) {\n    vector<string> result;\n    stringstream ss(s);\n    string word;\n\n    while (getline(ss, word, ',')) {  // Split by comma first\n        stringstream wordStream(word);  // Create a new stream for the current word\n        while (wordStream >> word) {  // Extract words from the current word stream\n            result.push_back(word);\n        }\n    }\n\n    return result;\n}\n\n// Function to test the words_string function\nvoid check() {\n    vector<string> result1 = words_string(\"Hi, my name is John\");\n    for (const auto& word : result1) {\n        cout << word << endl;\n    }\n\n    vector<string> result2 = words_string(\"One, two, three, four, five, six\");\n    for (const auto& word : result2) {\n        cout << word << endl;\n    }\n}\n\n"}
{"task_id": "CPP/102", "generation": "#include <iostream>\nusing namespace std;\n\nint choose_num(int x, int y) {\n    // Ensure x <= y for simplicity\n    if (y < x) {\n        swap(x, y);\n    }\n\n    // Check if there is any even number in the range [x, y]\n    for (int i = y; i >= x; --i) {\n        if (i % 2 == 0) {\n            return i;\n        }\n    }\n\n    // If no even number is found\n    return -1;\n}\n\n// Function to test the choose_num function with some examples\nvoid test() {\n    cout << \"choose_num(12, 15): \" << choose_num(12, 15) << endl; // Should output 14\n    cout << \"choose_num(13, 12): \" << choose_num(13, 12) << endl; // Should output -1\n    cout << \"choose_num(10, 18): \" << choose_num(10, 18) << endl; // Should output 18\n    cout << \"choose_num(5, 7): \" << choose_num(5, 7) << endl;     // Should output 6\n}\n\n"}
{"task_id": "CPP/103", "generation": "#include <stdio.h>\n#include <cmath>\n#include <string>\n\nusing namespace std;\n\nstring rounded_avg(int n, int m) {\n    // Check if n is greater than m\n    if (n > m) {\n        return \"-1\";\n    }\n\n    // Calculate the sum of integers from n to m\n    long long sum = 0;\n    for (int i = n; i <= m; ++i) {\n        sum += i;\n    }\n\n    // Calculate the average and round it down\n    int avg = sum / (m - n + 1);\n\n    // Convert the rounded average to a binary string\n    string binary = \"\";\n    if (avg == 0) {\n        binary = \"0\";\n    } else {\n        while (avg > 0) {\n            binary = to_string(avg % 2) + binary;\n            avg /= 2;\n        }\n    }\n\n    return binary;\n}\n\n"}
{"task_id": "CPP/104", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n// Helper function to check if a number contains only odd digits\nbool hasOnlyOddDigits(int num) {\n    while (num > 0) {\n        int digit = num % 10;\n        if (digit % 2 == 0) return false; // If any digit is even, return false\n        num /= 10;\n    }\n    return true;\n}\n\n// Function to return a sorted vector of all elements that have no even digits\nvector<int> unique_digits(vector<int> x) {\n    vector<int> result;\n\n    // Filter out numbers with at least one even digit\n    for (int num : x) {\n        if (hasOnlyOddDigits(num)) {\n            result.push_back(num);\n        }\n    }\n\n    // Sort the resulting vector in increasing order\n    sort(result.begin(), result.end());\n\n    return result;\n}\n\n// Function to test the unique_digits function with provided examples\nvoid test() {\n    vector<int> x1 = {15, 33, 1422, 1};\n    vector<int> expected1 = {1, 15, 33};\n    assert(unique_digits(x1) == expected1);\n\n    vector<int> x2 = {152, 323, 1422, 10};\n    vector<int> expected2 = {};\n    assert(unique_digits(x2) == expected2);\n\n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/105", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to convert a digit to its corresponding name\nstring digit_to_name(int digit) {\n    map<int, string> digit_names = {\n        {1, \"One\"}, {2, \"Two\"}, {3, \"Three\"},\n        {4, \"Four\"}, {5, \"Five\"}, {6, \"Six\"},\n        {7, \"Seven\"}, {8, \"Eight\"}, {9, \"Nine\"}\n    };\n    return digit_names[digit];\n}\n\nvector<string> by_length(vector<int> arr) {\n    // Filter out numbers not in the range 1 to 9\n    vector<int> filtered_arr;\n    for (int num : arr) {\n        if (num >= 1 && num <= 9) {\n            filtered_arr.push_back(num);\n        }\n    }\n\n    // Sort the filtered array\n    sort(filtered_arr.begin(), filtered_arr.end());\n\n    // Reverse the sorted array\n    reverse(filtered_arr.begin(), filtered_arr.end());\n\n    // Convert each number to its corresponding name and store in a vector of strings\n    vector<string> result;\n    for (int num : filtered_arr) {\n        result.push_back(digit_to_name(num));\n    }\n\n    return result;\n}\n\n// Function to test the by_length function\nvoid test() {\n    vector<int> arr1 = {2, 1, 1, 4, 5, 8, 2, 3};\n    vector<string> expected1 = {\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"};\n    assert(by_length(arr1) == expected1);\n\n    vector<int> arr2 = {};\n    vector<string> expected2 = {};\n    assert(by_length(arr2) == expected2);\n\n    vector<int> arr3 = {1, -1, 55};\n    vector<string> expected3 = {\"One\"};\n    assert(by_length(arr3) == expected3);\n\n    printf(\"All tests passed!\\n\");\n}\n\n"}
{"task_id": "CPP/106", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// Function to calculate the factorial of a number\nint factorial(int num) {\n    if (num == 0 || num == 1)\n        return 1;\n    int fact = 1;\n    for (int i = 2; i <= num; ++i) {\n        fact *= i;\n    }\n    return fact;\n}\n\n// Function to calculate the sum of numbers from 1 to a number\nint sumTo(int num) {\n    return (num * (num + 1)) / 2;\n}\n\nvector<int> f(int n) {\n    vector<int> result(n);\n    \n    for (int i = 0; i < n; ++i) {\n        int index = i + 1; // Since i starts from 1\n        if ((index % 2) == 0) { // Check if the index is even\n            result[i] = factorial(index);\n        } else { // If the index is odd\n            result[i] = sumTo(index);\n        }\n    }\n    \n    return result;\n}\n\n// Function to check the correctness of the function f\nvoid check() {\n    vector<int> expected = {1, 2, 6, 24, 15};\n    vector<int> result = f(5);\n    if (result == expected) {\n        cout << \"Correct!\" << endl;\n    } else {\n        cout << \"Incorrect. Expected: \";\n        for (int num : expected)\n            cout << num << \" \";\n        cout << \"\\nGot: \";\n        for (int num : result)\n            cout << num << \" \";\n        cout << endl;\n    }\n}\n\n"}
{"task_id": "CPP/107", "generation": "#include <iostream>\n#include <vector>\n\n// Function to generate all palindromic numbers up to n\nstd::vector<int> generate_palindromes(int n) {\n    std::vector<int> palindromes;\n    \n    // Single digit palindromes are always included\n    for (int i = 1; i <= 9; ++i) {\n        if (i <= n) {\n            palindromes.push_back(i);\n        }\n    }\n\n    // Generate two-digit and multi-digit palindromes\n    for (int d = 2; ; ++d) {\n        int start = std::pow(10, d - 1);\n        int end = std::pow(10, d);\n\n        if (end > n) break;\n\n        // Generate palindrome by fixing the first half and mirroring it\n        for (int i = start; i < end; ++i) {\n            std::string str_i = std::to_string(i);\n            std::string rev_str_i = std::string(str_i.rbegin(), str_i.rend());\n            int palindrome = std::stoi(str_i + rev_str_i.substr(1));\n            if (palindrome <= n) {\n                palindromes.push_back(palindrome);\n            }\n        }\n    }\n\n    return palindromes;\n}\n\n// Function to count even and odd palindromes\nstd::vector<int> even_odd_palindrome(int n) {\n    std::vector<int> palindromes = generate_palindromes(n);\n\n    int even_count = 0, odd_count = 0;\n\n    for (int palindrome : palindromes) {\n        if (palindrome % 2 == 0) {\n            ++even_count;\n        } else {\n            ++odd_count;\n        }\n    }\n\n    return {even_count, odd_count};\n}\n\n// Main function to test the solution\n"}
{"task_id": "CPP/108", "generation": "#include <iostream>\n#include <vector>\n\n// Function to calculate the sum of digits of an integer.\nint sum_of_digits(int num) {\n    int sum = 0;\n    bool isNegative = num < 0;\n    \n    while (num != 0) {\n        int digit = abs(num % 10);\n        sum += digit;\n        num /= 10;\n    }\n    \n    // If the number was negative, subtract the first digit from the sum.\n    if (isNegative && sum > 0) {\n        sum -= digit; // Subtract the last digit which is actually the first signed digit\n    }\n    \n    return sum;\n}\n\n// Function to count numbers with a positive sum of digits.\nint count_nums(const std::vector<int>& n) {\n    int count = 0;\n    for (int num : n) {\n        if (sum_of_digits(num) > 0) {\n            ++count;\n        }\n    }\n    return count;\n}\n\n// Function to test the count_nums function with provided examples.\nvoid test_count_nums() {\n    assert(count_nums({}) == 0);\n    assert(count_nums({-1, 11, -11}) == 1);\n    assert(count_nums({1, 1, 2}) == 3);\n    std::cout << \"All tests passed!\" << std::endl;\n}\n\n"}
{"task_id": "CPP/109", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool move_one_ball(vector<int> arr) {\n    // If the vector is empty, return true\n    if (arr.empty()) {\n        return true;\n    }\n\n    int n = arr.size();\n    int inversions = 0;\n\n    // Count the number of inversions\n    for (int i = 0; i < n - 1; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            if (arr[i] > arr[j]) {\n                inversions++;\n            }\n        }\n    }\n\n    // Check if there is at most one inversion\n    return inversions <= 1;\n}\n\n// Function to test the move_one_ball function with provided examples\nvoid check() {\n    assert(move_one_ball({3, 4, 5, 1, 2}) == true);\n    assert(move_one_ball({3, 5, 4, 1, 2}) == false);\n    assert(move_one_ball({}) == true);\n    cout << \"All test cases passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/110", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring exchange(vector<int> lst1, vector<int> lst2) {\n    // Check if all elements in lst1 are already even\n    bool allEven = true;\n    for (int num : lst1) {\n        if (num % 2 != 0) {\n            allEven = false;\n            break;\n        }\n    }\n\n    // If all elements in lst1 are already even, return \"YES\"\n    if (allEven) {\n        return \"YES\";\n    }\n\n    // Check if there is at least one odd number in lst2\n    bool hasOdd = false;\n    for (int num : lst2) {\n        if (num % 2 != 0) {\n            hasOdd = true;\n            break;\n        }\n    }\n\n    // If there is an odd number in lst2, return \"YES\"\n    if (hasOdd) {\n        return \"YES\";\n    }\n\n    // Otherwise, it's not possible to make all elements in lst1 even\n    return \"NO\";\n}\n\n"}
{"task_id": "CPP/111", "generation": "#include <iostream>\n#include <string>\n#include <map>\nusing namespace std;\n\nmap<char, int> histogram(string test) {\n    map<char, int> letterCount;\n    \n    // Count occurrences of each letter\n    for (char c : test) {\n        if (c != ' ') {  // Ignore spaces\n            letterCount[c]++;\n        }\n    }\n\n    // Find the maximum count\n    int maxCount = 0;\n    for (const auto& pair : letterCount) {\n        if (pair.second > maxCount) {\n            maxCount = pair.second;\n        }\n    }\n\n    // Create a map with letters that have the highest frequency\n    map<char, int> result;\n    for (const auto& pair : letterCount) {\n        if (pair.second == maxCount) {\n            result.insert(pair);\n        }\n    }\n\n    return result;\n}\n\n// Function to print the histogram map\nvoid printHistogram(const map<char, int>& hist) {\n    for (const auto& pair : hist) {\n        cout << \"{\" << pair.first << \", \" << pair.second << \"} \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/112", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to check if a string is a palindrome\nbool is_palindrome(const string& str) {\n    int left = 0;\n    int right = str.size() - 1;\n    \n    while (left < right) {\n        if (str[left] != str[right]) {\n            return false;\n        }\n        ++left;\n        --right;\n    }\n    return true;\n}\n\n// Function to reverse delete characters and check palindrome\nvector<string> reverse_delete(string s, string c) {\n    // Remove all characters in s that are present in c\n    for (char ch : c) {\n        s.erase(remove(s.begin(), s.end(), ch), s.end());\n    }\n    \n    // Check if the resulting string is a palindrome\n    bool result = is_palindrome(s);\n    \n    // Return the result as a vector of strings\n    return {s, to_string(result)};\n}\n\n"}
{"task_id": "CPP/113", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<string> odd_count(vector<string> lst) {\n    vector<string> result;\n    \n    for (const auto& str : lst) {\n        int count = 0;\n        \n        // Count the number of odd digits in the current string\n        for (char c : str) {\n            if ((c - '0') % 2 != 0) {\n                count++;\n            }\n        }\n        \n        // Construct the result string\n        string new_str = \"the number of odd elements \";\n        new_str += to_string(count);\n        new_str += \"n the str\";\n        new_str += to_string(count);\n        new_str += \"ng \";\n        new_str += to_string(count);\n        new_str += \" of the \";\n        new_str += to_string(count);\n        new_str += \"nput.\";\n        \n        result.push_back(new_str);\n    }\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/114", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nlong long minSubArraySum(vector<long long> nums) {\n    if (nums.empty()) return 0; // Handle empty vector case\n\n    long long current_min = nums[0];\n    long long global_min = nums[0];\n\n    for (size_t i = 1; i < nums.size(); ++i) {\n        // Update the current minimum sum\n        current_min = min(nums[i], current_min + nums[i]);\n        \n        // Update the global minimum sum if needed\n        global_min = min(global_min, current_min);\n    }\n\n    return global_min;\n}\n\n"}
{"task_id": "CPP/115", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint max_fill(vector<vector<int>> grid, int capacity) {\n    int total_drops = 0;\n    \n    // Iterate through each row (well)\n    for (const auto& row : grid) {\n        int water_units = 0;\n        \n        // Count the number of units of water in the current well\n        for (int unit : row) {\n            if (unit == 1) {\n                ++water_units;\n            }\n        }\n        \n        // Calculate the number of drops needed for this well\n        if (water_units > 0) {\n            total_drops += (water_units + capacity - 1) / capacity; // Ceiling division\n        }\n    }\n    \n    return total_drops;\n}\n\n"}
{"task_id": "CPP/116", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\n// Function to count the number of ones in the binary representation of an integer\nint count_ones(int n) {\n    int count = 0;\n    while (n > 0) {\n        count += n & 1; // Check if the least significant bit is set\n        n >>= 1; // Right shift to check the next bit\n    }\n    return count;\n}\n\n// Custom comparator for sorting\nbool custom_sort(int a, int b) {\n    int ones_a = count_ones(a);\n    int ones_b = count_ones(b);\n\n    if (ones_a == ones_b) {\n        return a < b; // Sort by decimal value if the number of ones is the same\n    }\n    return ones_a < ones_b; // Otherwise, sort by the number of ones\n}\n\n// Function to sort the array based on the custom comparator\nstd::vector<int> sort_array(std::vector<int> arr) {\n    std::sort(arr.begin(), arr.end(), custom_sort);\n    return arr;\n}\n\n"}
{"task_id": "CPP/117", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\n// Helper function to check if a character is a consonant.\nbool is_consonant(char c) {\n    return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z');\n}\n\n// Helper function to count the number of consonants in a word.\nint count_consonants(const string& word) {\n    int count = 0;\n    for (char c : word) {\n        if (is_consonant(c)) {\n            ++count;\n        }\n    }\n    return count;\n}\n\nvector<string> select_words(string s, int n) {\n    vector<string> result;\n    // Split the string into words.\n    size_t start = 0;\n    size_t end = s.find(' ');\n    \n    while (end != string::npos) {\n        string word = s.substr(start, end - start);\n        if (count_consonants(word) == n) {\n            result.push_back(word);\n        }\n        start = end + 1;\n        end = s.find(' ', start);\n    }\n    \n    // Check the last segment of the string.\n    string last_word = s.substr(start);\n    if (!last_word.empty() && count_consonants(last_word) == n) {\n        result.push_back(last_word);\n    }\n\n    return result;\n}\n\n// Function to test the select_words function with provided examples.\nvoid test_select_words() {\n    assert(select_words(\"Mary had a little lamb\", 4) == vector<string>{\"little\"});\n    assert(select_words(\"Mary had a little lamb\", 3) == vector<string>{\"Mary\", \"lamb\"});\n    assert(select_words(\"simple white space\", 2) == vector<string>{});\n    assert(select_words(\"Hello world\", 4) == vector<string>{\"world\"});\n    assert(select_words(\"Uncle sam\", 3) == vector<string>{\"Uncle\"});\n\n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/118", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_vowel(char c) {\n    // Check if the character is a vowel (case sensitive)\n    return tolower(c) == 'a' || tolower(c) == 'e' || tolower(c) == 'i' || \n           tolower(c) == 'o' || tolower(c) == 'u';\n}\n\nbool is_consonant(char c) {\n    // Check if the character is a consonant (case sensitive)\n    return !is_vowel(c);\n}\n\nstring get_closest_vowel(string word) {\n    int n = word.length();\n    \n    // Start from the second last character and move towards the beginning\n    for (int i = n - 2; i >= 0; --i) {\n        if (is_consonant(word[i + 1]) && is_consonant(word[i])) {\n            // Check if the current character is a vowel\n            if (is_vowel(word[i])) {\n                return string(1, word[i]);\n            }\n        }\n    }\n\n    // If no such vowel is found, return an empty string\n    return \"\";\n}\n\n"}
{"task_id": "CPP/119", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Helper function to check if a given string is balanced\nbool is_balanced(const string& s) {\n    int balance = 0;\n    for (char c : s) {\n        if (c == '(') {\n            ++balance;\n        } else if (c == ')') {\n            --balance;\n            if (balance < 0) {\n                return false; // More closing parentheses than opening ones\n            }\n        }\n    }\n    return balance == 0; // True if balanced, false otherwise\n}\n\n// Main function to check if it's possible to make a good string by concatenating two strings in some order\nstring match_parens(vector<string> lst) {\n    string s1 = lst[0];\n    string s2 = lst[1];\n\n    // Check both possible concatenations\n    if (is_balanced(s1 + s2) || is_balanced(s2 + s1)) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\n\n"}
{"task_id": "CPP/120", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n// Function to find the k maximum elements in arr and return them in ascending order.\nvector<int> maximum(vector<int> arr, int k) {\n    // Use nth_element to partially sort the array such that the first k elements are the largest k numbers\n    nth_element(arr.begin(), arr.begin() + k - 1, arr.end(), greater<int>());\n    \n    // Extract the first k elements and sort them in ascending order\n    vector<int> result(arr.begin(), arr.begin() + k);\n    sort(result.begin(), result.end());\n    \n    return result;\n}\n\n// Function to print a vector\nvoid printVector(const vector<int>& vec) {\n    for (int num : vec) {\n        cout << num << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/121", "generation": "#include <vector>\nusing namespace std;\n\nint solution(vector<int> lst) {\n    int sum = 0;\n    for (size_t i = 0; i < lst.size(); ++i) {\n        // Check if the index is even and the element at that position is odd\n        if (i % 2 == 0 && lst[i] % 2 != 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n\n// Function to test the solution with provided examples\nvoid check_solution() {\n    assert(solution({5, 8, 7, 1}) == 12);\n    assert(solution({3, 3, 3, 3, 3}) == 9);\n    assert(solution({30, 13, 24, 321}) == 0);\n}\n\n"}
{"task_id": "CPP/122", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint add_elements(vector<int> arr, int k) {\n    int sum = 0;\n    for (int i = 0; i < k; ++i) {\n        // Check if the absolute value of the element is less than 100\n        if (abs(arr[i]) < 100) {\n            sum += arr[i];\n        }\n    }\n    return sum;\n}\n\n// Function to test the solution with provided data points\nvoid check_solution() {\n    vector<int> arr = {111, 21, 3, 4000, 5, 6, 7, 8, 9};\n    int k = 4;\n    cout << \"Sum of elements with at most two digits from the first \" << k << \" elements: \" \n         << add_elements(arr, k) << endl; // Expected output: 24\n\n    arr = {10, 20, 30, 40, 50};\n    k = 5;\n    cout << \"Sum of elements with at most two digits from the first \" << k << \" elements: \" \n         << add_elements(arr, k) << endl; // Expected output: 60\n\n    arr = {123, 45, 6789, 101, 2};\n    k = 3;\n    cout << \"Sum of elements with at most two digits from the first \" << k << \" elements: \" \n         << add_elements(arr, k) << endl; // Expected output: 47\n}\n\n"}
{"task_id": "CPP/123", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n// Function to generate and return the odd numbers in the Collatz sequence of n.\nvector<int> get_odd_collatz(int n) {\n    vector<int> result;\n    \n    // Generate the Collatz sequence for n\n    while (n != 1) {\n        if (n % 2 == 0) {\n            n = n / 2;  // If n is even, divide it by 2\n        } else {\n            result.push_back(n);  // If n is odd, add it to the result vector\n            n = 3 * n + 1;  // Apply the Collatz operation for odd numbers\n        }\n    }\n    \n    // Add the final number 1 to the result vector (since 1 is always an odd number in the sequence)\n    result.push_back(1);\n    \n    // Sort the result vector in increasing order\n    sort(result.begin(), result.end());\n    \n    return result;\n}\n\n// Function to test the get_odd_collatz function with some example inputs.\nvoid test_get_odd_collatz() {\n    cout << \"Testing get_odd_collatz...\" << endl;\n    vector<int> result1 = get_odd_collatz(5);\n    for (int num : result1) {\n        cout << num << \" \";\n    }\n    cout << endl;\n\n    vector<int> result2 = get_odd_collatz(7);\n    for (int num : result2) {\n        cout << num << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/124", "generation": "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nbool valid_date(string date) {\n    // Check if the date format is mm-dd-yyyy\n    size_t pos = 0;\n    int month, day, year;\n    \n    // Extract month (mm)\n    pos = date.find(\"-\");\n    if (pos == string::npos || pos != 5) return false;\n    month = stoi(date.substr(0, pos));\n    \n    // Extract day (dd)\n    pos = date.find(\"-\", pos + 1);\n    if (pos == string::npos || pos != 8) return false;\n    day = stoi(date.substr(pos + 1, 2));\n    \n    // Extract year (yyyy)\n    year = stoi(date.substr(pos + 3));\n    \n    // Check month range\n    if (month < 1 || month > 12) return false;\n\n    // Validate days based on the month\n    vector<int> months_with_31_days = {1, 3, 5, 7, 8, 10, 12};\n    vector<int> months_with_30_days = {4, 6, 9, 11};\n\n    if (months_with_31_days.count(month) > 0 && day < 1 || day > 31) return false;\n    else if (months_with_30_days.count(month) > 0 && day < 1 || day > 30) return false;\n    else if (month == 2 && (day < 1 || day > 29)) return false;\n\n    // If all checks pass, the date is valid\n    return true;\n}\n\n"}
{"task_id": "CPP/125", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to count lowercase letters with odd order in the alphabet\nint countOddOrderLowercaseLetters(const string& str) {\n    int count = 0;\n    for (char c : str) {\n        if (islower(c)) {\n            // Convert character to its corresponding index in the alphabet\n            int index = static_cast<int>(c - 'a');\n            if (index % 2 == 1) {\n                count++;\n            }\n        }\n    }\n    return count;\n}\n\n// Function to split words based on whitespace, commas, or count lowercase letters with odd order\nvector<string> split_words(string txt) {\n    vector<string> result;\n\n    // Check for whitespace splitting\n    size_t start = 0;\n    while (start < txt.size()) {\n        size_t end = txt.find(' ', start);\n        if (end == string::npos) {\n            end = txt.find(',', start); // Try to find a comma next\n            if (end == string::npos) { // If no whitespace or comma, return the count of lowercase letters with odd order\n                result.push_back(to_string(countOddOrderLowercaseLetters(txt.substr(start))));\n                break;\n            }\n        }\n\n        if (start < end) {\n            result.push_back(txt.substr(start, end - start));\n        }\n        start = end + 1; // Move to the next part of the string\n    }\n\n    return result;\n}\n\n// Function to test the split_words function with provided examples\nvoid test_split_words() {\n    vector<string> result;\n\n    result = split_words(\"Hello world!\");\n    for (const auto& word : result) {\n        cout << word << endl; // Should print: Hello, world!\n    }\n\n    result = split_words(\"Hello,world!\");\n    for (const auto& word : result) {\n        cout << word << endl; // Should print: Hello, world!\n    }\n\n    result = split_words(\"abcdef\");\n    for (const auto& word : result) {\n        cout << word << endl; // Should print: 3\n    }\n}\n\n"}
{"task_id": "CPP/126", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nbool is_sorted(vector<int> lst) {\n    // Check if the list is already sorted or not\n    bool ascending = true;\n    for (int i = 0; i < lst.size() - 1 && ascending; ++i) {\n        if (lst[i] > lst[i + 1]) {\n            ascending = false;\n        }\n    }\n\n    // If it's not sorted, return false immediately\n    if (!ascending) {\n        return false;\n    }\n\n    // Check for any number appearing more than twice\n    int count[200] = {0}; // Assuming the maximum possible value is 199 (since no negative numbers and only integers)\n    for (int num : lst) {\n        if (++count[num] > 2) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\n// Function to test the is_sorted function with provided examples\nvoid check() {\n    assert(is_sorted({5}) == true);\n    assert(is_sorted({1, 2, 3, 4, 5}) == true);\n    assert(is_sorted({1, 3, 2, 4, 5}) == false);\n    assert(is_sorted({1, 2, 3, 4, 5, 6}) == true);\n    assert(is_sorted({1, 2, 3, 4, 5, 6, 7}) == true);\n    assert(is_sorted({1, 3, 2, 4, 5, 6, 7}) == false);\n    assert(is_sorted({1, 2, 2, 3, 3, 4}) == true);\n    assert(is_sorted({1, 2, 2, 2, 3, 4}) == false);\n\n    cout << \"All tests passed.\" << endl;\n}\n\n"}
{"task_id": "CPP/127", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to check if a number is prime\nbool isPrime(int n) {\n    if (n <= 1) return false;\n    if (n == 2 || n == 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    for (int i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0)\n            return false;\n    }\n    return true;\n}\n\n// Function to find the intersection of two intervals\nvector<int> intersect(vector<int> interval1, vector<int> interval2) {\n    int start = max(interval1[0], interval2[0]);\n    int end = min(interval1[1], interval2[1]);\n    \n    if (start > end) return {}; // No intersection\n    \n    return {start, end};\n}\n\n// Main function to determine the result\nstring intersection(vector<int> interval1, vector<int> interval2) {\n    vector<int> intersectionInterval = intersect(interval1, interval2);\n    \n    if (intersectionInterval.empty()) return \"NO\";\n    \n    int length = intersectionInterval[1] - intersectionInterval[0];\n    \n    if (isPrime(length)) return \"YES\";\n    else return \"NO\";\n}\n\n// Function to test the solution with provided examples\nvoid test() {\n    cout << intersection({1, 2}, {2, 3}) << endl; // Output: NO\n    cout << intersection({-1, 1}, {0, 4}) << endl; // Output: NO\n    cout << intersection({-3, -1}, {-5, 5}) << endl; // Output: YES\n}\n\n"}
{"task_id": "CPP/128", "generation": "#include <stdio.h>\n#include <vector>\n\nint prod_signs(const std::vector<int>& arr) {\n    if (arr.empty()) {\n        return -32768;\n    }\n\n    int sum_of_magnitudes = 0;\n    int product_of_signs = 1;\n\n    for (const auto& num : arr) {\n        // Add the magnitude of the number to the sum\n        sum_of_magnitudes += std::abs(num);\n\n        // Multiply the product of signs by -1 if the number is negative, or keep it as 1 if positive.\n        // If the number is zero, set the product of signs to 0 and break out of the loop since any further multiplication will be 0.\n        if (num == 0) {\n            product_of_signs = 0;\n            break;\n        } else if (num < 0) {\n            product_of_signs *= -1;\n        }\n    }\n\n    // Return the sum of magnitudes multiplied by the product of signs\n    return sum_of_magnitudes * product_of_signs;\n}\n\n// Example usage:\n"}
{"task_id": "CPP/129", "generation": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <set>\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef tuple<int, int, vector<int>> tiii;\n\nconst int dx[4] = {0, 1, 0, -1};\nconst int dy[4] = {1, 0, -1, 0};\n\nvector<int> minPath(vector<vector<int>>& grid, int k) {\n    int n = grid.size();\n    priority_queue<tiii, vector<tiii>, greater<>> pq;\n    \n    // Initialize the starting state: (row, col, path)\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            pq.push({grid[i][j], i * n + j, {grid[i][j]}});\n        }\n    }\n\n    set<vector<int>> visited;\n    \n    while (!pq.empty()) {\n        auto [val, pos, path] = pq.top();\n        pq.pop();\n\n        if (path.size() == k) {\n            return path; // Found the minimum path of length k\n        }\n\n        int x = pos / n, y = pos % n;\n\n        for (int i = 0; i < 4; ++i) {\n            int nx = x + dx[i], ny = y + dy[i];\n            if (nx >= 0 && nx < n && ny >= 0 && ny < n) {\n                vector<int> newPath = path;\n                newPath.push_back(grid[nx][ny]);\n                tiii newState = {grid[nx][ny], nx * n + ny, newPath};\n                \n                // Check if this state has already been visited with the same length\n                if (visited.find(newPath) == visited.end()) {\n                    pq.push(newState);\n                    visited.insert(newPath);\n                }\n            }\n        }\n    }\n\n    return {}; // This should never be reached due to problem constraints\n}\n\n"}
{"task_id": "CPP/130", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Function to calculate the tribonacci number for a given n\nint tribonacci(int n) {\n    if (n == 0) return 3;\n    else if (n % 2 == 0) return 1 + n / 2;\n    else {\n        // Recursively calculate tri(n-1), tri(n-2), and tri(n+1)\n        int a = tribonacci(n - 1);\n        int b = tribonacci(n - 2);\n        int c = tribonacci(n + 1);\n        return a + b + c;\n    }\n}\n\n// Function to generate the first n + 1 numbers of the Tribonacci sequence\nvector<int> tri(int n) {\n    vector<int> result;\n    for (int i = 0; i <= n; ++i) {\n        result.push_back(tribonacci(i));\n    }\n    return result;\n}\n\n// Main function to test the implementation\n"}
{"task_id": "CPP/131", "generation": "#include <iostream>\nusing namespace std;\n\nint digits(int n) {\n    int product = 1;\n    bool hasOddDigit = false;\n\n    while (n > 0) {\n        int digit = n % 10;\n        if (digit % 2 != 0) { // Check if the digit is odd\n            product *= digit;\n            hasOddDigit = true;\n        }\n        n /= 10; // Remove the last digit\n    }\n\n    return hasOddDigit ? product : 0;\n}\n\n"}
{"task_id": "CPP/132", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_nested(string str) {\n    int balance = 0;\n    bool hasNested = false;\n\n    for (char ch : str) {\n        if (ch == '[') {\n            balance++;\n            // Check if there's a nested structure starting here\n            if (balance > 1 && !hasNested) {\n                hasNested = true;\n            }\n        } else if (ch == ']') {\n            balance--;\n            if (balance < 0) {\n                return false; // Unbalanced brackets\n            }\n        }\n    }\n\n    // Check if there was at least one nested structure and the string is balanced\n    return hasNested && balance == 0;\n}\n\n"}
{"task_id": "CPP/133", "generation": "#include <stdio.h>\n#include <math.h>\n#include <vector>\n\nusing namespace std;\n\nint sum_squares(vector<float> lst) {\n    int sum = 0;\n    \n    for (float num : lst) {\n        // Round up to the nearest integer\n        float ceil_num = ceil(num);\n        \n        // Square the rounded number and add it to the sum\n        sum += static_cast<int>(ceil_num * ceil_num);\n    }\n    \n    return sum;\n}\n\n// Function to test the correctness of the solution\nvoid check() {\n    assert(sum_squares({1, 2, 3}) == 14);\n    assert(sum_squares({1, 4, 9}) == 98);\n    assert(sum_squares({1, 3, 5, 7}) == 84);\n    assert(sum_squares({1.4f, 4.2f, 0.0f}) == 29);\n    assert(sum_squares({-2.4f, 1.0f, 1.0f}) == 6);\n    \n    printf(\"All test cases passed!\\n\");\n}\n\n"}
{"task_id": "CPP/134", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool check_if_last_char_is_a_letter(string txt) {\n    // Check if the string is empty\n    if (txt.empty()) {\n        return false;\n    }\n\n    // Get the last character of the string\n    char lastChar = txt.back();\n\n    // Check if the last character is an alphabetical character\n    if (!isalpha(lastChar)) {\n        return false;\n    }\n\n    // Check if the last character is not part of a word\n    size_t pos = txt.find_last_not_of(\" \");\n    if (pos == string::npos || pos != txt.length() - 1) {\n        return false;\n    }\n\n    return true;\n}\n\n"}
{"task_id": "CPP/135", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint can_arrange(vector<int> arr) {\n    int n = arr.size();\n    \n    if (n <= 1) {\n        // If the vector has one or no elements, there is no preceding element to compare with.\n        return -1;\n    }\n    \n    for (int i = n - 2; i >= 0; --i) {\n        if (arr[i] > arr[i + 1]) {\n            // Found an element that is not greater than or equal to its preceding element\n            return i;\n        }\n    }\n    \n    // If no such element was found, return -1\n    return -1;\n}\n\n"}
{"task_id": "CPP/136", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Function to find the largest negative and smallest positive integers in a vector\nvector<int> largest_smallest_integers(vector<int> lst) {\n    int max_negative = INT_MIN; // Initialize with the smallest possible integer\n    int min_positive = INT_MAX; // Initialize with the largest possible integer\n\n    bool hasNegative = false;\n    bool hasPositive = false;\n\n    for (int num : lst) {\n        if (num < 0) {\n            hasNegative = true;\n            max_negative = max(max_negative, num);\n        } else if (num > 0) {\n            hasPositive = true;\n            min_positive = min(min_positive, num);\n        }\n    }\n\n    // If no negative or positive integers are found, return {0, 0}\n    if (!hasNegative && !hasPositive) {\n        return {0, 0};\n    } else {\n        return {max_negative, min_positive};\n    }\n}\n\n// Function to test the largest_smallest_integers function\nvoid test() {\n    vector<int> lst1 = {2, 4, 1, 3, 5, 7};\n    vector<int> result1 = largest_smallest_integers(lst1);\n    cout << \"Test 1: {\" << result1[0] << \", \" << result1[1] << \"}\" << endl;\n\n    vector<int> lst2 = {};\n    vector<int> result2 = largest_smallest_integers(lst2);\n    cout << \"Test 2: {\" << result2[0] << \", \" << result2[1] << \"}\" << endl;\n\n    vector<int> lst3 = {0};\n    vector<int> result3 = largest_smallest_integers(lst3);\n    cout << \"Test 3: {\" << result3[0] << \", \" << result3[1] << \"}\" << endl;\n}\n\n"}
{"task_id": "CPP/137", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <boost/any.hpp>\n\n// Function to compare two boost::any objects and return the larger one in its original type.\nboost::any compare_one(boost::any a, boost::any b) {\n    // Convert both values to strings for comparison\n    std::string strA = boost::any_cast<std::string>(a);\n    std::string strB = boost::any_cast<std::string>(b);\n\n    // Remove commas from the string if present (for string representations of floats)\n    std::replace(strA.begin(), strA.end(), ',', '.');\n    std::replace(strB.begin(), strB.end(), ',', '.');\n\n    // Convert strings to doubles for comparison\n    double numA = std::stod(strA);\n    double numB = std::stod(strB);\n\n    // Compare the numeric values and return the larger one in its original type\n    if (numA > numB) {\n        return a;\n    } else if (numB > numA) {\n        return b;\n    } else {\n        return boost::any();  // Return \"None\" as an empty boost::any object\n    }\n}\n\n"}
{"task_id": "CPP/138", "generation": "#include <iostream>\nusing namespace std;\n\nbool is_equal_to_sum_even(int n) {\n    // Check if n is less than the smallest possible sum of 4 positive even numbers\n    if (n < 8) {\n        return false;\n    }\n    // If n is 8 or greater, it can always be written as a sum of 4 positive even numbers\n    return true;\n}\n\n"}
{"task_id": "CPP/139", "generation": "#include <iostream>\n\n// Function to calculate factorial of a number\nlong long factorial(long long num) {\n    if (num == 0 || num == 1)\n        return 1;\n    else\n        return num * factorial(num - 1);\n}\n\n// Function to calculate Brazilian factorial\nlong long special_factorial(int n) {\n    long long result = 1;\n    for (int i = n; i > 0; --i) {\n        result *= factorial(i);\n    }\n    return result;\n}\n\n"}
{"task_id": "CPP/140", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring fix_spaces(string text) {\n    string result;\n    int space_count = 0;\n\n    for (char ch : text) {\n        if (ch == ' ') {\n            space_count++;\n            // If there are more than two consecutive spaces, replace them with '-'\n            if (space_count > 2) {\n                if (!result.empty() && result.back() != '-') {\n                    result += '-';\n                }\n                space_count = 1; // Reset the count after replacing\n            }\n        } else {\n            // If it's not a space or we've just replaced more than two spaces, add an underscore\n            if (space_count > 0) {\n                result += '_';\n                space_count = 0;\n            }\n            result += ch;\n        }\n    }\n\n    // Handle trailing spaces\n    if (space_count > 2 && !result.empty() && result.back() != '-') {\n        result += '-';\n    } else if (space_count == 1) {\n        result.pop_back(); // Remove the last underscore added for a single space\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/141", "generation": "#include <iostream>\n#include <string>\n#include <cctype> // for std::isalpha and std::isdigit\n\nusing namespace std;\n\nbool isValidName(const string& name) {\n    int digitCount = 0;\n    size_t dotPos = name.find('.');\n    \n    // Check if there is exactly one dot\n    if (dotPos == string::npos || dotPos + 1 == name.length()) return false;\n    \n    // Check the substring before the dot\n    for (size_t i = 0; i < dotPos; ++i) {\n        if (!std::isalpha(name[i])) return false;\n    }\n    \n    // Check the substring after the dot\n    string extension = name.substr(dotPos + 1);\n    if (extension != \"txt\" && extension != \"exe\" && extension != \"dll\") return false;\n    \n    // Count digits in the entire name\n    for (char c : name) {\n        if (std::isdigit(c)) ++digitCount;\n    }\n    \n    // Check if there are more than three digits\n    return digitCount <= 3;\n}\n\nstring file_name_check(string file_name) {\n    return isValidName(file_name) ? \"Yes\" : \"No\";\n}\n\n"}
{"task_id": "CPP/142", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint sum_squares(vector<int> lst) {\n    int sum = 0;\n    \n    for (size_t i = 0; i < lst.size(); ++i) {\n        if ((i % 3 == 0 && i != 0) || (i % 4 == 0)) {\n            // If the index is a multiple of 3, square the integer\n            if (i % 3 == 0) {\n                sum += lst[i] * lst[i];\n            }\n            // If the index is a multiple of 4 and not a multiple of 3, cube the integer\n            else if (i % 4 == 0) {\n                sum += lst[i] * lst[i] * lst[i];\n            }\n        } else {\n            // Add the original value to the sum if the index is neither a multiple of 3 nor 4\n            sum += lst[i];\n        }\n    }\n    \n    return sum;\n}\n\n"}
{"task_id": "CPP/143", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    if (n == 2 || n == 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    for (int i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0)\n            return false;\n    }\n    return true;\n}\n\n// Function to extract words with prime length from the sentence\nstring words_in_sentence(string sentence) {\n    stringstream ss(sentence);\n    string word, result = \"\";\n    \n    while (ss >> word) {\n        if (is_prime(word.length())) {\n            if (!result.empty()) \n                result += \" \";\n            result += word;\n        }\n    }\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/144", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\n// Function to simplify two fractions and check if their product is a whole number\nbool simplify(string x, string n) {\n    // Helper function to parse fraction from string\n    auto parse_fraction = [](const string& fraction) -> pair<int, int> {\n        size_t slash_pos = fraction.find('/');\n        int numerator = stoi(fraction.substr(0, slash_pos));\n        int denominator = stoi(fraction.substr(slash_pos + 1));\n        return {numerator, denominator};\n    };\n\n    // Parse the fractions\n    auto [x_numerator, x_denominator] = parse_fraction(x);\n    auto [n_numerator, n_denominator] = parse_fraction(n);\n\n    // Compute the product of numerators and denominators\n    int product_numerator = x_numerator * n_numerator;\n    int product_denominator = x_denominator * n_denominator;\n\n    // Check if the product is a whole number\n    return (product_numerator % product_denominator) == 0;\n}\n\n"}
{"task_id": "CPP/145", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n// Helper function to calculate the sum of digits of a number\nint digitSum(int num) {\n    int sum = 0;\n    bool isNegative = num < 0;\n    while (num != 0) {\n        int digit = abs(num % 10);\n        sum += digit;\n        num /= 10;\n    }\n    return isNegative ? -sum : sum;\n}\n\n// Comparator function for sorting\nbool compareByDigitSumAndIndex(int a, int b, const vector<int>& originalIndices) {\n    int sumA = digitSum(a);\n    int sumB = digitSum(b);\n\n    if (sumA == sumB) {\n        return originalIndices[a] < originalIndices[b];\n    }\n    return sumA < sumB;\n}\n\nvector<int> order_by_points(vector<int> nums) {\n    vector<int> sortedNums(nums); // Copy the original vector\n    vector<int> originalIndices(sortedNums.size());\n    \n    for (int i = 0; i < sortedNums.size(); ++i) {\n        originalIndices[i] = i;\n    }\n\n    // Sort using a custom comparator\n    sort(sortedNums.begin(), sortedNums.end(), [&](int a, int b) {\n        return compareByDigitSumAndIndex(a, b, originalIndices);\n    });\n\n    return sortedNums;\n}\n\n// Function to check the correctness of the solution\nvoid check() {\n    vector<int> test1 = {1, 11, -1, -11, -12};\n    vector<int> expected1 = {-1, -11, 1, -12, 11};\n    assert(order_by_points(test1) == expected1);\n\n    vector<int> test2 = {};\n    vector<int> expected2 = {};\n    assert(order_by_points(test2) == expected2);\n\n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/146", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint specialFilter(vector<int> nums) {\n    int count = 0;\n    \n    for (int num : nums) {\n        // Skip numbers less than or equal to 10\n        if (num <= 10) continue;\n        \n        // Convert the number to a string to easily access digits\n        string strNum = to_string(abs(num));\n        \n        // Check if both first and last digits are odd\n        int firstDigit = strNum[0] - '0';\n        int lastDigit = strNum[strNum.length() - 1] - '0';\n        \n        if (firstDigit % 2 != 0 && lastDigit % 2 != 0) {\n            count++;\n        }\n    }\n    \n    return count;\n}\n\n"}
{"task_id": "CPP/147", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nint get_max_triples(int n){\n    // Step 1: Generate vector a\n    vector<int> a(n);\n    for (int i = 1; i <= n; ++i) {\n        a[i-1] = i * i - i + 1;\n    }\n\n    int count = 0;\n\n    // Step 2 and 3: Iterate through all triples (i, j, k)\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            for (int k = j + 1; k < n; ++k) {\n                if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                    count++;\n                }\n            }\n        }\n    }\n\n    return count;\n}\n\n// Example usage\n"}
{"task_id": "CPP/148", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to return all planets between planet1 and planet2 in order from closest to farthest from the sun.\nvector<string> bf(string planet1, string planet2) {\n    vector<string> planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n    \n    // Find the indices of planet1 and planet2 in the sorted list\n    int index1 = -1, index2 = -1;\n    for (int i = 0; i < planets.size(); ++i) {\n        if (planets[i] == planet1) index1 = i;\n        if (planets[i] == planet2) index2 = i;\n    }\n    \n    // If either of the planets is not found, return an empty vector\n    if (index1 == -1 || index2 == -1) {\n        return {};\n    }\n    \n    // Ensure index1 < index2 for correct order\n    if (index1 > index2) swap(index1, index2);\n    \n    // Return the sublist of planets between index1 and index2\n    vector<string> result;\n    for (int i = index1 + 1; i < index2; ++i) {\n        result.push_back(planets[i]);\n    }\n    \n    return result;\n}\n\n// Function to test the bf function with some examples\nvoid test() {\n    vector<string> result;\n\n    // Test case 1: Jupiter and Neptune\n    result = bf(\"Jupiter\", \"Neptune\");\n    for (const auto& planet : result) {\n        cout << planet << \" \";\n    }\n    cout << endl; // Expected output: Saturn Uranus\n\n    // Test case 2: Earth and Mercury\n    result = bf(\"Earth\", \"Mercury\");\n    for (const auto& planet : result) {\n        cout << planet << \" \";\n    }\n    cout << endl; // Expected output: Venus\n\n    // Test case 3: Mercury and Uranus\n    result = bf(\"Mercury\", \"Uranus\");\n    for (const auto& planet : result) {\n        cout << planet << \" \";\n    }\n    cout << endl; // Expected output: Venus Earth Mars Jupiter Saturn\n}\n\n"}
{"task_id": "CPP/149", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to sort the vector of strings based on given criteria\nvector<string> sorted_list_sum(vector<string> lst) {\n    // Remove strings with odd lengths\n    lst.erase(remove_if(lst.begin(), lst.end(), [](const string& s) { return s.length() % 2 != 0; }), lst.end());\n\n    // Sort the vector by length, and then alphabetically if lengths are equal\n    sort(lst.begin(), lst.end(), [](const string& a, const string& b) {\n        if (a.length() == b.length()) {\n            return a < b;\n        }\n        return a.length() < b.length();\n    });\n\n    return lst;\n}\n\n// Function to check the correctness of the solution\nvoid check() {\n    assert((sorted_list_sum({\"aa\", \"a\", \"aaa\"}) == vector<string>{\"aa\"}));\n    assert((sorted_list_sum({\"ab\", \"a\", \"aaa\", \"cd\"}) == vector<string>{\"ab\", \"cd\"}));\n}\n\n"}
{"task_id": "CPP/150", "generation": "#include <stdio.h>\n\n// Helper function to check if a number is prime\nint is_prime(int num) {\n    if (num <= 1) return 0; // Numbers less than or equal to 1 are not prime\n    for (int i = 2; i * i <= num; i++) {\n        if (num % i == 0) return 0; // If divisible by any number, it's not prime\n    }\n    return 1; // Prime number\n}\n\n// Main function to determine x or y based on whether n is prime\nint x_or_y(int n, int x, int y) {\n    if (is_prime(n)) {\n        return x;\n    } else {\n        return y;\n    }\n}\n\n"}
{"task_id": "CPP/151", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nlong long double_the_difference(vector<float> lst) {\n    long long sum = 0;\n    \n    // Iterate through each element in the list\n    for (float num : lst) {\n        // Check if the number is positive, an integer, and odd\n        if (num > 0 && floor(num) == num && static_cast<int>(num) % 2 != 0) {\n            sum += pow(num, 2);\n        }\n    }\n    \n    return sum;\n}\n\n// Function to test the correctness of the solution\nvoid check() {\n    assert(double_the_difference({1, 3, 2, 0}) == 10);\n    assert(double_the_difference({-1, -2, 0}) == 0);\n    assert(double_the_difference({9, -2}) == 81);\n    assert(double_the_difference({0}) == 0);\n    assert(double_the_difference({}) == 0); // Testing with an empty vector\n}\n\n"}
{"task_id": "CPP/152", "generation": "#include <stdio.h>\n#include <math.h>\n#include <vector>\nusing namespace std;\n\nvector<int> compare(vector<int> game, vector<int> guess) {\n    vector<int> result;\n    \n    // Iterate through each match\n    for (size_t i = 0; i < game.size(); ++i) {\n        // Calculate the absolute difference between the score and the guess\n        int diff = abs(game[i] - guess[i]);\n        \n        // Add the difference to the result vector\n        result.push_back(diff);\n    }\n    \n    return result;\n}\n\n// Function to test the compare function with provided examples\nvoid test() {\n    vector<int> game1 = {1, 2, 3, 4, 5, 1};\n    vector<int> guess1 = {1, 2, 3, 4, 2, -2};\n    vector<int> expected1 = {0, 0, 0, 0, 3, 3};\n    assert(compare(game1, guess1) == expected1);\n\n    vector<int> game2 = {0, 5, 0, 0, 0, 4};\n    vector<int> guess2 = {4, 1, 1, 0, 0, -2};\n    vector<int> expected2 = {4, 4, 1, 0, 0, 6};\n    assert(compare(game2, guess2) == expected2);\n\n    printf(\"All tests passed.\\n\");\n}\n\n"}
{"task_id": "CPP/153", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to calculate the strength of an extension\nint calculateStrength(const string& extension) {\n    int cap = 0, sm = 0;\n    for (char c : extension) {\n        if (isupper(c)) cap++;\n        else if (islower(c)) sm++;\n    }\n    return cap - sm;\n}\n\n// Function to find the strongest extension\nstring Strongest_Extension(string class_name, vector<string> extensions) {\n    int max_strength = INT_MIN;\n    string strongest_extension = \"\";\n    \n    for (const string& ext : extensions) {\n        int strength = calculateStrength(ext);\n        if (strength > max_strength) {\n            max_strength = strength;\n            strongest_extension = ext;\n        }\n    }\n\n    // If there are multiple extensions with the same strength, choose the first one\n    return class_name + \".\" + strongest_extension;\n}\n\n// Example usage and test function\nvoid test() {\n    string result1 = Strongest_Extension(\"my_class\", {\"AA\", \"Be\", \"CC\"});\n    cout << (result1 == \"my_class.AA\" ? \"Pass\" : \"Fail\") << endl;\n\n    string result2 = Strongest_Extension(\"Slices\", {\"SErviNGSliCes\", \"Cheese\", \"StuFfed\"});\n    cout << (result2 == \"Slices.SErviNGSliCes\" ? \"Pass\" : \"Fail\") << endl;\n}\n\n"}
{"task_id": "CPP/154", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\n// Function to rotate a string by one position to the left\nstring rotate_left(string s) {\n    if (s.empty()) return s;\n    char first = s.front();\n    s.erase(s.begin());\n    s.push_back(first);\n    return s;\n}\n\nbool cycpattern_check(string a, string b) {\n    // Check if b is already a substring of a\n    if (a.find(b) != string::npos) {\n        return true;\n    }\n\n    // Generate all rotations of b and check each one\n    string rotated_b = b;\n    for (int i = 0; i < b.length(); ++i) {\n        rotated_b = rotate_left(rotated_b);\n        if (a.find(rotated_b) != string::npos) {\n            return true;\n        }\n    }\n\n    // If none of the rotations are substrings, return false\n    return false;\n}\n\n"}
{"task_id": "CPP/155", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// Function to count even and odd digits in an integer\nvector<int> even_odd_count(int num) {\n    // Convert the absolute value of the number to a string to easily iterate over each digit\n    string str_num = to_string(abs(num));\n    \n    int even_count = 0;\n    int odd_count = 0;\n\n    // Iterate through each character in the string representation of the number\n    for (char c : str_num) {\n        int digit = c - '0'; // Convert char to int\n        if (digit % 2 == 0) {\n            even_count++;\n        } else {\n            odd_count++;\n        }\n    }\n\n    return {even_count, odd_count};\n}\n\n// Function to test the even_odd_count function with some examples\nvoid test_even_odd_count() {\n    cout << \"Testing even_odd_count:\" << endl;\n    vector<int> result;\n\n    // Test case 1: -12\n    result = even_odd_count(-12);\n    cout << \"-12 -> { \" << result[0] << \", \" << result[1] << \" }\" << endl; // Should be {1, 1}\n\n    // Test case 2: 123\n    result = even_odd_count(123);\n    cout << \"123 -> { \" << result[0] << \", \" << result[1] << \" }\" << endl; // Should be {1, 2}\n\n    // Test case 3: -456789\n    result = even_odd_count(-456789);\n    cout << \"-456789 -> { \" << result[0] << \", \" << result[1] << \" }\" << endl; // Should be {2, 4}\n\n    // Test case 4: 0\n    result = even_odd_count(0);\n    cout << \"0 -> { \" << result[0] << \", \" << result[1] << \" }\" << endl; // Should be {1, 0}\n}\n\n"}
{"task_id": "CPP/156", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\n// Function to convert integer to lowercase Roman numeral\nstring int_to_mini_roman(int number) {\n    // Mapping of integers to their corresponding Roman numerals in lowercase\n    vector<pair<int, string>> roman_numerals = {\n        {1000, \"m\"}, {900, \"cm\"}, {500, \"d\"}, {400, \"cd\"},\n        {100, \"c\"}, {90, \"xc\"}, {50, \"l\"}, {40, \"xl\"},\n        {10, \"x\"}, {9, \"ix\"}, {5, \"v\"}, {4, \"iv\"}, {1, \"i\"}\n    };\n\n    string result = \"\";\n\n    // Iterate through the mapping and subtract values from number\n    for (const auto& value : roman_numerals) {\n        while (number >= value.first) {\n            result += value.second;\n            number -= value.first;\n        }\n    }\n\n    return result;\n}\n\n// Function to check the correctness of the conversion function\nvoid check() {\n    assert(int_to_mini_roman(19) == \"xix\");\n    assert(int_to_mini_roman(152) == \"clii\");\n    assert(int_to_mini_roman(426) == \"cdxxvi\");\n    cout << \"All test cases passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/157", "generation": "#include <stdio.h>\n#include <math.h>\n\nusing namespace std;\n\nbool right_angle_triangle(float a, float b, float c) {\n    // Sort the sides to ensure that 'c' is the longest side (hypotenuse)\n    if (a > c) swap(a, c);\n    if (b > c) swap(b, c);\n\n    // Check if the Pythagorean theorem holds\n    return fabs(a*a + b*b - c*c) < 1e-6; // Using a small tolerance to account for floating point precision issues\n}\n\n"}
{"task_id": "CPP/158", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nstring find_max(vector<string> words) {\n    if (words.empty()) return \"\";\n\n    // Lambda function to count unique characters in a word\n    auto count_unique_chars = [](const string& s) -> int {\n        bool seen[256] = {false};\n        for (char c : s) {\n            seen[c] = true;\n        }\n        int count = 0;\n        for (bool b : seen) {\n            if (b) count++;\n        }\n        return count;\n    };\n\n    // Lambda function to compare words based on unique characters and lexicographical order\n    auto compare_words = [&count_unique_chars](const string& a, const string& b) -> bool {\n        int unique_a = count_unique_chars(a);\n        int unique_b = count_unique_chars(b);\n        if (unique_a == unique_b) return a < b;\n        return unique_a > unique_b;\n    };\n\n    // Find the word with maximum number of unique characters\n    auto max_word_it = max_element(words.begin(), words.end(), compare_words);\n\n    return *max_word_it;\n}\n\n"}
{"task_id": "CPP/159", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nvector<int> eat(int number, int need, int remaining) {\n    // Calculate the minimum between the needed carrots and the available remaining carrots\n    int toEat = min(need, remaining);\n    \n    // Update the total number of eaten carrots\n    int totalEaten = number + toEat;\n    \n    // Update the remaining carrots after eating\n    int leftOver = remaining - toEat;\n    \n    // If there are not enough remaining carrots to satisfy your need, eat all that are available\n    if (toEat < need) {\n        totalEaten += need - toEat;  // Eat the rest of what you need\n        leftOver = 0;                // No more carrots left after eating\n    }\n    \n    return {totalEaten, leftOver};\n}\n\n// Example usage:\n"}
{"task_id": "CPP/160", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nint do_algebra(vector<string> operators, vector<int> operands) {\n    // Initialize the result with the first operand\n    int result = operands[0];\n\n    // Iterate through the operators and apply them to the current result and next operand\n    for (size_t i = 0; i < operators.size(); ++i) {\n        if (operators[i] == \"+\") {\n            result += operands[i + 1];\n        } else if (operators[i] == \"-\") {\n            result -= operands[i + 1];\n        } else if (operators[i] == \"*\") {\n            result *= operands[i + 1];\n        } else if (operators[i] == \"//\") {\n            result /= operands[i + 1]; // Floor division\n        } else if (operators[i] == \"**\") {\n            result = pow(result, operands[i + 1]); // Exponentiation\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/161", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\n// Function to check if a character is a letter\nbool isLetter(char c) {\n    return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z');\n}\n\n// Function to reverse the case of a letter\nchar reverseCase(char c) {\n    if (isupper(c)) {\n        return tolower(c);\n    } else {\n        return toupper(c);\n    }\n}\n\nstring solve(string s) {\n    bool hasLetters = false;\n    \n    // Check each character in the string\n    for (char &c : s) {\n        if (isLetter(c)) {\n            c = reverseCase(c);  // Reverse case of letter\n            hasLetters = true;   // Mark that there is at least one letter\n        }\n    }\n\n    // If no letters were found, reverse the entire string\n    if (!hasLetters) {\n        reverse(s.begin(), s.end());\n    }\n\n    return s;\n}\n\n"}
{"task_id": "CPP/162", "generation": "#include <iostream>\n#include <openssl/md5.h>\n#include <iomanip>\n#include <sstream>\n\n// Function to convert byte array to hex string\nstd::string bytesToHex(const unsigned char* bytes, size_t length) {\n    std::stringstream ss;\n    for (size_t i = 0; i < length; ++i) {\n        ss << std::hex << std::setw(2) << std::setfill('0') << static_cast<int>(bytes[i]);\n    }\n    return ss.str();\n}\n\n// Function to compute the MD5 hash of a string\nstd::string string_to_md5(const std::string& text) {\n    if (text.empty()) {\n        return \"None\";\n    }\n\n    unsigned char digest[MD5_DIGEST_LENGTH];\n    MD5((unsigned char*)text.c_str(), text.length(), (unsigned char*)&digest);    \n\n    // Convert the hash to a hexadecimal string\n    return bytesToHex(digest, MD5_DIGEST_LENGTH);\n}\n\n"}
{"task_id": "CPP/163", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nvector<int> generate_integers(int a, int b) {\n    vector<int> result;\n    \n    // Ensure a is less than or equal to b for simplicity\n    if (a > b) {\n        swap(a, b);\n    }\n    \n    // Iterate through the range from a to b\n    for (int i = a; i <= b; ++i) {\n        // Extract each digit and check if it's even\n        int num = i;\n        while (num > 0) {\n            int digit = num % 10;\n            if (digit % 2 == 0 && digit != 0) { // Check for even digits, excluding zero\n                result.push_back(digit);\n            }\n            num /= 10; // Move to the next digit\n        }\n    }\n    \n    return result;\n}\n\n// Function to print the vector elements\nvoid print_vector(const vector<int>& vec) {\n    printf(\"{\");\n    for (size_t i = 0; i < vec.size(); ++i) {\n        printf(\"%d\", vec[i]);\n        if (i != vec.size() - 1) {\n            printf(\", \");\n        }\n    }\n    printf(\"}\\n\");\n}\n\n"}
{"task_id": "CPP/0", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // For std::sort\n#include <cmath>      // For std::abs\n\nusing namespace std;\n\nbool has_close_elements(vector<float> numbers, float threshold) {\n    // Sort the vector to make comparison of consecutive elements easier\n    sort(numbers.begin(), numbers.end());\n\n    // Iterate through the sorted vector and check differences between consecutive elements\n    for (size_t i = 0; i < numbers.size() - 1; ++i) {\n        if (std::abs(numbers[i] - numbers[i + 1]) < threshold) {\n            return true;\n        }\n    }\n\n    // If no such pair is found, return false\n    return false;\n}\n\n// Function to test the has_close_elements function with provided data points\nvoid check() {\n    assert(has_close_elements({1.0f, 2.0f, 3.0f}, 0.5f) == false);\n    assert(has_close_elements({1.0f, 2.8f, 3.0f, 4.0f, 5.0f, 2.0f}, 0.3f) == true);\n    cout << \"All tests passed.\" << endl;\n}\n\n"}
{"task_id": "CPP/1", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> separate_paren_groups(string paren_string) {\n    vector<string> result;\n    string current_group = \"\";\n    int balance = 0;\n\n    for (char ch : paren_string) {\n        if (ch == '(') {\n            balance++;\n            current_group += ch;\n        } else if (ch == ')') {\n            balance--;\n            current_group += ch;\n            if (balance == 0) {\n                result.push_back(current_group);\n                current_group = \"\";\n            }\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/2", "generation": "#include <stdio.h>\n#include <math.h>\n\nusing namespace std;\n\nfloat truncate_number(float number) {\n    float intPart;\n    modf(number, &intPart); // intPart will be the largest integer less than or equal to number\n    return number - intPart; // Return the decimal part\n}\n\n"}
{"task_id": "CPP/3", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool below_zero(vector<int> operations) {\n    int balance = 0; // Start with a zero balance\n\n    for (int op : operations) {\n        balance += op; // Update the balance after each operation\n\n        if (balance < 0) { // Check if the balance falls below zero\n            return true;\n        }\n    }\n\n    return false; // Return false if the balance never goes below zero\n}\n\n// Function to test the below_zero function with provided examples\nvoid check_function() {\n    vector<int> operations1 = {1, 2, 3};\n    cout << \"Test 1: \" << (below_zero(operations1) ? \"true\" : \"false\") << endl; // Expected output: false\n\n    vector<int> operations2 = {1, 2, -4, 5};\n    cout << \"Test 2: \" << (below_zero(operations2) ? \"true\" : \"false\") << endl; // Expected output: true\n}\n\n"}
{"task_id": "CPP/4", "generation": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nfloat mean_absolute_deviation(vector<float> numbers) {\n    // Step 1: Calculate the mean of the dataset\n    float sum = 0.0;\n    for (float num : numbers) {\n        sum += num;\n    }\n    float mean = sum / numbers.size();\n\n    // Step 2 and 3: Compute the absolute differences and find their average\n    float mad = 0.0;\n    for (float num : numbers) {\n        mad += abs(num - mean);\n    }\n    mad /= numbers.size();\n\n    return mad;\n}\n\n"}
{"task_id": "CPP/5", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> intersperse(vector<int> numbers, int delimeter) {\n    if (numbers.empty()) return {}; // Return empty vector if input is empty\n\n    vector<int> result;\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        result.push_back(numbers[i]);\n        if (i != numbers.size() - 1) { // Don't add delimiter after the last element\n            result.push_back(delimeter);\n        }\n    }\n\n    return result;\n}\n\n// Function to print vector elements for testing\nvoid printVector(const vector<int>& vec) {\n    for (int num : vec) {\n        cout << num << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/6", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<int> parse_nested_parens(string paren_string) {\n    vector<int> depths;\n    int current_depth = 0, max_depth = 0;\n\n    // Split the input string into groups based on spaces\n    size_t start = 0, end = 0;\n    while ((end = paren_string.find(' ', start)) != string::npos) {\n        string group = paren_string.substr(start, end - start);\n        start = end + 1;\n\n        max_depth = 0;\n        // Iterate through the characters of each group\n        for (char c : group) {\n            if (c == '(') {\n                current_depth++;\n                max_depth = max(max_depth, current_depth);\n            } else if (c == ')') {\n                current_depth--;\n            }\n        }\n\n        // Reset current depth for the next group\n        current_depth = 0;\n        depths.push_back(max_depth);\n    }\n\n    // Handle the last group in case there is no trailing space\n    string last_group = paren_string.substr(start);\n    max_depth = 0;\n    for (char c : last_group) {\n        if (c == '(') {\n            current_depth++;\n            max_depth = max(max_depth, current_depth);\n        } else if (c == ')') {\n            current_depth--;\n        }\n    }\n\n    depths.push_back(max_depth);\n\n    return depths;\n}\n\n"}
{"task_id": "CPP/7", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to filter strings containing a given substring\nvector<string> filter_by_substring(vector<string> strings, string substring) {\n    vector<string> filteredStrings;\n    \n    // Iterate through each string in the input vector\n    for (const auto& str : strings) {\n        // Check if the current string contains the given substring\n        if (str.find(substring) != string::npos) {\n            // If it does, add it to the filtered list\n            filteredStrings.push_back(str);\n        }\n    }\n    \n    return filteredStrings;\n}\n\n// Function to test the filter_by_substring function\nvoid test_filter_by_substring() {\n    vector<string> input1 = {};\n    vector<string> expected1 = {};\n    assert(filter_by_substring(input1, \"a\") == expected1);\n\n    vector<string> input2 = {\"abc\", \"bacd\", \"cde\", \"vector\"};\n    vector<string> expected2 = {\"abc\", \"bacd\", \"vector\"};\n    assert(filter_by_substring(input2, \"a\") == expected2);\n\n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/8", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> sum_product(vector<int> numbers) {\n    int sum = 0;\n    int product = 1;\n\n    // If the vector is empty, return (0, 1)\n    if (numbers.empty()) {\n        return {sum, product};\n    }\n\n    // Calculate the sum and product\n    for (int num : numbers) {\n        sum += num;\n        product *= num;\n    }\n\n    return {sum, product};\n}\n\n// Function to test the sum_product function\nvoid test_sum_product() {\n    vector<int> empty = {};\n    vector<int> nums1 = {1, 2, 3, 4};\n\n    // Test with an empty vector\n    auto result1 = sum_product(empty);\n    cout << \"Empty vector: Sum = \" << result1[0] << \", Product = \" << result1[1] << endl;\n\n    // Test with a non-empty vector\n    auto result2 = sum_product(nums1);\n    cout << \"Non-empty vector (1, 2, 3, 4): Sum = \" << result2[0] << \", Product = \" << result2[1] << endl;\n}\n\n"}
{"task_id": "CPP/9", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> rolling_max(vector<int> numbers) {\n    if (numbers.empty()) return {};  // Return an empty vector if the input is empty\n\n    vector<int> result;\n    int current_max = numbers[0];  // Initialize the current maximum with the first element\n    for (int num : numbers) {\n        if (num > current_max) {\n            current_max = num;  // Update the current maximum if a larger number is found\n        }\n        result.push_back(current_max);  // Add the current maximum to the result vector\n    }\n\n    return result;\n}\n\n// Function to print the vector for testing purposes\nvoid print_vector(const vector<int>& vec) {\n    for (int num : vec) {\n        cout << num << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/10", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_palindrome(const string& str) {\n    // Test if given string is a palindrome\n    return str == string(str.rbegin(), str.rend());\n}\n\nstring make_palindrome(string str) {\n    /*\n    Find the shortest palindrome that begins with a supplied string. \n    Algorithm idea is simple: - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    */\n    \n    // Start from the full length and go down to 0\n    for (int i = str.length(); i > 0; --i) {\n        if (is_palindrome(str.substr(0, i))) {\n            // Found the longest palindromic prefix\n            string palindrome_suffix = str.substr(i);\n            reverse(palindrome_suffix.begin(), palindrome_suffix.end());\n            return str + palindrome_suffix;\n        }\n    }\n\n    // If no palindromic suffix is found (which should not happen for non-empty strings), return the original string.\n    return str;\n}\n\n"}
{"task_id": "CPP/11", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring string_xor(string a, string b) {\n    // Ensure both strings are of equal length by padding with leading zeros if necessary\n    int maxLength = max(a.length(), b.length());\n    a.insert(0, maxLength - a.length(), '0');\n    b.insert(0, maxLength - b.length(), '0');\n\n    string result = \"\";\n    for (int i = 0; i < maxLength; ++i) {\n        // Perform XOR on each bit\n        if (a[i] == b[i]) {\n            result += \"0\";\n        } else {\n            result += \"1\";\n        }\n    }\n\n    return result;\n}\n\n// Function to test the string_xor function\nvoid test_string_xor() {\n    cout << string_xor(\"010\", \"110\") << endl; // Expected output: \"100\"\n    cout << string_xor(\"111\", \"101\") << endl; // Expected output: \"010\"\n    cout << string_xor(\"000\", \"111\") << endl; // Expected output: \"111\"\n}\n\n"}
{"task_id": "CPP/12", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring longest(vector<string> strings) {\n    if (strings.empty()) {\n        return \"\"; // Return an empty string to indicate None in this context.\n    }\n\n    const string* longestString = &strings[0]; // Assume the first string is the longest initially.\n\n    for (const auto& str : strings) {\n        if (str.length() > longestString->length()) {\n            longestString = &str; // Update the pointer to point to the new longest string.\n        }\n    }\n\n    return *longestString; // Dereference the pointer to get the actual string.\n}\n\n"}
{"task_id": "CPP/13", "generation": "#include <stdio.h>\nusing namespace std;\n\nint greatest_common_divisor(int a, int b) {\n    // Ensure a >= b\n    if (a < b) {\n        swap(a, b);\n    }\n\n    // Euclidean algorithm\n    while (b != 0) {\n        int temp = b;\n        b = a % b;\n        a = temp;\n    }\n\n    return a;\n}\n\n"}
{"task_id": "CPP/14", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> all_prefixes(const string& str) {\n    vector<string> prefixes;\n    for (size_t i = 1; i <= str.length(); ++i) {\n        prefixes.push_back(str.substr(0, i));\n    }\n    return prefixes;\n}\n\n"}
{"task_id": "CPP/15", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring string_sequence(int n) {\n    if (n < 0) return \"\"; // Return an empty string for negative input\n\n    string result = \"\";\n    for (int i = 0; i <= n; ++i) {\n        result += to_string(i);\n        if (i != n) {\n            result += \" \";\n        }\n    }\n    return result;\n}\n\n// Function to test the string_sequence function\nvoid test_string_sequence() {\n    cout << \"Testing string_sequence...\" << endl;\n    assert(string_sequence(0) == \"0\");\n    assert(string_sequence(5) == \"0 1 2 3 4 5\");\n    assert(string_sequence(-1).empty());\n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/16", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm> // For std::tolower\n\nusing namespace std;\n\nint count_distinct_characters(string str) { \n    // Convert the string to lowercase to ignore case sensitivity\n    transform(str.begin(), str.end(), str.begin(), ::tolower);\n    \n    // Use a set to store distinct characters\n    std::set<char> distinct_chars;\n    \n    // Iterate through each character in the string and add it to the set\n    for (char c : str) {\n        distinct_chars.insert(c);\n    }\n    \n    // The size of the set is the number of distinct characters\n    return distinct_chars.size();\n}\n\n// Function to test the count_distinct_characters function\nvoid test() {\n    assert(count_distinct_characters(\"xyzXYZ\") == 3);\n    assert(count_distinct_characters(\"Jerry\") == 4);\n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/17", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<int> parse_music(string music_string) {\n    vector<int> beats;\n    \n    // Iterate through the string, processing one character at a time\n    for (size_t i = 0; i < music_string.length(); ++i) {\n        if (music_string[i] == 'o') {\n            // Whole note lasts four beats\n            beats.push_back(4);\n        } else if (music_string[i] == '|') {\n            // Check the next character to determine which type of note it is\n            if (i + 1 < music_string.length() && music_string[i + 1] == '|') {\n                // Half note lasts two beats\n                beats.push_back(2);\n                i++; // Skip the next character as we've processed a half note\n            } else {\n                // Quarter note lasts one beat\n                beats.push_back(1);\n            }\n        }\n    }\n\n    return beats;\n}\n\n"}
{"task_id": "CPP/18", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint how_many_times(string str, string substring) {\n    int count = 0;\n    size_t pos = 0;\n\n    // Loop through the original string to find all occurrences of the substring\n    while ((pos = str.find(substring, pos)) != string::npos) {\n        count++;\n        pos++; // Move one character forward to allow for overlapping matches\n    }\n\n    return count;\n}\n\n"}
{"task_id": "CPP/19", "generation": "#include <iostream>\n#include <string>\n#include <map>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to convert word to number\nint word_to_number(const string& word) {\n    map<string, int> num_map = {{\"zero\", 0}, {\"one\", 1}, {\"two\", 2}, {\"three\", 3},\n                                {\"four\", 4}, {\"five\", 5}, {\"six\", 6}, {\"seven\", 7},\n                                {\"eight\", 8}, {\"nine\", 9}};\n    return num_map[word];\n}\n\n// Function to sort the numbers\nstring sort_numbers(const string& input) {\n    vector<string> words;\n    string number = \"\";\n    \n    // Split the input into words\n    for (char ch : input) {\n        if (ch == ' ') {\n            words.push_back(number);\n            number.clear();\n        } else {\n            number += ch;\n        }\n    }\n    words.push_back(number);  // Add the last word\n    \n    // Sort the words based on their numeric value\n    sort(words.begin(), words.end(), [](const string& a, const string& b) {\n        return word_to_number(a) < word_to_number(b);\n    });\n    \n    // Join the sorted words back into a single string\n    string result;\n    for (const auto& word : words) {\n        if (!result.empty()) {\n            result += \" \";\n        }\n        result += word;\n    }\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/20", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\npair<float, float> find_closest_elements(vector<float> numbers) {\n    if (numbers.size() < 2) {\n        throw invalid_argument(\"The vector must contain at least two elements.\");\n    }\n\n    // Initialize the closest pair with the first two elements\n    float min_diff = abs(numbers[1] - numbers[0]);\n    pair<float, float> closest_pair(numbers[0], numbers[1]);\n\n    // Iterate through the vector starting from the second element\n    for (size_t i = 2; i < numbers.size(); ++i) {\n        // Calculate the difference between current and previous elements\n        float diff = abs(numbers[i] - numbers[i-1]);\n        \n        // Update the closest pair if a smaller difference is found\n        if (diff < min_diff) {\n            min_diff = diff;\n            closest_pair.first = min(numbers[i], numbers[i-1]);\n            closest_pair.second = max(numbers[i], numbers[i-1]);\n        }\n    }\n\n    return closest_pair;\n}\n\n"}
{"task_id": "CPP/21", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // For std::min_element and std::max_element\n\nusing namespace std;\n\nvector<float> rescale_to_unit(vector<float> numbers) {\n    if (numbers.size() < 2) {\n        throw invalid_argument(\"Vector must contain at least two elements.\");\n    }\n\n    float min_value = *std::min_element(numbers.begin(), numbers.end());\n    float max_value = *std::max_element(numbers.begin(), numbers.end());\n\n    vector<float> rescaled_numbers;\n    for (float num : numbers) {\n        float scaled_num = (num - min_value) / (max_value - min_value);\n        rescaled_numbers.push_back(scaled_num);\n    }\n\n    return rescaled_numbers;\n}\n\n"}
{"task_id": "CPP/22", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <list>\n#include <boost/any.hpp>\n\ntypedef std::list<boost::any> list_any;\nusing namespace std;\n\n// Function to filter integers from a list of boost::any values\nstd::vector<int> filter_integers(list_any values) {\n    std::vector<int> result;\n    \n    for (const auto& value : values) {\n        if (value.type() == typeid(int)) {\n            result.push_back(boost::any_cast<int>(value));\n        }\n    }\n    \n    return result;\n}\n\n// Function to check the correctness of the filter_integers function\nvoid check_function() {\n    list_any test1 = {boost::any(3.14), boost::any(5)};\n    list_any test2 = {boost::any(1), boost::any(2), boost::any(3), boost::any(\"abc\"), boost::any({}), boost::any({})};\n    \n    std::vector<int> result1 = filter_integers(test1);\n    std::vector<int> expected1 = {5};\n    assert(result1 == expected1);\n    \n    std::vector<int> result2 = filter_integers(test2);\n    std::vector<int> expected2 = {1, 2, 3};\n    assert(result2 == expected2);\n    \n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/23", "generation": "#include <iostream>\nusing namespace std;\n\nint strlen(string str) {\n    int length = 0;\n    for (char ch : str) {\n        length++;\n    }\n    return length;\n}\n\n// Function to test the strlen function\nvoid test_strlen() {\n    cout << \"strlen(\"\"\") << \": \" << strlen(\"\") << endl; // Should print 0\n    cout << \"strlen(\"\"abc\"\")\": \" << strlen(\"abc\") << endl; // Should print 3\n}\n\n"}
{"task_id": "CPP/24", "generation": "#include <iostream>\nusing namespace std;\n\nint largest_divisor(int n) {\n    for (int i = n - 1; i > 0; --i) {\n        if (n % i == 0) {\n            return i;\n        }\n    }\n    // If no divisor is found, which should not happen for positive integers,\n    // we can return -1 or throw an exception.\n    return -1;\n}\n\n"}
{"task_id": "CPP/25", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nbool isPrime(int num) {\n    if (num <= 1) return false;\n    for (int i = 2; i * i <= num; ++i) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\nvector<int> factorize(int n) {\n    vector<int> factors;\n    // Check divisibility by 2\n    while (n % 2 == 0) {\n        factors.push_back(2);\n        n /= 2;\n    }\n\n    // Check for odd factors\n    for (int i = 3; i * i <= n; i += 2) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n\n    // If n is a prime number greater than 2\n    if (n > 2) {\n        factors.push_back(n);\n    }\n\n    return factors;\n}\n\n"}
{"task_id": "CPP/26", "generation": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nvector<int> remove_duplicates(vector<int> numbers) {\n    // Create a hash map to count occurrences of each element\n    unordered_map<int, int> counts;\n    \n    // Count the occurrences of each number in the vector\n    for (int num : numbers) {\n        counts[num]++;\n    }\n    \n    // Reserve space in the result vector to avoid reallocations\n    vector<int> result;\n    result.reserve(numbers.size());\n    \n    // Iterate through the original vector and add elements that occur exactly once\n    for (int num : numbers) {\n        if (counts[num] == 1) {\n            result.push_back(num);\n        }\n    }\n    \n    return result;\n}\n\n// Function to check the correctness of the remove_duplicates function\nvoid check() {\n    vector<int> input = {1, 2, 3, 2, 4};\n    vector<int> expected_output = {1, 3, 4};\n    vector<int> output = remove_duplicates(input);\n    \n    if (output == expected_output) {\n        cout << \"Test passed!\" << endl;\n    } else {\n        cout << \"Test failed!\" << endl;\n    }\n}\n\n"}
{"task_id": "CPP/27", "generation": "#include <iostream>\n#include <string>\n#include <cctype>  // For tolower and toupper functions\n\nusing namespace std;\n\nstring flip_case(string str) {\n    for (char &c : str) {\n        if (isupper(c)) {\n            c = tolower(c);\n        } else if (islower(c)) {\n            c = toupper(c);\n        }\n    }\n    return str;\n}\n\n"}
{"task_id": "CPP/28", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <numeric> // For std::accumulate\n\nusing namespace std;\n\nstring concatenate(vector<string> strings) {\n    return accumulate(strings.begin(), strings.end(), string(\"\"));\n}\n\n"}
{"task_id": "CPP/29", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> filter_by_prefix(vector<string> strings, string prefix) {\n    vector<string> result;\n    for (const auto& str : strings) {\n        if (str.substr(0, prefix.length()) == prefix) {\n            result.push_back(str);\n        }\n    }\n    return result;\n}\n\n// Function to test the filter_by_prefix function\nvoid test_filter_by_prefix() {\n    vector<string> input1 = {};\n    string prefix1 = \"a\";\n    vector<string> expected1 = {};\n    assert(filter_by_prefix(input1, prefix1) == expected1);\n\n    vector<string> input2 = {\"abc\", \"bcd\", \"cde\", \"vector\"};\n    string prefix2 = \"a\";\n    vector<string> expected2 = {\"abc\", \"vector\"};\n    assert(filter_by_prefix(input2, prefix2) == expected2);\n\n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/30", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvector<float> get_positive(vector<float> l) {\n    vector<float> result;\n    for (float num : l) {\n        if (num > 0) {\n            result.push_back(num);\n        }\n    }\n    return result;\n}\n\n"}
{"task_id": "CPP/31", "generation": "#include <iostream>\nusing namespace std;\n\nbool is_prime(long long n) {\n    // Handle edge cases for 0, 1, and negative numbers\n    if (n <= 1) return false;\n    \n    // Check divisibility from 2 to sqrt(n)\n    for (long long i = 2; i * i <= n; ++i) {\n        if (n % i == 0) return false;\n    }\n    \n    return true;\n}\n\n"}
{"task_id": "CPP/32", "generation": "#include <iostream>\n#include <vector>\n#include <cmath>\n\ndouble poly(const std::vector<double>& xs, double x) {\n    double sum = 0;\n    int n = xs.size();\n    for (int i = 0; i < n; ++i) {\n        sum += xs[i] * pow(x, i);\n    }\n    return sum;\n}\n\ndouble derivative_poly(const std::vector<double>& xs, double x) {\n    double sum = 0;\n    int n = xs.size();\n    for (int i = 1; i < n; ++i) {\n        sum += i * xs[i] * pow(x, i - 1);\n    }\n    return sum;\n}\n\ndouble find_zero(const std::vector<double>& xs, double x0, double tol = 1e-6, int max_iter = 1000) {\n    double x = x0;\n    for (int iter = 0; iter < max_iter; ++iter) {\n        double f_x = poly(xs, x);\n        if (std::abs(f_x) < tol) {\n            return x;\n        }\n        double df_x = derivative_poly(xs, x);\n        if (df_x == 0) {\n            std::cerr << \"Derivative is zero. No solution found.\" << std::endl;\n            return x; // or throw an exception\n        }\n        x -= f_x / df_x;\n    }\n    std::cerr << \"Maximum number of iterations reached. No solution found.\" << std::endl;\n    return x; // or throw an exception\n}\n\n"}
{"task_id": "CPP/33", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> sort_third(vector<int> l) {\n    // Extract elements at indices divisible by three\n    vector<int> third_indices_elements;\n    for (size_t i = 2; i < l.size(); i += 3) {\n        third_indices_elements.push_back(l[i]);\n    }\n\n    // Sort the extracted elements\n    sort(third_indices_elements.begin(), third_indices_elements.end());\n\n    // Replace original elements at indices divisible by three with sorted ones\n    for (size_t i = 2, j = 0; i < l.size(); i += 3, ++j) {\n        l[i] = third_indices_elements[j];\n    }\n\n    return l;\n}\n\n// Function to check the correctness of the sort_third function\nvoid check() {\n    vector<int> test1 = {1, 2, 3};\n    vector<int> expected1 = {1, 2, 3};\n    assert(sort_third(test1) == expected1);\n\n    vector<int> test2 = {5, 6, 3, 4, 8, 9, 2};\n    vector<int> expected2 = {2, 6, 3, 4, 8, 9, 5};\n    assert(sort_third(test2) == expected2);\n\n    cout << \"All test cases passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/34", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> unique(vector<int> l) {\n    // Use a set to remove duplicates\n    std::set<int> unique_elements(l.begin(), l.end());\n    \n    // Convert the set back to a vector and sort it\n    vector<int> result(unique_elements.begin(), unique_elements.end());\n    return result;\n}\n\n"}
{"task_id": "CPP/35", "generation": "#include <iostream>\n#include <vector>\n\nfloat max_element(const std::vector<float>& l) {\n    if (l.empty()) {\n        throw std::invalid_argument(\"Vector is empty\");\n    }\n\n    float max_val = l[0];\n    for (size_t i = 1; i < l.size(); ++i) {\n        if (l[i] > max_val) {\n            max_val = l[i];\n        }\n    }\n    return max_val;\n}\n\n// Function to test the max_element function\nvoid test_max_element() {\n    std::vector<float> vec1 = {1, 2, 3};\n    std::cout << \"Max element in {1, 2, 3}: \" << max_element(vec1) << std::endl;\n\n    std::vector<float> vec2 = {5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10};\n    std::cout << \"Max element in {5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10}: \" \n              << max_element(vec2) << std::endl;\n}\n\n"}
{"task_id": "CPP/36", "generation": "#include <iostream>\nusing namespace std;\n\nint fizz_buzz(int n) {\n    int count = 0;\n    \n    for (int i = 1; i < n; ++i) {\n        if (i % 11 == 0 || i % 13 == 0) {\n            // Convert the number to a string and count occurrences of '7'\n            string num_str = to_string(i);\n            for (char c : num_str) {\n                if (c == '7') {\n                    ++count;\n                }\n            }\n        }\n    }\n    \n    return count;\n}\n\n"}
{"task_id": "CPP/37", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<float> sort_even(vector<float> l) {\n    // Extract elements at even indices (0-based index, so every second element starting from 0)\n    vector<float> even_elements;\n    for (size_t i = 0; i < l.size(); i += 2) {\n        even_elements.push_back(l[i]);\n    }\n\n    // Sort the extracted even-indexed elements\n    sort(even_elements.begin(), even_elements.end());\n\n    // Create a new vector to store the result\n    vector<float> sorted_l(l);\n\n    // Place the sorted even-indexed elements back into their original positions\n    size_t even_index = 0;\n    for (size_t i = 0; i < l.size(); i += 2) {\n        sorted_l[i] = even_elements[even_index++];\n    }\n\n    return sorted_l;\n}\n\n// Function to test the sort_even function with provided examples\nvoid test_sort_even() {\n    vector<float> result1 = sort_even({1, 2, 3});\n    for (float val : result1) {\n        cout << val << \" \";\n    }\n    cout << endl;\n\n    vector<float> result2 = sort_even({5, 6, 3, 4});\n    for (float val : result2) {\n        cout << val << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/38", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nstring encode_cyclic(string s) { \n    // returns encoded string by cycling groups of three characters.  \n    int l = s.length();\n    int num = (l + 2) / 3;\n    string x, output;\n    for (int i = 0; i * 3 < l; i++) {\n        // cycle elements in each group. Unless group has fewer elements than 3.\n        x = s.substr(i * 3, 3);\n        if (x.length() == 3) x = x.substr(1) + x[0];\n        output += x;\n    }\n    return output;\n}\n\nstring decode_cyclic(string s) { \n    /*\n    takes as input string encoded with encode_cyclic function. Returns decoded string.\n    */\n    int l = s.length();\n    int num = (l + 2) / 3;\n    string x, output;\n    for (int i = 0; i * 3 < l; i++) {\n        // cycle elements in each group back to their original position. Unless group has fewer elements than 3.\n        x = s.substr(i * 3, 3);\n        if (x.length() == 3) x = x.back() + x.substr(0, 2); // Move the last character to the front\n        output += x;\n    }\n    return output;\n}\n\n"}
{"task_id": "CPP/39", "generation": "#include <iostream>\n#include <vector>\n\n// Function to check if a number is prime\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    if (num == 2 || num == 3) return true;\n    if (num % 2 == 0 || num % 3 == 0) return false;\n    for (int i = 5; i * i <= num; i += 6) {\n        if (num % i == 0 || num % (i + 2) == 0)\n            return false;\n    }\n    return true;\n}\n\n// Function to generate the n-th Fibonacci number that is also prime\nint prime_fib(int n) {\n    int count = 0; // Counter for prime Fibonacci numbers found\n    long fib1 = 0, fib2 = 1; // First two Fibonacci numbers\n\n    while (true) {\n        long next_fib = fib1 + fib2;\n        if (is_prime(next_fib)) {\n            count++;\n            if (count == n) return next_fib;\n        }\n        fib1 = fib2;\n        fib2 = next_fib;\n    }\n}\n\n"}
{"task_id": "CPP/40", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nbool triples_sum_to_zero(vector<int> l) {\n    // First, sort the vector to facilitate the two-pointer approach.\n    sort(l.begin(), l.end());\n\n    // Iterate through each element in the vector.\n    for (int i = 0; i < l.size() - 2; ++i) {\n        // Skip duplicate elements to avoid counting the same triple multiple times.\n        if (i > 0 && l[i] == l[i-1]) continue;\n\n        int left = i + 1;\n        int right = l.size() - 1;\n\n        while (left < right) {\n            int sum = l[i] + l[left] + l[right];\n\n            if (sum == 0) {\n                return true; // Found a triple that sums to zero.\n            } else if (sum < 0) {\n                ++left; // Need a larger number, move the left pointer to the right.\n            } else {\n                --right; // Need a smaller number, move the right pointer to the left.\n            }\n        }\n    }\n\n    return false; // No triple found that sums to zero.\n}\n\n"}
{"task_id": "CPP/41", "generation": "#include <iostream>\nusing namespace std;\n\nint car_race_collision(int n) {\n    return n;\n}\n\n"}
{"task_id": "CPP/42", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> incr_vector(vector<int> l) {\n    for (auto &elem : l) {\n        elem += 1;\n    }\n    return l;\n}\n\n// Function to print the elements of the vector\nvoid print_vector(const vector<int>& v) {\n    for (const auto& elem : v) {\n        cout << elem << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/43", "generation": "#include <iostream>\n#include <vector>\n#include <set>\n\nbool pairs_sum_to_zero(const std::vector<int>& l) {\n    std::set<int> seen;\n\n    for (int num : l) {\n        if (seen.find(-num) != seen.end()) {\n            return true;\n        }\n        seen.insert(num);\n    }\n\n    return false;\n}\n\n// Function to test the pairs_sum_to_zero function\nvoid test_pairs_sum_to_zero() {\n    assert(pairs_sum_to_zero({1, 3, 5, 0}) == false);\n    assert(pairs_sum_to_zero({1, 3, -2, 1}) == false);\n    assert(pairs_sum_to_zero({1, 2, 3, 7}) == false);\n    assert(pairs_sum_to_zero({2, 4, -5, 3, 5, 7}) == true);\n    assert(pairs_sum_to_zero({1}) == false);\n\n    std::cout << \"All tests passed!\" << std::endl;\n}\n\n"}
{"task_id": "CPP/44", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring change_base(int x, int base) {\n    if (x == 0) return \"0\"; // Handle the case when x is 0\n\n    string result = \"\";\n    while (x > 0) {\n        int remainder = x % base;\n        result = to_string(remainder) + result; // Convert remainder to string and prepend it\n        x /= base; // Divide x by base\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/45", "generation": "#include <stdio.h>\nusing namespace std;\n\nfloat triangle_area(float a, float h) {\n    return 0.5 * a * h;\n}\n\n"}
{"task_id": "CPP/46", "generation": "#include <stdio.h>\nusing namespace std;\n\nint fib4(int n) {\n    if (n == 0 || n == 1 || n == 3) return 0;\n    if (n == 2) return 2;\n\n    int a = 0, b = 0, c = 2, d = 0, nextTerm;\n\n    for (int i = 4; i <= n; ++i) {\n        nextTerm = a + b + c + d;\n        a = b;\n        b = c;\n        c = d;\n        d = nextTerm;\n    }\n\n    return d;\n}\n\n"}
{"task_id": "CPP/47", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nfloat median(vector<float> l) {\n    // Sort the vector\n    sort(l.begin(), l.end());\n    \n    int n = l.size();\n    \n    if (n % 2 == 0) {\n        // If even number of elements, return the average of the two middle elements\n        return (l[n/2 - 1] + l[n/2]) / 2.0;\n    } else {\n        // If odd number of elements, return the middle element\n        return l[n/2];\n    }\n}\n\n"}
{"task_id": "CPP/48", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_palindrome(string text) {\n    int left = 0; // Start from the beginning of the string\n    int right = text.length() - 1; // Start from the end of the string\n\n    while (left < right) {\n        if (text[left] != text[right]) {\n            return false; // Characters do not match, so it's not a palindrome\n        }\n        left++; // Move towards the center from the left\n        right--; // Move towards the center from the right\n    }\n\n    return true; // All characters matched, so it is a palindrome\n}\n\n"}
{"task_id": "CPP/49", "generation": "#include <stdio.h>\nusing namespace std;\n\nint modp(int n, int p) {\n    if (n == 0) return 1; // Base case: any number to the power of 0 is 1\n\n    long long result = 1;\n    long long base = 2;\n\n    while (n > 0) {\n        if (n % 2 == 1) { // If n is odd, multiply the result by the current base\n            result = (result * base) % p;\n        }\n        base = (base * base) % p; // Square the base\n        n /= 2; // Halve the exponent\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/50", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nstring encode_shift(string s) {\n    // returns encoded string by shifting every character by 5 in the alphabet.\n    string out;\n    int i;\n    for (i = 0; i < s.length(); i++) {\n        int w = ((int)s[i] + 5 - (int)'a') % 26 + (int)'a';\n        out += (char)w;\n    }\n    return out;\n}\n\nstring decode_shift(string s) {\n    // takes as input string encoded with encode_shift function. Returns decoded string.\n    string out;\n    int i;\n    for (i = 0; i < s.length(); i++) {\n        int w = ((int)s[i] - 5 - (int)'a') % 26 + (int)'a';\n        out += (char)w;\n    }\n    return out;\n}\n\n"}
{"task_id": "CPP/51", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring remove_vowels(string text) {\n    // Define vowels as both lowercase and uppercase for simplicity\n    const string vowels = \"aeiouAEIOU\";\n    \n    // Create a new string to store the result\n    string result;\n    \n    // Iterate through each character in the input string\n    for (char ch : text) {\n        // Check if the character is not a vowel\n        if (vowels.find(ch) == string::npos) {\n            // If it's not a vowel, add it to the result string\n            result += ch;\n        }\n    }\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/52", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Function to check if all elements in the vector are below the threshold\nbool below_threshold(vector<int> l, int t) {\n    // Iterate through each element in the vector\n    for (int num : l) {\n        // If any number is not below the threshold, return false\n        if (num >= t) {\n            return false;\n        }\n    }\n    // If all numbers are below the threshold, return true\n    return true;\n}\n\n// Function to test the below_threshold function with provided examples\nvoid test_below_threshold() {\n    cout << boolalpha; // Print bools as true/false instead of 1/0\n    cout << \"Test 1: \" << below_threshold({1, 2, 4, 10}, 100) << endl; // Expected output: true\n    cout << \"Test 2: \" << below_threshold({1, 20, 4, 10}, 5) << endl;  // Expected output: false\n}\n\n"}
{"task_id": "CPP/53", "generation": "#include <iostream>  // Include iostream for input/output operations\n\nusing namespace std;\n\nint add(int x, int y) {\n    return x + y;  // Return the sum of x and y\n}\n\n"}
{"task_id": "CPP/54", "generation": "#include <iostream>\n#include <string>\n#include <set>\n\nusing namespace std;\n\nbool same_chars(string s0, string s1) {\n    // Create a set for each string to store unique characters\n    set<char> chars_s0(s0.begin(), s0.end());\n    set<char> chars_s1(s1.begin(), s1.end());\n\n    // Check if both sets have the same elements\n    return chars_s0 == chars_s1;\n}\n\n"}
{"task_id": "CPP/55", "generation": "#include <iostream>\nusing namespace std;\n\nint fib(int n) {\n    if (n <= 0) {\n        return 0;\n    } else if (n == 1) {\n        return 1;\n    } else {\n        int a = 0, b = 1, c;\n        for (int i = 2; i <= n; ++i) {\n            c = a + b;\n            a = b;\n            b = c;\n        }\n        return b;\n    }\n}\n\n"}
{"task_id": "CPP/56", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    int count = 0;\n    \n    for (char c : brackets) {\n        if (c == '<') {\n            count++;\n        } else if (c == '>') {\n            count--;\n            if (count < 0) {\n                return false; // More closing brackets than opening ones\n            }\n        }\n    }\n    \n    return count == 0; // True if all brackets are correctly matched\n}\n\n"}
{"task_id": "CPP/57", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool monotonic(vector<float> l) {\n    if (l.size() <= 1) {\n        return true; // A vector with 0 or 1 element is trivially monotonic.\n    }\n\n    bool increasing = false;\n    for (size_t i = 1; i < l.size(); ++i) {\n        if (l[i] > l[i - 1]) {\n            if (!increasing) {\n                increasing = true;\n            } else if (l[i] <= l[i - 1]) {\n                return false; // Found a non-increasing pair when we expected an increase.\n            }\n        } else if (l[i] < l[i - 1]) {\n            if (increasing) {\n                return false; // Found a non-decreasing pair when we expected a decrease.\n            } else {\n                increasing = true;\n            }\n        }\n    }\n\n    return true;\n}\n\n"}
{"task_id": "CPP/58", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n// Function to remove duplicates and sort the vector\nvoid removeDuplicatesAndSort(vector<int>& vec) {\n    sort(vec.begin(), vec.end());\n    vec.erase(unique(vec.begin(), vec.end()), vec.end());\n}\n\n// Function to find common elements in two sorted vectors\nvector<int> common(vector<int> l1, vector<int> l2) {\n    // Remove duplicates and sort both vectors\n    removeDuplicatesAndSort(l1);\n    removeDuplicatesAndSort(l2);\n\n    vector<int> result;\n    int i = 0, j = 0;\n\n    // Use two-pointer technique to find common elements\n    while (i < l1.size() && j < l2.size()) {\n        if (l1[i] == l2[j]) {\n            result.push_back(l1[i]);\n            ++i;\n            ++j;\n        } else if (l1[i] < l2[j]) {\n            ++i;\n        } else {\n            ++j;\n        }\n    }\n\n    return result;\n}\n\n// Function to print the vector\nvoid printVector(const vector<int>& vec) {\n    for (int num : vec) {\n        cout << num << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/59", "generation": "#include <iostream>\n#include <cmath>\nusing namespace std;\n\nint largest_prime_factor(int n) {\n    // Remove all factors of 2\n    while (n % 2 == 0) {\n        n /= 2;\n    }\n\n    // Check for odd factors from 3 to sqrt(n)\n    int factor = 3;\n    while (factor * factor <= n) {\n        while (n % factor == 0) {\n            n /= factor;\n        }\n        factor += 2; // Only check odd numbers\n    }\n\n    // If n is a prime number greater than 2\n    if (n > 2) {\n        return n;\n    } else {\n        return factor - 2; // The last factor found will be the largest one\n    }\n}\n\n"}
{"task_id": "CPP/60", "generation": "#include <iostream>\nusing namespace std;\n\nint sum_to_n(int n) {\n    return (n * (n + 1)) / 2;\n}\n\n"}
{"task_id": "CPP/61", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    int balance = 0;\n    \n    for (char c : brackets) {\n        if (c == '(') {\n            balance++;\n        } else if (c == ')') {\n            balance--;\n        }\n        \n        // If at any point the balance is negative, it means there's a closing bracket without an opening one\n        if (balance < 0) {\n            return false;\n        }\n    }\n    \n    // Finally, check if all brackets are balanced\n    return balance == 0;\n}\n\n"}
{"task_id": "CPP/62", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvector<float> derivative(vector<float> xs) {\n    // Create a new vector to store the coefficients of the derivative polynomial\n    vector<float> result;\n    \n    // Iterate through the input vector starting from index 1\n    for (size_t i = 1; i < xs.size(); ++i) {\n        // Multiply each coefficient by its corresponding power and add it to the result\n        result.push_back(xs[i] * static_cast<float>(i));\n    }\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/63", "generation": "#include <iostream>\nusing namespace std;\n\nint fibfib(int n) {\n    // Base cases\n    if (n == 0 || n == 1) return 0;\n    if (n == 2) return 1;\n\n    // Array to store the computed values of FibFib sequence\n    int dp[n + 1];\n    dp[0] = 0; // fibfib(0)\n    dp[1] = 0; // fibfib(1)\n    dp[2] = 1; // fibfib(2)\n\n    // Fill the array using the recurrence relation\n    for (int i = 3; i <= n; ++i) {\n        dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3];\n    }\n\n    return dp[n];\n}\n\n// Function to test the fibfib function with some examples\nvoid testFibfib() {\n    cout << \"fibfib(1): \" << fibfib(1) << endl; // Should output 0\n    cout << \"fibfib(5): \" << fibfib(5) << endl; // Should output 4\n    cout << \"fibfib(8): \" << fibfib(8) << endl; // Should output 24\n}\n\n"}
{"task_id": "CPP/64", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint vowels_count(string s) {\n    int count = 0;\n    \n    // Convert the string to lowercase for easier comparison\n    transform(s.begin(), s.end(), s.begin(), ::tolower);\n    \n    // Iterate through each character in the string\n    for (size_t i = 0; i < s.length(); ++i) {\n        char c = s[i];\n        \n        // Check if the current character is a vowel or 'y' at the end of the word\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' || \n            (c == 'y' && i == s.length() - 1)) {\n            count++;\n        }\n    }\n    \n    return count;\n}\n\n"}
{"task_id": "CPP/65", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring circular_shift(int x, int shift) {\n    // Convert the integer to a string\n    string num_str = to_string(x);\n    \n    // Get the length of the number\n    size_t len = num_str.length();\n    \n    // If shift is greater than or equal to the length of the number,\n    // reverse the digits.\n    if (shift >= len) {\n        return string(num_str.rbegin(), num_str.rend());\n    }\n    \n    // Perform the circular right shift\n    int effective_shift = shift % len;\n    string shifted_str = num_str.substr(len - effective_shift) + num_str.substr(0, len - effective_shift);\n    \n    return shifted_str;\n}\n\n"}
{"task_id": "CPP/66", "generation": "#include <iostream>\n#include <string>\n\n// Function to calculate the sum of ASCII values of uppercase characters in a string\nint digitSum(const std::string& s) {\n    int sum = 0;\n    for (char c : s) {\n        if (isupper(c)) { // Check if the character is an uppercase letter\n            sum += static_cast<int>(c); // Add its ASCII value to the sum\n        }\n    }\n    return sum;\n}\n\n// Function to test the digitSum function with provided examples\nvoid checkFunction() {\n    assert(digitSum(\"\") == 0);\n    assert(digitSum(\"abAB\") == 131);\n    assert(digitSum(\"abcCd\") == 67);\n    assert(digitSum(\"helloE\") == 69);\n    assert(digitSum(\"woArBld\") == 131);\n    assert(digitSum(\"aAaaaXa\") == 153);\n\n    std::cout << \"All test cases passed!\" << std::endl;\n}\n\n"}
{"task_id": "CPP/67", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nint fruit_distribution(string s, int n) {\n    // Extract the numbers using string stream\n    stringstream ss(s);\n    string temp;\n    getline(ss, temp, ' ');  // Read \"apples\"\n    getline(ss, temp, ' ');  // Read number of apples\n    int apples = stoi(temp);\n\n    getline(ss, temp, ' ');  // Read \"and\"\n    getline(ss, temp, ' ');  // Read number of oranges\n    int oranges = stoi(temp);\n\n    // Calculate the number of mangoes\n    int mangoes = n - (apples + oranges);\n    return mangoes;\n}\n\n"}
{"task_id": "CPP/68", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> pluck(vector<int> arr) {\n    int minEvenValue = -1;\n    int minIndex = -1;\n\n    for (int i = 0; i < arr.size(); ++i) {\n        if (arr[i] % 2 == 0) { // Check if the node value is even\n            if (minEvenValue == -1 || arr[i] < minEvenValue || \n                (arr[i] == minEvenValue && i < minIndex)) {\n                minEvenValue = arr[i];\n                minIndex = i;\n            }\n        }\n    }\n\n    // If no even values were found, return an empty vector\n    if (minEvenValue == -1) {\n        return {};\n    } else {\n        return {minEvenValue, minIndex};\n    }\n}\n\n"}
{"task_id": "CPP/69", "generation": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint search(vector<int> lst) {\n    // Create a frequency map to count occurrences of each integer\n    unordered_map<int, int> freqMap;\n    \n    // Count the frequency of each number in the vector\n    for (int num : lst) {\n        freqMap[num]++;\n    }\n    \n    // Initialize the result with -1\n    int result = -1;\n    \n    // Iterate through the map to find the greatest integer that meets the condition\n    for (const auto& pair : freqMap) {\n        if (pair.first <= pair.second && pair.first > result) {\n            result = pair.first;\n        }\n    }\n    \n    return result;\n}\n\n// Function to test the search function with provided examples\nvoid test() {\n    assert(search({4, 1, 2, 2, 3, 1}) == 2);\n    assert(search({1, 2, 2, 3, 3, 3, 4, 4, 4}) == 3);\n    assert(search({5, 5, 4, 4, 4}) == -1);\n    \n    cout << \"All tests passed.\" << endl;\n}\n\n"}
{"task_id": "CPP/70", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> strange_sort_list(vector<int> lst) {\n    // Sort the input vector in ascending order\n    sort(lst.begin(), lst.end());\n    \n    vector<int> result;\n    int start = 0;  // Start index for minimum values\n    int end = lst.size() - 1;  // End index for maximum values\n    \n    while (start <= end) {\n        if (start == end) {\n            // If only one element is left, add it to the result\n            result.push_back(lst[start]);\n            break;\n        }\n        \n        // Add minimum value from the sorted list\n        result.push_back(lst[start++]);\n        // Add maximum value from the sorted list\n        result.push_back(lst[end--]);\n    }\n    \n    return result;\n}\n\n// Function to check the correctness of the strange_sort_list function\nvoid check() {\n    assert(strange_sort_list({1, 2, 3, 4}) == vector<int>({1, 4, 2, 3}));\n    assert(strange_sort_list({5, 5, 5, 5}) == vector<int>({5, 5, 5, 5}));\n    assert(strange_sort_list({}) == vector<int>({}));\n    cout << \"All test cases passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/71", "generation": "#include <stdio.h>\n#include <math.h>\n\nusing namespace std;\n\nfloat triangle_area(float a, float b, float c) {\n    // Check if the sides form a valid triangle\n    if (a + b <= c || a + c <= b || b + c <= a) {\n        return -1;\n    }\n\n    // Calculate the semi-perimeter\n    float s = (a + b + c) / 2.0;\n\n    // Calculate the area using Heron's formula\n    float area = sqrt(s * (s - a) * (s - b) * (s - c));\n\n    // Round the result to 2 decimal points\n    return round(area * 100) / 100;\n}\n\n"}
{"task_id": "CPP/72", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool will_it_fly(vector<int> q, int w) {\n    // Check if the sum of elements is within the weight limit\n    int sum = 0;\n    for (int num : q) {\n        sum += num;\n    }\n    if (sum > w) return false;\n\n    // Check if the vector is palindromic\n    for (size_t i = 0; i < q.size() / 2; ++i) {\n        if (q[i] != q[q.size() - 1 - i]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\n// Function to test the will_it_fly function\nvoid test_will_it_fly() {\n    assert(will_it_fly({1, 2}, 5) == false);\n    assert(will_it_fly({3, 2, 3}, 1) == false);\n    assert(will_it_fly({3, 2, 3}, 9) == true);\n    assert(will_it_fly({3}, 5) == true);\n\n    cout << \"All tests passed.\" << endl;\n}\n\n"}
{"task_id": "CPP/73", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint smallest_change(vector<int> arr) {\n    int left = 0;\n    int right = arr.size() - 1;\n    int changes = 0;\n\n    while (left < right) {\n        if (arr[left] != arr[right]) {\n            changes++;\n        }\n        left++;\n        right--;\n    }\n\n    return changes;\n}\n\n"}
{"task_id": "CPP/74", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to calculate the total number of characters in a vector of strings\nint count_chars(const vector<string>& vec) {\n    int total = 0;\n    for (const auto& str : vec) {\n        total += str.length();\n    }\n    return total;\n}\n\nvector<string> total_match(vector<string> lst1, vector<string> lst2) {\n    // Calculate the total number of characters in both vectors\n    int chars_lst1 = count_chars(lst1);\n    int chars_lst2 = count_chars(lst2);\n\n    // Compare and return the appropriate vector\n    if (chars_lst1 < chars_lst2) {\n        return lst1;\n    } else if (chars_lst2 < chars_lst1) {\n        return lst2;\n    } else {\n        return lst1;  // Both have the same number of characters, return the first one.\n    }\n}\n\n// Function to check the correctness of the total_match function\nvoid check() {\n    assert(total_match({}, {}) == vector<string>());\n    assert(total_match({\"hi\", \"admin\"}, {\"hI\", \"Hi\"}) == vector<string>{\"hI\", \"Hi\"});\n    assert(total_match({\"hi\", \"admin\"}, {\"hi\", \"hi\", \"admin\", \"project\"}) == vector<string>{\"hi\", \"admin\"});\n    assert(total_match({\"hi\", \"admin\"}, {\"hI\", \"hi\", \"hi\"}) == vector<string>{\"hI\", \"hi\", \"hi\"});\n    assert(total_match({\"4\"}, {\"1\", \"2\", \"3\", \"4\", \"5\"}) == vector<string>{\"4\"});\n\n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/75", "generation": "#include <iostream>\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\n// Function to check if the number can be expressed as a product of exactly three primes\nbool is_multiply_prime(int a) {\n    // Check all combinations of three prime numbers less than 100\n    for (int p1 = 2; p1 < 100; ++p1) {\n        if (!is_prime(p1)) continue;\n        for (int p2 = p1; p2 < 100; ++p2) {\n            if (!is_prime(p2)) continue;\n            for (int p3 = p2; p3 < 100; ++p3) {\n                if (!is_prime(p3)) continue;\n                if (p1 * p2 * p3 == a) return true;\n            }\n        }\n    }\n    return false;\n}\n\n// Function to test the is_multiply_prime function\nvoid test() {\n    cout << \"Testing is_multiply_prime(30): \" << (is_multiply_prime(30) ? \"true\" : \"false\") << endl; // Should be true\n    cout << \"Testing is_multiply_prime(60): \" << (is_multiply_prime(60) ? \"true\" : \"false\") << endl; // Should be false, as 60 = 2 * 3 * 10 and 10 is not prime\n    cout << \"Testing is_multiply_prime(77): \" << (is_multiply_prime(77) ? \"true\" : \"false\") << endl; // Should be true, as 77 = 7 * 11\n}\n\n"}
{"task_id": "CPP/76", "generation": "#include <iostream>\n#include <cmath>\n\nbool is_simple_power(int x, int n) {\n    if (n == 1) {\n        return x == 1; // Special case: 1^any = 1\n    }\n    \n    double log_value = log(x) / log(n);\n    int rounded_log_value = static_cast<int>(log_value + 0.5); // Round to nearest integer\n    \n    return (pow(n, rounded_log_value) == x);\n}\n\n"}
{"task_id": "CPP/77", "generation": "#include <stdio.h>\n#include <math.h>\n\nusing namespace std;\n\nbool iscube(int a) {\n    // Handle special cases: 0 and -1 are cubes of themselves.\n    if (a == 0 || a == -1) return true;\n    \n    // Calculate the cube root, round it to the nearest integer\n    int roundedRoot = round(cbrt(a));\n    \n    // Check if cubing this rounded value gives back the original number\n    return pow(roundedRoot, 3) == a;\n}\n\n"}
{"task_id": "CPP/78", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\n// Function to check if a character is a prime hexadecimal digit\nbool is_prime_hex_digit(char c) {\n    switch (c) {\n        case '2': case '3': case '5': case '7':\n        case 'B': case 'D': return true;\n        default: return false;\n    }\n}\n\n// Function to count the number of prime hexadecimal digits in a string\nint hex_key(string num) {\n    int count = 0;\n    for (char c : num) {\n        if (is_prime_hex_digit(c)) {\n            ++count;\n        }\n    }\n    return count;\n}\n\n// Main function to test the hex_key function\n"}
{"task_id": "CPP/79", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring decimal_to_binary(int decimal) {\n    // Convert the decimal number to binary string\n    string binary = \"\";\n    if (decimal == 0) {\n        binary = \"0\";\n    } else {\n        while (decimal > 0) {\n            int remainder = decimal % 2;\n            binary = to_string(remainder) + binary;\n            decimal /= 2;\n        }\n    }\n\n    // Add the 'db' prefix and suffix\n    return \"db\" + binary + \"db\";\n}\n\n// Function to test the conversion with some examples\nvoid test_decimal_to_binary() {\n    cout << decimal_to_binary(15) << endl;   // Should print: db1111db\n    cout << decimal_to_binary(32) << endl;   // Should print: db100000db\n    cout << decimal_to_binary(0) << endl;    // Should print: db0db\n    cout << decimal_to_binary(456) << endl;  // Should print: db111001000db\n}\n\n"}
{"task_id": "CPP/80", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_happy(string s) {\n    // Check if the string length is less than 3\n    if (s.length() < 3) return false;\n    \n    // Iterate through the string and check every three consecutive characters\n    for (int i = 0; i <= s.length() - 3; ++i) {\n        // If any two of these three characters are the same, return false\n        if (s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]) {\n            return false;\n        }\n    }\n    \n    // If no consecutive triplets have repeating characters, return true\n    return true;\n}\n\n"}
{"task_id": "CPP/81", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to convert GPA to letter grade\nstring gpa_to_letter(float gpa) {\n    if (gpa >= 4.0f) return \"A+\";\n    else if (gpa > 3.7f) return \"A\";\n    else if (gpa > 3.3f) return \"A-\";\n    else if (gpa > 3.0f) return \"B+\";\n    else if (gpa > 2.7f) return \"B\";\n    else if (gpa > 2.3f) return \"B-\";\n    else if (gpa > 2.0f) return \"C+\";\n    else if (gpa > 1.7f) return \"C\";\n    else if (gpa > 1.3f) return \"C-\";\n    else if (gpa > 1.0f) return \"D+\";\n    else if (gpa > 0.7f) return \"D\";\n    else if (gpa > 0.0f) return \"D-\";\n    else return \"E\";\n}\n\n// Function to convert vector of GPAs to vector of letter grades\nvector<string> numerical_letter_grade(vector<float> grades) {\n    vector<string> letter_grades;\n    for (float gpa : grades) {\n        letter_grades.push_back(gpa_to_letter(gpa));\n    }\n    return letter_grades;\n}\n\n// Example usage and check function\nvoid check() {\n    vector<float> test_grades = {4.0f, 3.0f, 1.7f, 2.0f, 3.5f};\n    vector<string> expected_output = {\"A+\", \"B\", \"C-\", \"C\", \"A-\"};\n    vector<string> output = numerical_letter_grade(test_grades);\n    \n    if (output == expected_output) {\n        printf(\"Test passed!\\n\");\n    } else {\n        printf(\"Test failed. Expected: %s, Got: %s\\n\", \n               expected_output[0].c_str(), output[0].c_str());\n    }\n}\n\n"}
{"task_id": "CPP/82", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\n// Helper function to check if a number is prime\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    if (n == 2 || n == 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n\n    for (int i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0)\n            return false;\n    }\n    return true;\n}\n\n// Function to check if the length of a string is prime\nbool prime_length(string str) {\n    int len = str.length();\n    return is_prime(len);\n}\n\n"}
{"task_id": "CPP/83", "generation": "#include <iostream>\nusing namespace std;\n\nint starts_one_ends(int n) {\n    // If n is 1, there's only one number (which is 1 itself)\n    if (n == 1) return 1;\n    \n    // For numbers starting with 1: the first digit is fixed as 1 and the rest can be any digit from 0 to 9\n    int start_with_1 = 1 * pow(10, n - 1);\n    \n    // For numbers ending with 1: the last digit is fixed as 1 and the rest can be any digit from 0 to 9\n    int end_with_1 = pow(10, n - 1) * 9;\n    \n    // Subtract the overlap (numbers that both start and end with 1)\n    int both_start_and_end_with_1 = pow(10, n - 2);\n    \n    return start_with_1 + end_with_1 - both_start_and_end_with_1;\n}\n\n"}
{"task_id": "CPP/84", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring solve(int N) {\n    int sum = 0;\n    \n    // Calculate the sum of digits\n    while (N > 0) {\n        sum += N % 10;\n        N /= 10;\n    }\n    \n    // Convert the sum to binary and return it as a string\n    string result = \"\";\n    if (sum == 0) {\n        result = \"0\";\n    } else {\n        while (sum > 0) {\n            result = to_string(sum % 2) + result;\n            sum /= 2;\n        }\n    }\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/85", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint add(const vector<int>& lst) {\n    int sum = 0;\n    \n    // Iterate over the list starting from index 1 (second element, which is at an \"odd\" position)\n    for (size_t i = 1; i < lst.size(); i += 2) {\n        if (lst[i] % 2 == 0) {  // Check if the element at the current odd index is even\n            sum += lst[i];\n        }\n    }\n    \n    return sum;\n}\n\n"}
{"task_id": "CPP/86", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\n// Function to sort characters in a word\nvoid sortWord(string &word) {\n    sort(word.begin(), word.end());\n}\n\n// Function to split the string into words and sort each word\nstring anti_shuffle(const string &s) {\n    string result;\n    string current_word;\n    \n    for (char ch : s) {\n        if (ch == ' ') {  // If we encounter a space, add the sorted word to the result\n            if (!current_word.empty()) {\n                sortWord(current_word);\n                result += current_word + \" \";\n                current_word.clear();\n            }\n            result += \" \";  // Add the space back to the result\n        } else {\n            current_word += ch;  // Build the current word\n        }\n    }\n\n    if (!current_word.empty()) {  // Handle the last word in the sentence\n        sortWord(current_word);\n        result += current_word;\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/87", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to get the coordinates of all occurrences of x in lst\nvector<vector<int>> get_row(vector<vector<int>> lst, int x) {\n    vector<vector<int>> result;\n    \n    // Iterate through each row and column in the list\n    for (size_t i = 0; i < lst.size(); ++i) {\n        for (size_t j = 0; j < lst[i].size(); ++j) {\n            if (lst[i][j] == x) {\n                result.push_back({static_cast<int>(i), static_cast<int>(j)});\n            }\n        }\n    }\n\n    // Sort the results by row in ascending order\n    sort(result.begin(), result.end());\n\n    // For each row, sort the columns in descending order\n    for (auto &row : result) {\n        if (row.size() > 1) {  // Ensure there are multiple elements to sort\n            sort(row.rbegin(), row.rend());\n        }\n    }\n\n    return result;\n}\n\n// Function to print the result for verification\nvoid print_result(const vector<vector<int>>& result) {\n    for (const auto& coord : result) {\n        cout << \"{\" << coord[0] << \", \" << coord[1] << \"} \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/88", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> sort_array(vector<int> array) {\n    // Check if the vector is empty or has only one element\n    if (array.empty() || array.size() == 1) {\n        return array;\n    }\n\n    int first = array.front();\n    int last = array.back();\n\n    // Calculate the sum of the first and last elements\n    int sum = first + last;\n\n    // Determine sorting order based on the sum being odd or even\n    vector<int> sorted_array(array);  // Make a copy to avoid modifying the original vector\n\n    if (sum % 2 == 0) {\n        // Sort in descending order\n        sort(sorted_array.begin(), sorted_array.end(), greater<int>());\n    } else {\n        // Sort in ascending order\n        sort(sorted_array.begin(), sorted_array.end());\n    }\n\n    return sorted_array;\n}\n\n// Function to test the solution with provided examples\nvoid check() {\n    vector<int> empty = {};\n    vector<int> single = {5};\n    vector<int> example1 = {2, 4, 3, 0, 1, 5};\n    vector<int> example2 = {2, 4, 3, 0, 1, 5, 6};\n\n    cout << \"Empty vector: \";\n    for (int num : sort_array(empty)) {\n        cout << num << \" \";\n    }\n    cout << endl;\n\n    cout << \"Single element vector: \";\n    for (int num : sort_array(single)) {\n        cout << num << \" \";\n    }\n    cout << endl;\n\n    cout << \"Example 1: \";\n    for (int num : sort_array(example1)) {\n        cout << num << \" \";\n    }\n    cout << endl;\n\n    cout << \"Example 2: \";\n    for (int num : sort_array(example2)) {\n        cout << num << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/89", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\n// Function to encrypt a string by rotating the alphabet down by 4 places.\nstring encrypt(string s) {\n    for (char &c : s) {\n        if (isalpha(c)) { // Check if the character is an alphabet letter\n            char base = islower(c) ? 'a' : 'A'; // Determine the base character ('a' or 'A')\n            c = base + (c - base + 4) % 26; // Rotate the character by 4 places and wrap around if necessary\n        }\n    }\n    return s;\n}\n\n"}
{"task_id": "CPP/90", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint next_smallest(vector<int> lst) {\n    // Check if the list is empty or has less than 2 unique elements\n    if (lst.size() < 2) return -1; // Return -1 to indicate no second smallest element\n\n    // Sort the vector while maintaining original indices using a pair of values\n    sort(lst.begin(), lst.end());\n\n    int prev = lst[0];\n    for (int i = 1; i < lst.size(); ++i) {\n        if (lst[i] != prev) return lst[i]; // Return the first unique element after the smallest one\n        prev = lst[i];\n    }\n\n    return -1; // If no second smallest element is found, return -1\n}\n\n"}
{"task_id": "CPP/91", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nint is_bored(string S) {\n    int count = 0;\n    \n    // Use stringstream to split the string into sentences based on delimiters\n    stringstream ss(S);\n    string sentence;\n    \n    while (getline(ss, sentence, '.')) {\n        if (!sentence.empty()) {\n            getline(ss, sentence, '?');\n            if (!sentence.empty()) {\n                getline(ss, sentence, '!');\n                if (!sentence.empty()) {\n                    // Trim leading and trailing spaces\n                    size_t start = sentence.find_first_not_of(\" \\t\");\n                    size_t end = sentence.find_last_not_of(\" \\t\");\n                    if (start == 0 && sentence.substr(start, 1) == \"I\") {\n                        count++;\n                    }\n                }\n            }\n        }\n    }\n    \n    return count;\n}\n\n"}
{"task_id": "CPP/92", "generation": "#include <iostream>\nusing namespace std;\n\nbool any_int(float a, float b, float c) {\n    // Check if all three numbers are integers\n    bool is_a_integer = (a == floor(a));\n    bool is_b_integer = (b == floor(b));\n    bool is_c_integer = (c == floor(c));\n\n    // If not all numbers are integers, return false\n    if (!is_a_integer || !is_b_integer || !is_c_integer) {\n        return false;\n    }\n\n    // Check if any number is the sum of the other two\n    if ((a == b + c) || (b == a + c) || (c == a + b)) {\n        return true;\n    } else {\n        return false;\n    }\n}\n\n"}
{"task_id": "CPP/93", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\n// Function to encode a message by swapping cases and replacing vowels\nstring encode(string message) {\n    // Define vowels for easy replacement\n    string vowels = \"aeiouAEIOU\";\n    \n    // Loop through each character in the message\n    for (char &c : message) {\n        if (isalpha(c)) {  // Check if it's a letter\n            // Swap case\n            c ^= ' ';  // XOR with space to swap case\n            \n            // Replace vowels with the next two letters ahead in the alphabet\n            if (vowels.find(c) != string::npos) {\n                int index = vowels.find(c);\n                switch (c) {\n                    case 'a': c = 'c'; break;\n                    case 'e': c = 'g'; break;\n                    case 'i': c = 'k'; break;\n                    case 'o': c = 'q'; break;\n                    case 'u': c = 'w'; break;\n                    case 'A': c = 'C'; break;\n                    case 'E': c = 'G'; break;\n                    case 'I': c = 'K'; break;\n                    case 'O': c = 'Q'; break;\n                    case 'U': c = 'W'; break;\n                }\n            }\n        }\n    }\n    \n    return message;\n}\n\n"}
{"task_id": "CPP/94", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool isPrime(int n) {\n    if (n <= 1) return false;\n    if (n == 2 || n == 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    for (int i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0)\n            return false;\n    }\n    return true;\n}\n\nint sumOfDigits(int n) {\n    int sum = 0;\n    while (n > 0) {\n        sum += n % 10;\n        n /= 10;\n    }\n    return sum;\n}\n\nint findLargestPrimeSum(vector<int> lst) {\n    int largestPrime = -1;\n    \n    for (int num : lst) {\n        if (isPrime(num)) {\n            if (num > largestPrime) {\n                largestPrime = num;\n            }\n        }\n    }\n\n    if (largestPrime == -1) {\n        return 0; // No prime number found\n    } else {\n        return sumOfDigits(largestPrime);\n    }\n}\n\n"}
{"task_id": "CPP/95", "generation": "#include <iostream>\n#include <string>\n#include <map>\n\nusing namespace std;\n\nbool check_dict_case(map<string, string> dict) {\n    // Check if the map is empty\n    if (dict.empty()) {\n        return false;\n    }\n\n    bool allLower = true;\n    bool allUpper = true;\n\n    for (const auto &pair : dict) {\n        const string &key = pair.first;\n\n        // Check if key is not in lower case or upper case\n        if (!islower(key[0]) && !isupper(key[0])) {\n            return false;\n        }\n\n        // Determine the case of the first key to set initial flags\n        if (allLower && isupper(key[0])) {\n            allLower = false;\n        }\n        if (allUpper && islower(key[0])) {\n            allUpper = false;\n        }\n\n        // If both flags are still true, it means we have mixed case keys\n        if (!allLower && !allUpper) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\n"}
{"task_id": "CPP/96", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Helper function to check if a number is prime\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    for (int i = 2; i * i <= num; ++i) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\n// Function to generate a vector of prime numbers less than n\nvector<int> count_up_to(int n) {\n    vector<int> primes;\n    for (int i = 2; i < n; ++i) {\n        if (is_prime(i)) {\n            primes.push_back(i);\n        }\n    }\n    return primes;\n}\n\n// Function to test the count_up_to function\nvoid test_count_up_to() {\n    assert(count_up_to(5) == vector<int>({2, 3}));\n    assert(count_up_to(11) == vector<int>({2, 3, 5, 7}));\n    assert(count_up_to(0).empty());\n    assert(count_up_to(20) == vector<int>({2, 3, 5, 7, 11, 13, 17, 19}));\n    assert(count_up_to(1).empty());\n    assert(count_up_to(18) == vector<int>({2, 3, 5, 7, 11, 13, 17}));\n\n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/97", "generation": "#include <iostream>\nusing namespace std;\n\nint multiply(int a, int b) {\n    // Extract the unit digit of each number\n    int unitDigitA = abs(a % 10);\n    int unitDigitB = abs(b % 10);\n\n    // Multiply the unit digits and return the result\n    return unitDigitA * unitDigitB;\n}\n\n"}
{"task_id": "CPP/98", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint count_upper(const string& s) {\n    int count = 0;\n    for (size_t i = 0; i < s.length(); i += 2) { // Iterate through even indices\n        char c = tolower(s[i]); // Convert the character to lowercase to simplify comparison\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n            count++;\n        }\n    }\n    return count;\n}\n\n"}
{"task_id": "CPP/99", "generation": "#include <stdio.h>\n#include <math.h>\n#include <string>\nusing namespace std;\n\nint closest_integer(string value) {\n    // Convert string to double\n    double num = stod(value);\n\n    // Extract the fractional part of the number\n    double fractional_part = num - floor(num);\n\n    // Check if the number is equidistant from two integers\n    if (fractional_part == 0.5 || fractional_part == -0.5) {\n        // Round away from zero\n        return num > 0 ? ceil(num) : floor(num);\n    } else {\n        // Use standard rounding rules\n        return round(num);\n    }\n}\n\n// Function to test the closest_integer function\nvoid check() {\n    printf(\"%d\\n\", closest_integer(\"10\"));       // Output: 10\n    printf(\"%d\\n\", closest_integer(\"15.3\"));     // Output: 15\n    printf(\"%d\\n\", closest_integer(\"14.5\"));     // Output: 15\n    printf(\"%d\\n\", closest_integer(\"-14.5\"));    // Output: -15\n}\n\n"}
{"task_id": "CPP/100", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Function to determine the next stone count based on the parity of the current level\nint getNextStoneCount(int currentLevel, int n) {\n    if (currentLevel == 0) {\n        return n; // First level has n stones\n    }\n    \n    // Determine the starting number for the next level\n    int start = (n % 2 == 0) ? n + 1 : n + 2;\n    \n    // Calculate the total number of stones in the current level\n    int stonesInCurrentLevel = start + 2 * currentLevel;\n    \n    return stonesInCurrentLevel;\n}\n\n// Function to make a pile of n levels of stones\nvector<int> make_a_pile(int n) {\n    vector<int> result;\n    for (int i = 0; i < n; ++i) {\n        int stonesInCurrentLevel = getNextStoneCount(i, n);\n        result.push_back(stonesInCurrentLevel);\n    }\n    return result;\n}\n\n// Function to print the vector\nvoid printVector(const vector<int>& vec) {\n    for (int val : vec) {\n        cout << val << \" \";\n    }\n    cout << endl;\n}\n\n// Main function to test the make_a_pile function\n"}
{"task_id": "CPP/101", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nvector<string> words_string(string s) {\n    vector<string> result;\n    string word;\n    istringstream iss(s);\n\n    while (getline(iss, word, ',')) { // Split by comma first\n        stringstream ss(word); // Create a new stringstream for each word to handle spaces\n        while (ss >> word) { // Extract words from the stringstream\n            if (!word.empty()) {\n                result.push_back(word);\n            }\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/102", "generation": "#include <iostream>\nusing namespace std;\n\nint choose_num(int x, int y) {\n    // Ensure x is less than or equal to y for simplicity\n    if (x > y) {\n        swap(x, y);\n    }\n\n    // Check the range from y down to x and find the largest even number\n    for (int i = y; i >= x; --i) {\n        if (i % 2 == 0) {\n            return i;\n        }\n    }\n\n    // If no even number is found, return -1\n    return -1;\n}\n\n// Function to test the choose_num function with provided examples\nvoid test() {\n    cout << \"choose_num(12, 15): \" << choose_num(12, 15) << endl; // Should output 14\n    cout << \"choose_num(13, 12): \" << choose_num(13, 12) << endl; // Should output -1\n    cout << \"choose_num(10, 20): \" << choose_num(10, 20) << endl; // Should output 20\n    cout << \"choose_num(21, 25): \" << choose_num(21, 25) << endl; // Should output 24\n}\n\n"}
{"task_id": "CPP/103", "generation": "#include <stdio.h>\n#include <cmath>\n#include <string>\nusing namespace std;\n\nstring rounded_avg(int n, int m) {\n    // Check if n is greater than m\n    if (n > m) {\n        return \"-1\";\n    }\n\n    // Calculate the sum of integers from n to m\n    long long sum = 0;\n    for (int i = n; i <= m; ++i) {\n        sum += i;\n    }\n\n    // Calculate the average and round it to the nearest integer\n    double average = static_cast<double>(sum) / (m - n + 1);\n    int rounded_average = std::round(average);\n\n    // Convert the rounded average to binary string\n    string binary_string = \"\";\n    if (rounded_average == 0) {\n        binary_string = \"0\";\n    } else {\n        while (rounded_average > 0) {\n            binary_string = to_string(rounded_average % 2) + binary_string;\n            rounded_average /= 2;\n        }\n    }\n\n    return binary_string;\n}\n\n"}
{"task_id": "CPP/104", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n// Function to check if a number has any even digit\nbool hasEvenDigit(int num) {\n    while (num > 0) {\n        int digit = num % 10;\n        if (digit % 2 == 0) return true; // If any digit is even, return true\n        num /= 10;\n    }\n    return false; // No even digits found\n}\n\n// Function to get a sorted vector of numbers with no even digits\nvector<int> unique_digits(vector<int> x) {\n    vector<int> result;\n\n    for (int num : x) {\n        if (!hasEvenDigit(num)) {\n            result.push_back(num);\n        }\n    }\n\n    // Sort the result vector in increasing order\n    sort(result.begin(), result.end());\n\n    return result;\n}\n\n// Function to print the vector\nvoid printVector(const vector<int>& vec) {\n    for (int num : vec) {\n        cout << num << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/105", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to map digits to their names\nmap<int, string> digit_to_name = {\n    {1, \"One\"}, {2, \"Two\"}, {3, \"Three\"}, {4, \"Four\"},\n    {5, \"Five\"}, {6, \"Six\"}, {7, \"Seven\"}, {8, \"Eight\"}, {9, \"Nine\"}\n};\n\nvector<string> by_length(vector<int> arr) {\n    // Step 1: Filter out numbers not between 1 and 9\n    vector<int> filtered;\n    for (int num : arr) {\n        if (num >= 1 && num <= 9) {\n            filtered.push_back(num);\n        }\n    }\n\n    // Step 2: Sort the remaining numbers in ascending order\n    sort(filtered.begin(), filtered.end());\n\n    // Step 3: Reverse the sorted vector\n    reverse(filtered.begin(), filtered.end());\n\n    // Step 4: Replace each digit with its corresponding name\n    vector<string> result;\n    for (int num : filtered) {\n        result.push_back(digit_to_name[num]);\n    }\n\n    return result;\n}\n\n// Function to test the solution\nvoid check() {\n    vector<int> arr1 = {2, 1, 1, 4, 5, 8, 2, 3};\n    vector<string> expected1 = {\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"};\n    assert(by_length(arr1) == expected1);\n\n    vector<int> arr2 = {};\n    vector<string> expected2 = {};\n    assert(by_length(arr2) == expected2);\n\n    vector<int> arr3 = {1, -1, 55};\n    vector<string> expected3 = {\"One\"};\n    assert(by_length(arr3) == expected3);\n\n    printf(\"All tests passed.\\n\");\n}\n\n"}
{"task_id": "CPP/106", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// Function to compute the factorial of a number\nint factorial(int n) {\n    if (n == 0 || n == 1)\n        return 1;\n    int result = 1;\n    for (int i = 2; i <= n; ++i) {\n        result *= i;\n    }\n    return result;\n}\n\n// Function to compute the sum of numbers from 1 to n\nint sumToN(int n) {\n    return (n * (n + 1)) / 2;\n}\n\nvector<int> f(int n) {\n    vector<int> result(n);\n    \n    for (int i = 0; i < n; ++i) {\n        if ((i + 1) % 2 == 0) { // Check if the index is even\n            result[i] = factorial(i + 1); // Factorial of (i+1)\n        } else {\n            result[i] = sumToN(i + 1); // Sum from 1 to (i+1)\n        }\n    }\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/107", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool is_palindrome(int num) {\n    string str = to_string(num);\n    int len = str.length();\n    for (int i = 0; i < len / 2; ++i) {\n        if (str[i] != str[len - i - 1]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nvector<int> even_odd_palindrome(int n) {\n    int count_even = 0, count_odd = 0;\n\n    // Single-digit palindromes\n    for (int i = 1; i <= n; ++i) {\n        if (is_palindrome(i)) {\n            if (i % 2 == 0) {\n                count_even++;\n            } else {\n                count_odd++;\n            }\n        }\n    }\n\n    // Multi-digit palindromes\n    for (int len = 2; len <= to_string(n).length(); ++len) {\n        generate_palindromes(len, n, count_even, count_odd);\n    }\n\n    return {count_even, count_odd};\n}\n\nvoid generate_palindromes(int length, int max_val, int& even_count, int& odd_count) {\n    if (length == 1) {\n        for (int i = 0; i <= 9; ++i) {\n            if (is_palindrome(i)) {\n                if (i % 2 == 0) {\n                    even_count++;\n                } else {\n                    odd_count++;\n                }\n            }\n        }\n    } else {\n        int half_len = length / 2;\n        for (int i = 1; i <= 9; ++i) { // First digit can't be zero\n            string prefix = to_string(i);\n            if (length % 2 == 0) {\n                generate_palindromes_helper(prefix, half_len - 1, max_val, even_count, odd_count);\n            } else {\n                for (int j = 0; j <= 9; ++j) { // Middle digit\n                    string middle = to_string(j);\n                    string full_prefix = prefix + middle;\n                    generate_palindromes_helper(full_prefix, half_len - 1, max_val, even_count, odd_count);\n                }\n            }\n        }\n    }\n}\n\nvoid generate_palindromes_helper(string prefix, int len, int max_val, int& even_count, int& odd_count) {\n    if (len == 0) {\n        int num = stoi(prefix + string(prefix.rbegin(), prefix.rend()));\n        if (num <= max_val && is_palindrome(num)) {\n            if (num % 2 == 0) {\n                even_count++;\n            } else {\n                odd_count++;\n            }\n        }\n    } else {\n        for (int i = 0; i <= 9; ++i) {\n            generate_palindromes_helper(prefix + to_string(i), len - 1, max_val, even_count, odd_count);\n        }\n    }\n}\n\n"}
{"task_id": "CPP/108", "generation": "#include <iostream>\n#include <vector>\n\n// Function to calculate the sum of digits of an integer.\nint sum_of_digits(int num) {\n    int sum = 0;\n    bool isNegative = num < 0;\n\n    while (num != 0) {\n        int digit = abs(num % 10);\n        sum += digit;\n        num /= 10;\n    }\n\n    // If the number was negative, subtract the first digit from the sum.\n    if (isNegative && sum > 0) {\n        sum -= digit; // Subtract the last added digit which is positive\n    }\n\n    return sum;\n}\n\n// Function to count numbers with a sum of digits greater than 0.\nint count_nums(const std::vector<int>& n) {\n    int count = 0;\n\n    for (int num : n) {\n        if (sum_of_digits(num) > 0) {\n            ++count;\n        }\n    }\n\n    return count;\n}\n\n// Function to test the count_nums function with provided data points.\nvoid test_count_nums() {\n    assert(count_nums({}) == 0);\n    assert(count_nums({-1, 11, -11}) == 1);\n    assert(count_nums({1, 1, 2}) == 3);\n\n    std::cout << \"All tests passed!\" << std::endl;\n}\n\n"}
{"task_id": "CPP/109", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool move_one_ball(vector<int> arr) {\n    int n = arr.size();\n    if (n == 0) return true;\n\n    // Count the number of out-of-order pairs\n    int count = 0;\n    for (int i = 1; i <= n; ++i) {\n        if ((i < n && arr[i] < arr[i - 1]) || (i == n && arr[0] < arr[n - 1])) {\n            count++;\n        }\n    }\n\n    // If there is at most one out-of-order pair, return true\n    return count <= 1;\n}\n\n// Function to test the move_one_ball function with provided examples\nvoid test() {\n    cout << (move_one_ball({3, 4, 5, 1, 2}) ? \"true\" : \"false\") << endl; // Expected: true\n    cout << (move_one_ball({3, 5, 4, 1, 2}) ? \"true\" : \"false\") << endl; // Expected: false\n}\n\n"}
{"task_id": "CPP/110", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring exchange(vector<int> lst1, vector<int> lst2) {\n    // Check for any odd elements in lst1\n    bool has_odd_in_lst1 = false;\n    for (int num : lst1) {\n        if (num % 2 != 0) {\n            has_odd_in_lst1 = true;\n            break;\n        }\n    }\n\n    // If there are no odd numbers, return \"YES\"\n    if (!has_odd_in_lst1) {\n        return \"YES\";\n    }\n\n    // Count the number of odd elements in lst1 and even elements in lst2\n    int odd_count_lst1 = 0;\n    for (int num : lst1) {\n        if (num % 2 != 0) {\n            odd_count_lst1++;\n        }\n    }\n    int even_count_lst2 = 0;\n    for (int num : lst2) {\n        if (num % 2 == 0) {\n            even_count_lst2++;\n        }\n    }\n\n    // Check if there are enough even numbers in lst2 to replace the odd numbers in lst1\n    if (odd_count_lst1 <= even_count_lst2) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n\n// Function to test the exchange function with provided data points\nvoid test_exchange() {\n    cout << exchange({1, 2, 3, 4}, {1, 2, 3, 4}) << endl; // Expected: YES\n    cout << exchange({1, 2, 3, 4}, {1, 5, 3, 4}) << endl; // Expected: NO\n}\n\n"}
{"task_id": "CPP/111", "generation": "#include <iostream>\n#include <string>\n#include <map>\n#include <vector>\n\nusing namespace std;\n\n// Function to create a histogram (frequency map) from the input string\nmap<char, int> histogram(string test) {\n    // Map to store character frequencies\n    map<char, int> freqMap;\n    \n    // Count the frequency of each character in the string\n    for (char c : test) {\n        if (c != ' ') {  // Ignore spaces\n            freqMap[c]++;\n        }\n    }\n\n    // Find the maximum frequency\n    int maxFreq = 0;\n    for (const auto &pair : freqMap) {\n        if (pair.second > maxFreq) {\n            maxFreq = pair.second;\n        }\n    }\n\n    // Create a map to store characters with the highest frequency\n    map<char, int> result;\n\n    // Add characters with the maximum frequency to the result map\n    for (const auto &pair : freqMap) {\n        if (pair.second == maxFreq) {\n            result.insert(pair);\n        }\n    }\n\n    return result;\n}\n\n// Function to print the histogram map\nvoid printHistogram(const map<char, int>& hist) {\n    for (const auto &pair : hist) {\n        cout << pair.first << \": \" << pair.second << endl;\n    }\n}\n\n"}
{"task_id": "CPP/112", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to check if a string is a palindrome\nbool is_palindrome(const string& str) {\n    int left = 0;\n    int right = str.size() - 1;\n    \n    while (left < right) {\n        if (str[left] != str[right]) {\n            return false;\n        }\n        ++left;\n        --right;\n    }\n    return true;\n}\n\n// Function to reverse delete characters in s that are present in c\nvector<string> reverse_delete(string s, string c) {\n    // Remove all characters from s that are present in c\n    for (char ch : c) {\n        s.erase(remove(s.begin(), s.end(), ch), s.end());\n    }\n    \n    // Check if the resulting string is a palindrome\n    bool result = is_palindrome(s);\n    \n    return {s, to_string(result)};\n}\n\n"}
{"task_id": "CPP/113", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<string> odd_count(vector<string> lst) {\n    vector<string> result;\n    \n    for (const auto& str : lst) {\n        int count = 0;\n        \n        // Count the number of odd digits in the current string\n        for (char c : str) {\n            if ((c - '0') % 2 != 0) {\n                count++;\n            }\n        }\n        \n        // Construct the result string with the count of odd digits\n        string output = \"the number of odd elements \";\n        output += to_string(count);\n        output += \"n the str\";\n        output += to_string(count);\n        output += \"ng \";\n        output += to_string(count);\n        output += \" of the \";\n        output += to_string(count);\n        output += \"nput.\";\n        \n        result.push_back(output);\n    }\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/114", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nlong long minSubArraySum(vector<long long> nums) {\n    if (nums.empty()) return 0; // Handle empty vector case\n\n    long long min_sum = nums[0];\n    long long current_sum = nums[0];\n\n    for (size_t i = 1; i < nums.size(); ++i) {\n        // Update the current sum to be the minimum of the current element or\n        // the current sum plus the current element.\n        current_sum = min(nums[i], current_sum + nums[i]);\n\n        // Update the minimum sum found so far.\n        min_sum = min(min_sum, current_sum);\n    }\n\n    return min_sum;\n}\n\n"}
{"task_id": "CPP/115", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint max_fill(vector<vector<int>> grid, int capacity) {\n    int total_lowerings = 0;\n    \n    // Iterate over each well (row in the grid)\n    for (const auto& row : grid) {\n        int water_units = 0;\n        \n        // Count the number of units of water in the current well\n        for (int unit : row) {\n            if (unit == 1) {\n                ++water_units;\n            }\n        }\n        \n        // Calculate the number of times a bucket with given capacity needs to be lowered\n        total_lowerings += (water_units + capacity - 1) / capacity; // Use ceiling division\n    }\n    \n    return total_lowerings;\n}\n\n"}
{"task_id": "CPP/116", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to count the number of ones in the binary representation of a number\nint count_ones(int n) {\n    int count = 0;\n    while (n > 0) {\n        count += n & 1; // Check if the least significant bit is set\n        n >>= 1; // Right shift to check the next bit\n    }\n    return count;\n}\n\n// Custom comparator for sorting\nbool custom_comparator(int a, int b) {\n    int ones_a = count_ones(a);\n    int ones_b = count_ones(b);\n\n    if (ones_a == ones_b) {\n        return a < b; // Sort by decimal value if the number of ones is equal\n    }\n    return ones_a < ones_b; // Otherwise, sort by the number of ones\n}\n\nvector<int> sort_array(vector<int> arr) {\n    std::sort(arr.begin(), arr.end(), custom_comparator);\n    return arr;\n}\n\n"}
{"task_id": "CPP/117", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\n// Helper function to check if a character is a consonant\nbool is_consonant(char c) {\n    return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z');\n}\n\n// Function to count the number of consonants in a word\nint count_consonants(const string& word) {\n    int count = 0;\n    for (char c : word) {\n        if (is_consonant(c)) {\n            ++count;\n        }\n    }\n    return count;\n}\n\nvector<string> select_words(string s, int n) {\n    vector<string> result;\n    // Split the string into words\n    size_t start = 0, end = 0;\n    while ((end = s.find(' ', start)) != string::npos) {\n        string word = s.substr(start, end - start);\n        if (count_consonants(word) == n) {\n            result.push_back(word);\n        }\n        start = end + 1;\n    }\n    // Check the last word\n    if (start < s.length()) {\n        string word = s.substr(start);\n        if (count_consonants(word) == n) {\n            result.push_back(word);\n        }\n    }\n    return result;\n}\n\n// Function to test the select_words function with provided examples\nvoid test() {\n    assert(select_words(\"Mary had a little lamb\", 4) == vector<string>{\"little\"});\n    assert(select_words(\"Mary had a little lamb\", 3) == vector<string>{\"Mary\", \"lamb\"});\n    assert(select_words(\"simple white space\", 2) == vector<string>{});\n    assert(select_words(\"Hello world\", 4) == vector<string>{\"world\"});\n    assert(select_words(\"Uncle sam\", 3) == vector<string>{\"Uncle\"});\n\n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/118", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_vowel(char c) {\n    return c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' ||\n           c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U';\n}\n\nbool is_consonant(char c) {\n    return !is_vowel(c) && isalpha(c);\n}\n\nstring get_closest_vowel(string word) {\n    int n = word.length();\n    \n    // Start from the second last character\n    for (int i = n - 2; i >= 0; --i) {\n        if (is_consonant(word[i + 1]) && is_consonant(word[i])) {\n            if (is_vowel(word[i])) {\n                return string(1, word[i]);\n            }\n        }\n    }\n\n    // If no such vowel found\n    return \"\";\n}\n\n"}
{"task_id": "CPP/119", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Helper function to check if a single string is balanced\nbool is_balanced(const string& s) {\n    int balance = 0;\n    for (char c : s) {\n        if (c == '(') {\n            ++balance;\n        } else if (c == ')') {\n            --balance;\n            if (balance < 0) {\n                return false; // More closing parentheses than opening ones\n            }\n        }\n    }\n    return balance == 0; // True if balanced, otherwise false\n}\n\n// Main function to check if concatenation of two strings can result in a balanced string\nstring match_parens(vector<string> lst) {\n    // Check both possible concatenations\n    if (is_balanced(lst[0] + lst[1]) || is_balanced(lst[1] + lst[0])) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\n\n"}
{"task_id": "CPP/120", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> maximum(vector<int> arr, int k) {\n    // Sort the array in ascending order\n    sort(arr.begin(), arr.end());\n    \n    // If k is 0 or negative, return an empty vector\n    if (k <= 0) {\n        return {};\n    }\n    \n    // Return the last k elements of the sorted array\n    return vector<int>(arr.rbegin(), arr.rbegin() + k);\n}\n\n"}
{"task_id": "CPP/121", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Function to calculate the sum of odd elements at even indices\nint solution(vector<int> lst) {\n    int sum = 0;\n    \n    // Iterate through the vector, starting from index 0 (even position)\n    for (size_t i = 0; i < lst.size(); i += 2) {\n        if (lst[i] % 2 != 0) {  // Check if the element is odd\n            sum += lst[i];      // Add it to the sum\n        }\n    }\n    \n    return sum;\n}\n\n// Function to test the solution with provided examples\nvoid check_solution() {\n    assert(solution({5, 8, 7, 1}) == 12);\n    assert(solution({3, 3, 3, 3, 3}) == 9);\n    assert(solution({30, 13, 24, 321}) == 13);\n    \n    cout << \"All test cases passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/122", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Function to check if a number has at most two digits\nbool hasAtMostTwoDigits(int num) {\n    return (num >= 0 && num <= 99);\n}\n\n// Function to sum elements with at most two digits from the first k elements of arr\nint add_elements(vector<int> arr, int k) {\n    int sum = 0;\n    for (int i = 0; i < k; ++i) {\n        if (hasAtMostTwoDigits(arr[i])) {\n            sum += arr[i];\n        }\n    }\n    return sum;\n}\n\n// Function to test the add_elements function\nvoid test() {\n    vector<int> arr = {111, 21, 3, 4000, 5, 6, 7, 8, 9};\n    int k = 4;\n    cout << \"Sum of elements with at most two digits from the first \" << k \n         << \" elements: \" << add_elements(arr, k) << endl; // Expected output: 24\n}\n\n"}
{"task_id": "CPP/123", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n// Function to generate and return the odd numbers in the Collatz sequence for a given n.\nvector<int> get_odd_collatz(int n) {\n    vector<int> result;\n    \n    // Generate the Collatz sequence until it reaches 1\n    while (n != 1) {\n        if (n % 2 == 0) {\n            n /= 2;  // If n is even, divide by 2\n        } else {\n            result.push_back(n);  // If n is odd, add to the result vector\n            n = 3 * n + 1;  // Apply the Collatz transformation for odd numbers\n        }\n    }\n    \n    // Add the last number (which is 1) to the result vector\n    result.push_back(1);\n    \n    // Sort the result vector in increasing order\n    sort(result.begin(), result.end());\n    \n    return result;\n}\n\n// Function to test the get_odd_collatz function with some example inputs.\nvoid test_get_odd_collatz() {\n    cout << \"Testing get_odd_collatz...\" << endl;\n    \n    // Test case 1: n = 5\n    vector<int> expected1 = {1, 5};\n    assert(get_odd_collatz(5) == expected1);\n    \n    // Test case 2: n = 7\n    vector<int> expected2 = {1, 7, 11, 22};\n    assert(get_odd_collatz(7) == expected2);\n    \n    // Test case 3: n = 1\n    vector<int> expected3 = {1};\n    assert(get_odd_collatz(1) == expected3);\n    \n    cout << \"All test cases passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/124", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nbool valid_date(string date) {\n    // Check if the date string is empty or not in the correct format mm-dd-yyyy\n    if (date.length() != 10 || date[2] != '-' || date[5] != '-') {\n        return false;\n    }\n\n    int month, day, year;\n\n    // Extract month, day, and year from the date string\n    stringstream ss(date);\n    char dash1, dash2;\n    ss >> month >> dash1 >> day >> dash2 >> year;\n\n    if (dash1 != '-' || dash2 != '-') {\n        return false;  // Incorrect format\n    }\n\n    // Validate month\n    if (month < 1 || month > 12) {\n        return false;\n    }\n\n    // Validate day based on the month\n    int max_days[12] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\n\n    if (day < 1 || day > max_days[month - 1]) {\n        return false;\n    }\n\n    // Check for leap year in February\n    if (month == 2 && day == 29) {\n        int is_leap_year = (year % 400 == 0) || (year % 4 == 0 && year % 100 != 0);\n        if (!is_leap_year) {\n            return false;\n        }\n    }\n\n    // If all checks pass, the date is valid\n    return true;\n}\n\n"}
{"task_id": "CPP/125", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to count lowercase letters with odd order in the alphabet\nint countOddOrderLetters(const string& word) {\n    int count = 0;\n    for (char c : word) {\n        if (islower(c)) {\n            // Calculate the order of the letter and check if it's odd\n            if ((c - 'a') % 2 == 1) {\n                count++;\n            }\n        }\n    }\n    return count;\n}\n\n// Function to split words based on whitespace, commas, or count lowercase letters with odd order\nvector<string> split_words(const string& txt) {\n    vector<string> result;\n\n    // Check if there are any whitespaces in the text\n    size_t pos = txt.find(' ');\n    if (pos != string::npos) {\n        // Split on whitespace\n        while ((pos = txt.find(' ')) != string::npos) {\n            result.push_back(txt.substr(0, pos));\n            txt.erase(0, pos + 1);\n        }\n        result.push_back(txt); // Add the last word\n    } else {\n        // Check if there are any commas in the text\n        size_t commaPos = txt.find(',');\n        if (commaPos != string::npos) {\n            // Split on comma\n            while ((commaPos = txt.find(',')) != string::npos) {\n                result.push_back(txt.substr(0, commaPos));\n                txt.erase(0, commaPos + 1);\n            }\n            result.push_back(txt); // Add the last word\n        } else {\n            // Count lowercase letters with odd order in the alphabet\n            int count = countOddOrderLetters(txt);\n            if (count > 0) {\n                result.push_back(to_string(count));\n            } else {\n                result.push_back(txt); // Return the original string as a single element vector\n            }\n        }\n    }\n\n    return result;\n}\n\n// Function to test the split_words function with examples\nvoid test_split_words() {\n    cout << \"split_words(\\\"Hello world!\\\") \u279e {\\\"Hello\\\", \\\"world!\\\"}\" << endl;\n    auto result1 = split_words(\"Hello world!\");\n    for (const auto& word : result1) {\n        cout << \"\\\"\" << word << \"\\\" \";\n    }\n    cout << endl;\n\n    cout << \"split_words(\\\"Hello,world!\\\") \u279e {\\\"Hello\\\", \\\"world!\\\"}\" << endl;\n    auto result2 = split_words(\"Hello,world!\");\n    for (const auto& word : result2) {\n        cout << \"\\\"\" << word << \"\\\" \";\n    }\n    cout << endl;\n\n    cout << \"split_words(\\\"abcdef\\\") == {\\\"3\\\"}\" << endl;\n    auto result3 = split_words(\"abcdef\");\n    for (const auto& word : result3) {\n        cout << \"\\\"\" << word << \"\\\" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/126", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nbool is_sorted(vector<int> lst) {\n    // Check if the list is already sorted or not\n    bool ascending = true;\n    for (int i = 1; i < lst.size(); ++i) {\n        if (lst[i] < lst[i - 1]) {\n            ascending = false;\n            break;\n        }\n    }\n\n    // If the list is not sorted, return false immediately\n    if (!ascending) return false;\n\n    // Check for any number appearing more than twice\n    int prev_count = 0;\n    int current_count = 1;\n    for (int i = 1; i < lst.size(); ++i) {\n        if (lst[i] == lst[i - 1]) {\n            current_count++;\n            if (current_count > 2) return false;\n        } else {\n            prev_count = current_count;\n            current_count = 1;\n        }\n    }\n\n    // Check the last element\n    if (prev_count > 2) return false;\n\n    return true;\n}\n\n"}
{"task_id": "CPP/127", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\n// Function to check if a number is prime\nbool isPrime(int n) {\n    if (n <= 1) return false;\n    if (n == 2 || n == 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    for (int i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0)\n            return false;\n    }\n    return true;\n}\n\n// Function to find the intersection of two intervals\nvector<int> intersect(vector<int> interval1, vector<int> interval2) {\n    int start = max(interval1[0], interval2[0]);\n    int end = min(interval1[1], interval2[1]);\n    \n    if (start > end) return {}; // No intersection\n    \n    return {start, end};\n}\n\n// Main function to determine if the length of the intersection is a prime number\nstring intersection(vector<int> interval1, vector<int> interval2) {\n    vector<int> intersected = intersect(interval1, interval2);\n    \n    if (intersected.empty()) return \"NO\";\n    \n    int length = intersected[1] - intersected[0];\n    if (isPrime(length)) return \"YES\";\n    else return \"NO\";\n}\n\n"}
{"task_id": "CPP/128", "generation": "#include <vector>\nusing namespace std;\n\nint prod_signs(vector<int> arr) {\n    if (arr.empty()) {\n        return -32768;\n    }\n\n    int sign_product = 1;\n    int magnitude_sum = 0;\n\n    for (int num : arr) {\n        // Calculate the product of signs\n        if (num < 0) {\n            sign_product *= -1;\n        } else if (num == 0) {\n            sign_product = 0;\n            break; // If any number is zero, the product will be zero\n        }\n        \n        // Add magnitude to sum\n        magnitude_sum += abs(num);\n    }\n\n    return sign_product * magnitude_sum;\n}\n\n// Example usage:\n"}
{"task_id": "CPP/129", "generation": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to get all possible paths of length k starting from (x, y)\nvoid getAllPaths(vector<vector<int>>& grid, int x, int y, vector<pair<int, int>>& path, queue<pair<vector<pair<int, int>>, int>>& q) {\n    int n = grid.size();\n    if (path.size() == 0 || (x >= 0 && x < n && y >= 0 && y < n)) { // Check bounds\n        path.push_back({x, y});\n        if (path.size() == k) {\n            q.push({path, 0}); // Push the path and a dummy value to keep track of depth\n        } else {\n            getAllPaths(grid, x + 1, y, path, q); // Down\n            getAllPaths(grid, x - 1, y, path, q); // Up\n            getAllPaths(grid, x, y + 1, path, q); // Right\n            getAllPaths(grid, x, y - 1, path, q); // Left\n        }\n        path.pop_back(); // Backtrack\n    }\n}\n\n// Function to compare two paths lexicographically\nbool comparePaths(const vector<pair<int, int>>& p1, const vector<pair<int, int>>& p2) {\n    for (int i = 0; i < min(p1.size(), p2.size()); ++i) {\n        if (p1[i] != p2[i]) {\n            return grid[p1[i].first][p1[i].second] < grid[p2[i].first][p2[i].second];\n        }\n    }\n    return p1.size() < p2.size();\n}\n\nvector<int> minPath(vector<vector<int>>& grid, int k) {\n    int n = grid.size();\n    vector<pair<int, int>> path;\n    queue<pair<vector<pair<int, int>>, int>> q;\n\n    // Start from each cell\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            getAllPaths(grid, i, j, path, q);\n        }\n    }\n\n    vector<pair<int, int>> minPath;\n    while (!q.empty()) {\n        auto current = q.front();\n        q.pop();\n        if (minPath.empty() || comparePaths(current.first, minPath)) {\n            minPath = current.first;\n        }\n    }\n\n    // Extract the values from the cells in the minimum path\n    vector<int> result;\n    for (auto& cell : minPath) {\n        result.push_back(grid[cell.first][cell.second]);\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/130", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Function to compute the nth Tribonacci number\nint tribonacci(int n) {\n    if (n == 0) return 3;\n    if (n == 1) return 3;\n    if (n % 2 == 0) return 1 + n / 2;\n    \n    // Initialize base cases\n    vector<int> tri = {3, 2}; // tri(0) and tri(1)\n    \n    for (int i = 2; i <= n; ++i) {\n        int next_value = tri[i - 1] + tri[i - 2];\n        if (i % 2 != 0) {\n            next_value += tribonacci(i + 1);\n        }\n        tri.push_back(next_value);\n    }\n    \n    return tri[n];\n}\n\n// Function to generate the first n+1 numbers of the Tribonacci sequence\nvector<int> tri(int n) {\n    vector<int> result;\n    for (int i = 0; i <= n; ++i) {\n        result.push_back(tribonacci(i));\n    }\n    return result;\n}\n\n// Main function to test the implementation\n"}
{"task_id": "CPP/131", "generation": "#include <iostream>\nusing namespace std;\n\nint digits(int n) {\n    int product = 1;\n    bool hasOddDigit = false;\n\n    while (n > 0) {\n        int digit = n % 10; // Get the last digit of n\n        if (digit % 2 != 0) { // Check if the digit is odd\n            product *= digit; // Multiply it to the product\n            hasOddDigit = true;\n        }\n        n /= 10; // Remove the last digit from n\n    }\n\n    return hasOddDigit ? product : 0; // Return the product if there was at least one odd digit, otherwise return 0\n}\n\n"}
{"task_id": "CPP/132", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_nested(string str) {\n    int balance = 0;\n    bool hasNested = false;\n\n    for (char c : str) {\n        if (c == '[') {\n            balance++;\n            // Check if there's a nested pair before this '['\n            if (balance > 1 && !hasNested) {\n                hasNested = true;\n            }\n        } else if (c == ']') {\n            balance--;\n            if (balance < 0) {\n                return false; // Unbalanced brackets\n            }\n        }\n    }\n\n    return hasNested && balance == 0; // Ensure all brackets are balanced and there was at least one nested pair\n}\n\n"}
{"task_id": "CPP/133", "generation": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nint sum_squares(vector<float> lst) {\n    int sum = 0;\n    \n    for (float num : lst) {\n        // Round to the nearest upper integer\n        float ceil_num = ceil(num);\n        \n        // Add the square of the rounded number to the sum\n        sum += static_cast<int>(ceil_num * ceil_num);\n    }\n    \n    return sum;\n}\n\n"}
{"task_id": "CPP/134", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool check_if_last_char_is_a_letter(string txt) {\n    // Check if the string is empty or has only one character and it's not a letter\n    if (txt.empty() || (txt.length() == 1 && !isalpha(txt[0]))) {\n        return false;\n    }\n\n    // Get the last character of the string\n    char lastChar = txt.back();\n\n    // Check if the second-to-last character is a space and the last character is an alphabet letter\n    if ((txt.length() > 1) && (txt[txt.length() - 2] == ' ') && isalpha(lastChar)) {\n        return true;\n    }\n\n    return false;\n}\n\n"}
{"task_id": "CPP/135", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint can_arrange(vector<int> arr) {\n    int n = arr.size();\n    \n    // Iterate from the second last element to the first element\n    for (int i = n - 2; i >= 0; --i) {\n        if (arr[i] > arr[i + 1]) {\n            return i;\n        }\n    }\n    \n    // If no such element is found, return -1\n    return -1;\n}\n\n// Function to test the can_arrange function with provided examples\nvoid check() {\n    vector<int> arr1 = {1, 2, 4, 3, 5};\n    vector<int> arr2 = {1, 2, 3};\n    \n    cout << \"can_arrange({1, 2, 4, 3, 5}) = \" << can_arrange(arr1) << endl; // Should output 3\n    cout << \"can_arrange({1, 2, 3}) = \" << can_arrange(arr2) << endl;       // Should output -1\n}\n\n"}
{"task_id": "CPP/136", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Function to find the largest negative and smallest positive integers in a vector\nvector<int> largest_smallest_integers(vector<int> lst) {\n    int max_negative = INT_MIN; // Initialize with the smallest possible integer\n    int min_positive = INT_MAX; // Initialize with the largest possible integer\n\n    bool has_negative = false;\n    bool has_positive = false;\n\n    for (int num : lst) {\n        if (num < 0) {\n            has_negative = true;\n            max_negative = max(max_negative, num);\n        } else if (num > 0) {\n            has_positive = true;\n            min_positive = min(min_positive, num);\n        }\n    }\n\n    // If no negative or positive integers are found, return {0, 0}\n    if (!has_negative && !has_positive) {\n        return {0, 0};\n    }\n\n    return {max_negative, min_positive};\n}\n\n// Function to test the largest_smallest_integers function\nvoid test() {\n    vector<int> lst1 = {2, 4, 1, 3, 5, 7};\n    vector<int> result1 = largest_smallest_integers(lst1);\n    cout << \"Test 1: \" << (result1 == vector<int>{0, 1} ? \"Passed\" : \"Failed\") << endl;\n\n    vector<int> lst2 = {};\n    vector<int> result2 = largest_smallest_integers(lst2);\n    cout << \"Test 2: \" << (result2 == vector<int>{0, 0} ? \"Passed\" : \"Failed\") << endl;\n\n    vector<int> lst3 = {0};\n    vector<int> result3 = largest_smallest_integers(lst3);\n    cout << \"Test 3: \" << (result3 == vector<int>{0, 0} ? \"Passed\" : \"Failed\") << endl;\n}\n\n"}
{"task_id": "CPP/137", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <boost/any.hpp>\n\n// Function to convert string with comma as decimal separator to float\nfloat str_to_float(const std::string& str) {\n    size_t pos;\n    return std::stof(str, &pos);\n}\n\nboost::any compare_one(boost::any a, boost::any b) {\n    // Convert both values to strings for comparison\n    std::string a_str = a.convert<std::string>();\n    std::string b_str = b.convert<std::string>();\n\n    // Check if the first value is a string with comma as decimal separator\n    if (a.type() == typeid(std::string) && a_str.find(',') != std::string::npos) {\n        float a_float = str_to_float(a_str);\n        // Convert the second value to float for comparison\n        boost::any b_any = b;\n        std::string b_str_temp = b_any.convert<std::string>();\n        if (b.type() == typeid(std::string) && b_str_temp.find(',') != std::string::npos) {\n            float b_float = str_to_float(b_str_temp);\n            return a_float > b_float ? boost::any(a_float) : boost::any(b_float);\n        } else {\n            float b_float = std::stof(b_str_temp);\n            return a_float > b_float ? boost::any(a_float) : boost::any(b_float);\n        }\n    }\n\n    // Check if the second value is a string with comma as decimal separator\n    if (b.type() == typeid(std::string) && b_str.find(',') != std::string::npos) {\n        float b_float = str_to_float(b_str);\n        // Convert the first value to float for comparison\n        boost::any a_any = a;\n        std::string a_str_temp = a_any.convert<std::string>();\n        if (a.type() == typeid(std::string) && a_str_temp.find(',') != std::string::npos) {\n            float a_float = str_to_float(a_str_temp);\n            return b_float > a_float ? boost::any(b_float) : boost::any(a_float);\n        } else {\n            float a_float = std::stof(a_str_temp);\n            return b_float > a_float ? boost::any(b_float) : boost::any(a_float);\n        }\n    }\n\n    // Direct comparison of strings\n    if (a_str > b_str) {\n        return a;\n    } else if (b_str > a_str) {\n        return b;\n    } else {\n        return boost::any();\n    }\n}\n\n"}
{"task_id": "CPP/138", "generation": "#include <iostream>\nusing namespace std;\n\nbool is_equal_to_sum_even(int n) {\n    // Check if n is at least 8 and is even\n    return n >= 8 && n % 2 == 0;\n}\n\n"}
{"task_id": "CPP/139", "generation": "#include <iostream>\n\n// Function to calculate factorial\nlong long factorial(long long num) {\n    if (num == 0 || num == 1)\n        return 1;\n    long long fact = 1;\n    for (int i = 2; i <= num; ++i) {\n        fact *= i;\n    }\n    return fact;\n}\n\n// Function to calculate Brazilian factorial\nlong long special_factorial(int n) {\n    if (n < 0)\n        throw std::invalid_argument(\"Input must be a positive integer\");\n\n    long long result = 1;\n    for (int i = n; i > 0; --i) {\n        result *= factorial(i);\n    }\n    return result;\n}\n\n// Main function to test the special_factorial function\n"}
{"task_id": "CPP/140", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nstring fix_spaces(string text) {\n    string result;\n    int space_count = 0; // To count consecutive spaces\n\n    for (char ch : text) {\n        if (ch == ' ') {\n            space_count++;\n            if (space_count == 1) { // First space, add an underscore\n                result += '_';\n            } else if (space_count > 2) { // More than two consecutive spaces, add a hyphen and reset count\n                result += '-';\n                space_count = 0;\n            }\n        } else {\n            space_count = 0; // Reset the count for non-space characters\n            result += ch;\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/141", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool hasMoreThanThreeDigits(const string& filename) {\n    int digitCount = 0;\n    for (char c : filename) {\n        if (isdigit(c)) {\n            digitCount++;\n            if (digitCount > 3) return true;\n        }\n    }\n    return false;\n}\n\nbool containsExactlyOneDot(const string& filename) {\n    int dotCount = 0;\n    for (char c : filename) {\n        if (c == '.') {\n            dotCount++;\n        }\n    }\n    return dotCount == 1;\n}\n\nbool startsWithLetter(const string& filename) {\n    if (filename.empty()) return false;\n    char firstChar = tolower(filename[0]);\n    return ('a' <= firstChar && firstChar <= 'z') || ('A' <= firstChar && firstChar <= 'Z');\n}\n\nbool endsWithValidExtension(const string& filename) {\n    size_t dotPos = filename.find('.');\n    if (dotPos == string::npos) return false;\n    string extension = filename.substr(dotPos + 1);\n    return extension == \"txt\" || extension == \"exe\" || extension == \"dll\";\n}\n\nstring file_name_check(string file_name) {\n    // Check each condition\n    if (hasMoreThanThreeDigits(file_name)) return \"No\";\n    if (!containsExactlyOneDot(file_name)) return \"No\";\n    if (!startsWithLetter(file_name)) return \"No\";\n    if (!endsWithValidExtension(file_name)) return \"No\";\n\n    return \"Yes\";\n}\n\n"}
{"task_id": "CPP/142", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint sum_squares(vector<int> lst) {\n    int sum = 0;\n    \n    for (size_t i = 0; i < lst.size(); ++i) {\n        if ((i + 1) % 3 == 0 && (i + 1) % 4 != 0) {\n            // Square the integer entry\n            sum += lst[i] * lst[i];\n        } else if ((i + 1) % 4 == 0) {\n            // Cube the integer entry\n            sum += lst[i] * lst[i] * lst[i];\n        }\n    }\n    \n    return sum;\n}\n\n"}
{"task_id": "CPP/143", "generation": "#include <iostream>\n#include <string>\n#include <vector>\n\n// Function to check if a number is prime\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    if (n == 2 || n == 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    for (int i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0)\n            return false;\n    }\n    return true;\n}\n\n// Function to split the sentence into words\nstd::vector<std::string> split_sentence(const std::string& sentence) {\n    std::vector<std::string> words;\n    std::string word;\n    for (char ch : sentence) {\n        if (ch == ' ') {\n            if (!word.empty()) {\n                words.push_back(word);\n                word.clear();\n            }\n        } else {\n            word += ch;\n        }\n    }\n    if (!word.empty()) {\n        words.push_back(word);\n    }\n    return words;\n}\n\n// Function to get words with prime length\nstd::string words_in_sentence(const std::string& sentence) {\n    std::vector<std::string> words = split_sentence(sentence);\n    std::string result;\n\n    for (const auto& word : words) {\n        if (is_prime(word.length())) {\n            if (!result.empty()) {\n                result += \" \";\n            }\n            result += word;\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/144", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool simplify(string x, string n) {\n    // Function to parse numerator and denominator from a fraction string\n    auto parse_fraction = [](const string& frac) -> pair<int, int> {\n        size_t slash_pos = frac.find('/');\n        int numerator = stoi(frac.substr(0, slash_pos));\n        int denominator = stoi(frac.substr(slash_pos + 1));\n        return {numerator, denominator};\n    };\n\n    // Parse the fractions\n    auto [num_x, den_x] = parse_fraction(x);\n    auto [num_n, den_n] = parse_fraction(n);\n\n    // Compute the product of numerators and denominators\n    int numerator_product = num_x * num_n;\n    int denominator_product = den_x * den_n;\n\n    // Check if the result is a whole number\n    return (numerator_product % denominator_product) == 0;\n}\n\n"}
{"task_id": "CPP/145", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// Helper function to calculate the sum of digits of a number.\nint digitSum(int n) {\n    int sum = 0;\n    bool isNegative = n < 0;\n    while (n != 0) {\n        int d = abs(n % 10);\n        sum += d;\n        n /= 10;\n    }\n    // If the original number was negative, subtract the first digit from the sum.\n    if (isNegative && n == -1) {\n        sum -= 9; // Assuming single-digit numbers are handled correctly\n    }\n    return sum;\n}\n\n// Comparator function to sort based on digit sum and then by index.\nbool compareByDigitSumAndIndex(const pair<int, int>& a, const pair<int, int>& b) {\n    if (a.first != b.first) {\n        // Compare by digit sum first\n        return a.first < b.first;\n    } else {\n        // If digit sums are equal, compare by original index\n        return a.second < b.second;\n    }\n}\n\nvector<int> order_by_points(vector<int> nums) {\n    vector<pair<int, int>> indexedNums;\n\n    for (int i = 0; i < nums.size(); ++i) {\n        // Store the number and its original index as a pair\n        indexedNums.push_back({digitSum(nums[i]), i});\n    }\n\n    // Sort based on digit sum and then by original index\n    sort(indexedNums.begin(), indexedNums.end(), compareByDigitSumAndIndex);\n\n    // Extract the sorted numbers from the pairs\n    vector<int> result;\n    for (const auto& p : indexedNums) {\n        result.push_back(nums[p.second]);\n    }\n\n    return result;\n}\n\n// Function to test the order_by_points function\nvoid check() {\n    assert(order_by_points({1, 11, -1, -11, -12}) == vector<int>{-1, -11, 1, -12, 11});\n    assert(order_by_points({}) == vector<int>{});\n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/146", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nint specialFilter(vector<int> nums) {\n    int count = 0;\n    \n    for (int num : nums) {\n        // Skip numbers that are not greater than 10\n        if (num <= 10) continue;\n        \n        string strNum = to_string(num);\n        int firstDigit = strNum[0] - '0';\n        int lastDigit = strNum[strNum.length() - 1] - '0';\n        \n        // Check if both the first and last digits are odd\n        if (firstDigit % 2 != 0 && lastDigit % 2 != 0) {\n            count++;\n        }\n    }\n    \n    return count;\n}\n\n"}
{"task_id": "CPP/147", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint get_max_triples(int n) {\n    // Step 1: Generate the vector a\n    vector<int> a(n);\n    for (int i = 1; i <= n; ++i) {\n        a[i-1] = i * i - i + 1;\n    }\n\n    int count = 0;\n\n    // Step 2: Check all possible triples (a_i, a_j, a_k)\n    for (int i = 0; i < n - 2; ++i) {\n        for (int j = i + 1; j < n - 1; ++j) {\n            for (int k = j + 1; k < n; ++k) {\n                if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                    count++;\n                }\n            }\n        }\n    }\n\n    return count;\n}\n\n// Example usage\n"}
{"task_id": "CPP/148", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to find the index of a planet in the sorted list of planets.\nint getPlanetIndex(const string& planet) {\n    const string planets[] = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n    \n    for (int i = 0; i < 8; ++i) {\n        if (planets[i] == planet) {\n            return i;\n        }\n    }\n    // If the planet is not found, return -1.\n    return -1;\n}\n\n// Function to get planets between two given planets.\nvector<string> bf(string planet1, string planet2) {\n    int index1 = getPlanetIndex(planet1);\n    int index2 = getPlanetIndex(planet2);\n\n    // Check if both planets are valid and in the correct order\n    if (index1 == -1 || index2 == -1 || index1 >= index2) {\n        return {};  // Return an empty vector if invalid or out of order.\n    }\n\n    vector<string> result;\n    for (int i = index1 + 1; i < index2; ++i) {\n        result.push_back(planets[i]);\n    }\n    \n    return result;\n}\n\n// Function to test the bf function\nvoid test() {\n    vector<string> result;\n\n    // Test cases\n    result = bf(\"Jupiter\", \"Neptune\");\n    for (const auto& planet : result) {\n        cout << planet << \" \";\n    }\n    cout << endl;\n\n    result = bf(\"Earth\", \"Mercury\");\n    for (const auto& planet : result) {\n        cout << planet << \" \";\n    }\n    cout << endl;\n\n    result = bf(\"Mercury\", \"Uranus\");\n    for (const auto& planet : result) {\n        cout << planet << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/149", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to check if a string has an odd length\nbool has_odd_length(const string& str) {\n    return str.length() % 2 != 0;\n}\n\n// Custom comparator for sorting strings first by length, then alphabetically\nstruct custom_comparator {\n    bool operator()(const string& a, const string& b) {\n        if (a.length() == b.length()) {\n            return a < b; // Alphabetical order if lengths are the same\n        }\n        return a.length() < b.length(); // Length order first\n    }\n};\n\nvector<string> sorted_list_sum(vector<string> lst) {\n    // Remove strings with odd lengths\n    lst.erase(remove_if(lst.begin(), lst.end(), has_odd_length), lst.end());\n    \n    // Sort the list using the custom comparator\n    sort(lst.begin(), lst.end(), custom_comparator());\n    \n    return lst;\n}\n\n// Function to test the sorted_list_sum function\nvoid check() {\n    assert(sorted_list_sum({\"aa\", \"a\", \"aaa\"}) == vector<string>{\"aa\"});\n    assert(sorted_list_sum({\"ab\", \"a\", \"aaa\", \"cd\"}) == vector<string>{\"ab\", \"cd\"});\n    cout << \"All tests passed successfully.\" << endl;\n}\n\n"}
{"task_id": "CPP/150", "generation": "#include <stdio.h>\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int num) {\n    if (num <= 1) return false; // Numbers less than or equal to 1 are not prime\n    for (int i = 2; i * i <= num; ++i) {\n        if (num % i == 0) return false; // If divisible by any number other than 1 and itself, it's not prime\n    }\n    return true;\n}\n\n// Function to return x if n is a prime number, otherwise return y\nint x_or_y(int n, int x, int y) {\n    return is_prime(n) ? x : y; // Use ternary operator for concise logic\n}\n\n"}
{"task_id": "CPP/151", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nlong long double_the_difference(vector<float> lst) {\n    long long sum = 0;\n    \n    for (float num : lst) {\n        // Check if the number is positive, an integer, and odd\n        if (num > 0 && floor(num) == num && static_cast<int>(num) % 2 != 0) {\n            sum += pow(num, 2);\n        }\n    }\n    \n    return sum;\n}\n\n"}
{"task_id": "CPP/152", "generation": "#include <stdio.h>\n#include <math.h>\n#include <vector>\nusing namespace std;\n\nvector<int> compare(vector<int> game, vector<int> guess) {\n    vector<int> result;\n    \n    // Iterate through each match and calculate the difference\n    for (size_t i = 0; i < game.size(); ++i) {\n        int diff = abs(game[i] - guess[i]);\n        result.push_back(diff);\n    }\n    \n    return result;\n}\n\n// Function to test the compare function with provided examples\nvoid test() {\n    vector<int> scores1 = {1, 2, 3, 4, 5, 1};\n    vector<int> guesses1 = {1, 2, 3, 4, 2, -2};\n    vector<int> expected1 = {0, 0, 0, 0, 3, 3};\n    \n    vector<int> scores2 = {0, 5, 0, 0, 0, 4};\n    vector<int> guesses2 = {4, 1, 1, 0, 0, -2};\n    vector<int> expected2 = {4, 4, 1, 0, 0, 6};\n    \n    assert(compare(scores1, guesses1) == expected1);\n    assert(compare(scores2, guesses2) == expected2);\n    \n    printf(\"All tests passed.\\n\");\n}\n\n"}
{"task_id": "CPP/153", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to calculate the strength of an extension\nint calculateStrength(const string& extension) {\n    int cap = 0, sm = 0;\n    for (char c : extension) {\n        if (isupper(c)) cap++;\n        else if (islower(c)) sm++;\n    }\n    return cap - sm;\n}\n\n// Function to find the strongest extension\nstring Strongest_Extension(string class_name, vector<string> extensions) {\n    int max_strength = INT_MIN; // Initialize with minimum possible integer value\n    string strongest_extension;\n\n    for (const string& ext : extensions) {\n        int strength = calculateStrength(ext);\n        if (strength > max_strength) {\n            max_strength = strength;\n            strongest_extension = ext;\n        }\n    }\n\n    return class_name + \".\" + strongest_extension;\n}\n\n// Function to test the Strongest_Extension function\nvoid test() {\n    cout << Strongest_Extension(\"my_class\", {\"AA\", \"Be\", \"CC\"}) << endl; // Expected: my_class.AA\n    cout << Strongest_Extension(\"Slices\", {\"SErviNGSliCes\", \"Cheese\", \"StuFfed\"}) << endl; // Expected: Slices.SErviNGSliCes\n}\n\n"}
{"task_id": "CPP/154", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\n// Function to rotate a string by one position to the left\nstring rotateLeft(string s) {\n    char firstChar = s[0];\n    for (int i = 1; i < s.length(); ++i) {\n        s[i - 1] = s[i];\n    }\n    s[s.length() - 1] = firstChar;\n    return s;\n}\n\n// Function to check if any rotation of b is a substring of a\nbool cycpattern_check(string a, string b) {\n    // Check for direct substring\n    if (a.find(b) != string::npos) {\n        return true;\n    }\n\n    int n = b.length();\n    string rotatedB = b;\n\n    // Generate all rotations and check each one\n    for (int i = 1; i < n; ++i) {\n        rotatedB = rotateLeft(rotatedB);\n        if (a.find(rotatedB) != string::npos) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\n// Function to test the cycpattern_check function\nvoid test() {\n    cout << boolalpha; // Print boolean values as true/false instead of 1/0\n    cout << \"cycpattern_check(\\\"abcd\\\", \\\"abd\\\") => \" << cycpattern_check(\"abcd\", \"abd\") << endl;\n    cout << \"cycpattern_check(\\\"hello\\\", \\\"ell\\\") => \" << cycpattern_check(\"hello\", \"ell\") << endl;\n    cout << \"cycpattern_check(\\\"whassup\\\", \\\"psus\\\") => \" << cycpattern_check(\"whassup\", \"psus\") << endl;\n    cout << \"cycpattern_check(\\\"abab\\\", \\\"baa\\\") => \" << cycpattern_check(\"abab\", \"baa\") << endl;\n    cout << \"cycpattern_check(\\\"efef\\\", \\\"eeff\\\") => \" << cycpattern_check(\"efef\", \"eeff\") << endl;\n    cout << \"cycpattern_check(\\\"himenss\\\", \\\"simen\\\") => \" << cycpattern_check(\"himenss\", \"simen\") << endl;\n}\n\n"}
{"task_id": "CPP/155", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// Function to count even and odd digits in a given integer\nvector<int> even_odd_count(int num) {\n    // Convert the number to its absolute value to handle negative numbers\n    int abs_num = abs(num);\n    \n    vector<int> counts(2, 0); // Initialize a vector with two elements (even and odd counts)\n    \n    while (abs_num > 0) {\n        int digit = abs_num % 10; // Get the last digit\n        \n        if (digit % 2 == 0) { // Check if the digit is even\n            counts[0]++; // Increment even count\n        } else {\n            counts[1]++; // Increment odd count\n        }\n        \n        abs_num /= 10; // Remove the last digit\n    }\n    \n    return counts;\n}\n\n// Function to test the even_odd_count function\nvoid test_even_odd_count() {\n    assert(even_odd_count(-12) == vector<int>({1, 1}));\n    assert(even_odd_count(123) == vector<int>({1, 2}));\n    assert(even_odd_count(0) == vector<int>({1, 0})); // Edge case: single digit zero\n    assert(even_odd_count(-9876543210) == vector<int>({5, 5})); // Even and odd counts are equal\n    \n    cout << \"All test cases passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/156", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nstring int_to_mini_roman(int number) {\n    // Mapping of integers to their corresponding lowercase Roman numerals\n    vector<pair<int, string>> roman_numerals = {\n        {1000, \"m\"}, {900, \"cm\"}, {500, \"d\"}, {400, \"cd\"},\n        {100, \"c\"}, {90, \"xc\"}, {50, \"l\"}, {40, \"xl\"},\n        {10, \"x\"}, {9, \"ix\"}, {5, \"v\"}, {4, \"iv\"}, {1, \"i\"}\n    };\n\n    string result = \"\";\n\n    // Iterate over the mapping and subtract values from number\n    for (const auto &pair : roman_numerals) {\n        while (number >= pair.first) {\n            result += pair.second;\n            number -= pair.first;\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/157", "generation": "#include <stdio.h>\n#include <math.h>\n\nusing namespace std;\n\nbool right_angle_triangle(float a, float b, float c) {\n    // First, find the longest side (hypotenuse)\n    float max_side = fmax(a, fmax(b, c));\n    \n    // Check if the square of the hypotenuse is equal to the sum of squares of other two sides\n    return (max_side * max_side == a * a + b * b + c * c - 2 * min(min(a, b), c) * min(min(a, b), c));\n}\n\n"}
{"task_id": "CPP/158", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to count unique characters in a string\nint count_unique_chars(const string& word) {\n    bool char_set[256] = {false}; // Assuming ASCII characters\n    int unique_count = 0;\n    for (char c : word) {\n        if (!char_set[c]) {\n            char_set[c] = true;\n            unique_count++;\n        }\n    }\n    return unique_count;\n}\n\n// Function to find the word with maximum number of unique characters\nstring find_max(vector<string> words) {\n    string max_word = \"\";\n    int max_unique_chars = 0;\n\n    for (const string& word : words) {\n        int unique_chars = count_unique_chars(word);\n        if (unique_chars > max_unique_chars || \n            (unique_chars == max_unique_chars && word < max_word)) {\n            max_word = word;\n            max_unique_chars = unique_chars;\n        }\n    }\n\n    return max_word;\n}\n\n// Function to test the find_max function\nvoid test_find_max() {\n    assert(find_max({\"name\", \"of\", \"string\"}) == \"string\");\n    assert(find_max({\"name\", \"enam\", \"game\"}) == \"enam\");\n    assert(find_max({\"aaaaaaa\", \"bb\", \"cc\"}) == \"aaaaaaa\");\n    cout << \"All test cases passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/159", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> eat(int number, int need, int remaining) {\n    // Calculate the actual number of carrots to be eaten from the remaining stock\n    int to_eat = min(need, remaining);\n    \n    // Update the total number of carrots eaten\n    int total_eaten = number + to_eat;\n    \n    // Update the remaining number of carrots\n    int left_remaining = remaining - to_eat;\n    \n    return {total_eaten, left_remaining};\n}\n\n// Function to test the eat function with provided examples\nvoid test_eat() {\n    vector<int> result1 = eat(5, 6, 10);\n    cout << \"eat(5, 6, 10) -> {\" << result1[0] << \", \" << result1[1] << \"}\" << endl;\n    \n    vector<int> result2 = eat(4, 8, 9);\n    cout << \"eat(4, 8, 9) -> {\" << result2[0] << \", \" << result2[1] << \"}\" << endl;\n    \n    vector<int> result3 = eat(1, 10, 10);\n    cout << \"eat(1, 10, 10) -> {\" << result3[0] << \", \" << result3[1] << \"}\" << endl;\n    \n    vector<int> result4 = eat(2, 11, 5);\n    cout << \"eat(2, 11, 5) -> {\" << result4[0] << \", \" << result4[1] << \"}\" << endl;\n}\n\n"}
{"task_id": "CPP/160", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nint do_algebra(vector<string> operatorVec, vector<int> operandVec) {\n    // Initialize result with the first operand\n    int result = operandVec[0];\n\n    // Iterate through the operators and operands to construct and evaluate the expression\n    for (size_t i = 0; i < operatorVec.size(); ++i) {\n        if (operatorVec[i] == \"+\") {\n            result += operandVec[i + 1];\n        } else if (operatorVec[i] == \"-\") {\n            result -= operandVec[i + 1];\n        } else if (operatorVec[i] == \"*\") {\n            result *= operandVec[i + 1];\n        } else if (operatorVec[i] == \"//\") {\n            result /= operandVec[i + 1]; // Floor division\n        } else if (operatorVec[i] == \"**\") {\n            result = pow(result, operandVec[i + 1]); // Exponentiation\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/161", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool isLetter(char c) {\n    return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z');\n}\n\nchar reverseCase(char c) {\n    if (islower(c)) {\n        return toupper(c);\n    } else if (isupper(c)) {\n        return tolower(c);\n    }\n    return c;\n}\n\nstring solve(string s) {\n    bool hasLetters = false;\n\n    // Check for letters in the string\n    for (char c : s) {\n        if (isLetter(c)) {\n            hasLetters = true;\n            break;\n        }\n    }\n\n    if (!hasLetters) {\n        // If no letters, reverse the entire string\n        reverse(s.begin(), s.end());\n    } else {\n        // If there are letters, reverse their case\n        for (char &c : s) {\n            c = reverseCase(c);\n        }\n    }\n\n    return s;\n}\n\n"}
{"task_id": "CPP/162", "generation": "#include <iostream>\n#include <string>\n#include <openssl/md5.h>\n\n// Function to convert string to its MD5 hash equivalent\nstd::string string_to_md5(const std::string& text) {\n    unsigned char digest[MD5_DIGEST_LENGTH];\n    MD5((unsigned char*)text.c_str(), text.length(), (unsigned char*)&digest);    \n\n    // Create destination string\n    char mdString[33];\n    for(int i = 0; i < 16; ++i)\n        sprintf(&mdString[i*2], \"%02x\", (unsigned int)digest[i]);\n\n    return std::string(mdString);\n}\n\n"}
{"task_id": "CPP/163", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\n// Function to generate even digits between two integers a and b\nvector<int> generate_integers(int a, int b) {\n    vector<int> result;\n    \n    // Ensure a is less than or equal to b for simplicity\n    if (a > b) swap(a, b);\n    \n    // Iterate through the range [a, b]\n    for (int i = a; i <= b; ++i) {\n        int num = i;\n        \n        // Extract digits from the number and check if they are even\n        while (num > 0) {\n            int digit = num % 10;\n            if (digit % 2 == 0 && result.size() < 4) { // Collect up to 4 unique even digits\n                result.push_back(digit);\n            }\n            num /= 10;\n        }\n    }\n    \n    return result;\n}\n\n// Function to print the vector for testing purposes\nvoid print_vector(const vector<int>& vec) {\n    printf(\"{\");\n    for (size_t i = 0; i < vec.size(); ++i) {\n        printf(\"%d\", vec[i]);\n        if (i != vec.size() - 1) printf(\", \");\n    }\n    printf(\"}\\n\");\n}\n\n"}
{"task_id": "CPP/0", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // For std::sort\nusing namespace std;\n\nbool has_close_elements(vector<float> numbers, float threshold) {\n    // Sort the vector to ensure we only need to check adjacent elements\n    sort(numbers.begin(), numbers.end());\n\n    // Iterate through the sorted vector and check if any two consecutive elements are closer than the threshold\n    for (size_t i = 0; i < numbers.size() - 1; ++i) {\n        if (numbers[i + 1] - numbers[i] < threshold) {\n            return true;\n        }\n    }\n\n    // If no such pair is found, return false\n    return false;\n}\n\n// Function to test the has_close_elements function with provided data points\nvoid check() {\n    assert(has_close_elements({1.0f, 2.0f, 3.0f}, 0.5f) == false);\n    assert(has_close_elements({1.0f, 2.8f, 3.0f, 4.0f, 5.0f, 2.0f}, 0.3f) == true);\n    cout << \"All tests passed.\" << endl;\n}\n\n"}
{"task_id": "CPP/1", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> separate_paren_groups(string paren_string) {\n    vector<string> result;\n    string current_group;\n    int balance = 0;\n\n    for (char ch : paren_string) {\n        if (ch == '(') {\n            // If the group is not empty, push it to the result and reset\n            if (!current_group.empty()) {\n                result.push_back(current_group);\n                current_group.clear();\n            }\n            ++balance;\n        } else if (ch == ')') {\n            --balance;\n            current_group += ch;\n            if (balance == 0) {\n                // A complete group is formed, add it to the result\n                result.push_back(current_group);\n                current_group.clear();\n            }\n        } else {\n            continue; // Ignore spaces\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/2", "generation": "#include <stdio.h>\n#include <math.h>\n\nfloat truncate_number(float number) {\n    float intPart;\n    modf(number, &intPart);  // intPart will be the largest integer less than or equal to number\n    return number - intPart; // The result is the decimal part of the number\n}\n\n"}
{"task_id": "CPP/3", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool below_zero(const vector<int>& operations) {\n    int balance = 0; // Start with a zero balance\n\n    for (int op : operations) {\n        balance += op; // Update the balance after each operation\n        if (balance < 0) {\n            return true; // Return true if balance falls below zero\n        }\n    }\n\n    return false; // Return false if balance never goes below zero\n}\n\n// Function to test the below_zero function with provided examples\nvoid check() {\n    vector<int> ops1 = {1, 2, 3};\n    vector<int> ops2 = {1, 2, -4, 5};\n\n    cout << \"Test 1: \" << (below_zero(ops1) ? \"true\" : \"false\") << endl; // Should output false\n    cout << \"Test 2: \" << (below_zero(ops2) ? \"true\" : \"false\") << endl; // Should output true\n}\n\n"}
{"task_id": "CPP/4", "generation": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nfloat mean_absolute_deviation(vector<float> numbers) {\n    if (numbers.empty()) {\n        return 0.0f; // Return 0 for an empty vector to avoid division by zero.\n    }\n\n    float sum = 0.0f;\n    for (const auto& num : numbers) {\n        sum += num;\n    }\n    float mean = sum / numbers.size();\n\n    float mad = 0.0f;\n    for (const auto& num : numbers) {\n        mad += abs(num - mean);\n    }\n    mad /= numbers.size();\n\n    return mad;\n}\n\n"}
{"task_id": "CPP/5", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> intersperse(vector<int> numbers, int delimeter) {\n    if (numbers.empty()) return {}; // Return empty vector if input is empty\n\n    vector<int> result;\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        result.push_back(numbers[i]);\n        if (i != numbers.size() - 1) { // Don't add delimiter after the last element\n            result.push_back(delimeter);\n        }\n    }\n\n    return result;\n}\n\n// Function to print the vector for testing purposes\nvoid printVector(const vector<int>& vec) {\n    for (int num : vec) {\n        cout << num << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/6", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to parse a single group of nested parentheses and return its deepest level of nesting.\nint maxDepth(string& paren_group) {\n    int current_depth = 0;\n    int max_depth = 0;\n    \n    for (char ch : paren_group) {\n        if (ch == '(') {\n            current_depth++;\n            max_depth = max(max_depth, current_depth);\n        } else if (ch == ')') {\n            current_depth--;\n        }\n    }\n    \n    return max_depth;\n}\n\n// Function to parse the entire string and return a vector of maximum depths for each group.\nvector<int> parse_nested_parens(string paren_string) {\n    vector<int> result;\n    size_t start = 0, end = 0;\n    \n    while (end < paren_string.length()) {\n        // Find the next group\n        if (paren_string[end] == '(' || paren_string[end] == ')') {\n            end++;\n        } else {\n            end++;\n        }\n        \n        // Extract the current group and calculate its depth\n        string group = paren_string.substr(start, end - start);\n        result.push_back(maxDepth(group));\n        \n        // Move to the next group\n        while (end < paren_string.length() && (paren_string[end] == ' ' || paren_string[end] == '(' || paren_string[end] == ')')) {\n            if (paren_string[end] != ' ') end++;\n        }\n        start = end;\n    }\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/7", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to filter strings containing a given substring\nvector<string> filter_by_substring(vector<string> strings, string substring) {\n    vector<string> filteredStrings;\n    \n    // Iterate through each string in the input vector\n    for (const auto& str : strings) {\n        // Check if the current string contains the given substring\n        if (str.find(substring) != string::npos) {\n            // If it does, add it to the filtered list\n            filteredStrings.push_back(str);\n        }\n    }\n    \n    return filteredStrings;\n}\n\n// Function to test the filter_by_substring function\nvoid test_filter_by_substring() {\n    vector<string> input1 = {};\n    vector<string> expected1 = {};\n    assert(filter_by_substring(input1, \"a\") == expected1);\n\n    vector<string> input2 = {\"abc\", \"bacd\", \"cde\", \"vector\"};\n    vector<string> expected2 = {\"abc\", \"bacd\", \"vector\"};\n    assert(filter_by_substring(input2, \"a\") == expected2);\n\n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/8", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Function to calculate the sum and product of a vector of integers.\nvector<int> sum_product(vector<int> numbers) {\n    int sum = 0;\n    int product = 1;\n\n    // Iterate through each number in the vector.\n    for (int num : numbers) {\n        sum += num;  // Add the current number to the sum.\n        if (num != 0) {\n            product *= num;  // Multiply the current number with the product, but skip zero to avoid unnecessary multiplication.\n        }\n    }\n\n    return {sum, product};\n}\n\n// Function to test the sum_product function.\nvoid test_sum_product() {\n    vector<int> empty;\n    vector<int> numbers = {1, 2, 3, 4};\n\n    // Test with an empty vector\n    auto result_empty = sum_product(empty);\n    cout << \"Empty Vector: Sum = \" << result_empty[0] << \", Product = \" << result_empty[1] << endl;\n\n    // Test with a non-empty vector\n    auto result_numbers = sum_product(numbers);\n    cout << \"Numbers Vector: Sum = \" << result_numbers[0] << \", Product = \" << result_numbers[1] << endl;\n}\n\n"}
{"task_id": "CPP/9", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> rolling_max(vector<int> numbers) {\n    vector<int> result;\n    if (numbers.empty()) return result;  // Return empty vector if input is empty\n\n    int current_max = numbers[0];  // Initialize the current maximum with the first element\n    for (int num : numbers) {\n        if (num > current_max) {\n            current_max = num;  // Update current_max if a larger number is found\n        }\n        result.push_back(current_max);  // Add the current maximum to the result vector\n    }\n\n    return result;\n}\n\n// Function to print the vector for testing purposes\nvoid print_vector(const vector<int>& vec) {\n    for (int num : vec) {\n        cout << num << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/10", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_palindrome(const string& str) {\n    // Test if given string is a palindrome\n    return str == string(str.rbegin(), str.rend());\n}\n\nstring make_palindrome(string str) {\n    /*\n    Find the shortest palindrome that begins with a supplied string. \n    Algorithm idea is simple: - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    */\n    \n    // Iterate from the end of the string towards the beginning\n    for (int i = str.length(); i > 0; --i) {\n        if (is_palindrome(str.substr(0, i))) {\n            // Found the longest palindromic prefix\n            break;\n        }\n    }\n\n    // If no palindromic suffix is found, the entire string itself is a palindrome\n    if (i == str.length()) {\n        return str;\n    }\n\n    // The length of the non-palindromic prefix\n    int len_prefix = str.length() - i;\n\n    // Reverse the non-palindromic prefix and append it to the end of the string\n    string reversed_prefix(str.substr(0, len_prefix));\n    reverse(reversed_prefix.begin(), reversed_prefix.end());\n    \n    return str + reversed_prefix;\n}\n\n"}
{"task_id": "CPP/11", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\n// Function to perform binary XOR on two strings\nstring string_xor(string a, string b) {\n    // Ensure both strings are of the same length\n    if (a.length() != b.length()) {\n        throw runtime_error(\"Input strings must be of the same length\");\n    }\n\n    // Initialize an empty result string\n    string result = \"\";\n\n    // Perform XOR on each bit and append to the result string\n    for (size_t i = 0; i < a.length(); ++i) {\n        if (a[i] == b[i]) {\n            result += \"0\";\n        } else {\n            result += \"1\";\n        }\n    }\n\n    return result;\n}\n\n// Function to test the string_xor function\nvoid test_string_xor() {\n    cout << \"Testing string_xor function:\" << endl;\n    cout << \"Input: \\\"010\\\", \\\"110\\\" | Output: \\\"\" << string_xor(\"010\", \"110\") << \"\\\" | Expected: \\\"100\\\"\" << endl;\n}\n\n"}
{"task_id": "CPP/12", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring longest(vector<string> strings) {\n    if (strings.empty()) {\n        return \"\"; // Return an empty string to indicate None in case of an empty vector.\n    }\n\n    string longestString = strings[0]; // Initialize with the first string\n\n    for (const auto& str : strings) {\n        if (str.length() > longestString.length()) {\n            longestString = str;\n        }\n    }\n\n    return longestString;\n}\n\n"}
{"task_id": "CPP/13", "generation": "#include <stdio.h>\nusing namespace std;\n\nint greatest_common_divisor(int a, int b) {\n    // Ensure a >= b to simplify the logic\n    if (b > a) {\n        return greatest_common_divisor(b, a);\n    }\n\n    // Base case: if b is 0, then GCD is a\n    if (b == 0) {\n        return a;\n    }\n\n    // Recursive call with remainder of a divided by b\n    return greatest_common_divisor(b, a % b);\n}\n\n"}
{"task_id": "CPP/14", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> all_prefixes(const string& str) {\n    vector<string> prefixes;\n    for (size_t i = 1; i <= str.length(); ++i) {\n        prefixes.push_back(str.substr(0, i));\n    }\n    return prefixes;\n}\n\n"}
{"task_id": "CPP/15", "generation": "#include <iostream>\n#include <sstream>\n#include <string>\n\nstd::string string_sequence(int n) {\n    if (n < 0) return \"\"; // Handle negative input gracefully\n\n    std::stringstream ss;\n    for (int i = 0; i <= n; ++i) {\n        ss << i;\n        if (i != n) ss << \" \";\n    }\n    return ss.str();\n}\n\n// Function to test the string_sequence function\nvoid test_string_sequence() {\n    assert(string_sequence(0) == \"0\");\n    assert(string_sequence(5) == \"0 1 2 3 4 5\");\n    assert(string_sequence(-1).empty()); // Test for negative input\n\n    std::cout << \"All tests passed!\" << std::endl;\n}\n\n"}
{"task_id": "CPP/16", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nint count_distinct_characters(string str) {\n    // Convert the string to lowercase to ensure case insensitivity\n    transform(str.begin(), str.end(), str.begin(), ::tolower);\n    \n    // Use a set to store distinct characters\n    std::set<char> distinct_chars;\n    \n    // Iterate through each character in the string and add it to the set\n    for (char c : str) {\n        distinct_chars.insert(c);\n    }\n    \n    // The size of the set is the number of distinct characters\n    return distinct_chars.size();\n}\n\n"}
{"task_id": "CPP/17", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<int> parse_music(string music_string) {\n    vector<int> beats;\n    \n    // Iterate through the string, processing one character at a time.\n    for (size_t i = 0; i < music_string.length(); ++i) {\n        if (music_string[i] == 'o') {  // Whole note\n            beats.push_back(4);\n        } else if (music_string[i] == '|') {  // Check the next character to determine the type of note\n            if (music_string[i + 1] == '|') {  // Half note\n                beats.push_back(2);\n                i++;  // Skip the next character as it's part of the half note\n            } else {  // Quater note\n                beats.push_back(1);\n            }\n        }\n    }\n\n    return beats;\n}\n\n"}
{"task_id": "CPP/18", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint how_many_times(string str, string substring) {\n    int count = 0;\n    size_t pos = 0;\n\n    // Loop through the original string to find all occurrences of the substring\n    while ((pos = str.find(substring, pos)) != string::npos) {\n        count++;\n        pos++; // Move one character forward to allow for overlapping matches\n    }\n\n    return count;\n}\n\n"}
{"task_id": "CPP/19", "generation": "#include <iostream>\n#include <string>\n#include <map>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to map number words to their numeric values\nmap<string, int> word_to_num = {\n    {\"zero\", 0},\n    {\"one\", 1},\n    {\"two\", 2},\n    {\"three\", 3},\n    {\"four\", 4},\n    {\"five\", 5},\n    {\"six\", 6},\n    {\"seven\", 7},\n    {\"eight\", 8},\n    {\"nine\", 9}\n};\n\n// Function to sort the string of number words\nstring sort_numbers(string numbers) {\n    // Split the input string into a vector of words\n    vector<string> num_words;\n    string current_word = \"\";\n    for (char ch : numbers) {\n        if (ch == ' ') {\n            num_words.push_back(current_word);\n            current_word = \"\";\n        } else {\n            current_word += ch;\n        }\n    }\n    // Add the last word if there is one\n    if (!current_word.empty()) {\n        num_words.push_back(current_word);\n    }\n\n    // Sort the vector based on numeric values using a custom comparator\n    sort(num_words.begin(), num_words.end(), [&](const string& a, const string& b) {\n        return word_to_num[a] < word_to_num[b];\n    });\n\n    // Join the sorted words back into a single string\n    string result;\n    for (size_t i = 0; i < num_words.size(); ++i) {\n        if (i > 0) {\n            result += \" \";\n        }\n        result += num_words[i];\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/20", "generation": "#include <iostream>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\npair<float, float> find_closest_elements(vector<float> numbers) {\n    if (numbers.size() < 2) {\n        throw invalid_argument(\"The vector must contain at least two elements.\");\n    }\n\n    // Initialize the first pair of closest elements\n    float min_diff = abs(numbers[1] - numbers[0]);\n    float closest_pair[2] = {numbers[0], numbers[1]};\n\n    // Iterate through the vector starting from the second element\n    for (size_t i = 1; i < numbers.size() - 1; ++i) {\n        float current_diff = abs(numbers[i + 1] - numbers[i]);\n        if (current_diff < min_diff) {\n            min_diff = current_diff;\n            closest_pair[0] = min(numbers[i], numbers[i + 1]);\n            closest_pair[1] = max(numbers[i], numbers[i + 1]);\n        }\n    }\n\n    return make_pair(closest_pair[0], closest_pair[1]);\n}\n\n"}
{"task_id": "CPP/21", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // For std::min_element and std::max_element\n\nusing namespace std;\n\nvector<float> rescale_to_unit(vector<float> numbers) {\n    if (numbers.size() < 2) {\n        throw invalid_argument(\"Vector must contain at least two elements.\");\n    }\n\n    float min_value = *std::min_element(numbers.begin(), numbers.end());\n    float max_value = *std::max_element(numbers.begin(), numbers.end());\n\n    vector<float> scaled_numbers;\n    for (float num : numbers) {\n        float new_value = (num - min_value) / (max_value - min_value);\n        scaled_numbers.push_back(new_value);\n    }\n\n    return scaled_numbers;\n}\n\n"}
{"task_id": "CPP/22", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <list>\n#include <boost/any.hpp>\n\ntypedef std::list<boost::any> list_any;\nusing namespace std;\n\n// Function to filter integers from a list of boost::any values\nvector<int> filter_integers(list_any values) {\n    vector<int> result;\n    \n    for (const auto& value : values) {\n        if (value.type() == typeid(int)) {\n            result.push_back(boost::any_cast<int>(value));\n        }\n    }\n    \n    return result;\n}\n\n// Function to check the correctness of the filter_integers function\nvoid check_function() {\n    list_any test1 = {boost::any(3.14), boost::any(5)};\n    vector<int> expected1 = {5};\n    assert(filter_integers(test1) == expected1);\n\n    list_any test2 = {boost::any(1), boost::any(2), boost::any(3), boost::any(\"abc\"), boost::any({}), boost::any({})};\n    vector<int> expected2 = {1, 2, 3};\n    assert(filter_integers(test2) == expected2);\n\n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/23", "generation": "#include <iostream>\nusing namespace std;\n\nint strlen(string str) {\n    int count = 0;\n    for (char ch : str) {\n        if (ch == '\\0') break; // Stop when we reach the null terminator\n        count++;\n    }\n    return count;\n}\n\n// Function to test the strlen function with some examples\nvoid test_strlen() {\n    cout << \"strlen(\\\"\\\") = \" << strlen(\"\") << endl;\n    cout << \"strlen(\\\"abc\\\") = \" << strlen(\"abc\") << endl;\n    cout << \"strlen(\\\"hello world\\\") = \" << strlen(\"hello world\") << endl;\n}\n\n"}
{"task_id": "CPP/24", "generation": "#include <iostream>\nusing namespace std;\n\nint largest_divisor(int n) {\n    for (int i = n - 1; i > 0; --i) {\n        if (n % i == 0) {\n            return i;\n        }\n    }\n    // If no divisor is found, which should not happen for positive integers,\n    // you can return a default value like 1.\n    return 1;\n}\n\n"}
{"task_id": "CPP/25", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> factorize(int n) {\n    vector<int> factors;\n    \n    // Check for each number from 2 to sqrt(n)\n    for (int i = 2; i * i <= n; ++i) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n    \n    // If there's any prime factor left greater than sqrt(n)\n    if (n > 1) {\n        factors.push_back(n);\n    }\n    \n    return factors;\n}\n\n"}
{"task_id": "CPP/26", "generation": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nvector<int> remove_duplicates(vector<int> numbers) {\n    // Create an unordered map to count occurrences of each number\n    unordered_map<int, int> counts;\n    \n    // Count the occurrences of each number in the input vector\n    for (int num : numbers) {\n        counts[num]++;\n    }\n    \n    // Reserve space in the result vector to improve performance\n    vector<int> result;\n    result.reserve(numbers.size());\n    \n    // Iterate through the original vector and add elements that occur only once\n    for (int num : numbers) {\n        if (counts[num] == 1) {\n            result.push_back(num);\n        }\n    }\n    \n    return result;\n}\n\n// Function to check the correctness of the remove_duplicates function\nvoid check() {\n    vector<int> input = {1, 2, 3, 2, 4};\n    vector<int> expected_output = {1, 3, 4};\n    vector<int> output = remove_duplicates(input);\n    \n    if (output == expected_output) {\n        cout << \"Test passed.\" << endl;\n    } else {\n        cout << \"Test failed.\" << endl;\n    }\n}\n\n"}
{"task_id": "CPP/27", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring flip_case(string str) {\n    for (char &c : str) {\n        // Check if the character is an uppercase letter and convert it to lowercase\n        if (isupper(c)) {\n            c = tolower(c);\n        }\n        // Otherwise, check if the character is a lowercase letter and convert it to uppercase\n        else if (islower(c)) {\n            c = toupper(c);\n        }\n    }\n    return str;\n}\n\n"}
{"task_id": "CPP/28", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <numeric> // For std::accumulate\n\nusing namespace std;\n\nstring concatenate(vector<string> strings) {\n    if (strings.empty()) {\n        return \"\";\n    }\n    \n    // Use std::accumulate to concatenate all strings in the vector\n    string result = accumulate(strings.begin(), strings.end(), \"\"s,\n                               [](const string& a, const string& b) { return a + b; });\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/29", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> filter_by_prefix(vector<string> strings, string prefix) {\n    vector<string> result;\n    for (const auto& str : strings) {\n        if (str.substr(0, prefix.length()) == prefix) {\n            result.push_back(str);\n        }\n    }\n    return result;\n}\n\n// Function to test the filter_by_prefix function\nvoid test_filter_by_prefix() {\n    vector<string> input1 = {};\n    vector<string> expected1 = {};\n    assert(filter_by_prefix(input1, \"a\") == expected1);\n\n    vector<string> input2 = {\"abc\", \"bcd\", \"cde\", \"vector\"};\n    vector<string> expected2 = {\"abc\", \"vector\"};\n    assert(filter_by_prefix(input2, \"a\") == expected2);\n\n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/30", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvector<float> get_positive(vector<float> l) {\n    vector<float> result;\n    \n    // Iterate through each element in the input vector\n    for (float num : l) {\n        // Check if the number is positive\n        if (num > 0) {\n            // Add it to the result vector\n            result.push_back(num);\n        }\n    }\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/31", "generation": "#include <iostream>\n#include <cmath>\n\nbool is_prime(long long n) {\n    // Handle edge cases\n    if (n <= 1) return false;\n    if (n == 2 || n == 3) return true;\n\n    // Check divisibility from 2 to sqrt(n)\n    for (long long i = 2; i <= std::sqrt(n); ++i) {\n        if (n % i == 0) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\n"}
{"task_id": "CPP/32", "generation": "#include <iostream>\n#include <vector>\n#include <cmath>\n\ndouble poly(vector<double> xs, double x) {\n    double sum = 0;\n    int i;\n    for (i = 0; i < xs.size(); i++) {\n        sum += xs[i] * pow(x, i);\n    }\n    return sum;\n}\n\ndouble deriv_poly(vector<double> xs, double x) {\n    double sum = 0;\n    int i;\n    for (i = 1; i < xs.size(); i++) {\n        sum += xs[i] * i * pow(x, i - 1);\n    }\n    return sum;\n}\n\ndouble find_zero(vector<double> xs) {\n    // Initial guess\n    double x = 0.0;\n\n    // Tolerance for convergence\n    const double tol = 1e-6;\n\n    // Maximum number of iterations to avoid infinite loops\n    const int max_iter = 1000;\n\n    for (int iter = 0; iter < max_iter; ++iter) {\n        double f_x = poly(xs, x);\n        double f_prime_x = deriv_poly(xs, x);\n\n        if (fabs(f_prime_x) < tol) {\n            // Avoid division by zero\n            break;\n        }\n\n        x -= f_x / f_prime_x;\n\n        if (fabs(f_x) < tol) {\n            // Convergence criterion\n            break;\n        }\n    }\n\n    return x;\n}\n\n"}
{"task_id": "CPP/33", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> sort_third(vector<int> l) {\n    vector<int> third_indices;\n    \n    // Extract elements at indices divisible by three\n    for (size_t i = 2; i < l.size(); i += 3) {\n        third_indices.push_back(l[i]);\n    }\n    \n    // Sort the extracted elements\n    sort(third_indices.begin(), third_indices.end());\n    \n    // Replace original values with sorted ones at indices divisible by three\n    for (size_t i = 2, j = 0; i < l.size(); i += 3, ++j) {\n        l[i] = third_indices[j];\n    }\n    \n    return l;\n}\n\n// Function to check the correctness of the sort_third function\nvoid check() {\n    vector<int> result1 = sort_third({1, 2, 3});\n    assert(result1 == vector<int>({1, 2, 3}));\n    \n    vector<int> result2 = sort_third({5, 6, 3, 4, 8, 9, 2});\n    assert(result2 == vector<int>({2, 6, 3, 4, 8, 9, 5}));\n    \n    cout << \"All test cases passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/34", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> unique(vector<int> l) {\n    // Sort the vector\n    sort(l.begin(), l.end());\n    \n    // Remove consecutive duplicates and get new end iterator\n    auto new_end = unique(l.begin(), l.end());\n    \n    // Resize the vector to contain only the unique elements\n    l.resize(distance(l.begin(), new_end));\n    \n    return l;\n}\n\n"}
{"task_id": "CPP/35", "generation": "#include <iostream>\n#include <vector>\n\nfloat max_element(const std::vector<float>& l) {\n    if (l.empty()) {\n        throw std::invalid_argument(\"Vector is empty\");\n    }\n\n    float max_val = l[0];\n    for (size_t i = 1; i < l.size(); ++i) {\n        if (l[i] > max_val) {\n            max_val = l[i];\n        }\n    }\n    return max_val;\n}\n\n"}
{"task_id": "CPP/36", "generation": "#include <iostream>\nusing namespace std;\n\nint fizz_buzz(int n) {\n    int count = 0;\n    \n    for (int i = 1; i < n; ++i) {\n        if (i % 11 == 0 || i % 13 == 0) {\n            // Convert the number to a string and count occurrences of '7'\n            string num_str = to_string(i);\n            for (char c : num_str) {\n                if (c == '7') {\n                    ++count;\n                }\n            }\n        }\n    }\n    \n    return count;\n}\n\n"}
{"task_id": "CPP/37", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<float> sort_even(vector<float> l) {\n    // Extract elements at even indices (0, 2, 4, ...)\n    vector<float> even_elements;\n    for (size_t i = 0; i < l.size(); i += 2) {\n        even_elements.push_back(l[i]);\n    }\n\n    // Sort the extracted even-indexed elements\n    sort(even_elements.begin(), even_elements.end());\n\n    // Create a new vector to store the result\n    vector<float> sorted_l(l);\n\n    // Place the sorted even-indexed elements back into their original positions\n    size_t even_index = 0;\n    for (size_t i = 0; i < l.size(); i += 2) {\n        sorted_l[i] = even_elements[even_index++];\n    }\n\n    return sorted_l;\n}\n\n// Function to test the sort_even function\nvoid test_sort_even() {\n    vector<float> result1 = sort_even({1, 2, 3});\n    for (float val : result1) {\n        cout << val << \" \";\n    }\n    cout << endl;\n\n    vector<float> result2 = sort_even({5, 6, 3, 4});\n    for (float val : result2) {\n        cout << val << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/38", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring encode_cyclic(string s) {\n    // returns encoded string by cycling groups of three characters.\n    int l = s.length();\n    int num = (l + 2) / 3;\n    string x, output;\n    for (int i = 0; i * 3 < l; i++) {\n        x = s.substr(i * 3, 3);\n        if (x.length() == 3) x = x.substr(1) + x[0];\n        output += x;\n    }\n    return output;\n}\n\nstring decode_cyclic(string s) {\n    /*\n    takes as input string encoded with encode_cyclic function. Returns decoded string.\n    */\n    int l = s.length();\n    int num = (l + 2) / 3;\n    string x, output;\n    for (int i = 0; i * 3 < l; i++) {\n        x = s.substr(i * 3, 3);\n        if (x.length() == 3) x = x[2] + x.substr(0, 2); // Move the first character to the end\n        output += x;\n    }\n    return output;\n}\n\n"}
{"task_id": "CPP/39", "generation": "#include <iostream>\n#include <cmath>\n\n// Function to check if a number is prime\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    if (num == 2 || num == 3) return true;\n    if (num % 2 == 0 || num % 3 == 0) return false;\n    for (int i = 5; i * i <= num; i += 6) {\n        if (num % i == 0 || num % (i + 2) == 0)\n            return false;\n    }\n    return true;\n}\n\n// Function to generate the n-th Fibonacci number that is also prime\nint prime_fib(int n) {\n    int count = 0; // Counter for prime Fibonacci numbers found\n    int a = 0, b = 1; // First two Fibonacci numbers\n\n    while (true) {\n        int fib = a + b;\n        a = b;\n        b = fib;\n\n        if (is_prime(fib)) {\n            count++;\n            if (count == n) {\n                return fib;\n            }\n        }\n    }\n\n    return -1; // This line should never be reached\n}\n\n"}
{"task_id": "CPP/40", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nbool triples_sum_to_zero(vector<int> l) {\n    // First, sort the vector to facilitate the two-pointer approach.\n    sort(l.begin(), l.end());\n    \n    int n = l.size();\n    \n    // Iterate through each element in the vector.\n    for (int i = 0; i < n - 2; ++i) {\n        // Skip duplicate elements to avoid redundant checks.\n        if (i > 0 && l[i] == l[i-1]) continue;\n        \n        int left = i + 1, right = n - 1;\n        \n        while (left < right) {\n            int sum = l[i] + l[left] + l[right];\n            \n            if (sum == 0) {\n                return true; // Found a triplet that sums to zero.\n            } else if (sum < 0) {\n                ++left; // Need a larger number, move the left pointer to right.\n            } else {\n                --right; // Need a smaller number, move the right pointer to left.\n            }\n        }\n    }\n    \n    return false; // No triplet found that sums to zero.\n}\n\n"}
{"task_id": "CPP/41", "generation": "#include <iostream>\nusing namespace std;\n\nint car_race_collision(int n) {\n    return n;\n}\n\n"}
{"task_id": "CPP/42", "generation": "#include <vector>\nusing namespace std;\n\n// Function to increment each element in the vector by 1\nvector<int> incr_list(vector<int> l) {\n    // Iterate through the vector and increment each element\n    for (int &elem : l) {\n        elem += 1;\n    }\n    \n    return l;\n}\n\n// Example usage:\n#include <iostream>\n#include <cassert>\n\n"}
{"task_id": "CPP/43", "generation": "#include <iostream>\n#include <vector>\n#include <set>\n\nusing namespace std;\n\nbool pairs_sum_to_zero(vector<int> l) {\n    // Use a set to store seen numbers\n    set<int> seen;\n    \n    for (int num : l) {\n        // Check if the negation of the current number is in the set\n        if (seen.find(-num) != seen.end()) {\n            return true;  // Found a pair that sums to zero\n        }\n        // Add the current number to the set\n        seen.insert(num);\n    }\n    \n    return false;  // No such pair found\n}\n\n// Function to test the pairs_sum_to_zero function with provided examples\nvoid test_pairs_sum_to_zero() {\n    assert(pairs_sum_to_zero({1, 3, 5, 0}) == false);\n    assert(pairs_sum_to_zero({1, 3, -2, 1}) == false);\n    assert(pairs_sum_to_zero({1, 2, 3, 7}) == false);\n    assert(pairs_sum_to_zero({2, 4, -5, 3, 5, 7}) == true);\n    assert(pairs_sum_to_zero({1}) == false);\n\n    cout << \"All test cases passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/44", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring change_base(int x, int base) {\n    if (x == 0) {\n        return \"0\";\n    }\n    \n    string result = \"\";\n    while (x > 0) {\n        int remainder = x % base;\n        result = to_string(remainder) + result;\n        x /= base;\n    }\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/45", "generation": "#include <stdio.h>\nusing namespace std;\n\nfloat triangle_area(float a, float h) {\n    return 0.5 * a * h;\n}\n\n"}
{"task_id": "CPP/46", "generation": "#include <iostream>\nusing namespace std;\n\nint fib4(int n) {\n    if (n == 0 || n == 1 || n == 2) {\n        return n == 2 ? 2 : 0;\n    }\n    \n    int a = 0, b = 0, c = 2, d = 0; // Initial values for fib4(0), fib4(1), fib4(2), and fib4(3)\n    int result;\n\n    for (int i = 3; i <= n; ++i) {\n        result = a + b + c + d;\n        a = b;\n        b = c;\n        c = d;\n        d = result;\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/47", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nfloat median(vector<float> l) {\n    // Sort the vector\n    sort(l.begin(), l.end());\n    \n    int n = l.size();\n    if (n % 2 == 0) {\n        // If even number of elements, return average of the two middle elements\n        return (l[n/2 - 1] + l[n/2]) / 2.0;\n    } else {\n        // If odd number of elements, return the middle element\n        return l[n/2];\n    }\n}\n\n"}
{"task_id": "CPP/48", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_palindrome(string text) {\n    int start = 0;\n    int end = text.length() - 1;\n\n    while (start < end) {\n        if (text[start] != text[end]) {\n            return false; // If characters at the current positions are not equal, it's not a palindrome\n        }\n        start++;\n        end--;\n    }\n\n    return true; // If all corresponding characters match, it is a palindrome\n}\n\n"}
{"task_id": "CPP/49", "generation": "#include <stdio.h>\nusing namespace std;\n\nint modp(int n, int p) {\n    if (n == 0)\n        return 1; // Any number to the power of 0 is 1\n\n    int result = 1;\n    long long base = 2;\n\n    while (n > 0) {\n        if (n % 2 == 1) { // If n is odd, multiply the result by the current base\n            result = (result * base) % p;\n        }\n        base = (base * base) % p; // Square the base and reduce modulo p\n        n /= 2; // Halve the exponent\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/50", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nstring encode_shift(string s) {\n    // returns encoded string by shifting every character by 5 in the alphabet.\n    string out;\n    int i;\n    for (i = 0; i < s.length(); i++) {\n        int w = ((int)s[i] + 5 - (int)'a') % 26 + (int)'a';\n        out += (char)w;\n    }\n    return out;\n}\n\nstring decode_shift(string s) {\n    // takes as input string encoded with encode_shift function. Returns decoded string.\n    string out;\n    int i;\n    for (i = 0; i < s.length(); i++) {\n        int w = ((int)s[i] - 5 - (int)'a') % 26 + (int)'a';\n        out += (char)w;\n    }\n    return out;\n}\n\n"}
{"task_id": "CPP/51", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring remove_vowels(string text) {\n    // Define vowels as both lowercase and uppercase\n    const string vowels = \"aeiouAEIOU\";\n    \n    // Create an empty string to store the result\n    string result;\n    \n    // Iterate through each character in the input string\n    for (char ch : text) {\n        // Check if the character is not a vowel\n        if (vowels.find(ch) == string::npos) {\n            // If it's not a vowel, add it to the result string\n            result += ch;\n        }\n    }\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/52", "generation": "#include <vector>\n#include <iostream>\n\n// Function to check if all elements in the vector are below the threshold\nbool below_threshold(const std::vector<int>& l, int t) {\n    for (const auto& num : l) {\n        if (num >= t) {\n            return false;\n        }\n    }\n    return true;\n}\n\n"}
{"task_id": "CPP/53", "generation": "#include <iostream>  // Include iostream for input/output operations\n\nusing namespace std;\n\nint add(int x, int y) {\n    return x + y;  // Return the sum of x and y\n}\n\n"}
{"task_id": "CPP/54", "generation": "#include <iostream>\n#include <string>\n#include <set>\n\nusing namespace std;\n\nbool same_chars(string s0, string s1) {\n    // Create a set for each string to store unique characters\n    set<char> chars_s0(s0.begin(), s0.end());\n    set<char> chars_s1(s1.begin(), s1.end());\n\n    // Check if both sets have the same elements\n    return chars_s0 == chars_s1;\n}\n\n"}
{"task_id": "CPP/55", "generation": "#include <stdio.h>\nusing namespace std;\n\nint fib(int n) {\n    if (n <= 0) return 0;\n    if (n == 1) return 1;\n\n    int a = 0, b = 1, c;\n    for (int i = 2; i <= n; ++i) {\n        c = a + b;\n        a = b;\n        b = c;\n    }\n    return b;\n}\n\n"}
{"task_id": "CPP/56", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    int balance = 0;\n    \n    for (char bracket : brackets) {\n        if (bracket == '<') {\n            balance++;\n        } else if (bracket == '>') {\n            balance--;\n            if (balance < 0) {\n                // If balance is negative, it means there's a closing bracket without an opening one\n                return false;\n            }\n        }\n    }\n    \n    // If balance is zero, all brackets are correctly matched\n    return balance == 0;\n}\n\n"}
{"task_id": "CPP/57", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool monotonic(vector<float> l) {\n    // Check if the vector is empty or has only one element\n    if (l.size() <= 1) return true;\n\n    bool increasing = false;\n    bool decreasing = false;\n\n    for (size_t i = 1; i < l.size(); ++i) {\n        if (l[i] > l[i - 1]) {\n            increasing = true;\n        } else if (l[i] < l[i - 1]) {\n            decreasing = true;\n        }\n\n        // If both increasing and decreasing flags are set, the sequence is not monotonic\n        if (increasing && decreasing) return false;\n    }\n\n    // The vector is either monotonically increasing or decreasing\n    return true;\n}\n\n"}
{"task_id": "CPP/58", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n// Function to remove duplicates and sort the vector\nvoid removeDuplicatesAndSort(vector<int>& vec) {\n    sort(vec.begin(), vec.end());\n    vec.erase(unique(vec.begin(), vec.end()), vec.end());\n}\n\n// Function to find common elements between two vectors\nvector<int> common(vector<int> l1, vector<int> l2) {\n    // Remove duplicates and sort both vectors\n    removeDuplicatesAndSort(l1);\n    removeDuplicatesAndSort(l2);\n\n    vector<int> result;\n    int i = 0, j = 0;\n\n    // Use two-pointer technique to find common elements\n    while (i < l1.size() && j < l2.size()) {\n        if (l1[i] == l2[j]) {\n            result.push_back(l1[i]);\n            ++i;\n            ++j;\n        } else if (l1[i] < l2[j]) {\n            ++i;\n        } else {\n            ++j;\n        }\n    }\n\n    return result;\n}\n\n// Function to print the vector\nvoid printVector(const vector<int>& vec) {\n    for (int num : vec) {\n        cout << num << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/59", "generation": "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\nint largest_prime_factor(int n) {\n    // Remove all the factors of 2\n    while (n % 2 == 0) {\n        n /= 2;\n    }\n\n    // Now n must be odd, start from 3 and remove all factors\n    for (int i = 3; i <= sqrt(n); i += 2) {\n        while (n % i == 0) {\n            n /= i;\n        }\n    }\n\n    // If n is a prime number greater than 2\n    if (n > 2) {\n        return n;\n    } else {\n        return -1; // This case should not happen as per the assumption that n is not a prime.\n    }\n}\n\n"}
{"task_id": "CPP/60", "generation": "#include <iostream>\nusing namespace std;\n\nint sum_to_n(int n) {\n    int sum = 0;\n    for (int i = 1; i <= n; ++i) {\n        sum += i;\n    }\n    return sum;\n}\n\n"}
{"task_id": "CPP/61", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    int balance = 0;\n    \n    for (char bracket : brackets) {\n        if (bracket == '(') {\n            balance++;\n        } else if (bracket == ')') {\n            balance--;\n        }\n        \n        // If at any point the balance is negative, it means there's a closing parenthesis without an opening one.\n        if (balance < 0) {\n            return false;\n        }\n    }\n    \n    // Finally, check if all parentheses are balanced\n    return balance == 0;\n}\n\n"}
{"task_id": "CPP/62", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvector<float> derivative(vector<float> xs) {\n    vector<float> result;\n    \n    // Iterate through the coefficients, starting from the first non-constant term\n    for (size_t i = 1; i < xs.size(); ++i) {\n        // Multiply the coefficient by its power and add to the result\n        result.push_back(xs[i] * i);\n    }\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/63", "generation": "#include <iostream>\nusing namespace std;\n\nint fibfib(int n) {\n    if (n == 0 || n == 1) return 0;\n    if (n == 2) return 1;\n\n    // Array to store the computed values of FibFib sequence\n    int dp[n + 1];\n    dp[0] = 0; // fibfib(0)\n    dp[1] = 0; // fibfib(1)\n    dp[2] = 1; // fibfib(2)\n\n    // Fill the dp array using the recurrence relation\n    for (int i = 3; i <= n; ++i) {\n        dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3];\n    }\n\n    return dp[n];\n}\n\n"}
{"task_id": "CPP/64", "generation": "#include <iostream>\n#include <string>\n\nint vowels_count(const std::string& s) {\n    int count = 0;\n    \n    // Convert the string to lowercase for easier comparison\n    std::transform(s.begin(), s.end(), s.begin(), ::tolower);\n    \n    // Check each character in the string\n    for (char c : s) {\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' || \n            (c == 'y' && s.length() - 1 == std::distance(s.begin(), std::find_if(s.rbegin(), s.rend(), [c](char ch) { return ch == c; }))) {\n            count++;\n        }\n    }\n    \n    return count;\n}\n\n"}
{"task_id": "CPP/65", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring circular_shift(int x, int shift) {\n    // Convert integer to string\n    string numStr = to_string(x);\n    \n    // Get the length of the number\n    size_t len = numStr.length();\n    \n    // If shift is greater than or equal to the number of digits, reverse the string\n    if (shift >= len) {\n        reverse(numStr.begin(), numStr.end());\n        return numStr;\n    }\n    \n    // Perform circular shift\n    int effectiveShift = shift % len;  // Handle shifts larger than the length of the number\n    string shiftedNumStr = numStr.substr(len - effectiveShift) + numStr.substr(0, len - effectiveShift);\n    \n    return shiftedNumStr;\n}\n\n"}
{"task_id": "CPP/66", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint digitSum(string s) {\n    int sum = 0;\n    for (char c : s) {\n        if (isupper(c)) { // Check if the character is uppercase\n            sum += static_cast<int>(c); // Add ASCII value of the character to sum\n        }\n    }\n    return sum;\n}\n\n// Function to test the digitSum function with provided examples\nvoid testDigitSum() {\n    cout << \"Testing digitSum:\" << endl;\n    assert(digitSum(\"\") == 0);\n    assert(digitSum(\"abAB\") == 131); // 'A' + 'B' = 65 + 66 = 131\n    assert(digitSum(\"abcCd\") == 67); // 'C' = 67\n    assert(digitSum(\"helloE\") == 69); // 'E' = 69\n    assert(digitSum(\"woArBld\") == 131); // 'A' + 'B' = 65 + 66 = 131\n    assert(digitSum(\"aAaaaXa\") == 153); // 'A' + 'A' + 'A' + 'X' = 65 + 65 + 65 + 88 = 283\n\n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/67", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint fruit_distribution(string s, int n) {\n    // Find the position of 'apples' in the string\n    size_t apples_pos = s.find(\"apples\");\n    \n    // Extract the number before 'apples'\n    size_t start_apples = s.rfind(' ', apples_pos);\n    if (start_apples == string::npos) {\n        start_apples = 0;\n    }\n    int num_apples = stoi(s.substr(start_apples, apples_pos - start_apples));\n    \n    // Find the position of 'oranges' in the string\n    size_t oranges_pos = s.find(\"oranges\");\n    \n    // Extract the number before 'oranges'\n    size_t start_oranges = s.rfind(' ', oranges_pos);\n    if (start_oranges == string::npos) {\n        start_oranges = 0;\n    }\n    int num_oranges = stoi(s.substr(start_oranges, oranges_pos - start_oranges));\n    \n    // Calculate the number of mangoes\n    int num_mangoes = n - num_apples - num_oranges;\n    \n    return num_mangoes;\n}\n\n"}
{"task_id": "CPP/68", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> pluck(vector<int> arr) {\n    int smallestEvenValue = -1;\n    int smallestIndex = -1;\n\n    for (int i = 0; i < arr.size(); ++i) {\n        if (arr[i] % 2 == 0 && (smallestEvenValue == -1 || arr[i] < smallestEvenValue)) {\n            smallestEvenValue = arr[i];\n            smallestIndex = i;\n        }\n    }\n\n    // If no even value was found, return an empty vector\n    if (smallestEvenValue == -1) {\n        return {};\n    } else {\n        return {smallestEvenValue, smallestIndex};\n    }\n}\n\n"}
{"task_id": "CPP/69", "generation": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint search(vector<int> lst) {\n    // Create a frequency map to count occurrences of each integer\n    unordered_map<int, int> freqMap;\n    \n    // Count the frequency of each number in the list\n    for (int num : lst) {\n        freqMap[num]++;\n    }\n    \n    // Initialize the result with -1\n    int result = -1;\n    \n    // Iterate through the map to find the greatest integer meeting the condition\n    for (const auto& pair : freqMap) {\n        if (pair.second >= pair.first && pair.first > result) {\n            result = pair.first;\n        }\n    }\n    \n    return result;\n}\n\n// Function to test the search function with provided examples\nvoid test() {\n    cout << \"Test 1: \" << search({4, 1, 2, 2, 3, 1}) << \" (Expected: 2)\" << endl;\n    cout << \"Test 2: \" << search({1, 2, 2, 3, 3, 3, 4, 4, 4}) << \" (Expected: 3)\" << endl;\n    cout << \"Test 3: \" << search({5, 5, 4, 4, 4}) << \" (Expected: -1)\" << endl;\n}\n\n"}
{"task_id": "CPP/70", "generation": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> strange_sort_list(vector<int> lst) {\n    // Sort the input vector in ascending order\n    sort(lst.begin(), lst.end());\n    \n    vector<int> result;\n    int left = 0;  // Pointer to the start of the sorted list\n    int right = lst.size() - 1;  // Pointer to the end of the sorted list\n    \n    while (left <= right) {\n        if (left == right) {\n            // If there's only one element left, add it to the result\n            result.push_back(lst[left]);\n            break;\n        }\n        \n        // Add the minimum value (from the start)\n        result.push_back(lst[left++]);\n        \n        // Add the maximum value (from the end)\n        result.push_back(lst[right--]);\n    }\n    \n    return result;\n}\n\n// Function to test the strange_sort_list function\nvoid test_strange_sort() {\n    vector<int> lst1 = {1, 2, 3, 4};\n    vector<int> expected1 = {1, 4, 2, 3};\n    assert(strange_sort_list(lst1) == expected1);\n    \n    vector<int> lst2 = {5, 5, 5, 5};\n    vector<int> expected2 = {5, 5, 5, 5};\n    assert(strange_sort_list(lst2) == expected2);\n    \n    vector<int> lst3 = {};\n    vector<int> expected3 = {};\n    assert(strange_sort_list(lst3) == expected3);\n    \n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/71", "generation": "#include <stdio.h>\n#include <math.h>\n\nusing namespace std;\n\nfloat triangle_area(float a, float b, float c) {\n    // Check if the sides form a valid triangle\n    if (a + b <= c || a + c <= b || b + c <= a) {\n        return -1;\n    }\n\n    // Calculate the semi-perimeter\n    float s = (a + b + c) / 2;\n\n    // Calculate the area using Heron's formula\n    float area = sqrt(s * (s - a) * (s - b) * (s - c));\n\n    // Round the result to 2 decimal points\n    return round(area * 100) / 100;\n}\n\n"}
{"task_id": "CPP/72", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool will_it_fly(vector<int> q, int w) {\n    // Check if the sum of elements is less than or equal to w\n    int sum = 0;\n    for (int num : q) {\n        sum += num;\n    }\n    \n    if (sum > w) return false; // If sum exceeds maximum possible weight, return false\n    \n    // Check if the vector is palindromic\n    for (size_t i = 0; i < q.size() / 2; ++i) {\n        if (q[i] != q[q.size() - 1 - i]) {\n            return false; // If not palindromic, return false\n        }\n    }\n    \n    return true; // If both conditions are met, return true\n}\n\n// Function to test the will_it_fly function with provided examples\nvoid check() {\n    cout << (will_it_fly({1, 2}, 5) ? \"true\" : \"false\") << endl; // false\n    cout << (will_it_fly({3, 2, 3}, 1) ? \"true\" : \"false\") << endl; // false\n    cout << (will_it_fly({3, 2, 3}, 9) ? \"true\" : \"false\") << endl; // true\n    cout << (will_it_fly({3}, 5) ? \"true\" : \"false\") << endl; // true\n}\n\n"}
{"task_id": "CPP/73", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint smallest_change(vector<int> arr) {\n    int left = 0;\n    int right = arr.size() - 1;\n    int changes = 0;\n\n    while (left < right) {\n        if (arr[left] != arr[right]) {\n            changes++;\n        }\n        left++;\n        right--;\n    }\n\n    return changes;\n}\n\n"}
{"task_id": "CPP/74", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to calculate the total number of characters in a vector of strings\nint count_chars(const vector<string>& lst) {\n    int total = 0;\n    for (const string& str : lst) {\n        total += str.length();\n    }\n    return total;\n}\n\nvector<string> total_match(vector<string> lst1, vector<string> lst2) {\n    // Calculate the total number of characters in both vectors\n    int chars_lst1 = count_chars(lst1);\n    int chars_lst2 = count_chars(lst2);\n\n    // Compare and return the appropriate vector\n    if (chars_lst1 < chars_lst2) {\n        return lst1;\n    } else if (chars_lst2 < chars_lst1) {\n        return lst2;\n    } else {\n        return lst1;  // Both vectors have the same number of characters, return the first one\n    }\n}\n\n// Function to test the total_match function with provided examples\nvoid test_total_match() {\n    cout << \"Test 1: \";\n    vector<string> result = total_match({}, {});\n    for (const string& str : result) {\n        cout << \"\\\"\" << str << \"\\\" \";\n    }\n    cout << endl;\n\n    cout << \"Test 2: \";\n    result = total_match({\"hi\", \"admin\"}, {\"hI\", \"Hi\"});\n    for (const string& str : result) {\n        cout << \"\\\"\" << str << \"\\\" \";\n    }\n    cout << endl;\n\n    cout << \"Test 3: \";\n    result = total_match({\"hi\", \"admin\"}, {\"hi\", \"hi\", \"admin\", \"project\"});\n    for (const string& str : result) {\n        cout << \"\\\"\" << str << \"\\\" \";\n    }\n    cout << endl;\n\n    cout << \"Test 4: \";\n    result = total_match({\"hi\", \"admin\"}, {\"hI\", \"hi\", \"hi\"});\n    for (const string& str : result) {\n        cout << \"\\\"\" << str << \"\\\" \";\n    }\n    cout << endl;\n\n    cout << \"Test 5: \";\n    result = total_match({\"4\"}, {\"1\", \"2\", \"3\", \"4\", \"5\"});\n    for (const string& str : result) {\n        cout << \"\\\"\" << str << \"\\\" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/75", "generation": "#include <iostream>\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\n// Function to check if the number can be expressed as a product of exactly three primes\nbool is_multiply_prime(int a) {\n    int count = 0;\n\n    // Check for prime factors less than 100\n    for (int i = 2; i < 100 && count <= 3; ++i) {\n        if (is_prime(i)) {\n            while (a % i == 0) {\n                a /= i;\n                count++;\n            }\n        }\n    }\n\n    // If the number is reduced to 1 and exactly three prime factors were found\n    return a == 1 && count == 3;\n}\n\n"}
{"task_id": "CPP/76", "generation": "#include <iostream>\n#include <cmath>\n\nbool is_simple_power(int x, int n) {\n    // Check for edge cases where n or x might be 0 or 1.\n    if (n == 1) {\n        return x == 1;\n    }\n    if (x == 1) {\n        return true;\n    }\n\n    // Calculate the logarithm base n of x\n    double log_result = log(x) / log(n);\n\n    // Check if the result is an integer by comparing it with its rounded value.\n    return floor(log_result + 0.5) == log_result;\n}\n\n"}
{"task_id": "CPP/77", "generation": "#include <stdio.h>\n#include <math.h>\nusing namespace std;\n\nbool iscube(int a) {\n    // Handle special cases: 0 and 1\n    if (a == 0 || a == 1) return true;\n    \n    // Calculate the cube root of the absolute value of 'a'\n    double cubeRoot = cbrt(abs(a));\n    \n    // Round the cube root to the nearest integer\n    int roundedCubeRoot = round(cubeRoot);\n    \n    // Check if cubing the rounded value gives back the original number\n    return (roundedCubeRoot * roundedCubeRoot * roundedCubeRoot == a);\n}\n\n"}
{"task_id": "CPP/78", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\n// Helper function to determine if a hexadecimal digit is prime\nbool is_prime_hex_digit(char hex_digit) {\n    switch (hex_digit) {\n        case '2': case '3': case '5': case '7':\n        case 'B': case 'D': // B and D are represented as uppercase letters in the input string\n            return true;\n        default:\n            return false;\n    }\n}\n\n// Function to count prime hexadecimal digits in a given string\nint hex_key(string num) {\n    int prime_count = 0;\n\n    for (char digit : num) {\n        if (is_prime_hex_digit(digit)) {\n            prime_count++;\n        }\n    }\n\n    return prime_count;\n}\n\n"}
{"task_id": "CPP/79", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring decimal_to_binary(int decimal) {\n    if (decimal == 0) {\n        return \"db0db\";\n    }\n\n    string binary = \"\";\n    while (decimal > 0) {\n        int remainder = decimal % 2;\n        binary = to_string(remainder) + binary;\n        decimal /= 2;\n    }\n    \n    // Add the prefix and suffix\n    return \"db\" + binary + \"db\";\n}\n\n"}
{"task_id": "CPP/80", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_happy(string s) {\n    // Check if the string length is less than 3\n    if (s.length() < 3) return false;\n    \n    // Iterate through the string and check every three consecutive characters\n    for (int i = 0; i <= s.length() - 3; ++i) {\n        // If any two of these three characters are the same, return false\n        if (s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]) {\n            return false;\n        }\n    }\n    \n    // If no consecutive sets of three characters have duplicates, return true\n    return true;\n}\n\n"}
{"task_id": "CPP/81", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to determine the letter grade for a given GPA\nstring get_letter_grade(float gpa) {\n    if (gpa >= 4.0) return \"A+\";\n    else if (gpa > 3.7) return \"A\";\n    else if (gpa > 3.3) return \"A-\";\n    else if (gpa > 3.0) return \"B+\";\n    else if (gpa > 2.7) return \"B\";\n    else if (gpa > 2.3) return \"B-\";\n    else if (gpa > 2.0) return \"C+\";\n    else if (gpa > 1.7) return \"C\";\n    else if (gpa > 1.3) return \"C-\";\n    else if (gpa > 1.0) return \"D+\";\n    else if (gpa > 0.7) return \"D\";\n    else if (gpa > 0.0) return \"D-\";\n    else return \"E\";\n}\n\n// Function to convert a vector of GPAs into letter grades\nvector<string> numerical_letter_grade(vector<float> grades) {\n    vector<string> letter_grades;\n    for (float gpa : grades) {\n        letter_grades.push_back(get_letter_grade(gpa));\n    }\n    return letter_grades;\n}\n\n"}
{"task_id": "CPP/82", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    if (n == 2 || n == 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n\n    for (int i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0)\n            return false;\n    }\n    return true;\n}\n\n// Function to check if the length of a string is prime\nbool prime_length(string str) {\n    int len = str.length();\n    return is_prime(len);\n}\n\n"}
{"task_id": "CPP/83", "generation": "#include <iostream>\nusing namespace std;\n\nint starts_one_ends(int n) {\n    // If n is 1, there's only one number (1 itself)\n    if (n == 1) return 1;\n    \n    // Count of numbers starting with 1: 10^(n-1)\n    int start_with_1 = pow(10, n - 1);\n    \n    // Count of numbers ending with 1: 10^(n-1)\n    int end_with_1 = pow(10, n - 1);\n    \n    // Count of numbers starting and ending with 1: 10^(n-2)\n    int both_start_and_end_with_1 = pow(10, n - 2);\n    \n    // Total count is the sum minus the overlap\n    return start_with_1 + end_with_1 - both_start_and_end_with_1;\n}\n\n"}
{"task_id": "CPP/84", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring solve(int N) {\n    int sum = 0;\n    \n    // Compute the sum of the digits\n    while (N > 0) {\n        sum += N % 10;  // Add the last digit to the sum\n        N /= 10;       // Remove the last digit from N\n    }\n    \n    // Convert the sum to a binary string\n    string result = \"\";\n    if (sum == 0) {\n        return \"0\";\n    }\n    \n    while (sum > 0) {\n        result = to_string(sum % 2) + result;  // Prepend the least significant bit\n        sum /= 2;                             // Divide by 2 for next iteration\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/85", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint add(vector<int> lst) {\n    int sum = 0;\n    \n    // Iterate through the vector starting from index 1 and increment by 2\n    for (size_t i = 1; i < lst.size(); i += 2) {\n        if (lst[i] % 2 == 0) {  // Check if the element is even\n            sum += lst[i];      // Add it to the sum\n        }\n    }\n    \n    return sum;\n}\n\n// Function to test the add function with provided examples\nvoid test() {\n    assert(add({4, 2, 6, 7}) == 2);  // Only 2 is at an odd index and is even\n    assert(add({1, 3, 5, 7, 9}) == 0);  // No elements are even at odd indices\n    assert(add({2, 4, 6, 8, 10}) == 4);  // Only 4 is at an odd index and is even\n    cout << \"All test cases passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/86", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\n// Function to reverse a substring in place\nvoid reverseString(string &s, int start, int end) {\n    while (start < end) {\n        swap(s[start], s[end]);\n        start++;\n        end--;\n    }\n}\n\n// Function to sort each word in the string based on ASCII values\nstring anti_shuffle(string s) {\n    // Remove leading and trailing spaces\n    s.erase(0, s.find_first_not_of(' '));\n    s.erase(s.find_last_not_of(' ') + 1);\n\n    int start = 0;\n    for (int i = 0; i <= s.length(); ++i) {\n        if (s[i] == ' ' || i == s.length()) {\n            // Sort the word\n            sort(s.begin() + start, s.begin() + i);\n            start = i + 1;\n        }\n    }\n\n    return s;\n}\n\n"}
{"task_id": "CPP/87", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Function to get the row and column index for each occurrence of x\nvoid findCoordinates(vector<vector<int>>& lst, int x, vector<pair<int, int>>& coords) {\n    for (int i = 0; i < lst.size(); ++i) {\n        for (int j = 0; j < lst[i].size(); ++j) {\n            if (lst[i][j] == x) {\n                coords.push_back({i, j});\n            }\n        }\n    }\n}\n\n// Function to sort the coordinates by row in ascending order and then by column in descending order\nvoid sortCoordinates(vector<pair<int, int>>& coords) {\n    // First, sort by row in ascending order\n    sort(coords.begin(), coords.end());\n\n    // Then, for each unique row, sort columns in descending order\n    for (int i = 0; i < coords.size(); ++i) {\n        if (i == 0 || coords[i].first != coords[i - 1].first) {\n            int start = i;\n            while (i + 1 < coords.size() && coords[i + 1].first == coords[i].first) {\n                ++i;\n            }\n            sort(coords.begin() + start, coords.begin() + i + 1, [](const pair<int, int>& a, const pair<int, int>& b) {\n                return a.second > b.second; // Descending order by column\n            });\n        }\n    }\n}\n\nvector<vector<int>> get_row(vector<vector<int>> lst, int x) {\n    vector<pair<int, int>> coords;\n    findCoordinates(lst, x, coords);\n    sortCoordinates(coords);\n\n    // Convert the coordinates to the required format\n    vector<vector<int>> result;\n    for (const auto& coord : coords) {\n        result.push_back({coord.first, coord.second});\n    }\n    return result;\n}\n\n// Function to print the 2D vector for testing purposes\nvoid printVector(const vector<vector<int>>& vec) {\n    for (const auto& row : vec) {\n        for (int val : row) {\n            cout << val << \" \";\n        }\n        cout << endl;\n    }\n}\n\n"}
{"task_id": "CPP/88", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> sort_array(vector<int> array) {\n    // Check if the input vector is empty or has only one element\n    if (array.empty() || array.size() == 1) {\n        return array;\n    }\n\n    int first = array.front();\n    int last = array.back();\n\n    // Determine sorting order based on the sum of the first and last elements\n    bool ascending = (first + last) % 2 != 0;\n\n    vector<int> sorted_array(array); // Create a copy to avoid modifying the original vector\n\n    if (ascending) {\n        sort(sorted_array.begin(), sorted_array.end());\n    } else {\n        sort(sorted_array.rbegin(), sorted_array.rend());\n    }\n\n    return sorted_array;\n}\n\n// Function to test the implementation\nvoid test_sort_array() {\n    assert(sort_array({}) == vector<int>());\n    assert(sort_array({5}) == vector<int>({5}));\n    assert(sort_array({2, 4, 3, 0, 1, 5}) == vector<int>({0, 1, 2, 3, 4, 5}));\n    assert(sort_array({2, 4, 3, 0, 1, 5, 6}) == vector<int>({6, 5, 4, 3, 2, 1, 0}));\n\n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/89", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\n// Function to encrypt a string by rotating each letter down by 4 places in the alphabet.\nstring encrypt(string s) {\n    for (char &c : s) {\n        if (isalpha(c)) { // Check if the character is an alphabet letter\n            char base = islower(c) ? 'a' : 'A'; // Determine the base character ('a' or 'A')\n            c = base + (c - base + 4) % 26; // Rotate the character by 4 places and wrap around if necessary\n        }\n    }\n    return s;\n}\n\n"}
{"task_id": "CPP/90", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <optional>\n\nusing namespace std;\n\n// Function to find the second smallest element in a vector of integers.\noptional<int> next_smallest(vector<int> lst) {\n    if (lst.empty()) return std::nullopt; // Return None if the list is empty\n\n    // Remove duplicates by sorting and then using unique\n    sort(lst.begin(), lst.end());\n    auto last = unique(lst.begin(), lst.end());\n\n    // If there are less than 2 unique elements, return None\n    if (last == lst.begin() + 1) return std::nullopt;\n\n    // Return the second smallest element\n    return *(lst.begin() + 1);\n}\n\n// Function to test the next_smallest function with provided data points.\nvoid check() {\n    assert(next_smallest({1, 2, 3, 4, 5}) == 2);\n    assert(next_smallest({5, 1, 4, 3, 2}) == 2);\n    assert(next_smallest({}) == std::nullopt);\n    assert(next_smallest({1, 1}) == std::nullopt);\n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/91", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nint is_bored(string S) {\n    int count = 0;\n    \n    // Use a stringstream to split the string into sentences based on delimiters\n    stringstream ss(S);\n    string sentence;\n    \n    while (getline(ss, sentence, '.')) {\n        if (!sentence.empty()) {\n            getline(ss, sentence, '?');\n            if (!sentence.empty()) {\n                getline(ss, sentence, '!');\n                if (!sentence.empty() && sentence.substr(0, 1) == \"I\") {\n                    count++;\n                }\n            } else {\n                // Handle the case where there's no '?' or '!'\n                if (sentence.substr(0, 1) == \"I\") {\n                    count++;\n                }\n            }\n        }\n    }\n    \n    return count;\n}\n\n"}
{"task_id": "CPP/92", "generation": "#include <iostream>\nusing namespace std;\n\nbool any_int(float a, float b, float c) {\n    // Convert floats to integers by truncating the decimal part.\n    int ia = static_cast<int>(a);\n    int ib = static_cast<int>(b);\n    int ic = static_cast<int>(c);\n\n    // Check if all numbers are integers\n    bool is_integer_a = (a - ia == 0.0f);\n    bool is_integer_b = (b - ib == 0.0f);\n    bool is_integer_c = (c - ic == 0.0f);\n\n    // If any number is not an integer, return false.\n    if (!is_integer_a || !is_integer_b || !is_integer_c) {\n        return false;\n    }\n\n    // Check if one of the numbers is equal to the sum of the other two\n    return (ia == ib + ic) || (ib == ia + ic) || (ic == ia + ib);\n}\n\n"}
{"task_id": "CPP/93", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to encode a message by swapping cases and replacing vowels\nstring encode(string message) {\n    // Define vowels for easy replacement\n    string vowels = \"aeiouAEIOU\";\n    \n    // Loop through each character in the message\n    for (char &c : message) {\n        if (isalpha(c)) {  // Check if it's a letter\n            // Swap case\n            c = islower(c) ? toupper(c) : tolower(c);\n            \n            // Replace vowels with the corresponding letter 2 places ahead\n            if (vowels.find(c) != string::npos) {\n                int index = vowels.find(c);\n                char nextVowel = vowels[(index + 2) % vowels.size()];\n                c = nextVowel;\n            }\n        }\n    }\n    \n    return message;\n}\n\n"}
{"task_id": "CPP/94", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Function to check if a number is prime\nbool isPrime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\n// Function to calculate the sum of digits of a number\nint sumOfDigits(int num) {\n    int sum = 0;\n    while (num > 0) {\n        sum += num % 10;\n        num /= 10;\n    }\n    return sum;\n}\n\n// Main function to find the largest prime and its digit sum\nint findLargestPrimeSum(vector<int> lst) {\n    int maxPrime = -1; // Initialize with a non-prime number\n\n    for (int num : lst) {\n        if (isPrime(num)) {\n            if (num > maxPrime) {\n                maxPrime = num;\n            }\n        }\n    }\n\n    return maxPrime == -1 ? 0 : sumOfDigits(maxPrime);\n}\n\n// Function to test the solution\nvoid test() {\n    vector<int> lst1 = {0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3};\n    cout << findLargestPrimeSum(lst1) << endl; // Output: 10\n\n    vector<int> lst2 = {1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1};\n    cout << findLargestPrimeSum(lst2) << endl; // Output: 25\n\n    vector<int> lst3 = {1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3};\n    cout << findLargestPrimeSum(lst3) << endl; // Output: 13\n\n    vector<int> lst4 = {0,724,32,71,99,32,6,0,5,91,83,0,5,6};\n    cout << findLargestPrimeSum(lst4) << endl; // Output: 11\n\n    vector<int> lst5 = {0,81,12,3,1,21};\n    cout << findLargestPrimeSum(lst5) << endl; // Output: 3\n\n    vector<int> lst6 = {0,8,1,2,1,7};\n    cout << findLargestPrimeSum(lst6) << endl; // Output: 7\n}\n\n"}
{"task_id": "CPP/95", "generation": "#include <iostream>\n#include <string>\n#include <map>\n\nusing namespace std;\n\nbool check_dict_case(map<string, string> dict) {\n    // Check if the map is empty\n    if (dict.empty()) {\n        return false;\n    }\n\n    bool allLower = true;\n    bool allUpper = true;\n\n    // Determine the case of the first key\n    for (const auto &pair : dict) {\n        if (!islower(pair.first[0])) {\n            allLower = false;\n        }\n        if (!isupper(pair.first[0])) {\n            allUpper = false;\n        }\n\n        // If both cases are mixed, return false immediately\n        if (!allLower && !allUpper) {\n            return false;\n        }\n    }\n\n    // Return true only if all keys are in the same case\n    return allLower || allUpper;\n}\n\n"}
{"task_id": "CPP/96", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// Helper function to check if a number is prime\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    for (int i = 2; i * i <= num; ++i) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\n// Function to generate a vector of prime numbers less than n\nvector<int> count_up_to(int n) {\n    vector<int> primes;\n    for (int i = 2; i < n; ++i) {\n        if (is_prime(i)) {\n            primes.push_back(i);\n        }\n    }\n    return primes;\n}\n\n// Function to test the count_up_to function\nvoid test_count_up_to() {\n    assert(count_up_to(5) == vector<int>({2, 3}));\n    assert(count_up_to(11) == vector<int>({2, 3, 5, 7}));\n    assert(count_up_to(0).empty());\n    assert(count_up_to(20) == vector<int>({2, 3, 5, 7, 11, 13, 17, 19}));\n    assert(count_up_to(1).empty());\n    assert(count_up_to(18) == vector<int>({2, 3, 5, 7, 11, 13, 17}));\n\n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/97", "generation": "#include <stdio.h>\nusing namespace std;\n\nint multiply(int a, int b) {\n    // Extract the unit digits of both numbers\n    int unitDigitA = abs(a % 10);\n    int unitDigitB = abs(b % 10);\n\n    // Return the product of the unit digits\n    return unitDigitA * unitDigitB;\n}\n\n"}
{"task_id": "CPP/98", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint count_upper(const string& s) {\n    int count = 0;\n    for (size_t i = 0; i < s.length(); i += 2) { // Iterate through even indices\n        if (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U') {\n            count++;\n        }\n    }\n    return count;\n}\n\n"}
{"task_id": "CPP/99", "generation": "#include <iostream>\n#include <cmath>\n#include <string>\n\nint closest_integer(const std::string& value) {\n    // Convert the string to a floating-point number\n    double num = std::stod(value);\n    \n    // Determine the nearest integers\n    int lower_int = static_cast<int>(std::floor(num));\n    int upper_int = static_cast<int>(std::ceil(num));\n    \n    // Check if they are equidistant from the original number\n    if (num - lower_int == upper_int - num) {\n        // If equidistant, round away from zero\n        return std::abs(num) > 0 ? upper_int : lower_int;\n    } else {\n        // Otherwise, choose the nearest one\n        return (num - lower_int < upper_int - num) ? lower_int : upper_int;\n    }\n}\n\n// Function to test the closest_integer function with some examples\nvoid check_function() {\n    std::cout << \"closest_integer(\\\"10\\\") = \" << closest_integer(\"10\") << std::endl;  // Should be 10\n    std::cout << \"closest_integer(\\\"15.3\\\") = \" << closest_integer(\"15.3\") << std::endl;  // Should be 15\n    std::cout << \"closest_integer(\\\"14.5\\\") = \" << closest_integer(\"14.5\") << std::endl;  // Should be 15\n    std::cout << \"closest_integer(\\\"-14.5\\\") = \" << closest_integer(\"-14.5\") << std::endl;  // Should be -15\n}\n\n"}
{"task_id": "CPP/100", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Function to determine the number of stones in each level\nvector<int> make_a_pile(int n) {\n    vector<int> pile;\n    \n    for (int i = 1; i <= n; ++i) {\n        // If i is odd, add the next odd number after n\n        if (i % 2 != 0) {\n            int stones = n + (n % 2 == 0 ? 1 : 2);\n            pile.push_back(stones);\n        } \n        // If i is even, add the next even number after n\n        else {\n            int stones = n + (n % 2 == 0 ? 2 : 1);\n            pile.push_back(stones);\n        }\n    }\n    \n    return pile;\n}\n\n// Function to print the vector for testing purposes\nvoid print_pile(const vector<int>& pile) {\n    cout << \"{\";\n    for (size_t i = 0; i < pile.size(); ++i) {\n        cout << pile[i];\n        if (i != pile.size() - 1) {\n            cout << \", \";\n        }\n    }\n    cout << \"}\" << endl;\n}\n\n"}
{"task_id": "CPP/101", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nvector<string> words_string(string s) {\n    vector<string> result;\n    stringstream ss(s);\n    string word;\n\n    while (getline(ss, word, ',')) { // Split by comma first\n        stringstream wordStream(word); // Create a new stringstream for the current word\n        while (wordStream >> word) {   // Extract words from the current word stream\n            if (!word.empty()) {\n                result.push_back(word);\n            }\n        }\n    }\n\n    return result;\n}\n\n// Function to test the words_string function\nvoid check() {\n    vector<string> expected1 = {\"Hi\", \"my\", \"name\", \"is\", \"John\"};\n    vector<string> result1 = words_string(\"Hi, my name is John\");\n    assert(expected1 == result1);\n\n    vector<string> expected2 = {\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"};\n    vector<string> result2 = words_string(\"One, two, three, four, five, six\");\n    assert(expected2 == result2);\n\n    printf(\"All tests passed!\\n\");\n}\n\n"}
{"task_id": "CPP/102", "generation": "#include <iostream>\nusing namespace std;\n\nint choose_num(int x, int y) {\n    // Check if the upper bound is less than the lower bound\n    if (y < x) {\n        return -1;\n    }\n\n    // Start from the upper bound and go downwards to find the largest even number\n    for (int i = y; i >= x; --i) {\n        if (i % 2 == 0) {\n            return i;\n        }\n    }\n\n    // If no even number is found, return -1\n    return -1;\n}\n\n// Function to test the choose_num function with some examples\nvoid test() {\n    cout << \"choose_num(12, 15): \" << choose_num(12, 15) << endl; // Should output 14\n    cout << \"choose_num(13, 12): \" << choose_num(13, 12) << endl; // Should output -1\n    cout << \"choose_num(8, 10): \" << choose_num(8, 10) << endl;   // Should output 10\n    cout << \"choose_num(9, 7): \" << choose_num(9, 7) << endl;     // Should output -1\n}\n\n"}
{"task_id": "CPP/103", "generation": "#include <stdio.h>\n#include <math.h>\n#include <string>\nusing namespace std;\n\nstring rounded_avg(int n, int m) {\n    // Check if n > m\n    if (n > m) {\n        return \"-1\";\n    }\n\n    // Calculate the sum of integers from n to m\n    long long sum = 0;\n    for (int i = n; i <= m; ++i) {\n        sum += i;\n    }\n\n    // Number of terms in the range [n, m]\n    int num_terms = m - n + 1;\n\n    // Calculate the average and round down\n    double avg = floor((double)sum / num_terms);\n\n    // Convert the rounded integer to binary string\n    string result = \"0b\";\n    while (avg > 0) {\n        if (avg % 2 == 1) {\n            result += '1';\n        } else {\n            result += '0';\n        }\n        avg /= 2;\n    }\n\n    // Reverse the string to get correct binary representation\n    reverse(result.begin(), result.end());\n\n    return result;\n}\n\n"}
{"task_id": "CPP/104", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n// Helper function to check if a number has any even digit\nbool has_even_digit(int num) {\n    while (num > 0) {\n        int digit = num % 10;\n        if (digit % 2 == 0) return true; // If any digit is even, return true\n        num /= 10;\n    }\n    return false; // No even digits found\n}\n\n// Function to return a sorted vector of all elements that have no even digit\nvector<int> unique_digits(vector<int> x) {\n    vector<int> result;\n\n    // Filter out numbers with any even digit\n    for (int num : x) {\n        if (!has_even_digit(num)) {\n            result.push_back(num);\n        }\n    }\n\n    // Sort the resulting vector in increasing order\n    sort(result.begin(), result.end());\n\n    return result;\n}\n\n// Function to print a vector of integers\nvoid print_vector(const vector<int>& vec) {\n    for (int num : vec) {\n        cout << num << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/105", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to replace digits by their names\nvector<string> by_length(vector<int> arr) {\n    // Map to store digit names\n    map<int, string> digit_names = {\n        {1, \"One\"}, {2, \"Two\"}, {3, \"Three\"},\n        {4, \"Four\"}, {5, \"Five\"}, {6, \"Six\"},\n        {7, \"Seven\"}, {8, \"Eight\"}, {9, \"Nine\"}\n    };\n\n    // Step 1: Filter out numbers that are not between 1 and 9 inclusive\n    vector<int> filtered_arr;\n    for (int num : arr) {\n        if (num >= 1 && num <= 9) {\n            filtered_arr.push_back(num);\n        }\n    }\n\n    // Step 2: Sort the remaining numbers\n    sort(filtered_arr.begin(), filtered_arr.end());\n\n    // Step 3: Reverse the sorted vector\n    reverse(filtered_arr.begin(), filtered_arr.end());\n\n    // Step 4: Replace each digit by its corresponding name\n    vector<string> result;\n    for (int num : filtered_arr) {\n        result.push_back(digit_names[num]);\n    }\n\n    return result;\n}\n\n// Function to print the result\nvoid print_result(const vector<string>& result) {\n    if (result.empty()) {\n        cout << \"{}\" << endl;\n    } else {\n        cout << \"{\";\n        for (size_t i = 0; i < result.size(); ++i) {\n            cout << result[i];\n            if (i != result.size() - 1) {\n                cout << \", \";\n            }\n        }\n        cout << \"}\" << endl;\n    }\n}\n\n"}
{"task_id": "CPP/106", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Function to calculate factorial of a number\nint factorial(int num) {\n    if (num == 0 || num == 1)\n        return 1;\n    int fact = 1;\n    for (int i = 2; i <= num; ++i) {\n        fact *= i;\n    }\n    return fact;\n}\n\n// Function to calculate sum of numbers from 1 to a number\nint sum(int num) {\n    return (num * (num + 1)) / 2;\n}\n\nvector<int> f(int n) {\n    vector<int> result(n);\n    \n    for (int i = 0; i < n; ++i) {\n        int index = i + 1; // Since i starts from 1\n        if ((index % 2) == 0) { // Check if the index is even\n            result[i] = factorial(index);\n        } else { // If the index is odd\n            result[i] = sum(index);\n        }\n    }\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/107", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nbool is_palindrome(int num) {\n    string str = to_string(num);\n    int len = str.length();\n    for (int i = 0; i < len / 2; ++i) {\n        if (str[i] != str[len - i - 1]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nvector<int> even_odd_palindrome(int n) {\n    int even_count = 0, odd_count = 0;\n\n    // Single digit palindromes\n    for (int i = 1; i <= n; ++i) {\n        if (is_palindrome(i)) {\n            if (i % 2 == 0) {\n                even_count++;\n            } else {\n                odd_count++;\n            }\n        }\n    }\n\n    // Multi-digit palindromes\n    for (int len = 2; len <= to_string(n).length(); ++len) {\n        generate_palindromes(len, n, even_count, odd_count);\n    }\n\n    return {even_count, odd_count};\n}\n\nvoid generate_palindromes(int length, int max_val, int& even_count, int& odd_count) {\n    if (length % 2 == 0) {\n        for (int i = 1; i <= 9; ++i) {\n            string prefix = to_string(i);\n            string suffix = prefix;\n            for (int j = 0; j < length / 2 - 1; ++j) {\n                suffix += '0';\n            }\n            int num = stoi(prefix + suffix);\n            if (num > max_val) break;\n            if (num % 2 == 0) even_count++;\n            else odd_count++;\n        }\n    } else {\n        for (int i = 1; i <= 9; ++i) {\n            string prefix = to_string(i);\n            string suffix = prefix;\n            for (int j = 0; j < length / 2; ++j) {\n                suffix += '0';\n            }\n            int num = stoi(prefix + suffix);\n            if (num > max_val) break;\n            if (num % 2 == 0) even_count++;\n            else odd_count++;\n        }\n    }\n}\n\n"}
{"task_id": "CPP/108", "generation": "#include <iostream>\n#include <vector>\n\n// Function to calculate the sum of digits of an integer, considering its sign.\nint sum_of_digits(int num) {\n    int sum = 0;\n    bool isNegative = num < 0;\n\n    // Handle negative numbers by making them positive and then adjusting the first digit\n    if (isNegative) {\n        num = -num; // Make number positive for processing digits\n        sum -= num % 10; // Subtract the last digit which will be negative\n        num /= 10;\n    }\n\n    while (num > 0) {\n        sum += num % 10;\n        num /= 10;\n    }\n\n    return sum;\n}\n\n// Function to count numbers with a positive sum of digits.\nint count_nums(const std::vector<int>& n) {\n    int count = 0;\n\n    for (const auto& num : n) {\n        if (sum_of_digits(num) > 0) {\n            ++count;\n        }\n    }\n\n    return count;\n}\n\n// Function to test the count_nums function with provided data points.\nvoid test() {\n    assert(count_nums({}) == 0);\n    assert(count_nums({-1, 11, -11}) == 1);\n    assert(count_nums({1, 1, 2}) == 3);\n\n    std::cout << \"All tests passed successfully.\" << std::endl;\n}\n\n"}
{"task_id": "CPP/109", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool move_one_ball(vector<int> arr) {\n    // If the vector is empty, return true\n    if (arr.empty()) {\n        return true;\n    }\n\n    int n = arr.size();\n    int shiftCount = 0;\n\n    // Find the number of shifts needed to make the array sorted\n    for (int i = 1; i < n; ++i) {\n        if (arr[i - 1] > arr[i]) {\n            shiftCount++;\n            if (shiftCount > 1) {\n                return false; // More than one shift is not possible\n            }\n        }\n    }\n\n    // Check the last and first element to ensure a single shift can sort it\n    if (shiftCount == 0 && arr[n - 1] > arr[0]) {\n        return false;\n    }\n\n    return true;\n}\n\n// Function to test the move_one_ball function with provided examples\nvoid test() {\n    vector<int> arr1 = {3, 4, 5, 1, 2};\n    vector<int> arr2 = {3, 5, 4, 1, 2};\n\n    cout << (move_one_ball(arr1) ? \"true\" : \"false\") << endl; // Output: true\n    cout << (move_one_ball(arr2) ? \"true\" : \"false\") << endl; // Output: false\n}\n\n"}
{"task_id": "CPP/110", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring exchange(vector<int> lst1, vector<int> lst2) {\n    // Count the number of odd elements in lst1\n    int oddCount = 0;\n    for (int num : lst1) {\n        if (num % 2 != 0) {\n            oddCount++;\n        }\n    }\n\n    // If there are no odd numbers, return \"YES\"\n    if (oddCount == 0) {\n        return \"YES\";\n    }\n\n    // Count the number of even elements in lst2\n    int evenCount = 0;\n    for (int num : lst2) {\n        if (num % 2 == 0) {\n            evenCount++;\n        }\n    }\n\n    // If there are enough even numbers in lst2 to replace all odd numbers in lst1, return \"YES\"\n    if (evenCount >= oddCount) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n\n// Function to test the exchange function\nvoid testExchange() {\n    cout << exchange({1, 2, 3, 4}, {1, 2, 3, 4}) << endl; // Should output \"YES\"\n    cout << exchange({1, 2, 3, 4}, {1, 5, 3, 4}) << endl; // Should output \"NO\"\n}\n\n"}
{"task_id": "CPP/111", "generation": "#include <iostream>\n#include <string>\n#include <map>\n#include <vector>\nusing namespace std;\n\n// Function to find the maximum occurrence of any character\nint maxOccurrence(const map<char, int>& countMap) {\n    if (countMap.empty()) return 0;\n    return (*max_element(countMap.begin(), countMap.end(),\n                         [](const pair<char, int>& a, const pair<char, int>& b) {\n                             return a.second < b.second;\n                         }))->second;\n}\n\n// Function to generate the histogram\nmap<char, int> histogram(string test) {\n    map<char, int> countMap;\n\n    // Count occurrences of each character\n    for (char c : test) {\n        if (c != ' ') {  // Ignore spaces\n            countMap[c]++;\n        }\n    }\n\n    // Find the maximum occurrence\n    int maxCount = maxOccurrence(countMap);\n\n    // Create a result map with characters that have the maximum occurrence\n    map<char, int> result;\n    for (const auto& pair : countMap) {\n        if (pair.second == maxCount) {\n            result.insert(pair);\n        }\n    }\n\n    return result;\n}\n\n// Function to test the histogram function\nvoid testHistogram() {\n    cout << \"Testing histogram...\" << endl;\n    map<char, int> result;\n\n    // Test cases\n    result = histogram(\"a b c\");\n    for (const auto& pair : result) {\n        cout << \"{\" << pair.first << \", \" << pair.second << \"} \";\n    }\n    cout << endl;\n\n    result = histogram(\"a b b a\");\n    for (const auto& pair : result) {\n        cout << \"{\" << pair.first << \", \" << pair.second << \"} \";\n    }\n    cout << endl;\n\n    result = histogram(\"a b c a b\");\n    for (const auto& pair : result) {\n        cout << \"{\" << pair.first << \", \" << pair.second << \"} \";\n    }\n    cout << endl;\n\n    result = histogram(\"b b b b a\");\n    for (const auto& pair : result) {\n        cout << \"{\" << pair.first << \", \" << pair.second << \"} \";\n    }\n    cout << endl;\n\n    result = histogram(\"\");\n    for (const auto& pair : result) {\n        cout << \"{\" << pair.first << \", \" << pair.second << \"} \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/112", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nbool is_palindrome(const string& str) {\n    int left = 0;\n    int right = str.size() - 1;\n    \n    while (left < right) {\n        if (str[left] != str[right]) {\n            return false;\n        }\n        ++left;\n        --right;\n    }\n    \n    return true;\n}\n\nvector<string> reverse_delete(string s, string c) {\n    // Remove characters in s that are present in c\n    for (char ch : c) {\n        s.erase(remove(s.begin(), s.end(), ch), s.end());\n    }\n\n    // Check if the resulting string is a palindrome\n    bool result = is_palindrome(s);\n    \n    // Return the modified string and the boolean result\n    return {s, to_string(result)};\n}\n\n"}
{"task_id": "CPP/113", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<string> odd_count(vector<string> lst) {\n    vector<string> result;\n    \n    for (const auto& str : lst) {\n        int count = 0;\n        \n        // Count the number of odd digits in the current string\n        for (char c : str) {\n            if ((c - '0') % 2 != 0) {\n                count++;\n            }\n        }\n        \n        // Construct the result string\n        string output = \"the number of odd elements \";\n        output += to_string(count);\n        output += \"n the str\";\n        output += to_string(count);\n        output += \"ng \";\n        output += to_string(count);\n        output += \" of the \";\n        output += to_string(count);\n        output += \"nput.\";\n        \n        result.push_back(output);\n    }\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/114", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nlong long minSubArraySum(vector<long long> nums) {\n    if (nums.empty()) return 0; // Handle empty vector case\n\n    long long current_sum = nums[0];\n    long long min_sum = nums[0];\n\n    for (size_t i = 1; i < nums.size(); ++i) {\n        // Update the current sum to be either the current element or the current element plus the previous current sum\n        current_sum = min(nums[i], current_sum + nums[i]);\n        \n        // Update the minimum sum found so far\n        min_sum = min(min_sum, current_sum);\n    }\n\n    return min_sum;\n}\n\n"}
{"task_id": "CPP/115", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint max_fill(vector<vector<int>> grid, int capacity) {\n    int total_drops = 0;\n    \n    // Iterate through each row (well)\n    for (const auto& well : grid) {\n        int water_units = 0;\n        \n        // Count the number of units of water in the current well\n        for (int unit : well) {\n            if (unit == 1) {\n                ++water_units;\n            }\n        }\n        \n        // Calculate the number of drops needed to empty the well\n        total_drops += (water_units + capacity - 1) / capacity;\n    }\n    \n    return total_drops;\n}\n\n"}
{"task_id": "CPP/116", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\n// Function to count the number of 1s in the binary representation of a number\nint count_ones(int n) {\n    int count = 0;\n    while (n > 0) {\n        count += n & 1; // Check if the least significant bit is set\n        n >>= 1; // Right shift to check the next bit\n    }\n    return count;\n}\n\n// Custom comparator function\nbool custom_comparator(int a, int b) {\n    int ones_a = count_ones(a);\n    int ones_b = count_ones(b);\n\n    if (ones_a == ones_b) {\n        return a < b; // If the number of 1s is the same, sort by decimal value\n    }\n    return ones_a < ones_b; // Otherwise, sort by the number of 1s in binary representation\n}\n\n// Function to sort the array based on the custom comparator\nstd::vector<int> sort_array(std::vector<int> arr) {\n    std::sort(arr.begin(), arr.end(), custom_comparator);\n    return arr;\n}\n\n"}
{"task_id": "CPP/117", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\n// Helper function to check if a character is a consonant\nbool is_consonant(char c) {\n    return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z');\n}\n\n// Helper function to count the number of consonants in a word\nint count_consonants(const string& word) {\n    int count = 0;\n    for (char c : word) {\n        if (is_consonant(c)) {\n            ++count;\n        }\n    }\n    return count;\n}\n\nvector<string> select_words(string s, int n) {\n    vector<string> result;\n    // Split the string into words\n    size_t start = 0;\n    size_t end = s.find(' ');\n    \n    while (end != string::npos) {\n        string word = s.substr(start, end - start);\n        if (count_consonants(word) == n) {\n            result.push_back(word);\n        }\n        start = end + 1;\n        end = s.find(' ', start);\n    }\n\n    // Check the last segment\n    string last_word = s.substr(start);\n    if (!last_word.empty() && count_consonants(last_word) == n) {\n        result.push_back(last_word);\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/118", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_vowel(char c) {\n    return tolower(c) == 'a' || tolower(c) == 'e' || tolower(c) == 'i' || tolower(c) == 'o' || tolower(c) == 'u';\n}\n\nbool is_consonant(char c) {\n    return !is_vowel(c) && isalpha(c);\n}\n\nstring get_closest_vowel(string word) {\n    int n = word.length();\n    \n    // Iterate from the second last character to the first\n    for (int i = n - 2; i >= 0; --i) {\n        if (is_consonant(word[i]) && is_consonant(word[i + 1])) {\n            // Check if the current character is a vowel and between two consonants\n            if (is_vowel(word[i])) {\n                return string(1, word[i]);\n            }\n        }\n    }\n\n    // If no such vowel is found, return an empty string\n    return \"\";\n}\n\n"}
{"task_id": "CPP/119", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Helper function to check if a single string is balanced\nbool is_balanced(const string& s) {\n    int balance = 0;\n    for (char c : s) {\n        if (c == '(') {\n            ++balance;\n        } else if (c == ')') {\n            --balance;\n        }\n        if (balance < 0) {\n            return false; // More closing parentheses than opening ones\n        }\n    }\n    return balance == 0; // All parentheses are balanced\n}\n\n// Main function to check if concatenating the two strings in any order results in a good string\nstring match_parens(vector<string> lst) {\n    // Check both possible concatenations\n    string concat1 = lst[0] + lst[1];\n    string concat2 = lst[1] + lst[0];\n\n    // Check if either of the concatenated strings is balanced\n    if (is_balanced(concat1) || is_balanced(concat2)) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\n\n"}
{"task_id": "CPP/120", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n// Function to return the maximum k numbers from the vector arr\nvector<int> maximum(vector<int> arr, int k) {\n    // Sort the array in descending order and then take the first k elements\n    sort(arr.begin(), arr.end(), greater<int>());\n    \n    // Resize the vector to contain only the top k elements\n    if (k < arr.size()) {\n        arr.resize(k);\n    }\n    \n    return arr;\n}\n\n"}
{"task_id": "CPP/121", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Function to calculate the sum of odd elements at even indices\nint solution(vector<int> lst) {\n    int sum = 0;\n    for (size_t i = 0; i < lst.size(); ++i) {\n        // Check if the index is even and the element at that position is odd\n        if (i % 2 == 0 && lst[i] % 2 != 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n\n// Function to test the solution with provided examples\nvoid test_solution() {\n    assert(solution({5, 8, 7, 1}) == 12);\n    assert(solution({3, 3, 3, 3, 3}) == 9);\n    assert(solution({30, 13, 24, 321}) == 0);\n    cout << \"All test cases passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/122", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint add_elements(vector<int> arr, int k) {\n    int sum = 0;\n    \n    // Iterate through the first k elements of the vector\n    for (int i = 0; i < k; ++i) {\n        // Check if the absolute value of the element is less than 100\n        if (abs(arr[i]) < 100) {\n            sum += arr[i];\n        }\n    }\n    \n    return sum;\n}\n\n// Function to test the add_elements function with provided data points\nvoid test_function() {\n    vector<int> arr = {111, 21, 3, 4000, 5, 6, 7, 8, 9};\n    int k = 4;\n    cout << \"Input: \";\n    for (int num : arr) {\n        cout << num << \" \";\n    }\n    cout << \"\\nk = \" << k << endl;\n    cout << \"Output: \" << add_elements(arr, k) << endl;\n\n    // Additional test cases\n    vector<int> arr2 = {10, 99, 88, 77, 66, 55};\n    int k2 = 3;\n    cout << \"\\nInput: \";\n    for (int num : arr2) {\n        cout << num << \" \";\n    }\n    cout << \"\\nk = \" << k2 << endl;\n    cout << \"Output: \" << add_elements(arr2, k2) << endl;\n}\n\n"}
{"task_id": "CPP/123", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n// Function to generate and return the odd numbers in the Collatz sequence of n.\nvector<int> get_odd_collatz(int n) {\n    vector<int> result;\n    \n    // Generate the Collatz sequence until it reaches 1.\n    while (n != 1) {\n        if (n % 2 == 0) {\n            n = n / 2;  // If n is even, divide by 2\n        } else {\n            result.push_back(n);  // If n is odd, add to the result vector and then apply the Collatz rule\n            n = 3 * n + 1;\n        }\n    }\n    \n    // Add the final number 1 to the result vector.\n    result.push_back(1);\n    \n    // Sort the result vector in increasing order.\n    sort(result.begin(), result.end());\n    \n    return result;\n}\n\n// Function to test the get_odd_collatz function with some examples.\nvoid test_get_odd_collatz() {\n    cout << \"Testing get_odd_collatz...\" << endl;\n    vector<int> result1 = get_odd_collatz(5);\n    for (int num : result1) {\n        cout << num << \" \";\n    }\n    cout << endl;\n\n    vector<int> result2 = get_odd_collatz(7);\n    for (int num : result2) {\n        cout << num << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/124", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nbool valid_date(string date) {\n    // Check if the date format is correct (mm-dd-yyyy)\n    string month, day, year;\n    stringstream ss(date);\n    \n    getline(ss, month, '-');\n    getline(ss, day, '-');\n    getline(ss, year, '-');\n\n    if (month.empty() || day.empty() || year.empty()) {\n        return false; // The date is not in the correct format\n    }\n\n    int m = stoi(month), d = stoi(day), y = stoi(year);\n\n    // Check if month is valid (1-12)\n    if (m < 1 || m > 12) {\n        return false;\n    }\n\n    // Check for leap year and validate February days\n    bool is_leap_year = (y % 4 == 0 && y % 100 != 0) || (y % 400 == 0);\n    if (m == 2) {\n        if ((is_leap_year && d > 29) || (!is_leap_year && d > 28)) {\n            return false;\n        }\n    } else if (m == 4 || m == 6 || m == 9 || m == 11) { // April, June, September, November\n        if (d > 30) {\n            return false;\n        }\n    } else { // January, March, May, July, August, October, December\n        if (d > 31) {\n            return false;\n        }\n    }\n\n    return true; // All conditions are satisfied\n}\n\n"}
{"task_id": "CPP/125", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nvector<string> split_words(string txt) {\n    // Check for whitespace separation\n    if (txt.find(' ') != string::npos) {\n        return vector<string>(1, txt);  // Return the entire text as a single element in the vector\n    }\n\n    // Check for comma separation\n    size_t pos = txt.find(',');\n    if (pos != string::npos) {\n        return {txt.substr(0, pos), txt.substr(pos + 1)};\n    }\n\n    // Count lowercase letters with odd order in the alphabet\n    int count = 0;\n    for (char c : txt) {\n        if (islower(c)) {\n            count += (c - 'a') % 2 == 1 ? 1 : 0;\n        }\n    }\n\n    return {to_string(count)};\n}\n\n// Function to test the split_words function\nvoid test_split_words() {\n    vector<string> result;\n\n    // Test case with whitespace separation\n    result = split_words(\"Hello world!\");\n    for (const auto& word : result) {\n        cout << word << endl;\n    }\n\n    // Test case with comma separation\n    result = split_words(\"Hello,world!\");\n    for (const auto& word : result) {\n        cout << word << endl;\n    }\n\n    // Test case with no separators and odd lowercase letters count\n    result = split_words(\"abcdef\");\n    for (const auto& word : result) {\n        cout << word << endl;\n    }\n}\n\n"}
{"task_id": "CPP/126", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nbool is_sorted(vector<int> lst) {\n    // Check if the list is empty or has one element, which is trivially sorted.\n    if (lst.size() <= 1) return true;\n\n    int count = 1; // To keep track of consecutive duplicates\n\n    for (int i = 1; i < lst.size(); ++i) {\n        // Check if the current number is greater than or equal to the previous one\n        if (lst[i] >= lst[i - 1]) {\n            // If it's a duplicate, increment count. If count exceeds 2, return false.\n            if (lst[i] == lst[i - 1]) {\n                ++count;\n                if (count > 2) return false;\n            }\n        } else {\n            // If the current number is less than the previous one, it's not sorted in ascending order\n            return false;\n        }\n    }\n\n    return true;\n}\n\n"}
{"task_id": "CPP/127", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    if (n == 2) return true;\n    if (n % 2 == 0) return false;\n    for (int i = 3; i * i <= n; i += 2) {\n        if (n % i == 0)\n            return false;\n    }\n    return true;\n}\n\n// Function to find the intersection of two intervals\nstring intersection(vector<int> interval1, vector<int> interval2) {\n    int start = max(interval1[0], interval2[0]);\n    int end = min(interval1[1], interval2[1]);\n\n    // Check if there is an intersection\n    if (start > end) return \"NO\";\n\n    // Calculate the length of the intersection\n    int length = end - start + 1;\n\n    // Check if the length is a prime number\n    if (is_prime(length)) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n\n"}
{"task_id": "CPP/128", "generation": "#include <iostream>\n#include <vector>\n\nint prod_signs(const std::vector<int>& arr) {\n    if (arr.empty()) {\n        return -32768;\n    }\n\n    int sum_of_magnitudes = 0;\n    int product_of_signs = 1;\n\n    for (const auto& num : arr) {\n        // Add the magnitude of the number to the sum\n        sum_of_magnitudes += std::abs(num);\n\n        // Multiply the product of signs by the sign of the current number\n        if (num > 0) {\n            product_of_signs *= 1;\n        } else if (num < 0) {\n            product_of_signs *= -1;\n        } else { // num == 0\n            product_of_signs = 0; // If any number is zero, the product of signs will be zero\n            break;\n        }\n    }\n\n    return sum_of_magnitudes * product_of_signs;\n}\n\n"}
{"task_id": "CPP/129", "generation": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <tuple>\n\nusing namespace std;\n\n// Define a structure to hold the state of the path and its value\nstruct PathState {\n    int x, y; // current position in the grid\n    vector<int> values; // values collected so far\n\n    bool operator<(const PathState &other) const {\n        // Compare lexicographically\n        for (int i = 0; i < min(values.size(), other.values.size()); ++i) {\n            if (values[i] != other.values[i]) return values[i] < other.values[i];\n        }\n        return values.size() < other.values.size();\n    }\n};\n\nvector<int> minPath(vector<vector<int>> grid, int k) {\n    int n = grid.size();\n    \n    // Min-heap to store the paths\n    priority_queue<PathState, vector<PathState>, greater<>> pq;\n    \n    // Initialize the heap with all starting positions\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            pq.push({i, j, {grid[i][j]}});\n        }\n    }\n\n    while (!pq.empty()) {\n        PathState current = pq.top();\n        pq.pop();\n\n        // If the path length is k, return it\n        if (current.values.size() == k) {\n            return current.values;\n        }\n\n        // Explore all possible moves (up, down, left, right)\n        int dx[] = {-1, 1, 0, 0};\n        int dy[] = {0, 0, -1, 1};\n\n        for (int dir = 0; dir < 4; ++dir) {\n            int nx = current.x + dx[dir];\n            int ny = current.y + dy[dir];\n\n            // Check if the new position is within bounds\n            if (nx >= 0 && nx < n && ny >= 0 && ny < n) {\n                vector<int> nextValues(current.values);\n                nextValues.push_back(grid[nx][ny]);\n                pq.push({nx, ny, move(nextValues)});\n            }\n        }\n    }\n\n    // This line should never be reached due to the problem constraints\n    return {};\n}\n\n"}
{"task_id": "CPP/130", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Function to calculate the nth number in the Tribonacci sequence\nint tribonacci(int n) {\n    if (n == 0) return 3;\n    else if (n % 2 == 0) return 1 + n / 2;\n    else {\n        // For odd n, we need to compute tri(n-1), tri(n-2), and tri(n+1)\n        int a = tribonacci(n - 1);\n        int b = tribonacci(n - 2);\n        int c = tribonacci(n + 1);\n        return a + b + c;\n    }\n}\n\n// Function to generate the first n + 1 numbers of the Tribonacci sequence\nvector<int> tri(int n) {\n    vector<int> result;\n    for (int i = 0; i <= n; ++i) {\n        result.push_back(tribonacci(i));\n    }\n    return result;\n}\n\n"}
{"task_id": "CPP/131", "generation": "#include <iostream>\nusing namespace std;\n\nint digits(int n) {\n    int product = 1;\n    bool hasOddDigit = false;\n\n    while (n > 0) {\n        int digit = n % 10;\n        if (digit % 2 != 0) { // Check if the digit is odd\n            product *= digit;\n            hasOddDigit = true;\n        }\n        n /= 10; // Remove the last digit\n    }\n\n    return hasOddDigit ? product : 0;\n}\n\n"}
{"task_id": "CPP/132", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_nested(string str) {\n    int balance = 0;\n    bool hasNested = false;\n\n    for (char ch : str) {\n        if (ch == '[') {\n            balance++;\n            // Check if there's a nested bracket before this opening bracket\n            if (balance > 1 && !hasNested) {\n                hasNested = true;\n            }\n        } else if (ch == ']') {\n            balance--;\n            if (balance < 0) {\n                return false; // Unbalanced brackets\n            }\n        }\n    }\n\n    // Check if there was at least one nested bracket and the string is balanced\n    return hasNested && balance == 0;\n}\n\n"}
{"task_id": "CPP/133", "generation": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nint sum_squares(vector<float> lst) {\n    int sum = 0;\n    \n    for (float num : lst) {\n        // Round up to the nearest integer\n        float ceil_num = ceil(num);\n        \n        // Add the square of the rounded number to the sum\n        sum += static_cast<int>(ceil_num * ceil_num);\n    }\n    \n    return sum;\n}\n\n"}
{"task_id": "CPP/134", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool check_if_last_char_is_a_letter(string txt) {\n    // Check if the string is empty\n    if (txt.empty()) return false;\n    \n    // Get the last character of the string\n    char lastChar = txt.back();\n    \n    // If the last character is a space, get the second-to-last character\n    if (lastChar == ' ') {\n        if (!txt.empty() && isalpha(txt[txt.length() - 2])) return true;\n        else return false;\n    }\n    \n    // The last character is not a space, so it's part of a word\n    return false;\n}\n\n"}
{"task_id": "CPP/135", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint can_arrange(vector<int> arr) {\n    int n = arr.size();\n    \n    // Iterate from the second last element to the first element\n    for (int i = n - 2; i >= 0; --i) {\n        if (arr[i] > arr[i + 1]) {\n            return i;\n        }\n    }\n    \n    // If no such element is found, return -1\n    return -1;\n}\n\n// Function to test the can_arrange function with provided examples\nvoid check() {\n    cout << \"can_arrange({1,2,4,3,5}) = \" << can_arrange({1, 2, 4, 3, 5}) << endl; // Should output 3\n    cout << \"can_arrange({1,2,3}) = \" << can_arrange({1, 2, 3}) << endl;          // Should output -1\n}\n\n"}
{"task_id": "CPP/136", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> largest_smallest_integers(vector<int> lst) {\n    int max_negative = INT_MIN; // Initialize to smallest possible integer\n    int min_positive = INT_MAX; // Initialize to largest possible integer\n\n    for (int num : lst) {\n        if (num > 0 && num < min_positive) {\n            min_positive = num;\n        } else if (num < 0 && num > max_negative) {\n            max_negative = num;\n        }\n    }\n\n    // If no positive or negative integers were found, set them to 0\n    if (min_positive == INT_MAX) {\n        min_positive = 0;\n    }\n    if (max_negative == INT_MIN) {\n        max_negative = 0;\n    }\n\n    return {max_negative, min_positive};\n}\n\n// Function to test the implementation with some example cases\nvoid check() {\n    vector<int> result;\n\n    result = largest_smallest_integers({2, 4, 1, 3, 5, 7});\n    cout << \"Test Case 1: {\" << result[0] << \", \" << result[1] << \"}\" << endl; // Should output {0, 1}\n\n    result = largest_smallest_integers({});\n    cout << \"Test Case 2: {\" << result[0] << \", \" << result[1] << \"}\" << endl; // Should output {0, 0}\n\n    result = largest_smallest_integers({0});\n    cout << \"Test Case 3: {\" << result[0] << \", \" << result[1] << \"}\" << endl; // Should output {0, 0}\n}\n\n"}
{"task_id": "CPP/137", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <boost/any.hpp>\n\n// Function to compare two boost::any types and return the larger one in its original type.\nboost::any compare_one(boost::any a, boost::any b) {\n    // Convert both values to strings for comparison\n    std::string strA = boost::any_cast<std::string>(a);\n    std::string strB = boost::any_cast<std::string>(b);\n\n    // Replace comma with dot in the string representations if necessary\n    std::replace(strA.begin(), strA.end(), ',', '.');\n    std::replace(strB.begin(), strB.end(), ',', '.');\n\n    // Convert strings to floats for comparison\n    float numA = std::stof(strA);\n    float numB = std::stof(strB);\n\n    if (numA > numB) {\n        return a;\n    } else if (numB > numA) {\n        return b;\n    } else {\n        return \"None\";\n    }\n}\n\n"}
{"task_id": "CPP/138", "generation": "#include <iostream>\nusing namespace std;\n\nbool is_equal_to_sum_even(int n) {\n    // Check if n is at least 8, since that's the smallest possible sum of 4 positive even numbers.\n    return n >= 8;\n}\n\n"}
{"task_id": "CPP/139", "generation": "#include <iostream>\n\n// Function to calculate factorial of a number\nlong long factorial(long long num) {\n    if (num == 0 || num == 1)\n        return 1;\n    else\n        return num * factorial(num - 1);\n}\n\n// Function to calculate the Brazilian factorial\nlong long special_factorial(int n) {\n    long long result = 1;\n    for (int i = n; i > 0; --i) {\n        result *= factorial(i);\n    }\n    return result;\n}\n\n"}
{"task_id": "CPP/140", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring fix_spaces(string text) {\n    string result = \"\";\n    int space_count = 0;\n    \n    for (size_t i = 0; i <= text.length(); ++i) {\n        if (text[i] == ' ') {\n            space_count++;\n        } else {\n            if (space_count == 1) {\n                result += '_';\n            } else if (space_count > 2) {\n                result += '-';\n            }\n            // Reset the count and add the non-space character\n            space_count = 0;\n            if (i < text.length()) {\n                result += text[i];\n            }\n        }\n    }\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/141", "generation": "#include <iostream>\n#include <string>\n#include <cctype> // for std::isalpha\n\nusing namespace std;\n\nbool hasMoreThanThreeDigits(const string& str) {\n    int digitCount = 0;\n    for (char c : str) {\n        if (isdigit(c)) {\n            digitCount++;\n            if (digitCount > 3) return true;\n        }\n    }\n    return false;\n}\n\nstring file_name_check(string file_name) {\n    // Check if there are more than three digits\n    if (hasMoreThanThreeDigits(file_name)) return \"No\";\n\n    // Find the position of the dot\n    size_t dotPos = file_name.find('.');\n    if (dotPos == string::npos || dotPos == 0 || dotPos == file_name.length() - 1) {\n        return \"No\";\n    }\n\n    // Check if there is exactly one dot and it's not at the start or end of the filename\n    size_t secondDotPos = file_name.find('.', dotPos + 1);\n    if (secondDotPos != string::npos) return \"No\";\n\n    // Extract the parts before and after the dot\n    string namePart = file_name.substr(0, dotPos);\n    string extPart = file_name.substr(dotPos + 1);\n\n    // Check if the name part starts with a letter and is not empty\n    if (namePart.empty() || !std::isalpha(namePart[0])) return \"No\";\n\n    // Check if the extension part is one of the allowed extensions\n    string allowedExtensions[] = {\"txt\", \"exe\", \"dll\"};\n    for (const string& ext : allowedExtensions) {\n        if (ext == extPart) return \"Yes\";\n    }\n\n    return \"No\";\n}\n\n"}
{"task_id": "CPP/142", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint sum_squares(vector<int> lst) {\n    int sum = 0;\n    \n    for (size_t i = 0; i < lst.size(); ++i) {\n        if ((i % 3 == 0 && i != 0) || (i % 4 == 0)) {\n            if (i % 3 == 0 && i % 4 != 0) {\n                // Cube the integer\n                sum += lst[i] * lst[i] * lst[i];\n            } else {\n                // Square the integer\n                sum += lst[i] * lst[i];\n            }\n        } else {\n            // Add the original value if index is not a multiple of 3 or 4\n            sum += lst[i];\n        }\n    }\n\n    return sum;\n}\n\n"}
{"task_id": "CPP/143", "generation": "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\n// Function to split the sentence into words\nvector<string> split_sentence(const string& sentence) {\n    vector<string> words;\n    string word;\n    for (char ch : sentence) {\n        if (ch != ' ') {\n            word += ch;\n        } else {\n            if (!word.empty()) {\n                words.push_back(word);\n                word.clear();\n            }\n        }\n    }\n    if (!word.empty()) {\n        words.push_back(word);\n    }\n    return words;\n}\n\n// Function to get the sentence with only prime length words\nstring words_in_sentence(const string& sentence) {\n    vector<string> words = split_sentence(sentence);\n\n    string result;\n    for (const auto& word : words) {\n        if (is_prime(word.length())) {\n            if (!result.empty()) {\n                result += \" \";\n            }\n            result += word;\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/144", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\n// Function to simplify two fractions and check if their product is a whole number\nbool simplify(string x, string n) {\n    // Helper function to parse fraction from string\n    auto parse_fraction = [](const string& frac) -> pair<int, int> {\n        size_t slash_pos = frac.find('/');\n        int numerator = stoi(frac.substr(0, slash_pos));\n        int denominator = stoi(frac.substr(slash_pos + 1));\n        return {numerator, denominator};\n    };\n\n    // Parse the fractions\n    auto [num_x, den_x] = parse_fraction(x);\n    auto [num_n, den_n] = parse_fraction(n);\n\n    // Multiply numerators and denominators\n    int product_num = num_x * num_n;\n    int product_den = den_x * den_n;\n\n    // Check if the result is a whole number\n    return (product_num % product_den) == 0;\n}\n\n"}
{"task_id": "CPP/145", "generation": "#include <vector>\n#include <algorithm>\n#include <string>\nusing namespace std;\n\n// Helper function to calculate the sum of digits of an integer\nint digitSum(int n) {\n    int sum = 0;\n    bool isNegative = n < 0;\n    while (n != 0) {\n        int d = abs(n % 10);\n        sum += d;\n        n /= 10;\n    }\n    return isNegative ? -sum : sum;\n}\n\n// Comparator function to sort based on digit sum and original index\nbool compare(int a, int b, const vector<int>& nums) {\n    int sumA = digitSum(a);\n    int sumB = digitSum(b);\n    \n    if (sumA == sumB) {\n        return nums.index_of(a) < nums.index_of(b); // Assuming .index_of() is a method to get the original index\n    }\n    return sumA < sumB;\n}\n\nvector<int> order_by_points(vector<int> nums) {\n    vector<int> sortedNums = nums; // Copy of the original vector for sorting\n    \n    // Sort using the custom comparator\n    sort(sortedNums.begin(), sortedNums.end(), [&](int a, int b) {\n        return compare(a, b, nums);\n    });\n    \n    return sortedNums;\n}\n\n// Example usage and check function\nvoid check() {\n    vector<int> test1 = {1, 11, -1, -11, -12};\n    vector<int> expected1 = {-1, -11, 1, -12, 11};\n    assert(order_by_points(test1) == expected1);\n    \n    vector<int> test2 = {};\n    vector<int> expected2 = {};\n    assert(order_by_points(test2) == expected2);\n    \n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/146", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nint specialFilter(vector<int> nums) {\n    int count = 0;\n    \n    for (int num : nums) {\n        // Skip numbers that are not greater than 10\n        if (num <= 10) continue;\n        \n        string strNum = to_string(num);\n        int firstDigit = strNum[0] - '0';\n        int lastDigit = strNum[strNum.length() - 1] - '0';\n        \n        // Check if both the first and last digits are odd\n        if (firstDigit % 2 != 0 && lastDigit % 2 != 0) {\n            count++;\n        }\n    }\n    \n    return count;\n}\n\n"}
{"task_id": "CPP/147", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint get_max_triples(int n) {\n    // Step 1: Generate vector a\n    vector<int> a(n);\n    for (int i = 1; i <= n; ++i) {\n        a[i-1] = i * i - i + 1;\n    }\n\n    int count = 0;\n\n    // Step 2 and 3: Check all possible triples (a_i, a_j, a_k)\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            for (int k = j + 1; k < n; ++k) {\n                if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                    count++;\n                }\n            }\n        }\n    }\n\n    return count;\n}\n\n// Function to test the solution with provided examples\nvoid check_solution() {\n    cout << \"Input: n = 5, Output: \" << get_max_triples(5) << endl; // Expected output: 1\n    cout << \"Input: n = 6, Output: \" << get_max_triples(6) << endl; // Additional test case\n}\n\n"}
{"task_id": "CPP/148", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to return all planets between planet1 and planet2, sorted by proximity to the sun.\nvector<string> bf(string planet1, string planet2) {\n    // Array of planets in order from closest to farthest from the Sun\n    const string planets[] = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n    \n    vector<string> result;\n    int index1, index2;\n\n    // Find indices of planet1 and planet2 in the array\n    for (int i = 0; i < 8; ++i) {\n        if (planets[i] == planet1) index1 = i;\n        if (planets[i] == planet2) index2 = i;\n    }\n\n    // Check if both planets are valid and in the correct order\n    if (index1 == -1 || index2 == -1 || index1 >= index2) {\n        return result;  // Return empty vector if invalid or out of order\n    }\n\n    // Add all planets between planet1 and planet2 to the result vector\n    for (int i = index1 + 1; i < index2; ++i) {\n        result.push_back(planets[i]);\n    }\n\n    return result;\n}\n\n// Function to test the bf function with given examples\nvoid test() {\n    vector<string> result;\n\n    // Test case 1\n    result = bf(\"Jupiter\", \"Neptune\");\n    for (const auto& planet : result) {\n        cout << planet << \" \";\n    }\n    cout << endl;  // Expected output: Saturn Uranus\n\n    // Test case 2\n    result = bf(\"Earth\", \"Mercury\");\n    for (const auto& planet : result) {\n        cout << planet << \" \";\n    }\n    cout << endl;  // Expected output: Venus\n\n    // Test case 3\n    result = bf(\"Mercury\", \"Uranus\");\n    for (const auto& planet : result) {\n        cout << planet << \" \";\n    }\n    cout << endl;  // Expected output: Venus Earth Mars Jupiter Saturn\n}\n\n"}
{"task_id": "CPP/149", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to remove odd-length strings and sort the remaining ones\nvector<string> sorted_list_sum(vector<string> lst) {\n    // Remove strings with odd lengths\n    lst.erase(remove_if(lst.begin(), lst.end(), [](const string& s) { return s.length() % 2 != 0; }), lst.end());\n\n    // Sort by length, then alphabetically if lengths are the same\n    sort(lst.begin(), lst.end(), [](const string& a, const string& b) {\n        if (a.length() == b.length()) {\n            return a < b;\n        }\n        return a.length() < b.length();\n    });\n\n    return lst;\n}\n\n// Function to check the correctness of the sorted_list_sum function\nvoid check_function() {\n    assert(sorted_list_sum({\"aa\", \"a\", \"aaa\"}) == vector<string>{\"aa\"});\n    assert(sorted_list_sum({\"ab\", \"a\", \"aaa\", \"cd\"}) == vector<string>{\"ab\", \"cd\"});\n    cout << \"All test cases passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/150", "generation": "#include<stdio.h>\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int n) {\n    if (n <= 1) return false; // Numbers less than or equal to 1 are not prime\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\n// Function that returns x if n is a prime number, otherwise returns y\nint x_or_y(int n, int x, int y) {\n    return is_prime(n) ? x : y;\n}\n\n"}
{"task_id": "CPP/151", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nlong long double_the_difference(vector<float> lst) {\n    long long sum = 0;\n    \n    for (float num : lst) {\n        // Check if the number is positive, an integer, and odd\n        if (num > 0 && floor(num) == num && static_cast<int>(num) % 2 != 0) {\n            sum += pow(num, 2);\n        }\n    }\n    \n    return sum;\n}\n\n"}
{"task_id": "CPP/152", "generation": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\n// Function to compare the scores and guesses\nvector<int> compare(vector<int> game, vector<int> guess) {\n    vector<int> result;\n    \n    // Iterate through each match\n    for (size_t i = 0; i < game.size(); ++i) {\n        // Calculate the absolute difference between score and guess\n        int diff = abs(game[i] - guess[i]);\n        \n        // Add the difference to the result vector\n        result.push_back(diff);\n    }\n    \n    return result;\n}\n\n// Function to print a vector for testing purposes\nvoid printVector(const vector<int>& vec) {\n    for (int num : vec) {\n        cout << num << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/153", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to calculate the strength of an extension\nint calculate_strength(const string& extension) {\n    int cap = 0, sm = 0;\n    for (char c : extension) {\n        if (isupper(c)) cap++;\n        else if (islower(c)) sm++;\n    }\n    return cap - sm;\n}\n\n// Function to find the strongest extension\nstring Strongest_Extension(string class_name, vector<string> extensions) {\n    int max_strength = INT_MIN;\n    string strongest_extension;\n\n    for (const string& ext : extensions) {\n        int strength = calculate_strength(ext);\n        if (strength > max_strength) {\n            max_strength = strength;\n            strongest_extension = ext;\n        }\n    }\n\n    return class_name + \".\" + strongest_extension;\n}\n\n// Function to test the solution\nvoid test() {\n    cout << Strongest_Extension(\"my_class\", {\"AA\", \"Be\", \"CC\"}) << endl; // Should output: my_class.AA\n    cout << Strongest_Extension(\"Slices\", {\"SErviNGSliCes\", \"Cheese\", \"StuFfed\"}) << endl; // Should output: Slices.SErviNGSliCes\n}\n\n"}
{"task_id": "CPP/154", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\n// Function to rotate a string by one position to the right\nstring rotate_right(string s) {\n    int len = s.length();\n    if (len == 0) return \"\";\n    char last_char = s[len - 1];\n    for (int i = len - 1; i > 0; --i) {\n        s[i] = s[i - 1];\n    }\n    s[0] = last_char;\n    return s;\n}\n\n// Function to check if any rotation of b is a substring of a\nbool cycpattern_check(string a, string b) {\n    // Check if b itself is a substring of a\n    if (a.find(b) != string::npos) {\n        return true;\n    }\n\n    int len_b = b.length();\n    for (int i = 0; i < len_b; ++i) {\n        // Generate the next rotation of b\n        string rotated_b = rotate_right(b);\n        // Check if the current rotation is a substring of a\n        if (a.find(rotated_b) != string::npos) {\n            return true;\n        }\n        b = rotated_b;  // Update b to the next rotation\n    }\n\n    return false;\n}\n\n"}
{"task_id": "CPP/155", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// Function to count even and odd digits in an integer\nvector<int> even_odd_count(int num) {\n    // Convert the number to a string to easily iterate over each digit\n    string str_num = to_string(abs(num));\n    \n    int even_count = 0;\n    int odd_count = 0;\n    \n    for (char digit : str_num) {\n        int digit_value = digit - '0'; // Convert char to int\n        if (digit_value % 2 == 0) {\n            even_count++;\n        } else {\n            odd_count++;\n        }\n    }\n    \n    return {even_count, odd_count};\n}\n\n// Function to test the even_odd_count function with some examples\nvoid test_even_odd_count() {\n    vector<int> result;\n    \n    // Test case 1: -12\n    result = even_odd_count(-12);\n    cout << \"even_odd_count(-12) ==> {\" << result[0] << \", \" << result[1] << \"}\" << endl; // Should output {1, 1}\n    \n    // Test case 2: 123\n    result = even_odd_count(123);\n    cout << \"even_odd_count(123) ==> {\" << result[0] << \", \" << result[1] << \"}\" << endl; // Should output {1, 2}\n    \n    // Test case 3: -456\n    result = even_odd_count(-456);\n    cout << \"even_odd_count(-456) ==> {\" << result[0] << \", \" << result[1] << \"}\" << endl; // Should output {2, 1}\n    \n    // Test case 4: 789\n    result = even_odd_count(789);\n    cout << \"even_odd_count(789) ==> {\" << result[0] << \", \" << result[1] << \"}\" << endl; // Should output {1, 2}\n}\n\n"}
{"task_id": "CPP/156", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\n// Function to convert integer to mini Roman numeral in lowercase\nstring int_to_mini_roman(int number) {\n    // Mapping of integers to their corresponding Roman numerals\n    vector<pair<int, string>> roman_numerals = {\n        {1000, \"m\"}, {900, \"cm\"}, {500, \"d\"}, {400, \"cd\"},\n        {100, \"c\"}, {90, \"xc\"}, {50, \"l\"}, {40, \"xl\"},\n        {10, \"x\"}, {9, \"ix\"}, {5, \"v\"}, {4, \"iv\"}, {1, \"i\"}\n    };\n\n    string result = \"\";\n\n    // Iterate through the mapping and construct the Roman numeral\n    for (const auto& value : roman_numerals) {\n        while (number >= value.first) {\n            result += value.second;\n            number -= value.first;\n        }\n    }\n\n    return result;\n}\n\n// Function to test the int_to_mini_roman function with provided examples\nvoid check() {\n    assert(int_to_mini_roman(19) == \"xix\");\n    assert(int_to_mini_roman(152) == \"clii\");\n    assert(int_to_mini_roman(426) == \"cdxxvi\");\n    cout << \"All test cases passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/157", "generation": "#include <stdio.h>\n#include <math.h>\n\nusing namespace std;\n\nbool right_angle_triangle(float a, float b, float c) {\n    // First, find the longest side (hypotenuse)\n    float max_side = max(a, max(b, c));\n    \n    // Check if the square of the hypotenuse is equal to the sum of squares of other two sides\n    return fabs(max_side * max_side - (a * a + b * b + c * c - 2 * min_side * min_side)) < 1e-6;\n}\n\n// Helper function to find the minimum side among three given sides\nfloat min(float x, float y, float z) {\n    if (x <= y && x <= z)\n        return x;\n    else if (y <= x && y <= z)\n        return y;\n    else\n        return z;\n}\n"}
{"task_id": "CPP/158", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\n// Function to count unique characters in a string\nint count_unique_chars(const string& word) {\n    bool seen[256] = {false}; // Assuming ASCII characters, 0-255 range\n    int unique_count = 0;\n    for (char c : word) {\n        if (!seen[c]) {\n            seen[c] = true;\n            unique_count++;\n        }\n    }\n    return unique_count;\n}\n\n// Function to find the string with maximum number of unique characters\nstring find_max(vector<string> words) {\n    // Sort the vector lexicographically first\n    sort(words.begin(), words.end());\n\n    int max_unique_chars = 0;\n    string result;\n\n    for (const auto& word : words) {\n        int unique_chars = count_unique_chars(word);\n        if (unique_chars > max_unique_chars) {\n            max_unique_chars = unique_chars;\n            result = word;\n        }\n    }\n\n    return result;\n}\n\n// Function to test the find_max function\nvoid test_find_max() {\n    assert(find_max({\"name\", \"of\", \"string\"}) == \"string\");\n    assert(find_max({\"name\", \"enam\", \"game\"}) == \"enam\");\n    assert(find_max({\"aaaaaaa\", \"bb\", \"cc\"}) == \"aaaaaaa\");\n\n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/159", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nvector<int> eat(int number, int need, int remaining) {\n    // Calculate the actual number of carrots to be eaten\n    int to_eat = min(need, remaining);\n    \n    // Update the total number of carrots eaten\n    int total_eaten = number + to_eat;\n    \n    // Update the remaining carrots after eating\n    int left = remaining - to_eat;\n    \n    return {total_eaten, left};\n}\n\n// Function to test the eat function with provided examples\nvoid test() {\n    vector<int> result1 = eat(5, 6, 10);\n    printf(\"eat(5, 6, 10) -> {%d, %d}\\n\", result1[0], result1[1]); // Should print {11, 4}\n    \n    vector<int> result2 = eat(4, 8, 9);\n    printf(\"eat(4, 8, 9) -> {%d, %d}\\n\", result2[0], result2[1]); // Should print {12, 1}\n    \n    vector<int> result3 = eat(1, 10, 10);\n    printf(\"eat(1, 10, 10) -> {%d, %d}\\n\", result3[0], result3[1]); // Should print {11, 0}\n    \n    vector<int> result4 = eat(2, 11, 5);\n    printf(\"eat(2, 11, 5) -> {%d, %d}\\n\", result4[0], result4[1]); // Should print {7, 0}\n}\n\n"}
{"task_id": "CPP/160", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nint do_algebra(vector<string> operatorVec, vector<int> operandVec) {\n    // Initialize the result with the first operand\n    int result = operandVec[0];\n\n    // Iterate through the operators and operands to perform the operations\n    for (size_t i = 0; i < operatorVec.size(); ++i) {\n        if (operatorVec[i] == \"+\") {\n            result += operandVec[i + 1];\n        } else if (operatorVec[i] == \"-\") {\n            result -= operandVec[i + 1];\n        } else if (operatorVec[i] == \"*\") {\n            result *= operandVec[i + 1];\n        } else if (operatorVec[i] == \"//\") {\n            result /= operandVec[i + 1]; // Floor division\n        } else if (operatorVec[i] == \"**\") {\n            result = pow(result, operandVec[i + 1]); // Exponentiation\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/161", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\n// Function to check if a character is a letter\nbool isLetter(char c) {\n    return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z');\n}\n\nstring solve(string s) {\n    bool hasLetters = false;\n    \n    // Check each character in the string\n    for (char &c : s) {\n        if (isLetter(c)) {\n            hasLetters = true;\n            // Reverse case of the letter\n            if (islower(c)) c = toupper(c);\n            else c = tolower(c);\n        }\n    }\n\n    // If no letters were found, reverse the entire string\n    if (!hasLetters) {\n        reverse(s.begin(), s.end());\n    }\n\n    return s;\n}\n\n"}
{"task_id": "CPP/162", "generation": "#include <iostream>\n#include <string>\n#include <openssl/md5.h>\n\n// Function to convert string to MD5 hash\nstd::string string_to_md5(const std::string& text) {\n    unsigned char digest[MD5_DIGEST_LENGTH];\n    \n    // Compute the MD5 hash\n    MD5(reinterpret_cast<const unsigned char*>(text.c_str()), text.length(), digest);\n    \n    // Convert the hash to a hexadecimal string\n    char md5String[33];\n    for (int i = 0; i < MD5_DIGEST_LENGTH; i++) {\n        sprintf(&md5String[i*2], \"%02x\", (unsigned int)digest[i]);\n    }\n    \n    return std::string(md5String);\n}\n\n// Function to check the correctness of the string_to_md5 function\nvoid check_function() {\n    std::string test_text = \"Hello world\";\n    std::string expected_hash = \"3e25960a79dbc69b674cd4ec67a72c62\";\n    \n    std::string result = string_to_md5(test_text);\n    if (result == expected_hash) {\n        std::cout << \"Test passed.\" << std::endl;\n    } else {\n        std::cout << \"Test failed. Expected: \" << expected_hash << \", Got: \" << result << std::endl;\n    }\n}\n\n"}
{"task_id": "CPP/163", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Function to generate even digits between a and b\nvector<int> generate_integers(int a, int b) {\n    vector<int> result;\n    \n    // Ensure a is less than or equal to b for simplicity\n    if (a > b) swap(a, b);\n    \n    // Iterate through the range [a, b]\n    for (int i = a; i <= b; ++i) {\n        // Extract each digit from the current number and check if it's even\n        while (i > 0) {\n            int digit = i % 10;\n            if (digit >= 0 && digit <= 8 && digit % 2 == 0) {\n                result.push_back(digit);\n            }\n            i /= 10; // Move to the next digit\n        }\n    }\n    \n    return result;\n}\n\n// Function to print the vector of even digits\nvoid print_vector(const vector<int>& vec) {\n    for (int num : vec) {\n        cout << num << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/0", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // For std::sort\n\nbool has_close_elements(std::vector<float> numbers, float threshold) {\n    // Sort the vector first\n    std::sort(numbers.begin(), numbers.end());\n\n    // Check adjacent elements to find if any pair is closer than the threshold\n    for (size_t i = 0; i < numbers.size() - 1; ++i) {\n        if (numbers[i + 1] - numbers[i] < threshold) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\n"}
{"task_id": "CPP/1", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> separate_paren_groups(string paren_string) {\n    // Remove spaces from the input string\n    paren_string.erase(remove_if(paren_string.begin(), paren_string.end(), isspace), paren_string.end());\n    \n    vector<string> result;\n    stack<int> indices;\n    \n    for (int i = 0; i < paren_string.length(); ++i) {\n        if (paren_string[i] == '(') {\n            // Push the index of the opening parenthesis onto the stack\n            indices.push(i);\n        } else if (paren_string[i] == ')') {\n            // Pop the top element from the stack when a closing parenthesis is encountered\n            if (!indices.empty()) {\n                indices.pop();\n                \n                // If the stack is empty, we have completed a group\n                if (indices.empty()) {\n                    int start = i - 1;\n                    while (start >= 0 && paren_string[start] == ')') --start; // Find the matching opening parenthesis\n                    result.push_back(paren_string.substr(start + 1, i - start));\n                }\n            }\n        }\n    }\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/2", "generation": "#include <stdio.h>\n#include <math.h>\n\nfloat truncate_number(float number) {\n    float integerPart;\n    modf(number, &integerPart); // modf returns the fractional part and stores the integer part in `integerPart`\n    return number - integerPart; // The result is the decimal part of the number\n}\n\n"}
{"task_id": "CPP/3", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool below_zero(vector<int> operations) {\n    int balance = 0; // Start with zero balance\n\n    for (int op : operations) {\n        balance += op; // Update the balance after each operation\n        if (balance < 0) {\n            return true; // Return true if balance falls below zero\n        }\n    }\n\n    return false; // Return false if balance never goes below zero\n}\n\n// Function to test the below_zero function with provided examples\nvoid check() {\n    vector<int> operations1 = {1, 2, 3};\n    vector<int> operations2 = {1, 2, -4, 5};\n\n    cout << \"Test Case 1: \" << (below_zero(operations1) ? \"true\" : \"false\") << endl;\n    cout << \"Test Case 2: \" << (below_zero(operations2) ? \"true\" : \"false\") << endl;\n}\n\n"}
{"task_id": "CPP/4", "generation": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nfloat mean_absolute_deviation(vector<float> numbers) {\n    // Step 1: Calculate the mean of the dataset\n    float sum = 0.0;\n    for (auto num : numbers) {\n        sum += num;\n    }\n    float mean = sum / numbers.size();\n\n    // Step 2 and 3: Compute the absolute differences and find their average\n    float mad = 0.0;\n    for (auto num : numbers) {\n        mad += abs(num - mean);\n    }\n    mad /= numbers.size();\n\n    return mad;\n}\n\n"}
{"task_id": "CPP/5", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> intersperse(vector<int> numbers, int delimeter) {\n    if (numbers.empty()) return numbers; // Return empty vector if input is empty\n\n    vector<int> result;\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        result.push_back(numbers[i]);\n        if (i != numbers.size() - 1) { // Avoid adding delimiter after the last element\n            result.push_back(delimeter);\n        }\n    }\n\n    return result;\n}\n\n// Function to print vector elements for testing\nvoid printVector(const vector<int>& vec) {\n    for (int num : vec) {\n        cout << num << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/6", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<int> parse_nested_parens(string paren_string) {\n    vector<int> depths;\n    int current_depth = 0, max_depth = 0;\n    \n    for (size_t i = 0; i < paren_string.length(); ++i) {\n        if (paren_string[i] == '(') {\n            current_depth++;\n            max_depth = max(max_depth, current_depth);\n        } else if (paren_string[i] == ')') {\n            current_depth--;\n        }\n        \n        // Check for spaces to determine the end of a group\n        if (paren_string[i] == ' ' && i > 0) {\n            depths.push_back(max_depth);\n            max_depth = 0; // Reset max_depth for the next group\n            current_depth = 0;\n        }\n    }\n\n    // Add the last group's depth to the vector\n    if (current_depth != 0) {\n        depths.push_back(max_depth);\n    }\n\n    return depths;\n}\n\n"}
{"task_id": "CPP/7", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to filter strings containing a given substring\nvector<string> filter_by_substring(vector<string> strings, string substring) {\n    vector<string> filtered_strings;\n    \n    // Iterate through each string in the input vector\n    for (const auto& str : strings) {\n        // Check if the current string contains the given substring\n        if (str.find(substring) != string::npos) {\n            // If it does, add it to the filtered list\n            filtered_strings.push_back(str);\n        }\n    }\n    \n    return filtered_strings;\n}\n\n// Function to test the filter_by_substring function\nvoid test_filter_by_substring() {\n    vector<string> input1 = {};\n    vector<string> expected1 = {};\n    assert(filter_by_substring(input1, \"a\") == expected1);\n\n    vector<string> input2 = {\"abc\", \"bacd\", \"cde\", \"vector\"};\n    vector<string> expected2 = {\"abc\", \"bacd\", \"vector\"};\n    assert(filter_by_substring(input2, \"a\") == expected2);\n\n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/8", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> sum_product(vector<int> numbers) {\n    int sum = 0;\n    int product = 1;\n\n    // Iterate through each number in the vector\n    for (int num : numbers) {\n        sum += num;  // Add the current number to the sum\n        if (num != 0) {  // Avoid division by zero when calculating the product\n            product *= num;\n        }\n    }\n\n    return {sum, product};\n}\n\n// Function to test the sum_product function with provided data points\nvoid test_sum_product() {\n    vector<int> empty = {};\n    vector<int> nums1 = {1, 2, 3, 4};\n\n    // Test case for an empty vector\n    auto result1 = sum_product(empty);\n    cout << \"Empty vector: Sum = \" << result1[0] << \", Product = \" << result1[1] << endl;\n\n    // Test case for a non-empty vector\n    auto result2 = sum_product(nums1);\n    cout << \"Vector {1, 2, 3, 4}: Sum = \" << result2[0] << \", Product = \" << result2[1] << endl;\n}\n\n"}
{"task_id": "CPP/9", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> rolling_max(vector<int> numbers) {\n    if (numbers.empty()) return {}; // Return an empty vector if the input is empty\n\n    vector<int> result;\n    int current_max = numbers[0]; // Initialize with the first element\n\n    for (int num : numbers) {\n        if (num > current_max) {\n            current_max = num; // Update current_max if a larger number is found\n        }\n        result.push_back(current_max); // Add the current max to the result vector\n    }\n\n    return result;\n}\n\n// Function to print the vector for testing purposes\nvoid print_vector(const vector<int>& vec) {\n    for (int val : vec) {\n        cout << val << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/10", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_palindrome(string str) {\n    // Test if given string is a palindrome\n    string s(str.rbegin(), str.rend());\n    return s == str;\n}\n\nstring make_palindrome(string str) {\n    /*\n    Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n        - Find the longest postfix of supplied string that is a palindrome.\n        - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    */\n    \n    int n = str.length();\n    for (int i = 0; i < n; ++i) {\n        // Check if the substring from i to n-1 is a palindrome\n        if (is_palindrome(str.substr(i))) {\n            // The longest palindromic suffix starts at index i and ends at n-1\n            string prefix = str.substr(0, i);\n            // Reverse the prefix and append it to the end of the original string\n            return str + string(prefix.rbegin(), prefix.rend());\n        }\n    }\n\n    // If no palindromic suffix is found (which should not happen for non-empty strings), return the original string\n    return str;\n}\n\n"}
{"task_id": "CPP/11", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\n// Function to perform binary XOR on two strings\nstring string_xor(string a, string b) {\n    // Ensure both strings are of the same length\n    if (a.length() != b.length()) {\n        throw runtime_error(\"Input strings must be of the same length\");\n    }\n\n    string result = \"\";\n    for (size_t i = 0; i < a.length(); ++i) {\n        // XOR operation: '1' ^ '1' = '0', '1' ^ '0' = '1', '0' ^ '1' = '1', '0' ^ '0' = '0'\n        if (a[i] == b[i]) {\n            result += \"0\";\n        } else {\n            result += \"1\";\n        }\n    }\n\n    return result;\n}\n\n// Function to test the string_xor function\nvoid test_string_xor() {\n    assert(string_xor(\"010\", \"110\") == \"100\");\n    assert(string_xor(\"111\", \"000\") == \"111\");\n    assert(string_xor(\"101010\", \"010101\") == \"111111\");\n    cout << \"All tests passed successfully.\" << endl;\n}\n\n"}
{"task_id": "CPP/12", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring longest(vector<string> strings) {\n    if (strings.empty()) {\n        return \"\"; // Return an empty string to indicate None in this context.\n    }\n\n    const size_t max_length = 0;\n    string result;\n\n    for (const auto& str : strings) {\n        if (str.length() > max_length) {\n            max_length = str.length();\n            result = str;\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/13", "generation": "#include <iostream>\nusing namespace std;\n\nint greatest_common_divisor(int a, int b) {\n    while (b != 0) {\n        int temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n\n// Function to test the greatest_common_divisor function\nvoid test_greatest_common_divisor() {\n    cout << \"Testing greatest_common_divisor function:\" << endl;\n    cout << \"greatest_common_divisor(3, 5) = \" << greatest_common_divisor(3, 5) << \" (Expected: 1)\" << endl;\n    cout << \"greatest_common_divisor(25, 15) = \" << greatest_common_divisor(25, 15) << \" (Expected: 5)\" << endl;\n}\n\n"}
{"task_id": "CPP/14", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to generate all prefixes of the input string\nvector<string> all_prefixes(string str) {\n    vector<string> prefixes;\n    for (size_t i = 1; i <= str.length(); ++i) {\n        // Extract substring from start to current index and add it to the vector\n        prefixes.push_back(str.substr(0, i));\n    }\n    return prefixes;\n}\n\n// Function to print the vector of strings\nvoid print_vector(const vector<string>& vec) {\n    for (const auto& str : vec) {\n        cout << \"\\\"\" << str << \"\\\" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/15", "generation": "#include <iostream>\n#include <sstream>\n#include <string>\n\nstd::string string_sequence(int n) {\n    std::stringstream ss;\n    for (int i = 0; i <= n; ++i) {\n        ss << i;\n        if (i < n) {\n            ss << \" \";\n        }\n    }\n    return ss.str();\n}\n\n// Function to test the string_sequence function\nvoid test_string_sequence() {\n    std::cout << \"Testing string_sequence with input 0: \" << string_sequence(0) << std::endl; // Expected output: \"0\"\n    std::cout << \"Testing string_sequence with input 5: \" << string_sequence(5) << std::endl; // Expected output: \"0 1 2 3 4 5\"\n}\n\n"}
{"task_id": "CPP/16", "generation": "#include <iostream>\n#include <string>\n#include <set>\n\nusing namespace std;\n\nint count_distinct_characters(string str) {\n    // Convert all characters to lowercase to ensure case insensitivity\n    transform(str.begin(), str.end(), str.begin(), ::tolower);\n    \n    // Use a set to store distinct characters\n    set<char> distinct_chars;\n    \n    // Iterate through the string and add each character to the set\n    for (char c : str) {\n        distinct_chars.insert(c);\n    }\n    \n    // The size of the set is the number of distinct characters\n    return distinct_chars.size();\n}\n\n"}
{"task_id": "CPP/17", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<int> parse_music(string music_string) {\n    vector<int> durations;\n    \n    // Iterate through the input string and process each note\n    for (size_t i = 0; i < music_string.length(); ) {\n        if (music_string[i] == 'o') {\n            // Whole note lasts four beats\n            durations.push_back(4);\n            i += 2; // Skip \"o\" and the space after it\n        } else if (music_string[i] == 'o' && music_string[i + 1] == '|') {\n            // Half note lasts two beats\n            durations.push_back(2);\n            i += 3; // Skip \"o|\" and the space after it\n        } else if (music_string[i] == '.' && music_string[i + 1] == '|') {\n            // Quarter note lasts one beat\n            durations.push_back(1);\n            i += 3; // Skip \".|\" and the space after it\n        }\n    }\n\n    return durations;\n}\n\n// Function to test the parse_music function\nvoid test_parse_music() {\n    string input = \"o o| .| o| o| .| .| .| .| o o\";\n    vector<int> expected_output = {4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4};\n    vector<int> output = parse_music(input);\n\n    if (output == expected_output) {\n        printf(\"Test passed!\\n\");\n    } else {\n        printf(\"Test failed! Expected: %v, Got: %v\\n\", expected_output, output);\n    }\n}\n\n"}
{"task_id": "CPP/18", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint how_many_times(const string& str, const string& substring) {\n    int count = 0;\n    size_t pos = 0;\n\n    // Loop through the original string to find all occurrences of the substring\n    while ((pos = str.find(substring, pos)) != string::npos) {\n        ++count;  // Increment count for each occurrence found\n        pos++;    // Move one character forward to allow overlapping matches\n    }\n\n    return count;\n}\n\n"}
{"task_id": "CPP/19", "generation": "#include <iostream>\n#include <string>\n#include <map>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to map word to number\nint word_to_number(const string& word) {\n    map<string, int> num_map = {{\"zero\", 0}, {\"one\", 1}, {\"two\", 2}, {\"three\", 3},\n                                {\"four\", 4}, {\"five\", 5}, {\"six\", 6}, {\"seven\", 7},\n                                {\"eight\", 8}, {\"nine\", 9}};\n    return num_map[word];\n}\n\n// Function to sort the numbers\nstring sort_numbers(const string& input) {\n    vector<string> words;\n    string current_word = \"\";\n    \n    // Split the input into individual words\n    for (char ch : input) {\n        if (ch == ' ') {\n            if (!current_word.empty()) {\n                words.push_back(current_word);\n                current_word.clear();\n            }\n        } else {\n            current_word += ch;\n        }\n    }\n    if (!current_word.empty()) {\n        words.push_back(current_word);\n    }\n\n    // Sort the words based on their corresponding numbers\n    sort(words.begin(), words.end(), [&](const string& a, const string& b) {\n        return word_to_number(a) < word_to_number(b);\n    });\n\n    // Join the sorted words back into a single string\n    string result;\n    for (size_t i = 0; i < words.size(); ++i) {\n        if (i > 0) {\n            result += \" \";\n        }\n        result += words[i];\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/20", "generation": "#include <iostream>\n#include <cmath>\n#include <vector>\nusing namespace std;\n\npair<float, float> find_closest_elements(vector<float> numbers) {\n    if (numbers.size() < 2) {\n        throw invalid_argument(\"The vector must contain at least two elements.\");\n    }\n\n    // Initialize the first pair of closest elements\n    float min_diff = abs(numbers[1] - numbers[0]);\n    pair<float, float> closest_elements = {numbers[0], numbers[1]};\n\n    // Iterate through the vector starting from the second element\n    for (size_t i = 2; i < numbers.size(); ++i) {\n        if (abs(numbers[i] - numbers[i-1]) < min_diff) {\n            min_diff = abs(numbers[i] - numbers[i-1]);\n            closest_elements = {numbers[i-1], numbers[i]};\n        }\n    }\n\n    return closest_elements;\n}\n\n"}
{"task_id": "CPP/21", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // For std::min_element and std::max_element\n\nusing namespace std;\n\nvector<float> rescale_to_unit(vector<float> numbers) {\n    if (numbers.size() < 2) {\n        throw invalid_argument(\"Vector must contain at least two elements.\");\n    }\n\n    float min_val = *std::min_element(numbers.begin(), numbers.end());\n    float max_val = *std::max_element(numbers.begin(), numbers.end());\n\n    vector<float> scaled_numbers;\n    for (float num : numbers) {\n        float new_value = (num - min_val) / (max_val - min_val);\n        scaled_numbers.push_back(new_value);\n    }\n\n    return scaled_numbers;\n}\n\n"}
{"task_id": "CPP/22", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <list>\n#include <boost/any.hpp>\n\ntypedef std::list<boost::any> list_any;\nusing namespace std;\n\nvector<int> filter_integers(list_any values) {\n    vector<int> result;\n    \n    for (const auto& value : values) {\n        if (value.type() == typeid(int)) {\n            result.push_back(boost::any_cast<int>(value));\n        }\n    }\n    \n    return result;\n}\n\n// Example usage\n"}
{"task_id": "CPP/23", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint strlen(const string& str) {\n    return str.length();\n}\n\n// Function to test the strlen function\nvoid test_strlen() {\n    cout << \"Length of \\\"\\\" is: \" << strlen(\"\") << endl;\n    cout << \"Length of \\\"abc\\\" is: \" << strlen(\"abc\") << endl;\n    cout << \"Length of \\\"hello, world!\\\" is: \" << strlen(\"hello, world!\") << endl;\n}\n\n"}
{"task_id": "CPP/24", "generation": "#include <iostream>\n\nint largest_divisor(int n) {\n    // Iterate from n-1 down to 1\n    for (int i = n - 1; i > 0; --i) {\n        if (n % i == 0) {\n            return i; // Return the first number that divides n evenly\n        }\n    }\n    return 1; // If no divisor is found, return 1 (every number is divisible by 1)\n}\n\n"}
{"task_id": "CPP/25", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> factorize(int n) {\n    vector<int> factors;\n    \n    // Divide n by 2 to remove all even factors\n    while (n % 2 == 0) {\n        factors.push_back(2);\n        n /= 2;\n    }\n    \n    // Now n must be odd, so we can skip one element (Note i = i +2)\n    for (int i = 3; i * i <= n; i += 2) {\n        // While i divides n, append i and divide n\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n    \n    // This condition is to handle the case when n is a prime number greater than 2\n    if (n > 2) {\n        factors.push_back(n);\n    }\n    \n    return factors;\n}\n\n"}
{"task_id": "CPP/26", "generation": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nvector<int> remove_duplicates(vector<int> numbers) {\n    // Create an unordered map to count occurrences of each number\n    unordered_map<int, int> counts;\n    \n    // Count the occurrences of each element in the input vector\n    for (int num : numbers) {\n        counts[num]++;\n    }\n    \n    // Reserve space in the result vector to avoid reallocations\n    vector<int> result;\n    result.reserve(numbers.size());\n    \n    // Iterate through the original vector and add elements that occur only once\n    for (int num : numbers) {\n        if (counts[num] == 1) {\n            result.push_back(num);\n        }\n    }\n    \n    return result;\n}\n\n// Function to check the correctness of the remove_duplicates function\nvoid check() {\n    vector<int> input = {1, 2, 3, 2, 4};\n    vector<int> expected_output = {1, 3, 4};\n    vector<int> output = remove_duplicates(input);\n    \n    cout << \"Input: \";\n    for (int num : input) {\n        cout << num << \" \";\n    }\n    cout << \"\\nExpected Output: \";\n    for (int num : expected_output) {\n        cout << num << \" \";\n    }\n    cout << \"\\nActual Output: \";\n    for (int num : output) {\n        cout << num << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/27", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring flip_case(string str) {\n    for (char &c : str) {\n        if (islower(c)) {\n            c = toupper(c);\n        } else if (isupper(c)) {\n            c = tolower(c);\n        }\n    }\n    return str;\n}\n\n"}
{"task_id": "CPP/28", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <numeric> // For std::accumulate\n\nusing namespace std;\n\nstring concatenate(vector<string> strings) {\n    if (strings.empty()) {\n        return \"\";\n    }\n    \n    // Use std::accumulate to concatenate all elements in the vector\n    string result = accumulate(strings.begin(), strings.end(), \"\"s, [](const string& a, const string& b) {\n        return a + b;\n    });\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/29", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<string> filter_by_prefix(vector<string> strings, string prefix) {\n    vector<string> filtered_strings;\n    \n    for (const auto& str : strings) {\n        if (str.substr(0, prefix.length()) == prefix) {\n            filtered_strings.push_back(str);\n        }\n    }\n    \n    return filtered_strings;\n}\n\n// Function to test the filter_by_prefix function\nvoid test_filter_by_prefix() {\n    vector<string> result1 = filter_by_prefix({}, \"a\");\n    cout << \"Test 1: \";\n    if (result1.empty()) {\n        cout << \"Passed\" << endl;\n    } else {\n        cout << \"Failed\" << endl;\n    }\n\n    vector<string> result2 = filter_by_prefix({\"abc\", \"bcd\", \"cde\", \"vector\"}, \"a\");\n    cout << \"Test 2: \";\n    if (result2 == vector<string>{\"abc\", \"vector\"}) {\n        cout << \"Passed\" << endl;\n    } else {\n        cout << \"Failed\" << endl;\n    }\n}\n\n"}
{"task_id": "CPP/30", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<float> get_positive(vector<float> l) {\n    vector<float> result;\n    for (float num : l) {\n        if (num > 0) {\n            result.push_back(num);\n        }\n    }\n    return result;\n}\n\n"}
{"task_id": "CPP/31", "generation": "#include <iostream>\n#include <cmath> // For sqrt function\n\nusing namespace std;\n\nbool is_prime(long long n) {\n    if (n <= 1) return false; // Numbers less than or equal to 1 are not prime\n    if (n == 2 || n == 3) return true; // 2 and 3 are prime numbers\n    if (n % 2 == 0 || n % 3 == 0) return false; // Exclude multiples of 2 and 3\n\n    for (long long i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0)\n            return false;\n    }\n    return true;\n}\n\n"}
{"task_id": "CPP/32", "generation": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\ndouble poly(vector<double> xs, double x) {\n    /*\n    Evaluates polynomial with coefficients xs at point x.\n    return xs[0] + xs[1] * x + xs[2] * x^2 + ... + xs[n] * x^n\n    */\n    double sum = 0;\n    int i;\n    for (i = 0; i < xs.size(); i++) {\n        sum += xs[i] * pow(x, i);\n    }\n    return sum;\n}\n\ndouble find_zero(vector<double> xs) {\n    /*\n    xs are coefficients of a polynomial. find_zero finds x such that poly(x) = 0.\n    It returns only one zero point, even if there are many.\n    Moreover, find_zero only takes lists xs having an odd number of coefficients\n    and the largest non-zero coefficient as it guarantees a solution.\n\n    >>> round(find_zero({1, 2}), 2) # f(x) = 1 + 2x \n    -0.5\n    >>> round(find_zero({-6, 11, -6, 1}), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3 \n    1.0\n    */\n    \n    // Ensure the polynomial has an odd number of coefficients\n    if (xs.size() % 2 == 0) {\n        throw runtime_error(\"The polynomial must have an odd number of coefficients.\");\n    }\n    \n    // Find a suitable interval [a, b] where f(a) * f(b) < 0\n    double a = -10.0;\n    double b = 10.0;\n    while (poly(xs, a) * poly(xs, b) >= 0) {\n        if (fabs(poly(xs, a)) < fabs(poly(xs, b))) {\n            a *= 2;\n        } else {\n            b /= 2;\n        }\n    }\n\n    // Bisection method to find the root\n    double c = (a + b) / 2.0;\n    while ((b - a) > 1e-6) {  // Tolerance for stopping condition\n        if (poly(xs, c) == 0) {\n            return c;  // Exact root found\n        } else if (poly(xs, a) * poly(xs, c) < 0) {\n            b = c;\n        } else {\n            a = c;\n        }\n        c = (a + b) / 2.0;\n    }\n\n    return c;\n}\n\n"}
{"task_id": "CPP/33", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> sort_third(vector<int> l) {\n    vector<int> third_indices;\n    \n    // Extract elements at indices divisible by three\n    for (size_t i = 0; i < l.size(); ++i) {\n        if ((i + 1) % 3 == 0) {\n            third_indices.push_back(l[i]);\n        }\n    }\n\n    // Sort the extracted elements\n    sort(third_indices.begin(), third_indices.end());\n\n    // Replace the original elements at those indices with sorted ones\n    for (size_t i = 0, j = 0; i < l.size(); ++i) {\n        if ((i + 1) % 3 == 0) {\n            l[i] = third_indices[j++];\n        }\n    }\n\n    return l;\n}\n\n// Function to test the sort_third function\nvoid test_sort_third() {\n    vector<int> result;\n\n    // Test case 1\n    result = sort_third({1, 2, 3});\n    for (int num : result) {\n        cout << num << \" \";\n    }\n    cout << endl; // Expected output: 1 2 3\n\n    // Test case 2\n    result = sort_third({5, 6, 3, 4, 8, 9, 2});\n    for (int num : result) {\n        cout << num << \" \";\n    }\n    cout << endl; // Expected output: 2 6 3 4 8 9 5\n}\n\n"}
{"task_id": "CPP/34", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> unique(vector<int> l) {\n    // Sort the vector\n    sort(l.begin(), l.end());\n    \n    // Remove consecutive duplicates and return iterator to new end\n    auto new_end = unique(l.begin(), l.end());\n    \n    // Resize the vector to remove unused elements\n    l.resize(distance(l.begin(), new_end));\n    \n    return l;\n}\n\n"}
{"task_id": "CPP/35", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nfloat max_element(vector<float> l) {\n    if (l.empty()) {  // Check if the vector is empty\n        return -1;   // Return a special value or throw an exception as needed\n    }\n\n    float max_val = l[0];  // Initialize max_val with the first element of the vector\n\n    for (float num : l) {\n        if (num > max_val) {\n            max_val = num;\n        }\n    }\n\n    return max_val;  // Return the maximum value found\n}\n\n"}
{"task_id": "CPP/36", "generation": "#include <iostream>\nusing namespace std;\n\nint fizz_buzz(int n) {\n    int count = 0;\n    \n    for (int i = 1; i < n; ++i) {\n        if (i % 11 == 0 || i % 13 == 0) {\n            // Convert the number to a string and count occurrences of '7'\n            string num_str = to_string(i);\n            for (char c : num_str) {\n                if (c == '7') {\n                    ++count;\n                }\n            }\n        }\n    }\n    \n    return count;\n}\n\n"}
{"task_id": "CPP/37", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<float> sort_even(vector<float> l) {\n    // Extract elements at even indices (0, 2, 4, ...)\n    vector<float> even_elements;\n    for (size_t i = 0; i < l.size(); i += 2) {\n        even_elements.push_back(l[i]);\n    }\n\n    // Sort the extracted elements\n    sort(even_elements.begin(), even_elements.end());\n\n    // Place sorted elements back into their original positions\n    size_t even_index = 0;\n    for (size_t i = 0; i < l.size(); i += 2) {\n        l[i] = even_elements[even_index++];\n    }\n\n    return l;\n}\n\n// Function to print the vector\nvoid print_vector(const vector<float>& v) {\n    for (float val : v) {\n        cout << val << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/38", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring encode_cyclic(string s) {\n    // returns encoded string by cycling groups of three characters.\n    int l = s.length();\n    int num = (l + 2) / 3;\n    string x, output;\n    for (int i = 0; i * 3 < l; i++) {\n        x = s.substr(i * 3, 3);\n        if (x.length() == 3) x = x.substr(1) + x[0];\n        output += x;\n    }\n    return output;\n}\n\nstring decode_cyclic(string s) {\n    /*\n    takes as input string encoded with encode_cyclic function. Returns decoded string.\n    */\n    int l = s.length();\n    int num = (l + 2) / 3;\n    string x, output;\n    for (int i = 0; i * 3 < l; i++) {\n        x = s.substr(i * 3, 3);\n        if (x.length() == 3) x = x.back() + x.substr(0, 2); // Move the last character to the front\n        output += x;\n    }\n    return output;\n}\n\n"}
{"task_id": "CPP/39", "generation": "#include <iostream>\n#include <vector>\n\n// Function to check if a number is prime\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    if (num == 2 || num == 3) return true;\n    if (num % 2 == 0 || num % 3 == 0) return false;\n    for (int i = 5; i * i <= num; i += 6) {\n        if (num % i == 0 || num % (i + 2) == 0)\n            return false;\n    }\n    return true;\n}\n\n// Function to generate the n-th Fibonacci number that is also prime\nint prime_fib(int n) {\n    int count = 0; // To keep track of how many prime Fibonacci numbers we have found\n    long fib1 = 0, fib2 = 1; // Initial two Fibonacci numbers\n\n    while (true) {\n        long next_fib = fib1 + fib2;\n        if (is_prime(next_fib)) {\n            count++;\n            if (count == n) return next_fib;\n        }\n        fib1 = fib2;\n        fib2 = next_fib;\n    }\n}\n\n"}
{"task_id": "CPP/40", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nbool triples_sum_to_zero(vector<int> l) {\n    // First, sort the array to facilitate the two-pointer approach.\n    sort(l.begin(), l.end());\n    \n    int n = l.size();\n    \n    for (int i = 0; i < n - 2; ++i) {\n        // Skip duplicate elements to avoid redundant checks\n        if (i > 0 && l[i] == l[i-1]) continue;\n        \n        int left = i + 1, right = n - 1;\n        \n        while (left < right) {\n            int sum = l[i] + l[left] + l[right];\n            \n            if (sum == 0) {\n                return true;\n            } else if (sum < 0) {\n                ++left; // Need a larger number\n            } else {\n                --right; // Need a smaller number\n            }\n        }\n    }\n    \n    return false;\n}\n\n// Function to test the solution with provided examples\nvoid test() {\n    assert(triples_sum_to_zero({1, 3, 5, 0}) == false);\n    assert(triples_sum_to_zero({1, 3, -2, 1}) == true);\n    assert(triples_sum_to_zero({1, 2, 3, 7}) == false);\n    assert(triples_sum_to_zero({2, 4, -5, 3, 9, 7}) == true);\n    assert(triples_sum_to_zero({1}) == false);\n    \n    cout << \"All test cases passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/41", "generation": "#include <iostream>\nusing namespace std;\n\nint car_race_collision(int n) {\n    return n * n;\n}\n\n"}
{"task_id": "CPP/42", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> incr_vector(vector<int> l) {\n    for (int &i : l) {\n        i += 1;\n    }\n    return l;\n}\n\n// Function to print the vector elements\nvoid print_vector(const vector<int>& v) {\n    for (const int& elem : v) {\n        cout << elem << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/43", "generation": "#include <iostream>\n#include <vector>\n#include <set>\n\nusing namespace std;\n\nbool pairs_sum_to_zero(vector<int> l) {\n    // Use a set to store the numbers we've seen so far\n    set<int> seen;\n    \n    for (int num : l) {\n        // Check if the negation of the current number is in the set\n        if (seen.find(-num) != seen.end()) {\n            return true;  // Found two numbers that sum to zero\n        }\n        // Add the current number to the set\n        seen.insert(num);\n    }\n    \n    return false;  // No pair found that sums to zero\n}\n\n// Function to test the pairs_sum_to_zero function with provided examples\nvoid test_pairs_sum_to_zero() {\n    assert(pairs_sum_to_zero({1, 3, 5, 0}) == false);\n    assert(pairs_sum_to_zero({1, 3, -2, 1}) == false);\n    assert(pairs_sum_to_zero({1, 2, 3, 7}) == false);\n    assert(pairs_sum_to_zero({2, 4, -5, 3, 5, 7}) == true);\n    assert(pairs_sum_to_zero({1}) == false);\n\n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/44", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring change_base(int x, int base) {\n    if (x == 0) {\n        return \"0\";\n    }\n    \n    string result = \"\";\n    while (x > 0) {\n        int digit = x % base;\n        result = to_string(digit) + result;\n        x /= base;\n    }\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/45", "generation": "#include <stdio.h>\nusing namespace std;\n\nfloat triangle_area(float a, float h) {\n    return 0.5 * a * h;\n}\n\n"}
{"task_id": "CPP/46", "generation": "#include <iostream>\nusing namespace std;\n\nint fib4(int n) {\n    if (n == 0 || n == 1 || n == 2) {\n        return n == 2 ? 2 : 0;\n    }\n    \n    // Initialize the first four values of the sequence\n    int a = 0, b = 0, c = 2, d = 0;\n    \n    // Compute fib4(n) iteratively\n    for (int i = 3; i <= n; ++i) {\n        int next = a + b + c + d;\n        a = b;\n        b = c;\n        c = d;\n        d = next;\n    }\n    \n    return d;\n}\n\n"}
{"task_id": "CPP/47", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nfloat median(vector<float> l) {\n    // Sort the vector\n    sort(l.begin(), l.end());\n    \n    int n = l.size();\n    \n    // Check if the number of elements is odd or even\n    if (n % 2 == 1) {\n        // If odd, return the middle element\n        return l[n / 2];\n    } else {\n        // If even, return the average of the two middle elements\n        return (l[(n - 1) / 2] + l[n / 2]) / 2.0;\n    }\n}\n\n"}
{"task_id": "CPP/48", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_palindrome(string text) {\n    int start = 0;\n    int end = text.length() - 1;\n\n    while (start < end) {\n        if (text[start] != text[end]) {\n            return false; // Characters do not match, so it's not a palindrome\n        }\n        start++;\n        end--;\n    }\n\n    return true; // All characters matched, so it is a palindrome\n}\n\n"}
{"task_id": "CPP/49", "generation": "#include <stdio.h>\nusing namespace std;\n\nint modp(int n, int p) {\n    if (n == 0)\n        return 1; // Any number to the power of 0 is 1\n\n    long long result = 1;\n    long long base = 2;\n\n    while (n > 0) {\n        if (n % 2 == 1) { // If n is odd, multiply the result by the current base\n            result = (result * base) % p;\n        }\n        base = (base * base) % p; // Square the base and reduce modulo p\n        n /= 2; // Halve n\n    }\n\n    return result % p;\n}\n\n"}
{"task_id": "CPP/50", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nstring encode_shift(string s) {\n    // returns encoded string by shifting every character by 5 in the alphabet.\n    string out;\n    int i;\n    for (i = 0; i < s.length(); i++) {\n        int w = ((int)s[i] + 5 - (int)'a') % 26 + (int)'a';\n        out += (char)w;\n    }\n    return out;\n}\n\nstring decode_shift(string s) {\n    // takes as input string encoded with encode_shift function. Returns decoded string.\n    string out;\n    int i;\n    for (i = 0; i < s.length(); i++) {\n        int w = ((int)s[i] - 5 - (int)'a') % 26 + (int)'a';\n        out += (char)w;\n    }\n    return out;\n}\n\n"}
{"task_id": "CPP/51", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nstring remove_vowels(string text) {\n    // Define the vowels to be removed (both lowercase and uppercase)\n    string vowels = \"aeiouAEIOU\";\n    \n    // Use a stream iterator to filter out the vowels from the input string\n    return string(remove(vowels.begin(), vowels.end(), text));\n}\n\n"}
{"task_id": "CPP/52", "generation": "#include <vector>\nusing namespace std;\n\nbool below_threshold(vector<int> l, int t) {\n    for (int num : l) {\n        if (num >= t) {\n            return false;\n        }\n    }\n    return true;\n}\n\n// Example usage:\n"}
{"task_id": "CPP/53", "generation": "#include <iostream>  // Include iostream for input/output operations\n\nusing namespace std;\n\nint add(int x, int y) {\n    return x + y;     // Return the sum of x and y\n}\n\n"}
{"task_id": "CPP/54", "generation": "#include <iostream>\n#include <string>\n#include <unordered_set>\n\nusing namespace std;\n\nbool same_chars(string s0, string s1) {\n    // Create unordered sets to store unique characters from each string\n    unordered_set<char> chars_s0(s0.begin(), s0.end());\n    unordered_set<char> chars_s1(s1.begin(), s1.end());\n\n    // Check if the sets of unique characters are equal\n    return chars_s0 == chars_s1;\n}\n\n"}
{"task_id": "CPP/55", "generation": "#include <iostream>\nusing namespace std;\n\nint fib(int n) {\n    if (n <= 0) return 0;\n    if (n == 1) return 1;\n\n    int a = 0, b = 1, c;\n    for (int i = 2; i <= n; ++i) {\n        c = a + b;\n        a = b;\n        b = c;\n    }\n    return b;\n}\n\n"}
{"task_id": "CPP/56", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    int balance = 0;\n    \n    for (char bracket : brackets) {\n        if (bracket == '<') {\n            balance++;\n        } else if (bracket == '>') {\n            balance--;\n        }\n        \n        // If at any point the balance is negative, it means there's a closing bracket without an opening one\n        if (balance < 0) {\n            return false;\n        }\n    }\n    \n    // At the end, the balance should be zero for correct bracketing\n    return balance == 0;\n}\n\n"}
{"task_id": "CPP/57", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool isMonotonic(const vector<float>& l) {\n    bool increasing = false;\n    bool decreasing = false;\n\n    for (size_t i = 1; i < l.size(); ++i) {\n        if (l[i] > l[i - 1]) {\n            increasing = true;\n        } else if (l[i] < l[i - 1]) {\n            decreasing = true;\n        }\n\n        // If both flags are set, the sequence is not monotonic\n        if (increasing && decreasing) {\n            return false;\n        }\n    }\n\n    // The sequence is either increasing or decreasing, but not both\n    return true;\n}\n\n"}
{"task_id": "CPP/58", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to remove duplicates and sort a vector\nvoid uniqueAndSort(vector<int>& vec) {\n    sort(vec.begin(), vec.end());\n    vec.erase(unique(vec.begin(), vec.end()), vec.end());\n}\n\nvector<int> common(vector<int> l1, vector<int> l2) {\n    // Remove duplicates and sort both vectors\n    uniqueAndSort(l1);\n    uniqueAndSort(l2);\n\n    // Find the intersection of the two sorted vectors\n    vector<int> result;\n    set_intersection(l1.begin(), l1.end(), l2.begin(), l2.end(), back_inserter(result));\n\n    return result;\n}\n\n"}
{"task_id": "CPP/59", "generation": "#include <iostream>\nusing namespace std;\n\nint largest_prime_factor(int n) {\n    int maxPrime = -1;\n    \n    // Divide by 2 to remove all even factors\n    while (n % 2 == 0) {\n        maxPrime = 2;\n        n /= 2;\n    }\n    \n    // Check for odd factors from 3 onwards\n    for (int i = 3; i * i <= n; i += 2) {\n        while (n % i == 0) {\n            maxPrime = i;\n            n = n / i;\n        }\n    }\n    \n    // If n is a prime number greater than 2\n    if (n > 2)\n        maxPrime = n;\n    \n    return maxPrime;\n}\n\n"}
{"task_id": "CPP/60", "generation": "#include <iostream>\nusing namespace std;\n\nint sum_to_n(int n) {\n    return (n * (n + 1)) / 2;\n}\n\n"}
{"task_id": "CPP/61", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    int balance = 0;\n    \n    for (char c : brackets) {\n        if (c == '(') {\n            balance++;\n        } else if (c == ')') {\n            balance--;\n        }\n        \n        // If at any point the balance is negative, it means there's a closing parenthesis without an opening one\n        if (balance < 0) {\n            return false;\n        }\n    }\n    \n    // If the balance is zero at the end, all parentheses are correctly matched\n    return balance == 0;\n}\n\n"}
{"task_id": "CPP/62", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvector<float> derivative(vector<float> xs) {\n    // Create a new vector to hold the coefficients of the derivative polynomial\n    vector<float> result;\n    \n    // Iterate through the input vector, starting from the first non-constant term (index 1)\n    for (size_t i = 1; i < xs.size(); ++i) {\n        // Multiply each coefficient by its corresponding power (i)\n        result.push_back(xs[i] * i);\n    }\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/63", "generation": "#include <iostream>\nusing namespace std;\n\nint fibfib(int n) {\n    // Base cases\n    if (n == 0 || n == 1) return 0;\n    if (n == 2) return 1;\n\n    // Array to store the computed values of FibFib sequence\n    int dp[n + 1];\n    dp[0] = 0; // fibfib(0)\n    dp[1] = 0; // fibfib(1)\n    dp[2] = 1; // fibfib(2)\n\n    // Compute the rest of the values iteratively\n    for (int i = 3; i <= n; ++i) {\n        dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3];\n    }\n\n    return dp[n];\n}\n\n// Function to test the fibfib function with some examples\nvoid testFibfib() {\n    cout << \"fibfib(1): \" << fibfib(1) << endl; // Expected: 0\n    cout << \"fibfib(5): \" << fibfib(5) << endl; // Expected: 4\n    cout << \"fibfib(8): \" << fibfib(8) << endl; // Expected: 24\n}\n\n"}
{"task_id": "CPP/64", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint vowels_count(string s) {\n    int count = 0;\n    \n    // Convert the string to lowercase for easier comparison\n    transform(s.begin(), s.end(), s.begin(), ::tolower);\n    \n    // Check each character in the string\n    for (char c : s) {\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n            count++;\n        } else if (c == 'y' && s.length() - 1 == distance(s.begin(), find_if(s.rbegin(), s.rend(), [](char ch) { return !isspace(ch); }))) {\n            // Check if the last character is 'y'\n            count++;\n        }\n    }\n    \n    return count;\n}\n\n"}
{"task_id": "CPP/65", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\n// Function to perform circular shift or reverse if shift > number of digits\nstring circular_shift(int x, int shift) {\n    // Convert integer to string for easier manipulation\n    string num_str = to_string(x);\n    \n    // Get the length of the number\n    int len = num_str.length();\n    \n    // If shift is greater than the number of digits, reverse the string\n    if (shift > len) {\n        return num_str;\n    }\n    \n    // Perform circular right shift\n    shift %= len;  // Handle cases where shift > len\n    string shifted_str = num_str.substr(len - shift) + num_str.substr(0, len - shift);\n    \n    return shifted_str;\n}\n\n// Function to test the circular_shift function with provided examples\nvoid test_circular_shift() {\n    cout << \"circular_shift(12345, 2): \" << circular_shift(12345, 2) << endl; // Should output \"34512\"\n    cout << \"circular_shift(12345, 7): \" << circular_shift(12345, 7) << endl; // Should output \"12345\" (since 7 > number of digits)\n}\n\n"}
{"task_id": "CPP/66", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint digitSum(string s) {\n    int sum = 0;\n    for (char c : s) {\n        if (isupper(c)) { // Check if the character is uppercase\n            sum += static_cast<int>(c); // Add its ASCII value to the sum\n        }\n    }\n    return sum;\n}\n\n// Function to test the digitSum function with provided examples\nvoid checkFunction() {\n    assert(digitSum(\"\") == 0);\n    assert(digitSum(\"abAB\") == 131);\n    assert(digitSum(\"abcCd\") == 67);\n    assert(digitSum(\"helloE\") == 69);\n    assert(digitSum(\"woArBld\") == 131);\n    assert(digitSum(\"aAaaaXa\") == 153);\n\n    cout << \"All test cases passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/67", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\nusing namespace std;\n\nint fruit_distribution(string s, int n) {\n    // Use a stringstream to parse the string\n    stringstream ss(s);\n    string temp;\n    int apples = 0, oranges = 0;\n\n    // Extract numbers from the string\n    while (getline(ss, temp, ' ')) {\n        if (temp == \"apples\") {\n            getline(ss, temp, ' ');\n            ss >> apples;\n        } else if (temp == \"oranges\") {\n            getline(ss, temp, ' ');\n            ss >> oranges;\n        }\n    }\n\n    // Calculate the number of mangoes\n    int mangoes = n - (apples + oranges);\n    return mangoes;\n}\n\n// Function to test the fruit_distribution function\nvoid test_fruit_distribution() {\n    cout << \"Test 1: \" << fruit_distribution(\"5 apples and 6 oranges\", 19) << \" (Expected: 8)\" << endl;\n    cout << \"Test 2: \" << fruit_distribution(\"0 apples and 1 oranges\", 3) << \" (Expected: 2)\" << endl;\n    cout << \"Test 3: \" << fruit_distribution(\"2 apples and 3 oranges\", 100) << \" (Expected: 95)\" << endl;\n    cout << \"Test 4: \" << fruit_distribution(\"100 apples and 1 oranges\", 120) << \" (Expected: 19)\" << endl;\n}\n\n"}
{"task_id": "CPP/68", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> pluck(vector<int> arr) {\n    // Check if the array is empty\n    if (arr.empty()) {\n        return {};\n    }\n\n    int smallestEvenValue = -1;\n    int smallestIndex = -1;\n\n    for (int i = 0; i < arr.size(); ++i) {\n        if (arr[i] % 2 == 0) { // Check if the value is even\n            if (smallestEvenValue == -1 || arr[i] < smallestEvenValue) {\n                smallestEvenValue = arr[i];\n                smallestIndex = i;\n            } else if (arr[i] == smallestEvenValue && i < smallestIndex) {\n                // If there are multiple nodes with the same smallest even value, choose the one with the smallest index\n                smallestIndex = i;\n            }\n        }\n    }\n\n    // If no even values were found, return an empty vector\n    if (smallestEvenValue == -1) {\n        return {};\n    }\n\n    return {smallestEvenValue, smallestIndex};\n}\n\n"}
{"task_id": "CPP/69", "generation": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nint search(vector<int> lst) {\n    // Create a frequency map to count the occurrences of each number\n    unordered_map<int, int> freqMap;\n    \n    // Populate the frequency map\n    for (int num : lst) {\n        freqMap[num]++;\n    }\n    \n    // Find the greatest integer that meets the criteria\n    int result = -1;\n    for (const auto& pair : freqMap) {\n        if (pair.first <= pair.second) {\n            result = max(result, pair.first);\n        }\n    }\n    \n    return result;\n}\n\n// Function to test the search function with provided examples\nvoid test() {\n    assert(search({4, 1, 2, 2, 3, 1}) == 2);\n    assert(search({1, 2, 2, 3, 3, 3, 4, 4, 4}) == 3);\n    assert(search({5, 5, 4, 4, 4}) == -1);\n    \n    cout << \"All tests passed.\" << endl;\n}\n\n"}
{"task_id": "CPP/70", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> strange_sort_list(vector<int> lst) {\n    // Sort the input list in ascending order\n    sort(lst.begin(), lst.end());\n    \n    vector<int> result;\n    int start = 0;  // Pointer to the beginning of the sorted list\n    int end = lst.size() - 1;  // Pointer to the end of the sorted list\n    \n    while (start <= end) {\n        if (start == end) {\n            // If there's only one element left, add it to the result\n            result.push_back(lst[start]);\n        } else {\n            // Add the minimum value first\n            result.push_back(lst[start++]);\n            // Then add the maximum value\n            result.push_back(lst[end--]);\n        }\n    }\n    \n    return result;\n}\n\n// Function to test the strange_sort_list function with provided examples\nvoid test_strange_sort() {\n    vector<int> lst1 = {1, 2, 3, 4};\n    vector<int> expected1 = {1, 4, 2, 3};\n    assert(strange_sort_list(lst1) == expected1);\n\n    vector<int> lst2 = {5, 5, 5, 5};\n    vector<int> expected2 = {5, 5, 5, 5};\n    assert(strange_sort_list(lst2) == expected2);\n\n    vector<int> lst3 = {};\n    vector<int> expected3 = {};\n    assert(strange_sort_list(lst3) == expected3);\n\n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/71", "generation": "#include <stdio.h>\n#include <math.h>\n\nusing namespace std;\n\nfloat triangle_area(float a, float b, float c) {\n    // Check for valid triangle using the triangle inequality theorem\n    if (a + b <= c || a + c <= b || b + c <= a) {\n        return -1;\n    }\n\n    // Calculate the semi-perimeter\n    float s = (a + b + c) / 2.0;\n\n    // Use Heron's formula to calculate the area\n    float area = sqrt(s * (s - a) * (s - b) * (s - c));\n\n    // Round the result to 2 decimal points\n    return round(area * 100) / 100;\n}\n\n"}
{"task_id": "CPP/72", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool will_it_fly(vector<int> q, int w) {\n    // Check if the vector is a palindrome\n    for (int i = 0; i < q.size() / 2; ++i) {\n        if (q[i] != q[q.size() - 1 - i]) {\n            return false; // Not a palindrome\n        }\n    }\n\n    // Calculate the sum of elements in the vector\n    int sum = 0;\n    for (int num : q) {\n        sum += num;\n    }\n\n    // Check if the sum is less than or equal to w\n    return sum <= w;\n}\n\n// Function to test the will_it_fly function with provided examples\nvoid test() {\n    cout << boolalpha; // Print bools as true/false instead of 1/0\n    cout << \"will_it_fly({1, 2}, 5) \u279e \" << will_it_fly({1, 2}, 5) << endl;\n    cout << \"will_it_fly({3, 2, 3}, 1) \u279e \" << will_it_fly({3, 2, 3}, 1) << endl;\n    cout << \"will_it_fly({3, 2, 3}, 9) \u279e \" << will_it_fly({3, 2, 3}, 9) << endl;\n    cout << \"will_it_fly({3}, 5) \u279e \" << will_it_fly({3}, 5) << endl;\n}\n\n"}
{"task_id": "CPP/73", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint smallest_change(vector<int> arr) {\n    int left = 0;\n    int right = arr.size() - 1;\n    int count_changes = 0;\n\n    while (left < right) {\n        if (arr[left] != arr[right]) {\n            count_changes++;\n        }\n        left++;\n        right--;\n    }\n\n    return count_changes;\n}\n\n"}
{"task_id": "CPP/74", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to calculate the total number of characters in a vector of strings\nint count_chars(const vector<string>& vec) {\n    int total = 0;\n    for (const auto& str : vec) {\n        total += str.length();\n    }\n    return total;\n}\n\nvector<string> total_match(vector<string> lst1, vector<string> lst2) {\n    // Calculate the total number of characters in each vector\n    int chars_lst1 = count_chars(lst1);\n    int chars_lst2 = count_chars(lst2);\n\n    // Compare and return the appropriate vector\n    if (chars_lst1 < chars_lst2) {\n        return lst1;\n    } else if (chars_lst2 < chars_lst1) {\n        return lst2;\n    } else {\n        return lst1;  // Return the first vector if they have the same number of characters\n    }\n}\n\n// Function to test the total_match function with provided examples\nvoid test_total_match() {\n    assert(total_match({}, {}) == vector<string>());\n    assert(total_match({\"hi\", \"admin\"}, {\"hI\", \"Hi\"}) == vector<string>{\"hI\", \"Hi\"});\n    assert(total_match({\"hi\", \"admin\"}, {\"hi\", \"hi\", \"admin\", \"project\"}) == vector<string>{\"hi\", \"admin\"});\n    assert(total_match({\"hi\", \"admin\"}, {\"hI\", \"hi\", \"hi\"}) == vector<string>{\"hI\", \"hi\", \"hi\"});\n    assert(total_match({\"4\"}, {\"1\", \"2\", \"3\", \"4\", \"5\"}) == vector<string>{\"4\"});\n\n    cout << \"All tests passed successfully.\" << endl;\n}\n\n"}
{"task_id": "CPP/75", "generation": "#include <iostream>\nusing namespace std;\n\n// Helper function to check if a number is prime\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\n// Function to check if the number is a product of exactly three prime numbers\nbool is_multiply_prime(int a) {\n    int count = 0;\n\n    // Check for factors up to the square root of 'a'\n    for (int i = 2; i * i <= a; ++i) {\n        while (a % i == 0 && is_prime(i)) {\n            count++;\n            a /= i;\n        }\n    }\n\n    // If there are exactly three prime factors, return true\n    if (count == 3 && a > 1 && is_prime(a)) {\n        return true;\n    }\n\n    return false;\n}\n\n"}
{"task_id": "CPP/76", "generation": "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\nbool is_simple_power(int x, int n) {\n    if (n == 1) {\n        return x == 1; // Special case: 1^any = 1\n    }\n    \n    double logResult = log(x) / log(n);\n    return floor(logResult) == logResult;\n}\n\n"}
{"task_id": "CPP/77", "generation": "#include <stdio.h>\n#include <math.h>\n\nusing namespace std;\n\nbool iscube(int a) {\n    // Handle special case for 0\n    if (a == 0) return true;\n    \n    // Calculate the cube root of the absolute value of 'a'\n    double cubeRoot = cbrt(abs(a));\n    \n    // Round the cube root to the nearest integer\n    int roundedCubeRoot = round(cubeRoot);\n    \n    // Check if cubing the rounded value gives back the original number\n    return (roundedCubeRoot * roundedCubeRoot * roundedCubeRoot == a);\n}\n\n"}
{"task_id": "CPP/78", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\n// Function to check if a hexadecimal digit is prime\nbool is_hex_prime(char hex_digit) {\n    switch(hex_digit) {\n        case '2': case '3': case '5': case '7':\n        case 'B': case 'D': return true;\n        default: return false;\n    }\n}\n\n// Function to count the number of prime hexadecimal digits in a string\nint hex_key(string num) {\n    int count = 0;\n    for (char digit : num) {\n        if (is_hex_prime(digit)) {\n            count++;\n        }\n    }\n    return count;\n}\n\n// Main function to test the hex_key function\n"}
{"task_id": "CPP/79", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\n// Function to convert decimal to binary\nstring decimal_to_binary(int decimal) {\n    if (decimal == 0) {\n        return \"db0db\";\n    }\n\n    string binary = \"\";\n    while (decimal > 0) {\n        int remainder = decimal % 2;\n        binary = to_string(remainder) + binary;\n        decimal /= 2;\n    }\n    \n    // Add 'db' at the beginning and end\n    return \"db\" + binary + \"db\";\n}\n\n// Function to test the conversion with some examples\nvoid test_decimal_to_binary() {\n    cout << decimal_to_binary(15) << endl;   // Should print: db1111db\n    cout << decimal_to_binary(32) << endl;   // Should print: db100000db\n    cout << decimal_to_binary(0) << endl;    // Should print: db0db\n}\n\n"}
{"task_id": "CPP/80", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_happy(string s) {\n    // Check if the string length is less than 3\n    if (s.length() < 3) return false;\n\n    // Iterate through the string and check every three consecutive characters\n    for (size_t i = 0; i <= s.length() - 3; ++i) {\n        // If any two of these three characters are the same, return false\n        if (s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]) {\n            return false;\n        }\n    }\n\n    // If no three consecutive characters are the same, return true\n    return true;\n}\n\n"}
{"task_id": "CPP/81", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to convert GPA to letter grade\nstring gpa_to_letter(float gpa) {\n    if (gpa >= 4.0f) return \"A+\";\n    else if (gpa > 3.7f) return \"A\";\n    else if (gpa > 3.3f) return \"A-\";\n    else if (gpa > 3.0f) return \"B+\";\n    else if (gpa > 2.7f) return \"B\";\n    else if (gpa > 2.3f) return \"B-\";\n    else if (gpa > 2.0f) return \"C+\";\n    else if (gpa > 1.7f) return \"C\";\n    else if (gpa > 1.3f) return \"C-\";\n    else if (gpa > 1.0f) return \"D+\";\n    else if (gpa > 0.7f) return \"D\";\n    else if (gpa > 0.0f) return \"D-\";\n    else return \"E\";\n}\n\n// Function to convert vector of GPAs to vector of letter grades\nvector<string> numerical_letter_grade(vector<float> grades) {\n    vector<string> letter_grades;\n    for (float gpa : grades) {\n        letter_grades.push_back(gpa_to_letter(gpa));\n    }\n    return letter_grades;\n}\n\n// Function to check the correctness of the solution\nvoid check() {\n    vector<float> test_grades = {4.0f, 3.0f, 1.7f, 2.0f, 3.5f};\n    vector<string> expected_output = {\"A+\", \"B\", \"C-\", \"C\", \"A-\"};\n    vector<string> output = numerical_letter_grade(test_grades);\n    \n    if (output == expected_output) {\n        printf(\"The function works correctly!\\n\");\n    } else {\n        printf(\"There is an error in the function.\\n\");\n    }\n}\n\n"}
{"task_id": "CPP/82", "generation": "#include <iostream>\n#include <string>\n\n// Function to check if a number is prime\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    if (n == 2 || n == 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    \n    for (int i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0)\n            return false;\n    }\n    return true;\n}\n\n// Function to check if the length of a string is prime\nbool prime_length(string str) {\n    int len = str.length();\n    return is_prime(len);\n}\n\n"}
{"task_id": "CPP/83", "generation": "#include <iostream>\nusing namespace std;\n\nint starts_one_ends(int n) {\n    // If n is 1, there's only one number (which is 1 itself)\n    if (n == 1) return 1;\n    \n    // Count of numbers starting with 1: 10^(n-1)\n    int start_with_1 = pow(10, n - 1);\n    \n    // Count of numbers ending with 1: 10^(n-1)\n    int end_with_1 = pow(10, n - 1);\n    \n    // Count of numbers starting and ending with 1: 10^(n-2)\n    int both_start_and_end_with_1 = pow(10, n - 2);\n    \n    // Total count is the sum minus the overlap\n    return start_with_1 + end_with_1 - both_start_and_end_with_1;\n}\n\n"}
{"task_id": "CPP/84", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\n// Function to convert an integer to its binary string representation\nstring intToBinary(int num) {\n    if (num == 0)\n        return \"0\";\n    \n    string binary = \"\";\n    while (num > 0) {\n        binary = to_string(num % 2) + binary;\n        num /= 2;\n    }\n    return binary;\n}\n\n// Function to calculate the sum of digits of N and return it in binary form\nstring solve(int N) {\n    int sum = 0;\n    \n    // Calculate the sum of digits\n    while (N > 0) {\n        sum += N % 10;\n        N /= 10;\n    }\n    \n    // Convert the sum to binary string\n    return intToBinary(sum);\n}\n\n"}
{"task_id": "CPP/85", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint add(vector<int> lst){\n    int sum = 0;\n    \n    // Iterate through the vector starting from index 1 with a step of 2\n    for (size_t i = 1; i < lst.size(); i += 2) {\n        if (lst[i] % 2 == 0) {  // Check if the element is even\n            sum += lst[i];      // Add it to the sum\n        }\n    }\n    \n    return sum;\n}\n\n"}
{"task_id": "CPP/86", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nstring anti_shuffle(string s) {\n    // Helper function to sort each word\n    auto sort_word = [](const string& word) -> string {\n        string sorted_word = word;\n        sort(sorted_word.begin(), sorted_word.end());\n        return sorted_word;\n    };\n\n    string result;\n    string current_word;\n    for (char c : s) {\n        if (c == ' ') {  // If we encounter a space, add the sorted word to the result\n            if (!current_word.empty()) {\n                result += sort_word(current_word);\n                result += \" \";\n                current_word.clear();\n            }\n            result += c;\n        } else {  // Otherwise, build the current word\n            current_word += c;\n        }\n    }\n\n    // Add the last word after the loop ends\n    if (!current_word.empty()) {\n        result += sort_word(current_word);\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/87", "generation": "#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<vector<int>> get_row(vector<vector<int>> lst, int x) {\n    vector<pair<int, int>> coordinates;\n    \n    // Find all occurrences of x and record their positions\n    for (int row = 0; row < lst.size(); ++row) {\n        for (int col = 0; col < lst[row].size(); ++col) {\n            if (lst[row][col] == x) {\n                coordinates.push_back({row, col});\n            }\n        }\n    }\n\n    // Sort by rows in ascending order and then by columns in descending order\n    sort(coordinates.begin(), coordinates.end(),\n         [](const pair<int, int>& a, const pair<int, int>& b) {\n             if (a.first == b.first) return a.second > b.second;\n             return a.first < b.first;\n         });\n\n    // Convert the sorted pairs back to vector of vectors\n    vector<vector<int>> result(coordinates.size(), vector<int>(2));\n    for (int i = 0; i < coordinates.size(); ++i) {\n        result[i][0] = coordinates[i].first;\n        result[i][1] = coordinates[i].second;\n    }\n\n    return result;\n}\n\n// Example usage:\nvoid print_result(const vector<vector<int>>& result) {\n    for (const auto& coord : result) {\n        printf(\"({%d, %d}) \", coord[0], coord[1]);\n    }\n    printf(\"\\n\");\n}\n\n"}
{"task_id": "CPP/88", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> sort_array(vector<int> array) {\n    // Check if the vector is empty or has only one element\n    if (array.empty() || array.size() == 1) {\n        return array;\n    }\n\n    // Calculate the sum of the first and last elements\n    int sum = array.front() + array.back();\n\n    // Determine sorting order based on the sum being odd or even\n    vector<int> sorted_array(array); // Create a copy to avoid modifying the original vector\n\n    if (sum % 2 == 0) {\n        // Sort in descending order if the sum is even\n        sort(sorted_array.rbegin(), sorted_array.rend());\n    } else {\n        // Sort in ascending order if the sum is odd\n        sort(sorted_array.begin(), sorted_array.end());\n    }\n\n    return sorted_array;\n}\n\n// Function to test the correctness of the solution\nvoid check() {\n    assert(sort_array({}) == vector<int>());\n    assert(sort_array({5}) == vector<int>({5}));\n    assert(sort_array({2, 4, 3, 0, 1, 5}) == vector<int>({0, 1, 2, 3, 4, 5}));\n    assert(sort_array({2, 4, 3, 0, 1, 5, 6}) == vector<int>({6, 5, 4, 3, 2, 1, 0}));\n}\n\n"}
{"task_id": "CPP/89", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\n// Function to encrypt the input string by rotating the alphabet down by 4 places\nstring encrypt(string s) {\n    for (char &c : s) {\n        // Check if the character is a lowercase letter\n        if (islower(c)) {\n            c = 'a' + (c - 'a' + 4) % 26;\n        }\n        // Check if the character is an uppercase letter\n        else if (isupper(c)) {\n            c = 'A' + (c - 'A' + 4) % 26;\n        }\n    }\n    return s;\n}\n\n"}
{"task_id": "CPP/90", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint next_smallest(vector<int> lst) {\n    // If the vector is empty or has less than 2 unique elements, return None (represented as -1)\n    if (lst.size() < 2 || std::unique(lst.begin(), lst.end()) == lst.begin() + lst.size()) {\n        return -1; // Indicating no second smallest element\n    }\n\n    // Sort the vector to find the second smallest element easily\n    sort(lst.begin(), lst.end());\n\n    // Return the second element in the sorted list\n    return lst[1];\n}\n\n// Function to test the next_smallest function with provided data points\nvoid check() {\n    assert(next_smallest({1, 2, 3, 4, 5}) == 2);\n    assert(next_smallest({5, 1, 4, 3, 2}) == 2);\n    assert(next_smallest({}) == -1); // Empty vector\n    assert(next_smallest({1, 1}) == -1); // Only one unique element\n    cout << \"All test cases passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/91", "generation": "#include <iostream>\n#include <sstream>\n#include <string>\nusing namespace std;\n\nint is_bored(string S) {\n    int count = 0;\n    \n    // Use stringstream to split the string into sentences based on delimiters\n    stringstream ss(S);\n    string sentence;\n    \n    while (getline(ss, sentence, '.')) {\n        if (!sentence.empty()) {\n            getline(ss, sentence, '?');\n            if (!sentence.empty()) {\n                getline(ss, sentence, '!');\n                if (!sentence.empty()) {\n                    // Trim leading and trailing spaces\n                    sentence.erase(0, sentence.find_first_not_of(\" \\t\\n\\r\\f\\v\"));\n                    sentence.erase(sentence.find_last_not_of(\" \\t\\n\\r\\f\\v\") + 1);\n                    \n                    // Check if the first word is \"I\"\n                    size_t pos = sentence.find(\" \");\n                    if (pos == string::npos) {\n                        if (sentence == \"I\") count++;\n                    } else {\n                        if (sentence.substr(0, pos) == \"I\") count++;\n                    }\n                }\n            }\n        }\n    }\n    \n    return count;\n}\n\n"}
{"task_id": "CPP/92", "generation": "#include <iostream>\n#include <cmath>\n\nbool any_int(float a, float b, float c) {\n    // Check if all numbers are integers\n    bool is_a_integer = (a == floor(a));\n    bool is_b_integer = (b == floor(b));\n    bool is_c_integer = (c == floor(c));\n\n    // If not all numbers are integers, return false\n    if (!is_a_integer || !is_b_integer || !is_c_integer) {\n        return false;\n    }\n\n    // Check if one of the numbers is equal to the sum of the other two\n    return (a == b + c) || (b == a + c) || (c == a + b);\n}\n\n"}
{"task_id": "CPP/93", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\n// Function to encode a message by swapping cases and replacing vowels\nstring encode(string message) {\n    // Define vowels and their replacements\n    string vowels = \"aeiouAEIOU\";\n    string replacement_vowels = \"cgikmoCGIKMO\";\n\n    for (char &c : message) {\n        if (isalpha(c)) {  // Check if the character is a letter\n            c = islower(c) ? toupper(c) : tolower(c);  // Swap case\n\n            // Find the vowel and replace it with its corresponding replacement\n            size_t pos = vowels.find(c);\n            if (pos != string::npos) {\n                c = replacement_vowels[pos];\n            }\n        }\n    }\n\n    return message;\n}\n\n"}
{"task_id": "CPP/94", "generation": "bool isPrime(int n) {\n    if (n <= 1) return false;\n    if (n == 2 || n == 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    for (int i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0)\n            return false;\n    }\n    return true;\n}\n"}
{"task_id": "CPP/95", "generation": "#include <iostream>\n#include <string>\n#include <map>\n\nusing namespace std;\n\nbool check_dict_case(map<string, string> dict) {\n    // Check if the map is empty\n    if (dict.empty()) {\n        return false;\n    }\n\n    bool allLower = true;\n    bool allUpper = true;\n\n    // Determine the case of the first key\n    for (const auto &pair : dict) {\n        const string& key = pair.first;\n        if (!islower(key[0])) {\n            allLower = false;\n        }\n        if (!isupper(key[0])) {\n            allUpper = false;\n        }\n\n        // If both flags are false, return false\n        if (!allLower && !allUpper) {\n            return false;\n        }\n    }\n\n    // Return true if either all keys are in lowercase or all keys are in uppercase\n    return allLower || allUpper;\n}\n\n// Function to test the check_dict_case function with provided examples\nvoid test_check_dict_case() {\n    assert(check_dict_case({{\"a\", \"apple\"}, {\"b\", \"banana\"}}) == true);\n    assert(check_dict_case({{\"a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}) == false);\n    assert(check_dict_case({{\"a\", \"apple\"}, {\"8\", \"banana\"}, {\"a\", \"apple\"}}) == false);\n    assert(check_dict_case({{\"Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}) == false);\n    assert(check_dict_case({{\"STATE\", \"NC\"}, {\"ZIP\", \"12345\"}}) == true);\n\n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/96", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// Helper function to check if a number is prime\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    for (int i = 2; i * i <= num; ++i) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\n// Function to generate a vector of prime numbers less than n\nvector<int> count_up_to(int n) {\n    vector<int> primes;\n    for (int i = 2; i < n; ++i) {\n        if (is_prime(i)) {\n            primes.push_back(i);\n        }\n    }\n    return primes;\n}\n\n// Function to test the count_up_to function\nvoid test_count_up_to() {\n    assert(count_up_to(5) == vector<int>({2, 3}));\n    assert(count_up_to(11) == vector<int>({2, 3, 5, 7}));\n    assert(count_up_to(0).empty());\n    assert(count_up_to(20) == vector<int>({2, 3, 5, 7, 11, 13, 17, 19}));\n    assert(count_up_to(1).empty());\n    assert(count_up_to(18) == vector<int>({2, 3, 5, 7, 11, 13, 17}));\n\n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/97", "generation": "#include <iostream>\nusing namespace std;\n\nint multiply(int a, int b) {\n    // Extract the unit digits of both numbers\n    int unitDigitA = abs(a % 10);\n    int unitDigitB = abs(b % 10);\n\n    // Return the product of the unit digits\n    return unitDigitA * unitDigitB;\n}\n\n"}
{"task_id": "CPP/98", "generation": "#include <iostream>\n#include <string>\n\n// Function to check if a character is an uppercase vowel\nbool is_upper_vowel(char c) {\n    return (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U');\n}\n\nint count_upper(const std::string& s) {\n    int count = 0;\n    for (size_t i = 0; i < s.length(); i += 2) { // Iterate over even indices\n        if (is_upper_vowel(s[i])) {\n            count++;\n        }\n    }\n    return count;\n}\n\n// Function to test the count_upper function with some examples\nvoid test_count_upper() {\n    std::cout << \"count_upper(\\\"aBCdEf\\\") returns: \" << count_upper(\"aBCdEf\") << \" (Expected: 1)\" << std::endl;\n    std::cout << \"count_upper(\\\"abcdefg\\\") returns: \" << count_upper(\"abcdefg\") << \" (Expected: 0)\" << std::endl;\n    std::cout << \"count_upper(\\\"dBBE\\\") returns: \" << count_upper(\"dBBE\") << \" (Expected: 0)\" << std::endl;\n}\n\n"}
{"task_id": "CPP/99", "generation": "#include <iostream>\n#include <cmath>\n#include <string>\n\nusing namespace std;\n\nint closest_integer(string value) {\n    // Convert string to double\n    double num = stod(value);\n    \n    // Determine the nearest integers\n    int lower_int = static_cast<int>(floor(num));\n    int upper_int = static_cast<int>(ceil(num));\n    \n    // Check if the number is exactly halfway between two integers\n    if (num - lower_int == 0.5) {\n        return num > 0 ? upper_int : lower_int;\n    } else if (upper_int - num == 0.5) {\n        return num < 0 ? lower_int : upper_int;\n    }\n    \n    // If not exactly halfway, use the standard rounding\n    double fractional_part = num - static_cast<int>(num);\n    if (fractional_part >= 0.5 || (fractional_part > 0 && num < 0)) {\n        return ceil(num);\n    } else {\n        return floor(num);\n    }\n}\n\n"}
{"task_id": "CPP/100", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Function to make a pile of n levels of stones\nvector<int> make_a_pile(int n) {\n    vector<int> result;\n    int current_stones = n;\n\n    for (int i = 0; i < n; ++i) {\n        // If the number of stones in the previous level is odd, add the next odd number.\n        if (current_stones % 2 != 0) {\n            current_stones += 2;\n        }\n        // If the number of stones in the previous level is even, add the next even number.\n        else {\n            current_stones += 1; // Since we are adding one to an even number, it becomes odd\n            current_stones += 1; // Adding another 1 to make it even again\n        }\n        result.push_back(current_stones);\n    }\n\n    return result;\n}\n\n// Function to print the vector for testing purposes\nvoid print_vector(const vector<int>& vec) {\n    for (int i = 0; i < vec.size(); ++i) {\n        cout << vec[i] << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/101", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nvector<string> words_string(string s) {\n    vector<string> result;\n    stringstream ss(s);\n    string word;\n\n    while (getline(ss, word, ',')) {  // Split by comma first\n        stringstream ws(word);  // Create a new stringstream for each word\n        while (ws >> word) {  // Split the word by spaces\n            if (!word.empty()) {\n                result.push_back(word);\n            }\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/102", "generation": "#include <iostream>\nusing namespace std;\n\nint choose_num(int x, int y) {\n    // Check if the upper bound is less than the lower bound\n    if (y < x) {\n        return -1;\n    }\n\n    // Start from the end of the range and check for the largest even number\n    for (int i = y; i >= x; --i) {\n        if (i % 2 == 0) {\n            return i;\n        }\n    }\n\n    // If no even number is found, return -1\n    return -1;\n}\n\n// Function to test the choose_num function with some examples\nvoid test() {\n    cout << \"choose_num(12, 15): \" << choose_num(12, 15) << endl; // Should output 14\n    cout << \"choose_num(13, 12): \" << choose_num(13, 12) << endl; // Should output -1\n    cout << \"choose_num(8, 10): \" << choose_num(8, 10) << endl;   // Should output 10\n    cout << \"choose_num(7, 7): \" << choose_num(7, 7) << endl;     // Should output -1 (since 7 is not even)\n}\n\n"}
{"task_id": "CPP/103", "generation": "#include <stdio.h>\n#include <cmath>\n#include <string>\n\nusing namespace std;\n\nstring rounded_avg(int n, int m) {\n    // Check if n is greater than m\n    if (n > m) {\n        return \"-1\";\n    }\n\n    // Calculate the sum of integers from n to m\n    long long sum = 0;\n    for (int i = n; i <= m; ++i) {\n        sum += i;\n    }\n\n    // Calculate the average and round it down\n    int avg = floor((double)sum / (m - n + 1));\n\n    // Convert the rounded average to binary\n    string binary = \"\";\n    if (avg == 0) {\n        binary = \"0\";\n    } else {\n        while (avg > 0) {\n            binary = to_string(avg % 2) + binary;\n            avg /= 2;\n        }\n    }\n\n    return binary;\n}\n\n"}
{"task_id": "CPP/104", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n// Helper function to check if a number has any even digit\nbool has_even_digit(int num) {\n    while (num > 0) {\n        int digit = num % 10;\n        if (digit % 2 == 0) return true; // If any digit is even, return true\n        num /= 10;\n    }\n    return false; // No even digits found\n}\n\n// Function to return a sorted vector of all elements that have no even digit\nvector<int> unique_digits(vector<int> x) {\n    vector<int> result;\n\n    // Filter out numbers with any even digit\n    for (int num : x) {\n        if (!has_even_digit(num)) {\n            result.push_back(num);\n        }\n    }\n\n    // Sort the resulting vector in increasing order\n    sort(result.begin(), result.end());\n\n    return result;\n}\n\n// Function to test the unique_digits function\nvoid test() {\n    vector<int> x1 = {15, 33, 1422, 1};\n    vector<int> expected1 = {1, 15, 33};\n    assert(unique_digits(x1) == expected1);\n\n    vector<int> x2 = {152, 323, 1422, 10};\n    vector<int> expected2 = {};\n    assert(unique_digits(x2) == expected2);\n\n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/105", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to map numbers 1-9 to their names\nstd::map<int, string> number_to_name = {\n    {1, \"One\"}, {2, \"Two\"}, {3, \"Three\"}, {4, \"Four\"},\n    {5, \"Five\"}, {6, \"Six\"}, {7, \"Seven\"}, {8, \"Eight\"}, {9, \"Nine\"}\n};\n\nvector<string> by_length(vector<int> arr) {\n    // Step 1: Filter out numbers not between 1 and 9\n    vector<int> filtered;\n    for (int num : arr) {\n        if (num >= 1 && num <= 9) {\n            filtered.push_back(num);\n        }\n    }\n\n    // Step 2: Sort the remaining numbers in ascending order\n    sort(filtered.begin(), filtered.end());\n\n    // Step 3: Reverse the sorted vector\n    reverse(filtered.begin(), filtered.end());\n\n    // Step 4: Replace each digit with its corresponding name\n    vector<string> result;\n    for (int num : filtered) {\n        result.push_back(number_to_name[num]);\n    }\n\n    return result;\n}\n\n// Function to test the solution\nvoid check() {\n    vector<int> arr1 = {2, 1, 1, 4, 5, 8, 2, 3};\n    vector<string> expected1 = {\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"};\n    assert(by_length(arr1) == expected1);\n\n    vector<int> arr2 = {};\n    vector<string> expected2 = {};\n    assert(by_length(arr2) == expected2);\n\n    vector<int> arr3 = {1, -1, 55};\n    vector<string> expected3 = {\"One\"};\n    assert(by_length(arr3) == expected3);\n\n    printf(\"All tests passed.\\n\");\n}\n\n"}
{"task_id": "CPP/106", "generation": "#include <iostream>\n#include <vector>\n\n// Function to calculate factorial of a number\nint factorial(int n) {\n    int result = 1;\n    for (int i = 2; i <= n; ++i) {\n        result *= i;\n    }\n    return result;\n}\n\n// Function to calculate the sum of numbers from 1 to n\nint sum_to_n(int n) {\n    return (n * (n + 1)) / 2;\n}\n\nvector<int> f(int n) {\n    vector<int> result(n);\n    \n    for (int i = 0; i < n; ++i) {\n        int index = i + 1; // Since i starts from 1\n        if ((index % 2) == 0) { // Check if the index is even\n            result[i] = factorial(index);\n        } else { // If the index is odd\n            result[i] = sum_to_n(index);\n        }\n    }\n    \n    return result;\n}\n\n// Function to check the correctness of the function f\nvoid check() {\n    vector<int> expected = {1, 2, 6, 24, 15};\n    vector<int> result = f(5);\n    if (result == expected) {\n        std::cout << \"Correct!\" << std::endl;\n    } else {\n        std::cout << \"Incorrect. Expected: \";\n        for (int num : expected) {\n            std::cout << num << \" \";\n        }\n        std::cout << \"\\nGot: \";\n        for (int num : result) {\n            std::cout << num << \" \";\n        }\n        std::cout << std::endl;\n    }\n}\n\n"}
{"task_id": "CPP/107", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Function to generate and count even and odd palindromes up to n\nvector<int> even_odd_palindrome(int n) {\n    vector<int> result(2, 0); // Initialize with two elements: [even_count, odd_count]\n    \n    // Single digit numbers are all palindromes\n    for (int i = 1; i <= 9; ++i) {\n        if (i % 2 == 0) {\n            ++result[0]; // Even count\n        } else {\n            ++result[1]; // Odd count\n        }\n    }\n\n    // Generate and check two-digit palindromes\n    for (int i = 1; i <= 9; ++i) {\n        int palindrome = i * 11;\n        if (palindrome > n) break;\n        if (palindrome % 2 == 0) {\n            ++result[0]; // Even count\n        } else {\n            ++result[1]; // Odd count\n        }\n    }\n\n    // Generate and check three-digit palindromes\n    for (int i = 1; i <= 9; ++i) {\n        for (int j = 0; j <= 9; ++j) {\n            int palindrome = i * 100 + j * 10 + i;\n            if (palindrome > n) break;\n            if (palindrome % 2 == 0) {\n                ++result[0]; // Even count\n            } else {\n                ++result[1]; // Odd count\n            }\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/108", "generation": "#include <iostream>\n#include <vector>\n\nint count_nums(const std::vector<int>& n) {\n    int count = 0;\n    \n    for (int num : n) {\n        int sum_of_digits = 0;\n        \n        // Handle negative numbers\n        if (num < 0) {\n            num = -num; // Make the number positive to process digits\n            bool is_first_digit_negative = true;\n            \n            while (num > 0) {\n                int digit = num % 10;\n                sum_of_digits += (is_first_digit_negative ? -digit : digit);\n                \n                if (!is_first_digit_negative && digit != 0) break; // Stop after the first non-zero positive digit\n                is_first_digit_negative = false;\n                num /= 10;\n            }\n        } else {\n            while (num > 0) {\n                sum_of_digits += num % 10;\n                num /= 10;\n            }\n        }\n        \n        if (sum_of_digits > 0) {\n            count++;\n        }\n    }\n    \n    return count;\n}\n\n"}
{"task_id": "CPP/109", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool move_one_ball(vector<int> arr) {\n    if (arr.empty()) return true; // An empty vector is trivially sorted\n\n    int n = arr.size();\n    for (int i = 0; i < n - 1; ++i) {\n        if (arr[i] > arr[i + 1]) {\n            // Check if shifting from this point makes the array non-decreasing\n            bool can_sort = true;\n            for (int j = i + 1, k = 0; j < n && k <= i; ++j, ++k) {\n                if (arr[j] < arr[k]) {\n                    can_sort = false;\n                    break;\n                }\n            }\n            // Check the last element with the first element after a full rotation\n            if (can_sort && arr[0] >= arr[n - 1]) return true;\n        }\n    }\n\n    return false; // If no valid shift point is found, return false\n}\n\n"}
{"task_id": "CPP/110", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring exchange(vector<int> lst1, vector<int> lst2) {\n    // Count the number of odd elements in lst1\n    int oddCount = 0;\n    for (int num : lst1) {\n        if (num % 2 != 0) {\n            oddCount++;\n        }\n    }\n\n    // Count the number of even elements in lst2\n    int evenCount = 0;\n    for (int num : lst2) {\n        if (num % 2 == 0) {\n            evenCount++;\n        }\n    }\n\n    // Check if there are enough even numbers in lst2 to replace all odd numbers in lst1\n    return (evenCount >= oddCount) ? \"YES\" : \"NO\";\n}\n\n// Function to test the exchange function with provided examples\nvoid testExchange() {\n    cout << exchange({1, 2, 3, 4}, {1, 2, 3, 4}) << endl; // Should output \"YES\"\n    cout << exchange({1, 2, 3, 4}, {1, 5, 3, 4}) << endl; // Should output \"NO\"\n}\n\n"}
{"task_id": "CPP/111", "generation": "#include <iostream>\n#include <string>\n#include <map>\nusing namespace std;\n\nmap<char, int> histogram(string test) {\n    map<char, int> letterCount;\n    if (test.empty()) return letterCount; // Return an empty map for an empty string\n\n    // Split the input string by spaces and count occurrences of each letter\n    size_t start = 0;\n    while (start < test.size()) {\n        size_t end = test.find(' ', start);\n        if (end == string::npos) {\n            end = test.size();\n        }\n        string word = test.substr(start, end - start);\n        ++letterCount[word[0]];\n        start = end + 1;\n    }\n\n    // Find the maximum count\n    int maxCount = 0;\n    for (const auto& pair : letterCount) {\n        if (pair.second > maxCount) {\n            maxCount = pair.second;\n        }\n    }\n\n    // Create a result map with only letters that have the highest count\n    map<char, int> result;\n    for (const auto& pair : letterCount) {\n        if (pair.second == maxCount) {\n            result[pair.first] = pair.second;\n        }\n    }\n\n    return result;\n}\n\n// Function to test the histogram function with provided examples\nvoid check() {\n    cout << \"Histogram of 'a b c': \";\n    for (const auto& pair : histogram(\"a b c\")) {\n        cout << \"{\" << pair.first << \", \" << pair.second << \"} \";\n    }\n    cout << endl;\n\n    cout << \"Histogram of 'a b b a': \";\n    for (const auto& pair : histogram(\"a b b a\")) {\n        cout << \"{\" << pair.first << \", \" << pair.second << \"} \";\n    }\n    cout << endl;\n\n    cout << \"Histogram of 'a b c a b': \";\n    for (const auto& pair : histogram(\"a b c a b\")) {\n        cout << \"{\" << pair.first << \", \" << pair.second << \"} \";\n    }\n    cout << endl;\n\n    cout << \"Histogram of 'b b b b a': \";\n    for (const auto& pair : histogram(\"b b b b a\")) {\n        cout << \"{\" << pair.first << \", \" << pair.second << \"} \";\n    }\n    cout << endl;\n\n    cout << \"Histogram of '': \";\n    for (const auto& pair : histogram(\"\")) {\n        cout << \"{\" << pair.first << \", \" << pair.second << \"} \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/112", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to check if a string is a palindrome\nbool is_palindrome(const string& str) {\n    int left = 0;\n    int right = str.size() - 1;\n    \n    while (left < right) {\n        if (str[left] != str[right]) {\n            return false;\n        }\n        ++left;\n        --right;\n    }\n    return true;\n}\n\n// Function to reverse delete characters and check palindrome\nvector<string> reverse_delete(string s, string c) {\n    // Remove all characters in s that are present in c\n    for (char ch : c) {\n        s.erase(remove(s.begin(), s.end(), ch), s.end());\n    }\n    \n    // Check if the resulting string is a palindrome\n    bool result = is_palindrome(s);\n    \n    // Return the modified string and the boolean result\n    return {s, to_string(result)};\n}\n\n"}
{"task_id": "CPP/113", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<string> odd_count(vector<string> lst) {\n    vector<string> result;\n    \n    for (const auto& str : lst) {\n        int num_odds = 0;\n        \n        // Count the number of odd digits in the current string\n        for (char c : str) {\n            if ((c - '0') % 2 != 0) {\n                num_odds++;\n            }\n        }\n        \n        // Construct the result string\n        string output = \"the number of odd elements \";\n        output += to_string(num_odds);\n        output += \"n the str\";\n        output += to_string(num_odds);\n        output += \"ng \";\n        output += to_string(num_odds);\n        output += \" of the \";\n        output += to_string(num_odds);\n        output += \"nput.\";\n        \n        result.push_back(output);\n    }\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/114", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nlong long minSubArraySum(vector<long long> nums) {\n    if (nums.empty()) return 0; // Handle empty vector case\n\n    long long current_min = nums[0];\n    long long global_min = nums[0];\n\n    for (size_t i = 1; i < nums.size(); ++i) {\n        current_min = min(nums[i], current_min + nums[i]);\n        global_min = min(global_min, current_min);\n    }\n\n    return global_min;\n}\n\n"}
{"task_id": "CPP/115", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint max_fill(vector<vector<int>> grid, int capacity) {\n    int total_lowerings = 0;\n    \n    // Iterate over each well (row in the grid)\n    for (const auto& row : grid) {\n        int water_units = 0;\n        \n        // Count the number of 1s in the current row\n        for (int unit : row) {\n            if (unit == 1) {\n                water_units++;\n            }\n        }\n        \n        // Calculate the number of times buckets need to be lowered for this well\n        total_lowerings += (water_units + capacity - 1) / capacity;\n    }\n    \n    return total_lowerings;\n}\n\n"}
{"task_id": "CPP/116", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to count the number of ones in the binary representation of an integer\nint count_ones(int n) {\n    int count = 0;\n    while (n > 0) {\n        count += n & 1; // Check if the least significant bit is set\n        n >>= 1; // Right shift to check the next bit\n    }\n    return count;\n}\n\n// Comparator function for sorting based on number of ones and then by decimal value\nbool custom_sort(int a, int b) {\n    int ones_a = count_ones(a);\n    int ones_b = count_ones(b);\n\n    if (ones_a == ones_b) {\n        return a < b; // Sort by decimal value if the number of ones is the same\n    }\n    return ones_a < ones_b; // Otherwise, sort by number of ones\n}\n\nvector<int> sort_array(vector<int> arr) {\n    std::sort(arr.begin(), arr.end(), custom_sort);\n    return arr;\n}\n\n"}
{"task_id": "CPP/117", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\n// Helper function to count consonants in a word\nint count_consonants(const string& word) {\n    int count = 0;\n    for (char ch : word) {\n        if (isalpha(ch)) { // Check if the character is an alphabet letter\n            char lower_ch = tolower(ch); // Convert to lowercase to simplify comparison\n            if (lower_ch != 'a' && lower_ch != 'e' && lower_ch != 'i' && lower_ch != 'o' && lower_ch != 'u') {\n                count++;\n            }\n        }\n    }\n    return count;\n}\n\n// Main function to select words with exactly n consonants\nvector<string> select_words(string s, int n) {\n    vector<string> result;\n    // Split the string into words based on spaces\n    stringstream ss(s);\n    string word;\n    while (getline(ss, word, ' ')) {\n        if (count_consonants(word) == n) {\n            result.push_back(word);\n        }\n    }\n    return result;\n}\n\n// Function to test the select_words function\nvoid test_select_words() {\n    assert(select_words(\"Mary had a little lamb\", 4) == vector<string>({\"little\"}));\n    assert(select_words(\"Mary had a little lamb\", 3) == vector<string>({\"Mary\", \"lamb\"}));\n    assert(select_words(\"simple white space\", 2) == vector<string>());\n    assert(select_words(\"Hello world\", 4) == vector<string>({\"world\"}));\n    assert(select_words(\"Uncle sam\", 3) == vector<string>({\"Uncle\"}));\n\n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/118", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_vowel(char c) {\n    return c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' ||\n           c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U';\n}\n\nbool is_consonant(char c) {\n    return !is_vowel(c) && isalpha(c);\n}\n\nstring get_closest_vowel(string word) {\n    int n = word.length();\n    \n    for (int i = n - 2; i >= 0; --i) { // Start from the second last character\n        if (is_consonant(word[i]) && is_vowel(word[i + 1]) && is_consonant(word[i + 2])) {\n            return string(1, word[i + 1]);\n        }\n    }\n\n    return \"\"; // Return empty string if no such vowel found\n}\n\n"}
{"task_id": "CPP/119", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Helper function to check if a given string is balanced\nbool is_balanced(const string& s) {\n    int balance = 0;\n    for (char c : s) {\n        if (c == '(') {\n            ++balance;\n        } else if (c == ')') {\n            --balance;\n            if (balance < 0) {\n                return false; // More closing parentheses than opening\n            }\n        }\n    }\n    return balance == 0; // Balanced if no imbalance and all parentheses are matched\n}\n\n// Main function to check if we can make a good string by concatenating two strings in some order\nstring match_parens(vector<string> lst) {\n    // Check both possible concatenations\n    if (is_balanced(lst[0] + lst[1]) || is_balanced(lst[1] + lst[0])) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\n\n"}
{"task_id": "CPP/120", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n// Function to return the maximum k numbers from the vector arr\nvector<int> maximum(vector<int> arr, int k) {\n    // Use nth_element to partially sort the first k elements in descending order\n    nth_element(arr.begin(), arr.begin() + k - 1, arr.end(), greater<int>());\n    \n    // Create a new vector to store the top k elements\n    vector<int> result;\n    \n    // Copy the top k elements into the result vector\n    for (int i = 0; i < k; ++i) {\n        result.push_back(arr[i]);\n    }\n    \n    // Sort the result vector in ascending order\n    sort(result.begin(), result.end());\n    \n    return result;\n}\n\n// Function to print the vector\nvoid printVector(const vector<int>& vec) {\n    for (int num : vec) {\n        cout << num << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/121", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Function to calculate the sum of odd elements at even indices\nint solution(vector<int> lst) {\n    int sum = 0;\n    // Iterate through the list, starting from index 0 (even position)\n    for (size_t i = 0; i < lst.size(); i += 2) {\n        if (lst[i] % 2 != 0) { // Check if the element is odd\n            sum += lst[i];     // Add it to the sum\n        }\n    }\n    return sum;\n}\n\n// Function to test the solution with provided examples\nvoid check() {\n    cout << \"solution({5, 8, 7, 1}) = \" << solution({5, 8, 7, 1}) << \" (Expected: 12)\" << endl;\n    cout << \"solution({3, 3, 3, 3, 3}) = \" << solution({3, 3, 3, 3, 3}) << \" (Expected: 9)\" << endl;\n    cout << \"solution({30, 13, 24, 321}) = \" << solution({30, 13, 24, 321}) << \" (Expected: 0)\" << endl;\n}\n\n"}
{"task_id": "CPP/122", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint add_elements(vector<int> arr, int k) {\n    int sum = 0;\n    \n    // Iterate through the first k elements of the vector\n    for (int i = 0; i < k; ++i) {\n        // Check if the element has at most two digits\n        if (arr[i] >= 0 && arr[i] <= 99) {\n            sum += arr[i];\n        }\n    }\n    \n    return sum;\n}\n\n// Function to test the add_elements function with provided data points\nvoid test_function() {\n    vector<int> arr1 = {111, 21, 3, 4000, 5, 6, 7, 8, 9};\n    int k1 = 4;\n    cout << \"Test Case 1: Expected Output: 24, Actual Output: \" << add_elements(arr1, k1) << endl;\n\n    vector<int> arr2 = {10, 23, 56, 78, 90};\n    int k2 = 5;\n    cout << \"Test Case 2: Expected Output: 240, Actual Output: \" << add_elements(arr2, k2) << endl;\n\n    vector<int> arr3 = {100, 200, 300, 400};\n    int k3 = 4;\n    cout << \"Test Case 3: Expected Output: 0, Actual Output: \" << add_elements(arr3, k3) << endl;\n\n    vector<int> arr4 = {1, 2, 3, 4, 5, 6, 7};\n    int k4 = 7;\n    cout << \"Test Case 4: Expected Output: 21, Actual Output: \" << add_elements(arr4, k4) << endl;\n\n    vector<int> arr5 = {99, 88, 77, 66, 55};\n    int k5 = 3;\n    cout << \"Test Case 5: Expected Output: 250, Actual Output: \" << add_elements(arr5, k5) << endl;\n}\n\n"}
{"task_id": "CPP/123", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> get_odd_collatz(int n) {\n    vector<int> result;\n    \n    // Generate the Collatz sequence and collect odd numbers\n    while (n != 1) {\n        if (n % 2 == 1) {  // Check if n is odd\n            result.push_back(n);\n        }\n        n = (n % 2 == 0) ? n / 2 : 3 * n + 1;  // Apply Collatz rules\n    }\n    \n    // Add the last number, which is always 1 and is odd\n    result.push_back(1);\n\n    // Sort the vector in increasing order\n    sort(result.begin(), result.end());\n    \n    return result;\n}\n\n// Function to test the get_odd_collatz function with some examples\nvoid test_get_odd_collatz() {\n    cout << \"Testing get_odd_collatz...\" << endl;\n    vector<int> result1 = get_odd_collatz(5);\n    for (int num : result1) {\n        cout << num << \" \";\n    }\n    cout << endl;\n\n    vector<int> result2 = get_odd_collatz(7);\n    for (int num : result2) {\n        cout << num << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/124", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\nusing namespace std;\n\nbool valid_date(string date) {\n    // Check if the date string is empty\n    if (date.empty()) {\n        return false;\n    }\n\n    // Define days in each month for non-leap years\n    int days_in_month[12] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\n\n    // Use stringstream to parse the date string\n    stringstream ss(date);\n    int month, day, year;\n    char dash1, dash2;\n\n    if (!(ss >> month >> dash1 >> day >> dash2 >> year)) {\n        return false; // Incorrect format or invalid characters\n    }\n\n    // Validate the format (mm-dd-yyyy)\n    if (dash1 != '-' || dash2 != '-') {\n        return false;\n    }\n\n    // Validate the month\n    if (month < 1 || month > 12) {\n        return false;\n    }\n\n    // Validate the day based on the month and year\n    if (day < 1 || day > days_in_month[month - 1]) {\n        return false;\n\n        // Check for leap year in February\n    } else if (month == 2 && day > 29) {\n        return false;\n    }\n\n    // Leap year check\n    bool is_leap_year = (year % 4 == 0 && (year % 100 != 0 || year % 400 == 0));\n    if (month == 2 && day == 29 && !is_leap_year) {\n        return false;\n    }\n\n    // If all checks pass, the date is valid\n    return true;\n}\n\n"}
{"task_id": "CPP/125", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nvector<string> split_words(string txt) {\n    // Check for whitespace splitting\n    size_t pos = txt.find(' ');\n    if (pos != string::npos) {\n        vector<string> result;\n        while ((pos = txt.find(' ')) != string::npos) {\n            result.push_back(txt.substr(0, pos));\n            txt.erase(0, pos + 1);\n        }\n        result.push_back(txt); // Add the last word\n        return result;\n    }\n\n    // Check for comma splitting\n    size_t pos_comma = txt.find(',');\n    if (pos_comma != string::npos) {\n        vector<string> result;\n        while ((pos_comma = txt.find(',')) != string::npos) {\n            result.push_back(txt.substr(0, pos_comma));\n            txt.erase(0, pos_comma + 1);\n        }\n        result.push_back(txt); // Add the last word\n        return result;\n    }\n\n    // Count lowercase letters with odd order in the alphabet\n    int count = 0;\n    for (char c : txt) {\n        if (islower(c)) {\n            count += (c - 'a') % 2 == 1 ? 1 : 0;\n        }\n    }\n    return {to_string(count)};\n}\n\n// Function to test the split_words function\nvoid test_split_words() {\n    vector<string> result;\n\n    // Test case with whitespace\n    result = split_words(\"Hello world!\");\n    for (const auto& word : result) {\n        cout << word << endl;\n    }\n\n    // Test case with comma\n    result = split_words(\"Hello,world!\");\n    for (const auto& word : result) {\n        cout << word << endl;\n    }\n\n    // Test case without whitespace or comma\n    result = split_words(\"abcdef\");\n    for (const auto& word : result) {\n        cout << word << endl;\n    }\n}\n\n"}
{"task_id": "CPP/126", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nbool is_sorted(vector<int> lst) {\n    // Check if the list is already sorted or not\n    bool ascending = true;\n    for (int i = 0; i < lst.size() - 1 && ascending; ++i) {\n        if (lst[i] > lst[i + 1]) {\n            ascending = false;\n        }\n    }\n\n    // If the list is not sorted, return false\n    if (!ascending) return false;\n\n    // Check for any number appearing more than twice\n    int prev_num = lst[0];\n    int count = 1;\n    for (int i = 1; i < lst.size(); ++i) {\n        if (lst[i] == prev_num) {\n            count++;\n            if (count > 2) return false;\n        } else {\n            prev_num = lst[i];\n            count = 1;\n        }\n    }\n\n    // If all checks pass, the list is sorted and no number appears more than twice\n    return true;\n}\n\n"}
{"task_id": "CPP/127", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\n// Function to check if a number is prime\nbool isPrime(int n) {\n    if (n <= 1) return false;\n    if (n == 2) return true;\n    if (n % 2 == 0) return false;\n    for (int i = 3; i * i <= n; i += 2) {\n        if (n % i == 0)\n            return false;\n    }\n    return true;\n}\n\n// Function to find the intersection of two intervals and check if its length is prime\nstring intersection(vector<int> interval1, vector<int> interval2) {\n    int start = max(interval1[0], interval2[0]);\n    int end = min(interval1[1], interval2[1]);\n\n    // If there's no intersection, return \"NO\"\n    if (start > end)\n        return \"NO\";\n\n    // Calculate the length of the intersection\n    int length = end - start + 1;\n\n    // Check if the length is a prime number\n    if (isPrime(length))\n        return \"YES\";\n    else\n        return \"NO\";\n}\n\n"}
{"task_id": "CPP/128", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint prod_signs(vector<int> arr) {\n    if (arr.empty()) {\n        return -32768;\n    }\n\n    int product_of_signs = 1;\n    int sum_of_magnitudes = 0;\n\n    for (int num : arr) {\n        // Calculate the product of signs\n        if (num > 0) {\n            product_of_signs *= 1; // Positive numbers contribute +1 to the sign product\n        } else if (num < 0) {\n            product_of_signs *= -1; // Negative numbers contribute -1 to the sign product\n        }\n\n        // Calculate the sum of magnitudes\n        sum_of_magnitudes += abs(num);\n    }\n\n    return product_of_signs * sum_of_magnitudes;\n}\n\n// Function to test the prod_signs function with provided examples\nvoid check() {\n    cout << \"prod_signs({1, 2, 2, -4}) == \" << prod_signs({1, 2, 2, -4}) << endl; // Should output -9\n    cout << \"prod_signs({0, 1}) == \" << prod_signs({0, 1}) << endl;               // Should output 0\n    cout << \"prod_signs({}) == \" << prod_signs({}) << endl;                       // Should output -32768\n}\n\n"}
{"task_id": "CPP/129", "generation": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <tuple>\n\nusing namespace std;\n\n// Define a structure to hold the current state (position, value list, steps taken)\nstruct State {\n    int x, y;\n    vector<int> path;\n    \n    // Constructor for initial state\n    State(int x, int y) : x(x), y(y), path({grid[x][y]}) {}\n};\n\n// Comparator for priority queue to prioritize paths with smaller values first\nbool operator<(const State& a, const State& b) {\n    return a.path > b.path; // Min-heap based on lexicographical order of paths\n}\n\nvector<int> minPath(vector<vector<int>> grid, int k) {\n    int N = grid.size();\n    \n    // Priority queue to explore the minimum path first\n    priority_queue<State> pq;\n    \n    // Initialize the priority queue with all starting states (all cells)\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            pq.push(State(i, j));\n        }\n    }\n    \n    while (!pq.empty()) {\n        State current = pq.top();\n        pq.pop();\n        \n        // If the path length is k, return the result\n        if (current.path.size() == k) {\n            return current.path;\n        }\n        \n        // Explore all possible moves (up, down, left, right)\n        vector<pair<int, int>> directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n        for (auto& dir : directions) {\n            int newX = current.x + dir.first;\n            int newY = current.y + dir.second;\n            \n            // Check if the new position is within bounds\n            if (newX >= 0 && newX < N && newY >= 0 && newY < N) {\n                vector<int> newPath = current.path;\n                newPath.push_back(grid[newX][newY]);\n                \n                pq.push(State(newX, newY));\n            }\n        }\n    }\n    \n    // If no path of length k is found (should not happen given the problem constraints)\n    return {};\n}\n\n"}
{"task_id": "CPP/130", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Function to compute the nth element of the Tribonacci sequence\nint tribonacci(int n) {\n    if (n == 1) return 3;\n    else if (n % 2 == 0) return 1 + n / 2;\n    else {\n        // Base cases for the first few odd numbers\n        if (n == 3) return 8; // tri(3) = tri(2) + tri(1) + tri(4)\n        else if (n == 5) return 19; // tri(5) = tri(4) + tri(3) + tri(6)\n\n        // Recursive call for odd n\n        int a = tribonacci(n - 1);\n        int b = tribonacci(n - 2);\n        int c = tribonacci(n + 1);\n\n        return a + b + c;\n    }\n}\n\n// Function to generate the first n+1 elements of the Tribonacci sequence\nvector<int> tri(int n) {\n    vector<int> result;\n\n    // Compute and store each element in the sequence up to n\n    for (int i = 0; i <= n; ++i) {\n        result.push_back(tribonacci(i));\n    }\n\n    return result;\n}\n\n// Function to print the elements of a vector\nvoid printVector(const vector<int>& vec) {\n    for (int num : vec) {\n        cout << num << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/131", "generation": "#include <iostream>\nusing namespace std;\n\nint digits(int n) {\n    int product = 1;\n    bool hasOddDigit = false;\n\n    while (n > 0) {\n        int digit = n % 10; // Get the last digit of n\n        if (digit % 2 != 0) { // Check if the digit is odd\n            product *= digit; // Multiply it to the product\n            hasOddDigit = true;\n        }\n        n /= 10; // Remove the last digit from n\n    }\n\n    return hasOddDigit ? product : 0;\n}\n\n"}
{"task_id": "CPP/132", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_nested(string str) {\n    int balance = 0;\n    bool hasNested = false;\n\n    for (char ch : str) {\n        if (ch == '[') {\n            balance++;\n            // Check if there's a nested bracket before this one\n            if (balance > 1 && !hasNested) {\n                hasNested = true;\n            }\n        } else if (ch == ']') {\n            balance--;\n        }\n\n        // If the balance goes negative, it means we have an unmatched closing bracket\n        if (balance < 0) {\n            return false;\n        }\n    }\n\n    // The string must be balanced and contain at least one nested pair\n    return hasNested && balance == 0;\n}\n\n"}
{"task_id": "CPP/133", "generation": "#include <iostream>\n#include <cmath>\n#include <vector>\n\nusing namespace std;\n\nint sum_squares(vector<float> lst) {\n    int sum = 0;\n    \n    for (float num : lst) {\n        // Round to the nearest upper integer\n        float ceil_num = ceil(num);\n        \n        // Add the square of the rounded number to the sum\n        sum += static_cast<int>(ceil_num * ceil_num);\n    }\n    \n    return sum;\n}\n\n"}
{"task_id": "CPP/134", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool check_if_last_char_is_a_letter(string txt) {\n    // Check if the string is empty\n    if (txt.empty()) return false;\n    \n    // Get the last character of the string\n    char lastChar = txt.back();\n    \n    // If the last character is a space, get the second-to-last character\n    if (lastChar == ' ') {\n        if (isalpha(txt[txt.length() - 2])) {\n            return true;\n        } else {\n            return false;\n        }\n    } else {\n        return false; // The last character is not a space, so it's part of a word\n    }\n}\n\n"}
{"task_id": "CPP/135", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint can_arrange(vector<int> arr) {\n    int n = arr.size();\n    \n    // Iterate from the second last element to the first element\n    for (int i = n - 2; i >= 0; --i) {\n        if (arr[i] > arr[i + 1]) {\n            return i;\n        }\n    }\n    \n    // If no such element is found, return -1\n    return -1;\n}\n\n// Function to test the can_arrange function with provided examples\nvoid check() {\n    cout << \"can_arrange({1,2,4,3,5}) = \" << can_arrange({1, 2, 4, 3, 5}) << endl; // Should output 3\n    cout << \"can_arrange({1,2,3}) = \" << can_arrange({1, 2, 3}) << endl;          // Should output -1\n}\n\n"}
{"task_id": "CPP/136", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> largest_smallest_integers(vector<int> lst) {\n    int max_negative = 0;\n    int min_positive = 0;\n\n    // Check if there are any negative integers in the list\n    bool has_negative = false;\n    for (int num : lst) {\n        if (num < 0) {\n            has_negative = true;\n            if (max_negative == 0 || num > max_negative) {\n                max_negative = num;\n            }\n        } else if (num > 0) {\n            min_positive = num;\n            break; // Once we find the first positive number, no need to continue\n        }\n    }\n\n    // If there are no negative integers, set max_negative to 0\n    if (!has_negative) {\n        max_negative = 0;\n    }\n\n    return {max_negative, min_positive};\n}\n\n// Function to test the implementation with provided examples\nvoid check() {\n    vector<int> lst1 = {2, 4, 1, 3, 5, 7};\n    vector<int> result1 = largest_smallest_integers(lst1);\n    cout << \"Test Case 1: {\" << result1[0] << \", \" << result1[1] << \"}\" << endl;\n\n    vector<int> lst2 = {};\n    vector<int> result2 = largest_smallest_integers(lst2);\n    cout << \"Test Case 2: {\" << result2[0] << \", \" << result2[1] << \"}\" << endl;\n\n    vector<int> lst3 = {0};\n    vector<int> result3 = largest_smallest_integers(lst3);\n    cout << \"Test Case 3: {\" << result3[0] << \", \" << result3[1] << \"}\" << endl;\n}\n\n"}
{"task_id": "CPP/137", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <boost/any.hpp>\n\n// Function to compare two boost::any types and return the larger one.\nboost::any compare_one(boost::any a, boost::any b) {\n    // Convert both values to strings for comparison\n    std::string strA = any_cast<std::string>(a);\n    std::string strB = any_cast<std::string>(b);\n\n    // Replace commas with dots in the string representations of numbers\n    std::replace(strA.begin(), strA.end(), ',', '.');\n    std::replace(strB.begin(), strB.end(), ',', '.');\n\n    // Try to convert strings to floats for comparison\n    float numA = std::strtof(strA.c_str(), nullptr);\n    float numB = std::strtof(strB.c_str(), nullptr);\n\n    if (numA > numB) {\n        return a;\n    } else if (numB > numA) {\n        return b;\n    } else {\n        // If the numbers are equal, return \"None\"\n        return boost::any(\"None\");\n    }\n}\n\n"}
{"task_id": "CPP/138", "generation": "#include <iostream>\nusing namespace std;\n\nbool is_equal_to_sum_even(int n) {\n    // Check if n is less than 8 or not divisible by 2\n    if (n < 8 || n % 2 != 0) {\n        return false;\n    }\n    \n    // If n is at least 8 and even, it can be written as the sum of four positive even numbers\n    return true;\n}\n\n"}
{"task_id": "CPP/139", "generation": "#include <iostream>\n\n// Function to calculate factorial of a number\nlong long factorial(long long num) {\n    if (num == 0 || num == 1)\n        return 1;\n    else\n        return num * factorial(num - 1);\n}\n\n// Function to calculate Brazilian factorial\nlong long special_factorial(int n) {\n    long long result = 1;\n    for (int i = n; i > 0; --i) {\n        result *= factorial(i);\n    }\n    return result;\n}\n\n"}
{"task_id": "CPP/140", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring fix_spaces(string text) {\n    string result;\n    int consecutiveSpaces = 0;\n\n    for (char ch : text) {\n        if (ch == ' ') {\n            consecutiveSpaces++;\n        } else {\n            if (consecutiveSpaces > 2) {\n                // Replace the last two spaces with '-'\n                result += '-';\n                // Add one more '-' to account for the current space\n                result += '-';\n                consecutiveSpaces = 0;\n            } else if (consecutiveSpaces >= 1) {\n                // Replace single or double spaces with '_'\n                result += string(consecutiveSpaces, '_');\n                consecutiveSpaces = 0;\n            }\n        }\n    }\n\n    // Handle trailing spaces\n    if (consecutiveSpaces > 2) {\n        result += '-';\n        result += '-';\n    } else if (consecutiveSpaces >= 1) {\n        result += string(consecutiveSpaces, '_');\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/141", "generation": "#include <iostream>\n#include <string>\n#include <cctype> // for std::isalpha and std::isdigit\n\nusing namespace std;\n\nbool isValidName(const string& name) {\n    int digitCount = 0;\n    bool hasDot = false;\n    size_t dotPosition = name.find('.');\n    \n    // Check if there is exactly one dot\n    if (dotPosition == string::npos || dotPosition == 0 || dotPosition == name.length() - 1) {\n        return false;\n    }\n    \n    // Check the substring before the dot\n    for (size_t i = 0; i < dotPosition; ++i) {\n        if (!std::isalpha(name[i])) {\n            return false;\n        }\n    }\n    \n    // Check the substring after the dot\n    string extension = name.substr(dotPosition + 1);\n    if (extension != \"txt\" && extension != \"exe\" && extension != \"dll\") {\n        return false;\n    }\n    \n    // Count digits in the entire file name\n    for (char c : name) {\n        if (std::isdigit(c)) {\n            digitCount++;\n        }\n    }\n    \n    // Check if there are more than three digits\n    if (digitCount > 3) {\n        return false;\n    }\n    \n    return true;\n}\n\nstring file_name_check(string file_name) {\n    if (isValidName(file_name)) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\n\n"}
{"task_id": "CPP/142", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint sum_squares(vector<int> lst) {\n    int sum = 0;\n    \n    for (size_t i = 0; i < lst.size(); ++i) {\n        if ((i + 1) % 3 == 0 && (i + 1) % 4 != 0) {\n            // Square the element if its index is a multiple of 3\n            sum += lst[i] * lst[i];\n        } else if ((i + 1) % 4 == 0) {\n            // Cube the element if its index is a multiple of 4 and not a multiple of 3\n            sum += lst[i] * lst[i] * lst[i];\n        } else {\n            // Add the original value to the sum\n            sum += lst[i];\n        }\n    }\n\n    return sum;\n}\n\n"}
{"task_id": "CPP/143", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    if (n == 2 || n == 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    for (int i = 5; i * i <= n; i += 6)\n        if (n % i == 0 || n % (i + 2) == 0)\n            return false;\n    return true;\n}\n\n// Function to process the sentence and return words with prime length\nstring words_in_sentence(string sentence) {\n    string result = \"\";\n    int word_start = 0;\n    \n    // Iterate through each character in the sentence\n    for (int i = 0; i <= sentence.length(); ++i) {\n        if (sentence[i] == ' ' || i == sentence.length()) {\n            int length = i - word_start;\n            if (is_prime(length)) {\n                result += sentence.substr(word_start, length);\n                result += \" \"; // Add a space after the word\n            }\n            word_start = i + 1; // Move to the next word start\n        }\n    }\n    \n    // Remove the trailing space if it exists\n    if (!result.empty() && result.back() == ' ') {\n        result.pop_back();\n    }\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/144", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\n// Function to simplify two fractions x * n and check if it results in a whole number\nbool simplify(string x, string n) {\n    // Helper function to parse fraction from string\n    auto parse_fraction = [](const string& fraction) -> pair<int, int> {\n        size_t slash_pos = fraction.find('/');\n        int numerator = stoi(fraction.substr(0, slash_pos));\n        int denominator = stoi(fraction.substr(slash_pos + 1));\n        return {numerator, denominator};\n    };\n\n    // Parse the fractions\n    auto [x_numerator, x_denominator] = parse_fraction(x);\n    auto [n_numerator, n_denominator] = parse_fraction(n);\n\n    // Multiply numerators and denominators\n    int product_numerator = x_numerator * n_numerator;\n    int product_denominator = x_denominator * n_denominator;\n\n    // Check if the result is a whole number\n    return (product_numerator % product_denominator == 0);\n}\n\n"}
{"task_id": "CPP/145", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// Helper function to calculate the sum of digits of an integer\nint digitSum(int n) {\n    int sum = 0;\n    bool negative = false;\n    \n    if (n < 0) {\n        n = -n; // Make it positive for processing\n        negative = true;\n    }\n    \n    while (n > 0) {\n        sum += n % 10;\n        n /= 10;\n    }\n    \n    return negative ? -sum : sum;\n}\n\n// Comparator function to sort based on digit sum and original index\nbool compareByDigitSumAndIndex(const pair<int, int>& a, const pair<int, int>& b) {\n    if (a.first == b.first) {\n        // If the digit sums are equal, use the original index as tiebreaker\n        return a.second < b.second;\n    }\n    return a.first < b.first;\n}\n\nvector<int> order_by_points(vector<int> nums) {\n    vector<pair<int, int>> indexedNums;\n    \n    for (int i = 0; i < nums.size(); ++i) {\n        // Store the original index along with the number\n        indexedNums.push_back({digitSum(nums[i]), i});\n    }\n    \n    // Sort based on digit sum and then by original index\n    sort(indexedNums.begin(), indexedNums.end(), compareByDigitSumAndIndex);\n    \n    // Extract the sorted numbers from the pairs\n    vector<int> result;\n    for (const auto& p : indexedNums) {\n        result.push_back(nums[p.second]);\n    }\n    \n    return result;\n}\n\n// Function to check the correctness of the solution\nvoid check() {\n    assert(order_by_points({1, 11, -1, -11, -12}) == vector<int>{-1, -11, 1, -12, 11});\n    assert(order_by_points({}) == vector<int>{});\n    cout << \"All test cases passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/146", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nint specialFilter(vector<int> nums) {\n    int count = 0;\n    \n    for (int num : nums) {\n        // Skip numbers that are not greater than 10\n        if (num <= 10) continue;\n        \n        string strNum = to_string(num);\n        int firstDigit = strNum[0] - '0';\n        int lastDigit = strNum[strNum.length() - 1] - '0';\n        \n        // Check if both the first and last digits are odd\n        if (firstDigit % 2 != 0 && lastDigit % 2 != 0) {\n            count++;\n        }\n    }\n    \n    return count;\n}\n\n"}
{"task_id": "CPP/147", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint get_max_triples(int n) {\n    // Step 1: Generate the vector a\n    vector<int> a(n);\n    for (int i = 0; i < n; ++i) {\n        a[i] = i * i - i + 1;\n    }\n\n    int count = 0;\n\n    // Step 2 and 3: Iterate through all possible triples and check the condition\n    for (int i = 0; i < n - 2; ++i) {\n        for (int j = i + 1; j < n - 1; ++j) {\n            for (int k = j + 1; k < n; ++k) {\n                if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                    count++;\n                }\n            }\n        }\n    }\n\n    // Step 4: Return the count of valid triples\n    return count;\n}\n\n"}
{"task_id": "CPP/148", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to check if a planet name is valid and return its index, or -1 if invalid.\nint getPlanetIndex(const string& planet) {\n    vector<string> planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n    \n    for (size_t i = 0; i < planets.size(); ++i) {\n        if (planets[i] == planet) {\n            return static_cast<int>(i);\n        }\n    }\n    return -1;\n}\n\n// Function to get the list of planets between two given planets.\nvector<string> bf(string planet1, string planet2) {\n    int index1 = getPlanetIndex(planet1);\n    int index2 = getPlanetIndex(planet2);\n\n    // Check if both planets are valid\n    if (index1 == -1 || index2 == -1) {\n        return {};  // Return an empty vector if either planet is invalid\n    }\n\n    // Ensure index1 < index2 for correct ordering\n    if (index1 > index2) {\n        swap(index1, index2);\n    }\n\n    vector<string> result;\n    for (int i = index1 + 1; i < index2; ++i) {\n        result.push_back(planets[i]);\n    }\n    \n    return result;\n}\n\n// Function to test the bf function\nvoid test() {\n    vector<string> result;\n\n    // Test cases\n    result = bf(\"Jupiter\", \"Neptune\");\n    for (const auto& planet : result) {\n        cout << planet << \" \";\n    }\n    cout << endl;  // Expected output: Saturn Uranus\n\n    result = bf(\"Earth\", \"Mercury\");\n    for (const auto& planet : result) {\n        cout << planet << \" \";\n    }\n    cout << endl;  // Expected output: Venus\n\n    result = bf(\"Mercury\", \"Uranus\");\n    for (const auto& planet : result) {\n        cout << planet << \" \";\n    }\n    cout << endl;  // Expected output: Venus Earth Mars Jupiter Saturn\n}\n\n"}
{"task_id": "CPP/149", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to remove odd-length strings and sort the rest\nvector<string> sorted_list_sum(vector<string> lst) {\n    // Remove strings with odd lengths\n    lst.erase(remove_if(lst.begin(), lst.end(), [](const string& s) { return s.length() % 2 != 0; }), lst.end());\n\n    // Sort by length, then alphabetically for the same length\n    sort(lst.begin(), lst.end(), [](const string& a, const string& b) {\n        if (a.length() == b.length()) {\n            return a < b;\n        }\n        return a.length() < b.length();\n    });\n\n    return lst;\n}\n\n// Function to test the sorted_list_sum function\nvoid test_sorted_list_sum() {\n    assert(sorted_list_sum({\"aa\", \"a\", \"aaa\"}) == vector<string>({\"aa\"}));\n    assert(sorted_list_sum({\"ab\", \"a\", \"aaa\", \"cd\"}) == vector<string>({\"ab\", \"cd\"}));\n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/150", "generation": "#include <stdio.h>\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int n) {\n    if (n <= 1) return false; // Numbers less than or equal to 1 are not prime\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\n// Function that returns x if n is a prime number, otherwise returns y\nint x_or_y(int n, int x, int y) {\n    return is_prime(n) ? x : y;\n}\n\n"}
{"task_id": "CPP/151", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nlong long double_the_difference(vector<float> lst) {\n    long long sum = 0;\n    \n    for (float num : lst) {\n        // Check if the number is positive, an integer, and odd\n        if (num > 0 && floor(num) == num && static_cast<int>(num) % 2 != 0) {\n            sum += pow(num, 2);\n        }\n    }\n    \n    return sum;\n}\n\n"}
{"task_id": "CPP/152", "generation": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nvector<int> compare(vector<int> game, vector<int> guess) {\n    vector<int> result;\n    \n    // Ensure both vectors are of the same length\n    if (game.size() != guess.size()) {\n        throw runtime_error(\"Vectors must be of the same length\");\n    }\n    \n    for (size_t i = 0; i < game.size(); ++i) {\n        int difference = abs(game[i] - guess[i]);\n        result.push_back(difference);\n    }\n    \n    return result;\n}\n\n// Function to test the compare function\nvoid test() {\n    vector<int> scores1 = {1, 2, 3, 4, 5, 1};\n    vector<int> guesses1 = {1, 2, 3, 4, 2, -2};\n    vector<int> expected1 = {0, 0, 0, 0, 3, 3};\n    \n    vector<int> scores2 = {0, 5, 0, 0, 0, 4};\n    vector<int> guesses2 = {4, 1, 1, 0, 0, -2};\n    vector<int> expected2 = {4, 4, 1, 0, 0, 6};\n    \n    assert(compare(scores1, guesses1) == expected1);\n    assert(compare(scores2, guesses2) == expected2);\n    \n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/153", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to calculate the strength of an extension\nint calculateStrength(const string& extension) {\n    int cap = 0, sm = 0;\n    for (char c : extension) {\n        if (isupper(c)) cap++;\n        else if (islower(c)) sm++;\n    }\n    return cap - sm;\n}\n\n// Function to find the strongest extension\nstring Strongest_Extension(string class_name, vector<string> extensions) {\n    int max_strength = INT_MIN;\n    string strongest_extension;\n\n    for (const auto& ext : extensions) {\n        int strength = calculateStrength(ext);\n        if (strength > max_strength) {\n            max_strength = strength;\n            strongest_extension = ext;\n        }\n    }\n\n    return class_name + \".\" + strongest_extension;\n}\n\n// Function to test the solution\nvoid test() {\n    string result1 = Strongest_Extension(\"Slices\", {\"SErviNGSliCes\", \"Cheese\", \"StuFfed\"});\n    cout << (result1 == \"Slices.SErviNGSliCes\" ? \"Test 1 Passed\" : \"Test 1 Failed\") << endl;\n\n    string result2 = Strongest_Extension(\"my_class\", {\"AA\", \"Be\", \"CC\"});\n    cout << (result2 == \"my_class.AA\" ? \"Test 2 Passed\" : \"Test 2 Failed\") << endl;\n}\n\n"}
{"task_id": "CPP/154", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\n// Function to generate all rotations of a string\nvoid getRotations(string &str) {\n    int n = str.length();\n    for (int i = 0; i < n; i++) {\n        // Rotate the string by moving the first character to the end\n        char firstChar = str[0];\n        for (int j = 1; j < n; j++)\n            str[j - 1] = str[j];\n        str[n - 1] = firstChar;\n    }\n}\n\n// Function to check if any rotation of b is a substring of a\nbool cycpattern_check(string a, string b) {\n    int na = a.length();\n    int nb = b.length();\n\n    // Check if b itself is a substring of a\n    for (int i = 0; i < na - nb + 1; i++) {\n        if (a.substr(i, nb) == b)\n            return true;\n    }\n\n    // Generate all rotations of b and check each rotation\n    string rotatedB = b;\n    getRotations(rotatedB);\n    for (int i = 0; i < na - nb + 1; i++) {\n        if (a.substr(i, nb) == rotatedB)\n            return true;\n    }\n\n    // If no match is found, return false\n    return false;\n}\n\n// Function to test the cycpattern_check function with given examples\nvoid test() {\n    cout << boolalpha; // Print boolean values as true/false instead of 1/0\n    cout << \"cycpattern_check(\\\"abcd\\\", \\\"abd\\\") => \" << cycpattern_check(\"abcd\", \"abd\") << endl;\n    cout << \"cycpattern_check(\\\"hello\\\", \\\"ell\\\") => \" << cycpattern_check(\"hello\", \"ell\") << endl;\n    cout << \"cycpattern_check(\\\"whassup\\\", \\\"psus\\\") => \" << cycpattern_check(\"whassup\", \"psus\") << endl;\n    cout << \"cycpattern_check(\\\"abab\\\", \\\"baa\\\") => \" << cycpattern_check(\"abab\", \"baa\") << endl;\n    cout << \"cycpattern_check(\\\"efef\\\", \\\"eeff\\\") => \" << cycpattern_check(\"efef\", \"eeff\") << endl;\n    cout << \"cycpattern_check(\\\"himenss\\\", \\\"simen\\\") => \" << cycpattern_check(\"himenss\", \"simen\") << endl;\n}\n\n"}
{"task_id": "CPP/155", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> even_odd_count(int num) {\n    // Convert the number to its absolute value to handle negative numbers\n    num = abs(num);\n    \n    int count_even = 0;\n    int count_odd = 0;\n    \n    while (num > 0) {\n        int digit = num % 10;  // Get the last digit\n        if (digit % 2 == 0) {\n            count_even++;  // Increment even count if the digit is even\n        } else {\n            count_odd++;   // Increment odd count if the digit is odd\n        }\n        \n        num /= 10;  // Remove the last digit from the number\n    }\n    \n    return {count_even, count_odd};\n}\n\n"}
{"task_id": "CPP/156", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring int_to_mini_roman(int number) {\n    // Mapping of integers to Roman numerals in descending order\n    vector<pair<int, string>> roman_map = {\n        {1000, \"m\"}, {900, \"cm\"}, {500, \"d\"}, {400, \"cd\"},\n        {100, \"c\"}, {90, \"xc\"}, {50, \"l\"}, {40, \"xl\"},\n        {10, \"x\"}, {9, \"ix\"}, {5, \"v\"}, {4, \"iv\"}, {1, \"i\"}\n    };\n\n    string result = \"\";\n\n    // Iterate over the mapping and subtract from the number\n    for (const auto& [value, numeral] : roman_map) {\n        while (number >= value) {\n            result += numeral;\n            number -= value;\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/157", "generation": "#include <stdio.h>\n#include <math.h>\n\nusing namespace std;\n\nbool right_angle_triangle(float a, float b, float c) {\n    // Sort the sides to ensure c is the longest side\n    if (a > c) swap(a, c);\n    if (b > c) swap(b, c);\n\n    // Check the Pythagorean theorem\n    return fabs(a*a + b*b - c*c) < 1e-6; // Using a small tolerance to account for floating point precision issues\n}\n\n"}
{"task_id": "CPP/158", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nstring find_max(vector<string> words) {\n    if (words.empty()) {\n        return \"\"; // Return an empty string if the vector is empty\n    }\n\n    // Find the word with the maximum number of unique characters\n    auto max_unique_word = *max_element(words.begin(), words.end(),\n                                        [](const string& a, const string& b) {\n                                            int unique_a = count_if(a.begin(), a.end(), \n                                                                    [&](char c){ return std::count(a.begin(), a.end(), c) == 1; });\n                                            int unique_b = count_if(b.begin(), b.end(), \n                                                                    [&](char c){ return std::count(b.begin(), b.end(), c) == 1; });\n                                            if (unique_a == unique_b) {\n                                                return a < b; // Lexicographical order\n                                            }\n                                            return unique_a > unique_b;\n                                        });\n\n    return max_unique_word;\n}\n\n// Function to test the find_max function with provided examples\nvoid test_find_max() {\n    assert(find_max({\"name\", \"of\", \"string\"}) == \"string\");\n    assert(find_max({\"name\", \"enam\", \"game\"}) == \"enam\");\n    assert(find_max({\"aaaaaaa\", \"bb\", \"cc\"}) == \"aaaaaaa\");\n\n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/159", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nvector<int> eat(int number, int need, int remaining) {\n    // Calculate the additional carrots needed\n    int additional_needed = need - number;\n    \n    // Determine if there are enough remaining carrots to satisfy this need\n    if (additional_needed <= remaining) {\n        // If there are enough, update the total eaten and reduce the remaining\n        return {number + additional_needed, remaining - additional_needed};\n    } else {\n        // If not enough, eat all remaining carrots\n        int total_eaten = number + remaining;\n        return {total_eaten, 0};\n    }\n}\n\n// Function to test the eat function with provided examples\nvoid check() {\n    printf(\"%d %d\\n\", eat(5, 6, 10)[0], eat(5, 6, 10)[1]); // Should print: 11 4\n    printf(\"%d %d\\n\", eat(4, 8, 9)[0], eat(4, 8, 9)[1]);   // Should print: 12 1\n    printf(\"%d %d\\n\", eat(1, 10, 10)[0], eat(1, 10, 10)[1]); // Should print: 11 0\n    printf(\"%d %d\\n\", eat(2, 11, 5)[0], eat(2, 11, 5)[1]);   // Should print: 7 0\n}\n\n"}
{"task_id": "CPP/160", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nint do_algebra(vector<string> operators, vector<int> operands) {\n    if (operands.size() == 0 || operators.size() == 0) return 0;\n    \n    int result = operands[0];\n    \n    for (size_t i = 0; i < operators.size(); ++i) {\n        switch (operators[i][0]) {\n            case '+':\n                result += operands[i + 1];\n                break;\n            case '-':\n                result -= operands[i + 1];\n                break;\n            case '*':\n                result *= operands[i + 1];\n                break;\n            case '/': \n                // For floor division, use integer division\n                result /= operands[i + 1];\n                break;\n            case '**':\n                // For exponentiation, use pow function from cmath\n                result = pow(result, operands[i + 1]);\n                break;\n            default:\n                cout << \"Invalid operator: \" << operators[i] << endl;\n                return -1; // Return an error code if the operator is invalid\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/161", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\n// Function to solve the problem as described\nstring solve(string s) {\n    bool containsLetter = false;\n    \n    // Check if the string contains any letter\n    for (char c : s) {\n        if (isalpha(c)) {\n            containsLetter = true;\n            break;\n        }\n    }\n\n    // If no letters are present, reverse the entire string\n    if (!containsLetter) {\n        reverse(s.begin(), s.end());\n    } else {\n        // Otherwise, convert each letter to its opposite case\n        for (char &c : s) {\n            if (islower(c)) {\n                c = toupper(c);\n            } else if (isupper(c)) {\n                c = tolower(c);\n            }\n        }\n    }\n\n    return s;\n}\n\n// Function to test the solve function with provided examples\nvoid test() {\n    cout << \"solve(\\\"1234\\\") = \\\"\" << solve(\"1234\") << \"\\\" (Expected: \\\"4321\\\")\" << endl;\n    cout << \"solve(\\\"ab\\\") = \\\"\" << solve(\"ab\") << \"\\\" (Expected: \\\"AB\\\")\" << endl;\n    cout << \"solve(\\\"#a@C\\\") = \\\"\" << solve(\"#a@C\") << \"\\\" (Expected: \\\"#A@c\\\")\" << endl;\n}\n\n"}
{"task_id": "CPP/162", "generation": "#include <iostream>\n#include <string>\n#include <openssl/md5.h>\n\n// Function to convert raw bytes to hex string\nstd::string bytes_to_hex(const unsigned char* bytes, size_t length) {\n    std::stringstream ss;\n    for (size_t i = 0; i < length; ++i) {\n        ss << std::hex << std::setw(2) << std::setfill('0') << static_cast<int>(bytes[i]);\n    }\n    return ss.str();\n}\n\n// Function to convert string to MD5 hash\nstd::string string_to_md5(const std::string& text) {\n    if (text.empty()) {\n        return \"None\";\n    }\n\n    unsigned char digest[MD5_DIGEST_LENGTH];\n    MD5((unsigned char*)text.c_str(), text.length(), (unsigned char*)&digest);    \n\n    // Convert the hash to a hexadecimal string\n    return bytes_to_hex(digest, MD5_DIGEST_LENGTH);\n}\n\n"}
{"task_id": "CPP/163", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Function to generate even digits between a and b in ascending order.\nvector<int> generate_integers(int a, int b) {\n    vector<int> result;\n    \n    // Ensure a is less than or equal to b for simplicity\n    if (a > b) swap(a, b);\n    \n    // Iterate through the range [a, b]\n    for (int i = a; i <= b; ++i) {\n        int num = i;\n        \n        // Extract each digit and check if it is even\n        while (num > 0) {\n            int digit = num % 10;\n            if (digit % 2 == 0 && result.size() < 5) { // Limit to 4 digits per number\n                result.push_back(digit);\n            }\n            num /= 10;\n        }\n    }\n    \n    return result;\n}\n\n// Function to print the vector for testing purposes\nvoid print_vector(const vector<int>& vec) {\n    for (int i : vec) {\n        cout << i << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/0", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // For std::sort\n\nbool has_close_elements(const std::vector<float>& numbers, float threshold) {\n    // Sort the vector first\n    std::vector<float> sorted_numbers = numbers;\n    std::sort(sorted_numbers.begin(), sorted_numbers.end());\n\n    // Check adjacent elements in the sorted vector\n    for (size_t i = 0; i < sorted_numbers.size() - 1; ++i) {\n        if (sorted_numbers[i + 1] - sorted_numbers[i] < threshold) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\n"}
{"task_id": "CPP/1", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> separate_paren_groups(string paren_string) {\n    vector<string> result;\n    string current_group = \"\";\n    int balance = 0;\n\n    for (char ch : paren_string) {\n        if (ch == '(') {\n            balance++;\n            current_group += ch;\n        } else if (ch == ')') {\n            balance--;\n            current_group += ch;\n            if (balance == 0) {\n                result.push_back(current_group);\n                current_group = \"\";\n            }\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/2", "generation": "#include <stdio.h>\n#include <math.h>\n\nfloat truncate_number(float number) {\n    float integerPart, decimalPart;\n    modf(number, &integerPart);  // integerPart will be the largest integer less than or equal to number\n    decimalPart = number - integerPart;  // decimalPart is the fractional part of the number\n    return decimalPart;\n}\n\n"}
{"task_id": "CPP/3", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool below_zero(vector<int> operations) {\n    int balance = 0; // Start with a zero balance\n\n    for (int op : operations) {\n        balance += op; // Update the balance after each operation\n        if (balance < 0) { // Check if the balance is below zero\n            return true;\n        }\n    }\n\n    return false; // Return false if the balance never falls below zero\n}\n\n// Function to test the below_zero function with provided examples\nvoid test_below_zero() {\n    vector<int> operations1 = {1, 2, 3};\n    vector<int> operations2 = {1, 2, -4, 5};\n\n    cout << \"Test 1: \" << (below_zero(operations1) ? \"Passed\" : \"Failed\") << endl;\n    cout << \"Test 2: \" << (below_zero(operations2) ? \"Passed\" : \"Failed\") << endl;\n}\n\n"}
{"task_id": "CPP/4", "generation": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nfloat mean_absolute_deviation(vector<float> numbers) {\n    if (numbers.empty()) {\n        return 0.0f; // Return 0 for an empty vector to avoid division by zero.\n    }\n\n    float sum = 0.0f;\n    for (const auto& num : numbers) {\n        sum += num;\n    }\n    float mean = sum / numbers.size();\n\n    float mad = 0.0f;\n    for (const auto& num : numbers) {\n        mad += abs(num - mean);\n    }\n    mad /= numbers.size();\n\n    return mad;\n}\n\n"}
{"task_id": "CPP/5", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> intersperse(vector<int> numbers, int delimeter) {\n    // If the input vector is empty or contains only one element, return it as is.\n    if (numbers.size() <= 1) {\n        return numbers;\n    }\n\n    // Create a new vector to store the result\n    vector<int> result;\n\n    // Iterate through the input vector and insert elements into the result vector\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        result.push_back(numbers[i]);\n        if (i != numbers.size() - 1) {  // Do not add delimiter after the last element\n            result.push_back(delimeter);\n        }\n    }\n\n    return result;\n}\n\n// Function to print the vector for testing purposes\nvoid printVector(const vector<int>& vec) {\n    for (int num : vec) {\n        cout << num << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/6", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<int> parse_nested_parens(string paren_string) {\n    vector<int> depths;\n    size_t start = 0, end = 0;\n    \n    // Split the input string by spaces to get individual groups\n    while ((end = paren_string.find(' ', start)) != string::npos) {\n        string group = paren_string.substr(start, end - start);\n        int max_depth = 0, current_depth = 0;\n\n        // Iterate through each character in the group\n        for (char c : group) {\n            if (c == '(') {\n                current_depth++;\n                max_depth = max(max_depth, current_depth);\n            } else if (c == ')') {\n                current_depth--;\n            }\n        }\n\n        depths.push_back(max_depth);\n        start = end + 1;\n    }\n\n    // Process the last group\n    string last_group = paren_string.substr(start);\n    int max_depth = 0, current_depth = 0;\n\n    for (char c : last_group) {\n        if (c == '(') {\n            current_depth++;\n            max_depth = max(max_depth, current_depth);\n        } else if (c == ')') {\n            current_depth--;\n        }\n    }\n\n    depths.push_back(max_depth);\n\n    return depths;\n}\n\n"}
{"task_id": "CPP/7", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> filter_by_substring(vector<string> strings, string substring) {\n    vector<string> filteredStrings;\n    \n    // Iterate through each string in the input vector\n    for (const auto& str : strings) {\n        // Check if the current string contains the given substring\n        if (str.find(substring) != string::npos) {\n            // If it does, add it to the filtered list\n            filteredStrings.push_back(str);\n        }\n    }\n\n    return filteredStrings;\n}\n\n// Function to test the filter_by_substring function\nvoid test_filter_by_substring() {\n    vector<string> input1 = {};\n    vector<string> expected1 = {};\n    assert(filter_by_substring(input1, \"a\") == expected1);\n\n    vector<string> input2 = {\"abc\", \"bacd\", \"cde\", \"vector\"};\n    vector<string> expected2 = {\"abc\", \"bacd\", \"vector\"};\n    assert(filter_by_substring(input2, \"a\") == expected2);\n\n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/8", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> sum_product(vector<int> numbers) {\n    int sum = 0;\n    int product = 1;\n\n    // Iterate through each number in the vector\n    for (int num : numbers) {\n        sum += num;  // Add the current number to the sum\n        if (num != 0) {  // Avoid division by zero when calculating product\n            product *= num;\n        }\n    }\n\n    return {sum, product};\n}\n\n// Function to test the sum_product function with provided data points\nvoid test_sum_product() {\n    vector<int> empty = {};\n    vector<int> numbers = {1, 2, 3, 4};\n\n    // Test case for an empty vector\n    auto result1 = sum_product(empty);\n    cout << \"Empty vector: Sum = \" << result1[0] << \", Product = \" << result1[1] << endl;\n\n    // Test case for a non-empty vector\n    auto result2 = sum_product(numbers);\n    cout << \"Non-empty vector (1, 2, 3, 4): Sum = \" << result2[0] << \", Product = \" << result2[1] << endl;\n}\n\n"}
{"task_id": "CPP/9", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> rolling_max(vector<int> numbers) {\n    if (numbers.empty()) return {};  // Return an empty vector if the input is empty\n\n    vector<int> result;\n    int current_max = numbers[0];  // Initialize the current maximum with the first element\n    for (int num : numbers) {\n        if (num > current_max) {\n            current_max = num;  // Update the current maximum if a larger number is found\n        }\n        result.push_back(current_max);  // Add the current maximum to the result vector\n    }\n\n    return result;\n}\n\n// Function to print the vector for testing purposes\nvoid print_vector(const vector<int>& vec) {\n    for (int num : vec) {\n        cout << num << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/10", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_palindrome(string str) {\n    // Test if given string is a palindrome\n    string s(str.rbegin(), str.rend());\n    return s == str;\n}\n\nstring make_palindrome(string str) {\n    /*\n    Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    */\n    \n    int n = str.length();\n    for (int i = 0; i < n; ++i) {\n        // Check if the substring from i to the end is a palindrome\n        if (is_palindrome(str.substr(i))) {\n            // The longest palindromic suffix starts at index i\n            string prefix = str.substr(0, i);\n            // Reverse the prefix and append it to the original string\n            return str + string(prefix.rbegin(), prefix.rend());\n        }\n    }\n    \n    // If no palindromic suffix is found (which should not happen for non-empty strings), return the original string\n    return str;\n}\n\n"}
{"task_id": "CPP/11", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring string_xor(string a, string b) {\n    // Ensure both strings are of equal length by padding with leading zeros if necessary\n    int len_a = a.length();\n    int len_b = b.length();\n    if (len_a > len_b) {\n        for (int i = 0; i < len_a - len_b; ++i) {\n            b = '0' + b;\n        }\n    } else if (len_b > len_a) {\n        for (int i = 0; i < len_b - len_a; ++i) {\n            a = '0' + a;\n        }\n    }\n\n    // Perform XOR operation\n    string result = \"\";\n    for (size_t i = 0; i < a.length(); ++i) {\n        if (a[i] == b[i]) {\n            result += \"0\";\n        } else {\n            result += \"1\";\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/12", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring longest(vector<string> strings) {\n    if (strings.empty()) {\n        return \"\"; // Return an empty string to represent None in this context.\n    }\n\n    string longestString = strings[0]; // Initialize with the first string\n\n    for (const auto& str : strings) {\n        if (str.length() > longestString.length()) {\n            longestString = str;\n        }\n    }\n\n    return longestString;\n}\n\n"}
{"task_id": "CPP/13", "generation": "#include <stdio.h>\nusing namespace std;\n\nint greatest_common_divisor(int a, int b) {\n    // Ensure a >= b\n    if (a < b) {\n        swap(a, b);\n    }\n\n    // Apply Euclidean algorithm\n    while (b != 0) {\n        int temp = b;\n        b = a % b;\n        a = temp;\n    }\n\n    return a;\n}\n\n"}
{"task_id": "CPP/14", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> all_prefixes(const string& str) {\n    vector<string> prefixes;\n    for (size_t i = 1; i <= str.size(); ++i) {\n        prefixes.push_back(str.substr(0, i));\n    }\n    return prefixes;\n}\n\n"}
{"task_id": "CPP/15", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring string_sequence(int n) {\n    if (n < 0) return \"\"; // Handle negative input gracefully\n\n    string result = \"\";\n    for (int i = 0; i <= n; ++i) {\n        result += to_string(i);\n        if (i != n) {\n            result += \" \";\n        }\n    }\n    return result;\n}\n\n// Function to test the string_sequence function\nvoid test() {\n    cout << \"Testing with input 5: \" << string_sequence(5) << endl; // Expected output: \"0 1 2 3 4 5\"\n    cout << \"Testing with input 0: \" << string_sequence(0) << endl; // Expected output: \"0\"\n}\n\n"}
{"task_id": "CPP/16", "generation": "#include <iostream>\n#include <string>\n#include <set>\n\nusing namespace std;\n\nint count_distinct_characters(string str) {\n    // Convert the string to lowercase to ignore case sensitivity\n    transform(str.begin(), str.end(), str.begin(), ::tolower);\n    \n    // Use a set to store distinct characters\n    set<char> distinct_chars(str.begin(), str.end());\n    \n    // The size of the set gives us the count of distinct characters\n    return distinct_chars.size();\n}\n\n"}
{"task_id": "CPP/17", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<int> parse_music(string music_string) {\n    vector<int> durations;\n    \n    // Iterate through the string, processing two characters at a time\n    for (size_t i = 0; i < music_string.length(); ) {\n        if (i + 1 < music_string.length() && music_string[i] == 'o' && music_string[i + 1] == '|') {\n            // \"o|\" - half note, lasts two beats\n            durations.push_back(2);\n            i += 2;\n        } else if (music_string[i] == '.') {\n            // \".|\" - quarter note, lasts one beat\n            durations.push_back(1);\n            i++;\n        } else if (music_string[i] == 'o') {\n            // \"o\" - whole note, lasts four beats\n            durations.push_back(4);\n            i++;\n        } else {\n            // Invalid character or end of string\n            break;\n        }\n    }\n\n    return durations;\n}\n\n"}
{"task_id": "CPP/18", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint how_many_times(string str, string substring) {\n    int count = 0;\n    size_t pos = 0;\n\n    // Loop through the original string to find all occurrences of the substring\n    while ((pos = str.find(substring, pos)) != string::npos) {\n        count++;\n        pos++; // Move to the next position for overlapping cases\n    }\n\n    return count;\n}\n\n"}
{"task_id": "CPP/19", "generation": "#include <iostream>\n#include <string>\n#include <map>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to map word to number\nint word_to_number(const string& word) {\n    map<string, int> num_map = {{\"zero\", 0}, {\"one\", 1}, {\"two\", 2}, {\"three\", 3},\n                                {\"four\", 4}, {\"five\", 5}, {\"six\", 6}, {\"seven\", 7},\n                                {\"eight\", 8}, {\"nine\", 9}};\n    return num_map[word];\n}\n\n// Function to sort the numbers in a string\nstring sort_numbers(const string& numbers) {\n    vector<string> words;\n    string current_word = \"\";\n    \n    // Split the input string into individual words\n    for (char ch : numbers) {\n        if (ch == ' ') {\n            if (!current_word.empty()) {\n                words.push_back(current_word);\n                current_word.clear();\n            }\n        } else {\n            current_word += ch;\n        }\n    }\n    if (!current_word.empty()) {\n        words.push_back(current_word);\n    }\n\n    // Sort the vector based on numeric values\n    sort(words.begin(), words.end(), [&](const string& a, const string& b) {\n        return word_to_number(a) < word_to_number(b);\n    });\n\n    // Join the sorted words back into a single string\n    string result;\n    for (const auto& word : words) {\n        if (!result.empty()) {\n            result += \" \";\n        }\n        result += word;\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/20", "generation": "#include <stdio.h>\n#include <math.h>\n#include <vector>\n\nusing namespace std;\n\nstd::pair<float, float> find_closest_elements(const std::vector<float>& numbers) {\n    if (numbers.size() < 2) {\n        throw std::invalid_argument(\"The vector must contain at least two elements.\");\n    }\n\n    // Initialize the first pair of closest elements\n    float min_diff = std::numeric_limits<float>::max();\n    float closest_a = numbers[0];\n    float closest_b = numbers[1];\n\n    for (size_t i = 0; i < numbers.size() - 1; ++i) {\n        for (size_t j = i + 1; j < numbers.size(); ++j) {\n            float diff = std::abs(numbers[i] - numbers[j]);\n            if (diff < min_diff) {\n                min_diff = diff;\n                closest_a = std::min(numbers[i], numbers[j]);\n                closest_b = std::max(numbers[i], numbers[j]);\n            }\n        }\n    }\n\n    return {closest_a, closest_b};\n}\n\n// Example usage\n"}
{"task_id": "CPP/21", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<float> rescale_to_unit(vector<float> numbers) {\n    if (numbers.size() < 2) {\n        throw invalid_argument(\"The vector must contain at least two elements.\");\n    }\n\n    float min_val = *min_element(numbers.begin(), numbers.end());\n    float max_val = *max_element(numbers.begin(), numbers.end());\n\n    // Avoid division by zero in case all values are the same\n    if (min_val == max_val) {\n        throw runtime_error(\"All values in the vector are the same, cannot rescale.\");\n    }\n\n    vector<float> scaled_numbers;\n    for (float num : numbers) {\n        float scaled_num = (num - min_val) / (max_val - min_val);\n        scaled_numbers.push_back(scaled_num);\n    }\n\n    return scaled_numbers;\n}\n\n"}
{"task_id": "CPP/22", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <boost/any.hpp>\n#include <list>\n\ntypedef std::list<boost::any> list_any;\nusing namespace std;\n\nvector<int> filter_integers(list_any values) {\n    vector<int> result;\n    \n    for (const auto& value : values) {\n        if (value.type() == typeid(int)) {\n            result.push_back(boost::any_cast<int>(value));\n        }\n    }\n    \n    return result;\n}\n\n// Example usage\n"}
{"task_id": "CPP/23", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint strlen(const string& str) {\n    return str.size();\n}\n\n"}
{"task_id": "CPP/24", "generation": "#include <iostream>\nusing namespace std;\n\nint largest_divisor(int n) {\n    for (int i = n - 1; i > 0; --i) {\n        if (n % i == 0) {\n            return i;\n        }\n    }\n    // If no divisor is found, which should not happen for positive integers,\n    // we can return -1 or throw an exception.\n    return -1;\n}\n\n"}
{"task_id": "CPP/25", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> factorize(int n) {\n    vector<int> factors;\n    \n    // Check for each number from 2 up to the square root of n\n    for (int i = 2; i * i <= n; ++i) {\n        while (n % i == 0) {  // If i is a factor of n\n            factors.push_back(i);  // Add i to the list of factors\n            n /= i;  // Divide n by i\n        }\n    }\n    \n    // If n is still greater than 1, it means n itself is a prime number\n    if (n > 1) {\n        factors.push_back(n);\n    }\n    \n    return factors;\n}\n\n// Example usage:\n"}
{"task_id": "CPP/26", "generation": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nvector<int> remove_duplicates(vector<int> numbers) {\n    // Create a hash map to count occurrences of each element\n    unordered_map<int, int> counts;\n    \n    // Count the occurrences of each number in the vector\n    for (int num : numbers) {\n        counts[num]++;\n    }\n    \n    // Reserve space in the result vector to avoid reallocations\n    vector<int> result;\n    result.reserve(numbers.size());\n    \n    // Iterate through the original vector and add elements that occur only once\n    for (int num : numbers) {\n        if (counts[num] == 1) {\n            result.push_back(num);\n        }\n    }\n    \n    return result;\n}\n\n// Function to print the vector for testing purposes\nvoid print_vector(const vector<int>& vec) {\n    for (int num : vec) {\n        cout << num << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/27", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring flip_case(string str) {\n    for (char &c : str) {\n        if (isupper(c)) {\n            c = tolower(c);\n        } else if (islower(c)) {\n            c = toupper(c);\n        }\n    }\n    return str;\n}\n\n"}
{"task_id": "CPP/28", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <numeric> // For std::accumulate\n\nusing namespace std;\n\nstring concatenate(vector<string> strings) {\n    if (strings.empty()) {\n        return \"\";\n    }\n    \n    // Use std::accumulate to concatenate all strings in the vector\n    string result = accumulate(strings.begin(), strings.end(), \"\"s,\n                               [](const string& a, const string& b) { return a + b; });\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/29", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to filter strings by prefix\nvector<string> filter_by_prefix(vector<string> strings, string prefix) {\n    vector<string> filteredStrings;\n    \n    // Iterate through each string in the input vector\n    for (const auto& str : strings) {\n        // Check if the current string starts with the given prefix\n        if (str.substr(0, prefix.length()) == prefix) {\n            filteredStrings.push_back(str);\n        }\n    }\n    \n    return filteredStrings;\n}\n\n// Function to print a vector of strings\nvoid print_vector(const vector<string>& vec) {\n    for (const auto& str : vec) {\n        cout << str << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/30", "generation": "#include <iostream>\n#include <vector>\n\n// Function to return only positive numbers in the vector.\nstd::vector<float> get_positive(std::vector<float> l) {\n    std::vector<float> result;\n    \n    // Iterate through each element in the input vector\n    for (float num : l) {\n        // Check if the number is greater than 0\n        if (num > 0) {\n            // If it's positive, add it to the result vector\n            result.push_back(num);\n        }\n    }\n    \n    return result;\n}\n\n// Function to print the elements of a vector for testing purposes\nvoid print_vector(const std::vector<float>& vec) {\n    for (float num : vec) {\n        std::cout << num << \" \";\n    }\n    std::cout << std::endl;\n}\n\n"}
{"task_id": "CPP/31", "generation": "#include <iostream>\nusing namespace std;\n\nbool is_prime(long long n) {\n    // Handle edge cases for numbers less than or equal to 1\n    if (n <= 1) return false;\n    \n    // Check divisibility from 2 up to the square root of n\n    for (long long i = 2; i * i <= n; ++i) {\n        if (n % i == 0) return false;\n    }\n    \n    return true;\n}\n\n"}
{"task_id": "CPP/32", "generation": "#include <iostream>\n#include <vector>\n#include <cmath>\n\ndouble poly(const std::vector<double>& xs, double x) {\n    double sum = 0;\n    int n = xs.size();\n    for (int i = 0; i < n; ++i) {\n        sum += xs[i] * pow(x, i);\n    }\n    return sum;\n}\n\ndouble find_zero(const std::vector<double>& xs) {\n    // Check if the polynomial is of even degree and has a non-zero coefficient\n    int n = xs.size();\n    if (n % 2 != 0 || xs.empty()) {\n        throw std::invalid_argument(\"Polynomial must have an even number of coefficients.\");\n    }\n\n    // Find intervals where the function changes sign to locate roots\n    double a, b;\n    for (a = -10.0; poly(xs, a) * poly(xs, a + 1.0) > 0 && a < 10.0; ++a);\n    b = a + 1.0;\n\n    // Bisection method to find one root\n    double c;\n    while (b - a > 1e-6) {\n        c = (a + b) / 2.0;\n        if (poly(xs, c) * poly(xs, a) < 0) {\n            b = c;\n        } else {\n            a = c;\n        }\n    }\n\n    return (a + b) / 2.0;\n}\n\n"}
{"task_id": "CPP/33", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> sort_third(vector<int> l) {\n    // Extract elements at indices divisible by three\n    vector<int> third_indices;\n    for (size_t i = 0; i < l.size(); ++i) {\n        if ((i + 1) % 3 == 0) {\n            third_indices.push_back(l[i]);\n        }\n    }\n\n    // Sort the extracted elements\n    sort(third_indices.begin(), third_indices.end());\n\n    // Place sorted elements back into their original positions\n    for (size_t i = 0, j = 0; i < l.size(); ++i) {\n        if ((i + 1) % 3 == 0) {\n            l[i] = third_indices[j++];\n        }\n    }\n\n    return l;\n}\n\n// Function to test the sort_third function\nvoid test_sort_third() {\n    vector<int> result;\n\n    // Test case 1\n    result = sort_third({1, 2, 3});\n    for (int num : result) cout << num << \" \";\n    cout << endl; // Expected output: 1 2 3\n\n    // Test case 2\n    result = sort_third({5, 6, 3, 4, 8, 9, 2});\n    for (int num : result) cout << num << \" \";\n    cout << endl; // Expected output: 2 6 3 4 8 9 5\n\n    // Test case 3\n    result = sort_third({10, 20, 30, 40, 50, 60});\n    for (int num : result) cout << num << \" \";\n    cout << endl; // Expected output: 10 20 30 40 50 60\n\n    // Test case 4\n    result = sort_third({});\n    for (int num : result) cout << num << \" \";\n    cout << endl; // Expected output: \n}\n\n"}
{"task_id": "CPP/34", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> unique(vector<int> l) {\n    // Sort the vector\n    sort(l.begin(), l.end());\n    \n    // Remove consecutive duplicates\n    auto last = unique(l.begin(), l.end());\n    \n    // Resize the vector to contain only the unique elements\n    l.resize(distance(l.begin(), last));\n    \n    return l;\n}\n\n"}
{"task_id": "CPP/35", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nfloat max_element(vector<float> l) {\n    if (l.empty()) {  // Check if the vector is empty\n        return -1;   // Return a special value or throw an exception as needed\n    }\n\n    float max_val = l[0];  // Initialize max_val with the first element of the vector\n\n    for (float num : l) {\n        if (num > max_val) {\n            max_val = num;\n        }\n    }\n\n    return max_val;\n}\n\n"}
{"task_id": "CPP/36", "generation": "#include <iostream>\nusing namespace std;\n\nint fizz_buzz(int n) {\n    int count = 0;\n    \n    for (int i = 1; i < n; ++i) {\n        if (i % 11 == 0 || i % 13 == 0) {\n            // Convert the number to a string and count occurrences of '7'\n            string numStr = to_string(i);\n            for (char c : numStr) {\n                if (c == '7') {\n                    ++count;\n                }\n            }\n        }\n    }\n    \n    return count;\n}\n\n"}
{"task_id": "CPP/37", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<float> sort_even(vector<float> l) {\n    // Extract even-indexed elements and store them in a separate vector\n    vector<float> even_elements;\n    for (size_t i = 0; i < l.size(); i += 2) {\n        even_elements.push_back(l[i]);\n    }\n\n    // Sort the extracted even-indexed elements\n    sort(even_elements.begin(), even_elements.end());\n\n    // Place sorted elements back into their original positions\n    size_t even_index = 0;\n    for (size_t i = 0; i < l.size(); i += 2) {\n        l[i] = even_elements[even_index++];\n    }\n\n    return l;\n}\n\n// Function to print the vector\nvoid print_vector(const vector<float>& v) {\n    for (float val : v) {\n        cout << val << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/38", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring encode_cyclic(string s) {\n    // returns encoded string by cycling groups of three characters.\n    int l = s.length();\n    int num = (l + 2) / 3;\n    string x, output;\n    for (int i = 0; i * 3 < l; i++) {\n        x = s.substr(i * 3, 3);\n        if (x.length() == 3) x = x.substr(1) + x[0];\n        output += x;\n    }\n    return output;\n}\n\nstring decode_cyclic(string s) {\n    /*\n    takes as input string encoded with encode_cyclic function. Returns decoded string.\n    */\n    int l = s.length();\n    int num = (l + 2) / 3;\n    string x, output;\n    for (int i = 0; i * 3 < l; i++) {\n        x = s.substr(i * 3, 3);\n        if (x.length() == 3) x = x[2] + x.substr(0, 2); // Move the first character to the end\n        output += x;\n    }\n    return output;\n}\n\n"}
{"task_id": "CPP/39", "generation": "#include <iostream>\nusing namespace std;\n\n// Helper function to check if a number is prime\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    if (num == 2 || num == 3) return true;\n    if (num % 2 == 0 || num % 3 == 0) return false;\n    for (int i = 5; i * i <= num; i += 6) {\n        if (num % i == 0 || num % (i + 2) == 0)\n            return false;\n    }\n    return true;\n}\n\n// Function to find the n-th Fibonacci number that is also prime\nint prime_fib(int n) {\n    int count = 0; // Counter for prime Fibonacci numbers found\n    int a = 0, b = 1; // First two Fibonacci numbers\n\n    while (true) {\n        int fib = a + b;\n        a = b;\n        b = fib;\n\n        if (is_prime(fib)) {\n            count++;\n            if (count == n) return fib;\n        }\n    }\n}\n\n"}
{"task_id": "CPP/40", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool triples_sum_to_zero(vector<int> l) {\n    // First, sort the vector to facilitate the two-pointer approach.\n    sort(l.begin(), l.end());\n    \n    int n = l.size();\n    \n    for (int i = 0; i < n - 2; ++i) {\n        // Skip duplicate elements to avoid redundant checks\n        if (i > 0 && l[i] == l[i-1]) continue;\n        \n        int left = i + 1, right = n - 1;\n        \n        while (left < right) {\n            int sum = l[i] + l[left] + l[right];\n            \n            if (sum == 0) {\n                return true; // Found three numbers that sum to zero\n            } else if (sum < 0) {\n                ++left; // Need a larger number, move the left pointer to right\n            } else {\n                --right; // Need a smaller number, move the right pointer to left\n            }\n        }\n    }\n    \n    return false; // No three numbers sum to zero\n}\n\n"}
{"task_id": "CPP/41", "generation": "#include <stdio.h>\n\nint car_race_collision(int n) {\n    return n;\n}\n\n"}
{"task_id": "CPP/42", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Function to increment each element of the vector by 1\nvector<int> incr_list(vector<int> l) {\n    for (int &num : l) {\n        num += 1;\n    }\n    return l;\n}\n\n// Function to print the elements of a vector\nvoid print_vector(const vector<int>& v) {\n    for (const int& num : v) {\n        cout << num << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/43", "generation": "#include <iostream>\n#include <vector>\n#include <set>\n\nusing namespace std;\n\nbool pairs_sum_to_zero(vector<int> l) {\n    // Use a set to store seen numbers\n    set<int> seen;\n    \n    for (int num : l) {\n        // Check if the negation of the current number is in the set\n        if (seen.find(-num) != seen.end()) {\n            return true;  // Found a pair that sums to zero\n        }\n        // Add the current number to the set\n        seen.insert(num);\n    }\n    \n    return false;  // No such pair found\n}\n\n// Function to test the pairs_sum_to_zero function with provided examples\nvoid test_pairs_sum_to_zero() {\n    assert(pairs_sum_to_zero({1, 3, 5, 0}) == false);\n    assert(pairs_sum_to_zero({1, 3, -2, 1}) == false);\n    assert(pairs_sum_to_zero({1, 2, 3, 7}) == false);\n    assert(pairs_sum_to_zero({2, 4, -5, 3, 5, 7}) == true);\n    assert(pairs_sum_to_zero({1}) == false);\n\n    cout << \"All test cases passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/44", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring change_base(int x, int base) {\n    if (x == 0) {\n        return \"0\";\n    }\n    \n    string result = \"\";\n    while (x > 0) {\n        int digit = x % base;\n        result = to_string(digit) + result;\n        x /= base;\n    }\n    return result;\n}\n\n"}
{"task_id": "CPP/45", "generation": "#include <stdio.h>\nusing namespace std;\n\nfloat triangle_area(float a, float h) {\n    return 0.5 * a * h;\n}\n\n"}
{"task_id": "CPP/46", "generation": "#include <iostream>\nusing namespace std;\n\nint fib4(int n) {\n    if (n == 0 || n == 1 || n == 2) return n == 2 ? 2 : 0;\n    if (n == 3) return 0;\n\n    // Initialize the first four values of the sequence\n    int a = 0, b = 0, c = 2, d = 0;\n\n    // Compute fib4(n) iteratively\n    for (int i = 4; i <= n; ++i) {\n        int next = a + b + c + d;\n        a = b;\n        b = c;\n        c = d;\n        d = next;\n    }\n\n    return d;\n}\n\n"}
{"task_id": "CPP/47", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nfloat median(vector<float> l) {\n    // Sort the vector\n    sort(l.begin(), l.end());\n\n    int n = l.size();\n    \n    // Check if the number of elements is odd or even\n    if (n % 2 == 1) {\n        // If odd, return the middle element\n        return l[n / 2];\n    } else {\n        // If even, return the average of the two middle elements\n        return (l[(n - 1) / 2] + l[n / 2]) / 2.0;\n    }\n}\n\n"}
{"task_id": "CPP/48", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_palindrome(string text) {\n    int left = 0;\n    int right = text.length() - 1;\n\n    while (left < right) {\n        if (text[left] != text[right]) {\n            return false; // Characters do not match, so it's not a palindrome\n        }\n        left++;\n        right--;\n    }\n\n    return true; // All characters matched, it is a palindrome\n}\n\n"}
{"task_id": "CPP/49", "generation": "#include <stdio.h>\nusing namespace std;\n\nint modp(int n, int p) {\n    if (n == 0)\n        return 1; // Base case: any number to the power of 0 is 1\n\n    int result = 1;\n    long base = 2;\n\n    while (n > 0) {\n        if (n % 2 == 1) { // If n is odd, multiply the result by the current base\n            result = (result * base) % p;\n        }\n        n = n / 2; // Halve the exponent\n        base = (base * base) % p; // Square the base\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/50", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nstring encode_shift(string s) {\n    // returns encoded string by shifting every character by 5 in the alphabet.\n    string out;\n    int i;\n    for (i = 0; i < s.length(); i++) {\n        int w = ((int)s[i] + 5 - (int)'a') % 26 + (int)'a';\n        out += (char)w;\n    }\n    return out;\n}\n\nstring decode_shift(string s) {\n    // takes as input string encoded with encode_shift function. Returns decoded string.\n    string out;\n    int i;\n    for (i = 0; i < s.length(); i++) {\n        int w = ((int)s[i] - 5 - (int)'a') % 26 + (int)'a';\n        out += (char)w;\n    }\n    return out;\n}\n\n"}
{"task_id": "CPP/51", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\n// Helper function to check if a character is a vowel\nbool is_vowel(char c) {\n    string vowels = \"aeiouAEIOU\";\n    return vowels.find(c) != string::npos;\n}\n\n// Function to remove vowels from the input string\nstring remove_vowels(string text) {\n    string result;\n    for (char ch : text) {\n        if (!is_vowel(ch)) {\n            result += ch;\n        }\n    }\n    return result;\n}\n\n"}
{"task_id": "CPP/52", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Function to check if all elements in the vector are below the threshold\nbool below_threshold(vector<int> l, int t) {\n    // Iterate through each element in the vector\n    for (int num : l) {\n        // If any number is greater than or equal to the threshold, return false\n        if (num >= t) {\n            return false;\n        }\n    }\n    // If all numbers are below the threshold, return true\n    return true;\n}\n\n// Function to test the below_threshold function with provided data points\nvoid test_below_threshold() {\n    cout << boolalpha; // Print bools as true/false instead of 1/0\n    cout << \"Test 1: \" << below_threshold({1, 2, 4, 10}, 100) << endl; // Expected output: true\n    cout << \"Test 2: \" << below_threshold({1, 20, 4, 10}, 5) << endl;  // Expected output: false\n}\n\n"}
{"task_id": "CPP/53", "generation": "#include <iostream>  // Include iostream for input/output operations\n\nusing namespace std;\n\nint add(int x, int y) {\n    return x + y;  // Return the sum of x and y\n}\n\n// Function to test the add function with some example inputs\nvoid testAddFunction() {\n    cout << \"Testing add function:\" << endl;\n    cout << \"add(2, 3) = \" << add(2, 3) << \" (Expected: 5)\" << endl;\n    cout << \"add(5, 7) = \" << add(5, 7) << \" (Expected: 12)\" << endl;\n}\n\n"}
{"task_id": "CPP/54", "generation": "#include <iostream>\n#include <string>\n#include <unordered_set>\n\nusing namespace std;\n\nbool same_chars(string s0, string s1) {\n    // Create unordered sets to store unique characters from each string\n    unordered_set<char> chars_s0(s0.begin(), s0.end());\n    unordered_set<char> chars_s1(s1.begin(), s1.end());\n\n    // Check if both sets have the same number of elements and contain exactly the same characters\n    return chars_s0 == chars_s1;\n}\n\n"}
{"task_id": "CPP/55", "generation": "#include <stdio.h>\nusing namespace std;\n\nint fib(int n) {\n    if (n <= 0) {\n        return 0;\n    } else if (n == 1) {\n        return 1;\n    } else {\n        int a = 0, b = 1, c;\n        for (int i = 2; i <= n; ++i) {\n            c = a + b;\n            a = b;\n            b = c;\n        }\n        return b;\n    }\n}\n\n// Function to test the fib function\nvoid test_fib() {\n    printf(\"fib(10) = %d\\n\", fib(10)); // Should print 55\n    printf(\"fib(1) = %d\\n\", fib(1));   // Should print 1\n    printf(\"fib(8) = %d\\n\", fib(8));   // Should print 21\n}\n\n"}
{"task_id": "CPP/56", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    int count = 0;\n    \n    for (char c : brackets) {\n        if (c == '<') {\n            count++;\n        } else if (c == '>') {\n            count--;\n            if (count < 0) {\n                // If count goes negative, there's an unmatched closing bracket\n                return false;\n            }\n        }\n    }\n    \n    // If count is not zero at the end, there are unmatched opening brackets\n    return count == 0;\n}\n\n"}
{"task_id": "CPP/57", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool monotonic(vector<float> l) {\n    bool increasing = true;\n    bool decreasing = true;\n\n    for (size_t i = 1; i < l.size(); ++i) {\n        if (l[i] > l[i - 1]) {\n            decreasing = false;\n        } else if (l[i] < l[i - 1]) {\n            increasing = false;\n        }\n    }\n\n    return increasing || decreasing;\n}\n\n"}
{"task_id": "CPP/58", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to remove duplicates and sort a vector\nvoid unique_and_sort(vector<int>& vec) {\n    sort(vec.begin(), vec.end());\n    vec.erase(unique(vec.begin(), vec.end()), vec.end());\n}\n\n// Function to find common elements between two vectors\nvector<int> common(vector<int> l1, vector<int> l2) {\n    // Remove duplicates and sort both vectors\n    unique_and_sort(l1);\n    unique_and_sort(l2);\n\n    // Find the intersection of the two sorted vectors\n    vector<int> result;\n    set_intersection(l1.begin(), l1.end(), l2.begin(), l2.end(), back_inserter(result));\n\n    return result;\n}\n\n// Function to print a vector\nvoid print_vector(const vector<int>& vec) {\n    for (int num : vec) {\n        cout << num << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/59", "generation": "#include <iostream>\nusing namespace std;\n\nint largest_prime_factor(int n) {\n    int max_prime = -1;\n    \n    // Divide by 2 to remove all even factors\n    while (n % 2 == 0) {\n        max_prime = 2;\n        n /= 2;\n    }\n    \n    // Check for odd factors from 3 onwards\n    for (int i = 3; i * i <= n; i += 2) {\n        while (n % i == 0) {\n            max_prime = i;\n            n /= i;\n        }\n    }\n    \n    // If n is a prime number greater than 2\n    if (n > 2) {\n        max_prime = n;\n    }\n    \n    return max_prime;\n}\n\n"}
{"task_id": "CPP/60", "generation": "#include <iostream>\nusing namespace std;\n\nint sum_to_n(int n) {\n    return (n * (n + 1)) / 2;\n}\n\n"}
{"task_id": "CPP/61", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    int count = 0;\n    \n    for (char ch : brackets) {\n        if (ch == '(') {\n            ++count; // Increment counter for an opening parenthesis\n        } else if (ch == ')') {\n            --count; // Decrement counter for a closing parenthesis\n            \n            // If the counter goes negative, there are more closing parentheses than opening ones\n            if (count < 0) {\n                return false;\n            }\n        }\n    }\n    \n    // The string is correct if the counter is zero at the end\n    return count == 0;\n}\n\n"}
{"task_id": "CPP/62", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvector<float> derivative(vector<float> xs) {\n    // Create a new vector to store the coefficients of the derivative polynomial\n    vector<float> result;\n    \n    // Iterate through the input vector starting from the first non-constant term\n    for (size_t i = 1; i < xs.size(); ++i) {\n        // Multiply the coefficient by its power and add it to the result vector\n        result.push_back(xs[i] * static_cast<float>(i));\n    }\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/63", "generation": "#include <iostream>\nusing namespace std;\n\nint fibfib(int n) {\n    if (n == 0 || n == 1) return 0;\n    if (n == 2) return 1;\n\n    int a = 0, b = 0, c = 1, d;\n    for (int i = 3; i <= n; ++i) {\n        d = a + b + c;\n        a = b;\n        b = c;\n        c = d;\n    }\n    return c;\n}\n\n"}
{"task_id": "CPP/64", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint vowels_count(string s) {\n    int count = 0;\n    \n    // Convert the string to lowercase for easier comparison\n    transform(s.begin(), s.end(), s.begin(), ::tolower);\n    \n    // Check each character in the string\n    for (size_t i = 0; i < s.length(); ++i) {\n        char c = s[i];\n        \n        // Count 'a', 'e', 'i', 'o', 'u'\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n            count++;\n        }\n        \n        // Check if the last character is 'y'\n        if (i == s.length() - 1 && c == 'y') {\n            count++;\n        }\n    }\n    \n    return count;\n}\n\n"}
{"task_id": "CPP/65", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\n// Function to perform circular shift or reverse if shift > number of digits\nstring circular_shift(int x, int shift) {\n    // Convert integer to string for easy manipulation\n    string num_str = to_string(x);\n    int n = num_str.length();\n\n    // If shift is greater than the number of digits, reverse the string\n    if (shift >= n) {\n        return num_str;\n    }\n\n    // Perform circular right shift\n    shift %= n;  // In case shift > n, we use modulo to get effective shift count\n\n    // Perform the rotation\n    string result = num_str.substr(n - shift) + num_str.substr(0, n - shift);\n    \n    return result;\n}\n\n// Function to test the circular_shift function with provided examples\nvoid test_circular_shift() {\n    cout << \"circular_shift(12345, 2): \" << circular_shift(12345, 2) << endl; // Expected: \"34512\"\n    cout << \"circular_shift(12345, 7): \" << circular_shift(12345, 7) << endl; // Expected: \"12345\" (since 7 % 5 = 2)\n}\n\n"}
{"task_id": "CPP/66", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint digitSum(string s) {\n    int sum = 0;\n    for (char c : s) {\n        if (isupper(c)) { // Check if the character is uppercase\n            sum += static_cast<int>(c); // Add its ASCII value to the sum\n        }\n    }\n    return sum;\n}\n\n// Function to test the digitSum function with provided examples\nvoid check() {\n    cout << \"digitSum(\\\"\\\") => \" << digitSum(\"\") << endl; // Expected output: 0\n    cout << \"digitSum(\\\"abAB\\\") => \" << digitSum(\"abAB\") << endl; // Expected output: 131\n    cout << \"digitSum(\\\"abcCd\\\") => \" << digitSum(\"abcCd\") << endl; // Expected output: 67\n    cout << \"digitSum(\\\"helloE\\\") => \" << digitSum(\"helloE\") << endl; // Expected output: 69\n    cout << \"digitSum(\\\"woArBld\\\") => \" << digitSum(\"woArBld\") << endl; // Expected output: 131\n    cout << \"digitSum(\\\"aAaaaXa\\\") => \" << digitSum(\"aAaaaXa\") << endl; // Expected output: 153\n}\n\n"}
{"task_id": "CPP/67", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nint fruit_distribution(string s, int n) {\n    // Extract the number of apples and oranges from the string\n    size_t apple_pos = s.find(\"apples\");\n    size_t orange_pos = s.find(\"oranges\");\n\n    if (apple_pos == string::npos || orange_pos == string::npos) {\n        cout << \"Invalid input format.\" << endl;\n        return -1; // Return an error value to indicate invalid input\n    }\n\n    int apples, oranges;\n\n    // Extract the number before 'apples'\n    stringstream ss(s.substr(0, apple_pos));\n    ss >> apples;\n\n    // Extract the number after 'apples' and before 'oranges'\n    ss.clear();\n    ss.str(s.substr(apple_pos + 8, orange_pos - apple_pos - 7));\n    ss >> oranges;\n\n    // Calculate the number of mangoes\n    int mangoes = n - (apples + oranges);\n    return mangoes;\n}\n\n"}
{"task_id": "CPP/68", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> pluck(vector<int> arr) {\n    if (arr.empty()) {\n        return {};\n    }\n\n    int minEvenValue = -1;\n    int minValueIndex = -1;\n\n    for (int i = 0; i < arr.size(); ++i) {\n        if (arr[i] % 2 == 0 && (minEvenValue == -1 || arr[i] < minEvenValue)) {\n            minEvenValue = arr[i];\n            minValueIndex = i;\n        }\n    }\n\n    // If no even value was found, return an empty vector\n    if (minEvenValue == -1) {\n        return {};\n    }\n\n    return {minEvenValue, minValueIndex};\n}\n\n"}
{"task_id": "CPP/69", "generation": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint search(vector<int> lst) {\n    // Create a frequency map to count occurrences of each number\n    unordered_map<int, int> freqMap;\n    \n    // Count the frequency of each integer in the vector\n    for (int num : lst) {\n        freqMap[num]++;\n    }\n    \n    // Find the greatest integer whose frequency is >= its value\n    int result = -1;\n    for (const auto& pair : freqMap) {\n        if (pair.first <= pair.second && pair.first > result) {\n            result = pair.first;\n        }\n    }\n    \n    return result;\n}\n\n// Function to test the search function with provided examples\nvoid test() {\n    assert(search({4, 1, 2, 2, 3, 1}) == 2);\n    assert(search({1, 2, 2, 3, 3, 3, 4, 4, 4}) == 3);\n    assert(search({5, 5, 4, 4, 4}) == -1);\n    \n    cout << \"All tests passed.\" << endl;\n}\n\n"}
{"task_id": "CPP/70", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> strange_sort_list(vector<int> lst) {\n    // Sort the list to easily find min and max values\n    sort(lst.begin(), lst.end());\n    \n    vector<int> result;\n    int start = 0;  // Pointer for minimum value\n    int end = lst.size() - 1;  // Pointer for maximum value\n    \n    while (start <= end) {\n        if (start == end) {\n            // If only one element is left, add it to the result\n            result.push_back(lst[start]);\n            break;\n        }\n        \n        // Add minimum value\n        result.push_back(lst[start++]);\n        \n        // Add maximum value\n        result.push_back(lst[end--]);\n    }\n    \n    return result;\n}\n\n// Function to check the correctness of the strange_sort_list function\nvoid check() {\n    assert(strange_sort_list({1, 2, 3, 4}) == vector<int>({1, 4, 2, 3}));\n    assert(strange_sort_list({5, 5, 5, 5}) == vector<int>({5, 5, 5, 5}));\n    assert(strange_sort_list({}) == vector<int>({}));\n    cout << \"All test cases passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/71", "generation": "#include <stdio.h>\n#include <math.h>\n\nusing namespace std;\n\nfloat triangle_area(float a, float b, float c) {\n    // Check if the sides form a valid triangle\n    if (a + b <= c || a + c <= b || b + c <= a) {\n        return -1;\n    }\n\n    // Calculate the semi-perimeter\n    float s = (a + b + c) / 2.0;\n\n    // Calculate the area using Heron's formula\n    float area = sqrt(s * (s - a) * (s - b) * (s - c));\n\n    // Round to 2 decimal points\n    return round(area * 100) / 100;\n}\n\n"}
{"task_id": "CPP/72", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool will_it_fly(vector<int> q, int w) {\n    // Check if the vector is a palindrome\n    for (int i = 0; i < q.size() / 2; ++i) {\n        if (q[i] != q[q.size() - 1 - i]) {\n            return false;\n        }\n    }\n\n    // Calculate the sum of elements in the vector\n    int sum = 0;\n    for (int num : q) {\n        sum += num;\n    }\n\n    // Check if the sum is less than or equal to w\n    return sum <= w;\n}\n\n// Function to test the will_it_fly function with provided examples\nvoid test() {\n    cout << boolalpha; // Print bools as true/false instead of 1/0\n    cout << \"will_it_fly({1, 2}, 5) \u279e \" << will_it_fly({1, 2}, 5) << endl;\n    cout << \"will_it_fly({3, 2, 3}, 1) \u279e \" << will_it_fly({3, 2, 3}, 1) << endl;\n    cout << \"will_it_fly({3, 2, 3}, 9) \u279e \" << will_it_fly({3, 2, 3}, 9) << endl;\n    cout << \"will_it_fly({3}, 5) \u279e \" << will_it_fly({3}, 5) << endl;\n}\n\n"}
{"task_id": "CPP/73", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint smallest_change(vector<int> arr) {\n    int left = 0;\n    int right = arr.size() - 1;\n    int changes = 0;\n\n    while (left <= right) {\n        if (arr[left] != arr[right]) {\n            ++changes;\n        }\n        ++left;\n        --right;\n    }\n\n    return changes;\n}\n\n"}
{"task_id": "CPP/74", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to calculate the total number of characters in a vector of strings\nint count_chars(const vector<string>& vec) {\n    int total = 0;\n    for (const auto& str : vec) {\n        total += str.length();\n    }\n    return total;\n}\n\nvector<string> total_match(vector<string> lst1, vector<string> lst2) {\n    // Calculate the total number of characters in both vectors\n    int chars_lst1 = count_chars(lst1);\n    int chars_lst2 = count_chars(lst2);\n\n    // Compare and return the appropriate vector\n    if (chars_lst1 < chars_lst2) {\n        return lst1;\n    } else if (chars_lst2 < chars_lst1) {\n        return lst2;\n    } else {\n        return lst1;  // Both have the same number of characters, return the first one\n    }\n}\n\n// Function to test the total_match function with provided examples\nvoid test_total_match() {\n    assert(total_match({}, {}) == vector<string>());\n    assert(total_match({\"hi\", \"admin\"}, {\"hI\", \"Hi\"}) == vector<string>{\"hI\", \"Hi\"});\n    assert(total_match({\"hi\", \"admin\"}, {\"hi\", \"hi\", \"admin\", \"project\"}) == vector<string>{\"hi\", \"admin\"});\n    assert(total_match({\"hi\", \"admin\"}, {\"hI\", \"hi\", \"hi\"}) == vector<string>{\"hI\", \"hi\", \"hi\"});\n    assert(total_match({\"4\"}, {\"1\", \"2\", \"3\", \"4\", \"5\"}) == vector<string>{\"4\"});\n\n    cout << \"All tests passed.\" << endl;\n}\n\n"}
{"task_id": "CPP/75", "generation": "#include <iostream>\nusing namespace std;\n\n// Helper function to check if a number is prime\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\n// Main function to check if the number is a product of exactly three primes\nbool is_multiply_prime(int a) {\n    // Check all combinations of three prime numbers less than 100\n    for (int p1 = 2; p1 < 100; ++p1) {\n        if (!is_prime(p1)) continue;\n        for (int p2 = p1; p2 < 100; ++p2) {\n            if (!is_prime(p2)) continue;\n            for (int p3 = p2; p3 < 100; ++p3) {\n                if (!is_prime(p3)) continue;\n                if (p1 * p2 * p3 == a) return true;\n            }\n        }\n    }\n    return false;\n}\n\n// Function to test the is_multiply_prime function\nvoid check() {\n    cout << \"Testing is_multiply_prime(30): \" << (is_multiply_prime(30) ? \"true\" : \"false\") << endl; // Should be true\n    cout << \"Testing is_multiply_prime(105): \" << (is_multiply_prime(105) ? \"true\" : \"false\") << endl; // Should be true, 105 = 3 * 5 * 7\n    cout << \"Testing is_multiply_prime(29): \" << (is_multiply_prime(29) ? \"true\" : \"false\") << endl; // Should be false\n}\n\n"}
{"task_id": "CPP/76", "generation": "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\nbool is_simple_power(int x, int n) {\n    // Check if n is 1 and x is not 1. If so, return false.\n    if (n == 1 && x != 1) {\n        return false;\n    }\n    \n    // Calculate the logarithm of x to the base n\n    double k = log(x) / log(n);\n    \n    // Check if k is an integer by comparing it with its rounded value\n    return floor(k) == k;\n}\n\n"}
{"task_id": "CPP/77", "generation": "#include <stdio.h>\n#include <math.h>\nusing namespace std;\n\nbool iscube(int a) {\n    // Take the cube root of the absolute value of a\n    double cubeRoot = cbrt(abs(a));\n    \n    // Round the result to the nearest integer\n    int roundedCubeRoot = round(cubeRoot);\n    \n    // Cube the rounded integer and check if it equals the original number a\n    return pow(roundedCubeRoot, 3) == abs(a);\n}\n\n"}
{"task_id": "CPP/78", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\n// Helper function to check if a hexadecimal digit is prime\nbool is_prime_hex_digit(char hex_digit) {\n    // Convert the character to its integer value\n    int digit_value = hex_digit;\n    \n    // Handle uppercase letters A-F\n    if (hex_digit >= 'A' && hex_digit <= 'F') {\n        digit_value -= 'A';\n        digit_value += 10; // A is 10, B is 11, ..., F is 15\n    }\n    \n    // Check if the value is a prime number\n    switch (digit_value) {\n        case 2:\n        case 3:\n        case 5:\n        case 7:\n        case 11: // 'B' in decimal\n        case 13: // 'D' in decimal\n            return true;\n        default:\n            return false;\n    }\n}\n\n// Main function to count prime hexadecimal digits\nint hex_key(string num) {\n    int count = 0;\n    \n    for (char digit : num) {\n        if (is_prime_hex_digit(digit)) {\n            count++;\n        }\n    }\n    \n    return count;\n}\n\n"}
{"task_id": "CPP/79", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\n// Function to convert decimal to binary and format it with 'db' prefix and suffix\nstring decimal_to_binary(int decimal) {\n    // Convert decimal to binary string\n    string binary = \"\";\n    if (decimal == 0) {\n        binary = \"0\";\n    } else {\n        while (decimal > 0) {\n            int remainder = decimal % 2;\n            binary = to_string(remainder) + binary;\n            decimal /= 2;\n        }\n    }\n\n    // Add 'db' prefix and suffix\n    return \"db\" + binary + \"db\";\n}\n\n// Function to test the conversion with some examples\nvoid test_decimal_to_binary() {\n    cout << decimal_to_binary(15) << endl;   // Should print: db1111db\n    cout << decimal_to_binary(32) << endl;   // Should print: db100000db\n    cout << decimal_to_binary(0) << endl;    // Should print: db0db\n    cout << decimal_to_binary(1) << endl;    // Should print: db1db\n}\n\n"}
{"task_id": "CPP/80", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_happy(string s) {\n    // Check if the string length is less than 3\n    if (s.length() < 3) return false;\n\n    // Iterate through the string, checking every set of three consecutive characters\n    for (int i = 0; i <= s.length() - 3; ++i) {\n        // Check if any two out of these three characters are the same\n        if (s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]) {\n            return false;\n        }\n    }\n\n    // If no consecutive sets of three characters have any duplicates, the string is happy\n    return true;\n}\n\n"}
{"task_id": "CPP/81", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> numerical_letter_grade(vector<float> grades) {\n    vector<string> letter_grades;\n    \n    for (float gpa : grades) {\n        if (gpa >= 4.0f) {\n            letter_grades.push_back(\"A+\");\n        } else if (gpa > 3.7f) {\n            letter_grades.push_back(\"A\");\n        } else if (gpa > 3.3f) {\n            letter_grades.push_back(\"A-\");\n        } else if (gpa > 3.0f) {\n            letter_grades.push_back(\"B+\");\n        } else if (gpa > 2.7f) {\n            letter_grades.push_back(\"B\");\n        } else if (gpa > 2.3f) {\n            letter_grades.push_back(\"B-\");\n        } else if (gpa > 2.0f) {\n            letter_grades.push_back(\"C+\");\n        } else if (gpa > 1.7f) {\n            letter_grades.push_back(\"C\");\n        } else if (gpa > 1.3f) {\n            letter_grades.push_back(\"C-\");\n        } else if (gpa > 1.0f) {\n            letter_grades.push_back(\"D+\");\n        } else if (gpa > 0.7f) {\n            letter_grades.push_back(\"D\");\n        } else if (gpa > 0.0f) {\n            letter_grades.push_back(\"D-\");\n        } else {\n            letter_grades.push_back(\"E\");\n        }\n    }\n\n    return letter_grades;\n}\n\n"}
{"task_id": "CPP/82", "generation": "#include <iostream>\n#include <string>\n\n// Function to check if a number is prime\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    if (num == 2) return true;\n    if (num % 2 == 0) return false;\n\n    for (int i = 3; i * i <= num; i += 2) {\n        if (num % i == 0)\n            return false;\n    }\n    return true;\n}\n\n// Function to check if the length of a string is prime\nbool prime_length(const std::string& str) {\n    int len = str.length();\n    return is_prime(len);\n}\n\n"}
{"task_id": "CPP/83", "generation": "#include <iostream>\nusing namespace std;\n\nint starts_one_ends(int n) {\n    // If n is 1, there's only one number (which is 1 itself)\n    if (n == 1) return 1;\n    \n    // Count of numbers starting with 1: 10^(n-1)\n    int start_with_1 = pow(10, n - 1);\n    \n    // Count of numbers ending with 1: 9 * 10^(n-2) (first digit can't be zero and the rest can be anything from 0 to 9)\n    int end_with_1 = 9 * pow(10, n - 2);\n    \n    // Count of numbers starting and ending with 1: 9 * 10^(n-2) (the middle part can be any number except all zeros if it's the only digit left)\n    int start_and_end_with_1 = 9 * pow(10, n - 2);\n    \n    // Total count is the sum of numbers starting with 1 and ending with 1 minus those that do both\n    return start_with_1 + end_with_1 - start_and_end_with_1;\n}\n\n"}
{"task_id": "CPP/84", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\n// Function to calculate the sum of digits of N\nint sumOfDigits(int N) {\n    int sum = 0;\n    while (N > 0) {\n        sum += N % 10; // Add the last digit to the sum\n        N /= 10;       // Remove the last digit from N\n    }\n    return sum;\n}\n\n// Function to convert an integer to binary string\nstring intToBinary(int num) {\n    if (num == 0) return \"0\";\n    string binary = \"\";\n    while (num > 0) {\n        binary = to_string(num % 2) + binary; // Prepend the remainder of division by 2\n        num /= 2;\n    }\n    return binary;\n}\n\n// Main function to solve the problem\nstring solve(int N) {\n    int sum = sumOfDigits(N); // Calculate the sum of digits\n    return intToBinary(sum);   // Convert the sum to a binary string\n}\n\n"}
{"task_id": "CPP/85", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint add(vector<int> lst) {\n    int sum = 0;\n    for (size_t i = 1; i < lst.size(); i += 2) { // Start from index 1 and step by 2 to check odd indices\n        if (lst[i] % 2 == 0) { // Check if the element at the current odd index is even\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n\n"}
{"task_id": "CPP/86", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to sort characters in a word\nvoid sortWord(string& word) {\n    sort(word.begin(), word.end());\n}\n\n// Function to replace each word in the string with its sorted version\nstring anti_shuffle(const string& s) {\n    string result;\n    string currentWord;\n    \n    for (char ch : s) {\n        if (ch == ' ') {\n            // If we encounter a space, add the sorted word and space to the result\n            sortWord(currentWord);\n            result += currentWord + \" \";\n            currentWord.clear();\n        } else {\n            // Otherwise, add the character to the current word\n            currentWord += ch;\n        }\n    }\n\n    // Add the last word (if any) after the loop ends\n    if (!currentWord.empty()) {\n        sortWord(currentWord);\n        result += currentWord;\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/87", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<vector<int>> get_row(vector<vector<int>> lst, int x) {\n    vector<pair<int, int>> coordinates;\n    \n    // Collect all occurrences of x and store their positions\n    for (int i = 0; i < lst.size(); ++i) {\n        for (int j = 0; j < lst[i].size(); ++j) {\n            if (lst[i][j] == x) {\n                coordinates.push_back({i, j});\n            }\n        }\n    }\n\n    // Sort by row in ascending order and then by column in descending order within the same row\n    sort(coordinates.begin(), coordinates.end(), [](const pair<int, int>& a, const pair<int, int>& b) {\n        if (a.first == b.first) return a.second > b.second;\n        return a.first < b.first;\n    });\n\n    // Convert pairs to vector of vectors for the final result\n    vector<vector<int>> result(coordinates.size(), vector<int>(2));\n    for (int i = 0; i < coordinates.size(); ++i) {\n        result[i][0] = coordinates[i].first;\n        result[i][1] = coordinates[i].second;\n    }\n\n    return result;\n}\n\n// Function to print the result\nvoid print_result(const vector<vector<int>>& result) {\n    for (const auto& row : result) {\n        cout << \"{\" << row[0] << \", \" << row[1] << \"} \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/88", "generation": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> sort_array(vector<int> array) {\n    // Check if the input vector is empty or has only one element\n    if (array.empty() || array.size() == 1) {\n        return array;\n    }\n\n    int first = array.front();\n    int last = array.back();\n\n    // Calculate the sum of the first and last elements\n    int sum = first + last;\n\n    // Determine sorting order based on the sum being odd or even\n    vector<int> sorted_array(array);  // Make a copy to avoid modifying the original vector\n\n    if (sum % 2 == 0) {\n        // Sort in descending order\n        sort(sorted_array.begin(), sorted_array.end(), greater<int>());\n    } else {\n        // Sort in ascending order\n        sort(sorted_array.begin(), sorted_array.end());\n    }\n\n    return sorted_array;\n}\n\n// Function to test the solution with provided examples\nvoid check() {\n    vector<int> empty = {};\n    vector<int> singleElement = {5};\n    vector<int> example1 = {2, 4, 3, 0, 1, 5};\n    vector<int> example2 = {2, 4, 3, 0, 1, 5, 6};\n\n    assert(sort_array(empty) == empty);\n    assert(sort_array(singleElement) == singleElement);\n    assert(sort_array(example1) == vector<int>({0, 1, 2, 3, 4, 5}));\n    assert(sort_array(example2) == vector<int>({6, 5, 4, 3, 2, 1, 0}));\n\n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/89", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\n// Function to rotate a single character by 4 places\nchar rotateChar(char c) {\n    if (c >= 'a' && c <= 'z') {\n        return ((c - 'a' + 4) % 26) + 'a';\n    } else if (c >= 'A' && c <= 'Z') {\n        return ((c - 'A' + 4) % 26) + 'A';\n    }\n    // If the character is not a letter, return it as is\n    return c;\n}\n\n// Function to encrypt the input string by rotating each character\nstring encrypt(string s) {\n    for (char &c : s) {\n        c = rotateChar(c);\n    }\n    return s;\n}\n\n"}
{"task_id": "CPP/90", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n// Function to find the second smallest element in a vector\nstd::optional<int> next_smallest(const std::vector<int>& lst) {\n    if (lst.empty()) return std::nullopt; // Return None if the list is empty\n\n    int first = INT_MAX;\n    int second = INT_MAX;\n\n    for (int num : lst) {\n        if (num < first) {\n            second = first;\n            first = num;\n        } else if (first < num && num < second) {\n            second = num;\n        }\n    }\n\n    // If no second smallest element was found, return None\n    return (second == INT_MAX) ? std::nullopt : second;\n}\n\n// Function to test the next_smallest function\nvoid test_next_smallest() {\n    assert(next_smallest({1, 2, 3, 4, 5}) == 2);\n    assert(next_smallest({5, 1, 4, 3, 2}) == 2);\n    assert(next_smallest({}) == std::nullopt);\n    assert(next_smallest({1, 1}) == std::nullopt);\n    assert(next_smallest({10, 9, 8, 7, 6, 5, 4, 3, 2, 1}) == 2);\n\n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/91", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint is_bored(string S) {\n    int count = 0;\n    string delimiters = \".!?\";\n    \n    // Remove leading and trailing spaces\n    size_t start = S.find_first_not_of(\" \\t\");\n    if (start == string::npos)\n        return count; // If the string is empty or only contains whitespace\n\n    size_t end = S.find_last_not_of(\" \\t\");\n    S = S.substr(start, end - start + 1);\n\n    // Split the string into sentences\n    size_t pos = 0;\n    while ((pos = S.find_first_of(delimiters)) != string::npos) {\n        // Extract the sentence before the delimiter\n        string sentence = S.substr(0, pos);\n        \n        // Trim leading and trailing spaces from the sentence\n        size_t start_sentence = sentence.find_first_not_of(\" \\t\");\n        if (start_sentence == string::npos)\n            continue; // Skip empty sentences\n        \n        size_t end_sentence = sentence.find_last_not_of(\" \\t\");\n        sentence = sentence.substr(start_sentence, end_sentence - start_sentence + 1);\n        \n        // Check if the sentence starts with \"I\"\n        if (sentence.length() > 0 && sentence[0] == 'I')\n            count++;\n        \n        // Remove the processed part of the string\n        S = S.substr(pos + 1);\n    }\n    \n    return count;\n}\n\n"}
{"task_id": "CPP/92", "generation": "#include <iostream>\nusing namespace std;\n\nbool any_int(float a, float b, float c) {\n    // Check if all three numbers are integers\n    bool is_a_integer = (a == floor(a));\n    bool is_b_integer = (b == floor(b));\n    bool is_c_integer = (c == floor(c));\n\n    // If not all numbers are integers, return false\n    if (!is_a_integer || !is_b_integer || !is_c_integer) {\n        return false;\n    }\n\n    // Check if any number is equal to the sum of the other two\n    return (a == b + c) || (b == a + c) || (c == a + b);\n}\n\n"}
{"task_id": "CPP/93", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\n// Function to encode a given string by swapping cases and replacing vowels\nstring encode(string message) {\n    // Swap case of all letters\n    for (char &c : message) {\n        if (islower(c)) c = toupper(c);\n        else if (isupper(c)) c = tolower(c);\n    }\n\n    // Replace each vowel with the letter that appears 2 places ahead in the alphabet\n    string vowels = \"AEIOUaeiou\";\n    for (char &c : message) {\n        if (vowels.find(c) != string::npos) {\n            int index = vowels.find(c);\n            c = vowels[(index + 2) % vowels.size()];\n        }\n    }\n\n    return message;\n}\n\n"}
{"task_id": "CPP/94", "generation": "bool isPrime(int n) {\n    if (n <= 1) return false;\n    if (n == 2 || n == 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    for (int i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0)\n            return false;\n    }\n    return true;\n}\n"}
{"task_id": "CPP/95", "generation": "#include <iostream>\n#include <string>\n#include <map>\n\nusing namespace std;\n\nbool check_dict_case(map<string, string> dict) {\n    // Check if the map is empty\n    if (dict.empty()) {\n        return false;\n    }\n\n    // Determine the case of the first key\n    bool allLower = true;\n    for (const auto& pair : dict) {\n        if (!islower(pair.first[0])) {\n            allLower = false;\n            break;\n        }\n    }\n\n    if (allLower) {\n        return true;  // All keys are in lowercase\n    }\n\n    // Check if the first key is uppercase or mixed case\n    bool allUpper = true;\n    for (const auto& pair : dict) {\n        if (!isupper(pair.first[0])) {\n            allUpper = false;\n            break;\n        }\n    }\n\n    return allUpper;  // All keys are in uppercase\n}\n\n"}
{"task_id": "CPP/96", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Helper function to check if a number is prime\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    for (int i = 2; i * i <= num; ++i) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\n// Function to generate a vector of prime numbers less than n\nvector<int> count_up_to(int n) {\n    vector<int> primes;\n    for (int i = 2; i < n; ++i) {\n        if (is_prime(i)) {\n            primes.push_back(i);\n        }\n    }\n    return primes;\n}\n\n// Function to test the correctness of the count_up_to function\nvoid check_function() {\n    assert(count_up_to(5) == vector<int>({2, 3}));\n    assert(count_up_to(11) == vector<int>({2, 3, 5, 7}));\n    assert(count_up_to(0).empty());\n    assert(count_up_to(20) == vector<int>({2, 3, 5, 7, 11, 13, 17, 19}));\n    assert(count_up_to(1).empty());\n    assert(count_up_to(18) == vector<int>({2, 3, 5, 7, 11, 13, 17}));\n    cout << \"All test cases passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/97", "generation": "#include <iostream>\nusing namespace std;\n\nint multiply(int a, int b) {\n    // Extract the unit digit of both numbers\n    int unitDigitA = abs(a % 10);\n    int unitDigitB = abs(b % 10);\n\n    // Multiply the unit digits and return the result\n    return unitDigitA * unitDigitB;\n}\n\n"}
{"task_id": "CPP/98", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint count_upper(const string& s) {\n    int count = 0;\n    for (size_t i = 0; i < s.length(); i += 2) { // Iterate through even indices\n        char c = tolower(s[i]); // Convert the character to lowercase to simplify comparison\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n            count++;\n        }\n    }\n    return count;\n}\n\n"}
{"task_id": "CPP/99", "generation": "#include <iostream>\n#include <cmath>\n#include <string>\n\nusing namespace std;\n\nint closest_integer(string value) {\n    // Convert string to double\n    double num = stod(value);\n    \n    // Extract the fractional part of the number\n    double frac_part = modf(num, &num);\n    \n    // Check if the number is exactly halfway between two integers\n    if (fabs(frac_part - 0.5) < 1e-9 || fabs(frac_part + 0.5) < 1e-9) {\n        // If it's positive and equidistant, round away from zero\n        if (frac_part > 0) {\n            return num >= 0 ? ceil(num) : floor(num);\n        } else {\n            // If it's negative and equidistant, round away from zero\n            return num <= 0 ? ceil(num) : floor(num);\n        }\n    } else {\n        // Standard rounding\n        return round(num);\n    }\n}\n\n"}
{"task_id": "CPP/100", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Function to determine the next odd or even number\nint getNextStoneCount(int current) {\n    if (current % 2 == 0) {\n        // If current is even, return the next odd number\n        return current + 1;\n    } else {\n        // If current is odd, return the next even number\n        return current + 2;\n    }\n}\n\n// Function to make a pile of n levels of stones\nvector<int> make_a_pile(int n) {\n    vector<int> result;\n    int current_stones = n;\n\n    for (int i = 0; i < n; ++i) {\n        result.push_back(current_stones);\n        current_stones = getNextStoneCount(current_stones);\n    }\n\n    return result;\n}\n\n// Function to check the correctness of the make_a_pile function\nvoid check() {\n    vector<int> expected1 = {3, 5, 7};\n    assert(make_a_pile(3) == expected1);\n\n    vector<int> expected2 = {4, 6, 8, 10};\n    assert(make_a_pile(4) == expected2);\n\n    cout << \"All test cases passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/101", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nvector<string> words_string(const string& s) {\n    vector<string> result;\n    stringstream ss(s);\n    string word;\n\n    while (getline(ss, word, ',')) { // Split by commas first\n        stringstream wordStream(word); // Create a stream for the current word\n        while (wordStream >> word) { // Extract words from the current word stream\n            if (!word.empty()) {\n                result.push_back(word);\n            }\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/102", "generation": "#include <iostream>\nusing namespace std;\n\nint choose_num(int x, int y) {\n    // Ensure x is less than or equal to y\n    if (x > y) {\n        return -1;\n    }\n\n    // Start from the end of the range and check for the largest even number\n    for (int i = y; i >= x; --i) {\n        if (i % 2 == 0) {\n            return i;\n        }\n    }\n\n    // If no even number is found, return -1\n    return -1;\n}\n\n// Function to test the choose_num function with some examples\nvoid test() {\n    cout << \"choose_num(12, 15): \" << choose_num(12, 15) << endl; // Should output 14\n    cout << \"choose_num(13, 12): \" << choose_num(13, 12) << endl; // Should output -1\n    cout << \"choose_num(8, 10): \" << choose_num(8, 10) << endl;   // Should output 10\n    cout << \"choose_num(9, 7): \" << choose_num(9, 7) << endl;     // Should output -1\n}\n\n"}
{"task_id": "CPP/103", "generation": "#include <stdio.h>\n#include <cmath>\n#include <string>\n\nusing namespace std;\n\nstring rounded_avg(int n, int m) {\n    // Check if n is greater than m\n    if (n > m) {\n        return \"-1\";\n    }\n\n    // Calculate the sum of integers from n to m\n    long long sum = 0;\n    for (int i = n; i <= m; ++i) {\n        sum += i;\n    }\n\n    // Calculate the average and round it down\n    int avg = floor((double)sum / (m - n + 1));\n\n    // Convert the rounded integer to binary\n    string binary = \"\";\n    while (avg > 0) {\n        binary = to_string(avg % 2) + binary;\n        avg /= 2;\n    }\n\n    return binary;\n}\n\n"}
{"task_id": "CPP/104", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nbool hasEvenDigit(int num) {\n    while (num > 0) {\n        int digit = num % 10;\n        if (digit % 2 == 0) {\n            return true; // Found an even digit\n        }\n        num /= 10;\n    }\n    return false; // No even digits found\n}\n\nvector<int> unique_digits(vector<int> x) {\n    vector<int> result;\n\n    for (int num : x) {\n        if (!hasEvenDigit(num)) {\n            result.push_back(num);\n        }\n    }\n\n    sort(result.begin(), result.end());\n    return result;\n}\n\n// Function to test the implementation\nvoid test() {\n    vector<int> nums1 = {15, 33, 1422, 1};\n    vector<int> expected1 = {1, 15, 33};\n    assert(unique_digits(nums1) == expected1);\n\n    vector<int> nums2 = {152, 323, 1422, 10};\n    vector<int> expected2 = {};\n    assert(unique_digits(nums2) == expected2);\n\n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/105", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to convert number to word\nstring num_to_word(int num) {\n    map<int, string> digit_to_word = {\n        {1, \"One\"}, {2, \"Two\"}, {3, \"Three\"}, {4, \"Four\"},\n        {5, \"Five\"}, {6, \"Six\"}, {7, \"Seven\"}, {8, \"Eight\"}, {9, \"Nine\"}\n    };\n    \n    return digit_to_word[num];\n}\n\nvector<string> by_length(vector<int> arr) {\n    // Step 1: Filter out numbers not between 1 and 9\n    vector<int> filtered;\n    for (int num : arr) {\n        if (num >= 1 && num <= 9) {\n            filtered.push_back(num);\n        }\n    }\n\n    // Step 2: Sort the remaining numbers in ascending order\n    sort(filtered.begin(), filtered.end());\n\n    // Step 3: Reverse the sorted vector\n    reverse(filtered.begin(), filtered.end());\n\n    // Step 4: Replace each digit with its corresponding name\n    vector<string> result;\n    for (int num : filtered) {\n        result.push_back(num_to_word(num));\n    }\n\n    return result;\n}\n\n// Function to test the solution\nvoid test() {\n    vector<int> arr1 = {2, 1, 1, 4, 5, 8, 2, 3};\n    vector<string> expected1 = {\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"};\n    assert(by_length(arr1) == expected1);\n\n    vector<int> arr2 = {};\n    vector<string> expected2 = {};\n    assert(by_length(arr2) == expected2);\n\n    vector<int> arr3 = {1, -1, 55};\n    vector<string> expected3 = {\"One\"};\n    assert(by_length(arr3) == expected3);\n\n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/106", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Function to compute factorial of a number\nint factorial(int num) {\n    int fact = 1;\n    for (int i = 1; i <= num; ++i) {\n        fact *= i;\n    }\n    return fact;\n}\n\n// Function to compute the sum of numbers from 1 to num\nint sumToN(int num) {\n    return (num * (num + 1)) / 2;\n}\n\nvector<int> f(int n) {\n    vector<int> result(n);\n    \n    for (int i = 0; i < n; ++i) {\n        if ((i % 2) == 0) { // If index is even\n            result[i] = factorial(i + 1); // Factorial of (i+1)\n        } else { // If index is odd\n            result[i] = sumToN(i + 1); // Sum from 1 to (i+1)\n        }\n    }\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/107", "generation": "#include <iostream>\n#include <vector>\n\nbool is_palindrome(int num) {\n    std::string str = std::to_string(num);\n    int len = str.length();\n    for (int i = 0; i < len / 2; ++i) {\n        if (str[i] != str[len - i - 1]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nstd::vector<int> even_odd_palindrome(int n) {\n    int even_count = 0, odd_count = 0;\n\n    // Check single-digit numbers\n    for (int i = 1; i <= n; ++i) {\n        if (is_palindrome(i)) {\n            if (i % 2 == 0) {\n                even_count++;\n            } else {\n                odd_count++;\n            }\n        }\n    }\n\n    // Check multi-digit palindromes\n    for (int len = 2; len <= n; ++len) {\n        int start = std::pow(10, len - 1);\n        int end = std::pow(10, len) - 1;\n\n        if (start > n || end > n) break;\n\n        // Generate palindromes of length 'len'\n        for (int i = start; i <= end; ++i) {\n            std::string str = std::to_string(i);\n            int mid = len / 2;\n            std::string palindrome_str = str.substr(0, mid);\n\n            if (len % 2 == 1) { // Odd length\n                for (int j = 0; j <= 9; ++j) {\n                    std::string new_palindrome_str = palindrome_str + std::to_string(j) + std::string(palindrome_str.rbegin(), palindrome_str.rend());\n                    int num = std::stoi(new_palindrome_str);\n                    if (num > n) break;\n                    if (is_palindrome(num)) {\n                        if (num % 2 == 0) {\n                            even_count++;\n                        } else {\n                            odd_count++;\n                        }\n                    }\n                }\n            } else { // Even length\n                for (int j = 0; j <= 9; ++j) {\n                    std::string new_palindrome_str = palindrome_str + std::to_string(j);\n                    int num = std::stoi(new_palindrome_str + std::string(palindrome_str.rbegin(), palindrome_str.rend()));\n                    if (num > n) break;\n                    if (is_palindrome(num)) {\n                        if (num % 2 == 0) {\n                            even_count++;\n                        } else {\n                            odd_count++;\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    return {even_count, odd_count};\n}\n\n"}
{"task_id": "CPP/108", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint count_nums(vector<int> n) {\n    int count = 0;\n    \n    for (int num : n) {\n        if (sum_of_digits(num) > 0) {\n            count++;\n        }\n    }\n    \n    return count;\n}\n\nint sum_of_digits(int num) {\n    bool isNegative = num < 0;\n    int absNum = abs(num);\n    int sum = 0;\n\n    while (absNum != 0) {\n        int digit = absNum % 10;\n        sum += digit;\n        absNum /= 10;\n    }\n\n    // If the number was negative, subtract the first digit from the sum\n    if (isNegative && sum > 0) {\n        sum -= digit; // Subtract the last digit which is actually the first signed digit\n    }\n    \n    return sum;\n}\n\n"}
{"task_id": "CPP/109", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool move_one_ball(vector<int> arr) {\n    int n = arr.size();\n    \n    // If the vector is empty, return true\n    if (n == 0) {\n        return true;\n    }\n    \n    // Find the index where a shift would be needed to make it non-decreasing\n    for (int i = 1; i < n; ++i) {\n        if (arr[i] < arr[i - 1]) {\n            // Check if performing one right shift operation results in a sorted array\n            bool isSorted = true;\n            for (int j = 0; j < n - 1; ++j) {\n                if (arr[(j + i) % n] > arr[(j + 1 + i) % n]) {\n                    isSorted = false;\n                    break;\n                }\n            }\n            return isSorted;\n        }\n    }\n    \n    // If no such index is found, the array is already sorted\n    return true;\n}\n\n// Function to test the move_one_ball function with provided examples\nvoid check() {\n    vector<int> arr1 = {3, 4, 5, 1, 2};\n    vector<int> arr2 = {3, 5, 4, 1, 2};\n    \n    cout << (move_one_ball(arr1) ? \"true\" : \"false\") << endl; // Expected: true\n    cout << (move_one_ball(arr2) ? \"true\" : \"false\") << endl; // Expected: false\n}\n\n"}
{"task_id": "CPP/110", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring exchange(vector<int> lst1, vector<int> lst2) {\n    // Check if there are any odd numbers in lst1\n    bool has_odd_in_lst1 = false;\n    for (int num : lst1) {\n        if (num % 2 != 0) {\n            has_odd_in_lst1 = true;\n            break;\n        }\n    }\n\n    // If no odd number is found, return \"YES\"\n    if (!has_odd_in_lst1) {\n        return \"YES\";\n    }\n\n    // Count the number of odd and even elements in both lists\n    int odd_count_lst1 = 0, even_count_lst2 = 0;\n    for (int num : lst1) {\n        if (num % 2 != 0) {\n            odd_count_lst1++;\n        }\n    }\n    for (int num : lst2) {\n        if (num % 2 == 0) {\n            even_count_lst2++;\n        }\n    }\n\n    // Check if we have enough even numbers in lst2 to exchange with the odd numbers in lst1\n    if (odd_count_lst1 <= even_count_lst2) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n\n// Function to test the solution\nvoid test() {\n    cout << exchange({1, 2, 3, 4}, {1, 2, 3, 4}) << endl; // Expected: \"YES\"\n    cout << exchange({1, 2, 3, 4}, {1, 5, 3, 4}) << endl; // Expected: \"NO\"\n}\n\n"}
{"task_id": "CPP/111", "generation": "#include <iostream>\n#include <string>\n#include <map>\n#include <vector>\nusing namespace std;\n\n// Function to get the histogram (frequency map) of characters in a string\nmap<char, int> histogram(string test) {\n    map<char, int> letterCount;\n    \n    // Count occurrences of each character\n    for (char c : test) {\n        if (c != ' ') {  // Ignore spaces\n            letterCount[c]++;\n        }\n    }\n\n    // Find the maximum count\n    int maxCount = 0;\n    for (const auto& pair : letterCount) {\n        if (pair.second > maxCount) {\n            maxCount = pair.second;\n        }\n    }\n\n    // Create a map to store letters with the highest frequency\n    map<char, int> result;\n\n    // Populate the result map with letters that have the maximum count\n    for (const auto& pair : letterCount) {\n        if (pair.second == maxCount) {\n            result.insert(pair);\n        }\n    }\n\n    return result;\n}\n\n// Function to print the histogram map\nvoid printHistogram(const map<char, int>& hist) {\n    for (const auto& pair : hist) {\n        cout << \"{\" << pair.first << \", \" << pair.second << \"} \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/112", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nbool is_palindrome(const string& str) {\n    int left = 0;\n    int right = str.size() - 1;\n    \n    while (left < right) {\n        if (str[left] != str[right]) {\n            return false;\n        }\n        ++left;\n        --right;\n    }\n    \n    return true;\n}\n\nvector<string> reverse_delete(string s, string c) {\n    // Remove all characters in s that are present in c\n    for (char ch : c) {\n        s.erase(remove(s.begin(), s.end(), ch), s.end());\n    }\n\n    // Check if the resulting string is a palindrome\n    bool result = is_palindrome(s);\n    \n    return {s, to_string(result)};\n}\n\n"}
{"task_id": "CPP/113", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<string> odd_count(vector<string> lst) {\n    vector<string> result;\n    for (const auto& str : lst) {\n        int count = 0;\n        // Count the number of odd digits in the string\n        for (char c : str) {\n            if ((c - '0') % 2 != 0) {\n                count++;\n            }\n        }\n        \n        // Construct the result string with the appropriate replacements\n        string output = \"the number of odd elements \";\n        output += to_string(count);\n        output += \"n the str\";\n        output += to_string(count);\n        output += \"ng \";\n        output += to_string(count);\n        output += \" of the \";\n        output += to_string(count);\n        output += \"nput.\";\n        \n        result.push_back(output);\n    }\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/114", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nlong long minSubArraySum(vector<long long> nums) {\n    if (nums.empty()) return 0; // Handle empty vector case\n\n    long long min_sum = nums[0];\n    long long current_sum = nums[0];\n\n    for (size_t i = 1; i < nums.size(); ++i) {\n        // Update the current sum to be the minimum of the current element or\n        // the current sum plus the current element.\n        current_sum = min(nums[i], current_sum + nums[i]);\n        \n        // Update the minimum sum found so far.\n        min_sum = min(min_sum, current_sum);\n    }\n\n    return min_sum;\n}\n\n"}
{"task_id": "CPP/115", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint max_fill(vector<vector<int>> grid, int capacity) {\n    int total_lowerings = 0;\n    \n    // Iterate over each well (row in the grid)\n    for (const auto& row : grid) {\n        int water_units = 0;\n        \n        // Count the number of 1s in the current row\n        for (int unit : row) {\n            if (unit == 1) {\n                ++water_units;\n            }\n        }\n        \n        // Calculate the number of times the bucket needs to be lowered\n        total_lowerings += (water_units + capacity - 1) / capacity;\n    }\n    \n    return total_lowerings;\n}\n\n"}
{"task_id": "CPP/116", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\n// Function to count the number of ones in the binary representation of an integer\nint count_ones(int n) {\n    int count = 0;\n    while (n > 0) {\n        count += n & 1; // Check if the least significant bit is set\n        n >>= 1; // Right shift to check the next bit\n    }\n    return count;\n}\n\n// Custom comparator for sorting\nbool custom_sort(int a, int b) {\n    int ones_a = count_ones(a);\n    int ones_b = count_ones(b);\n\n    if (ones_a == ones_b) {\n        return a < b; // Sort by decimal value if the number of ones is the same\n    }\n    return ones_a < ones_b; // Otherwise, sort by the number of ones\n}\n\n// Function to sort the array based on the custom comparator\nstd::vector<int> sort_array(std::vector<int> arr) {\n    std::sort(arr.begin(), arr.end(), custom_sort);\n    return arr;\n}\n\n"}
{"task_id": "CPP/117", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\n// Helper function to check if a character is a consonant.\nbool is_consonant(char c) {\n    return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z');\n}\n\n// Helper function to count the number of consonants in a word.\nint count_consonants(const string& word) {\n    int count = 0;\n    for (char c : word) {\n        if (is_consonant(c)) {\n            ++count;\n        }\n    }\n    return count;\n}\n\nvector<string> select_words(string s, int n) {\n    vector<string> result;\n    // Split the string into words.\n    string current_word = \"\";\n    for (char c : s) {\n        if (c == ' ') {  // End of a word\n            if (!current_word.empty() && count_consonants(current_word) == n) {\n                result.push_back(current_word);\n            }\n            current_word.clear();\n        } else {\n            current_word += c;\n        }\n    }\n    // Check the last word in case there is no space at the end of the string.\n    if (!current_word.empty() && count_consonants(current_word) == n) {\n        result.push_back(current_word);\n    }\n    return result;\n}\n\n// Function to test the select_words function with provided examples.\nvoid test_select_words() {\n    assert(select_words(\"Mary had a little lamb\", 4) == vector<string>{\"little\"});\n    assert(select_words(\"Mary had a little lamb\", 3) == vector<string>{\"Mary\", \"lamb\"});\n    assert(select_words(\"simple white space\", 2) == vector<string>{});\n    assert(select_words(\"Hello world\", 4) == vector<string>{\"world\"});\n    assert(select_words(\"Uncle sam\", 3) == vector<string>{\"Uncle\"});\n\n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/118", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_vowel(char c) {\n    return c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' ||\n           c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U';\n}\n\nbool is_consonant(char c) {\n    return !is_vowel(c) && isalpha(c);\n}\n\nstring get_closest_vowel(string word) {\n    int n = word.length();\n    \n    // Traverse the string from right to left\n    for (int i = n - 2; i > 0; --i) {\n        if (is_consonant(word[i]) && is_consonant(word[i + 1])) {\n            // Check if the character before the current consonant is a vowel\n            if (is_vowel(word[i - 1])) {\n                return string(1, word[i - 1]);\n            }\n        }\n    }\n\n    // If no such vowel is found, return an empty string\n    return \"\";\n}\n\n"}
{"task_id": "CPP/119", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Helper function to check if a string is balanced\nbool is_balanced(const string& s) {\n    int balance = 0;\n    for (char c : s) {\n        if (c == '(') {\n            balance++;\n        } else if (c == ')') {\n            balance--;\n            if (balance < 0) {\n                return false; // More closing parentheses than opening\n            }\n        }\n    }\n    return balance == 0; // True if balanced, false otherwise\n}\n\n// Main function to check if concatenation of two strings can result in a good string\nstring match_parens(vector<string> lst) {\n    // Check both possible concatenations\n    string s1 = lst[0] + lst[1];\n    string s2 = lst[1] + lst[0];\n\n    // Check if either concatenated string is balanced\n    if (is_balanced(s1) || is_balanced(s2)) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\n\n// Function to test the match_parens function with provided examples\nvoid check() {\n    cout << match_parens({\"()(\", \")\"}); // Expected output: Yes\n    cout << endl;\n    cout << match_parens({\")\", \")\"});   // Expected output: No\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/120", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> maximum(vector<int> arr, int k) {\n    // Sort the array in ascending order\n    sort(arr.begin(), arr.end());\n    \n    // If k is 0 or negative, return an empty vector\n    if (k <= 0) {\n        return {};\n    }\n    \n    // Return a sub-vector of length k from the end of the sorted array\n    return vector<int>(arr.rbegin(), arr.rbegin() + k);\n}\n\n"}
{"task_id": "CPP/121", "generation": "#include <vector>\nusing namespace std;\n\nint solution(vector<int> lst) {\n    int sum = 0;\n    for (size_t i = 0; i < lst.size(); ++i) {\n        // Check if the index is even and the element at that position is odd\n        if (i % 2 == 0 && lst[i] % 2 != 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n\n// Function to test the solution with provided examples\nvoid check() {\n    assert(solution({5, 8, 7, 1}) == 12);\n    assert(solution({3, 3, 3, 3, 3}) == 9);\n    assert(solution({30, 13, 24, 321}) == 0);\n}\n\n"}
{"task_id": "CPP/122", "generation": "#include <stdio.h>\n#include <vector>\n\nusing namespace std;\n\nint add_elements(vector<int> arr, int k) {\n    int sum = 0;\n    \n    // Iterate through the first k elements of the vector\n    for (int i = 0; i < k; ++i) {\n        // Check if the current element has at most two digits\n        if (arr[i] >= -99 && arr[i] <= 99) {\n            sum += arr[i];\n        }\n    }\n    \n    return sum;\n}\n\n// Function to test the solution with provided data points\nvoid check_solution() {\n    vector<int> arr1 = {111, 21, 3, 4000, 5, 6, 7, 8, 9};\n    int k1 = 4;\n    printf(\"Test 1: Expected output is 24, Actual output is %d\\n\", add_elements(arr1, k1));\n    \n    vector<int> arr2 = {10, 20, 30, 40, 50};\n    int k2 = 5;\n    printf(\"Test 2: Expected output is 150, Actual output is %d\\n\", add_elements(arr2, k2));\n    \n    vector<int> arr3 = {9876, -123, 456, -789, 101};\n    int k3 = 3;\n    printf(\"Test 3: Expected output is -123, Actual output is %d\\n\", add_elements(arr3, k3));\n}\n\n"}
{"task_id": "CPP/123", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n// Function to generate and return the odd numbers in the Collatz sequence of n.\nvector<int> get_odd_collatz(int n) {\n    vector<int> result;\n    \n    // Generate the Collatz sequence until it reaches 1\n    while (n != 1) {\n        if (n % 2 == 0) {\n            n = n / 2;  // If n is even, divide by 2\n        } else {\n            result.push_back(n);  // If n is odd, add to the result vector and then apply the Collatz rule\n            n = 3 * n + 1;\n        }\n    }\n    \n    // Add the final number 1 to the result vector as it's always an odd number in the sequence\n    result.push_back(1);\n    \n    // Sort the result vector in increasing order\n    sort(result.begin(), result.end());\n    \n    return result;\n}\n\n// Function to test the get_odd_collatz function with some examples\nvoid test_get_odd_collatz() {\n    cout << \"Testing get_odd_collatz...\" << endl;\n    vector<int> result1 = get_odd_collatz(5);\n    for (int num : result1) {\n        cout << num << \" \";\n    }\n    cout << endl;\n\n    vector<int> result2 = get_odd_collatz(7);\n    for (int num : result2) {\n        cout << num << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/124", "generation": "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nbool valid_date(string date) {\n    // Check if the date string is empty or not in the correct format mm-dd-yyyy\n    if (date.length() != 10 || date[2] != '-' || date[5] != '-') {\n        return false;\n    }\n\n    // Extract month, day, and year from the date string\n    int month = stoi(date.substr(0, 2));\n    int day = stoi(date.substr(3, 2));\n    int year = stoi(date.substr(6));\n\n    // Validate the month\n    if (month < 1 || month > 12) {\n        return false;\n    }\n\n    // Validate the day based on the month\n    vector<int> thirtyOneDayMonths = {1, 3, 5, 7, 8, 10, 12};\n    vector<int> thirtyDayMonths = {4, 6, 9, 11};\n\n    if (find(thirtyOneDayMonths.begin(), thirtyOneDayMonths.end(), month) != thirtyOneDayMonths.end()) {\n        // Month has 31 days\n        if (day < 1 || day > 31) {\n            return false;\n        }\n    } else if (find(thirtyDayMonths.begin(), thirtyDayMonths.end(), month) != thirtyDayMonths.end()) {\n        // Month has 30 days\n        if (day < 1 || day > 30) {\n            return false;\n        }\n    } else {\n        // February\n        if (day < 1 || day > 29) {\n            return false;\n        }\n    }\n\n    // If all validations pass, the date is valid\n    return true;\n}\n\n"}
{"task_id": "CPP/125", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nvector<string> split_words(string txt) {\n    vector<string> result;\n    \n    // Check for whitespace splitting\n    if (txt.find(' ') != string::npos) {\n        size_t start = 0;\n        size_t end = txt.find(' ');\n        while (end != string::npos) {\n            result.push_back(txt.substr(start, end - start));\n            start = end + 1;\n            end = txt.find(' ', start);\n        }\n        result.push_back(txt.substr(start)); // Add the last word\n    } \n    // Check for comma splitting\n    else if (txt.find(',') != string::npos) {\n        size_t start = 0;\n        size_t end = txt.find(',');\n        while (end != string::npos) {\n            result.push_back(txt.substr(start, end - start));\n            start = end + 1;\n            end = txt.find(',', start);\n        }\n        result.push_back(txt.substr(start)); // Add the last word\n    } \n    // Count lowercase letters with odd order in the alphabet\n    else {\n        int count = 0;\n        for (char c : txt) {\n            if (islower(c)) {\n                int letterValue = tolower(c) - 'a';\n                if (letterValue % 2 == 1) {\n                    count++;\n                }\n            }\n        }\n        result.push_back(to_string(count));\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/126", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nbool is_sorted(vector<int> lst) {\n    // Check if the list is already sorted or not\n    bool ascending = true;\n    for (int i = 1; i < lst.size(); ++i) {\n        if (lst[i] < lst[i - 1]) {\n            ascending = false;\n            break;\n        }\n    }\n\n    // If the list is not sorted, return false\n    if (!ascending) return false;\n\n    // Check for any number appearing more than twice\n    int count = 1;\n    for (int i = 1; i < lst.size(); ++i) {\n        if (lst[i] == lst[i - 1]) {\n            count++;\n            if (count > 2) return false;\n        } else {\n            count = 1;\n        }\n    }\n\n    // If all checks pass, the list is sorted and no number appears more than twice\n    return true;\n}\n\n"}
{"task_id": "CPP/127", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    if (n == 2) return true;\n    if (n % 2 == 0) return false;\n    for (int i = 3; i * i <= n; i += 2) {\n        if (n % i == 0)\n            return false;\n    }\n    return true;\n}\n\n// Function to find the intersection of two intervals\nvector<int> intersect(vector<int> interval1, vector<int> interval2) {\n    int start = max(interval1[0], interval2[0]);\n    int end = min(interval1[1], interval2[1]);\n    \n    if (start > end) return {}; // No intersection\n    \n    return {start, end};\n}\n\n// Function to determine if the length of the intersection is a prime number\nstring intersection(vector<int> interval1, vector<int> interval2) {\n    vector<int> inter = intersect(interval1, interval2);\n    \n    if (inter.empty()) return \"NO\";\n    \n    int length = inter[1] - inter[0];\n    \n    if (is_prime(length)) return \"YES\";\n    else return \"NO\";\n}\n\n"}
{"task_id": "CPP/128", "generation": "#include <iostream>\n#include <vector>\n\nint prod_signs(const std::vector<int>& arr) {\n    if (arr.empty()) {\n        return -32768;\n    }\n\n    int product_of_signs = 1;\n    int sum_of_magnitudes = 0;\n\n    for (const auto& num : arr) {\n        // Calculate the product of signs\n        if (num < 0) {\n            product_of_signs *= -1;\n        } else if (num == 0) {\n            product_of_signs = 0;\n            break; // If any number is zero, the product will be zero.\n        }\n\n        // Calculate the sum of magnitudes\n        sum_of_magnitudes += std::abs(num);\n    }\n\n    return product_of_signs * sum_of_magnitudes;\n}\n\n// Function to test the prod_signs function with provided examples\nvoid check() {\n    assert(prod_signs({1, 2, 2, -4}) == -9);\n    assert(prod_signs({0, 1}) == 0);\n    assert(prod_signs({}) == -32768);\n\n    std::cout << \"All test cases passed!\" << std::endl;\n}\n\n"}
{"task_id": "CPP/129", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int N = 10; // Maximum size of the grid\n\n// Directions for moving up, down, left, right\nint dx[] = {-1, 1, 0, 0};\nint dy[] = {0, 0, -1, 1};\n\nvector<int> minPath(vector<vector<int>>& grid, int k) {\n    int n = grid.size();\n    vector<vector<vector<bool>>> visited(n, vector<vector<bool>>(n, vector<bool>(k + 1, false)));\n    \n    // Recursive function to find the minimum path\n    auto dfs = [&](int x, int y, int len, vector<int>& path) -> bool {\n        if (len == k) {\n            return true;\n        }\n        \n        visited[x][y][len] = true;\n        for (int i = 0; i < 4; ++i) {\n            int nx = x + dx[i];\n            int ny = y + dy[i];\n            \n            if (nx >= 0 && nx < n && ny >= 0 && ny < n && !visited[nx][ny][len]) {\n                path.push_back(grid[nx][ny]);\n                if (dfs(nx, ny, len + 1, path)) {\n                    return true;\n                }\n                path.pop_back();\n            }\n        }\n        \n        visited[x][y][len] = false;\n        return false;\n    };\n    \n    vector<int> minPathValues;\n    int minPathValue = INT_MAX;\n    \n    // Try starting from each cell\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            vector<int> path;\n            if (dfs(i, j, 1, path)) {\n                int pathValue = 0;\n                for (auto val : path) {\n                    pathValue = pathValue * 10 + val;\n                }\n                if (pathValue < minPathValue) {\n                    minPathValues = path;\n                    minPathValue = pathValue;\n                }\n            }\n        }\n    }\n    \n    return minPathValues;\n}\n\n"}
{"task_id": "CPP/130", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Function to compute the n-th Tribonacci number\nint tribonacci(int n) {\n    if (n == 0) return 3;\n    else if (n % 2 == 0) return 1 + n / 2;\n    else {\n        // Base cases for the first few odd numbers\n        if (n == 1) return 3;\n        if (n == 3) return 8;\n\n        int a = 3, b = 2, c = 8; // tri(0), tri(1), and tri(3)\n        for (int i = 4; i <= n; ++i) {\n            int next = a + b + c;\n            a = b;\n            b = c;\n            c = next;\n        }\n        return c;\n    }\n}\n\n// Function to generate the first n+1 Tribonacci numbers\nvector<int> tri(int n) {\n    vector<int> result(n + 1);\n    for (int i = 0; i <= n; ++i) {\n        result[i] = tribonacci(i);\n    }\n    return result;\n}\n\n// Main function to test the implementation\n"}
{"task_id": "CPP/131", "generation": "#include <iostream>\nusing namespace std;\n\nint digits(int n) {\n    int product = 1;\n    bool hasOddDigit = false;\n\n    while (n > 0) {\n        int digit = n % 10; // Get the last digit of n\n        if (digit % 2 != 0) { // Check if the digit is odd\n            product *= digit; // Multiply it to the product\n            hasOddDigit = true;\n        }\n        n /= 10; // Remove the last digit from n\n    }\n\n    return hasOddDigit ? product : 0; // Return the product if there was at least one odd digit, otherwise return 0\n}\n\n"}
{"task_id": "CPP/132", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_nested(string str) {\n    int balance = 0;\n    bool hasNested = false;\n\n    for (char ch : str) {\n        if (ch == '[') {\n            balance++;\n            // Check if there's a nested pair before this opening bracket\n            if (balance > 1 && !hasNested) {\n                hasNested = true;\n            }\n        } else if (ch == ']') {\n            balance--;\n            if (balance < 0) {\n                return false; // Unmatched closing bracket\n            }\n        }\n    }\n\n    // Check if there's at least one nested pair and the string is balanced\n    return hasNested && balance == 0;\n}\n\n"}
{"task_id": "CPP/133", "generation": "#include <iostream>\n#include <cmath>\n#include <vector>\n\nusing namespace std;\n\nint sum_squares(vector<float> lst) {\n    int sum = 0;\n    for (float num : lst) {\n        // Round to the nearest upper integer\n        float ceil_num = ceil(num);\n        // Square the rounded number and add it to the sum\n        sum += static_cast<int>(ceil_num * ceil_num);\n    }\n    return sum;\n}\n\n"}
{"task_id": "CPP/134", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool check_if_last_char_is_a_letter(string txt) {\n    // Check if the string is empty or has only one non-space character\n    if (txt.empty() || (txt.size() == 1 && !isspace(txt[0]))) {\n        return false;\n    }\n\n    // Get the last two characters of the string\n    char second_last_char = txt[txt.size() - 2];\n    char last_char = txt[txt.size() - 1];\n\n    // Check if the last character is a space and the second-to-last character is not a space\n    return isspace(last_char) && !isspace(second_last_char);\n}\n\n"}
{"task_id": "CPP/135", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint can_arrange(vector<int> arr) {\n    int n = arr.size();\n    \n    // Iterate from the second last element to the first element\n    for (int i = n - 2; i >= 0; --i) {\n        if (arr[i] > arr[i + 1]) {\n            return i;\n        }\n    }\n    \n    // If no such element is found, return -1\n    return -1;\n}\n\n// Function to test the can_arrange function with provided examples\nvoid check() {\n    cout << \"can_arrange({1,2,4,3,5}) = \" << can_arrange({1, 2, 4, 3, 5}) << endl; // Expected output: 3\n    cout << \"can_arrange({1,2,3}) = \" << can_arrange({1, 2, 3}) << endl;          // Expected output: -1\n}\n\n"}
{"task_id": "CPP/136", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Function to find the largest negative and smallest positive integers in a vector\nvector<int> largest_smallest_integers(vector<int> lst) {\n    int largest_negative = 0;\n    int smallest_positive = 0;\n\n    for (int num : lst) {\n        if (num < 0 && num > largest_negative) {\n            largest_negative = num;\n        } else if (num > 0 && (smallest_positive == 0 || num < smallest_positive)) {\n            smallest_positive = num;\n        }\n    }\n\n    return {largest_negative, smallest_positive};\n}\n\n// Function to test the correctness of the function\nvoid test() {\n    vector<int> lst1 = {2, 4, 1, 3, 5, 7};\n    vector<int> result1 = largest_smallest_integers(lst1);\n    cout << \"Test 1: \" << (result1 == vector<int>{0, 1} ? \"Passed\" : \"Failed\") << endl;\n\n    vector<int> lst2 = {};\n    vector<int> result2 = largest_smallest_integers(lst2);\n    cout << \"Test 2: \" << (result2 == vector<int>{0, 0} ? \"Passed\" : \"Failed\") << endl;\n\n    vector<int> lst3 = {0};\n    vector<int> result3 = largest_smallest_integers(lst3);\n    cout << \"Test 3: \" << (result3 == vector<int>{0, 0} ? \"Passed\" : \"Failed\") << endl;\n}\n\n"}
{"task_id": "CPP/137", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <boost/any.hpp>\n\n// Function to compare two boost::any values and return the larger one in its original type.\nboost::any compare_one(boost::any a, boost::any b) {\n    // Convert both values to strings for comparison\n    std::string strA = boost::any_cast<std::string>(a);\n    std::string strB = boost::any_cast<std::string>(b);\n\n    // Replace comma with dot in the string representations if necessary\n    std::replace(strA.begin(), strA.end(), ',', '.');\n    std::replace(strB.begin(), strB.end(), ',', '.');\n\n    // Convert strings to doubles for comparison\n    double numA = std::stod(strA);\n    double numB = std::stod(strB);\n\n    if (numA > numB) {\n        return a;\n    } else if (numB > numA) {\n        return b;\n    } else {\n        return \"None\";\n    }\n}\n\n"}
{"task_id": "CPP/138", "generation": "#include <iostream>\nusing namespace std;\n\nbool is_equal_to_sum_even(int n) {\n    // Check if n is less than 8 or not even\n    if (n < 8 || n % 2 != 0) {\n        return false;\n    }\n    \n    // If n is at least 8 and even, it can be written as the sum of four positive even numbers\n    return true;\n}\n\n"}
{"task_id": "CPP/139", "generation": "#include <iostream>\n\n// Function to calculate factorial of a number\nlong long factorial(long long num) {\n    if (num == 0 || num == 1)\n        return 1;\n    else\n        return num * factorial(num - 1);\n}\n\n// Function to calculate Brazilian factorial\nlong long special_factorial(int n) {\n    long long result = 1;\n    for (int i = n; i > 0; --i) {\n        result *= factorial(i);\n    }\n    return result;\n}\n\n"}
{"task_id": "CPP/140", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring fix_spaces(string text) {\n    int n = text.length();\n    bool in_consecutive_spaces = false;\n    for (int i = 0; i < n; ++i) {\n        if (text[i] == ' ') {\n            // Check if we are already inside a sequence of spaces\n            if (in_consecutive_spaces) {\n                continue;\n            } else {\n                in_consecutive_spaces = true;\n            }\n        } else {\n            // If we were in consecutive spaces, replace them with '-'\n            if (in_consecutive_spaces) {\n                text[i - 1] = '-';\n                in_consecutive_spaces = false;\n            }\n            // Replace all other spaces with '_'\n            if (text[i] == ' ') {\n                text[i] = '_';\n            }\n        }\n    }\n\n    // Handle the last sequence of spaces\n    if (in_consecutive_spaces) {\n        text[n - 1] = '-';\n    }\n\n    return text;\n}\n\n"}
{"task_id": "CPP/141", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_valid_char(char c) {\n    return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || (c >= '0' && c <= '9');\n}\n\nstring file_name_check(string file_name) {\n    int digit_count = 0;\n    bool has_dot = false;\n    bool valid_start = false;\n    string extension;\n\n    // Check for the first dot and count digits\n    for (int i = 0; i < file_name.length(); ++i) {\n        if (file_name[i] == '.') {\n            if (!has_dot) {\n                has_dot = true;\n                continue;\n            } else {\n                return \"No\"; // More than one dot found\n            }\n        }\n\n        if (is_valid_char(file_name[i])) {\n            valid_start = i == 0 || is_valid_char(file_name[i - 1]);\n        }\n\n        if (isdigit(file_name[i])) {\n            digit_count++;\n            if (digit_count > 3) return \"No\"; // More than three digits found\n        }\n    }\n\n    // Check for the extension after the dot\n    int dot_index = file_name.find('.');\n    if (dot_index != string::npos && dot_index < file_name.length() - 1) {\n        extension = file_name.substr(dot_index + 1);\n        if (extension == \"txt\" || extension == \"exe\" || extension == \"dll\") {\n            return valid_start ? \"Yes\" : \"No\"; // Check for valid start\n        } else {\n            return \"No\";\n        }\n    }\n\n    return \"No\"; // No dot found or invalid format\n}\n\n"}
{"task_id": "CPP/142", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint sum_squares(vector<int> lst) {\n    int sum = 0;\n    \n    // Iterate through each element in the vector\n    for (size_t i = 0; i < lst.size(); ++i) {\n        if ((i + 1) % 3 == 0 && (i + 1) % 4 != 0) {\n            sum += lst[i] * lst[i]; // Square the element\n        } else if ((i + 1) % 4 == 0) {\n            sum += lst[i] * lst[i] * lst[i]; // Cube the element\n        }\n    }\n    \n    return sum;\n}\n\n// Function to test the implementation with provided examples\nvoid test() {\n    cout << \"Test 1: {1,2,3} -> Expected: 6, Got: \" << sum_squares({1, 2, 3}) << endl;\n    cout << \"Test 2: {} -> Expected: 0, Got: \" << sum_squares({}) << endl;\n    cout << \"Test 3: {-1,-5,2,-1,-5} -> Expected: -126, Got: \" << sum_squares({-1, -5, 2, -1, -5}) << endl;\n}\n\n"}
{"task_id": "CPP/143", "generation": "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    if (n == 2 || n == 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    for (int i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0)\n            return false;\n    }\n    return true;\n}\n\n// Function to split the sentence into words\nvector<string> split_sentence(const string& sentence) {\n    vector<string> words;\n    string word;\n    for (char ch : sentence) {\n        if (ch != ' ') {\n            word += ch;\n        } else {\n            if (!word.empty()) {\n                words.push_back(word);\n                word.clear();\n            }\n        }\n    }\n    if (!word.empty()) {\n        words.push_back(word);\n    }\n    return words;\n}\n\n// Function to get the sentence with prime length words\nstring words_in_sentence(const string& sentence) {\n    vector<string> words = split_sentence(sentence);\n    string result;\n\n    for (const auto& word : words) {\n        if (is_prime(word.length())) {\n            if (!result.empty()) {\n                result += \" \";\n            }\n            result += word;\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/144", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\n// Function to parse the numerator and denominator from the string representation\npair<int, int> parseFraction(const string& fraction) {\n    size_t slashPos = fraction.find('/');\n    int numerator = stoi(fraction.substr(0, slashPos));\n    int denominator = stoi(fraction.substr(slashPos + 1));\n    return {numerator, denominator};\n}\n\n// Function to simplify the expression x * n and check if it evaluates to a whole number\nbool simplify(string x, string n) {\n    // Parse both fractions\n    auto [numX, denomX] = parseFraction(x);\n    auto [numN, denomN] = parseFraction(n);\n\n    // Multiply numerators and denominators\n    int productNum = numX * numN;\n    int productDenom = denomX * denomN;\n\n    // Check if the result is a whole number\n    return (productNum % productDenom == 0);\n}\n\n"}
{"task_id": "CPP/145", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// Helper function to calculate the sum of digits of an integer\nint digitSum(int n) {\n    int sum = 0;\n    bool isNegative = n < 0;\n    while (n != 0) {\n        int digit = abs(n % 10);\n        sum += digit;\n        n /= 10;\n    }\n    if (isNegative) {\n        // If the number was negative, subtract the first digit\n        sum -= 2 * abs(n % 10); // Subtract twice the absolute value of the last digit to account for the leading negative sign\n    }\n    return sum;\n}\n\n// Custom comparator function based on digit sum and original index\nbool compareByDigitSum(const int& a, const int& b) {\n    int sumA = digitSum(a);\n    int sumB = digitSum(b);\n    \n    if (sumA == sumB) {\n        // If the sums are equal, use the original index as tiebreaker\n        return a < b;\n    }\n    return sumA < sumB;\n}\n\nvector<int> order_by_points(vector<int> nums) {\n    // Sort the vector using the custom comparator\n    sort(nums.begin(), nums.end(), compareByDigitSum);\n    return nums;\n}\n\n// Function to print the vector for testing purposes\nvoid printVector(const vector<int>& vec) {\n    for (int num : vec) {\n        cout << num << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/146", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nint specialFilter(vector<int> nums) {\n    int count = 0;\n    \n    for (int num : nums) {\n        // Skip numbers less than or equal to 10\n        if (num <= 10) continue;\n        \n        string strNum = to_string(num);\n        int firstDigit = strNum[0] - '0';\n        int lastDigit = strNum[strNum.length() - 1] - '0';\n        \n        // Check if both digits are odd\n        if ((firstDigit % 2 != 0) && (lastDigit % 2 != 0)) {\n            count++;\n        }\n    }\n    \n    return count;\n}\n\n"}
{"task_id": "CPP/147", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint get_max_triples(int n) {\n    // Step 1: Generate vector a\n    vector<int> a(n);\n    for (int i = 1; i <= n; ++i) {\n        a[i - 1] = i * i - i + 1;\n    }\n\n    int count = 0;\n\n    // Step 2 and 3: Iterate through all possible triples\n    for (int i = 0; i < n - 2; ++i) {\n        for (int j = i + 1; j < n - 1; ++j) {\n            for (int k = j + 1; k < n; ++k) {\n                if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                    count++;\n                }\n            }\n        }\n    }\n\n    return count;\n}\n\n// Example usage\n"}
{"task_id": "CPP/148", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to find the index of a planet in the list\nint findPlanetIndex(const string& planet, const vector<string>& planets) {\n    for (size_t i = 0; i < planets.size(); ++i) {\n        if (planets[i] == planet) return static_cast<int>(i);\n    }\n    return -1;\n}\n\nvector<string> bf(string planet1, string planet2) {\n    // List of planets in order from closest to farthest from the Sun\n    vector<string> planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n    \n    // Find indices of input planets\n    int index1 = findPlanetIndex(planet1, planets);\n    int index2 = findPlanetIndex(planet2, planets);\n\n    // Check if both planets are valid and in the correct order\n    if (index1 == -1 || index2 == -1) {\n        return {};  // Return empty vector if either planet is invalid\n    }\n    if (index1 > index2) {\n        swap(index1, index2);  // Ensure index1 < index2 for correct range\n    }\n\n    // Collect planets between the two indices\n    vector<string> result;\n    for (int i = index1 + 1; i < index2; ++i) {\n        result.push_back(planets[i]);\n    }\n    \n    return result;\n}\n\n// Function to test the bf function with examples\nvoid test() {\n    vector<string> result;\n\n    // Test cases\n    result = bf(\"Jupiter\", \"Neptune\");\n    for (const auto& planet : result) cout << planet << \" \";\n    cout << endl;  // Expected output: Saturn Uranus\n\n    result = bf(\"Earth\", \"Mercury\");\n    for (const auto& planet : result) cout << planet << \" \";\n    cout << endl;  // Expected output: Venus\n\n    result = bf(\"Mercury\", \"Uranus\");\n    for (const auto& planet : result) cout << planet << \" \";\n    cout << endl;  // Expected output: Venus Earth Mars Jupiter Saturn\n}\n\n"}
{"task_id": "CPP/149", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to check if a string has an odd length\nbool has_odd_length(const string& str) {\n    return str.length() % 2 != 0;\n}\n\n// Comparator function for sorting strings by their length and then alphabetically\nbool compare_strings(const string& a, const string& b) {\n    if (a.length() == b.length()) {\n        return a < b; // If lengths are equal, sort alphabetically\n    }\n    return a.length() < b.length(); // Otherwise, sort by length\n}\n\nvector<string> sorted_list_sum(vector<string> lst) {\n    // Remove strings with odd lengths\n    lst.erase(remove_if(lst.begin(), lst.end(), has_odd_length), lst.end());\n    \n    // Sort the vector using the custom comparator\n    sort(lst.begin(), lst.end(), compare_strings);\n    \n    return lst;\n}\n\n// Function to test the sorted_list_sum function\nvoid test() {\n    assert(sorted_list_sum({\"aa\", \"a\", \"aaa\"}) == vector<string>{\"aa\"});\n    assert(sorted_list_sum({\"ab\", \"a\", \"aaa\", \"cd\"}) == vector<string>{\"ab\", \"cd\"});\n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/150", "generation": "#include <stdio.h>\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int n) {\n    if (n <= 1) return false; // Numbers less than or equal to 1 are not prime\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0) return false; // If divisible by any number other than 1 and itself, it's not prime\n    }\n    return true;\n}\n\n// Function to return x if n is a prime number, otherwise return y\nint x_or_y(int n, int x, int y) {\n    return is_prime(n) ? x : y; // Use ternary operator for concise logic\n}\n\n"}
{"task_id": "CPP/151", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nlong long double_the_difference(vector<float> lst) {\n    long long sum = 0;\n    \n    for (float num : lst) {\n        // Check if the number is positive and an integer\n        if (num > 0 && floor(num) == num) {\n            int intNum = static_cast<int>(num);\n            // Check if the number is odd\n            if (intNum % 2 != 0) {\n                sum += intNum * intNum;\n            }\n        }\n    }\n    \n    return sum;\n}\n\n// Function to test the correctness of the solution\nvoid check() {\n    assert(double_the_difference({1, 3, 2, 0}) == 10);\n    assert(double_the_difference({-1, -2, 0}) == 0);\n    assert(double_the_difference({9, -2}) == 81);\n    assert(double_the_difference({0}) == 0);\n    assert(double_the_difference({}) == 0);\n    \n    cout << \"All test cases passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/152", "generation": "#include <iostream>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\n// Function to compare the game results with the guesses\nvector<int> compare(vector<int> game, vector<int> guess) {\n    vector<int> result;\n    \n    // Iterate through each match and calculate the difference\n    for (size_t i = 0; i < game.size(); ++i) {\n        int diff = abs(game[i] - guess[i]);\n        result.push_back(diff);\n    }\n    \n    return result;\n}\n\n// Function to test the compare function with provided examples\nvoid test() {\n    vector<int> game1 = {1, 2, 3, 4, 5, 1};\n    vector<int> guess1 = {1, 2, 3, 4, 2, -2};\n    vector<int> expected1 = {0, 0, 0, 0, 3, 3};\n    assert(compare(game1, guess1) == expected1);\n\n    vector<int> game2 = {0, 5, 0, 0, 0, 4};\n    vector<int> guess2 = {4, 1, 1, 0, 0, -2};\n    vector<int> expected2 = {4, 4, 1, 0, 0, 6};\n    assert(compare(game2, guess2) == expected2);\n\n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/153", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to calculate the strength of an extension\nint calculateStrength(const string& extension) {\n    int cap = 0, sm = 0;\n    for (char c : extension) {\n        if (isupper(c)) cap++;\n        else if (islower(c)) sm++;\n    }\n    return cap - sm;\n}\n\n// Function to find the strongest extension\nstring Strongest_Extension(string class_name, vector<string> extensions) {\n    int max_strength = INT_MIN;\n    string strongest_extension;\n\n    for (const auto& ext : extensions) {\n        int strength = calculateStrength(ext);\n        if (strength > max_strength) {\n            max_strength = strength;\n            strongest_extension = ext;\n        }\n    }\n\n    return class_name + \".\" + strongest_extension;\n}\n\n// Function to test the solution\nvoid test() {\n    assert(Strongest_Extension(\"my_class\", {\"AA\", \"Be\", \"CC\"}) == \"my_class.AA\");\n    assert(Strongest_Extension(\"Slices\", {\"SErviNGSliCes\", \"Cheese\", \"StuFfed\"}) == \"Slices.SErviNGSliCes\");\n    cout << \"All tests passed.\" << endl;\n}\n\n"}
{"task_id": "CPP/154", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\n// Function to generate all rotations of a string\nvoid generate_rotations(string &str, vector<string> &rotations) {\n    int n = str.length();\n    for (int i = 0; i < n; i++) {\n        // Rotate the string by one character\n        str = str.substr(1) + str[0];\n        rotations.push_back(str);\n    }\n}\n\n// Function to check if any rotation of b is a substring of a\nbool cycpattern_check(string a, string b) {\n    vector<string> rotations;\n    generate_rotations(b, rotations);\n\n    // Check each rotation\n    for (const auto &rotation : rotations) {\n        if (a.find(rotation) != string::npos) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\n"}
{"task_id": "CPP/155", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvector<int> even_odd_count(int num) {\n    // Convert the number to a string to easily iterate over each digit\n    string strNum = to_string(abs(num));\n    \n    int evenCount = 0;\n    int oddCount = 0;\n    \n    for (char digit : strNum) {\n        if ((digit - '0') % 2 == 0) {\n            evenCount++;\n        } else {\n            oddCount++;\n        }\n    }\n    \n    return {evenCount, oddCount};\n}\n\n"}
{"task_id": "CPP/156", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring int_to_mini_roman(int number) {\n    // Mapping of integers to their corresponding Roman numerals in lowercase\n    vector<pair<int, string>> roman_map = {\n        {1000, \"m\"}, {900, \"cm\"}, {500, \"d\"}, {400, \"cd\"},\n        {100, \"c\"}, {90, \"xc\"}, {50, \"l\"}, {40, \"xl\"},\n        {10, \"x\"}, {9, \"ix\"}, {5, \"v\"}, {4, \"iv\"}, {1, \"i\"}\n    };\n\n    string roman_numeral = \"\";\n    \n    // Iterate through the map and subtract the value from number\n    for (const auto& [value, numeral] : roman_map) {\n        while (number >= value) {\n            roman_numeral += numeral;\n            number -= value;\n        }\n    }\n\n    return roman_numeral;\n}\n\n"}
{"task_id": "CPP/157", "generation": "#include<stdio.h>\n#include<math.h>\n\nusing namespace std;\n\nbool right_angle_triangle(float a, float b, float c) {\n    // First, find the longest side (hypotenuse)\n    float max_side = max(a, max(b, c));\n    \n    // Check if the square of the hypotenuse is equal to the sum of squares of other two sides\n    return fabs(max_side * max_side - (a * a + b * b + c * c - 2 * max_side * max_side)) < 1e-6;\n}\n\n"}
{"task_id": "CPP/158", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\n// Function to count unique characters in a string\nint count_unique_chars(const string& word) {\n    bool seen[256] = {false}; // Assuming ASCII characters\n    int unique_count = 0;\n    for (char c : word) {\n        if (!seen[c]) {\n            seen[c] = true;\n            unique_count++;\n        }\n    }\n    return unique_count;\n}\n\n// Function to find the word with maximum number of unique characters\nstring find_max(vector<string> words) {\n    string max_word = \"\";\n    int max_unique_chars = 0;\n\n    for (const string& word : words) {\n        int unique_chars = count_unique_chars(word);\n        if (unique_chars > max_unique_chars || \n            (unique_chars == max_unique_chars && word < max_word)) {\n            max_word = word;\n            max_unique_chars = unique_chars;\n        }\n    }\n\n    return max_word;\n}\n\n// Function to test the find_max function\nvoid test_find_max() {\n    assert(find_max({\"name\", \"of\", \"string\"}) == \"string\");\n    assert(find_max({\"name\", \"enam\", \"game\"}) == \"enam\");\n    assert(find_max({\"aaaaaaa\", \"bb\", \"cc\"}) == \"aaaaaaa\");\n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/159", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nvector<int> eat(int number, int need, int remaining) {\n    // Calculate the maximum number of carrots that can be eaten from the remaining stock\n    int toEat = min(need, remaining);\n    \n    // Update the total number of eaten carrots and the remaining carrots\n    int newTotalEaten = number + toEat;\n    int newRemaining = remaining - toEat;\n\n    return {newTotalEaten, newRemaining};\n}\n\n// Example usage:\n"}
{"task_id": "CPP/160", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nint do_algebra(vector<string> operators, vector<int> operands) {\n    if (operands.size() < 2 || operators.size() != operands.size() - 1) {\n        throw invalid_argument(\"Invalid input: the length of operator vector should be one less than the length of operand vector.\");\n    }\n\n    int result = operands[0];\n\n    for (size_t i = 0; i < operators.size(); ++i) {\n        if (operators[i] == \"+\") {\n            result += operands[i + 1];\n        } else if (operators[i] == \"-\") {\n            result -= operands[i + 1];\n        } else if (operators[i] == \"*\") {\n            result *= operands[i + 1];\n        } else if (operators[i] == \"//\") {\n            result /= operands[i + 1]; // Floor division\n        } else if (operators[i] == \"**\") {\n            result = pow(result, operands[i + 1]); // Exponentiation\n        } else {\n            throw invalid_argument(\"Invalid operator: \" + operators[i]);\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/161", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\n// Function to solve the problem as described\nstring solve(string s) {\n    bool hasLetters = false;\n    \n    // Check if there are any letters in the string\n    for (char c : s) {\n        if (isalpha(c)) {\n            hasLetters = true;\n            break;\n        }\n    }\n\n    // If no letters, reverse the entire string\n    if (!hasLetters) {\n        reverse(s.begin(), s.end());\n    } else {\n        // Otherwise, reverse case for each letter and keep other characters as is\n        for (char &c : s) {\n            if (isalpha(c)) {\n                c = islower(c) ? toupper(c) : tolower(c);\n            }\n        }\n    }\n\n    return s;\n}\n\n"}
{"task_id": "CPP/162", "generation": "#include <iostream>\n#include <string>\n#include <openssl/md5.h>\n\n// Function to convert byte array to hex string\nstd::string bytes_to_hex(const unsigned char* bytes, size_t length) {\n    std::stringstream ss;\n    for (size_t i = 0; i < length; ++i) {\n        ss << std::hex << std::setw(2) << std::setfill('0') << static_cast<int>(bytes[i]);\n    }\n    return ss.str();\n}\n\n// Function to convert string to MD5 hash\nstd::string string_to_md5(const std::string& text) {\n    if (text.empty()) {\n        return \"None\";\n    }\n\n    unsigned char digest[MD5_DIGEST_LENGTH];\n    MD5((unsigned char*)text.c_str(), text.length(), (unsigned char*)&digest);    \n\n    // Convert the hash to a hexadecimal string\n    return bytes_to_hex(digest, MD5_DIGEST_LENGTH);\n}\n\n"}
{"task_id": "CPP/163", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Function to generate even digits between two integers a and b\nvector<int> generate_integers(int a, int b) {\n    vector<int> result;\n    \n    // Ensure a is less than or equal to b for simplicity\n    if (a > b) {\n        swap(a, b);\n    }\n    \n    // Iterate through the range from a to b\n    for (int i = a; i <= b; ++i) {\n        // Extract each digit and check if it's even\n        int num = i;\n        while (num > 0) {\n            int digit = num % 10;\n            if (digit % 2 == 0 && digit != 0) { // Check if the digit is even and not zero\n                result.push_back(digit);\n            }\n            num /= 10; // Move to the next digit\n        }\n    }\n    \n    return result;\n}\n\n// Function to print the vector of integers\nvoid print_vector(const vector<int>& vec) {\n    for (int i : vec) {\n        cout << i << \" \";\n    }\n    cout << endl;\n}\n\n// Main function to test the generate_integers function\n"}
{"task_id": "CPP/0", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // For std::sort\n#include <cmath>      // For std::abs\n\nusing namespace std;\n\nbool has_close_elements(vector<float> numbers, float threshold) {\n    // Sort the vector to make adjacent elements close in value\n    sort(numbers.begin(), numbers.end());\n\n    // Check the difference between each pair of adjacent elements\n    for (size_t i = 0; i < numbers.size() - 1; ++i) {\n        if (std::abs(numbers[i] - numbers[i + 1]) < threshold) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\n"}
{"task_id": "CPP/1", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> separate_paren_groups(string paren_string) {\n    vector<string> groups;\n    int balance = 0;\n    string current_group;\n\n    for (char ch : paren_string) {\n        if (ch == '(') {\n            balance++;\n            current_group += ch;\n        } else if (ch == ')') {\n            balance--;\n            current_group += ch;\n            if (balance == 0) {\n                groups.push_back(current_group);\n                current_group.clear();\n            }\n        }\n    }\n\n    return groups;\n}\n\n"}
{"task_id": "CPP/2", "generation": "#include <stdio.h>\n#include <cmath>  // Include cmath for floor function\n\nusing namespace std;\n\nfloat truncate_number(float number) {\n    float integerPart = floor(number);  // Get the largest integer less than or equal to the given number\n    float decimalPart = number - integerPart;  // Subtract the integer part from the original number to get the decimal part\n    return decimalPart;\n}\n\n"}
{"task_id": "CPP/3", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool below_zero(vector<int> operations) {\n    int balance = 0; // Start with a zero balance\n\n    for (int op : operations) {\n        balance += op; // Update the balance after each operation\n        if (balance < 0) {\n            return true; // Return true if balance falls below zero\n        }\n    }\n\n    return false; // Return false if balance never goes below zero\n}\n\n// Function to test the below_zero function with provided examples\nvoid check() {\n    vector<int> operations1 = {1, 2, 3};\n    vector<int> operations2 = {1, 2, -4, 5};\n\n    cout << \"Test 1: \" << (below_zero(operations1) ? \"Passed\" : \"Failed\") << endl;\n    cout << \"Test 2: \" << (below_zero(operations2) ? \"Passed\" : \"Failed\") << endl;\n}\n\n"}
{"task_id": "CPP/4", "generation": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nfloat mean_absolute_deviation(vector<float> numbers) {\n    // Step 1: Calculate the mean of the dataset\n    float sum = 0.0;\n    for (float num : numbers) {\n        sum += num;\n    }\n    float mean = sum / numbers.size();\n\n    // Step 2 and 3: Compute the absolute differences and find their average\n    float mad = 0.0;\n    for (float num : numbers) {\n        mad += abs(num - mean);\n    }\n    mad /= numbers.size();\n\n    return mad;\n}\n\n"}
{"task_id": "CPP/5", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> intersperse(vector<int> numbers, int delimeter) {\n    // Reserve space for the new elements to avoid reallocations\n    size_t original_size = numbers.size();\n    size_t new_size = original_size + (original_size - 1); // Each element except the last one will have a delimiter after it\n    vector<int> result(new_size);\n\n    int index = 0;\n    for (size_t i = 0; i < original_size; ++i) {\n        result[index++] = numbers[i];\n        if (i != original_size - 1) { // Don't add the delimiter after the last element\n            result[index++] = delimeter;\n        }\n    }\n\n    return result;\n}\n\n// Function to print the vector for testing purposes\nvoid printVector(const vector<int>& vec) {\n    for (int num : vec) {\n        cout << num << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/6", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<int> parse_nested_parens(string paren_string) {\n    vector<int> depths;\n    string current_group = \"\";\n    \n    // Split the input string into groups based on spaces\n    for (char ch : paren_string) {\n        if (ch == ' ') {\n            if (!current_group.empty()) {\n                int max_depth = 0, current_depth = 0;\n                \n                // Process each group to find its maximum depth of nesting\n                for (char c : current_group) {\n                    if (c == '(') {\n                        current_depth++;\n                        max_depth = max(max_depth, current_depth);\n                    } else if (c == ')') {\n                        current_depth--;\n                    }\n                }\n                \n                depths.push_back(max_depth);\n                current_group.clear();\n            }\n        } else {\n            current_group += ch;\n        }\n    }\n\n    // Process the last group if it exists\n    if (!current_group.empty()) {\n        int max_depth = 0, current_depth = 0;\n        \n        for (char c : current_group) {\n            if (c == '(') {\n                current_depth++;\n                max_depth = max(max_depth, current_depth);\n            } else if (c == ')') {\n                current_depth--;\n            }\n        }\n        \n        depths.push_back(max_depth);\n    }\n\n    return depths;\n}\n\n"}
{"task_id": "CPP/7", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to filter strings containing a given substring\nvector<string> filter_by_substring(vector<string> strings, string substring) {\n    vector<string> filtered_strings;\n    \n    // Iterate through each string in the input vector\n    for (const auto& str : strings) {\n        // Check if the current string contains the given substring\n        if (str.find(substring) != string::npos) {\n            // If it does, add it to the filtered list\n            filtered_strings.push_back(str);\n        }\n    }\n    \n    return filtered_strings;\n}\n\n// Function to test the filter_by_substring function\nvoid test_filter_by_substring() {\n    vector<string> input1 = {};\n    vector<string> expected1 = {};\n    assert(filter_by_substring(input1, \"a\") == expected1);\n\n    vector<string> input2 = {\"abc\", \"bacd\", \"cde\", \"vector\"};\n    vector<string> expected2 = {\"abc\", \"bacd\", \"vector\"};\n    assert(filter_by_substring(input2, \"a\") == expected2);\n\n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/8", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Function to calculate the sum and product of all integers in a vector.\nvector<int> sum_product(vector<int> numbers) {\n    int sum = 0;\n    int product = 1;\n\n    // Iterate through each number in the vector\n    for (int num : numbers) {\n        sum += num;  // Add the current number to the sum\n        if (num != 0) {  // Avoid multiplying by zero, as it would result in a product of 0\n            product *= num;\n        }\n    }\n\n    return {sum, product};\n}\n\n// Function to test the sum_product function with some example inputs.\nvoid test_sum_product() {\n    vector<int> empty = {};\n    vector<int> numbers1 = {1, 2, 3, 4};\n\n    // Test case for an empty vector\n    auto result1 = sum_product(empty);\n    cout << \"Empty vector: Sum = \" << result1[0] << \", Product = \" << result1[1] << endl;\n\n    // Test case for a non-empty vector\n    auto result2 = sum_product(numbers1);\n    cout << \"Non-empty vector (1, 2, 3, 4): Sum = \" << result2[0] << \", Product = \" << result2[1] << endl;\n}\n\n"}
{"task_id": "CPP/9", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> rolling_max(vector<int> numbers) {\n    if (numbers.empty()) return {}; // Return an empty vector if the input is empty\n\n    vector<int> result;\n    int current_max = numbers[0]; // Initialize with the first element\n\n    for (int num : numbers) {\n        if (num > current_max) {\n            current_max = num; // Update the current maximum\n        }\n        result.push_back(current_max); // Add the current maximum to the result vector\n    }\n\n    return result;\n}\n\n// Function to print a vector of integers\nvoid print_vector(const vector<int>& vec) {\n    for (int val : vec) {\n        cout << val << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/10", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_palindrome(string str) {\n    // Test if given string is a palindrome\n    string s(str.rbegin(), str.rend());\n    return s == str;\n}\n\nint find_longest_palindromic_suffix(const string& str) {\n    int n = str.length();\n    for (int i = 0; i < n; ++i) {\n        if (is_palindrome(str.substr(i))) {\n            return i;\n        }\n    }\n    return 0;\n}\n\nstring make_palindrome(string str) {\n    /*\n    Find the shortest palindrome that begins with a supplied string. \n    Algorithm idea is simple: - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    */\n    int n = str.length();\n    if (n == 0) {\n        return \"\";\n    }\n\n    // Find the length of the longest palindromic suffix\n    int len_of_palindrome_suffix = find_longest_palindromic_suffix(str);\n\n    // The prefix that needs to be reversed and appended\n    string prefix_to_reverse = str.substr(0, n - len_of_palindrome_suffix);\n    reverse(prefix_to_reverse.begin(), prefix_to_reverse.end());\n\n    // Append the reversed prefix to the original string\n    return str + prefix_to_reverse;\n}\n\n"}
{"task_id": "CPP/11", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\n// Function to perform binary XOR on two strings\nstring string_xor(string a, string b) {\n    // Ensure both strings are of the same length\n    if (a.length() != b.length()) {\n        throw runtime_error(\"Input strings must be of the same length\");\n    }\n\n    string result = \"\";\n    \n    // Perform XOR operation character by character\n    for (size_t i = 0; i < a.length(); ++i) {\n        // XOR two characters and append to the result string\n        if (a[i] == b[i]) {\n            result += '0';\n        } else {\n            result += '1';\n        }\n    }\n\n    return result;\n}\n\n// Function to test the string_xor function\nvoid test_string_xor() {\n    assert(string_xor(\"010\", \"110\") == \"100\");\n    assert(string_xor(\"111\", \"000\") == \"111\");\n    assert(string_xor(\"101010\", \"010101\") == \"111111\");\n\n    cout << \"All test cases passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/12", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring longest(vector<string> strings) {\n    if (strings.empty()) {\n        return \"None\"; // Return \"None\" if the input vector is empty.\n    }\n\n    string longestString = strings[0]; // Initialize with the first string in the list.\n\n    for (const auto& str : strings) {\n        if (str.length() > longestString.length()) {\n            longestString = str; // Update the longest string if a longer one is found.\n        }\n    }\n\n    return longestString;\n}\n\n"}
{"task_id": "CPP/13", "generation": "#include <stdio.h>\nusing namespace std;\n\nint greatest_common_divisor(int a, int b) {\n    // Ensure a >= b to simplify the logic\n    if (a < b) {\n        swap(a, b);\n    }\n\n    // Euclidean algorithm\n    while (b != 0) {\n        int temp = b;\n        b = a % b;\n        a = temp;\n    }\n    \n    return a; // At this point, 'a' is the GCD of the original 'a' and 'b'\n}\n\n"}
{"task_id": "CPP/14", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to generate all prefixes of the given string\nvector<string> all_prefixes(string str) {\n    vector<string> prefixes;\n    for (size_t i = 1; i <= str.length(); ++i) {\n        prefixes.push_back(str.substr(0, i));\n    }\n    return prefixes;\n}\n\n"}
{"task_id": "CPP/15", "generation": "#include <iostream>\n#include <sstream>\n#include <string>\n\nstd::string string_sequence(int n) {\n    std::stringstream ss;\n    for (int i = 0; i <= n; ++i) {\n        ss << i;\n        if (i < n) {\n            ss << \" \";\n        }\n    }\n    return ss.str();\n}\n\n// Function to test the string_sequence function\nvoid test_string_sequence() {\n    std::cout << \"Testing string_sequence with input 0: \" << string_sequence(0) << std::endl;\n    std::cout << \"Expected output: 0\" << std::endl;\n\n    std::cout << \"Testing string_sequence with input 5: \" << string_sequence(5) << std::endl;\n    std::cout << \"Expected output: 0 1 2 3 4 5\" << std::endl;\n}\n\n"}
{"task_id": "CPP/16", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nint count_distinct_characters(string str) {\n    // Convert string to lowercase (or uppercase)\n    transform(str.begin(), str.end(), str.begin(), ::tolower);\n\n    // Use a set to store distinct characters\n    std::set<char> distinct_chars(str.begin(), str.end());\n\n    // The size of the set is the number of distinct characters\n    return distinct_chars.size();\n}\n\n"}
{"task_id": "CPP/17", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<int> parse_music(string music_string) {\n    vector<int> durations;\n    \n    // Iterate through the string and process each character\n    for (size_t i = 0; i < music_string.length(); ) {\n        if (music_string[i] == 'o') {\n            // Whole note lasts four beats\n            durations.push_back(4);\n            i += 1; // Move to the next character\n        } else if (music_string[i] == 'o' && music_string[i + 1] == '|') {\n            // Half note lasts two beats\n            durations.push_back(2);\n            i += 2; // Skip the next character as well\n        } else if (music_string[i] == '.' && music_string[i + 1] == '|') {\n            // Quarter note lasts one beat\n            durations.push_back(1);\n            i += 2; // Skip the next character as well\n        }\n    }\n\n    return durations;\n}\n\n// Function to test the parse_music function\nvoid test_parse_music() {\n    string input = \"o o| .| o| o| .| .| .| .| o o\";\n    vector<int> expected_output = {4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4};\n    vector<int> output = parse_music(input);\n\n    if (output == expected_output) {\n        printf(\"Test passed!\\n\");\n    } else {\n        printf(\"Test failed! Expected: \");\n        for (int dur : expected_output) {\n            printf(\"%d \", dur);\n        }\n        printf(\"\\nGot: \");\n        for (int dur : output) {\n            printf(\"%d \", dur);\n        }\n        printf(\"\\n\");\n    }\n}\n\n"}
{"task_id": "CPP/18", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint how_many_times(const string& str, const string& substring) {\n    int count = 0;\n    size_t pos = 0;\n\n    // Loop through the original string to find all occurrences of the substring\n    while ((pos = str.find(substring, pos)) != string::npos) {\n        count++;\n        pos++; // Move one character forward to allow for overlapping matches\n    }\n\n    return count;\n}\n\n"}
{"task_id": "CPP/19", "generation": "#include <iostream>\n#include <string>\n#include <map>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to map word to its corresponding number\nint word_to_number(const string& word) {\n    map<string, int> num_map = {{\"zero\", 0}, {\"one\", 1}, {\"two\", 2}, {\"three\", 3},\n                                {\"four\", 4}, {\"five\", 5}, {\"six\", 6}, {\"seven\", 7},\n                                {\"eight\", 8}, {\"nine\", 9}};\n    return num_map[word];\n}\n\n// Function to sort the numbers in a string\nstring sort_numbers(const string& input) {\n    vector<string> words;\n    string current_word = \"\";\n    \n    // Split the input into individual words\n    for (char ch : input) {\n        if (ch == ' ') {\n            if (!current_word.empty()) {\n                words.push_back(current_word);\n                current_word.clear();\n            }\n        } else {\n            current_word += ch;\n        }\n    }\n    if (!current_word.empty()) {\n        words.push_back(current_word);\n    }\n\n    // Sort the vector of words based on their corresponding numbers\n    sort(words.begin(), words.end(), [](const string& a, const string& b) {\n        return word_to_number(a) < word_to_number(b);\n    });\n\n    // Join the sorted words back into a single string\n    string result;\n    for (const auto& word : words) {\n        if (!result.empty()) {\n            result += \" \";\n        }\n        result += word;\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/20", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\npair<float, float> find_closest_elements(vector<float> numbers) {\n    if (numbers.size() < 2) {\n        throw invalid_argument(\"The vector must contain at least two elements.\");\n    }\n\n    float min_diff = numeric_limits<float>::max();\n    pair<float, float> closest_pair;\n\n    for (size_t i = 0; i < numbers.size() - 1; ++i) {\n        float diff = abs(numbers[i] - numbers[i + 1]);\n        if (diff < min_diff) {\n            min_diff = diff;\n            closest_pair = make_pair(min(min(numbers[i], numbers[i + 1]), max(numbers[i], numbers[i + 1])), \n                                     max(min(numbers[i], numbers[i + 1]), max(numbers[i], numbers[i + 1])));\n        }\n    }\n\n    return closest_pair;\n}\n\n"}
{"task_id": "CPP/21", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<float> rescale_to_unit(vector<float> numbers) {\n    if (numbers.size() < 2) {\n        throw invalid_argument(\"Vector must contain at least two elements.\");\n    }\n\n    float min_value = *min_element(numbers.begin(), numbers.end());\n    float max_value = *max_element(numbers.begin(), numbers.end());\n\n    vector<float> scaled_numbers;\n    for (float num : numbers) {\n        float new_value = (num - min_value) / (max_value - min_value);\n        scaled_numbers.push_back(new_value);\n    }\n\n    return scaled_numbers;\n}\n\n"}
{"task_id": "CPP/22", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <list>\n#include <boost/any.hpp>\n\ntypedef std::list<boost::any> list_any;\nusing namespace std;\n\nvector<int> filter_integers(list_any values) {\n    vector<int> result;\n    for (const auto& value : values) {\n        if (value.type() == typeid(int)) {\n            result.push_back(boost::any_cast<int>(value));\n        }\n    }\n    return result;\n}\n\n// Function to test the filter_integers function\nvoid test_filter_integers() {\n    list_any values1 = {boost::any(3.14), boost::any(5)};\n    vector<int> result1 = filter_integers(values1);\n    assert(result1 == vector<int>({5}));\n\n    list_any values2 = {boost::any(1), boost::any(2), boost::any(3), boost::any(\"abc\"), boost::any({}), boost::any({})};\n    vector<int> result2 = filter_integers(values2);\n    assert(result2 == vector<int>({1, 2, 3}));\n\n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/23", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\n// Function to calculate the length of a string\nint strlen(const string& str) {\n    return str.length();\n}\n\n"}
{"task_id": "CPP/24", "generation": "#include <iostream>\nusing namespace std;\n\nint largest_divisor(int n) {\n    for (int i = n - 1; i > 0; --i) {\n        if (n % i == 0) {\n            return i;\n        }\n    }\n    // If no divisor is found, which should not happen for positive integers,\n    // we can return a default value like 1.\n    return 1;\n}\n\n"}
{"task_id": "CPP/25", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> factorize(int n) {\n    vector<int> factors;\n    \n    // Divide by 2 to get all the 2s\n    while (n % 2 == 0) {\n        factors.push_back(2);\n        n /= 2;\n    }\n    \n    // Check for odd factors from 3 onwards\n    for (int i = 3; i * i <= n; i += 2) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n    \n    // If n is a prime number greater than 2\n    if (n > 2) {\n        factors.push_back(n);\n    }\n    \n    return factors;\n}\n\n// Example usage:\n"}
{"task_id": "CPP/26", "generation": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nvector<int> remove_duplicates(vector<int> numbers) {\n    // Create a map to count occurrences of each element\n    unordered_map<int, int> counts;\n    \n    // Count the occurrences of each number in the vector\n    for (int num : numbers) {\n        counts[num]++;\n    }\n    \n    // Reserve space in the result vector to avoid reallocations\n    vector<int> result;\n    result.reserve(numbers.size());\n    \n    // Iterate through the original vector and add elements that occur exactly once\n    for (int num : numbers) {\n        if (counts[num] == 1) {\n            result.push_back(num);\n        }\n    }\n    \n    return result;\n}\n\n// Function to test the remove_duplicates function\nvoid test_remove_duplicates() {\n    vector<int> input = {1, 2, 3, 2, 4};\n    vector<int> output = remove_duplicates(input);\n    \n    // Print the result\n    for (int num : output) {\n        cout << num << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/27", "generation": "#include <iostream>\n#include <string>\n#include <cctype>  // For tolower and toupper functions\n\nusing namespace std;\n\nstring flip_case(string str) {\n    for (char &c : str) {\n        if (isupper(c)) {\n            c = tolower(c);\n        } else if (islower(c)) {\n            c = toupper(c);\n        }\n    }\n    return str;\n}\n\n"}
{"task_id": "CPP/28", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <numeric> // for std::accumulate\n\nusing namespace std;\n\nstring concatenate(vector<string> strings) {\n    return accumulate(strings.begin(), strings.end(), string(\"\"));\n}\n\n"}
{"task_id": "CPP/29", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> filter_by_prefix(vector<string> strings, string prefix) {\n    vector<string> filtered_strings;\n    \n    // Iterate through each string in the input vector\n    for (const auto& str : strings) {\n        // Check if the string starts with the given prefix\n        if (str.substr(0, prefix.length()) == prefix) {\n            // If it does, add it to the result vector\n            filtered_strings.push_back(str);\n        }\n    }\n    \n    return filtered_strings;\n}\n\n// Function to test the filter_by_prefix function\nvoid test_filter_by_prefix() {\n    vector<string> input1 = {};\n    string prefix1 = \"a\";\n    vector<string> expected1 = {};\n    assert(filter_by_prefix(input1, prefix1) == expected1);\n\n    vector<string> input2 = {\"abc\", \"bcd\", \"cde\", \"vector\"};\n    string prefix2 = \"a\";\n    vector<string> expected2 = {\"abc\", \"vector\"};\n    assert(filter_by_prefix(input2, prefix2) == expected2);\n\n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/30", "generation": "#include <iostream>\n#include <vector>\n\n// Function to return only positive numbers in the vector.\nstd::vector<float> get_positive(const std::vector<float>& l) {\n    std::vector<float> result;\n    \n    // Iterate through each element in the input vector\n    for (float num : l) {\n        // Check if the number is positive\n        if (num > 0) {\n            // Add it to the result vector\n            result.push_back(num);\n        }\n    }\n    \n    return result;\n}\n\n// Function to print the elements of a vector\nvoid print_vector(const std::vector<float>& vec) {\n    for (float num : vec) {\n        std::cout << num << \" \";\n    }\n    std::cout << std::endl;\n}\n\n"}
{"task_id": "CPP/31", "generation": "#include <iostream>\n#include <cmath> // For sqrt function\n\nusing namespace std;\n\nbool is_prime(long long n) {\n    if (n <= 1) return false; // Numbers less than or equal to 1 are not prime\n    if (n == 2 || n == 3) return true; // 2 and 3 are prime numbers\n    if (n % 2 == 0 || n % 3 == 0) return false; // Exclude multiples of 2 and 3\n\n    for (long long i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0)\n            return false;\n    }\n    return true;\n}\n\n"}
{"task_id": "CPP/32", "generation": "#include <iostream>\n#include <vector>\n#include <cmath>\n\ndouble poly(const std::vector<double>& xs, double x) {\n    double sum = 0;\n    int i;\n    for (i = 0; i < xs.size(); i++) {\n        sum += xs[i] * pow(x, i);\n    }\n    return sum;\n}\n\nstd::vector<double> poly_derivative(const std::vector<double>& xs) {\n    std::vector<double> derivative(xs.size() - 1);\n    for (int i = 0; i < xs.size() - 1; ++i) {\n        derivative[i] = xs[i + 1] * (i + 1);\n    }\n    return derivative;\n}\n\ndouble find_zero(const std::vector<double>& xs, double initial_guess = 0.0, double tolerance = 1e-6, int max_iterations = 1000) {\n    if (xs.size() % 2 != 0 || !std::abs(xs.back()) > 1e-9) {\n        throw std::invalid_argument(\"The polynomial must have an even number of coefficients and a non-zero leading coefficient.\");\n    }\n\n    double x = initial_guess;\n    for (int i = 0; i < max_iterations; ++i) {\n        double f_x = poly(xs, x);\n        if (std::abs(f_x) < tolerance) {\n            return x;\n        }\n        std::vector<double> derivative = poly_derivative(xs);\n        double f_prime_x = poly(derivative, x);\n        if (f_prime_x == 0) {\n            throw std::runtime_error(\"Derivative is zero; no convergence.\");\n        }\n        x -= f_x / f_prime_x;\n    }\n\n    // If we reach here, the method did not converge\n    throw std::runtime_error(\"Newton-Raphson method did not converge within the maximum number of iterations.\");\n}\n\n"}
{"task_id": "CPP/33", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> sort_third(vector<int> l) {\n    // Extract elements at indices divisible by three\n    vector<int> third_indices;\n    for (size_t i = 2; i < l.size(); i += 3) {\n        third_indices.push_back(l[i]);\n    }\n\n    // Sort the extracted elements\n    sort(third_indices.begin(), third_indices.end());\n\n    // Replace original elements at indices divisible by three with sorted ones\n    size_t index = 0;\n    for (size_t i = 2; i < l.size(); i += 3) {\n        l[i] = third_indices[index++];\n    }\n\n    return l;\n}\n\n// Function to check the correctness of the sort_third function\nvoid check() {\n    vector<int> result1 = sort_third({1, 2, 3});\n    assert((result1 == vector<int>({1, 2, 3})));\n\n    vector<int> result2 = sort_third({5, 6, 3, 4, 8, 9, 2});\n    assert((result2 == vector<int>({2, 6, 3, 4, 8, 9, 5})));\n\n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/34", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> unique(vector<int> l) {\n    // Sort the vector\n    sort(l.begin(), l.end());\n    \n    // Remove duplicates using std::unique\n    auto last = unique(l.begin(), l.end());\n    \n    // Erase the elements after the last unique element\n    l.erase(last, l.end());\n    \n    return l;\n}\n\n"}
{"task_id": "CPP/35", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nfloat max_element(vector<float> l) {\n    if (l.empty()) {\n        return 0; // or throw an exception, depending on your use case\n    }\n\n    float max_val = l[0]; // Initialize with the first element\n\n    for (size_t i = 1; i < l.size(); ++i) {\n        if (l[i] > max_val) {\n            max_val = l[i];\n        }\n    }\n\n    return max_val;\n}\n\n"}
{"task_id": "CPP/36", "generation": "#include <iostream>\nusing namespace std;\n\nint fizz_buzz(int n) {\n    int count = 0;\n    \n    for (int i = 1; i < n; ++i) {\n        if (i % 11 == 0 || i % 13 == 0) {\n            // Convert the number to a string and count occurrences of '7'\n            string num_str = to_string(i);\n            for (char c : num_str) {\n                if (c == '7') {\n                    ++count;\n                }\n            }\n        }\n    }\n    \n    return count;\n}\n\n"}
{"task_id": "CPP/37", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<float> sort_even(vector<float> l) {\n    // Extract elements at even indices (0-based index, so 0, 2, 4, ...)\n    vector<float> even_elements;\n    for (size_t i = 0; i < l.size(); i += 2) {\n        even_elements.push_back(l[i]);\n    }\n\n    // Sort the extracted elements\n    sort(even_elements.begin(), even_elements.end());\n\n    // Create a new vector to store the result\n    vector<float> sorted_l(l);\n\n    // Place the sorted elements back into their original positions in the new vector\n    size_t even_index = 0;\n    for (size_t i = 0; i < l.size(); i += 2) {\n        sorted_l[i] = even_elements[even_index++];\n    }\n\n    return sorted_l;\n}\n\n// Function to check the correctness of the sort_even function\nvoid check() {\n    vector<float> result1 = sort_even({1, 2, 3});\n    assert(result1 == vector<float>({1, 2, 3}));\n\n    vector<float> result2 = sort_even({5, 6, 3, 4});\n    assert(result2 == vector<float>({3, 6, 5, 4}));\n\n    cout << \"All test cases passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/38", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring encode_cyclic(string s) { \n    // returns encoded string by cycling groups of three characters.\n    int l = s.length();\n    int num = (l + 2) / 3;\n    string x, output;\n    for (int i = 0; i * 3 < l; i++) {\n        x = s.substr(i * 3, 3);\n        if (x.length() == 3) x = x.substr(1) + x[0];\n        output += x;\n    }\n    return output;\n}\n\nstring decode_cyclic(string s) { \n    // takes as input string encoded with encode_cyclic function. Returns decoded string.\n    int l = s.length();\n    int num = (l + 2) / 3;\n    string x, output;\n    for (int i = 0; i * 3 < l; i++) {\n        x = s.substr(i * 3, 3);\n        if (x.length() == 3) x = x.back() + x.substr(0, 2); // Move the last character to the front\n        output += x;\n    }\n    return output;\n}\n\n"}
{"task_id": "CPP/39", "generation": "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\n// Helper function to check if a number is prime\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    if (num == 2 || num == 3) return true;\n    if (num % 2 == 0 || num % 3 == 0) return false;\n    for (int i = 5; i * i <= num; i += 6) {\n        if (num % i == 0 || num % (i + 2) == 0)\n            return false;\n    }\n    return true;\n}\n\n// Function to find the n-th Fibonacci number that is also prime\nint prime_fib(int n) {\n    int count = 0; // Counter for prime Fibonacci numbers found\n    int a = 0, b = 1; // First two Fibonacci numbers\n\n    while (true) {\n        int fib = a + b;\n        a = b;\n        b = fib;\n\n        if (is_prime(fib)) {\n            count++;\n            if (count == n) return fib;\n        }\n    }\n}\n\n"}
{"task_id": "CPP/40", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nbool triples_sum_to_zero(vector<int> l) {\n    // First, sort the array to facilitate the two-pointer approach.\n    sort(l.begin(), l.end());\n    \n    int n = l.size();\n    \n    // Iterate through each element in the vector.\n    for (int i = 0; i < n - 2; ++i) {\n        // Skip duplicate elements to avoid redundant checks.\n        if (i > 0 && l[i] == l[i-1]) continue;\n        \n        int left = i + 1, right = n - 1;\n        \n        while (left < right) {\n            int sum = l[i] + l[left] + l[right];\n            \n            if (sum == 0) {\n                return true; // Found a triplet that sums to zero.\n            } else if (sum < 0) {\n                ++left; // Need a larger number, move the left pointer to the right.\n            } else {\n                --right; // Need a smaller number, move the right pointer to the left.\n            }\n        }\n    }\n    \n    return false; // No triplet found that sums to zero.\n}\n\n"}
{"task_id": "CPP/41", "generation": "#include <iostream>\nusing namespace std;\n\nint car_race_collision(int n) {\n    // Each car from one direction will collide with each car from the opposite direction.\n    return n * n;\n}\n\n"}
{"task_id": "CPP/42", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> incr_vector(vector<int> l) {\n    for (int &num : l) {\n        num += 1;\n    }\n    return l;\n}\n\n// Function to check the correctness of the incr_vector function\nvoid check_function() {\n    vector<int> test1 = {1, 2, 3};\n    vector<int> expected1 = {2, 3, 4};\n    assert(incr_vector(test1) == expected1);\n\n    vector<int> test2 = {5, 3, 5, 2, 3, 3, 9, 0, 123};\n    vector<int> expected2 = {6, 4, 6, 3, 4, 4, 10, 1, 124};\n    assert(incr_vector(test2) == expected2);\n\n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/43", "generation": "#include <iostream>\n#include <vector>\n#include <set>\n\nbool pairs_sum_to_zero(const std::vector<int>& l) {\n    std::set<int> seen;\n    for (int num : l) {\n        if (seen.find(-num) != seen.end()) {\n            return true; // Found a pair that sums to zero\n        }\n        seen.insert(num);\n    }\n    return false; // No such pair found\n}\n\n// Function to test the pairs_sum_to_zero function with provided data points\nvoid test_pairs_sum_to_zero() {\n    assert(pairs_sum_to_zero({1, 3, 5, 0}) == false);\n    assert(pairs_sum_to_zero({1, 3, -2, 1}) == false);\n    assert(pairs_sum_to_zero({1, 2, 3, 7}) == false);\n    assert(pairs_sum_to_zero({2, 4, -5, 3, 5, 7}) == true);\n    assert(pairs_sum_to_zero({1}) == false);\n\n    std::cout << \"All test cases passed!\" << std::endl;\n}\n\n"}
{"task_id": "CPP/44", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring change_base(int x, int base) {\n    if (x == 0) {\n        return \"0\";\n    }\n    \n    string result = \"\";\n    while (x > 0) {\n        int remainder = x % base;\n        result = to_string(remainder) + result;\n        x /= base;\n    }\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/45", "generation": "#include <stdio.h>\nusing namespace std;\n\nfloat triangle_area(float a, float h) {\n    return 0.5 * a * h;\n}\n\n"}
{"task_id": "CPP/46", "generation": "#include <iostream>\nusing namespace std;\n\nint fib4(int n) {\n    if (n == 0 || n == 1 || n == 2) return n == 2 ? 2 : 0;\n    if (n == 3) return 0;\n\n    // Initialize the first four values of the sequence\n    int a = 0, b = 0, c = 2, d = 0;\n\n    // Compute fib4(n) iteratively\n    for (int i = 4; i <= n; ++i) {\n        int next = a + b + c + d;\n        a = b;\n        b = c;\n        c = d;\n        d = next;\n    }\n\n    return d;\n}\n\n// Function to test the fib4 function\nvoid test() {\n    cout << \"fib4(5): \" << fib4(5) << endl; // Should output 4\n    cout << \"fib4(6): \" << fib4(6) << endl; // Should output 8\n    cout << \"fib4(7): \" << fib4(7) << endl; // Should output 14\n}\n\n"}
{"task_id": "CPP/47", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nfloat median(vector<float> l) {\n    // Sort the vector\n    sort(l.begin(), l.end());\n    \n    int n = l.size();\n    \n    if (n % 2 == 0) {\n        // If even number of elements, return the average of the two middle elements\n        return (l[n / 2 - 1] + l[n / 2]) / 2.0;\n    } else {\n        // If odd number of elements, return the middle element\n        return l[n / 2];\n    }\n}\n\n"}
{"task_id": "CPP/48", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_palindrome(string text) {\n    int left = 0;\n    int right = text.length() - 1;\n\n    while (left < right) {\n        if (text[left] != text[right]) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n\n    return true;\n}\n\n"}
{"task_id": "CPP/49", "generation": "#include <stdio.h>\nusing namespace std;\n\nint modp(int n, int p) {\n    if (n == 0) return 1; // Base case: any number to the power of 0 is 1\n\n    long long result = 1;\n    long long base = 2;\n\n    while (n > 0) {\n        // If n is odd, multiply the result by the current base\n        if (n % 2 == 1) {\n            result = (result * base) % p;\n        }\n        // Square the base and reduce it modulo p\n        base = (base * base) % p;\n        // Divide n by 2\n        n /= 2;\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/50", "generation": "#include <stdio.h>\n#include <string>\n\nusing namespace std;\n\nstring encode_shift(string s) {\n    // returns encoded string by shifting every character by 5 in the alphabet.\n    string out;\n    int i;\n    for (i = 0; i < s.length(); i++) {\n        int w = ((int)s[i] + 5 - (int)'a') % 26 + (int)'a';\n        out += (char)w;\n    }\n    return out;\n}\n\nstring decode_shift(string s) {\n    // takes as input string encoded with encode_shift function. Returns decoded string.\n    string out;\n    int i;\n    for (i = 0; i < s.length(); i++) {\n        int w = ((int)s[i] - 5 - (int)'a') % 26 + (int)'a';\n        out += (char)w;\n    }\n    return out;\n}\n\n"}
{"task_id": "CPP/51", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nbool is_vowel(char c) {\n    // Convert character to lowercase for simplicity\n    char lower_c = tolower(c);\n    return lower_c == 'a' || lower_c == 'e' || lower_c == 'i' || lower_c == 'o' || lower_c == 'u';\n}\n\nstring remove_vowels(string text) {\n    string result;\n    for (char c : text) {\n        if (!is_vowel(c)) {\n            result += c;\n        }\n    }\n    return result;\n}\n\n"}
{"task_id": "CPP/52", "generation": "#include <vector>\n#include <iostream>\n\n// Function to check if all elements in the vector are below the threshold\nbool below_threshold(const std::vector<int>& l, int t) {\n    for (int num : l) {\n        if (num >= t) {\n            return false;\n        }\n    }\n    return true;\n}\n\n// Main function to test the below_threshold function\n"}
{"task_id": "CPP/53", "generation": "#include <iostream>  // Include iostream for input/output operations\n\nusing namespace std;\n\nint add(int x, int y) {\n    return x + y;  // Return the sum of x and y\n}\n\n"}
{"task_id": "CPP/54", "generation": "#include <iostream>\n#include <string>\n#include <set>\n\nusing namespace std;\n\nbool same_chars(string s0, string s1) {\n    // Create a set for each string to store unique characters\n    set<char> chars_s0(s0.begin(), s0.end());\n    set<char> chars_s1(s1.begin(), s1.end());\n\n    // Check if both sets have the same elements\n    return chars_s0 == chars_s1;\n}\n\n"}
{"task_id": "CPP/55", "generation": "#include <iostream>\nusing namespace std;\n\nint fib(int n) {\n    if (n <= 0) return 0;\n    if (n == 1) return 1;\n\n    int a = 0, b = 1, c;\n    for (int i = 2; i <= n; ++i) {\n        c = a + b;\n        a = b;\n        b = c;\n    }\n    return b;\n}\n\n// Function to test the fib function\nvoid test_fib() {\n    cout << \"fib(10): \" << fib(10) << endl; // Should output 55\n    cout << \"fib(1): \" << fib(1) << endl;   // Should output 1\n    cout << \"fib(8): \" << fib(8) << endl;   // Should output 21\n}\n\n"}
{"task_id": "CPP/56", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    int count = 0;\n    \n    for (char ch : brackets) {\n        if (ch == '<') {\n            count++;\n        } else if (ch == '>') {\n            count--;\n            if (count < 0) {\n                // If count is negative, it means there's a closing bracket without an opening one\n                return false;\n            }\n        }\n    }\n    \n    // The string is correct if the counter is zero at the end\n    return count == 0;\n}\n\n"}
{"task_id": "CPP/57", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool monotonic(vector<float> l) {\n    // Check if the list is empty or has only one element\n    if (l.size() <= 1) return true;\n\n    // Determine the direction of the sequence (increasing or decreasing)\n    bool increasing = false;\n    bool decreasing = false;\n\n    for (size_t i = 1; i < l.size(); ++i) {\n        if (l[i] > l[i - 1]) {\n            increasing = true;\n        } else if (l[i] < l[i - 1]) {\n            decreasing = true;\n        }\n\n        // If both conditions are true, the sequence is not monotonic\n        if (increasing && decreasing) return false;\n    }\n\n    // The list is either strictly increasing or strictly decreasing\n    return true;\n}\n\n"}
{"task_id": "CPP/58", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // For std::sort\n#include <set>       // For std::set_intersection\n\nusing namespace std;\n\n// Function to find common elements in two vectors, sorted and unique\nvector<int> common(vector<int> l1, vector<int> l2) {\n    set<int> s1(l1.begin(), l1.end()); // Convert first vector to a set\n    set<int> s2(l2.begin(), l2.end()); // Convert second vector to a set\n\n    vector<int> result;\n    \n    // Use set_intersection to find common elements and store them in the result vector\n    set_intersection(s1.begin(), s1.end(), s2.begin(), s2.end(), back_inserter(result));\n\n    // Sort the result (though it should already be sorted due to set properties)\n    sort(result.begin(), result.end());\n\n    return result;\n}\n\n"}
{"task_id": "CPP/59", "generation": "#include <iostream>\nusing namespace std;\n\nint largest_prime_factor(int n) {\n    int maxPrime = -1;\n    \n    // Divide by 2 to remove all even factors\n    while (n % 2 == 0) {\n        maxPrime = 2;\n        n /= 2;\n    }\n    \n    // Check for odd factors from 3 onwards\n    for (int i = 3; i * i <= n; i += 2) {\n        while (n % i == 0) {\n            maxPrime = i;\n            n /= i;\n        }\n    }\n    \n    // If n is a prime number greater than 2\n    if (n > 2) {\n        maxPrime = n;\n    }\n    \n    return maxPrime;\n}\n\n"}
{"task_id": "CPP/60", "generation": "#include <iostream>\nusing namespace std;\n\nint sum_to_n(int n) {\n    return (n * (n + 1)) / 2;\n}\n\n"}
{"task_id": "CPP/61", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    int balance = 0;\n    for (char c : brackets) {\n        if (c == '(') {\n            balance++;\n        } else if (c == ')') {\n            balance--;\n        }\n        // If at any point the balance is negative, it means there's a closing parenthesis without an opening one\n        if (balance < 0) {\n            return false;\n        }\n    }\n    // If the balance is zero, all parentheses are correctly matched\n    return balance == 0;\n}\n\n"}
{"task_id": "CPP/62", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvector<float> derivative(vector<float> xs) {\n    // Create a new vector to store the coefficients of the derivative polynomial.\n    vector<float> result;\n    \n    // Iterate through the input vector, starting from the first non-constant term.\n    for (size_t i = 1; i < xs.size(); ++i) {\n        // Multiply each coefficient by its corresponding power and add it to the result vector.\n        result.push_back(xs[i] * i);\n    }\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/63", "generation": "#include <iostream>\nusing namespace std;\n\nint fibfib(int n) {\n    if (n == 0 || n == 1) return 0;\n    if (n == 2) return 1;\n\n    int a = 0, b = 0, c = 1; // Initial values for fibfib(0), fibfib(1), and fibfib(2)\n    int result = 0;\n\n    for (int i = 3; i <= n; ++i) {\n        result = a + b + c;\n        a = b;\n        b = c;\n        c = result;\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/64", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint vowels_count(string s) {\n    int count = 0;\n    \n    // Convert the string to lowercase for easier comparison\n    transform(s.begin(), s.end(), s.begin(), ::tolower);\n    \n    // Check each character in the string\n    for (char c : s) {\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' || \n            (c == 'y' && s.length() - 1 == distance(s.begin(), find_if(s.rbegin(), s.rend(), [](char ch) { return !isspace(ch); })))) {\n            count++;\n        }\n    }\n    \n    return count;\n}\n\n"}
{"task_id": "CPP/65", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to perform circular shift or reverse if shift > number of digits\nstring circular_shift(int x, int shift) {\n    // Convert the integer to a string\n    string num_str = to_string(x);\n    \n    // Get the length of the string (number of digits)\n    size_t len = num_str.length();\n    \n    // If shift is greater than or equal to the number of digits, reverse the string\n    if (shift >= len) {\n        reverse(num_str.begin(), num_str.end());\n    } else {\n        // Perform circular right shift\n        int effective_shift = shift % len;\n        string shifted_part = num_str.substr(len - effective_shift);\n        string remaining_part = num_str.substr(0, len - effective_shift);\n        num_str = shifted_part + remaining_part;\n    }\n    \n    return num_str;\n}\n\n// Function to test the circular_shift function\nvoid test_circular_shift() {\n    cout << \"circular_shift(12345, 2): \" << circular_shift(12345, 2) << endl; // Expected: \"34512\"\n    cout << \"circular_shift(12345, 7): \" << circular_shift(12345, 7) << endl; // Expected: \"54321\"\n}\n\n"}
{"task_id": "CPP/66", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint digitSum(string s) {\n    int sum = 0;\n    for (char c : s) {\n        if (isupper(c)) { // Check if the character is uppercase\n            sum += static_cast<int>(c); // Add its ASCII value to the sum\n        }\n    }\n    return sum;\n}\n\n// Function to test the digitSum function with provided examples\nvoid testDigitSum() {\n    cout << \"Testing digitSum:\" << endl;\n    assert(digitSum(\"\") == 0);\n    assert(digitSum(\"abAB\") == 131);\n    assert(digitSum(\"abcCd\") == 67);\n    assert(digitSum(\"helloE\") == 69);\n    assert(digitSum(\"woArBld\") == 131);\n    assert(digitSum(\"aAaaaXa\") == 153);\n\n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/67", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint fruit_distribution(string s, int n) {\n    // Find the position of 'apples' in the string\n    size_t apples_pos = s.find(\"apples\");\n    \n    // Extract the number before 'apples'\n    size_t start_apples = s.rfind(' ', apples_pos);\n    if (start_apples == string::npos) {\n        start_apples = 0;\n    }\n    int num_apples = stoi(s.substr(start_apples, apples_pos - start_apples).c_str());\n    \n    // Find the position of 'oranges' in the string\n    size_t oranges_pos = s.find(\"oranges\");\n    \n    // Extract the number before 'oranges'\n    size_t start_oranges = s.rfind(' ', oranges_pos);\n    if (start_oranges == string::npos) {\n        start_oranges = 0;\n    }\n    int num_oranges = stoi(s.substr(start_oranges, oranges_pos - start_oranges).c_str());\n    \n    // Calculate the number of mangoes\n    int num_mangoes = n - (num_apples + num_oranges);\n    return num_mangoes;\n}\n\n"}
{"task_id": "CPP/68", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> pluck(vector<int> arr) {\n    int minEvenValue = -1;\n    int minIndex = -1;\n\n    for (int i = 0; i < arr.size(); ++i) {\n        if (arr[i] % 2 == 0) { // Check if the current node is even\n            if (minEvenValue == -1 || arr[i] < minEvenValue || \n                (arr[i] == minEvenValue && i < minIndex)) {\n                minEvenValue = arr[i];\n                minIndex = i;\n            }\n        }\n    }\n\n    // If no even value was found, return an empty vector\n    if (minEvenValue == -1) {\n        return {};\n    } else {\n        return {minEvenValue, minIndex};\n    }\n}\n\n"}
{"task_id": "CPP/69", "generation": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint search(vector<int> lst) {\n    // Create a frequency map to count occurrences of each number\n    unordered_map<int, int> freqMap;\n    \n    // Count the frequency of each integer in the vector\n    for (int num : lst) {\n        freqMap[num]++;\n    }\n    \n    // Initialize the result with -1\n    int result = -1;\n    \n    // Iterate through the map to find the greatest number that meets the condition\n    for (const auto &pair : freqMap) {\n        if (pair.first <= pair.second && pair.first > result) {\n            result = pair.first;\n        }\n    }\n    \n    return result;\n}\n\n// Function to test the search function with provided examples\nvoid test() {\n    cout << \"search({4, 1, 2, 2, 3, 1}) == \" << search({4, 1, 2, 2, 3, 1}) << endl; // Should output 2\n    cout << \"search({1, 2, 2, 3, 3, 3, 4, 4, 4}) == \" << search({1, 2, 2, 3, 3, 3, 4, 4, 4}) << endl; // Should output 3\n    cout << \"search({5, 5, 4, 4, 4}) == \" << search({5, 5, 4, 4, 4}) << endl; // Should output -1\n}\n\n"}
{"task_id": "CPP/70", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> strange_sort_list(vector<int> lst) {\n    // Sort the list to easily find min and max\n    sort(lst.begin(), lst.end());\n    \n    vector<int> result;\n    int start = 0;  // Pointer for minimum value\n    int end = lst.size() - 1;  // Pointer for maximum value\n    \n    while (start <= end) {\n        if (start == end) {\n            // If only one element is left, add it to the result\n            result.push_back(lst[start]);\n            break;\n        }\n        \n        // Add minimum value\n        result.push_back(lst[start++]);\n        \n        // Add maximum value\n        result.push_back(lst[end--]);\n    }\n    \n    return result;\n}\n\n// Function to check the correctness of the strange_sort_list function\nvoid check() {\n    assert(strange_sort_list({1, 2, 3, 4}) == vector<int>({1, 4, 2, 3}));\n    assert(strange_sort_list({5, 5, 5, 5}) == vector<int>({5, 5, 5, 5}));\n    assert(strange_sort_list({}) == vector<int>({}));\n    cout << \"All test cases passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/71", "generation": "#include <stdio.h>\n#include <math.h>\n\nusing namespace std;\n\nfloat triangle_area(float a, float b, float c) {\n    // Check if the sides form a valid triangle\n    if (a + b <= c || a + c <= b || b + c <= a) {\n        return -1;\n    }\n\n    // Calculate the semi-perimeter\n    float s = (a + b + c) / 2;\n\n    // Calculate the area using Heron's formula\n    float area = sqrt(s * (s - a) * (s - b) * (s - c));\n\n    // Round to 2 decimal points\n    return round(area * 100) / 100;\n}\n\n"}
{"task_id": "CPP/72", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool is_balanced(const vector<int>& q) {\n    for (size_t i = 0; i < q.size() / 2; ++i) {\n        if (q[i] != q[q.size() - 1 - i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nbool will_it_fly(const vector<int>& q, int w) {\n    // Check if the sum of elements is less than or equal to w\n    int sum = 0;\n    for (int num : q) {\n        sum += num;\n    }\n\n    // Check if the vector is balanced\n    bool balanced = is_balanced(q);\n\n    return sum <= w && balanced;\n}\n\n// Function to test the will_it_fly function with provided examples\nvoid test() {\n    cout << \"will_it_fly({1, 2}, 5) \u279e \" << will_it_fly({1, 2}, 5) << endl; // false\n    cout << \"will_it_fly({3, 2, 3}, 1) \u279e \" << will_it_fly({3, 2, 3}, 1) << endl; // false\n    cout << \"will_it_fly({3, 2, 3}, 9) \u279e \" << will_it_fly({3, 2, 3}, 9) << endl; // true\n    cout << \"will_it_fly({3}, 5) \u279e \" << will_it_fly({3}, 5) << endl; // true\n}\n\n"}
{"task_id": "CPP/73", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint smallest_change(vector<int> arr) {\n    int left = 0;\n    int right = arr.size() - 1;\n    int changes_needed = 0;\n\n    while (left < right) {\n        if (arr[left] != arr[right]) {\n            ++changes_needed;\n        }\n        ++left;\n        --right;\n    }\n\n    return changes_needed;\n}\n\n"}
{"task_id": "CPP/74", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to calculate the total number of characters in a vector of strings\nint count_chars(const vector<string>& vec) {\n    int total = 0;\n    for (const auto& str : vec) {\n        total += str.length();\n    }\n    return total;\n}\n\nvector<string> total_match(vector<string> lst1, vector<string> lst2) {\n    // Calculate the total number of characters in both vectors\n    int chars_lst1 = count_chars(lst1);\n    int chars_lst2 = count_chars(lst2);\n\n    // Compare and return the appropriate vector\n    if (chars_lst1 < chars_lst2) {\n        return lst1;\n    } else if (chars_lst2 < chars_lst1) {\n        return lst2;\n    } else {\n        return lst1;  // Return the first vector if both have the same number of characters\n    }\n}\n\n// Function to test the total_match function with provided examples\nvoid test_total_match() {\n    assert(total_match({}, {}) == vector<string>());\n    assert(total_match({\"hi\", \"admin\"}, {\"hI\", \"Hi\"}) == vector<string>{\"hI\", \"Hi\"});\n    assert(total_match({\"hi\", \"admin\"}, {\"hi\", \"hi\", \"admin\", \"project\"}) == vector<string>{\"hi\", \"admin\"});\n    assert(total_match({\"hi\", \"admin\"}, {\"hI\", \"hi\", \"hi\"}) == vector<string>{\"hI\", \"hi\", \"hi\"});\n    assert(total_match({\"4\"}, {\"1\", \"2\", \"3\", \"4\", \"5\"}) == vector<string>{\"4\"});\n\n    cout << \"All tests passed successfully.\" << endl;\n}\n\n"}
{"task_id": "CPP/75", "generation": "#include <iostream>\nusing namespace std;\n\n// Helper function to check if a number is prime\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\n// Main function to check if the number is a product of exactly three primes\nbool is_multiply_prime(int a) {\n    // We will use an array of prime numbers less than 100 for simplicity\n    int primes[] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97};\n    int count = 0;\n\n    // Iterate through the primes and check if they divide a\n    for (int prime : primes) {\n        while (a % prime == 0) {\n            a /= prime;\n            count++;\n        }\n    }\n\n    // Check if exactly three prime factors were found\n    return count == 3 && a == 1;\n}\n\n// Function to test the is_multiply_prime function\nvoid test() {\n    cout << \"Testing is_multiply_prime...\" << endl;\n    assert(is_multiply_prime(30) == true);   // 2 * 3 * 5 = 30\n    assert(is_multiply_prime(60) == false);  // 2^2 * 3 * 5, more than three primes\n    assert(is_multiply_prime(105) == true);  // 3 * 5 * 7 = 105\n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/76", "generation": "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\nbool is_simple_power(int x, int n) {\n    // Check if n is 1 and x is not 1. If so, return false.\n    if (n == 1 && x != 1) {\n        return false;\n    }\n    \n    // Calculate the logarithm of x to the base n\n    double log_result = log(x) / log(n);\n    \n    // Check if the result is an integer by comparing it with its rounded value\n    return floor(log_result) == log_result;\n}\n\n"}
{"task_id": "CPP/77", "generation": "#include <stdio.h>\n#include <math.h>\n\nusing namespace std;\n\nbool iscube(int a) {\n    // Handle special case for 0\n    if (a == 0) return true;\n    \n    // Calculate the cube root of the absolute value of 'a'\n    double cubeRoot = cbrt(abs(a));\n    \n    // Round the cube root to the nearest integer\n    int roundedCubeRoot = round(cubeRoot);\n    \n    // Check if cubing the rounded value gives back the original number\n    return (roundedCubeRoot * roundedCubeRoot * roundedCubeRoot == a);\n}\n\n"}
{"task_id": "CPP/78", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\n// Helper function to check if a hexadecimal digit is prime\nbool is_prime_hex_digit(char hex_digit) {\n    switch (hex_digit) {\n        case '2': case '3': case '5': case '7':\n        case 'B': case 'D': return true;\n        default: return false;\n    }\n}\n\n// Main function to count the number of prime hexadecimal digits\nint hex_key(string num) {\n    int count = 0;\n    for (char digit : num) {\n        if (is_prime_hex_digit(digit)) {\n            count++;\n        }\n    }\n    return count;\n}\n\n// Function to test the hex_key function with provided examples\nvoid check() {\n    cout << \"hex_key(\\\"AB\\\") should be 1: \" << hex_key(\"AB\") << endl;\n    cout << \"hex_key(\\\"1077E\\\") should be 2: \" << hex_key(\"1077E\") << endl;\n    cout << \"hex_key(\\\"ABED1A33\\\") should be 4: \" << hex_key(\"ABED1A33\") << endl;\n    cout << \"hex_key(\\\"123456789ABCDEF0\\\") should be 6: \" << hex_key(\"123456789ABCDEF0\") << endl;\n    cout << \"hex_key(\\\"2020\\\") should be 2: \" << hex_key(\"2020\") << endl;\n}\n\n"}
{"task_id": "CPP/79", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring decimal_to_binary(int decimal) {\n    // Convert the decimal number to binary using bit manipulation\n    if (decimal == 0) return \"db0db\";\n    \n    string binary = \"\";\n    while (decimal > 0) {\n        int remainder = decimal % 2;\n        binary = to_string(remainder) + binary;\n        decimal /= 2;\n    }\n    \n    // Add the \"db\" prefix and suffix\n    return \"db\" + binary + \"db\";\n}\n\n// Function to test the correctness of the function\nvoid check() {\n    cout << decimal_to_binary(15) << endl;   // Expected output: db1111db\n    cout << decimal_to_binary(32) << endl;   // Expected output: db100000db\n    cout << decimal_to_binary(0) << endl;    // Expected output: db0db\n}\n\n"}
{"task_id": "CPP/80", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_happy(string s) {\n    // Check if the length of the string is less than 3\n    if (s.length() < 3) return false;\n\n    // Iterate through the string and check every set of three consecutive characters\n    for (size_t i = 0; i <= s.length() - 3; ++i) {\n        // Check if any two out of the three consecutive characters are the same\n        if (s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]) {\n            return false;\n        }\n    }\n\n    // If no three consecutive characters are the same, the string is happy\n    return true;\n}\n\n"}
{"task_id": "CPP/81", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to map GPA to a corresponding letter grade\nvector<string> numerical_letter_grade(vector<float> grades) {\n    vector<string> letter_grades;\n    \n    for (float gpa : grades) {\n        if (gpa >= 4.0f) {\n            letter_grades.push_back(\"A+\");\n        } else if (gpa > 3.7f) {\n            letter_grades.push_back(\"A\");\n        } else if (gpa > 3.3f) {\n            letter_grades.push_back(\"A-\");\n        } else if (gpa > 3.0f) {\n            letter_grades.push_back(\"B+\");\n        } else if (gpa > 2.7f) {\n            letter_grades.push_back(\"B\");\n        } else if (gpa > 2.3f) {\n            letter_grades.push_back(\"B-\");\n        } else if (gpa > 2.0f) {\n            letter_grades.push_back(\"C+\");\n        } else if (gpa > 1.7f) {\n            letter_grades.push_back(\"C\");\n        } else if (gpa > 1.3f) {\n            letter_grades.push_back(\"C-\");\n        } else if (gpa > 1.0f) {\n            letter_grades.push_back(\"D+\");\n        } else if (gpa > 0.7f) {\n            letter_grades.push_back(\"D\");\n        } else if (gpa > 0.0f) {\n            letter_grades.push_back(\"D-\");\n        } else {\n            letter_grades.push_back(\"E\");\n        }\n    }\n\n    return letter_grades;\n}\n\n// Function to check the correctness of the function\nvoid check() {\n    vector<float> grades = {4.0, 3, 1.7, 2, 3.5};\n    vector<string> expected = {\"A+\", \"B\", \"C-\", \"C\", \"A-\"};\n    vector<string> result = numerical_letter_grade(grades);\n\n    if (result == expected) {\n        printf(\"Test passed!\\n\");\n    } else {\n        printf(\"Test failed! Expected: %s, Got: %s\\n\", \n               expected.begin(), result.begin());\n    }\n}\n\n"}
{"task_id": "CPP/82", "generation": "#include <iostream>\n#include <string>\n\n// Function to check if a number is prime\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    if (n == 2 || n == 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n\n    for (int i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0)\n            return false;\n    }\n    return true;\n}\n\n// Function to check if the length of a string is prime\nbool prime_length(const std::string& str) {\n    int len = str.length();\n    return is_prime(len);\n}\n\n"}
{"task_id": "CPP/83", "generation": "#include <iostream>\nusing namespace std;\n\nint starts_one_ends(int n) {\n    // If n is 1, there's only one number (1 itself)\n    if (n == 1) return 1;\n    \n    // For numbers starting with 1: the remaining (n-1) digits can be any digit from 0 to 9\n    int start_with_1 = 9 * pow(10, n - 2);\n    \n    // For numbers ending with 1: the first (n-1) digits can be any digit from 0 to 9\n    int end_with_1 = 9 * pow(10, n - 2);\n    \n    // Numbers that both start and end with 1: the middle (n-2) digits can be any digit from 0 to 9\n    int both_start_and_end_with_1 = pow(10, n - 2);\n    \n    // Total count is the sum of numbers starting with 1 and ending with 1 minus the overlap\n    return start_with_1 + end_with_1 - both_start_and_end_with_1;\n}\n\n"}
{"task_id": "CPP/84", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring solve(int N) {\n    int sum = 0;\n    \n    // Calculate the sum of digits\n    while (N > 0) {\n        sum += N % 10;  // Add the last digit to the sum\n        N /= 10;        // Remove the last digit from N\n    }\n    \n    // Convert the sum to binary string\n    string binarySum = \"\";\n    if (sum == 0) {\n        return \"0\";\n    }\n    \n    while (sum > 0) {\n        binarySum = to_string(sum % 2) + binarySum;  // Prepend the remainder when divided by 2\n        sum /= 2;                                    // Divide the sum by 2\n    }\n    \n    return binarySum;\n}\n\n"}
{"task_id": "CPP/85", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint add(vector<int> lst) {\n    int sum = 0;\n    \n    // Iterate through the vector starting from index 1 (second element)\n    for (size_t i = 1; i < lst.size(); i += 2) {\n        if (lst[i] % 2 == 0) {  // Check if the element is even\n            sum += lst[i];\n        }\n    }\n    \n    return sum;\n}\n\n"}
{"task_id": "CPP/86", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to sort individual words while keeping spaces as they are\nvoid sortWord(string &word) {\n    for (int i = 0; i < word.length(); ++i) {\n        if (word[i] != ' ') { // Skip spaces\n            int j = i + 1;\n            char temp;\n            while (j < word.length() && word[j] != ' ') { // Sort characters in the word\n                if (word[j] < word[i]) {\n                    temp = word[i];\n                    word[i] = word[j];\n                    word[j] = temp;\n                    i = j - 1; // Adjust index to recheck the swapped position\n                }\n                ++j;\n            }\n        }\n    }\n}\n\n// Function to sort each word in the sentence while keeping spaces and order intact\nstring anti_shuffle(string s) {\n    string result = \"\";\n    int start = 0;\n\n    for (int i = 0; i <= s.length(); ++i) { // Loop through the string including the end\n        if (s[i] == ' ' || i == s.length()) { // End of a word or end of the string\n            sortWord(s.substr(start, i - start)); // Sort the current word\n            result += s.substr(start, i - start); // Append it to the result\n            start = i + 1; // Move to the next word\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/87", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to get the coordinates of x in the list and return sorted as required\nvector<vector<int>> get_row(vector<vector<int>> lst, int x) {\n    vector<vector<int>> result;\n    \n    // Iterate through each row\n    for (int i = 0; i < lst.size(); ++i) {\n        const auto& row = lst[i];\n        \n        // Iterate through each element in the row\n        for (int j = 0; j < row.size(); ++j) {\n            if (row[j] == x) {\n                result.push_back({i, j});\n            }\n        }\n    }\n\n    // Sort by rows in ascending order and then within each row sort columns in descending order\n    sort(result.begin(), result.end());\n    \n    // Sorting the coordinates for a specific row in descending order of column indices\n    for (auto& coord : result) {\n        if (coord.size() > 1) { // Ensure we only process rows with more than one coordinate\n            sort(coord.rbegin(), coord.rend());\n        }\n    }\n\n    return result;\n}\n\n// Function to print the result for verification\nvoid print_result(const vector<vector<int>>& result) {\n    for (const auto& row : result) {\n        for (int val : row) {\n            cout << val << \" \";\n        }\n        cout << endl;\n    }\n}\n\n"}
{"task_id": "CPP/88", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> sort_array(vector<int> array) {\n    // Check if the input vector is empty or has only one element\n    if (array.empty() || array.size() == 1) {\n        return array;\n    }\n\n    int firstElement = array.front();\n    int lastElement = array.back();\n\n    // Calculate the sum of the first and last elements\n    int sum = firstElement + lastElement;\n\n    // Determine sorting order based on the sum being odd or even\n    vector<int> sortedArray(array);  // Make a copy to avoid modifying the original vector\n\n    if (sum % 2 == 0) {\n        // Sort in descending order\n        sort(sortedArray.begin(), sortedArray.end(), greater<int>());\n    } else {\n        // Sort in ascending order\n        sort(sortedArray.begin(), sortedArray.end());\n    }\n\n    return sortedArray;\n}\n\n// Function to test the solution with provided examples\nvoid check() {\n    vector<int> emptyVec = {};\n    vector<int> singleElementVec = {5};\n    vector<int> vec1 = {2, 4, 3, 0, 1, 5};\n    vector<int> vec2 = {2, 4, 3, 0, 1, 5, 6};\n\n    cout << \"sort_array({}) => \";\n    for (int num : sort_array(emptyVec)) {\n        cout << num << \" \";\n    }\n    cout << endl;\n\n    cout << \"sort_array({5}) => \";\n    for (int num : sort_array(singleElementVec)) {\n        cout << num << \" \";\n    }\n    cout << endl;\n\n    cout << \"sort_array({2, 4, 3, 0, 1, 5}) => \";\n    for (int num : sort_array(vec1)) {\n        cout << num << \" \";\n    }\n    cout << endl;\n\n    cout << \"sort_array({2, 4, 3, 0, 1, 5, 6}) => \";\n    for (int num : sort_array(vec2)) {\n        cout << num << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/89", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\n// Helper function to rotate a single character by 4 places\nchar rotateChar(char c) {\n    if (c >= 'a' && c <= 'z') {\n        return ((c - 'a' + 4) % 26) + 'a';\n    } else if (c >= 'A' && c <= 'Z') {\n        return ((c - 'A' + 4) % 26) + 'A';\n    }\n    // Non-alphabetic characters are not changed\n    return c;\n}\n\n// Function to encrypt the string by rotating each character\nstring encrypt(string s) {\n    for (char &c : s) {\n        c = rotateChar(c);\n    }\n    return s;\n}\n\n"}
{"task_id": "CPP/90", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n// Function to return the 2nd smallest element in a vector.\nint next_smallest(vector<int> lst) {\n    // If the list is empty or has only one unique element, return None (represented as -1 here)\n    if (lst.size() <= 1 || (unique(lst.begin(), lst.end()) == lst.begin())) {\n        return -1; // Representing None\n    }\n\n    // Sort the vector\n    sort(lst.begin(), lst.end());\n\n    // Find the second smallest element\n    auto it = unique(lst.begin(), lst.end());\n    if (it != lst.end() && next(it) != lst.end()) {\n        return *next(it);\n    } else {\n        return -1; // Representing None\n    }\n}\n\n// Function to test the next_smallest function with provided data points.\nvoid test_next_smallest() {\n    assert(next_smallest({1, 2, 3, 4, 5}) == 2);\n    assert(next_smallest({5, 1, 4, 3, 2}) == 2);\n    assert(next_smallest({}) == -1); // Representing None\n    assert(next_smallest({1, 1}) == -1); // Representing None\n    cout << \"All test cases passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/91", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nint is_bored(string S) {\n    int count = 0;\n    stringstream ss(S);\n    string sentence;\n\n    // Split the input string into sentences\n    while (getline(ss, sentence, '.')) {\n        if (!sentence.empty()) { // Check for empty sentences\n            getline(ss, sentence, '?');\n            if (!sentence.empty()) {\n                getline(ss, sentence, '!');\n                if (!sentence.empty()) {\n                    // Trim leading and trailing spaces\n                    size_t start = sentence.find_first_not_of(\" \\t\");\n                    size_t end = sentence.find_last_not_of(\" \\t\");\n\n                    if (start != string::npos && end != string::npos) {\n                        sentence = sentence.substr(start, end - start + 1);\n                        // Check if the first word is \"I\"\n                        if (!sentence.empty() && sentence[0] == 'I') {\n                            count++;\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    return count;\n}\n\n"}
{"task_id": "CPP/92", "generation": "#include <iostream>\nusing namespace std;\n\nbool any_int(float a, float b, float c) {\n    // Convert floats to integers by truncating the decimal part.\n    int ia = static_cast<int>(a);\n    int ib = static_cast<int>(b);\n    int ic = static_cast<int>(c);\n\n    // Check if all numbers are integers\n    bool is_integer_a = (a == ia);\n    bool is_integer_b = (b == ib);\n    bool is_integer_c = (c == ic);\n\n    // If any of the numbers is not an integer, return false.\n    if (!is_integer_a || !is_integer_b || !is_integer_c) {\n        return false;\n    }\n\n    // Check if one number is equal to the sum of the other two\n    return (ia == ib + ic) || (ib == ia + ic) || (ic == ia + ib);\n}\n\n"}
{"task_id": "CPP/93", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\n// Function to encode a message by swapping cases and replacing vowels\nstring encode(string message) {\n    // Swap case of all letters\n    for (char &c : message) {\n        if (islower(c)) c = toupper(c);\n        else if (isupper(c)) c = tolower(c);\n    }\n\n    // Replace each vowel with the letter that appears 2 places ahead in the alphabet\n    string vowels = \"aeiouAEIOU\";\n    for (char &c : message) {\n        if (vowels.find(c) != string::npos) {\n            int index = vowels.find(c);\n            c = vowels[(index + 2) % vowels.length()];\n        }\n    }\n\n    return message;\n}\n\n"}
{"task_id": "CPP/94", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Helper function to check if a number is prime\nbool isPrime(int n) {\n    if (n <= 1) return false;\n    if (n == 2 || n == 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    for (int i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0)\n            return false;\n    }\n    return true;\n}\n\n// Function to find the sum of digits of a number\nint sumOfDigits(int num) {\n    int sum = 0;\n    while (num > 0) {\n        sum += num % 10;\n        num /= 10;\n    }\n    return sum;\n}\n\n// Main function to find the largest prime and its digit sum\nint largestPrimeDigitSum(vector<int> lst) {\n    int maxPrime = -1; // Initialize with a non-prime value\n\n    for (int num : lst) {\n        if (isPrime(num)) {\n            if (num > maxPrime) {\n                maxPrime = num;\n            }\n        }\n    }\n\n    return sumOfDigits(maxPrime);\n}\n\n// Function to test the solution\nvoid check() {\n    vector<int> lst1 = {0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3};\n    cout << largestPrimeDigitSum(lst1) << endl; // Output: 10\n\n    vector<int> lst2 = {1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1};\n    cout << largestPrimeDigitSum(lst2) << endl; // Output: 25\n\n    vector<int> lst3 = {1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3};\n    cout << largestPrimeDigitSum(lst3) << endl; // Output: 13\n\n    vector<int> lst4 = {0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6};\n    cout << largestPrimeDigitSum(lst4) << endl; // Output: 11\n\n    vector<int> lst5 = {0, 81, 12, 3, 1, 21};\n    cout << largestPrimeDigitSum(lst5) << endl; // Output: 3\n\n    vector<int> lst6 = {0, 8, 1, 2, 1, 7};\n    cout << largestPrimeDigitSum(lst6) << endl; // Output: 7\n}\n\n"}
{"task_id": "CPP/95", "generation": "#include <iostream>\n#include <string>\n#include <map>\n\nusing namespace std;\n\nbool check_dict_case(map<string, string> dict) {\n    // Check if the map is empty\n    if (dict.empty()) {\n        return false;\n    }\n\n    bool allLower = true;\n    bool allUpper = true;\n\n    // Determine the case of the first key\n    for (const auto &pair : dict) {\n        if (!islower(pair.first[0])) {\n            allLower = false;\n        }\n        if (!isupper(pair.first[0])) {\n            allUpper = false;\n        }\n\n        // If both conditions are false, return false immediately\n        if (!allLower && !allUpper) {\n            return false;\n        }\n    }\n\n    // Return true only if all keys are in the same case\n    return allLower || allUpper;\n}\n\n// Function to test the check_dict_case function with provided examples\nvoid test_check_dict_case() {\n    cout << boolalpha; // Print bools as true/false instead of 1/0\n    cout << \"check_dict_case({\\\"a\\\",\\\"apple\\\"}, {\\\"b\\\",\\\"banana\\\"}): \" \n         << check_dict_case({{\"a\", \"apple\"}, {\"b\", \"banana\"}}) << endl;\n    cout << \"check_dict_case({\\\"a\\\",\\\"apple\\\"}, {\\\"A\\\",\\\"banana\\\"}, {\\\"B\\\",\\\"banana\\\"}): \"\n         << check_dict_case({{\"a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}) << endl;\n    cout << \"check_dict_case({\\\"a\\\",\\\"apple\\\"}, {\\\"8\\\",\\\"banana\\\"}, {\\\"a\\\",\\\"apple\\\"}): \"\n         << check_dict_case({{\"a\", \"apple\"}, {\"8\", \"banana\"}, {\"a\", \"apple\"}}) << endl;\n    cout << \"check_dict_case({\\\"Name\\\",\\\"John\\\"}, {\\\"Age\\\",\\\"36\\\"}, {\\\"City\\\",\\\"Houston\\\"}): \"\n         << check_dict_case({{\"Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}) << endl;\n    cout << \"check_dict_case({\\\"STATE\\\",\\\"NC\\\"}, {\\\"ZIP\\\",\\\"12345\\\"}): \"\n         << check_dict_case({{\"STATE\", \"NC\"}, {\"ZIP\", \"12345\"}}) << endl;\n}\n\n"}
{"task_id": "CPP/96", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Helper function to check if a number is prime\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    for (int i = 2; i * i <= num; ++i) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\n// Function to generate a vector of prime numbers less than n\nvector<int> count_up_to(int n) {\n    vector<int> primes;\n    for (int i = 2; i < n; ++i) {\n        if (is_prime(i)) {\n            primes.push_back(i);\n        }\n    }\n    return primes;\n}\n\n// Function to test the count_up_to function\nvoid test_count_up_to() {\n    assert(count_up_to(5) == vector<int>({2, 3}));\n    assert(count_up_to(11) == vector<int>({2, 3, 5, 7}));\n    assert(count_up_to(0).empty());\n    assert(count_up_to(20) == vector<int>({2, 3, 5, 7, 11, 13, 17, 19}));\n    assert(count_up_to(1).empty());\n    assert(count_up_to(18) == vector<int>({2, 3, 5, 7, 11, 13, 17}));\n\n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/97", "generation": "#include <iostream>\n\n// Function to get the unit digit of an integer\nint getUnitDigit(int num) {\n    return abs(num) % 10;\n}\n\n// Function to multiply the unit digits of two integers\nint multiply(int a, int b) {\n    // Get the unit digits of both numbers\n    int unitDigitA = getUnitDigit(a);\n    int unitDigitB = getUnitDigit(b);\n\n    // Return the product of the unit digits\n    return unitDigitA * unitDigitB;\n}\n\n// Function to test the multiply function with some examples\nvoid testMultiply() {\n    std::cout << \"multiply(148, 412) should return 16: \" \n              << (multiply(148, 412) == 16 ? \"Pass\" : \"Fail\") << std::endl;\n    std::cout << \"multiply(19, 28) should return 72: \"\n              << (multiply(19, 28) == 72 ? \"Pass\" : \"Fail\") << std::endl;\n    std::cout << \"multiply(2020, 1851) should return 0: \"\n              << (multiply(2020, 1851) == 0 ? \"Pass\" : \"Fail\") << std::endl;\n    std::cout << \"multiply(14, -15) should return 20: \"\n              << (multiply(14, -15) == 20 ? \"Pass\" : \"Fail\") << std::endl;\n}\n\n"}
{"task_id": "CPP/98", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint count_upper(string s) {\n    int count = 0;\n    for (size_t i = 0; i < s.length(); i += 2) { // Iterate over even indices\n        char c = tolower(s[i]); // Convert the character to lowercase to simplify comparison\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n            count++;\n        }\n    }\n    return count;\n}\n\n"}
{"task_id": "CPP/99", "generation": "#include <iostream>\n#include <cmath>\n#include <string>\n\nusing namespace std;\n\nint closest_integer(string value) {\n    // Convert the string to a floating-point number\n    double num = stod(value);\n    \n    // Check if the number is exactly halfway between two integers\n    double fractional_part = modf(num, &num);\n    int integer_part = static_cast<int>(num);\n    \n    if (fabs(fractional_part) == 0.5) {\n        // If equidistant from two integers, round away from zero\n        return num > 0 ? ceil(num) : floor(num);\n    } else {\n        // Otherwise, use standard rounding rules\n        return round(num);\n    }\n}\n\n"}
{"task_id": "CPP/100", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Function to determine the next stone count based on the parity of the current level\nint getNextStoneCount(int currentStones) {\n    if (currentStones % 2 == 0) {\n        // If the current number of stones is even, add 1 to get the next odd number\n        return currentStones + 1;\n    } else {\n        // If the current number of stones is odd, add 2 to get the next even number\n        return currentStones + 2;\n    }\n}\n\n// Function to make a pile of n levels of stones\nvector<int> make_a_pile(int n) {\n    vector<int> stonePile(n);\n    \n    // Initialize the first level with n stones\n    stonePile[0] = n;\n\n    // Fill in the rest of the levels based on the rules\n    for (int i = 1; i < n; ++i) {\n        stonePile[i] = getNextStoneCount(stonePile[i - 1]);\n    }\n\n    return stonePile;\n}\n\n// Function to print the vector\nvoid printVector(const vector<int>& vec) {\n    for (const auto& val : vec) {\n        cout << val << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/101", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nvector<string> words_string(string s) {\n    vector<string> result;\n    string word;\n    \n    // Use a stringstream to split the input string by commas and spaces\n    for (char& c : s) {\n        if (c == ',' || c == ' ') {\n            if (!word.empty()) {\n                result.push_back(word);\n                word.clear();\n            }\n        } else {\n            word += c;\n        }\n    }\n    \n    // Add the last word if it exists\n    if (!word.empty()) {\n        result.push_back(word);\n    }\n    \n    return result;\n}\n\n// Function to test the words_string function\nvoid check() {\n    vector<string> result1 = words_string(\"Hi, my name is John\");\n    for (const auto& word : result1) {\n        cout << word << endl;\n    }\n\n    vector<string> result2 = words_string(\"One, two, three, four, five, six\");\n    for (const auto& word : result2) {\n        cout << word << endl;\n    }\n}\n\n"}
{"task_id": "CPP/102", "generation": "#include <iostream>\nusing namespace std;\n\nint choose_num(int x, int y) {\n    // Ensure x is less than or equal to y for simplicity\n    if (x > y) {\n        swap(x, y);\n    }\n\n    // Check from the upper bound downwards to find the largest even number\n    for (int i = y; i >= x; --i) {\n        if (i % 2 == 0) {\n            return i;\n        }\n    }\n\n    // If no even number is found in the range, return -1\n    return -1;\n}\n\n// Function to test the choose_num function with some examples\nvoid test() {\n    cout << \"choose_num(12, 15): \" << choose_num(12, 15) << endl; // Should output 14\n    cout << \"choose_num(13, 12): \" << choose_num(13, 12) << endl; // Should output -1\n    cout << \"choose_num(10, 18): \" << choose_num(10, 18) << endl; // Should output 18\n    cout << \"choose_num(21, 25): \" << choose_num(21, 25) << endl; // Should output 24\n}\n\n"}
{"task_id": "CPP/103", "generation": "#include <stdio.h>\n#include <cmath>\n#include <string>\n\nusing namespace std;\n\nstring rounded_avg(int n, int m) {\n    // Check if n is greater than m\n    if (n > m) {\n        return \"-1\";\n    }\n\n    // Calculate the sum of integers from n to m\n    long long total_sum = 0;\n    for (int i = n; i <= m; ++i) {\n        total_sum += i;\n    }\n\n    // Calculate the number of elements in the range [n, m]\n    int num_elements = m - n + 1;\n\n    // Calculate the average\n    double average = static_cast<double>(total_sum) / num_elements;\n\n    // Round to the nearest integer (towards the smaller one if tie)\n    long long rounded_average = round(average);\n\n    // Convert the rounded average to binary and return it as a string\n    return bitset<64>(rounded_average).to_string().substr(64 - log2(rounded_average + 1));\n}\n\n"}
{"task_id": "CPP/104", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nbool hasEvenDigit(int n) {\n    while (n > 0) {\n        int digit = n % 10;\n        if (digit % 2 == 0) return true; // If any digit is even, return true\n        n /= 10;\n    }\n    return false; // No even digits found\n}\n\nvector<int> unique_digits(vector<int> x) {\n    vector<int> result;\n\n    for (int num : x) {\n        if (!hasEvenDigit(num)) {\n            result.push_back(num);\n        }\n    }\n\n    sort(result.begin(), result.end()); // Sort the resulting vector\n\n    return result;\n}\n\n// Function to print the vector\nvoid printVector(const vector<int>& vec) {\n    for (int num : vec) {\n        cout << num << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/105", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to convert number to word\nstring num_to_word(int n) {\n    map<int, string> num_map = {\n        {1, \"One\"}, {2, \"Two\"}, {3, \"Three\"},\n        {4, \"Four\"}, {5, \"Five\"}, {6, \"Six\"},\n        {7, \"Seven\"}, {8, \"Eight\"}, {9, \"Nine\"}\n    };\n    return num_map[n];\n}\n\n// Function to process the vector\nvector<string> by_length(vector<int> arr) {\n    // Step 1: Filter out numbers not between 1 and 9 inclusive\n    vector<int> filtered;\n    for (int num : arr) {\n        if (num >= 1 && num <= 9) {\n            filtered.push_back(num);\n        }\n    }\n\n    // Step 2: Sort the remaining numbers in ascending order\n    sort(filtered.begin(), filtered.end());\n\n    // Step 3: Reverse the sorted vector\n    reverse(filtered.begin(), filtered.end());\n\n    // Step 4: Replace each digit with its corresponding name\n    vector<string> result;\n    for (int num : filtered) {\n        result.push_back(num_to_word(num));\n    }\n\n    return result;\n}\n\n// Function to print the vector of strings\nvoid print_vector(const vector<string>& vec) {\n    if (vec.empty()) {\n        cout << \"{}\" << endl;\n    } else {\n        cout << \"{\";\n        for (size_t i = 0; i < vec.size(); ++i) {\n            cout << vec[i];\n            if (i != vec.size() - 1) {\n                cout << \", \";\n            }\n        }\n        cout << \"}\" << endl;\n    }\n}\n\n"}
{"task_id": "CPP/106", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Function to compute factorial of a number\nint factorial(int num) {\n    if (num == 0 || num == 1)\n        return 1;\n    int fact = 1;\n    for (int i = 2; i <= num; ++i) {\n        fact *= i;\n    }\n    return fact;\n}\n\n// Function to compute the sum of numbers from 1 to n\nint sumToN(int n) {\n    return (n * (n + 1)) / 2;\n}\n\nvector<int> f(int n) {\n    vector<int> result(n);\n    \n    for (int i = 0; i < n; ++i) {\n        if ((i + 1) % 2 == 0) { // Check if index is even\n            result[i] = factorial(i + 1); // Factorial of (i+1)\n        } else { // Index is odd\n            result[i] = sumToN(i + 1); // Sum from 1 to (i+1)\n        }\n    }\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/107", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nbool is_palindrome(int num) {\n    string str = to_string(num);\n    int len = str.length();\n    for (int i = 0; i < len / 2; ++i) {\n        if (str[i] != str[len - i - 1]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nvector<int> even_odd_palindrome(int n) {\n    int even_count = 0, odd_count = 0;\n\n    // Single-digit palindromes\n    for (int i = 1; i <= n; ++i) {\n        if (is_palindrome(i)) {\n            if (i % 2 == 0) {\n                even_count++;\n            } else {\n                odd_count++;\n            }\n        }\n    }\n\n    // Multi-digit palindromes\n    for (int len = 2; len <= n; ++len) {\n        int start = pow(10, len - 1);\n        int end = pow(10, len) - 1;\n        if (end > n) {\n            end = n;\n        }\n        \n        // Generate palindromes of length `len`\n        for (int i = start; i <= end; ++i) {\n            string str = to_string(i);\n            int mid = str.length() / 2;\n            string second_half = str.substr(mid, str.length() - mid);\n            reverse(second_half.begin(), second_half.end());\n            string palindrome = str + second_half;\n\n            int num = stoi(palindrome);\n            if (num <= n) {\n                if (num % 2 == 0) {\n                    even_count++;\n                } else {\n                    odd_count++;\n                }\n            }\n        }\n    }\n\n    return {even_count, odd_count};\n}\n\n"}
{"task_id": "CPP/108", "generation": "#include <iostream>\n#include <vector>\n\n// Function to calculate the sum of digits of an integer, considering its sign.\nint sum_of_digits(int num) {\n    int sum = 0;\n    bool isNegative = num < 0;\n\n    while (num != 0) {\n        int digit = abs(num % 10);\n        sum += digit;\n        num /= 10;\n    }\n\n    // If the number was negative, subtract twice the first digit to account for its sign.\n    if (isNegative && sum > 0) {\n        sum -= 2 * (abs(num / 10));\n    }\n    return sum;\n}\n\n// Function to count numbers with a positive sum of digits in a vector.\nint count_nums(const std::vector<int>& n) {\n    int count = 0;\n    for (int num : n) {\n        if (sum_of_digits(num) > 0) {\n            ++count;\n        }\n    }\n    return count;\n}\n\n// Function to test the count_nums function with provided examples.\nvoid test() {\n    assert(count_nums({}) == 0);\n    assert(count_nums({-1, 11, -11}) == 1);\n    assert(count_nums({1, 1, 2}) == 3);\n\n    std::cout << \"All tests passed successfully!\" << std::endl;\n}\n\n"}
{"task_id": "CPP/109", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool move_one_ball(vector<int> arr) {\n    if (arr.empty()) return true; // If the vector is empty, it's trivially sorted\n\n    int n = arr.size();\n    int count = 0;\n    \n    for (int i = 1; i < n; ++i) {\n        if (arr[i] < arr[i - 1]) {\n            count++;\n        }\n    }\n\n    // Check the last element and first element\n    if (arr[n-1] > arr[0]) {\n        count++;\n    }\n\n    // If there is more than one place where the order breaks, it's not possible to sort with right shifts\n    return count <= 1;\n}\n\n"}
{"task_id": "CPP/110", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring exchange(vector<int> lst1, vector<int> lst2) {\n    int oddCount = 0;\n    int evenCount = 0;\n\n    // Count odd and even numbers in lst1\n    for (int num : lst1) {\n        if (num % 2 != 0) {\n            oddCount++;\n        }\n    }\n\n    // Count even numbers in lst2\n    for (int num : lst2) {\n        if (num % 2 == 0) {\n            evenCount++;\n        }\n    }\n\n    // Check if it's possible to make all elements in lst1 even by exchanging\n    if (oddCount <= evenCount) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n\n"}
{"task_id": "CPP/111", "generation": "#include <iostream>\n#include <string>\n#include <map>\n#include <vector>\nusing namespace std;\n\n// Function to find the histogram of letter frequencies\nmap<char, int> histogram(string test) {\n    map<char, int> frequencyMap;\n    \n    // Count the frequency of each character in the string\n    for (char c : test) {\n        if (c != ' ') {  // Ignore spaces\n            frequencyMap[c]++;\n        }\n    }\n\n    // Find the maximum frequency\n    int maxFrequency = 0;\n    for (const auto& pair : frequencyMap) {\n        if (pair.second > maxFrequency) {\n            maxFrequency = pair.second;\n        }\n    }\n\n    // Create a map to store characters with the highest frequency\n    map<char, int> result;\n\n    // Populate the result map with characters that have the maximum frequency\n    for (const auto& pair : frequencyMap) {\n        if (pair.second == maxFrequency) {\n            result.insert(pair);\n        }\n    }\n\n    return result;\n}\n\n// Function to print the histogram map\nvoid printHistogram(const map<char, int>& hist) {\n    for (const auto& pair : hist) {\n        cout << \"{\" << pair.first << \", \" << pair.second << \"} \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/112", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to check if a string is a palindrome\nbool is_palindrome(const string& str) {\n    int left = 0;\n    int right = str.size() - 1;\n    \n    while (left < right) {\n        if (str[left] != str[right]) {\n            return false;\n        }\n        ++left;\n        --right;\n    }\n    return true;\n}\n\n// Function to reverse_delete and check palindrome\nvector<string> reverse_delete(string s, string c) {\n    // Remove characters from s that are in c\n    for (char ch : c) {\n        s.erase(remove(s.begin(), s.end(), ch), s.end());\n    }\n\n    // Check if the resulting string is a palindrome\n    bool result = is_palindrome(s);\n\n    // Return the result as a vector of strings\n    return {s, to_string(result)};\n}\n\n"}
{"task_id": "CPP/113", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\n// Function to count the number of odd digits in a string\nint countOddDigits(const string& str) {\n    int count = 0;\n    for (char c : str) {\n        if ((c - '0') % 2 != 0) {\n            ++count;\n        }\n    }\n    return count;\n}\n\n// Function to generate the modified strings\nvector<string> odd_count(vector<string> lst) {\n    vector<string> result;\n    for (const string& s : lst) {\n        int numOddDigits = countOddDigits(s);\n        string modifiedStr = \"the number of odd elements \" + to_string(numOddDigits) +\n                             \"n the str\" + to_string(numOddDigits) + \"ng \" +\n                             to_string(numOddDigits) + \" of the \" +\n                             to_string(numOddDigits) + \"nput.\";\n        result.push_back(modifiedStr);\n    }\n    return result;\n}\n\n// Function to print the vector of strings\nvoid printResult(const vector<string>& result) {\n    for (const string& str : result) {\n        cout << str << endl;\n    }\n}\n\n"}
{"task_id": "CPP/114", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nlong long minSubArraySum(vector<long long> nums) {\n    if (nums.empty()) return 0; // Handle empty vector case\n\n    long long current_min = nums[0];\n    long long global_min = nums[0];\n\n    for (size_t i = 1; i < nums.size(); ++i) {\n        // Update the current minimum sub-array sum ending at index i\n        current_min = min(nums[i], current_min + nums[i]);\n        \n        // Update the global minimum sub-array sum found so far\n        if (current_min < global_min) {\n            global_min = current_min;\n        }\n    }\n\n    return global_min;\n}\n\n"}
{"task_id": "CPP/115", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint max_fill(vector<vector<int>> grid, int capacity) {\n    int total_lowerings = 0;\n    \n    // Iterate over each row (well)\n    for (const auto& row : grid) {\n        int water_units = 0;\n        \n        // Count the number of 1s in the current row\n        for (int unit : row) {\n            if (unit == 1) {\n                ++water_units;\n            }\n        }\n        \n        // Calculate how many times the bucket needs to be lowered for this well\n        int lowerings = (water_units + capacity - 1) / capacity; // Ceiling division\n        \n        // Add to total lowerings\n        total_lowerings += lowerings;\n    }\n    \n    return total_lowerings;\n}\n\n"}
{"task_id": "CPP/116", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\n// Function to count the number of ones in the binary representation of an integer\nint count_ones(int n) {\n    int count = 0;\n    while (n > 0) {\n        count += n & 1; // Check if the least significant bit is set\n        n >>= 1;       // Right shift to check the next bit\n    }\n    return count;\n}\n\n// Custom comparator for sorting based on number of ones and then by decimal value\nbool custom_sort(int a, int b) {\n    int ones_a = count_ones(a);\n    int ones_b = count_ones(b);\n\n    if (ones_a == ones_b) {\n        return a < b; // Sort by decimal value if the number of ones is the same\n    }\n    return ones_a < ones_b; // Otherwise, sort based on the number of ones\n}\n\n// Function to sort the array according to the given rules\nstd::vector<int> sort_array(std::vector<int> arr) {\n    std::sort(arr.begin(), arr.end(), custom_sort);\n    return arr;\n}\n\n"}
{"task_id": "CPP/117", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\n// Helper function to count consonants in a word\nint count_consonants(const string& word) {\n    int count = 0;\n    for (char ch : word) {\n        if (isalpha(ch) && !(ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' ||\n                             ch == 'A' || ch == 'E' || ch == 'I' || ch == 'O' || ch == 'U')) {\n            count++;\n        }\n    }\n    return count;\n}\n\n// Main function to select words with exactly n consonants\nvector<string> select_words(string s, int n) {\n    vector<string> result;\n    string word = \"\";\n    \n    // Split the input string into words\n    for (char ch : s) {\n        if (ch == ' ') {\n            if (!word.empty()) {\n                if (count_consonants(word) == n) {\n                    result.push_back(word);\n                }\n                word.clear();\n            }\n        } else {\n            word += ch;\n        }\n    }\n    \n    // Check the last word\n    if (!word.empty()) {\n        if (count_consonants(word) == n) {\n            result.push_back(word);\n        }\n    }\n    \n    return result;\n}\n\n// Function to test the select_words function with provided examples\nvoid test_select_words() {\n    assert(select_words(\"Mary had a little lamb\", 4) == vector<string>({\"little\"}));\n    assert(select_words(\"Mary had a little lamb\", 3) == vector<string>({\"Mary\", \"lamb\"}));\n    assert(select_words(\"simple white space\", 2) == vector<string>());\n    assert(select_words(\"Hello world\", 4) == vector<string>({\"world\"}));\n    assert(select_words(\"Uncle sam\", 3) == vector<string>({\"Uncle\"}));\n\n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/118", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool isVowel(char c) {\n    return (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' ||\n            c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U');\n}\n\nbool isConsonant(char c) {\n    return !isVowel(c) && isalpha(c);\n}\n\nstring get_closest_vowel(string word) {\n    int n = word.length();\n    \n    // Start from the second last character and move left\n    for (int i = n - 2; i >= 0; --i) {\n        if (isConsonant(word[i + 1]) && isVowel(word[i])) {\n            return string(1, word[i]);\n        }\n    }\n\n    // If no vowel found that meets the condition\n    return \"\";\n}\n\n"}
{"task_id": "CPP/119", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Helper function to check if a string is balanced\nbool is_balanced(const string& s) {\n    int balance = 0;\n    for (char c : s) {\n        if (c == '(') {\n            ++balance;\n        } else if (c == ')') {\n            --balance;\n            if (balance < 0) {\n                return false; // More closing parentheses than opening\n            }\n        }\n    }\n    return balance == 0; // Balanced if no unmatched open parentheses left\n}\n\nstring match_parens(vector<string> lst) {\n    // Check both possible concatenations\n    string concat1 = lst[0] + lst[1];\n    string concat2 = lst[1] + lst[0];\n\n    // Check if either concatenation is balanced\n    if (is_balanced(concat1) || is_balanced(concat2)) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\n\n"}
{"task_id": "CPP/120", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> maximum(vector<int> arr, int k) {\n    // Sort the array in ascending order\n    sort(arr.begin(), arr.end());\n    \n    // Get the last k elements and return them\n    vector<int> result(arr.end() - k, arr.end());\n    return result;\n}\n\n"}
{"task_id": "CPP/121", "generation": "#include <vector>\nusing namespace std;\n\nint solution(const vector<int>& lst) {\n    int sum = 0;\n    \n    // Iterate through the list, checking only even indices (0-based)\n    for (size_t i = 0; i < lst.size(); i += 2) {\n        if (lst[i] % 2 != 0) {  // Check if the element at an even index is odd\n            sum += lst[i];\n        }\n    }\n    \n    return sum;\n}\n\n// Function to test the solution with provided examples\nvoid check_solution() {\n    assert(solution({5, 8, 7, 1}) == 12);\n    assert(solution({3, 3, 3, 3, 3}) == 9);\n    assert(solution({30, 13, 24, 321}) == 0);\n    \n    cout << \"All test cases passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/122", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint add_elements(vector<int> arr, int k) {\n    int sum = 0;\n    for (int i = 0; i < k; ++i) {\n        // Check if the element has at most two digits\n        if (arr[i] >= -99 && arr[i] <= 99) {\n            sum += arr[i];\n        }\n    }\n    return sum;\n}\n\n// Function to test the add_elements function with provided data points\nvoid check() {\n    vector<int> arr1 = {111, 21, 3, 4000, 5, 6, 7, 8, 9};\n    int k1 = 4;\n    cout << \"Test Case 1: Expected Output: 24, Actual Output: \" << add_elements(arr1, k1) << endl;\n\n    vector<int> arr2 = {100, -10, 5678, 9, 123, 45};\n    int k2 = 6;\n    cout << \"Test Case 2: Expected Output: 56, Actual Output: \" << add_elements(arr2, k2) << endl;\n\n    vector<int> arr3 = {0, -1, -98, 99, 101};\n    int k3 = 5;\n    cout << \"Test Case 3: Expected Output: 90, Actual Output: \" << add_elements(arr3, k3) << endl;\n}\n\n"}
{"task_id": "CPP/123", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n// Function to generate and return the odd numbers in the Collatz sequence of n.\nvector<int> get_odd_collatz(int n) {\n    vector<int> result;\n    \n    // Generate the Collatz sequence until we reach 1\n    while (n != 1) {\n        if (n % 2 == 0) {\n            n = n / 2;  // If n is even, divide it by 2\n        } else {\n            result.push_back(n);  // If n is odd, add it to the result vector\n            n = 3 * n + 1;  // Apply the Collatz operation for odd numbers\n        }\n    }\n    \n    // Add the last number (which is 1) to the result vector\n    result.push_back(1);\n    \n    // Sort the result vector in increasing order\n    sort(result.begin(), result.end());\n    \n    return result;\n}\n\n// Function to check the correctness of the get_odd_collatz function\nvoid check() {\n    cout << \"Checking with n = 5: \";\n    vector<int> expected = {1, 5};\n    vector<int> result = get_odd_collatz(5);\n    if (result == expected) {\n        cout << \"Correct!\" << endl;\n    } else {\n        cout << \"Incorrect. Expected: \";\n        for (int num : expected) {\n            cout << num << \" \";\n        }\n        cout << \"\\nGot: \";\n        for (int num : result) {\n            cout << num << \" \";\n        }\n        cout << endl;\n    }\n\n    cout << \"Checking with n = 7: \";\n    vector<int> expected2 = {1, 5, 7};\n    vector<int> result2 = get_odd_collatz(7);\n    if (result2 == expected2) {\n        cout << \"Correct!\" << endl;\n    } else {\n        cout << \"Incorrect. Expected: \";\n        for (int num : expected2) {\n            cout << num << \" \";\n        }\n        cout << \"\\nGot: \";\n        for (int num : result2) {\n            cout << num << \" \";\n        }\n        cout << endl;\n    }\n}\n\n"}
{"task_id": "CPP/124", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\nusing namespace std;\n\nbool valid_date(string date) {\n    // Check if the date string is empty\n    if (date.empty()) return false;\n    \n    // Use stringstream to parse the date into components\n    stringstream ss(date);\n    string month, day, year;\n    char dash1, dash2;\n    \n    // Parse the date in the format mm-dd-yyyy\n    if (!(ss >> month >> dash1 >> day >> dash2 >> year)) return false;\n    \n    // Check if the delimiters are correct\n    if (dash1 != '-' || dash2 != '-') return false;\n    \n    // Convert strings to integers for easier manipulation\n    int m, d, y;\n    try {\n        m = stoi(month);\n        d = stoi(day);\n        y = stoi(year);\n    } catch (...) {\n        return false;  // If conversion fails, the date is invalid\n    }\n    \n    // Check if month and day are within valid ranges\n    if (m < 1 || m > 12) return false;\n    if (d < 1 || d > 31) return false;\n    \n    // Check for correct number of days in each month\n    bool isLeapYear = (y % 4 == 0 && y % 100 != 0) || (y % 400 == 0);\n    if ((m == 2 && d > 29) || (d > 30 && !(m == 4 || m == 6 || m == 9 || m == 11))) return false;\n    \n    // If all checks pass, the date is valid\n    return true;\n}\n\n"}
{"task_id": "CPP/125", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cctype> // For std::islower\n\nusing namespace std;\n\n// Function to count lowercase letters with odd order in the alphabet\nint countOddOrderLowercaseLetters(const string& str) {\n    int count = 0;\n    for (char c : str) {\n        if (std::islower(c)) {\n            int letterValue = static_cast<int>(c - 'a');\n            if (letterValue % 2 == 1) {\n                ++count;\n            }\n        }\n    }\n    return count;\n}\n\n// Function to split the string based on whitespace and commas\nvector<string> split_words(const string& txt) {\n    vector<string> result;\n\n    // Check for whitespace splitting\n    size_t start = 0, end = 0;\n    while ((end = txt.find(' ', start)) != string::npos) {\n        if (start < end) {\n            result.push_back(txt.substr(start, end - start));\n        }\n        start = end + 1;\n    }\n\n    // Check for comma splitting\n    if (start < txt.size()) {\n        while ((end = txt.find(',', start)) != string::npos) {\n            if (start < end) {\n                result.push_back(txt.substr(start, end - start));\n            }\n            start = end + 1;\n        }\n        if (start < txt.size()) {\n            result.push_back(txt.substr(start));\n        }\n    }\n\n    // If no splitting was done, count lowercase letters with odd order\n    if (result.empty()) {\n        int count = countOddOrderLowercaseLetters(txt);\n        result.push_back(to_string(count));\n    }\n\n    return result;\n}\n\n// Function to test the split_words function\nvoid test_split_words() {\n    vector<string> result;\n\n    // Test case 1: Split on whitespace\n    result = split_words(\"Hello world!\");\n    for (const string& word : result) {\n        cout << word << endl; // Should print \"Hello\" and \"world!\"\n    }\n\n    // Test case 2: Split on comma\n    result = split_words(\"Hello,world!\");\n    for (const string& word : result) {\n        cout << word << endl; // Should print \"Hello\" and \"world!\"\n    }\n\n    // Test case 3: Count lowercase letters with odd order\n    result = split_words(\"abcdef\");\n    for (const string& word : result) {\n        cout << word << endl; // Should print \"3\"\n    }\n}\n\n"}
{"task_id": "CPP/126", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nbool is_sorted(vector<int> lst) {\n    // Check if the list is already sorted or not\n    bool ascending = true;\n    for (int i = 0; i < lst.size() - 1 && ascending; ++i) {\n        if (lst[i] > lst[i + 1]) {\n            ascending = false;\n        }\n    }\n\n    // If it's not sorted, return false immediately\n    if (!ascending) {\n        return false;\n    }\n\n    // Check for any number appearing more than twice\n    int count = 1;\n    for (int i = 0; i < lst.size() - 1; ++i) {\n        if (lst[i] == lst[i + 1]) {\n            count++;\n            if (count > 2) {\n                return false;\n            }\n        } else {\n            count = 1;\n        }\n    }\n\n    // If all checks pass, the list is sorted and no number appears more than twice\n    return true;\n}\n\n// Function to test the is_sorted function with provided examples\nvoid check() {\n    assert(is_sorted({5}) == true);\n    assert(is_sorted({1, 2, 3, 4, 5}) == true);\n    assert(is_sorted({1, 3, 2, 4, 5}) == false);\n    assert(is_sorted({1, 2, 3, 4, 5, 6}) == true);\n    assert(is_sorted({1, 2, 3, 4, 5, 6, 7}) == true);\n    assert(is_sorted({1, 3, 2, 4, 5, 6, 7}) == false);\n    assert(is_sorted({1, 2, 2, 3, 3, 4}) == true);\n    assert(is_sorted({1, 2, 2, 2, 3, 4}) == false);\n\n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/127", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\n// Helper function to check if a number is prime\nbool isPrime(int n) {\n    if (n <= 1) return false;\n    if (n == 2 || n == 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    for (int i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0)\n            return false;\n    }\n    return true;\n}\n\n// Function to determine the intersection of two intervals and check if its length is prime\nstring intersection(vector<int> interval1, vector<int> interval2) {\n    int start = max(interval1[0], interval2[0]);\n    int end = min(interval1[1], interval2[1]);\n\n    // If there's no intersection, return \"NO\"\n    if (start > end)\n        return \"NO\";\n\n    // Calculate the length of the intersection\n    int length = end - start + 1;\n\n    // Check if the length is prime\n    if (isPrime(length))\n        return \"YES\";\n    else\n        return \"NO\";\n}\n\n"}
{"task_id": "CPP/128", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint prod_signs(vector<int> arr) {\n    if (arr.empty()) {\n        return -32768;\n    }\n\n    int sum_of_magnitudes = 0;\n    int product_of_signs = 1;\n\n    for (int num : arr) {\n        // Add the magnitude of the number to the sum\n        sum_of_magnitudes += abs(num);\n\n        // Multiply the product of signs by the sign of the current number\n        if (num > 0) {\n            product_of_signs *= 1;\n        } else if (num < 0) {\n            product_of_signs *= -1;\n        } else { // num == 0\n            product_of_signs = 0; // If any number is zero, the product of signs will be zero\n            break;\n        }\n    }\n\n    return sum_of_magnitudes * product_of_signs;\n}\n\n"}
{"task_id": "CPP/129", "generation": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to get all possible paths of length k from a given cell (i, j)\nvoid getAllPaths(vector<vector<int>>& grid, int i, int j, vector<int>& path, vector<vector<bool>>& visited, queue<pair<vector<int>, pair<int, int>>>& q) {\n    if (path.size() == 0 || path.back() != grid[i][j]) { // Ensure the cell is not already in the current path\n        path.push_back(grid[i][j]);\n        visited[i][j] = true;\n        \n        // Check all possible moves: up, down, left, right\n        if (i > 0 && !visited[i-1][j]) {\n            q.push({path, {i-1, j}});\n        }\n        if (i < grid.size() - 1 && !visited[i+1][j]) {\n            q.push({path, {i+1, j}});\n        }\n        if (j > 0 && !visited[i][j-1]) {\n            q.push({path, {i, j-1}});\n        }\n        if (j < grid[0].size() - 1 && !visited[i][j+1]) {\n            q.push({path, {i, j+1}});\n        }\n        \n        visited[i][j] = false; // Backtrack\n    }\n}\n\n// Function to find the minimum path of length k in the grid\nvector<int> minPath(vector<vector<int>>& grid, int k) {\n    int n = grid.size();\n    vector<int> result;\n    \n    // Initialize queue with all possible starting points and empty paths\n    queue<pair<vector<int>, pair<int, int>>> q;\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            vector<int> path;\n            vector<vector<bool>> visited(n, vector<bool>(n, false));\n            q.push({path, {i, j}});\n        }\n    }\n\n    // Process the queue to find all paths of length k\n    while (!q.empty()) {\n        auto [currentPath, currentCell] = q.front();\n        q.pop();\n\n        if (currentPath.size() == k) {\n            result = currentPath;\n            break; // We found a path of length k, no need to explore further\n        }\n\n        getAllPaths(grid, currentCell.first, currentCell.second, currentPath, visited, q);\n    }\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/130", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Function to compute the Tribonacci sequence up to n terms\nvector<int> tribonacci(int n) {\n    vector<int> result(n + 1, 0); // Initialize a vector of size n+1 with all elements as 0\n\n    if (n >= 1) result[0] = 3; // tri(1) is defined as 3\n    for (int i = 2; i <= n; ++i) {\n        if (i % 2 == 0) {\n            result[i - 1] = 1 + i / 2;\n        } else {\n            result[i - 1] = result[i - 2] + result[i - 3] + result[(i + 1) % (n + 1)];\n        }\n    }\n\n    return result;\n}\n\n// Function to print the vector\nvoid printVector(const vector<int>& vec) {\n    for (int num : vec) {\n        cout << num << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/131", "generation": "#include <iostream>\nusing namespace std;\n\nint digits(int n) {\n    int product = 1;\n    bool hasOddDigit = false;\n\n    while (n > 0) {\n        int digit = n % 10;\n        if (digit % 2 != 0) { // Check if the digit is odd\n            product *= digit;\n            hasOddDigit = true;\n        }\n        n /= 10; // Remove the last digit\n    }\n\n    return hasOddDigit ? product : 0;\n}\n\n"}
{"task_id": "CPP/132", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_nested(string str) {\n    int balance = 0;\n    bool hasNested = false;\n\n    for (char c : str) {\n        if (c == '[') {\n            balance++;\n            // If we have an opening bracket and there's already a nested structure, mark it as true\n            if (balance > 1 && !hasNested) {\n                hasNested = true;\n            }\n        } else if (c == ']') {\n            balance--;\n            // If the balance is zero and we've seen a nested structure before, return false\n            if (balance == 0 && hasNested) {\n                return false;\n            }\n        }\n\n        // If at any point the balance goes negative, it means there's an unmatched closing bracket\n        if (balance < 0) {\n            return false;\n        }\n    }\n\n    // The string is valid if we have a non-zero balance and found nested structure\n    return balance > 0 && hasNested;\n}\n\n"}
{"task_id": "CPP/133", "generation": "#include <stdio.h>\n#include <math.h>\n#include <vector>\n\nusing namespace std;\n\nint sum_squares(vector<float> lst) {\n    int sum = 0;\n    \n    for (float num : lst) {\n        // Round up to the nearest integer\n        float ceil_num = ceil(num);\n        \n        // Add the square of the rounded number to the sum\n        sum += static_cast<int>(ceil_num * ceil_num);\n    }\n    \n    return sum;\n}\n\n// Function to test the correctness of the sum_squares function\nvoid test() {\n    assert(sum_squares({1, 2, 3}) == 14);\n    assert(sum_squares({1, 4, 9}) == 98);\n    assert(sum_squares({1, 3, 5, 7}) == 84);\n    assert(sum_squares({1.4f, 4.2f, 0.0f}) == 29);\n    assert(sum_squares({-2.4f, 1.0f, 1.0f}) == 6);\n\n    printf(\"All test cases passed!\\n\");\n}\n\n"}
{"task_id": "CPP/134", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool check_if_last_char_is_a_letter(string txt) {\n    // If the string is empty, return false\n    if (txt.empty()) {\n        return false;\n    }\n\n    // Get the last character of the string\n    char lastChar = txt.back();\n\n    // Check if the last character is an alphabetical letter and not part of a word\n    if ((lastChar >= 'a' && lastChar <= 'z') || (lastChar >= 'A' && lastChar <= 'Z')) {\n        // Check if it's at the end or followed by a space\n        if (txt.size() == 1 || txt[txt.size() - 2] == ' ') {\n            return true;\n        }\n    }\n\n    return false;\n}\n\n"}
{"task_id": "CPP/135", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint can_arrange(vector<int> arr) {\n    if (arr.size() <= 1) {\n        return -1; // No elements or single element means no such index exists.\n    }\n\n    for (int i = arr.size() - 2; i >= 0; --i) {\n        if (arr[i] > arr[i + 1]) {\n            return i;\n        }\n    }\n\n    return -1; // Return -1 if no such element is found.\n}\n\n// Function to test the can_arrange function\nvoid test_can_arrange() {\n    assert(can_arrange({1, 2, 4, 3, 5}) == 3);\n    assert(can_arrange({1, 2, 3}) == -1);\n    assert(can_arrange({5, 4, 3, 2, 1}) == 0);\n    assert(can_arrange({1, 3, 2, 4, 5}) == 2);\n    cout << \"All test cases passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/136", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Function to find the largest negative and smallest positive integers in a vector.\nvector<int> largest_smallest_integers(vector<int> lst) {\n    int max_negative = INT_MIN;  // Initialize with the smallest possible integer\n    int min_positive = INT_MAX;  // Initialize with the largest possible integer\n\n    for (int num : lst) {\n        if (num < 0 && num > max_negative) {\n            max_negative = num;\n        } else if (num > 0 && num < min_positive) {\n            min_positive = num;\n        }\n    }\n\n    // If no negative or positive integers were found, set them to 0\n    if (max_negative == INT_MIN) {\n        max_negative = 0;\n    }\n    if (min_positive == INT_MAX) {\n        min_positive = 0;\n    }\n\n    return {max_negative, min_positive};\n}\n\n// Function to test the largest_smallest_integers function with provided examples.\nvoid check() {\n    vector<int> lst1 = {2, 4, 1, 3, 5, 7};\n    vector<int> result1 = largest_smallest_integers(lst1);\n    cout << \"largest_smallest_integers({2, 4, 1, 3, 5, 7}) == {\" << result1[0] << \", \" << result1[1] << \"}\" << endl;\n\n    vector<int> lst2 = {};\n    vector<int> result2 = largest_smallest_integers(lst2);\n    cout << \"largest_smallest_integers({}) == {\" << result2[0] << \", \" << result2[1] << \"}\" << endl;\n\n    vector<int> lst3 = {0};\n    vector<int> result3 = largest_smallest_integers(lst3);\n    cout << \"largest_smallest_integers({0}) == {\" << result3[0] << \", \" << result3[1] << \"}\" << endl;\n}\n\n"}
{"task_id": "CPP/137", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <boost/any.hpp>\n\n// Function to compare two boost::any values and return the larger one.\nboost::any compare_one(boost::any a, boost::any b) {\n    // Convert both values to strings for comparison\n    std::string strA = convert_to_string(a);\n    std::string strB = convert_to_string(b);\n\n    // Compare the string representations of the numbers\n    if (strA > strB) {\n        return a;\n    } else if (strB > strA) {\n        return b;\n    } else {\n        return boost::any(\"None\");\n    }\n}\n\n// Helper function to convert any value to a string.\nstd::string convert_to_string(const boost::any& value) {\n    std::string result;\n\n    // Check the type of the value and convert accordingly\n    if (value.type() == typeid(int)) {\n        result = std::to_string(boost::any_cast<int>(value));\n    } else if (value.type() == typeid(float)) {\n        result = std::to_string(boost::any_cast<float>(value));\n    } else if (value.type() == typeid(std::string)) {\n        result = boost::any_cast<std::string>(value);\n    }\n\n    // Handle the case where the string contains a comma as a decimal separator\n    size_t pos;\n    while ((pos = result.find(',')) != std::string::npos) {\n        result.replace(pos, 1, \".\");\n    }\n\n    return result;\n}\n\n// Function to test the compare_one function with provided data points.\nvoid test() {\n    boost::any a1(1);\n    boost::any b1(2.5f);\n    boost::any a2(1);\n    boost::any b2(\"2,3\");\n    boost::any a3(\"5,1\");\n    boost::any b3(\"6\");\n    boost::any a4(\"1\");\n    boost::any b4(1);\n\n    std::cout << \"compare_one(1, 2.5) \u279e \" << compare_one(a1, b1).cast<std::string>() << std::endl;\n    std::cout << \"compare_one(1, \\\"2,3\\\") \u279e \" << compare_one(a2, b2).cast<std::string>() << std::endl;\n    std::cout << \"compare_one(\\\"5,1\\\", \\\"6\\\") \u279e \" << compare_one(a3, b3).cast<std::string>() << std::endl;\n    std::cout << \"compare_one(\\\"1\\\", 1) \u279e \" << compare_one(a4, b4).cast<std::string>() << std::endl;\n}\n\n"}
{"task_id": "CPP/138", "generation": "#include <iostream>\nusing namespace std;\n\nbool is_equal_to_sum_even(int n) {\n    // Check if n is even and greater than or equal to 8\n    return (n % 2 == 0 && n >= 8);\n}\n\n"}
{"task_id": "CPP/139", "generation": "#include <iostream>\n\n// Function to calculate factorial of a number\nlong long factorial(long long num) {\n    if (num == 0 || num == 1)\n        return 1;\n    else\n        return num * factorial(num - 1);\n}\n\n// Function to calculate Brazilian factorial\nlong long special_factorial(int n) {\n    long long result = 1;\n    for (int i = n; i > 0; --i) {\n        result *= factorial(i);\n    }\n    return result;\n}\n\n"}
{"task_id": "CPP/140", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring fix_spaces(string text) {\n    string result;\n    int space_count = 0;\n\n    for (char c : text) {\n        if (c == ' ') {\n            space_count++;\n            // If we have more than two consecutive spaces, add a hyphen and reset the count\n            if (space_count > 2) {\n                result += '-';\n                space_count = 1; // Reset to start counting again\n            }\n        } else {\n            // Add non-space characters or underscores as needed\n            if (space_count == 1) {\n                result += '_';\n            }\n            space_count = 0; // Reset the count for new word\n            result += c;\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/141", "generation": "#include <iostream>\n#include <string>\n#include <cctype> // for std::isdigit\n\nusing namespace std;\n\nbool is_valid_filename(const string& file_name) {\n    int digit_count = 0;\n    size_t dot_pos = file_name.find('.');\n    \n    // Check if there is exactly one dot in the filename\n    if (dot_pos == string::npos || dot_pos == 0 || dot_pos == file_name.length() - 1) {\n        return false;\n    }\n    \n    // Count digits and check the substring before the dot\n    for (size_t i = 0; i < dot_pos; ++i) {\n        if (std::isdigit(file_name[i])) {\n            digit_count++;\n            if (digit_count > 3) {\n                return false;\n            }\n        } else if (!std::isalpha(file_name[i])) {\n            return false;\n        }\n    }\n\n    // Check the substring after the dot\n    string extension = file_name.substr(dot_pos + 1);\n    if (extension != \"txt\" && extension != \"exe\" && extension != \"dll\") {\n        return false;\n    }\n\n    return true;\n}\n\nstring file_name_check(const string& file_name) {\n    if (is_valid_filename(file_name)) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\n\n"}
{"task_id": "CPP/142", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint sum_squares(vector<int> lst) {\n    int sum = 0;\n    \n    for (size_t i = 0; i < lst.size(); ++i) {\n        if ((i + 1) % 3 == 0 && (i + 1) % 4 != 0) {\n            // Square the element if its index is a multiple of 3 but not a multiple of 4\n            sum += lst[i] * lst[i];\n        } else if ((i + 1) % 4 == 0) {\n            // Cube the element if its index is a multiple of 4\n            sum += lst[i] * lst[i] * lst[i];\n        } else {\n            // Add the element as it is if its index is neither a multiple of 3 nor 4\n            sum += lst[i];\n        }\n    }\n\n    return sum;\n}\n\n// Function to test the implementation with provided examples\nvoid test() {\n    cout << \"Test 1: {1,2,3} -> Expected: 6, Got: \" << sum_squares({1, 2, 3}) << endl;\n    cout << \"Test 2: {} -> Expected: 0, Got: \" << sum_squares({}) << endl;\n    cout << \"Test 3: {-1,-5,2,-1,-5} -> Expected: -126, Got: \" << sum_squares({-1, -5, 2, -1, -5}) << endl;\n}\n\n"}
{"task_id": "CPP/143", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    if (n == 2 || n == 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    for (int i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0)\n            return false;\n    }\n    return true;\n}\n\n// Function to process the sentence and return words with prime length\nstring words_in_sentence(string sentence) {\n    string result = \"\";\n    int word_start = 0;\n\n    // Iterate through each character in the sentence\n    for (int i = 0; i <= sentence.length(); ++i) {\n        if (sentence[i] == ' ' || i == sentence.length()) {\n            int length = i - word_start;\n            if (is_prime(length)) {\n                result += sentence.substr(word_start, length);\n                result += \" \";\n            }\n            word_start = i + 1; // Move to the next word\n        }\n    }\n\n    // Remove trailing space\n    if (!result.empty() && result.back() == ' ') {\n        result.pop_back();\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/144", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\n// Function to parse numerator and denominator from string\npair<int, int> parseFraction(const string& fraction) {\n    size_t slashPos = fraction.find('/');\n    if (slashPos == string::npos) {\n        throw invalid_argument(\"Invalid fraction format\");\n    }\n    int numerator = stoi(fraction.substr(0, slashPos));\n    int denominator = stoi(fraction.substr(slashPos + 1));\n    return {numerator, denominator};\n}\n\n// Function to simplify the expression x * n\nbool simplify(string x, string n) {\n    // Parse both fractions\n    auto [numX, denomX] = parseFraction(x);\n    auto [numN, denomN] = parseFraction(n);\n\n    // Multiply numerators and denominators\n    int productNum = numX * numN;\n    int productDenom = denomX * denomN;\n\n    // Check if the result is a whole number\n    return (productNum % productDenom == 0);\n}\n\n"}
{"task_id": "CPP/145", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\n// Helper function to calculate the sum of digits of an integer.\nint digitSum(int n) {\n    int sum = 0;\n    bool isNegative = n < 0;\n    while (n != 0) {\n        int digit = abs(n % 10);\n        sum += digit;\n        n /= 10;\n    }\n    if (isNegative && sum > 0) {\n        // If the number was negative, subtract the last digit to account for the sign.\n        sum -= digit; // Subtract the first digit which is negative\n    }\n    return sum;\n}\n\n// Custom comparator function to sort based on digit sum and original index.\nbool compareByDigitSumAndIndex(const std::pair<int, int>& a, const std::pair<int, int>& b) {\n    int sumA = digitSum(a.first);\n    int sumB = digitSum(b.first);\n\n    if (sumA == sumB) {\n        // If sums are equal, sort by original index\n        return a.second < b.second;\n    }\n    return sumA < sumB;\n}\n\n// Function to order the vector based on the sum of digits and original indices.\nstd::vector<int> order_by_points(std::vector<int> nums) {\n    std::vector<std::pair<int, int>> indexedNums;\n\n    // Create a vector of pairs (number, index)\n    for (size_t i = 0; i < nums.size(); ++i) {\n        indexedNums.push_back({nums[i], static_cast<int>(i)});\n    }\n\n    // Sort the vector based on digit sum and original index\n    std::sort(indexedNums.begin(), indexedNums.end(), compareByDigitSumAndIndex);\n\n    // Extract the sorted numbers from the pairs\n    std::vector<int> result;\n    for (const auto& p : indexedNums) {\n        result.push_back(p.first);\n    }\n\n    return result;\n}\n\n// Function to check the correctness of the order_by_points function.\nvoid check() {\n    assert(order_by_points({1, 11, -1, -11, -12}) == std::vector<int>{-1, -11, 1, -12, 11});\n    assert(order_by_points({}) == std::vector<int>{});\n    std::cout << \"All tests passed!\" << std::endl;\n}\n\n"}
{"task_id": "CPP/146", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Function to extract the first digit of a number\nint firstDigit(int n) {\n    while (n >= 10) {\n        n /= 10;\n    }\n    return n;\n}\n\n// Function to extract the last digit of a number\nint lastDigit(int n) {\n    return abs(n) % 10; // Use absolute value in case of negative numbers\n}\n\n// Main function that counts elements meeting the criteria\nint specialFilter(vector<int> nums) {\n    int count = 0;\n    for (int num : nums) {\n        if (num > 10 && firstDigit(num) % 2 != 0 && lastDigit(num) % 2 != 0) {\n            count++;\n        }\n    }\n    return count;\n}\n\n// Function to test the specialFilter function\nvoid test() {\n    vector<int> test1 = {15, -73, 14, -15};\n    vector<int> test2 = {33, -2, -3, 45, 21, 109};\n\n    cout << \"Test 1: \" << specialFilter(test1) << endl; // Expected output: 1\n    cout << \"Test 2: \" << specialFilter(test2) << endl; // Expected output: 2\n}\n\n"}
{"task_id": "CPP/147", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint get_max_triples(int n) {\n    // Step 1: Generate vector a\n    vector<int> a(n);\n    for (int i = 1; i <= n; ++i) {\n        a[i - 1] = i * i - i + 1;\n    }\n\n    int count = 0;\n\n    // Step 2 and 3: Iterate through all possible triples\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            for (int k = j + 1; k < n; ++k) {\n                // Step 3: Check if the sum is a multiple of 3\n                if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                    count++;\n                }\n            }\n        }\n    }\n\n    return count;\n}\n\n"}
{"task_id": "CPP/148", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to return all planets between planet1 and planet2 in order from closest to farthest from the sun.\nvector<string> bf(string planet1, string planet2) {\n    // List of planets sorted by their proximity to the Sun\n    vector<string> planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n    \n    // Find the indices of planet1 and planet2 in the list\n    auto it1 = find(planets.begin(), planets.end(), planet1);\n    auto it2 = find(planets.begin(), planets.end(), planet2);\n\n    // Check if both planets are valid\n    if (it1 == planets.end() || it2 == planets.end()) {\n        return {};  // Return an empty vector if either planet is not found\n    }\n\n    // Ensure the first index comes before the second index\n    if (it1 > it2) {\n        swap(it1, it2);\n    }\n\n    // Extract and return the sublist of planets between the two indices\n    vector<string> result(it1 + 1, it2);\n    return result;\n}\n\n// Function to test the bf function with some examples\nvoid test() {\n    vector<string> result;\n\n    result = bf(\"Jupiter\", \"Neptune\");\n    for (const auto& planet : result) {\n        cout << planet << \" \";\n    }\n    cout << endl;  // Expected output: Saturn Uranus\n\n    result = bf(\"Earth\", \"Mercury\");\n    for (const auto& planet : result) {\n        cout << planet << \" \";\n    }\n    cout << endl;  // Expected output: Venus\n\n    result = bf(\"Mercury\", \"Uranus\");\n    for (const auto& planet : result) {\n        cout << planet << \" \";\n    }\n    cout << endl;  // Expected output: Venus Earth Mars Jupiter Saturn\n}\n\n"}
{"task_id": "CPP/149", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to check if a string has an odd length\nbool has_odd_length(const string& str) {\n    return str.length() % 2 != 0;\n}\n\n// Comparator function for sorting the strings\nbool custom_sort(const string& a, const string& b) {\n    // First compare by length\n    if (a.length() == b.length()) {\n        // If lengths are equal, sort alphabetically\n        return a < b;\n    }\n    return a.length() < b.length();\n}\n\nvector<string> sorted_list_sum(vector<string> lst) {\n    // Remove strings with odd lengths\n    lst.erase(remove_if(lst.begin(), lst.end(), has_odd_length), lst.end());\n    \n    // Sort the list using custom comparator\n    sort(lst.begin(), lst.end(), custom_sort);\n    \n    return lst;\n}\n\n// Function to test the sorted_list_sum function\nvoid test() {\n    assert(sorted_list_sum({\"aa\", \"a\", \"aaa\"}) == vector<string>({\"aa\"}));\n    assert(sorted_list_sum({\"ab\", \"a\", \"aaa\", \"cd\"}) == vector<string>({\"ab\", \"cd\"}));\n    cout << \"All tests passed successfully.\" << endl;\n}\n\n"}
{"task_id": "CPP/150", "generation": "#include <stdio.h>\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int num) {\n    if (num <= 1) return false; // Numbers less than or equal to 1 are not prime\n    for (int i = 2; i * i <= num; ++i) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\n// Function that returns x if n is a prime number, otherwise returns y\nint x_or_y(int n, int x, int y) {\n    return is_prime(n) ? x : y;\n}\n\n"}
{"task_id": "CPP/151", "generation": "#include <vector>\nusing namespace std;\n\nlong long double_the_difference(vector<float> lst) {\n    long long sum = 0;\n    \n    for (float num : lst) {\n        // Check if the number is positive, an integer, and odd\n        if (num > 0 && floor(num) == num && static_cast<int>(num) % 2 != 0) {\n            sum += pow(num, 2);\n        }\n    }\n    \n    return sum;\n}\n\n// Example usage:\n"}
{"task_id": "CPP/152", "generation": "#include <stdio.h>\n#include <math.h>\n#include <vector>\nusing namespace std;\n\nvector<int> compare(vector<int> game, vector<int> guess) {\n    vector<int> result;\n    \n    // Ensure both vectors have the same length\n    if (game.size() != guess.size()) {\n        printf(\"Error: The input vectors must be of the same length.\\n\");\n        return result;  // Return an empty vector in case of error\n    }\n    \n    // Compare each element and calculate the absolute difference\n    for (size_t i = 0; i < game.size(); ++i) {\n        int diff = abs(game[i] - guess[i]);\n        result.push_back(diff);\n    }\n    \n    return result;\n}\n\n// Function to test the compare function with provided examples\nvoid test() {\n    vector<int> scores1 = {1, 2, 3, 4, 5, 1};\n    vector<int> guesses1 = {1, 2, 3, 4, 2, -2};\n    vector<int> expected1 = {0, 0, 0, 0, 3, 3};\n    \n    vector<int> scores2 = {0, 5, 0, 0, 0, 4};\n    vector<int> guesses2 = {4, 1, 1, 0, 0, -2};\n    vector<int> expected2 = {4, 4, 1, 0, 0, 6};\n    \n    vector<int> result1 = compare(scores1, guesses1);\n    vector<int> result2 = compare(scores2, guesses2);\n    \n    printf(\"Test 1: \");\n    for (int i : result1) {\n        printf(\"%d \", i);\n    }\n    printf(\"\\nExpected: \");\n    for (int i : expected1) {\n        printf(\"%d \", i);\n    }\n    printf(\"\\n\");\n    \n    printf(\"Test 2: \");\n    for (int i : result2) {\n        printf(\"%d \", i);\n    }\n    printf(\"\\nExpected: \");\n    for (int i : expected2) {\n        printf(\"%d \", i);\n    }\n    printf(\"\\n\");\n}\n\n"}
{"task_id": "CPP/153", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to calculate the strength of an extension\nint calculateStrength(const string& extension) {\n    int cap = 0, sm = 0;\n    for (char c : extension) {\n        if (isupper(c)) cap++;\n        else if (islower(c)) sm++;\n    }\n    return cap - sm;\n}\n\n// Function to find the strongest extension\nstring Strongest_Extension(string class_name, vector<string> extensions) {\n    int max_strength = INT_MIN;\n    string strongest_extension;\n\n    for (const auto& ext : extensions) {\n        int strength = calculateStrength(ext);\n        if (strength > max_strength) {\n            max_strength = strength;\n            strongest_extension = ext;\n        }\n    }\n\n    return class_name + \".\" + strongest_extension;\n}\n\n// Function to test the solution\nvoid test() {\n    assert(Strongest_Extension(\"my_class\", {\"AA\", \"Be\", \"CC\"}) == \"my_class.AA\");\n    assert(Strongest_Extension(\"Slices\", {\"SErviNGSliCes\", \"Cheese\", \"StuFfed\"}) == \"Slices.SErviNGSliCes\");\n    cout << \"All tests passed successfully.\" << endl;\n}\n\n"}
{"task_id": "CPP/154", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\n// Function to generate all rotations of a string\nvoid generate_rotations(string &b, vector<string> &rotations) {\n    int n = b.length();\n    for (int i = 0; i < n; ++i) {\n        // Rotate the string by one character\n        string temp = b.substr(i) + b.substr(0, i);\n        rotations.push_back(temp);\n    }\n}\n\n// Function to check if any rotation of b is a substring of a\nbool cycpattern_check(string a, string b) {\n    int n = a.length();\n    int m = b.length();\n\n    // Generate all rotations of b\n    vector<string> rotations;\n    generate_rotations(b, rotations);\n\n    // Check each rotation to see if it is a substring of a\n    for (const auto &rotation : rotations) {\n        if (a.find(rotation) != string::npos) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\n"}
{"task_id": "CPP/155", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// Function to count even and odd digits in an integer\nvector<int> even_odd_count(int num) {\n    // Convert the number to a string to easily iterate over each digit\n    string str_num = to_string(abs(num));\n    \n    int even_count = 0;\n    int odd_count = 0;\n    \n    for (char digit : str_num) {\n        if ((digit - '0') % 2 == 0) {\n            even_count++;\n        } else {\n            odd_count++;\n        }\n    }\n    \n    return {even_count, odd_count};\n}\n\n// Function to test the even_odd_count function\nvoid test_even_odd_count() {\n    assert(even_odd_count(-12) == vector<int>({1, 1}));\n    assert(even_odd_count(123) == vector<int>({1, 2}));\n    assert(even_odd_count(0) == vector<int>({1, 0})); // Edge case: single digit '0'\n    assert(even_odd_count(-9876543210) == vector<int>({5, 5}));\n    \n    cout << \"All test cases passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/156", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to convert integer to lowercase Roman numeral\nstring int_to_mini_roman(int number) {\n    // Mapping of integers to their Roman numeral equivalents in lowercase\n    vector<pair<int, string>> roman_map = {\n        {1000, \"m\"}, {900, \"cm\"}, {500, \"d\"}, {400, \"cd\"},\n        {100, \"c\"}, {90, \"xc\"}, {50, \"l\"}, {40, \"xl\"},\n        {10, \"x\"}, {9, \"ix\"}, {5, \"v\"}, {4, \"iv\"}, {1, \"i\"}\n    };\n\n    string result = \"\";\n\n    // Iterate through the map and subtract values from number\n    for (const auto& roman : roman_map) {\n        while (number >= roman.first) {\n            result += roman.second;\n            number -= roman.first;\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/157", "generation": "#include <stdio.h>\n#include <math.h>\n\nusing namespace std;\n\nbool right_angle_triangle(float a, float b, float c) {\n    // Sort the sides to ensure the longest side is considered as the hypotenuse\n    if (a > b && a > c) {\n        return (a * a == b * b + c * c);\n    } else if (b > a && b > c) {\n        return (b * b == a * a + c * c);\n    } else {\n        return (c * c == a * a + b * b);\n    }\n}\n\n"}
{"task_id": "CPP/158", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to count unique characters in a string\nint count_unique_chars(const string& word) {\n    bool seen[256] = {false}; // Assuming ASCII characters\n    int unique_count = 0;\n    for (char c : word) {\n        if (!seen[c]) {\n            seen[c] = true;\n            unique_count++;\n        }\n    }\n    return unique_count;\n}\n\n// Comparator function to sort based on the number of unique characters and lexicographical order\nbool compare(const string& a, const string& b) {\n    int count_a = count_unique_chars(a);\n    int count_b = count_unique_chars(b);\n\n    if (count_a == count_b) {\n        return a < b; // Lexicographically smaller comes first\n    }\n    return count_a > count_b;\n}\n\nstring find_max(vector<string> words) {\n    sort(words.begin(), words.end(), compare);\n    return words.front();\n}\n\n"}
{"task_id": "CPP/159", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nvector<int> eat(int number, int need, int remaining) {\n    // Calculate the actual number of carrots to be eaten\n    int to_eat = min(need, remaining);\n    \n    // Update the total number of eaten carrots\n    int total_eaten = number + to_eat;\n    \n    // Update the remaining carrots\n    int left_remaining = remaining - to_eat;\n\n    return {total_eaten, left_remaining};\n}\n\n// Function to test the eat function with provided examples\nvoid check() {\n    vector<int> result1 = eat(5, 6, 10);\n    printf(\"eat(5, 6, 10) -> {%d, %d}\\n\", result1[0], result1[1]); // Expected: {11, 4}\n\n    vector<int> result2 = eat(4, 8, 9);\n    printf(\"eat(4, 8, 9) -> {%d, %d}\\n\", result2[0], result2[1]); // Expected: {12, 1}\n\n    vector<int> result3 = eat(1, 10, 10);\n    printf(\"eat(1, 10, 10) -> {%d, %d}\\n\", result3[0], result3[1]); // Expected: {11, 0}\n\n    vector<int> result4 = eat(2, 11, 5);\n    printf(\"eat(2, 11, 5) -> {%d, %d}\\n\", result4[0], result4[1]); // Expected: {7, 0}\n}\n\n"}
{"task_id": "CPP/160", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nint do_algebra(vector<string> operatorVec, vector<int> operandVec) {\n    // Initialize the result with the first operand\n    int result = operandVec[0];\n\n    // Iterate through each operator and apply it to the current result and next operand\n    for (size_t i = 0; i < operatorVec.size(); ++i) {\n        if (operatorVec[i] == \"+\") {\n            result += operandVec[i + 1];\n        } else if (operatorVec[i] == \"-\") {\n            result -= operandVec[i + 1];\n        } else if (operatorVec[i] == \"*\") {\n            result *= operandVec[i + 1];\n        } else if (operatorVec[i] == \"//\") {\n            result /= operandVec[i + 1]; // Floor division\n        } else if (operatorVec[i] == \"**\") {\n            result = pow(result, operandVec[i + 1]); // Exponentiation\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/161", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\n// Function to solve the problem as described\nstring solve(string s) {\n    bool hasLetters = false;\n    \n    // Check if the string contains any letters and reverse their case\n    for (char &c : s) {\n        if (isalpha(c)) {  // Check if c is a letter\n            hasLetters = true;\n            if (islower(c)) {\n                c = toupper(c);\n            } else {\n                c = tolower(c);\n            }\n        }\n    }\n\n    // If the string contains no letters, reverse the entire string\n    if (!hasLetters) {\n        reverse(s.begin(), s.end());\n    }\n\n    return s;\n}\n\n// Function to test the solve function with some examples\nvoid test() {\n    cout << \"solve(\\\"1234\\\") = \\\"\" << solve(\"1234\") << \"\\\" (Expected: \\\"4321\\\")\" << endl;\n    cout << \"solve(\\\"ab\\\") = \\\"\" << solve(\"ab\") << \"\\\" (Expected: \\\"AB\\\")\" << endl;\n    cout << \"solve(\\\"#a@C\\\") = \\\"\" << solve(\"#a@C\") << \"\\\" (Expected: \\\"#A@c\\\")\" << endl;\n}\n\n"}
{"task_id": "CPP/162", "generation": "#include <iostream>\n#include <string>\n#include <openssl/md5.h>\n\n// Function to convert string to MD5 hash\nstd::string string_to_md5(const std::string& text) {\n    unsigned char digest[MD5_DIGEST_LENGTH];\n    MD5((unsigned char*)text.c_str(), text.length(), (unsigned char*)&digest);    \n\n    // Create destination string\n    char mdString[33];\n    for(int i = 0; i < 16; ++i)\n        sprintf(&mdString[i*2], \"%02x\", (unsigned int)digest[i]);\n\n    return std::string(mdString);\n}\n\n"}
{"task_id": "CPP/163", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\n// Function to generate even digits between two integers a and b\nvector<int> generate_integers(int a, int b) {\n    vector<int> result;\n    \n    // Ensure a is less than or equal to b for simplicity\n    if (a > b) swap(a, b);\n    \n    // Iterate through the range [a, b]\n    for (int i = a; i <= b; ++i) {\n        int num = i;\n        \n        // Extract digits and check if they are even\n        while (num > 0) {\n            int digit = num % 10;\n            if (digit % 2 == 0 && digit != 0) { // Exclude 0 as it's not in the range [2, 8]\n                result.push_back(digit);\n            }\n            num /= 10; // Move to the next digit\n        }\n    }\n    \n    return result;\n}\n\n// Function to print the vector for testing purposes\nvoid print_vector(const vector<int>& vec) {\n    printf(\"{\");\n    for (size_t i = 0; i < vec.size(); ++i) {\n        printf(\"%d\", vec[i]);\n        if (i != vec.size() - 1) printf(\", \");\n    }\n    printf(\"}\\n\");\n}\n\n"}
{"task_id": "CPP/0", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm> // For std::sort\n#include <cmath>     // For std::abs\n\nusing namespace std;\n\nbool has_close_elements(vector<float> numbers, float threshold) {\n    if (numbers.size() <= 1) return false; // If the vector is empty or contains only one element, no two elements can be close.\n\n    // Sort the vector\n    sort(numbers.begin(), numbers.end());\n\n    // Check the difference between consecutive elements\n    for (size_t i = 0; i < numbers.size() - 1; ++i) {\n        if (std::abs(numbers[i] - numbers[i + 1]) < threshold) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\n// Example usage:\n"}
{"task_id": "CPP/1", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> separate_paren_groups(string paren_string) {\n    vector<string> groups;\n    string current_group;\n    int balance = 0;\n\n    for (char ch : paren_string) {\n        if (ch == '(') {\n            balance++;\n            current_group += ch;\n        } else if (ch == ')') {\n            balance--;\n            current_group += ch;\n            if (balance == 0) {\n                groups.push_back(current_group);\n                current_group.clear();\n            }\n        }\n    }\n\n    return groups;\n}\n\n"}
{"task_id": "CPP/2", "generation": "#include <stdio.h>\n#include <cmath>\n\nfloat truncate_number(float number) {\n    // Get the integer part using floor function\n    float integerPart = floor(number);\n    \n    // Subtract the integer part from the original number to get the decimal part\n    float decimalPart = number - integerPart;\n    \n    return decimalPart;\n}\n\n"}
{"task_id": "CPP/3", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool below_zero(vector<int> operations) {\n    int balance = 0; // Start with a zero balance\n\n    for (int op : operations) {\n        balance += op; // Update the balance by adding each operation\n        \n        if (balance < 0) { // Check if the balance falls below zero\n            return true;\n        }\n    }\n\n    return false; // Return false if the balance never goes below zero\n}\n\n// Function to test the below_zero function with provided data points\nvoid check() {\n    assert(!below_zero({1, 2, 3}));\n    assert(below_zero({1, 2, -4, 5}));\n    cout << \"All tests passed successfully.\" << endl;\n}\n\n"}
{"task_id": "CPP/4", "generation": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nfloat mean_absolute_deviation(vector<float> numbers) {\n    // Calculate the mean of the dataset\n    float sum = 0.0;\n    for (auto num : numbers) {\n        sum += num;\n    }\n    float mean = sum / numbers.size();\n\n    // Calculate the Mean Absolute Deviation\n    float mad = 0.0;\n    for (auto num : numbers) {\n        mad += abs(num - mean);\n    }\n    mad /= numbers.size();\n\n    return mad;\n}\n\n"}
{"task_id": "CPP/5", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> intersperse(vector<int> numbers, int delimeter) {\n    // Check if the input vector is empty or has only one element\n    if (numbers.size() <= 1) {\n        return numbers;\n    }\n\n    // Create a new vector to store the result\n    vector<int> result;\n\n    // Iterate through the input vector and insert elements into the result vector\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        result.push_back(numbers[i]);\n        if (i != numbers.size() - 1) {  // Do not add delimiter after the last element\n            result.push_back(delimeter);\n        }\n    }\n\n    return result;\n}\n\n// Function to test the intersperse function\nvoid testIntersperse() {\n    vector<int> emptyVec = {};\n    vector<int> singleElementVec = {1};\n    vector<int> multiElementVec = {1, 2, 3};\n\n    cout << \"Empty Vector: \";\n    for (int num : intersperse(emptyVec, 4)) {\n        cout << num << \" \";\n    }\n    cout << endl;\n\n    cout << \"Single Element Vector: \";\n    for (int num : intersperse(singleElementVec, 4)) {\n        cout << num << \" \";\n    }\n    cout << endl;\n\n    cout << \"Multi Element Vector: \";\n    for (int num : intersperse(multiElementVec, 4)) {\n        cout << num << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/6", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<int> parse_nested_parens(string paren_string) {\n    vector<int> depths;\n    size_t start = 0, end = 0;\n    \n    // Split the input string by spaces to get individual groups\n    while ((end = paren_string.find(' ', start)) != string::npos) {\n        string group = paren_string.substr(start, end - start);\n        int max_depth = 0, current_depth = 0;\n\n        // Iterate through each character in the group\n        for (char c : group) {\n            if (c == '(') {\n                current_depth++;\n                max_depth = max(max_depth, current_depth);\n            } else if (c == ')') {\n                current_depth--;\n            }\n        }\n\n        // Store the maximum depth of this group\n        depths.push_back(max_depth);\n\n        // Move to the next group\n        start = end + 1;\n    }\n\n    // Handle the last group in case there is no trailing space\n    if (start < paren_string.length()) {\n        string last_group = paren_string.substr(start);\n        int max_depth = 0, current_depth = 0;\n\n        for (char c : last_group) {\n            if (c == '(') {\n                current_depth++;\n                max_depth = max(max_depth, current_depth);\n            } else if (c == ')') {\n                current_depth--;\n            }\n        }\n\n        depths.push_back(max_depth);\n    }\n\n    return depths;\n}\n\n"}
{"task_id": "CPP/7", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to filter strings containing a given substring\nvector<string> filter_by_substring(vector<string> strings, string substring) {\n    vector<string> filtered_strings;\n    \n    // Iterate through each string in the input vector\n    for (const auto& str : strings) {\n        // Check if the current string contains the given substring\n        if (str.find(substring) != string::npos) {\n            // If it does, add it to the filtered list\n            filtered_strings.push_back(str);\n        }\n    }\n    \n    return filtered_strings;\n}\n\n// Function to test the filter_by_substring function\nvoid test_filter_by_substring() {\n    vector<string> input1 = {};\n    vector<string> expected_output1 = {};\n    assert(filter_by_substring(input1, \"a\") == expected_output1);\n\n    vector<string> input2 = {\"abc\", \"bacd\", \"cde\", \"vector\"};\n    vector<string> expected_output2 = {\"abc\", \"bacd\", \"vector\"};\n    assert(filter_by_substring(input2, \"a\") == expected_output2);\n\n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/8", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> sum_product(vector<int> numbers) {\n    int sum = 0;\n    int product = 1;\n\n    // Iterate through each number in the vector\n    for (int num : numbers) {\n        sum += num;  // Add the current number to the sum\n        if (num != 0) {  // Avoid division by zero when calculating product\n            product *= num;\n        }\n    }\n\n    return {sum, product};\n}\n\n// Function to test the sum_product function with provided data points\nvoid test_sum_product() {\n    vector<int> empty = {};\n    vector<int> nums1 = {1, 2, 3, 4};\n\n    // Test case for an empty vector\n    auto result1 = sum_product(empty);\n    cout << \"Empty vector: Sum = \" << result1[0] << \", Product = \" << result1[1] << endl;\n\n    // Test case for a non-empty vector\n    auto result2 = sum_product(nums1);\n    cout << \"Vector {1, 2, 3, 4}: Sum = \" << result2[0] << \", Product = \" << result2[1] << endl;\n}\n\n"}
{"task_id": "CPP/9", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> rolling_max(vector<int> numbers) {\n    if (numbers.empty()) return {}; // Return an empty vector if the input is empty\n\n    vector<int> result;\n    int current_max = numbers[0]; // Initialize with the first element\n\n    for (int num : numbers) {\n        if (num > current_max) {\n            current_max = num; // Update current_max if a larger number is found\n        }\n        result.push_back(current_max); // Add the current max to the result vector\n    }\n\n    return result;\n}\n\n// Function to print the vector for testing purposes\nvoid print_vector(const vector<int>& vec) {\n    for (int val : vec) {\n        cout << val << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/10", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_palindrome(const string& str) {\n    // Test if given string is a palindrome\n    return str == string(str.rbegin(), str.rend());\n}\n\nstring make_palindrome(string str) {\n    /*\n    Find the shortest palindrome that begins with a supplied string. \n    Algorithm idea is simple: - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    */\n    \n    // Start from the full length and go down to 0\n    for (int i = str.length(); i > 0; --i) {\n        if (is_palindrome(str.substr(0, i))) {\n            // Found the longest palindromic prefix\n            string prefix = str.substr(i);\n            reverse(prefix.begin(), prefix.end());\n            return str + prefix;\n        }\n    }\n\n    // If no palindrome is found, it means the whole string is a palindrome itself.\n    return str;\n}\n\n"}
{"task_id": "CPP/11", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\n// Function to perform binary XOR on two strings\nstring string_xor(string a, string b) {\n    // Ensure both strings are of equal length\n    if (a.length() != b.length()) {\n        throw runtime_error(\"Input strings must be of the same length\");\n    }\n\n    // Initialize an empty result string\n    string result = \"\";\n\n    // Perform XOR on each bit and append to the result string\n    for (size_t i = 0; i < a.length(); ++i) {\n        if (a[i] == b[i]) {\n            result += '0';\n        } else {\n            result += '1';\n        }\n    }\n\n    return result;\n}\n\n// Function to test the string_xor function\nvoid test_string_xor() {\n    assert(string_xor(\"010\", \"110\") == \"100\");\n    assert(string_xor(\"111\", \"000\") == \"111\");\n    assert(string_xor(\"001\", \"001\") == \"000\");\n    cout << \"All tests passed successfully.\" << endl;\n}\n\n"}
{"task_id": "CPP/12", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring longest(vector<string> strings) {\n    if (strings.empty()) {\n        return \"\"; // Return an empty string to indicate None in case of an empty vector.\n    }\n\n    string longestString = strings[0]; // Assume the first string is the longest initially.\n\n    for (const auto& str : strings) {\n        if (str.length() > longestString.length()) {\n            longestString = str; // Update the longest string if a longer one is found.\n        }\n    }\n\n    return longestString;\n}\n\n"}
{"task_id": "CPP/13", "generation": "#include <stdio.h>\nusing namespace std;\n\nint greatest_common_divisor(int a, int b) {\n    // Ensure a >= b for simplicity\n    if (b > a) {\n        return greatest_common_divisor(b, a);\n    }\n\n    // Base case: if b is 0, then GCD is a\n    if (b == 0) {\n        return a;\n    }\n\n    // Recursive call using the Euclidean algorithm\n    return greatest_common_divisor(b, a % b);\n}\n\n"}
{"task_id": "CPP/14", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> all_prefixes(const string& str) {\n    vector<string> prefixes;\n    for (size_t i = 1; i <= str.length(); ++i) {\n        prefixes.push_back(str.substr(0, i));\n    }\n    return prefixes;\n}\n\n"}
{"task_id": "CPP/15", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring string_sequence(int n) {\n    if (n < 0) return \"\"; // Handle negative input gracefully\n\n    string result = \"\";\n    for (int i = 0; i <= n; ++i) {\n        result += to_string(i);\n        if (i != n) {\n            result += \" \";\n        }\n    }\n    return result;\n}\n\n// Function to test the string_sequence function\nvoid test_function() {\n    cout << \"Testing with input 5: \" << string_sequence(5) << endl; // Expected output: \"0 1 2 3 4 5\"\n    cout << \"Testing with input 0: \" << string_sequence(0) << endl; // Expected output: \"0\"\n}\n\n"}
{"task_id": "CPP/16", "generation": "#include <iostream>\n#include <string>\n#include <set>\n\nusing namespace std;\n\nint count_distinct_characters(string str) {\n    // Convert the string to lowercase to ensure case insensitivity\n    transform(str.begin(), str.end(), str.begin(), ::tolower);\n    \n    // Use a set to store distinct characters\n    set<char> distinct_chars(str.begin(), str.end());\n    \n    // The size of the set is the number of distinct characters\n    return distinct_chars.size();\n}\n\n"}
{"task_id": "CPP/17", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<int> parse_music(string music_string) {\n    vector<int> beats;\n    \n    // Iterate over the string, processing two characters at a time\n    for (size_t i = 0; i < music_string.length(); ) {\n        if (i + 1 < music_string.length() && music_string[i] == 'o' && music_string[i + 1] == '|') {\n            // \"o|\" is a half note, lasts two beats\n            beats.push_back(2);\n            i += 2;\n        } else if (music_string[i] == '.') {\n            // \".\" is part of a quarter note, lasts one beat\n            if (i + 1 < music_string.length() && music_string[i + 1] == '|') {\n                beats.push_back(1);\n                i += 2;\n            } else {\n                cout << \"Invalid input: missing '|' after '.'\" << endl;\n                return {}; // Return an empty vector or handle the error as needed\n            }\n        } else if (music_string[i] == 'o') {\n            // \"o\" is a whole note, lasts four beats\n            beats.push_back(4);\n            i += 1;\n        } else {\n            cout << \"Invalid input: unrecognized character '\" << music_string[i] << \"'\" << endl;\n            return {}; // Return an empty vector or handle the error as needed\n        }\n    }\n\n    return beats;\n}\n\n"}
{"task_id": "CPP/18", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint how_many_times(const string& str, const string& substring) {\n    if (substring.empty()) return 0; // If the substring is empty, return 0\n\n    int count = 0;\n    size_t pos = 0;\n\n    while ((pos = str.find(substring, pos)) != string::npos) {\n        ++count;\n        pos++; // Move to the next character to allow for overlapping matches\n    }\n\n    return count;\n}\n\n"}
{"task_id": "CPP/19", "generation": "#include <iostream>\n#include <string>\n#include <map>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to map words to numbers\nint word_to_number(const string& word) {\n    map<string, int> number_map = {{\"zero\", 0}, {\"one\", 1}, {\"two\", 2}, {\"three\", 3},\n                                   {\"four\", 4}, {\"five\", 5}, {\"six\", 6}, {\"seven\", 7},\n                                   {\"eight\", 8}, {\"nine\", 9}};\n    return number_map[word];\n}\n\n// Function to sort the numbers\nstring sort_numbers(const string& input) {\n    vector<string> words;\n    string current_word = \"\";\n    \n    // Split the input into words\n    for (char ch : input) {\n        if (ch == ' ') {\n            if (!current_word.empty()) {\n                words.push_back(current_word);\n                current_word.clear();\n            }\n        } else {\n            current_word += ch;\n        }\n    }\n    if (!current_word.empty()) {\n        words.push_back(current_word);\n    }\n\n    // Convert words to numbers, sort them\n    vector<int> numbers(words.size());\n    for (size_t i = 0; i < words.size(); ++i) {\n        numbers[i] = word_to_number(words[i]);\n    }\n    sort(numbers.begin(), numbers.end());\n\n    // Convert sorted numbers back to words and form the output string\n    string result;\n    for (int num : numbers) {\n        auto it = number_map.find(num);\n        if (it != number_map.end()) {\n            result += it->first + \" \";\n        }\n    }\n\n    // Remove trailing space\n    if (!result.empty()) {\n        result.pop_back();\n    }\n\n    return result;\n}\n\n// Main function to test the sort_numbers function\n"}
{"task_id": "CPP/20", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\npair<float, float> find_closest_elements(vector<float> numbers) {\n    if (numbers.size() < 2) {\n        throw invalid_argument(\"The vector must contain at least two elements.\");\n    }\n\n    // Initialize the closest pair with the first two elements\n    float min_diff = abs(numbers[1] - numbers[0]);\n    float closest_a = numbers[0];\n    float closest_b = numbers[1];\n\n    // Iterate through the vector starting from the second element\n    for (size_t i = 1; i < numbers.size() - 1; ++i) {\n        float current_diff = abs(numbers[i + 1] - numbers[i]);\n        if (current_diff < min_diff) {\n            min_diff = current_diff;\n            closest_a = min(numbers[i], numbers[i + 1]);\n            closest_b = max(numbers[i], numbers[i + 1]);\n        }\n    }\n\n    return make_pair(closest_a, closest_b);\n}\n\n"}
{"task_id": "CPP/21", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // for std::min_element and std::max_element\n\nusing namespace std;\n\nvector<float> rescale_to_unit(vector<float> numbers) {\n    if (numbers.size() < 2) {\n        throw invalid_argument(\"Vector must contain at least two elements.\");\n    }\n\n    float min_value = *std::min_element(numbers.begin(), numbers.end());\n    float max_value = *std::max_element(numbers.begin(), numbers.end());\n\n    vector<float> scaled_numbers;\n    for (float num : numbers) {\n        float new_value = (num - min_value) / (max_value - min_value);\n        scaled_numbers.push_back(new_value);\n    }\n\n    return scaled_numbers;\n}\n\n"}
{"task_id": "CPP/22", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <boost/any.hpp>\n\ntypedef std::list<boost::any> list_any;\nusing namespace std;\n\n// Function to filter integers from a list of boost::any values\nstd::vector<int> filter_integers(list_any values) {\n    std::vector<int> result;\n    \n    for (const auto& value : values) {\n        if (value.type() == typeid(int)) {\n            result.push_back(boost::any_cast<int>(value));\n        }\n    }\n    \n    return result;\n}\n\n// Function to check the correctness of the filter_integers function\nvoid check_function() {\n    list_any test1 = {boost::any(3), boost::any(5.6), boost::any(7)};\n    vector<int> expected1 = {3, 7};\n    assert(filter_integers(test1) == expected1);\n\n    list_any test2 = {boost::any(\"abc\"), boost::any(42), boost::any(std::vector<int>{})};\n    vector<int> expected2 = {42};\n    assert(filter_integers(test2) == expected2);\n\n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/23", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint strlen(string str) {\n    int length = 0;\n    for (char ch : str) {\n        length++;\n    }\n    return length;\n}\n\n// Function to test the strlen function with some examples\nvoid test_strlen() {\n    cout << \"Length of \\\"\\\" is: \" << strlen(\"\") << endl; // Should output 0\n    cout << \"Length of \\\"abc\\\" is: \" << strlen(\"abc\") << endl; // Should output 3\n    cout << \"Length of \\\"hello world\\\" is: \" << strlen(\"hello world\") << endl; // Should output 11\n}\n\n"}
{"task_id": "CPP/24", "generation": "#include <iostream>\nusing namespace std;\n\nint largest_divisor(int n) {\n    for (int i = n - 1; i > 0; --i) {\n        if (n % i == 0) {\n            return i;\n        }\n    }\n    // If no divisor is found, which should not happen for positive integers,\n    // we can return a default value like 1.\n    return 1;\n}\n\n"}
{"task_id": "CPP/25", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> factorize(int n) {\n    vector<int> factors;\n    \n    // Divide by 2 to get rid of all even factors\n    while (n % 2 == 0) {\n        factors.push_back(2);\n        n /= 2;\n    }\n    \n    // Check for odd factors from 3 onwards\n    for (int i = 3; i * i <= n; i += 2) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n    \n    // If n is a prime number greater than 2\n    if (n > 2) {\n        factors.push_back(n);\n    }\n    \n    return factors;\n}\n\n"}
{"task_id": "CPP/26", "generation": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nvector<int> remove_duplicates(vector<int> numbers) {\n    // Create a map to count occurrences of each element\n    unordered_map<int, int> counts;\n    \n    // Count the occurrences of each number in the vector\n    for (int num : numbers) {\n        counts[num]++;\n    }\n    \n    // Reserve space in the result vector to avoid reallocations\n    vector<int> result;\n    result.reserve(numbers.size());\n    \n    // Iterate through the original vector and add elements that occur exactly once\n    for (int num : numbers) {\n        if (counts[num] == 1) {\n            result.push_back(num);\n        }\n    }\n    \n    return result;\n}\n\n// Function to test the remove_duplicates function\nvoid check() {\n    vector<int> input = {1, 2, 3, 2, 4};\n    vector<int> output = remove_duplicates(input);\n    \n    cout << \"Input: \";\n    for (int num : input) {\n        cout << num << \" \";\n    }\n    cout << \"\\nOutput: \";\n    for (int num : output) {\n        cout << num << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/27", "generation": "#include <iostream>\n#include <string>\n#include <cctype>  // For tolower and toupper functions\n\nusing namespace std;\n\nstring flip_case(string str) {\n    for (char &c : str) {\n        if (isupper(c)) {\n            c = tolower(c);\n        } else if (islower(c)) {\n            c = toupper(c);\n        }\n    }\n    return str;\n}\n\n"}
{"task_id": "CPP/28", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <numeric> // For std::accumulate\n\nusing namespace std;\n\nstring concatenate(vector<string> strings) {\n    if (strings.empty()) {\n        return \"\";\n    }\n    \n    // Use std::accumulate to concatenate all strings in the vector\n    string result = accumulate(strings.begin(), strings.end(), \"\"s,\n                               [](const string& a, const string& b) { return a + b; });\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/29", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to filter strings by a given prefix\nvector<string> filter_by_prefix(vector<string> strings, string prefix) {\n    vector<string> result;\n    \n    // Iterate through each string in the input vector\n    for (const auto& str : strings) {\n        // Check if the string starts with the given prefix\n        if (str.substr(0, prefix.length()) == prefix) {\n            result.push_back(str);\n        }\n    }\n    \n    return result;\n}\n\n// Function to print the contents of a vector of strings\nvoid print_vector(const vector<string>& vec) {\n    for (const auto& str : vec) {\n        cout << str << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/30", "generation": "#include <iostream>\n#include <vector>\n\n// Function to return only positive numbers in the vector.\nstd::vector<float> get_positive(std::vector<float> l) {\n    std::vector<float> result;\n    \n    // Iterate through each element in the input vector\n    for (float num : l) {\n        // Check if the number is positive\n        if (num > 0) {\n            // Add it to the result vector\n            result.push_back(num);\n        }\n    }\n    \n    return result;\n}\n\n// Function to print the elements of a vector\nvoid print_vector(const std::vector<float>& vec) {\n    for (float num : vec) {\n        std::cout << num << \" \";\n    }\n    std::cout << std::endl;\n}\n\n"}
{"task_id": "CPP/31", "generation": "#include <iostream>\nusing namespace std;\n\nbool is_prime(long long n) {\n    // Handle edge cases for numbers less than or equal to 1\n    if (n <= 1) return false;\n    \n    // Check divisibility from 2 up to the square root of n\n    for (long long i = 2; i * i <= n; ++i) {\n        if (n % i == 0) return false;\n    }\n    \n    return true;\n}\n\n"}
{"task_id": "CPP/32", "generation": "#include <iostream>\n#include <vector>\n#include <cmath>\n\ndouble poly(const std::vector<double>& xs, double x) {\n    double sum = 0;\n    int i;\n    for (i = 0; i < xs.size(); ++i) {\n        sum += xs[i] * pow(x, i);\n    }\n    return sum;\n}\n\ndouble find_zero(const std::vector<double>& xs) {\n    // Check if the number of coefficients is even\n    if (xs.size() % 2 != 0) {\n        throw std::invalid_argument(\"The number of coefficients must be even.\");\n    }\n\n    // Find the largest non-zero coefficient index\n    int max_index = -1;\n    double max_coeff = -INFINITY;\n    for (int i = 0; i < xs.size(); ++i) {\n        if (fabs(xs[i]) > max_coeff && xs[i] != 0) {\n            max_coeff = fabs(xs[i]);\n            max_index = i;\n        }\n    }\n\n    // Ensure the polynomial has a solution\n    double x1 = -max_index, x2 = max_index;\n    while (poly(xs, x1) * poly(xs, x2) > 0) {\n        if (fabs(x1) < 1e-6) x1 -= 1;\n        else x1 *= 0.5;\n\n        if (fabs(x2) < 1e-6) x2 += 1;\n        else x2 *= 2;\n    }\n\n    // Bisection method to find the root\n    double a = x1, b = x2;\n    while (b - a > 1e-6) {\n        double c = (a + b) / 2.0;\n        if (poly(xs, c) * poly(xs, a) < 0) {\n            b = c;\n        } else {\n            a = c;\n        }\n    }\n\n    return (a + b) / 2.0;\n}\n\n"}
{"task_id": "CPP/33", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> sort_third(vector<int> l) {\n    vector<int> third_indices;\n    \n    // Extract elements at indices divisible by three\n    for (size_t i = 2; i < l.size(); i += 3) {\n        third_indices.push_back(l[i]);\n    }\n    \n    // Sort the extracted elements\n    sort(third_indices.begin(), third_indices.end());\n    \n    // Replace original values with sorted ones at indices divisible by three\n    for (size_t i = 2, j = 0; i < l.size(); i += 3, ++j) {\n        l[i] = third_indices[j];\n    }\n    \n    return l;\n}\n\n// Function to test the sort_third function\nvoid test_sort_third() {\n    vector<int> v1 = {1, 2, 3};\n    vector<int> expected1 = {1, 2, 3};\n    assert(sort_third(v1) == expected1);\n\n    vector<int> v2 = {5, 6, 3, 4, 8, 9, 2};\n    vector<int> expected2 = {2, 6, 3, 4, 8, 9, 5};\n    assert(sort_third(v2) == expected2);\n\n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/34", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> unique(vector<int> l) {\n    // Sort the vector\n    sort(l.begin(), l.end());\n    \n    // Remove consecutive duplicates\n    auto last = unique(l.begin(), l.end());\n    \n    // Resize the vector to remove unused elements\n    l.resize(distance(l.begin(), last));\n    \n    return l;\n}\n\n"}
{"task_id": "CPP/35", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nfloat max_element(const vector<float>& l) {\n    if (l.empty()) {\n        throw runtime_error(\"Vector is empty\");\n    }\n\n    float max_val = l[0];\n    for (size_t i = 1; i < l.size(); ++i) {\n        if (l[i] > max_val) {\n            max_val = l[i];\n        }\n    }\n    return max_val;\n}\n\n"}
{"task_id": "CPP/36", "generation": "#include <iostream>\nusing namespace std;\n\nint fizz_buzz(int n) {\n    int count = 0;\n    \n    for (int i = 1; i < n; ++i) {\n        if (i % 11 == 0 || i % 13 == 0) {\n            // Convert the number to a string and count occurrences of '7'\n            string str_i = to_string(i);\n            for (char c : str_i) {\n                if (c == '7') {\n                    ++count;\n                }\n            }\n        }\n    }\n    \n    return count;\n}\n\n"}
{"task_id": "CPP/37", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<float> sort_even(vector<float> l) {\n    // Extract elements at even indices (0, 2, 4, ...)\n    vector<float> even_elements;\n    for (size_t i = 0; i < l.size(); i += 2) {\n        even_elements.push_back(l[i]);\n    }\n\n    // Sort the extracted even-indexed elements\n    sort(even_elements.begin(), even_elements.end());\n\n    // Create a new vector to store the result\n    vector<float> sorted_l(l);\n\n    // Place the sorted even-indexed elements back into their original positions\n    size_t even_index = 0;\n    for (size_t i = 0; i < l.size(); i += 2) {\n        sorted_l[i] = even_elements[even_index++];\n    }\n\n    return sorted_l;\n}\n\n// Function to test the sort_even function with provided examples\nvoid test_sort_even() {\n    vector<float> result1 = sort_even({1, 2, 3});\n    for (float val : result1) {\n        cout << val << \" \";\n    }\n    cout << endl;\n\n    vector<float> result2 = sort_even({5, 6, 3, 4});\n    for (float val : result2) {\n        cout << val << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/38", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nstring encode_cyclic(string s) {\n    // returns encoded string by cycling groups of three characters.\n    int l = s.length();\n    int num = (l + 2) / 3;\n    string x, output;\n    for (int i = 0; i * 3 < l; i++) {\n        x = s.substr(i * 3, 3);\n        if (x.length() == 3) x = x[2] + x.substr(0, 2);\n        output += x;\n    }\n    return output;\n}\n\nstring decode_cyclic(string s) {\n    /*\n    takes as input string encoded with encode_cyclic function. Returns decoded string.\n    */\n    int l = s.length();\n    int num = (l + 2) / 3;\n    string x, output;\n    for (int i = 0; i * 3 < l; i++) {\n        x = s.substr(i * 3, 3);\n        if (x.length() == 3) x = x[1] + x[2] + x[0];\n        output += x;\n    }\n    return output;\n}\n\n"}
{"task_id": "CPP/39", "generation": "#include <iostream>\n#include <vector>\n\n// Function to check if a number is prime\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    if (num == 2 || num == 3) return true;\n    if (num % 2 == 0 || num % 3 == 0) return false;\n    for (int i = 5; i * i <= num; i += 6) {\n        if (num % i == 0 || num % (i + 2) == 0) return false;\n    }\n    return true;\n}\n\n// Function to generate the n-th Fibonacci number that is also prime\nint prime_fib(int n) {\n    int count = 0; // Counter for prime Fibonacci numbers found\n    long fib1 = 0, fib2 = 1; // First two Fibonacci numbers\n\n    while (true) {\n        long next_fib = fib1 + fib2;\n        if (is_prime(next_fib)) {\n            count++;\n            if (count == n) return next_fib;\n        }\n        fib1 = fib2;\n        fib2 = next_fib;\n    }\n}\n\n"}
{"task_id": "CPP/40", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nbool triples_sum_to_zero(vector<int> l) {\n    // First, sort the vector to facilitate the two-pointer approach.\n    sort(l.begin(), l.end());\n    \n    // Iterate through each element in the vector, treating it as the first element of a potential triplet.\n    for (int i = 0; i < l.size() - 2; ++i) {\n        // Skip duplicate elements to avoid counting the same triplet multiple times.\n        if (i > 0 && l[i] == l[i-1]) continue;\n        \n        int left = i + 1, right = l.size() - 1;\n        \n        // Use two pointers to find a pair that sums up with the current element to zero.\n        while (left < right) {\n            int sum = l[i] + l[left] + l[right];\n            \n            if (sum == 0) {\n                return true; // Found a triplet that sums to zero.\n            } else if (sum < 0) {\n                ++left; // Need a larger number, move the left pointer to the right.\n            } else {\n                --right; // Need a smaller number, move the right pointer to the left.\n            }\n        }\n    }\n    \n    return false; // No triplet found that sums to zero.\n}\n\n"}
{"task_id": "CPP/41", "generation": "#include <iostream>\nusing namespace std;\n\nint car_race_collision(int n) {\n    // Each car moving left to right will collide with each car moving right to left.\n    return n * n;\n}\n\n"}
{"task_id": "CPP/42", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> incr_vector(vector<int> l) {\n    for (int &i : l) {\n        i += 1;\n    }\n    return l;\n}\n\n// Function to print the vector elements\nvoid print_vector(const vector<int>& v) {\n    for (const int& elem : v) {\n        cout << elem << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/43", "generation": "#include <iostream>\n#include <vector>\n#include <set>\n\nbool pairs_sum_to_zero(const std::vector<int>& l) {\n    std::set<int> seen;\n    \n    // Iterate through each element in the vector\n    for (int num : l) {\n        // Check if the negation of the current number is already in the set\n        if (seen.find(-num) != seen.end()) {\n            return true;  // Found a pair that sums to zero\n        }\n        seen.insert(num);  // Add the current number to the set\n    }\n    \n    return false;  // No such pair found\n}\n\n// Function to test the pairs_sum_to_zero function with provided examples\nvoid check() {\n    assert(pairs_sum_to_zero({1, 3, 5, 0}) == false);\n    assert(pairs_sum_to_zero({1, 3, -2, 1}) == false);\n    assert(pairs_sum_to_zero({1, 2, 3, 7}) == false);\n    assert(pairs_sum_to_zero({2, 4, -5, 3, 5, 7}) == true);\n    assert(pairs_sum_to_zero({1}) == false);\n\n    std::cout << \"All test cases passed!\" << std::endl;\n}\n\n"}
{"task_id": "CPP/44", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring change_base(int x, int base) {\n    if (base < 2 || base > 9) {\n        throw invalid_argument(\"Base must be between 2 and 9.\");\n    }\n    \n    string result = \"\";\n    while (x > 0) {\n        int remainder = x % base;\n        result = to_string(remainder) + result;\n        x /= base;\n    }\n    \n    return result.empty() ? \"0\" : result;\n}\n\n"}
{"task_id": "CPP/45", "generation": "#include <stdio.h>\nusing namespace std;\n\nfloat triangle_area(float a, float h) {\n    return 0.5 * a * h;\n}\n\n"}
{"task_id": "CPP/46", "generation": "#include <iostream>\nusing namespace std;\n\nint fib4(int n) {\n    if (n == 0 || n == 1 || n == 2) {\n        return n == 2 ? 2 : 0;\n    }\n    \n    if (n == 3) {\n        return 0;\n    }\n\n    // Initialize the first four values of the sequence\n    int a = 0, b = 0, c = 2, d = 0;\n\n    // Compute fib4(n) iteratively\n    for (int i = 4; i <= n; ++i) {\n        int next = a + b + c + d;\n        a = b;\n        b = c;\n        c = d;\n        d = next;\n    }\n\n    return d;\n}\n\n"}
{"task_id": "CPP/47", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nfloat median(vector<float> l) {\n    // Sort the vector\n    sort(l.begin(), l.end());\n    \n    int n = l.size();\n    \n    // Check if the number of elements is odd or even\n    if (n % 2 == 1) {\n        // If odd, return the middle element\n        return l[n / 2];\n    } else {\n        // If even, return the average of the two middle elements\n        float mid1 = l[(n - 1) / 2];\n        float mid2 = l[n / 2];\n        return (mid1 + mid2) / 2.0;\n    }\n}\n\n"}
{"task_id": "CPP/48", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_palindrome(string text) {\n    int left = 0;\n    int right = text.length() - 1;\n\n    while (left < right) {\n        if (text[left] != text[right]) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n\n    return true;\n}\n\n"}
{"task_id": "CPP/49", "generation": "#include <stdio.h>\nusing namespace std;\n\nint modp(int n, int p) {\n    // Base case: 2^0 % p is always 1\n    if (n == 0)\n        return 1;\n    \n    // Initialize result to 1 (since we are multiplying by 2^n)\n    long long result = 1;\n    long long base = 2;\n\n    // Update n to be half of its value in each iteration\n    while (n > 0) {\n        // If n is odd, multiply the result with the current base\n        if (n % 2 == 1)\n            result = (result * base) % p;\n        \n        // Square the base and reduce it modulo p\n        base = (base * base) % p;\n\n        // Divide n by 2\n        n /= 2;\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/50", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nstring encode_shift(string s) {\n    // returns encoded string by shifting every character by 5 in the alphabet.\n    string out;\n    int i;\n    for (i = 0; i < s.length(); i++) {\n        int w = ((int)s[i] + 5 - (int)'a') % 26 + (int)'a';\n        out += (char)w;\n    }\n    return out;\n}\n\nstring decode_shift(string s) {\n    // takes as input string encoded with encode_shift function. Returns decoded string.\n    string out;\n    int i;\n    for (i = 0; i < s.length(); i++) {\n        int w = ((int)s[i] - 5 - (int)'a') % 26 + (int)'a';\n        out += (char)w;\n    }\n    return out;\n}\n\n"}
{"task_id": "CPP/51", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nbool is_vowel(char c) {\n    // Convert character to lowercase for simplicity\n    char lower_c = tolower(c);\n    return lower_c == 'a' || lower_c == 'e' || lower_c == 'i' || lower_c == 'o' || lower_c == 'u';\n}\n\nstring remove_vowels(string text) {\n    string result;\n    for (char c : text) {\n        if (!is_vowel(c)) {\n            result += c;\n        }\n    }\n    return result;\n}\n\n"}
{"task_id": "CPP/52", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Function to check if all elements in the vector are below the threshold\nbool below_threshold(vector<int> l, int t) {\n    // Iterate through each element in the vector\n    for (int num : l) {\n        // If any number is greater than or equal to the threshold, return false\n        if (num >= t) {\n            return false;\n        }\n    }\n    // If all numbers are below the threshold, return true\n    return true;\n}\n\n// Function to test the below_threshold function with provided examples\nvoid check_function() {\n    cout << boolalpha; // Print bools as true/false instead of 1/0\n    cout << \"below_threshold({1, 2, 4, 10}, 100): \" << below_threshold({1, 2, 4, 10}, 100) << endl;\n    cout << \"below_threshold({1, 20, 4, 10}, 5): \" << below_threshold({1, 20, 4, 10}, 5) << endl;\n}\n\n"}
{"task_id": "CPP/53", "generation": "#include <iostream>  // Include iostream for input/output operations\n\nusing namespace std;\n\nint add(int x, int y) {\n    return x + y;  // Return the sum of x and y\n}\n\n"}
{"task_id": "CPP/54", "generation": "#include <iostream>\n#include <string>\n#include <set>\n\nusing namespace std;\n\nbool same_chars(string s0, string s1) {\n    // Create a set for each string to store unique characters\n    set<char> chars_s0(s0.begin(), s0.end());\n    set<char> chars_s1(s1.begin(), s1.end());\n\n    // Compare the sets\n    return chars_s0 == chars_s1;\n}\n\n"}
{"task_id": "CPP/55", "generation": "#include <stdio.h>\nusing namespace std;\n\nint fib(int n) {\n    if (n <= 0) {\n        return 0;\n    } else if (n == 1) {\n        return 1;\n    } else {\n        int a = 0, b = 1, c;\n        for (int i = 2; i <= n; ++i) {\n            c = a + b;\n            a = b;\n            b = c;\n        }\n        return b;\n    }\n}\n\n// Function to test the fib function\nvoid test_fib() {\n    printf(\"fib(10) = %d\\n\", fib(10)); // Expected output: 55\n    printf(\"fib(1) = %d\\n\", fib(1));   // Expected output: 1\n    printf(\"fib(8) = %d\\n\", fib(8));   // Expected output: 21\n}\n\n"}
{"task_id": "CPP/56", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    int balance = 0;\n    \n    for (char bracket : brackets) {\n        if (bracket == '<') {\n            balance++;\n        } else if (bracket == '>') {\n            balance--;\n        }\n        \n        // If at any point the balance is negative, it means there's a closing bracket without an opening one\n        if (balance < 0) {\n            return false;\n        }\n    }\n    \n    // The string is correct if the balance is zero at the end\n    return balance == 0;\n}\n\n"}
{"task_id": "CPP/57", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool monotonic(vector<float> l) {\n    // Check if the vector is empty or has only one element\n    if (l.size() <= 1) return true;\n\n    // Determine the direction of the sequence\n    bool increasing = false;\n    if (l[0] < l[1]) {\n        increasing = true;\n    } else if (l[0] > l[1]) {\n        increasing = false;\n    }\n\n    // Check the rest of the vector for monotonicity\n    for (size_t i = 1; i < l.size(); ++i) {\n        if ((increasing && l[i-1] > l[i]) || (!increasing && l[i-1] < l[i])) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\n"}
{"task_id": "CPP/58", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n// Function to return sorted unique common elements for two vectors.\nvector<int> common(vector<int> l1, vector<int> l2) {\n    // Remove duplicates from both vectors\n    sort(l1.begin(), l1.end());\n    auto last = unique(l1.begin(), l1.end());\n    l1.erase(last, l1.end());\n\n    sort(l2.begin(), l2.end());\n    auto last2 = unique(l2.begin(), l2.end());\n    l2.erase(last2, l2.end());\n\n    // Find common elements\n    vector<int> result;\n    set_intersection(l1.begin(), l1.end(), l2.begin(), l2.end(), back_inserter(result));\n\n    return result;\n}\n\n"}
{"task_id": "CPP/59", "generation": "#include <iostream>\nusing namespace std;\n\nint largest_prime_factor(int n) {\n    int maxPrime = -1;\n    \n    // Remove all the 2s that divide n\n    while (n % 2 == 0) {\n        maxPrime = 2;\n        n /= 2;\n    }\n    \n    // n must be odd at this point, so we can skip one element (Note i = i +2)\n    for (int i = 3; i * i <= n; i += 2) {\n        // While i divides n, print i and divide n\n        while (n % i == 0) {\n            maxPrime = i;\n            n = n / i;\n        }\n    }\n    \n    // This condition is to handle the case when n is a prime number greater than 2\n    if (n > 2)\n        maxPrime = n;\n    \n    return maxPrime;\n}\n\n"}
{"task_id": "CPP/60", "generation": "#include <iostream>\nusing namespace std;\n\nint sum_to_n(int n) {\n    return (n * (n + 1)) / 2;\n}\n\n"}
{"task_id": "CPP/61", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    int balance = 0;\n    \n    for (char bracket : brackets) {\n        if (bracket == '(') {\n            balance++;\n        } else if (bracket == ')') {\n            balance--;\n        }\n        \n        // If at any point the balance is negative, it means there's a closing bracket without an opening one\n        if (balance < 0) {\n            return false;\n        }\n    }\n    \n    // The string is correct if the balance is zero at the end\n    return balance == 0;\n}\n\n"}
{"task_id": "CPP/62", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvector<float> derivative(vector<float> xs) {\n    vector<float> result;\n    \n    // Skip the first element (constant term), as its derivative is 0.\n    for (size_t i = 1; i < xs.size(); ++i) {\n        result.push_back(xs[i] * i);\n    }\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/63", "generation": "#include <iostream>\nusing namespace std;\n\nint fibfib(int n) {\n    // Base cases\n    if (n == 0 || n == 1) return 0;\n    if (n == 2) return 1;\n\n    // Array to store the computed values of FibFib sequence\n    int dp[n + 1];\n    dp[0] = 0; dp[1] = 0; dp[2] = 1;\n\n    // Fill the dp array using the recurrence relation\n    for (int i = 3; i <= n; ++i) {\n        dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3];\n    }\n\n    return dp[n];\n}\n\n// Function to test the fibfib function with some examples\nvoid testFibfib() {\n    cout << \"fibfib(1): \" << fibfib(1) << endl; // Expected output: 0\n    cout << \"fibfib(5): \" << fibfib(5) << endl; // Expected output: 4\n    cout << \"fibfib(8): \" << fibfib(8) << endl; // Expected output: 24\n}\n\n"}
{"task_id": "CPP/64", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint vowels_count(string s) {\n    int count = 0;\n    \n    // Convert the string to lowercase for easier comparison\n    transform(s.begin(), s.end(), s.begin(), ::tolower);\n    \n    // Check each character in the string\n    for (size_t i = 0; i < s.length(); ++i) {\n        char c = s[i];\n        \n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n            count++;\n        } else if (c == 'y' && i == s.length() - 1) {\n            // Count 'y' only if it is at the end of the word\n            count++;\n        }\n    }\n    \n    return count;\n}\n\n"}
{"task_id": "CPP/65", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring circular_shift(int x, int shift) {\n    // Convert integer to string\n    string num_str = to_string(x);\n    \n    // Get the length of the number\n    size_t len = num_str.length();\n    \n    // If shift is greater than or equal to the number of digits, reverse the string\n    if (shift >= len) {\n        return string(num_str.rbegin(), num_str.rend());\n    }\n    \n    // Perform circular shift\n    int effective_shift = shift % len;\n    string shifted_str = num_str.substr(len - effective_shift) + num_str.substr(0, len - effective_shift);\n    \n    return shifted_str;\n}\n\n"}
{"task_id": "CPP/66", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint digitSum(string s) {\n    int sum = 0;\n    for (char c : s) {\n        if (isupper(c)) { // Check if the character is uppercase\n            sum += static_cast<int>(c); // Add its ASCII value to the sum\n        }\n    }\n    return sum;\n}\n\n// Function to test the digitSum function with provided examples\nvoid testDigitSum() {\n    cout << \"Testing digitSum:\" << endl;\n    assert(digitSum(\"\") == 0);\n    assert(digitSum(\"abAB\") == 131);\n    assert(digitSum(\"abcCd\") == 67);\n    assert(digitSum(\"helloE\") == 69);\n    assert(digitSum(\"woArBld\") == 131);\n    assert(digitSum(\"aAaaaXa\") == 153);\n\n    cout << \"All tests passed successfully!\" << endl;\n}\n\n"}
{"task_id": "CPP/67", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint fruit_distribution(string s, int n) {\n    // Find the positions of 'apples' and 'oranges'\n    size_t apples_pos = s.find(\"apples\");\n    size_t oranges_pos = s.find(\"oranges\");\n\n    // Extract the number of apples\n    string num_apples_str = s.substr(apples_pos - 1, 2);\n    int num_apples = stoi(num_apples_str);\n\n    // Extract the number of oranges\n    string num_oranges_str = s.substr(oranges_pos - 1, 2);\n    int num_oranges = stoi(num_oranges_str);\n\n    // Calculate the number of mangoes\n    int num_mangoes = n - (num_apples + num_oranges);\n\n    return num_mangoes;\n}\n\n"}
{"task_id": "CPP/68", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> pluck(vector<int> arr) {\n    // Check if the array is empty\n    if (arr.empty()) {\n        return {};\n    }\n\n    int smallestEvenValue = -1;\n    int index = -1;\n\n    for (int i = 0; i < arr.size(); ++i) {\n        // Check if the current element is even and smaller than the current smallest even value\n        if (arr[i] % 2 == 0 && (smallestEvenValue == -1 || arr[i] < smallestEvenValue)) {\n            smallestEvenValue = arr[i];\n            index = i;\n        }\n    }\n\n    // If no even values were found, return an empty vector\n    if (smallestEvenValue == -1) {\n        return {};\n    }\n\n    return {smallestEvenValue, index};\n}\n\n"}
{"task_id": "CPP/69", "generation": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint search(vector<int> lst) {\n    // Create a frequency map to count occurrences of each number\n    unordered_map<int, int> freqMap;\n    \n    // Count the frequency of each integer in the vector\n    for (int num : lst) {\n        freqMap[num]++;\n    }\n    \n    // Initialize the result as -1\n    int result = -1;\n    \n    // Iterate through the unique integers and check the condition\n    for (const auto& pair : freqMap) {\n        if (pair.second >= pair.first && pair.first > result) {\n            result = pair.first;\n        }\n    }\n    \n    return result;\n}\n\n// Function to test the search function with given examples\nvoid test() {\n    cout << \"search({4, 1, 2, 2, 3, 1}) == \" << search({4, 1, 2, 2, 3, 1}) << endl; // Should output 2\n    cout << \"search({1, 2, 2, 3, 3, 3, 4, 4, 4}) == \" << search({1, 2, 2, 3, 3, 3, 4, 4, 4}) << endl; // Should output 3\n    cout << \"search({5, 5, 4, 4, 4}) == \" << search({5, 5, 4, 4, 4}) << endl; // Should output -1\n}\n\n"}
{"task_id": "CPP/70", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> strange_sort_list(vector<int> lst) {\n    // Sort the input vector\n    sort(lst.begin(), lst.end());\n    \n    vector<int> result;\n    int start = 0;  // Pointer to the beginning of the sorted list\n    int end = lst.size() - 1;  // Pointer to the end of the sorted list\n    \n    while (start <= end) {\n        if (start == end) {\n            // If only one element is left, add it to the result\n            result.push_back(lst[start]);\n            break;\n        }\n        \n        // Add the minimum value from the remaining elements\n        result.push_back(lst[start++]);\n        \n        // Add the maximum value from the remaining elements\n        if (start <= end) {\n            result.push_back(lst[end--]);\n        }\n    }\n    \n    return result;\n}\n\n// Function to check the correctness of the strange_sort_list function\nvoid check() {\n    assert(strange_sort_list({1, 2, 3, 4}) == vector<int>({1, 4, 2, 3}));\n    assert(strange_sort_list({5, 5, 5, 5}) == vector<int>({5, 5, 5, 5}));\n    assert(strange_sort_list({}) == vector<int>({}));\n    cout << \"All test cases passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/71", "generation": "#include <stdio.h>\n#include <math.h>\n\nusing namespace std;\n\nfloat triangle_area(float a, float b, float c) {\n    // Check if the sides form a valid triangle\n    if (a + b <= c || a + c <= b || b + c <= a) {\n        return -1;\n    }\n\n    // Calculate the semi-perimeter\n    float s = (a + b + c) / 2.0;\n\n    // Calculate the area using Heron's formula\n    float area = sqrt(s * (s - a) * (s - b) * (s - c));\n\n    // Round to 2 decimal points\n    return round(area * 100) / 100;\n}\n\n"}
{"task_id": "CPP/72", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool will_it_fly(vector<int> q, int w) {\n    // Check if the sum of elements is less than or equal to w\n    int sum = 0;\n    for (int num : q) {\n        sum += num;\n    }\n    if (sum > w) return false;\n\n    // Check if the vector is a palindrome\n    for (size_t i = 0; i < q.size() / 2; ++i) {\n        if (q[i] != q[q.size() - 1 - i]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\n// Function to test the will_it_fly function with provided examples\nvoid test_will_it_fly() {\n    cout << boolalpha; // Print bools as true/false instead of 1/0\n    cout << \"will_it_fly({1, 2}, 5) \u279e \" << will_it_fly({1, 2}, 5) << endl;\n    cout << \"will_it_fly({3, 2, 3}, 1) \u279e \" << will_it_fly({3, 2, 3}, 1) << endl;\n    cout << \"will_it_fly({3, 2, 3}, 9) \u279e \" << will_it_fly({3, 2, 3}, 9) << endl;\n    cout << \"will_it_fly({3}, 5) \u279e \" << will_it_fly({3}, 5) << endl;\n}\n\n"}
{"task_id": "CPP/73", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint smallest_change(vector<int> arr) {\n    int left = 0;\n    int right = arr.size() - 1;\n    int changes = 0;\n\n    while (left <= right) {\n        if (arr[left] != arr[right]) {\n            changes++;\n        }\n        left++;\n        right--;\n    }\n\n    return changes;\n}\n\n"}
{"task_id": "CPP/74", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to calculate the total number of characters in a vector of strings\nint count_chars(const vector<string>& vec) {\n    int total = 0;\n    for (const auto& str : vec) {\n        total += str.length();\n    }\n    return total;\n}\n\nvector<string> total_match(vector<string> lst1, vector<string> lst2) {\n    // Calculate the total number of characters in both vectors\n    int chars_lst1 = count_chars(lst1);\n    int chars_lst2 = count_chars(lst2);\n\n    // Compare and return the appropriate vector\n    if (chars_lst1 < chars_lst2) {\n        return lst1;\n    } else if (chars_lst2 < chars_lst1) {\n        return lst2;\n    } else {\n        return lst1;  // If they are equal, return the first vector\n    }\n}\n\n// Function to test the total_match function with provided examples\nvoid test_total_match() {\n    assert(total_match({}, {}) == vector<string>());\n    assert(total_match({\"hi\", \"admin\"}, {\"hI\", \"Hi\"}) == vector<string>{\"hI\", \"Hi\"});\n    assert(total_match({\"hi\", \"admin\"}, {\"hi\", \"hi\", \"admin\", \"project\"}) == vector<string>{\"hi\", \"admin\"});\n    assert(total_match({\"hi\", \"admin\"}, {\"hI\", \"hi\", \"hi\"}) == vector<string>{\"hI\", \"hi\", \"hi\"});\n    assert(total_match({\"4\"}, {\"1\", \"2\", \"3\", \"4\", \"5\"}) == vector<string>{\"4\"});\n\n    cout << \"All tests passed successfully.\" << endl;\n}\n\n"}
{"task_id": "CPP/75", "generation": "#include <iostream>\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    if (n == 2 || n == 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    for (int i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0)\n            return false;\n    }\n    return true;\n}\n\n// Function to get all prime numbers less than 100\nvoid generate_primes(int primes[], int &size) {\n    size = 0;\n    for (int i = 2; i < 100; ++i) {\n        if (is_prime(i)) {\n            primes[size++] = i;\n        }\n    }\n}\n\n// Function to check if the number is a product of exactly three prime numbers\nbool is_multiply_prime(int a) {\n    int primes[25]; // There are 25 prime numbers less than 100\n    int size = 0;\n    generate_primes(primes, size);\n\n    for (int i = 0; i < size; ++i) {\n        for (int j = i; j < size; ++j) {\n            for (int k = j; k < size; ++k) {\n                if (primes[i] * primes[j] * primes[k] == a)\n                    return true;\n            }\n        }\n    }\n\n    return false;\n}\n\n// Main function to test the is_multiply_prime function\n"}
{"task_id": "CPP/76", "generation": "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\nbool is_simple_power(int x, int n) {\n    // Check for the base case where n is 1 and x is not 1\n    if (n == 1 && x != 1) return false;\n    \n    // Calculate the logarithm of x to the base n\n    double k = log(x) / log(n);\n    \n    // Check if k is an integer by comparing it with its rounded value\n    return floor(k) == k;\n}\n\n"}
{"task_id": "CPP/77", "generation": "#include <stdio.h>\n#include <cmath>\n\nusing namespace std;\n\nbool iscube(int a) {\n    // Handle special cases: 0 and 1\n    if (a == 0 || a == 1) return true;\n    \n    // Calculate the cube root of the absolute value of 'a'\n    double cubeRoot = cbrt(abs(a));\n    \n    // Round the cube root to the nearest integer\n    int roundedCubeRoot = round(cubeRoot);\n    \n    // Check if cubing the rounded value gives back the original number\n    return pow(roundedCubeRoot, 3) == a;\n}\n\n"}
{"task_id": "CPP/78", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\n// Helper function to check if a hexadecimal digit is prime\nbool is_prime_hex_digit(char hex_digit) {\n    // Convert the character to lowercase for easier comparison\n    char lower_hex_digit = tolower(hex_digit);\n    \n    // Check if the digit is one of the prime hexadecimal digits\n    return (lower_hex_digit == '2' || lower_hex_digit == '3' ||\n            lower_hex_digit == '5' || lower_hex_digit == '7' ||\n            lower_hex_digit == 'b' || lower_hex_digit == 'd');\n}\n\n// Main function to count prime hexadecimal digits in the input string\nint hex_key(string num) {\n    int count = 0;\n    \n    // Iterate through each character of the input string\n    for (char digit : num) {\n        if (is_prime_hex_digit(digit)) {\n            count++;\n        }\n    }\n    \n    return count;\n}\n\n// Function to test the hex_key function with provided examples\nvoid test_hex_key() {\n    cout << \"Testing hex_key function:\" << endl;\n    cout << \"Input: \\\"AB\\\", Expected Output: 1, Actual Output: \" << hex_key(\"AB\") << endl;\n    cout << \"Input: \\\"1077E\\\", Expected Output: 2, Actual Output: \" << hex_key(\"1077E\") << endl;\n    cout << \"Input: \\\"ABED1A33\\\", Expected Output: 4, Actual Output: \" << hex_key(\"ABED1A33\") << endl;\n    cout << \"Input: \\\"123456789ABCDEF0\\\", Expected Output: 6, Actual Output: \" << hex_key(\"123456789ABCDEF0\") << endl;\n    cout << \"Input: \\\"2020\\\", Expected Output: 2, Actual Output: \" << hex_key(\"2020\") << endl;\n}\n\n"}
{"task_id": "CPP/79", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring decimal_to_binary(int decimal) {\n    if (decimal == 0) {\n        return \"db0db\";\n    }\n\n    string binary = \"\";\n    while (decimal > 0) {\n        int remainder = decimal % 2;\n        binary = to_string(remainder) + binary;\n        decimal /= 2;\n    }\n    \n    // Add the prefix and suffix\n    return \"db\" + binary + \"db\";\n}\n\n"}
{"task_id": "CPP/80", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_happy(string s) {\n    // Check if the string length is less than 3\n    if (s.length() < 3) return false;\n    \n    // Iterate through the string and check every three consecutive characters\n    for (int i = 0; i <= s.length() - 3; ++i) {\n        // Check if any two of the three consecutive characters are the same\n        if (s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]) {\n            return false;\n        }\n    }\n    \n    // If no three consecutive characters are the same, the string is happy\n    return true;\n}\n\n"}
{"task_id": "CPP/81", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> numerical_letter_grade(vector<float> grades) {\n    vector<string> letter_grades;\n    \n    for (float gpa : grades) {\n        if (gpa >= 4.0) {\n            letter_grades.push_back(\"A+\");\n        } else if (gpa > 3.7) {\n            letter_grades.push_back(\"A\");\n        } else if (gpa > 3.3) {\n            letter_grades.push_back(\"A-\");\n        } else if (gpa > 3.0) {\n            letter_grades.push_back(\"B+\");\n        } else if (gpa > 2.7) {\n            letter_grades.push_back(\"B\");\n        } else if (gpa > 2.3) {\n            letter_grades.push_back(\"B-\");\n        } else if (gpa > 2.0) {\n            letter_grades.push_back(\"C+\");\n        } else if (gpa > 1.7) {\n            letter_grades.push_back(\"C\");\n        } else if (gpa > 1.3) {\n            letter_grades.push_back(\"C-\");\n        } else if (gpa > 1.0) {\n            letter_grades.push_back(\"D+\");\n        } else if (gpa > 0.7) {\n            letter_grades.push_back(\"D\");\n        } else if (gpa > 0.0) {\n            letter_grades.push_back(\"D-\");\n        } else {\n            letter_grades.push_back(\"E\");\n        }\n    }\n\n    return letter_grades;\n}\n\n"}
{"task_id": "CPP/82", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    if (num == 2) return true;\n    if (num % 2 == 0) return false;\n\n    for (int i = 3; i * i <= num; i += 2) {\n        if (num % i == 0)\n            return false;\n    }\n    return true;\n}\n\n// Function to check if the length of a string is prime\nbool prime_length(string str) {\n    int len = str.length();\n    return is_prime(len);\n}\n\n"}
{"task_id": "CPP/83", "generation": "#include <iostream>\nusing namespace std;\n\nint starts_one_ends(int n) {\n    if (n == 1) return 1; // Special case for single-digit numbers\n\n    int count_starting_with_1 = pow(10, n - 1);\n    int count_ending_with_1 = pow(10, n - 1);\n    int count_both_start_and_end_with_1 = pow(10, n - 2);\n\n    return count_starting_with_1 + count_ending_with_1 - count_both_start_and_end_with_1;\n}\n\n"}
{"task_id": "CPP/84", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring solve(int N) {\n    int sum = 0;\n    \n    // Calculate the sum of digits\n    while (N > 0) {\n        sum += N % 10;  // Add the last digit to the sum\n        N /= 10;        // Remove the last digit from N\n    }\n    \n    // Convert the sum to binary and return it as a string\n    string binarySum = \"\";\n    if (sum == 0) {\n        binarySum = \"0\";\n    } else {\n        while (sum > 0) {\n            binarySum = to_string(sum % 2) + binarySum;  // Prepend the remainder of sum divided by 2\n            sum /= 2;                                   // Divide sum by 2\n        }\n    }\n    \n    return binarySum;\n}\n\n"}
{"task_id": "CPP/85", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint add(vector<int> lst){\n    int sum = 0;\n    \n    // Iterate through the vector starting from index 1 with a step of 2\n    for (size_t i = 1; i < lst.size(); i += 2) {\n        if (lst[i] % 2 == 0) { // Check if the element is even\n            sum += lst[i]; // Add it to the sum\n        }\n    }\n    \n    return sum;\n}\n\n// Function to test the add function with provided examples\nvoid check() {\n    assert(add({4, 2, 6, 7}) == 2); // Should be 2 (only 2 is even and at an odd index)\n    assert(add({1, 3, 5, 7, 9}) == 0); // No even numbers at odd indices\n    assert(add({2, 4, 6, 8, 10}) == 4); // Only 4 is even and at an odd index\n    cout << \"All test cases passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/86", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to sort individual words\nvoid sortWord(string &word) {\n    sort(word.begin(), word.end());\n}\n\n// Main function to process the string and return the ordered version\nstring anti_shuffle(const string &s) {\n    string result;\n    string currentWord;\n    \n    // Iterate through each character in the input string\n    for (char ch : s) {\n        if (ch == ' ') {\n            // If a space is encountered, sort the previous word and add it to the result\n            sortWord(currentWord);\n            result += currentWord + \" \";\n            currentWord.clear();\n        } else {\n            // Otherwise, append the character to the current word\n            currentWord += ch;\n        }\n    }\n\n    // Sort and add the last word if there is one\n    if (!currentWord.empty()) {\n        sortWord(currentWord);\n        result += currentWord;\n    }\n\n    return result;\n}\n\n// Function to test the anti_shuffle function\nvoid test() {\n    cout << anti_shuffle(\"Hi\") << endl;          // Output: Hi\n    cout << anti_shuffle(\"hello\") << endl;       // Output: ehllo\n    cout << anti_shuffle(\"Hello World!!!\") << endl;  // Output: Hello !!!Wdlor\n}\n\n"}
{"task_id": "CPP/87", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to get the coordinates of all occurrences of x in lst\nvector<vector<int>> get_row(vector<vector<int>> lst, int x) {\n    vector<vector<int>> result;\n    \n    // Iterate through each row and column\n    for (int i = 0; i < lst.size(); ++i) {\n        for (int j = 0; j < lst[i].size(); ++j) {\n            if (lst[i][j] == x) {\n                // Store the coordinate {row, column}\n                result.push_back({i, j});\n            }\n        }\n    }\n\n    // Sort by row in ascending order\n    sort(result.begin(), result.end());\n\n    // For each row, sort columns in descending order\n    for (auto &coord : result) {\n        if (coord.size() > 1) { // Ensure we only process coordinates with more than one element\n            sort(coord.rbegin(), coord.rend());\n        }\n    }\n\n    return result;\n}\n\n// Function to print the result for verification\nvoid print_result(const vector<vector<int>>& result) {\n    for (const auto& row : result) {\n        cout << \"{\";\n        for (size_t i = 0; i < row.size(); ++i) {\n            cout << row[i];\n            if (i < row.size() - 1) cout << \", \";\n        }\n        cout << \"} \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/88", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> sort_array(vector<int> array) {\n    // Check if the vector is empty or has only one element\n    if (array.empty() || array.size() == 1) {\n        return array;\n    }\n\n    int first = array.front();\n    int last = array.back();\n\n    // Calculate the sum of the first and last elements\n    int sum = first + last;\n\n    // Determine sorting order based on the sum being odd or even\n    if (sum % 2 == 0) {\n        // Sort in descending order\n        vector<int> sorted_array(array);\n        sort(sorted_array.rbegin(), sorted_array.rend());\n        return sorted_array;\n    } else {\n        // Sort in ascending order\n        vector<int> sorted_array(array);\n        sort(sorted_array.begin(), sorted_array.end());\n        return sorted_array;\n    }\n}\n\n// Function to check the correctness of the solution\nvoid check() {\n    assert(sort_array({}) == vector<int>());\n    assert(sort_array({5}) == vector<int>({5}));\n    assert(sort_array({2, 4, 3, 0, 1, 5}) == vector<int>({0, 1, 2, 3, 4, 5}));\n    assert(sort_array({2, 4, 3, 0, 1, 5, 6}) == vector<int>({6, 5, 4, 3, 2, 1, 0}));\n}\n\n"}
{"task_id": "CPP/89", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring encrypt(string s) {\n    string result = \"\";\n    for (char &c : s) {\n        if (isalpha(c)) {  // Check if the character is a letter\n            char base = 'a';  // For lowercase letters\n            if (isupper(c)) {\n                base = 'A';  // For uppercase letters\n            }\n            c = base + ((c - base + 4) % 26);  // Rotate by 4 and handle wrap-around\n        }\n        result += c;\n    }\n    return result;\n}\n\n"}
{"task_id": "CPP/90", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n// Function to find the second smallest element in a vector\nstd::optional<int> next_smallest(const std::vector<int>& lst) {\n    if (lst.size() < 2) {\n        return std::nullopt; // Return None if there are less than 2 elements\n    }\n\n    int first = INT_MAX;\n    int second = INT_MAX;\n\n    for (int num : lst) {\n        if (num < first) {\n            second = first;\n            first = num;\n        } else if (num < second && num != first) {\n            second = num;\n        }\n    }\n\n    return second == INT_MAX ? std::nullopt : second; // Return None if no second smallest element is found\n}\n\n"}
{"task_id": "CPP/91", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nint is_bored(string S) {\n    int count = 0;\n    \n    // Use stringstream to split the string into sentences based on delimiters\n    stringstream ss(S);\n    string sentence;\n    \n    while (getline(ss, sentence, '.')) {\n        size_t pos = 0;\n        \n        // Find the first character of each sentence after removing leading spaces\n        while (pos < sentence.length() && isspace(sentence[pos])) ++pos;\n\n        // Check if the sentence starts with \"I\"\n        if (pos + 2 < sentence.length() && \n            tolower(sentence[pos]) == 'i' &&\n            tolower(sentence[pos+1]) == ' ' &&\n            pos + 3 < sentence.length() && \n            tolower(sentence[pos+2]) != ' ') {\n            \n            count++;\n        }\n        \n        // Handle other delimiters\n        while (getline(ss, sentence, '?')) {\n            size_t pos = 0;\n            while (pos < sentence.length() && isspace(sentence[pos])) ++pos;\n\n            if (pos + 2 < sentence.length() &&\n                tolower(sentence[pos]) == 'i' &&\n                tolower(sentence[pos+1]) == ' ' &&\n                pos + 3 < sentence.length() && \n                tolower(sentence[pos+2]) != ' ') {\n                \n                count++;\n            }\n        }\n\n        while (getline(ss, sentence, '!')) {\n            size_t pos = 0;\n            while (pos < sentence.length() && isspace(sentence[pos])) ++pos;\n\n            if (pos + 2 < sentence.length() &&\n                tolower(sentence[pos]) == 'i' &&\n                tolower(sentence[pos+1]) == ' ' &&\n                pos + 3 < sentence.length() && \n                tolower(sentence[pos+2]) != ' ') {\n                \n                count++;\n            }\n        }\n    }\n\n    return count;\n}\n\n"}
{"task_id": "CPP/92", "generation": "#include <stdio.h>\nusing namespace std;\n\nbool any_int(float a, float b, float c) {\n    // Convert floats to integers by truncating the decimal part.\n    int ia = static_cast<int>(a);\n    int ib = static_cast<int>(b);\n    int ic = static_cast<int>(c);\n\n    // Check if all numbers are integers\n    if (a != static_cast<float>(ia) || b != static_cast<float>(ib) || c != static_cast<float>(ic)) {\n        return false;\n    }\n\n    // Check if any number is the sum of the other two\n    return (ia == ib + ic) || (ib == ia + ic) || (ic == ia + ib);\n}\n\n"}
{"task_id": "CPP/93", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\n// Function to encode a message by swapping cases and replacing vowels\nstring encode(string message) {\n    // Define vowels and their corresponding replacements\n    string vowels = \"aeiouAEIOU\";\n    string replacement_vowels = \"cefgiCEFGI\";\n\n    for (char &c : message) {\n        if (isalpha(c)) {  // Check if the character is a letter\n            c = islower(c) ? toupper(c) : tolower(c);  // Swap case\n\n            // Find the vowel and replace it with its corresponding replacement\n            size_t index = vowels.find(c);\n            if (index != string::npos) {\n                c = replacement_vowels[index];\n            }\n        }\n    }\n\n    return message;\n}\n\n"}
{"task_id": "CPP/94", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Function to check if a number is prime\nbool isPrime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\n// Function to calculate the sum of digits of a number\nint sumOfDigits(int num) {\n    int sum = 0;\n    while (num > 0) {\n        sum += num % 10;\n        num /= 10;\n    }\n    return sum;\n}\n\n// Main function to find the largest prime and return the sum of its digits\nint findLargestPrimeSum(vector<int> lst) {\n    int maxPrime = -1; // Initialize with a non-prime number\n\n    for (int num : lst) {\n        if (isPrime(num)) {\n            if (num > maxPrime) {\n                maxPrime = num;\n            }\n        }\n    }\n\n    if (maxPrime == -1) return 0; // No prime numbers found\n    else return sumOfDigits(maxPrime);\n}\n\n// Function to test the solution with provided examples\nvoid check() {\n    vector<int> lst1 = {0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3};\n    cout << findLargestPrimeSum(lst1) << endl; // Output: 10\n\n    vector<int> lst2 = {1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1};\n    cout << findLargestPrimeSum(lst2) << endl; // Output: 25\n\n    vector<int> lst3 = {1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3};\n    cout << findLargestPrimeSum(lst3) << endl; // Output: 13\n\n    vector<int> lst4 = {0,724,32,71,99,32,6,0,5,91,83,0,5,6};\n    cout << findLargestPrimeSum(lst4) << endl; // Output: 11\n\n    vector<int> lst5 = {0,81,12,3,1,21};\n    cout << findLargestPrimeSum(lst5) << endl; // Output: 3\n\n    vector<int> lst6 = {0,8,1,2,1,7};\n    cout << findLargestPrimeSum(lst6) << endl; // Output: 7\n}\n\n"}
{"task_id": "CPP/95", "generation": "#include <iostream>\n#include <string>\n#include <map>\n\nusing namespace std;\n\nbool check_dict_case(map<string, string> dict) {\n    // Check if the map is empty\n    if (dict.empty()) {\n        return false;\n    }\n\n    // Determine the case of the first key\n    bool allLower = true;\n    bool allUpper = true;\n\n    for (const auto &pair : dict) {\n        const string &key = pair.first;\n        if (!islower(key[0])) {\n            allLower = false;\n        }\n        if (!isupper(key[0])) {\n            allUpper = false;\n        }\n\n        // If both cases are mixed, return false\n        if (!allLower && !allUpper) {\n            return false;\n        }\n    }\n\n    // Return true if either all keys are in lowercase or all keys are in uppercase\n    return allLower || allUpper;\n}\n\n// Function to test the check_dict_case function with provided examples\nvoid test_check_dict_case() {\n    cout << boolalpha; // Print bools as true/false instead of 1/0\n    cout << \"check_dict_case({\\\"a\\\",\\\"apple\\\"}, {\\\"b\\\",\\\"banana\\\"}): \" \n         << check_dict_case({{\"a\", \"apple\"}, {\"b\", \"banana\"}}) << endl;\n    cout << \"check_dict_case({\\\"a\\\",\\\"apple\\\"}, {\\\"A\\\",\\\"banana\\\"}, {\\\"B\\\",\\\"banana\\\"}): \"\n         << check_dict_case({{\"a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}) << endl;\n    cout << \"check_dict_case({\\\"a\\\",\\\"apple\\\"}, {\\\"8\\\",\\\"banana\\\"}, {\\\"a\\\",\\\"apple\\\"}): \"\n         << check_dict_case({{\"a\", \"apple\"}, {\"8\", \"banana\"}, {\"a\", \"apple\"}}) << endl;\n    cout << \"check_dict_case({\\\"Name\\\",\\\"John\\\"}, {\\\"Age\\\",\\\"36\\\"}, {\\\"City\\\",\\\"Houston\\\"}): \"\n         << check_dict_case({{\"Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}) << endl;\n    cout << \"check_dict_case({\\\"STATE\\\",\\\"NC\\\"}, {\\\"ZIP\\\",\\\"12345\\\"}): \"\n         << check_dict_case({{\"STATE\", \"NC\"}, {\"ZIP\", \"12345\"}}) << endl;\n}\n\n"}
{"task_id": "CPP/96", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Helper function to check if a number is prime\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    for (int i = 2; i * i <= num; ++i) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\n// Function to generate a vector of prime numbers less than n\nvector<int> count_up_to(int n) {\n    vector<int> primes;\n    for (int i = 2; i < n; ++i) {\n        if (is_prime(i)) {\n            primes.push_back(i);\n        }\n    }\n    return primes;\n}\n\n// Function to test the count_up_to function\nvoid test_count_up_to() {\n    assert(count_up_to(5) == vector<int>({2, 3}));\n    assert(count_up_to(11) == vector<int>({2, 3, 5, 7}));\n    assert(count_up_to(0).empty());\n    assert(count_up_to(20) == vector<int>({2, 3, 5, 7, 11, 13, 17, 19}));\n    assert(count_up_to(1).empty());\n    assert(count_up_to(18) == vector<int>({2, 3, 5, 7, 11, 13, 17}));\n\n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/97", "generation": "#include <iostream>\nusing namespace std;\n\nint multiply(int a, int b) {\n    // Extract the unit digit of each number\n    int unitDigitA = abs(a % 10);\n    int unitDigitB = abs(b % 10);\n\n    // Multiply the unit digits and return the result\n    return unitDigitA * unitDigitB;\n}\n\n"}
{"task_id": "CPP/98", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint count_upper(string s) {\n    int count = 0;\n    // Iterate over the string with a step of 2 to check only even indices\n    for (size_t i = 0; i < s.length(); i += 2) {\n        char c = s[i];\n        // Check if the character is an uppercase vowel\n        if (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n            count++;\n        }\n    }\n    return count;\n}\n\n"}
{"task_id": "CPP/99", "generation": "#include <iostream>\n#include <cmath>\n#include <string>\nusing namespace std;\n\nint closest_integer(string value) {\n    // Convert the string to a floating-point number\n    double num = stod(value);\n\n    // Determine if the number is exactly halfway between two integers\n    double fractional_part = modf(num, &num);\n    int integer_part = static_cast<int>(num);\n\n    // Check if the number is equidistant from two integers\n    if (abs(fractional_part) == 0.5) {\n        // Round away from zero\n        return num > 0 ? ceil(num) : floor(num);\n    } else {\n        // Use standard rounding rules\n        return round(num);\n    }\n}\n\n"}
{"task_id": "CPP/100", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> make_a_pile(int n) {\n    vector<int> pile;\n    \n    // Start with the initial number of stones in the first level.\n    int current_stones = n;\n    \n    for (int i = 0; i < n; ++i) {\n        pile.push_back(current_stones);\n        \n        // Determine the next number of stones:\n        // If the current number is odd, add 2 to get the next even number.\n        // If the current number is even, add 2 to get the next odd number.\n        if (current_stones % 2 == 0) {\n            current_stones += 2;\n        } else {\n            current_stones += 2;\n        }\n    }\n    \n    return pile;\n}\n\n// Function to check the correctness of the make_a_pile function\nvoid check() {\n    vector<int> result = make_a_pile(3);\n    assert(result == vector<int>({3, 5, 7}));\n    \n    result = make_a_pile(4);\n    assert(result == vector<int>({4, 6, 8, 10}));\n    \n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/101", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nvector<string> words_string(const string& s) {\n    vector<string> result;\n    stringstream ss(s);\n    string word;\n\n    while (getline(ss, word, ',')) {  // Split by comma first\n        stringstream wordStream(word);  // Create a stream for the current word\n        while (wordStream >> word) {  // Extract words from the current word stream\n            result.push_back(word);\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/102", "generation": "#include <iostream>\nusing namespace std;\n\nint choose_num(int x, int y) {\n    // Check if the upper bound is less than the lower bound\n    if (y < x) {\n        return -1;\n    }\n\n    // Start from the upper bound and check downwards for the largest even number\n    for (int i = y; i >= x; --i) {\n        if (i % 2 == 0) {\n            return i;\n        }\n    }\n\n    // If no even number is found, return -1\n    return -1;\n}\n\n// Function to test the choose_num function with some examples\nvoid test() {\n    cout << \"choose_num(12, 15): \" << choose_num(12, 15) << endl; // Should output 14\n    cout << \"choose_num(13, 12): \" << choose_num(13, 12) << endl; // Should output -1\n    cout << \"choose_num(8, 10): \" << choose_num(8, 10) << endl;   // Should output 10\n    cout << \"choose_num(9, 7): \" << choose_num(9, 7) << endl;     // Should output -1\n}\n\n"}
{"task_id": "CPP/103", "generation": "#include <stdio.h>\n#include <cmath>\n#include <string>\n\nusing namespace std;\n\nstring rounded_avg(int n, int m) {\n    // Check if n is greater than m\n    if (n > m) {\n        return \"-1\";\n    }\n\n    // Calculate the sum of integers from n to m\n    long long sum = 0;\n    for (int i = n; i <= m; ++i) {\n        sum += i;\n    }\n\n    // Calculate the average and round it to the nearest integer (towards the smaller one)\n    int avg = floor((double)(sum + (m - n + 1) / 2) / (m - n + 1));\n\n    // Convert the rounded average to binary\n    string binary_avg;\n    if (avg == 0) {\n        binary_avg = \"0\";\n    } else {\n        while (avg > 0) {\n            binary_avg = to_string(avg % 2) + binary_avg;\n            avg /= 2;\n        }\n    }\n\n    return binary_avg;\n}\n\n"}
{"task_id": "CPP/104", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n// Helper function to check if a number has any even digit\nbool has_even_digit(int num) {\n    while (num > 0) {\n        int digit = num % 10;\n        if (digit % 2 == 0) return true; // If any digit is even, return true\n        num /= 10;\n    }\n    return false; // No even digits found\n}\n\n// Function to return a sorted vector of all elements that have no even digit\nvector<int> unique_digits(vector<int> x) {\n    vector<int> result;\n\n    // Filter out numbers with any even digit\n    for (int num : x) {\n        if (!has_even_digit(num)) {\n            result.push_back(num);\n        }\n    }\n\n    // Sort the resulting vector in increasing order\n    sort(result.begin(), result.end());\n\n    return result;\n}\n\n// Function to print the vector\nvoid print_vector(const vector<int>& vec) {\n    for (int num : vec) {\n        cout << num << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/105", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to convert a number to its corresponding word\nstring num_to_word(int n) {\n    map<int, string> digit_names = {\n        {1, \"One\"}, {2, \"Two\"}, {3, \"Three\"},\n        {4, \"Four\"}, {5, \"Five\"}, {6, \"Six\"},\n        {7, \"Seven\"}, {8, \"Eight\"}, {9, \"Nine\"}\n    };\n    \n    return digit_names[n];\n}\n\nvector<string> by_length(vector<int> arr) {\n    // Step 1: Filter out numbers not between 1 and 9\n    vector<int> filtered;\n    for (int num : arr) {\n        if (num >= 1 && num <= 9) {\n            filtered.push_back(num);\n        }\n    }\n\n    // Step 2: Sort the filtered numbers in ascending order\n    sort(filtered.begin(), filtered.end());\n\n    // Step 3: Reverse the sorted vector\n    reverse(filtered.begin(), filtered.end());\n\n    // Step 4: Replace each digit with its corresponding word\n    vector<string> result;\n    for (int num : filtered) {\n        result.push_back(num_to_word(num));\n    }\n\n    return result;\n}\n\n// Function to print the vector of strings\nvoid print_vector(const vector<string>& vec) {\n    if (vec.empty()) {\n        cout << \"{}\" << endl;\n    } else {\n        cout << \"{\";\n        for (size_t i = 0; i < vec.size(); ++i) {\n            cout << vec[i];\n            if (i != vec.size() - 1) {\n                cout << \", \";\n            }\n        }\n        cout << \"}\" << endl;\n    }\n}\n\n"}
{"task_id": "CPP/106", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Function to compute the factorial of a number\nint factorial(int n) {\n    if (n == 0 || n == 1) return 1;\n    int result = 1;\n    for (int i = 2; i <= n; ++i) {\n        result *= i;\n    }\n    return result;\n}\n\n// Function to compute the sum of numbers from 1 to n\nint sumToN(int n) {\n    return (n * (n + 1)) / 2;\n}\n\nvector<int> f(int n) {\n    vector<int> result(n);\n    for (int i = 0; i < n; ++i) {\n        if ((i + 1) % 2 == 0) { // Check if the index is even\n            result[i] = factorial(i + 1);\n        } else { // The index is odd\n            result[i] = sumToN(i + 1);\n        }\n    }\n    return result;\n}\n\n"}
{"task_id": "CPP/107", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nbool is_palindrome(int num) {\n    string str = to_string(num);\n    int left = 0;\n    int right = str.length() - 1;\n    while (left < right) {\n        if (str[left] != str[right]) {\n            return false;\n        }\n        ++left;\n        --right;\n    }\n    return true;\n}\n\nvector<int> even_odd_palindrome(int n) {\n    vector<int> result(2, 0); // Initialize with two elements for even and odd counts\n    for (int i = 1; i <= n; ++i) {\n        if (is_palindrome(i)) {\n            if (i % 2 == 0) {\n                ++result[0]; // Even palindrome count\n            } else {\n                ++result[1]; // Odd palindrome count\n            }\n        }\n    }\n    return result;\n}\n\n"}
{"task_id": "CPP/108", "generation": "#include <iostream>\n#include <vector>\n\n// Function to calculate the sum of digits of a number\nint sum_of_digits(int num) {\n    int sum = 0;\n    bool isNegative = num < 0;\n\n    // Handle negative numbers by making them positive and then processing\n    if (isNegative) {\n        num = -num;\n    }\n\n    while (num > 0) {\n        sum += num % 10;  // Add the last digit to sum\n        num /= 10;        // Remove the last digit\n    }\n\n    return isNegative ? -sum : sum;  // Return negative if original number was negative, otherwise positive\n}\n\n// Function to count numbers with a sum of digits greater than zero\nint count_nums(const std::vector<int>& n) {\n    int count = 0;\n\n    for (int num : n) {\n        if (sum_of_digits(num) > 0) {\n            ++count;\n        }\n    }\n\n    return count;\n}\n\n// Function to test the count_nums function with provided examples\nvoid test() {\n    std::cout << \"Test cases:\" << std::endl;\n    std::vector<int> empty = {};\n    std::vector<int> nums1 = {-1, 11, -11};\n    std::vector<int> nums2 = {1, 1, 2};\n\n    std::cout << \"count_nums({}) == \" << count_nums(empty) << \" (Expected: 0)\" << std::endl;\n    std::cout << \"count_nums({-1, 11, -11}) == \" << count_nums(nums1) << \" (Expected: 1)\" << std::endl;\n    std::cout << \"count_nums({1, 1, 2}) == \" << count_nums(nums2) << \" (Expected: 3)\" << std::endl;\n}\n\n"}
{"task_id": "CPP/109", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool move_one_ball(vector<int> arr) {\n    // If the vector is empty, return true\n    if (arr.empty()) {\n        return true;\n    }\n\n    int n = arr.size();\n    \n    // Find the index where a shift would make the array sorted\n    for (int i = 0; i < n - 1; ++i) {\n        if (arr[i] > arr[i + 1]) {\n            // Check if performing one right shift starting from this point makes it sorted\n            bool is_sorted = true;\n            for (int j = 0; j < n - 1; ++j) {\n                int shifted_index = (i + j) % n;\n                if (arr[shifted_index] > arr[(i + j + 1) % n]) {\n                    is_sorted = false;\n                    break;\n                }\n            }\n            if (is_sorted) {\n                return true;\n            }\n        }\n    }\n\n    // If no such shift can make the array sorted, return false\n    return false;\n}\n\n// Function to test the move_one_ball function with provided examples\nvoid test() {\n    assert(move_one_ball({3, 4, 5, 1, 2}) == true);\n    assert(move_one_ball({3, 5, 4, 1, 2}) == false);\n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/110", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring exchange(vector<int> lst1, vector<int> lst2) {\n    int oddCount = 0;\n    \n    // Count how many odd numbers are there in lst1\n    for (int num : lst1) {\n        if (num % 2 != 0) {\n            oddCount++;\n        }\n    }\n\n    // Check if there are enough even numbers in lst2 to replace all odd numbers in lst1\n    int evenCount = 0;\n    for (int num : lst2) {\n        if (num % 2 == 0) {\n            evenCount++;\n        }\n    }\n\n    return (oddCount <= evenCount) ? \"YES\" : \"NO\";\n}\n\n// Function to test the exchange function with given examples\nvoid testExchange() {\n    vector<int> lst1 = {1, 2, 3, 4};\n    vector<int> lst2 = {1, 2, 3, 4};\n    cout << \"exchange({1, 2, 3, 4}, {1, 2, 3, 4}) => \" << exchange(lst1, lst2) << endl;\n\n    lst1 = {1, 2, 3, 4};\n    lst2 = {1, 5, 3, 4};\n    cout << \"exchange({1, 2, 3, 4}, {1, 5, 3, 4}) => \" << exchange(lst1, lst2) << endl;\n}\n\n"}
{"task_id": "CPP/111", "generation": "#include <iostream>\n#include <string>\n#include <map>\n#include <vector>\nusing namespace std;\n\nmap<char, int> histogram(string test) {\n    map<char, int> letterCount;\n    \n    // Count occurrences of each character\n    for (char c : test) {\n        if (c != ' ') {  // Ignore spaces\n            letterCount[c]++;\n        }\n    }\n\n    // Find the maximum count\n    int maxCount = 0;\n    for (const auto& pair : letterCount) {\n        if (pair.second > maxCount) {\n            maxCount = pair.second;\n        }\n    }\n\n    // Collect all letters that have the maximum count\n    map<char, int> result;\n    for (const auto& pair : letterCount) {\n        if (pair.second == maxCount) {\n            result.insert(pair);\n        }\n    }\n\n    return result;\n}\n\n// Function to test the histogram function with some examples\nvoid testHistogram() {\n    cout << \"histogram(\\\"a b c\\\") == {\";\n    for (const auto& pair : histogram(\"a b c\")) {\n        cout << \"{\" << pair.first << \", \" << pair.second << \"}\";\n    }\n    cout << \"}\\n\";\n\n    cout << \"histogram(\\\"a b b a\\\") == {\";\n    for (const auto& pair : histogram(\"a b b a\")) {\n        cout << \"{\" << pair.first << \", \" << pair.second << \"}\";\n    }\n    cout << \"}\\n\";\n\n    cout << \"histogram(\\\"a b c a b\\\") == {\";\n    for (const auto& pair : histogram(\"a b c a b\")) {\n        cout << \"{\" << pair.first << \", \" << pair.second << \"}\";\n    }\n    cout << \"}\\n\";\n\n    cout << \"histogram(\\\"b b b b a\\\") == {\";\n    for (const auto& pair : histogram(\"b b b b a\")) {\n        cout << \"{\" << pair.first << \", \" << pair.second << \"}\";\n    }\n    cout << \"}\\n\";\n\n    cout << \"histogram(\\\"\\\") == {\";\n    for (const auto& pair : histogram(\"\")) {\n        cout << \"{\" << pair.first << \", \" << pair.second << \"}\";\n    }\n    cout << \"}\\n\";\n}\n\n"}
{"task_id": "CPP/112", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to check if a string is a palindrome\nbool is_palindrome(const string& str) {\n    int left = 0;\n    int right = str.size() - 1;\n    \n    while (left < right) {\n        if (str[left] != str[right]) {\n            return false;\n        }\n        ++left;\n        --right;\n    }\n    return true;\n}\n\n// Function to reverse_delete\nvector<string> reverse_delete(string s, string c) {\n    // Remove characters in s that are present in c\n    for (char ch : c) {\n        s.erase(remove(s.begin(), s.end(), ch), s.end());\n    }\n\n    // Check if the resulting string is a palindrome\n    bool result = is_palindrome(s);\n\n    // Return the result as a vector containing the modified string and the boolean\n    return {s, to_string(result)};\n}\n\n"}
{"task_id": "CPP/113", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<string> odd_count(vector<string> lst) {\n    vector<string> result;\n    \n    for (const string& str : lst) {\n        int count = 0;\n        \n        // Count the number of odd digits in the current string\n        for (char c : str) {\n            if ((c - '0') % 2 != 0) {\n                count++;\n            }\n        }\n        \n        // Construct the result string with the appropriate replacements\n        string output = \"the number of odd elements \";\n        output += to_string(count);\n        output += \"n the str\";\n        output += to_string(count);\n        output += \"ng \";\n        output += to_string(count);\n        output += \" of the \";\n        output += to_string(count);\n        output += \"nput.\";\n        \n        result.push_back(output);\n    }\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/114", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nlong long minSubArraySum(vector<long long> nums) {\n    if (nums.empty()) return 0; // Handle empty vector case\n\n    long long current_sum = nums[0];\n    long long min_sum = nums[0];\n\n    for (size_t i = 1; i < nums.size(); ++i) {\n        // If current sum becomes negative, start from the current element\n        current_sum = min(nums[i], current_sum + nums[i]);\n        min_sum = min(min_sum, current_sum);\n    }\n\n    return min_sum;\n}\n\n"}
{"task_id": "CPP/115", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint max_fill(vector<vector<int>> grid, int capacity) {\n    int total_lowers = 0;\n    \n    // Iterate over each well (row in the grid)\n    for (const auto& row : grid) {\n        int water_in_well = 0;\n        \n        // Count the number of 1s in the current well\n        for (int cell : row) {\n            if (cell == 1) {\n                ++water_in_well;\n            }\n        }\n        \n        // Calculate how many times this well needs to be emptied\n        int lowers_needed = (water_in_well + capacity - 1) / capacity; // Ceiling division\n        \n        total_lowers += lowers_needed;\n    }\n    \n    return total_lowers;\n}\n\n"}
{"task_id": "CPP/116", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\n// Function to count the number of 1s in the binary representation of a number\nint countOnes(int n) {\n    int count = 0;\n    while (n > 0) {\n        count += n & 1; // Check if the least significant bit is set\n        n >>= 1; // Right shift to check the next bit\n    }\n    return count;\n}\n\n// Comparator function for sorting based on number of ones and then by decimal value\nbool compare(int a, int b) {\n    int onesA = countOnes(a);\n    int onesB = countOnes(b);\n\n    if (onesA == onesB) {\n        return a < b; // If the number of ones is the same, sort by decimal value\n    }\n    return onesA < onesB; // Otherwise, sort based on the number of ones\n}\n\n// Function to sort the array according to the given criteria\nstd::vector<int> sort_array(std::vector<int> arr) {\n    std::sort(arr.begin(), arr.end(), compare);\n    return arr;\n}\n\n"}
{"task_id": "CPP/117", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nbool is_consonant(char c) {\n    // Convert character to lowercase for simplicity\n    char lower_c = tolower(c);\n    return (lower_c >= 'a' && lower_c <= 'z') && !(lower_c == 'a' || lower_c == 'e' || lower_c == 'i' || lower_c == 'o' || lower_c == 'u');\n}\n\nvector<string> select_words(string s, int n) {\n    vector<string> result;\n    string word = \"\";\n    \n    // Split the string into words\n    for (char c : s) {\n        if (c == ' ') {\n            if (!word.empty()) {\n                // Count consonants in the current word\n                int count_consonants = count_if(word.begin(), word.end(), is_consonant);\n                \n                // If the count matches n, add to result\n                if (count_consonants == n) {\n                    result.push_back(word);\n                }\n                \n                word.clear();\n            }\n        } else {\n            word += c;\n        }\n    }\n\n    // Check the last word in case there's no space at the end of the string\n    if (!word.empty()) {\n        int count_consonants = count_if(word.begin(), word.end(), is_consonant);\n        \n        if (count_consonants == n) {\n            result.push_back(word);\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/118", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_vowel(char c) {\n    return tolower(c) == 'a' || tolower(c) == 'e' || tolower(c) == 'i' || \n           tolower(c) == 'o' || tolower(c) == 'u';\n}\n\nbool is_consonant(char c) {\n    return !is_vowel(c) && isalpha(c);\n}\n\nstring get_closest_vowel(string word) {\n    int n = word.length();\n    \n    // Start from the second last character and move towards the beginning\n    for (int i = n - 2; i >= 0; --i) {\n        if (is_consonant(word[i]) && is_consonant(word[i + 1])) {\n            // Check if the current character is a vowel\n            if (is_vowel(word[i])) {\n                return string(1, word[i]);\n            }\n        }\n    }\n\n    // If no such vowel is found, return an empty string\n    return \"\";\n}\n\n"}
{"task_id": "CPP/119", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Helper function to count open and close parentheses in a string\npair<int, int> count_parens(const string& s) {\n    int open = 0;\n    int close = 0;\n    for (char c : s) {\n        if (c == '(') open++;\n        else if (c == ')') close++;\n    }\n    return {open, close};\n}\n\n// Function to check if a string is balanced\nbool is_balanced(const string& s) {\n    int balance = 0;\n    for (char c : s) {\n        if (c == '(') balance++;\n        else if (c == ')') balance--;\n        if (balance < 0) return false; // Early exit if unbalanced\n    }\n    return balance == 0;\n}\n\n// Main function to check if concatenation of two strings can form a balanced string\nstring match_parens(vector<string> lst) {\n    auto [open1, close1] = count_parens(lst[0]);\n    auto [open2, close2] = count_parens(lst[1]);\n\n    // Check both possible concatenations\n    if (is_balanced(lst[0] + lst[1]) || is_balanced(lst[1] + lst[0])) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\n\n"}
{"task_id": "CPP/120", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n// Function to return a vector of length k with the maximum k numbers from arr, in ascending order.\nvector<int> maximum(vector<int> arr, int k) {\n    // Sort the array first (optional but useful for understanding)\n    sort(arr.begin(), arr.end());\n    \n    // Use nth_element to find the k-th largest element\n    nth_element(arr.begin(), arr.begin() + k - 1, arr.end(), greater<int>());\n    \n    // Create a new vector of size k and copy the top k elements from arr into it\n    vector<int> result;\n    for (int i = 0; i < k; ++i) {\n        result.push_back(arr[i]);\n    }\n    \n    // Sort the result in ascending order\n    sort(result.begin(), result.end());\n    \n    return result;\n}\n\n// Function to print a vector\nvoid printVector(const vector<int>& vec) {\n    for (int num : vec) {\n        cout << num << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/121", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Function to sum all the odd elements in even positions\nint solution(vector<int> lst) {\n    int sum = 0;\n    for (size_t i = 0; i < lst.size(); ++i) {\n        // Check if the index is even and the element at that position is odd\n        if (i % 2 == 0 && lst[i] % 2 != 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n\n// Function to test the solution with provided examples\nvoid check() {\n    assert(solution({5, 8, 7, 1}) == 12);\n    assert(solution({3, 3, 3, 3, 3}) == 9);\n    assert(solution({30, 13, 24, 321}) == 0);\n    cout << \"All test cases passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/122", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint add_elements(vector<int> arr, int k) {\n    int sum = 0;\n    \n    // Iterate through the first k elements of the array\n    for (int i = 0; i < k; ++i) {\n        // Check if the current element has at most two digits\n        if (arr[i] >= -99 && arr[i] <= 99) {\n            sum += arr[i];\n        }\n    }\n    \n    return sum;\n}\n\n// Function to test the add_elements function with provided data points\nvoid test_function() {\n    vector<int> arr1 = {111, 21, 3, 4000, 5, 6, 7, 8, 9};\n    int k1 = 4;\n    cout << \"Test Case 1: Expected Output: 24, Actual Output: \" << add_elements(arr1, k1) << endl;\n\n    vector<int> arr2 = {10, -5, 30, 20, 40};\n    int k2 = 5;\n    cout << \"Test Case 2: Expected Output: 60, Actual Output: \" << add_elements(arr2, k2) << endl;\n\n    vector<int> arr3 = {100, -98, 97, -96, 95};\n    int k3 = 3;\n    cout << \"Test Case 3: Expected Output: -194, Actual Output: \" << add_elements(arr3, k3) << endl;\n\n    vector<int> arr4 = {0, 123, 456, 789};\n    int k4 = 4;\n    cout << \"Test Case 4: Expected Output: 0, Actual Output: \" << add_elements(arr4, k4) << endl;\n}\n\n"}
{"task_id": "CPP/123", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n// Function to generate and return the odd numbers in the Collatz sequence of n\nvector<int> get_odd_collatz(int n) {\n    vector<int> result;\n    \n    // Generate the Collatz sequence until it reaches 1\n    while (n != 1) {\n        if (n % 2 == 0) {\n            n = n / 2;  // If n is even, divide by 2\n        } else {\n            result.push_back(n);  // If n is odd, add to the result vector\n            n = 3 * n + 1;        // Apply the Collatz transformation\n        }\n    }\n    \n    // Add the final number 1 to the result vector\n    result.push_back(1);\n    \n    // Sort the result vector in increasing order\n    sort(result.begin(), result.end());\n    \n    return result;\n}\n\n// Function to check the correctness of the get_odd_collatz function\nvoid check() {\n    vector<int> expected = {1, 5};\n    vector<int> result = get_odd_collatz(5);\n    if (result == expected) {\n        cout << \"Test passed for n = 5\" << endl;\n    } else {\n        cout << \"Test failed for n = 5. Expected: \";\n        for (int num : expected) {\n            cout << num << \" \";\n        }\n        cout << \"\\nGot: \";\n        for (int num : result) {\n            cout << num << \" \";\n        }\n        cout << endl;\n    }\n\n    vector<int> expected2 = {1, 3};\n    vector<int> result2 = get_odd_collatz(6);\n    if (result2 == expected2) {\n        cout << \"Test passed for n = 6\" << endl;\n    } else {\n        cout << \"Test failed for n = 6. Expected: \";\n        for (int num : expected2) {\n            cout << num << \" \";\n        }\n        cout << \"\\nGot: \";\n        for (int num : result2) {\n            cout << num << \" \";\n        }\n        cout << endl;\n    }\n}\n\n"}
{"task_id": "CPP/124", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool valid_date(string date) {\n    // Check if the date string is in the correct format mm-dd-yyyy\n    size_t pos = 0;\n    int month, day, year;\n    \n    // Extract month\n    pos = date.find(\"-\");\n    if (pos == string::npos || pos != 2) return false;\n    month = stoi(date.substr(0, pos));\n    \n    // Extract day\n    pos = date.find(\"-\", pos + 1);\n    if (pos == string::npos || pos != 5) return false;\n    day = stoi(date.substr(pos - 3, 2));\n    \n    // Extract year\n    year = stoi(date.substr(pos + 1));\n    \n    // Validate month\n    if (month < 1 || month > 12) return false;\n    \n    // Validate day based on the month\n    bool is_leap_year = (year % 4 == 0 && (year % 100 != 0 || year % 400 == 0));\n    int max_days[12] = {31, 28 + is_leap_year, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\n    \n    if (day < 1 || day > max_days[month - 1]) return false;\n    \n    // If all validations pass\n    return true;\n}\n\n"}
{"task_id": "CPP/125", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to count lowercase letters with odd order in the alphabet\nint countOddOrderLowercaseLetters(const string& str) {\n    int count = 0;\n    for (char c : str) {\n        if (islower(c)) {\n            int letterValue = static_cast<int>(c - 'a');\n            if (letterValue % 2 == 1) {\n                count++;\n            }\n        }\n    }\n    return count;\n}\n\n// Function to split the string based on whitespace or commas\nvector<string> split_words(const string& txt) {\n    vector<string> result;\n\n    // Check for whitespace and split by it\n    size_t start = 0, end = txt.find(' ');\n    while (end != string::npos) {\n        if (start < end) {\n            result.push_back(txt.substr(start, end - start));\n        }\n        start = end + 1;\n        end = txt.find(' ', start);\n    }\n\n    // Check for commas and split by it\n    if (start < txt.size()) {\n        string lastPart = txt.substr(start);\n        size_t commaPos = lastPart.find(',');\n        while (commaPos != string::npos) {\n            result.push_back(lastPart.substr(0, commaPos));\n            start = commaPos + 1;\n            commaPos = lastPart.find(',', start);\n        }\n        if (start < lastPart.size()) {\n            result.push_back(lastPart.substr(start));\n        }\n    }\n\n    // If no whitespace or commas are found, count lowercase letters with odd order\n    if (result.empty()) {\n        return {to_string(countOddOrderLowercaseLetters(txt))};\n    }\n\n    return result;\n}\n\n// Function to test the split_words function\nvoid test_split_words() {\n    assert(split_words(\"Hello world!\") == vector<string>{\"Hello\", \"world!\"});\n    assert(split_words(\"Hello,world!\") == vector<string>{\"Hello\", \"world!\"});\n    assert(split_words(\"abcdef\") == vector<string>{\"3\"});\n    cout << \"All tests passed.\" << endl;\n}\n\n"}
{"task_id": "CPP/126", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nbool is_sorted(vector<int> lst) {\n    // Check if the vector is sorted in ascending order\n    for (int i = 1; i < lst.size(); ++i) {\n        if (lst[i] < lst[i - 1]) {\n            return false;\n        }\n    }\n\n    // Check if any number appears more than twice\n    int count[1001] = {0}; // Assuming the maximum possible value is less than or equal to 1000\n    for (int num : lst) {\n        if (++count[num] > 2) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\n// Function to test the is_sorted function with provided examples\nvoid check() {\n    assert(is_sorted({5}) == true);\n    assert(is_sorted({1, 2, 3, 4, 5}) == true);\n    assert(is_sorted({1, 3, 2, 4, 5}) == false);\n    assert(is_sorted({1, 2, 3, 4, 5, 6}) == true);\n    assert(is_sorted({1, 2, 3, 4, 5, 6, 7}) == true);\n    assert(is_sorted({1, 3, 2, 4, 5, 6, 7}) == false);\n    assert(is_sorted({1, 2, 2, 3, 3, 4}) == true);\n    assert(is_sorted({1, 2, 2, 2, 3, 4}) == false);\n\n    cout << \"All tests passed.\" << endl;\n}\n\n"}
{"task_id": "CPP/127", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\n// Function to check if a number is prime\nbool isPrime(int n) {\n    if (n <= 1) return false;\n    if (n == 2 || n == 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    for (int i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0)\n            return false;\n    }\n    return true;\n}\n\n// Function to find the intersection of two intervals and check if its length is prime\nstring intersection(vector<int> interval1, vector<int> interval2) {\n    int start = max(interval1[0], interval2[0]);\n    int end = min(interval1[1], interval2[1]);\n\n    // Check if there is an intersection\n    if (start > end) return \"NO\";\n\n    // Calculate the length of the intersection\n    int length = end - start + 1;\n\n    // Check if the length is a prime number\n    if (isPrime(length)) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n\n"}
{"task_id": "CPP/128", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint prod_signs(vector<int> arr) {\n    if (arr.empty()) {\n        return -32768;\n    }\n\n    int sum_of_magnitudes = 0;\n    int product_of_signs = 1;\n\n    for (int num : arr) {\n        // Calculate the magnitude\n        sum_of_magnitudes += abs(num);\n\n        // Calculate the product of signs\n        if (num > 0) {\n            product_of_signs *= 1;\n        } else if (num < 0) {\n            product_of_signs *= -1;\n        } else { // num == 0\n            product_of_signs = 0;\n            break; // If any number is zero, the product of signs will be zero.\n        }\n    }\n\n    return sum_of_magnitudes * product_of_signs;\n}\n\n"}
{"task_id": "CPP/129", "generation": "#include <iostream>\n#include <vector>\n#include <map>\nusing namespace std;\n\nconst int MAXN = 10; // Assuming N <= 10 for simplicity\n\n// Directions: up, down, left, right\nint dx[] = {-1, 1, 0, 0};\nint dy[] = {0, 0, -1, 1};\n\nmap<pair<int, int>, map<int, vector<int>>> memo;\n\nvector<int> minPath(vector<vector<int>>& grid, int k) {\n    int N = grid.size();\n    // Memoization key: (current cell row, current cell col), remaining steps\n    return dfs(grid, 0, 0, k);\n}\n\nvector<int> dfs(vector<vector<int>>& grid, int x, int y, int k) {\n    if (memo.find({x, y}) != memo.end() && memo[{x, y}].find(k) != memo[{x, y}].end()) {\n        return memo[{x, y}][k];\n    }\n\n    vector<int> path = {grid[x][y]};\n    int N = grid.size();\n    \n    // Explore all 4 possible directions\n    for (int i = 0; i < 4; ++i) {\n        int nx = x + dx[i], ny = y + dy[i];\n        if (nx >= 0 && nx < N && ny >= 0 && ny < N) {\n            vector<int> nextPath = dfs(grid, nx, ny, k - 1);\n            if (nextPath.size() == k - 1) {\n                path.insert(path.end(), nextPath.begin(), nextPath.end());\n                break;\n            }\n        }\n    }\n\n    memo[{x, y}][k] = path;\n    return path;\n}\n\n"}
{"task_id": "CPP/130", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Function to compute the nth term of the Tribonacci sequence\nint tribonacci(int n) {\n    if (n == 0) return 3;\n    if (n == 1) return 1;\n    if (n % 2 == 0) return 1 + n / 2;\n\n    // Initialize base cases\n    int a = 3, b = 1, c;\n    for (int i = 2; i <= n; ++i) {\n        c = a + b + tribonacci(i - 1);\n        a = b;\n        b = c;\n    }\n    return c;\n}\n\n// Function to generate the first n+1 numbers of the Tribonacci sequence\nvector<int> tri(int n) {\n    vector<int> result(n + 1, 0);\n    \n    // Compute and store each term in the result vector\n    for (int i = 0; i <= n; ++i) {\n        result[i] = tribonacci(i);\n    }\n    \n    return result;\n}\n\n// Function to print the vector\nvoid printVector(const vector<int>& vec) {\n    for (int num : vec) {\n        cout << num << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/131", "generation": "#include <iostream>\nusing namespace std;\n\nint digits(int n) {\n    int product = 1;\n    bool hasOddDigit = false;\n\n    while (n > 0) {\n        int digit = n % 10; // Get the last digit of n\n        if (digit % 2 != 0) { // Check if the digit is odd\n            product *= digit; // Multiply it to the product\n            hasOddDigit = true;\n        }\n        n /= 10; // Remove the last digit from n\n    }\n\n    return hasOddDigit ? product : 0; // Return the product if there was at least one odd digit, otherwise return 0\n}\n\n"}
{"task_id": "CPP/132", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_nested(string str) {\n    int balance = 0;\n    bool hasNested = false;\n\n    for (char ch : str) {\n        if (ch == '[') {\n            balance++;\n            // Check if there's a nested pair before the current opening bracket\n            if (balance > 1 && !hasNested) {\n                hasNested = true;\n            }\n        } else if (ch == ']') {\n            balance--;\n            if (balance < 0) {\n                return false; // Unbalanced brackets\n            }\n        }\n    }\n\n    // Check if there's at least one nested pair and the string is balanced\n    return hasNested && balance == 0;\n}\n\n"}
{"task_id": "CPP/133", "generation": "#include <iostream>\n#include <vector>\n#include <cmath> // For ceil function\n\nusing namespace std;\n\nint sum_squares(vector<float> lst) {\n    int sum = 0;\n    for (float num : lst) {\n        float ceiling_num = ceil(num);\n        int squared_num = static_cast<int>(ceiling_num * ceiling_num);\n        sum += squared_num;\n    }\n    return sum;\n}\n\n// Function to test the correctness of the solution\nvoid check() {\n    assert(sum_squares({1, 2, 3}) == 14);\n    assert(sum_squares({1, 4, 9}) == 98);\n    assert(sum_squares({1, 3, 5, 7}) == 84);\n    assert(sum_squares({1.4f, 4.2f, 0.0f}) == 29);\n    assert(sum_squares({-2.4f, 1.0f, 1.0f}) == 6);\n}\n\n"}
{"task_id": "CPP/134", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool check_if_last_char_is_a_letter(string txt) {\n    // If the string is empty, return false\n    if (txt.empty()) {\n        return false;\n    }\n\n    // Remove trailing spaces from the string\n    while (!txt.empty() && txt.back() == ' ') {\n        txt.pop_back();\n    }\n\n    // Check if the last character is an alphabetical character\n    if (txt.empty()) {\n        return false;  // If there are no characters left after removing spaces, return false\n    }\n\n    char lastChar = txt.back();\n\n    // Check if the last character is a letter\n    return ('a' <= lastChar && lastChar <= 'z') || ('A' <= lastChar && lastChar <= 'Z');\n}\n\n"}
{"task_id": "CPP/135", "generation": "#include <vector>\nusing namespace std;\n\nint can_arrange(vector<int> arr) {\n    int n = arr.size();\n    \n    if (n <= 1) {\n        // If the vector has one or zero elements, there is no preceding element to compare with.\n        return -1;\n    }\n    \n    for (int i = n - 2; i >= 0; --i) {\n        if (arr[i] > arr[i + 1]) {\n            // Found an element that is not greater than or equal to its next element\n            return i;\n        }\n    }\n    \n    // If no such element was found, return -1\n    return -1;\n}\n\n// Example usage:\n"}
{"task_id": "CPP/136", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> largest_smallest_integers(vector<int> lst) {\n    int a = 0; // To store the largest negative integer\n    int b = 0; // To store the smallest positive integer\n\n    for (int num : lst) {\n        if (num > 0 && (b == 0 || num < b)) {\n            b = num;\n        } else if (num < 0 && (a == 0 || num > a)) {\n            a = num;\n        }\n    }\n\n    return {a, b};\n}\n\n// Function to test the solution with provided examples\nvoid check() {\n    vector<int> result1 = largest_smallest_integers({2, 4, 1, 3, 5, 7});\n    assert(result1 == vector<int>({0, 1}));\n\n    vector<int> result2 = largest_smallest_integers({});\n    assert(result2 == vector<int>({0, 0}));\n\n    vector<int> result3 = largest_smallest_integers({0});\n    assert(result3 == vector<int>({0, 0}));\n\n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/137", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <boost/any.hpp>\n\n// Function to convert string with comma as decimal separator to float\nfloat str_to_float(const std::string& str) {\n    size_t pos;\n    return std::stof(str, &pos); // Convert the string to a float\n}\n\nboost::any compare_one(boost::any a, boost::any b) {\n    if (a.type() == typeid(int)) {\n        int intA = std::any_cast<int>(a);\n        if (b.type() == typeid(int)) {\n            int intB = std::any_cast<int>(b);\n            return intA >= intB ? a : b;\n        } else if (b.type() == typeid(float)) {\n            float floatB = std::any_cast<float>(b);\n            return intA >= floatB ? a : b;\n        } else if (b.type() == typeid(std::string)) {\n            std::string strB = std::any_cast<std::string>(b);\n            float floatB = str_to_float(strB); // Convert string to float\n            return intA >= floatB ? a : b;\n        }\n    } else if (a.type() == typeid(float)) {\n        float floatA = std::any_cast<float>(a);\n        if (b.type() == typeid(int)) {\n            int intB = std::any_cast<int>(b);\n            return floatA >= intB ? a : b;\n        } else if (b.type() == typeid(float)) {\n            float floatB = std::any_cast<float>(b);\n            return floatA >= floatB ? a : b;\n        } else if (b.type() == typeid(std::string)) {\n            std::string strB = std::any_cast<std::string>(b);\n            float floatB = str_to_float(strB); // Convert string to float\n            return floatA >= floatB ? a : b;\n        }\n    } else if (a.type() == typeid(std::string)) {\n        std::string strA = std::any_cast<std::string>(a);\n        if (b.type() == typeid(int)) {\n            int intB = std::any_cast<int>(b);\n            float floatA = str_to_float(strA); // Convert string to float\n            return floatA >= intB ? a : b;\n        } else if (b.type() == typeid(float)) {\n            float floatB = std::any_cast<float>(b);\n            float floatA = str_to_float(strA); // Convert string to float\n            return floatA >= floatB ? a : b;\n        } else if (b.type() == typeid(std::string)) {\n            std::string strB = std::any_cast<std::string>(b);\n            float floatA = str_to_float(strA); // Convert both strings to floats for comparison\n            float floatB = str_to_float(strB);\n            return floatA >= floatB ? a : b;\n        }\n    }\n\n    return boost::none; // Return None if the types are not comparable or equal\n}\n\n"}
{"task_id": "CPP/138", "generation": "#include <iostream>\nusing namespace std;\n\nbool is_equal_to_sum_even(int n) {\n    // Check if n is less than 8 or not divisible by 2\n    if (n < 8 || n % 2 != 0) {\n        return false;\n    }\n    \n    // If n is at least 8 and even, it can be written as the sum of four positive even numbers\n    return true;\n}\n\n"}
{"task_id": "CPP/139", "generation": "#include <iostream>\n\n// Function to calculate factorial\nlong long factorial(long long num) {\n    if (num == 0 || num == 1)\n        return 1;\n    else\n        return num * factorial(num - 1);\n}\n\n// Function to calculate Brazilian factorial\nlong long special_factorial(int n) {\n    long long result = 1;\n    for (int i = n; i > 0; --i) {\n        result *= factorial(i);\n    }\n    return result;\n}\n\n"}
{"task_id": "CPP/140", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring fix_spaces(string text) {\n    bool in_consecutive_spaces = false;\n    for (size_t i = 0; i < text.length(); ++i) {\n        if (text[i] == ' ') {\n            if (!in_consecutive_spaces) {\n                // Start of consecutive spaces\n                in_consecutive_spaces = true;\n            }\n            // Replace space with underscore or dash as needed\n            if (i + 1 < text.length() && text[i + 1] == ' ') {\n                continue; // Skip to the next space\n            } else {\n                if (in_consecutive_spaces) {\n                    // If we are in a sequence of spaces, replace them with -\n                    for (size_t j = i - 1; j >= 0 && text[j] == ' '; --j) {\n                        text[j] = '-';\n                    }\n                    in_consecutive_spaces = false;\n                } else {\n                    // Replace single space with underscore\n                    text[i] = '_';\n                }\n            }\n        } else {\n            in_consecutive_spaces = false; // Reset the flag if not a space\n        }\n    }\n    return text;\n}\n\n"}
{"task_id": "CPP/141", "generation": "#include <iostream>\n#include <string>\n#include <cctype> // For std::isdigit\n\nusing namespace std;\n\nbool hasMoreThanThreeDigits(const string& filename) {\n    int digitCount = 0;\n    for (char c : filename) {\n        if (std::isdigit(c)) {\n            ++digitCount;\n            if (digitCount > 3) return true;\n        }\n    }\n    return false;\n}\n\nstring file_name_check(string file_name) {\n    // Check if there are more than three digits\n    if (hasMoreThanThreeDigits(file_name)) return \"No\";\n\n    // Find the position of the dot\n    size_t dotPos = file_name.find('.');\n    if (dotPos == string::npos || dotPos == 0 || dotPos == file_name.length() - 1) {\n        return \"No\";\n    }\n\n    // Check the substring before the dot\n    for (size_t i = 0; i < dotPos; ++i) {\n        if (!std::isalpha(file_name[i])) {\n            return \"No\";\n        }\n    }\n\n    // Check the extension\n    string extension = file_name.substr(dotPos + 1);\n    if (extension != \"txt\" && extension != \"exe\" && extension != \"dll\") {\n        return \"No\";\n    }\n\n    return \"Yes\";\n}\n\n"}
{"task_id": "CPP/142", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint sum_squares(vector<int> lst) {\n    int sum = 0;\n    \n    for (size_t i = 0; i < lst.size(); ++i) {\n        if ((i + 1) % 3 == 0 && (i + 1) % 4 != 0) {\n            // Square the entry if its index is a multiple of 3 and not a multiple of 4\n            sum += lst[i] * lst[i];\n        } else if ((i + 1) % 4 == 0) {\n            // Cube the entry if its index is a multiple of 4\n            sum += lst[i] * lst[i] * lst[i];\n        } else {\n            // Add the original value to the sum if the index is not a multiple of 3 or 4\n            sum += lst[i];\n        }\n    }\n\n    return sum;\n}\n\n// Function to test the implementation with provided examples\nvoid test() {\n    cout << \"Test case 1: {1,2,3} -> Expected output: 6\" << endl;\n    cout << \"Actual output: \" << sum_squares({1, 2, 3}) << endl;\n\n    cout << \"Test case 2: {} -> Expected output: 0\" << endl;\n    cout << \"Actual output: \" << sum_squares({}) << endl;\n\n    cout << \"Test case 3: {-1,-5,2,-1,-5} -> Expected output: -126\" << endl;\n    cout << \"Actual output: \" << sum_squares({-1, -5, 2, -1, -5}) << endl;\n}\n\n"}
{"task_id": "CPP/143", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    if (n == 2 || n == 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    for (int i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0)\n            return false;\n    }\n    return true;\n}\n\n// Function to split the sentence into words\nvector<string> split_sentence(const string& sentence) {\n    stringstream ss(sentence);\n    vector<string> words;\n    string word;\n    while (ss >> word) {\n        words.push_back(word);\n    }\n    return words;\n}\n\n// Main function to process the sentence and collect words with prime length\nstring words_in_sentence(string sentence) {\n    vector<string> words = split_sentence(sentence);\n    string result;\n\n    for (const auto& word : words) {\n        if (is_prime(word.length())) {\n            if (!result.empty()) {\n                result += \" \";\n            }\n            result += word;\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/144", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\n// Function to parse the fraction from string format to integer values\npair<int, int> parseFraction(const string& fraction) {\n    size_t slashPos = fraction.find('/');\n    int numerator = stoi(fraction.substr(0, slashPos));\n    int denominator = stoi(fraction.substr(slashPos + 1));\n    return {numerator, denominator};\n}\n\n// Function to simplify the expression x * n and check if it evaluates to a whole number\nbool simplify(string x, string n) {\n    // Parse both fractions\n    auto [numX, denX] = parseFraction(x);\n    auto [numN, denN] = parseFraction(n);\n\n    // Multiply numerators and denominators\n    int numeratorResult = numX * numN;\n    int denominatorResult = denX * denN;\n\n    // Check if the result is a whole number\n    return (numeratorResult % denominatorResult) == 0;\n}\n\n"}
{"task_id": "CPP/145", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n// Helper function to calculate the sum of digits of an integer\nint digitSum(int n) {\n    int sum = 0;\n    bool isNegative = n < 0;\n    while (n != 0) {\n        int d = abs(n % 10);\n        sum += d;\n        n /= 10;\n    }\n    // If the number was negative, subtract the first digit\n    if (isNegative && n == -1) {\n        sum -= 9; // Assuming single-digit numbers are handled correctly\n    }\n    return sum;\n}\n\n// Comparator function to sort based on digit sum and original index\nbool compareByDigitSumAndIndex(int a, int b, const vector<int>& nums) {\n    int sumA = digitSum(a);\n    int sumB = digitSum(b);\n    if (sumA == sumB) {\n        return nums.index_of(a) < nums.index_of(b); // Assuming index_of is a function that returns the original index\n    }\n    return sumA < sumB;\n}\n\nvector<int> order_by_points(vector<int> nums) {\n    vector<int> sortedNums = nums; // Copy of the original vector to keep track of indices\n    sort(sortedNums.begin(), sortedNums.end(), [&nums](int a, int b) {\n        return compareByDigitSumAndIndex(a, b, nums);\n    });\n    return sortedNums;\n}\n\n// Function to check the correctness of the solution\nvoid check() {\n    vector<int> test1 = {1, 11, -1, -11, -12};\n    vector<int> expected1 = {-1, -11, 1, -12, 11};\n    assert(order_by_points(test1) == expected1);\n\n    vector<int> test2 = {};\n    vector<int> expected2 = {};\n    assert(order_by_points(test2) == expected2);\n\n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/146", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool isOddDigit(int digit) {\n    return (digit % 2 != 0);\n}\n\nint specialFilter(vector<int> nums) {\n    int count = 0;\n    \n    for (int num : nums) {\n        // Skip numbers that are not greater than 10\n        if (num <= 10) continue;\n\n        string strNum = to_string(num);\n\n        // Check if the first and last digits are odd\n        if (isOddDigit(strNum[0] - '0') && isOddDigit(strNum[strNum.length() - 1] - '0')) {\n            count++;\n        }\n    }\n\n    return count;\n}\n\n"}
{"task_id": "CPP/147", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint get_max_triples(int n) {\n    // Step 1: Generate the vector a\n    vector<int> a(n);\n    for (int i = 0; i < n; ++i) {\n        a[i] = i * i - i + 1;\n    }\n\n    int count = 0;\n\n    // Step 2 and 3: Iterate through all possible triples (i, j, k)\n    for (int i = 0; i < n - 2; ++i) {\n        for (int j = i + 1; j < n - 1; ++j) {\n            for (int k = j + 1; k < n; ++k) {\n                // Step 3: Check if the sum of the triple is divisible by 3\n                if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                    count++;\n                }\n            }\n        }\n    }\n\n    return count;\n}\n\n"}
{"task_id": "CPP/148", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to return all planets between planet1 and planet2, sorted by proximity to the Sun.\nvector<string> bf(string planet1, string planet2) {\n    // List of planets in order from closest to farthest from the Sun\n    vector<string> planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n    \n    // Find the indices of planet1 and planet2 in the list\n    auto it1 = find(planets.begin(), planets.end(), planet1);\n    auto it2 = find(planets.begin(), planets.end(), planet2);\n    \n    // Check if both planets are valid (i.e., found in the list)\n    if (it1 == planets.end() || it2 == planets.end()) {\n        return {};  // Return an empty vector if either planet is not valid\n    }\n    \n    // Ensure that it1 comes before it2 for correct ordering\n    if (it1 > it2) {\n        swap(it1, it2);\n    }\n    \n    // Extract the sublist of planets between the two indices and return it\n    vector<string> result;\n    for (auto i = it1 + 1; i != it2; ++i) {\n        result.push_back(*i);\n    }\n    return result;\n}\n\n// Function to test the bf function with some examples\nvoid test() {\n    vector<string> result;\n\n    // Test case 1: Jupiter and Neptune\n    result = bf(\"Jupiter\", \"Neptune\");\n    for (const auto& planet : result) {\n        cout << planet << \" \";\n    }\n    cout << endl;  // Expected output: Saturn Uranus\n\n    // Test case 2: Earth and Mercury\n    result = bf(\"Earth\", \"Mercury\");\n    for (const auto& planet : result) {\n        cout << planet << \" \";\n    }\n    cout << endl;  // Expected output: Venus\n\n    // Test case 3: Mercury and Uranus\n    result = bf(\"Mercury\", \"Uranus\");\n    for (const auto& planet : result) {\n        cout << planet << \" \";\n    }\n    cout << endl;  // Expected output: Venus Earth Mars Jupiter Saturn\n}\n\n"}
{"task_id": "CPP/149", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to check if a string has an odd length\nbool has_odd_length(const string& str) {\n    return str.length() % 2 != 0;\n}\n\n// Comparator function for sorting strings by their length and then alphabetically\nbool compare_strings(const string& s1, const string& s2) {\n    if (s1.length() == s2.length()) {\n        return s1 < s2; // Alphabetical order if lengths are the same\n    }\n    return s1.length() < s2.length(); // Length order first\n}\n\nvector<string> sorted_list_sum(vector<string> lst) {\n    // Remove strings with odd lengths\n    lst.erase(remove_if(lst.begin(), lst.end(), has_odd_length), lst.end());\n    \n    // Sort the vector using the custom comparator\n    sort(lst.begin(), lst.end(), compare_strings);\n    \n    return lst;\n}\n\n// Function to test the sorted_list_sum function\nvoid test() {\n    assert(sorted_list_sum({\"aa\", \"a\", \"aaa\"}) == vector<string>{\"aa\"});\n    assert(sorted_list_sum({\"ab\", \"a\", \"aaa\", \"cd\"}) == vector<string>{\"ab\", \"cd\"});\n    cout << \"All tests passed successfully.\" << endl;\n}\n\n"}
{"task_id": "CPP/150", "generation": "#include <stdio.h>\n\n// Helper function to check if a number is prime\nint is_prime(int num) {\n    if (num <= 1) return 0; // Numbers less than or equal to 1 are not prime\n    for (int i = 2; i * i <= num; i++) {\n        if (num % i == 0) return 0; // If divisible by any number other than 1 and itself, it's not prime\n    }\n    return 1; // The number is prime\n}\n\n// Main function to determine x or y based on whether n is prime\nint x_or_y(int n, int x, int y) {\n    if (is_prime(n)) {\n        return x;\n    } else {\n        return y;\n    }\n}\n\n"}
{"task_id": "CPP/151", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nlong long double_the_difference(vector<float> lst) {\n    long long sum = 0;\n    \n    for (auto num : lst) {\n        // Check if the number is positive, an integer, and odd\n        if (num > 0 && floor(num) == num && static_cast<int>(num) % 2 != 0) {\n            sum += pow(num, 2);\n        }\n    }\n    \n    return sum;\n}\n\n"}
{"task_id": "CPP/152", "generation": "#include <stdio.h>\n#include <math.h>\n#include <vector>\nusing namespace std;\n\n// Function to compare the game results with the guesses\nvector<int> compare(vector<int> game, vector<int> guess) {\n    vector<int> differences;\n    \n    // Iterate through each match and calculate the difference\n    for (size_t i = 0; i < game.size(); ++i) {\n        int diff = abs(game[i] - guess[i]);\n        differences.push_back(diff);\n    }\n    \n    return differences;\n}\n\n// Example usage\n"}
{"task_id": "CPP/153", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to calculate the strength of an extension\nint calculateStrength(const string& extension) {\n    int cap = 0, sm = 0;\n    for (char c : extension) {\n        if (isupper(c)) cap++;\n        else if (islower(c)) sm++;\n    }\n    return cap - sm;\n}\n\n// Function to find the strongest extension\nstring Strongest_Extension(string class_name, vector<string> extensions) {\n    int max_strength = INT_MIN;\n    string strongest_extension;\n\n    for (const string& ext : extensions) {\n        int strength = calculateStrength(ext);\n        if (strength > max_strength) {\n            max_strength = strength;\n            strongest_extension = ext;\n        }\n    }\n\n    return class_name + \".\" + strongest_extension;\n}\n\n// Example usage\n"}
{"task_id": "CPP/154", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\n// Function to generate all rotations of a string\nvoid generate_rotations(string &str, vector<string> &rotations) {\n    int n = str.length();\n    for (int i = 0; i < n; ++i) {\n        // Rotate the string by moving the first character to the end\n        char first_char = str[0];\n        str.erase(0, 1);\n        str += first_char;\n        rotations.push_back(str);\n    }\n}\n\n// Function to check if any rotation of b is a substring of a\nbool cycpattern_check(string a, string b) {\n    // Generate all rotations of b\n    vector<string> rotations;\n    generate_rotations(b, rotations);\n\n    // Check each rotation to see if it is a substring of a\n    for (const auto &rotation : rotations) {\n        if (a.find(rotation) != string::npos) {\n            return true;\n        }\n    }\n\n    // If none of the rotations are substrings of a, return false\n    return false;\n}\n\n"}
{"task_id": "CPP/155", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// Function to count even and odd digits in a given integer\nvector<int> even_odd_count(int num) {\n    // Convert the number to its absolute value to handle negative numbers\n    int abs_num = abs(num);\n    \n    vector<int> result(2, 0); // Initialize the result vector with two elements (even and odd counts)\n    \n    while (abs_num > 0) {\n        int digit = abs_num % 10; // Get the last digit\n        \n        if (digit % 2 == 0) { // Check if the digit is even\n            result[0]++; // Increment the count of even digits\n        } else {\n            result[1]++; // Increment the count of odd digits\n        }\n        \n        abs_num /= 10; // Remove the last digit\n    }\n    \n    return result;\n}\n\n// Function to test the even_odd_count function\nvoid test_even_odd_count() {\n    cout << \"Testing even_odd_count...\" << endl;\n    \n    vector<int> result1 = even_odd_count(-12);\n    cout << \"even_odd_count(-12) -> {1, 1} (Expected: {1, 1})\" << endl;\n    cout << \"Result: {\" << result1[0] << \", \" << result1[1] << \"}\" << endl;\n    \n    vector<int> result2 = even_odd_count(123);\n    cout << \"even_odd_count(123) -> {1, 2} (Expected: {1, 2})\" << endl;\n    cout << \"Result: {\" << result2[0] << \", \" << result2[1] << \"}\" << endl;\n    \n    vector<int> result3 = even_odd_count(-456);\n    cout << \"even_odd_count(-456) -> {2, 1} (Expected: {2, 1})\" << endl;\n    cout << \"Result: {\" << result3[0] << \", \" << result3[1] << \"}\" << endl;\n}\n\n"}
{"task_id": "CPP/156", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nstring int_to_mini_roman(int number) {\n    // Mapping of integers to their corresponding lowercase Roman numerals\n    vector<pair<int, string>> roman_map = {\n        {1000, \"m\"}, {900, \"cm\"}, {500, \"d\"}, {400, \"cd\"},\n        {100, \"c\"}, {90, \"xc\"}, {50, \"l\"}, {40, \"xl\"},\n        {10, \"x\"}, {9, \"ix\"}, {5, \"v\"}, {4, \"iv\"}, {1, \"i\"}\n    };\n\n    string result = \"\";\n    for (const auto& [value, numeral] : roman_map) {\n        while (number >= value) {\n            result += numeral;\n            number -= value;\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/157", "generation": "#include <stdio.h>\n#include <math.h>\nusing namespace std;\n\nbool right_angle_triangle(float a, float b, float c) {\n    // Sort the sides to ensure c is the longest side\n    if (a > c) swap(a, c);\n    if (b > c) swap(b, c);\n\n    // Check the Pythagorean theorem\n    return fabs(a*a + b*b - c*c) < 1e-6; // Using a small tolerance to account for floating point precision issues\n}\n\n"}
{"task_id": "CPP/158", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nstring find_max(vector<string> words) {\n    if (words.empty()) return \"\"; // Handle empty vector case\n\n    string max_word = words[0];\n    int max_unique_chars = unique_chars(words[0]);\n\n    for (size_t i = 1; i < words.size(); ++i) {\n        int current_unique_chars = unique_chars(words[i]);\n        if (current_unique_chars > max_unique_chars ||\n            (current_unique_chars == max_unique_chars && words[i] < max_word)) {\n            max_word = words[i];\n            max_unique_chars = current_unique_chars;\n        }\n    }\n\n    return max_word;\n\n}\n\nint unique_chars(const string& word) {\n    std::set<char> chars(word.begin(), word.end());\n    return chars.size();\n}\n\n// Function to test the solution with provided examples\nvoid check() {\n    assert(find_max({\"name\", \"of\", \"string\"}) == \"string\");\n    assert(find_max({\"name\", \"enam\", \"game\"}) == \"enam\");\n    assert(find_max({\"aaaaaaa\", \"bb\", \"cc\"}) == \"aaaaaaa\");\n}\n\n"}
{"task_id": "CPP/159", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nvector<int> eat(int number, int need, int remaining) {\n    // Calculate the minimum between the needed carrots and the available remaining carrots\n    int to_eat = min(need, remaining);\n    \n    // Update the total number of eaten carrots\n    int total_eaten = number + to_eat;\n    \n    // Update the remaining carrots after eating\n    int left_remaining = remaining - to_eat;\n    \n    // Return the results as a vector\n    return {total_eaten, left_remaining};\n}\n\n// Example usage:\n"}
{"task_id": "CPP/160", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nint do_algebra(vector<string> operators, vector<int> operands) {\n    if (operands.size() == 0 || operators.size() != operands.size() - 1) {\n        throw invalid_argument(\"Invalid input vectors\");\n    }\n\n    int result = operands[0];\n\n    for (size_t i = 0; i < operators.size(); ++i) {\n        switch (operators[i][0]) {\n            case '+':\n                result += operands[i + 1];\n                break;\n            case '-':\n                result -= operands[i + 1];\n                break;\n            case '*':\n                result *= operands[i + 1];\n                break;\n            case '/':\n                if (operands[i + 1] == 0) {\n                    throw runtime_error(\"Division by zero\");\n                }\n                result /= operands[i + 1];\n                break;\n            case '%':\n                result %= operands[i + 1];\n                break;\n            case '^':\n                result = pow(result, operands[i + 1]);\n                break;\n            default:\n                throw invalid_argument(\"Invalid operator\");\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/161", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool isLetter(char c) {\n    return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z');\n}\n\nstring solve(string s) {\n    bool hasLetters = false;\n    \n    // Check if the string contains any letters\n    for (char c : s) {\n        if (isLetter(c)) {\n            hasLetters = true;\n            break;\n        }\n    }\n\n    if (!hasLetters) {\n        // If no letters are present, reverse the entire string\n        reverse(s.begin(), s.end());\n    } else {\n        // If there are letters, convert them to their opposite case\n        for (char &c : s) {\n            if (isLetter(c)) {\n                c = islower(c) ? toupper(c) : tolower(c);\n            }\n        }\n    }\n\n    return s;\n}\n\n"}
{"task_id": "CPP/162", "generation": "#include <iostream>\n#include <string>\n#include <openssl/md5.h>\n\n// Function to convert string to MD5 hash\nstd::string string_to_md5(const std::string& text) {\n    unsigned char digest[MD5_DIGEST_LENGTH];\n    MD5((unsigned char*)text.c_str(), text.length(), (unsigned char*)&digest);    \n\n    // Create destination string\n    char mdString[33];\n    for(int i = 0; i < 16; ++i)\n        sprintf(&mdString[i*2], \"%02x\", (unsigned int)digest[i]);\n\n    return std::string(mdString);\n}\n\n"}
{"task_id": "CPP/163", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> generate_integers(int a, int b) {\n    vector<int> result;\n    \n    // Ensure the range is valid and adjust if necessary\n    if (a > b) swap(a, b);\n    \n    for (int i = a; i <= b; ++i) {\n        // Extract each digit from the current number\n        while (i > 0) {\n            int digit = i % 10;\n            // Check if the digit is even and add it to the result vector\n            if (digit >= 2 && digit % 2 == 0) {\n                result.push_back(digit);\n            }\n            i /= 10; // Move to the next digit\n        }\n    }\n    \n    return result;\n}\n\n// Function to print the contents of a vector for testing purposes\nvoid print_vector(const vector<int>& vec) {\n    for (int num : vec) {\n        cout << num << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/0", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // For std::sort\n\nbool has_close_elements(vector<float> numbers, float threshold) {\n    // Sort the vector first\n    sort(numbers.begin(), numbers.end());\n\n    // Iterate through adjacent elements to check if any pair is closer than the threshold\n    for (size_t i = 0; i < numbers.size() - 1; ++i) {\n        if (numbers[i + 1] - numbers[i] < threshold) {\n            return true;\n        }\n    }\n\n    // If no such pair found, return false\n    return false;\n}\n\n"}
{"task_id": "CPP/1", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> separate_paren_groups(string paren_string) {\n    vector<string> result;\n    string current_group;\n    int balance = 0;\n\n    for (char ch : paren_string) {\n        if (ch == '(') {\n            balance++;\n            current_group += ch;\n        } else if (ch == ')') {\n            balance--;\n            current_group += ch;\n            if (balance == 0) {\n                result.push_back(current_group);\n                current_group.clear();\n            }\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/2", "generation": "#include <stdio.h>\n#include <math.h>\n\nfloat truncate_number(float number) {\n    float integerPart;\n    modf(number, &integerPart);  // modf returns the fractional part and stores the integer part in `integerPart`\n    return number - integerPart; // Subtracting the integer part from the original number gives the decimal part\n}\n\n"}
{"task_id": "CPP/3", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool below_zero(vector<int> operations) {\n    int balance = 0; // Start with a zero balance\n\n    for (int op : operations) {\n        balance += op; // Update the balance after each operation\n\n        if (balance < 0) { // Check if the balance falls below zero\n            return true;\n        }\n    }\n\n    return false; // Return false if the balance never goes below zero\n}\n\n// Function to test the below_zero function with provided examples\nvoid check_function() {\n    vector<int> operations1 = {1, 2, 3};\n    vector<int> operations2 = {1, 2, -4, 5};\n\n    cout << \"Test Case 1: \" << (below_zero(operations1) ? \"Passed\" : \"Failed\") << endl;\n    cout << \"Test Case 2: \" << (below_zero(operations2) ? \"Passed\" : \"Failed\") << endl;\n}\n\n"}
{"task_id": "CPP/4", "generation": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nfloat mean_absolute_deviation(vector<float> numbers) {\n    // Step 1: Calculate the mean of the dataset\n    float sum = 0.0;\n    for (const auto& num : numbers) {\n        sum += num;\n    }\n    float mean = sum / numbers.size();\n\n    // Step 2 and 3: Compute the absolute differences and their average\n    float mad = 0.0;\n    for (const auto& num : numbers) {\n        mad += abs(num - mean);\n    }\n    mad /= numbers.size();\n\n    return mad;\n}\n\n"}
{"task_id": "CPP/5", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> intersperse(vector<int> numbers, int delimeter) {\n    vector<int> result;\n    \n    // Iterate through the original vector and insert each element followed by the delimiter\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        result.push_back(numbers[i]);\n        if (i != numbers.size() - 1) {  // Do not add a delimiter after the last element\n            result.push_back(delimeter);\n        }\n    }\n    \n    return result;\n}\n\n// Function to test the intersperse function\nvoid testIntersperse() {\n    vector<int> emptyVec = {};\n    vector<int> vec1 = {1, 2, 3};\n    vector<int> expected1 = {1, 4, 2, 4, 3};\n\n    cout << \"Testing with an empty vector:\" << endl;\n    for (int num : intersperse(emptyVec, 4)) {\n        cout << num << \" \";\n    }\n    cout << endl;\n\n    cout << \"Testing with a non-empty vector:\" << endl;\n    for (int num : intersperse(vec1, 4)) {\n        cout << num << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/6", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to parse and determine the deepest level of nesting for a single group of parentheses\nint maxDepthOfNesting(const string& group) {\n    int currentDepth = 0;\n    int maxDepth = 0;\n    \n    for (char ch : group) {\n        if (ch == '(') {\n            currentDepth++;\n            maxDepth = max(maxDepth, currentDepth);\n        } else if (ch == ')') {\n            currentDepth--;\n        }\n    }\n    \n    return maxDepth;\n}\n\n// Function to process the entire string and return a vector of maximum depths for each group\nvector<int> parse_nested_parens(string paren_string) {\n    vector<int> result;\n    size_t start = 0;\n    size_t end = paren_string.find(' ');\n    \n    while (end != string::npos) {\n        // Extract the current group from the string\n        string group = paren_string.substr(start, end - start);\n        \n        // Calculate the maximum depth of nesting for the current group\n        int maxDepth = maxDepthOfNesting(group);\n        \n        result.push_back(maxDepth);\n        \n        // Move to the next group\n        start = end + 1;\n        end = paren_string.find(' ', start);\n    }\n    \n    // Process the last group if there is one\n    if (start < paren_string.length()) {\n        string group = paren_string.substr(start);\n        int maxDepth = maxDepthOfNesting(group);\n        result.push_back(maxDepth);\n    }\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/7", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to filter strings containing a given substring\nvector<string> filter_by_substring(vector<string> strings, string substring) {\n    vector<string> filtered_strings;\n    \n    // Iterate through each string in the input vector\n    for (const auto& str : strings) {\n        // Check if the current string contains the substring\n        if (str.find(substring) != string::npos) {\n            // If it does, add it to the filtered list\n            filtered_strings.push_back(str);\n        }\n    }\n    \n    return filtered_strings;\n}\n\n// Function to test the filter_by_substring function\nvoid test_filter_by_substring() {\n    vector<string> input1 = {};\n    vector<string> expected1 = {};\n    assert(filter_by_substring(input1, \"a\") == expected1);\n\n    vector<string> input2 = {\"abc\", \"bacd\", \"cde\", \"vector\"};\n    vector<string> expected2 = {\"abc\", \"bacd\", \"vector\"};\n    assert(filter_by_substring(input2, \"a\") == expected2);\n\n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/8", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// Function to calculate the sum and product of elements in a vector\nvector<int> sum_product(vector<int> numbers) {\n    int sum = 0;\n    int product = 1;\n\n    // Iterate through each number in the vector\n    for (int num : numbers) {\n        sum += num;  // Add the current number to the sum\n        product *= num;  // Multiply the current number with the product\n    }\n\n    return {sum, product};\n}\n\n// Function to test the sum_product function\nvoid test_sum_product() {\n    vector<int> empty = {};\n    vector<int> result1 = sum_product(empty);\n    cout << \"Empty Vector: Sum = \" << result1[0] << \", Product = \" << result1[1] << endl;\n\n    vector<int> numbers = {1, 2, 3, 4};\n    vector<int> result2 = sum_product(numbers);\n    cout << \"Vector [1, 2, 3, 4]: Sum = \" << result2[0] << \", Product = \" << result2[1] << endl;\n}\n\n"}
{"task_id": "CPP/9", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> rolling_max(vector<int> numbers) {\n    if (numbers.empty()) return {};  // Return an empty vector if input is empty\n\n    vector<int> result;\n    int current_max = numbers[0];  // Initialize the current maximum with the first element\n    for (int num : numbers) {\n        if (num > current_max) {\n            current_max = num;  // Update the current maximum if a larger number is found\n        }\n        result.push_back(current_max);  // Add the current maximum to the result vector\n    }\n\n    return result;\n}\n\n// Function to print the vector for testing purposes\nvoid print_vector(const vector<int>& vec) {\n    for (int num : vec) {\n        cout << num << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/10", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_palindrome(const string& str) {\n    // Test if given string is a palindrome \n    return str == string(str.rbegin(), str.rend());\n}\n\nstring make_palindrome(string str) {\n    /*\n    Find the shortest palindrome that begins with a supplied string. \n    Algorithm idea is simple: - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    */\n    \n    // Start from the full length and reduce until we find a palindromic suffix\n    for (int i = str.length(); i > 0; --i) {\n        if (is_palindrome(str.substr(0, i))) {\n            // Found the longest palindromic prefix\n            string prefix = str.substr(i);\n            reverse(prefix.begin(), prefix.end());\n            return str + prefix;\n        }\n    }\n\n    // If no palindromic suffix is found, the entire string itself is a palindrome.\n    return str;\n}\n\n"}
{"task_id": "CPP/11", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring string_xor(string a, string b) {\n    // Ensure both strings are of equal length by padding with leading zeros if necessary\n    int maxLength = max(a.length(), b.length());\n    a.insert(0, maxLength - a.length(), '0');\n    b.insert(0, maxLength - b.length(), '0');\n\n    string result(maxLength, '0');  // Initialize the result string\n\n    // Perform XOR operation character by character\n    for (int i = 0; i < maxLength; ++i) {\n        if (a[i] != b[i]) {\n            result[i] = '1';  // If characters are different, set result to '1'\n        }\n    }\n\n    return result;\n}\n\n// Function to test the string_xor function\nvoid test_string_xor() {\n    cout << \"Testing string_xor function:\" << endl;\n    cout << \"Input: \\\"010\\\", \\\"110\\\" - Output: \\\"\" << string_xor(\"010\", \"110\") << \"\\\" (Expected: \\\"100\\\")\" << endl;\n    cout << \"Input: \\\"10101\\\", \\\"11001\\\" - Output: \\\"\" << string_xor(\"10101\", \"11001\") << \"\\\" (Expected: \\\"01100\\\")\" << endl;\n}\n\n"}
{"task_id": "CPP/12", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring longest(const vector<string>& strings) {\n    if (strings.empty()) {\n        return \"\"; // Return an empty string to indicate None in this context.\n    }\n\n    const string* longestString = &strings[0];\n    for (const auto& str : strings) {\n        if (str.length() > longestString->length()) {\n            longestString = &str;\n        }\n    }\n\n    return *longestString;\n}\n\n"}
{"task_id": "CPP/13", "generation": "#include <stdio.h>\nusing namespace std;\n\nint greatest_common_divisor(int a, int b) {\n    // Ensure a >= b to simplify the logic\n    if (b > a) {\n        return greatest_common_divisor(b, a);\n    }\n\n    // Base case: if b is 0, then GCD is a\n    if (b == 0) {\n        return a;\n    }\n\n    // Recursive call with remainder of a divided by b\n    return greatest_common_divisor(b, a % b);\n}\n\n"}
{"task_id": "CPP/14", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to generate all prefixes of the input string\nvector<string> all_prefixes(string str) {\n    vector<string> prefixes;\n    for (size_t i = 1; i <= str.length(); ++i) {\n        prefixes.push_back(str.substr(0, i));\n    }\n    return prefixes;\n}\n\n"}
{"task_id": "CPP/15", "generation": "#include <iostream>\n#include <sstream>\n#include <string>\nusing namespace std;\n\nstring string_sequence(int n) {\n    stringstream ss;\n    for (int i = 0; i <= n; ++i) {\n        ss << i;\n        if (i < n) {\n            ss << \" \";\n        }\n    }\n    return ss.str();\n}\n\n// Function to test the string_sequence function\nvoid test_string_sequence() {\n    cout << \"Testing string_sequence...\" << endl;\n    assert(string_sequence(0) == \"0\");\n    assert(string_sequence(5) == \"0 1 2 3 4 5\");\n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/16", "generation": "#include <iostream>\n#include <string>\n#include <set>\n\nusing namespace std;\n\nint count_distinct_characters(string str) {\n    // Convert the string to lowercase to ensure case insensitivity\n    transform(str.begin(), str.end(), str.begin(), ::tolower);\n    \n    // Use a set to store distinct characters\n    set<char> distinct_chars(str.begin(), str.end());\n    \n    // The size of the set is the number of distinct characters\n    return distinct_chars.size();\n}\n\n"}
{"task_id": "CPP/17", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<int> parse_music(string music_string) {\n    vector<int> durations;\n    \n    // Iterate through the string, processing one character at a time\n    for (size_t i = 0; i < music_string.length(); ++i) {\n        if (music_string[i] == 'o') {  // Whole note\n            durations.push_back(4);\n        } else if (music_string[i] == '|') {  // Check the next character to determine the type of note\n            if (music_string[i + 1] == '|') {  // Half note\n                durations.push_back(2);\n                i++;  // Skip the next character as it is part of the half note\n            } else {  // Quater note\n                durations.push_back(1);\n            }\n        }\n    }\n    \n    return durations;\n}\n\n"}
{"task_id": "CPP/18", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint how_many_times(const string& str, const string& substring) {\n    if (substring.empty()) return 0;\n    \n    int count = 0;\n    size_t pos = 0;\n    \n    while ((pos = str.find(substring, pos)) != string::npos) {\n        ++count;\n        pos++; // Move to the next character to allow overlapping matches\n    }\n    \n    return count;\n}\n\n"}
{"task_id": "CPP/19", "generation": "#include <iostream>\n#include <string>\n#include <map>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to convert word to number\nint word_to_number(const string& word) {\n    map<string, int> num_map = {{\"zero\", 0}, {\"one\", 1}, {\"two\", 2}, {\"three\", 3},\n                                {\"four\", 4}, {\"five\", 5}, {\"six\", 6}, {\"seven\", 7},\n                                {\"eight\", 8}, {\"nine\", 9}};\n    return num_map[word];\n}\n\n// Function to sort numbers\nstring sort_numbers(const string& numbers) {\n    vector<string> words;\n    string number;\n    \n    // Split the input string into individual words\n    for (char ch : numbers) {\n        if (ch == ' ') {\n            if (!number.empty()) {\n                words.push_back(number);\n                number.clear();\n            }\n        } else {\n            number += ch;\n        }\n    }\n    if (!number.empty()) {\n        words.push_back(number);\n    }\n\n    // Sort the words based on their numeric value\n    sort(words.begin(), words.end(), [](const string& a, const string& b) {\n        return word_to_number(a) < word_to_number(b);\n    });\n\n    // Join the sorted words back into a single string\n    string result;\n    for (const auto& word : words) {\n        if (!result.empty()) {\n            result += \" \";\n        }\n        result += word;\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/20", "generation": "#include <iostream>\n#include <cmath>\n#include <vector>\n\nusing namespace std;\n\npair<float, float> find_closest_elements(vector<float> numbers) {\n    if (numbers.size() < 2) {\n        throw invalid_argument(\"The vector must contain at least two elements.\");\n    }\n\n    // Initialize the minimum difference to a large value\n    float min_diff = numeric_limits<float>::max();\n    pair<float, float> closest_pair;\n\n    // Iterate through the vector to find the closest pair\n    for (size_t i = 0; i < numbers.size() - 1; ++i) {\n        for (size_t j = i + 1; j < numbers.size(); ++j) {\n            float diff = abs(numbers[i] - numbers[j]);\n            if (diff < min_diff) {\n                min_diff = diff;\n                closest_pair = make_pair(min(diff * numbers[i], diff * numbers[j]), max(diff * numbers[i], diff * numbers[j]));\n            }\n        }\n    }\n\n    return closest_pair;\n}\n\n"}
{"task_id": "CPP/21", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // For std::min_element and std::max_element\n\nusing namespace std;\n\nvector<float> rescale_to_unit(vector<float> numbers) {\n    if (numbers.size() < 2) {\n        throw invalid_argument(\"Vector must contain at least two elements.\");\n    }\n\n    float min_value = *std::min_element(numbers.begin(), numbers.end());\n    float max_value = *std::max_element(numbers.begin(), numbers.end());\n\n    vector<float> scaled_numbers;\n    for (float num : numbers) {\n        float new_value = (num - min_value) / (max_value - min_value);\n        scaled_numbers.push_back(new_value);\n    }\n\n    return scaled_numbers;\n}\n\n"}
{"task_id": "CPP/22", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <list>\n#include <boost/any.hpp>\n\ntypedef std::list<boost::any> list_any;\nusing namespace std;\n\nvector<int> filter_integers(list_any values) {\n    vector<int> result;\n    for (const auto& value : values) {\n        if (value.type() == typeid(int)) {\n            result.push_back(boost::any_cast<int>(value));\n        }\n    }\n    return result;\n}\n\n"}
{"task_id": "CPP/23", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint strlen(const string& str) {\n    // Return the size of the string, which is equivalent to its length.\n    return str.size();\n}\n\n// Function to test the strlen function with some examples\nvoid test_strlen() {\n    cout << \"Length of \\\"\\\" (empty string): \" << strlen(\"\") << endl;\n    cout << \"Length of \\\"abc\\\": \" << strlen(\"abc\") << endl;\n    cout << \"Length of \\\"hello world\\\": \" << strlen(\"hello world\") << endl;\n}\n\n"}
{"task_id": "CPP/24", "generation": "#include <iostream>\nusing namespace std;\n\nint largest_divisor(int n) {\n    for (int i = n - 1; i > 0; --i) {\n        if (n % i == 0) {\n            return i;\n        }\n    }\n    // If no divisor is found, which should not happen for positive integers,\n    // we can return -1 or throw an exception. For simplicity, returning -1.\n    return -1;\n}\n\n"}
{"task_id": "CPP/25", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> factorize(int n) {\n    vector<int> factors;\n    \n    // Divide by 2 to get rid of all even factors\n    while (n % 2 == 0) {\n        factors.push_back(2);\n        n /= 2;\n    }\n    \n    // Check for odd factors from 3 onwards\n    for (int i = 3; i * i <= n; i += 2) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n    \n    // If n is a prime number greater than 2\n    if (n > 2) {\n        factors.push_back(n);\n    }\n    \n    return factors;\n}\n\n"}
{"task_id": "CPP/26", "generation": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nvector<int> remove_duplicates(vector<int> numbers) {\n    // Create an unordered map to count occurrences of each element\n    unordered_map<int, int> counts;\n    \n    // Count the occurrences of each number in the input vector\n    for (int num : numbers) {\n        counts[num]++;\n    }\n    \n    // Create a new vector to store elements that occur exactly once\n    vector<int> result;\n    \n    // Iterate through the original vector and add elements to the result if they occur only once\n    for (int num : numbers) {\n        if (counts[num] == 1) {\n            result.push_back(num);\n        }\n    }\n    \n    return result;\n}\n\n// Function to check the correctness of the remove_duplicates function\nvoid check() {\n    vector<int> input = {1, 2, 3, 2, 4};\n    vector<int> expected_output = {1, 3, 4};\n    vector<int> output = remove_duplicates(input);\n    \n    if (output == expected_output) {\n        cout << \"Test passed.\" << endl;\n    } else {\n        cout << \"Test failed.\" << endl;\n    }\n}\n\n"}
{"task_id": "CPP/27", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring flip_case(string str) {\n    for (char &c : str) {\n        if (islower(c)) {\n            c = toupper(c);\n        } else if (isupper(c)) {\n            c = tolower(c);\n        }\n    }\n    return str;\n}\n\n"}
{"task_id": "CPP/28", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <numeric> // For std::accumulate\n\nusing namespace std;\n\nstring concatenate(vector<string> strings) {\n    // Use std::accumulate to concatenate all strings in the vector\n    return accumulate(strings.begin(), strings.end(), string(\"\"));\n}\n\n// Function to test the concatenate function\nvoid test_concatenate() {\n    assert(concatenate({}) == \"\");\n    assert(concatenate({\"a\", \"b\", \"c\"}) == \"abc\");\n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/29", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to filter strings based on the given prefix\nvector<string> filter_by_prefix(vector<string> strings, string prefix) {\n    vector<string> filtered_strings;\n    \n    // Iterate through each string in the input vector\n    for (const auto& str : strings) {\n        // Check if the current string starts with the given prefix\n        if (str.substr(0, prefix.length()) == prefix) {\n            // If it does, add it to the filtered list\n            filtered_strings.push_back(str);\n        }\n    }\n    \n    return filtered_strings;\n}\n\n// Function to test the filter_by_prefix function\nvoid test_filter_by_prefix() {\n    vector<string> input1 = {};\n    string prefix1 = \"a\";\n    vector<string> result1 = filter_by_prefix(input1, prefix1);\n    cout << \"Test 1: \";\n    if (result1.empty()) {\n        cout << \"Passed\" << endl;\n    } else {\n        cout << \"Failed\" << endl;\n    }\n\n    vector<string> input2 = {\"abc\", \"bcd\", \"cde\", \"vector\"};\n    string prefix2 = \"a\";\n    vector<string> result2 = filter_by_prefix(input2, prefix2);\n    cout << \"Test 2: \";\n    if (result2 == vector<string>{\"abc\", \"vector\"}) {\n        cout << \"Passed\" << endl;\n    } else {\n        cout << \"Failed\" << endl;\n    }\n}\n\n"}
{"task_id": "CPP/30", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvector<float> get_positive(vector<float> l) {\n    vector<float> result;\n    for (float num : l) {\n        if (num > 0) {\n            result.push_back(num);\n        }\n    }\n    return result;\n}\n\n"}
{"task_id": "CPP/31", "generation": "#include <iostream>\nusing namespace std;\n\nbool is_prime(long long n) {\n    // Handle edge cases for numbers less than or equal to 1\n    if (n <= 1) return false;\n    \n    // Check divisibility from 2 up to the square root of n\n    for (long long i = 2; i * i <= n; ++i) {\n        if (n % i == 0) {\n            return false; // Found a divisor, so it's not prime\n        }\n    }\n    \n    return true; // No divisors found, so it is prime\n}\n\n"}
{"task_id": "CPP/32", "generation": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\ndouble poly(vector<double> xs, double x) {\n    /*\n    Evaluates polynomial with coefficients xs at point x.\n    */\n    double sum = 0;\n    int i;\n    for (i = 0; i < xs.size(); i++) {\n        sum += xs[i] * pow(x, i);\n    }\n    return sum;\n}\n\ndouble find_zero(vector<double> xs) {\n    /*\n    xs are coefficients of a polynomial. find_zero finds x such that poly(x) = 0.\n    The function assumes the list xs has an even number of coefficients and the largest non-zero coefficient guarantees a solution.\n\n    >>> round(find_zero({1, 2}), 2) # f(x) = 1 + 2x\n    -0.5 \n    >>> round(find_zero({-6, 11, -6, 1}), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n    1.0\n    */\n    \n    // Check if the list has an even number of coefficients\n    if (xs.size() % 2 != 0) {\n        cerr << \"Error: The polynomial must have an even number of coefficients.\" << endl;\n        return -1; // Indicate error\n    }\n    \n    // Find the largest non-zero coefficient to determine the initial interval\n    double max_coeff = 0.0;\n    for (double coeff : xs) {\n        if (fabs(coeff) > max_coeff && coeff != 0) {\n            max_coeff = fabs(coeff);\n        }\n    }\n\n    // Determine the sign of the polynomial at a point far from zero\n    int n = xs.size() - 1; // Degree of the polynomial\n    double x1 = -max_coeff / (fabs(xs[n]) + 1e-6); // Start with a negative value\n    double x2 = max_coeff / (fabs(xs[n]) + 1e-6);  // Start with a positive value\n\n    while (poly(xs, x1) * poly(xs, x2) > 0.0) {\n        cerr << \"Error: The chosen interval does not bracket a root.\" << endl;\n        return -1; // Indicate error\n    }\n\n    double tol = 1e-6; // Tolerance for the bisection method\n    while (fabs(x2 - x1) > tol) {\n        double xm = (x1 + x2) / 2.0;\n        if (poly(xs, xm) == 0.0) {\n            return xm; // Exact root found\n        } else if (poly(xs, x1) * poly(xs, xm) < 0.0) {\n            x2 = xm; // Root is in the left half\n        } else {\n            x1 = xm; // Root is in the right half\n        }\n    }\n\n    return (x1 + x2) / 2.0; // Return the midpoint as an approximation of the root\n}\n\n"}
{"task_id": "CPP/33", "generation": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> sort_third(vector<int> l) {\n    // Step 1: Identify indices divisible by three\n    vector<int> third_indices;\n    for (size_t i = 0; i < l.size(); ++i) {\n        if ((i + 1) % 3 == 0) { // +1 because index starts from 0, but we consider every 3rd element starting from 1\n            third_indices.push_back(i);\n        }\n    }\n\n    // Step 2: Extract and sort the elements at those indices\n    vector<int> to_sort;\n    for (int idx : third_indices) {\n        to_sort.push_back(l[idx]);\n    }\n    sort(to_sort.begin(), to_sort.end());\n\n    // Step 3: Place the sorted elements back into their original positions\n    int sorted_idx = 0;\n    for (size_t i = 0; i < l.size(); ++i) {\n        if ((i + 1) % 3 == 0) { // +1 because index starts from 0, but we consider every 3rd element starting from 1\n            l[i] = to_sort[sorted_idx++];\n        }\n    }\n\n    return l;\n}\n\n// Example usage:\n"}
{"task_id": "CPP/34", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> unique(vector<int> l) {\n    // Sort the input vector\n    sort(l.begin(), l.end());\n    \n    // Remove consecutive duplicate elements\n    auto last = unique(l.begin(), l.end());\n    \n    // Resize the vector to contain only the unique elements\n    l.resize(distance(l.begin(), last));\n    \n    return l;\n}\n\n"}
{"task_id": "CPP/35", "generation": "#include <iostream>\n#include <vector>\n\nfloat max_element(const std::vector<float>& l) {\n    if (l.empty()) {\n        throw std::invalid_argument(\"Vector is empty\");\n    }\n\n    float max_val = l[0];\n    for (size_t i = 1; i < l.size(); ++i) {\n        if (l[i] > max_val) {\n            max_val = l[i];\n        }\n    }\n    return max_val;\n}\n\n"}
{"task_id": "CPP/36", "generation": "#include <iostream>\nusing namespace std;\n\nint fizz_buzz(int n) {\n    int count = 0;\n    \n    for (int i = 1; i < n; ++i) {\n        if (i % 11 == 0 || i % 13 == 0) {\n            // Convert the number to a string and count occurrences of '7'\n            string num_str = to_string(i);\n            for (char c : num_str) {\n                if (c == '7') {\n                    ++count;\n                }\n            }\n        }\n    }\n    \n    return count;\n}\n\n"}
{"task_id": "CPP/37", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<float> sort_even(vector<float> l) {\n    // Extract elements at even indices\n    vector<float> evens;\n    for (size_t i = 0; i < l.size(); i += 2) {\n        evens.push_back(l[i]);\n    }\n\n    // Sort the extracted elements\n    sort(evens.begin(), evens.end());\n\n    // Place sorted elements back into their original positions\n    size_t evenIndex = 0;\n    for (size_t i = 0; i < l.size(); ++i) {\n        if (i % 2 == 0) {\n            l[i] = evens[evenIndex++];\n        }\n    }\n\n    return l;\n}\n\n// Function to check the correctness of the sort_even function\nvoid check() {\n    vector<float> result1 = sort_even({1, 2, 3});\n    assert(result1 == vector<float>({1, 2, 3}));\n\n    vector<float> result2 = sort_even({5, 6, 3, 4});\n    assert(result2 == vector<float>({3, 6, 5, 4}));\n\n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/38", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nstring encode_cyclic(string s) { \n    // returns encoded string by cycling groups of three characters.  \n    int l = s.length();\n    int num = (l + 2) / 3;\n    string x, output;\n    for (int i = 0; i * 3 < l; i++) {\n        x = s.substr(i * 3, 3);\n        if (x.length() == 3) x = x.substr(1) + x[0];\n        output += x;\n    }\n    return output;\n}\n\nstring decode_cyclic(string s) { \n    /*\n    takes as input string encoded with encode_cyclic function. Returns decoded string.\n    */\n    int l = s.length();\n    int num = (l + 2) / 3;\n    string x, output;\n    for (int i = 0; i * 3 < l; i++) {\n        x = s.substr(i * 3, 3);\n        if (x.length() == 3) x = x[2] + x.substr(0, 2); // Rotate one position to the left\n        output += x;\n    }\n    return output;\n}\n\n"}
{"task_id": "CPP/39", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    if (num == 2 || num == 3) return true;\n    if (num % 2 == 0 || num % 3 == 0) return false;\n    for (int i = 5; i * i <= num; i += 6) {\n        if (num % i == 0 || num % (i + 2) == 0)\n            return false;\n    }\n    return true;\n}\n\n// Function to generate the n-th prime Fibonacci number\nint prime_fib(int n) {\n    int count = 0; // Counter for prime Fibonacci numbers found\n    long fib1 = 0, fib2 = 1; // First two Fibonacci numbers\n\n    while (true) {\n        long next_fib = fib1 + fib2;\n        if (is_prime(next_fib)) {\n            count++;\n            if (count == n) return next_fib;\n        }\n        fib1 = fib2;\n        fib2 = next_fib;\n    }\n}\n\n"}
{"task_id": "CPP/40", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nbool triples_sum_to_zero(vector<int> l) {\n    // Sort the vector first\n    sort(l.begin(), l.end());\n    \n    // Iterate through each element in the vector, treating it as a potential 'a' in (a + b + c = 0)\n    for (int i = 0; i < l.size() - 2; ++i) {\n        // Skip duplicate elements to avoid redundant checks\n        if (i > 0 && l[i] == l[i-1]) continue;\n        \n        int left = i + 1, right = l.size() - 1;\n        \n        while (left < right) {\n            int sum = l[i] + l[left] + l[right];\n            \n            if (sum == 0) {\n                return true; // Found a triplet that sums to zero\n            } else if (sum < 0) {\n                ++left; // Need a larger number, move the left pointer to right\n            } else {\n                --right; // Need a smaller number, move the right pointer to left\n            }\n        }\n    }\n    \n    return false; // No triplet found that sums to zero\n}\n\n"}
{"task_id": "CPP/41", "generation": "#include <iostream>\nusing namespace std;\n\nint car_race_collision(int n) {\n    return n;\n}\n\n"}
{"task_id": "CPP/42", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> incr_vector(vector<int> l) {\n    for (int &i : l) {\n        i += 1;\n    }\n    return l;\n}\n\n// Function to print the vector\nvoid print_vector(const vector<int>& v) {\n    for (const int& i : v) {\n        cout << i << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/43", "generation": "#include <iostream>\n#include <vector>\n#include <set>\n\nusing namespace std;\n\nbool pairs_sum_to_zero(vector<int> l) {\n    // Use a set to store seen numbers\n    set<int> seen;\n    \n    for (int num : l) {\n        // Check if the negation of the current number is in the set\n        if (seen.find(-num) != seen.end()) {\n            return true;\n        }\n        // Add the current number to the set\n        seen.insert(num);\n    }\n    \n    // If no such pair is found, return false\n    return false;\n}\n\n"}
{"task_id": "CPP/44", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring change_base(int x, int base) {\n    if (x == 0) return \"0\"; // Handle the case where x is zero\n\n    string result = \"\";\n    while (x > 0) {\n        int remainder = x % base;\n        char digit = '0' + remainder; // Convert the integer to its character representation\n        result = digit + result; // Prepend the digit to the result string\n        x /= base; // Divide x by the base\n    }\n    return result;\n}\n\n"}
{"task_id": "CPP/45", "generation": "#include <iostream>\nusing namespace std;\n\nfloat triangle_area(float a, float h) {\n    return 0.5 * a * h;\n}\n\n"}
{"task_id": "CPP/46", "generation": "#include <stdio.h>\nusing namespace std;\n\nint fib4(int n) {\n    if (n == 0 || n == 1 || n == 3) return 0;\n    if (n == 2) return 2;\n\n    int a = 0, b = 0, c = 2, d = 0, result;\n    \n    for (int i = 4; i <= n; ++i) {\n        result = a + b + c + d;\n        a = b;\n        b = c;\n        c = d;\n        d = result;\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/47", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nfloat median(vector<float> l) {\n    // Sort the vector\n    sort(l.begin(), l.end());\n    \n    int n = l.size();\n    \n    if (n % 2 == 0) {\n        // If even number of elements, return the average of the two middle elements\n        return (l[n / 2 - 1] + l[n / 2]) / 2.0;\n    } else {\n        // If odd number of elements, return the middle element\n        return l[n / 2];\n    }\n}\n\n"}
{"task_id": "CPP/48", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_palindrome(string text) {\n    int left = 0;\n    int right = text.length() - 1;\n\n    while (left < right) {\n        if (text[left] != text[right]) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n\n    return true;\n}\n\n"}
{"task_id": "CPP/49", "generation": "#include <stdio.h>\nusing namespace std;\n\nint modp(int n, int p) {\n    if (n == 0)\n        return 1; // Any number to the power of 0 is 1\n\n    long result = 1;\n    long base = 2;\n\n    while (n > 0) {\n        // If n is odd, multiply the result by the current base\n        if (n % 2 == 1)\n            result = (result * base) % p;\n\n        // Square the base and reduce it modulo p\n        base = (base * base) % p;\n        n /= 2; // Divide n by 2\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/50", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nstring encode_shift(string s) {\n    // returns encoded string by shifting every character by 5 in the alphabet.\n    string out;\n    int i;\n    for (i = 0; i < s.length(); i++) {\n        int w = ((int)s[i] + 5 - (int)'a') % 26 + (int)'a';\n        out += (char)w;\n    }\n    return out;\n}\n\nstring decode_shift(string s) {\n    // takes as input string encoded with encode_shift function. Returns decoded string.\n    string out;\n    int i;\n    for (i = 0; i < s.length(); i++) {\n        int w = ((int)s[i] - 5 - (int)'a') % 26 + (int)'a';\n        out += (char)w;\n    }\n    return out;\n}\n\n"}
{"task_id": "CPP/51", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nbool is_vowel(char c) {\n    // Convert character to lowercase for simplicity\n    char lower_c = tolower(c);\n    return lower_c == 'a' || lower_c == 'e' || lower_c == 'i' || lower_c == 'o' || lower_c == 'u';\n}\n\nstring remove_vowels(string text) {\n    string result;\n    for (char c : text) {\n        if (!is_vowel(c)) {\n            result += c;\n        }\n    }\n    return result;\n}\n\n"}
{"task_id": "CPP/52", "generation": "#include <vector>\n#include <iostream>\n\n// Function to check if all elements in the vector are below the threshold\nbool below_threshold(const std::vector<int>& l, int t) {\n    for (int num : l) {\n        if (num >= t) {\n            return false;\n        }\n    }\n    return true;\n}\n\n// Function to test the below_threshold function with provided data points\nvoid check_function() {\n    assert(below_threshold({1, 2, 4, 10}, 100) == true);\n    assert(below_threshold({1, 20, 4, 10}, 5) == false);\n    std::cout << \"All tests passed successfully.\" << std::endl;\n}\n\n"}
{"task_id": "CPP/53", "generation": "#include <iostream>  // Include iostream for input/output operations\n\nusing namespace std;\n\nint add(int x, int y) {\n    return x + y;  // Return the sum of x and y\n}\n\n"}
{"task_id": "CPP/54", "generation": "#include <iostream>\n#include <string>\n#include <set>\n\nusing namespace std;\n\nbool same_chars(string s0, string s1) {\n    // Create a set for each string to store unique characters\n    set<char> chars_s0(s0.begin(), s0.end());\n    set<char> chars_s1(s1.begin(), s1.end());\n\n    // Compare the sets\n    return chars_s0 == chars_s1;\n}\n\n"}
{"task_id": "CPP/55", "generation": "#include <stdio.h>\nusing namespace std;\n\nint fib(int n) {\n    if (n <= 0) return 0;\n    else if (n == 1) return 1;\n    else return fib(n - 1) + fib(n - 2);\n}\n\n"}
{"task_id": "CPP/56", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    int count = 0;\n    \n    for (char c : brackets) {\n        if (c == '<') {\n            count++;\n        } else if (c == '>') {\n            count--;\n            if (count < 0) {\n                return false; // More closing brackets than opening ones\n            }\n        }\n    }\n    \n    return count == 0; // True if all brackets are correctly matched\n}\n\n"}
{"task_id": "CPP/57", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool monotonic(vector<float> l) {\n    if (l.size() <= 1) {\n        return true; // A vector with 0 or 1 element is trivially monotonic.\n    }\n\n    bool increasing = false;\n    bool decreasing = false;\n\n    for (size_t i = 1; i < l.size(); ++i) {\n        if (l[i] > l[i - 1]) {\n            increasing = true;\n        } else if (l[i] < l[i - 1]) {\n            decreasing = true;\n        }\n\n        // If both increasing and decreasing flags are set, the sequence is not monotonic.\n        if (increasing && decreasing) {\n            return false;\n        }\n    }\n\n    return true; // The sequence is either strictly increasing or strictly decreasing.\n}\n\n"}
{"task_id": "CPP/58", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\n\nusing namespace std;\n\nvector<int> common(vector<int> l1, vector<int> l2) {\n    // Create sets from both vectors\n    set<int> s1(l1.begin(), l1.end());\n    set<int> s2(l2.begin(), l2.end());\n\n    // Find the intersection of the two sets\n    set<int> result;\n    set_intersection(s1.begin(), s1.end(), s2.begin(), s2.end(), inserter(result, result.begin()));\n\n    // Convert the set to a vector and sort it\n    vector<int> commonElements(result.begin(), result.end());\n    sort(commonElements.begin(), commonElements.end());\n\n    return commonElements;\n}\n\n"}
{"task_id": "CPP/59", "generation": "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\nint largest_prime_factor(int n) {\n    // Remove all factors of 2\n    while (n % 2 == 0) {\n        n /= 2;\n    }\n\n    // Check for odd factors from 3 to sqrt(n)\n    int factor = 3;\n    while (factor * factor <= n) {\n        while (n % factor == 0) {\n            n /= factor;\n        }\n        factor += 2;\n    }\n\n    // If n is a prime number greater than 2\n    if (n > 2) {\n        return n;\n    } else {\n        return factor - 2; // The last factor found will be the largest prime factor\n    }\n}\n\n"}
{"task_id": "CPP/60", "generation": "#include <iostream>\nusing namespace std;\n\nint sum_to_n(int n) {\n    int sum = 0;\n    for (int i = 1; i <= n; ++i) {\n        sum += i;\n    }\n    return sum;\n}\n\n// Function to test the sum_to_n function with provided data points\nvoid test_sum_to_n() {\n    cout << \"Testing sum_to_n...\" << endl;\n    assert(sum_to_n(30) == 465);\n    assert(sum_to_n(100) == 5050);\n    assert(sum_to_n(5) == 15);\n    assert(sum_to_n(10) == 55);\n    assert(sum_to_n(1) == 1);\n\n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/61", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    int balance = 0;\n    \n    for (char bracket : brackets) {\n        if (bracket == '(') {\n            balance++;\n        } else if (bracket == ')') {\n            balance--;\n        }\n        \n        // If at any point the balance is negative, it means there's a closing bracket without an opening one\n        if (balance < 0) {\n            return false;\n        }\n    }\n    \n    // If the final balance is zero, all brackets are correctly matched\n    return balance == 0;\n}\n\n"}
{"task_id": "CPP/62", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// Function to compute the derivative of a polynomial represented by its coefficients\nvector<float> derivative(vector<float> xs) {\n    // Create a new vector to hold the derivatives, starting from index 1 (ignoring the constant term)\n    vector<float> result;\n    \n    for (size_t i = 1; i < xs.size(); ++i) {\n        // Multiply each coefficient by its corresponding power\n        result.push_back(xs[i] * static_cast<float>(i));\n    }\n    \n    return result;\n}\n\n// Function to print the polynomial coefficients\nvoid printPolynomial(const vector<float>& coeffs) {\n    for (size_t i = 0; i < coeffs.size(); ++i) {\n        cout << coeffs[i];\n        if (i != coeffs.size() - 1) {\n            cout << \" * x^\" << i;\n        }\n        if (i != coeffs.size() - 2) {\n            cout << \" + \";\n        }\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/63", "generation": "#include <iostream>\nusing namespace std;\n\nint fibfib(int n) {\n    // Base cases\n    if (n == 0 || n == 1) return 0;\n    if (n == 2) return 1;\n\n    // Array to store the computed values of FibFib sequence\n    int dp[n + 1];\n    dp[0] = 0; // fibfib(0)\n    dp[1] = 0; // fibfib(1)\n    dp[2] = 1; // fibfib(2)\n\n    // Fill the dp array using the recurrence relation\n    for (int i = 3; i <= n; ++i) {\n        dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3];\n    }\n\n    return dp[n];\n}\n\n"}
{"task_id": "CPP/64", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint vowels_count(string s) {\n    int count = 0;\n    \n    // Convert the string to lowercase for easier comparison\n    transform(s.begin(), s.end(), s.begin(), ::tolower);\n    \n    // Check each character in the string\n    for (char c : s) {\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' || \n            (c == 'y' && s.length() - 1 == distance(s.begin(), find_if(s.rbegin(), s.rend(), [](char ch) { return !isspace(ch); })))) {\n            count++;\n        }\n    }\n    \n    return count;\n}\n\n"}
{"task_id": "CPP/65", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring circular_shift(int x, int shift) {\n    // Convert integer to string\n    string num_str = to_string(x);\n    \n    // Get the length of the number\n    size_t len = num_str.length();\n    \n    // If shift is greater than or equal to the number of digits, reverse the string\n    if (shift >= len) {\n        return num_str;\n    }\n    \n    // Perform circular right shift\n    int effective_shift = shift % len;  // To handle shifts larger than the length\n    string shifted_str = num_str.substr(len - effective_shift) + num_str.substr(0, len - effective_shift);\n    \n    return shifted_str;\n}\n\n"}
{"task_id": "CPP/66", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint digitSum(const string& s) {\n    int sum = 0;\n    for (char c : s) {\n        if (isupper(c)) { // Check if the character is uppercase\n            sum += static_cast<int>(c); // Add its ASCII value to the sum\n        }\n    }\n    return sum;\n}\n\n// Function to test the digitSum function with provided examples\nvoid checkFunction() {\n    assert(digitSum(\"\") == 0);\n    assert(digitSum(\"abAB\") == 131);\n    assert(digitSum(\"abcCd\") == 67);\n    assert(digitSum(\"helloE\") == 69);\n    assert(digitSum(\"woArBld\") == 131);\n    assert(digitSum(\"aAaaaXa\") == 153);\n\n    cout << \"All test cases passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/67", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint fruit_distribution(string s, int n) {\n    // Find the positions of 'apples' and 'oranges'\n    size_t apples_pos = s.find(\"apples\");\n    size_t oranges_pos = s.find(\"oranges\");\n\n    // Extract the number of apples\n    string apples_str = s.substr(apples_pos - 1, apples_pos);\n    int apples_count = stoi(apples_str);\n\n    // Extract the number of oranges\n    string oranges_str = s.substr(oranges_pos - 1, oranges_pos);\n    int oranges_count = stoi(oranges_str);\n\n    // Calculate the number of mangoes\n    int mangoes_count = n - (apples_count + oranges_count);\n\n    return mangoes_count;\n}\n\n"}
{"task_id": "CPP/68", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> pluck(vector<int> arr) {\n    if (arr.empty()) return {};\n\n    int minEvenValue = -1;\n    int minIndex = -1;\n\n    for (int i = 0; i < arr.size(); ++i) {\n        if (arr[i] % 2 == 0) { // Check if the node value is even\n            if (minEvenValue == -1 || arr[i] < minEvenValue || \n                (arr[i] == minEvenValue && i < minIndex)) {\n                minEvenValue = arr[i];\n                minIndex = i;\n            }\n        }\n    }\n\n    return {minEvenValue, minIndex};\n}\n\n"}
{"task_id": "CPP/69", "generation": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint search(vector<int> lst) {\n    // Create a frequency map to count occurrences of each integer\n    unordered_map<int, int> freqMap;\n    \n    // Count the frequency of each number in the vector\n    for (int num : lst) {\n        freqMap[num]++;\n    }\n    \n    // Initialize the result as -1\n    int result = -1;\n    \n    // Iterate through the unique numbers and check the condition\n    for (auto& pair : freqMap) {\n        if (pair.first <= pair.second && pair.first > result) {\n            result = pair.first;\n        }\n    }\n    \n    return result;\n}\n\n// Function to test the search function with provided examples\nvoid test() {\n    cout << \"search({4, 1, 2, 2, 3, 1}) == \" << search({4, 1, 2, 2, 3, 1}) << endl; // Should output 2\n    cout << \"search({1, 2, 2, 3, 3, 3, 4, 4, 4}) == \" << search({1, 2, 2, 3, 3, 3, 4, 4, 4}) << endl; // Should output 3\n    cout << \"search({5, 5, 4, 4, 4}) == \" << search({5, 5, 4, 4, 4}) << endl; // Should output -1\n}\n\n"}
{"task_id": "CPP/70", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> strange_sort_list(vector<int> lst) {\n    // Sort the input vector in ascending order\n    sort(lst.begin(), lst.end());\n    \n    vector<int> result;\n    int start = 0; // Start index for minimum values\n    int end = lst.size() - 1; // End index for maximum values\n    \n    while (start <= end) {\n        if (start == end) {\n            // If only one element is left, add it to the result\n            result.push_back(lst[start]);\n        } else {\n            // Add minimum value from the start of the sorted list\n            result.push_back(lst[start++]);\n            // Add maximum value from the end of the sorted list\n            result.push_back(lst[end--]);\n        }\n    }\n    \n    return result;\n}\n\n// Function to check the correctness of the strange_sort_list function\nvoid check() {\n    assert(strange_sort_list({1, 2, 3, 4}) == vector<int>({1, 4, 2, 3}));\n    assert(strange_sort_list({5, 5, 5, 5}) == vector<int>({5, 5, 5, 5}));\n    assert(strange_sort_list({}) == vector<int>({}));\n    cout << \"All test cases passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/71", "generation": "#include <stdio.h>\n#include <math.h>\n\nusing namespace std;\n\nfloat triangle_area(float a, float b, float c) {\n    // Check if the sides form a valid triangle\n    if (a + b <= c || a + c <= b || b + c <= a) {\n        return -1;\n    }\n\n    // Calculate the semi-perimeter\n    float s = (a + b + c) / 2.0;\n\n    // Calculate the area using Heron's formula\n    float area = sqrt(s * (s - a) * (s - b) * (s - c));\n\n    // Round the result to 2 decimal points\n    return round(area * 100) / 100;\n}\n\n"}
{"task_id": "CPP/72", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool will_it_fly(vector<int> q, int w) {\n    // Check if the sum of elements is within the weight limit\n    int sum = 0;\n    for (int num : q) {\n        sum += num;\n    }\n    if (sum > w) return false;\n\n    // Check if the vector is a palindrome\n    for (size_t i = 0; i < q.size() / 2; ++i) {\n        if (q[i] != q[q.size() - 1 - i]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\n// Function to test the will_it_fly function with provided examples\nvoid check() {\n    cout << boolalpha; // Print bools as true/false instead of 1/0\n    cout << \"will_it_fly({1, 2}, 5): \" << will_it_fly({1, 2}, 5) << endl;\n    cout << \"will_it_fly({3, 2, 3}, 1): \" << will_it_fly({3, 2, 3}, 1) << endl;\n    cout << \"will_it_fly({3, 2, 3}, 9): \" << will_it_fly({3, 2, 3}, 9) << endl;\n    cout << \"will_it_fly({3}, 5): \" << will_it_fly({3}, 5) << endl;\n}\n\n"}
{"task_id": "CPP/73", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint smallest_change(vector<int> arr) {\n    int n = arr.size();\n    int left = 0;\n    int right = n - 1;\n    int changes = 0;\n\n    while (left < right) {\n        if (arr[left] != arr[right]) {\n            changes++;\n        }\n        left++;\n        right--;\n    }\n\n    return changes;\n}\n\n"}
{"task_id": "CPP/74", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to calculate the total number of characters in a vector of strings\nint total_chars(const vector<string>& vec) {\n    int sum = 0;\n    for (const auto& str : vec) {\n        sum += str.length();\n    }\n    return sum;\n}\n\nvector<string> total_match(vector<string> lst1, vector<string> lst2) {\n    // Calculate the total number of characters in both vectors\n    int chars_lst1 = total_chars(lst1);\n    int chars_lst2 = total_chars(lst2);\n\n    // Compare and return the appropriate vector\n    if (chars_lst1 < chars_lst2) {\n        return lst1;\n    } else if (chars_lst2 < chars_lst1) {\n        return lst2;\n    } else {\n        return lst1;  // Return the first vector if both have the same number of characters\n    }\n}\n\n// Function to test the total_match function with provided examples\nvoid test_total_match() {\n    cout << \"Test 1: \";\n    vector<string> result = total_match({}, {});\n    for (const auto& str : result) {\n        cout << str << \" \";\n    }\n    cout << endl;\n\n    cout << \"Test 2: \";\n    result = total_match({\"hi\", \"admin\"}, {\"hI\", \"Hi\"});\n    for (const auto& str : result) {\n        cout << str << \" \";\n    }\n    cout << endl;\n\n    cout << \"Test 3: \";\n    result = total_match({\"hi\", \"admin\"}, {\"hi\", \"hi\", \"admin\", \"project\"});\n    for (const auto& str : result) {\n        cout << str << \" \";\n    }\n    cout << endl;\n\n    cout << \"Test 4: \";\n    result = total_match({\"hi\", \"admin\"}, {\"hI\", \"hi\", \"hi\"});\n    for (const auto& str : result) {\n        cout << str << \" \";\n    }\n    cout << endl;\n\n    cout << \"Test 5: \";\n    result = total_match({\"4\"}, {\"1\", \"2\", \"3\", \"4\", \"5\"});\n    for (const auto& str : result) {\n        cout << str << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/75", "generation": "#include <iostream>\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    if (n == 2 || n == 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    for (int i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0)\n            return false;\n    }\n    return true;\n}\n\n// Function to check if the given number is a product of exactly three prime numbers\nbool is_multiply_prime(int a) {\n    // Generate all primes less than 100\n    int primes[] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97};\n    int num_primes = sizeof(primes) / sizeof(primes[0]);\n\n    // Try all combinations of three primes\n    for (int i = 0; i < num_primes; ++i) {\n        for (int j = i; j < num_primes; ++j) {\n            for (int k = j; k < num_primes; ++k) {\n                if (primes[i] * primes[j] * primes[k] == a)\n                    return true;\n            }\n        }\n    }\n\n    return false;\n}\n\n// Function to test the is_multiply_prime function\nvoid test() {\n    cout << \"Testing is_multiply_prime...\" << endl;\n    assert(is_multiply_prime(30) == true); // 2 * 3 * 5 = 30\n    assert(is_multiply_prime(60) == false); // Not a product of exactly three primes\n    assert(is_multiply_prime(105) == true); // 3 * 5 * 7 = 105\n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/76", "generation": "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\nbool is_simple_power(int x, int n) {\n    if (n == 1) {\n        return x == 1; // Special case: 1^any_number = 1\n    }\n    \n    double log_result = log(x) / log(n);\n    return floor(log_result) == log_result;\n}\n\n"}
{"task_id": "CPP/77", "generation": "#include <stdio.h>\n#include <math.h>\n\nusing namespace std;\n\nbool iscube(int a) {\n    // Handle special cases: 0 and 1\n    if (a == 0 || a == 1) return true;\n    \n    // Calculate the cube root of the absolute value of 'a'\n    double cubeRoot = cbrt(abs(a));\n    \n    // Round the cube root to the nearest integer\n    int roundedCubeRoot = round(cubeRoot);\n    \n    // Check if cubing the rounded value gives back the original number\n    return (int)pow(roundedCubeRoot, 3) == a;\n}\n\n// Function to test the iscube function with provided examples\nvoid testIscube() {\n    printf(\"iscube(1) ==> %s\\n\", iscube(1) ? \"true\" : \"false\");\n    printf(\"iscube(2) ==> %s\\n\", iscube(2) ? \"true\" : \"false\");\n    printf(\"iscube(-1) ==> %s\\n\", iscube(-1) ? \"true\" : \"false\");\n    printf(\"iscube(64) ==> %s\\n\", iscube(64) ? \"true\" : \"false\");\n    printf(\"iscube(0) ==> %s\\n\", iscube(0) ? \"true\" : \"false\");\n    printf(\"iscube(180) ==> %s\\n\", iscube(180) ? \"true\" : \"false\");\n}\n\n"}
{"task_id": "CPP/78", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nint hex_key(string num) {\n    // Define a set of prime hexadecimal digits\n    const string primes = \"2357BD\";\n    \n    int count = 0;\n    \n    // Iterate through each character in the input string\n    for (char c : num) {\n        if (primes.find(c) != string::npos) {\n            ++count;  // Increment count if the digit is prime\n        }\n    }\n    \n    return count;\n}\n\n"}
{"task_id": "CPP/79", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\n// Function to convert decimal to binary\nstring decimal_to_binary(int decimal) {\n    if (decimal == 0) {\n        return \"db0db\";\n    }\n\n    string binary = \"\";\n    while (decimal > 0) {\n        int remainder = decimal % 2;\n        binary = to_string(remainder) + binary;\n        decimal /= 2;\n    }\n    \n    // Add the prefix and suffix\n    return \"db\" + binary + \"db\";\n}\n\n// Function to check the correctness of the conversion\nvoid check_conversion(int decimal, const string& expected) {\n    string result = decimal_to_binary(decimal);\n    cout << \"decimal: \" << decimal << \", expected: \" << expected << \", got: \" << result << endl;\n    if (result == expected) {\n        cout << \"Test passed.\" << endl;\n    } else {\n        cout << \"Test failed.\" << endl;\n    }\n}\n\n"}
{"task_id": "CPP/80", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_happy(string s) {\n    // Check if the string length is less than 3\n    if (s.length() < 3) return false;\n    \n    // Iterate through the string, checking every set of three consecutive characters\n    for (size_t i = 0; i <= s.length() - 3; ++i) {\n        // Check if any two out of the three consecutive characters are the same\n        if (s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]) {\n            return false;\n        }\n    }\n    \n    // If no three consecutive characters are the same, the string is happy\n    return true;\n}\n\n"}
{"task_id": "CPP/81", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\n// Function to convert GPA to letter grade\nstring gpa_to_letter(float gpa) {\n    if (gpa >= 4.0f) return \"A+\";\n    else if (gpa > 3.7f) return \"A\";\n    else if (gpa > 3.3f) return \"A-\";\n    else if (gpa > 3.0f) return \"B+\";\n    else if (gpa > 2.7f) return \"B\";\n    else if (gpa > 2.3f) return \"B-\";\n    else if (gpa > 2.0f) return \"C+\";\n    else if (gpa > 1.7f) return \"C\";\n    else if (gpa > 1.3f) return \"C-\";\n    else if (gpa > 1.0f) return \"D+\";\n    else if (gpa > 0.7f) return \"D\";\n    else if (gpa > 0.0f) return \"D-\";\n    else return \"E\";\n}\n\n// Function to convert vector of GPAs to vector of letter grades\nvector<string> numerical_letter_grade(vector<float> grades) {\n    vector<string> letter_grades;\n    for (float gpa : grades) {\n        letter_grades.push_back(gpa_to_letter(gpa));\n    }\n    return letter_grades;\n}\n\n// Function to check the correctness of the function\nvoid check() {\n    vector<float> test_grades = {4.0f, 3.0f, 1.7f, 2.0f, 3.5f};\n    vector<string> expected = {\"A+\", \"B\", \"C-\", \"C\", \"A-\"};\n    vector<string> result = numerical_letter_grade(test_grades);\n    \n    if (result == expected) {\n        cout << \"Test passed!\" << endl;\n    } else {\n        cout << \"Test failed. Expected: \";\n        for (const auto& grade : expected) {\n            cout << grade << \" \";\n        }\n        cout << \"\\nGot: \";\n        for (const auto& grade : result) {\n            cout << grade << \" \";\n        }\n        cout << endl;\n    }\n}\n\n"}
{"task_id": "CPP/82", "generation": "#include <iostream>\n#include <string>\n\n// Function to check if a number is prime\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    if (n == 2 || n == 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n\n    for (int i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0)\n            return false;\n    }\n    return true;\n}\n\n// Function to check if the length of a string is prime\nbool prime_length(string str) {\n    int len = str.length();\n    return is_prime(len);\n}\n\n"}
{"task_id": "CPP/83", "generation": "#include <iostream>\nusing namespace std;\n\nint starts_one_ends(int n) {\n    if (n == 1) return 1; // Special case for 1-digit numbers\n\n    long long count = 2 * pow(10, n - 1) - pow(10, n - 2);\n    return count;\n}\n\n"}
{"task_id": "CPP/84", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring solve(int N) {\n    int sum = 0;\n    \n    // Calculate the sum of digits\n    while (N > 0) {\n        sum += N % 10;  // Add the last digit to the sum\n        N /= 10;        // Remove the last digit from N\n    }\n    \n    // Convert the sum to binary string\n    string binarySum = \"\";\n    if (sum == 0) {\n        return \"0\";\n    }\n    \n    while (sum > 0) {\n        binarySum = to_string(sum % 2) + binarySum;  // Prepend the remainder when divided by 2\n        sum /= 2;                                    // Divide the sum by 2\n    }\n    \n    return binarySum;\n}\n\n"}
{"task_id": "CPP/85", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint add(vector<int> lst) {\n    int sum = 0;\n    \n    // Iterate through the vector starting from index 1 (second element)\n    for (size_t i = 1; i < lst.size(); i += 2) {\n        if (lst[i] % 2 == 0) {  // Check if the element at an odd index is even\n            sum += lst[i];\n        }\n    }\n    \n    return sum;\n}\n\n"}
{"task_id": "CPP/86", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to sort the characters of a word in ascending order\nvoid sortWord(string &word) {\n    sort(word.begin(), word.end());\n}\n\n// Function to return an ordered version of the string\nstring anti_shuffle(const string &s) {\n    string result;\n    string currentWord;\n    \n    // Iterate through each character in the input string\n    for (char ch : s) {\n        if (ch == ' ') {\n            // If a space is encountered, sort and add the previous word to the result\n            if (!currentWord.empty()) {\n                sortWord(currentWord);\n                result += currentWord + \" \";\n                currentWord.clear();\n            }\n            result += ch;  // Add the space to the result\n        } else {\n            // Otherwise, append the character to the current word\n            currentWord += ch;\n        }\n    }\n\n    // Sort and add the last word if it exists\n    if (!currentWord.empty()) {\n        sortWord(currentWord);\n        result += currentWord;\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/87", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to get the row and column indices where x appears\nvector<vector<int>> get_row(vector<vector<int>> lst, int x) {\n    vector<vector<int>> result;\n    \n    // Iterate through each row in the list\n    for (size_t i = 0; i < lst.size(); ++i) {\n        const auto& row = lst[i];\n        \n        // Iterate through each element in the current row\n        for (size_t j = 0; j < row.size(); ++j) {\n            if (row[j] == x) {\n                result.push_back({static_cast<int>(i), static_cast<int>(j)});\n            }\n        }\n    }\n\n    // Sort by rows in ascending order and then by columns in descending order within each row\n    sort(result.begin(), result.end(), [](const vector<int>& a, const vector<int>& b) {\n        if (a[0] == b[0]) return a[1] > b[1]; // Descending order for columns\n        return a[0] < b[0]; // Ascending order for rows\n    });\n\n    return result;\n}\n\n// Function to print the result for verification\nvoid print_result(const vector<vector<int>>& result) {\n    for (const auto& coord : result) {\n        cout << \"{\" << coord[0] << \", \" << coord[1] << \"} \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/88", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> sort_array(vector<int> array) {\n    // Check if the vector is empty or has only one element\n    if (array.empty() || array.size() == 1) {\n        return array;\n    }\n\n    int first = array.front();\n    int last = array.back();\n\n    // Calculate the sum of the first and last elements\n    int sum = first + last;\n\n    // Determine the sorting order based on the sum being odd or even\n    if (sum % 2 == 0) {\n        // Sort in descending order\n        vector<int> sorted_array(array);\n        sort(sorted_array.rbegin(), sorted_array.rend());\n        return sorted_array;\n    } else {\n        // Sort in ascending order\n        vector<int> sorted_array(array);\n        sort(sorted_array.begin(), sorted_array.end());\n        return sorted_array;\n    }\n}\n\n// Function to test the solution with provided examples\nvoid check() {\n    printf(\"{%s}\\n\", sort_array({}).empty() ? \"[]\" : \"{5, 4, 3, 2, 1}\"); // Example might be incorrect for empty vector\n    printf(\"{%d}\\n\", sort_array({5})[0]); // Should return {5}\n    printf(\"{%s}\\n\", sort_array({2, 4, 3, 0, 1, 5}).begin(), sort_array({2, 4, 3, 0, 1, 5}).end()); // Should return [0, 1, 2, 3, 4, 5]\n    printf(\"{%s}\\n\", sort_array({2, 4, 3, 0, 1, 5, 6}).rbegin(), sort_array({2, 4, 3, 0, 1, 5, 6}).rend()); // Should return [6, 5, 4, 3, 2, 1, 0]\n}\n\n"}
{"task_id": "CPP/89", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\n// Function to rotate a single character by 4 places\nchar rotateChar(char c) {\n    if (c >= 'a' && c <= 'z') {\n        return ((c - 'a' + 4) % 26) + 'a';\n    } else if (c >= 'A' && c <= 'Z') {\n        return ((c - 'A' + 4) % 26) + 'A';\n    }\n    // Non-alphabetic characters are not rotated\n    return c;\n}\n\n// Function to encrypt the string by rotating each character\nstring encrypt(string s) {\n    for (char &c : s) {\n        c = rotateChar(c);\n    }\n    return s;\n}\n\n"}
{"task_id": "CPP/90", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint next_smallest(vector<int> lst) {\n    // If the vector is empty or has less than 2 unique elements, return None (represented as -1)\n    if (lst.size() < 2 || (unique(lst.begin(), lst.end()) == lst.begin())) {\n        return -1; // Using -1 to represent None\n    }\n\n    // Sort the list and remove duplicates\n    sort(lst.begin(), lst.end());\n    auto last_unique = unique(lst.begin(), lst.end());\n\n    // Return the second smallest element\n    if (last_unique != lst.end()) {\n        return *(++lst.begin()); // Move past the first element to get the second one\n    }\n\n    return -1; // This line should theoretically never be reached due to previous checks\n}\n\n"}
{"task_id": "CPP/91", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nint is_bored(string S) {\n    int count = 0;\n    \n    // Use stringstream to split the string into sentences based on delimiters\n    stringstream ss(S);\n    string sentence;\n    \n    while (getline(ss, sentence, '.')) {\n        if (!sentence.empty()) {\n            getline(ss, sentence, '?');\n            if (!sentence.empty()) {\n                getline(ss, sentence, '!');\n                if (!sentence.empty() && sentence.substr(0, 1) == \"I\") {\n                    count++;\n                }\n            }\n        }\n    }\n    \n    return count;\n}\n\n"}
{"task_id": "CPP/92", "generation": "#include <iostream>\nusing namespace std;\n\nbool is_integer(float num) {\n    return floor(num) == num;\n}\n\nbool any_int(float a, float b, float c) {\n    // Check if all numbers are integers\n    if (is_integer(a) && is_integer(b) && is_integer(c)) {\n        // Check if one of the numbers is equal to the sum of the other two\n        return (a == b + c) || (b == a + c) || (c == a + b);\n    } else {\n        return false;\n    }\n}\n\n"}
{"task_id": "CPP/93", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to encode a message by swapping cases and replacing vowels\nstring encode(string message) {\n    // Swap case of all letters\n    transform(message.begin(), message.end(), message.begin(),\n              [](unsigned char c) { return islower(c) ? toupper(c) : tolower(c); });\n\n    // Define the mapping for vowels\n    string vowels = \"aeiouAEIOU\";\n    string replacement_vowels = \"cgikmoCGIKMO\";\n\n    // Replace each vowel with its corresponding character in the replacement_vowels\n    for (size_t i = 0; i < message.length(); ++i) {\n        if (vowels.find(message[i]) != string::npos) {\n            size_t index = vowels.find(message[i]);\n            message[i] = replacement_vowels[index];\n        }\n    }\n\n    return message;\n}\n\n"}
{"task_id": "CPP/94", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Function to check if a number is prime\nbool isPrime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\n// Function to calculate the sum of digits of a number\nint sumOfDigits(int n) {\n    int sum = 0;\n    while (n > 0) {\n        sum += n % 10;\n        n /= 10;\n    }\n    return sum;\n}\n\n// Main function to find the largest prime and its digit sum\nint largestPrimeDigitSum(vector<int> lst) {\n    int maxPrime = -1; // Initialize with a non-prime number\n\n    for (int num : lst) {\n        if (isPrime(num)) {\n            if (num > maxPrime) {\n                maxPrime = num;\n            }\n        }\n    }\n\n    return maxPrime == -1 ? 0 : sumOfDigits(maxPrime);\n}\n\n// Function to test the solution with provided examples\nvoid check() {\n    vector<int> lst1 = {0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3};\n    cout << \"Test 1: \" << largestPrimeDigitSum(lst1) << endl; // Output should be 10\n\n    vector<int> lst2 = {1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1};\n    cout << \"Test 2: \" << largestPrimeDigitSum(lst2) << endl; // Output should be 25\n\n    vector<int> lst3 = {1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3};\n    cout << \"Test 3: \" << largestPrimeDigitSum(lst3) << endl; // Output should be 13\n\n    vector<int> lst4 = {0,724,32,71,99,32,6,0,5,91,83,0,5,6};\n    cout << \"Test 4: \" << largestPrimeDigitSum(lst4) << endl; // Output should be 11\n\n    vector<int> lst5 = {0,81,12,3,1,21};\n    cout << \"Test 5: \" << largestPrimeDigitSum(lst5) << endl; // Output should be 3\n\n    vector<int> lst6 = {0,8,1,2,1,7};\n    cout << \"Test 6: \" << largestPrimeDigitSum(lst6) << endl; // Output should be 7\n}\n\n"}
{"task_id": "CPP/95", "generation": "#include <iostream>\n#include <string>\n#include <map>\n\nusing namespace std;\n\nbool check_dict_case(map<string, string> dict) {\n    // Check if the map is empty\n    if (dict.empty()) {\n        return false;\n    }\n\n    // Determine the case of the first key\n    bool allLower = true;\n    bool allUpper = true;\n\n    for (const auto &pair : dict) {\n        const string& key = pair.first;\n        if (!islower(key[0])) {\n            allLower = false;\n        }\n        if (!isupper(key[0])) {\n            allUpper = false;\n        }\n\n        // If both flags are false, it means the keys are mixed case\n        if (!allLower && !allUpper) {\n            return false;\n        }\n    }\n\n    // Return true only if all keys are in the same case\n    return allLower || allUpper;\n}\n\n// Function to test the check_dict_case function with provided examples\nvoid test_check_dict_case() {\n    cout << (check_dict_case({{\"a\", \"apple\"}, {\"b\", \"banana\"}}) ? \"true\" : \"false\") << endl; // true\n    cout << (check_dict_case({{\"a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}) ? \"true\" : \"false\") << endl; // false\n    cout << (check_dict_case({{\"a\", \"apple\"}, {\"8\", \"banana\"}, {\"a\", \"apple\"}}) ? \"true\" : \"false\") << endl; // false\n    cout << (check_dict_case({{\"Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}) ? \"true\" : \"false\") << endl; // false\n    cout << (check_dict_case({{\"STATE\", \"NC\"}, {\"ZIP\", \"12345\"}}) ? \"true\" : \"false\") << endl; // true\n}\n\n"}
{"task_id": "CPP/96", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Helper function to check if a number is prime\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    for (int i = 2; i * i <= num; ++i) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\n// Function to generate a vector of prime numbers less than n\nvector<int> count_up_to(int n) {\n    vector<int> primes;\n    for (int i = 2; i < n; ++i) {\n        if (is_prime(i)) {\n            primes.push_back(i);\n        }\n    }\n    return primes;\n}\n\n// Function to test the count_up_to function\nvoid test_count_up_to() {\n    assert(count_up_to(5) == vector<int>({2, 3}));\n    assert(count_up_to(11) == vector<int>({2, 3, 5, 7}));\n    assert(count_up_to(0).empty());\n    assert(count_up_to(20) == vector<int>({2, 3, 5, 7, 11, 13, 17, 19}));\n    assert(count_up_to(1).empty());\n    assert(count_up_to(18) == vector<int>({2, 3, 5, 7, 11, 13, 17}));\n\n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/97", "generation": "#include <iostream>\nusing namespace std;\n\nint multiply(int a, int b) {\n    // Extract the unit digit of both numbers\n    int unit_digit_a = abs(a % 10);\n    int unit_digit_b = abs(b % 10);\n\n    // Multiply the unit digits and return the result\n    return unit_digit_a * unit_digit_b;\n}\n\n"}
{"task_id": "CPP/98", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint count_upper(const string& s) {\n    int count = 0;\n    for (size_t i = 0; i < s.length(); i += 2) { // Iterate through even indices\n        char c = s[i];\n        if (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n            count++;\n        }\n    }\n    return count;\n}\n\n"}
{"task_id": "CPP/99", "generation": "#include <iostream>\n#include <cmath>\n#include <string>\nusing namespace std;\n\nint closest_integer(string value) {\n    // Convert string to double\n    double num = stod(value);\n    \n    // Determine the two nearest integers\n    int lower_int = static_cast<int>(floor(num));\n    int upper_int = static_cast<int>(ceil(num));\n    \n    // Check which integer is closer or if they are equidistant, round away from zero\n    if (num - lower_int == upper_int - num) {\n        return abs(num) > abs(lower_int) ? upper_int : lower_int;\n    } else {\n        return num - lower_int < 0.5 ? lower_int : upper_int;\n    }\n}\n\n"}
{"task_id": "CPP/100", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> make_a_pile(int n) {\n    vector<int> pile;\n    int current_stones = n;\n\n    for (int i = 0; i < n; ++i) {\n        pile.push_back(current_stones);\n        // Determine the next number of stones\n        if (current_stones % 2 == 0) {\n            current_stones += 2; // Next even number\n        } else {\n            current_stones += 2; // Next odd number\n        }\n    }\n\n    return pile;\n}\n\n// Function to check the correctness of the solution\nvoid check_solution() {\n    vector<int> result1 = make_a_pile(3);\n    assert(result1 == vector<int>({3, 5, 7}));\n\n    vector<int> result2 = make_a_pile(4);\n    assert(result2 == vector<int>({4, 6, 8, 10}));\n\n    vector<int> result3 = make_a_pile(1);\n    assert(result3 == vector<int>({1, 3}));\n\n    cout << \"All test cases passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/101", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nvector<string> words_string(string s) {\n    vector<string> result;\n    stringstream ss(s);\n    string word;\n\n    while (getline(ss, word, ',')) {  // Split by commas first\n        stringstream wordStream(word);  // Create a new stream for the current word\n        while (wordStream >> word) {  // Extract words from the current word\n            result.push_back(word);\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/102", "generation": "#include <iostream>\nusing namespace std;\n\nint choose_num(int x, int y) {\n    // Ensure x is less than or equal to y\n    if (x > y) {\n        return -1;\n    }\n\n    // Start from the end of the range and check for the largest even number\n    for (int i = y; i >= x; --i) {\n        if (i % 2 == 0) {\n            return i;\n        }\n    }\n\n    // If no even number is found, return -1\n    return -1;\n}\n\n// Function to test the choose_num function with some examples\nvoid test() {\n    cout << \"choose_num(12, 15): \" << choose_num(12, 15) << endl; // Should output 14\n    cout << \"choose_num(13, 12): \" << choose_num(13, 12) << endl; // Should output -1\n    cout << \"choose_num(10, 20): \" << choose_num(10, 20) << endl; // Should output 20\n    cout << \"choose_num(21, 25): \" << choose_num(21, 25) << endl; // Should output 24\n}\n\n"}
{"task_id": "CPP/103", "generation": "#include <stdio.h>\n#include <math.h>\n#include <string>\nusing namespace std;\n\nstring rounded_avg(int n, int m) {\n    // Check if n is greater than m\n    if (n > m) {\n        return \"-1\";\n    }\n\n    // Calculate the sum of integers from n to m\n    long long sum = 0;\n    for (int i = n; i <= m; ++i) {\n        sum += i;\n    }\n\n    // Calculate the average and round it down\n    int avg = sum / (m - n + 1);\n\n    // Convert the rounded average to binary string\n    string binary = \"\";\n    if (avg == 0) {\n        binary = \"0\";\n    } else {\n        while (avg > 0) {\n            binary = to_string(avg % 2) + binary;\n            avg /= 2;\n        }\n    }\n\n    return binary;\n}\n\n"}
{"task_id": "CPP/104", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nbool hasEvenDigit(int num) {\n    while (num > 0) {\n        int digit = num % 10;\n        if (digit % 2 == 0) {\n            return true; // Found an even digit\n        }\n        num /= 10;\n    }\n    return false; // No even digits found\n}\n\nvector<int> unique_digits(vector<int> x) {\n    vector<int> result;\n\n    for (int num : x) {\n        if (!hasEvenDigit(num)) {\n            result.push_back(num);\n        }\n    }\n\n    sort(result.begin(), result.end());\n    return result;\n}\n\n"}
{"task_id": "CPP/105", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to convert a digit to its corresponding name\nstring num_to_word(int n) {\n    map<int, string> digit_names = {\n        {1, \"One\"}, {2, \"Two\"}, {3, \"Three\"}, {4, \"Four\"},\n        {5, \"Five\"}, {6, \"Six\"}, {7, \"Seven\"}, {8, \"Eight\"}, {9, \"Nine\"}\n    };\n    return digit_names[n];\n}\n\n// Function to process the vector as per the problem statement\nvector<string> by_length(vector<int> arr) {\n    // Filter out numbers that are not between 1 and 9\n    vector<int> filtered_arr;\n    for (int num : arr) {\n        if (num >= 1 && num <= 9) {\n            filtered_arr.push_back(num);\n        }\n    }\n\n    // Sort the filtered array\n    sort(filtered_arr.begin(), filtered_arr.end());\n\n    // Reverse the sorted array\n    reverse(filtered_arr.begin(), filtered_arr.end());\n\n    // Convert each number to its corresponding name and store in a vector of strings\n    vector<string> result;\n    for (int num : filtered_arr) {\n        result.push_back(num_to_word(num));\n    }\n\n    return result;\n}\n\n// Function to check the correctness of the by_length function\nvoid check() {\n    vector<int> arr1 = {2, 1, 1, 4, 5, 8, 2, 3};\n    vector<string> expected1 = {\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"};\n    assert(by_length(arr1) == expected1);\n\n    vector<int> arr2 = {};\n    vector<string> expected2 = {};\n    assert(by_length(arr2) == expected2);\n\n    vector<int> arr3 = {1, -1, 55};\n    vector<string> expected3 = {\"One\"};\n    assert(by_length(arr3) == expected3);\n\n    printf(\"All test cases passed.\\n\");\n}\n\n"}
{"task_id": "CPP/106", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Function to compute the factorial of a number\nint factorial(int num) {\n    if (num == 0 || num == 1)\n        return 1;\n    int fact = 1;\n    for (int i = 2; i <= num; ++i) {\n        fact *= i;\n    }\n    return fact;\n}\n\n// Function to compute the sum of numbers from 1 to a number\nint sumTo(int num) {\n    return (num * (num + 1)) / 2;\n}\n\nvector<int> f(int n) {\n    vector<int> result(n);\n    \n    for (int i = 0; i < n; ++i) {\n        if ((i + 1) % 2 == 0) { // Check if the index is even\n            result[i] = factorial(i + 1); // Factorial of (i+1)\n        } else { // The index is odd\n            result[i] = sumTo(i + 1); // Sum from 1 to (i+1)\n        }\n    }\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/107", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nbool is_palindrome(int num) {\n    string str = to_string(num);\n    int left = 0;\n    int right = str.length() - 1;\n    \n    while (left < right) {\n        if (str[left] != str[right]) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n    return true;\n}\n\nvector<int> even_odd_palindrome(int n) {\n    vector<int> result(2, 0); // Initialize with two elements for even and odd counts\n    for (int i = 1; i <= n; ++i) {\n        if (is_palindrome(i)) {\n            if (i % 2 == 0) {\n                result[0]++; // Even palindrome count\n            } else {\n                result[1]++; // Odd palindrome count\n            }\n        }\n    }\n    return result;\n}\n\n"}
{"task_id": "CPP/108", "generation": "#include <iostream>\n#include <vector>\n\nint count_nums(const std::vector<int>& n) {\n    int count = 0;\n    \n    for (int num : n) {\n        int sum_of_digits = 0;\n        \n        // Handle negative numbers by making them positive and then subtracting the first digit later\n        if (num < 0) {\n            num = -num; // Make it positive\n            sum_of_digits -= num % 10; // Subtract the last digit which is now the first signed digit\n            num /= 10;\n        }\n        \n        while (num > 0) {\n            sum_of_digits += num % 10;\n            num /= 10;\n        }\n        \n        if (sum_of_digits > 0) {\n            count++;\n        }\n    }\n    \n    return count;\n}\n\n"}
{"task_id": "CPP/109", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool move_one_ball(vector<int> arr) {\n    int N = arr.size();\n    \n    // Check if there's any element that is greater than its next element (considering circular shift)\n    for (int i = 0; i < N; ++i) {\n        if (arr[i] > arr[(i + 1) % N]) {\n            return false;\n        }\n    }\n    \n    // If no such condition exists, it's possible to sort the array with right shifts\n    return true;\n}\n\n"}
{"task_id": "CPP/110", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring exchange(vector<int> lst1, vector<int> lst2) {\n    int oddCountLst1 = 0;\n    \n    // Count the number of odd elements in lst1\n    for (int num : lst1) {\n        if (num % 2 != 0) {\n            oddCountLst1++;\n        }\n    }\n\n    // If there are no odd elements in lst1, it's already all even\n    if (oddCountLst1 == 0) {\n        return \"YES\";\n    }\n\n    int oddCountLst2 = 0;\n    \n    // Count the number of odd elements in lst2\n    for (int num : lst2) {\n        if (num % 2 != 0) {\n            oddCountLst2++;\n        }\n    }\n\n    // If there are enough odd elements in lst2 to replace all odd elements in lst1, return \"YES\"\n    if (oddCountLst2 >= oddCountLst1) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n\n"}
{"task_id": "CPP/111", "generation": "#include <iostream>\n#include <string>\n#include <map>\n#include <vector>\nusing namespace std;\n\nmap<char, int> histogram(string test) {\n    map<char, int> charCount;\n    \n    // Count occurrences of each character\n    for (char c : test) {\n        if (c != ' ') {  // Ignore spaces\n            charCount[c]++;\n        }\n    }\n\n    // Find the maximum count\n    int maxCount = 0;\n    for (const auto& pair : charCount) {\n        if (pair.second > maxCount) {\n            maxCount = pair.second;\n        }\n    }\n\n    // Collect characters with the highest frequency\n    map<char, int> result;\n    for (const auto& pair : charCount) {\n        if (pair.second == maxCount) {\n            result.insert(pair);\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/112", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to check if a string is a palindrome\nbool is_palindrome(const string& str) {\n    int left = 0;\n    int right = str.size() - 1;\n    while (left < right) {\n        if (str[left] != str[right]) {\n            return false;\n        }\n        ++left;\n        --right;\n    }\n    return true;\n}\n\n// Function to reverse delete characters\nvector<string> reverse_delete(string s, string c) {\n    // Remove all characters in s that are present in c\n    for (char ch : c) {\n        s.erase(remove(s.begin(), s.end(), ch), s.end());\n    }\n\n    // Check if the resulting string is a palindrome\n    bool result = is_palindrome(s);\n\n    // Return the result as a vector containing the modified string and the boolean\n    return {s, (result ? \"True\" : \"False\")};\n}\n\n"}
{"task_id": "CPP/113", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<string> odd_count(vector<string> lst) {\n    vector<string> result;\n    \n    for (const auto& str : lst) {\n        int count = 0;\n        \n        // Count the number of odd digits in the string\n        for (char c : str) {\n            if ((c - '0') % 2 != 0) {\n                count++;\n            }\n        }\n\n        // Construct the result string\n        string output = \"the number of odd elements \";\n        output += to_string(count);\n        output += \"n the str\";\n        output += to_string(count);\n        output += \"ng \";\n        output += to_string(count);\n        output += \" of the \";\n        output += to_string(count);\n        output += \"nput.\";\n        \n        result.push_back(output);\n    }\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/114", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nlong long minSubArraySum(vector<long long> nums) {\n    if (nums.empty()) return 0; // Handle empty vector case\n\n    long long current_min = nums[0];\n    long long global_min = nums[0];\n\n    for (size_t i = 1; i < nums.size(); ++i) {\n        // Update the current minimum sum ending at position i\n        current_min = min(nums[i], current_min + nums[i]);\n        \n        // Update the global minimum sum found so far\n        if (current_min < global_min) {\n            global_min = current_min;\n        }\n    }\n\n    return global_min;\n}\n\n"}
{"task_id": "CPP/115", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint max_fill(vector<vector<int>> grid, int capacity) {\n    int total_lowerings = 0;\n    \n    // Iterate through each well (row)\n    for (const auto& row : grid) {\n        int water_units = 0;\n        \n        // Count the number of units of water in the current well\n        for (int unit : row) {\n            if (unit == 1) {\n                ++water_units;\n            }\n        }\n        \n        // Calculate the number of times the bucket needs to be lowered\n        total_lowerings += (water_units + capacity - 1) / capacity;\n    }\n    \n    return total_lowerings;\n}\n\n"}
{"task_id": "CPP/116", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to count the number of ones in the binary representation of an integer\nint count_ones(int n) {\n    int count = 0;\n    while (n > 0) {\n        count += n & 1; // Check if the least significant bit is set\n        n >>= 1; // Right shift to check the next bit\n    }\n    return count;\n}\n\n// Comparator function for sorting based on number of ones and then by decimal value\nbool compare(int a, int b) {\n    int ones_a = count_ones(a);\n    int ones_b = count_ones(b);\n\n    if (ones_a == ones_b) {\n        return a < b; // If the number of ones is the same, sort by decimal value\n    }\n    return ones_a < ones_b; // Otherwise, sort based on the number of ones\n}\n\nvector<int> sort_array(vector<int> arr) {\n    // Sort the array using the custom comparator\n    sort(arr.begin(), arr.end(), compare);\n    return arr;\n}\n\n"}
{"task_id": "CPP/117", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\n// Helper function to check if a character is a consonant.\nbool is_consonant(char c) {\n    return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z');\n}\n\n// Function to count the number of consonants in a word.\nint count_consonants(const string& word) {\n    int count = 0;\n    for (char c : word) {\n        if (islower(c)) c = toupper(c); // Convert to uppercase to simplify checking\n        if (is_consonant(c)) ++count;\n    }\n    return count;\n}\n\n// Main function that returns words with exactly n consonants.\nvector<string> select_words(const string& s, int n) {\n    vector<string> result;\n    stringstream ss(s);\n    string word;\n\n    while (ss >> word) { // Extract each word from the stream\n        if (count_consonants(word) == n) {\n            result.push_back(word);\n        }\n    }\n\n    return result;\n}\n\n// Function to test the select_words function.\nvoid test_select_words() {\n    assert(select_words(\"Mary had a little lamb\", 4) == vector<string>{\"little\"});\n    assert(select_words(\"Mary had a little lamb\", 3) == vector<string>{\"Mary\", \"lamb\"});\n    assert(select_words(\"simple white space\", 2) == vector<string>{});\n    assert(select_words(\"Hello world\", 4) == vector<string>{\"world\"});\n    assert(select_words(\"Uncle sam\", 3) == vector<string>{\"Uncle\"});\n\n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/118", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_vowel(char c) {\n    return tolower(c) == 'a' || tolower(c) == 'e' || tolower(c) == 'i' || tolower(c) == 'o' || tolower(c) == 'u';\n}\n\nbool is_consonant(char c) {\n    return !is_vowel(c) && isalpha(c);\n}\n\nstring get_closest_vowel(string word) {\n    int n = word.length();\n    \n    // Iterate from the second last character to the first\n    for (int i = n - 2; i >= 0; --i) {\n        if (is_consonant(word[i]) && is_consonant(word[i + 1])) {\n            // Check if the current character is a vowel and between two consonants\n            if (is_vowel(word[i])) {\n                return string(1, word[i]);\n            }\n        }\n    }\n\n    // If no such vowel found, return an empty string\n    return \"\";\n}\n\n"}
{"task_id": "CPP/119", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\n// Helper function to count open and close parentheses\nint count_parentheses(const string& s, char open, char close) {\n    int balance = 0;\n    for (char c : s) {\n        if (c == open) balance++;\n        else if (c == close) balance--;\n        if (balance < 0) return -1; // Early exit if unbalanced\n    }\n    return balance == 0 ? 0 : 1; // 0 means balanced, 1 means not balanced\n}\n\n// Main function to check if the strings can be concatenated to form a good string\nstring match_parens(vector<string> lst) {\n    string s1 = lst[0];\n    string s2 = lst[1];\n\n    // Check both permutations: s1 + s2 and s2 + s1\n    int balance_s1s2 = count_parentheses(s1, '(', ')') + count_parentheses(s2, '(', ')');\n    int balance_s2s1 = count_parentheses(s2, '(', ')') + count_parentheses(s1, '(', ')');\n\n    if (balance_s1s2 == 0 || balance_s2s1 == 0) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\n\n"}
{"task_id": "CPP/120", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> maximum(vector<int> arr, int k) {\n    // Sort the array in descending order\n    sort(arr.begin(), arr.end(), greater<int>());\n    \n    // If k is 0 or negative, return an empty vector\n    if (k <= 0 || k > arr.size()) {\n        return {};\n    }\n    \n    // Slice the first k elements from the sorted array\n    vector<int> result(arr.begin(), arr.begin() + k);\n    \n    // Sort the resulting vector in ascending order as required\n    sort(result.begin(), result.end());\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/121", "generation": "#include <vector>\nusing namespace std;\n\nint solution(vector<int> lst) {\n    int sum = 0;\n    for (size_t i = 0; i < lst.size(); ++i) {\n        // Check if the index is even and the element at that position is odd\n        if (i % 2 == 0 && lst[i] % 2 != 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n\n// Function to test the solution with provided examples\nvoid check_solution() {\n    assert(solution({5, 8, 7, 1}) == 12);\n    assert(solution({3, 3, 3, 3, 3}) == 9);\n    assert(solution({30, 13, 24, 321}) == 0);\n}\n\n"}
{"task_id": "CPP/122", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// Function to check if a number has at most two digits\nbool hasAtMostTwoDigits(int num) {\n    return num >= 0 && num <= 99;\n}\n\n// Function to sum elements with at most two digits from the first k elements of arr\nint add_elements(vector<int> arr, int k) {\n    int sum = 0;\n    for (int i = 0; i < k; ++i) {\n        if (hasAtMostTwoDigits(arr[i])) {\n            sum += arr[i];\n        }\n    }\n    return sum;\n}\n\n// Function to test the add_elements function\nvoid test() {\n    vector<int> arr1 = {111, 21, 3, 4000, 5, 6, 7, 8, 9};\n    int k1 = 4;\n    cout << \"Test Case 1: Expected Output: 24, Actual Output: \" << add_elements(arr1, k1) << endl;\n\n    vector<int> arr2 = {10, 20, 30, 40, 50};\n    int k2 = 5;\n    cout << \"Test Case 2: Expected Output: 150, Actual Output: \" << add_elements(arr2, k2) << endl;\n\n    vector<int> arr3 = {9876, 5432, 123, 456, 789};\n    int k3 = 3;\n    cout << \"Test Case 3: Expected Output: 123, Actual Output: \" << add_elements(arr3, k3) << endl;\n\n    vector<int> arr4 = {0, -1, -2, -3, -4};\n    int k4 = 5;\n    cout << \"Test Case 4: Expected Output: 0, Actual Output: \" << add_elements(arr4, k4) << endl;\n}\n\n"}
{"task_id": "CPP/123", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n// Function to generate and return the odd numbers in the Collatz sequence of n.\nvector<int> get_odd_collatz(int n) {\n    vector<int> result;\n    \n    // Generate the Collatz sequence until it reaches 1\n    while (n != 1) {\n        if (n % 2 == 0) {\n            n /= 2;  // If n is even, divide by 2\n        } else {\n            result.push_back(n);  // If n is odd, add to the result vector\n            n = 3 * n + 1;  // Apply the Collatz transformation\n        }\n    }\n    \n    // Add the final number (which is 1) to the result vector\n    result.push_back(1);\n    \n    // Sort the result vector in increasing order\n    sort(result.begin(), result.end());\n    \n    return result;\n}\n\n// Function to test the get_odd_collatz function with some examples.\nvoid test_get_odd_collatz() {\n    cout << \"Testing get_odd_collatz...\" << endl;\n    assert(get_odd_collatz(5) == vector<int>({1, 5}));\n    assert(get_odd_collatz(7) == vector<int>({1, 7, 11, 22}));\n    assert(get_odd_collatz(1) == vector<int>({1}));\n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/124", "generation": "#include <iostream>\n#include <string>\n#include <vector>\n\nbool valid_date(const std::string& date) {\n    // Check if the date format is correct (mm-dd-yyyy)\n    size_t pos = 0;\n    int month, day, year;\n\n    // Extract month, day, and year from the string\n    pos = date.find('-');\n    if (pos == std::string::npos || pos != 2) return false; // Format error\n\n    month = std::stoi(date.substr(0, pos));\n    \n    pos += 1;\n    day = std::stoi(date.substr(pos, 2));\n\n    pos += 3;\n    year = std::stoi(date.substr(pos));\n\n    // Check if the date is in a valid format\n    if (month < 1 || month > 12) return false; // Month must be between 1 and 12\n\n    int days_in_month[12] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\n\n    // Check for leap year\n    if (year % 4 == 0 && (year % 100 != 0 || year % 400 == 0)) {\n        days_in_month[1] = 29; // February has 29 days in a leap year\n    }\n\n    // Check the number of days for each month\n    if (day < 1 || day > days_in_month[month - 1]) return false;\n\n    return true;\n}\n\n"}
{"task_id": "CPP/125", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nvector<string> split_words(string txt) {\n    // Check for whitespace splitting\n    size_t pos = txt.find(' ');\n    if (pos != string::npos) {\n        vector<string> result;\n        while ((pos = txt.find(' ')) != string::npos) {\n            result.push_back(txt.substr(0, pos));\n            txt.erase(0, pos + 1);\n        }\n        result.push_back(txt); // Add the last word\n        return result;\n    }\n\n    // Check for comma splitting\n    size_t pos_comma = txt.find(',');\n    if (pos_comma != string::npos) {\n        vector<string> result;\n        while ((pos_comma = txt.find(',')) != string::npos) {\n            result.push_back(txt.substr(0, pos_comma));\n            txt.erase(0, pos_comma + 1);\n        }\n        result.push_back(txt); // Add the last word\n        return result;\n    }\n\n    // Count lowercase letters with odd order in the alphabet\n    int count = 0;\n    for (char c : txt) {\n        if (islower(c)) {\n            if ((c - 'a') % 2 == 1) {\n                count++;\n            }\n        }\n    }\n    return vector<string>{to_string(count)};\n}\n\n// Function to test the split_words function\nvoid test_split_words() {\n    assert(split_words(\"Hello world!\") == vector<string>{\"Hello\", \"world!\"});\n    assert(split_words(\"Hello,world!\") == vector<string>{\"Hello\", \"world!\"});\n    assert(split_words(\"abcdef\") == vector<string>{\"3\"});\n    cout << \"All tests passed.\" << endl;\n}\n\n"}
{"task_id": "CPP/126", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nbool is_sorted(vector<int> lst) {\n    // Check if the list is already sorted or not\n    bool sorted = is_sorted(lst.begin(), lst.end());\n    \n    // If not sorted, return false immediately\n    if (!sorted) return false;\n    \n    // Count occurrences of each number in the vector\n    for (int i = 0; i < lst.size(); ++i) {\n        int count = 1;\n        while (i + 1 < lst.size() && lst[i] == lst[i + 1]) {\n            count++;\n            i++;\n        }\n        // If any number appears more than twice, return false\n        if (count > 2) return false;\n    }\n    \n    // If both conditions are met, return true\n    return true;\n}\n\n"}
{"task_id": "CPP/127", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to check if a number is prime\nbool isPrime(int n) {\n    if (n <= 1) return false;\n    if (n == 2 || n == 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    for (int i = 5; i * i <= n; i += 6)\n        if (n % i == 0 || n % (i + 2) == 0)\n            return false;\n    return true;\n}\n\n// Function to find the intersection of two intervals and check if its length is prime\nstring intersection(vector<int> interval1, vector<int> interval2) {\n    int start = max(interval1[0], interval2[0]);\n    int end = min(interval1[1], interval2[1]);\n\n    // Check for valid intersection\n    if (start > end) return \"NO\";\n\n    // Calculate the length of the intersection\n    int length = end - start + 1;\n\n    // Check if the length is a prime number\n    if (isPrime(length)) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n\n"}
{"task_id": "CPP/128", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint prod_signs(vector<int> arr) {\n    if (arr.empty()) {\n        return -32768;\n    }\n\n    int sign_product = 1;\n    int magnitude_sum = 0;\n\n    for (int num : arr) {\n        // Calculate the product of signs\n        if (num < 0) {\n            sign_product *= -1;\n        } else if (num == 0) {\n            sign_product = 0; // If any number is zero, the product will be zero\n            break;\n        }\n\n        // Calculate the sum of magnitudes\n        magnitude_sum += abs(num);\n    }\n\n    return sign_product * magnitude_sum;\n}\n\n// Function to test the prod_signs function with provided examples\nvoid check() {\n    cout << \"Checking examples:\" << endl;\n    assert(prod_signs({1, 2, 2, -4}) == -9); // (-1) * (1 + 2 + 2 + 4) = -9\n    assert(prod_signs({0, 1}) == 0);         // 0 * (abs(0) + abs(1)) = 0\n    assert(prod_signs({}) == -32768);        // Empty vector case\n\n    cout << \"All checks passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/129", "generation": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <tuple>\n\nusing namespace std;\n\n// Define a structure to hold the state of the current path\nstruct PathState {\n    int x, y; // Current cell coordinates\n    vector<int> values; // Values visited in the current path\n\n    bool operator<(const PathState& other) const {\n        // Compare paths lexicographically\n        for (int i = 0; i < min(values.size(), other.values.size()); ++i) {\n            if (values[i] != other.values[i]) return values[i] > other.values[i];\n        }\n        return values.size() > other.values.size();\n    }\n};\n\nvector<int> minPath(vector<vector<int>> grid, int k) {\n    int N = grid.size();\n    priority_queue<PathState, vector<PathState>, greater<>> pq;\n    \n    // Initialize the priority queue with all possible starting points\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            pq.push({i, j, {grid[i][j]}});\n        }\n    }\n\n    // Directions for moving to neighboring cells\n    vector<pair<int, int>> directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n\n    while (!pq.empty()) {\n        PathState current = pq.top();\n        pq.pop();\n\n        if (current.values.size() == k) {\n            // If the path length is exactly k, return it\n            return current.values;\n        }\n\n        for (auto& dir : directions) {\n            int nx = current.x + dir.first;\n            int ny = current.y + dir.second;\n\n            // Check if the new position is within bounds\n            if (nx >= 0 && nx < N && ny >= 0 && ny < N) {\n                vector<int> nextValues = current.values;\n                nextValues.push_back(grid[nx][ny]);\n                pq.push({nx, ny, move(nextValues)});\n            }\n        }\n    }\n\n    // This line should never be reached due to the problem constraints\n    return {};\n}\n\n"}
{"task_id": "CPP/130", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Function to compute the nth Tribonacci number\nint tribonacci(int n) {\n    if (n == 0) return 3;\n    if (n == 1) return 1 + n / 2;\n    \n    int a = 3, b = 1 + 1 / 2; // tri(0) and tri(1)\n    int c = 0;\n\n    for (int i = 2; i <= n; ++i) {\n        if (i % 2 == 0) {\n            c = 1 + i / 2;\n        } else {\n            c = a + b + tribonacci(i + 1);\n        }\n        a = b;\n        b = c;\n    }\n\n    return b;\n}\n\n// Function to generate the first n+1 Tribonacci numbers\nvector<int> tri(int n) {\n    vector<int> result(n + 1, 0);\n    \n    for (int i = 0; i <= n; ++i) {\n        result[i] = tribonacci(i);\n    }\n    \n    return result;\n}\n\n// Function to print the vector\nvoid printVector(const vector<int>& vec) {\n    for (int num : vec) {\n        cout << num << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/131", "generation": "#include <iostream>\nusing namespace std;\n\nint digits(int n) {\n    int product = 1;\n    bool hasOddDigit = false;\n\n    while (n > 0) {\n        int digit = n % 10; // Get the last digit of n\n        if (digit % 2 != 0) { // Check if the digit is odd\n            product *= digit; // Multiply it to the product\n            hasOddDigit = true;\n        }\n        n /= 10; // Remove the last digit from n\n    }\n\n    return hasOddDigit ? product : 0;\n}\n\n"}
{"task_id": "CPP/132", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_nested(string str) {\n    int balance = 0;\n    bool hasNested = false;\n\n    for (char c : str) {\n        if (c == '[') {\n            balance++;\n            // If we find a nested bracket, set the flag\n            if (balance > 1 && !hasNested) {\n                hasNested = true;\n            }\n        } else if (c == ']') {\n            balance--;\n            if (balance < 0) {\n                // This means there's an unmatched closing bracket\n                return false;\n            }\n        }\n    }\n\n    // Check if we have any nested brackets and the string is balanced\n    return hasNested && balance == 0;\n}\n\n"}
{"task_id": "CPP/133", "generation": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nint sum_squares(vector<float> lst) {\n    int sum = 0;\n    \n    for (float num : lst) {\n        // Round up to the nearest integer\n        float ceil_num = ceil(num);\n        \n        // Add the square of the rounded number to the sum\n        sum += static_cast<int>(ceil_num * ceil_num);\n    }\n    \n    return sum;\n}\n\n"}
{"task_id": "CPP/134", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool check_if_last_char_is_a_letter(string txt) {\n    // If the string is empty, return false\n    if (txt.empty()) {\n        return false;\n    }\n\n    // Trim trailing whitespace\n    auto last = txt.find_last_not_of(' ');\n    if (last == string::npos) {\n        return false;  // The string consists only of spaces\n    }\n    txt = txt.substr(0, last + 1);\n\n    // Check if the last character is an alphabetical character and not part of a word\n    char lastChar = txt.back();\n    if (!isalpha(lastChar)) {\n        return false;\n    }\n\n    // Ensure it's not preceded by another non-space character\n    if (last > 0 && !isspace(txt[last - 1])) {\n        return true;\n    }\n    return false;\n}\n\n"}
{"task_id": "CPP/135", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint can_arrange(vector<int> arr) {\n    if (arr.size() <= 1) {\n        return -1; // No elements or only one element means no such index exists.\n    }\n\n    for (int i = arr.size() - 2; i >= 0; --i) {\n        if (arr[i] > arr[i + 1]) {\n            return i;\n        }\n    }\n\n    return -1; // Return -1 if no such element is found.\n}\n\n// Function to test the can_arrange function\nvoid check() {\n    assert(can_arrange({1, 2, 4, 3, 5}) == 3);\n    assert(can_arrange({1, 2, 3}) == -1);\n    assert(can_arrange({5, 4, 3, 2, 1}) == 0);\n    assert(can_arrange({1, 3, 5, 7, 6}) == 4);\n    cout << \"All test cases passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/136", "generation": "#include <iostream>\n#include <vector>\n#include <climits> // For INT_MIN and INT_MAX\n\nusing namespace std;\n\nvector<int> largest_smallest_integers(vector<int> lst) {\n    int max_negative = INT_MIN; // Initialize with smallest possible integer\n    int min_positive = INT_MAX; // Initialize with largest possible integer\n    \n    for (int num : lst) {\n        if (num < 0 && num > max_negative) {\n            max_negative = num;\n        } else if (num > 0 && num < min_positive) {\n            min_positive = num;\n        }\n    }\n\n    vector<int> result = {max_negative, min_positive};\n    \n    // If no negative or positive integers were found, set the values to 0\n    if (max_negative == INT_MIN) max_negative = 0;\n    if (min_positive == INT_MAX) min_positive = 0;\n\n    return result;\n}\n\n// Function to test the implementation with provided examples\nvoid check() {\n    vector<int> lst1 = {2, 4, 1, 3, 5, 7};\n    vector<int> lst2 = {};\n    vector<int> lst3 = {0};\n\n    cout << \"Test Case 1: \";\n    printVector(largest_smallest_integers(lst1)); // Expected output: [0, 1]\n    \n    cout << \"Test Case 2: \";\n    printVector(largest_smallest_integers(lst2)); // Expected output: [0, 0]\n    \n    cout << \"Test Case 3: \";\n    printVector(largest_smallest_integers(lst3)); // Expected output: [0, 0]\n}\n\n// Helper function to print the vector\nvoid printVector(const vector<int>& vec) {\n    for (int num : vec) {\n        cout << num << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/137", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <boost/any.hpp>\n\n// Function to convert string with comma as decimal separator to float\nfloat str_to_float(const std::string& s) {\n    size_t pos;\n    return std::stof(s, &pos); // Convert the string to a float\n}\n\nboost::any compare_one(boost::any a, boost::any b) {\n    if (a.type() == typeid(int)) {\n        int ai = std::any_cast<int>(a);\n        if (b.type() == typeid(int)) {\n            int bi = std::any_cast<int>(b);\n            return (ai > bi) ? ai : (ai == bi ? boost::any(\"None\") : bi);\n        } else if (b.type() == typeid(float)) {\n            float bf = std::any_cast<float>(b);\n            return (ai > bf) ? ai : (ai == bf ? boost::any(\"None\") : bf);\n        } else if (b.type() == typeid(std::string)) {\n            std::string bs = std::any_cast<std::string>(b);\n            float bf = str_to_float(bs); // Convert string to float\n            return (ai > bf) ? ai : (ai == bf ? boost::any(\"None\") : bf);\n        }\n    } else if (a.type() == typeid(float)) {\n        float af = std::any_cast<float>(a);\n        if (b.type() == typeid(int)) {\n            int bi = std::any_cast<int>(b);\n            return (af > bi) ? af : (af == bi ? boost::any(\"None\") : bi);\n        } else if (b.type() == typeid(float)) {\n            float bf = std::any_cast<float>(b);\n            return (af > bf) ? af : (af == bf ? boost::any(\"None\") : bf);\n        } else if (b.type() == typeid(std::string)) {\n            std::string bs = std::any_cast<std::string>(b);\n            float bf = str_to_float(bs); // Convert string to float\n            return (af > bf) ? af : (af == bf ? boost::any(\"None\") : bf);\n        }\n    } else if (a.type() == typeid(std::string)) {\n        std::string as = std::any_cast<std::string>(a);\n        if (b.type() == typeid(int)) {\n            int bi = std::any_cast<int>(b);\n            float af = str_to_float(as); // Convert string to float\n            return (af > bi) ? af : (af == bi ? boost::any(\"None\") : bi);\n        } else if (b.type() == typeid(float)) {\n            float bf = std::any_cast<float>(b);\n            float af = str_to_float(as); // Convert string to float\n            return (af > bf) ? af : (af == bf ? boost::any(\"None\") : bf);\n        } else if (b.type() == typeid(std::string)) {\n            std::string bs = std::any_cast<std::string>(b);\n            float af = str_to_float(as); // Convert string to float\n            float bf = str_to_float(bs); // Convert string to float\n            return (af > bf) ? as : (af == bf ? boost::any(\"None\") : bs);\n        }\n    }\n\n    return boost::any(\"None\"); // Default case, should not reach here if types are correct\n}\n\n"}
{"task_id": "CPP/138", "generation": "#include <iostream>\nusing namespace std;\n\nbool is_equal_to_sum_even(int n) {\n    // Since the smallest sum of 4 positive even numbers is 2 + 2 + 2 + 2 = 8,\n    // any number less than 8 cannot be written as such a sum.\n    if (n < 8) return false;\n\n    // Any number greater than or equal to 8 can be written as the sum of\n    // exactly 4 positive even numbers because we can always subtract 8 and add back\n    // four more 2's, which is still an even number.\n    return true;\n}\n\n"}
{"task_id": "CPP/139", "generation": "#include <iostream>\n\n// Function to calculate factorial of a number\nlong long factorial(long long num) {\n    if (num == 0 || num == 1)\n        return 1;\n    else\n        return num * factorial(num - 1);\n}\n\n// Function to calculate Brazilian factorial\nlong long special_factorial(int n) {\n    long long result = 1;\n    for (int i = n; i > 0; --i) {\n        result *= factorial(i);\n    }\n    return result;\n}\n\n"}
{"task_id": "CPP/140", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring fix_spaces(string text) {\n    int consecutiveSpaces = 0;\n    for (int i = 0; i < text.length(); ++i) {\n        if (text[i] == ' ') {\n            consecutiveSpaces++;\n        } else {\n            if (consecutiveSpaces > 2) {\n                // Replace the last three spaces with '-'\n                text.erase(i - 3, 3);\n                text.insert(i - 3, \"-\");\n                i -= 3; // Adjust index to account for the replacement\n            }\n            consecutiveSpaces = 0;\n        }\n    }\n\n    // Handle trailing spaces if any (more than two)\n    if (consecutiveSpaces > 2) {\n        int lastSpaceIndex = text.length() - 1;\n        while (lastSpaceIndex >= 0 && text[lastSpaceIndex] == ' ') {\n            lastSpaceIndex--;\n        }\n        if (lastSpaceIndex + 3 < text.length()) {\n            text.erase(lastSpaceIndex + 3, text.length() - lastSpaceIndex - 3);\n            text.insert(lastSpaceIndex + 3, \"-\");\n        }\n    }\n\n    // Replace remaining single spaces with '_'\n    for (int i = 0; i < text.length(); ++i) {\n        if (text[i] == ' ') {\n            text.replace(i, 1, \"_\");\n            i++; // Skip the next character as it's now an underscore\n        }\n    }\n\n    return text;\n}\n\n"}
{"task_id": "CPP/141", "generation": "#include <iostream>\n#include <string>\n#include <cctype> // for std::isalpha\n\nusing namespace std;\n\nbool hasMoreThanThreeDigits(const string& name) {\n    int digitCount = 0;\n    for (char c : name) {\n        if (isdigit(c)) {\n            digitCount++;\n            if (digitCount > 3) return true;\n        }\n    }\n    return false;\n}\n\nstring file_name_check(string file_name) {\n    // Check the number of digits\n    if (hasMoreThanThreeDigits(file_name)) return \"No\";\n\n    // Find the position of the dot\n    size_t dotPos = file_name.find('.');\n    if (dotPos == string::npos || dotPos == 0 || dotPos == file_name.length() - 1) {\n        return \"No\";\n    }\n\n    // Check the substring before the dot\n    for (size_t i = 0; i < dotPos; ++i) {\n        if (!isalpha(file_name[i])) {\n            return \"No\";\n        }\n    }\n\n    // Check the extension after the dot\n    string extension = file_name.substr(dotPos + 1);\n    if (extension != \"txt\" && extension != \"exe\" && extension != \"dll\") {\n        return \"No\";\n    }\n\n    return \"Yes\";\n}\n\n"}
{"task_id": "CPP/142", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint sum_squares(vector<int> lst) {\n    int sum = 0;\n    \n    for (size_t i = 0; i < lst.size(); ++i) {\n        if ((i + 1) % 3 == 0 && (i + 1) % 4 != 0) {\n            // Square the integer entry\n            sum += lst[i] * lst[i];\n        } else if ((i + 1) % 4 == 0) {\n            // Cube the integer entry\n            sum += lst[i] * lst[i] * lst[i];\n        }\n    }\n    \n    return sum;\n}\n\n"}
{"task_id": "CPP/143", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    if (n == 2 || n == 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    for (int i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0)\n            return false;\n    }\n    return true;\n}\n\n// Function to process the sentence and return words with prime length\nstring words_in_sentence(string sentence) {\n    stringstream ss(sentence);\n    string word;\n    string result = \"\";\n    \n    while (ss >> word) {\n        if (is_prime(word.length())) {\n            if (!result.empty()) result += \" \";\n            result += word;\n        }\n    }\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/144", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\n// Function to simplify two fractions and check if their product is a whole number\nbool simplify(string x, string n) {\n    // Helper function to parse fraction from string\n    auto parse_fraction = [](const string& frac) -> pair<int, int> {\n        size_t slash_pos = frac.find('/');\n        int numerator = stoi(frac.substr(0, slash_pos));\n        int denominator = stoi(frac.substr(slash_pos + 1));\n        return {numerator, denominator};\n    };\n\n    // Parse the fractions\n    auto [num_x, den_x] = parse_fraction(x);\n    auto [num_n, den_n] = parse_fraction(n);\n\n    // Calculate the product of the numerators and denominators\n    int numerator_product = num_x * num_n;\n    int denominator_product = den_x * den_n;\n\n    // Check if the result is a whole number\n    return (numerator_product % denominator_product) == 0;\n}\n\n"}
{"task_id": "CPP/145", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// Helper function to calculate the sum of digits of an integer\nint digitSum(int n) {\n    int sum = 0;\n    bool isNegative = n < 0;\n    while (n != 0) {\n        int d = abs(n % 10);\n        sum += d;\n        n /= 10;\n    }\n    if (isNegative && sum > 0) {\n        // If the number was negative, subtract the first digit from the sum\n        sum -= 2 * (abs(n % 10)); // Subtract twice the first digit to account for the negative sign\n    }\n    return sum;\n}\n\n// Custom comparator function based on the sum of digits and original index\nbool compareByDigitSumAndIndex(int a, int b) {\n    int sumA = digitSum(a);\n    int sumB = digitSum(b);\n    \n    if (sumA == sumB) {\n        // If sums are equal, use the original index as tiebreaker\n        return a < b;\n    }\n    return sumA < sumB;\n}\n\nvector<int> order_by_points(vector<int> nums) {\n    // Sort the vector using the custom comparator\n    sort(nums.begin(), nums.end(), compareByDigitSumAndIndex);\n    return nums;\n}\n\n// Function to print the vector for testing purposes\nvoid printVector(const vector<int>& vec) {\n    for (int num : vec) {\n        cout << num << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/146", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nint specialFilter(vector<int> nums) {\n    int count = 0;\n    \n    for (int num : nums) {\n        // Skip numbers that are not greater than 10\n        if (num <= 10) continue;\n        \n        string strNum = to_string(num);\n        int firstDigit = strNum[0] - '0';\n        int lastDigit = strNum[strNum.length() - 1] - '0';\n        \n        // Check if both the first and last digits are odd\n        if (firstDigit % 2 != 0 && lastDigit % 2 != 0) {\n            count++;\n        }\n    }\n    \n    return count;\n}\n\n"}
{"task_id": "CPP/147", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint get_max_triples(int n) {\n    // Step 1: Generate the vector a\n    vector<int> a(n);\n    for (int i = 1; i <= n; ++i) {\n        a[i - 1] = i * i - i + 1;\n    }\n\n    int count = 0;\n\n    // Step 2 and 3: Iterate through all possible triples (i, j, k)\n    for (int i = 0; i < n - 2; ++i) {\n        for (int j = i + 1; j < n - 1; ++j) {\n            for (int k = j + 1; k < n; ++k) {\n                if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                    count++;\n                }\n            }\n        }\n    }\n\n    return count;\n}\n\n// Function to test the solution\nvoid check() {\n    int result = get_max_triples(5);\n    cout << \"Output: \" << result << endl; // Expected output: 1\n}\n\n"}
{"task_id": "CPP/148", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to check if a given planet name is valid\nbool isValidPlanet(const string& planet) {\n    vector<string> planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n    return find(planets.begin(), planets.end(), planet) != planets.end();\n}\n\n// Function to get the index of a given planet in the sorted list\nint getIndex(const string& planet) {\n    vector<string> planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n    return find(planets.begin(), planets.end(), planet) - planets.begin();\n}\n\n// Function to get the list of planets between two given planets\nvector<string> bf(string planet1, string planet2) {\n    if (!isValidPlanet(planet1) || !isValidPlanet(planet2)) {\n        return {};\n    }\n\n    int index1 = getIndex(planet1);\n    int index2 = getIndex(planet2);\n\n    // Ensure index1 is less than index2\n    if (index1 > index2) {\n        swap(index1, index2);\n    }\n\n    vector<string> planetsBetween;\n    for (int i = index1 + 1; i < index2; ++i) {\n        planetsBetween.push_back(getPlanets()[i]);\n    }\n    return planetsBetween;\n}\n\n// Helper function to get the list of all planets\nvector<string> getPlanets() {\n    return {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n}\n\n"}
{"task_id": "CPP/149", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to sort a vector of strings based on given criteria\nvector<string> sorted_list_sum(vector<string> lst) {\n    // Remove strings with odd lengths\n    lst.erase(remove_if(lst.begin(), lst.end(), [](const string& s) { return s.length() % 2 != 0; }), lst.end());\n\n    // Sort the vector by length, then alphabetically if lengths are equal\n    sort(lst.begin(), lst.end(), [](const string& a, const string& b) {\n        if (a.length() == b.length()) {\n            return a < b;\n        }\n        return a.length() < b.length();\n    });\n\n    return lst;\n}\n\n// Function to check the correctness of the sorted_list_sum function\nvoid check_function() {\n    assert(sorted_list_sum({\"aa\", \"a\", \"aaa\"}) == vector<string>{\"aa\"});\n    assert(sorted_list_sum({\"ab\", \"a\", \"aaa\", \"cd\"}) == vector<string>{\"ab\", \"cd\"});\n    cout << \"All test cases passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/150", "generation": "#include<stdio.h>\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int n) {\n    if (n <= 1) return false; // Numbers less than or equal to 1 are not prime\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\n// Function that returns x if n is a prime number, otherwise returns y\nint x_or_y(int n, int x, int y) {\n    return is_prime(n) ? x : y;\n}\n\n"}
{"task_id": "CPP/151", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nlong long double_the_difference(vector<float> lst) {\n    long long sum = 0;\n    \n    for (float num : lst) {\n        // Check if the number is positive, an integer, and odd\n        if (num > 0 && floor(num) == num && static_cast<int>(num) % 2 != 0) {\n            sum += pow(num, 2);\n        }\n    }\n    \n    return sum;\n}\n\n"}
{"task_id": "CPP/152", "generation": "#include <iostream>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\n// Function to compare the scores with guesses\nvector<int> compare(vector<int> game, vector<int> guess) {\n    vector<int> result;\n    \n    // Iterate through each match and calculate the absolute difference\n    for (size_t i = 0; i < game.size(); ++i) {\n        int diff = abs(game[i] - guess[i]);\n        result.push_back(diff);\n    }\n    \n    return result;\n}\n\n// Function to print a vector of integers\nvoid printVector(const vector<int>& vec) {\n    for (int num : vec) {\n        cout << num << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/153", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to calculate the strength of an extension\nint calculateStrength(const string& extension) {\n    int cap = 0, sm = 0;\n    for (char c : extension) {\n        if (isupper(c)) cap++;\n        else if (islower(c)) sm++;\n    }\n    return cap - sm;\n}\n\nstring Strongest_Extension(string class_name, vector<string> extensions) {\n    string strongest_extension = \"\";\n    int max_strength = INT_MIN;\n\n    for (const string& extension : extensions) {\n        int strength = calculateStrength(extension);\n        if (strength > max_strength) {\n            max_strength = strength;\n            strongest_extension = extension;\n        }\n    }\n\n    return class_name + \".\" + strongest_extension;\n}\n\n// Example usage\n"}
{"task_id": "CPP/154", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool cycpattern_check(string a, string b) {\n    // Concatenate the first word with itself to handle rotation\n    string doubled_a = a + a;\n    \n    // Check if the second word is a substring of the concatenated string\n    return doubled_a.find(b) != string::npos;\n}\n\n"}
{"task_id": "CPP/155", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// Function to count even and odd digits in an integer\nvector<int> even_odd_count(int num) {\n    // Convert the number to a string to easily iterate over each digit\n    string str_num = to_string(abs(num));\n    \n    int even_count = 0;\n    int odd_count = 0;\n    \n    for (char digit : str_num) {\n        if ((digit - '0') % 2 == 0) {\n            even_count++;\n        } else {\n            odd_count++;\n        }\n    }\n    \n    return {even_count, odd_count};\n}\n\n// Function to test the even_odd_count function\nvoid test_even_odd_count() {\n    assert(even_odd_count(-12) == vector<int>({1, 1}));\n    assert(even_odd_count(123) == vector<int>({1, 2}));\n    assert(even_odd_count(0) == vector<int>({1, 0})); // Edge case: single digit 0\n    assert(even_odd_count(-9876543210) == vector<int>({5, 5}));\n    \n    cout << \"All test cases passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/156", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to convert an integer to its Roman numeral equivalent in lowercase\nstring int_to_mini_roman(int number) {\n    // Mapping of integers to their corresponding Roman numerals\n    vector<pair<int, string>> roman_map = {\n        {1000, \"m\"}, {900, \"cm\"}, {500, \"d\"}, {400, \"cd\"},\n        {100, \"c\"}, {90, \"xc\"}, {50, \"l\"}, {40, \"xl\"},\n        {10, \"x\"}, {9, \"ix\"}, {5, \"v\"}, {4, \"iv\"}, {1, \"i\"}\n    };\n\n    string roman_numeral = \"\";\n\n    // Iterate through the map and construct the Roman numeral\n    for (const auto& [value, symbol] : roman_map) {\n        while (number >= value) {\n            roman_numeral += symbol;\n            number -= value;\n        }\n    }\n\n    return roman_numeral;\n}\n\n// Function to check the correctness of the int_to_mini_roman function\nvoid check() {\n    assert(int_to_mini_roman(19) == \"xix\");\n    assert(int_to_mini_roman(152) == \"clii\");\n    assert(int_to_mini_roman(426) == \"cdxxvi\");\n    cout << \"All test cases passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/157", "generation": "#include <stdio.h>\n#include <math.h>\n\nusing namespace std;\n\nbool right_angle_triangle(float a, float b, float c) {\n    // First, sort the sides so that 'c' is the longest side (hypotenuse)\n    if (a > c) swap(a, c);\n    if (b > c) swap(b, c);\n\n    // Check if the Pythagorean theorem holds\n    return fabs(a*a + b*b - c*c) < 1e-6; // Using a small epsilon to account for floating point precision issues\n}\n\n"}
{"task_id": "CPP/158", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to count unique characters in a string\nint count_unique_chars(const string& word) {\n    bool seen[256] = {false};\n    int count = 0;\n    for (char c : word) {\n        if (!seen[c]) {\n            seen[c] = true;\n            count++;\n        }\n    }\n    return count;\n}\n\n// Function to find the word with maximum unique characters\nstring find_max(vector<string> words) {\n    string max_word = \"\";\n    int max_unique_chars = 0;\n\n    for (const auto& word : words) {\n        int unique_chars = count_unique_chars(word);\n        if (unique_chars > max_unique_chars || \n            (unique_chars == max_unique_chars && word < max_word)) {\n            max_word = word;\n            max_unique_chars = unique_chars;\n        }\n    }\n\n    return max_word;\n}\n\n// Function to test the find_max function\nvoid test_find_max() {\n    assert(find_max({\"name\", \"of\", \"string\"}) == \"string\");\n    assert(find_max({\"name\", \"enam\", \"game\"}) == \"enam\");\n    assert(find_max({\"aaaaaaa\", \"bb\", \"cc\"}) == \"aaaaaaa\");\n    cout << \"All test cases passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/159", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nvector<int> eat(int number, int need, int remaining) {\n    // Calculate the maximum number of carrots that can be eaten from the remaining stock\n    int max_to_eat = min(need, remaining);\n    \n    // Update the total number of carrots eaten\n    int total_eaten = number + max_to_eat;\n    \n    // Update the remaining carrots in stock\n    int remaining_after_meal = remaining - max_to_eat;\n    \n    return {total_eaten, remaining_after_meal};\n}\n\n// Function to test the eat function with provided examples\nvoid check() {\n    vector<int> result1 = eat(5, 6, 10);\n    printf(\"eat(5, 6, 10) -> {%d, %d}\\n\", result1[0], result1[1]); // Expected: {11, 4}\n    \n    vector<int> result2 = eat(4, 8, 9);\n    printf(\"eat(4, 8, 9) -> {%d, %d}\\n\", result2[0], result2[1]); // Expected: {12, 1}\n    \n    vector<int> result3 = eat(1, 10, 10);\n    printf(\"eat(1, 10, 10) -> {%d, %d}\\n\", result3[0], result3[1]); // Expected: {11, 0}\n    \n    vector<int> result4 = eat(2, 11, 5);\n    printf(\"eat(2, 11, 5) -> {%d, %d}\\n\", result4[0], result4[1]); // Expected: {7, 0}\n}\n\n"}
{"task_id": "CPP/160", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nint do_algebra(vector<string> operators, vector<int> operands) {\n    if (operands.size() == 0 || operators.size() == 0) {\n        throw invalid_argument(\"Operands and operators vectors must not be empty.\");\n    }\n\n    int result = operands[0];\n\n    for (size_t i = 0; i < operators.size(); ++i) {\n        switch (operators[i][0]) {\n            case '+':\n                result += operands[i + 1];\n                break;\n            case '-':\n                result -= operands[i + 1];\n                break;\n            case '*':\n                result *= operands[i + 1];\n                break;\n            case '/': \n                // Assuming integer division\n                if (operands[i + 1] == 0) {\n                    throw runtime_error(\"Division by zero is not allowed.\");\n                }\n                result /= operands[i + 1];\n                break;\n            case '**':\n                result = pow(result, operands[i + 1]);\n                break;\n            default:\n                throw invalid_argument(\"Invalid operator: \" + operators[i]);\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/161", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\n// Function to solve the problem as described\nstring solve(string s) {\n    bool hasLetters = false;\n    \n    // Check if there are any letters in the string\n    for (char c : s) {\n        if (isalpha(c)) {\n            hasLetters = true;\n            break;\n        }\n    }\n\n    if (!hasLetters) {\n        // If no letters, reverse the entire string\n        reverse(s.begin(), s.end());\n    } else {\n        // If there are letters, convert them to their opposite case\n        for (char &c : s) {\n            if (islower(c)) {\n                c = toupper(c);\n            } else if (isupper(c)) {\n                c = tolower(c);\n            }\n        }\n    }\n\n    return s;\n}\n\n// Function to test the solve function with provided examples\nvoid test() {\n    cout << \"solve(\\\"1234\\\") = \\\"\" << solve(\"1234\") << \"\\\" (Expected: \\\"4321\\\")\" << endl;\n    cout << \"solve(\\\"ab\\\") = \\\"\" << solve(\"ab\") << \"\\\" (Expected: \\\"AB\\\")\" << endl;\n    cout << \"solve(\\\"#a@C\\\") = \\\"\" << solve(\"#a@C\") << \"\\\" (Expected: \\\"#A@c\\\")\" << endl;\n}\n\n"}
{"task_id": "CPP/162", "generation": "#include <iostream>\n#include <openssl/md5.h>\n#include <sstream>\n#include <iomanip>\n\n// Function to convert byte array to hex string\nstd::string bytes_to_hex(const unsigned char* bytes, size_t len) {\n    std::stringstream ss;\n    for (size_t i = 0; i < len; ++i) {\n        ss << std::hex << std::setw(2) << std::setfill('0') << static_cast<int>(bytes[i]);\n    }\n    return ss.str();\n}\n\n// Function to convert string to MD5 hash\nstd::string string_to_md5(const std::string& text) {\n    if (text.empty()) {\n        return \"None\";\n    }\n\n    unsigned char digest[MD5_DIGEST_LENGTH];\n    MD5(reinterpret_cast<const unsigned char*>(text.c_str()), text.length(), digest);\n\n    // Convert the hash to a hexadecimal string\n    return bytes_to_hex(digest, MD5_DIGEST_LENGTH);\n}\n\n"}
{"task_id": "CPP/163", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Function to generate even digits between two integers a and b\nvector<int> generate_integers(int a, int b) {\n    vector<int> result;\n    \n    // Ensure a is less than or equal to b for simplicity\n    if (a > b) swap(a, b);\n    \n    // Iterate through each number in the range [a, b]\n    for (int i = a; i <= b; ++i) {\n        int num = abs(i);  // Use absolute value to handle negative numbers\n        \n        // Check each digit of the current number\n        while (num > 0) {\n            int digit = num % 10;\n            if (digit % 2 == 0 && digit < 10) {  // Check if the digit is even and less than 10\n                result.push_back(digit);\n            }\n            num /= 10;  // Move to the next digit\n        }\n    }\n    \n    return result;\n}\n\n// Function to print the vector of integers\nvoid print_vector(const vector<int>& vec) {\n    for (int i : vec) {\n        cout << i << \" \";\n    }\n    cout << endl;\n}\n\n// Main function to test the generate_integers function\n"}
{"task_id": "CPP/0", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // For std::sort\n\nbool has_close_elements(const std::vector<float>& numbers, float threshold) {\n    // Sort the vector first\n    std::sort(numbers.begin(), numbers.end());\n    \n    // Check adjacent elements for closeness\n    for (size_t i = 0; i < numbers.size() - 1; ++i) {\n        if (numbers[i + 1] - numbers[i] < threshold) {\n            return true;\n        }\n    }\n    \n    // If no such pair is found, return false\n    return false;\n}\n\n"}
{"task_id": "CPP/1", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<string> separate_paren_groups(string paren_string) {\n    // Remove spaces from the input string\n    paren_string.erase(remove(paren_string.begin(), paren_string.end(), ' '), paren_string.end());\n    \n    vector<string> groups;\n    int balance = 0;\n    string current_group;\n    \n    for (char c : paren_string) {\n        if (c == '(') {\n            balance++;\n            current_group += c;\n        } else if (c == ')') {\n            balance--;\n            current_group += c;\n            if (balance == 0) {\n                groups.push_back(current_group);\n                current_group.clear();\n            }\n        }\n    }\n    \n    return groups;\n}\n\n"}
{"task_id": "CPP/2", "generation": "#include <stdio.h>\n#include <math.h>\n\nfloat truncate_number(float number) {\n    float integerPart;\n    modf(number, &integerPart); // modf returns the fractional part and stores the integer part in &integerPart\n    return number - integerPart; // Subtracting the integer part from the original number gives the decimal part\n}\n\n"}
{"task_id": "CPP/3", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool below_zero(const vector<int>& operations) {\n    int balance = 0; // Start with a zero balance\n\n    for (int op : operations) {\n        balance += op; // Update the balance after each operation\n        if (balance < 0) {\n            return true; // Return true if balance falls below zero\n        }\n    }\n\n    return false; // Return false if balance never falls below zero\n}\n\n// Function to test the below_zero function with provided examples\nvoid check() {\n    vector<int> operations1 = {1, 2, 3};\n    vector<int> operations2 = {1, 2, -4, 5};\n\n    cout << \"Test 1: \" << (below_zero(operations1) ? \"true\" : \"false\") << endl;\n    cout << \"Test 2: \" << (below_zero(operations2) ? \"true\" : \"false\") << endl;\n}\n\n"}
{"task_id": "CPP/4", "generation": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nfloat mean_absolute_deviation(vector<float> numbers) {\n    // Calculate the mean of the dataset\n    float sum = 0.0;\n    for (float num : numbers) {\n        sum += num;\n    }\n    float mean = sum / numbers.size();\n\n    // Calculate the Mean Absolute Deviation\n    float mad = 0.0;\n    for (float num : numbers) {\n        mad += abs(num - mean);\n    }\n    mad /= numbers.size();\n\n    return mad;\n}\n\n"}
{"task_id": "CPP/5", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> intersperse(vector<int> numbers, int delimeter) {\n    if (numbers.empty()) return {}; // Return an empty vector if input is empty\n\n    vector<int> result;\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        result.push_back(numbers[i]);\n        if (i != numbers.size() - 1) { // Avoid adding delimiter after the last element\n            result.push_back(delimeter);\n        }\n    }\n\n    return result;\n}\n\n// Function to print the vector for testing purposes\nvoid printVector(const vector<int>& vec) {\n    for (int num : vec) {\n        cout << num << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/6", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<int> parse_nested_parens(string paren_string) {\n    vector<int> depths;\n    size_t start = 0; // Start index for each group\n\n    while (start < paren_string.length()) {\n        int max_depth = 0;\n        int current_depth = 0;\n\n        // Iterate through the characters in the current group\n        for (size_t i = start; i < paren_string.length(); ++i) {\n            if (paren_string[i] == '(') {\n                current_depth++;\n                max_depth = max(max_depth, current_depth);\n            } else if (paren_string[i] == ')') {\n                current_depth--;\n            }\n        }\n\n        // Add the maximum depth to the result vector\n        depths.push_back(max_depth);\n\n        // Move to the next group\n        start += 1 + max_depth; // Skip over the current group and its closing parenthesis\n    }\n\n    return depths;\n}\n\n"}
{"task_id": "CPP/7", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to filter strings containing a given substring\nvector<string> filter_by_substring(vector<string> strings, string substring) {\n    vector<string> filteredStrings;\n    \n    // Iterate through each string in the input vector\n    for (const auto& str : strings) {\n        // Check if the current string contains the substring\n        if (str.find(substring) != string::npos) {\n            // If it does, add it to the filtered list\n            filteredStrings.push_back(str);\n        }\n    }\n    \n    return filteredStrings;\n}\n\n// Function to print a vector of strings for testing purposes\nvoid print_vector(const vector<string>& vec) {\n    cout << \"{ \";\n    for (const auto& str : vec) {\n        cout << \"\\\"\" << str << \"\\\" \";\n    }\n    cout << \"}\" << endl;\n}\n\n"}
{"task_id": "CPP/8", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> sum_product(vector<int> numbers) {\n    int sum = 0;\n    int product = 1;\n\n    // Iterate through each number in the vector\n    for (int num : numbers) {\n        sum += num;  // Add the current number to the sum\n        if (num != 0) {  // Avoid division by zero when calculating product\n            product *= num;\n        }\n    }\n\n    return {sum, product};\n}\n\n// Function to test the sum_product function with some example inputs\nvoid test_sum_product() {\n    vector<int> empty = {};\n    vector<int> nums1 = {1, 2, 3, 4};\n\n    // Test case for an empty vector\n    auto result1 = sum_product(empty);\n    cout << \"Empty Vector: Sum = \" << result1[0] << \", Product = \" << result1[1] << endl;\n\n    // Test case for a non-empty vector\n    auto result2 = sum_product(nums1);\n    cout << \"Non-Empty Vector: Sum = \" << result2[0] << \", Product = \" << result2[1] << endl;\n}\n\n"}
{"task_id": "CPP/9", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> rolling_max(vector<int> numbers) {\n    if (numbers.empty()) return {};  // Return an empty vector if the input is empty\n\n    vector<int> result;\n    int current_max = numbers[0];  // Initialize with the first element\n    for (int num : numbers) {\n        if (num > current_max) {\n            current_max = num;  // Update the current maximum\n        }\n        result.push_back(current_max);  // Add the current maximum to the result vector\n    }\n\n    return result;\n}\n\n// Function to print a vector of integers\nvoid print_vector(const vector<int>& vec) {\n    for (int val : vec) {\n        cout << val << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/10", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_palindrome(const string& str) {\n    // Test if given string is a palindrome\n    return str == string(str.rbegin(), str.rend());\n}\n\nint find_longest_palindromic_suffix(const string& str) {\n    int n = str.length();\n    for (int i = 0; i < n; ++i) {\n        if (is_palindrome(str.substr(i))) {\n            return i;\n        }\n    }\n    return 0;\n}\n\nstring make_palindrome(string str) {\n    /*\n    Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    */\n    int n = str.length();\n    if (n == 0) {\n        return \"\";\n    }\n\n    // Find the length of the longest palindromic suffix\n    int len_of_palindrome_suffix = find_longest_palindromic_suffix(str);\n\n    // The prefix that is not part of the palindromic suffix\n    string non_palindromic_prefix = str.substr(0, n - len_of_palindrome_suffix);\n\n    // Reverse the non-palindromic prefix and append it to the original string\n    reverse(non_palindromic_prefix.begin(), non_palindromic_prefix.end());\n    return str + non_palindromic_prefix;\n}\n\n"}
{"task_id": "CPP/11", "generation": "#include <iostream>\n#include <string>\n\n// Function to perform binary XOR on two strings\nstd::string string_xor(const std::string& a, const std::string& b) {\n    // Ensure both strings are of equal length by padding with leading zeros if necessary\n    size_t max_length = std::max(a.length(), b.length());\n    std::string padded_a(max_length, '0');\n    std::string padded_b(max_length, '0');\n\n    // Copy the original strings to the padded versions\n    for (size_t i = 0; i < a.length(); ++i) {\n        padded_a[max_length - a.length() + i] = a[i];\n    }\n    for (size_t i = 0; i < b.length(); ++i) {\n        padded_b[max_length - b.length() + i] = b[i];\n    }\n\n    // Perform XOR operation\n    std::string result(max_length, '0');\n    for (size_t i = 0; i < max_length; ++i) {\n        if (padded_a[i] == padded_b[i]) {\n            result[i] = '0';\n        } else {\n            result[i] = '1';\n        }\n    }\n\n    return result;\n}\n\n// Function to test the string_xor function\nvoid test_string_xor() {\n    std::string a = \"010\";\n    std::string b = \"110\";\n    std::string expected_result = \"100\";\n\n    std::string result = string_xor(a, b);\n\n    if (result == expected_result) {\n        std::cout << \"Test passed: \" << result << std::endl;\n    } else {\n        std::cout << \"Test failed: Expected \" << expected_result << \", but got \" << result << std::endl;\n    }\n}\n\n"}
{"task_id": "CPP/12", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring longest(vector<string> strings) {\n    if (strings.empty()) {\n        return \"\"; // Return an empty string to indicate None\n    }\n\n    string longestString = strings[0];\n    for (const auto& str : strings) {\n        if (str.length() > longestString.length()) {\n            longestString = str;\n        }\n    }\n    return longestString;\n}\n\n// Function to test the correctness of the longest function\nvoid check() {\n    assert(longest({}) == \"\");\n    assert(longest({\"a\", \"b\", \"c\"}) == \"a\");\n    assert(longest({\"a\", \"bb\", \"ccc\"}) == \"ccc\");\n    cout << \"All tests passed successfully.\" << endl;\n}\n\n"}
{"task_id": "CPP/13", "generation": "#include <stdio.h>\nusing namespace std;\n\nint greatest_common_divisor(int a, int b) {\n    // Ensure a >= b to simplify the loop condition\n    if (a < b) {\n        swap(a, b);\n    }\n\n    while (b != 0) {\n        int temp = b;\n        b = a % b;\n        a = temp;\n    }\n\n    return a;\n}\n\n"}
{"task_id": "CPP/14", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\n// Function to generate all prefixes of a given string\nvector<string> all_prefixes(string str) {\n    vector<string> prefixes;\n    for (size_t i = 1; i <= str.length(); ++i) {\n        // Extract the prefix up to index i and add it to the vector\n        prefixes.push_back(str.substr(0, i));\n    }\n    return prefixes;\n}\n\n// Function to print all elements of a vector of strings\nvoid print_vector(const vector<string>& vec) {\n    for (const auto& str : vec) {\n        cout << \"\\\"\" << str << \"\\\" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/15", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring string_sequence(int n) {\n    if (n < 0) return \"\"; // Handle negative input\n\n    string result = \"\";\n    for (int i = 0; i <= n; ++i) {\n        result += to_string(i);\n        if (i != n) {\n            result += \" \";\n        }\n    }\n    return result;\n}\n\n// Function to test the string_sequence function\nvoid test() {\n    cout << \"Testing with input 5: \" << string_sequence(5) << endl; // Expected output: \"0 1 2 3 4 5\"\n    cout << \"Testing with input 0: \" << string_sequence(0) << endl; // Expected output: \"0\"\n}\n\n"}
{"task_id": "CPP/16", "generation": "#include <iostream>\n#include <string>\n#include <set>\n\nusing namespace std;\n\nint count_distinct_characters(string str) {\n    // Convert string to lowercase (or uppercase) to handle case insensitivity\n    transform(str.begin(), str.end(), str.begin(), ::tolower);\n\n    // Use a set to store distinct characters\n    set<char> distinct_chars(str.begin(), str.end());\n\n    // The size of the set is the number of distinct characters\n    return distinct_chars.size();\n}\n\n"}
{"task_id": "CPP/17", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<int> parse_music(string music_string) {\n    vector<int> beats;\n    \n    // Iterate through the string, processing one character at a time\n    for (size_t i = 0; i < music_string.length(); ++i) {\n        if (music_string[i] == 'o') {  // Whole note\n            beats.push_back(4);\n        } else if (music_string[i] == '|') {  // Check if it's a half or quarter note\n            if (i + 1 < music_string.length() && music_string[i + 1] == '|') {\n                ++i;  // Skip the next character as well for \"o|\"\n                beats.push_back(2);\n            } else {\n                beats.push_back(1);  // \".|\" is a quarter note\n            }\n        }\n    }\n\n    return beats;\n}\n\n"}
{"task_id": "CPP/18", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint how_many_times(string str, string substring) {\n    int count = 0;\n    size_t pos = 0;\n\n    // Loop through the original string to find all occurrences of the substring\n    while ((pos = str.find(substring, pos)) != string::npos) {\n        count++;\n        pos++; // Move one character forward to allow for overlapping matches\n    }\n\n    return count;\n}\n\n"}
{"task_id": "CPP/19", "generation": "#include <iostream>\n#include <string>\n#include <map>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to convert word to number\nint word_to_number(const string& word) {\n    map<string, int> num_map = {{\"zero\", 0}, {\"one\", 1}, {\"two\", 2}, {\"three\", 3},\n                                {\"four\", 4}, {\"five\", 5}, {\"six\", 6}, {\"seven\", 7},\n                                {\"eight\", 8}, {\"nine\", 9}};\n    return num_map[word];\n}\n\n// Function to sort numbers\nstring sort_numbers(const string& numbers) {\n    vector<string> words;\n    string current_word = \"\";\n    \n    // Split the input string into individual words\n    for (char ch : numbers) {\n        if (ch == ' ') {\n            if (!current_word.empty()) {\n                words.push_back(current_word);\n                current_word.clear();\n            }\n        } else {\n            current_word += ch;\n        }\n    }\n    if (!current_word.empty()) {\n        words.push_back(current_word);\n    }\n\n    // Sort the vector of words based on their numeric values\n    sort(words.begin(), words.end(), [](const string& a, const string& b) {\n        return word_to_number(a) < word_to_number(b);\n    });\n\n    // Join the sorted words back into a single string\n    string result;\n    for (size_t i = 0; i < words.size(); ++i) {\n        if (i > 0) {\n            result += \" \";\n        }\n        result += words[i];\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/20", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // For std::sort\n\n// Function to find and return two closest numbers in a vector\nstd::pair<float, float> find_closest_elements(const std::vector<float>& numbers) {\n    if (numbers.size() < 2) {\n        throw std::invalid_argument(\"Vector must contain at least two elements.\");\n    }\n\n    // Sort the vector\n    std::vector<float> sorted_numbers(numbers);\n    std::sort(sorted_numbers.begin(), sorted_numbers.end());\n\n    float min_diff = std::numeric_limits<float>::max();\n    std::pair<float, float> closest_pair;\n\n    // Iterate through the sorted vector to find the minimum difference\n    for (size_t i = 0; i < sorted_numbers.size() - 1; ++i) {\n        float diff = sorted_numbers[i + 1] - sorted_numbers[i];\n        if (diff < min_diff) {\n            min_diff = diff;\n            closest_pair = {sorted_numbers[i], sorted_numbers[i + 1]};\n        }\n    }\n\n    return closest_pair;\n}\n\n// Function to test the find_closest_elements function\nvoid test_find_closest_elements() {\n    auto result1 = find_closest_elements({1.0, 2.0, 3.0, 4.0, 5.0, 2.2});\n    std::cout << \"Closest elements: (\" << result1.first << \", \" << result1.second << \")\" << std::endl;\n\n    auto result2 = find_closest_elements({1.0, 2.0, 3.0, 4.0, 5.0, 2.0});\n    std::cout << \"Closest elements: (\" << result2.first << \", \" << result2.second << \")\" << std::endl;\n}\n\n"}
{"task_id": "CPP/21", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // For std::min_element and std::max_element\n\nusing namespace std;\n\nvector<float> rescale_to_unit(vector<float> numbers) {\n    if (numbers.size() < 2) {\n        throw invalid_argument(\"Vector must contain at least two elements.\");\n    }\n\n    float min_value = *std::min_element(numbers.begin(), numbers.end());\n    float max_value = *std::max_element(numbers.begin(), numbers.end());\n\n    vector<float> scaled_numbers;\n    for (float num : numbers) {\n        float new_value = (num - min_value) / (max_value - min_value);\n        scaled_numbers.push_back(new_value);\n    }\n\n    return scaled_numbers;\n}\n\n"}
{"task_id": "CPP/22", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <list>\n#include <boost/any.hpp>\n\ntypedef std::list<boost::any> list_any;\nusing namespace std;\n\nvector<int> filter_integers(list_any values) {\n    vector<int> result;\n    for (const auto& value : values) {\n        if (value.type() == typeid(int)) {\n            result.push_back(boost::any_cast<int>(value));\n        }\n    }\n    return result;\n}\n\n"}
{"task_id": "CPP/23", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint strlen(const string& str) {\n    int len = 0;\n    for (char ch : str) {\n        if (ch == '\\0') break; // Stop at the null terminator\n        ++len;\n    }\n    return len;\n}\n\n// Function to test the strlen function with some examples\nvoid test_strlen() {\n    cout << \"strlen(\"\"\") << \": \" << strlen(\"\") << endl;\n    cout << \"strlen(\"\"abc\"\")\" << \": \" << strlen(\"abc\") << endl;\n    cout << \"strlen(\"\"hello world\"\")\" << \": \" << strlen(\"hello world\") << endl;\n}\n\n"}
{"task_id": "CPP/24", "generation": "#include <iostream>\nusing namespace std;\n\nint largest_divisor(int n) {\n    for (int i = n - 1; i > 0; --i) {\n        if (n % i == 0) {\n            return i;\n        }\n    }\n    // If no divisor is found, which should not happen for positive integers,\n    // we can return a default value or throw an exception.\n    return -1; // This line will never be reached for valid input\n}\n\n"}
{"task_id": "CPP/25", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> factorize(int n) {\n    vector<int> factors;\n    \n    // Check for number of 2s that divide n\n    while (n % 2 == 0) {\n        factors.push_back(2);\n        n = n / 2;\n    }\n    \n    // n must be odd at this point, so we can skip one element (Note i = i +2)\n    for (int i = 3; i * i <= n; i += 2) {\n        // While i divides n, append i and divide n\n        while (n % i == 0) {\n            factors.push_back(i);\n            n = n / i;\n        }\n    }\n    \n    // This condition is to handle the case when n is a prime number greater than 2\n    if (n > 2)\n        factors.push_back(n);\n    \n    return factors;\n}\n\n// Example usage:\n"}
{"task_id": "CPP/26", "generation": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nvector<int> remove_duplicates(vector<int> numbers) {\n    // Create a map to count occurrences of each element\n    unordered_map<int, int> counts;\n    \n    // Count the occurrences of each number in the vector\n    for (int num : numbers) {\n        counts[num]++;\n    }\n    \n    // Reserve space in the result vector to avoid reallocations\n    vector<int> result;\n    result.reserve(numbers.size());\n    \n    // Iterate through the original vector and keep only those elements that occur exactly once\n    for (int num : numbers) {\n        if (counts[num] == 1) {\n            result.push_back(num);\n        }\n    }\n    \n    return result;\n}\n\n// Function to print the vector\nvoid print_vector(const vector<int>& vec) {\n    for (int num : vec) {\n        cout << num << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/27", "generation": "#include <iostream>\n#include <string>\n#include <cctype>  // For islower and isupper functions\n\nusing namespace std;\n\nstring flip_case(string str) {\n    for (char &c : str) {  // Iterate through each character in the string\n        if (islower(c)) {  // Check if the character is lowercase\n            c = toupper(c);  // Convert to uppercase\n        } else if (isupper(c)) {  // Check if the character is uppercase\n            c = tolower(c);  // Convert to lowercase\n        }\n    }\n    return str;  // Return the modified string\n}\n\n"}
{"task_id": "CPP/28", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <numeric> // For std::accumulate\n\nusing namespace std;\n\nstring concatenate(vector<string> strings) {\n    if (strings.empty()) {\n        return \"\";\n    }\n    \n    // Use std::accumulate to concatenate all strings in the vector\n    string result = accumulate(strings.begin(), strings.end(), \"\"s, [](const string& a, const string& b) {\n        return a + b;\n    });\n    \n    return result;\n}\n\n// Function to test the concatenate function\nvoid test_concatenate() {\n    assert(concatenate({}) == \"\");\n    assert(concatenate({\"a\", \"b\", \"c\"}) == \"abc\");\n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/29", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\n// Function to filter strings by prefix\nvector<string> filter_by_prefix(vector<string> strings, string prefix) {\n    vector<string> filteredStrings;\n    \n    // Iterate through each string in the input vector\n    for (const auto& str : strings) {\n        // Check if the current string starts with the given prefix\n        if (str.substr(0, prefix.length()) == prefix) {\n            filteredStrings.push_back(str);\n        }\n    }\n    \n    return filteredStrings;\n}\n\n// Function to print the contents of a vector of strings\nvoid print_vector(const vector<string>& vec) {\n    for (const auto& str : vec) {\n        cout << str << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/30", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvector<float> get_positive(vector<float> l) {\n    vector<float> result;\n    for (float num : l) {\n        if (num > 0) {\n            result.push_back(num);\n        }\n    }\n    return result;\n}\n\n"}
{"task_id": "CPP/31", "generation": "#include <iostream>\nusing namespace std;\n\nbool is_prime(long long n) {\n    // Handle edge cases for numbers less than or equal to 1\n    if (n <= 1) return false;\n    \n    // Check divisibility from 2 up to the square root of n\n    for (long long i = 2; i * i <= n; ++i) {\n        if (n % i == 0) return false;\n    }\n    \n    return true;\n}\n\n"}
{"task_id": "CPP/32", "generation": "#include <iostream>\n#include <vector>\n#include <cmath>\n\ndouble poly(const std::vector<double>& xs, double x) {\n    double sum = 0;\n    int i;\n    for (i = 0; i < xs.size(); i++) {\n        sum += xs[i] * pow(x, i);\n    }\n    return sum;\n}\n\ndouble find_zero(const std::vector<double>& xs) {\n    // Check if the number of coefficients is even\n    if (xs.size() % 2 != 0) {\n        throw std::invalid_argument(\"The polynomial must have an even number of coefficients.\");\n    }\n\n    // Find the largest non-zero coefficient\n    double max_coeff = -INFINITY;\n    for (double coeff : xs) {\n        if (coeff != 0 && abs(coeff) > max_coeff) {\n            max_coeff = abs(coeff);\n        }\n    }\n\n    // Initial guess based on the largest non-zero coefficient's index\n    int n = xs.size() - 1; // Degree of the polynomial\n    double x0 = static_cast<double>(n);\n\n    // Newton-Raphson method\n    const double tol = 1e-6; // Tolerance for convergence\n    double x = x0;\n    while (true) {\n        double f_x = poly(xs, x);\n        if (abs(f_x) < tol) {\n            break;\n        }\n        double f_prime_x = 0;\n        for (int i = 1; i <= n; ++i) {\n            f_prime_x += xs[i] * i * pow(x, i - 1);\n        }\n        x -= f_x / f_prime_x;\n    }\n\n    return x;\n}\n\n"}
{"task_id": "CPP/33", "generation": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> sort_third(vector<int> l) {\n    vector<int> third_indices;\n    \n    // Extract elements at indices divisible by three\n    for (size_t i = 2; i < l.size(); i += 3) {\n        third_indices.push_back(l[i]);\n    }\n    \n    // Sort the extracted elements\n    sort(third_indices.begin(), third_indices.end());\n    \n    // Replace original values with sorted ones at indices divisible by three\n    for (size_t i = 2, j = 0; i < l.size(); i += 3, ++j) {\n        l[i] = third_indices[j];\n    }\n    \n    return l;\n}\n\n// Example usage:\n"}
{"task_id": "CPP/34", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> unique(vector<int> l) {\n    // Remove duplicates and move them to the beginning of the vector\n    auto last = unique(l.begin(), l.end());\n    \n    // Resize the vector to contain only the unique elements\n    l.resize(distance(l.begin(), last));\n    \n    // Sort the vector\n    sort(l.begin(), l.end());\n    \n    return l;\n}\n\n"}
{"task_id": "CPP/35", "generation": "#include <iostream>\n#include <vector>\n\nfloat max_element(const std::vector<float>& l) {\n    if (l.empty()) {\n        throw std::invalid_argument(\"Vector is empty\");\n    }\n\n    float max_val = l[0];\n    for (size_t i = 1; i < l.size(); ++i) {\n        if (l[i] > max_val) {\n            max_val = l[i];\n        }\n    }\n    return max_val;\n}\n\n// Function to test the max_element function\nvoid test_max_element() {\n    std::vector<float> vec1 = {1, 2, 3};\n    std::cout << \"Max element in {1, 2, 3}: \" << max_element(vec1) << std::endl;\n\n    std::vector<float> vec2 = {5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10};\n    std::cout << \"Max element in {5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10}: \" \n              << max_element(vec2) << std::endl;\n}\n\n"}
{"task_id": "CPP/36", "generation": "#include <iostream>\nusing namespace std;\n\nint fizz_buzz(int n) {\n    int count = 0;\n    \n    for (int i = 1; i < n; ++i) {\n        if (i % 11 == 0 || i % 13 == 0) {\n            // Convert the number to a string and count occurrences of '7'\n            string num_str = to_string(i);\n            for (char c : num_str) {\n                if (c == '7') {\n                    ++count;\n                }\n            }\n        }\n    }\n    \n    return count;\n}\n\n"}
{"task_id": "CPP/37", "generation": "#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<float> sort_even(vector<float> l) {\n    // Extract even-indexed elements (considering 0-based index)\n    vector<float> even_elements;\n    for (size_t i = 0; i < l.size(); i += 2) {\n        even_elements.push_back(l[i]);\n    }\n\n    // Sort the extracted even-indexed elements\n    sort(even_elements.begin(), even_elements.end());\n\n    // Create a new vector to store the result\n    vector<float> sorted_l(l);\n\n    // Place the sorted even-indexed elements back into their original positions\n    size_t even_index = 0;\n    for (size_t i = 0; i < l.size(); i += 2) {\n        sorted_l[i] = even_elements[even_index++];\n    }\n\n    return sorted_l;\n}\n\n// Example usage:\n"}
{"task_id": "CPP/38", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring encode_cyclic(string s) {\n    // returns encoded string by cycling groups of three characters.\n    int l = s.length();\n    int num = (l + 2) / 3;\n    string x, output;\n    for (int i = 0; i * 3 < l; i++) {\n        x = s.substr(i * 3, 3);\n        if (x.length() == 3) x = x.substr(1) + x[0];\n        output += x;\n    }\n    return output;\n}\n\nstring decode_cyclic(string s) {\n    /*\n    takes as input string encoded with encode_cyclic function. Returns decoded string.\n    */\n    int l = s.length();\n    int num = (l + 2) / 3;\n    string x, output;\n    for (int i = 0; i * 3 < l; i++) {\n        x = s.substr(i * 3, 3);\n        if (x.length() == 3) x = x[1] + x.substr(2, 1) + x[0];\n        output += x;\n    }\n    return output;\n}\n\n"}
{"task_id": "CPP/39", "generation": "#include <iostream>\n#include <cmath>\n\n// Function to check if a number is prime\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    if (num == 2 || num == 3) return true;\n    if (num % 2 == 0 || num % 3 == 0) return false;\n    for (int i = 5; i * i <= num; i += 6) {\n        if (num % i == 0 || num % (i + 2) == 0)\n            return false;\n    }\n    return true;\n}\n\n// Function to generate the n-th Fibonacci number that is also prime\nint prime_fib(int n) {\n    int count = 0; // Counter for prime Fibonacci numbers found\n    int a = 0, b = 1; // First two Fibonacci numbers\n\n    while (true) {\n        int fib = a + b;\n        a = b;\n        b = fib;\n\n        if (is_prime(fib)) {\n            count++;\n            if (count == n) return fib;\n        }\n    }\n}\n\n"}
{"task_id": "CPP/40", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nbool triples_sum_to_zero(vector<int> l) {\n    // First, sort the array to facilitate the two-pointer approach.\n    sort(l.begin(), l.end());\n    \n    int n = l.size();\n    \n    for (int i = 0; i < n - 2; ++i) {\n        // Skip duplicate elements to avoid redundant checks\n        if (i > 0 && l[i] == l[i-1]) continue;\n        \n        int left = i + 1, right = n - 1;\n        \n        while (left < right) {\n            int sum = l[i] + l[left] + l[right];\n            \n            if (sum == 0) {\n                return true; // Found a triplet that sums to zero\n            } else if (sum < 0) {\n                ++left; // Need a larger number, move the left pointer to right\n            } else {\n                --right; // Need a smaller number, move the right pointer to left\n            }\n        }\n    }\n    \n    return false; // No triplet found that sums to zero\n}\n\n"}
{"task_id": "CPP/41", "generation": "#include <iostream>\nusing namespace std;\n\nint car_race_collision(int n) {\n    return n * n;\n}\n\n"}
{"task_id": "CPP/42", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> incr_vector(vector<int> l) {\n    for (auto &elem : l) {\n        elem += 1;\n    }\n    return l;\n}\n\n// Function to test the incr_vector function\nvoid test_incr_vector() {\n    vector<int> vec1 = {1, 2, 3};\n    vector<int> result1 = incr_vector(vec1);\n    for (int num : result1) {\n        cout << num << \" \";\n    }\n    cout << endl;\n\n    vector<int> vec2 = {5, 3, 5, 2, 3, 3, 9, 0, 123};\n    vector<int> result2 = incr_vector(vec2);\n    for (int num : result2) {\n        cout << num << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/43", "generation": "#include <iostream>\n#include <vector>\n#include <set>\n\nusing namespace std;\n\nbool pairs_sum_to_zero(vector<int> l) {\n    // Create a set to store seen numbers\n    set<int> seen;\n    \n    for (int num : l) {\n        // Check if the negation of the current number is in the set\n        if (seen.find(-num) != seen.end()) {\n            return true;  // Found two numbers that sum to zero\n        }\n        // Add the current number to the set\n        seen.insert(num);\n    }\n    \n    return false;  // No such pair found\n}\n\n// Function to test the pairs_sum_to_zero function with provided examples\nvoid test_pairs_sum_to_zero() {\n    assert(pairs_sum_to_zero({1, 3, 5, 0}) == false);\n    assert(pairs_sum_to_zero({1, 3, -2, 1}) == false);\n    assert(pairs_sum_to_zero({1, 2, 3, 7}) == false);\n    assert(pairs_sum_to_zero({2, 4, -5, 3, 5, 7}) == true);\n    assert(pairs_sum_to_zero({1}) == false);\n\n    cout << \"All test cases passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/44", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring change_base(int x, int base) {\n    if (x == 0) {\n        return \"0\";\n    }\n    \n    string result = \"\";\n    while (x > 0) {\n        int digit = x % base;\n        result = to_string(digit) + result;\n        x /= base;\n    }\n    return result;\n}\n\n"}
{"task_id": "CPP/45", "generation": "#include <stdio.h>\nusing namespace std;\n\nfloat triangle_area(float a, float h) {\n    return 0.5 * a * h;\n}\n\n"}
{"task_id": "CPP/46", "generation": "#include <iostream>\nusing namespace std;\n\nint fib4(int n) {\n    if (n == 0 || n == 1 || n == 2) {\n        return n == 2 ? 2 : 0;\n    }\n    \n    // Initialize the first four values of the sequence\n    int a = 0, b = 0, c = 2, d = 0;\n    \n    // Compute fib4(n) iteratively\n    for (int i = 3; i <= n; ++i) {\n        int next = a + b + c + d;\n        a = b;\n        b = c;\n        c = d;\n        d = next;\n    }\n    \n    return d;\n}\n\n"}
{"task_id": "CPP/47", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nfloat median(vector<float> l) {\n    // Sort the vector\n    sort(l.begin(), l.end());\n    \n    int n = l.size();\n    \n    // Check if the number of elements is odd or even\n    if (n % 2 == 1) {\n        // If odd, return the middle element\n        return l[n / 2];\n    } else {\n        // If even, return the average of the two middle elements\n        float mid1 = l[(n - 1) / 2];\n        float mid2 = l[n / 2];\n        return (mid1 + mid2) / 2.0;\n    }\n}\n\n"}
{"task_id": "CPP/48", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_palindrome(string text) {\n    int start = 0;\n    int end = text.length() - 1;\n\n    while (start < end) {\n        if (text[start] != text[end]) {\n            return false; // If characters at the current positions are not equal, it's not a palindrome\n        }\n        start++;\n        end--;\n    }\n\n    return true; // All characters matched correctly, so it is a palindrome\n}\n\n"}
{"task_id": "CPP/49", "generation": "#include <stdio.h>\nusing namespace std;\n\nint modp(int n, int p) {\n    if (n == 0) return 1; // Base case: 2^0 = 1\n\n    long long result = 1;\n    long long base = 2;\n\n    while (n > 0) {\n        if (n % 2 == 1) { // If n is odd, multiply the result by the current base\n            result = (result * base) % p;\n        }\n        base = (base * base) % p; // Square the base and reduce modulo p\n        n /= 2; // Halve n\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/50", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nstring encode_shift(string s) {\n    // returns encoded string by shifting every character by 5 in the alphabet.\n    string out;\n    int i;\n    for (i = 0; i < s.length(); i++) {\n        int w = ((int)s[i] + 5 - (int)'a') % 26 + (int)'a';\n        out += (char)w;\n    }\n    return out;\n}\n\nstring decode_shift(string s) {\n    // takes as input string encoded with encode_shift function. Returns decoded string.\n    string out;\n    int i;\n    for (i = 0; i < s.length(); i++) {\n        int w = ((int)s[i] - 5 - (int)'a') % 26 + (int)'a';\n        out += (char)w;\n    }\n    return out;\n}\n\n"}
{"task_id": "CPP/51", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nstring remove_vowels(string text) {\n    // Define the vowels in both lowercase and uppercase\n    string vowels = \"aeiouAEIOU\";\n    \n    // Use a stream iterator to iterate through each character of the input string\n    return remove_if(text.begin(), text.end(), [&vowels](char c) {\n        return vowels.find(c) != string::npos;\n    });\n}\n\n"}
{"task_id": "CPP/52", "generation": "#include <vector>\nusing namespace std;\n\nbool below_threshold(vector<int> l, int t) {\n    for (int num : l) {\n        if (num >= t) {\n            return false;\n        }\n    }\n    return true;\n}\n\n// Example usage:\n"}
{"task_id": "CPP/53", "generation": "#include <iostream>  // Include iostream for input/output operations\n\nusing namespace std;\n\nint add(int x, int y) {\n    return x + y;  // Return the sum of x and y\n}\n\n"}
{"task_id": "CPP/54", "generation": "#include <iostream>\n#include <string>\n#include <unordered_map>\n\nusing namespace std;\n\nbool same_chars(string s0, string s1) {\n    // Create a frequency map for s0\n    unordered_map<char, int> freqMapS0;\n    for (char c : s0) {\n        freqMapS0[c]++;\n    }\n\n    // Create a frequency map for s1\n    unordered_map<char, int> freqMapS1;\n    for (char c : s1) {\n        freqMapS1[c]++;\n    }\n\n    // Compare the two frequency maps\n    return freqMapS0 == freqMapS1;\n}\n\n"}
{"task_id": "CPP/55", "generation": "#include <iostream>\nusing namespace std;\n\nint fib(int n) {\n    if (n <= 0) return 0;\n    if (n == 1) return 1;\n\n    int a = 0, b = 1, c;\n    for (int i = 2; i <= n; ++i) {\n        c = a + b;\n        a = b;\n        b = c;\n    }\n    return b;\n}\n\n// Function to test the fib function\nvoid testFib() {\n    cout << \"fib(10): \" << fib(10) << endl; // Should output 55\n    cout << \"fib(1): \" << fib(1) << endl;   // Should output 1\n    cout << \"fib(8): \" << fib(8) << endl;   // Should output 21\n}\n\n"}
{"task_id": "CPP/56", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    int count = 0;\n    \n    for (char c : brackets) {\n        if (c == '<') {\n            count++;\n        } else if (c == '>') {\n            count--;\n            if (count < 0) {\n                return false; // Found a closing bracket without an opening one\n            }\n        }\n    }\n    \n    return count == 0; // True if all brackets are correctly matched\n}\n\n"}
{"task_id": "CPP/57", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool monotonic(vector<float> l) {\n    if (l.size() <= 1) {\n        return true; // A vector with 0 or 1 element is trivially monotonic.\n    }\n\n    bool increasing = false;\n    for (size_t i = 1; i < l.size(); ++i) {\n        if (l[i] > l[i - 1]) {\n            if (!increasing) {\n                increasing = true;\n            } else {\n                return false; // Found a pair that breaks the increasing order.\n            }\n        } else if (l[i] < l[i - 1]) {\n            if (increasing) {\n                return false; // Found a pair that breaks the decreasing order after an increase.\n            }\n        }\n    }\n\n    return true;\n}\n\n"}
{"task_id": "CPP/58", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // For std::sort and std::unique\n#include <set>       // For std::set_intersection\n\nusing namespace std;\n\nvector<int> common(vector<int> l1, vector<int> l2) {\n    // Convert vectors to sets for unique elements\n    set<int> s1(l1.begin(), l1.end());\n    set<int> s2(l2.begin(), l2.end());\n\n    // Create a temporary vector to store the result of intersection\n    vector<int> result;\n\n    // Perform set intersection\n    set_intersection(s1.begin(), s1.end(), s2.begin(), s2.end(), back_inserter(result));\n\n    // Sort and remove duplicates from the result (though set_intersection already does this)\n    sort(result.begin(), result.end());\n    auto last = unique(result.begin(), result.end());\n\n    // Resize to remove any remaining duplicate elements\n    result.resize(distance(result.begin(), last));\n\n    return result;\n}\n\n"}
{"task_id": "CPP/59", "generation": "#include <iostream>\nusing namespace std;\n\nint largest_prime_factor(int n) {\n    // Handle even numbers first\n    while (n % 2 == 0) {\n        n /= 2;\n    }\n    \n    // Check for odd factors starting from 3\n    int factor = 3;\n    while (factor * factor <= n) {\n        while (n % factor == 0) {\n            n /= factor;\n        }\n        factor += 2;  // Move to the next odd number\n    }\n    \n    // If n is still greater than 1, then it is a prime number and the largest prime factor\n    return n;\n}\n\n"}
{"task_id": "CPP/60", "generation": "#include <iostream>\nusing namespace std;\n\nint sum_to_n(int n) {\n    int sum = 0;\n    for (int i = 1; i <= n; ++i) {\n        sum += i;\n    }\n    return sum;\n}\n\n"}
{"task_id": "CPP/61", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    int balance = 0;\n    \n    for (char c : brackets) {\n        if (c == '(') {\n            balance++;\n        } else if (c == ')') {\n            balance--;\n        }\n        \n        // If at any point the balance is negative, it means there's a closing bracket without an opening one\n        if (balance < 0) {\n            return false;\n        }\n    }\n    \n    // Finally, check if all opening brackets have been closed\n    return balance == 0;\n}\n\n"}
{"task_id": "CPP/62", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvector<float> derivative(vector<float> xs) {\n    vector<float> result;\n    \n    // Iterate through the coefficients starting from the first non-constant term\n    for (size_t i = 1; i < xs.size(); ++i) {\n        // Multiply the coefficient by its degree and add to the result\n        result.push_back(xs[i] * i);\n    }\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/63", "generation": "#include <iostream>\nusing namespace std;\n\nint fibfib(int n) {\n    // Base cases\n    if (n == 0 || n == 1) return 0;\n    if (n == 2) return 1;\n\n    // Array to store the computed values of FibFib sequence\n    int dp[n + 1];\n    \n    // Initialize base cases\n    dp[0] = 0;\n    dp[1] = 0;\n    dp[2] = 1;\n\n    // Fill the dp array using the recurrence relation\n    for (int i = 3; i <= n; ++i) {\n        dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3];\n    }\n\n    // Return the nth element of the FibFib sequence\n    return dp[n];\n}\n\n// Function to test the fibfib function with provided examples\nvoid test_fibfib() {\n    cout << \"fibfib(1) = \" << fibfib(1) << endl; // Expected output: 0\n    cout << \"fibfib(5) = \" << fibfib(5) << endl; // Expected output: 4\n    cout << \"fibfib(8) = \" << fibfib(8) << endl; // Expected output: 24\n}\n\n"}
{"task_id": "CPP/64", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint vowels_count(string s) {\n    int count = 0;\n    \n    // Convert the string to lowercase for easier comparison\n    transform(s.begin(), s.end(), s.begin(), ::tolower);\n    \n    // Check each character in the string\n    for (size_t i = 0; i < s.length(); ++i) {\n        char c = s[i];\n        \n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n            count++;\n        } else if (c == 'y' && i == s.length() - 1) {\n            count++;\n        }\n    }\n    \n    return count;\n}\n\n"}
{"task_id": "CPP/65", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring circular_shift(int x, int shift) {\n    // Convert the integer to a string\n    string num_str = to_string(x);\n    \n    // Get the length of the number\n    size_t len = num_str.length();\n    \n    // If shift is greater than or equal to the length of the number,\n    // reverse the digits.\n    if (shift >= len) {\n        reverse(num_str.begin(), num_str.end());\n    } else {\n        // Perform circular right shift\n        int effective_shift = shift % len;\n        string shifted_part = num_str.substr(len - effective_shift);\n        string remaining_part = num_str.substr(0, len - effective_shift);\n        num_str = shifted_part + remaining_part;\n    }\n    \n    return num_str;\n}\n\n"}
{"task_id": "CPP/66", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint digitSum(string s) {\n    int sum = 0;\n    for (char c : s) {\n        if (isupper(c)) { // Check if the character is uppercase\n            sum += static_cast<int>(c); // Add its ASCII value to the sum\n        }\n    }\n    return sum;\n}\n\n// Function to test the digitSum function with provided examples\nvoid check() {\n    cout << \"digitSum(\\\"\\\") => \" << digitSum(\"\") << endl; // Should be 0\n    cout << \"digitSum(\\\"abAB\\\") => \" << digitSum(\"abAB\") << endl; // Should be 131 (65 + 66)\n    cout << \"digitSum(\\\"abcCd\\\") => \" << digitSum(\"abcCd\") << endl; // Should be 67 ('C' = 67)\n    cout << \"digitSum(\\\"helloE\\\") => \" << digitSum(\"helloE\") << endl; // Should be 69 ('E' = 69)\n    cout << \"digitSum(\\\"woArBld\\\") => \" << digitSum(\"woArBld\") << endl; // Should be 131 (65 + 66)\n    cout << \"digitSum(\\\"aAaaaXa\\\") => \" << digitSum(\"aAaaaXa\") << endl; // Should be 153 ('A' = 65, 'X' = 88)\n}\n\n"}
{"task_id": "CPP/67", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint fruit_distribution(string s, int n) {\n    // Find the position of 'apples' and 'oranges'\n    size_t apple_pos = s.find(\" apples\");\n    size_t orange_pos = s.find(\" oranges\");\n\n    // Extract the number of apples\n    int num_apples = stoi(s.substr(apple_pos - 1, apple_pos));\n\n    // Extract the number of oranges\n    int num_oranges = stoi(s.substr(orange_pos - 1, orange_pos));\n\n    // Calculate the number of mangoes\n    int num_mangoes = n - (num_apples + num_oranges);\n\n    return num_mangoes;\n}\n\n"}
{"task_id": "CPP/68", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> pluck(vector<int> arr) {\n    if (arr.empty()) {\n        return {};\n    }\n\n    int smallestEvenValue = -1;\n    int smallestIndex = -1;\n\n    for (int i = 0; i < arr.size(); ++i) {\n        if (arr[i] % 2 == 0 && (smallestEvenValue == -1 || arr[i] < smallestEvenValue)) {\n            smallestEvenValue = arr[i];\n            smallestIndex = i;\n        }\n    }\n\n    // If no even value was found, return an empty vector\n    if (smallestEvenValue == -1) {\n        return {};\n    }\n\n    return {smallestEvenValue, smallestIndex};\n}\n\n"}
{"task_id": "CPP/69", "generation": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nint search(vector<int> lst) {\n    // Create a map to store the frequency of each element in the vector\n    unordered_map<int, int> freqMap;\n    \n    // Count the frequency of each integer in the vector\n    for (int num : lst) {\n        freqMap[num]++;\n    }\n    \n    // Initialize the result with -1, as we need to return -1 if no such value exists\n    int result = -1;\n    \n    // Iterate through the map and check the condition\n    for (const auto& pair : freqMap) {\n        if (pair.second >= pair.first && pair.first > result) {\n            result = pair.first;\n        }\n    }\n    \n    return result;\n}\n\n// Function to test the search function with provided examples\nvoid test() {\n    assert(search({4, 1, 2, 2, 3, 1}) == 2);\n    assert(search({1, 2, 2, 3, 3, 3, 4, 4, 4}) == 3);\n    assert(search({5, 5, 4, 4, 4}) == -1);\n    cout << \"All tests passed.\" << endl;\n}\n\n"}
{"task_id": "CPP/70", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> strange_sort_list(vector<int> lst) {\n    // Sort the input vector in ascending order\n    sort(lst.begin(), lst.end());\n\n    vector<int> result;\n    int start = 0; // Start index for minimum value\n    int end = lst.size() - 1; // End index for maximum value\n\n    while (start <= end) {\n        if (start == end) {\n            // If only one element is left, add it to the result\n            result.push_back(lst[start]);\n            break;\n        }\n\n        // Add minimum value from the sorted list\n        result.push_back(lst[start++]);\n\n        // Add maximum value from the sorted list\n        result.push_back(lst[end--]);\n    }\n\n    return result;\n}\n\n// Function to check the correctness of the strange_sort_list function\nvoid check() {\n    assert(strange_sort_list({1, 2, 3, 4}) == vector<int>({1, 4, 2, 3}));\n    assert(strange_sort_list({5, 5, 5, 5}) == vector<int>({5, 5, 5, 5}));\n    assert(strange_sort_list({}) == vector<int>({}));\n    cout << \"All test cases passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/71", "generation": "#include <stdio.h>\n#include <math.h>\n\nusing namespace std;\n\nfloat triangle_area(float a, float b, float c) {\n    // Check if the sides form a valid triangle\n    if (a + b <= c || a + c <= b || b + c <= a) {\n        return -1;\n    }\n\n    // Calculate the semi-perimeter\n    float s = (a + b + c) / 2;\n\n    // Calculate the area using Heron's formula\n    float area = sqrt(s * (s - a) * (s - b) * (s - c));\n\n    // Round to 2 decimal points\n    return round(area * 100) / 100;\n}\n\n"}
{"task_id": "CPP/72", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool is_palindrome(const vector<int>& q) {\n    for (size_t i = 0; i < q.size() / 2; ++i) {\n        if (q[i] != q[q.size() - 1 - i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nbool will_it_fly(vector<int> q, int w) {\n    // Check if the vector is palindromic\n    bool is_balanced = is_palindrome(q);\n    \n    // Calculate the sum of elements in the vector\n    int sum = 0;\n    for (int num : q) {\n        sum += num;\n    }\n    \n    // Check if the sum is less than or equal to w and the vector is balanced\n    return is_balanced && sum <= w;\n}\n\n// Function to test the will_it_fly function with provided examples\nvoid test() {\n    cout << boolalpha; // Print bools as true/false instead of 1/0\n    cout << \"will_it_fly({1, 2}, 5): \" << will_it_fly({1, 2}, 5) << endl;\n    cout << \"will_it_fly({3, 2, 3}, 1): \" << will_it_fly({3, 2, 3}, 1) << endl;\n    cout << \"will_it_fly({3, 2, 3}, 9): \" << will_it_fly({3, 2, 3}, 9) << endl;\n    cout << \"will_it_fly({3}, 5): \" << will_it_fly({3}, 5) << endl;\n}\n\n"}
{"task_id": "CPP/73", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint smallest_change(vector<int> arr) {\n    int left = 0;\n    int right = arr.size() - 1;\n    int changes = 0;\n\n    while (left < right) {\n        if (arr[left] != arr[right]) {\n            changes++;\n        }\n        left++;\n        right--;\n    }\n\n    return changes;\n}\n\n"}
{"task_id": "CPP/74", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to count the total number of characters in a vector of strings\nint count_chars(const vector<string>& vec) {\n    int total = 0;\n    for (const auto& str : vec) {\n        total += str.length();\n    }\n    return total;\n}\n\nvector<string> total_match(vector<string> lst1, vector<string> lst2) {\n    // Calculate the total number of characters in each vector\n    int chars_lst1 = count_chars(lst1);\n    int chars_lst2 = count_chars(lst2);\n\n    // Compare and return the appropriate vector\n    if (chars_lst1 < chars_lst2) {\n        return lst1;\n    } else if (chars_lst2 < chars_lst1) {\n        return lst2;\n    } else {\n        return lst1;  // If they are equal, return the first vector\n    }\n}\n\n// Function to test the total_match function with provided examples\nvoid test_total_match() {\n    assert(total_match({}, {}) == vector<string>());\n    assert(total_match({\"hi\", \"admin\"}, {\"hI\", \"Hi\"}) == vector<string>{\"hI\", \"Hi\"});\n    assert(total_match({\"hi\", \"admin\"}, {\"hi\", \"hi\", \"admin\", \"project\"}) == vector<string>{\"hi\", \"admin\"});\n    assert(total_match({\"hi\", \"admin\"}, {\"hI\", \"hi\", \"hi\"}) == vector<string>{\"hI\", \"hi\", \"hi\"});\n    assert(total_match({\"4\"}, {\"1\", \"2\", \"3\", \"4\", \"5\"}) == vector<string>{\"4\"});\n\n    cout << \"All tests passed successfully.\" << endl;\n}\n\n"}
{"task_id": "CPP/75", "generation": "#include <iostream>\nusing namespace std;\n\n// Helper function to check if a number is prime\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    if (n == 2 || n == 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    \n    for (int i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0)\n            return false;\n    }\n    return true;\n}\n\n// Main function to check if the number is a product of exactly three prime numbers\nbool is_multiply_prime(int a) {\n    int count = 0;\n    \n    // Check for factors up to the square root of 'a'\n    for (int i = 2; i * i <= a; ++i) {\n        while (a % i == 0 && is_prime(i)) {\n            if (++count > 3) return false; // More than three prime factors\n            a /= i;\n        }\n    }\n    \n    // Check the remaining part of 'a'\n    if (a != 1 && is_prime(a)) count++;\n    \n    return count == 3;\n}\n\n"}
{"task_id": "CPP/76", "generation": "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\nbool is_simple_power(int x, int n) {\n    // Check if n is 1 and x is not 1. If so, return false.\n    if (n == 1 && x != 1) {\n        return false;\n    }\n    \n    // Calculate the logarithm of x to the base n\n    double log_result = log(x) / log(n);\n    \n    // Check if the result is an integer by comparing it with its rounded value\n    return floor(log_result) == log_result;\n}\n\n"}
{"task_id": "CPP/77", "generation": "#include <stdio.h>\n#include <math.h>\n\nusing namespace std;\n\nbool iscube(int a) {\n    // Handle special case for 0 separately\n    if (a == 0) return true;\n    \n    // Calculate the cube root and round it to the nearest integer\n    int roundedCubeRoot = round(cbrt(a));\n    \n    // Check if cubing this rounded value gives back the original number\n    return pow(roundedCubeRoot, 3) == a;\n}\n\n"}
{"task_id": "CPP/78", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\n// Function to check if a hexadecimal digit is prime\nbool is_prime_hex_digit(char hex_digit) {\n    // Convert the character to its corresponding integer value\n    int digit_value = hex_digit;\n    \n    // Adjust for uppercase letters A-F\n    if (hex_digit >= 'A' && hex_digit <= 'F') {\n        digit_value -= 'A' - 10;\n    }\n    \n    // Check if the digit is a prime number\n    switch(digit_value) {\n        case 2:\n        case 3:\n        case 5:\n        case 7:\n        case 11: // B in decimal\n        case 13: // D in decimal\n            return true;\n        default:\n            return false;\n    }\n}\n\n// Function to count the number of prime hexadecimal digits in a string\nint hex_key(string num) {\n    int count = 0;\n    \n    for (char digit : num) {\n        if (is_prime_hex_digit(digit)) {\n            count++;\n        }\n    }\n    \n    return count;\n}\n\n"}
{"task_id": "CPP/79", "generation": "#include <iostream>\n#include <string>\n#include <bitset>\n\nusing namespace std;\n\n// Function to convert decimal to binary and return in required format\nstring decimal_to_binary(int decimal) {\n    // Convert the integer to a binary string using bitset\n    bitset<32> binary(decimal);\n    string binaryString = binary.to_string();\n\n    // Remove leading zeros from the binary string\n    size_t firstOne = binaryString.find('1');\n    if (firstOne != string::npos) {\n        binaryString = binaryString.substr(firstOne);\n    }\n\n    // Add \"db\" at the beginning and end of the string\n    return \"db\" + binaryString + \"db\";\n}\n\n// Function to test the decimal_to_binary function with some examples\nvoid test_decimal_to_binary() {\n    cout << decimal_to_binary(15) << endl;   // Expected output: db1111db\n    cout << decimal_to_binary(32) << endl;   // Expected output: db100000db\n    cout << decimal_to_binary(64) << endl;   // Expected output: db1000000db\n}\n\n"}
{"task_id": "CPP/80", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_happy(string s) {\n    // Check if the string length is less than 3\n    if (s.length() < 3) return false;\n\n    // Iterate through the string and check every three consecutive characters\n    for (size_t i = 0; i <= s.length() - 3; ++i) {\n        // Check if any two of the three consecutive characters are the same\n        if (s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]) {\n            return false;\n        }\n    }\n\n    // If no three consecutive characters are the same, the string is happy\n    return true;\n}\n\n"}
{"task_id": "CPP/81", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\n// Function to map GPA to letter grade\nstring gpa_to_letter(float gpa) {\n    if (gpa >= 4.0f) return \"A+\";\n    else if (gpa > 3.7f) return \"A\";\n    else if (gpa > 3.3f) return \"A-\";\n    else if (gpa > 3.0f) return \"B+\";\n    else if (gpa > 2.7f) return \"B\";\n    else if (gpa > 2.3f) return \"B-\";\n    else if (gpa > 2.0f) return \"C+\";\n    else if (gpa > 1.7f) return \"C\";\n    else if (gpa > 1.3f) return \"C-\";\n    else if (gpa > 1.0f) return \"D+\";\n    else if (gpa > 0.7f) return \"D\";\n    else if (gpa > 0.0f) return \"D-\";\n    else return \"E\";\n}\n\n// Function to convert vector of GPAs to vector of letter grades\nvector<string> numerical_letter_grade(vector<float> grades) {\n    vector<string> letter_grades;\n    for (float gpa : grades) {\n        letter_grades.push_back(gpa_to_letter(gpa));\n    }\n    return letter_grades;\n}\n\n// Function to test the correctness of the function\nvoid check() {\n    vector<float> input = {4.0f, 3.0f, 1.7f, 2.0f, 3.5f};\n    vector<string> expected_output = {\"A+\", \"B\", \"C-\", \"C\", \"A-\"};\n    vector<string> output = numerical_letter_grade(input);\n    \n    if (output == expected_output) {\n        printf(\"Test passed!\\n\");\n    } else {\n        printf(\"Test failed! Expected: %s, Got: %s\\n\", \n               expected_output[0].c_str(), output[0].c_str());\n    }\n}\n\n"}
{"task_id": "CPP/82", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    if (num == 2) return true;\n    if (num % 2 == 0) return false;\n\n    for (int i = 3; i * i <= num; i += 2) {\n        if (num % i == 0)\n            return false;\n    }\n    return true;\n}\n\n// Function to check if the length of a string is prime\nbool prime_length(string str) {\n    int len = str.length();\n    return is_prime(len);\n}\n\n"}
{"task_id": "CPP/83", "generation": "#include <iostream>\nusing namespace std;\n\nint starts_one_ends(int n) {\n    // If n is 1, there's only one number (1 itself)\n    if (n == 1) return 1;\n    \n    // Count of numbers starting with 1: 1 * 10^(n-1)\n    int start_with_1 = 1 * pow(10, n - 1);\n    \n    // Count of numbers ending with 1: 9 * 10^(n-2) * 1\n    int end_with_1 = 9 * pow(10, n - 2) * 1;\n    \n    // Count of numbers starting and ending with 1: 9 * (n-2)\n    int both_start_and_end_with_1 = 9 * (pow(10, n - 2));\n    \n    // Total count is the sum of start_with_1 and end_with_1 minus both_start_and_end_with_1\n    return start_with_1 + end_with_1 - both_start_and_end_with_1;\n}\n\n"}
{"task_id": "CPP/84", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\n// Function to convert an integer to its binary representation as a string\nstring intToBinary(int num) {\n    if (num == 0) return \"0\";\n    string binary = \"\";\n    while (num > 0) {\n        binary = to_string(num % 2) + binary;\n        num /= 2;\n    }\n    return binary;\n}\n\n// Function to calculate the sum of digits of N and convert it to binary\nstring solve(int N) {\n    int sum = 0;\n    \n    // Calculate the sum of digits\n    while (N > 0) {\n        sum += N % 10;\n        N /= 10;\n    }\n    \n    // Convert the sum to binary\n    return intToBinary(sum);\n}\n\n"}
{"task_id": "CPP/85", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint add(vector<int> lst) {\n    int sum = 0;\n    \n    // Iterate through the list starting from index 1 (second element)\n    // and increment by 2 to check only odd indices.\n    for (size_t i = 1; i < lst.size(); i += 2) {\n        if (lst[i] % 2 == 0) {  // Check if the element at the current odd index is even\n            sum += lst[i];      // Add it to the sum\n        }\n    }\n    \n    return sum;\n}\n\n"}
{"task_id": "CPP/86", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\n// Function to split a string by spaces and return a vector of words\nvector<string> split(const string &s) {\n    vector<string> tokens;\n    string token;\n    istringstream tokenStream(s);\n    while (getline(tokenStream, token, ' ')) {\n        if (!token.empty()) {\n            tokens.push_back(token);\n        }\n    }\n    return tokens;\n}\n\n// Function to sort each word in the sentence\nstring anti_shuffle(string s) {\n    // Split the string into words\n    vector<string> words = split(s);\n\n    // Sort characters of each word and reconstruct the sentence\n    for (auto &word : words) {\n        sort(word.begin(), word.end());\n    }\n\n    // Reconstruct the sentence with sorted words\n    string result;\n    for (size_t i = 0; i < words.size(); ++i) {\n        if (i > 0) {\n            result += \" \";\n        }\n        result += words[i];\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/87", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to get the coordinates of x in lst\nvector<vector<int>> get_row(vector<vector<int>> lst, int x) {\n    vector<vector<int>> result;\n    \n    // Iterate through each row and column\n    for (int i = 0; i < lst.size(); ++i) {\n        for (int j = 0; j < lst[i].size(); ++j) {\n            if (lst[i][j] == x) {\n                result.push_back({i, j});\n            }\n        }\n    }\n\n    // Sort by row in ascending order\n    sort(result.begin(), result.end());\n\n    // For each row, sort the columns in descending order\n    for (auto &row : result) {\n        if (row.size() > 1) {  // Ensure there are at least two elements to sort\n            sort(row.rbegin(), row.rend());\n        }\n    }\n\n    return result;\n}\n\n// Function to print the result for verification\nvoid print_result(const vector<vector<int>>& result) {\n    for (const auto& coord : result) {\n        cout << \"{\" << coord[0] << \", \" << coord[1] << \"} \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/88", "generation": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> sort_array(vector<int> array) {\n    // Check if the vector is empty or contains only one element\n    if (array.empty() || array.size() == 1) {\n        return array;\n    }\n\n    int first = array.front();\n    int last = array.back();\n\n    // Calculate the sum of the first and last elements\n    int sum = first + last;\n\n    // Determine the sorting order based on the sum being odd or even\n    vector<int> sorted_array(array);  // Make a copy to avoid modifying the original vector\n\n    if (sum % 2 == 0) {\n        // Sort in descending order\n        sort(sorted_array.rbegin(), sorted_array.rend());\n    } else {\n        // Sort in ascending order\n        sort(sorted_array.begin(), sorted_array.end());\n    }\n\n    return sorted_array;\n}\n\n// Function to test the solution with provided examples\nvoid check() {\n    assert(sort_array({}) == vector<int>());\n    assert(sort_array({5}) == vector<int>({5}));\n    assert(sort_array({2, 4, 3, 0, 1, 5}) == vector<int>({0, 1, 2, 3, 4, 5}));\n    assert(sort_array({2, 4, 3, 0, 1, 5, 6}) == vector<int>({6, 5, 4, 3, 2, 1, 0}));\n}\n\n"}
{"task_id": "CPP/89", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\n// Function to rotate a single character by 4 places\nchar rotateChar(char c) {\n    if (c >= 'a' && c <= 'z') {\n        return ((c - 'a' + 4) % 26) + 'a';\n    } else if (c >= 'A' && c <= 'Z') {\n        return ((c - 'A' + 4) % 26) + 'A';\n    }\n    // Non-alphabetic characters remain unchanged\n    return c;\n}\n\n// Function to encrypt the string by rotating each character\nstring encrypt(string s) {\n    for (char &c : s) {\n        c = rotateChar(c);\n    }\n    return s;\n}\n\n"}
{"task_id": "CPP/90", "generation": "#include <vector>\n#include <algorithm>\n#include <optional>\n\n// Function to find the second smallest element in a vector of integers.\nstd::optional<int> next_smallest(const std::vector<int>& lst) {\n    if (lst.empty()) return std::nullopt;\n\n    // Remove duplicates by sorting and then using unique\n    auto last = std::unique(lst.begin(), lst.end());\n    lst.erase(last, lst.end());\n\n    // If there are less than 2 unique elements, return nullopt\n    if (lst.size() < 2) return std::nullopt;\n\n    // Find the second smallest element\n    auto it = std::min_element(lst.begin() + 1, lst.end());\n    return *it;\n}\n\n// Function to test the next_smallest function with some examples\nvoid check() {\n    assert(next_smallest({1, 2, 3, 4, 5}) == 2);\n    assert(next_smallest({5, 1, 4, 3, 2}) == 2);\n    assert(!next_smallest({}).has_value());\n    assert(!next_smallest({1, 1}).has_value());\n\n    std::cout << \"All tests passed!\" << std::endl;\n}\n\n"}
{"task_id": "CPP/91", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nint is_bored(string S) {\n    int count = 0;\n    stringstream ss(S);\n    string sentence;\n\n    // Split the input string into sentences using delimiters: '.', '?', '!'\n    while (getline(ss, sentence, '.')) {\n        if (!sentence.empty()) {\n            getline(ss, sentence, '?');\n            if (!sentence.empty()) {\n                getline(ss, sentence, '!');\n                if (!sentence.empty() && sentence.substr(0, 1) == \"I\") {\n                    count++;\n                }\n            }\n        }\n    }\n\n    return count;\n}\n\n"}
{"task_id": "CPP/92", "generation": "#include <iostream>\nusing namespace std;\n\nbool any_int(float a, float b, float c) {\n    // Convert floats to integers by truncating the decimal part\n    int ia = static_cast<int>(a);\n    int ib = static_cast<int>(b);\n    int ic = static_cast<int>(c);\n\n    // Check if all numbers are integers (i.e., their fractional parts are 0)\n    bool is_integer_a = a == static_cast<float>(ia);\n    bool is_integer_b = b == static_cast<float>(ib);\n    bool is_integer_c = c == static_cast<float>(ic);\n\n    // If any of the numbers are not integers, return false\n    if (!is_integer_a || !is_integer_b || !is_integer_c) {\n        return false;\n    }\n\n    // Check if one number is equal to the sum of the other two\n    return (ia == ib + ic) || (ib == ia + ic) || (ic == ia + ib);\n}\n\n"}
{"task_id": "CPP/93", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\n// Function to swap case of a character\nchar swapCase(char c) {\n    if (islower(c)) return toupper(c);\n    else if (isupper(c)) return tolower(c);\n    return c;\n}\n\n// Function to replace vowels with the letter 2 places ahead in the alphabet\nstring replaceVowels(string s) {\n    string result = \"\";\n    for (char& c : s) {\n        switch (tolower(c)) {\n            case 'a': result += 'C'; break;\n            case 'e': result += 'G'; break;\n            case 'i': result += 'K'; break;\n            case 'o': result += 'Q'; break;\n            case 'u': result += 'W'; break;\n            default: result += c; break;\n        }\n    }\n    return result;\n}\n\n// Main encoding function\nstring encode(string message) {\n    // Swap the case of all letters\n    transform(message.begin(), message.end(), message.begin(), swapCase);\n    \n    // Replace vowels with the letter 2 places ahead in the alphabet\n    string encoded = replaceVowels(message);\n    \n    return encoded;\n}\n\n"}
{"task_id": "CPP/94", "generation": "bool isPrime(int n) {\n    if (n <= 1) return false;\n    if (n == 2 || n == 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    for (int i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0)\n            return false;\n    }\n    return true;\n}\n"}
{"task_id": "CPP/95", "generation": "#include <iostream>\n#include <string>\n#include <map>\n\nusing namespace std;\n\nbool check_dict_case(map<string, string> dict) {\n    // Check if the map is empty\n    if (dict.empty()) {\n        return false;\n    }\n\n    bool allLower = true;\n    bool allUpper = true;\n\n    for (const auto &pair : dict) {\n        const string &key = pair.first;\n\n        // Check if key is in lower case\n        if (!islower(key[0]) || !all_of(key.begin(), key.end(), ::islower)) {\n            allLower = false;\n        }\n\n        // Check if key is in upper case\n        if (!isupper(key[0]) || !all_of(key.begin(), key.end(), ::isupper)) {\n            allUpper = false;\n        }\n    }\n\n    return allLower || allUpper;\n}\n\n"}
{"task_id": "CPP/96", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Helper function to check if a number is prime\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    for (int i = 2; i * i <= num; ++i) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\n// Function to generate a vector of prime numbers less than n\nvector<int> count_up_to(int n) {\n    vector<int> primes;\n    for (int i = 2; i < n; ++i) {\n        if (is_prime(i)) {\n            primes.push_back(i);\n        }\n    }\n    return primes;\n}\n\n// Function to test the count_up_to function\nvoid test_count_up_to() {\n    cout << \"count_up_to(5): {\";\n    for (int num : count_up_to(5)) {\n        cout << num << \", \";\n    }\n    cout << \"}\" << endl;\n\n    cout << \"count_up_to(11): {\";\n    for (int num : count_up_to(11)) {\n        cout << num << \", \";\n    }\n    cout << \"}\" << endl;\n\n    cout << \"count_up_to(0): {\";\n    for (int num : count_up_to(0)) {\n        cout << num << \", \";\n    }\n    cout << \"}\" << endl;\n\n    cout << \"count_up_to(20): {\";\n    for (int num : count_up_to(20)) {\n        cout << num << \", \";\n    }\n    cout << \"}\" << endl;\n\n    cout << \"count_up_to(1): {\";\n    for (int num : count_up_to(1)) {\n        cout << num << \", \";\n    }\n    cout << \"}\" << endl;\n\n    cout << \"count_up_to(18): {\";\n    for (int num : count_up_to(18)) {\n        cout << num << \", \";\n    }\n    cout << \"}\" << endl;\n}\n\n"}
{"task_id": "CPP/97", "generation": "#include <iostream>\nusing namespace std;\n\nint multiply(int a, int b) {\n    // Extract the unit digit of both numbers\n    int unitDigitA = abs(a % 10);\n    int unitDigitB = abs(b % 10);\n\n    // Multiply the unit digits and return the result\n    return unitDigitA * unitDigitB;\n}\n\n"}
{"task_id": "CPP/98", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint count_upper(string s) {\n    int count = 0;\n    \n    // Iterate through the string, checking only even indices\n    for (size_t i = 0; i < s.length(); i += 2) {\n        char c = tolower(s[i]);\n        \n        // Check if the character is an uppercase vowel\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n            count++;\n        }\n    }\n    \n    return count;\n}\n\n"}
{"task_id": "CPP/99", "generation": "#include <iostream>\n#include <cmath>\n#include <string>\n\nusing namespace std;\n\nint closest_integer(string value) {\n    // Convert the string to a floating-point number\n    double num = stod(value);\n    \n    // Determine if it is equidistant from two integers (0.5 or -0.5)\n    double fractionalPart = modf(num, &num);\n    \n    // Check for equidistant cases and round away from zero\n    if (abs(fractionalPart) == 0.5) {\n        return num > 0 ? ceil(num) : floor(num);\n    } else {\n        return round(num);\n    }\n}\n\n"}
{"task_id": "CPP/100", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Function to generate the pile of stones\nvector<int> make_a_pile(int n) {\n    vector<int> result;\n    \n    // Start with n stones at the first level\n    int current_stones = n;\n    for (int i = 0; i < n; ++i) {\n        result.push_back(current_stones);\n        \n        // Determine the next number of stones based on whether the current is odd or even\n        if (current_stones % 2 == 0) {\n            // If current_stones is even, add the next even number\n            current_stones += 2;\n        } else {\n            // If current_stones is odd, add the next odd number\n            current_stones += 2;\n        }\n    }\n    \n    return result;\n}\n\n// Function to check the correctness of the make_a_pile function\nvoid check() {\n    vector<int> expected = {3, 5, 7};\n    assert(make_a_pile(3) == expected);\n    \n    expected = {4, 6, 8, 10};\n    assert(make_a_pile(4) == expected);\n    \n    cout << \"All test cases passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/101", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>  // For std::istringstream\n\nusing namespace std;\n\nvector<string> words_string(string s) {\n    vector<string> result;\n    stringstream ss(s);\n    string word;\n\n    while (getline(ss, word, ',')) {  // Split by commas\n        stringstream wordStream(word);  // Create a stream for the current word\n        while (wordStream >> word) {  // Extract words from the current word stream\n            if (!word.empty()) {\n                result.push_back(word);\n            }\n        }\n    }\n\n    return result;\n}\n\n// Function to test the words_string function\nvoid check() {\n    vector<string> expected1 = {\"Hi\", \"my\", \"name\", \"is\", \"John\"};\n    vector<string> expected2 = {\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"};\n\n    vector<string> result1 = words_string(\"Hi, my name is John\");\n    vector<string> result2 = words_string(\"One, two, three, four, five, six\");\n\n    if (result1 == expected1 && result2 == expected2) {\n        cout << \"All tests passed!\" << endl;\n    } else {\n        cout << \"Tests failed.\" << endl;\n    }\n}\n\n"}
{"task_id": "CPP/102", "generation": "#include <iostream>\nusing namespace std;\n\nint choose_num(int x, int y) {\n    // Check if the upper bound is less than the lower bound\n    if (y < x) {\n        return -1;\n    }\n\n    // Start from the upper bound and check downwards for an even number\n    for (int i = y; i >= x; --i) {\n        if (i % 2 == 0) {\n            return i;\n        }\n    }\n\n    // If no even number is found, return -1\n    return -1;\n}\n\n// Function to test the choose_num function with some examples\nvoid test() {\n    cout << \"choose_num(12, 15): \" << choose_num(12, 15) << endl; // Should output 14\n    cout << \"choose_num(13, 12): \" << choose_num(13, 12) << endl; // Should output -1\n    cout << \"choose_num(10, 20): \" << choose_num(10, 20) << endl; // Should output 20\n    cout << \"choose_num(5, 7): \" << choose_num(5, 7) << endl;     // Should output 6\n}\n\n"}
{"task_id": "CPP/103", "generation": "#include <stdio.h>\n#include <cmath>\n#include <string>\n\nusing namespace std;\n\nstring rounded_avg(int n, int m) {\n    // Check if n is greater than m\n    if (n > m) {\n        return \"-1\";\n    }\n\n    // Calculate the sum of integers from n to m\n    long long sum = 0;\n    for (int i = n; i <= m; ++i) {\n        sum += i;\n    }\n\n    // Calculate the average and round it to the nearest integer (towards the smaller one)\n    int avg = round(static_cast<double>(sum) / (m - n + 1));\n\n    // Convert the rounded integer to binary\n    string binary = \"\";\n    if (avg == 0) {\n        binary += \"0\";\n    }\n    while (avg > 0) {\n        binary = to_string(avg % 2) + binary;\n        avg /= 2;\n    }\n\n    return binary;\n}\n\n"}
{"task_id": "CPP/104", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nbool hasEvenDigit(int num) {\n    while (num > 0) {\n        int digit = num % 10;\n        if (digit % 2 == 0) {\n            return true;\n        }\n        num /= 10;\n    }\n    return false;\n}\n\nvector<int> unique_digits(vector<int> x) {\n    vector<int> result;\n\n    for (int num : x) {\n        if (!hasEvenDigit(num)) {\n            result.push_back(num);\n        }\n    }\n\n    sort(result.begin(), result.end());\n\n    return result;\n}\n\n// Function to print the vector\nvoid printVector(const vector<int>& vec) {\n    for (int num : vec) {\n        cout << num << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/105", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to replace number by its corresponding name\nstring get_name(int num) {\n    map<int, string> digit_names = {\n        {1, \"One\"}, {2, \"Two\"}, {3, \"Three\"}, {4, \"Four\"},\n        {5, \"Five\"}, {6, \"Six\"}, {7, \"Seven\"}, {8, \"Eight\"}, {9, \"Nine\"}\n    };\n    return digit_names[num];\n}\n\nvector<string> by_length(vector<int> arr) {\n    // Step 1: Filter out numbers not between 1 and 9\n    vector<int> filtered;\n    for (int num : arr) {\n        if (num >= 1 && num <= 9) {\n            filtered.push_back(num);\n        }\n    }\n\n    // Step 2: Sort the filtered numbers in ascending order\n    sort(filtered.begin(), filtered.end());\n\n    // Step 3: Reverse the sorted vector\n    reverse(filtered.begin(), filtered.end());\n\n    // Step 4: Replace each digit by its corresponding name\n    vector<string> result;\n    for (int num : filtered) {\n        result.push_back(get_name(num));\n    }\n\n    return result;\n}\n\n// Function to test the solution\nvoid check() {\n    vector<int> arr1 = {2, 1, 1, 4, 5, 8, 2, 3};\n    vector<string> expected1 = {\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"};\n    assert(by_length(arr1) == expected1);\n\n    vector<int> arr2 = {};\n    vector<string> expected2 = {};\n    assert(by_length(arr2) == expected2);\n\n    vector<int> arr3 = {1, -1, 55};\n    vector<string> expected3 = {\"One\"};\n    assert(by_length(arr3) == expected3);\n\n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/106", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// Function to calculate factorial of a number\nint factorial(int num) {\n    if (num == 0 || num == 1)\n        return 1;\n    int fact = 1;\n    for (int i = 2; i <= num; ++i) {\n        fact *= i;\n    }\n    return fact;\n}\n\n// Function to calculate sum of numbers from 1 to a number\nint sum(int num) {\n    return (num * (num + 1)) / 2;\n}\n\nvector<int> f(int n) {\n    vector<int> result(n);\n    for (int i = 0; i < n; ++i) {\n        int index = i + 1; // Since i starts from 1\n        if ((index % 2) == 0) { // Check if index is even\n            result[i] = factorial(index);\n        } else { // If index is odd\n            result[i] = sum(index);\n        }\n    }\n    return result;\n}\n\n// Function to check the correctness of the function f\nvoid check() {\n    vector<int> expected = {1, 2, 6, 24, 15};\n    vector<int> result = f(5);\n    bool is_correct = true;\n    for (int i = 0; i < 5 && is_correct; ++i) {\n        if (result[i] != expected[i]) {\n            is_correct = false;\n        }\n    }\n    if (is_correct) {\n        cout << \"The function f is correct.\" << endl;\n    } else {\n        cout << \"The function f is incorrect.\" << endl;\n    }\n}\n\n"}
{"task_id": "CPP/107", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool is_palindrome(int num) {\n    string str = to_string(num);\n    int len = str.length();\n    for (int i = 0; i < len / 2; ++i) {\n        if (str[i] != str[len - i - 1]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nvector<int> even_odd_palindrome(int n) {\n    int even_count = 0, odd_count = 0;\n\n    // Single-digit palindromes\n    for (int i = 1; i <= n; ++i) {\n        if (is_palindrome(i)) {\n            if (i % 2 == 0) {\n                even_count++;\n            } else {\n                odd_count++;\n            }\n        }\n    }\n\n    // Multi-digit palindromes\n    for (int len = 2; len <= to_string(n).length(); ++len) {\n        int start = pow(10, len - 1);\n        int end = pow(10, len) - 1;\n        \n        if (end > n) {\n            end = n;\n        }\n\n        for (int i = start; i <= end; ++i) {\n            string str = to_string(i);\n            string rev_str = str;\n            reverse(rev_str.begin(), rev_str.end());\n            \n            // Construct the palindrome\n            int palindrome;\n            if (len % 2 == 0) {\n                palindrome = stoi(str + rev_str.substr(1));\n            } else {\n                palindrome = stoi(str + rev_str);\n            }\n\n            if (palindrome <= n && is_palindrome(palindrome)) {\n                if (palindrome % 2 == 0) {\n                    even_count++;\n                } else {\n                    odd_count++;\n                }\n            }\n        }\n    }\n\n    return {even_count, odd_count};\n}\n\n"}
{"task_id": "CPP/108", "generation": "#include <iostream>\n#include <vector>\n\nint count_nums(const std::vector<int>& n) {\n    int count = 0;\n    \n    for (const auto& num : n) {\n        int sum_of_digits = 0;\n        \n        // Handle positive and negative numbers separately\n        if (num >= 0) {\n            while (num > 0) {\n                sum_of_digits += num % 10;\n                num /= 10;\n            }\n        } else {\n            bool first_digit_neg = true;\n            int abs_num = std::abs(num);\n            \n            while (abs_num > 0) {\n                if (first_digit_neg) {\n                    sum_of_digits -= abs_num % 10;\n                    first_digit_neg = false;\n                } else {\n                    sum_of_digits += abs_num % 10;\n                }\n                abs_num /= 10;\n            }\n        }\n        \n        // Check if the sum of digits is greater than zero\n        if (sum_of_digits > 0) {\n            count++;\n        }\n    }\n    \n    return count;\n}\n\n"}
{"task_id": "CPP/109", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool move_one_ball(vector<int> arr) {\n    int N = arr.size();\n    \n    // Check if there's any element that is smaller than its next element (considering wrap-around)\n    for (int i = 0; i < N; ++i) {\n        if (arr[i] > arr[(i + 1) % N]) {\n            return false;\n        }\n    }\n    \n    // If no such pair is found, it's possible to sort the array by right shifts\n    return true;\n}\n\n"}
{"task_id": "CPP/110", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring exchange(vector<int> lst1, vector<int> lst2) {\n    int oddCount = 0;\n    int evenCount = 0;\n\n    // Count odd and even numbers in lst1\n    for (int num : lst1) {\n        if (num % 2 != 0) {\n            oddCount++;\n        }\n    }\n\n    // Count even numbers in lst2\n    for (int num : lst2) {\n        if (num % 2 == 0) {\n            evenCount++;\n        }\n    }\n\n    // Check if it's possible to exchange elements\n    if (oddCount <= evenCount) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n\n"}
{"task_id": "CPP/111", "generation": "#include <iostream>\n#include <string>\n#include <map>\n#include <vector>\nusing namespace std;\n\n// Function to find the most frequent letters and their counts\nmap<char, int> histogram(string test) {\n    map<char, int> letterCount;\n    \n    // Count the frequency of each character in the string\n    for (char c : test) {\n        if (c != ' ') {  // Ignore spaces\n            letterCount[c]++;\n        }\n    }\n\n    // Find the maximum count\n    int maxCount = 0;\n    for (const auto& pair : letterCount) {\n        if (pair.second > maxCount) {\n            maxCount = pair.second;\n        }\n    }\n\n    // Create a map to store the most frequent letters and their counts\n    map<char, int> result;\n    for (const auto& pair : letterCount) {\n        if (pair.second == maxCount) {\n            result.insert(pair);\n        }\n    }\n\n    return result;\n}\n\n// Function to print the map for testing purposes\nvoid printMap(const map<char, int>& m) {\n    for (const auto& pair : m) {\n        cout << \"{\" << pair.first << \", \" << pair.second << \"} \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/112", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nbool is_palindrome(const string& str) {\n    int left = 0;\n    int right = str.size() - 1;\n    \n    while (left < right) {\n        if (str[left] != str[right]) {\n            return false;\n        }\n        ++left;\n        --right;\n    }\n    \n    return true;\n}\n\nvector<string> reverse_delete(string s, string c) {\n    // Remove characters in s that are present in c\n    for (char ch : c) {\n        s.erase(remove(s.begin(), s.end(), ch), s.end());\n    }\n\n    // Check if the resulting string is a palindrome\n    bool result = is_palindrome(s);\n\n    // Return the modified string and the boolean result\n    return {s, to_string(result)};\n}\n\n"}
{"task_id": "CPP/113", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<string> odd_count(vector<string> lst) {\n    vector<string> result;\n    for (const auto& str : lst) {\n        int count = 0;\n        // Count the number of odd digits in the string\n        for (char c : str) {\n            if ((c - '0') % 2 != 0) {\n                count++;\n            }\n        }\n        // Construct the result string\n        string output = \"the number of odd elements \";\n        output += to_string(count);\n        output += \"n the str\";\n        output += to_string(count);\n        output += \"ng \";\n        output += to_string(count);\n        output += \" of the \";\n        output += to_string(count);\n        output += \"nput.\";\n        result.push_back(output);\n    }\n    return result;\n}\n\n"}
{"task_id": "CPP/114", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nlong long minSubArraySum(vector<long long> nums) {\n    if (nums.empty()) return 0; // Handle empty vector case\n\n    long long current_sum = nums[0];\n    long long min_sum = nums[0];\n\n    for (size_t i = 1; i < nums.size(); ++i) {\n        // If current sum becomes negative, start from the current element\n        current_sum = min(nums[i], current_sum + nums[i]);\n        min_sum = min(min_sum, current_sum);\n    }\n\n    return min_sum;\n}\n\n"}
{"task_id": "CPP/115", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint max_fill(vector<vector<int>> grid, int capacity) {\n    int total_lowerings = 0;\n    \n    // Iterate through each well (row in the grid)\n    for (const auto& row : grid) {\n        int water_units = 0;\n        \n        // Count the number of units of water in this well\n        for (int unit : row) {\n            if (unit == 1) {\n                ++water_units;\n            }\n        }\n        \n        // Calculate the number of times the bucket must be lowered\n        total_lowerings += (water_units + capacity - 1) / capacity;\n    }\n    \n    return total_lowerings;\n}\n\n"}
{"task_id": "CPP/116", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to count the number of 1s in the binary representation of an integer\nint countOnes(int n) {\n    int count = 0;\n    while (n > 0) {\n        count += n & 1; // Check if the last bit is 1\n        n >>= 1; // Right shift to check the next bit\n    }\n    return count;\n}\n\n// Custom comparator for sorting\nbool customComparator(int a, int b) {\n    int onesA = countOnes(a);\n    int onesB = countOnes(b);\n\n    if (onesA == onesB) {\n        return a < b; // If the number of 1s is the same, sort by decimal value\n    }\n    return onesA < onesB; // Otherwise, sort by the number of 1s\n}\n\nvector<int> sort_array(vector<int> arr) {\n    sort(arr.begin(), arr.end(), customComparator);\n    return arr;\n}\n\n"}
{"task_id": "CPP/117", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\n// Helper function to check if a character is a consonant\nbool is_consonant(char c) {\n    return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') \n           && !(c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u'\n                || c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U');\n}\n\n// Function to count the number of consonants in a word\nint count_consonants(const string& word) {\n    int count = 0;\n    for (char c : word) {\n        if (is_consonant(c)) {\n            ++count;\n        }\n    }\n    return count;\n}\n\nvector<string> select_words(string s, int n) {\n    vector<string> result;\n    // Split the string into words\n    size_t start = 0;\n    size_t end = s.find(' ');\n    \n    while (end != string::npos) {\n        string word = s.substr(start, end - start);\n        if (count_consonants(word) == n) {\n            result.push_back(word);\n        }\n        start = end + 1;\n        end = s.find(' ', start);\n    }\n    \n    // Check the last segment\n    string last_word = s.substr(start);\n    if (!last_word.empty() && count_consonants(last_word) == n) {\n        result.push_back(last_word);\n    }\n    \n    return result;\n}\n\n// Function to test the select_words function\nvoid test_select_words() {\n    assert(select_words(\"Mary had a little lamb\", 4) == vector<string>{\"little\"});\n    assert(select_words(\"Mary had a little lamb\", 3) == vector<string>{\"Mary\", \"lamb\"});\n    assert(select_words(\"simple white space\", 2).empty());\n    assert(select_words(\"Hello world\", 4) == vector<string>{\"world\"});\n    assert(select_words(\"Uncle sam\", 3) == vector<string>{\"Uncle\"});\n\n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/118", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_vowel(char c) {\n    return tolower(c) == 'a' || tolower(c) == 'e' || tolower(c) == 'i' || \n           tolower(c) == 'o' || tolower(c) == 'u';\n}\n\nbool is_consonant(char c) {\n    return !is_vowel(c) && isalpha(c);\n}\n\nstring get_closest_vowel(string word) {\n    int n = word.length();\n    \n    for (int i = n - 2; i >= 0; --i) { // Start from the second last character\n        if (is_consonant(word[i]) && is_consonant(word[i + 1])) {\n            if (is_vowel(word[i + 1])) {\n                return string(1, word[i + 1]);\n            }\n        }\n    }\n\n    return \"\"; // Return empty string if no such vowel found\n}\n\n"}
{"task_id": "CPP/119", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\n// Helper function to count open and close parentheses in a string\nint count_parentheses(const string& s) {\n    int open = 0, close = 0;\n    for (char c : s) {\n        if (c == '(') open++;\n        else if (c == ')') close++;\n    }\n    return open - close; // Returns the difference between open and close parentheses\n}\n\n// Function to check if a string is balanced\nbool is_balanced(const string& s) {\n    int balance = 0;\n    for (char c : s) {\n        if (c == '(') balance++;\n        else if (c == ')') balance--;\n        if (balance < 0) return false; // If balance goes negative, it's unbalanced\n    }\n    return balance == 0; // String is balanced if balance is zero\n}\n\nstring match_parens(vector<string> lst) {\n    string s1 = lst[0], s2 = lst[1];\n    \n    // Check both possible concatenations\n    if (is_balanced(s1 + s2)) return \"Yes\";\n    if (is_balanced(s2 + s1)) return \"Yes\";\n\n    return \"No\"; // If neither order is balanced, return \"No\"\n}\n\n"}
{"task_id": "CPP/120", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n// Function to return the maximum k numbers from the vector arr\nvector<int> maximum(vector<int> arr, int k) {\n    // Sort the first k elements of the vector in descending order\n    nth_element(arr.begin(), arr.begin() + k - 1, arr.end(), greater<int>());\n    \n    // Create a new vector to store the top k elements\n    vector<int> result;\n    for (int i = 0; i < k; ++i) {\n        result.push_back(arr[i]);\n    }\n    \n    // Sort the resulting vector in ascending order\n    sort(result.begin(), result.end());\n    \n    return result;\n}\n\n// Function to print the vector\nvoid printVector(const vector<int>& vec) {\n    for (int num : vec) {\n        cout << num << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/121", "generation": "#include <vector>\nusing namespace std;\n\nint solution(const vector<int>& lst) {\n    int sum = 0;\n    for (size_t i = 0; i < lst.size(); ++i) {\n        // Check if the index is even and the element at that position is odd\n        if (i % 2 == 0 && lst[i] % 2 != 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n\n// Function to test the solution with provided examples\nvoid check_solution() {\n    assert(solution({5, 8, 7, 1}) == 12);\n    assert(solution({3, 3, 3, 3, 3}) == 9);\n    assert(solution({30, 13, 24, 321}) == 0);\n}\n\n"}
{"task_id": "CPP/122", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint add_elements(vector<int> arr, int k) {\n    int sum = 0;\n    \n    // Iterate through the first k elements of the array\n    for (int i = 0; i < k; ++i) {\n        // Check if the current element has at most two digits\n        if (arr[i] >= -99 && arr[i] <= 99) {\n            sum += arr[i];\n        }\n    }\n    \n    return sum;\n}\n\n// Function to test the add_elements function with provided data points\nvoid check() {\n    vector<int> arr1 = {111, 21, 3, 4000, 5, 6, 7, 8, 9};\n    int k1 = 4;\n    cout << \"Test Case 1: Expected Output: 24, Actual Output: \" << add_elements(arr1, k1) << endl;\n\n    vector<int> arr2 = {100, -56, 78, 34, 99};\n    int k2 = 5;\n    cout << \"Test Case 2: Expected Output: 211, Actual Output: \" << add_elements(arr2, k2) << endl;\n\n    vector<int> arr3 = {10, 20, 30, 40, 50};\n    int k3 = 3;\n    cout << \"Test Case 3: Expected Output: 60, Actual Output: \" << add_elements(arr3, k3) << endl;\n\n    vector<int> arr4 = {1, 2, 3, 4, 5};\n    int k4 = 5;\n    cout << \"Test Case 4: Expected Output: 15, Actual Output: \" << add_elements(arr4, k4) << endl;\n}\n\n"}
{"task_id": "CPP/123", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n// Function to get the next number in the Collatz sequence\nint next_collatz(int n) {\n    if (n % 2 == 0) {\n        return n / 2;\n    } else {\n        return 3 * n + 1;\n    }\n}\n\n// Function to generate and return odd numbers in the Collatz sequence of a given number\nvector<int> get_odd_collatz(int n) {\n    vector<int> result;\n    \n    // Generate the Collatz sequence until we reach 1\n    while (n != 1) {\n        if (n % 2 == 1) { // Check if the current number is odd\n            result.push_back(n);\n        }\n        n = next_collatz(n); // Move to the next number in the sequence\n    }\n\n    // Add 1 to the result as it's always part of the Collatz sequence for any positive integer\n    result.push_back(1);\n\n    // Sort the vector in increasing order\n    sort(result.begin(), result.end());\n\n    return result;\n}\n\n// Function to test the get_odd_collatz function with some examples\nvoid test_get_odd_collatz() {\n    cout << \"Testing get_odd_collatz...\" << endl;\n\n    vector<int> result = get_odd_collatz(5);\n    cout << \"get_odd_collatz(5) returns: \";\n    for (int num : result) {\n        cout << num << \" \";\n    }\n    cout << endl;\n\n    result = get_odd_collatz(10);\n    cout << \"get_odd_collatz(10) returns: \";\n    for (int num : result) {\n        cout << num << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/124", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nbool valid_date(string date) {\n    // Check if the date string is empty\n    if (date.empty()) return false;\n\n    // Use stringstream to split the date into month, day, and year\n    stringstream ss(date);\n    string token;\n    vector<string> parts;\n    while (getline(ss, token, '-')) {\n        parts.push_back(token);\n    }\n\n    // Check if we have exactly 3 parts (month, day, year)\n    if (parts.size() != 3) return false;\n\n    int month, day, year;\n    try {\n        // Convert the string parts to integers\n        month = stoi(parts[0]);\n        day = stoi(parts[1]);\n        year = stoi(parts[2]);\n\n        // Validate the number of days for each month\n        if (month == 2) {\n            if ((year % 400 == 0 || (year % 4 == 0 && year % 100 != 0)) && day > 29) return false;\n            else if (day > 28) return false;\n        } else if (month == 4 || month == 6 || month == 9 || month == 11) {\n            if (day > 30) return false;\n        } else {\n            if (day > 31) return false;\n        }\n\n        // Validate the month\n        if (month < 1 || month > 12) return false;\n\n    } catch (...) {\n        // If conversion to integer fails, it's not a valid date\n        return false;\n    }\n\n    return true;\n}\n\n"}
{"task_id": "CPP/125", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\n// Function to count lowercase letters with odd order in the alphabet\nint countOddOrderLetters(const string& str) {\n    int count = 0;\n    for (char c : str) {\n        if (islower(c)) {\n            // Calculate the order of the letter and check if it's odd\n            if ((c - 'a') % 2 == 1) {\n                count++;\n            }\n        }\n    }\n    return count;\n}\n\n// Function to split words based on whitespace, commas, or return a vector with one element for lowercase letters with odd order\nvector<string> split_words(string txt) {\n    // Check if there are any whitespaces in the text\n    size_t pos = txt.find(' ');\n    if (pos != string::npos) {\n        // Split by whitespace\n        string firstPart = txt.substr(0, pos);\n        string secondPart = txt.substr(pos + 1);\n        return {firstPart, secondPart};\n    }\n\n    // Check if there are any commas in the text\n    pos = txt.find(',');\n    if (pos != string::npos) {\n        // Split by comma\n        string firstPart = txt.substr(0, pos);\n        string secondPart = txt.substr(pos + 1);\n        return {firstPart, secondPart};\n    }\n\n    // If no whitespaces or commas are found, count lowercase letters with odd order\n    int oddCount = countOddOrderLetters(txt);\n    if (oddCount > 0) {\n        vector<string> result;\n        result.push_back(to_string(oddCount));\n        return result;\n    } else {\n        // Return the original text as a single element in a vector\n        return {txt};\n    }\n}\n\n// Function to test the split_words function with provided examples\nvoid test_split_words() {\n    assert(split_words(\"Hello world!\") == vector<string>{\"Hello\", \"world!\"});\n    assert(split_words(\"Hello,world!\") == vector<string>{\"Hello\", \"world!\"});\n    assert(split_words(\"abcdef\") == vector<string>{\"3\"});\n    assert(split_words(\"AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz\") == vector<string>{\"13\"});\n    assert(split_words(\"NoSpacesOrCommas\") == vector<string>{\"NoSpacesOrCommas\"});\n\n    printf(\"All tests passed.\\n\");\n}\n\n"}
{"task_id": "CPP/126", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nbool is_sorted(vector<int> lst) {\n    // Check if the list is empty or has one element, which is trivially sorted.\n    if (lst.size() <= 1) return true;\n    \n    int count = 1; // To keep track of consecutive duplicates\n    \n    for (int i = 1; i < lst.size(); ++i) {\n        // Check if the current number is greater than or equal to the previous one\n        if (lst[i] >= lst[i - 1]) {\n            // If it's a duplicate, increment count\n            if (lst[i] == lst[i - 1]) {\n                count++;\n                // If a number appears more than twice, return false\n                if (count > 2) return false;\n            } else {\n                // Reset count for new numbers\n                count = 1;\n            }\n        } else {\n            // If the list is not sorted in ascending order, return false\n            return false;\n        }\n    }\n    \n    return true;\n}\n\n"}
{"task_id": "CPP/127", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    if (n == 2) return true;\n    if (n % 2 == 0) return false;\n    for (int i = 3; i * i <= n; i += 2) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\nstd::string intersection(std::vector<int> interval1, std::vector<int> interval2) {\n    int start = std::max(interval1[0], interval2[0]);\n    int end = std::min(interval1[1], interval2[1]);\n\n    if (start > end) return \"NO\"; // No intersection\n\n    int length = end - start + 1;\n\n    if (is_prime(length)) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n\n"}
{"task_id": "CPP/128", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint prod_signs(vector<int> arr) {\n    if (arr.empty()) {\n        return -32768;\n    }\n\n    int magnitude_sum = 0;\n    int sign_product = 1;\n\n    for (int num : arr) {\n        magnitude_sum += abs(num);\n\n        // Determine the product of signs\n        if (num < 0) {\n            sign_product *= -1;\n        } else if (num == 0) {\n            sign_product = 0;\n            break; // If any number is zero, the overall product will be zero.\n        }\n    }\n\n    return magnitude_sum * sign_product;\n}\n\n"}
{"task_id": "CPP/129", "generation": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\n// Define directions for moving up, down, left, right\nconst int dx[] = {-1, 1, 0, 0};\nconst int dy[] = {0, 0, -1, 1};\n\nstruct Path {\n    vector<int> path;\n    int x, y;\n    \n    bool operator<(const Path& other) const {\n        // Compare lexicographically\n        for (int i = 0; i < min(path.size(), other.path.size()); ++i) {\n            if (path[i] != other.path[i]) return path[i] < other.path[i];\n        }\n        return path.size() < other.path.size();\n    }\n};\n\nvector<int> minPath(vector<vector<int>>& grid, int k) {\n    int n = grid.size();\n    \n    // Priority queue to store paths\n    priority_queue<Path, vector<Path>, greater<>> pq;\n    \n    // Initialize the starting points (all cells)\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            pq.push({{grid[i][j]}, i, j});\n        }\n    }\n    \n    while (!pq.empty()) {\n        Path current = pq.top();\n        pq.pop();\n        \n        // If the path length is k, return it\n        if (current.path.size() == k) {\n            return current.path;\n        }\n        \n        // Explore neighbors\n        for (int dir = 0; dir < 4; ++dir) {\n            int nx = current.x + dx[dir];\n            int ny = current.y + dy[dir];\n            \n            // Check if the new position is within bounds\n            if (nx >= 0 && nx < n && ny >= 0 && ny < n) {\n                vector<int> newPath = current.path;\n                newPath.push_back(grid[nx][ny]);\n                \n                pq.push({newPath, nx, ny});\n            }\n        }\n    }\n    \n    return {}; // This should never happen due to the problem constraints\n}\n\n"}
{"task_id": "CPP/130", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Function to compute the tribonacci number for a given n\nint tribonacci(int n) {\n    if (n == 1) return 3;\n    else if (n % 2 == 0) return 1 + n / 2;\n    else {\n        // For odd n, we need to calculate tri(n-1), tri(n-2), and tri(n+1)\n        int a = tribonacci(n - 1);\n        int b = tribonacci(n - 2);\n        int c = tribonacci(n + 1); // Note: This is not directly used in the formula, but we need to calculate it\n        return a + b + c;\n    }\n}\n\n// Function to generate the first n+1 numbers of the Tribonacci sequence\nvector<int> tri(int n) {\n    vector<int> result(n + 1);\n    for (int i = 0; i <= n; ++i) {\n        result[i] = tribonacci(i);\n    }\n    return result;\n}\n\n// Function to print a vector\nvoid printVector(const vector<int>& vec) {\n    for (const auto& val : vec) {\n        cout << val << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/131", "generation": "#include <iostream>\nusing namespace std;\n\nint digits(int n) {\n    int product = 1;\n    bool hasOddDigit = false;\n\n    while (n > 0) {\n        int digit = n % 10;\n        if (digit % 2 != 0) { // Check if the digit is odd\n            product *= digit;\n            hasOddDigit = true;\n        }\n        n /= 10; // Remove the last digit from n\n    }\n\n    return hasOddDigit ? product : 0;\n}\n\n"}
{"task_id": "CPP/132", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_nested(string str) {\n    int balance = 0;\n    bool hasNested = false;\n\n    for (char c : str) {\n        if (c == '[') {\n            balance++;\n        } else if (c == ']') {\n            if (balance > 1) {\n                // If there are more than one opening brackets before this closing bracket, it means nesting\n                hasNested = true;\n            }\n            balance--;\n        }\n\n        // If at any point the balance is negative, it means we have a closing bracket without an opening counterpart\n        if (balance < 0) {\n            return false;\n        }\n    }\n\n    // The string must be balanced and contain nested brackets to be considered valid\n    return hasNested && balance == 0;\n}\n\n"}
{"task_id": "CPP/133", "generation": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nint sum_squares(vector<float> lst) {\n    int sum = 0;\n    \n    for (float num : lst) {\n        // Round up to the nearest integer\n        float ceil_num = ceil(num);\n        \n        // Add the square of the rounded number to the sum\n        sum += static_cast<int>(ceil_num * ceil_num);\n    }\n    \n    return sum;\n}\n\n"}
{"task_id": "CPP/134", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool check_if_last_char_is_a_letter(string txt) {\n    // Check if the string is empty or does not end with a space\n    if (txt.empty() || txt.back() != ' ') {\n        return false;\n    }\n\n    // Find the last non-space character before the trailing space\n    size_t pos = txt.find_last_not_of(' ');\n    if (pos == string::npos) {\n        return false;  // The entire string is spaces, no valid letter at the end\n    }\n\n    // Check if the character at that position is an alphabetical character\n    char last_char = txt[pos];\n    return ('a' <= last_char && last_char <= 'z') || ('A' <= last_char && last_char <= 'Z');\n}\n\n"}
{"task_id": "CPP/135", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint can_arrange(vector<int> arr) {\n    if (arr.size() <= 1) {\n        return -1; // No elements or only one element means no such index exists.\n    }\n\n    for (int i = arr.size() - 2; i >= 0; --i) {\n        if (arr[i] > arr[i + 1]) {\n            return i;\n        }\n    }\n\n    return -1; // Return -1 if no such element is found.\n}\n\n"}
{"task_id": "CPP/136", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> largest_smallest_integers(vector<int> lst) {\n    int max_negative = INT_MIN; // Initialize to smallest possible integer\n    int min_positive = INT_MAX; // Initialize to largest possible integer\n\n    bool has_negative = false;\n    bool has_positive = false;\n\n    for (int num : lst) {\n        if (num < 0) {\n            has_negative = true;\n            max_negative = max(max_negative, num);\n        } else if (num > 0) {\n            has_positive = true;\n            min_positive = min(min_positive, num);\n        }\n    }\n\n    // If no negative or positive integers are found, return {0, 0}\n    if (!has_negative || !has_positive) {\n        return {0, 0};\n    }\n\n    return {max_negative, min_positive};\n}\n\n"}
{"task_id": "CPP/137", "generation": "#include <iostream>\n#include <string>\n#include <boost/any.hpp>\n\n// Function to convert string with comma as decimal separator to double\ndouble str_to_double(const std::string& s) {\n    size_t pos;\n    return std::stod(s, &pos); // Convert and get the position of the first non-converted character\n}\n\nbool is_comma_decimal(const std::string& s) {\n    for (char c : s) {\n        if (c == ',') return true;\n    }\n    return false;\n}\n\nboost::any compare_one(boost::any a, boost::any b) {\n    double val_a = 0.0;\n    double val_b = 0.0;\n\n    // Convert to common format\n    if (a.type() == typeid(int)) {\n        val_a = std::any_cast<int>(a);\n    } else if (a.type() == typeid(float)) {\n        val_a = std::any_cast<float>(a);\n    } else if (a.type() == typeid(std::string)) {\n        const std::string& str_a = std::any_cast<std::string>(a);\n        if (is_comma_decimal(str_a)) {\n            val_a = str_to_double(str_a);\n        } else {\n            val_a = std::stod(str_a); // Convert using dot as decimal separator\n        }\n    }\n\n    if (b.type() == typeid(int)) {\n        val_b = std::any_cast<int>(b);\n    } else if (b.type() == typeid(float)) {\n        val_b = std::any_cast<float>(b);\n    } else if (b.type() == typeid(std::string)) {\n        const std::string& str_b = std::any_cast<std::string>(b);\n        if (is_comma_decimal(str_b)) {\n            val_b = str_to_double(str_b);\n        } else {\n            val_b = std::stod(str_b); // Convert using dot as decimal separator\n        }\n    }\n\n    // Compare the values and return the larger one in its original type\n    if (val_a > val_b) {\n        if (a.type() == typeid(int)) {\n            return a;\n        } else if (a.type() == typeid(float)) {\n            return b; // Return as float since it was converted to double for comparison\n        } else if (a.type() == typeid(std::string)) {\n            return std::to_string(val_a); // Convert back to string with dot as decimal separator\n        }\n    } else if (val_b > val_a) {\n        if (b.type() == typeid(int)) {\n            return b;\n        } else if (b.type() == typeid(float)) {\n            return a; // Return as float since it was converted to double for comparison\n        } else if (b.type() == typeid(std::string)) {\n            return std::to_string(val_b); // Convert back to string with dot as decimal separator\n        }\n    }\n\n    // If values are equal, return None\n    return boost::any();\n}\n\n"}
{"task_id": "CPP/138", "generation": "#include <iostream>\nusing namespace std;\n\nbool is_equal_to_sum_even(int n) {\n    // Check if n is less than 8 or not even\n    if (n < 8 || n % 2 != 0) {\n        return false;\n    }\n    \n    // If n is at least 8 and even, it can be written as the sum of four positive even numbers\n    return true;\n}\n\n"}
{"task_id": "CPP/139", "generation": "#include <iostream>\n\n// Function to compute factorial of a number\nlong long factorial(long long num) {\n    if (num == 0 || num == 1)\n        return 1;\n    else\n        return num * factorial(num - 1);\n}\n\n// Function to compute the Brazilian factorial\nlong long special_factorial(int n) {\n    long long result = 1;\n    for (int i = n; i > 0; --i) {\n        result *= factorial(i);\n    }\n    return result;\n}\n\n"}
{"task_id": "CPP/140", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring fix_spaces(string text) {\n    string result;\n    int space_count = 0;\n\n    for (char c : text) {\n        if (c == ' ') {\n            space_count++;\n            // If we have more than two consecutive spaces, add a hyphen\n            if (space_count > 2) {\n                result += '-';\n                // Skip the next characters as they are part of the same sequence of spaces\n                while (text[++result.size() - 1] == ' ');\n            }\n        } else {\n            space_count = 0; // Reset count for non-space characters\n            result += c;\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/141", "generation": "#include <iostream>\n#include <string>\n#include <cctype>\n\nusing namespace std;\n\nbool has_valid_prefix(const string& name) {\n    if (name.empty() || !isalpha(name[0])) return false;\n    int digit_count = 0;\n    for (char c : name) {\n        if (isdigit(c)) {\n            digit_count++;\n            if (digit_count > 3) return false;\n        } else if (!isalnum(c)) {\n            return false; // Invalid character\n        }\n    }\n    return true;\n}\n\nbool has_valid_extension(const string& name, size_t dot_pos) {\n    const string valid_extensions[] = {\"txt\", \"exe\", \"dll\"};\n    string extension = name.substr(dot_pos + 1);\n    for (const string& ext : valid_extensions) {\n        if (extension == ext) return true;\n    }\n    return false;\n}\n\nstring file_name_check(string file_name) {\n    size_t dot_pos = file_name.find('.');\n    if (dot_pos == string::npos || dot_pos == 0 || dot_pos + 4 > file_name.size()) {\n        return \"No\";\n    }\n\n    // Check the prefix\n    if (!has_valid_prefix(file_name.substr(0, dot_pos))) {\n        return \"No\";\n    }\n\n    // Check the extension\n    if (!has_valid_extension(file_name, dot_pos)) {\n        return \"No\";\n    }\n\n    return \"Yes\";\n}\n\n"}
{"task_id": "CPP/142", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint sum_squares(vector<int> lst) {\n    int sum = 0;\n    \n    for (size_t i = 0; i < lst.size(); ++i) {\n        if ((i + 1) % 3 == 0 && (i + 1) % 4 != 0) {\n            // Square the integer entry\n            sum += lst[i] * lst[i];\n        } else if ((i + 1) % 4 == 0) {\n            // Cube the integer entry\n            sum += lst[i] * lst[i] * lst[i];\n        }\n    }\n    \n    return sum;\n}\n\n// Function to test the implementation with provided examples\nvoid test() {\n    cout << \"Test 1: {1,2,3} -> Expected: 6, Got: \" << sum_squares({1, 2, 3}) << endl;\n    cout << \"Test 2: {} -> Expected: 0, Got: \" << sum_squares({}) << endl;\n    cout << \"Test 3: {-1,-5,2,-1,-5} -> Expected: -126, Got: \" << sum_squares({-1, -5, 2, -1, -5}) << endl;\n}\n\n"}
{"task_id": "CPP/143", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    if (n == 2 || n == 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    for (int i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0)\n            return false;\n    }\n    return true;\n}\n\n// Function to extract words with prime length from the sentence\nstring words_in_sentence(string sentence) {\n    stringstream ss(sentence);\n    string word, result = \"\";\n    \n    while (ss >> word) {\n        if (is_prime(word.length())) {\n            if (!result.empty()) \n                result += \" \";\n            result += word;\n        }\n    }\n    \n    return result;\n}\n\n// Function to test the solution\nvoid check() {\n    cout << words_in_sentence(\"This is a test\") << endl; // Output: \"is\"\n    cout << words_in_sentence(\"lets go for swimming\") << endl; // Output: \"go for\"\n}\n\n"}
{"task_id": "CPP/144", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool simplify(string x, string n) {\n    // Helper function to parse the fraction and return its components as integers\n    auto parse_fraction = [](const string& fraction) -> pair<int, int> {\n        size_t slash_pos = fraction.find('/');\n        int numerator = stoi(fraction.substr(0, slash_pos));\n        int denominator = stoi(fraction.substr(slash_pos + 1));\n        return {numerator, denominator};\n    };\n\n    // Parse the fractions\n    auto [num_x, den_x] = parse_fraction(x);\n    auto [num_n, den_n] = parse_fraction(n);\n\n    // Calculate the product of the numerators and denominators\n    int product_num = num_x * num_n;\n    int product_den = den_x * den_n;\n\n    // Check if the result is a whole number\n    return (product_num % product_den) == 0;\n}\n\n"}
{"task_id": "CPP/145", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// Helper function to calculate the sum of digits of an integer\nint digitSum(int n) {\n    int sum = 0;\n    bool negative = false;\n    \n    if (n < 0) {\n        n = -n; // Make it positive for digit extraction\n        negative = true;\n    }\n    \n    while (n > 0) {\n        sum += n % 10;\n        n /= 10;\n    }\n    \n    return sum;\n}\n\n// Custom comparator to sort based on the sum of digits and original index if sums are equal\nbool compareByDigitSumAndIndex(int a, int b, const vector<int>& nums) {\n    int sumA = digitSum(a);\n    int sumB = digitSum(b);\n    \n    // If sums are different, use the sum for comparison\n    if (sumA != sumB) {\n        return sumA < sumB;\n    }\n    \n    // If sums are the same, compare based on original index\n    return nums.index_of(a) < nums.index_of(b);\n}\n\nvector<int> order_by_points(vector<int> nums) {\n    vector<int> sortedNums = nums; // Copy of the original vector\n    \n    // Sort using the custom comparator\n    sort(sortedNums.begin(), sortedNums.end(), [&](int a, int b) {\n        return compareByDigitSumAndIndex(a, b, nums);\n    });\n    \n    return sortedNums;\n}\n\n// Function to check if the solution is correct\nvoid check() {\n    vector<int> test1 = {1, 11, -1, -11, -12};\n    vector<int> expected1 = {-1, -11, 1, -12, 11};\n    assert(order_by_points(test1) == expected1);\n    \n    vector<int> test2 = {};\n    vector<int> expected2 = {};\n    assert(order_by_points(test2) == expected2);\n    \n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/146", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint specialFilter(vector<int> nums) {\n    int count = 0;\n    \n    for (int num : nums) {\n        // Skip numbers that are not greater than 10\n        if (num <= 10) continue;\n        \n        // Convert number to string to easily access first and last digits\n        string strNum = to_string(abs(num));\n        \n        // Check the first digit\n        int firstDigit = strNum[0] - '0';\n        bool isFirstOdd = (firstDigit % 2 != 0);\n        \n        // Check the last digit\n        int lastDigit = strNum[strNum.length() - 1] - '0';\n        bool isLastOdd = (lastDigit % 2 != 0);\n        \n        // If both first and last digits are odd, increment count\n        if (isFirstOdd && isLastOdd) {\n            count++;\n        }\n    }\n    \n    return count;\n}\n\n"}
{"task_id": "CPP/147", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint get_max_triples(int n) {\n    vector<int> a(n);\n    \n    // Generate the vector a based on the formula a[i] = i * i - i + 1\n    for (int i = 0; i < n; ++i) {\n        a[i] = i * i - i + 1;\n    }\n    \n    int count = 0;\n    \n    // Iterate through all possible triples (i, j, k)\n    for (int i = 0; i < n - 2; ++i) {\n        for (int j = i + 1; j < n - 1; ++j) {\n            for (int k = j + 1; k < n; ++k) {\n                // Check if the sum of the triple is divisible by 3\n                if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                    count++;\n                }\n            }\n        }\n    }\n    \n    return count;\n}\n\n"}
{"task_id": "CPP/148", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to return all planets between planet1 and planet2, sorted by proximity to the Sun.\nvector<string> bf(string planet1, string planet2) {\n    // List of planets in order from closest to farthest from the Sun\n    vector<string> planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n    \n    // Find the positions of planet1 and planet2 in the list\n    auto it1 = find(planets.begin(), planets.end(), planet1);\n    auto it2 = find(planets.begin(), planets.end(), planet2);\n\n    // Check if both planets are valid\n    if (it1 == planets.end() || it2 == planets.end()) {\n        return {};  // Return an empty vector if either planet is not found\n    }\n\n    // Ensure the first iterator comes before the second one\n    if (it1 > it2) {\n        swap(it1, it2);\n    }\n\n    // Extract and return the sublist of planets between the two positions\n    vector<string> result;\n    for (auto it = it1 + 1; it != it2; ++it) {\n        result.push_back(*it);\n    }\n    \n    return result;\n}\n\n// Function to test the bf function with some examples\nvoid test() {\n    vector<string> result;\n\n    // Test case 1: Jupiter and Neptune\n    result = bf(\"Jupiter\", \"Neptune\");\n    for (const auto& planet : result) {\n        cout << planet << \" \";\n    }\n    cout << endl;  // Expected output: Saturn Uranus\n\n    // Test case 2: Earth and Mercury\n    result = bf(\"Earth\", \"Mercury\");\n    for (const auto& planet : result) {\n        cout << planet << \" \";\n    }\n    cout << endl;  // Expected output: Venus\n\n    // Test case 3: Mercury and Uranus\n    result = bf(\"Mercury\", \"Uranus\");\n    for (const auto& planet : result) {\n        cout << planet << \" \";\n    }\n    cout << endl;  // Expected output: Venus Earth Mars Jupiter Saturn\n}\n\n"}
{"task_id": "CPP/149", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to check if a string has an odd length\nbool has_odd_length(const string& str) {\n    return str.length() % 2 != 0;\n}\n\n// Comparator function for sorting strings by their length and then alphabetically\nbool compare_strings(const string& s1, const string& s2) {\n    if (s1.length() == s2.length()) {\n        return s1 < s2; // Alphabetical order if lengths are the same\n    }\n    return s1.length() < s2.length(); // Length order first\n}\n\nvector<string> sorted_list_sum(vector<string> lst) {\n    // Remove strings with odd lengths\n    lst.erase(remove_if(lst.begin(), lst.end(), has_odd_length), lst.end());\n\n    // Sort the vector using the custom comparator\n    sort(lst.begin(), lst.end(), compare_strings);\n\n    return lst;\n}\n\n// Function to test the sorted_list_sum function\nvoid test() {\n    assert(sorted_list_sum({\"aa\", \"a\", \"aaa\"}) == vector<string>{\"aa\"});\n    assert(sorted_list_sum({\"ab\", \"a\", \"aaa\", \"cd\"}) == vector<string>{\"ab\", \"cd\"});\n    cout << \"All tests passed.\" << endl;\n}\n\n"}
{"task_id": "CPP/150", "generation": "#include <stdio.h>\nusing namespace std;\n\n// Function to check if a number is prime\nbool isPrime(int n) {\n    // Handle edge cases\n    if (n <= 1) return false;\n    if (n == 2 || n == 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n\n    // Check for factors from 5 to sqrt(n)\n    for (int i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) return false;\n    }\n    return true;\n}\n\n// Function that returns x if n is prime, otherwise y\nint x_or_y(int n, int x, int y) {\n    return isPrime(n) ? x : y;\n}\n\n"}
{"task_id": "CPP/151", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nlong long double_the_difference(vector<float> lst) {\n    long long sum = 0;\n    \n    for (float num : lst) {\n        // Check if the number is positive, an integer, and odd\n        if (num > 0 && floor(num) == num && static_cast<int>(num) % 2 != 0) {\n            sum += pow(num, 2);\n        }\n    }\n    \n    return sum;\n}\n\n"}
{"task_id": "CPP/152", "generation": "#include <stdio.h>\n#include <math.h>\n#include <vector>\nusing namespace std;\n\nvector<int> compare(vector<int> game, vector<int> guess) {\n    vector<int> result;\n    \n    // Iterate through each match\n    for (size_t i = 0; i < game.size(); ++i) {\n        // Calculate the absolute difference between score and guess\n        int diff = abs(game[i] - guess[i]);\n        \n        // Add the difference to the result vector\n        result.push_back(diff);\n    }\n    \n    return result;\n}\n\n// Function to test the compare function with provided examples\nvoid check() {\n    vector<int> game1 = {1, 2, 3, 4, 5, 1};\n    vector<int> guess1 = {1, 2, 3, 4, 2, -2};\n    vector<int> expected1 = {0, 0, 0, 0, 3, 3};\n    assert(compare(game1, guess1) == expected1);\n\n    vector<int> game2 = {0, 5, 0, 0, 0, 4};\n    vector<int> guess2 = {4, 1, 1, 0, 0, -2};\n    vector<int> expected2 = {4, 4, 1, 0, 0, 6};\n    assert(compare(game2, guess2) == expected2);\n\n    printf(\"All tests passed.\\n\");\n}\n\n"}
{"task_id": "CPP/153", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to calculate the strength of an extension\nint calculateStrength(const string& extension) {\n    int cap = 0, sm = 0;\n    for (char c : extension) {\n        if (isupper(c)) cap++;\n        else if (islower(c)) sm++;\n    }\n    return cap - sm;\n}\n\n// Function to find the strongest extension\nstring Strongest_Extension(string class_name, vector<string> extensions) {\n    int max_strength = INT_MIN;\n    string strongest_extension;\n\n    for (const string& ext : extensions) {\n        int strength = calculateStrength(ext);\n        if (strength > max_strength) {\n            max_strength = strength;\n            strongest_extension = ext;\n        }\n    }\n\n    // If there are multiple extensions with the same strength, choose the first one\n    return class_name + \".\" + strongest_extension;\n}\n\n// Function to test the solution\nvoid test() {\n    cout << Strongest_Extension(\"my_class\", {\"AA\", \"Be\", \"CC\"}) << endl; // Expected: my_class.AA\n    cout << Strongest_Extension(\"Slices\", {\"SErviNGSliCes\", \"Cheese\", \"StuFfed\"}) << endl; // Expected: Slices.SErviNGSliCes\n}\n\n"}
{"task_id": "CPP/154", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_rotation(string s1, string s2) {\n    // Check if s2 is a substring of s1 + s1 (concatenated with itself)\n    return (s1.length() == s2.length()) && ((s1 + s1).find(s2) != string::npos);\n}\n\nbool cycpattern_check(string a, string b) {\n    // Check if b or any rotation of b is a substring of a\n    for (int i = 0; i < b.length(); ++i) {\n        string rotated_b = b.substr(i) + b.substr(0, i);\n        if (is_rotation(a, rotated_b)) {\n            return true;\n        }\n    }\n    return false;\n}\n\n"}
{"task_id": "CPP/155", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// Function to count even and odd digits in an integer\nvector<int> even_odd_count(int num) {\n    // Convert the number to a string to easily iterate over each digit\n    string str_num = to_string(abs(num));\n    \n    int even_count = 0;\n    int odd_count = 0;\n    \n    // Iterate through each character in the string\n    for (char c : str_num) {\n        int digit = c - '0';  // Convert char to int\n        if (digit % 2 == 0) {\n            even_count++;\n        } else {\n            odd_count++;\n        }\n    }\n    \n    return {even_count, odd_count};\n}\n\n// Function to test the even_odd_count function with some examples\nvoid test_even_odd_count() {\n    cout << \"Testing even_odd_count:\" << endl;\n    vector<int> result1 = even_odd_count(-12);\n    cout << \"-12: {\" << result1[0] << \", \" << result1[1] << \"} (Expected: {1, 1})\" << endl;\n\n    vector<int> result2 = even_odd_count(123);\n    cout << \"123: {\" << result2[0] << \", \" << result2[1] << \"} (Expected: {1, 2})\" << endl;\n}\n\n"}
{"task_id": "CPP/156", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Mapping of integer values to Roman numerals in lowercase\nconst vector<pair<int, string>> roman_map = {\n    {1000, \"m\"}, {900, \"cm\"}, {500, \"d\"}, {400, \"cd\"},\n    {100, \"c\"}, {90, \"xc\"}, {50, \"l\"}, {40, \"xl\"},\n    {10, \"x\"}, {9, \"ix\"}, {5, \"v\"}, {4, \"iv\"}, {1, \"i\"}\n};\n\nstring int_to_mini_roman(int number) {\n    string roman;\n    for (const auto& value : roman_map) {\n        while (number >= value.first) {\n            roman += value.second;\n            number -= value.first;\n        }\n    }\n    return roman;\n}\n\n"}
{"task_id": "CPP/157", "generation": "#include <stdio.h>\n#include <math.h>\n\nusing namespace std;\n\nbool right_angle_triangle(float a, float b, float c) {\n    // Sort the sides to ensure that 'c' is the longest side (hypotenuse)\n    if (a > c) swap(a, c);\n    if (b > c) swap(b, c);\n\n    // Check if the Pythagorean theorem holds\n    return fabs(a*a + b*b - c*c) < 1e-6; // Using a small tolerance to account for floating point precision issues\n}\n\n"}
{"task_id": "CPP/158", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\n// Function to count unique characters in a string\nint count_unique_chars(const string& word) {\n    bool chars[256] = {false}; // Assuming ASCII characters for simplicity\n    int unique_count = 0;\n    for (char c : word) {\n        if (!chars[c]) {\n            chars[c] = true;\n            unique_count++;\n        }\n    }\n    return unique_count;\n}\n\n// Function to find the string with maximum number of unique characters\nstring find_max(vector<string> words) {\n    // Sort the vector lexicographically first\n    sort(words.begin(), words.end());\n    \n    int max_unique_chars = 0;\n    string result;\n\n    for (const auto& word : words) {\n        int unique_chars = count_unique_chars(word);\n        if (unique_chars > max_unique_chars) {\n            max_unique_chars = unique_chars;\n            result = word;\n        }\n    }\n\n    return result;\n}\n\n// Function to test the find_max function\nvoid test_find_max() {\n    assert(find_max({\"name\", \"of\", \"string\"}) == \"string\");\n    assert(find_max({\"name\", \"enam\", \"game\"}) == \"enam\");\n    assert(find_max({\"aaaaaaa\", \"bb\", \"cc\"}) == \"aaaaaaa\");\n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/159", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nvector<int> eat(int number, int need, int remaining) {\n    // Calculate the minimum between the needed carrots and the available remaining carrots\n    int toEat = min(need, remaining);\n    \n    // Update the total number of eaten carrots\n    int totalEaten = number + toEat;\n    \n    // Update the remaining carrots after eating\n    int leftOver = remaining - toEat;\n    \n    // Return a vector containing the total number of eaten carrots and the remaining carrots\n    return {totalEaten, leftOver};\n}\n\n// Function to test the eat function with provided examples\nvoid check() {\n    printf(\"%d %d\\n\", eat(5, 6, 10)[0], eat(5, 6, 10)[1]); // Expected output: 11 4\n    printf(\"%d %d\\n\", eat(4, 8, 9)[0], eat(4, 8, 9)[1]);   // Expected output: 12 1\n    printf(\"%d %d\\n\", eat(1, 10, 10)[0], eat(1, 10, 10)[1]); // Expected output: 11 0\n    printf(\"%d %d\\n\", eat(2, 11, 5)[0], eat(2, 11, 5)[1]);   // Expected output: 7 0\n}\n\n"}
{"task_id": "CPP/160", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nint do_algebra(vector<string> operatorVec, vector<int> operandVec) {\n    // Construct the algebraic expression string\n    stringstream ss;\n    for (size_t i = 0; i < operatorVec.size(); ++i) {\n        ss << operandVec[i];\n        if (i < operatorVec.size()) {\n            ss << \" \" << operatorVec[i] << \" \";\n        }\n    }\n    ss << operandVec.back();\n\n    // Evaluate the expression\n    int result;\n    eval_expression(ss.str(), result);\n    return result;\n}\n\nvoid eval_expression(const string& expr, int& result) {\n    stack<int> numbers;\n    stack<char> operators;\n\n    for (char ch : expr) {\n        if (isdigit(ch)) {\n            numbers.push(ch - '0');\n        } else if (ch == '+' || ch == '-' || ch == '*' || ch == '/' || ch == '%' || ch == '^') {\n            while (!operators.empty() && precedence(operators.top()) >= precedence(ch)) {\n                int num2 = numbers.top(); numbers.pop();\n                int num1 = numbers.top(); numbers.pop();\n                char op = operators.top(); operators.pop();\n\n                int res;\n                switch (op) {\n                    case '+': res = num1 + num2; break;\n                    case '-': res = num1 - num2; break;\n                    case '*': res = num1 * num2; break;\n                    case '/': res = num1 / num2; break;\n                    case '%': res = num1 % num2; break;\n                    case '^': res = pow(num1, num2); break;\n                }\n                numbers.push(res);\n            }\n            operators.push(ch);\n        }\n    }\n\n    while (!operators.empty()) {\n        int num2 = numbers.top(); numbers.pop();\n        int num1 = numbers.top(); numbers.pop();\n        char op = operators.top(); operators.pop();\n\n        int res;\n        switch (op) {\n            case '+': res = num1 + num2; break;\n            case '-': res = num1 - num2; break;\n            case '*': res = num1 * num2; break;\n            case '/': res = num1 / num2; break;\n            case '%': res = num1 % num2; break;\n            case '^': res = pow(num1, num2); break;\n        }\n        numbers.push(res);\n    }\n\n    result = numbers.top();\n}\n\nint precedence(char op) {\n    if (op == '+' || op == '-') return 1;\n    if (op == '*' || op == '/' || op == '%' || op == '^') return 2;\n    return 0; // For other characters\n}\n\n"}
{"task_id": "CPP/161", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\n// Function to solve the problem as described\nstring solve(string s) {\n    bool hasLetters = false;\n    \n    // Check if there are any letters in the string\n    for (char c : s) {\n        if (isalpha(c)) {\n            hasLetters = true;\n            break;\n        }\n    }\n\n    if (!hasLetters) {\n        // If no letters, reverse the entire string\n        reverse(s.begin(), s.end());\n    } else {\n        // If there are letters, reverse their case\n        for (char &c : s) {\n            if (islower(c)) {\n                c = toupper(c);\n            } else if (isupper(c)) {\n                c = tolower(c);\n            }\n        }\n    }\n\n    return s;\n}\n\n// Function to test the solve function with provided examples\nvoid test() {\n    cout << \"solve(\\\"1234\\\") = \\\"\" << solve(\"1234\") << \"\\\" (Expected: \\\"4321\\\")\" << endl;\n    cout << \"solve(\\\"ab\\\") = \\\"\" << solve(\"ab\") << \"\\\" (Expected: \\\"AB\\\")\" << endl;\n    cout << \"solve(\\\"#a@C\\\") = \\\"\" << solve(\"#a@C\") << \"\\\" (Expected: \\\"#A@c\\\")\" << endl;\n}\n\n"}
{"task_id": "CPP/162", "generation": "#include <iostream>\n#include <string>\n#include <openssl/md5.h>\n\n// Function to convert byte array to hex string\nstd::string bytes_to_hex(const unsigned char* bytes, size_t length) {\n    std::stringstream ss;\n    for (size_t i = 0; i < length; ++i) {\n        ss << std::hex << std::setw(2) << std::setfill('0') << static_cast<int>(bytes[i]);\n    }\n    return ss.str();\n}\n\n// Function to convert string to MD5 hash\nstd::string string_to_md5(const std::string& text) {\n    if (text.empty()) {\n        return \"None\";\n    }\n\n    unsigned char digest[MD5_DIGEST_LENGTH];\n    MD5((unsigned char*)text.c_str(), text.length(), (unsigned char*)&digest);    \n\n    // Convert the hash to a hexadecimal string\n    return bytes_to_hex(digest, MD5_DIGEST_LENGTH);\n}\n\n"}
{"task_id": "CPP/163", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Function to generate even digits between a and b in ascending order\nvector<int> generate_integers(int a, int b) {\n    vector<int> result;\n    \n    // Ensure a is less than or equal to b for simplicity\n    if (a > b) {\n        swap(a, b);\n    }\n    \n    // Iterate through the range [a, b]\n    for (int i = a; i <= b; ++i) {\n        // Extract each digit from the current number\n        while (i > 0) {\n            int digit = i % 10;\n            if (digit % 2 == 0 && digit != 0) { // Check if the digit is even and not zero\n                result.push_back(digit);\n            }\n            i /= 10; // Move to the next digit\n        }\n    }\n    \n    return result;\n}\n\n// Function to print the vector of integers\nvoid print_vector(const vector<int>& vec) {\n    for (int num : vec) {\n        cout << num << \" \";\n    }\n    cout << endl;\n}\n\n// Main function to test the generate_integers function\n"}
{"task_id": "CPP/0", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // For std::sort\n\nbool has_close_elements(std::vector<float> numbers, float threshold) {\n    if (numbers.size() <= 1) return false; // If there are less than two elements, no pairs to check\n    \n    // Sort the vector\n    std::sort(numbers.begin(), numbers.end());\n    \n    // Check adjacent elements for closeness\n    for (size_t i = 0; i < numbers.size() - 1; ++i) {\n        if (numbers[i + 1] - numbers[i] < threshold) {\n            return true;\n        }\n    }\n    \n    return false;\n}\n\n"}
{"task_id": "CPP/1", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> separate_paren_groups(string paren_string) {\n    // Remove all spaces from the input string\n    paren_string.erase(remove_if(paren_string.begin(), paren_string.end(), isspace), paren_string.end());\n\n    vector<string> groups;\n    stack<char> stk;\n    int start = 0;\n\n    for (int i = 0; i < paren_string.length(); ++i) {\n        if (paren_string[i] == '(') {\n            // Push opening parenthesis onto the stack\n            stk.push(paren_string[i]);\n        } else if (paren_string[i] == ')') {\n            // Pop from stack when a closing parenthesis is encountered\n            stk.pop();\n            if (stk.empty()) {\n                // When stack becomes empty, we found a complete group\n                groups.push_back(paren_string.substr(start, i - start + 1));\n                start = i + 1;\n            }\n        }\n    }\n\n    return groups;\n}\n\n"}
{"task_id": "CPP/2", "generation": "#include <stdio.h>\n#include <cmath>  // Include cmath for floor function\n\nusing namespace std;\n\nfloat truncate_number(float number) {\n    float integerPart = floor(number);  // Get the integer part of the number\n    return number - integerPart;        // Subtract the integer part from the original number to get the decimal part\n}\n\n"}
{"task_id": "CPP/3", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool below_zero(vector<int> operations) {\n    int balance = 0; // Start with zero balance\n\n    for (int op : operations) {\n        balance += op; // Update the balance after each operation\n        if (balance < 0) {\n            return true; // Return true if balance falls below zero\n        }\n    }\n\n    return false; // Return false if balance never falls below zero\n}\n\n// Function to test the below_zero function with provided examples\nvoid check() {\n    vector<int> operations1 = {1, 2, 3};\n    vector<int> operations2 = {1, 2, -4, 5};\n\n    cout << \"Test Case 1: \" << (below_zero(operations1) ? \"true\" : \"false\") << endl;\n    cout << \"Test Case 2: \" << (below_zero(operations2) ? \"true\" : \"false\") << endl;\n}\n\n"}
{"task_id": "CPP/4", "generation": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nfloat mean_absolute_deviation(vector<float> numbers) {\n    if (numbers.empty()) {\n        return 0.0; // Return 0 for an empty vector to avoid division by zero.\n    }\n\n    float sum = 0.0;\n    for (const auto& num : numbers) {\n        sum += num;\n    }\n    float mean = sum / numbers.size();\n\n    float mad = 0.0;\n    for (const auto& num : numbers) {\n        mad += abs(num - mean);\n    }\n    mad /= numbers.size();\n\n    return mad;\n}\n\n"}
{"task_id": "CPP/5", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> intersperse(vector<int> numbers, int delimeter) {\n    // Create a new vector to store the result\n    vector<int> result;\n    \n    // Iterate through the input vector\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        // Add the current element from the input vector\n        result.push_back(numbers[i]);\n        \n        // If it's not the last element, add the delimiter\n        if (i != numbers.size() - 1) {\n            result.push_back(delimeter);\n        }\n    }\n    \n    return result;\n}\n\n// Function to print the elements of a vector\nvoid printVector(const vector<int>& vec) {\n    for (int num : vec) {\n        cout << num << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/6", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<int> parse_nested_parens(string paren_string) {\n    vector<int> depths;\n    string current_group = \"\";\n    \n    // Split the input string into groups based on spaces\n    for (char c : paren_string) {\n        if (c == ' ') {\n            if (!current_group.empty()) {\n                int max_depth = 0, current_depth = 0;\n                \n                // Process each group to find the maximum depth of nesting\n                for (char ch : current_group) {\n                    if (ch == '(') {\n                        current_depth++;\n                        max_depth = max(max_depth, current_depth);\n                    } else if (ch == ')') {\n                        current_depth--;\n                    }\n                }\n                \n                depths.push_back(max_depth);\n                current_group.clear();\n            }\n        } else {\n            current_group += c;\n        }\n    }\n\n    // Process the last group\n    if (!current_group.empty()) {\n        int max_depth = 0, current_depth = 0;\n        \n        for (char ch : current_group) {\n            if (ch == '(') {\n                current_depth++;\n                max_depth = max(max_depth, current_depth);\n            } else if (ch == ')') {\n                current_depth--;\n            }\n        }\n        \n        depths.push_back(max_depth);\n    }\n\n    return depths;\n}\n\n"}
{"task_id": "CPP/7", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> filter_by_substring(vector<string> strings, string substring) {\n    vector<string> filteredStrings;\n    \n    // Iterate through each string in the input vector\n    for (const auto& str : strings) {\n        // Check if the current string contains the given substring\n        if (str.find(substring) != string::npos) {\n            filteredStrings.push_back(str);\n        }\n    }\n    \n    return filteredStrings;\n}\n\n// Function to test the filter_by_substring function\nvoid test_filter_by_substring() {\n    vector<string> input1 = {};\n    vector<string> expected1 = {};\n    assert(filter_by_substring(input1, \"a\") == expected1);\n\n    vector<string> input2 = {\"abc\", \"bacd\", \"cde\", \"vector\"};\n    vector<string> expected2 = {\"abc\", \"bacd\", \"vector\"};\n    assert(filter_by_substring(input2, \"a\") == expected2);\n\n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/8", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> sum_product(vector<int> numbers) {\n    int sum = 0;\n    int product = 1;\n\n    // Calculate the sum and product\n    for (int num : numbers) {\n        sum += num;\n        product *= num;\n    }\n\n    return {sum, product};\n}\n\n// Function to test the sum_product function\nvoid test_sum_product() {\n    vector<int> emptyVec;\n    vector<int> result1 = sum_product(emptyVec);\n    cout << \"Empty Vector: Sum = \" << result1[0] << \", Product = \" << result1[1] << endl;\n\n    vector<int> vec1 = {1, 2, 3, 4};\n    vector<int> result2 = sum_product(vec1);\n    cout << \"Vector {1, 2, 3, 4}: Sum = \" << result2[0] << \", Product = \" << result2[1] << endl;\n}\n\n"}
{"task_id": "CPP/9", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> rolling_max(vector<int> numbers) {\n    vector<int> result;\n    if (numbers.empty()) return result; // Return empty vector if input is empty\n\n    int max_so_far = numbers[0]; // Initialize the maximum so far with the first element\n    for (int num : numbers) {\n        if (num > max_so_far) {\n            max_so_far = num;\n        }\n        result.push_back(max_so_far);\n    }\n\n    return result;\n}\n\n// Function to print the vector\nvoid print_vector(const vector<int>& vec) {\n    for (int val : vec) {\n        cout << val << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/10", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_palindrome(const string& str) {\n    // Test if given string is a palindrome\n    return str == string(str.rbegin(), str.rend());\n}\n\nstring make_palindrome(string str) {\n    /*\n    Find the shortest palindrome that begins with a supplied string. \n    Algorithm idea is simple: - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    */\n    \n    // Start from the end of the string and move backwards\n    for (int i = str.length(); i > 0; --i) {\n        if (is_palindrome(str.substr(0, i))) {\n            // Found the longest palindromic prefix\n            break;\n        }\n    }\n\n    // The suffix is from index i to the end of the string\n    string suffix = str.substr(i);\n    \n    // Reverse the prefix and append it to the original string\n    string reversed_prefix = string(suffix.rbegin(), suffix.rend());\n    return str + reversed_prefix;\n}\n\n"}
{"task_id": "CPP/11", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\n// Function to perform binary XOR on two strings\nstring string_xor(string a, string b) {\n    // Ensure both strings are of the same length\n    if (a.length() != b.length()) {\n        cout << \"Input strings must be of equal length.\" << endl;\n        return \"\";\n    }\n\n    string result = \"\";  // Initialize the result string\n\n    // Perform XOR on each bit and append to the result string\n    for (size_t i = 0; i < a.length(); ++i) {\n        if (a[i] == b[i]) {\n            result += '0';  // If bits are the same, append '0'\n        } else {\n            result += '1';  // If bits are different, append '1'\n        }\n    }\n\n    return result;\n}\n\n// Function to test the string_xor function\nvoid test_string_xor() {\n    string a = \"010\";\n    string b = \"110\";\n    string expected = \"100\";\n    string result = string_xor(a, b);\n\n    cout << \"Input: \" << a << \" and \" << b << endl;\n    cout << \"Expected Result: \" << expected << endl;\n    cout << \"Actual Result: \" << result << endl;\n\n    if (result == expected) {\n        cout << \"Test Passed!\" << endl;\n    } else {\n        cout << \"Test Failed!\" << endl;\n    }\n}\n\n"}
{"task_id": "CPP/12", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring longest(vector<string> strings) {\n    if (strings.empty()) {\n        return \"\"; // Return an empty string to indicate None in this context\n    }\n\n    const string* longestString = &strings[0];\n    for (const auto& str : strings) {\n        if (str.length() > longestString->length()) {\n            longestString = &str;\n        }\n    }\n\n    return *longestString;\n}\n\n"}
{"task_id": "CPP/13", "generation": "#include <stdio.h>\nusing namespace std;\n\nint greatest_common_divisor(int a, int b) {\n    // Ensure a >= b by swapping if necessary\n    if (a < b) {\n        swap(a, b);\n    }\n\n    // Use Euclidean algorithm to find GCD\n    while (b != 0) {\n        int temp = b;\n        b = a % b;\n        a = temp;\n    }\n\n    return a; // The GCD is now in 'a'\n}\n\n"}
{"task_id": "CPP/14", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to generate all prefixes of the input string\nvector<string> all_prefixes(string str) {\n    vector<string> prefixes;\n    for (size_t i = 1; i <= str.length(); ++i) {\n        prefixes.push_back(str.substr(0, i));\n    }\n    return prefixes;\n}\n\n"}
{"task_id": "CPP/15", "generation": "#include <iostream>\n#include <sstream>\n#include <string>\nusing namespace std;\n\nstring string_sequence(int n) {\n    stringstream ss;\n    for (int i = 0; i <= n; ++i) {\n        ss << i;\n        if (i < n) {\n            ss << \" \";\n        }\n    }\n    return ss.str();\n}\n\n// Function to test the string_sequence function\nvoid test_string_sequence() {\n    cout << \"Testing string_sequence...\" << endl;\n    assert(string_sequence(0) == \"0\");\n    assert(string_sequence(5) == \"0 1 2 3 4 5\");\n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/16", "generation": "#include <iostream>\n#include <string>\n#include <set>\n\nusing namespace std;\n\nint count_distinct_characters(string str) {\n    // Convert string to lowercase for case-insensitive comparison\n    transform(str.begin(), str.end(), str.begin(), ::tolower);\n\n    // Use a set to store distinct characters\n    set<char> distinct_chars;\n\n    // Iterate through the string and add each character to the set\n    for (char c : str) {\n        distinct_chars.insert(c);\n    }\n\n    // The size of the set is the number of distinct characters\n    return distinct_chars.size();\n}\n\n"}
{"task_id": "CPP/17", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<int> parse_music(string music_string) {\n    vector<int> durations;\n    \n    // Iterate through the string and process each character\n    for (size_t i = 0; i < music_string.length(); ) {\n        if (music_string[i] == 'o') {\n            // Whole note: lasts four beats\n            durations.push_back(4);\n            i += 1; // Move to the next character\n        } else if (music_string[i] == 'o' && music_string[i + 1] == '|') {\n            // Half note: lasts two beats\n            durations.push_back(2);\n            i += 2; // Skip the next character as well\n        } else if (music_string[i] == '.' && music_string[i + 1] == '|') {\n            // Quarter note: lasts one beat\n            durations.push_back(1);\n            i += 2; // Skip the next character as well\n        }\n    }\n\n    return durations;\n}\n\n// Function to test the parse_music function\nvoid test_parse_music() {\n    string input = \"o o| .| o| o| .| .| .| .| o o\";\n    vector<int> expected_output = {4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4};\n    \n    vector<int> output = parse_music(input);\n    \n    if (output == expected_output) {\n        printf(\"Test passed!\\n\");\n    } else {\n        printf(\"Test failed.\\n\");\n    }\n}\n\n"}
{"task_id": "CPP/18", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint how_many_times(const string& str, const string& substring) {\n    if (substring.empty()) return 0;\n    \n    int count = 0;\n    size_t pos = 0;\n    \n    while ((pos = str.find(substring, pos)) != string::npos) {\n        ++count;\n        pos++; // Move to the next character after the found substring\n    }\n    \n    return count;\n}\n\n"}
{"task_id": "CPP/19", "generation": "#include <iostream>\n#include <string>\n#include <map>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to map word to number\nint word_to_number(const string& word) {\n    map<string, int> num_map = {{\"zero\", 0}, {\"one\", 1}, {\"two\", 2}, {\"three\", 3},\n                                {\"four\", 4}, {\"five\", 5}, {\"six\", 6}, {\"seven\", 7},\n                                {\"eight\", 8}, {\"nine\", 9}};\n    return num_map[word];\n}\n\n// Function to sort the numbers\nstring sort_numbers(const string& input) {\n    vector<string> words;\n    string current_word = \"\";\n    \n    // Split the input into words\n    for (char ch : input) {\n        if (ch == ' ') {\n            if (!current_word.empty()) {\n                words.push_back(current_word);\n                current_word.clear();\n            }\n        } else {\n            current_word += ch;\n        }\n    }\n    if (!current_word.empty()) {\n        words.push_back(current_word);\n    }\n\n    // Sort the words based on their numerical value\n    sort(words.begin(), words.end(), [](const string& a, const string& b) {\n        return word_to_number(a) < word_to_number(b);\n    });\n\n    // Join the sorted words back into a single string\n    string result;\n    for (const auto& word : words) {\n        if (!result.empty()) {\n            result += \" \";\n        }\n        result += word;\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/20", "generation": "#include <iostream>\n#include <cmath>\n#include <vector>\n\nusing namespace std;\n\npair<float, float> find_closest_elements(vector<float> numbers) {\n    if (numbers.size() < 2) {\n        throw invalid_argument(\"The vector must contain at least two elements.\");\n    }\n\n    // Initialize the first pair of closest elements\n    float min_diff = abs(numbers[1] - numbers[0]);\n    float closest_pair[2] = {numbers[0], numbers[1]};\n    \n    // Iterate through the vector starting from the second element\n    for (size_t i = 1; i < numbers.size() - 1; ++i) {\n        float current_diff = abs(numbers[i + 1] - numbers[i]);\n        \n        if (current_diff < min_diff) {\n            min_diff = current_diff;\n            closest_pair[0] = min(numbers[i], numbers[i + 1]);\n            closest_pair[1] = max(numbers[i], numbers[i + 1]);\n        }\n    }\n\n    return {closest_pair[0], closest_pair[1]};\n}\n\n"}
{"task_id": "CPP/21", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // For std::min_element and std::max_element\n\nusing namespace std;\n\nvector<float> rescale_to_unit(vector<float> numbers) {\n    if (numbers.size() < 2) {\n        throw invalid_argument(\"Vector must contain at least two elements.\");\n    }\n\n    float min_value = *std::min_element(numbers.begin(), numbers.end());\n    float max_value = *std::max_element(numbers.begin(), numbers.end());\n\n    vector<float> scaled_numbers;\n    for (float num : numbers) {\n        float new_value = (num - min_value) / (max_value - min_value);\n        scaled_numbers.push_back(new_value);\n    }\n\n    return scaled_numbers;\n}\n\n"}
{"task_id": "CPP/22", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <boost/any.hpp>\n\ntypedef std::list<boost::any> list_any;\nusing namespace std;\n\n// Function to filter out only integer values from the given list of boost::any\nvector<int> filter_integers(list_any values) {\n    vector<int> integers;\n    \n    for (const auto& value : values) {\n        if (value.type() == typeid(int)) {\n            integers.push_back(boost::any_cast<int>(value));\n        }\n    }\n    \n    return integers;\n}\n\n"}
{"task_id": "CPP/23", "generation": "#include <iostream>\nusing namespace std;\n\nint strlen(string str) {\n    int length = 0;\n    for (char ch : str) {\n        length++;\n    }\n    return length;\n}\n\n// Function to test the strlen function with some examples\nvoid test_strlen() {\n    cout << \"Length of \\\"\\\" is: \" << strlen(\"\") << endl; // Should output 0\n    cout << \"Length of \\\"abc\\\" is: \" << strlen(\"abc\") << endl; // Should output 3\n    cout << \"Length of \\\"hello world\\\" is: \" << strlen(\"hello world\") << endl; // Should output 11\n}\n\n"}
{"task_id": "CPP/24", "generation": "#include <iostream>\nusing namespace std;\n\nint largest_divisor(int n) {\n    for (int i = n - 1; i > 0; --i) {\n        if (n % i == 0) {\n            return i;\n        }\n    }\n    // If no divisor is found, which should not happen for positive integers,\n    // we can return a default value like 1.\n    return 1;\n}\n\n"}
{"task_id": "CPP/25", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> factorize(int n) {\n    vector<int> factors;\n    \n    // Check for number of 2s that divide n\n    while (n % 2 == 0) {\n        factors.push_back(2);\n        n = n / 2;\n    }\n    \n    // n must be odd at this point, so we can skip one element (Note i = i + 2)\n    for (int i = 3; i * i <= n; i += 2) {\n        // While i divides n, add i and divide n\n        while (n % i == 0) {\n            factors.push_back(i);\n            n = n / i;\n        }\n    }\n    \n    // This condition is to handle the case when n is a prime number greater than 2\n    if (n > 2) {\n        factors.push_back(n);\n    }\n    \n    return factors;\n}\n\n// Example usage:\n"}
{"task_id": "CPP/26", "generation": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nvector<int> remove_duplicates(vector<int> numbers) {\n    // Create a map to count occurrences of each number\n    unordered_map<int, int> counts;\n    \n    // Count the occurrences of each element in the vector\n    for (int num : numbers) {\n        counts[num]++;\n    }\n    \n    // Reserve space in the result vector to improve performance\n    vector<int> result;\n    result.reserve(numbers.size());\n    \n    // Iterate through the original vector and add elements that occur only once\n    for (int num : numbers) {\n        if (counts[num] == 1) {\n            result.push_back(num);\n        }\n    }\n    \n    return result;\n}\n\n// Function to check the correctness of the remove_duplicates function\nvoid check() {\n    vector<int> input = {1, 2, 3, 2, 4};\n    vector<int> expected_output = {1, 3, 4};\n    vector<int> output = remove_duplicates(input);\n    \n    if (output == expected_output) {\n        cout << \"Test passed.\" << endl;\n    } else {\n        cout << \"Test failed.\" << endl;\n    }\n}\n\n"}
{"task_id": "CPP/27", "generation": "#include <iostream>\n#include <string>\n#include <cctype>  // For std::isupper, std::tolower, and std::toupper\n\nusing namespace std;\n\nstring flip_case(string str) {\n    for (char &c : str) {\n        if (std::isupper(c)) {\n            c = std::tolower(c);\n        } else if (std::islower(c)) {\n            c = std::toupper(c);\n        }\n    }\n    return str;\n}\n\n"}
{"task_id": "CPP/28", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <numeric> // For std::accumulate\n\nusing namespace std;\n\nstring concatenate(vector<string> strings) {\n    return accumulate(strings.begin(), strings.end(), string(\"\"));\n}\n\n"}
{"task_id": "CPP/29", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to filter strings by prefix\nvector<string> filter_by_prefix(vector<string> strings, string prefix) {\n    vector<string> filteredStrings;\n    \n    // Iterate through each string in the input vector\n    for (const auto& str : strings) {\n        // Check if the string starts with the given prefix\n        if (str.substr(0, prefix.length()) == prefix) {\n            filteredStrings.push_back(str);\n        }\n    }\n    \n    return filteredStrings;\n}\n\n// Function to test the filter_by_prefix function\nvoid test_filter_by_prefix() {\n    vector<string> input1 = {};\n    string prefix1 = \"a\";\n    vector<string> expected1 = {};\n    assert(filter_by_prefix(input1, prefix1) == expected1);\n\n    vector<string> input2 = {\"abc\", \"bcd\", \"cde\", \"vector\"};\n    string prefix2 = \"a\";\n    vector<string> expected2 = {\"abc\", \"vector\"};\n    assert(filter_by_prefix(input2, prefix2) == expected2);\n\n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/30", "generation": "#include <iostream>\n#include <vector>\n\n// Function to return only positive numbers in the vector.\nstd::vector<float> get_positive(const std::vector<float>& l) {\n    std::vector<float> result;\n    for (const auto& num : l) {\n        if (num > 0) {\n            result.push_back(num);\n        }\n    }\n    return result;\n}\n\n// Function to print the vector\nvoid print_vector(const std::vector<float>& vec) {\n    for (const auto& num : vec) {\n        std::cout << num << \" \";\n    }\n    std::cout << std::endl;\n}\n\n"}
{"task_id": "CPP/31", "generation": "#include <iostream>\nusing namespace std;\n\nbool is_prime(long long n) {\n    // Handle edge cases\n    if (n <= 1) return false;\n    if (n == 2 || n == 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n\n    // Check for factors from 5 to the square root of n\n    for (long long i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0)\n            return false;\n    }\n\n    return true;\n}\n\n"}
{"task_id": "CPP/32", "generation": "#include <iostream>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\ndouble poly(vector<double> xs, double x) {\n    /*\n    Evaluates polynomial with coefficients xs at point x.\n    */\n    double sum = 0;\n    int i;\n    for (i = 0; i < xs.size(); i++) {\n        sum += xs[i] * pow(x, i);\n    }\n    return sum;\n}\n\ndouble find_zero(vector<double> xs) {\n    /*\n    Find a root of the polynomial defined by coefficients in xs.\n    Assumes that there is at least one real root and uses bisection method to find it.\n    */\n    \n    // Check if the polynomial has an even number of non-zero terms\n    int degree = 0;\n    for (auto coeff : xs) {\n        if (coeff != 0) {\n            degree++;\n        }\n    }\n    \n    if (degree % 2 == 1 || degree == 0) {\n        throw runtime_error(\"The polynomial does not have an even number of non-zero terms or is constant.\");\n    }\n\n    // Bisection method\n    double a = -10.0;  // Lower bound for the root search interval\n    double b = 10.0;   // Upper bound for the root search interval\n\n    while (b - a > 1e-6) {  // Tolerance for convergence\n        double c = (a + b) / 2;\n        if (poly(xs, c) == 0) {\n            return c;  // Exact root found\n        } else if (poly(xs, a) * poly(xs, c) < 0) {\n            b = c;  // Root is in the left half\n        } else {\n            a = c;  // Root is in the right half\n        }\n    }\n\n    return (a + b) / 2;  // Return the midpoint as the root approximation\n}\n\n"}
{"task_id": "CPP/33", "generation": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> sort_third(vector<int> l) {\n    vector<int> third_indices;\n    \n    // Extract elements at indices divisible by three\n    for (size_t i = 2; i < l.size(); i += 3) {\n        third_indices.push_back(l[i]);\n    }\n    \n    // Sort the extracted elements\n    sort(third_indices.begin(), third_indices.end());\n    \n    // Replace original values with sorted ones at indices divisible by three\n    for (size_t i = 2, j = 0; i < l.size() && j < third_indices.size(); i += 3, ++j) {\n        l[i] = third_indices[j];\n    }\n    \n    return l;\n}\n\n// Function to test the sort_third function\nvoid test_sort_third() {\n    vector<int> v1 = {1, 2, 3};\n    vector<int> expected1 = {1, 2, 3};\n    assert(sort_third(v1) == expected1);\n\n    vector<int> v2 = {5, 6, 3, 4, 8, 9, 2};\n    vector<int> expected2 = {2, 6, 3, 4, 8, 9, 5};\n    assert(sort_third(v2) == expected2);\n\n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/34", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> unique(vector<int> l) {\n    // Remove duplicates and get the new end iterator\n    auto new_end = unique(l.begin(), l.end());\n    \n    // Resize the vector to remove unused elements\n    l.resize(distance(l.begin(), new_end));\n    \n    // Sort the vector\n    sort(l.begin(), l.end());\n    \n    return l;\n}\n\n"}
{"task_id": "CPP/35", "generation": "#include <iostream>\n#include <vector>\n\nfloat max_element(const std::vector<float>& l) {\n    if (l.empty()) {\n        throw std::invalid_argument(\"Vector is empty\");\n    }\n\n    float max_val = l[0];\n    for (size_t i = 1; i < l.size(); ++i) {\n        if (l[i] > max_val) {\n            max_val = l[i];\n        }\n    }\n    return max_val;\n}\n\n"}
{"task_id": "CPP/36", "generation": "#include <iostream>\nusing namespace std;\n\nint fizz_buzz(int n) {\n    int count = 0;\n    \n    for (int i = 1; i < n; ++i) {\n        if (i % 11 == 0 || i % 13 == 0) {\n            // Convert the number to a string and count occurrences of '7'\n            string num_str = to_string(i);\n            for (char c : num_str) {\n                if (c == '7') {\n                    ++count;\n                }\n            }\n        }\n    }\n    \n    return count;\n}\n\n"}
{"task_id": "CPP/37", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<float> sort_even(vector<float> l) {\n    // Extract even-indexed elements (considering 0-based indexing)\n    vector<float> evens;\n    for (size_t i = 1; i < l.size(); i += 2) {\n        evens.push_back(l[i]);\n    }\n\n    // Sort the extracted even-indexed elements\n    sort(evens.begin(), evens.end());\n\n    // Reconstruct the vector with sorted even-indexed elements and original odd-indexed elements\n    size_t evenIndex = 0;\n    for (size_t i = 1; i < l.size(); i += 2) {\n        l[i] = evens[evenIndex++];\n    }\n\n    return l;\n}\n\n// Function to check the correctness of the sort_even function\nvoid check() {\n    vector<float> test1 = {1, 2, 3};\n    vector<float> expected1 = {1, 2, 3};\n    assert(sort_even(test1) == expected1);\n\n    vector<float> test2 = {5, 6, 3, 4};\n    vector<float> expected2 = {3, 6, 5, 4};\n    assert(sort_even(test2) == expected2);\n\n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/38", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring encode_cyclic(string s) { \n    // returns encoded string by cycling groups of three characters.  \n    int l = s.length();\n    int num = (l + 2) / 3;\n    string x, output;\n    for (int i = 0; i * 3 < l; i++) {\n        x = s.substr(i * 3, 3);\n        if (x.length() == 3) x = x.substr(1) + x[0];\n        output += x;\n    }\n    return output;\n}\n\nstring decode_cyclic(string s) { \n    // takes as input string encoded with encode_cyclic function. Returns decoded string.\n    int l = s.length();\n    int num = (l + 2) / 3;\n    string x, output;\n    for (int i = 0; i * 3 < l; i++) {\n        x = s.substr(i * 3, 3);\n        if (x.length() == 3) x = x[2] + x.substr(0, 2); // Move the first character to the end\n        output += x;\n    }\n    return output;\n}\n\n"}
{"task_id": "CPP/39", "generation": "#include <iostream>\nusing namespace std;\n\n// Helper function to check if a number is prime\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    if (num == 2 || num == 3) return true;\n    if (num % 2 == 0 || num % 3 == 0) return false;\n    for (int i = 5; i * i <= num; i += 6) {\n        if (num % i == 0 || num % (i + 2) == 0)\n            return false;\n    }\n    return true;\n}\n\n// Function to find the n-th Fibonacci number that is also prime\nint prime_fib(int n) {\n    int count = 0; // Counter for prime Fibonacci numbers found\n    long fib1 = 0, fib2 = 1; // First two Fibonacci numbers\n\n    while (true) {\n        long next_fib = fib1 + fib2;\n        fib1 = fib2;\n        fib2 = next_fib;\n\n        if (is_prime(fib2)) {\n            count++;\n            if (count == n) return fib2;\n        }\n    }\n}\n\n"}
{"task_id": "CPP/40", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool triples_sum_to_zero(vector<int> l) {\n    // First, sort the array to facilitate the two-pointer approach.\n    sort(l.begin(), l.end());\n    \n    int n = l.size();\n    \n    for (int i = 0; i < n - 2; ++i) {\n        // Skip duplicate elements to avoid redundant checks\n        if (i > 0 && l[i] == l[i-1]) continue;\n        \n        int left = i + 1, right = n - 1;\n        \n        while (left < right) {\n            int sum = l[i] + l[left] + l[right];\n            \n            if (sum == 0) {\n                return true; // Found a triplet that sums to zero\n            } else if (sum < 0) {\n                ++left; // Need a larger number, move the left pointer to right\n            } else {\n                --right; // Need a smaller number, move the right pointer to left\n            }\n        }\n    }\n    \n    return false; // No triplet found that sums to zero\n}\n\n"}
{"task_id": "CPP/41", "generation": "#include <iostream>\nusing namespace std;\n\nint car_race_collision(int n) {\n    // Each car moving left to right will collide with one car moving right to left.\n    return n;\n}\n\n"}
{"task_id": "CPP/42", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> incr_vector(vector<int> l) {\n    for (int &i : l) {\n        i += 1;\n    }\n    return l;\n}\n\n// Function to print the elements of the vector\nvoid print_vector(const vector<int>& v) {\n    for (const int& elem : v) {\n        cout << elem << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/43", "generation": "#include <iostream>\n#include <vector>\n#include <set>\n\nusing namespace std;\n\nbool pairs_sum_to_zero(vector<int> l) {\n    // Use a set to store seen numbers\n    set<int> seen;\n    \n    for (int num : l) {\n        // Check if the negation of the current number is in the set\n        if (seen.find(-num) != seen.end()) {\n            return true;  // Found a pair that sums to zero\n        }\n        // Add the current number to the set\n        seen.insert(num);\n    }\n    \n    return false;  // No such pair found\n}\n\n// Function to test the pairs_sum_to_zero function with provided examples\nvoid test_pairs_sum_to_zero() {\n    assert(pairs_sum_to_zero({1, 3, 5, 0}) == false);\n    assert(pairs_sum_to_zero({1, 3, -2, 1}) == false);\n    assert(pairs_sum_to_zero({1, 2, 3, 7}) == false);\n    assert(pairs_sum_to_zero({2, 4, -5, 3, 5, 7}) == true);\n    assert(pairs_sum_to_zero({1}) == false);\n\n    cout << \"All test cases passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/44", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring change_base(int x, int base) {\n    if (base >= 10 || base <= 1) {\n        throw invalid_argument(\"Base must be between 2 and 9.\");\n    }\n    \n    string result = \"\";\n    while (x > 0) {\n        int remainder = x % base;\n        result = to_string(remainder) + result;\n        x /= base;\n    }\n    \n    return result.empty() ? \"0\" : result;\n}\n\n"}
{"task_id": "CPP/45", "generation": "#include <stdio.h>\nusing namespace std;\n\nfloat triangle_area(float a, float h) {\n    return 0.5 * a * h;\n}\n\n"}
{"task_id": "CPP/46", "generation": "#include <iostream>\nusing namespace std;\n\nint fib4(int n) {\n    if (n == 0 || n == 1 || n == 2) return n == 2 ? 2 : 0;\n    if (n == 3) return 0;\n\n    int a = 0, b = 0, c = 2, d = 0; // Initialize the first four values\n    for (int i = 4; i <= n; ++i) {\n        int next = a + b + c + d;\n        a = b;\n        b = c;\n        c = d;\n        d = next;\n    }\n    return d;\n}\n\n"}
{"task_id": "CPP/47", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nfloat median(vector<float> l) {\n    // Sort the vector in ascending order\n    sort(l.begin(), l.end());\n    \n    int n = l.size();\n    \n    // Check if the number of elements is odd or even\n    if (n % 2 == 1) {\n        // If odd, return the middle element\n        return l[n / 2];\n    } else {\n        // If even, return the average of the two middle elements\n        float mid1 = l[(n - 1) / 2];\n        float mid2 = l[n / 2];\n        return (mid1 + mid2) / 2.0;\n    }\n}\n\n"}
{"task_id": "CPP/48", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_palindrome(string text) {\n    int left = 0; // Start index\n    int right = text.length() - 1; // End index\n\n    while (left < right) {\n        if (text[left] != text[right]) {\n            return false; // Characters do not match, it's not a palindrome\n        }\n        left++; // Move the start index to the right\n        right--; // Move the end index to the left\n    }\n\n    return true; // All characters matched, it is a palindrome\n}\n\n"}
{"task_id": "CPP/49", "generation": "#include <stdio.h>\nusing namespace std;\n\nint modp(int n, int p) {\n    if (n == 0) return 1; // Base case: 2^0 = 1\n\n    int result = 1;\n    long long base = 2;\n\n    while (n > 0) {\n        if (n % 2 == 1) { // If n is odd, multiply the result by the current base\n            result = (result * base) % p;\n        }\n        base = (base * base) % p; // Square the base and reduce modulo p\n        n /= 2; // Divide n by 2\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/50", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nstring encode_shift(string s) {\n    // returns encoded string by shifting every character by 5 in the alphabet.\n    string out;\n    int i;\n    for (i = 0; i < s.length(); i++) {\n        int w = ((int)s[i] + 5 - (int)'a') % 26 + (int)'a';\n        out += (char)w;\n    }\n    return out;\n}\n\nstring decode_shift(string s) {\n    // takes as input string encoded with encode_shift function. Returns decoded string.\n    string out;\n    int i;\n    for (i = 0; i < s.length(); i++) {\n        int w = ((int)s[i] - 5 - (int)'a') % 26 + (int)'a';\n        out += (char)w;\n    }\n    return out;\n}\n\n"}
{"task_id": "CPP/51", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring remove_vowels(string text) {\n    // Define vowels as a string for easy checking\n    const string vowels = \"aeiouAEIOU\";\n    \n    // Create an empty string to store the result\n    string result;\n    \n    // Iterate through each character in the input string\n    for (char ch : text) {\n        // Check if the character is not a vowel\n        if (vowels.find(ch) == string::npos) {\n            // If it's not a vowel, add it to the result string\n            result += ch;\n        }\n    }\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/52", "generation": "#include <vector>\n#include <iostream>\n\n// Function to check if all elements in the vector are below the threshold\nbool below_threshold(const std::vector<int>& l, int t) {\n    for (int num : l) {\n        if (num >= t) {\n            return false;\n        }\n    }\n    return true;\n}\n\n// Example usage and test cases\n"}
{"task_id": "CPP/53", "generation": "#include <stdio.h>\n\n// Function to add two numbers\nint add(int x, int y) {\n    return x + y;\n}\n\n"}
{"task_id": "CPP/54", "generation": "#include <iostream>\n#include <string>\n#include <set>\n\nusing namespace std;\n\nbool same_chars(string s0, string s1) {\n    // Create a set to store unique characters from the first string\n    set<char> chars_s0(s0.begin(), s0.end());\n    \n    // Create a set to store unique characters from the second string\n    set<char> chars_s1(s1.begin(), s1.end());\n    \n    // Compare the two sets\n    return chars_s0 == chars_s1;\n}\n\n"}
{"task_id": "CPP/55", "generation": "#include <iostream>\nusing namespace std;\n\nint fib(int n) {\n    if (n <= 0) {\n        return 0;\n    } else if (n == 1) {\n        return 1;\n    } else {\n        int a = 0, b = 1, c;\n        for (int i = 2; i <= n; ++i) {\n            c = a + b;\n            a = b;\n            b = c;\n        }\n        return b;\n    }\n}\n\n"}
{"task_id": "CPP/56", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    int balance = 0;\n    \n    for (char bracket : brackets) {\n        if (bracket == '<') {\n            balance++;\n        } else if (bracket == '>') {\n            balance--;\n        }\n        \n        // If at any point the balance is negative, it means there's a closing bracket without an opening one\n        if (balance < 0) {\n            return false;\n        }\n    }\n    \n    // The string is correct if the balance is zero at the end\n    return balance == 0;\n}\n\n"}
{"task_id": "CPP/57", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool monotonic(vector<float> l) {\n    // Check if the vector is empty or has only one element\n    if (l.size() <= 1) return true;\n\n    // Determine the direction based on the first two elements\n    bool increasing = (l[1] >= l[0]);\n\n    for (size_t i = 1; i < l.size(); ++i) {\n        if (increasing && l[i] < l[i - 1]) {\n            return false;\n        } else if (!increasing && l[i] > l[i - 1]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\n"}
{"task_id": "CPP/58", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // for std::sort\n#include <set>       // for std::set_intersection\n\nusing namespace std;\n\n// Function to find sorted unique common elements in two vectors\nvector<int> common(vector<int> l1, vector<int> l2) {\n    set<int> set1(l1.begin(), l1.end()); // Convert first vector to a set\n    set<int> set2(l2.begin(), l2.end()); // Convert second vector to a set\n\n    vector<int> result;\n    set_intersection(set1.begin(), set1.end(), set2.begin(), set2.end(), back_inserter(result)); // Find intersection\n\n    sort(result.begin(), result.end()); // Sort the result\n    return result; // Return the sorted unique common elements\n}\n\n// Function to print a vector\nvoid printVector(const vector<int>& vec) {\n    for (int num : vec) {\n        cout << num << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/59", "generation": "#include <iostream>\nusing namespace std;\n\nint largest_prime_factor(int n) {\n    int max_prime = -1;\n    \n    // Divide n by 2 to remove all even factors\n    while (n % 2 == 0) {\n        max_prime = 2;\n        n /= 2;\n    }\n    \n    // Now n must be odd, start from 3 and check for factors\n    for (int i = 3; i * i <= n; i += 2) {\n        while (n % i == 0) {\n            max_prime = i;\n            n = n / i;\n        }\n    }\n    \n    // If n is a prime number greater than 2\n    if (n > 2)\n        max_prime = n;\n    \n    return max_prime;\n}\n\n"}
{"task_id": "CPP/60", "generation": "#include <iostream>\nusing namespace std;\n\nint sum_to_n(int n) {\n    return (n * (n + 1)) / 2;\n}\n\n"}
{"task_id": "CPP/61", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    int balance = 0;\n    for (char c : brackets) {\n        if (c == '(') {\n            ++balance;\n        } else if (c == ')') {\n            --balance;\n        }\n        // If at any point the balance is negative, it means there's a closing parenthesis without an opening one\n        if (balance < 0) {\n            return false;\n        }\n    }\n    // If balance is zero, all parentheses are correctly matched\n    return balance == 0;\n}\n\n"}
{"task_id": "CPP/62", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// Function to calculate the derivative of a polynomial\nvector<float> derivative(vector<float> xs) {\n    vector<float> result;\n    for (size_t i = 1; i < xs.size(); ++i) {\n        // Multiply each coefficient by its degree and add it to the result\n        result.push_back(xs[i] * i);\n    }\n    return result;\n}\n\n// Function to print the polynomial coefficients\nvoid printPolynomial(const vector<float>& coeffs) {\n    for (size_t i = 0; i < coeffs.size(); ++i) {\n        cout << coeffs[i];\n        if (i != coeffs.size() - 1) {\n            cout << \" * x^\" << i;\n        }\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/63", "generation": "#include <iostream>\nusing namespace std;\n\nint fibfib(int n) {\n    if (n == 0 || n == 1) return 0;\n    if (n == 2) return 1;\n\n    int a = 0, b = 0, c = 1, d;\n    for (int i = 3; i <= n; ++i) {\n        d = a + b + c;\n        a = b;\n        b = c;\n        c = d;\n    }\n    return d;\n}\n\n"}
{"task_id": "CPP/64", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint vowels_count(string s) {\n    int count = 0;\n    \n    // Convert the string to lowercase for easier comparison\n    transform(s.begin(), s.end(), s.begin(), ::tolower);\n    \n    // Check each character in the string\n    for (size_t i = 0; i < s.length(); ++i) {\n        char c = s[i];\n        \n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n            count++;\n        } else if (c == 'y' && i == s.length() - 1) {\n            count++;\n        }\n    }\n    \n    return count;\n}\n\n"}
{"task_id": "CPP/65", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nstring circular_shift(int x, int shift) {\n    // Convert the integer to a string\n    string num_str = to_string(x);\n    \n    // Get the length of the number\n    size_t len = num_str.length();\n    \n    // If shift is greater than or equal to the number of digits, reverse the string\n    if (shift >= len) {\n        reverse(num_str.begin(), num_str.end());\n    } else {\n        // Perform circular right shift\n        int effective_shift = shift % len;\n        string shifted_part = num_str.substr(len - effective_shift);\n        string remaining_part = num_str.substr(0, len - effective_shift);\n        \n        num_str = shifted_part + remaining_part;\n    }\n    \n    return num_str;\n}\n\n// Function to test the circular_shift function\nvoid test_circular_shift() {\n    cout << \"Testing circular_shift:\" << endl;\n    cout << \"circular_shift(1234, 2): \" << circular_shift(1234, 2) << \" (Expected: 3412)\" << endl;\n    cout << \"circular_shift(1234, 5): \" << circular_shift(1234, 5) << \" (Expected: 4321)\" << endl;\n}\n\n"}
{"task_id": "CPP/66", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint digitSum(string s) {\n    int sum = 0;\n    for (char c : s) {\n        if (isupper(c)) { // Check if the character is uppercase\n            sum += static_cast<int>(c); // Add ASCII value of the character to the sum\n        }\n    }\n    return sum;\n}\n\n// Function to test the digitSum function with provided examples\nvoid check() {\n    cout << \"digitSum(\\\"\\\") => \" << digitSum(\"\") << endl; // Expected output: 0\n    cout << \"digitSum(\\\"abAB\\\") => \" << digitSum(\"abAB\") << endl; // Expected output: 131\n    cout << \"digitSum(\\\"abcCd\\\") => \" << digitSum(\"abcCd\") << endl; // Expected output: 67\n    cout << \"digitSum(\\\"helloE\\\") => \" << digitSum(\"helloE\") << endl; // Expected output: 69\n    cout << \"digitSum(\\\"woArBld\\\") => \" << digitSum(\"woArBld\") << endl; // Expected output: 131\n    cout << \"digitSum(\\\"aAaaaXa\\\") => \" << digitSum(\"aAaaaXa\") << endl; // Expected output: 153\n}\n\n"}
{"task_id": "CPP/67", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint fruit_distribution(string s, int n) {\n    // Find the positions of 'apples' and 'oranges'\n    size_t apples_pos = s.find(\"apples\");\n    size_t oranges_pos = s.find(\"oranges\");\n\n    // Extract the number before 'apples'\n    string apple_count_str = s.substr(0, apples_pos);\n    int apple_count = stoi(apple_count_str);\n\n    // Extract the number after 'and' and before 'oranges'\n    string orange_count_str = s.substr(apples_pos + 8, oranges_pos - (apples_pos + 8));\n    int orange_count = stoi(orange_count_str);\n\n    // Calculate the number of mangoes\n    int mango_count = n - apple_count - orange_count;\n    return mango_count;\n}\n\n"}
{"task_id": "CPP/68", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> pluck(vector<int> arr) {\n    // Check if the array is empty\n    if (arr.empty()) {\n        return {};\n    }\n\n    int smallestEvenValue = -1;\n    int smallestIndex = -1;\n\n    for (int i = 0; i < arr.size(); ++i) {\n        if (arr[i] % 2 == 0) { // Check if the value is even\n            if (smallestEvenValue == -1 || arr[i] < smallestEvenValue) {\n                smallestEvenValue = arr[i];\n                smallestIndex = i;\n            } else if (arr[i] == smallestEvenValue && i < smallestIndex) {\n                // If there are multiple nodes with the same smallest even value, choose the one with the smallest index\n                smallestIndex = i;\n            }\n        }\n    }\n\n    // If no even values were found, return an empty vector\n    if (smallestEvenValue == -1) {\n        return {};\n    } else {\n        return {smallestEvenValue, smallestIndex};\n    }\n}\n\n"}
{"task_id": "CPP/69", "generation": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nint search(vector<int> lst) {\n    // Create a map to store the frequency of each integer in the vector\n    unordered_map<int, int> freqMap;\n    \n    // Count the frequency of each integer\n    for (int num : lst) {\n        freqMap[num]++;\n    }\n    \n    // Initialize the result with -1, assuming no such value exists\n    int result = -1;\n    \n    // Iterate through the map to find the greatest integer meeting the condition\n    for (const auto& pair : freqMap) {\n        if (pair.second >= pair.first && pair.first > result) {\n            result = pair.first;\n        }\n    }\n    \n    return result;\n}\n\n// Function to test the search function with provided examples\nvoid test() {\n    assert(search({4, 1, 2, 2, 3, 1}) == 2);\n    assert(search({1, 2, 2, 3, 3, 3, 4, 4, 4}) == 3);\n    assert(search({5, 5, 4, 4, 4}) == -1);\n    \n    cout << \"All tests passed.\" << endl;\n}\n\n"}
{"task_id": "CPP/70", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> strange_sort_list(vector<int> lst) {\n    // Sort the input list in ascending order\n    sort(lst.begin(), lst.end());\n    \n    vector<int> result;\n    int start = 0;  // Pointer to the beginning of the sorted list\n    int end = lst.size() - 1;  // Pointer to the end of the sorted list\n    \n    while (start <= end) {\n        if (start == end) {\n            // If there's only one element left, add it to the result\n            result.push_back(lst[start]);\n        } else {\n            // Add the minimum value first\n            result.push_back(lst[start++]);\n            // Then add the maximum value\n            result.push_back(lst[end--]);\n        }\n    }\n    \n    return result;\n}\n\n// Function to check the correctness of the strange_sort_list function\nvoid check() {\n    assert(strange_sort_list({1, 2, 3, 4}) == vector<int>({1, 4, 2, 3}));\n    assert(strange_sort_list({5, 5, 5, 5}) == vector<int>({5, 5, 5, 5}));\n    assert(strange_sort_list({}) == vector<int>({}));\n    cout << \"All test cases passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/71", "generation": "#include <stdio.h>\n#include <math.h>\n\nusing namespace std;\n\nfloat triangle_area(float a, float b, float c) {\n    // Check if the sides form a valid triangle\n    if (a + b <= c || a + c <= b || b + c <= a) {\n        return -1;\n    }\n\n    // Calculate the semi-perimeter\n    float s = (a + b + c) / 2;\n\n    // Calculate the area using Heron's formula\n    float area = sqrt(s * (s - a) * (s - b) * (s - c));\n\n    // Round the result to 2 decimal points\n    return round(area * 100) / 100;\n}\n\n"}
{"task_id": "CPP/72", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool will_it_fly(vector<int> q, int w) {\n    // Check if the sum of elements is less than or equal to w\n    int sum = 0;\n    for (int num : q) {\n        sum += num;\n    }\n    if (sum > w) return false;\n\n    // Check if the vector is palindromic\n    for (size_t i = 0; i < q.size() / 2; ++i) {\n        if (q[i] != q[q.size() - 1 - i]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\n// Function to test the will_it_fly function with provided examples\nvoid check_function() {\n    cout << boolalpha; // Print bools as true/false instead of 1/0\n    cout << \"will_it_fly({1, 2}, 5): \" << will_it_fly({1, 2}, 5) << endl;\n    cout << \"will_it_fly({3, 2, 3}, 1): \" << will_it_fly({3, 2, 3}, 1) << endl;\n    cout << \"will_it_fly({3, 2, 3}, 9): \" << will_it_fly({3, 2, 3}, 9) << endl;\n    cout << \"will_it_fly({3}, 5): \" << will_it_fly({3}, 5) << endl;\n}\n\n"}
{"task_id": "CPP/73", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint smallest_change(vector<int> arr) {\n    int left = 0;\n    int right = arr.size() - 1;\n    int changes_needed = 0;\n\n    while (left < right) {\n        if (arr[left] != arr[right]) {\n            changes_needed++;\n        }\n        left++;\n        right--;\n    }\n\n    return changes_needed;\n}\n\n"}
{"task_id": "CPP/74", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to calculate the total number of characters in a vector of strings\nint count_chars(const vector<string>& vec) {\n    int total = 0;\n    for (const auto& str : vec) {\n        total += str.length();\n    }\n    return total;\n}\n\nvector<string> total_match(vector<string> lst1, vector<string> lst2) {\n    // Calculate the total number of characters in each vector\n    int chars_lst1 = count_chars(lst1);\n    int chars_lst2 = count_chars(lst2);\n\n    // Compare and return the appropriate vector\n    if (chars_lst1 < chars_lst2) {\n        return lst1;\n    } else if (chars_lst2 < chars_lst1) {\n        return lst2;\n    } else {\n        return lst1;  // Return the first vector if they have the same number of characters\n    }\n}\n\n// Function to test the total_match function with provided examples\nvoid test_total_match() {\n    assert(total_match({}, {}) == vector<string>());\n    assert(total_match({\"hi\", \"admin\"}, {\"hI\", \"Hi\"}) == vector<string>{\"hI\", \"Hi\"});\n    assert(total_match({\"hi\", \"admin\"}, {\"hi\", \"hi\", \"admin\", \"project\"}) == vector<string>{\"hi\", \"admin\"});\n    assert(total_match({\"hi\", \"admin\"}, {\"hI\", \"hi\", \"hi\"}) == vector<string>{\"hI\", \"hi\", \"hi\"});\n    assert(total_match({\"4\"}, {\"1\", \"2\", \"3\", \"4\", \"5\"}) == vector<string>{\"4\"});\n\n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/75", "generation": "#include <iostream>\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    if (n == 2 || n == 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    for (int i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0)\n            return false;\n    }\n    return true;\n}\n\n// Function to generate all prime numbers less than 100\nvoid generate_primes(int primes[], int &size) {\n    size = 0;\n    for (int i = 2; i < 100; ++i) {\n        if (is_prime(i)) {\n            primes[size++] = i;\n        }\n    }\n}\n\n// Function to check if the given number is a product of three prime numbers\nbool is_multiply_prime(int a) {\n    int primes[25]; // There are 25 prime numbers less than 100\n    int size = 0;\n    generate_primes(primes, size);\n\n    for (int i = 0; i < size; ++i) {\n        for (int j = i; j < size; ++j) {\n            for (int k = j; k < size; ++k) {\n                if (primes[i] * primes[j] * primes[k] == a)\n                    return true;\n            }\n        }\n    }\n\n    return false;\n}\n\n"}
{"task_id": "CPP/76", "generation": "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\nbool is_simple_power(int x, int n) {\n    // Check if n is 1 and x is not 1. If so, return false.\n    if (n == 1 && x != 1) {\n        return false;\n    }\n    \n    // Calculate the logarithm of x to the base n\n    double log_result = log(x) / log(n);\n    \n    // Check if the result is an integer by comparing it with its rounded value\n    return floor(log_result) == log_result;\n}\n\n"}
{"task_id": "CPP/77", "generation": "#include <stdio.h>\n#include <math.h>\n\nusing namespace std;\n\nbool iscube(int a) {\n    // Handle special case for 0\n    if (a == 0) return true;\n    \n    // Calculate the cube root and round it to the nearest integer\n    int root = round(cbrt(a));\n    \n    // Check if cubing the rounded value gives back the original number\n    return pow(root, 3) == a;\n}\n\n"}
{"task_id": "CPP/78", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nint hex_key(string num) {\n    // Define a set of prime hexadecimal digits\n    const string primes = \"2357BD\";\n    \n    int count = 0;\n    \n    // Iterate through each character in the input string\n    for (char c : num) {\n        // Check if the character is in the set of prime hexadecimal digits\n        if (primes.find(c) != string::npos) {\n            count++;\n        }\n    }\n    \n    return count;\n}\n\n"}
{"task_id": "CPP/79", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring decimal_to_binary(int decimal) {\n    if (decimal == 0) {\n        return \"db0db\";\n    }\n\n    string binary = \"\";\n    while (decimal > 0) {\n        int remainder = decimal % 2;\n        binary = to_string(remainder) + binary;\n        decimal /= 2;\n    }\n    \n    // Add the \"db\" prefix and suffix\n    return \"db\" + binary + \"db\";\n}\n\n"}
{"task_id": "CPP/80", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_happy(string s) {\n    // Check if the string length is less than 3\n    if (s.length() < 3) return false;\n\n    // Iterate through the string and check every three consecutive characters\n    for (int i = 0; i <= s.length() - 3; ++i) {\n        // If any two of these three characters are the same, return false\n        if (s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]) {\n            return false;\n        }\n    }\n\n    // If no consecutive triplets have repeating characters, return true\n    return true;\n}\n\n"}
{"task_id": "CPP/81", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to convert GPA to letter grade\nstring gpa_to_letter(float gpa) {\n    if (gpa >= 4.0) return \"A+\";\n    else if (gpa > 3.7) return \"A\";\n    else if (gpa > 3.3) return \"A-\";\n    else if (gpa > 3.0) return \"B+\";\n    else if (gpa > 2.7) return \"B\";\n    else if (gpa > 2.3) return \"B-\";\n    else if (gpa > 2.0) return \"C+\";\n    else if (gpa > 1.7) return \"C\";\n    else if (gpa > 1.3) return \"C-\";\n    else if (gpa > 1.0) return \"D+\";\n    else if (gpa > 0.7) return \"D\";\n    else if (gpa > 0.0) return \"D-\";\n    else return \"E\";\n}\n\n// Function to convert vector of GPAs to vector of letter grades\nvector<string> numerical_letter_grade(vector<float> grades) {\n    vector<string> letter_grades;\n    for (float gpa : grades) {\n        letter_grades.push_back(gpa_to_letter(gpa));\n    }\n    return letter_grades;\n}\n\n// Function to check the correctness of the function\nvoid check() {\n    vector<float> test_grades = {4.0, 3, 1.7, 2, 3.5};\n    vector<string> expected_output = {\"A+\", \"B\", \"C-\", \"C\", \"A-\"};\n    vector<string> output = numerical_letter_grade(test_grades);\n    \n    if (output == expected_output) {\n        cout << \"Test passed!\" << endl;\n    } else {\n        cout << \"Test failed. Expected: \";\n        for (const auto& grade : expected_output) {\n            cout << grade << \" \";\n        }\n        cout << \"\\nGot: \";\n        for (const auto& grade : output) {\n            cout << grade << \" \";\n        }\n        cout << endl;\n    }\n}\n\n"}
{"task_id": "CPP/82", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    if (n == 2 || n == 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n\n    for (int i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0)\n            return false;\n    }\n    return true;\n}\n\n// Function to check if the length of a string is prime\nbool prime_length(string str) {\n    int len = str.length();\n    return is_prime(len);\n}\n\n"}
{"task_id": "CPP/83", "generation": "#include <iostream>\nusing namespace std;\n\nint starts_one_ends(int n) {\n    // If n is 1, there is only one such number: \"1\"\n    if (n == 1) return 1;\n    \n    // Count of numbers starting with 1\n    int start_with_1 = pow(10, n - 1);\n    \n    // Count of numbers ending with 1\n    int end_with_1 = pow(10, n - 1);\n    \n    // Count of numbers both starting and ending with 1\n    int both_start_end_with_1 = pow(10, n - 2);\n    \n    // Total count is the sum minus the overlap\n    return start_with_1 + end_with_1 - both_start_end_with_1;\n}\n\n"}
{"task_id": "CPP/84", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\n// Function to solve the problem\nstring solve(int N) {\n    int sum = 0;\n    \n    // Sum the digits of N\n    while (N > 0) {\n        sum += N % 10;  // Add the last digit to sum\n        N /= 10;        // Remove the last digit from N\n    }\n    \n    // Convert the sum to a binary string\n    return bitset<14>(sum).to_string().substr(14 - (int)log2(sum)); \n}\n\n// Function to check the correctness of the solution\nvoid check() {\n    assert(solve(1000) == \"1\");\n    assert(solve(150) == \"110\");\n    assert(solve(147) == \"1100\");\n    cout << \"All test cases passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/85", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint add(vector<int> lst){\n    int sum = 0;\n    \n    // Iterate through the vector starting from index 1 with a step of 2\n    for (size_t i = 1; i < lst.size(); i += 2) {\n        if (lst[i] % 2 == 0) { // Check if the element is even\n            sum += lst[i]; // Add it to the sum\n        }\n    }\n    \n    return sum;\n}\n\n"}
{"task_id": "CPP/86", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\n// Function to split a string into words separated by spaces\nvector<string> split(const string &s) {\n    vector<string> tokens;\n    string token;\n    istringstream tokenStream(s);\n    while (getline(tokenStream, token, ' ')) {\n        if (!token.empty()) {\n            tokens.push_back(token);\n        }\n    }\n    return tokens;\n}\n\n// Function to sort each word in the sentence\nstring anti_shuffle(string s) {\n    vector<string> words = split(s);\n\n    for (auto &word : words) {\n        // Sort characters of the current word\n        sort(word.begin(), word.end());\n    }\n\n    string result;\n    for (size_t i = 0; i < words.size(); ++i) {\n        if (i > 0) {\n            result += \" \"; // Add space between words\n        }\n        result += words[i];\n    }\n\n    return result;\n}\n\n// Function to check the correctness of the anti_shuffle function\nvoid check() {\n    assert(anti_shuffle(\"Hi\") == \"Hi\");\n    assert(anti_shuffle(\"hello\") == \"ehllo\");\n    assert(anti_shuffle(\"Hello World!!!\") == \"Hello !!!Wdlor\");\n    cout << \"All test cases passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/87", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // For std::sort\n\nusing namespace std;\n\n// Function to get the coordinates of all occurrences of x\nvector<vector<int>> get_row(vector<vector<int>> lst, int x) {\n    vector<vector<int>> result;\n    \n    // Iterate through each row in the list\n    for (size_t i = 0; i < lst.size(); ++i) {\n        // Iterate through each column in the current row\n        for (size_t j = 0; j < lst[i].size(); ++j) {\n            if (lst[i][j] == x) {\n                result.push_back({static_cast<int>(i), static_cast<int>(j)});\n            }\n        }\n    }\n\n    // Sort by rows in ascending order\n    sort(result.begin(), result.end());\n\n    // For each row, sort the columns in descending order\n    for (auto &row : result) {\n        sort(row.rbegin(), row.rend());\n    }\n\n    return result;\n}\n\n// Function to print the result for verification\nvoid print_result(const vector<vector<int>>& result) {\n    for (const auto& coord : result) {\n        cout << \"{\" << coord[0] << \", \" << coord[1] << \"} \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/88", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> sort_array(vector<int> array) {\n    // Check if the vector is empty or contains only one element\n    if (array.empty() || array.size() == 1) {\n        return array;\n    }\n\n    int first = array.front();\n    int last = array.back();\n\n    // Calculate the sum of the first and last elements\n    int sum = first + last;\n\n    // Determine the sorting order based on the sum being odd or even\n    if (sum % 2 == 0) {\n        // Sort in descending order\n        vector<int> sorted_array(array);\n        sort(sorted_array.rbegin(), sorted_array.rend());\n        return sorted_array;\n    } else {\n        // Sort in ascending order\n        vector<int> sorted_array(array);\n        sort(sorted_array.begin(), sorted_array.end());\n        return sorted_array;\n    }\n}\n\n// Function to test the sort_array function with provided examples\nvoid test_sort_array() {\n    assert(sort_array({}) == vector<int>());\n    assert(sort_array({5}) == vector<int>({5}));\n    assert(sort_array({2, 4, 3, 0, 1, 5}) == vector<int>({0, 1, 2, 3, 4, 5}));\n    assert(sort_array({2, 4, 3, 0, 1, 5, 6}) == vector<int>({6, 5, 4, 3, 2, 1, 0}));\n\n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/89", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\n// Function to encrypt a string by rotating the alphabet\nstring encrypt(string s) {\n    // Define the size of the alphabet\n    const int ALPHABET_SIZE = 26;\n    \n    // Create a translation table for the encryption\n    string translationTable = \"lmnopqrstuvwxyzabcd\";\n    \n    string encryptedString = \"\";\n    \n    // Iterate through each character in the input string\n    for (char c : s) {\n        if (isalpha(c)) {  // Check if the character is an alphabet letter\n            char lowerCaseChar = tolower(c);  // Convert to lowercase for simplicity\n            \n            // Find the index of the character in the translation table\n            int index = lowerCaseChar - 'a';\n            \n            // Append the corresponding encrypted character to the result string\n            encryptedString += translationTable[index];\n        } else {\n            // If it's not an alphabet letter, just append the original character\n            encryptedString += c;\n        }\n    }\n    \n    return encryptedString;\n}\n\n"}
{"task_id": "CPP/90", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint next_smallest(vector<int> lst) {\n    // Check for an empty list\n    if (lst.empty()) return -1;  // Return -1 to indicate None\n\n    // Sort the vector and remove duplicates\n    sort(lst.begin(), lst.end());\n    auto it = unique(lst.begin(), lst.end());\n\n    // If there are less than 2 unique elements, return -1 to indicate None\n    if (it == lst.begin() + 1) return -1;\n\n    // Return the second smallest element\n    return *(it - 1);\n}\n\n"}
{"task_id": "CPP/91", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nint is_bored(string S) {\n    int count = 0;\n    stringstream ss(S);\n    string sentence;\n\n    // Split the input string into sentences\n    while (getline(ss, sentence, '.')) {\n        if (!sentence.empty()) {\n            getline(ss, sentence, '?');\n            if (!sentence.empty()) {\n                getline(ss, sentence, '!');\n                if (!sentence.empty()) {\n                    // Trim leading and trailing spaces from the sentence\n                    size_t start = sentence.find_first_not_of(\" \\t\");\n                    size_t end = sentence.find_last_not_of(\" \\t\");\n                    if (start != string::npos && end != string::npos) {\n                        sentence = sentence.substr(start, end - start + 1);\n                        // Check if the sentence starts with \"I\"\n                        if (sentence.substr(0, 1) == \"I\") {\n                            count++;\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    return count;\n}\n\n"}
{"task_id": "CPP/92", "generation": "#include <iostream>\nusing namespace std;\n\nbool any_int(float a, float b, float c) {\n    // Check if all three numbers are integers\n    bool is_a_integer = (a == floor(a));\n    bool is_b_integer = (b == floor(b));\n    bool is_c_integer = (c == floor(c));\n\n    // If any of the numbers is not an integer, return false\n    if (!is_a_integer || !is_b_integer || !is_c_integer) {\n        return false;\n    }\n\n    // Check if one number is equal to the sum of the other two\n    int int_a = static_cast<int>(a);\n    int int_b = static_cast<int>(b);\n    int int_c = static_cast<int>(c);\n\n    return (int_a == int_b + int_c) || \n           (int_b == int_a + int_c) ||\n           (int_c == int_a + int_b);\n}\n\n// Function to test the any_int function\nvoid test_any_int() {\n    cout << \"any_int(5, 2, 7): \" << any_int(5.0f, 2.0f, 7.0f) << endl; // true\n    cout << \"any_int(3, 2, 2): \" << any_int(3.0f, 2.0f, 2.0f) << endl; // false\n    cout << \"any_int(3, -2, 1): \" << any_int(3.0f, -2.0f, 1.0f) << endl; // true\n    cout << \"any_int(3.6, -2.2, 2): \" << any_int(3.6f, -2.2f, 2.0f) << endl; // false\n}\n\n"}
{"task_id": "CPP/93", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\n// Function to encode a message by swapping cases and replacing vowels\nstring encode(string message) {\n    // Define the mapping for vowels\n    string vowels = \"aeiouAEIOU\";\n    string replacement_vowels = \"gikmoGIKMO\";\n\n    // Swap case of all letters in the message\n    transform(message.begin(), message.end(), message.begin(),\n              [](unsigned char c){ return islower(c) ? toupper(c) : tolower(c); });\n\n    // Replace vowels with their corresponding replacements\n    for (char &c : message) {\n        if (vowels.find(c) != string::npos) {\n            size_t index = vowels.find(c);\n            c = replacement_vowels[index];\n        }\n    }\n\n    return message;\n}\n\n"}
{"task_id": "CPP/94", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Function to check if a number is prime\nbool isPrime(int n) {\n    if (n <= 1) return false;\n    if (n == 2 || n == 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    for (int i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0)\n            return false;\n    }\n    return true;\n}\n\n// Function to calculate the sum of digits of a number\nint sumOfDigits(int n) {\n    int sum = 0;\n    while (n > 0) {\n        sum += n % 10;\n        n /= 10;\n    }\n    return sum;\n}\n\n// Main function to find the largest prime and its digit sum\nint findLargestPrimeSum(vector<int> lst) {\n    int maxPrime = -1;\n    \n    // Find the largest prime number in the list\n    for (int num : lst) {\n        if (isPrime(num)) {\n            if (num > maxPrime)\n                maxPrime = num;\n        }\n    }\n\n    // Return the sum of digits of the largest prime number found\n    return maxPrime == -1 ? 0 : sumOfDigits(maxPrime);\n}\n\n// Function to test the solution with provided examples\nvoid test() {\n    vector<int> lst1 = {0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3};\n    cout << findLargestPrimeSum(lst1) << endl; // Output: 10\n\n    vector<int> lst2 = {1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1};\n    cout << findLargestPrimeSum(lst2) << endl; // Output: 25\n\n    vector<int> lst3 = {1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3};\n    cout << findLargestPrimeSum(lst3) << endl; // Output: 13\n\n    vector<int> lst4 = {0,724,32,71,99,32,6,0,5,91,83,0,5,6};\n    cout << findLargestPrimeSum(lst4) << endl; // Output: 11\n\n    vector<int> lst5 = {0,81,12,3,1,21};\n    cout << findLargestPrimeSum(lst5) << endl; // Output: 3\n\n    vector<int> lst6 = {0,8,1,2,1,7};\n    cout << findLargestPrimeSum(lst6) << endl; // Output: 7\n}\n\n"}
{"task_id": "CPP/95", "generation": "#include <iostream>\n#include <string>\n#include <map>\n\nusing namespace std;\n\nbool check_dict_case(map<string, string> dict) {\n    // Check if the map is empty\n    if (dict.empty()) {\n        return false;\n    }\n\n    // Determine the case of the first key\n    bool allLower = true;\n    bool allUpper = true;\n\n    for (const auto &pair : dict) {\n        const string& key = pair.first;\n\n        // Check if the key is not a string, but we know it should be since map keys are strings\n        if (!key.empty()) {\n            if (islower(key[0])) {\n                allUpper = false;\n            } else if (isupper(key[0])) {\n                allLower = false;\n            }\n        }\n\n        // If both flags are false, return false immediately\n        if (!allLower && !allUpper) {\n            return false;\n        }\n    }\n\n    // Return true only if either all keys are in lower case or all keys are in upper case\n    return allLower || allUpper;\n}\n\n// Function to test the check_dict_case function with provided examples\nvoid test_check_dict_case() {\n    cout << boolalpha; // Print bools as true/false instead of 1/0\n\n    cout << \"check_dict_case({\\\"a\\\",\\\"apple\\\"}, {\\\"b\\\",\\\"banana\\\"}): \" \n         << check_dict_case({{\"a\", \"apple\"}, {\"b\", \"banana\"}}) << endl;\n    \n    cout << \"check_dict_case({\\\"a\\\",\\\"apple\\\"}, {\\\"A\\\",\\\"banana\\\"}, {\\\"B\\\",\\\"banana\\\"}): \"\n         << check_dict_case({{\"a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}) << endl;\n\n    cout << \"check_dict_case({\\\"a\\\",\\\"apple\\\"}, {\\\"8\\\",\\\"banana\\\"}, {\\\"a\\\",\\\"apple\\\"}): \"\n         << check_dict_case({{\"a\", \"apple\"}, {\"8\", \"banana\"}, {\"a\", \"apple\"}}) << endl;\n    \n    cout << \"check_dict_case({\\\"Name\\\",\\\"John\\\"}, {\\\"Age\\\",\\\"36\\\"}, {\\\"City\\\",\\\"Houston\\\"}): \"\n         << check_dict_case({{\"Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}) << endl;\n\n    cout << \"check_dict_case({\\\"STATE\\\",\\\"NC\\\"}, {\\\"ZIP\\\",\\\"12345\\\"}): \"\n         << check_dict_case({{\"STATE\", \"NC\"}, {\"ZIP\", \"12345\"}}) << endl;\n}\n\n"}
{"task_id": "CPP/96", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Helper function to check if a number is prime\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    for (int i = 2; i * i <= num; ++i) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\n// Function to generate a vector of prime numbers less than n\nvector<int> count_up_to(int n) {\n    vector<int> primes;\n    for (int i = 2; i < n; ++i) {\n        if (is_prime(i)) {\n            primes.push_back(i);\n        }\n    }\n    return primes;\n}\n\n// Function to test the count_up_to function\nvoid test_count_up_to() {\n    assert(count_up_to(5) == vector<int>({2, 3}));\n    assert(count_up_to(11) == vector<int>({2, 3, 5, 7}));\n    assert(count_up_to(0).empty());\n    assert(count_up_to(20) == vector<int>({2, 3, 5, 7, 11, 13, 17, 19}));\n    assert(count_up_to(1).empty());\n    assert(count_up_to(18) == vector<int>({2, 3, 5, 7, 11, 13, 17}));\n\n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/97", "generation": "#include <iostream>\nusing namespace std;\n\nint multiply(int a, int b) {\n    // Extract the unit digit of both numbers\n    int unitDigitA = abs(a % 10);\n    int unitDigitB = abs(b % 10);\n\n    // Multiply the unit digits and return the result\n    return unitDigitA * unitDigitB;\n}\n\n"}
{"task_id": "CPP/98", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint count_upper(const string& s) {\n    int count = 0;\n    for (size_t i = 0; i < s.length(); i += 2) { // Iterate through even indices\n        char c = tolower(s[i]); // Convert the character to lowercase to simplify comparison\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n            count++;\n        }\n    }\n    return count;\n}\n\n"}
{"task_id": "CPP/99", "generation": "#include <iostream>\n#include <cmath>\n#include <string>\n\nusing namespace std;\n\nint closest_integer(string value) {\n    // Convert string to floating-point number\n    double num = stod(value);\n    \n    // Determine the floor and ceil values\n    int lower = static_cast<int>(floor(num));\n    int upper = static_cast<int>(ceil(num));\n    \n    // Check if the number is exactly halfway between two integers\n    if (num - lower == 0.5) {\n        return num > 0 ? upper : lower;\n    } else {\n        // Determine which integer is closer\n        double diff_to_lower = num - lower;\n        double diff_to_upper = upper - num;\n        \n        // If the differences are equal, round away from zero\n        if (diff_to_lower == diff_to_upper) {\n            return num > 0 ? upper : lower;\n        } else {\n            return diff_to_lower < diff_to_upper ? lower : upper;\n        }\n    }\n}\n\n"}
{"task_id": "CPP/100", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Function to generate the pile of stones\nvector<int> make_a_pile(int n) {\n    vector<int> pile;\n    int current_stones = n;\n    \n    for (int i = 0; i < n; ++i) {\n        pile.push_back(current_stones);\n        // Determine the next number of stones based on whether the current is odd or even\n        if (current_stones % 2 == 0) {\n            current_stones += 2; // Next even number\n        } else {\n            current_stones += 2; // Next odd number, since adding 2 to an odd number results in another odd number\n        }\n    }\n    \n    return pile;\n}\n\n// Function to check the correctness of the make_a_pile function\nvoid check() {\n    vector<int> result = make_a_pile(3);\n    cout << \"For n=3: \";\n    for (int stones : result) {\n        cout << stones << \" \";\n    }\n    cout << endl;\n\n    result = make_a_pile(4);\n    cout << \"For n=4: \";\n    for (int stones : result) {\n        cout << stones << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/101", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nvector<string> words_string(string s) {\n    vector<string> result;\n    string word;\n    istringstream stream(s);\n\n    // Loop through each word in the input string\n    while (getline(stream, word, ',')) { // Split by comma first\n        stringstream wordStream(word);\n        while (wordStream >> word) { // Then split by spaces within the word\n            result.push_back(word);\n        }\n    }\n\n    return result;\n}\n\n// Function to test the words_string function\nvoid test_words_string() {\n    vector<string> expected1 = {\"Hi\", \"my\", \"name\", \"is\", \"John\"};\n    vector<string> result1 = words_string(\"Hi, my name is John\");\n    assert(expected1 == result1);\n\n    vector<string> expected2 = {\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"};\n    vector<string> result2 = words_string(\"One, two, three, four, five, six\");\n    assert(expected2 == result2);\n\n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/102", "generation": "#include <iostream>\nusing namespace std;\n\nint choose_num(int x, int y) {\n    // If x > y, there's no valid range\n    if (x > y) {\n        return -1;\n    }\n\n    // Check if x is even and within the range [x, y]\n    if (x % 2 == 0 && x <= y) {\n        return x;\n    } else {\n        // Find the next even number greater than or equal to x\n        int next_even = ((x + 1) / 2) * 2;\n        // Check if this next even number is within the range [x, y]\n        if (next_even <= y) {\n            return next_even;\n        } else {\n            return -1;\n        }\n    }\n}\n\n"}
{"task_id": "CPP/103", "generation": "#include <stdio.h>\n#include <cmath>\n#include <string>\n\nusing namespace std;\n\nstring rounded_avg(int n, int m) {\n    // Check if n is greater than m\n    if (n > m) {\n        return \"-1\";\n    }\n\n    // Calculate the sum of integers from n to m\n    long long sum = 0;\n    for (int i = n; i <= m; ++i) {\n        sum += i;\n    }\n\n    // Calculate the average and round it down\n    int avg = sum / (m - n + 1);\n\n    // Convert the rounded average to binary\n    string binary = \"\";\n    if (avg == 0) {\n        binary = \"0\";\n    } else {\n        while (avg > 0) {\n            binary = to_string(avg % 2) + binary;\n            avg /= 2;\n        }\n    }\n\n    return binary;\n}\n\n"}
{"task_id": "CPP/104", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nbool hasEvenDigit(int num) {\n    while (num > 0) {\n        int digit = num % 10;\n        if (digit % 2 == 0) {\n            return true; // Found an even digit\n        }\n        num /= 10;\n    }\n    return false; // No even digits found\n}\n\nvector<int> unique_digits(vector<int> x) {\n    vector<int> result;\n\n    for (int num : x) {\n        if (!hasEvenDigit(num)) {\n            result.push_back(num);\n        }\n    }\n\n    sort(result.begin(), result.end());\n    return result;\n}\n\n// Function to print the vector\nvoid printVector(const vector<int>& v) {\n    for (int num : v) {\n        cout << num << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/105", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to get the string representation of a number between 1 and 9\nstring getDigitName(int digit) {\n    map<int, string> digitNames = {\n        {1, \"One\"}, {2, \"Two\"}, {3, \"Three\"},\n        {4, \"Four\"}, {5, \"Five\"}, {6, \"Six\"},\n        {7, \"Seven\"}, {8, \"Eight\"}, {9, \"Nine\"}\n    };\n    return digitNames[digit];\n}\n\nvector<string> by_length(vector<int> arr) {\n    // Step 1: Filter out numbers not between 1 and 9\n    vector<int> filtered;\n    for (int num : arr) {\n        if (num >= 1 && num <= 9) {\n            filtered.push_back(num);\n        }\n    }\n\n    // Step 2: Sort the remaining numbers in ascending order\n    sort(filtered.begin(), filtered.end());\n\n    // Step 3: Reverse the sorted vector\n    reverse(filtered.begin(), filtered.end());\n\n    // Step 4: Replace each digit with its corresponding name\n    vector<string> result;\n    for (int num : filtered) {\n        result.push_back(getDigitName(num));\n    }\n\n    return result;\n}\n\n// Function to print the vector of strings\nvoid printResult(const vector<string>& result) {\n    if (result.empty()) {\n        cout << \"{}\" << endl;\n    } else {\n        cout << \"{\";\n        for (size_t i = 0; i < result.size(); ++i) {\n            cout << result[i];\n            if (i != result.size() - 1) {\n                cout << \", \";\n            }\n        }\n        cout << \"}\" << endl;\n    }\n}\n\n"}
{"task_id": "CPP/106", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// Function to calculate factorial of a number\nint factorial(int num) {\n    if (num == 0 || num == 1)\n        return 1;\n    int fact = 1;\n    for (int i = 2; i <= num; ++i) {\n        fact *= i;\n    }\n    return fact;\n}\n\n// Function to calculate the sum of numbers from 1 to a number\nint sumTo(int num) {\n    return (num * (num + 1)) / 2;\n}\n\nvector<int> f(int n) {\n    vector<int> result(n);\n    \n    for (int i = 0; i < n; ++i) {\n        int index = i + 1; // Since i starts from 1\n        if ((index % 2) == 0) { // Check if the index is even\n            result[i] = factorial(index);\n        } else { // If the index is odd\n            result[i] = sumTo(index);\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/107", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool is_palindrome(int num) {\n    string str = to_string(num);\n    int len = str.length();\n    for (int i = 0; i < len / 2; ++i) {\n        if (str[i] != str[len - i - 1]) return false;\n    }\n    return true;\n}\n\nvector<int> even_odd_palindrome(int n) {\n    vector<int> result(2, 0); // Initialize with two elements for even and odd counts\n    for (int i = 1; i <= n; ++i) {\n        if (is_palindrome(i)) {\n            if (i % 2 == 0) {\n                result[0]++; // Even palindrome count\n            } else {\n                result[1]++; // Odd palindrome count\n            }\n        }\n    }\n    return result;\n}\n\n"}
{"task_id": "CPP/108", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// Function to calculate the sum of digits of an integer\nint sum_of_digits(int num) {\n    int sum = 0;\n    bool isNegative = num < 0;\n    \n    // Handle negative numbers by making them positive and adjusting the first digit's sign later\n    if (isNegative) {\n        num = -num;\n    }\n    \n    while (num > 0) {\n        sum += num % 10;\n        num /= 10;\n    }\n    \n    // If the original number was negative, subtract the first digit from the sum\n    if (isNegative && sum != 0) {\n        sum -= num % 10; // The last digit is the first digit of the original negative number\n    }\n    \n    return sum;\n}\n\n// Function to count numbers with a positive sum of digits\nint count_nums(vector<int> n) {\n    int count = 0;\n    for (int num : n) {\n        if (sum_of_digits(num) > 0) {\n            count++;\n        }\n    }\n    return count;\n}\n\n// Main function for testing\n"}
{"task_id": "CPP/109", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool move_one_ball(vector<int> arr) {\n    int n = arr.size();\n    \n    // If the vector is empty, return true\n    if (n == 0) return true;\n    \n    // Find the point where we can split the array to make it sorted by one right shift\n    for (int i = 1; i < n; ++i) {\n        bool is_sorted = true;\n        \n        // Check if the first part and second part are in non-decreasing order\n        for (int j = 0; j < i - 1; ++j) {\n            if (arr[j] > arr[j + 1]) {\n                is_sorted = false;\n                break;\n            }\n        }\n        \n        // Check if the last element of the first part and the first element of the second part are in order\n        if (is_sorted && i < n - 1) {\n            if (arr[i - 1] > arr[i]) {\n                is_sorted = false;\n            }\n        }\n        \n        for (int j = i; j < n - 1; ++j) {\n            if (arr[j] > arr[j + 1]) {\n                is_sorted = false;\n                break;\n            }\n        }\n        \n        // If the array can be sorted by one right shift, return true\n        if (is_sorted) return true;\n    }\n    \n    // If no such split point is found, return false\n    return false;\n}\n\n// Function to test the move_one_ball function with provided examples\nvoid check() {\n    vector<int> arr1 = {3, 4, 5, 1, 2};\n    vector<int> arr2 = {3, 5, 4, 1, 2};\n    \n    cout << (move_one_ball(arr1) ? \"true\" : \"false\") << endl; // Expected: true\n    cout << (move_one_ball(arr2) ? \"true\" : \"false\") << endl; // Expected: false\n}\n\n"}
{"task_id": "CPP/110", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring exchange(vector<int> lst1, vector<int> lst2) {\n    int oddCountLst1 = 0;\n    \n    // Count the number of odd elements in lst1\n    for (int num : lst1) {\n        if (num % 2 != 0) {\n            oddCountLst1++;\n        }\n    }\n\n    // Check if there are enough odd elements in lst2 to exchange with lst1\n    int oddCountLst2 = 0;\n    for (int num : lst2) {\n        if (num % 2 != 0) {\n            oddCountLst2++;\n        }\n    }\n\n    if (oddCountLst1 <= oddCountLst2) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n\n// Function to test the exchange function\nvoid testExchange() {\n    cout << exchange({1, 2, 3, 4}, {1, 2, 3, 4}) << endl; // Output: YES\n    cout << exchange({1, 2, 3, 4}, {1, 5, 3, 4}) << endl; // Output: NO\n}\n\n"}
{"task_id": "CPP/111", "generation": "#include <iostream>\n#include <string>\n#include <map>\n#include <vector>\nusing namespace std;\n\n// Function to create a histogram of character frequencies\nmap<char, int> histogram(string test) {\n    map<char, int> charCount;\n    \n    // Count the occurrences of each character\n    for (char c : test) {\n        if (c != ' ') {  // Ignore spaces\n            charCount[c]++;\n        }\n    }\n\n    // Find the maximum frequency\n    int maxFrequency = 0;\n    for (const auto& pair : charCount) {\n        if (pair.second > maxFrequency) {\n            maxFrequency = pair.second;\n        }\n    }\n\n    // Create a map to store characters with the highest frequency\n    map<char, int> result;\n    for (const auto& pair : charCount) {\n        if (pair.second == maxFrequency) {\n            result.insert(pair);\n        }\n    }\n\n    return result;\n}\n\n// Function to print the histogram map\nvoid printHistogram(const map<char, int>& hist) {\n    for (const auto& pair : hist) {\n        cout << \"{\" << pair.first << \", \" << pair.second << \"} \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/112", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to check if a string is a palindrome\nbool is_palindrome(const string& str) {\n    int left = 0;\n    int right = str.length() - 1;\n    \n    while (left < right) {\n        if (str[left] != str[right]) {\n            return false;\n        }\n        ++left;\n        --right;\n    }\n    return true;\n}\n\n// Function to reverse_delete and check palindrome\nvector<string> reverse_delete(string s, string c) {\n    // Remove characters from s that are in c\n    for (char ch : c) {\n        s.erase(remove(s.begin(), s.end(), ch), s.end());\n    }\n\n    // Check if the resulting string is a palindrome\n    bool result = is_palindrome(s);\n\n    // Return the result as a vector of strings\n    return {s, to_string(result)};\n}\n\n"}
{"task_id": "CPP/113", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<string> odd_count(vector<string> lst) {\n    vector<string> result;\n    for (const auto& str : lst) {\n        int count = 0;\n        // Count the number of odd digits in the string\n        for (char c : str) {\n            if ((c - '0') % 2 != 0) {\n                count++;\n            }\n        }\n\n        // Format and add to result vector\n        string formatted_str = \"the number of odd elements \" + to_string(count) + \"n the str\" + to_string(count) + \"ng \" + to_string(count) + \" of the \" + to_string(count) + \"nput.\";\n        result.push_back(formatted_str);\n    }\n    return result;\n}\n\n"}
{"task_id": "CPP/114", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nlong long minSubArraySum(vector<long long> nums) {\n    if (nums.empty()) return 0; // Handle empty vector case\n\n    long long current_min = nums[0];\n    long long global_min = nums[0];\n\n    for (size_t i = 1; i < nums.size(); ++i) {\n        current_min = min(nums[i], current_min + nums[i]);\n        global_min = min(global_min, current_min);\n    }\n\n    return global_min;\n}\n\n"}
{"task_id": "CPP/115", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint max_fill(vector<vector<int>> grid, int capacity) {\n    int total_fills = 0;\n    \n    // Iterate through each well (row in the grid)\n    for (const auto& row : grid) {\n        int water_units = 0;\n        \n        // Count the units of water in the current well\n        for (int unit : row) {\n            water_units += unit;\n        }\n        \n        // Calculate the number of bucket fills needed for this well\n        if (water_units > 0) {\n            total_fills += (water_units + capacity - 1) / capacity; // Ceiling division\n        }\n    }\n    \n    return total_fills;\n}\n\n"}
{"task_id": "CPP/116", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\n// Function to count the number of 1s in the binary representation of a number\nint countOnes(int n) {\n    int count = 0;\n    while (n > 0) {\n        count += n & 1; // Check if the least significant bit is set\n        n >>= 1; // Right shift to check the next bit\n    }\n    return count;\n}\n\n// Custom comparator for sorting\nbool customComparator(int a, int b) {\n    int onesA = countOnes(a);\n    int onesB = countOnes(b);\n\n    if (onesA == onesB) {\n        return a < b; // If the number of 1s is the same, sort by decimal value\n    }\n    return onesA < onesB; // Otherwise, sort by the number of 1s in binary representation\n}\n\n// Function to sort the array based on the given criteria\nstd::vector<int> sort_array(std::vector<int> arr) {\n    std::sort(arr.begin(), arr.end(), customComparator);\n    return arr;\n}\n\n"}
{"task_id": "CPP/117", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\nusing namespace std;\n\n// Helper function to count the number of consonants in a word\nint count_consonants(const string& word) {\n    int count = 0;\n    for (char c : word) {\n        if (isalpha(c)) { // Check if the character is an alphabet letter\n            char lower_c = tolower(c); // Convert to lowercase to simplify comparison\n            if (lower_c != 'a' && lower_c != 'e' && lower_c != 'i' && lower_c != 'o' && lower_c != 'u') {\n                count++;\n            }\n        }\n    }\n    return count;\n}\n\n// Function to select words with exactly n consonants\nvector<string> select_words(const string& s, int n) {\n    vector<string> result;\n    stringstream ss(s);\n    string word;\n\n    while (ss >> word) { // Split the input string into words\n        if (count_consonants(word) == n) {\n            result.push_back(word); // Add to result if it has exactly n consonants\n        }\n    }\n\n    return result;\n}\n\n// Function to test the select_words function with provided examples\nvoid test_select_words() {\n    assert(select_words(\"Mary had a little lamb\", 4) == vector<string>{\"little\"});\n    assert(select_words(\"Mary had a little lamb\", 3) == vector<string>{\"Mary\", \"lamb\"});\n    assert(select_words(\"simple white space\", 2).empty());\n    assert(select_words(\"Hello world\", 4) == vector<string>{\"world\"});\n    assert(select_words(\"Uncle sam\", 3) == vector<string>{\"Uncle\"});\n\n    cout << \"All tests passed.\" << endl;\n}\n\n"}
{"task_id": "CPP/118", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_vowel(char c) {\n    return c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' ||\n           c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U';\n}\n\nbool is_consonant(char c) {\n    return !is_vowel(c) && isalpha(c);\n}\n\nstring get_closest_vowel(string word) {\n    int n = word.length();\n    \n    // Start from the second last character and move towards the beginning\n    for (int i = n - 2; i >= 0; --i) {\n        if (is_consonant(word[i + 1]) && is_consonant(word[i])) {\n            if (is_vowel(word[i])) {\n                return string(1, word[i]);\n            }\n        }\n    }\n\n    // If no such vowel is found\n    return \"\";\n}\n\n"}
{"task_id": "CPP/119", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Helper function to check if a string is balanced\nbool is_balanced(const string& s) {\n    int balance = 0;\n    for (char c : s) {\n        if (c == '(') {\n            ++balance;\n        } else if (c == ')') {\n            --balance;\n            if (balance < 0) {\n                return false; // More closing parentheses than opening\n            }\n        }\n    }\n    return balance == 0; // True if balanced, false otherwise\n}\n\n// Main function to check if concatenating the strings in some order results in a good string\nstring match_parens(vector<string> lst) {\n    // Check both possible concatenations\n    if (is_balanced(lst[0] + lst[1]) || is_balanced(lst[1] + lst[0])) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\n\n"}
{"task_id": "CPP/120", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n// Function to return the maximum k numbers from the given vector arr\nvector<int> maximum(vector<int> arr, int k) {\n    // Use nth_element to partially sort the array such that the first k elements are in sorted order\n    nth_element(arr.begin(), arr.begin() + k - 1, arr.end(), greater<int>());\n    \n    // Copy the top k elements into a new vector and sort it in ascending order\n    vector<int> result(arr.begin(), arr.begin() + k);\n    sort(result.begin(), result.end());\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/121", "generation": "#include <vector>\nusing namespace std;\n\nint solution(vector<int> lst) {\n    int sum = 0;\n    // Iterate over the list, starting from index 0 (which is considered even)\n    for (size_t i = 0; i < lst.size(); i += 2) {\n        if (lst[i] % 2 != 0) { // Check if the element at the current position is odd\n            sum += lst[i]; // Add it to the sum if it's odd\n        }\n    }\n    return sum;\n}\n\n// Example usage:\n"}
{"task_id": "CPP/122", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint add_elements(vector<int> arr, int k) {\n    int sum = 0;\n    \n    // Iterate through the first k elements of the array\n    for (int i = 0; i < k; ++i) {\n        // Check if the element has at most two digits\n        if (arr[i] >= 0 && arr[i] <= 99) {\n            sum += arr[i];\n        }\n    }\n    \n    return sum;\n}\n\n// Function to test the add_elements function with provided data points\nvoid test_function() {\n    vector<int> arr = {111, 21, 3, 4000, 5, 6, 7, 8, 9};\n    int k = 4;\n    cout << \"Input: \";\n    for (int num : arr) {\n        cout << num << \" \";\n    }\n    cout << \"\\nk = \" << k << endl;\n    cout << \"Output: \" << add_elements(arr, k) << endl;\n\n    // Additional test cases\n    vector<int> test_arr1 = {10, 20, 30, 40, 50};\n    int k1 = 3;\n    cout << \"\\nInput: \";\n    for (int num : test_arr1) {\n        cout << num << \" \";\n    }\n    cout << \"\\nk = \" << k1 << endl;\n    cout << \"Output: \" << add_elements(test_arr1, k1) << endl;\n\n    vector<int> test_arr2 = {9876543210, 123456789, -1, -2, -3};\n    int k2 = 5;\n    cout << \"\\nInput: \";\n    for (int num : test_arr2) {\n        cout << num << \" \";\n    }\n    cout << \"\\nk = \" << k2 << endl;\n    cout << \"Output: \" << add_elements(test_arr2, k2) << endl;\n}\n\n"}
{"task_id": "CPP/123", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n// Function to generate and return the odd numbers in the Collatz sequence of n.\nvector<int> get_odd_collatz(int n) {\n    vector<int> result;\n    \n    // Generate the Collatz sequence until it reaches 1\n    while (n != 1) {\n        if (n % 2 == 0) {\n            n /= 2; // If n is even, divide by 2\n        } else {\n            result.push_back(n); // If n is odd, add to the result vector\n            n = 3 * n + 1; // Apply the Collatz transformation\n        }\n    }\n    \n    // Add the last number (which is 1) to the result vector\n    result.push_back(1);\n    \n    // Sort the result vector in increasing order\n    sort(result.begin(), result.end());\n    \n    return result;\n}\n\n// Function to check the correctness of the get_odd_collatz function\nvoid check() {\n    vector<int> expected = {1, 5};\n    vector<int> result = get_odd_collatz(5);\n    if (result == expected) {\n        cout << \"Test passed for input 5.\" << endl;\n    } else {\n        cout << \"Test failed for input 5. Expected: \";\n        for (int num : expected) {\n            cout << num << \" \";\n        }\n        cout << \"\\nGot: \";\n        for (int num : result) {\n            cout << num << \" \";\n        }\n        cout << endl;\n    }\n\n    vector<int> expected2 = {1, 3, 5, 7};\n    vector<int> result2 = get_odd_collatz(8);\n    if (result2 == expected2) {\n        cout << \"Test passed for input 8.\" << endl;\n    } else {\n        cout << \"Test failed for input 8. Expected: \";\n        for (int num : expected2) {\n            cout << num << \" \";\n        }\n        cout << \"\\nGot: \";\n        for (int num : result2) {\n            cout << num << \" \";\n        }\n        cout << endl;\n    }\n}\n\n"}
{"task_id": "CPP/124", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nbool valid_date(string date) {\n    // Check if the date string is empty\n    if (date.empty()) return false;\n\n    // Use stringstream to split the date into month, day, and year\n    stringstream ss(date);\n    string token;\n    vector<string> parts;\n    while (getline(ss, token, '-')) {\n        parts.push_back(token);\n    }\n\n    // Check if the date is in the correct format mm-dd-yyyy\n    if (parts.size() != 3) return false;\n\n    int month, day, year;\n    try {\n        month = stoi(parts[0]);\n        day = stoi(parts[1]);\n        year = stoi(parts[2]);\n    } catch (...) {\n        // If any part of the date cannot be converted to an integer, it's invalid\n        return false;\n    }\n\n    // Validate the month\n    if (month < 1 || month > 12) return false;\n\n    // Validate the day based on the month\n    if ((month == 4 || month == 6 || month == 9 || month == 11) && (day < 1 || day > 30)) return false;\n    else if (month == 2) {\n        if (day < 1 || day > 29) return false;\n        // Check for leap year\n        if ((year % 4 == 0 && year % 100 != 0) || (year % 400 == 0)) {\n            if (day > 29) return false;\n        }\n    } else {\n        if (day < 1 || day > 31) return false;\n    }\n\n    // If all checks pass, the date is valid\n    return true;\n}\n\n"}
{"task_id": "CPP/125", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to count lowercase letters with odd order in the alphabet\nint count_odd_order_letters(const string& str) {\n    int count = 0;\n    for (char c : str) {\n        if (islower(c)) {\n            // Convert character to its corresponding index (a=0, b=1, ..., z=25)\n            int index = static_cast<int>(c - 'a');\n            if (index % 2 == 1) { // Check if the index is odd\n                count++;\n            }\n        }\n    }\n    return count;\n}\n\n// Function to split words based on whitespace and commas\nvector<string> split_words(const string& txt) {\n    vector<string> result;\n\n    // First, try splitting by whitespace\n    size_t start = 0;\n    while (start < txt.size()) {\n        size_t end = txt.find_first_of(\" ,\", start);\n        if (end == string::npos) {\n            end = txt.size();\n        }\n        result.push_back(txt.substr(start, end - start));\n        start = end + 1;\n    }\n\n    // If no whitespace or comma is found, count lowercase letters with odd order\n    if (result.empty()) {\n        int count = count_odd_order_letters(txt);\n        result.push_back(to_string(count));\n    }\n\n    return result;\n}\n\n// Function to check the correctness of the split_words function\nvoid check() {\n    assert(split_words(\"Hello world!\") == vector<string>{\"Hello\", \"world!\"});\n    assert(split_words(\"Hello,world!\") == vector<string>{\"Hello\", \"world!\"});\n    assert(split_words(\"abcdef\") == vector<string>{\"3\"});\n    cout << \"All test cases passed.\" << endl;\n}\n\n"}
{"task_id": "CPP/126", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nbool is_sorted(vector<int> lst) {\n    // Check if the list is empty or has one element, which is trivially sorted.\n    if (lst.size() <= 1) return true;\n    \n    int count = 1; // To keep track of consecutive duplicates\n    \n    for (int i = 1; i < lst.size(); ++i) {\n        if (lst[i] == lst[i - 1]) {\n            count++;\n            // If a number appears more than twice, return false.\n            if (count > 2) return false;\n        } else {\n            count = 1; // Reset the count for new numbers\n        }\n        \n        // Check if the current element is not greater than the previous one\n        if (lst[i] < lst[i - 1]) return false;\n    }\n    \n    return true;\n}\n\n// Function to test the is_sorted function with provided examples.\nvoid check() {\n    assert(is_sorted({5}) == true);\n    assert(is_sorted({1, 2, 3, 4, 5}) == true);\n    assert(is_sorted({1, 3, 2, 4, 5}) == false);\n    assert(is_sorted({1, 2, 3, 4, 5, 6}) == true);\n    assert(is_sorted({1, 2, 3, 4, 5, 6, 7}) == true);\n    assert(is_sorted({1, 3, 2, 4, 5, 6, 7}) == false);\n    assert(is_sorted({1, 2, 2, 3, 3, 4}) == true);\n    assert(is_sorted({1, 2, 2, 2, 3, 4}) == false);\n    \n    cout << \"All tests passed.\" << endl;\n}\n\n"}
{"task_id": "CPP/127", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    if (n == 2) return true;\n    if (n % 2 == 0) return false;\n    for (int i = 3; i * i <= n; i += 2) {\n        if (n % i == 0)\n            return false;\n    }\n    return true;\n}\n\n// Function to find the intersection of two intervals\nstring intersection(vector<int> interval1, vector<int> interval2) {\n    int start = max(interval1[0], interval2[0]);\n    int end = min(interval1[1], interval2[1]);\n\n    // Check if there is an intersection\n    if (start > end) return \"NO\";\n\n    // Calculate the length of the intersection\n    int length = end - start + 1;\n\n    // Check if the length is a prime number\n    if (is_prime(length)) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n\n"}
{"task_id": "CPP/128", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint prod_signs(vector<int> arr) {\n    if (arr.empty()) {\n        return -32768;\n    }\n\n    int sign_product = 1;\n    int magnitude_sum = 0;\n\n    for (int num : arr) {\n        // Determine the sign of each number\n        if (num > 0) {\n            sign_product *= 1; // Positive numbers contribute +1 to the product\n        } else if (num < 0) {\n            sign_product *= -1; // Negative numbers contribute -1 to the product\n        } else { // num == 0\n            sign_product = 0; // If any number is zero, the product of signs is zero\n            break;\n        }\n\n        // Add the magnitude (absolute value) to the sum\n        magnitude_sum += abs(num);\n    }\n\n    return sign_product * magnitude_sum;\n}\n\n// Function to test the prod_signs function with provided examples\nvoid check() {\n    cout << \"prod_signs({1, 2, 2, -4}) == \" << prod_signs({1, 2, 2, -4}) << endl; // Should output -9\n    cout << \"prod_signs({0, 1}) == \" << prod_signs({0, 1}) << endl; // Should output 0\n    cout << \"prod_signs({}) == \" << prod_signs({}) << endl; // Should output -32768\n}\n\n"}
{"task_id": "CPP/129", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Directions for moving up, down, left, right\nconst vector<pair<int, int>> directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n\nbool isValidMove(int x, int y, int N) {\n    return x >= 0 && x < N && y >= 0 && y < N;\n}\n\nvoid dfs(vector<vector<int>>& grid, vector<int>& path, int& minPathValue, int k, int x, int y, int currentLength, int currentValue) {\n    if (currentLength == k) {\n        // If the current path length is equal to k, update the minimum path value\n        if (minPathValue.empty() || currentValue < minPathValue.back()) {\n            minPathValue = path;\n        }\n        return;\n    }\n\n    for (const auto& dir : directions) {\n        int newX = x + dir.first;\n        int newY = y + dir.second;\n\n        if (isValidMove(newX, newY, grid.size())) {\n            // Mark the cell as visited\n            int tempValue = grid[newX][newY];\n            path.push_back(tempValue);\n            dfs(grid, path, minPathValue, k, newX, newY, currentLength + 1, currentValue * 10 + tempValue);\n\n            // Backtrack\n            path.pop_back();\n        }\n    }\n}\n\nvector<int> minPath(vector<vector<int>>& grid, int k) {\n    int N = grid.size();\n    vector<int> path;\n    vector<int> minPathValue;\n\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            // Start DFS from each cell\n            dfs(grid, path, minPathValue, k, i, j, 1, grid[i][j]);\n        }\n    }\n\n    return minPathValue;\n}\n\n"}
{"task_id": "CPP/130", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Function to calculate the nth Tribonacci number\nint tribonacci(int n) {\n    if (n == 0) return 3;\n    if (n == 1) return 1; // Note: tri(1) = 3, not 1 as in Fibonacci\n\n    vector<int> memo(n + 1);\n    memo[0] = 3;\n    memo[1] = 3;\n\n    for (int i = 2; i <= n; ++i) {\n        if (i % 2 == 0) {\n            memo[i] = 1 + i / 2;\n        } else {\n            memo[i] = memo[i - 1] + memo[i - 2] + memo[i + 1];\n        }\n    }\n\n    return memo[n];\n}\n\n// Function to generate the first n+1 numbers of the Tribonacci sequence\nvector<int> tri(int n) {\n    vector<int> result;\n    for (int i = 0; i <= n; ++i) {\n        result.push_back(tribonacci(i));\n    }\n    return result;\n}\n\n"}
{"task_id": "CPP/131", "generation": "#include <iostream>\nusing namespace std;\n\nint digits(int n) {\n    int product = 1;\n    bool hasOddDigit = false;\n\n    while (n > 0) {\n        int digit = n % 10;\n        if (digit % 2 != 0) { // Check if the digit is odd\n            product *= digit;\n            hasOddDigit = true;\n        }\n        n /= 10; // Remove the last digit\n    }\n\n    return hasOddDigit ? product : 0;\n}\n\n"}
{"task_id": "CPP/132", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_nested(string str) {\n    int balance = 0;\n    bool hasNested = false;\n\n    for (char c : str) {\n        if (c == '[') {\n            balance++;\n            // Check if there's a nested pair before this opening bracket\n            if (balance > 1 && !hasNested) {\n                hasNested = true;\n            }\n        } else if (c == ']') {\n            balance--;\n            if (balance < 0) {\n                return false; // Unbalanced brackets\n            }\n        }\n    }\n\n    // Check if there was at least one nested pair and the string is balanced\n    return hasNested && balance == 0;\n}\n\n"}
{"task_id": "CPP/133", "generation": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nint sum_squares(vector<float> lst) {\n    int sum = 0;\n    \n    for (float num : lst) {\n        // Round up to the nearest integer\n        float ceil_num = ceil(num);\n        \n        // Add the square of the rounded number to the sum\n        sum += static_cast<int>(ceil_num * ceil_num);\n    }\n    \n    return sum;\n}\n\n// Function to test the correctness of the sum_squares function\nvoid check() {\n    assert(sum_squares({1, 2, 3}) == 14);\n    assert(sum_squares({1, 4, 9}) == 98);\n    assert(sum_squares({1, 3, 5, 7}) == 84);\n    assert(sum_squares({1.4f, 4.2f, 0.0f}) == 29);\n    assert(sum_squares({-2.4f, 1.0f, 1.0f}) == 6);\n\n    cout << \"All test cases passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/134", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool check_if_last_char_is_a_letter(string txt) {\n    // Check if the string is empty or does not end with a space\n    if (txt.empty() || txt.back() != ' ') {\n        return false;\n    }\n\n    // Find the last non-space character before the trailing space\n    size_t pos = txt.find_last_not_of(' ');\n    if (pos == string::npos) {\n        return false;  // The entire string is spaces, no valid letter at the end\n    }\n\n    // Check if the character just before the last non-space character is a space\n    if (txt[pos - 1] != ' ') {\n        return false;  // The last non-space character is not part of a word\n    }\n\n    // Check if the last non-space character is an alphabetical letter\n    char last_char = txt.back();\n    return isalpha(last_char);\n}\n\n"}
{"task_id": "CPP/135", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint can_arrange(vector<int> arr) {\n    int n = arr.size();\n    \n    // Iterate from the second last element to the first element\n    for (int i = n - 2; i >= 0; --i) {\n        if (arr[i] > arr[i + 1]) {\n            return i;\n        }\n    }\n    \n    // If no such element is found, return -1\n    return -1;\n}\n\n// Function to test the can_arrange function with provided examples\nvoid check() {\n    assert(can_arrange({1, 2, 4, 3, 5}) == 3);\n    assert(can_arrange({1, 2, 3}) == -1);\n    cout << \"All tests passed successfully.\" << endl;\n}\n\n"}
{"task_id": "CPP/136", "generation": "#include <iostream>\n#include <vector>\n#include <climits> // For INT_MIN and INT_MAX\n\nusing namespace std;\n\nvector<int> largest_smallest_integers(vector<int> lst) {\n    int max_negative = INT_MIN; // Initialize to smallest possible integer\n    int min_positive = INT_MAX; // Initialize to largest possible integer\n    \n    for (int num : lst) {\n        if (num < 0 && num > max_negative) {\n            max_negative = num;\n        } else if (num > 0 && num < min_positive) {\n            min_positive = num;\n        }\n    }\n\n    // If no negative or positive integers are found, set them to 0\n    if (max_negative == INT_MIN) {\n        max_negative = 0;\n    }\n    if (min_positive == INT_MAX) {\n        min_positive = 0;\n    }\n\n    return {max_negative, min_positive};\n}\n\n"}
{"task_id": "CPP/137", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <boost/any.hpp>\n\n// Helper function to convert string with comma decimal separator to float\nfloat str_to_float(const std::string& s) {\n    size_t pos;\n    return std::stof(s, &pos); // Convert the string and get the position of the first non-converted character\n}\n\nboost::any compare_one(boost::any a, boost::any b) {\n    if (a.type() == typeid(float)) {\n        float valA = std::any_cast<float>(a);\n        if (b.type() == typeid(float)) {\n            float valB = std::any_cast<float>(b);\n            return (valA > valB) ? a : (valA < valB) ? b : \"None\";\n        } else if (b.type() == typeid(std::string)) {\n            float valB = str_to_float(std::any_cast<std::string>(b));\n            return (valA > valB) ? a : (valA < valB) ? b : \"None\";\n        }\n    } else if (a.type() == typeid(std::string)) {\n        std::string valA = std::any_cast<std::string>(a);\n        if (b.type() == typeid(float)) {\n            float valB = std::any_cast<float>(b);\n            return (str_to_float(valA) > valB) ? a : (str_to_float(valA) < valB) ? b : \"None\";\n        } else if (b.type() == typeid(std::string)) {\n            std::string valB = std::any_cast<std::string>(b);\n            return (str_to_float(valA) > str_to_float(valB)) ? a : (str_to_float(valA) < str_to_float(valB)) ? b : \"None\";\n        }\n    }\n\n    // If both are integers, we can use any_cast<int> and compare\n    int valA = std::any_cast<int>(a);\n    if (b.type() == typeid(int)) {\n        int valB = std::any_cast<int>(b);\n        return (valA > valB) ? a : (valA < valB) ? b : \"None\";\n    }\n\n    // If both are strings, we can compare them directly\n    std::string valA_str = std::any_cast<std::string>(a);\n    if (b.type() == typeid(std::string)) {\n        std::string valB_str = std::any_cast<std::string>(b);\n        return (valA_str > valB_str) ? a : (valA_str < valB_str) ? b : \"None\";\n    }\n\n    // If types do not match or are unknown, return None\n    return \"None\";\n}\n\n"}
{"task_id": "CPP/138", "generation": "#include <iostream>\nusing namespace std;\n\nbool is_equal_to_sum_even(int n) {\n    // Check if n is less than 8, as it cannot be expressed as a sum of four positive even numbers.\n    if (n < 8) return false;\n    \n    // Subtract the minimum sum of four positive even numbers (2 + 2 + 2 + 2 = 8)\n    int remainder = n - 8;\n    \n    // Check if the remainder is even\n    return remainder % 2 == 0;\n}\n\n"}
{"task_id": "CPP/139", "generation": "#include <iostream>\n\n// Function to calculate factorial of a number\nlong long factorial(long long num) {\n    if (num == 0 || num == 1)\n        return 1;\n    long long fact = 1;\n    for (int i = 2; i <= num; ++i) {\n        fact *= i;\n    }\n    return fact;\n}\n\n// Function to calculate Brazilian factorial\nlong long special_factorial(int n) {\n    if (n < 0) {\n        std::cerr << \"Error: Input must be a positive integer.\" << std::endl;\n        return -1; // Indicate an error\n    }\n\n    long long result = 1;\n    for (int i = n; i > 0; --i) {\n        result *= factorial(i);\n    }\n    return result;\n}\n\n// Function to test the special_factorial function\nvoid test_special_factorial() {\n    std::cout << \"Testing special_factorial(4): \" << special_factorial(4) << \" (Expected: 288)\" << std::endl;\n    std::cout << \"Testing special_factorial(3): \" << special_factorial(3) << \" (Expected: 12)\" << std::endl;\n    std::cout << \"Testing special_factorial(5): \" << special_factorial(5) << \" (Expected: 34560)\" << std::endl;\n}\n\n"}
{"task_id": "CPP/140", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring fix_spaces(string text) {\n    string result;\n    int space_count = 0; // To count consecutive spaces\n\n    for (char ch : text) {\n        if (ch == ' ') {\n            space_count++;\n            if (space_count == 1) {\n                result += '_'; // Add underscore for the first space\n            } else if (space_count > 2) {\n                result += '-'; // Replace more than two consecutive spaces with a hyphen\n                space_count = 0; // Reset count after replacing\n            }\n        } else {\n            result += ch;\n            space_count = 0; // Reset count for non-space characters\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/141", "generation": "#include <iostream>\n#include <string>\n#include <cctype> // for std::isalpha and std::isdigit\n\nusing namespace std;\n\nbool is_valid_file_name(const string& file_name) {\n    int digit_count = 0;\n    size_t dot_position = file_name.find('.');\n    \n    // Check if there is exactly one dot\n    if (dot_position == string::npos || dot_position + 1 == file_name.length()) {\n        return false;\n    }\n    \n    // Check the substring before the dot\n    for (size_t i = 0; i < dot_position; ++i) {\n        if (!std::isalpha(file_name[i])) {\n            return false;\n        }\n        if (std::isdigit(file_name[i])) {\n            digit_count++;\n        }\n        if (digit_count > 3) {\n            return false;\n        }\n    }\n\n    // Check the substring after the dot\n    string extension = file_name.substr(dot_position + 1);\n    if (extension != \"txt\" && extension != \"exe\" && extension != \"dll\") {\n        return false;\n    }\n\n    return true;\n}\n\nstring file_name_check(const string& file_name) {\n    if (is_valid_file_name(file_name)) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\n\n"}
{"task_id": "CPP/142", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint sum_squares(vector<int> lst) {\n    int sum = 0;\n    \n    for (size_t i = 0; i < lst.size(); ++i) {\n        if ((i + 1) % 3 == 0 && (i + 1) % 4 != 0) {\n            // If the index is a multiple of 3 but not a multiple of 4, cube the value\n            sum += lst[i] * lst[i] * lst[i];\n        } else if ((i + 1) % 4 == 0) {\n            // If the index is a multiple of 4, square the value\n            sum += lst[i] * lst[i];\n        } else {\n            // Otherwise, keep the original value\n            sum += lst[i];\n        }\n    }\n\n    return sum;\n}\n\n"}
{"task_id": "CPP/143", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\n// Function to split the sentence into words\nvector<string> split_sentence(const string& sentence) {\n    stringstream ss(sentence);\n    vector<string> words;\n    string word;\n    while (ss >> word) {\n        words.push_back(word);\n    }\n    return words;\n}\n\n// Main function to filter words with prime length\nstring words_in_sentence(string sentence) {\n    // Split the sentence into words\n    vector<string> words = split_sentence(sentence);\n\n    // Collect words whose lengths are prime numbers\n    string result;\n    for (const auto& word : words) {\n        if (is_prime(word.length())) {\n            if (!result.empty()) result += \" \";\n            result += word;\n        }\n    }\n\n    return result;\n}\n\n// Function to test the solution with provided examples\nvoid check() {\n    cout << words_in_sentence(\"This is a test\") << endl; // Output: \"is\"\n    cout << words_in_sentence(\"lets go for swimming\") << endl; // Output: \"go for\"\n}\n\n"}
{"task_id": "CPP/144", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\n// Function to parse numerator and denominator from a fraction string\npair<int, int> parseFraction(const string& fraction) {\n    size_t slashPos = fraction.find('/');\n    int numerator = stoi(fraction.substr(0, slashPos));\n    int denominator = stoi(fraction.substr(slashPos + 1));\n    return {numerator, denominator};\n}\n\n// Function to simplify the expression x * n\nbool simplify(string x, string n) {\n    // Parse the fractions\n    auto [numX, denX] = parseFraction(x);\n    auto [numN, denN] = parseFraction(n);\n\n    // Calculate the product of numerators and denominators\n    int numeratorProduct = numX * numN;\n    int denominatorProduct = denX * denN;\n\n    // Check if the result is a whole number\n    return (numeratorProduct % denominatorProduct) == 0;\n}\n\n"}
{"task_id": "CPP/145", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// Helper function to calculate the sum of digits of an integer\nint digitSum(int n) {\n    int sum = 0;\n    bool isNegative = n < 0;\n    while (n != 0) {\n        int d = abs(n % 10);\n        sum += d;\n        n /= 10;\n    }\n    // If the number was negative, subtract the first digit\n    if (isNegative && n == -1) {\n        sum -= 9; // Assuming single-digit numbers are handled correctly\n    }\n    return sum;\n}\n\n// Comparator function to sort based on digit sum and original index\nbool compare(int a, int b, const vector<int>& nums) {\n    int sumA = digitSum(a);\n    int sumB = digitSum(b);\n    \n    if (sumA == sumB) {\n        // If the sums are equal, use the original index as tiebreaker\n        return nums.index_of(a) < nums.index_of(b);\n    }\n    return sumA < sumB;\n}\n\nvector<int> order_by_points(vector<int> nums) {\n    vector<int> sortedNums = nums; // Copy of the original vector to keep track of indices\n    \n    // Use stable_sort to maintain relative order for equal elements\n    stable_sort(sortedNums.begin(), sortedNums.end(), [&](int a, int b) {\n        return compare(a, b, sortedNums);\n    });\n    \n    return sortedNums;\n}\n\n// Function to check the correctness of the solution\nvoid check() {\n    vector<int> test1 = {1, 11, -1, -11, -12};\n    vector<int> expected1 = {-1, -11, 1, -12, 11};\n    assert(order_by_points(test1) == expected1);\n    \n    vector<int> test2 = {};\n    vector<int> expected2 = {};\n    assert(order_by_points(test2) == expected2);\n    \n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/146", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Function to check if a digit is odd\nbool isOdd(int n) {\n    return n % 2 != 0;\n}\n\n// Function to extract and check the first and last digits of a number\nbool isFirstAndLastDigitOdd(int num) {\n    int absNum = abs(num); // Get the absolute value to handle negative numbers\n    while (absNum >= 10) { // Remove the last digit until we reach the first one\n        absNum /= 10;\n    }\n    int lastDigit = absNum % 10; // The remaining digit is the last digit\n\n    if (isOdd(lastDigit)) {\n        return true; // Check if the last digit is odd\n    }\n\n    while (absNum > 0) { // Remove all digits until we reach the first one\n        absNum /= 10;\n    }\n    int firstDigit = absNum % 10; // The remaining digit is the first digit\n\n    return isOdd(firstDigit); // Check if the first digit is odd\n}\n\n// Main function to count numbers that meet the criteria\nint specialFilter(vector<int> nums) {\n    int count = 0;\n    for (int num : nums) {\n        if (num > 10 && isFirstAndLastDigitOdd(num)) {\n            count++;\n        }\n    }\n    return count;\n}\n\n// Function to test the specialFilter function\nvoid testSpecialFilter() {\n    assert(specialFilter({15, -73, 14, -15}) == 1);\n    assert(specialFilter({33, -2, -3, 45, 21, 109}) == 2);\n    cout << \"All tests passed successfully.\" << endl;\n}\n\n"}
{"task_id": "CPP/147", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint get_max_triples(int n) {\n    // Step 1: Generate vector a\n    vector<int> a(n);\n    for (int i = 1; i <= n; ++i) {\n        a[i - 1] = i * i - i + 1;\n    }\n\n    int count = 0;\n\n    // Step 2 and 3: Iterate through all possible triples\n    for (int i = 0; i < n - 2; ++i) {\n        for (int j = i + 1; j < n - 1; ++j) {\n            for (int k = j + 1; k < n; ++k) {\n                // Step 3: Check if the sum of the triple is divisible by 3\n                if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                    count++;\n                }\n            }\n        }\n    }\n\n    return count;\n}\n\n"}
{"task_id": "CPP/148", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Define the order of the planets based on their distance from the Sun\nconst vector<string> planet_order = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n\nvector<string> bf(string planet1, string planet2) {\n    // Find the indices of the given planets in the sorted list\n    auto it1 = find(planet_order.begin(), planet_order.end(), planet1);\n    auto it2 = find(planet_order.begin(), planet_order.end(), planet2);\n\n    // Check if both planets are valid and in the correct order\n    if (it1 == planet_order.end() || it2 == planet_order.end() || it1 >= it2) {\n        return {};  // Return an empty vector if invalid or out of order\n    }\n\n    // Get the indices of the found planets\n    int index1 = distance(planet_order.begin(), it1);\n    int index2 = distance(planet_order.begin(), it2);\n\n    // Create a vector to store the result\n    vector<string> result;\n\n    // Add all planets between the two given planets (inclusive)\n    for (int i = min(index1, index2) + 1; i < max(index1, index2); ++i) {\n        result.push_back(planet_order[i]);\n    }\n\n    return result;\n}\n\n// Function to test the bf function\nvoid test() {\n    vector<string> result;\n\n    // Test cases\n    result = bf(\"Jupiter\", \"Neptune\");\n    for (const auto& planet : result) {\n        cout << planet << \" \";\n    }\n    cout << endl;\n\n    result = bf(\"Earth\", \"Mercury\");\n    for (const auto& planet : result) {\n        cout << planet << \" \";\n    }\n    cout << endl;\n\n    result = bf(\"Mercury\", \"Uranus\");\n    for (const auto& planet : result) {\n        cout << planet << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/149", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to sort the vector of strings based on given rules\nvector<string> sorted_list_sum(vector<string> lst) {\n    // Remove strings with odd lengths\n    lst.erase(remove_if(lst.begin(), lst.end(), [](const string& s) { return s.length() % 2 != 0; }), lst.end());\n\n    // Sort the vector by length and then alphabetically\n    sort(lst.begin(), lst.end(), [](const string& a, const string& b) {\n        if (a.length() == b.length()) {\n            return a < b;\n        }\n        return a.length() < b.length();\n    });\n\n    return lst;\n}\n\n// Function to check the correctness of the solution\nvoid check() {\n    assert((sorted_list_sum({\"aa\", \"a\", \"aaa\"}) == vector<string>{\"aa\"}));\n    assert((sorted_list_sum({\"ab\", \"a\", \"aaa\", \"cd\"}) == vector<string>{\"ab\", \"cd\"}));\n}\n\n"}
{"task_id": "CPP/150", "generation": "#include <stdio.h>\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int num) {\n    if (num <= 1) return false; // Numbers less than or equal to 1 are not prime\n    for (int i = 2; i * i <= num; ++i) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\n// Function that returns x if n is a prime number, otherwise returns y\nint x_or_y(int n, int x, int y) {\n    return is_prime(n) ? x : y;\n}\n\n"}
{"task_id": "CPP/151", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nlong long double_the_difference(vector<float> lst) {\n    long long sum = 0;\n    \n    for (float num : lst) {\n        // Check if the number is positive, an integer, and odd\n        if (num > 0 && floor(num) == num && static_cast<int>(num) % 2 != 0) {\n            sum += pow(num, 2);\n        }\n    }\n    \n    return sum;\n}\n\n"}
{"task_id": "CPP/152", "generation": "#include <stdio.h>\n#include <math.h>\n#include <vector>\nusing namespace std;\n\nvector<int> compare(vector<int> game, vector<int> guess) {\n    vector<int> result;\n    \n    // Ensure both vectors are of equal length\n    if (game.size() != guess.size()) {\n        printf(\"Error: The input vectors must be of the same length.\\n\");\n        return result;  // Return an empty vector in case of error\n    }\n    \n    // Compare each element and calculate the absolute difference\n    for (size_t i = 0; i < game.size(); ++i) {\n        int diff = abs(game[i] - guess[i]);\n        result.push_back(diff);\n    }\n    \n    return result;\n}\n\n// Function to test the compare function with provided examples\nvoid test() {\n    vector<int> scores1 = {1, 2, 3, 4, 5, 1};\n    vector<int> guesses1 = {1, 2, 3, 4, 2, -2};\n    vector<int> result1 = compare(scores1, guesses1);\n    for (int val : result1) {\n        printf(\"%d \", val);\n    }\n    printf(\"\\n\");\n\n    vector<int> scores2 = {0, 5, 0, 0, 0, 4};\n    vector<int> guesses2 = {4, 1, 1, 0, 0, -2};\n    vector<int> result2 = compare(scores2, guesses2);\n    for (int val : result2) {\n        printf(\"%d \", val);\n    }\n    printf(\"\\n\");\n}\n\n"}
{"task_id": "CPP/153", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to calculate the strength of an extension\nint calculateStrength(const string& extension) {\n    int cap = 0, sm = 0;\n    for (char c : extension) {\n        if (isupper(c)) cap++;\n        else if (islower(c)) sm++;\n    }\n    return cap - sm;\n}\n\n// Function to find the strongest extension\nstring Strongest_Extension(string class_name, vector<string> extensions) {\n    int max_strength = INT_MIN; // Initialize with minimum possible value\n    string strongest_extension;\n\n    for (const string& ext : extensions) {\n        int strength = calculateStrength(ext);\n        if (strength > max_strength) {\n            max_strength = strength;\n            strongest_extension = ext;\n        }\n    }\n\n    return class_name + \".\" + strongest_extension;\n}\n\n// Function to test the solution\nvoid test() {\n    cout << Strongest_Extension(\"my_class\", {\"AA\", \"Be\", \"CC\"}) << endl; // Expected: my_class.AA\n    cout << Strongest_Extension(\"Slices\", {\"SErviNGSliCes\", \"Cheese\", \"StuFfed\"}) << endl; // Expected: Slices.SErviNGSliCes\n}\n\n"}
{"task_id": "CPP/154", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_rotation(const string& s, const string& t) {\n    // Check if t is a rotation of s by comparing lengths and using a trick to check rotations\n    return s.length() == t.length() && (s + s).find(t) != string::npos;\n}\n\nbool cycpattern_check(string a, string b) {\n    // Concatenate the first word with itself\n    string doubled_a = a + a;\n    \n    // Check if any rotation of b is a substring in the concatenated string\n    for (int i = 0; i < b.length(); ++i) {\n        string rotated_b = b.substr(i) + b.substr(0, i);\n        if (doubled_a.find(rotated_b) != string::npos) {\n            return true;\n        }\n    }\n    \n    return false;\n}\n\n"}
{"task_id": "CPP/155", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// Function to count even and odd digits in an integer\nvector<int> even_odd_count(int num) {\n    // Convert the number to a string to easily iterate over each digit\n    string str_num = to_string(abs(num));\n    \n    int even_count = 0;\n    int odd_count = 0;\n    \n    // Iterate through each character in the string representation of the number\n    for (char c : str_num) {\n        int digit = c - '0'; // Convert char to int\n        if (digit % 2 == 0) {\n            even_count++;\n        } else {\n            odd_count++;\n        }\n    }\n    \n    return {even_count, odd_count};\n}\n\n// Function to test the even_odd_count function\nvoid test_even_odd_count() {\n    assert(even_odd_count(-12) == vector<int>({1, 1}));\n    assert(even_odd_count(123) == vector<int>({1, 2}));\n    assert(even_odd_count(0) == vector<int>({1, 0})); // Edge case: single digit '0'\n    assert(even_odd_count(-9876543210) == vector<int>({5, 5}));\n    \n    cout << \"All test cases passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/156", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\n// Function to convert integer to lowercase Roman numeral\nstring int_to_mini_roman(int number) {\n    // Mapping of integers to their corresponding Roman numerals in descending order\n    vector<pair<int, string>> romanMap = {\n        {1000, \"m\"}, {900, \"cm\"}, {500, \"d\"}, {400, \"cd\"},\n        {100, \"c\"}, {90, \"xc\"}, {50, \"l\"}, {40, \"xl\"},\n        {10, \"x\"}, {9, \"ix\"}, {5, \"v\"}, {4, \"iv\"}, {1, \"i\"}\n    };\n\n    string roman = \"\";\n\n    // Iterate over the map and subtract from number\n    for (const auto& value : romanMap) {\n        while (number >= value.first) {\n            roman += value.second;\n            number -= value.first;\n        }\n    }\n\n    return roman;\n}\n\n// Function to check the correctness of the int_to_mini_roman function\nvoid check() {\n    assert(int_to_mini_roman(19) == \"xix\");\n    assert(int_to_mini_roman(152) == \"clii\");\n    assert(int_to_mini_roman(426) == \"cdxxvi\");\n    cout << \"All test cases passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/157", "generation": "#include <stdio.h>\n#include <math.h>\n\nusing namespace std;\n\nbool right_angle_triangle(float a, float b, float c) {\n    // Sort the sides to ensure c is the longest side\n    if (a > c) swap(a, c);\n    if (b > c) swap(b, c);\n\n    // Check the Pythagorean theorem\n    return fabs(a*a + b*b - c*c) < 1e-6; // Using a small epsilon to account for floating point precision issues\n}\n\n"}
{"task_id": "CPP/158", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to count unique characters in a string\nint count_unique_chars(const string& word) {\n    bool seen[256] = {false}; // Assuming ASCII characters\n    int unique_count = 0;\n    for (char c : word) {\n        if (!seen[c]) {\n            seen[c] = true;\n            unique_count++;\n        }\n    }\n    return unique_count;\n}\n\n// Function to find the string with maximum number of unique characters\nstring find_max(vector<string> words) {\n    // Sort the vector lexicographically first\n    sort(words.begin(), words.end());\n    \n    int max_unique_chars = 0;\n    string result;\n\n    for (const auto& word : words) {\n        int unique_chars = count_unique_chars(word);\n        if (unique_chars > max_unique_chars) {\n            max_unique_chars = unique_chars;\n            result = word;\n        }\n    }\n\n    return result;\n}\n\n// Function to test the find_max function\nvoid test_find_max() {\n    assert(find_max({\"name\", \"of\", \"string\"}) == \"string\");\n    assert(find_max({\"name\", \"enam\", \"game\"}) == \"enam\");\n    assert(find_max({\"aaaaaaa\", \"bb\", \"cc\"}) == \"aaaaaaa\");\n\n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/159", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nvector<int> eat(int number, int need, int remaining) {\n    // Calculate the actual number of carrots to be eaten\n    int to_eat = min(need, remaining);\n    \n    // Update the total number of carrots eaten\n    int total_eaten = number + to_eat;\n    \n    // Update the remaining number of carrots\n    int left_over = remaining - to_eat;\n    \n    return {total_eaten, left_over};\n}\n\n// Example usage:\n"}
{"task_id": "CPP/160", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nint do_algebra(vector<string> operatorVec, vector<int> operandVec) {\n    if (operatorVec.empty() || operandVec.size() < 2) {\n        throw invalid_argument(\"Invalid input: operators and operands must be valid.\");\n    }\n\n    int result = operandVec[0];\n\n    for (size_t i = 0; i < operatorVec.size(); ++i) {\n        switch (operatorVec[i][0]) {\n            case '+':\n                result += operandVec[i + 1];\n                break;\n            case '-':\n                result -= operandVec[i + 1];\n                break;\n            case '*':\n                result *= operandVec[i + 1];\n                break;\n            case '/':\n                if (operandVec[i + 1] == 0) {\n                    throw runtime_error(\"Division by zero is not allowed.\");\n                }\n                result /= operandVec[i + 1];\n                break;\n            case '%':\n                if (operandVec[i + 1] == 0) {\n                    throw runtime_error(\"Modulo by zero is not allowed.\");\n                }\n                result %= operandVec[i + 1];\n                break;\n            case '^':\n                result = pow(result, operandVec[i + 1]);\n                break;\n            default:\n                throw invalid_argument(\"Invalid operator: \" + operatorVec[i]);\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/161", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\n// Function to check if a character is a letter\nbool isLetter(char c) {\n    return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z');\n}\n\n// Function to reverse the case of a letter\nchar reverseCase(char c) {\n    if (isupper(c)) {\n        return tolower(c);\n    } else {\n        return toupper(c);\n    }\n}\n\nstring solve(string s) {\n    bool containsLetters = false;\n    \n    // Check if the string contains any letters\n    for (char c : s) {\n        if (isLetter(c)) {\n            containsLetters = true;\n            break;\n        }\n    }\n\n    if (!containsLetters) {\n        // If no letters are present, reverse the entire string\n        reverse(s.begin(), s.end());\n    } else {\n        // If there are letters, reverse their case\n        for (char &c : s) {\n            if (isLetter(c)) {\n                c = reverseCase(c);\n            }\n        }\n    }\n\n    return s;\n}\n\n"}
{"task_id": "CPP/162", "generation": "#include <iostream>\n#include <string>\n#include <openssl/md5.h>\n\n// Function to convert string to MD5 hash\nstd::string string_to_md5(const std::string& text) {\n    unsigned char digest[MD5_DIGEST_LENGTH];\n    MD5_CTX md5;\n    \n    // Initialize the context\n    MD5_Init(&md5);\n    \n    // Update the context with the input data\n    MD5_Update(&md5, text.c_str(), text.size());\n    \n    // Finalize the hash computation\n    MD5_Final(digest, &md5);\n    \n    // Convert the digest to a hexadecimal string\n    std::stringstream ss;\n    for (int i = 0; i < MD5_DIGEST_LENGTH; ++i) {\n        ss << std::hex << std::setw(2) << std::setfill('0') << (int)digest[i];\n    }\n    \n    return ss.str();\n}\n\n// Function to check the correctness of the string_to_md5 function\nvoid check_function() {\n    std::string test_text = \"Hello world\";\n    std::string expected_hash = \"3e25960a79dbc69b674cd4ec67a72c62\";\n    \n    std::string result = string_to_md5(test_text);\n    \n    if (result == expected_hash) {\n        std::cout << \"Test passed.\" << std::endl;\n    } else {\n        std::cout << \"Test failed. Expected: \" << expected_hash << \", Got: \" << result << std::endl;\n    }\n}\n\n"}
{"task_id": "CPP/163", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> generate_integers(int a, int b) {\n    vector<int> even_digits;\n    \n    // Ensure a is less than or equal to b for simplicity\n    if (a > b) swap(a, b);\n    \n    // Iterate through each number in the range [a, b]\n    for (int i = a; i <= b; ++i) {\n        int num = i;\n        \n        // Extract digits and check if they are even\n        while (num > 0) {\n            int digit = num % 10;\n            if (digit % 2 == 0 && digit != 0) { // Check for non-zero even digit\n                even_digits.push_back(digit);\n            }\n            num /= 10; // Move to the next digit\n        }\n    }\n    \n    return even_digits;\n}\n\n// Function to print vector elements\nvoid print_vector(const vector<int>& vec) {\n    for (int val : vec) {\n        cout << val << \" \";\n    }\n    cout << endl;\n}\n\n"}
