{"task_id": "CPP/0", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // For std::sort\n\nbool has_close_elements(vector<float> numbers, float threshold) {\n    // Sort the vector first\n    sort(numbers.begin(), numbers.end());\n\n    // Iterate through adjacent elements to check if any pair is closer than the threshold\n    for (size_t i = 0; i < numbers.size() - 1; ++i) {\n        if (numbers[i + 1] - numbers[i] < threshold) {\n            return true;\n        }\n    }\n\n    // If no such pair found, return false\n    return false;\n}\n\n"}
{"task_id": "CPP/1", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> separate_paren_groups(string paren_string) {\n    vector<string> result;\n    string current_group;\n    int balance = 0;\n\n    for (char ch : paren_string) {\n        if (ch == '(') {\n            balance++;\n            current_group += ch;\n        } else if (ch == ')') {\n            balance--;\n            current_group += ch;\n            if (balance == 0) {\n                result.push_back(current_group);\n                current_group.clear();\n            }\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/2", "generation": "#include <stdio.h>\n#include <math.h>\n\nfloat truncate_number(float number) {\n    float integerPart;\n    modf(number, &integerPart);  // modf returns the fractional part and stores the integer part in `integerPart`\n    return number - integerPart; // Subtracting the integer part from the original number gives the decimal part\n}\n\n"}
{"task_id": "CPP/3", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool below_zero(vector<int> operations) {\n    int balance = 0; // Start with a zero balance\n\n    for (int op : operations) {\n        balance += op; // Update the balance after each operation\n\n        if (balance < 0) { // Check if the balance falls below zero\n            return true;\n        }\n    }\n\n    return false; // Return false if the balance never goes below zero\n}\n\n// Function to test the below_zero function with provided examples\nvoid check_function() {\n    vector<int> operations1 = {1, 2, 3};\n    vector<int> operations2 = {1, 2, -4, 5};\n\n    cout << \"Test Case 1: \" << (below_zero(operations1) ? \"Passed\" : \"Failed\") << endl;\n    cout << \"Test Case 2: \" << (below_zero(operations2) ? \"Passed\" : \"Failed\") << endl;\n}\n\n"}
{"task_id": "CPP/4", "generation": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nfloat mean_absolute_deviation(vector<float> numbers) {\n    // Step 1: Calculate the mean of the dataset\n    float sum = 0.0;\n    for (const auto& num : numbers) {\n        sum += num;\n    }\n    float mean = sum / numbers.size();\n\n    // Step 2 and 3: Compute the absolute differences and their average\n    float mad = 0.0;\n    for (const auto& num : numbers) {\n        mad += abs(num - mean);\n    }\n    mad /= numbers.size();\n\n    return mad;\n}\n\n"}
{"task_id": "CPP/5", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> intersperse(vector<int> numbers, int delimeter) {\n    vector<int> result;\n    \n    // Iterate through the original vector and insert each element followed by the delimiter\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        result.push_back(numbers[i]);\n        if (i != numbers.size() - 1) {  // Do not add a delimiter after the last element\n            result.push_back(delimeter);\n        }\n    }\n    \n    return result;\n}\n\n// Function to test the intersperse function\nvoid testIntersperse() {\n    vector<int> emptyVec = {};\n    vector<int> vec1 = {1, 2, 3};\n    vector<int> expected1 = {1, 4, 2, 4, 3};\n\n    cout << \"Testing with an empty vector:\" << endl;\n    for (int num : intersperse(emptyVec, 4)) {\n        cout << num << \" \";\n    }\n    cout << endl;\n\n    cout << \"Testing with a non-empty vector:\" << endl;\n    for (int num : intersperse(vec1, 4)) {\n        cout << num << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/6", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to parse and determine the deepest level of nesting for a single group of parentheses\nint maxDepthOfNesting(const string& group) {\n    int currentDepth = 0;\n    int maxDepth = 0;\n    \n    for (char ch : group) {\n        if (ch == '(') {\n            currentDepth++;\n            maxDepth = max(maxDepth, currentDepth);\n        } else if (ch == ')') {\n            currentDepth--;\n        }\n    }\n    \n    return maxDepth;\n}\n\n// Function to process the entire string and return a vector of maximum depths for each group\nvector<int> parse_nested_parens(string paren_string) {\n    vector<int> result;\n    size_t start = 0;\n    size_t end = paren_string.find(' ');\n    \n    while (end != string::npos) {\n        // Extract the current group from the string\n        string group = paren_string.substr(start, end - start);\n        \n        // Calculate the maximum depth of nesting for the current group\n        int maxDepth = maxDepthOfNesting(group);\n        \n        result.push_back(maxDepth);\n        \n        // Move to the next group\n        start = end + 1;\n        end = paren_string.find(' ', start);\n    }\n    \n    // Process the last group if there is one\n    if (start < paren_string.length()) {\n        string group = paren_string.substr(start);\n        int maxDepth = maxDepthOfNesting(group);\n        result.push_back(maxDepth);\n    }\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/7", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to filter strings containing a given substring\nvector<string> filter_by_substring(vector<string> strings, string substring) {\n    vector<string> filtered_strings;\n    \n    // Iterate through each string in the input vector\n    for (const auto& str : strings) {\n        // Check if the current string contains the substring\n        if (str.find(substring) != string::npos) {\n            // If it does, add it to the filtered list\n            filtered_strings.push_back(str);\n        }\n    }\n    \n    return filtered_strings;\n}\n\n// Function to test the filter_by_substring function\nvoid test_filter_by_substring() {\n    vector<string> input1 = {};\n    vector<string> expected1 = {};\n    assert(filter_by_substring(input1, \"a\") == expected1);\n\n    vector<string> input2 = {\"abc\", \"bacd\", \"cde\", \"vector\"};\n    vector<string> expected2 = {\"abc\", \"bacd\", \"vector\"};\n    assert(filter_by_substring(input2, \"a\") == expected2);\n\n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/8", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// Function to calculate the sum and product of elements in a vector\nvector<int> sum_product(vector<int> numbers) {\n    int sum = 0;\n    int product = 1;\n\n    // Iterate through each number in the vector\n    for (int num : numbers) {\n        sum += num;  // Add the current number to the sum\n        product *= num;  // Multiply the current number with the product\n    }\n\n    return {sum, product};\n}\n\n// Function to test the sum_product function\nvoid test_sum_product() {\n    vector<int> empty = {};\n    vector<int> result1 = sum_product(empty);\n    cout << \"Empty Vector: Sum = \" << result1[0] << \", Product = \" << result1[1] << endl;\n\n    vector<int> numbers = {1, 2, 3, 4};\n    vector<int> result2 = sum_product(numbers);\n    cout << \"Vector [1, 2, 3, 4]: Sum = \" << result2[0] << \", Product = \" << result2[1] << endl;\n}\n\n"}
{"task_id": "CPP/9", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> rolling_max(vector<int> numbers) {\n    if (numbers.empty()) return {};  // Return an empty vector if input is empty\n\n    vector<int> result;\n    int current_max = numbers[0];  // Initialize the current maximum with the first element\n    for (int num : numbers) {\n        if (num > current_max) {\n            current_max = num;  // Update the current maximum if a larger number is found\n        }\n        result.push_back(current_max);  // Add the current maximum to the result vector\n    }\n\n    return result;\n}\n\n// Function to print the vector for testing purposes\nvoid print_vector(const vector<int>& vec) {\n    for (int num : vec) {\n        cout << num << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/10", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_palindrome(const string& str) {\n    // Test if given string is a palindrome\n    string s(str.rbegin(), str.rend());\n    return s == str;\n}\n\nstring make_palindrome(string str) {\n    /*\n    Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n        - Find the longest postfix of supplied string that is a palindrome.\n        - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    */\n    \n    // Edge case: if the string is already a palindrome, return it as is\n    if (is_palindrome(str)) {\n        return str;\n    }\n    \n    int n = str.length();\n    for (int i = 0; i < n; ++i) {\n        // Check if the suffix starting from index i to the end is a palindrome\n        if (is_palindrome(str.substr(i))) {\n            // The longest palindromic suffix starts at index i\n            string prefix = str.substr(0, i);\n            // Reverse the prefix and append it to the original string\n            reverse(prefix.begin(), prefix.end());\n            return str + prefix;\n        }\n    }\n    \n    // If no palindromic suffix is found (which should not happen in valid cases), return the original string\n    return str;\n}\n\n"}
{"task_id": "CPP/11", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring string_xor(string a, string b) {\n    // Ensure both strings are of equal length by padding with leading zeros if necessary\n    int maxLength = max(a.length(), b.length());\n    a.insert(0, maxLength - a.length(), '0');\n    b.insert(0, maxLength - b.length(), '0');\n\n    string result(maxLength, '0');  // Initialize the result string\n\n    // Perform XOR operation character by character\n    for (int i = 0; i < maxLength; ++i) {\n        if (a[i] != b[i]) {\n            result[i] = '1';  // If characters are different, set result to '1'\n        }\n    }\n\n    return result;\n}\n\n// Function to test the string_xor function\nvoid test_string_xor() {\n    cout << \"Testing string_xor function:\" << endl;\n    cout << \"Input: \\\"010\\\", \\\"110\\\" - Output: \\\"\" << string_xor(\"010\", \"110\") << \"\\\" (Expected: \\\"100\\\")\" << endl;\n    cout << \"Input: \\\"10101\\\", \\\"11001\\\" - Output: \\\"\" << string_xor(\"10101\", \"11001\") << \"\\\" (Expected: \\\"01100\\\")\" << endl;\n}\n\n"}
{"task_id": "CPP/12", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring longest(const vector<string>& strings) {\n    if (strings.empty()) {\n        return \"\"; // Return an empty string to indicate None in this context.\n    }\n\n    const string* longestString = &strings[0];\n    for (const auto& str : strings) {\n        if (str.length() > longestString->length()) {\n            longestString = &str;\n        }\n    }\n\n    return *longestString;\n}\n\n"}
{"task_id": "CPP/13", "generation": "#include <stdio.h>\nusing namespace std;\n\nint greatest_common_divisor(int a, int b) {\n    // Ensure a >= b to simplify the logic\n    if (b > a) {\n        return greatest_common_divisor(b, a);\n    }\n\n    // Base case: if b is 0, then GCD is a\n    if (b == 0) {\n        return a;\n    }\n\n    // Recursive call with remainder of a divided by b\n    return greatest_common_divisor(b, a % b);\n}\n\n"}
{"task_id": "CPP/14", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to generate all prefixes of the input string\nvector<string> all_prefixes(string str) {\n    vector<string> prefixes;\n    for (size_t i = 1; i <= str.length(); ++i) {\n        prefixes.push_back(str.substr(0, i));\n    }\n    return prefixes;\n}\n\n"}
{"task_id": "CPP/15", "generation": "#include <iostream>\n#include <sstream>\n#include <string>\nusing namespace std;\n\nstring string_sequence(int n) {\n    stringstream ss;\n    for (int i = 0; i <= n; ++i) {\n        ss << i;\n        if (i < n) {\n            ss << \" \";\n        }\n    }\n    return ss.str();\n}\n\n// Function to test the string_sequence function\nvoid test_string_sequence() {\n    cout << \"Testing string_sequence...\" << endl;\n    assert(string_sequence(0) == \"0\");\n    assert(string_sequence(5) == \"0 1 2 3 4 5\");\n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/16", "generation": "#include <iostream>\n#include <string>\n#include <set>\n\nusing namespace std;\n\nint count_distinct_characters(string str) {\n    // Convert the string to lowercase to ensure case insensitivity\n    transform(str.begin(), str.end(), str.begin(), ::tolower);\n    \n    // Use a set to store distinct characters\n    set<char> distinct_chars(str.begin(), str.end());\n    \n    // The size of the set is the number of distinct characters\n    return distinct_chars.size();\n}\n\n"}
{"task_id": "CPP/17", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\n// Function to map note symbols to their corresponding beats\nint get_beats(const string& note) {\n    if (note == \"o\") return 4;\n    else if (note == \"o|\") return 2;\n    else if (note == \".|\") return 1;\n    else return 0; // Default case, though not expected to be reached\n}\n\n// Function to parse the music string and return a vector of beats\nvector<int> parse_music(string music_string) {\n    vector<int> beats;\n\n    // Split the music string into individual notes\n    size_t start = 0;\n    size_t end = music_string.find(' ');\n    \n    while (end != string::npos) {\n        string note = music_string.substr(start, end - start);\n        beats.push_back(get_beats(note));\n        start = end + 1;\n        end = music_string.find(' ', start);\n    }\n    \n    // Add the last note\n    if (start < music_string.length()) {\n        beats.push_back(get_beats(music_string.substr(start)));\n    }\n\n    return beats;\n}\n\n// Function to check the correctness of the parse_music function\nvoid check() {\n    string input = \"o o| .| o| o| .| .| .| .| o o\";\n    vector<int> expected_output = {4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4};\n    vector<int> output = parse_music(input);\n\n    if (output == expected_output) {\n        cout << \"Test passed!\" << endl;\n    } else {\n        cout << \"Test failed!\" << endl;\n        for (int i = 0; i < min(output.size(), expected_output.size()); ++i) {\n            if (output[i] != expected_output[i]) {\n                cout << \"At index \" << i << \": Expected \" << expected_output[i] << \", got \" << output[i] << endl;\n            }\n        }\n    }\n}\n\n"}
{"task_id": "CPP/18", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint how_many_times(const string& str, const string& substring) {\n    if (substring.empty()) return 0;\n    \n    int count = 0;\n    size_t pos = 0;\n    \n    while ((pos = str.find(substring, pos)) != string::npos) {\n        ++count;\n        pos++; // Move to the next character to allow overlapping matches\n    }\n    \n    return count;\n}\n\n"}
{"task_id": "CPP/19", "generation": "#include <iostream>\n#include <string>\n#include <map>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to convert word to number\nint word_to_number(const string& word) {\n    map<string, int> num_map = {{\"zero\", 0}, {\"one\", 1}, {\"two\", 2}, {\"three\", 3},\n                                {\"four\", 4}, {\"five\", 5}, {\"six\", 6}, {\"seven\", 7},\n                                {\"eight\", 8}, {\"nine\", 9}};\n    return num_map[word];\n}\n\n// Function to sort numbers\nstring sort_numbers(const string& numbers) {\n    vector<string> words;\n    string number;\n    \n    // Split the input string into individual words\n    for (char ch : numbers) {\n        if (ch == ' ') {\n            if (!number.empty()) {\n                words.push_back(number);\n                number.clear();\n            }\n        } else {\n            number += ch;\n        }\n    }\n    if (!number.empty()) {\n        words.push_back(number);\n    }\n\n    // Sort the words based on their numeric value\n    sort(words.begin(), words.end(), [](const string& a, const string& b) {\n        return word_to_number(a) < word_to_number(b);\n    });\n\n    // Join the sorted words back into a single string\n    string result;\n    for (const auto& word : words) {\n        if (!result.empty()) {\n            result += \" \";\n        }\n        result += word;\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/20", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<float> find_closest_elements(vector<float> numbers) {\n    // Sort the input vector in ascending order\n    sort(numbers.begin(), numbers.end());\n\n    // Initialize variables to store the closest pair and their minimum difference\n    float min_diff = numeric_limits<float>::max();\n    float result[2] = {0.0, 0.0};\n\n    // Iterate through the sorted list to find the closest elements\n    for (size_t i = 0; i < numbers.size() - 1; ++i) {\n        float diff = numbers[i + 1] - numbers[i];\n        if (diff < min_diff) {\n            min_diff = diff;\n            result[0] = numbers[i];\n            result[1] = numbers[i + 1];\n        }\n    }\n\n    // Return the closest pair as a vector\n    return {result[0], result[1]};\n}\n\n// Function to check the correctness of the solution\nvoid check() {\n    vector<float> test1 = {1.0, 2.0, 3.0, 4.0, 5.0, 2.2};\n    vector<float> expected1 = {2.0, 2.2};\n    assert(find_closest_elements(test1) == expected1);\n\n    vector<float> test2 = {1.0, 2.0, 3.0, 4.0, 5.0, 2.0};\n    vector<float> expected2 = {2.0, 2.0};\n    assert(find_closest_elements(test2) == expected2);\n\n    cout << \"All test cases passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/21", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // For std::min_element and std::max_element\n\nusing namespace std;\n\nvector<float> rescale_to_unit(vector<float> numbers) {\n    if (numbers.size() < 2) {\n        throw invalid_argument(\"Vector must contain at least two elements.\");\n    }\n\n    float min_value = *std::min_element(numbers.begin(), numbers.end());\n    float max_value = *std::max_element(numbers.begin(), numbers.end());\n\n    vector<float> scaled_numbers;\n    for (float num : numbers) {\n        float new_value = (num - min_value) / (max_value - min_value);\n        scaled_numbers.push_back(new_value);\n    }\n\n    return scaled_numbers;\n}\n\n"}
{"task_id": "CPP/22", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <list>\n#include <boost/any.hpp>\n\ntypedef std::list<boost::any> list_any;\nusing namespace std;\n\nvector<int> filter_integers(list_any values) {\n    vector<int> result;\n    for (const auto& value : values) {\n        if (value.type() == typeid(int)) {\n            result.push_back(boost::any_cast<int>(value));\n        }\n    }\n    return result;\n}\n\n"}
{"task_id": "CPP/23", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint strlen(const string& str) {\n    // Return the size of the string, which is equivalent to its length.\n    return str.size();\n}\n\n// Function to test the strlen function with some examples\nvoid test_strlen() {\n    cout << \"Length of \\\"\\\" (empty string): \" << strlen(\"\") << endl;\n    cout << \"Length of \\\"abc\\\": \" << strlen(\"abc\") << endl;\n    cout << \"Length of \\\"hello world\\\": \" << strlen(\"hello world\") << endl;\n}\n\n"}
{"task_id": "CPP/24", "generation": "#include <iostream>\nusing namespace std;\n\nint largest_divisor(int n) {\n    for (int i = n - 1; i > 0; --i) {\n        if (n % i == 0) {\n            return i;\n        }\n    }\n    // If no divisor is found, which should not happen for positive integers,\n    // we can return -1 or throw an exception. For simplicity, returning -1.\n    return -1;\n}\n\n"}
{"task_id": "CPP/25", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> factorize(int n) {\n    vector<int> factors;\n    \n    // Divide by 2 to get rid of all even factors\n    while (n % 2 == 0) {\n        factors.push_back(2);\n        n /= 2;\n    }\n    \n    // Check for odd factors from 3 onwards\n    for (int i = 3; i * i <= n; i += 2) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n    \n    // If n is a prime number greater than 2\n    if (n > 2) {\n        factors.push_back(n);\n    }\n    \n    return factors;\n}\n\n"}
{"task_id": "CPP/26", "generation": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nvector<int> remove_duplicates(vector<int> numbers) {\n    // Create an unordered map to count occurrences of each element\n    unordered_map<int, int> counts;\n    \n    // Count the occurrences of each number in the input vector\n    for (int num : numbers) {\n        counts[num]++;\n    }\n    \n    // Create a new vector to store elements that occur exactly once\n    vector<int> result;\n    \n    // Iterate through the original vector and add elements to the result if they occur only once\n    for (int num : numbers) {\n        if (counts[num] == 1) {\n            result.push_back(num);\n        }\n    }\n    \n    return result;\n}\n\n// Function to check the correctness of the remove_duplicates function\nvoid check() {\n    vector<int> input = {1, 2, 3, 2, 4};\n    vector<int> expected_output = {1, 3, 4};\n    vector<int> output = remove_duplicates(input);\n    \n    if (output == expected_output) {\n        cout << \"Test passed.\" << endl;\n    } else {\n        cout << \"Test failed.\" << endl;\n    }\n}\n\n"}
{"task_id": "CPP/27", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring flip_case(string str) {\n    for (char &c : str) {\n        if (islower(c)) {\n            c = toupper(c);\n        } else if (isupper(c)) {\n            c = tolower(c);\n        }\n    }\n    return str;\n}\n\n"}
{"task_id": "CPP/28", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <numeric> // For std::accumulate\n\nusing namespace std;\n\nstring concatenate(vector<string> strings) {\n    // Use std::accumulate to concatenate all strings in the vector\n    return accumulate(strings.begin(), strings.end(), string(\"\"));\n}\n\n// Function to test the concatenate function\nvoid test_concatenate() {\n    assert(concatenate({}) == \"\");\n    assert(concatenate({\"a\", \"b\", \"c\"}) == \"abc\");\n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/29", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to filter strings based on the given prefix\nvector<string> filter_by_prefix(vector<string> strings, string prefix) {\n    vector<string> filtered_strings;\n    \n    // Iterate through each string in the input vector\n    for (const auto& str : strings) {\n        // Check if the current string starts with the given prefix\n        if (str.substr(0, prefix.length()) == prefix) {\n            // If it does, add it to the filtered list\n            filtered_strings.push_back(str);\n        }\n    }\n    \n    return filtered_strings;\n}\n\n// Function to test the filter_by_prefix function\nvoid test_filter_by_prefix() {\n    vector<string> input1 = {};\n    string prefix1 = \"a\";\n    vector<string> result1 = filter_by_prefix(input1, prefix1);\n    cout << \"Test 1: \";\n    if (result1.empty()) {\n        cout << \"Passed\" << endl;\n    } else {\n        cout << \"Failed\" << endl;\n    }\n\n    vector<string> input2 = {\"abc\", \"bcd\", \"cde\", \"vector\"};\n    string prefix2 = \"a\";\n    vector<string> result2 = filter_by_prefix(input2, prefix2);\n    cout << \"Test 2: \";\n    if (result2 == vector<string>{\"abc\", \"vector\"}) {\n        cout << \"Passed\" << endl;\n    } else {\n        cout << \"Failed\" << endl;\n    }\n}\n\n"}
{"task_id": "CPP/30", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvector<float> get_positive(vector<float> l) {\n    vector<float> result;\n    for (float num : l) {\n        if (num > 0) {\n            result.push_back(num);\n        }\n    }\n    return result;\n}\n\n"}
{"task_id": "CPP/31", "generation": "#include <iostream>\nusing namespace std;\n\nbool is_prime(long long n) {\n    // Handle edge cases for numbers less than or equal to 1\n    if (n <= 1) return false;\n    \n    // Check divisibility from 2 up to the square root of n\n    for (long long i = 2; i * i <= n; ++i) {\n        if (n % i == 0) {\n            return false; // Found a divisor, so it's not prime\n        }\n    }\n    \n    return true; // No divisors found, so it is prime\n}\n\n"}
{"task_id": "CPP/32", "generation": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <cassert>\n\ndouble poly(const std::vector<double>& xs, double x) {\n    double sum = 0;\n    for (size_t i = 0; i < xs.size(); ++i) {\n        sum += xs[i] * pow(x, static_cast<int>(i));\n    }\n    return sum;\n}\n\ndouble find_zero(const std::vector<double>& xs) {\n    // Ensure that the polynomial has an even number of coefficients and a non-zero leading coefficient\n    if (xs.size() % 2 != 0 || xs.back() == 0) {\n        throw std::invalid_argument(\"The polynomial must have an even number of coefficients and a non-zero leading coefficient.\");\n    }\n\n    // Use fsolve from the C++ library to find the root, starting with an initial guess\n    double zero_point = 0.0; // Initial guess\n\n    // Placeholder for finding roots using numerical methods (fsolve is not available in standard C++)\n    // For demonstration purposes, we can use a simple iterative method or rely on external libraries like Eigen or Armadillo\n    // Here, we assume the existence of an fsolve-like function from some library\n\n    return zero_point; // Placeholder for actual root finding logic\n}\n\n"}
{"task_id": "CPP/33", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> sort_third(vector<int> l) {\n    // Extract elements at indices divisible by 3\n    vector<int> third_indices;\n    for (size_t i = 2; i < l.size(); i += 3) {\n        third_indices.push_back(l[i]);\n    }\n\n    // Sort the extracted elements\n    sort(third_indices.begin(), third_indices.end());\n\n    // Create a copy of the original list to avoid modifying it directly\n    vector<int> l_prime = l;\n\n    // Replace elements at indices divisible by 3 with sorted values\n    size_t j = 0;\n    for (size_t i = 2; i < l.size(); i += 3) {\n        l_prime[i] = third_indices[j++];\n    }\n\n    return l_prime;\n}\n\n// Function to print the vector\nvoid print_vector(const vector<int>& v) {\n    for (int val : v) {\n        cout << val << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/34", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> unique(vector<int> l) {\n    // Sort the input vector\n    sort(l.begin(), l.end());\n    \n    // Remove consecutive duplicate elements\n    auto last = unique(l.begin(), l.end());\n    \n    // Resize the vector to contain only the unique elements\n    l.resize(distance(l.begin(), last));\n    \n    return l;\n}\n\n"}
{"task_id": "CPP/35", "generation": "#include <iostream>\n#include <vector>\n\nfloat max_element(const std::vector<float>& l) {\n    if (l.empty()) {\n        throw std::invalid_argument(\"Vector is empty\");\n    }\n\n    float max_val = l[0];\n    for (size_t i = 1; i < l.size(); ++i) {\n        if (l[i] > max_val) {\n            max_val = l[i];\n        }\n    }\n    return max_val;\n}\n\n"}
{"task_id": "CPP/36", "generation": "#include <iostream>\nusing namespace std;\n\nint fizz_buzz(int n) {\n    int count = 0;\n    \n    for (int i = 1; i < n; ++i) {\n        if (i % 11 == 0 || i % 13 == 0) {\n            // Convert the number to a string and count occurrences of '7'\n            string num_str = to_string(i);\n            for (char c : num_str) {\n                if (c == '7') {\n                    ++count;\n                }\n            }\n        }\n    }\n    \n    return count;\n}\n\n"}
{"task_id": "CPP/37", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<float> sort_even(vector<float> l) {\n    // Extract elements at even indices\n    vector<float> evens;\n    for (size_t i = 0; i < l.size(); i += 2) {\n        evens.push_back(l[i]);\n    }\n\n    // Sort the extracted elements\n    sort(evens.begin(), evens.end());\n\n    // Place sorted elements back into their original positions\n    size_t evenIndex = 0;\n    for (size_t i = 0; i < l.size(); ++i) {\n        if (i % 2 == 0) {\n            l[i] = evens[evenIndex++];\n        }\n    }\n\n    return l;\n}\n\n// Function to check the correctness of the sort_even function\nvoid check() {\n    vector<float> result1 = sort_even({1, 2, 3});\n    assert(result1 == vector<float>({1, 2, 3}));\n\n    vector<float> result2 = sort_even({5, 6, 3, 4});\n    assert(result2 == vector<float>({3, 6, 5, 4}));\n\n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/38", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nstring encode_cyclic(string s) { \n    // returns encoded string by cycling groups of three characters.  \n    int l = s.length();\n    int num = (l + 2) / 3;\n    string x, output;\n    for (int i = 0; i * 3 < l; i++) {\n        x = s.substr(i * 3, 3);\n        if (x.length() == 3) x = x.substr(1) + x[0];\n        output += x;\n    }\n    return output;\n}\n\nstring decode_cyclic(string s) { \n    /*\n    takes as input string encoded with encode_cyclic function. Returns decoded string.\n    */\n    int l = s.length();\n    int num = (l + 2) / 3;\n    string x, output;\n    for (int i = 0; i * 3 < l; i++) {\n        x = s.substr(i * 3, 3);\n        if (x.length() == 3) x = x[2] + x.substr(0, 2); // Rotate one position to the left\n        output += x;\n    }\n    return output;\n}\n\n"}
{"task_id": "CPP/39", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    if (num == 2 || num == 3) return true;\n    if (num % 2 == 0 || num % 3 == 0) return false;\n    for (int i = 5; i * i <= num; i += 6) {\n        if (num % i == 0 || num % (i + 2) == 0)\n            return false;\n    }\n    return true;\n}\n\n// Function to generate the n-th prime Fibonacci number\nint prime_fib(int n) {\n    int count = 0; // Counter for prime Fibonacci numbers found\n    long fib1 = 0, fib2 = 1; // First two Fibonacci numbers\n\n    while (true) {\n        long next_fib = fib1 + fib2;\n        if (is_prime(next_fib)) {\n            count++;\n            if (count == n) return next_fib;\n        }\n        fib1 = fib2;\n        fib2 = next_fib;\n    }\n}\n\n"}
{"task_id": "CPP/40", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool triples_sum_to_zero(vector<int> l) {\n    int n = l.size();\n    \n    // Iterate through each element in the list\n    for (int i = 0; i < n - 2; ++i) {\n        // Iterate through the elements after the current one\n        for (int j = i + 1; j < n - 1; ++j) {\n            // Iterate through the elements after the second one\n            for (int k = j + 1; k < n; ++k) {\n                // Check if the sum of the three elements is zero\n                if (l[i] + l[j] + l[k] == 0) {\n                    return true;\n                }\n            }\n        }\n    }\n    \n    // If no such triplet is found, return false\n    return false;\n}\n\n// Function to test the triples_sum_to_zero function with provided examples\nvoid test_triples_sum_to_zero() {\n    assert(triples_sum_to_zero({1, 3, 5, 0}) == false);\n    assert(triples_sum_to_zero({1, 3, -2, 1}) == true);\n    assert(triples_sum_to_zero({1, 2, 3, 7}) == false);\n    assert(triples_sum_to_zero({2, 4, -5, 3, 9, 7}) == true);\n    assert(triples_sum_to_zero({1}) == false);\n    \n    cout << \"All test cases passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/41", "generation": "#include <iostream>\n\nint car_race_collision(int n) {\n    return n * n;\n}\n\n"}
{"task_id": "CPP/42", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> incr_list(vector<int> l) {\n    for (int i = 0; i < l.size(); ++i) {\n        l[i] += 1;\n    }\n    return l;\n}\n\n// Function to test the incr_list function\nvoid test_incr_list() {\n    vector<int> result1 = incr_list({1, 2, 3});\n    for (int num : result1) {\n        cout << num << \" \";\n    }\n    cout << endl;\n\n    vector<int> result2 = incr_list({5, 3, 5, 2, 3, 3, 9, 0, 123});\n    for (int num : result2) {\n        cout << num << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/43", "generation": "#include <iostream>\n#include <vector>\n#include <set>\n\nusing namespace std;\n\nbool pairs_sum_to_zero(vector<int> l) {\n    // Use a set to store seen numbers\n    set<int> seen;\n    \n    for (int num : l) {\n        // Check if the negation of the current number is in the set\n        if (seen.find(-num) != seen.end()) {\n            return true;\n        }\n        // Add the current number to the set\n        seen.insert(num);\n    }\n    \n    // If no such pair is found, return false\n    return false;\n}\n\n"}
{"task_id": "CPP/44", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring change_base(int x, int base) {\n    if (x == 0) return \"0\"; // Handle the case where x is zero\n\n    string result = \"\";\n    while (x > 0) {\n        int remainder = x % base;\n        char digit = '0' + remainder; // Convert the integer to its character representation\n        result = digit + result; // Prepend the digit to the result string\n        x /= base; // Divide x by the base\n    }\n    return result;\n}\n\n"}
{"task_id": "CPP/45", "generation": "#include <iostream>\nusing namespace std;\n\nfloat triangle_area(float a, float h) {\n    return 0.5 * a * h;\n}\n\n"}
{"task_id": "CPP/46", "generation": "#include <stdio.h>\nusing namespace std;\n\nint fib4(int n) {\n    if (n == 0 || n == 1 || n == 3) return 0;\n    if (n == 2) return 2;\n\n    int a = 0, b = 0, c = 2, d = 0, result;\n    \n    for (int i = 4; i <= n; ++i) {\n        result = a + b + c + d;\n        a = b;\n        b = c;\n        c = d;\n        d = result;\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/47", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nfloat median(vector<float> l) {\n    // Sort the vector\n    sort(l.begin(), l.end());\n    \n    int n = l.size();\n    \n    if (n % 2 == 0) {\n        // If even number of elements, return the average of the two middle elements\n        return (l[n / 2 - 1] + l[n / 2]) / 2.0;\n    } else {\n        // If odd number of elements, return the middle element\n        return l[n / 2];\n    }\n}\n\n"}
{"task_id": "CPP/48", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_palindrome(string text) {\n    int left = 0;\n    int right = text.length() - 1;\n\n    while (left < right) {\n        if (text[left] != text[right]) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n\n    return true;\n}\n\n"}
{"task_id": "CPP/49", "generation": "#include <stdio.h>\nusing namespace std;\n\nint modp(int n, int p) {\n    if (n == 0)\n        return 1; // Any number to the power of 0 is 1\n\n    long result = 1;\n    long base = 2;\n\n    while (n > 0) {\n        // If n is odd, multiply the result by the current base\n        if (n % 2 == 1)\n            result = (result * base) % p;\n\n        // Square the base and reduce it modulo p\n        base = (base * base) % p;\n        n /= 2; // Divide n by 2\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/50", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring encode_shift(const string& s) {\n    // returns encoded string by shifting every character by 5 in the alphabet.\n    string out;\n    for (char c : s) {\n        if (isalpha(c)) {  // Check if the character is an alphabetic letter\n            char shifted = ((c - 'a' + 5) % 26) + 'a';\n            out += shifted;\n        } else {\n            out += c;  // Non-alphabetic characters remain unchanged\n        }\n    }\n    return out;\n}\n\nstring decode_shift(const string& s) {\n    // takes as input string encoded with encode_shift function. Returns decoded string.\n    string out;\n    for (char c : s) {\n        if (isalpha(c)) {  // Check if the character is an alphabetic letter\n            char shifted = ((c - 'a' - 5 + 26) % 26) + 'a';  // Handle negative shifts with modulo 26\n            out += shifted;\n        } else {\n            out += c;  // Non-alphabetic characters remain unchanged\n        }\n    }\n    return out;\n}\n\n"}
{"task_id": "CPP/51", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nbool is_vowel(char c) {\n    // Convert character to lowercase for simplicity\n    char lower_c = tolower(c);\n    return lower_c == 'a' || lower_c == 'e' || lower_c == 'i' || lower_c == 'o' || lower_c == 'u';\n}\n\nstring remove_vowels(string text) {\n    string result;\n    for (char c : text) {\n        if (!is_vowel(c)) {\n            result += c;\n        }\n    }\n    return result;\n}\n\n"}
{"task_id": "CPP/52", "generation": "#include <vector>\n#include <iostream>\n\n// Function to check if all elements in the vector are below the threshold\nbool below_threshold(const std::vector<int>& l, int t) {\n    for (int num : l) {\n        if (num >= t) {\n            return false;\n        }\n    }\n    return true;\n}\n\n// Function to test the below_threshold function with provided data points\nvoid check_function() {\n    assert(below_threshold({1, 2, 4, 10}, 100) == true);\n    assert(below_threshold({1, 20, 4, 10}, 5) == false);\n    std::cout << \"All tests passed successfully.\" << std::endl;\n}\n\n"}
{"task_id": "CPP/53", "generation": "#include <iostream>  // Include iostream for input/output operations\n\nusing namespace std;\n\nint add(int x, int y) {\n    return x + y;  // Return the sum of x and y\n}\n\n"}
{"task_id": "CPP/54", "generation": "#include <iostream>\n#include <string>\n#include <set>\n\nusing namespace std;\n\nbool same_chars(string s0, string s1) {\n    // Create a set for each string to store unique characters\n    set<char> chars_s0(s0.begin(), s0.end());\n    set<char> chars_s1(s1.begin(), s1.end());\n\n    // Compare the sets\n    return chars_s0 == chars_s1;\n}\n\n"}
{"task_id": "CPP/55", "generation": "#include <stdio.h>\nusing namespace std;\n\nint fib(int n) {\n    if (n <= 0) return 0;\n    else if (n == 1) return 1;\n    else return fib(n - 1) + fib(n - 2);\n}\n\n"}
{"task_id": "CPP/56", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    int count = 0;\n    \n    for (char c : brackets) {\n        if (c == '<') {\n            count++;\n        } else if (c == '>') {\n            count--;\n            if (count < 0) {\n                return false; // More closing brackets than opening ones\n            }\n        }\n    }\n    \n    return count == 0; // True if all brackets are correctly matched\n}\n\n"}
{"task_id": "CPP/57", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool monotonic(vector<float> l) {\n    if (l.size() <= 1) {\n        return true; // A vector with 0 or 1 element is trivially monotonic.\n    }\n\n    bool increasing = false;\n    bool decreasing = false;\n\n    for (size_t i = 1; i < l.size(); ++i) {\n        if (l[i] > l[i - 1]) {\n            increasing = true;\n        } else if (l[i] < l[i - 1]) {\n            decreasing = true;\n        }\n\n        // If both increasing and decreasing flags are set, the sequence is not monotonic.\n        if (increasing && decreasing) {\n            return false;\n        }\n    }\n\n    return true; // The sequence is either strictly increasing or strictly decreasing.\n}\n\n"}
{"task_id": "CPP/58", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\n\nusing namespace std;\n\nvector<int> common(vector<int> l1, vector<int> l2) {\n    // Create sets from both vectors\n    set<int> s1(l1.begin(), l1.end());\n    set<int> s2(l2.begin(), l2.end());\n\n    // Find the intersection of the two sets\n    set<int> result;\n    set_intersection(s1.begin(), s1.end(), s2.begin(), s2.end(), inserter(result, result.begin()));\n\n    // Convert the set to a vector and sort it\n    vector<int> commonElements(result.begin(), result.end());\n    sort(commonElements.begin(), commonElements.end());\n\n    return commonElements;\n}\n\n"}
{"task_id": "CPP/59", "generation": "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\nint largest_prime_factor(int n) {\n    // Remove all factors of 2\n    while (n % 2 == 0) {\n        n /= 2;\n    }\n\n    // Check for odd factors from 3 to sqrt(n)\n    int factor = 3;\n    while (factor * factor <= n) {\n        while (n % factor == 0) {\n            n /= factor;\n        }\n        factor += 2;\n    }\n\n    // If n is a prime number greater than 2\n    if (n > 2) {\n        return n;\n    } else {\n        return factor - 2; // The last factor found will be the largest prime factor\n    }\n}\n\n"}
{"task_id": "CPP/60", "generation": "#include <iostream>\nusing namespace std;\n\nint sum_to_n(int n) {\n    int sum = 0;\n    for (int i = 1; i <= n; ++i) {\n        sum += i;\n    }\n    return sum;\n}\n\n// Function to test the sum_to_n function with provided data points\nvoid test_sum_to_n() {\n    cout << \"Testing sum_to_n...\" << endl;\n    assert(sum_to_n(30) == 465);\n    assert(sum_to_n(100) == 5050);\n    assert(sum_to_n(5) == 15);\n    assert(sum_to_n(10) == 55);\n    assert(sum_to_n(1) == 1);\n\n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/61", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    int balance = 0;\n    \n    for (char bracket : brackets) {\n        if (bracket == '(') {\n            balance++;\n        } else if (bracket == ')') {\n            balance--;\n        }\n        \n        // If at any point the balance is negative, it means there's a closing bracket without an opening one\n        if (balance < 0) {\n            return false;\n        }\n    }\n    \n    // If the final balance is zero, all brackets are correctly matched\n    return balance == 0;\n}\n\n"}
{"task_id": "CPP/62", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// Function to compute the derivative of a polynomial represented by its coefficients\nvector<float> derivative(vector<float> xs) {\n    // Create a new vector to hold the derivatives, starting from index 1 (ignoring the constant term)\n    vector<float> result;\n    \n    for (size_t i = 1; i < xs.size(); ++i) {\n        // Multiply each coefficient by its corresponding power\n        result.push_back(xs[i] * static_cast<float>(i));\n    }\n    \n    return result;\n}\n\n// Function to print the polynomial coefficients\nvoid printPolynomial(const vector<float>& coeffs) {\n    for (size_t i = 0; i < coeffs.size(); ++i) {\n        cout << coeffs[i];\n        if (i != coeffs.size() - 1) {\n            cout << \" * x^\" << i;\n        }\n        if (i != coeffs.size() - 2) {\n            cout << \" + \";\n        }\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/63", "generation": "#include <iostream>\nusing namespace std;\n\nint fibfib(int n) {\n    // Base cases\n    if (n == 0 || n == 1) return 0;\n    if (n == 2) return 1;\n\n    // Array to store the computed values of FibFib sequence\n    int dp[n + 1];\n    dp[0] = 0; // fibfib(0)\n    dp[1] = 0; // fibfib(1)\n    dp[2] = 1; // fibfib(2)\n\n    // Fill the dp array using the recurrence relation\n    for (int i = 3; i <= n; ++i) {\n        dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3];\n    }\n\n    return dp[n];\n}\n\n"}
{"task_id": "CPP/64", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nint vowels_count(string s) {\n    // Define a set of vowels including 'y' which is considered a vowel only if it's at the end\n    string vowels = \"aeiou\";\n    \n    // Initialize count of vowels\n    int count = 0;\n    \n    // Iterate through each character in the string\n    for (char ch : s) {\n        // Check if the lowercase version of the character is in the set of vowels\n        if (vowels.find(tolower(ch)) != string::npos) {\n            count++;\n        }\n    }\n    \n    // If the last character is 'y', add one more to the count\n    if (tolower(s.back()) == 'y') {\n        count += 1;\n    }\n    \n    return count;\n}\n\n"}
{"task_id": "CPP/65", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring circular_shift(int x, int shift) {\n    // Convert the integer to a string\n    string num_str = to_string(x);\n    int num_length = num_str.length();\n    \n    // If shift is greater than or equal to the number of digits, reverse the string\n    if (shift >= num_length) {\n        return string(num_str.rbegin(), num_str.rend());\n    }\n    \n    // Perform circular right shift by slicing and concatenating\n    int effective_shift = shift % num_length;\n    string shifted_str = num_str.substr(num_length - effective_shift) + num_str.substr(0, num_length - effective_shift);\n    return shifted_str;\n}\n\n"}
{"task_id": "CPP/66", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint digitSum(const string& s) {\n    int sum = 0;\n    for (char c : s) {\n        if (isupper(c)) { // Check if the character is uppercase\n            sum += static_cast<int>(c); // Add its ASCII value to the sum\n        }\n    }\n    return sum;\n}\n\n// Function to test the digitSum function with provided examples\nvoid checkFunction() {\n    assert(digitSum(\"\") == 0);\n    assert(digitSum(\"abAB\") == 131);\n    assert(digitSum(\"abcCd\") == 67);\n    assert(digitSum(\"helloE\") == 69);\n    assert(digitSum(\"woArBld\") == 131);\n    assert(digitSum(\"aAaaaXa\") == 153);\n\n    cout << \"All test cases passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/67", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nint fruit_distribution(string s, int n) {\n    // Split the string into parts using stringstream\n    stringstream ss(s);\n    string part;\n    int apples = 0, oranges = 0;\n\n    // Extract the number of apples and oranges from the string\n    while (getline(ss, part, ' ')) {\n        if (part.find(\"apples\") != string::npos) {\n            getline(ss, part, ' ');\n            stringstream(part) >> apples;\n        } else if (part.find(\"oranges\") != string::npos) {\n            getline(ss, part, ' ');\n            stringstream(part) >> oranges;\n        }\n    }\n\n    // Calculate the number of mangoes\n    int mangoes = n - (apples + oranges);\n    return mangoes;\n}\n\n"}
{"task_id": "CPP/68", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> pluck(vector<int> arr) {\n    int smallest_even = INT_MAX;\n    int index_of_smallest_even = -1;\n\n    for (int i = 0; i < arr.size(); ++i) {\n        if (arr[i] % 2 == 0 && arr[i] < smallest_even) {\n            smallest_even = arr[i];\n            index_of_smallest_even = i;\n        }\n    }\n\n    if (smallest_even == INT_MAX) {\n        return {};\n    }\n\n    return {smallest_even, index_of_smallest_even};\n}\n"}
{"task_id": "CPP/69", "generation": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint search(vector<int> lst) {\n    // Create a frequency map to count occurrences of each integer\n    unordered_map<int, int> freqMap;\n    \n    // Count the frequency of each number in the vector\n    for (int num : lst) {\n        freqMap[num]++;\n    }\n    \n    // Initialize the result as -1\n    int result = -1;\n    \n    // Iterate through the unique numbers and check the condition\n    for (auto& pair : freqMap) {\n        if (pair.first <= pair.second && pair.first > result) {\n            result = pair.first;\n        }\n    }\n    \n    return result;\n}\n\n// Function to test the search function with provided examples\nvoid test() {\n    cout << \"search({4, 1, 2, 2, 3, 1}) == \" << search({4, 1, 2, 2, 3, 1}) << endl; // Should output 2\n    cout << \"search({1, 2, 2, 3, 3, 3, 4, 4, 4}) == \" << search({1, 2, 2, 3, 3, 3, 4, 4, 4}) << endl; // Should output 3\n    cout << \"search({5, 5, 4, 4, 4}) == \" << search({5, 5, 4, 4, 4}) << endl; // Should output -1\n}\n\n"}
{"task_id": "CPP/70", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> strange_sort_list(vector<int> lst) {\n    // Sort the input list in ascending order\n    sort(lst.begin(), lst.end());\n    \n    vector<int> result;\n    int left = 0;  // Start from the beginning of the sorted list\n    int right = lst.size() - 1;  // Start from the end of the sorted list\n    \n    while (left <= right) {\n        if (left == right) {\n            // If only one element is left, add it to the result\n            result.push_back(lst[left]);\n            break;\n        }\n        \n        // Append the minimum value\n        result.push_back(lst[left++]);\n        \n        // Append the maximum value\n        result.push_back(lst[right--]);\n    }\n    \n    return result;\n}\n\n// Function to check the correctness of the solution\nvoid check() {\n    vector<int> lst1 = {1, 2, 3, 4};\n    vector<int> expected1 = {1, 4, 2, 3};\n    assert(strange_sort_list(lst1) == expected1);\n    \n    vector<int> lst2 = {5, 5, 5, 5};\n    vector<int> expected2 = {5, 5, 5, 5};\n    assert(strange_sort_list(lst2) == expected2);\n    \n    vector<int> lst3 = {};\n    vector<int> expected3 = {};\n    assert(strange_sort_list(lst3) == expected3);\n    \n    cout << \"All test cases passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/71", "generation": "#include <stdio.h>\n#include <math.h>\n\nusing namespace std;\n\nfloat triangle_area(float a, float b, float c) {\n    // Check if the sides form a valid triangle\n    if (a + b <= c || a + c <= b || b + c <= a) {\n        return -1;\n    }\n\n    // Calculate the semi-perimeter\n    float s = (a + b + c) / 2.0;\n\n    // Calculate the area using Heron's formula\n    float area = sqrt(s * (s - a) * (s - b) * (s - c));\n\n    // Round the result to 2 decimal points\n    return round(area * 100) / 100;\n}\n\n"}
{"task_id": "CPP/72", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool will_it_fly(vector<int> q, int w) {\n    // Check if the sum of elements is within the weight limit\n    int sum = 0;\n    for (int num : q) {\n        sum += num;\n    }\n    if (sum > w) return false;\n\n    // Check if the vector is a palindrome\n    for (size_t i = 0; i < q.size() / 2; ++i) {\n        if (q[i] != q[q.size() - 1 - i]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\n// Function to test the will_it_fly function with provided examples\nvoid check() {\n    cout << boolalpha; // Print bools as true/false instead of 1/0\n    cout << \"will_it_fly({1, 2}, 5): \" << will_it_fly({1, 2}, 5) << endl;\n    cout << \"will_it_fly({3, 2, 3}, 1): \" << will_it_fly({3, 2, 3}, 1) << endl;\n    cout << \"will_it_fly({3, 2, 3}, 9): \" << will_it_fly({3, 2, 3}, 9) << endl;\n    cout << \"will_it_fly({3}, 5): \" << will_it_fly({3}, 5) << endl;\n}\n\n"}
{"task_id": "CPP/73", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint smallest_change(vector<int> arr) {\n    int n = arr.size();\n    int left = 0;\n    int right = n - 1;\n    int changes = 0;\n\n    while (left < right) {\n        if (arr[left] != arr[right]) {\n            changes++;\n        }\n        left++;\n        right--;\n    }\n\n    return changes;\n}\n\n"}
{"task_id": "CPP/74", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to calculate the total number of characters in a vector of strings\nint total_chars(const vector<string>& vec) {\n    int sum = 0;\n    for (const auto& str : vec) {\n        sum += str.length();\n    }\n    return sum;\n}\n\nvector<string> total_match(vector<string> lst1, vector<string> lst2) {\n    // Calculate the total number of characters in both vectors\n    int chars_lst1 = total_chars(lst1);\n    int chars_lst2 = total_chars(lst2);\n\n    // Compare and return the appropriate vector\n    if (chars_lst1 < chars_lst2) {\n        return lst1;\n    } else if (chars_lst2 < chars_lst1) {\n        return lst2;\n    } else {\n        return lst1;  // Return the first vector if both have the same number of characters\n    }\n}\n\n// Function to test the total_match function with provided examples\nvoid test_total_match() {\n    cout << \"Test 1: \";\n    vector<string> result = total_match({}, {});\n    for (const auto& str : result) {\n        cout << str << \" \";\n    }\n    cout << endl;\n\n    cout << \"Test 2: \";\n    result = total_match({\"hi\", \"admin\"}, {\"hI\", \"Hi\"});\n    for (const auto& str : result) {\n        cout << str << \" \";\n    }\n    cout << endl;\n\n    cout << \"Test 3: \";\n    result = total_match({\"hi\", \"admin\"}, {\"hi\", \"hi\", \"admin\", \"project\"});\n    for (const auto& str : result) {\n        cout << str << \" \";\n    }\n    cout << endl;\n\n    cout << \"Test 4: \";\n    result = total_match({\"hi\", \"admin\"}, {\"hI\", \"hi\", \"hi\"});\n    for (const auto& str : result) {\n        cout << str << \" \";\n    }\n    cout << endl;\n\n    cout << \"Test 5: \";\n    result = total_match({\"4\"}, {\"1\", \"2\", \"3\", \"4\", \"5\"});\n    for (const auto& str : result) {\n        cout << str << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/75", "generation": "#include <iostream>\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    if (n == 2 || n == 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    for (int i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0)\n            return false;\n    }\n    return true;\n}\n\n// Function to check if the given number is a product of exactly three prime numbers\nbool is_multiply_prime(int a) {\n    // Generate all primes less than 100\n    int primes[] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97};\n    int num_primes = sizeof(primes) / sizeof(primes[0]);\n\n    // Try all combinations of three primes\n    for (int i = 0; i < num_primes; ++i) {\n        for (int j = i; j < num_primes; ++j) {\n            for (int k = j; k < num_primes; ++k) {\n                if (primes[i] * primes[j] * primes[k] == a)\n                    return true;\n            }\n        }\n    }\n\n    return false;\n}\n\n// Function to test the is_multiply_prime function\nvoid test() {\n    cout << \"Testing is_multiply_prime...\" << endl;\n    assert(is_multiply_prime(30) == true); // 2 * 3 * 5 = 30\n    assert(is_multiply_prime(60) == false); // Not a product of exactly three primes\n    assert(is_multiply_prime(105) == true); // 3 * 5 * 7 = 105\n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/76", "generation": "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\nbool is_simple_power(int x, int n) {\n    if (n == 1) {\n        return x == 1; // Special case: 1^any_number = 1\n    }\n    \n    double log_result = log(x) / log(n);\n    return floor(log_result) == log_result;\n}\n\n"}
{"task_id": "CPP/77", "generation": "#include <iostream>\n#include <cmath>\n\nbool iscube(int a) {\n    // Handle the special case where a is 0\n    if (a == 0) {\n        return true;\n    }\n    \n    // Iterate through possible integers from 0 up to and including the integer part of the cube root of |a| + 1\n    for (int i = 0; i <= static_cast<int>(cbrt(abs(a)) + 1); ++i) {\n        // Check if any of these integers cubed equals the absolute value of a\n        if (pow(i, 3) == abs(a)) {\n            return true;\n        }\n    }\n    \n    // If no such integer is found, return false\n    return false;\n}\n\n"}
{"task_id": "CPP/78", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nint hex_key(string num) {\n    // Define a set of prime hexadecimal digits\n    const string primes = \"2357BD\";\n    \n    int count = 0;\n    \n    // Iterate through each character in the input string\n    for (char c : num) {\n        if (primes.find(c) != string::npos) {\n            ++count;  // Increment count if the digit is prime\n        }\n    }\n    \n    return count;\n}\n\n"}
{"task_id": "CPP/79", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\n// Function to convert decimal to binary\nstring decimal_to_binary(int decimal) {\n    if (decimal == 0) {\n        return \"db0db\";\n    }\n\n    string binary = \"\";\n    while (decimal > 0) {\n        int remainder = decimal % 2;\n        binary = to_string(remainder) + binary;\n        decimal /= 2;\n    }\n    \n    // Add the prefix and suffix\n    return \"db\" + binary + \"db\";\n}\n\n// Function to check the correctness of the conversion\nvoid check_conversion(int decimal, const string& expected) {\n    string result = decimal_to_binary(decimal);\n    cout << \"decimal: \" << decimal << \", expected: \" << expected << \", got: \" << result << endl;\n    if (result == expected) {\n        cout << \"Test passed.\" << endl;\n    } else {\n        cout << \"Test failed.\" << endl;\n    }\n}\n\n"}
{"task_id": "CPP/80", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_happy(string s) {\n    // Check if the string length is less than 3\n    if (s.length() < 3) return false;\n    \n    // Iterate through the string, checking every set of three consecutive characters\n    for (size_t i = 0; i <= s.length() - 3; ++i) {\n        // Check if any two out of the three consecutive characters are the same\n        if (s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]) {\n            return false;\n        }\n    }\n    \n    // If no three consecutive characters are the same, the string is happy\n    return true;\n}\n\n"}
{"task_id": "CPP/81", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\n// Function to convert GPA to letter grade\nstring gpa_to_letter(float gpa) {\n    if (gpa >= 4.0f) return \"A+\";\n    else if (gpa > 3.7f) return \"A\";\n    else if (gpa > 3.3f) return \"A-\";\n    else if (gpa > 3.0f) return \"B+\";\n    else if (gpa > 2.7f) return \"B\";\n    else if (gpa > 2.3f) return \"B-\";\n    else if (gpa > 2.0f) return \"C+\";\n    else if (gpa > 1.7f) return \"C\";\n    else if (gpa > 1.3f) return \"C-\";\n    else if (gpa > 1.0f) return \"D+\";\n    else if (gpa > 0.7f) return \"D\";\n    else if (gpa > 0.0f) return \"D-\";\n    else return \"E\";\n}\n\n// Function to convert vector of GPAs to vector of letter grades\nvector<string> numerical_letter_grade(vector<float> grades) {\n    vector<string> letter_grades;\n    for (float gpa : grades) {\n        letter_grades.push_back(gpa_to_letter(gpa));\n    }\n    return letter_grades;\n}\n\n// Function to check the correctness of the function\nvoid check() {\n    vector<float> test_grades = {4.0f, 3.0f, 1.7f, 2.0f, 3.5f};\n    vector<string> expected = {\"A+\", \"B\", \"C-\", \"C\", \"A-\"};\n    vector<string> result = numerical_letter_grade(test_grades);\n    \n    if (result == expected) {\n        cout << \"Test passed!\" << endl;\n    } else {\n        cout << \"Test failed. Expected: \";\n        for (const auto& grade : expected) {\n            cout << grade << \" \";\n        }\n        cout << \"\\nGot: \";\n        for (const auto& grade : result) {\n            cout << grade << \" \";\n        }\n        cout << endl;\n    }\n}\n\n"}
{"task_id": "CPP/82", "generation": "#include <iostream>\n#include <string>\n\n// Function to check if a number is prime\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    if (n == 2 || n == 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n\n    for (int i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0)\n            return false;\n    }\n    return true;\n}\n\n// Function to check if the length of a string is prime\nbool prime_length(string str) {\n    int len = str.length();\n    return is_prime(len);\n}\n\n"}
{"task_id": "CPP/83", "generation": "#include <iostream>\n\nint starts_one_ends(int n) {\n    if (n == 1) {\n        return 1; // Only one 1-digit number (1) that starts and ends with 1\n    }\n\n    // For n > 1, calculate the count of numbers starting or ending with 1\n    long long total_count = 2 * static_cast<long long>(pow(10, n - 1)) - 1;\n    return total_count;\n}\n\n"}
{"task_id": "CPP/84", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring solve(int N) {\n    int sum = 0;\n    \n    // Calculate the sum of digits\n    while (N > 0) {\n        sum += N % 10;  // Add the last digit to the sum\n        N /= 10;        // Remove the last digit from N\n    }\n    \n    // Convert the sum to binary string\n    string binarySum = \"\";\n    if (sum == 0) {\n        return \"0\";\n    }\n    \n    while (sum > 0) {\n        binarySum = to_string(sum % 2) + binarySum;  // Prepend the remainder when divided by 2\n        sum /= 2;                                    // Divide the sum by 2\n    }\n    \n    return binarySum;\n}\n\n"}
{"task_id": "CPP/85", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint add(vector<int> lst) {\n    int sum = 0;\n    \n    // Iterate through the vector starting from index 1 (second element)\n    for (size_t i = 1; i < lst.size(); i += 2) {\n        if (lst[i] % 2 == 0) {  // Check if the element at an odd index is even\n            sum += lst[i];\n        }\n    }\n    \n    return sum;\n}\n\n"}
{"task_id": "CPP/86", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n\nusing namespace std;\n\nstring sort_word(const string& word) {\n    string sorted_word = word;\n    sort(sorted_word.begin(), sorted_word.end());\n    return sorted_word;\n}\n\nstring anti_shuffle(string s) {\n    // Split the string into words\n    vector<string> words;\n    string current_word;\n    for (char ch : s) {\n        if (ch == ' ') {\n            if (!current_word.empty()) {\n                words.push_back(current_word);\n                current_word.clear();\n            }\n            words.push_back(\" \");\n        } else {\n            current_word += ch;\n        }\n    }\n    if (!current_word.empty()) {\n        words.push_back(current_word);\n    }\n\n    // Sort each word and reconstruct the string\n    for (auto& word : words) {\n        if (word != \" \") {\n            word = sort_word(word);\n        }\n    }\n\n    // Join the sorted words back into a single string\n    s.clear();\n    for (const auto& w : words) {\n        s += w;\n    }\n\n    return s;\n}\n\n"}
{"task_id": "CPP/87", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to get the row and column indices where x appears\nvector<vector<int>> get_row(vector<vector<int>> lst, int x) {\n    vector<vector<int>> result;\n    \n    // Iterate through each row in the list\n    for (size_t i = 0; i < lst.size(); ++i) {\n        const auto& row = lst[i];\n        \n        // Iterate through each element in the current row\n        for (size_t j = 0; j < row.size(); ++j) {\n            if (row[j] == x) {\n                result.push_back({static_cast<int>(i), static_cast<int>(j)});\n            }\n        }\n    }\n\n    // Sort by rows in ascending order and then by columns in descending order within each row\n    sort(result.begin(), result.end(), [](const vector<int>& a, const vector<int>& b) {\n        if (a[0] == b[0]) return a[1] > b[1]; // Descending order for columns\n        return a[0] < b[0]; // Ascending order for rows\n    });\n\n    return result;\n}\n\n// Function to print the result for verification\nvoid print_result(const vector<vector<int>>& result) {\n    for (const auto& coord : result) {\n        cout << \"{\" << coord[0] << \", \" << coord[1] << \"} \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/88", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> sort_array(vector<int> array) {\n    // Check if the vector is empty or has only one element\n    if (array.empty() || array.size() == 1) {\n        return array;\n    }\n\n    int first = array.front();\n    int last = array.back();\n\n    // Calculate the sum of the first and last elements\n    int sum = first + last;\n\n    // Determine the sorting order based on the sum being odd or even\n    if (sum % 2 == 0) {\n        // Sort in descending order\n        vector<int> sorted_array(array);\n        sort(sorted_array.rbegin(), sorted_array.rend());\n        return sorted_array;\n    } else {\n        // Sort in ascending order\n        vector<int> sorted_array(array);\n        sort(sorted_array.begin(), sorted_array.end());\n        return sorted_array;\n    }\n}\n\n// Function to test the solution with provided examples\nvoid check() {\n    printf(\"{%s}\\n\", sort_array({}).empty() ? \"[]\" : \"{5, 4, 3, 2, 1}\"); // Example might be incorrect for empty vector\n    printf(\"{%d}\\n\", sort_array({5})[0]); // Should return {5}\n    printf(\"{%s}\\n\", sort_array({2, 4, 3, 0, 1, 5}).begin(), sort_array({2, 4, 3, 0, 1, 5}).end()); // Should return [0, 1, 2, 3, 4, 5]\n    printf(\"{%s}\\n\", sort_array({2, 4, 3, 0, 1, 5, 6}).rbegin(), sort_array({2, 4, 3, 0, 1, 5, 6}).rend()); // Should return [6, 5, 4, 3, 2, 1, 0]\n}\n\n"}
{"task_id": "CPP/89", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\n// Function to rotate a single character by 4 places\nchar rotateChar(char c) {\n    if (c >= 'a' && c <= 'z') {\n        return ((c - 'a' + 4) % 26) + 'a';\n    } else if (c >= 'A' && c <= 'Z') {\n        return ((c - 'A' + 4) % 26) + 'A';\n    }\n    // Non-alphabetic characters are not rotated\n    return c;\n}\n\n// Function to encrypt the string by rotating each character\nstring encrypt(string s) {\n    for (char &c : s) {\n        c = rotateChar(c);\n    }\n    return s;\n}\n\n"}
{"task_id": "CPP/90", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <optional>\n\nusing namespace std;\n\nstd::optional<int> next_smallest(const vector<int>& lst) {\n    if (lst.empty() || lst.size() < 2) {\n        return std::nullopt;\n    }\n\n    // Remove duplicates and sort the unique elements\n    auto it = unique(lst.begin(), lst.end());\n    lst.erase(it, lst.end());\n\n    if (lst.size() < 2) {\n        return std::nullopt;\n    }\n\n    // Sort the vector to find the second smallest element\n    sort(lst.begin(), lst.end());\n\n    // Return the second smallest element\n    return lst[1];\n}\n\n// Function to test the next_smallest function\nvoid test_next_smallest() {\n    assert(next_smallest({1, 2, 3, 4, 5}) == 2);\n    assert(next_smallest({5, 1, 4, 3, 2}) == 2);\n    assert(!next_smallest({}).has_value());\n    assert(!next_smallest({1, 1}).has_value());\n\n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/91", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <vector>\n\nusing namespace std;\n\nint is_bored(const string& S) {\n    // Split the string into sentences based on '.', '?', or '!'\n    vector<string> sentences;\n    stringstream ss(S);\n    string sentence;\n    \n    while (getline(ss, sentence, '.')) {\n        if (!sentence.empty()) {\n            sentences.push_back(sentence);\n        }\n    }\n    while (getline(ss, sentence, '?')) {\n        if (!sentence.empty()) {\n            sentences.push_back(sentence);\n        }\n    }\n    while (getline(ss, sentence, '!')) {\n        if (!sentence.empty()) {\n            sentences.push_back(sentence);\n        }\n    }\n\n    // Count the number of sentences that start with \"I\"\n    int boredom_count = 0;\n    for (const auto& s : sentences) {\n        string trimmed_sentence = s.substr(0, s.find_first_of(\" \\t\\n\\r\\f\\v\"));\n        if (!trimmed_sentence.empty() && trimmed_sentence[0] == 'I') {\n            ++boredom_count;\n        }\n    }\n\n    return boredom_count;\n}\n\n"}
{"task_id": "CPP/92", "generation": "#include <iostream>\nusing namespace std;\n\nbool is_integer(float num) {\n    return floor(num) == num;\n}\n\nbool any_int(float a, float b, float c) {\n    // Check if all numbers are integers\n    if (is_integer(a) && is_integer(b) && is_integer(c)) {\n        // Check if one of the numbers is equal to the sum of the other two\n        return (a == b + c) || (b == a + c) || (c == a + b);\n    } else {\n        return false;\n    }\n}\n\n"}
{"task_id": "CPP/93", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to encode the message\nstring encode(const string& message) {\n    // Define vowels and their corresponding shifted characters\n    const char vowel_shift[] = {'a', 'e', 'i', 'o', 'u',\n                                'A', 'E', 'I', 'O', 'U'};\n    const char shift_vowels[] = {'c', 'g', 'k', 'q', 'w',\n                                 'C', 'G', 'K', 'Q', 'W'};\n\n    string encoded_message;\n\n    for (char ch : message) {\n        // Check if the character is a vowel\n        bool is_vowel = false;\n        for (int i = 0; i < 10; ++i) {\n            if (ch == vowel_shift[i]) {\n                is_vowel = true;\n                break;\n            }\n        }\n\n        if (is_vowel) {\n            // Replace the vowel with its shifted character\n            ch = shift_vowels[vowel_shift - &vowel_shift[0]];\n        } else {\n            // Swap case for non-vowel characters\n            ch = isupper(ch) ? tolower(ch) : toupper(ch);\n        }\n\n        // Append the modified character to the encoded message\n        encoded_message += ch;\n    }\n\n    return encoded_message;\n}\n"}
{"task_id": "CPP/94", "generation": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i <= sqrt(n); ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\nint sum_of_digits(int n) {\n    int sum = 0;\n    while (n > 0) {\n        sum += n % 10;\n        n /= 10;\n    }\n    return sum;\n}\n\nint find_largest_prime_sum(vector<int> lst) {\n    int max_prime = -1;\n    for (int num : lst) {\n        if (is_prime(num) && num > max_prime) {\n            max_prime = num;\n        }\n    }\n\n    if (max_prime == -1) return 0;\n    else return sum_of_digits(max_prime);\n}\n\n"}
{"task_id": "CPP/95", "generation": "#include <iostream>\n#include <string>\n#include <map>\n\nusing namespace std;\n\nbool check_dict_case(map<string, string> dict) {\n    // Check if the dictionary is empty\n    if (dict.empty()) {\n        return false;\n    }\n\n    bool all_lower = true;\n    bool all_upper = true;\n\n    for (const auto &pair : dict) {\n        // Check if the key is in lowercase or uppercase\n        if (!pair.first.empty() && !islower(pair.first[0])) {\n            all_lower = false;\n        }\n        if (!pair.first.empty() && !isupper(pair.first[0])) {\n            all_upper = false;\n        }\n\n        // If both conditions fail, return false immediately\n        if (!all_lower && !all_upper) {\n            return false;\n        }\n    }\n\n    // Return true if either all keys are lowercase or all keys are uppercase\n    return all_lower || all_upper;\n}\n\n"}
{"task_id": "CPP/96", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Helper function to check if a number is prime\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    for (int i = 2; i * i <= num; ++i) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\n// Function to generate a vector of prime numbers less than n\nvector<int> count_up_to(int n) {\n    vector<int> primes;\n    for (int i = 2; i < n; ++i) {\n        if (is_prime(i)) {\n            primes.push_back(i);\n        }\n    }\n    return primes;\n}\n\n// Function to test the count_up_to function\nvoid test_count_up_to() {\n    assert(count_up_to(5) == vector<int>({2, 3}));\n    assert(count_up_to(11) == vector<int>({2, 3, 5, 7}));\n    assert(count_up_to(0).empty());\n    assert(count_up_to(20) == vector<int>({2, 3, 5, 7, 11, 13, 17, 19}));\n    assert(count_up_to(1).empty());\n    assert(count_up_to(18) == vector<int>({2, 3, 5, 7, 11, 13, 17}));\n\n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/97", "generation": "#include <iostream>\nusing namespace std;\n\nint multiply(int a, int b) {\n    // Extract the unit digit of both numbers\n    int unit_digit_a = abs(a % 10);\n    int unit_digit_b = abs(b % 10);\n\n    // Multiply the unit digits and return the result\n    return unit_digit_a * unit_digit_b;\n}\n\n"}
{"task_id": "CPP/98", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint count_upper(const string& s) {\n    int count = 0;\n    for (size_t i = 0; i < s.length(); i += 2) { // Iterate through even indices\n        char c = s[i];\n        if (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n            count++;\n        }\n    }\n    return count;\n}\n\n"}
{"task_id": "CPP/99", "generation": "#include <iostream>\n#include <cmath>\n#include <string>\nusing namespace std;\n\nint closest_integer(string value) {\n    // Convert string to double\n    double num = stod(value);\n    \n    // Determine the two nearest integers\n    int lower_int = static_cast<int>(floor(num));\n    int upper_int = static_cast<int>(ceil(num));\n    \n    // Check which integer is closer or if they are equidistant, round away from zero\n    if (num - lower_int == upper_int - num) {\n        return abs(num) > abs(lower_int) ? upper_int : lower_int;\n    } else {\n        return num - lower_int < 0.5 ? lower_int : upper_int;\n    }\n}\n\n"}
{"task_id": "CPP/100", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> make_a_pile(int n) {\n    vector<int> pile;\n    int current_stones = n;\n\n    for (int i = 0; i < n; ++i) {\n        pile.push_back(current_stones);\n        // Determine the next number of stones\n        if (current_stones % 2 == 0) {\n            current_stones += 2; // Next even number\n        } else {\n            current_stones += 2; // Next odd number\n        }\n    }\n\n    return pile;\n}\n\n// Function to check the correctness of the solution\nvoid check_solution() {\n    vector<int> result1 = make_a_pile(3);\n    assert(result1 == vector<int>({3, 5, 7}));\n\n    vector<int> result2 = make_a_pile(4);\n    assert(result2 == vector<int>({4, 6, 8, 10}));\n\n    vector<int> result3 = make_a_pile(1);\n    assert(result3 == vector<int>({1, 3}));\n\n    cout << \"All test cases passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/101", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nvector<string> words_string(string s) {\n    vector<string> result;\n    stringstream ss(s);\n    string word;\n\n    while (getline(ss, word, ',')) {  // Split by commas first\n        stringstream wordStream(word);  // Create a new stream for the current word\n        while (wordStream >> word) {  // Extract words from the current word\n            result.push_back(word);\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/102", "generation": "#include <iostream>\nusing namespace std;\n\nint choose_num(int x, int y) {\n    // Ensure x is less than or equal to y\n    if (x > y) {\n        return -1;\n    }\n\n    // Start from the end of the range and check for the largest even number\n    for (int i = y; i >= x; --i) {\n        if (i % 2 == 0) {\n            return i;\n        }\n    }\n\n    // If no even number is found, return -1\n    return -1;\n}\n\n// Function to test the choose_num function with some examples\nvoid test() {\n    cout << \"choose_num(12, 15): \" << choose_num(12, 15) << endl; // Should output 14\n    cout << \"choose_num(13, 12): \" << choose_num(13, 12) << endl; // Should output -1\n    cout << \"choose_num(10, 20): \" << choose_num(10, 20) << endl; // Should output 20\n    cout << \"choose_num(21, 25): \" << choose_num(21, 25) << endl; // Should output 24\n}\n\n"}
{"task_id": "CPP/103", "generation": "#include <stdio.h>\n#include <math.h>\n#include <string>\nusing namespace std;\n\nstring rounded_avg(int n, int m) {\n    // Check if n is greater than m\n    if (n > m) {\n        return \"-1\";\n    }\n\n    // Calculate the sum of integers from n to m\n    long long sum = 0;\n    for (int i = n; i <= m; ++i) {\n        sum += i;\n    }\n\n    // Calculate the average and round it down\n    int avg = sum / (m - n + 1);\n\n    // Convert the rounded average to binary string\n    string binary = \"\";\n    if (avg == 0) {\n        binary = \"0\";\n    } else {\n        while (avg > 0) {\n            binary = to_string(avg % 2) + binary;\n            avg /= 2;\n        }\n    }\n\n    return binary;\n}\n\n"}
{"task_id": "CPP/104", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nbool hasEvenDigit(int num) {\n    while (num > 0) {\n        int digit = num % 10;\n        if (digit % 2 == 0) {\n            return true; // Found an even digit\n        }\n        num /= 10;\n    }\n    return false; // No even digits found\n}\n\nvector<int> unique_digits(vector<int> x) {\n    vector<int> result;\n\n    for (int num : x) {\n        if (!hasEvenDigit(num)) {\n            result.push_back(num);\n        }\n    }\n\n    sort(result.begin(), result.end());\n    return result;\n}\n\n"}
{"task_id": "CPP/105", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to convert a digit to its corresponding name\nstring num_to_word(int n) {\n    map<int, string> digit_names = {\n        {1, \"One\"}, {2, \"Two\"}, {3, \"Three\"}, {4, \"Four\"},\n        {5, \"Five\"}, {6, \"Six\"}, {7, \"Seven\"}, {8, \"Eight\"}, {9, \"Nine\"}\n    };\n    return digit_names[n];\n}\n\n// Function to process the vector as per the problem statement\nvector<string> by_length(vector<int> arr) {\n    // Filter out numbers that are not between 1 and 9\n    vector<int> filtered_arr;\n    for (int num : arr) {\n        if (num >= 1 && num <= 9) {\n            filtered_arr.push_back(num);\n        }\n    }\n\n    // Sort the filtered array\n    sort(filtered_arr.begin(), filtered_arr.end());\n\n    // Reverse the sorted array\n    reverse(filtered_arr.begin(), filtered_arr.end());\n\n    // Convert each number to its corresponding name and store in a vector of strings\n    vector<string> result;\n    for (int num : filtered_arr) {\n        result.push_back(num_to_word(num));\n    }\n\n    return result;\n}\n\n// Function to check the correctness of the by_length function\nvoid check() {\n    vector<int> arr1 = {2, 1, 1, 4, 5, 8, 2, 3};\n    vector<string> expected1 = {\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"};\n    assert(by_length(arr1) == expected1);\n\n    vector<int> arr2 = {};\n    vector<string> expected2 = {};\n    assert(by_length(arr2) == expected2);\n\n    vector<int> arr3 = {1, -1, 55};\n    vector<string> expected3 = {\"One\"};\n    assert(by_length(arr3) == expected3);\n\n    printf(\"All test cases passed.\\n\");\n}\n\n"}
{"task_id": "CPP/106", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Function to compute the factorial of a number\nint factorial(int num) {\n    if (num == 0 || num == 1)\n        return 1;\n    int fact = 1;\n    for (int i = 2; i <= num; ++i) {\n        fact *= i;\n    }\n    return fact;\n}\n\n// Function to compute the sum of numbers from 1 to a number\nint sumTo(int num) {\n    return (num * (num + 1)) / 2;\n}\n\nvector<int> f(int n) {\n    vector<int> result(n);\n    \n    for (int i = 0; i < n; ++i) {\n        if ((i + 1) % 2 == 0) { // Check if the index is even\n            result[i] = factorial(i + 1); // Factorial of (i+1)\n        } else { // The index is odd\n            result[i] = sumTo(i + 1); // Sum from 1 to (i+1)\n        }\n    }\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/107", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nbool is_palindrome(int num) {\n    string str = to_string(num);\n    int left = 0;\n    int right = str.length() - 1;\n    \n    while (left < right) {\n        if (str[left] != str[right]) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n    return true;\n}\n\nvector<int> even_odd_palindrome(int n) {\n    vector<int> result(2, 0); // Initialize with two elements for even and odd counts\n    for (int i = 1; i <= n; ++i) {\n        if (is_palindrome(i)) {\n            if (i % 2 == 0) {\n                result[0]++; // Even palindrome count\n            } else {\n                result[1]++; // Odd palindrome count\n            }\n        }\n    }\n    return result;\n}\n\n"}
{"task_id": "CPP/108", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Helper function to calculate the sum of digits of a number.\nint sum_of_digits(int num) {\n    if (num < 0) {\n        num = -num; // Make number positive for digit extraction\n    }\n    int total = 0;\n    while (num > 0) {\n        total += num % 10;\n        num /= 10;\n    }\n    return total;\n}\n\n// Main function to count the numbers with a sum of digits greater than zero.\nint count_nums(vector<int> n) {\n    int count = 0;\n    for (int num : n) {\n        if (sum_of_digits(num) > 0) {\n            count++;\n        }\n    }\n    return count;\n}\n\n// Function to test the count_nums function with provided examples.\nvoid test_count_nums() {\n    assert(count_nums({}) == 0);\n    assert(count_nums({-1, 11, -11}) == 1);\n    assert(count_nums({1, 1, 2}) == 3);\n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/109", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool move_one_ball(vector<int> arr) {\n    int n = arr.size();\n    \n    if (n == 0) {\n        return true;\n    }\n    \n    // Find the index where the array is not sorted\n    for (int i = 1; i < n; ++i) {\n        if (arr[i] < arr[i - 1]) {\n            break;\n        }\n    }\n    \n    // If no such index found, the array is already sorted\n    if (i == n) {\n        return true;\n    }\n\n    // Check if we can make the array sorted by a single right shift\n    bool is_sorted = (arr[0] >= arr[n - 1]) && all_of(arr.begin(), arr.end() - 1, [&](int x, int y) { return x <= y; });\n\n    // Verify the circular condition for the last element\n    if (is_sorted && arr[n - 1] <= arr[1]) {\n        return true;\n    }\n\n    return false;\n}\n\n// Helper function to check all elements in a range satisfy a condition\ntemplate <typename Iterator, typename Predicate>\nbool all_of(Iterator first, Iterator last, Predicate pred) {\n    for (; first != last; ++first) {\n        if (!pred(*first)) {\n            return false;\n        }\n    }\n    return true;\n}\n\n"}
{"task_id": "CPP/110", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring exchange(vector<int> lst1, vector<int> lst2) {\n    // Count odd numbers in lst1 and even numbers in lst2\n    int odd_count_lst1 = 0;\n    int even_count_lst2 = 0;\n\n    for (int num : lst1) {\n        if (num % 2 != 0) {\n            odd_count_lst1++;\n        }\n    }\n\n    for (int num : lst2) {\n        if (num % 2 == 0) {\n            even_count_lst2++;\n        }\n    }\n\n    // Determine feasibility\n    if (even_count_lst2 >= odd_count_lst1) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n\n"}
{"task_id": "CPP/111", "generation": "#include <iostream>\n#include <string>\n#include <map>\n#include <vector>\nusing namespace std;\n\nmap<char, int> histogram(string test) {\n    map<char, int> charCount;\n    \n    // Count occurrences of each character\n    for (char c : test) {\n        if (c != ' ') {  // Ignore spaces\n            charCount[c]++;\n        }\n    }\n\n    // Find the maximum count\n    int maxCount = 0;\n    for (const auto& pair : charCount) {\n        if (pair.second > maxCount) {\n            maxCount = pair.second;\n        }\n    }\n\n    // Collect characters with the highest frequency\n    map<char, int> result;\n    for (const auto& pair : charCount) {\n        if (pair.second == maxCount) {\n            result.insert(pair);\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/112", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to check if a string is a palindrome\nbool is_palindrome(const string& str) {\n    int left = 0;\n    int right = str.size() - 1;\n    while (left < right) {\n        if (str[left] != str[right]) {\n            return false;\n        }\n        ++left;\n        --right;\n    }\n    return true;\n}\n\n// Function to reverse delete characters\nvector<string> reverse_delete(string s, string c) {\n    // Remove all characters in s that are present in c\n    for (char ch : c) {\n        s.erase(remove(s.begin(), s.end(), ch), s.end());\n    }\n\n    // Check if the resulting string is a palindrome\n    bool result = is_palindrome(s);\n\n    // Return the result as a vector containing the modified string and the boolean\n    return {s, (result ? \"True\" : \"False\")};\n}\n\n"}
{"task_id": "CPP/113", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<string> odd_count(vector<string> lst) {\n    vector<string> result;\n    \n    for (const auto& str : lst) {\n        int count = 0;\n        \n        // Count the number of odd digits in the string\n        for (char c : str) {\n            if ((c - '0') % 2 != 0) {\n                count++;\n            }\n        }\n\n        // Construct the result string\n        string output = \"the number of odd elements \";\n        output += to_string(count);\n        output += \"n the str\";\n        output += to_string(count);\n        output += \"ng \";\n        output += to_string(count);\n        output += \" of the \";\n        output += to_string(count);\n        output += \"nput.\";\n        \n        result.push_back(output);\n    }\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/114", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nlong long minSubArraySum(vector<long long> nums) {\n    if (nums.empty()) return 0; // Handle empty vector case\n\n    long long current_min = nums[0];\n    long long global_min = nums[0];\n\n    for (size_t i = 1; i < nums.size(); ++i) {\n        // Update the current minimum sum ending at position i\n        current_min = min(nums[i], current_min + nums[i]);\n        \n        // Update the global minimum sum found so far\n        if (current_min < global_min) {\n            global_min = current_min;\n        }\n    }\n\n    return global_min;\n}\n\n"}
{"task_id": "CPP/115", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint max_fill(vector<vector<int>> grid, int capacity) {\n    int total_lowerings = 0;\n    \n    // Iterate through each well (row)\n    for (const auto& row : grid) {\n        int water_units = 0;\n        \n        // Count the number of units of water in the current well\n        for (int unit : row) {\n            if (unit == 1) {\n                ++water_units;\n            }\n        }\n        \n        // Calculate the number of times the bucket needs to be lowered\n        total_lowerings += (water_units + capacity - 1) / capacity;\n    }\n    \n    return total_lowerings;\n}\n\n"}
{"task_id": "CPP/116", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint count_ones(int n) {\n    return __builtin_popcount(n);\n}\n\nbool compare(int a, int b) {\n    int ones_a = count_ones(a), ones_b = count_ones(b);\n    if (ones_a == ones_b) {\n        return a < b;\n    }\n    return ones_a < ones_b;\n}\n\nvector<int> sort_array(vector<int> arr) {\n    sort(arr.begin(), arr.end(), compare);\n    return arr;\n}\n\n"}
{"task_id": "CPP/117", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nbool is_consonant(char c) {\n    return std::tolower(c) >= 'b' && std::tolower(c) <= 'z' && std::tolower(c) != 'a' && std::tolower(c) != 'e' && std::tolower(c) != 'i' && std::tolower(c) != 'o' && std::tolower(c) != 'u';\n}\n\nint count_consonants(const std::string& word) {\n    int consonant_count = 0;\n    for (char c : word) {\n        if (is_consonant(c)) {\n            ++consonant_count;\n        }\n    }\n    return consonant_count;\n}\n\nstd::vector<std::string> select_words(const std::string& s, int n) {\n    std::vector<std::string> result;\n\n    if (s.empty()) {\n        return result;\n    }\n\n    std::istringstream iss(s);\n    std::string word;\n\n    while (iss >> word) {\n        if (count_consonants(word) == n) {\n            result.push_back(word);\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/118", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nbool is_vowel(char c) {\n    return c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' ||\n           c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U';\n}\n\nstring get_closest_vowel(string word) {\n    int n = word.length();\n    \n    // Iterate from the second last character to the third character\n    for (int i = n - 2; i >= 1; --i) {\n        if (is_vowel(word[i]) && isalpha(word[i-1]) && (!isalpha(word[i+1] || word[i+1] == '\\0'))) {\n            return string(1, word[i]);\n        }\n    }\n    \n    // If no vowel found that meets the condition\n    return \"\";\n}\n\n"}
{"task_id": "CPP/119", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nbool is_balanced(const string& s) {\n    int balance = 0;\n    for (char c : s) {\n        if (c == '(') {\n            balance += 1;\n        } else {\n            balance -= 1;\n        }\n        if (balance < 0) {\n            return false;\n        }\n    }\n    return balance == 0;\n}\n\nstring match_parens(vector<string> lst) {\n    // Check both possible concatenations\n    if (is_balanced(lst[0] + lst[1]) || is_balanced(lst[1] + lst[0])) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\n\n"}
{"task_id": "CPP/120", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> maximum(vector<int> arr, int k) {\n    // Sort the array in descending order\n    sort(arr.begin(), arr.end(), greater<int>());\n    \n    // If k is 0 or negative, return an empty vector\n    if (k <= 0 || k > arr.size()) {\n        return {};\n    }\n    \n    // Slice the first k elements from the sorted array\n    vector<int> result(arr.begin(), arr.begin() + k);\n    \n    // Sort the resulting vector in ascending order as required\n    sort(result.begin(), result.end());\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/121", "generation": "#include <vector>\nusing namespace std;\n\nint solution(vector<int> lst) {\n    int sum = 0;\n    for (size_t i = 0; i < lst.size(); ++i) {\n        // Check if the index is even and the element at that position is odd\n        if (i % 2 == 0 && lst[i] % 2 != 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n\n// Function to test the solution with provided examples\nvoid check_solution() {\n    assert(solution({5, 8, 7, 1}) == 12);\n    assert(solution({3, 3, 3, 3, 3}) == 9);\n    assert(solution({30, 13, 24, 321}) == 0);\n}\n\n"}
{"task_id": "CPP/122", "generation": "#include <vector>\n#include <algorithm>\n\nint add_elements(std::vector<int> arr, int k) {\n    // Filter the first k elements of the array and keep only those with at most two digits\n    std::vector<int> filtered_elements;\n    for (int i = 0; i < k && i < arr.size(); ++i) {\n        if (arr[i] >= 0 && arr[i] < 100) {\n            filtered_elements.push_back(arr[i]);\n        }\n    }\n\n    // Calculate the sum of these filtered elements\n    int sum = 0;\n    for (int num : filtered_elements) {\n        sum += num;\n    }\n\n    return sum;\n}\n"}
{"task_id": "CPP/123", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n// Function to generate and return the odd numbers in the Collatz sequence of n.\nvector<int> get_odd_collatz(int n) {\n    vector<int> result;\n    \n    // Generate the Collatz sequence until it reaches 1\n    while (n != 1) {\n        if (n % 2 == 0) {\n            n /= 2;  // If n is even, divide by 2\n        } else {\n            result.push_back(n);  // If n is odd, add to the result vector\n            n = 3 * n + 1;  // Apply the Collatz transformation\n        }\n    }\n    \n    // Add the final number (which is 1) to the result vector\n    result.push_back(1);\n    \n    // Sort the result vector in increasing order\n    sort(result.begin(), result.end());\n    \n    return result;\n}\n\n// Function to test the get_odd_collatz function with some examples.\nvoid test_get_odd_collatz() {\n    cout << \"Testing get_odd_collatz...\" << endl;\n    assert(get_odd_collatz(5) == vector<int>({1, 5}));\n    assert(get_odd_collatz(7) == vector<int>({1, 7, 11, 22}));\n    assert(get_odd_collatz(1) == vector<int>({1}));\n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/124", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <vector>\n\nbool valid_date(const std::string& date) {\n    // Split the date string into month, day, and year\n    std::istringstream iss(date);\n    std::string token;\n    std::vector<std::string> parts;\n    while (std::getline(iss, token, '-')) {\n        parts.push_back(token);\n    }\n\n    if (parts.size() != 3) {\n        return false; // The date string is not in the correct format\n    }\n\n    int month = std::stoi(parts[0]);\n    int day = std::stoi(parts[1]);\n    int year = std::stoi(parts[2]);\n\n    // Check if the month, day, and year are valid\n    if (month < 1 || month > 12) {\n        return false; // Invalid month\n    }\n\n    if (day < 1 || day > 31) {\n        return false; // Invalid day\n    }\n\n    if ((month == 4 || month == 6 || month == 9 || month == 11) && day > 30) {\n        return false; // April, June, September, and November have only 30 days\n    }\n\n    if (month == 2 && day > 29) {\n        return false; // February has at most 29 days in a leap year\n    }\n\n    // Check for leap year\n    bool is_leap_year = (year % 4 == 0 && (year % 100 != 0 || year % 400 == 0));\n    if (month == 2 && day > 28 && !is_leap_year) {\n        return false; // February has at most 28 days in a non-leap year\n    }\n\n    return true;\n}\n\n"}
{"task_id": "CPP/125", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nvector<string> split_words(string txt) {\n    if (txt.find(' ') != string::npos) {\n        // Split on whitespace\n        vector<string> result;\n        size_t start = 0, end = 0;\n        while ((end = txt.find(' ', start)) != string::npos) {\n            result.push_back(txt.substr(start, end - start));\n            start = end + 1;\n        }\n        result.push_back(txt.substr(start)); // Add the last word\n        return result;\n    } else if (txt.find(',') != string::npos) {\n        // Split on commas\n        vector<string> result;\n        size_t start = 0, end = 0;\n        while ((end = txt.find(',', start)) != string::npos) {\n            result.push_back(txt.substr(start, end - start));\n            start = end + 1;\n        }\n        result.push_back(txt.substr(start)); // Add the last word\n        return result;\n    } else {\n        // Count lowercase letters with odd ASCII values\n        int count = 0;\n        for (char c : txt) {\n            if (islower(c) && static_cast<int>(c - 'a') % 2 == 1) {\n                count++;\n            }\n        }\n        return {to_string(count)};\n    }\n}\n\n"}
{"task_id": "CPP/126", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nbool is_sorted(vector<int> lst) {\n    // Check if the list is already sorted or not\n    bool sorted = is_sorted(lst.begin(), lst.end());\n    \n    // If not sorted, return false immediately\n    if (!sorted) return false;\n    \n    // Count occurrences of each number in the vector\n    for (int i = 0; i < lst.size(); ++i) {\n        int count = 1;\n        while (i + 1 < lst.size() && lst[i] == lst[i + 1]) {\n            count++;\n            i++;\n        }\n        // If any number appears more than twice, return false\n        if (count > 2) return false;\n    }\n    \n    // If both conditions are met, return true\n    return true;\n}\n\n"}
{"task_id": "CPP/127", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\nstring intersection(vector<int> interval1, vector<int> interval2) {\n    int start = max(interval1[0], interval2[0]);\n    int end = min(interval1[1], interval2[1]);\n\n    if (start > end) {\n        return \"NO\";\n    }\n\n    int length = end - start + 1;\n\n    if (is_prime(length)) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n\n"}
{"task_id": "CPP/128", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint prod_signs(vector<int> arr) {\n    if (arr.empty()) {\n        return -32768;\n    }\n\n    int sign_product = 1;\n    int magnitude_sum = 0;\n\n    for (int num : arr) {\n        // Calculate the product of signs\n        if (num < 0) {\n            sign_product *= -1;\n        } else if (num == 0) {\n            sign_product = 0; // If any number is zero, the product will be zero\n            break;\n        }\n\n        // Calculate the sum of magnitudes\n        magnitude_sum += abs(num);\n    }\n\n    return sign_product * magnitude_sum;\n}\n\n// Function to test the prod_signs function with provided examples\nvoid check() {\n    cout << \"Checking examples:\" << endl;\n    assert(prod_signs({1, 2, 2, -4}) == -9); // (-1) * (1 + 2 + 2 + 4) = -9\n    assert(prod_signs({0, 1}) == 0);         // 0 * (abs(0) + abs(1)) = 0\n    assert(prod_signs({}) == -32768);        // Empty vector case\n\n    cout << \"All checks passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/129", "generation": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nint n;\nvector<vector<int>> grid;\nvector<pair<int, int>> directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n\nbool is_valid(int x, int y) {\n    return x >= 0 && x < n && y >= 0 && y < n;\n}\n\nvector<int> minPath(const vector<vector<int>>& grid_, int endX) {\n    n = grid_.size();\n    grid = grid_;\n    \n    if (grid[endX][endX] == -1) return {}; // If the destination is blocked\n    \n    vector<vector<bool>> visited(n, vector<bool>(n, false));\n    priority_queue<tuple<int, int, int>, vector<tuple<int, int, int>>, greater<tuple<int, int, int>>> pq;\n    pq.push({grid[0][0], 0, 0});\n    \n    while (!pq.empty()) {\n        auto [cost, x, y] = pq.top();\n        pq.pop();\n        \n        if (visited[x][y]) continue;\n        visited[x][y] = true;\n        \n        if (x == endX && y == endX) return {cost};\n        \n        for (auto& dir : directions) {\n            int newX = x + dir.first, newY = y + dir.second;\n            if (is_valid(newX, newY) && !visited[newX][newY]) {\n                pq.push({cost + grid[newX][newY], newX, newY});\n            }\n        }\n    }\n    \n    return {}; // If no path is found\n}\n\n"}
{"task_id": "CPP/130", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> tri(int n) {\n    if (n == 0) return {1};\n    if (n == 1) return {3};\n\n    vector<int> sequence = {1, 3};\n    for (int i = 2; i <= n; ++i) {\n        int next_value;\n        if (i % 2 == 0) {\n            next_value = 1 + (i / 2);\n        } else {\n            next_value = sequence[i - 1] + sequence[i - 2] + sequence[0];\n        }\n        sequence.push_back(next_value);\n    }\n\n    return {sequence.begin(), sequence.begin() + n + 1};\n}\n\n"}
{"task_id": "CPP/131", "generation": "#include <iostream>\nusing namespace std;\n\nint digits(int n) {\n    int product = 1;\n    bool hasOddDigit = false;\n\n    while (n > 0) {\n        int digit = n % 10; // Get the last digit of n\n        if (digit % 2 != 0) { // Check if the digit is odd\n            product *= digit; // Multiply it to the product\n            hasOddDigit = true;\n        }\n        n /= 10; // Remove the last digit from n\n    }\n\n    return hasOddDigit ? product : 0;\n}\n\n"}
{"task_id": "CPP/132", "generation": "#include <iostream>\n#include <string>\n#include <stack>\nusing namespace std;\n\nbool is_nested(string str) {\n    stack<char> stack;\n    bool nested_found = false;\n\n    for (char bracket : str) {\n        if (bracket == '[') {\n            stack.push(bracket);\n        } else if (bracket == ']' && !stack.empty()) {\n            stack.pop();\n            nested_found = true;\n        }\n    }\n\n    return nested_found && stack.empty();\n}\n\n"}
{"task_id": "CPP/133", "generation": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nint sum_squares(vector<float> lst) {\n    int sum = 0;\n    \n    for (float num : lst) {\n        // Round up to the nearest integer\n        float ceil_num = ceil(num);\n        \n        // Add the square of the rounded number to the sum\n        sum += static_cast<int>(ceil_num * ceil_num);\n    }\n    \n    return sum;\n}\n\n"}
{"task_id": "CPP/134", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool check_if_last_char_is_a_letter(const string& txt) {\n    // Check if the string is empty\n    if (txt.empty()) {\n        return false;\n    }\n    \n    // Get the last character of the string\n    char last_char = txt.back();\n    \n    // Check if the last character is an alphabetical character and not part of a word\n    if (isalpha(last_char) && \n        (txt.size() == 1 || !isalnum(txt[txt.size() - 2]))) {\n        return true;\n    } else {\n        return false;\n    }\n}\n\n"}
{"task_id": "CPP/135", "generation": "#include <iostream>\n#include <vector>\n\nint can_arrange(const std::vector<int>& arr) {\n    int n = arr.size();\n    for (int i = 1; i < n; ++i) {\n        if (arr[i] < arr[i - 1]) {\n            return i;\n        }\n    }\n    return -1;\n}\n\n"}
{"task_id": "CPP/136", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> largest_smallest_integers(vector<int> lst) {\n    vector<int> result = {0, 0}; // Initialize with default values\n\n    int max_negative = INT_MIN; // Start with the smallest possible integer\n    int min_positive = INT_MAX; // Start with the largest possible integer\n\n    for (int num : lst) {\n        if (num < 0 && num > max_negative) {\n            max_negative = num;\n        } else if (num > 0 && num < min_positive) {\n            min_positive = num;\n        }\n    }\n\n    result[0] = max_negative; // Assign the largest negative integer\n    result[1] = min_positive; // Assign the smallest positive integer\n\n    return result;\n}\n\n// Function to check the correctness of the solution\nvoid check() {\n    assert(largest_smallest_integers({2, 4, 1, 3, 5, 7}) == vector<int>({0, 1}));\n    assert(largest_smallest_integers({}) == vector<int>({0, 0}));\n    assert(largest_smallest_integers({0}) == vector<int>({0, 0}));\n    cout << \"All test cases passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/137", "generation": "#include <iostream>\n#include <string>\n\n// Define the compare_one function\nvoid compare_one(int a, const std::string& b) {\n    std::cout << \"Comparing \" << a << \" with \" << b << std::endl;\n}\n\n"}
{"task_id": "CPP/138", "generation": "#include <iostream>\n#include <vector>\n\nbool is_equal_to_sum_even(int n) {\n    // Since we need exactly 4 positive even numbers and the smallest sum of 4 positive even numbers (2+2+2+2) is 8,\n    // any number less than 8 cannot be expressed as such a sum.\n    if (n < 8) {\n        return false;\n    }\n    // If n is even, it can always be written as the sum of 4 even numbers because we can use 2 + 2 + (n-4) where (n-4) is also even.\n    return n % 2 == 0;\n}\n\n"}
{"task_id": "CPP/139", "generation": "#include <iostream>\n\n// Function to calculate factorial of a number\nlong long factorial(long long num) {\n    if (num == 0 || num == 1)\n        return 1;\n    else\n        return num * factorial(num - 1);\n}\n\n// Function to calculate Brazilian factorial\nlong long special_factorial(int n) {\n    long long result = 1;\n    for (int i = n; i > 0; --i) {\n        result *= factorial(i);\n    }\n    return result;\n}\n\n"}
{"task_id": "CPP/140", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nstring fix_spaces(string text) {\n    string result = \"\";\n    int space_count = 0;\n\n    for (char ch : text) {\n        if (ch == ' ') {\n            space_count++;\n        } else {\n            if (space_count > 2) {\n                result += '-';\n            } else if (space_count >= 1) {\n                result.append(space_count, '_');\n            }\n            space_count = 0;\n            result += ch;\n        }\n    }\n\n    // Handle trailing spaces\n    if (space_count > 2) {\n        result += '-';\n    } else if (space_count >= 1) {\n        result.append(space_count, '_');\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/141", "generation": "#include <iostream>\n#include <string>\n#include <regex>\n\nusing namespace std;\n\nstring file_name_check(const string& file_name) {\n    // Regular expression pattern based on the given conditions\n    const regex pattern(R\"(^[a-zA-Z][a-zA-Z0-9]{0,2}\\.[txt|exe|dll]{3}$)\");\n\n    // Check if the file name matches the pattern\n    if (regex_match(file_name, pattern)) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\n\n"}
{"task_id": "CPP/142", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint sum_squares(vector<int> lst) {\n    for (size_t i = 0; i < lst.size(); ++i) {\n        if (i % 3 == 0 && i != 0) {\n            lst[i] = lst[i] * lst[i]; // Square the element\n        } else if (i % 4 == 0 && i % 3 != 0) {\n            lst[i] = lst[i] * lst[i] * lst[i]; // Cube the element\n        }\n    }\n\n    int sum = 0;\n    for (int num : lst) {\n        sum += num; // Sum all elements in the list\n    }\n\n    return sum;\n}\n\n"}
{"task_id": "CPP/143", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    if (n == 2 || n == 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    for (int i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0)\n            return false;\n    }\n    return true;\n}\n\n// Function to process the sentence and return words with prime length\nstring words_in_sentence(string sentence) {\n    stringstream ss(sentence);\n    string word;\n    string result = \"\";\n    \n    while (ss >> word) {\n        if (is_prime(word.length())) {\n            if (!result.empty()) result += \" \";\n            result += word;\n        }\n    }\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/144", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\n// Function to simplify two fractions and check if their product is a whole number\nbool simplify(string x, string n) {\n    // Helper function to parse fraction from string\n    auto parse_fraction = [](const string& frac) -> pair<int, int> {\n        size_t slash_pos = frac.find('/');\n        int numerator = stoi(frac.substr(0, slash_pos));\n        int denominator = stoi(frac.substr(slash_pos + 1));\n        return {numerator, denominator};\n    };\n\n    // Parse the fractions\n    auto [num_x, den_x] = parse_fraction(x);\n    auto [num_n, den_n] = parse_fraction(n);\n\n    // Calculate the product of the numerators and denominators\n    int numerator_product = num_x * num_n;\n    int denominator_product = den_x * den_n;\n\n    // Check if the result is a whole number\n    return (numerator_product % denominator_product) == 0;\n}\n\n"}
{"task_id": "CPP/145", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\n// Function to calculate the sum of digits of an integer.\nint digit_sum(int n) {\n    if (n < 0) {\n        n = -n; // Make n positive for digit extraction\n    }\n    int sum = 0;\n    while (n > 0) {\n        sum += n % 10;\n        n /= 10;\n    }\n    return sum;\n}\n\n// Comparator function to sort based on the sum of digits and original index.\nbool compare_by_digit_sum(const std::pair<int, int>& a, const std::pair<int, int>& b) {\n    if (digit_sum(a.first) == digit_sum(b.first)) {\n        return a.second < b.second; // Maintain original order for ties\n    }\n    return digit_sum(a.first) < digit_sum(b.first);\n}\n\n// Function to sort the vector based on the sum of digits.\nstd::vector<int> order_by_points(std::vector<int> nums) {\n    std::vector<std::pair<int, int>> indexed_nums;\n    \n    // Create a vector of pairs (number, index)\n    for (int i = 0; i < nums.size(); ++i) {\n        indexed_nums.push_back({nums[i], i});\n    }\n    \n    // Sort the vector based on the custom comparator\n    std::sort(indexed_nums.begin(), indexed_nums.end(), compare_by_digit_sum);\n    \n    // Extract and return only the numbers from the sorted pairs\n    std::vector<int> result;\n    for (const auto& p : indexed_nums) {\n        result.push_back(p.first);\n    }\n    \n    return result;\n}\n\n// Function to check the correctness of the solution.\nvoid check() {\n    assert(order_by_points({1, 11, -1, -11, -12}) == std::vector<int>{-1, -11, 1, -12, 11});\n    assert(order_by_points({}) == std::vector<int>{});\n    assert(order_by_points({-100, -9, 0, 1, 10}) == std::vector<int>{0, 1, -9, -100, 10});\n}\n\n"}
{"task_id": "CPP/146", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nint specialFilter(vector<int> nums) {\n    int count = 0;\n    \n    for (int num : nums) {\n        // Skip numbers that are not greater than 10\n        if (num <= 10) continue;\n        \n        string strNum = to_string(num);\n        int firstDigit = strNum[0] - '0';\n        int lastDigit = strNum[strNum.length() - 1] - '0';\n        \n        // Check if both the first and last digits are odd\n        if (firstDigit % 2 != 0 && lastDigit % 2 != 0) {\n            count++;\n        }\n    }\n    \n    return count;\n}\n\n"}
{"task_id": "CPP/147", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint get_max_triples(int n) {\n    // Step 1: Generate the vector a\n    vector<int> a(n);\n    for (int i = 1; i <= n; ++i) {\n        a[i - 1] = i * i - i + 1;\n    }\n\n    int count = 0;\n\n    // Step 2 and 3: Iterate through all possible triples (i, j, k)\n    for (int i = 0; i < n - 2; ++i) {\n        for (int j = i + 1; j < n - 1; ++j) {\n            for (int k = j + 1; k < n; ++k) {\n                if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                    count++;\n                }\n            }\n        }\n    }\n\n    return count;\n}\n\n// Function to test the solution\nvoid check() {\n    int result = get_max_triples(5);\n    cout << \"Output: \" << result << endl; // Expected output: 1\n}\n\n"}
{"task_id": "CPP/148", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\n// Define the list of planets sorted by their proximity to the Sun.\nconst std::vector<std::string> planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n\nstd::vector<std::string> bf(std::string planet1, std::string planet2) {\n    // Find the indices of the given planets.\n    auto index1 = std::find(planets.begin(), planets.end(), planet1);\n    auto index2 = std::find(planets.begin(), planets.end(), planet2);\n\n    if (index1 == planets.end() || index2 == planets.end()) {\n        // If either planet is not found, return an empty vector.\n        return {};\n    }\n\n    int idx1 = std::distance(planets.begin(), index1);\n    int idx2 = std::distance(planets.begin(), index2);\n\n    // Ensure the indices are in ascending order.\n    if (idx1 > idx2) {\n        std::swap(idx1, idx2);\n    }\n\n    // Return the sublist of planets between the two indices.\n    return {planets.begin() + idx1 + 1, planets.begin() + idx2};\n}\n\n// Function to check the correctness of the bf function.\nvoid check() {\n    assert(bf(\"Jupiter\", \"Neptune\") == std::vector<std::string>{\"Saturn\", \"Uranus\"});\n    assert(bf(\"Earth\", \"Mercury\") == std::vector<std::string>{\"Venus\"});\n    assert(bf(\"Mercury\", \"Uranus\") == std::vector<std::string>{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"});\n    assert(bf(\"Pluto\", \"Mars\").empty()); // Pluto is not a valid planet name.\n}\n\n"}
{"task_id": "CPP/149", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nvector<string> vector_sort(const vector<string>& lst) {\n    // Filter out strings with odd lengths\n    vector<string> even_length_strings;\n    for (const string& s : lst) {\n        if (s.length() % 2 == 0) {\n            even_length_strings.push_back(s);\n        }\n    }\n\n    // Sort the filtered list by length, and then alphabetically if lengths are equal\n    sort(even_length_strings.begin(), even_length_strings.end(),\n         [](const string& a, const string& b) {\n             return a.length() == b.length() ? a < b : a.length() < b.length();\n         });\n\n    return even_length_strings;\n}\n\n"}
{"task_id": "CPP/150", "generation": "#include<stdio.h>\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int n) {\n    if (n <= 1) return false; // Numbers less than or equal to 1 are not prime\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\n// Function that returns x if n is a prime number, otherwise returns y\nint x_or_y(int n, int x, int y) {\n    return is_prime(n) ? x : y;\n}\n\n"}
{"task_id": "CPP/151", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nlong long double_the_difference(vector<float> lst) {\n    long long sum = 0;\n    \n    for (float num : lst) {\n        // Check if the number is positive, an integer, and odd\n        if (num > 0 && floor(num) == num && static_cast<int>(num) % 2 != 0) {\n            sum += pow(num, 2);\n        }\n    }\n    \n    return sum;\n}\n\n"}
{"task_id": "CPP/152", "generation": "#include <iostream>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\n// Function to compare the scores with guesses\nvector<int> compare(vector<int> game, vector<int> guess) {\n    vector<int> result;\n    \n    // Iterate through each match and calculate the absolute difference\n    for (size_t i = 0; i < game.size(); ++i) {\n        int diff = abs(game[i] - guess[i]);\n        result.push_back(diff);\n    }\n    \n    return result;\n}\n\n// Function to print a vector of integers\nvoid printVector(const vector<int>& vec) {\n    for (int num : vec) {\n        cout << num << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/153", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to calculate the strength of an extension\nint calculateStrength(const string& extension) {\n    int cap = 0, sm = 0;\n    for (char c : extension) {\n        if (isupper(c)) cap++;\n        else if (islower(c)) sm++;\n    }\n    return cap - sm;\n}\n\nstring Strongest_Extension(string class_name, vector<string> extensions) {\n    string strongest_extension = \"\";\n    int max_strength = INT_MIN;\n\n    for (const string& extension : extensions) {\n        int strength = calculateStrength(extension);\n        if (strength > max_strength) {\n            max_strength = strength;\n            strongest_extension = extension;\n        }\n    }\n\n    return class_name + \".\" + strongest_extension;\n}\n\n// Example usage\n"}
{"task_id": "CPP/154", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool cycpattern_check(string a, string b) {\n    // Concatenate the first string with itself to handle rotations\n    string doubled_a = a + a;\n    \n    // Check if the second string or any of its rotations is a substring of the concatenated string\n    return doubled_a.find(b) != string::npos;\n}\n\n"}
{"task_id": "CPP/155", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// Function to count even and odd digits in an integer\nvector<int> even_odd_count(int num) {\n    // Convert the number to a string to easily iterate over each digit\n    string str_num = to_string(abs(num));\n    \n    int even_count = 0;\n    int odd_count = 0;\n    \n    for (char digit : str_num) {\n        if ((digit - '0') % 2 == 0) {\n            even_count++;\n        } else {\n            odd_count++;\n        }\n    }\n    \n    return {even_count, odd_count};\n}\n\n// Function to test the even_odd_count function\nvoid test_even_odd_count() {\n    assert(even_odd_count(-12) == vector<int>({1, 1}));\n    assert(even_odd_count(123) == vector<int>({1, 2}));\n    assert(even_odd_count(0) == vector<int>({1, 0})); // Edge case: single digit 0\n    assert(even_odd_count(-9876543210) == vector<int>({5, 5}));\n    \n    cout << \"All test cases passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/156", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to convert an integer to its Roman numeral equivalent in lowercase\nstring int_to_mini_roman(int number) {\n    // Mapping of integers to their corresponding Roman numerals\n    vector<pair<int, string>> roman_map = {\n        {1000, \"m\"}, {900, \"cm\"}, {500, \"d\"}, {400, \"cd\"},\n        {100, \"c\"}, {90, \"xc\"}, {50, \"l\"}, {40, \"xl\"},\n        {10, \"x\"}, {9, \"ix\"}, {5, \"v\"}, {4, \"iv\"}, {1, \"i\"}\n    };\n\n    string roman_numeral = \"\";\n\n    // Iterate through the map and construct the Roman numeral\n    for (const auto& [value, symbol] : roman_map) {\n        while (number >= value) {\n            roman_numeral += symbol;\n            number -= value;\n        }\n    }\n\n    return roman_numeral;\n}\n\n// Function to check the correctness of the int_to_mini_roman function\nvoid check() {\n    assert(int_to_mini_roman(19) == \"xix\");\n    assert(int_to_mini_roman(152) == \"clii\");\n    assert(int_to_mini_roman(426) == \"cdxxvi\");\n    cout << \"All test cases passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/157", "generation": "#include <stdio.h>\n#include <math.h>\n\nusing namespace std;\n\nbool right_angle_triangle(float a, float b, float c) {\n    // First, sort the sides so that 'c' is the longest side (hypotenuse)\n    if (a > c) swap(a, c);\n    if (b > c) swap(b, c);\n\n    // Check if the Pythagorean theorem holds\n    return fabs(a*a + b*b - c*c) < 1e-6; // Using a small epsilon to account for floating point precision issues\n}\n\n"}
{"task_id": "CPP/158", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to count unique characters in a string\nint count_unique_chars(const string& word) {\n    bool seen[256] = {false};\n    int count = 0;\n    for (char c : word) {\n        if (!seen[c]) {\n            seen[c] = true;\n            count++;\n        }\n    }\n    return count;\n}\n\n// Function to find the word with maximum unique characters\nstring find_max(vector<string> words) {\n    string max_word = \"\";\n    int max_unique_chars = 0;\n\n    for (const auto& word : words) {\n        int unique_chars = count_unique_chars(word);\n        if (unique_chars > max_unique_chars || \n            (unique_chars == max_unique_chars && word < max_word)) {\n            max_word = word;\n            max_unique_chars = unique_chars;\n        }\n    }\n\n    return max_word;\n}\n\n// Function to test the find_max function\nvoid test_find_max() {\n    assert(find_max({\"name\", \"of\", \"string\"}) == \"string\");\n    assert(find_max({\"name\", \"enam\", \"game\"}) == \"enam\");\n    assert(find_max({\"aaaaaaa\", \"bb\", \"cc\"}) == \"aaaaaaa\");\n    cout << \"All test cases passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/159", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nvector<int> eat(int number, int need, int remaining) {\n    // Calculate the maximum number of carrots that can be eaten from the remaining stock\n    int max_to_eat = min(need, remaining);\n    \n    // Update the total number of carrots eaten\n    int total_eaten = number + max_to_eat;\n    \n    // Update the remaining carrots in stock\n    int remaining_after_meal = remaining - max_to_eat;\n    \n    return {total_eaten, remaining_after_meal};\n}\n\n// Function to test the eat function with provided examples\nvoid check() {\n    vector<int> result1 = eat(5, 6, 10);\n    printf(\"eat(5, 6, 10) -> {%d, %d}\\n\", result1[0], result1[1]); // Expected: {11, 4}\n    \n    vector<int> result2 = eat(4, 8, 9);\n    printf(\"eat(4, 8, 9) -> {%d, %d}\\n\", result2[0], result2[1]); // Expected: {12, 1}\n    \n    vector<int> result3 = eat(1, 10, 10);\n    printf(\"eat(1, 10, 10) -> {%d, %d}\\n\", result3[0], result3[1]); // Expected: {11, 0}\n    \n    vector<int> result4 = eat(2, 11, 5);\n    printf(\"eat(2, 11, 5) -> {%d, %d}\\n\", result4[0], result4[1]); // Expected: {7, 0}\n}\n\n"}
{"task_id": "CPP/160", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nint do_algebra(const vector<string>& operators, const vector<int>& operands) {\n    // Initialize the expression with the first operand\n    string expression = to_string(operands[0]);\n    \n    // Iterate through each operator and append it along with the next operand\n    for (size_t i = 0; i < operators.size(); ++i) {\n        expression += \" \" + operators[i] + \" \" + to_string(operands[i + 1]);\n    }\n    \n    // Evaluate the constructed expression using C++'s `std::stof` and `atof`\n    int result = std::stoi(expression);\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/161", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\n// Function to solve the problem as described\nstring solve(string s) {\n    bool hasLetters = false;\n    \n    // Check if there are any letters in the string\n    for (char c : s) {\n        if (isalpha(c)) {\n            hasLetters = true;\n            break;\n        }\n    }\n\n    if (!hasLetters) {\n        // If no letters, reverse the entire string\n        reverse(s.begin(), s.end());\n    } else {\n        // If there are letters, convert them to their opposite case\n        for (char &c : s) {\n            if (islower(c)) {\n                c = toupper(c);\n            } else if (isupper(c)) {\n                c = tolower(c);\n            }\n        }\n    }\n\n    return s;\n}\n\n// Function to test the solve function with provided examples\nvoid test() {\n    cout << \"solve(\\\"1234\\\") = \\\"\" << solve(\"1234\") << \"\\\" (Expected: \\\"4321\\\")\" << endl;\n    cout << \"solve(\\\"ab\\\") = \\\"\" << solve(\"ab\") << \"\\\" (Expected: \\\"AB\\\")\" << endl;\n    cout << \"solve(\\\"#a@C\\\") = \\\"\" << solve(\"#a@C\") << \"\\\" (Expected: \\\"#A@c\\\")\" << endl;\n}\n\n"}
{"task_id": "CPP/162", "generation": "#include <iostream>\n#include <openssl/md5.h>\n#include <sstream>\n#include <iomanip>\n\n// Function to convert byte array to hex string\nstd::string bytes_to_hex(const unsigned char* bytes, size_t len) {\n    std::stringstream ss;\n    for (size_t i = 0; i < len; ++i) {\n        ss << std::hex << std::setw(2) << std::setfill('0') << static_cast<int>(bytes[i]);\n    }\n    return ss.str();\n}\n\n// Function to convert string to MD5 hash\nstd::string string_to_md5(const std::string& text) {\n    if (text.empty()) {\n        return \"None\";\n    }\n\n    unsigned char digest[MD5_DIGEST_LENGTH];\n    MD5(reinterpret_cast<const unsigned char*>(text.c_str()), text.length(), digest);\n\n    // Convert the hash to a hexadecimal string\n    return bytes_to_hex(digest, MD5_DIGEST_LENGTH);\n}\n\n"}
{"task_id": "CPP/163", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> generate_integers(int a, int b) {\n    vector<int> result;\n    \n    // Ensure a is less than or equal to b for simplicity\n    if (a > b) swap(a, b);\n    \n    for (int num = min(a, b); num <= max(a, b); ++num) {\n        bool all_even_digits = true;\n        \n        // Check each digit of the number\n        for (char digit : to_string(num)) {\n            int d = digit - '0';\n            if (d % 2 != 0) {\n                all_even_digits = false;\n                break;\n            }\n        }\n        \n        // If all digits are even, add them to the result\n        if (all_even_digits) {\n            for (char digit : to_string(num)) {\n                int d = digit - '0';\n                result.push_back(d);\n            }\n        }\n    }\n    \n    // Sort and remove duplicates\n    sort(result.begin(), result.end());\n    auto last = unique(result.begin(), result.end());\n    result.erase(last, result.end());\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/0", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // For std::sort\n\nbool has_close_elements(vector<float> numbers, float threshold) {\n    // Sort the vector first\n    sort(numbers.begin(), numbers.end());\n\n    // Iterate through adjacent elements to check if any pair is closer than the threshold\n    for (size_t i = 0; i < numbers.size() - 1; ++i) {\n        if (numbers[i + 1] - numbers[i] < threshold) {\n            return true;\n        }\n    }\n\n    // If no such pair found, return false\n    return false;\n}\n\n"}
{"task_id": "CPP/1", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> separate_paren_groups(string paren_string) {\n    vector<string> result;\n    string current_group;\n    int balance = 0;\n\n    for (char ch : paren_string) {\n        if (ch == '(') {\n            balance++;\n            current_group += ch;\n        } else if (ch == ')') {\n            balance--;\n            current_group += ch;\n            if (balance == 0) {\n                result.push_back(current_group);\n                current_group.clear();\n            }\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/2", "generation": "#include <stdio.h>\n#include <math.h>\n\nfloat truncate_number(float number) {\n    float integerPart;\n    modf(number, &integerPart);  // modf returns the fractional part and stores the integer part in `integerPart`\n    return number - integerPart; // Subtracting the integer part from the original number gives the decimal part\n}\n\n"}
{"task_id": "CPP/3", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool below_zero(vector<int> operations) {\n    int balance = 0; // Start with a zero balance\n\n    for (int op : operations) {\n        balance += op; // Update the balance after each operation\n\n        if (balance < 0) { // Check if the balance falls below zero\n            return true;\n        }\n    }\n\n    return false; // Return false if the balance never goes below zero\n}\n\n// Function to test the below_zero function with provided examples\nvoid check_function() {\n    vector<int> operations1 = {1, 2, 3};\n    vector<int> operations2 = {1, 2, -4, 5};\n\n    cout << \"Test Case 1: \" << (below_zero(operations1) ? \"Passed\" : \"Failed\") << endl;\n    cout << \"Test Case 2: \" << (below_zero(operations2) ? \"Passed\" : \"Failed\") << endl;\n}\n\n"}
{"task_id": "CPP/4", "generation": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nfloat mean_absolute_deviation(vector<float> numbers) {\n    // Step 1: Calculate the mean of the dataset\n    float sum = 0.0;\n    for (const auto& num : numbers) {\n        sum += num;\n    }\n    float mean = sum / numbers.size();\n\n    // Step 2 and 3: Compute the absolute differences and their average\n    float mad = 0.0;\n    for (const auto& num : numbers) {\n        mad += abs(num - mean);\n    }\n    mad /= numbers.size();\n\n    return mad;\n}\n\n"}
{"task_id": "CPP/5", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> intersperse(vector<int> numbers, int delimeter) {\n    vector<int> result;\n    \n    // Iterate through the original vector and insert each element followed by the delimiter\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        result.push_back(numbers[i]);\n        if (i != numbers.size() - 1) {  // Do not add a delimiter after the last element\n            result.push_back(delimeter);\n        }\n    }\n    \n    return result;\n}\n\n// Function to test the intersperse function\nvoid testIntersperse() {\n    vector<int> emptyVec = {};\n    vector<int> vec1 = {1, 2, 3};\n    vector<int> expected1 = {1, 4, 2, 4, 3};\n\n    cout << \"Testing with an empty vector:\" << endl;\n    for (int num : intersperse(emptyVec, 4)) {\n        cout << num << \" \";\n    }\n    cout << endl;\n\n    cout << \"Testing with a non-empty vector:\" << endl;\n    for (int num : intersperse(vec1, 4)) {\n        cout << num << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/6", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to parse and determine the deepest level of nesting for a single group of parentheses\nint maxDepthOfNesting(const string& group) {\n    int currentDepth = 0;\n    int maxDepth = 0;\n    \n    for (char ch : group) {\n        if (ch == '(') {\n            currentDepth++;\n            maxDepth = max(maxDepth, currentDepth);\n        } else if (ch == ')') {\n            currentDepth--;\n        }\n    }\n    \n    return maxDepth;\n}\n\n// Function to process the entire string and return a vector of maximum depths for each group\nvector<int> parse_nested_parens(string paren_string) {\n    vector<int> result;\n    size_t start = 0;\n    size_t end = paren_string.find(' ');\n    \n    while (end != string::npos) {\n        // Extract the current group from the string\n        string group = paren_string.substr(start, end - start);\n        \n        // Calculate the maximum depth of nesting for the current group\n        int maxDepth = maxDepthOfNesting(group);\n        \n        result.push_back(maxDepth);\n        \n        // Move to the next group\n        start = end + 1;\n        end = paren_string.find(' ', start);\n    }\n    \n    // Process the last group if there is one\n    if (start < paren_string.length()) {\n        string group = paren_string.substr(start);\n        int maxDepth = maxDepthOfNesting(group);\n        result.push_back(maxDepth);\n    }\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/7", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to filter strings containing a given substring\nvector<string> filter_by_substring(vector<string> strings, string substring) {\n    vector<string> filtered_strings;\n    \n    // Iterate through each string in the input vector\n    for (const auto& str : strings) {\n        // Check if the current string contains the substring\n        if (str.find(substring) != string::npos) {\n            // If it does, add it to the filtered list\n            filtered_strings.push_back(str);\n        }\n    }\n    \n    return filtered_strings;\n}\n\n// Function to test the filter_by_substring function\nvoid test_filter_by_substring() {\n    vector<string> input1 = {};\n    vector<string> expected1 = {};\n    assert(filter_by_substring(input1, \"a\") == expected1);\n\n    vector<string> input2 = {\"abc\", \"bacd\", \"cde\", \"vector\"};\n    vector<string> expected2 = {\"abc\", \"bacd\", \"vector\"};\n    assert(filter_by_substring(input2, \"a\") == expected2);\n\n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/8", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// Function to calculate the sum and product of elements in a vector\nvector<int> sum_product(vector<int> numbers) {\n    int sum = 0;\n    int product = 1;\n\n    // Iterate through each number in the vector\n    for (int num : numbers) {\n        sum += num;  // Add the current number to the sum\n        product *= num;  // Multiply the current number with the product\n    }\n\n    return {sum, product};\n}\n\n// Function to test the sum_product function\nvoid test_sum_product() {\n    vector<int> empty = {};\n    vector<int> result1 = sum_product(empty);\n    cout << \"Empty Vector: Sum = \" << result1[0] << \", Product = \" << result1[1] << endl;\n\n    vector<int> numbers = {1, 2, 3, 4};\n    vector<int> result2 = sum_product(numbers);\n    cout << \"Vector [1, 2, 3, 4]: Sum = \" << result2[0] << \", Product = \" << result2[1] << endl;\n}\n\n"}
{"task_id": "CPP/9", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> rolling_max(vector<int> numbers) {\n    if (numbers.empty()) return {};  // Return an empty vector if input is empty\n\n    vector<int> result;\n    int current_max = numbers[0];  // Initialize the current maximum with the first element\n    for (int num : numbers) {\n        if (num > current_max) {\n            current_max = num;  // Update the current maximum if a larger number is found\n        }\n        result.push_back(current_max);  // Add the current maximum to the result vector\n    }\n\n    return result;\n}\n\n// Function to print the vector for testing purposes\nvoid print_vector(const vector<int>& vec) {\n    for (int num : vec) {\n        cout << num << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/10", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_palindrome(const string& str) {\n    // Test if given string is a palindrome\n    return str == string(str.rbegin(), str.rend());\n}\n\nstring make_palindrome(string str) {\n    /*\n    Find the shortest palindrome that begins with a supplied string. \n    Algorithm idea is simple: - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    */\n    \n    // Iterate from the beginning of the string\n    for (int i = 0; i < str.length(); ++i) {\n        // Check if the substring starting at position i is a palindrome\n        if (is_palindrome(str.substr(i))) {\n            // The longest palindromic suffix starts at position i\n            // The prefix before this suffix is from the start to position i-1\n            string prefix = str.substr(0, i);\n            reverse(prefix.begin(), prefix.end());  // Reverse the prefix\n            return str + prefix;  // Append the reversed prefix to the original string\n        }\n    }\n\n    // If no palindromic suffix is found (though it should not happen for valid input), return the original string\n    return str;\n}\n\n"}
{"task_id": "CPP/11", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring string_xor(string a, string b) {\n    // Ensure both strings are of equal length by padding with leading zeros if necessary\n    int maxLength = max(a.length(), b.length());\n    a.insert(0, maxLength - a.length(), '0');\n    b.insert(0, maxLength - b.length(), '0');\n\n    string result(maxLength, '0');  // Initialize the result string\n\n    // Perform XOR operation character by character\n    for (int i = 0; i < maxLength; ++i) {\n        if (a[i] != b[i]) {\n            result[i] = '1';  // If characters are different, set result to '1'\n        }\n    }\n\n    return result;\n}\n\n// Function to test the string_xor function\nvoid test_string_xor() {\n    cout << \"Testing string_xor function:\" << endl;\n    cout << \"Input: \\\"010\\\", \\\"110\\\" - Output: \\\"\" << string_xor(\"010\", \"110\") << \"\\\" (Expected: \\\"100\\\")\" << endl;\n    cout << \"Input: \\\"10101\\\", \\\"11001\\\" - Output: \\\"\" << string_xor(\"10101\", \"11001\") << \"\\\" (Expected: \\\"01100\\\")\" << endl;\n}\n\n"}
{"task_id": "CPP/12", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring longest(const vector<string>& strings) {\n    if (strings.empty()) {\n        return \"\"; // Return an empty string to indicate None in this context.\n    }\n\n    const string* longestString = &strings[0];\n    for (const auto& str : strings) {\n        if (str.length() > longestString->length()) {\n            longestString = &str;\n        }\n    }\n\n    return *longestString;\n}\n\n"}
{"task_id": "CPP/13", "generation": "#include <stdio.h>\nusing namespace std;\n\nint greatest_common_divisor(int a, int b) {\n    // Ensure a >= b to simplify the logic\n    if (b > a) {\n        return greatest_common_divisor(b, a);\n    }\n\n    // Base case: if b is 0, then GCD is a\n    if (b == 0) {\n        return a;\n    }\n\n    // Recursive call with remainder of a divided by b\n    return greatest_common_divisor(b, a % b);\n}\n\n"}
{"task_id": "CPP/14", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to generate all prefixes of the input string\nvector<string> all_prefixes(string str) {\n    vector<string> prefixes;\n    for (size_t i = 1; i <= str.length(); ++i) {\n        prefixes.push_back(str.substr(0, i));\n    }\n    return prefixes;\n}\n\n"}
{"task_id": "CPP/15", "generation": "#include <iostream>\n#include <sstream>\n#include <string>\nusing namespace std;\n\nstring string_sequence(int n) {\n    stringstream ss;\n    for (int i = 0; i <= n; ++i) {\n        ss << i;\n        if (i < n) {\n            ss << \" \";\n        }\n    }\n    return ss.str();\n}\n\n// Function to test the string_sequence function\nvoid test_string_sequence() {\n    cout << \"Testing string_sequence...\" << endl;\n    assert(string_sequence(0) == \"0\");\n    assert(string_sequence(5) == \"0 1 2 3 4 5\");\n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/16", "generation": "#include <iostream>\n#include <string>\n#include <set>\n\nusing namespace std;\n\nint count_distinct_characters(string str) {\n    // Convert the string to lowercase to ensure case insensitivity\n    transform(str.begin(), str.end(), str.begin(), ::tolower);\n    \n    // Use a set to store distinct characters\n    set<char> distinct_chars(str.begin(), str.end());\n    \n    // The size of the set is the number of distinct characters\n    return distinct_chars.size();\n}\n\n"}
{"task_id": "CPP/17", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<int> parse_music(string music_string) {\n    vector<int> beats;\n    \n    // Use istringstream to split the input string into individual notes\n    istringstream iss(music_string);\n    string note;\n    while (getline(iss, note, ' ')) {\n        if (note == \"o\") {\n            beats.push_back(4);\n        } else if (note == \"o|\") {\n            beats.push_back(2);\n        } else if (note == \".|\") {\n            beats.push_back(1);\n        }\n    }\n\n    return beats;\n}\n\n"}
{"task_id": "CPP/18", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint how_many_times(const string& str, const string& substring) {\n    if (substring.empty()) return 0;\n    \n    int count = 0;\n    size_t pos = 0;\n    \n    while ((pos = str.find(substring, pos)) != string::npos) {\n        ++count;\n        pos++; // Move to the next character to allow overlapping matches\n    }\n    \n    return count;\n}\n\n"}
{"task_id": "CPP/19", "generation": "#include <iostream>\n#include <string>\n#include <map>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to convert word to number\nint word_to_number(const string& word) {\n    map<string, int> num_map = {{\"zero\", 0}, {\"one\", 1}, {\"two\", 2}, {\"three\", 3},\n                                {\"four\", 4}, {\"five\", 5}, {\"six\", 6}, {\"seven\", 7},\n                                {\"eight\", 8}, {\"nine\", 9}};\n    return num_map[word];\n}\n\n// Function to sort numbers\nstring sort_numbers(const string& numbers) {\n    vector<string> words;\n    string number;\n    \n    // Split the input string into individual words\n    for (char ch : numbers) {\n        if (ch == ' ') {\n            if (!number.empty()) {\n                words.push_back(number);\n                number.clear();\n            }\n        } else {\n            number += ch;\n        }\n    }\n    if (!number.empty()) {\n        words.push_back(number);\n    }\n\n    // Sort the words based on their numeric value\n    sort(words.begin(), words.end(), [](const string& a, const string& b) {\n        return word_to_number(a) < word_to_number(b);\n    });\n\n    // Join the sorted words back into a single string\n    string result;\n    for (const auto& word : words) {\n        if (!result.empty()) {\n            result += \" \";\n        }\n        result += word;\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/20", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<float> find_closest_elements(vector<float> numbers) {\n    // Sort the vector of numbers\n    sort(numbers.begin(), numbers.end());\n    \n    // Initialize variables to store the closest pair and their minimum difference\n    float min_diff = numeric_limits<float>::max();\n    vector<float> result = {0.0, 0.0};\n    \n    // Iterate through the sorted list to find the closest pair\n    for (size_t i = 0; i < numbers.size() - 1; ++i) {\n        float diff = numbers[i + 1] - numbers[i];\n        \n        if (diff < min_diff) {\n            min_diff = diff;\n            result[0] = numbers[i];\n            result[1] = numbers[i + 1];\n        }\n    }\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/21", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // For std::min_element and std::max_element\n\nusing namespace std;\n\nvector<float> rescale_to_unit(vector<float> numbers) {\n    if (numbers.size() < 2) {\n        throw invalid_argument(\"Vector must contain at least two elements.\");\n    }\n\n    float min_value = *std::min_element(numbers.begin(), numbers.end());\n    float max_value = *std::max_element(numbers.begin(), numbers.end());\n\n    vector<float> scaled_numbers;\n    for (float num : numbers) {\n        float new_value = (num - min_value) / (max_value - min_value);\n        scaled_numbers.push_back(new_value);\n    }\n\n    return scaled_numbers;\n}\n\n"}
{"task_id": "CPP/22", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <list>\n#include <boost/any.hpp>\n\ntypedef std::list<boost::any> list_any;\nusing namespace std;\n\nvector<int> filter_integers(list_any values) {\n    vector<int> result;\n    for (const auto& value : values) {\n        if (value.type() == typeid(int)) {\n            result.push_back(boost::any_cast<int>(value));\n        }\n    }\n    return result;\n}\n\n"}
{"task_id": "CPP/23", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint strlen(const string& str) {\n    // Return the size of the string, which is equivalent to its length.\n    return str.size();\n}\n\n// Function to test the strlen function with some examples\nvoid test_strlen() {\n    cout << \"Length of \\\"\\\" (empty string): \" << strlen(\"\") << endl;\n    cout << \"Length of \\\"abc\\\": \" << strlen(\"abc\") << endl;\n    cout << \"Length of \\\"hello world\\\": \" << strlen(\"hello world\") << endl;\n}\n\n"}
{"task_id": "CPP/24", "generation": "#include <iostream>\nusing namespace std;\n\nint largest_divisor(int n) {\n    for (int i = n - 1; i > 0; --i) {\n        if (n % i == 0) {\n            return i;\n        }\n    }\n    // If no divisor is found, which should not happen for positive integers,\n    // we can return -1 or throw an exception. For simplicity, returning -1.\n    return -1;\n}\n\n"}
{"task_id": "CPP/25", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> factorize(int n) {\n    vector<int> factors;\n    \n    // Divide by 2 to get rid of all even factors\n    while (n % 2 == 0) {\n        factors.push_back(2);\n        n /= 2;\n    }\n    \n    // Check for odd factors from 3 onwards\n    for (int i = 3; i * i <= n; i += 2) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n    \n    // If n is a prime number greater than 2\n    if (n > 2) {\n        factors.push_back(n);\n    }\n    \n    return factors;\n}\n\n"}
{"task_id": "CPP/26", "generation": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nvector<int> remove_duplicates(vector<int> numbers) {\n    // Create an unordered map to count occurrences of each element\n    unordered_map<int, int> counts;\n    \n    // Count the occurrences of each number in the input vector\n    for (int num : numbers) {\n        counts[num]++;\n    }\n    \n    // Create a new vector to store elements that occur exactly once\n    vector<int> result;\n    \n    // Iterate through the original vector and add elements to the result if they occur only once\n    for (int num : numbers) {\n        if (counts[num] == 1) {\n            result.push_back(num);\n        }\n    }\n    \n    return result;\n}\n\n// Function to check the correctness of the remove_duplicates function\nvoid check() {\n    vector<int> input = {1, 2, 3, 2, 4};\n    vector<int> expected_output = {1, 3, 4};\n    vector<int> output = remove_duplicates(input);\n    \n    if (output == expected_output) {\n        cout << \"Test passed.\" << endl;\n    } else {\n        cout << \"Test failed.\" << endl;\n    }\n}\n\n"}
{"task_id": "CPP/27", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring flip_case(string str) {\n    for (char &c : str) {\n        if (islower(c)) {\n            c = toupper(c);\n        } else if (isupper(c)) {\n            c = tolower(c);\n        }\n    }\n    return str;\n}\n\n"}
{"task_id": "CPP/28", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <numeric> // For std::accumulate\n\nusing namespace std;\n\nstring concatenate(vector<string> strings) {\n    // Use std::accumulate to concatenate all strings in the vector\n    return accumulate(strings.begin(), strings.end(), string(\"\"));\n}\n\n// Function to test the concatenate function\nvoid test_concatenate() {\n    assert(concatenate({}) == \"\");\n    assert(concatenate({\"a\", \"b\", \"c\"}) == \"abc\");\n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/29", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to filter strings based on the given prefix\nvector<string> filter_by_prefix(vector<string> strings, string prefix) {\n    vector<string> filtered_strings;\n    \n    // Iterate through each string in the input vector\n    for (const auto& str : strings) {\n        // Check if the current string starts with the given prefix\n        if (str.substr(0, prefix.length()) == prefix) {\n            // If it does, add it to the filtered list\n            filtered_strings.push_back(str);\n        }\n    }\n    \n    return filtered_strings;\n}\n\n// Function to test the filter_by_prefix function\nvoid test_filter_by_prefix() {\n    vector<string> input1 = {};\n    string prefix1 = \"a\";\n    vector<string> result1 = filter_by_prefix(input1, prefix1);\n    cout << \"Test 1: \";\n    if (result1.empty()) {\n        cout << \"Passed\" << endl;\n    } else {\n        cout << \"Failed\" << endl;\n    }\n\n    vector<string> input2 = {\"abc\", \"bcd\", \"cde\", \"vector\"};\n    string prefix2 = \"a\";\n    vector<string> result2 = filter_by_prefix(input2, prefix2);\n    cout << \"Test 2: \";\n    if (result2 == vector<string>{\"abc\", \"vector\"}) {\n        cout << \"Passed\" << endl;\n    } else {\n        cout << \"Failed\" << endl;\n    }\n}\n\n"}
{"task_id": "CPP/30", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvector<float> get_positive(vector<float> l) {\n    vector<float> result;\n    for (float num : l) {\n        if (num > 0) {\n            result.push_back(num);\n        }\n    }\n    return result;\n}\n\n"}
{"task_id": "CPP/31", "generation": "#include <iostream>\nusing namespace std;\n\nbool is_prime(long long n) {\n    // Handle edge cases for numbers less than or equal to 1\n    if (n <= 1) return false;\n    \n    // Check divisibility from 2 up to the square root of n\n    for (long long i = 2; i * i <= n; ++i) {\n        if (n % i == 0) {\n            return false; // Found a divisor, so it's not prime\n        }\n    }\n    \n    return true; // No divisors found, so it is prime\n}\n\n"}
{"task_id": "CPP/32", "generation": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <cassert>\n\ndouble poly(const std::vector<double>& xs, double x) {\n    double sum = 0;\n    for (size_t i = 0; i < xs.size(); ++i) {\n        sum += xs[i] * pow(x, static_cast<int>(i));\n    }\n    return sum;\n}\n\ndouble find_zero(const std::vector<double>& xs) {\n    assert(xs.size() % 2 == 0); // Ensure the number of coefficients is even\n    double largest_non_zero = -std::numeric_limits<double>::max();\n    size_t index_of_largest = 0;\n\n    for (size_t i = 0; i < xs.size(); ++i) {\n        if (fabs(xs[i]) > fabs(largest_non_zero)) {\n            largest_non_zero = xs[i];\n            index_of_largest = i;\n        }\n    }\n\n    assert(largest_non_zero != 0); // Ensure there is a non-zero coefficient\n\n    double initial_guess = static_cast<double>(index_of_largest + 1);\n    double zero_point = fsolve(poly, initial_guess, xs);\n\n    return round(zero_point * 100) / 100; // Round to two decimal places\n}\n\ndouble fsolve(double (*func)(double, const std::vector<double>&), double x0, const std::vector<double>& params) {\n    // Placeholder for the actual implementation of fsolve using a numerical method like Newton's method or bisection.\n    // For simplicity, we assume this function is implemented elsewhere and returns an approximate root.\n    return 1.0; // Dummy value\n}\n\n"}
{"task_id": "CPP/33", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> sort_third(vector<int> l) {\n    // Extract elements at indices divisible by 3\n    vector<int> third_elements;\n    for (int i = 2; i < l.size(); i += 3) {\n        third_elements.push_back(l[i]);\n    }\n\n    // Sort the extracted elements\n    sort(third_elements.begin(), third_elements.end());\n\n    // Create result list as a copy of the original list\n    vector<int> l_prime = l;\n\n    // Replace sorted values in the result list at indices divisible by 3\n    for (int i = 0, j = 0; i < l.size(); i += 3, ++j) {\n        l_prime[i] = third_elements[j];\n    }\n\n    return l_prime;\n}\n\n// Function to print the vector\nvoid print_vector(const vector<int>& v) {\n    for (int val : v) {\n        cout << val << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/34", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> unique(vector<int> l) {\n    // Sort the input vector\n    sort(l.begin(), l.end());\n    \n    // Remove consecutive duplicate elements\n    auto last = unique(l.begin(), l.end());\n    \n    // Resize the vector to contain only the unique elements\n    l.resize(distance(l.begin(), last));\n    \n    return l;\n}\n\n"}
{"task_id": "CPP/35", "generation": "#include <iostream>\n#include <vector>\n\nfloat max_element(const std::vector<float>& l) {\n    if (l.empty()) {\n        throw std::invalid_argument(\"Vector is empty\");\n    }\n\n    float max_val = l[0];\n    for (size_t i = 1; i < l.size(); ++i) {\n        if (l[i] > max_val) {\n            max_val = l[i];\n        }\n    }\n    return max_val;\n}\n\n"}
{"task_id": "CPP/36", "generation": "#include <iostream>\nusing namespace std;\n\nint fizz_buzz(int n) {\n    int count = 0;\n    \n    for (int i = 1; i < n; ++i) {\n        if (i % 11 == 0 || i % 13 == 0) {\n            // Convert the number to a string and count occurrences of '7'\n            string num_str = to_string(i);\n            for (char c : num_str) {\n                if (c == '7') {\n                    ++count;\n                }\n            }\n        }\n    }\n    \n    return count;\n}\n\n"}
{"task_id": "CPP/37", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<float> sort_even(vector<float> l) {\n    // Extract elements at even indices\n    vector<float> evens;\n    for (size_t i = 0; i < l.size(); i += 2) {\n        evens.push_back(l[i]);\n    }\n\n    // Sort the extracted elements\n    sort(evens.begin(), evens.end());\n\n    // Place sorted elements back into their original positions\n    size_t evenIndex = 0;\n    for (size_t i = 0; i < l.size(); ++i) {\n        if (i % 2 == 0) {\n            l[i] = evens[evenIndex++];\n        }\n    }\n\n    return l;\n}\n\n// Function to check the correctness of the sort_even function\nvoid check() {\n    vector<float> result1 = sort_even({1, 2, 3});\n    assert(result1 == vector<float>({1, 2, 3}));\n\n    vector<float> result2 = sort_even({5, 6, 3, 4});\n    assert(result2 == vector<float>({3, 6, 5, 4}));\n\n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/38", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nstring encode_cyclic(string s) { \n    // returns encoded string by cycling groups of three characters.  \n    int l = s.length();\n    int num = (l + 2) / 3;\n    string x, output;\n    for (int i = 0; i * 3 < l; i++) {\n        x = s.substr(i * 3, 3);\n        if (x.length() == 3) x = x.substr(1) + x[0];\n        output += x;\n    }\n    return output;\n}\n\nstring decode_cyclic(string s) { \n    /*\n    takes as input string encoded with encode_cyclic function. Returns decoded string.\n    */\n    int l = s.length();\n    int num = (l + 2) / 3;\n    string x, output;\n    for (int i = 0; i * 3 < l; i++) {\n        x = s.substr(i * 3, 3);\n        if (x.length() == 3) x = x[2] + x.substr(0, 2); // Rotate one position to the left\n        output += x;\n    }\n    return output;\n}\n\n"}
{"task_id": "CPP/39", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    if (num == 2 || num == 3) return true;\n    if (num % 2 == 0 || num % 3 == 0) return false;\n    for (int i = 5; i * i <= num; i += 6) {\n        if (num % i == 0 || num % (i + 2) == 0)\n            return false;\n    }\n    return true;\n}\n\n// Function to generate the n-th prime Fibonacci number\nint prime_fib(int n) {\n    int count = 0; // Counter for prime Fibonacci numbers found\n    long fib1 = 0, fib2 = 1; // First two Fibonacci numbers\n\n    while (true) {\n        long next_fib = fib1 + fib2;\n        if (is_prime(next_fib)) {\n            count++;\n            if (count == n) return next_fib;\n        }\n        fib1 = fib2;\n        fib2 = next_fib;\n    }\n}\n\n"}
{"task_id": "CPP/40", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool triples_sum_to_zero(vector<int> l) {\n    int n = l.size();\n    \n    // Iterate through each element in the list\n    for (int i = 0; i < n - 2; ++i) {\n        // Iterate through elements after the current one\n        for (int j = i + 1; j < n - 1; ++j) {\n            // Iterate through elements after the second one\n            for (int k = j + 1; k < n; ++k) {\n                // Check if the sum of the triplet is zero\n                if (l[i] + l[j] + l[k] == 0) {\n                    return true;\n                }\n            }\n        }\n    }\n    \n    // If no such triplet is found, return false\n    return false;\n}\n\n"}
{"task_id": "CPP/41", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint car_race_collision(int n) {\n    // Since all cars are moving at the same speed and start far apart,\n    // each car traveling left to right will eventually collide with each car\n    // traveling right to left.\n    return n * n;\n}\n\n"}
{"task_id": "CPP/42", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> incr_list(vector<int> l) {\n    for (int i = 0; i < l.size(); ++i) {\n        l[i] += 1;\n    }\n    return l;\n}\n\n// Function to print the vector for verification\nvoid print_vector(const vector<int>& v) {\n    for (const int& val : v) {\n        cout << val << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/43", "generation": "#include <iostream>\n#include <vector>\n#include <set>\n\nusing namespace std;\n\nbool pairs_sum_to_zero(vector<int> l) {\n    // Use a set to store seen numbers\n    set<int> seen;\n    \n    for (int num : l) {\n        // Check if the negation of the current number is in the set\n        if (seen.find(-num) != seen.end()) {\n            return true;\n        }\n        // Add the current number to the set\n        seen.insert(num);\n    }\n    \n    // If no such pair is found, return false\n    return false;\n}\n\n"}
{"task_id": "CPP/44", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring change_base(int x, int base) {\n    if (x == 0) return \"0\"; // Handle the case where x is zero\n\n    string result = \"\";\n    while (x > 0) {\n        int remainder = x % base;\n        char digit = '0' + remainder; // Convert the integer to its character representation\n        result = digit + result; // Prepend the digit to the result string\n        x /= base; // Divide x by the base\n    }\n    return result;\n}\n\n"}
{"task_id": "CPP/45", "generation": "#include <iostream>\nusing namespace std;\n\nfloat triangle_area(float a, float h) {\n    return 0.5 * a * h;\n}\n\n"}
{"task_id": "CPP/46", "generation": "#include <stdio.h>\nusing namespace std;\n\nint fib4(int n) {\n    if (n == 0 || n == 1 || n == 3) return 0;\n    if (n == 2) return 2;\n\n    int a = 0, b = 0, c = 2, d = 0, result;\n    \n    for (int i = 4; i <= n; ++i) {\n        result = a + b + c + d;\n        a = b;\n        b = c;\n        c = d;\n        d = result;\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/47", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nfloat median(vector<float> l) {\n    // Sort the vector\n    sort(l.begin(), l.end());\n    \n    int n = l.size();\n    \n    if (n % 2 == 0) {\n        // If even number of elements, return the average of the two middle elements\n        return (l[n / 2 - 1] + l[n / 2]) / 2.0;\n    } else {\n        // If odd number of elements, return the middle element\n        return l[n / 2];\n    }\n}\n\n"}
{"task_id": "CPP/48", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_palindrome(string text) {\n    int left = 0;\n    int right = text.length() - 1;\n\n    while (left < right) {\n        if (text[left] != text[right]) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n\n    return true;\n}\n\n"}
{"task_id": "CPP/49", "generation": "#include <stdio.h>\nusing namespace std;\n\nint modp(int n, int p) {\n    if (n == 0)\n        return 1; // Any number to the power of 0 is 1\n\n    long result = 1;\n    long base = 2;\n\n    while (n > 0) {\n        // If n is odd, multiply the result by the current base\n        if (n % 2 == 1)\n            result = (result * base) % p;\n\n        // Square the base and reduce it modulo p\n        base = (base * base) % p;\n        n /= 2; // Divide n by 2\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/50", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nstring encode_shift(string s) {\n    // returns encoded string by shifting every character by 5 in the alphabet.\n    string out;\n    for (int i = 0; i < s.length(); i++) {\n        if (s[i] >= 'a' && s[i] <= 'z') {\n            int w = ((int)s[i] + 5 - (int)'a') % 26 + (int)'a';\n            out += (char)w;\n        } else {\n            // Non-alphabetic characters are not shifted\n            out += s[i];\n        }\n    }\n    return out;\n}\n\nstring decode_shift(string s) {\n    // takes as input string encoded with encode_shift function. Returns decoded string.\n    string out;\n    for (int i = 0; i < s.length(); i++) {\n        if (s[i] >= 'a' && s[i] <= 'z') {\n            int w = ((int)s[i] - 5 - (int)'a') % 26 + (int)'a';\n            out += (char)w;\n        } else {\n            // Non-alphabetic characters are not shifted\n            out += s[i];\n        }\n    }\n    return out;\n}\n\n"}
{"task_id": "CPP/51", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nbool is_vowel(char c) {\n    // Convert character to lowercase for simplicity\n    char lower_c = tolower(c);\n    return lower_c == 'a' || lower_c == 'e' || lower_c == 'i' || lower_c == 'o' || lower_c == 'u';\n}\n\nstring remove_vowels(string text) {\n    string result;\n    for (char c : text) {\n        if (!is_vowel(c)) {\n            result += c;\n        }\n    }\n    return result;\n}\n\n"}
{"task_id": "CPP/52", "generation": "#include <vector>\n#include <iostream>\n\n// Function to check if all elements in the vector are below the threshold\nbool below_threshold(const std::vector<int>& l, int t) {\n    for (int num : l) {\n        if (num >= t) {\n            return false;\n        }\n    }\n    return true;\n}\n\n// Function to test the below_threshold function with provided data points\nvoid check_function() {\n    assert(below_threshold({1, 2, 4, 10}, 100) == true);\n    assert(below_threshold({1, 20, 4, 10}, 5) == false);\n    std::cout << \"All tests passed successfully.\" << std::endl;\n}\n\n"}
{"task_id": "CPP/53", "generation": "#include <iostream>  // Include iostream for input/output operations\n\nusing namespace std;\n\nint add(int x, int y) {\n    return x + y;  // Return the sum of x and y\n}\n\n"}
{"task_id": "CPP/54", "generation": "#include <iostream>\n#include <string>\n#include <set>\n\nusing namespace std;\n\nbool same_chars(string s0, string s1) {\n    // Create a set for each string to store unique characters\n    set<char> chars_s0(s0.begin(), s0.end());\n    set<char> chars_s1(s1.begin(), s1.end());\n\n    // Compare the sets\n    return chars_s0 == chars_s1;\n}\n\n"}
{"task_id": "CPP/55", "generation": "#include <stdio.h>\nusing namespace std;\n\nint fib(int n) {\n    if (n <= 0) return 0;\n    else if (n == 1) return 1;\n    else return fib(n - 1) + fib(n - 2);\n}\n\n"}
{"task_id": "CPP/56", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    int count = 0;\n    \n    for (char c : brackets) {\n        if (c == '<') {\n            count++;\n        } else if (c == '>') {\n            count--;\n            if (count < 0) {\n                return false; // More closing brackets than opening ones\n            }\n        }\n    }\n    \n    return count == 0; // True if all brackets are correctly matched\n}\n\n"}
{"task_id": "CPP/57", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool monotonic(vector<float> l) {\n    if (l.size() <= 1) {\n        return true; // A vector with 0 or 1 element is trivially monotonic.\n    }\n\n    bool increasing = false;\n    bool decreasing = false;\n\n    for (size_t i = 1; i < l.size(); ++i) {\n        if (l[i] > l[i - 1]) {\n            increasing = true;\n        } else if (l[i] < l[i - 1]) {\n            decreasing = true;\n        }\n\n        // If both increasing and decreasing flags are set, the sequence is not monotonic.\n        if (increasing && decreasing) {\n            return false;\n        }\n    }\n\n    return true; // The sequence is either strictly increasing or strictly decreasing.\n}\n\n"}
{"task_id": "CPP/58", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\n\nusing namespace std;\n\nvector<int> common(vector<int> l1, vector<int> l2) {\n    // Create sets from both vectors\n    set<int> s1(l1.begin(), l1.end());\n    set<int> s2(l2.begin(), l2.end());\n\n    // Find the intersection of the two sets\n    set<int> result;\n    set_intersection(s1.begin(), s1.end(), s2.begin(), s2.end(), inserter(result, result.begin()));\n\n    // Convert the set to a vector and sort it\n    vector<int> commonElements(result.begin(), result.end());\n    sort(commonElements.begin(), commonElements.end());\n\n    return commonElements;\n}\n\n"}
{"task_id": "CPP/59", "generation": "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\nint largest_prime_factor(int n) {\n    // Remove all factors of 2\n    while (n % 2 == 0) {\n        n /= 2;\n    }\n\n    // Check for odd factors from 3 to sqrt(n)\n    int factor = 3;\n    while (factor * factor <= n) {\n        while (n % factor == 0) {\n            n /= factor;\n        }\n        factor += 2;\n    }\n\n    // If n is a prime number greater than 2\n    if (n > 2) {\n        return n;\n    } else {\n        return factor - 2; // The last factor found will be the largest prime factor\n    }\n}\n\n"}
{"task_id": "CPP/60", "generation": "#include <iostream>\nusing namespace std;\n\nint sum_to_n(int n) {\n    int sum = 0;\n    for (int i = 1; i <= n; ++i) {\n        sum += i;\n    }\n    return sum;\n}\n\n// Function to test the sum_to_n function with provided data points\nvoid test_sum_to_n() {\n    cout << \"Testing sum_to_n...\" << endl;\n    assert(sum_to_n(30) == 465);\n    assert(sum_to_n(100) == 5050);\n    assert(sum_to_n(5) == 15);\n    assert(sum_to_n(10) == 55);\n    assert(sum_to_n(1) == 1);\n\n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/61", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    int balance = 0;\n    \n    for (char bracket : brackets) {\n        if (bracket == '(') {\n            balance++;\n        } else if (bracket == ')') {\n            balance--;\n        }\n        \n        // If at any point the balance is negative, it means there's a closing bracket without an opening one\n        if (balance < 0) {\n            return false;\n        }\n    }\n    \n    // If the final balance is zero, all brackets are correctly matched\n    return balance == 0;\n}\n\n"}
{"task_id": "CPP/62", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// Function to compute the derivative of a polynomial represented by its coefficients\nvector<float> derivative(vector<float> xs) {\n    // Create a new vector to hold the derivatives, starting from index 1 (ignoring the constant term)\n    vector<float> result;\n    \n    for (size_t i = 1; i < xs.size(); ++i) {\n        // Multiply each coefficient by its corresponding power\n        result.push_back(xs[i] * static_cast<float>(i));\n    }\n    \n    return result;\n}\n\n// Function to print the polynomial coefficients\nvoid printPolynomial(const vector<float>& coeffs) {\n    for (size_t i = 0; i < coeffs.size(); ++i) {\n        cout << coeffs[i];\n        if (i != coeffs.size() - 1) {\n            cout << \" * x^\" << i;\n        }\n        if (i != coeffs.size() - 2) {\n            cout << \" + \";\n        }\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/63", "generation": "#include <iostream>\nusing namespace std;\n\nint fibfib(int n) {\n    // Base cases\n    if (n == 0 || n == 1) return 0;\n    if (n == 2) return 1;\n\n    // Array to store the computed values of FibFib sequence\n    int dp[n + 1];\n    dp[0] = 0; // fibfib(0)\n    dp[1] = 0; // fibfib(1)\n    dp[2] = 1; // fibfib(2)\n\n    // Fill the dp array using the recurrence relation\n    for (int i = 3; i <= n; ++i) {\n        dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3];\n    }\n\n    return dp[n];\n}\n\n"}
{"task_id": "CPP/64", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nint vowels_count(const string& s) {\n    int count = 0;\n    \n    // Define a set of vowels including 'y' which is considered a vowel only if it's at the end\n    const char* vowels = \"aeiou\";\n    bool y_at_end = (s.back() == 'y' || s.back() == 'Y');\n    \n    for (char c : s) {\n        // Check if the character is a vowel or 'y' at the end\n        if (strchr(vowels, tolower(c)) != nullptr || (c == 'y' && y_at_end)) {\n            count++;\n        }\n    }\n    \n    return count;\n}\n\n"}
{"task_id": "CPP/65", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nstring circular_shift(int x, int shift) {\n    // Convert the integer to a string to easily manipulate digits\n    string num_str = to_string(x);\n    int num_length = num_str.length();\n    \n    // If shift is greater than or equal to the number of digits, reverse the string\n    if (shift >= num_length) {\n        reverse(num_str.begin(), num_str.end());\n        return num_str;\n    }\n    \n    // Perform circular right shift by slicing and concatenating\n    int start = num_length - shift;\n    string shifted_str = num_str.substr(start) + num_str.substr(0, start);\n    return shifted_str;\n}\n\n// Function to test the circular_shift function\nvoid test_circular_shift() {\n    cout << \"Testing circular_shift:\" << endl;\n    cout << \"circular_shift(1234, 1): \" << circular_shift(1234, 1) << \" (Expected: 4123)\" << endl;\n    cout << \"circular_shift(1234, 2): \" << circular_shift(1234, 2) << \" (Expected: 3412)\" << endl;\n    cout << \"circular_shift(1234, 5): \" << circular_shift(1234, 5) << \" (Expected: 4321)\" << endl;\n}\n\n"}
{"task_id": "CPP/66", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint digitSum(const string& s) {\n    int sum = 0;\n    for (char c : s) {\n        if (isupper(c)) { // Check if the character is uppercase\n            sum += static_cast<int>(c); // Add its ASCII value to the sum\n        }\n    }\n    return sum;\n}\n\n// Function to test the digitSum function with provided examples\nvoid checkFunction() {\n    assert(digitSum(\"\") == 0);\n    assert(digitSum(\"abAB\") == 131);\n    assert(digitSum(\"abcCd\") == 67);\n    assert(digitSum(\"helloE\") == 69);\n    assert(digitSum(\"woArBld\") == 131);\n    assert(digitSum(\"aAaaaXa\") == 153);\n\n    cout << \"All test cases passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/67", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint fruit_distribution(string s, int n) {\n    // Find the positions of \"apples\" and \"oranges\"\n    size_t apple_pos = s.find(\" apples \");\n    size_t orange_pos = s.find(\" oranges\");\n\n    // Extract the number of apples\n    string apples_str = s.substr(apple_pos + 8, orange_pos - apple_pos - 8);\n    int apples = stoi(apples_str);\n\n    // Extract the number of oranges\n    string oranges_str = s.substr(orange_pos + 9);\n    int oranges = stoi(oranges_str);\n\n    // Calculate the number of mangoes\n    int mangoes = n - (apples + oranges);\n\n    return mangoes;\n}\n\n"}
{"task_id": "CPP/68", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> pluck(vector<int> arr) {\n    // Filter out even numbers and sort them by value and index\n    vector<pair<int, int>> even_nodes;\n    for (int i = 0; i < arr.size(); ++i) {\n        if (arr[i] % 2 == 0) {\n            even_nodes.push_back({arr[i], i});\n        }\n    }\n\n    // If there are no even nodes, return an empty vector\n    if (even_nodes.empty()) {\n        return {};\n    }\n\n    // Sort by value and then by index\n    sort(even_nodes.begin(), even_nodes.end());\n\n    // Return the node with the smallest even value and its index\n    return {even_nodes[0].first, even_nodes[0].second};\n}\n\n"}
{"task_id": "CPP/69", "generation": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint search(vector<int> lst) {\n    // Create a frequency map to count occurrences of each integer\n    unordered_map<int, int> freqMap;\n    \n    // Count the frequency of each number in the vector\n    for (int num : lst) {\n        freqMap[num]++;\n    }\n    \n    // Initialize the result as -1\n    int result = -1;\n    \n    // Iterate through the unique numbers and check the condition\n    for (auto& pair : freqMap) {\n        if (pair.first <= pair.second && pair.first > result) {\n            result = pair.first;\n        }\n    }\n    \n    return result;\n}\n\n// Function to test the search function with provided examples\nvoid test() {\n    cout << \"search({4, 1, 2, 2, 3, 1}) == \" << search({4, 1, 2, 2, 3, 1}) << endl; // Should output 2\n    cout << \"search({1, 2, 2, 3, 3, 3, 4, 4, 4}) == \" << search({1, 2, 2, 3, 3, 3, 4, 4, 4}) << endl; // Should output 3\n    cout << \"search({5, 5, 4, 4, 4}) == \" << search({5, 5, 4, 4, 4}) << endl; // Should output -1\n}\n\n"}
{"task_id": "CPP/70", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> strange_sort_list(vector<int> lst) {\n    // Sort the list in ascending order\n    sort(lst.begin(), lst.end());\n    \n    vector<int> result;\n    int start = 0; // Start index for minimum values\n    int end = lst.size() - 1; // End index for maximum values\n    \n    while (start <= end) {\n        if (start == end) {\n            // If only one element is left, add it to the result\n            result.push_back(lst[start]);\n        } else {\n            // Add the minimum value from the start\n            result.push_back(lst[start++]);\n            // Add the maximum value from the end\n            result.push_back(lst[end--]);\n        }\n    }\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/71", "generation": "#include <stdio.h>\n#include <math.h>\n\nusing namespace std;\n\nfloat triangle_area(float a, float b, float c) {\n    // Check if the sides form a valid triangle\n    if (a + b <= c || a + c <= b || b + c <= a) {\n        return -1;\n    }\n\n    // Calculate the semi-perimeter\n    float s = (a + b + c) / 2.0;\n\n    // Calculate the area using Heron's formula\n    float area = sqrt(s * (s - a) * (s - b) * (s - c));\n\n    // Round the result to 2 decimal points\n    return round(area * 100) / 100;\n}\n\n"}
{"task_id": "CPP/72", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool will_it_fly(vector<int> q, int w) {\n    // Check if the sum of elements is within the weight limit\n    int sum = 0;\n    for (int num : q) {\n        sum += num;\n    }\n    if (sum > w) return false;\n\n    // Check if the vector is a palindrome\n    for (size_t i = 0; i < q.size() / 2; ++i) {\n        if (q[i] != q[q.size() - 1 - i]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\n// Function to test the will_it_fly function with provided examples\nvoid check() {\n    cout << boolalpha; // Print bools as true/false instead of 1/0\n    cout << \"will_it_fly({1, 2}, 5): \" << will_it_fly({1, 2}, 5) << endl;\n    cout << \"will_it_fly({3, 2, 3}, 1): \" << will_it_fly({3, 2, 3}, 1) << endl;\n    cout << \"will_it_fly({3, 2, 3}, 9): \" << will_it_fly({3, 2, 3}, 9) << endl;\n    cout << \"will_it_fly({3}, 5): \" << will_it_fly({3}, 5) << endl;\n}\n\n"}
{"task_id": "CPP/73", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint smallest_change(vector<int> arr) {\n    int n = arr.size();\n    int left = 0;\n    int right = n - 1;\n    int changes = 0;\n\n    while (left < right) {\n        if (arr[left] != arr[right]) {\n            changes++;\n        }\n        left++;\n        right--;\n    }\n\n    return changes;\n}\n\n"}
{"task_id": "CPP/74", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to calculate the total number of characters in a vector of strings\nint total_chars(const vector<string>& vec) {\n    int sum = 0;\n    for (const auto& str : vec) {\n        sum += str.length();\n    }\n    return sum;\n}\n\nvector<string> total_match(vector<string> lst1, vector<string> lst2) {\n    // Calculate the total number of characters in both vectors\n    int chars_lst1 = total_chars(lst1);\n    int chars_lst2 = total_chars(lst2);\n\n    // Compare and return the appropriate vector\n    if (chars_lst1 < chars_lst2) {\n        return lst1;\n    } else if (chars_lst2 < chars_lst1) {\n        return lst2;\n    } else {\n        return lst1;  // Return the first vector if both have the same number of characters\n    }\n}\n\n// Function to test the total_match function with provided examples\nvoid test_total_match() {\n    cout << \"Test 1: \";\n    vector<string> result = total_match({}, {});\n    for (const auto& str : result) {\n        cout << str << \" \";\n    }\n    cout << endl;\n\n    cout << \"Test 2: \";\n    result = total_match({\"hi\", \"admin\"}, {\"hI\", \"Hi\"});\n    for (const auto& str : result) {\n        cout << str << \" \";\n    }\n    cout << endl;\n\n    cout << \"Test 3: \";\n    result = total_match({\"hi\", \"admin\"}, {\"hi\", \"hi\", \"admin\", \"project\"});\n    for (const auto& str : result) {\n        cout << str << \" \";\n    }\n    cout << endl;\n\n    cout << \"Test 4: \";\n    result = total_match({\"hi\", \"admin\"}, {\"hI\", \"hi\", \"hi\"});\n    for (const auto& str : result) {\n        cout << str << \" \";\n    }\n    cout << endl;\n\n    cout << \"Test 5: \";\n    result = total_match({\"4\"}, {\"1\", \"2\", \"3\", \"4\", \"5\"});\n    for (const auto& str : result) {\n        cout << str << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/75", "generation": "#include <iostream>\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    if (n == 2 || n == 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    for (int i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0)\n            return false;\n    }\n    return true;\n}\n\n// Function to check if the given number is a product of exactly three prime numbers\nbool is_multiply_prime(int a) {\n    // Generate all primes less than 100\n    int primes[] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97};\n    int num_primes = sizeof(primes) / sizeof(primes[0]);\n\n    // Try all combinations of three primes\n    for (int i = 0; i < num_primes; ++i) {\n        for (int j = i; j < num_primes; ++j) {\n            for (int k = j; k < num_primes; ++k) {\n                if (primes[i] * primes[j] * primes[k] == a)\n                    return true;\n            }\n        }\n    }\n\n    return false;\n}\n\n// Function to test the is_multiply_prime function\nvoid test() {\n    cout << \"Testing is_multiply_prime...\" << endl;\n    assert(is_multiply_prime(30) == true); // 2 * 3 * 5 = 30\n    assert(is_multiply_prime(60) == false); // Not a product of exactly three primes\n    assert(is_multiply_prime(105) == true); // 3 * 5 * 7 = 105\n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/76", "generation": "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\nbool is_simple_power(int x, int n) {\n    if (n == 1) {\n        return x == 1; // Special case: 1^any_number = 1\n    }\n    \n    double log_result = log(x) / log(n);\n    return floor(log_result) == log_result;\n}\n\n"}
{"task_id": "CPP/77", "generation": "#include <iostream>\n#include <cmath>\n\nbool iscube(int a) {\n    // Handle special case for zero\n    if (a == 0) return true;\n\n    // For negative numbers, take the absolute value\n    int abs_a = std::abs(a);\n\n    // Calculate the cube root and round it to the nearest integer\n    int cube_root = static_cast<int>(std::round(std::cbrt(abs_a)));\n\n    // Check if the cube of the rounded cube root equals the original number\n    return cube_root * cube_root * cube_root == abs_a;\n}\n\n"}
{"task_id": "CPP/78", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nint hex_key(string num) {\n    // Define a set of prime hexadecimal digits\n    const string primes = \"2357BD\";\n    \n    int count = 0;\n    \n    // Iterate through each character in the input string\n    for (char c : num) {\n        if (primes.find(c) != string::npos) {\n            ++count;  // Increment count if the digit is prime\n        }\n    }\n    \n    return count;\n}\n\n"}
{"task_id": "CPP/79", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\n// Function to convert decimal to binary\nstring decimal_to_binary(int decimal) {\n    if (decimal == 0) {\n        return \"db0db\";\n    }\n\n    string binary = \"\";\n    while (decimal > 0) {\n        int remainder = decimal % 2;\n        binary = to_string(remainder) + binary;\n        decimal /= 2;\n    }\n    \n    // Add the prefix and suffix\n    return \"db\" + binary + \"db\";\n}\n\n// Function to check the correctness of the conversion\nvoid check_conversion(int decimal, const string& expected) {\n    string result = decimal_to_binary(decimal);\n    cout << \"decimal: \" << decimal << \", expected: \" << expected << \", got: \" << result << endl;\n    if (result == expected) {\n        cout << \"Test passed.\" << endl;\n    } else {\n        cout << \"Test failed.\" << endl;\n    }\n}\n\n"}
{"task_id": "CPP/80", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_happy(string s) {\n    // Check if the string length is less than 3\n    if (s.length() < 3) return false;\n    \n    // Iterate through the string, checking every set of three consecutive characters\n    for (size_t i = 0; i <= s.length() - 3; ++i) {\n        // Check if any two out of the three consecutive characters are the same\n        if (s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]) {\n            return false;\n        }\n    }\n    \n    // If no three consecutive characters are the same, the string is happy\n    return true;\n}\n\n"}
{"task_id": "CPP/81", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\n// Function to convert GPA to letter grade\nstring gpa_to_letter(float gpa) {\n    if (gpa >= 4.0f) return \"A+\";\n    else if (gpa > 3.7f) return \"A\";\n    else if (gpa > 3.3f) return \"A-\";\n    else if (gpa > 3.0f) return \"B+\";\n    else if (gpa > 2.7f) return \"B\";\n    else if (gpa > 2.3f) return \"B-\";\n    else if (gpa > 2.0f) return \"C+\";\n    else if (gpa > 1.7f) return \"C\";\n    else if (gpa > 1.3f) return \"C-\";\n    else if (gpa > 1.0f) return \"D+\";\n    else if (gpa > 0.7f) return \"D\";\n    else if (gpa > 0.0f) return \"D-\";\n    else return \"E\";\n}\n\n// Function to convert vector of GPAs to vector of letter grades\nvector<string> numerical_letter_grade(vector<float> grades) {\n    vector<string> letter_grades;\n    for (float gpa : grades) {\n        letter_grades.push_back(gpa_to_letter(gpa));\n    }\n    return letter_grades;\n}\n\n// Function to check the correctness of the function\nvoid check() {\n    vector<float> test_grades = {4.0f, 3.0f, 1.7f, 2.0f, 3.5f};\n    vector<string> expected = {\"A+\", \"B\", \"C-\", \"C\", \"A-\"};\n    vector<string> result = numerical_letter_grade(test_grades);\n    \n    if (result == expected) {\n        cout << \"Test passed!\" << endl;\n    } else {\n        cout << \"Test failed. Expected: \";\n        for (const auto& grade : expected) {\n            cout << grade << \" \";\n        }\n        cout << \"\\nGot: \";\n        for (const auto& grade : result) {\n            cout << grade << \" \";\n        }\n        cout << endl;\n    }\n}\n\n"}
{"task_id": "CPP/82", "generation": "#include <iostream>\n#include <string>\n\n// Function to check if a number is prime\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    if (n == 2 || n == 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n\n    for (int i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0)\n            return false;\n    }\n    return true;\n}\n\n// Function to check if the length of a string is prime\nbool prime_length(string str) {\n    int len = str.length();\n    return is_prime(len);\n}\n\n"}
{"task_id": "CPP/83", "generation": "#include <iostream>\nusing namespace std;\n\nint starts_one_ends(int n) {\n    if (n == 1) {\n        return 1; // Only one number (1) fits the criteria\n    }\n\n    // Counting numbers starting with 1: 10^(n-1)\n    int start_with_1 = pow(10, n - 1);\n\n    // Counting numbers ending with 1: 9 * 10^(n-2)\n    int end_with_1 = 9 * pow(10, n - 2);\n\n    // Subtracting overlap (numbers that both start and end with 1): 10^(n-2)\n    int overlap = pow(10, n - 2);\n\n    return start_with_1 + end_with_1 - overlap;\n}\n\n"}
{"task_id": "CPP/84", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring solve(int N) {\n    int sum = 0;\n    \n    // Calculate the sum of digits\n    while (N > 0) {\n        sum += N % 10;  // Add the last digit to the sum\n        N /= 10;        // Remove the last digit from N\n    }\n    \n    // Convert the sum to binary string\n    string binarySum = \"\";\n    if (sum == 0) {\n        return \"0\";\n    }\n    \n    while (sum > 0) {\n        binarySum = to_string(sum % 2) + binarySum;  // Prepend the remainder when divided by 2\n        sum /= 2;                                    // Divide the sum by 2\n    }\n    \n    return binarySum;\n}\n\n"}
{"task_id": "CPP/85", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint add(vector<int> lst) {\n    int sum = 0;\n    \n    // Iterate through the vector starting from index 1 (second element)\n    for (size_t i = 1; i < lst.size(); i += 2) {\n        if (lst[i] % 2 == 0) {  // Check if the element at an odd index is even\n            sum += lst[i];\n        }\n    }\n    \n    return sum;\n}\n\n"}
{"task_id": "CPP/86", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nstring anti_shuffle(string s) {\n    // Split the string into words based on spaces\n    string result = \"\";\n    int start = 0;\n    \n    for (int i = 0; i <= s.length(); ++i) {\n        if (i == s.length() || s[i] == ' ') {\n            // Extract the word from the current start to the space or end of string\n            string word = s.substr(start, i - start);\n            \n            // Sort the characters in the word\n            sort(word.begin(), word.end());\n            \n            // Append the sorted word to the result\n            if (!result.empty() && result.back() != ' ') {\n                result += \" \";\n            }\n            result += word;\n            \n            // Update the start index for the next word\n            start = i + 1;\n        }\n    }\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/87", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to get the row and column indices where x appears\nvector<vector<int>> get_row(vector<vector<int>> lst, int x) {\n    vector<vector<int>> result;\n    \n    // Iterate through each row in the list\n    for (size_t i = 0; i < lst.size(); ++i) {\n        const auto& row = lst[i];\n        \n        // Iterate through each element in the current row\n        for (size_t j = 0; j < row.size(); ++j) {\n            if (row[j] == x) {\n                result.push_back({static_cast<int>(i), static_cast<int>(j)});\n            }\n        }\n    }\n\n    // Sort by rows in ascending order and then by columns in descending order within each row\n    sort(result.begin(), result.end(), [](const vector<int>& a, const vector<int>& b) {\n        if (a[0] == b[0]) return a[1] > b[1]; // Descending order for columns\n        return a[0] < b[0]; // Ascending order for rows\n    });\n\n    return result;\n}\n\n// Function to print the result for verification\nvoid print_result(const vector<vector<int>>& result) {\n    for (const auto& coord : result) {\n        cout << \"{\" << coord[0] << \", \" << coord[1] << \"} \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/88", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> sort_array(vector<int> array) {\n    // Check if the vector is empty or has only one element\n    if (array.empty() || array.size() == 1) {\n        return array;\n    }\n\n    int first = array.front();\n    int last = array.back();\n\n    // Calculate the sum of the first and last elements\n    int sum = first + last;\n\n    // Determine the sorting order based on the sum being odd or even\n    if (sum % 2 == 0) {\n        // Sort in descending order\n        vector<int> sorted_array(array);\n        sort(sorted_array.rbegin(), sorted_array.rend());\n        return sorted_array;\n    } else {\n        // Sort in ascending order\n        vector<int> sorted_array(array);\n        sort(sorted_array.begin(), sorted_array.end());\n        return sorted_array;\n    }\n}\n\n// Function to test the solution with provided examples\nvoid check() {\n    printf(\"{%s}\\n\", sort_array({}).empty() ? \"[]\" : \"{5, 4, 3, 2, 1}\"); // Example might be incorrect for empty vector\n    printf(\"{%d}\\n\", sort_array({5})[0]); // Should return {5}\n    printf(\"{%s}\\n\", sort_array({2, 4, 3, 0, 1, 5}).begin(), sort_array({2, 4, 3, 0, 1, 5}).end()); // Should return [0, 1, 2, 3, 4, 5]\n    printf(\"{%s}\\n\", sort_array({2, 4, 3, 0, 1, 5, 6}).rbegin(), sort_array({2, 4, 3, 0, 1, 5, 6}).rend()); // Should return [6, 5, 4, 3, 2, 1, 0]\n}\n\n"}
{"task_id": "CPP/89", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\n// Function to rotate a single character by 4 places\nchar rotateChar(char c) {\n    if (c >= 'a' && c <= 'z') {\n        return ((c - 'a' + 4) % 26) + 'a';\n    } else if (c >= 'A' && c <= 'Z') {\n        return ((c - 'A' + 4) % 26) + 'A';\n    }\n    // Non-alphabetic characters are not rotated\n    return c;\n}\n\n// Function to encrypt the string by rotating each character\nstring encrypt(string s) {\n    for (char &c : s) {\n        c = rotateChar(c);\n    }\n    return s;\n}\n\n"}
{"task_id": "CPP/90", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <optional>\n\nusing namespace std;\n\nstd::optional<int> next_smallest(const vector<int>& lst) {\n    if (lst.size() < 2) {\n        return std::nullopt; // Return None equivalent in C++\n    }\n\n    // Remove duplicates and sort the unique elements\n    auto it = unique(lst.begin(), lst.end());\n    vector<int> unique_elements(lst.begin(), it);\n\n    if (unique_elements.size() < 2) {\n        return std::nullopt; // Return None equivalent in C++\n    }\n\n    // Sort the unique elements to find the second smallest element\n    sort(unique_elements.begin(), unique_elements.end());\n\n    // Return the second smallest element\n    return unique_elements[1];\n}\n\n"}
{"task_id": "CPP/91", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <vector>\n\nusing namespace std;\n\nint is_bored(const string& S) {\n    // Split the string into sentences based on '.', '?' or '!'\n    vector<string> sentences;\n    stringstream ss(S);\n    string sentence;\n    \n    while (getline(ss, sentence, '.')) {\n        if (!sentence.empty()) {\n            sentences.push_back(sentence);\n        }\n    }\n    while (getline(ss, sentence, '?')) {\n        if (!sentence.empty()) {\n            sentences.push_back(sentence);\n        }\n    }\n    while (getline(ss, sentence, '!')) {\n        if (!sentence.empty()) {\n            sentences.push_back(sentence);\n        }\n    }\n\n    // Count the number of sentences that start with \"I\"\n    int boredom_count = 0;\n    for (const string& s : sentences) {\n        size_t pos = s.find_first_not_of(\" \\t\");\n        if (pos != string::npos && s.substr(pos, 1) == \"I\") {\n            ++boredom_count;\n        }\n    }\n\n    return boredom_count;\n}\n\n"}
{"task_id": "CPP/92", "generation": "#include <iostream>\nusing namespace std;\n\nbool is_integer(float num) {\n    return floor(num) == num;\n}\n\nbool any_int(float a, float b, float c) {\n    // Check if all numbers are integers\n    if (is_integer(a) && is_integer(b) && is_integer(c)) {\n        // Check if one of the numbers is equal to the sum of the other two\n        return (a == b + c) || (b == a + c) || (c == a + b);\n    } else {\n        return false;\n    }\n}\n\n"}
{"task_id": "CPP/93", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to swap case of a character\nchar swapCase(char c) {\n    if (islower(c)) return toupper(c);\n    else if (isupper(c)) return tolower(c);\n    return c;\n}\n\n// Function to replace vowels with the letter 2 places ahead in the alphabet\nchar replaceVowel(char c) {\n    string vowels = \"aeiouAEIOU\";\n    int index = -1;\n\n    // Find the vowel's position if it exists\n    for (int i = 0; i < vowels.size(); ++i) {\n        if (vowels[i] == c) {\n            index = i;\n            break;\n        }\n    }\n\n    // If it is a vowel, replace it with the letter 2 places ahead\n    if (index != -1 && index + 2 < vowels.size()) {\n        return vowels[index + 2];\n    }\n\n    return c; // Return the original character if not a vowel\n}\n\n// Main encoding function\nstring encode(string message) {\n    for (char &c : message) {\n        // Swap case\n        c = swapCase(c);\n\n        // Replace vowels with the letter 2 places ahead\n        c = replaceVowel(c);\n    }\n\n    return message;\n}\n\n"}
{"task_id": "CPP/94", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\nint sum_of_digits(int n) {\n    int sum = 0;\n    while (n > 0) {\n        sum += n % 10;\n        n /= 10;\n    }\n    return sum;\n}\n\nint find_largest_prime_sum(vector<int> lst) {\n    int max_prime = -1;\n    for (int num : lst) {\n        if (is_prime(num)) {\n            max_prime = max(max_prime, num);\n        }\n    }\n\n    if (max_prime == -1) {\n        return 0;\n    }\n\n    return sum_of_digits(max_prime);\n}\n\n"}
{"task_id": "CPP/95", "generation": "#include <iostream>\n#include <string>\n#include <map>\n\nbool check_dict_case(const std::map<std::string, std::string>& dict) {\n    if (dict.empty()) {\n        return false;\n    }\n\n    bool all_lower = true;\n    bool all_upper = true;\n\n    for (const auto& pair : dict) {\n        if (!pair.first.empty()) {\n            all_lower &= std::islower(pair.first[0]);\n            all_upper &= std::isupper(pair.first[0]);\n        }\n    }\n\n    return all_lower || all_upper;\n}\n\n"}
{"task_id": "CPP/96", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Helper function to check if a number is prime\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    for (int i = 2; i * i <= num; ++i) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\n// Function to generate a vector of prime numbers less than n\nvector<int> count_up_to(int n) {\n    vector<int> primes;\n    for (int i = 2; i < n; ++i) {\n        if (is_prime(i)) {\n            primes.push_back(i);\n        }\n    }\n    return primes;\n}\n\n// Function to test the count_up_to function\nvoid test_count_up_to() {\n    assert(count_up_to(5) == vector<int>({2, 3}));\n    assert(count_up_to(11) == vector<int>({2, 3, 5, 7}));\n    assert(count_up_to(0).empty());\n    assert(count_up_to(20) == vector<int>({2, 3, 5, 7, 11, 13, 17, 19}));\n    assert(count_up_to(1).empty());\n    assert(count_up_to(18) == vector<int>({2, 3, 5, 7, 11, 13, 17}));\n\n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/97", "generation": "#include <iostream>\nusing namespace std;\n\nint multiply(int a, int b) {\n    // Extract the unit digit of both numbers\n    int unit_digit_a = abs(a % 10);\n    int unit_digit_b = abs(b % 10);\n\n    // Multiply the unit digits and return the result\n    return unit_digit_a * unit_digit_b;\n}\n\n"}
{"task_id": "CPP/98", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint count_upper(const string& s) {\n    int count = 0;\n    for (size_t i = 0; i < s.length(); i += 2) { // Iterate through even indices\n        char c = s[i];\n        if (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n            count++;\n        }\n    }\n    return count;\n}\n\n"}
{"task_id": "CPP/99", "generation": "#include <iostream>\n#include <cmath>\n#include <string>\nusing namespace std;\n\nint closest_integer(string value) {\n    // Convert string to double\n    double num = stod(value);\n    \n    // Determine the two nearest integers\n    int lower_int = static_cast<int>(floor(num));\n    int upper_int = static_cast<int>(ceil(num));\n    \n    // Check which integer is closer or if they are equidistant, round away from zero\n    if (num - lower_int == upper_int - num) {\n        return abs(num) > abs(lower_int) ? upper_int : lower_int;\n    } else {\n        return num - lower_int < 0.5 ? lower_int : upper_int;\n    }\n}\n\n"}
{"task_id": "CPP/100", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> make_a_pile(int n) {\n    vector<int> pile;\n    int current_stones = n;\n\n    for (int i = 0; i < n; ++i) {\n        pile.push_back(current_stones);\n        // Determine the next number of stones\n        if (current_stones % 2 == 0) {\n            current_stones += 2; // Next even number\n        } else {\n            current_stones += 2; // Next odd number\n        }\n    }\n\n    return pile;\n}\n\n// Function to check the correctness of the solution\nvoid check_solution() {\n    vector<int> result1 = make_a_pile(3);\n    assert(result1 == vector<int>({3, 5, 7}));\n\n    vector<int> result2 = make_a_pile(4);\n    assert(result2 == vector<int>({4, 6, 8, 10}));\n\n    vector<int> result3 = make_a_pile(1);\n    assert(result3 == vector<int>({1, 3}));\n\n    cout << \"All test cases passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/101", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nvector<string> words_string(string s) {\n    vector<string> result;\n    stringstream ss(s);\n    string word;\n\n    while (getline(ss, word, ',')) {  // Split by commas first\n        stringstream wordStream(word);  // Create a new stream for the current word\n        while (wordStream >> word) {  // Extract words from the current word\n            result.push_back(word);\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/102", "generation": "#include <iostream>\nusing namespace std;\n\nint choose_num(int x, int y) {\n    // Ensure x is less than or equal to y\n    if (x > y) {\n        return -1;\n    }\n\n    // Start from the end of the range and check for the largest even number\n    for (int i = y; i >= x; --i) {\n        if (i % 2 == 0) {\n            return i;\n        }\n    }\n\n    // If no even number is found, return -1\n    return -1;\n}\n\n// Function to test the choose_num function with some examples\nvoid test() {\n    cout << \"choose_num(12, 15): \" << choose_num(12, 15) << endl; // Should output 14\n    cout << \"choose_num(13, 12): \" << choose_num(13, 12) << endl; // Should output -1\n    cout << \"choose_num(10, 20): \" << choose_num(10, 20) << endl; // Should output 20\n    cout << \"choose_num(21, 25): \" << choose_num(21, 25) << endl; // Should output 24\n}\n\n"}
{"task_id": "CPP/103", "generation": "#include <stdio.h>\n#include <math.h>\n#include <string>\nusing namespace std;\n\nstring rounded_avg(int n, int m) {\n    // Check if n is greater than m\n    if (n > m) {\n        return \"-1\";\n    }\n\n    // Calculate the sum of integers from n to m\n    long long sum = 0;\n    for (int i = n; i <= m; ++i) {\n        sum += i;\n    }\n\n    // Calculate the average and round it down\n    int avg = sum / (m - n + 1);\n\n    // Convert the rounded average to binary string\n    string binary = \"\";\n    if (avg == 0) {\n        binary = \"0\";\n    } else {\n        while (avg > 0) {\n            binary = to_string(avg % 2) + binary;\n            avg /= 2;\n        }\n    }\n\n    return binary;\n}\n\n"}
{"task_id": "CPP/104", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nbool hasEvenDigit(int num) {\n    while (num > 0) {\n        int digit = num % 10;\n        if (digit % 2 == 0) {\n            return true; // Found an even digit\n        }\n        num /= 10;\n    }\n    return false; // No even digits found\n}\n\nvector<int> unique_digits(vector<int> x) {\n    vector<int> result;\n\n    for (int num : x) {\n        if (!hasEvenDigit(num)) {\n            result.push_back(num);\n        }\n    }\n\n    sort(result.begin(), result.end());\n    return result;\n}\n\n"}
{"task_id": "CPP/105", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to convert a digit to its corresponding name\nstring num_to_word(int n) {\n    map<int, string> digit_names = {\n        {1, \"One\"}, {2, \"Two\"}, {3, \"Three\"}, {4, \"Four\"},\n        {5, \"Five\"}, {6, \"Six\"}, {7, \"Seven\"}, {8, \"Eight\"}, {9, \"Nine\"}\n    };\n    return digit_names[n];\n}\n\n// Function to process the vector as per the problem statement\nvector<string> by_length(vector<int> arr) {\n    // Filter out numbers that are not between 1 and 9\n    vector<int> filtered_arr;\n    for (int num : arr) {\n        if (num >= 1 && num <= 9) {\n            filtered_arr.push_back(num);\n        }\n    }\n\n    // Sort the filtered array\n    sort(filtered_arr.begin(), filtered_arr.end());\n\n    // Reverse the sorted array\n    reverse(filtered_arr.begin(), filtered_arr.end());\n\n    // Convert each number to its corresponding name and store in a vector of strings\n    vector<string> result;\n    for (int num : filtered_arr) {\n        result.push_back(num_to_word(num));\n    }\n\n    return result;\n}\n\n// Function to check the correctness of the by_length function\nvoid check() {\n    vector<int> arr1 = {2, 1, 1, 4, 5, 8, 2, 3};\n    vector<string> expected1 = {\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"};\n    assert(by_length(arr1) == expected1);\n\n    vector<int> arr2 = {};\n    vector<string> expected2 = {};\n    assert(by_length(arr2) == expected2);\n\n    vector<int> arr3 = {1, -1, 55};\n    vector<string> expected3 = {\"One\"};\n    assert(by_length(arr3) == expected3);\n\n    printf(\"All test cases passed.\\n\");\n}\n\n"}
{"task_id": "CPP/106", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Function to compute the factorial of a number\nint factorial(int num) {\n    if (num == 0 || num == 1)\n        return 1;\n    int fact = 1;\n    for (int i = 2; i <= num; ++i) {\n        fact *= i;\n    }\n    return fact;\n}\n\n// Function to compute the sum of numbers from 1 to a number\nint sumTo(int num) {\n    return (num * (num + 1)) / 2;\n}\n\nvector<int> f(int n) {\n    vector<int> result(n);\n    \n    for (int i = 0; i < n; ++i) {\n        if ((i + 1) % 2 == 0) { // Check if the index is even\n            result[i] = factorial(i + 1); // Factorial of (i+1)\n        } else { // The index is odd\n            result[i] = sumTo(i + 1); // Sum from 1 to (i+1)\n        }\n    }\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/107", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nbool is_palindrome(int num) {\n    string str = to_string(num);\n    int left = 0;\n    int right = str.length() - 1;\n    \n    while (left < right) {\n        if (str[left] != str[right]) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n    return true;\n}\n\nvector<int> even_odd_palindrome(int n) {\n    vector<int> result(2, 0); // Initialize with two elements for even and odd counts\n    for (int i = 1; i <= n; ++i) {\n        if (is_palindrome(i)) {\n            if (i % 2 == 0) {\n                result[0]++; // Even palindrome count\n            } else {\n                result[1]++; // Odd palindrome count\n            }\n        }\n    }\n    return result;\n}\n\n"}
{"task_id": "CPP/108", "generation": "#include <vector>\n#include <cmath>\n\n// Helper function to calculate the sum of digits of a number.\nint sum_of_digits(int num) {\n    if (num < 0) {\n        num = -num; // Make number positive for digit extraction\n    }\n    int total = 0;\n    while (num > 0) {\n        total += num % 10;\n        num /= 10;\n    }\n    return total;\n}\n\n// Main function to count the numbers with a sum of digits greater than zero.\nint count_nums(const std::vector<int>& n) {\n    int count = 0;\n    for (const auto& num : n) {\n        if (sum_of_digits(num) > 0) {\n            ++count;\n        }\n    }\n    return count;\n}\n\n// Function to test the count_nums function with provided data points.\nvoid test_count_nums() {\n    assert(count_nums({}) == 0);\n    assert(count_nums({-1, 11, -11}) == 1);\n    assert(count_nums({1, 1, 2}) == 3);\n    std::cout << \"All tests passed!\" << std::endl;\n}\n\n"}
{"task_id": "CPP/109", "generation": "#include <vector>\nusing namespace std;\n\nbool move_one_ball(vector<int> arr) {\n    int n = arr.size();\n    \n    if (n == 0) {\n        return true;\n    }\n    \n    // Find the index where the array is not sorted\n    int i = 1;  // Initialize i to start checking from the second element\n    for (; i < n; ++i) {\n        if (arr[i] < arr[i - 1]) {\n            break;\n        }\n    }\n    \n    if (i == n) {  // If no such index found, the array is already sorted\n        return true;\n    }\n\n    // Perform a right shift operation and check if it's sorted\n    vector<int> shifted_arr(arr.begin() + i, arr.end());\n    shifted_arr.insert(shifted_arr.end(), arr.begin(), arr.begin() + i);\n\n    for (int j = 1; j < n; ++j) {\n        if (shifted_arr[j] < shifted_arr[j - 1]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n"}
{"task_id": "CPP/110", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring exchange(vector<int> lst1, vector<int> lst2) {\n    bool has_odd_in_lst1 = false;\n    bool has_even_in_lst2 = false;\n\n    // Check for odd numbers in lst1\n    for (int num : lst1) {\n        if (num % 2 != 0) {\n            has_odd_in_lst1 = true;\n            break;\n        }\n    }\n\n    // Check for even numbers in lst2\n    for (int num : lst2) {\n        if (num % 2 == 0) {\n            has_even_in_lst2 = true;\n            break;\n        }\n    }\n\n    // Determine the result based on the checks\n    return (has_odd_in_lst1 && !has_even_in_lst2) ? \"NO\" : \"YES\";\n}\n\n"}
{"task_id": "CPP/111", "generation": "#include <iostream>\n#include <string>\n#include <map>\n#include <vector>\nusing namespace std;\n\nmap<char, int> histogram(string test) {\n    map<char, int> charCount;\n    \n    // Count occurrences of each character\n    for (char c : test) {\n        if (c != ' ') {  // Ignore spaces\n            charCount[c]++;\n        }\n    }\n\n    // Find the maximum count\n    int maxCount = 0;\n    for (const auto& pair : charCount) {\n        if (pair.second > maxCount) {\n            maxCount = pair.second;\n        }\n    }\n\n    // Collect characters with the highest frequency\n    map<char, int> result;\n    for (const auto& pair : charCount) {\n        if (pair.second == maxCount) {\n            result.insert(pair);\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/112", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to check if a string is a palindrome\nbool is_palindrome(const string& str) {\n    int left = 0;\n    int right = str.size() - 1;\n    while (left < right) {\n        if (str[left] != str[right]) {\n            return false;\n        }\n        ++left;\n        --right;\n    }\n    return true;\n}\n\n// Function to reverse delete characters\nvector<string> reverse_delete(string s, string c) {\n    // Remove all characters in s that are present in c\n    for (char ch : c) {\n        s.erase(remove(s.begin(), s.end(), ch), s.end());\n    }\n\n    // Check if the resulting string is a palindrome\n    bool result = is_palindrome(s);\n\n    // Return the result as a vector containing the modified string and the boolean\n    return {s, (result ? \"True\" : \"False\")};\n}\n\n"}
{"task_id": "CPP/113", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<string> odd_count(vector<string> lst) {\n    vector<string> result;\n    \n    for (const auto& str : lst) {\n        int count = 0;\n        \n        // Count the number of odd digits in the string\n        for (char c : str) {\n            if ((c - '0') % 2 != 0) {\n                count++;\n            }\n        }\n\n        // Construct the result string\n        string output = \"the number of odd elements \";\n        output += to_string(count);\n        output += \"n the str\";\n        output += to_string(count);\n        output += \"ng \";\n        output += to_string(count);\n        output += \" of the \";\n        output += to_string(count);\n        output += \"nput.\";\n        \n        result.push_back(output);\n    }\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/114", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nlong long minSubArraySum(vector<long long> nums) {\n    if (nums.empty()) return 0; // Handle empty vector case\n\n    long long current_min = nums[0];\n    long long global_min = nums[0];\n\n    for (size_t i = 1; i < nums.size(); ++i) {\n        // Update the current minimum sum ending at position i\n        current_min = min(nums[i], current_min + nums[i]);\n        \n        // Update the global minimum sum found so far\n        if (current_min < global_min) {\n            global_min = current_min;\n        }\n    }\n\n    return global_min;\n}\n\n"}
{"task_id": "CPP/115", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint max_fill(vector<vector<int>> grid, int capacity) {\n    int total_lowerings = 0;\n    \n    // Iterate through each well (row)\n    for (const auto& row : grid) {\n        int water_units = 0;\n        \n        // Count the number of units of water in the current well\n        for (int unit : row) {\n            if (unit == 1) {\n                ++water_units;\n            }\n        }\n        \n        // Calculate the number of times the bucket needs to be lowered\n        total_lowerings += (water_units + capacity - 1) / capacity;\n    }\n    \n    return total_lowerings;\n}\n\n"}
{"task_id": "CPP/116", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\n// Function to count the number of ones in the binary representation of an integer\nint count_ones(int n) {\n    int count = 0;\n    while (n > 0) {\n        count += n & 1; // Check if the least significant bit is set\n        n >>= 1;       // Right shift to check the next bit\n    }\n    return count;\n}\n\n// Function to sort the array based on the number of ones in binary representation and decimal value\nstd::vector<int> sort_array(std::vector<int> arr) {\n    auto comp = [](int a, int b) {\n        int count_a = count_ones(a);\n        int count_b = count_ones(b);\n        \n        if (count_a == count_b) {\n            return a < b; // Sort by decimal value if the number of ones is the same\n        }\n        return count_a < count_b; // Otherwise, sort by the number of ones\n    };\n    \n    std::sort(arr.begin(), arr.end(), comp);\n    return arr;\n}\n\n// Function to check the correctness of the sort_array function\nvoid check() {\n    assert(sort_array({1, 5, 2, 3, 4}) == std::vector<int>({1, 2, 4, 3, 5}));\n    assert(sort_array({-2, -3, -4, -5, -6}) == std::vector<int>({-4, -2, -6, -5, -3}));\n    assert(sort_array({1, 0, 2, 3, 4}) == std::vector<int>({0, 1, 2, 4, 3}));\n    std::cout << \"All test cases passed!\" << std::endl;\n}\n\n"}
{"task_id": "CPP/117", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nbool is_consonant(char c) {\n    return tolower(c) >= 'a' && tolower(c) <= 'z' && !(tolower(c) == 'a' || tolower(c) == 'e' || tolower(c) == 'i' || tolower(c) == 'o' || tolower(c) == 'u');\n}\n\nvector<string> select_words(const string& s, int n) {\n    vector<string> words;\n    vector<string> result;\n\n    // Split the input string into words\n    string current_word = \"\";\n    for (char c : s) {\n        if (c == ' ') {\n            if (!current_word.empty()) {\n                words.push_back(current_word);\n                current_word.clear();\n            }\n        } else {\n            current_word += c;\n        }\n    }\n    if (!current_word.empty()) {\n        words.push_back(current_word);\n    }\n\n    // Check each word for the exact number of consonants\n    for (const string& word : words) {\n        int count = 0;\n        for (char c : word) {\n            if (is_consonant(c)) {\n                ++count;\n            }\n        }\n        if (count == n) {\n            result.push_back(word);\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/118", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nbool isVowel(char c) {\n    return c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' ||\n           c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U';\n}\n\nstring get_closest_vowel(string word) {\n    int n = word.length();\n    \n    // Iterate from right to left, starting from the second last character\n    for (int i = n - 2; i > 0; --i) {\n        if (isVowel(word[i]) && isalpha(word[i-1]) && !isalpha(word[i+1])) {\n            return string(1, word[i]);\n        }\n    }\n    \n    return \"\";\n}\n\n"}
{"task_id": "CPP/119", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nbool is_balanced(const string& s) {\n    int balance = 0;\n    for (char c : s) {\n        if (c == '(') {\n            balance += 1;\n        } else {\n            balance -= 1;\n        }\n        if (balance < 0) {\n            return false;\n        }\n    }\n    return balance == 0;\n}\n\nstring match_parens(vector<string> lst) {\n    // Check both possible concatenations\n    if (is_balanced(lst[0] + lst[1]) || is_balanced(lst[1] + lst[0])) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\n\n"}
{"task_id": "CPP/120", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> maximum(vector<int> arr, int k) {\n    // Sort the array in descending order\n    sort(arr.begin(), arr.end(), greater<int>());\n    \n    // If k is 0 or negative, return an empty vector\n    if (k <= 0 || k > arr.size()) {\n        return {};\n    }\n    \n    // Slice the first k elements from the sorted array\n    vector<int> result(arr.begin(), arr.begin() + k);\n    \n    // Sort the resulting vector in ascending order as required\n    sort(result.begin(), result.end());\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/121", "generation": "#include <vector>\nusing namespace std;\n\nint solution(vector<int> lst) {\n    int sum = 0;\n    for (size_t i = 0; i < lst.size(); ++i) {\n        // Check if the index is even and the element at that position is odd\n        if (i % 2 == 0 && lst[i] % 2 != 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n\n// Function to test the solution with provided examples\nvoid check_solution() {\n    assert(solution({5, 8, 7, 1}) == 12);\n    assert(solution({3, 3, 3, 3, 3}) == 9);\n    assert(solution({30, 13, 24, 321}) == 0);\n}\n\n"}
{"task_id": "CPP/122", "generation": "#include <vector>\n#include <algorithm>\n\nint add_elements(std::vector<int> arr, int k) {\n    // Filter the first k elements of the array to include only those with at most two digits\n    std::vector<int> filtered_elements;\n    for (int i = 0; i < k; ++i) {\n        if (arr[i] >= 0 && arr[i] < 100) {\n            filtered_elements.push_back(arr[i]);\n        }\n    }\n\n    // Calculate the sum of these filtered elements\n    int sum = 0;\n    for (int num : filtered_elements) {\n        sum += num;\n    }\n\n    return sum;\n}\n"}
{"task_id": "CPP/123", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n// Function to generate and return the odd numbers in the Collatz sequence of n.\nvector<int> get_odd_collatz(int n) {\n    vector<int> result;\n    \n    // Generate the Collatz sequence until it reaches 1\n    while (n != 1) {\n        if (n % 2 == 0) {\n            n /= 2;  // If n is even, divide by 2\n        } else {\n            result.push_back(n);  // If n is odd, add to the result vector\n            n = 3 * n + 1;  // Apply the Collatz transformation\n        }\n    }\n    \n    // Add the final number (which is 1) to the result vector\n    result.push_back(1);\n    \n    // Sort the result vector in increasing order\n    sort(result.begin(), result.end());\n    \n    return result;\n}\n\n// Function to test the get_odd_collatz function with some examples.\nvoid test_get_odd_collatz() {\n    cout << \"Testing get_odd_collatz...\" << endl;\n    assert(get_odd_collatz(5) == vector<int>({1, 5}));\n    assert(get_odd_collatz(7) == vector<int>({1, 7, 11, 22}));\n    assert(get_odd_collatz(1) == vector<int>({1}));\n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/124", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <vector>\n\nbool valid_date(const std::string& date) {\n    // Split the date string into month, day, and year\n    std::istringstream iss(date);\n    std::string token;\n    std::vector<std::string> parts;\n\n    while (std::getline(iss, token, '-')) {\n        parts.push_back(token);\n    }\n\n    if (parts.size() != 3) {\n        return false; // Ensure the date string is in mm-dd-yyyy format\n    }\n\n    int month = std::stoi(parts[0]);\n    int day = std::stoi(parts[1]);\n    int year = std::stoi(parts[2]);\n\n    // Check if the number of days is valid for each month\n    if (month < 1 || month > 12) {\n        return false;\n    }\n\n    if ((month == 4 || month == 6 || month == 9 || month == 11) && day < 1 || day > 30) {\n        return false;\n    } else if ((month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) && (day < 1 || day > 31)) {\n        return false;\n    } else if (month == 2 && (day < 1 || day > 29)) {\n        return false;\n    }\n\n    // If all checks pass, the date is valid\n    return true;\n}\n\n"}
{"task_id": "CPP/125", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nvector<string> split_words(string txt) {\n    // Check for whitespace in the string\n    if (txt.find(' ') != string::npos) {\n        return vector<string>(istringstream(txt).istream_iterator<string>(), istream_iterator<string>());\n    }\n    \n    // Check for commas in the string\n    else if (txt.find(',') != string::npos) {\n        size_t pos = 0;\n        vector<string> result;\n        while ((pos = txt.find(',')) != string::npos) {\n            result.push_back(txt.substr(0, pos));\n            txt.erase(0, pos + 1);\n        }\n        result.push_back(txt); // Add the last segment\n        return result;\n    } else {\n        // Count lowercase letters with odd ASCII values\n        int count = 0;\n        for (char c : txt) {\n            if (islower(c) && (c - 'a') % 2 == 1) {\n                count++;\n            }\n        }\n        \n        // Return the result as a vector containing the count as a string\n        return {to_string(count)};\n    }\n}\n\n"}
{"task_id": "CPP/126", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nbool is_sorted(vector<int> lst) {\n    // Check if the list is already sorted or not\n    bool sorted = is_sorted(lst.begin(), lst.end());\n    \n    // If not sorted, return false immediately\n    if (!sorted) return false;\n    \n    // Count occurrences of each number in the vector\n    for (int i = 0; i < lst.size(); ++i) {\n        int count = 1;\n        while (i + 1 < lst.size() && lst[i] == lst[i + 1]) {\n            count++;\n            i++;\n        }\n        // If any number appears more than twice, return false\n        if (count > 2) return false;\n    }\n    \n    // If both conditions are met, return true\n    return true;\n}\n\n"}
{"task_id": "CPP/127", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\nstring intersection(vector<int> interval1, vector<int> interval2) {\n    int start = max(interval1[0], interval2[0]);\n    int end = min(interval1[1], interval2[1]);\n\n    if (start > end) {\n        return \"NO\";\n    }\n\n    int length = end - start + 1;\n\n    if (is_prime(length)) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n\n"}
{"task_id": "CPP/128", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint prod_signs(vector<int> arr) {\n    if (arr.empty()) {\n        return -32768;\n    }\n\n    int sign_product = 1;\n    int magnitude_sum = 0;\n\n    for (int num : arr) {\n        // Calculate the product of signs\n        if (num < 0) {\n            sign_product *= -1;\n        } else if (num == 0) {\n            sign_product = 0; // If any number is zero, the product will be zero\n            break;\n        }\n\n        // Calculate the sum of magnitudes\n        magnitude_sum += abs(num);\n    }\n\n    return sign_product * magnitude_sum;\n}\n\n// Function to test the prod_signs function with provided examples\nvoid check() {\n    cout << \"Checking examples:\" << endl;\n    assert(prod_signs({1, 2, 2, -4}) == -9); // (-1) * (1 + 2 + 2 + 4) = -9\n    assert(prod_signs({0, 1}) == 0);         // 0 * (abs(0) + abs(1)) = 0\n    assert(prod_signs({}) == -32768);        // Empty vector case\n\n    cout << \"All checks passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/129", "generation": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nint n;\nvector<vector<int>> directions = {{0, 1}, {1, 0}, {-1, 0}, {0, -1}};\n\nbool isValid(int x, int y) {\n    return x >= 0 && x < n && y >= 0 && y < n;\n}\n\nvoid getNeighbors(const vector<vector<int>>& grid, int x, int y, vector<pair<int, int>>& neighbors) {\n    for (const auto& dir : directions) {\n        int nx = x + dir[0], ny = y + dir[1];\n        if (isValid(nx, ny)) {\n            neighbors.push_back({nx, ny});\n        }\n    }\n}\n\nvector<int> minPath(vector<vector<int>> grid, int k) {\n    n = grid.size();\n    \n    queue<tuple<int, int, vector<int>>> q;\n    for (int i = 0; i < n; ++i)\n        for (int j = 0; j < n; ++j)\n            q.push({i, j, {grid[i][j]}});\n    \n    while (!q.empty()) {\n        auto [x, y, path] = q.front(); q.pop();\n        \n        if (path.size() == k) return path;\n        \n        vector<pair<int, int>> neighbors;\n        getNeighbors(grid, x, y, neighbors);\n        \n        for (const auto& neighbor : neighbors) {\n            int nx = neighbor.first, ny = neighbor.second;\n            if (!isValid(nx, ny)) continue;\n            \n            q.push({nx, ny, path});\n        }\n    }\n    \n    return {};\n}\n\n"}
{"task_id": "CPP/130", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> tri(int n) {\n    if (n == 0) return {1};\n    \n    vector<int> sequence = {1, 3};\n    for (int i = 2; i <= n; ++i) {\n        int next_value;\n        if (i % 2 == 0) {\n            next_value = 1 + i / 2;\n        } else {\n            next_value = sequence[i - 1] + sequence[i - 2];\n        }\n        sequence.push_back(next_value);\n    }\n    \n    return sequence;\n}\n\n"}
{"task_id": "CPP/131", "generation": "#include <iostream>\nusing namespace std;\n\nint digits(int n) {\n    int product = 1;\n    bool hasOddDigit = false;\n\n    while (n > 0) {\n        int digit = n % 10; // Get the last digit of n\n        if (digit % 2 != 0) { // Check if the digit is odd\n            product *= digit; // Multiply it to the product\n            hasOddDigit = true;\n        }\n        n /= 10; // Remove the last digit from n\n    }\n\n    return hasOddDigit ? product : 0;\n}\n\n"}
{"task_id": "CPP/132", "generation": "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nbool is_nested(string str) {\n    vector<char> stack;\n    bool nested_found = false;\n\n    for (char ch : str) {\n        if (ch == '[') {\n            stack.push_back(ch);\n        } else if (ch == ']') {\n            if (stack.empty()) {\n                return false; // No matching opening bracket\n            }\n            stack.pop_back();\n            if (!stack.empty()) {\n                nested_found = true;\n            }\n        }\n    }\n\n    return nested_found;\n}\n\n"}
{"task_id": "CPP/133", "generation": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nint sum_squares(vector<float> lst) {\n    int sum = 0;\n    \n    for (float num : lst) {\n        // Round up to the nearest integer\n        float ceil_num = ceil(num);\n        \n        // Add the square of the rounded number to the sum\n        sum += static_cast<int>(ceil_num * ceil_num);\n    }\n    \n    return sum;\n}\n\n"}
{"task_id": "CPP/134", "generation": "#include <iostream>\n#include <string>\n#include <cctype> // For isalpha and isalnum functions\n\nusing namespace std;\n\nbool check_if_last_char_is_a_letter(const string& txt) {\n    // Check if the string is empty\n    if (txt.empty()) {\n        return false;\n    }\n    \n    // Get the last character of the string\n    char last_char = txt.back();\n    \n    // Check if the last character is an alphabetical character and not part of a word\n    if (isalpha(last_char) && \n        (txt.size() == 1 || !isalnum(txt[txt.size() - 2]))) {\n        return true;\n    } else {\n        return false;\n    }\n}\n\n// Function to test the check_if_last_char_is_a_letter function\nvoid test_check_if_last_char_is_a_letter() {\n    assert(check_if_last_char_is_a_letter(\"apple pie\") == false);\n    assert(check_if_last_char_is_a_letter(\"apple pi e\") == true);\n    assert(check_if_last_char_is_a_letter(\"apple pi e \") == false);\n    assert(check_if_last_char_is_a_letter(\"\") == false);\n    \n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/135", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint can_arrange(vector<int> arr) {\n    int n = arr.size();\n    for (int i = 1; i < n; ++i) {\n        if (arr[i] < arr[i - 1]) {\n            return i;\n        }\n    }\n    return -1;\n}\n\n"}
{"task_id": "CPP/136", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> largest_smallest_integers(vector<int> lst) {\n    vector<int> result = {0, 0}; // Initialize with default values\n\n    int max_negative = INT_MIN; // Start with the smallest possible integer\n    int min_positive = INT_MAX; // Start with the largest possible integer\n\n    for (int num : lst) {\n        if (num < 0 && num > max_negative) {\n            max_negative = num;\n        } else if (num > 0 && num < min_positive) {\n            min_positive = num;\n        }\n    }\n\n    result[0] = max_negative; // Assign the largest negative integer\n    result[1] = min_positive; // Assign the smallest positive integer\n\n    return result;\n}\n\n"}
{"task_id": "CPP/137", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <boost/any.hpp>\n\nusing namespace std;\n\nboost::any compare_one(boost::any a, boost::any b) {\n    // Convert strings with commas to floats\n    float convert_to_float(const string& str) {\n        replace(str.begin(), str.end(), ',', '.');\n        return stof(str);\n    }\n\n    if (a.type() == typeid(float)) {\n        float val_a = boost::any_cast<float>(a);\n        if (b.type() == typeid(float)) {\n            float val_b = boost::any_cast<float>(b);\n            return val_a > val_b ? a : b;\n        } else if (b.type() == typeid(string)) {\n            string str_b = boost::any_cast<string>(b);\n            return convert_to_float(str_b) > val_a ? a : b;\n        }\n    } else if (a.type() == typeid(string)) {\n        float val_a = convert_to_float(boost::any_cast<string>(a));\n        if (b.type() == typeid(float)) {\n            float val_b = boost::any_cast<float>(b);\n            return val_a > val_b ? a : b;\n        } else if (b.type() == typeid(string)) {\n            string str_b = boost::any_cast<string>(b);\n            return convert_to_float(str_b) > val_a ? a : b;\n        }\n    }\n\n    // If both are integers\n    int val_a, val_b;\n    if (a.type() == typeid(int)) {\n        val_a = boost::any_cast<int>(a);\n        if (b.type() == typeid(int)) {\n            val_b = boost::any_cast<int>(b);\n            return val_a > val_b ? a : b;\n        }\n    }\n\n    // If values are equal, return \"None\"\n    return boost::any(\"None\");\n}\n\n"}
{"task_id": "CPP/138", "generation": "#include <iostream>\n#include <vector>\n\nbool is_equal_to_sum_even(int n) {\n    // The smallest sum of 4 positive even numbers is 2 + 2 + 2 + 2 = 8\n    if (n < 8) {\n        return false;\n    }\n    \n    // Since we are adding only even numbers, the result must be even\n    if (n % 2 != 0) {\n        return false;\n    }\n    \n    // If n is greater than or equal to 8 and even, it can always be written as the sum of 4 positive even numbers\n    return true;\n}\n\n"}
{"task_id": "CPP/139", "generation": "#include <iostream>\n\n// Function to calculate factorial of a number\nlong long factorial(long long num) {\n    if (num == 0 || num == 1)\n        return 1;\n    else\n        return num * factorial(num - 1);\n}\n\n// Function to calculate Brazilian factorial\nlong long special_factorial(int n) {\n    long long result = 1;\n    for (int i = n; i > 0; --i) {\n        result *= factorial(i);\n    }\n    return result;\n}\n\n"}
{"task_id": "CPP/140", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring fix_spaces(string text) {\n    // Replace all spaces with underscores\n    for (size_t i = 0; i < text.length(); ++i) {\n        if (text[i] == ' ') {\n            text[i] = '_';\n        }\n    }\n\n    // Find and replace more than two consecutive underscores with a hyphen\n    size_t start = 0;\n    while ((start = text.find(\"__\", start)) != string::npos) {\n        text.replace(start, 2, \"-\");\n        start += 1; // Move past the replaced characters to avoid infinite loop\n    }\n\n    return text;\n}\n\n"}
{"task_id": "CPP/141", "generation": "#include <iostream>\n#include <string>\n#include <regex>\n\nusing namespace std;\n\nstring file_name_check(const string& file_name) {\n    // Regular expression pattern based on the given conditions\n    regex pattern(\"^[a-zA-Z][a-zA-Z0-9]{0,2}\\\\.(txt|exe|dll)$\");\n    \n    // Check if the file name matches the pattern\n    if (regex_match(file_name, pattern)) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\n\n"}
{"task_id": "CPP/142", "generation": "#include <vector>\nusing namespace std;\n\nint sum_squares(vector<int> lst) {\n    for (size_t i = 0; i < lst.size(); ++i) {\n        if (i % 3 == 0 && i != 0) {\n            lst[i] = lst[i] * lst[i]; // Square the element\n        } else if (i % 4 == 0 && i % 3 != 0) {\n            lst[i] = lst[i] * lst[i] * lst[i]; // Cube the element\n        }\n    }\n\n    int sum = 0;\n    for (int num : lst) {\n        sum += num; // Sum all elements in the list\n    }\n\n    return sum;\n}\n"}
{"task_id": "CPP/143", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    if (n == 2 || n == 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    for (int i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0)\n            return false;\n    }\n    return true;\n}\n\n// Function to process the sentence and return words with prime length\nstring words_in_sentence(string sentence) {\n    stringstream ss(sentence);\n    string word;\n    string result = \"\";\n    \n    while (ss >> word) {\n        if (is_prime(word.length())) {\n            if (!result.empty()) result += \" \";\n            result += word;\n        }\n    }\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/144", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\n// Function to simplify two fractions and check if their product is a whole number\nbool simplify(string x, string n) {\n    // Helper function to parse fraction from string\n    auto parse_fraction = [](const string& frac) -> pair<int, int> {\n        size_t slash_pos = frac.find('/');\n        int numerator = stoi(frac.substr(0, slash_pos));\n        int denominator = stoi(frac.substr(slash_pos + 1));\n        return {numerator, denominator};\n    };\n\n    // Parse the fractions\n    auto [num_x, den_x] = parse_fraction(x);\n    auto [num_n, den_n] = parse_fraction(n);\n\n    // Calculate the product of the numerators and denominators\n    int numerator_product = num_x * num_n;\n    int denominator_product = den_x * den_n;\n\n    // Check if the result is a whole number\n    return (numerator_product % denominator_product) == 0;\n}\n\n"}
{"task_id": "CPP/145", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\n// Helper function to calculate the sum of digits of an integer.\nint digit_sum(int n) {\n    if (n < 0) {\n        n = -n; // Make n positive for digit extraction\n    }\n    int sum = 0;\n    while (n > 0) {\n        sum += n % 10;\n        n /= 10;\n    }\n    return sum;\n}\n\n// Main function to sort the vector based on the sum of digits.\nvector<int> order_by_points(vector<int> nums) {\n    // Create a vector of pairs where each pair contains the original index and the number\n    std::vector<std::pair<int, int>> nums_with_indices;\n    for (size_t i = 0; i < nums.size(); ++i) {\n        nums_with_indices.push_back({static_cast<int>(i), nums[i]});\n    }\n\n    // Sort the vector of pairs based on digit sum and then by original index\n    std::sort(nums_with_indices.begin(), nums_with_indices.end(),\n              [](const std::pair<int, int>& a, const std::pair<int, int>& b) {\n                  int sum_a = digit_sum(a.second);\n                  int sum_b = digit_sum(b.second);\n                  if (sum_a == sum_b) {\n                      return a.first < b.first; // Maintain original order for same digit sums\n                  }\n                  return sum_a < sum_b;\n              });\n\n    // Extract the sorted numbers from the vector of pairs\n    std::vector<int> result;\n    for (const auto& p : nums_with_indices) {\n        result.push_back(p.second);\n    }\n\n    return result;\n}\n\n// Function to check the correctness of the order_by_points function.\nvoid check() {\n    assert(order_by_points({1, 11, -1, -11, -12}) == std::vector<int>{-1, -11, 1, -12, 11});\n    assert(order_by_points({}) == std::vector<int>{});\n    std::cout << \"All test cases passed!\" << std::endl;\n}\n\n"}
{"task_id": "CPP/146", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nint specialFilter(vector<int> nums) {\n    int count = 0;\n    \n    for (int num : nums) {\n        // Skip numbers that are not greater than 10\n        if (num <= 10) continue;\n        \n        string strNum = to_string(num);\n        int firstDigit = strNum[0] - '0';\n        int lastDigit = strNum[strNum.length() - 1] - '0';\n        \n        // Check if both the first and last digits are odd\n        if (firstDigit % 2 != 0 && lastDigit % 2 != 0) {\n            count++;\n        }\n    }\n    \n    return count;\n}\n\n"}
{"task_id": "CPP/147", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint get_max_triples(int n) {\n    // Step 1: Generate the vector a\n    vector<int> a(n);\n    for (int i = 1; i <= n; ++i) {\n        a[i - 1] = i * i - i + 1;\n    }\n\n    int count = 0;\n\n    // Step 2 and 3: Iterate through all possible triples (i, j, k)\n    for (int i = 0; i < n - 2; ++i) {\n        for (int j = i + 1; j < n - 1; ++j) {\n            for (int k = j + 1; k < n; ++k) {\n                if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                    count++;\n                }\n            }\n        }\n    }\n\n    return count;\n}\n\n// Function to test the solution\nvoid check() {\n    int result = get_max_triples(5);\n    cout << \"Output: \" << result << endl; // Expected output: 1\n}\n\n"}
{"task_id": "CPP/148", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\n// Define a list of planets in order from closest to farthest from the Sun.\nconst std::vector<std::string> planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n\nstd::vector<std::string> bf(std::string planet1, std::string planet2) {\n    // Find the indices of the input planets.\n    auto index1 = std::find(planets.begin(), planets.end(), planet1);\n    auto index2 = std::find(planets.begin(), planets.end(), planet2);\n\n    if (index1 == planets.end() || index2 == planets.end()) {\n        // If either planet is not found, return an empty vector.\n        return {};\n    }\n\n    int idx1 = std::distance(planets.begin(), index1);\n    int idx2 = std::distance(planets.begin(), index2);\n\n    // Ensure that idx1 <= idx2 for correct slicing.\n    if (idx1 > idx2) {\n        std::swap(idx1, idx2);\n    }\n\n    // Return the sublist of planets between the two indices, excluding the input planets themselves.\n    return {planets.begin() + idx1 + 1, planets.begin() + idx2};\n}\n\n// Function to check and print the result\nvoid check_function() {\n    std::vector<std::string> result = bf(\"Jupiter\", \"Neptune\");\n    for (const auto& planet : result) {\n        std::cout << planet << \" \";\n    }\n    std::cout << std::endl;\n\n    result = bf(\"Earth\", \"Mercury\");\n    for (const auto& planet : result) {\n        std::cout << planet << \" \";\n    }\n    std::cout << std::endl;\n\n    result = bf(\"Mercury\", \"Uranus\");\n    for (const auto& planet : result) {\n        std::cout << planet << \" \";\n    }\n    std::cout << std::endl;\n}\n\n"}
{"task_id": "CPP/149", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nvector<string> vector_sort(vector<string> lst) {\n    // Filter out strings with odd lengths\n    lst.erase(remove_if(lst.begin(), lst.end(), [](const string& s) { return s.length() % 2 != 0; }), lst.end());\n    \n    // Sort the filtered list by length, then alphabetically\n    sort(lst.begin(), lst.end(), [](const string& a, const string& b) {\n        if (a.length() == b.length()) {\n            return a < b;\n        }\n        return a.length() < b.length();\n    });\n    \n    return lst;\n}\n\n"}
{"task_id": "CPP/150", "generation": "#include<stdio.h>\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int n) {\n    if (n <= 1) return false; // Numbers less than or equal to 1 are not prime\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\n// Function that returns x if n is a prime number, otherwise returns y\nint x_or_y(int n, int x, int y) {\n    return is_prime(n) ? x : y;\n}\n\n"}
{"task_id": "CPP/151", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nlong long double_the_difference(vector<float> lst) {\n    long long sum = 0;\n    \n    for (float num : lst) {\n        // Check if the number is positive, an integer, and odd\n        if (num > 0 && floor(num) == num && static_cast<int>(num) % 2 != 0) {\n            sum += pow(num, 2);\n        }\n    }\n    \n    return sum;\n}\n\n"}
{"task_id": "CPP/152", "generation": "#include <iostream>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\n// Function to compare the scores with guesses\nvector<int> compare(vector<int> game, vector<int> guess) {\n    vector<int> result;\n    \n    // Iterate through each match and calculate the absolute difference\n    for (size_t i = 0; i < game.size(); ++i) {\n        int diff = abs(game[i] - guess[i]);\n        result.push_back(diff);\n    }\n    \n    return result;\n}\n\n// Function to print a vector of integers\nvoid printVector(const vector<int>& vec) {\n    for (int num : vec) {\n        cout << num << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/153", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to calculate the strength of an extension\nint calculateStrength(const string& extension) {\n    int cap = 0, sm = 0;\n    for (char c : extension) {\n        if (isupper(c)) cap++;\n        else if (islower(c)) sm++;\n    }\n    return cap - sm;\n}\n\nstring Strongest_Extension(string class_name, vector<string> extensions) {\n    string strongest_extension = \"\";\n    int max_strength = INT_MIN;\n\n    for (const string& extension : extensions) {\n        int strength = calculateStrength(extension);\n        if (strength > max_strength) {\n            max_strength = strength;\n            strongest_extension = extension;\n        }\n    }\n\n    return class_name + \".\" + strongest_extension;\n}\n\n// Example usage\n"}
{"task_id": "CPP/154", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nbool cycpattern_check(const string& a, const string& b) {\n    // Concatenate the first string with itself to handle rotations\n    string doubled_a = a + a;\n    \n    // Check if the second string or any of its rotations is a substring of the concatenated string\n    return doubled_a.find(b) != string::npos;\n}\n\n"}
{"task_id": "CPP/155", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// Function to count even and odd digits in an integer\nvector<int> even_odd_count(int num) {\n    // Convert the number to a string to easily iterate over each digit\n    string str_num = to_string(abs(num));\n    \n    int even_count = 0;\n    int odd_count = 0;\n    \n    for (char digit : str_num) {\n        if ((digit - '0') % 2 == 0) {\n            even_count++;\n        } else {\n            odd_count++;\n        }\n    }\n    \n    return {even_count, odd_count};\n}\n\n// Function to test the even_odd_count function\nvoid test_even_odd_count() {\n    assert(even_odd_count(-12) == vector<int>({1, 1}));\n    assert(even_odd_count(123) == vector<int>({1, 2}));\n    assert(even_odd_count(0) == vector<int>({1, 0})); // Edge case: single digit 0\n    assert(even_odd_count(-9876543210) == vector<int>({5, 5}));\n    \n    cout << \"All test cases passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/156", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to convert an integer to its Roman numeral equivalent in lowercase\nstring int_to_mini_roman(int number) {\n    // Mapping of integers to their corresponding Roman numerals\n    vector<pair<int, string>> roman_map = {\n        {1000, \"m\"}, {900, \"cm\"}, {500, \"d\"}, {400, \"cd\"},\n        {100, \"c\"}, {90, \"xc\"}, {50, \"l\"}, {40, \"xl\"},\n        {10, \"x\"}, {9, \"ix\"}, {5, \"v\"}, {4, \"iv\"}, {1, \"i\"}\n    };\n\n    string roman_numeral = \"\";\n\n    // Iterate through the map and construct the Roman numeral\n    for (const auto& [value, symbol] : roman_map) {\n        while (number >= value) {\n            roman_numeral += symbol;\n            number -= value;\n        }\n    }\n\n    return roman_numeral;\n}\n\n// Function to check the correctness of the int_to_mini_roman function\nvoid check() {\n    assert(int_to_mini_roman(19) == \"xix\");\n    assert(int_to_mini_roman(152) == \"clii\");\n    assert(int_to_mini_roman(426) == \"cdxxvi\");\n    cout << \"All test cases passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/157", "generation": "#include <stdio.h>\n#include <math.h>\n\nusing namespace std;\n\nbool right_angle_triangle(float a, float b, float c) {\n    // First, sort the sides so that 'c' is the longest side (hypotenuse)\n    if (a > c) swap(a, c);\n    if (b > c) swap(b, c);\n\n    // Check if the Pythagorean theorem holds\n    return fabs(a*a + b*b - c*c) < 1e-6; // Using a small epsilon to account for floating point precision issues\n}\n\n"}
{"task_id": "CPP/158", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to count unique characters in a string\nint count_unique_chars(const string& word) {\n    bool seen[256] = {false};\n    int count = 0;\n    for (char c : word) {\n        if (!seen[c]) {\n            seen[c] = true;\n            count++;\n        }\n    }\n    return count;\n}\n\n// Function to find the word with maximum unique characters\nstring find_max(vector<string> words) {\n    string max_word = \"\";\n    int max_unique_chars = 0;\n\n    for (const auto& word : words) {\n        int unique_chars = count_unique_chars(word);\n        if (unique_chars > max_unique_chars || \n            (unique_chars == max_unique_chars && word < max_word)) {\n            max_word = word;\n            max_unique_chars = unique_chars;\n        }\n    }\n\n    return max_word;\n}\n\n// Function to test the find_max function\nvoid test_find_max() {\n    assert(find_max({\"name\", \"of\", \"string\"}) == \"string\");\n    assert(find_max({\"name\", \"enam\", \"game\"}) == \"enam\");\n    assert(find_max({\"aaaaaaa\", \"bb\", \"cc\"}) == \"aaaaaaa\");\n    cout << \"All test cases passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/159", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nvector<int> eat(int number, int need, int remaining) {\n    // Calculate the maximum number of carrots that can be eaten from the remaining stock\n    int max_to_eat = min(need, remaining);\n    \n    // Update the total number of carrots eaten\n    int total_eaten = number + max_to_eat;\n    \n    // Update the remaining carrots in stock\n    int remaining_after_meal = remaining - max_to_eat;\n    \n    return {total_eaten, remaining_after_meal};\n}\n\n// Function to test the eat function with provided examples\nvoid check() {\n    vector<int> result1 = eat(5, 6, 10);\n    printf(\"eat(5, 6, 10) -> {%d, %d}\\n\", result1[0], result1[1]); // Expected: {11, 4}\n    \n    vector<int> result2 = eat(4, 8, 9);\n    printf(\"eat(4, 8, 9) -> {%d, %d}\\n\", result2[0], result2[1]); // Expected: {12, 1}\n    \n    vector<int> result3 = eat(1, 10, 10);\n    printf(\"eat(1, 10, 10) -> {%d, %d}\\n\", result3[0], result3[1]); // Expected: {11, 0}\n    \n    vector<int> result4 = eat(2, 11, 5);\n    printf(\"eat(2, 11, 5) -> {%d, %d}\\n\", result4[0], result4[1]); // Expected: {7, 0}\n}\n\n"}
{"task_id": "CPP/160", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nint do_algebra(const vector<string>& operators, const vector<int>& operands) {\n    // Initialize the expression with the first operand\n    string expression = to_string(operands[0]);\n    \n    // Construct the expression by iterating through the operators and operands\n    for (size_t i = 0; i < operators.size(); ++i) {\n        expression += \" \" + operators[i] + \" \" + to_string(operands[i + 1]);\n    }\n    \n    // Evaluate the constructed expression using C++'s stringstream and eval-like mechanism\n    int result;\n    std::istringstream iss(expression);\n    iss >> result; // Read the integer value from the string\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/161", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\n// Function to solve the problem as described\nstring solve(string s) {\n    bool hasLetters = false;\n    \n    // Check if there are any letters in the string\n    for (char c : s) {\n        if (isalpha(c)) {\n            hasLetters = true;\n            break;\n        }\n    }\n\n    if (!hasLetters) {\n        // If no letters, reverse the entire string\n        reverse(s.begin(), s.end());\n    } else {\n        // If there are letters, convert them to their opposite case\n        for (char &c : s) {\n            if (islower(c)) {\n                c = toupper(c);\n            } else if (isupper(c)) {\n                c = tolower(c);\n            }\n        }\n    }\n\n    return s;\n}\n\n// Function to test the solve function with provided examples\nvoid test() {\n    cout << \"solve(\\\"1234\\\") = \\\"\" << solve(\"1234\") << \"\\\" (Expected: \\\"4321\\\")\" << endl;\n    cout << \"solve(\\\"ab\\\") = \\\"\" << solve(\"ab\") << \"\\\" (Expected: \\\"AB\\\")\" << endl;\n    cout << \"solve(\\\"#a@C\\\") = \\\"\" << solve(\"#a@C\") << \"\\\" (Expected: \\\"#A@c\\\")\" << endl;\n}\n\n"}
{"task_id": "CPP/162", "generation": "#include <iostream>\n#include <openssl/md5.h>\n#include <sstream>\n#include <iomanip>\n\n// Function to convert byte array to hex string\nstd::string bytes_to_hex(const unsigned char* bytes, size_t len) {\n    std::stringstream ss;\n    for (size_t i = 0; i < len; ++i) {\n        ss << std::hex << std::setw(2) << std::setfill('0') << static_cast<int>(bytes[i]);\n    }\n    return ss.str();\n}\n\n// Function to convert string to MD5 hash\nstd::string string_to_md5(const std::string& text) {\n    if (text.empty()) {\n        return \"None\";\n    }\n\n    unsigned char digest[MD5_DIGEST_LENGTH];\n    MD5(reinterpret_cast<const unsigned char*>(text.c_str()), text.length(), digest);\n\n    // Convert the hash to a hexadecimal string\n    return bytes_to_hex(digest, MD5_DIGEST_LENGTH);\n}\n\n"}
{"task_id": "CPP/163", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> generate_integers(int a, int b) {\n    vector<int> even_digits = {2, 4, 6, 8};\n    vector<int> result;\n    \n    // Ensure the range is from min(a, b) to max(a, b)\n    int start = min(a, b);\n    int end = max(a, b);\n    \n    // Iterate through each number in the range\n    for (int i = start; i <= end; ++i) {\n        string num_str = to_string(i);  // Convert number to string\n        for (char digit : num_str) {   // Iterate through each digit of the number\n            int digit_int = digit - '0';  // Convert character digit to integer\n            if (find(even_digits.begin(), even_digits.end(), digit_int) != even_digits.end()) {\n                result.push_back(digit_int);  // Add even digit to result set\n            }\n        }\n    }\n    \n    sort(result.begin(), result.end());  // Sort the result in ascending order\n    \n    return result;\n}\n\n// Function to print the vector for testing\nvoid print_vector(const vector<int>& vec) {\n    for (int num : vec) {\n        cout << num << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/0", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // For std::sort\n\nbool has_close_elements(vector<float> numbers, float threshold) {\n    // Sort the vector first\n    sort(numbers.begin(), numbers.end());\n\n    // Iterate through adjacent elements to check if any pair is closer than the threshold\n    for (size_t i = 0; i < numbers.size() - 1; ++i) {\n        if (numbers[i + 1] - numbers[i] < threshold) {\n            return true;\n        }\n    }\n\n    // If no such pair found, return false\n    return false;\n}\n\n"}
{"task_id": "CPP/1", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> separate_paren_groups(string paren_string) {\n    vector<string> result;\n    string current_group;\n    int balance = 0;\n\n    for (char ch : paren_string) {\n        if (ch == '(') {\n            balance++;\n            current_group += ch;\n        } else if (ch == ')') {\n            balance--;\n            current_group += ch;\n            if (balance == 0) {\n                result.push_back(current_group);\n                current_group.clear();\n            }\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/2", "generation": "#include <stdio.h>\n#include <math.h>\n\nfloat truncate_number(float number) {\n    float integerPart;\n    modf(number, &integerPart);  // modf returns the fractional part and stores the integer part in `integerPart`\n    return number - integerPart; // Subtracting the integer part from the original number gives the decimal part\n}\n\n"}
{"task_id": "CPP/3", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool below_zero(vector<int> operations) {\n    int balance = 0; // Start with a zero balance\n\n    for (int op : operations) {\n        balance += op; // Update the balance after each operation\n\n        if (balance < 0) { // Check if the balance falls below zero\n            return true;\n        }\n    }\n\n    return false; // Return false if the balance never goes below zero\n}\n\n// Function to test the below_zero function with provided examples\nvoid check_function() {\n    vector<int> operations1 = {1, 2, 3};\n    vector<int> operations2 = {1, 2, -4, 5};\n\n    cout << \"Test Case 1: \" << (below_zero(operations1) ? \"Passed\" : \"Failed\") << endl;\n    cout << \"Test Case 2: \" << (below_zero(operations2) ? \"Passed\" : \"Failed\") << endl;\n}\n\n"}
{"task_id": "CPP/4", "generation": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nfloat mean_absolute_deviation(vector<float> numbers) {\n    // Step 1: Calculate the mean of the dataset\n    float sum = 0.0;\n    for (const auto& num : numbers) {\n        sum += num;\n    }\n    float mean = sum / numbers.size();\n\n    // Step 2 and 3: Compute the absolute differences and their average\n    float mad = 0.0;\n    for (const auto& num : numbers) {\n        mad += abs(num - mean);\n    }\n    mad /= numbers.size();\n\n    return mad;\n}\n\n"}
{"task_id": "CPP/5", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> intersperse(vector<int> numbers, int delimeter) {\n    vector<int> result;\n    \n    // Iterate through the original vector and insert each element followed by the delimiter\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        result.push_back(numbers[i]);\n        if (i != numbers.size() - 1) {  // Do not add a delimiter after the last element\n            result.push_back(delimeter);\n        }\n    }\n    \n    return result;\n}\n\n// Function to test the intersperse function\nvoid testIntersperse() {\n    vector<int> emptyVec = {};\n    vector<int> vec1 = {1, 2, 3};\n    vector<int> expected1 = {1, 4, 2, 4, 3};\n\n    cout << \"Testing with an empty vector:\" << endl;\n    for (int num : intersperse(emptyVec, 4)) {\n        cout << num << \" \";\n    }\n    cout << endl;\n\n    cout << \"Testing with a non-empty vector:\" << endl;\n    for (int num : intersperse(vec1, 4)) {\n        cout << num << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/6", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to parse and determine the deepest level of nesting for a single group of parentheses\nint maxDepthOfNesting(const string& group) {\n    int currentDepth = 0;\n    int maxDepth = 0;\n    \n    for (char ch : group) {\n        if (ch == '(') {\n            currentDepth++;\n            maxDepth = max(maxDepth, currentDepth);\n        } else if (ch == ')') {\n            currentDepth--;\n        }\n    }\n    \n    return maxDepth;\n}\n\n// Function to process the entire string and return a vector of maximum depths for each group\nvector<int> parse_nested_parens(string paren_string) {\n    vector<int> result;\n    size_t start = 0;\n    size_t end = paren_string.find(' ');\n    \n    while (end != string::npos) {\n        // Extract the current group from the string\n        string group = paren_string.substr(start, end - start);\n        \n        // Calculate the maximum depth of nesting for the current group\n        int maxDepth = maxDepthOfNesting(group);\n        \n        result.push_back(maxDepth);\n        \n        // Move to the next group\n        start = end + 1;\n        end = paren_string.find(' ', start);\n    }\n    \n    // Process the last group if there is one\n    if (start < paren_string.length()) {\n        string group = paren_string.substr(start);\n        int maxDepth = maxDepthOfNesting(group);\n        result.push_back(maxDepth);\n    }\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/7", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to filter strings containing a given substring\nvector<string> filter_by_substring(vector<string> strings, string substring) {\n    vector<string> filtered_strings;\n    \n    // Iterate through each string in the input vector\n    for (const auto& str : strings) {\n        // Check if the current string contains the substring\n        if (str.find(substring) != string::npos) {\n            // If it does, add it to the filtered list\n            filtered_strings.push_back(str);\n        }\n    }\n    \n    return filtered_strings;\n}\n\n// Function to test the filter_by_substring function\nvoid test_filter_by_substring() {\n    vector<string> input1 = {};\n    vector<string> expected1 = {};\n    assert(filter_by_substring(input1, \"a\") == expected1);\n\n    vector<string> input2 = {\"abc\", \"bacd\", \"cde\", \"vector\"};\n    vector<string> expected2 = {\"abc\", \"bacd\", \"vector\"};\n    assert(filter_by_substring(input2, \"a\") == expected2);\n\n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/8", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// Function to calculate the sum and product of elements in a vector\nvector<int> sum_product(vector<int> numbers) {\n    int sum = 0;\n    int product = 1;\n\n    // Iterate through each number in the vector\n    for (int num : numbers) {\n        sum += num;  // Add the current number to the sum\n        product *= num;  // Multiply the current number with the product\n    }\n\n    return {sum, product};\n}\n\n// Function to test the sum_product function\nvoid test_sum_product() {\n    vector<int> empty = {};\n    vector<int> result1 = sum_product(empty);\n    cout << \"Empty Vector: Sum = \" << result1[0] << \", Product = \" << result1[1] << endl;\n\n    vector<int> numbers = {1, 2, 3, 4};\n    vector<int> result2 = sum_product(numbers);\n    cout << \"Vector [1, 2, 3, 4]: Sum = \" << result2[0] << \", Product = \" << result2[1] << endl;\n}\n\n"}
{"task_id": "CPP/9", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> rolling_max(vector<int> numbers) {\n    if (numbers.empty()) return {};  // Return an empty vector if input is empty\n\n    vector<int> result;\n    int current_max = numbers[0];  // Initialize the current maximum with the first element\n    for (int num : numbers) {\n        if (num > current_max) {\n            current_max = num;  // Update the current maximum if a larger number is found\n        }\n        result.push_back(current_max);  // Add the current maximum to the result vector\n    }\n\n    return result;\n}\n\n// Function to print the vector for testing purposes\nvoid print_vector(const vector<int>& vec) {\n    for (int num : vec) {\n        cout << num << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/10", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_palindrome(const string& s) {\n    return s == string(s.rbegin(), s.rend());\n}\n\nstring make_palindrome(string str) {\n    int n = str.length();\n    for (int i = 0; i < n; ++i) {\n        if (is_palindrome(str.substr(i))) {\n            // Correcting the concatenation of strings\n            return str + string(str.begin(), str.begin() + i).substr(0, i);\n        }\n    }\n    return str + string(str.rbegin(), str.rend());\n}\n\n"}
{"task_id": "CPP/11", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring string_xor(string a, string b) {\n    // Ensure both strings are of equal length by padding with leading zeros if necessary\n    int maxLength = max(a.length(), b.length());\n    a.insert(0, maxLength - a.length(), '0');\n    b.insert(0, maxLength - b.length(), '0');\n\n    string result(maxLength, '0');  // Initialize the result string\n\n    // Perform XOR operation character by character\n    for (int i = 0; i < maxLength; ++i) {\n        if (a[i] != b[i]) {\n            result[i] = '1';  // If characters are different, set result to '1'\n        }\n    }\n\n    return result;\n}\n\n// Function to test the string_xor function\nvoid test_string_xor() {\n    cout << \"Testing string_xor function:\" << endl;\n    cout << \"Input: \\\"010\\\", \\\"110\\\" - Output: \\\"\" << string_xor(\"010\", \"110\") << \"\\\" (Expected: \\\"100\\\")\" << endl;\n    cout << \"Input: \\\"10101\\\", \\\"11001\\\" - Output: \\\"\" << string_xor(\"10101\", \"11001\") << \"\\\" (Expected: \\\"01100\\\")\" << endl;\n}\n\n"}
{"task_id": "CPP/12", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring longest(const vector<string>& strings) {\n    if (strings.empty()) {\n        return \"\"; // Return an empty string to indicate None in this context.\n    }\n\n    const string* longestString = &strings[0];\n    for (const auto& str : strings) {\n        if (str.length() > longestString->length()) {\n            longestString = &str;\n        }\n    }\n\n    return *longestString;\n}\n\n"}
{"task_id": "CPP/13", "generation": "#include <stdio.h>\nusing namespace std;\n\nint greatest_common_divisor(int a, int b) {\n    // Ensure a >= b to simplify the logic\n    if (b > a) {\n        return greatest_common_divisor(b, a);\n    }\n\n    // Base case: if b is 0, then GCD is a\n    if (b == 0) {\n        return a;\n    }\n\n    // Recursive call with remainder of a divided by b\n    return greatest_common_divisor(b, a % b);\n}\n\n"}
{"task_id": "CPP/14", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to generate all prefixes of the input string\nvector<string> all_prefixes(string str) {\n    vector<string> prefixes;\n    for (size_t i = 1; i <= str.length(); ++i) {\n        prefixes.push_back(str.substr(0, i));\n    }\n    return prefixes;\n}\n\n"}
{"task_id": "CPP/15", "generation": "#include <iostream>\n#include <sstream>\n#include <string>\nusing namespace std;\n\nstring string_sequence(int n) {\n    stringstream ss;\n    for (int i = 0; i <= n; ++i) {\n        ss << i;\n        if (i < n) {\n            ss << \" \";\n        }\n    }\n    return ss.str();\n}\n\n// Function to test the string_sequence function\nvoid test_string_sequence() {\n    cout << \"Testing string_sequence...\" << endl;\n    assert(string_sequence(0) == \"0\");\n    assert(string_sequence(5) == \"0 1 2 3 4 5\");\n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/16", "generation": "#include <iostream>\n#include <string>\n#include <set>\n\nusing namespace std;\n\nint count_distinct_characters(string str) {\n    // Convert the string to lowercase to ensure case insensitivity\n    transform(str.begin(), str.end(), str.begin(), ::tolower);\n    \n    // Use a set to store distinct characters\n    set<char> distinct_chars(str.begin(), str.end());\n    \n    // The size of the set is the number of distinct characters\n    return distinct_chars.size();\n}\n\n"}
{"task_id": "CPP/17", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<int> parse_music(const string& music_string) {\n    vector<int> beats;\n    \n    // Split the input string into individual notes\n    size_t start = 0, end = 0;\n    while ((end = music_string.find(\" \", start)) != string::npos) {\n        string note = music_string.substr(start, end - start);\n        \n        if (note == \"o\") {\n            beats.push_back(4);\n        } else if (note == \"o|\") {\n            beats.push_back(2);\n        } else if (note == \".|\") {\n            beats.push_back(1);\n        }\n        \n        start = end + 1;\n    }\n    \n    // Handle the last note in case there is no trailing space\n    string last_note = music_string.substr(start);\n    if (last_note == \"o\") {\n        beats.push_back(4);\n    } else if (last_note == \"o|\") {\n        beats.push_back(2);\n    } else if (last_note == \".|\") {\n        beats.push_back(1);\n    }\n    \n    return beats;\n}\n\n"}
{"task_id": "CPP/18", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint how_many_times(const string& str, const string& substring) {\n    if (substring.empty()) return 0;\n    \n    int count = 0;\n    size_t pos = 0;\n    \n    while ((pos = str.find(substring, pos)) != string::npos) {\n        ++count;\n        pos++; // Move to the next character to allow overlapping matches\n    }\n    \n    return count;\n}\n\n"}
{"task_id": "CPP/19", "generation": "#include <iostream>\n#include <string>\n#include <map>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to convert word to number\nint word_to_number(const string& word) {\n    map<string, int> num_map = {{\"zero\", 0}, {\"one\", 1}, {\"two\", 2}, {\"three\", 3},\n                                {\"four\", 4}, {\"five\", 5}, {\"six\", 6}, {\"seven\", 7},\n                                {\"eight\", 8}, {\"nine\", 9}};\n    return num_map[word];\n}\n\n// Function to sort numbers\nstring sort_numbers(const string& numbers) {\n    vector<string> words;\n    string number;\n    \n    // Split the input string into individual words\n    for (char ch : numbers) {\n        if (ch == ' ') {\n            if (!number.empty()) {\n                words.push_back(number);\n                number.clear();\n            }\n        } else {\n            number += ch;\n        }\n    }\n    if (!number.empty()) {\n        words.push_back(number);\n    }\n\n    // Sort the words based on their numeric value\n    sort(words.begin(), words.end(), [](const string& a, const string& b) {\n        return word_to_number(a) < word_to_number(b);\n    });\n\n    // Join the sorted words back into a single string\n    string result;\n    for (const auto& word : words) {\n        if (!result.empty()) {\n            result += \" \";\n        }\n        result += word;\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/20", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to find the two closest elements in a vector of floats\nstd::pair<float, float> find_closest_elements(const std::vector<float>& numbers) {\n    // Sort the input vector (ensure it's not const for sorting)\n    std::vector<float> sorted_numbers(numbers);  // Make a copy of the vector to avoid modifying the original\n    sort(sorted_numbers.begin(), sorted_numbers.end());\n\n    float min_diff = std::numeric_limits<float>::max();\n    std::pair<float, float> closest_pair;\n\n    for (size_t i = 0; i < sorted_numbers.size() - 1; ++i) {\n        float diff = sorted_numbers[i + 1] - sorted_numbers[i];\n        if (diff < min_diff) {\n            min_diff = diff;\n            closest_pair = {sorted_numbers[i], sorted_numbers[i + 1]};\n        }\n    }\n\n    return closest_pair;\n}\n\n"}
{"task_id": "CPP/21", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // For std::min_element and std::max_element\n\nusing namespace std;\n\nvector<float> rescale_to_unit(vector<float> numbers) {\n    if (numbers.size() < 2) {\n        throw invalid_argument(\"Vector must contain at least two elements.\");\n    }\n\n    float min_value = *std::min_element(numbers.begin(), numbers.end());\n    float max_value = *std::max_element(numbers.begin(), numbers.end());\n\n    vector<float> scaled_numbers;\n    for (float num : numbers) {\n        float new_value = (num - min_value) / (max_value - min_value);\n        scaled_numbers.push_back(new_value);\n    }\n\n    return scaled_numbers;\n}\n\n"}
{"task_id": "CPP/22", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <list>\n#include <boost/any.hpp>\n\ntypedef std::list<boost::any> list_any;\nusing namespace std;\n\nvector<int> filter_integers(list_any values) {\n    vector<int> result;\n    for (const auto& value : values) {\n        if (value.type() == typeid(int)) {\n            result.push_back(boost::any_cast<int>(value));\n        }\n    }\n    return result;\n}\n\n"}
{"task_id": "CPP/23", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint strlen(const string& str) {\n    // Return the size of the string, which is equivalent to its length.\n    return str.size();\n}\n\n// Function to test the strlen function with some examples\nvoid test_strlen() {\n    cout << \"Length of \\\"\\\" (empty string): \" << strlen(\"\") << endl;\n    cout << \"Length of \\\"abc\\\": \" << strlen(\"abc\") << endl;\n    cout << \"Length of \\\"hello world\\\": \" << strlen(\"hello world\") << endl;\n}\n\n"}
{"task_id": "CPP/24", "generation": "#include <iostream>\nusing namespace std;\n\nint largest_divisor(int n) {\n    for (int i = n - 1; i > 0; --i) {\n        if (n % i == 0) {\n            return i;\n        }\n    }\n    // If no divisor is found, which should not happen for positive integers,\n    // we can return -1 or throw an exception. For simplicity, returning -1.\n    return -1;\n}\n\n"}
{"task_id": "CPP/25", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> factorize(int n) {\n    vector<int> factors;\n    \n    // Divide by 2 to get rid of all even factors\n    while (n % 2 == 0) {\n        factors.push_back(2);\n        n /= 2;\n    }\n    \n    // Check for odd factors from 3 onwards\n    for (int i = 3; i * i <= n; i += 2) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n    \n    // If n is a prime number greater than 2\n    if (n > 2) {\n        factors.push_back(n);\n    }\n    \n    return factors;\n}\n\n"}
{"task_id": "CPP/26", "generation": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nvector<int> remove_duplicates(vector<int> numbers) {\n    // Create an unordered map to count occurrences of each element\n    unordered_map<int, int> counts;\n    \n    // Count the occurrences of each number in the input vector\n    for (int num : numbers) {\n        counts[num]++;\n    }\n    \n    // Create a new vector to store elements that occur exactly once\n    vector<int> result;\n    \n    // Iterate through the original vector and add elements to the result if they occur only once\n    for (int num : numbers) {\n        if (counts[num] == 1) {\n            result.push_back(num);\n        }\n    }\n    \n    return result;\n}\n\n// Function to check the correctness of the remove_duplicates function\nvoid check() {\n    vector<int> input = {1, 2, 3, 2, 4};\n    vector<int> expected_output = {1, 3, 4};\n    vector<int> output = remove_duplicates(input);\n    \n    if (output == expected_output) {\n        cout << \"Test passed.\" << endl;\n    } else {\n        cout << \"Test failed.\" << endl;\n    }\n}\n\n"}
{"task_id": "CPP/27", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring flip_case(string str) {\n    for (char &c : str) {\n        if (islower(c)) {\n            c = toupper(c);\n        } else if (isupper(c)) {\n            c = tolower(c);\n        }\n    }\n    return str;\n}\n\n"}
{"task_id": "CPP/28", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <numeric> // For std::accumulate\n\nusing namespace std;\n\nstring concatenate(vector<string> strings) {\n    // Use std::accumulate to concatenate all strings in the vector\n    return accumulate(strings.begin(), strings.end(), string(\"\"));\n}\n\n// Function to test the concatenate function\nvoid test_concatenate() {\n    assert(concatenate({}) == \"\");\n    assert(concatenate({\"a\", \"b\", \"c\"}) == \"abc\");\n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/29", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to filter strings based on the given prefix\nvector<string> filter_by_prefix(vector<string> strings, string prefix) {\n    vector<string> filtered_strings;\n    \n    // Iterate through each string in the input vector\n    for (const auto& str : strings) {\n        // Check if the current string starts with the given prefix\n        if (str.substr(0, prefix.length()) == prefix) {\n            // If it does, add it to the filtered list\n            filtered_strings.push_back(str);\n        }\n    }\n    \n    return filtered_strings;\n}\n\n// Function to test the filter_by_prefix function\nvoid test_filter_by_prefix() {\n    vector<string> input1 = {};\n    string prefix1 = \"a\";\n    vector<string> result1 = filter_by_prefix(input1, prefix1);\n    cout << \"Test 1: \";\n    if (result1.empty()) {\n        cout << \"Passed\" << endl;\n    } else {\n        cout << \"Failed\" << endl;\n    }\n\n    vector<string> input2 = {\"abc\", \"bcd\", \"cde\", \"vector\"};\n    string prefix2 = \"a\";\n    vector<string> result2 = filter_by_prefix(input2, prefix2);\n    cout << \"Test 2: \";\n    if (result2 == vector<string>{\"abc\", \"vector\"}) {\n        cout << \"Passed\" << endl;\n    } else {\n        cout << \"Failed\" << endl;\n    }\n}\n\n"}
{"task_id": "CPP/30", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvector<float> get_positive(vector<float> l) {\n    vector<float> result;\n    for (float num : l) {\n        if (num > 0) {\n            result.push_back(num);\n        }\n    }\n    return result;\n}\n\n"}
{"task_id": "CPP/31", "generation": "#include <iostream>\nusing namespace std;\n\nbool is_prime(long long n) {\n    // Handle edge cases for numbers less than or equal to 1\n    if (n <= 1) return false;\n    \n    // Check divisibility from 2 up to the square root of n\n    for (long long i = 2; i * i <= n; ++i) {\n        if (n % i == 0) {\n            return false; // Found a divisor, so it's not prime\n        }\n    }\n    \n    return true; // No divisors found, so it is prime\n}\n\n"}
{"task_id": "CPP/32", "generation": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <cassert>\n\ndouble poly(const std::vector<double>& xs, double x) {\n    double sum = 0;\n    for (size_t i = 0; i < xs.size(); ++i) {\n        sum += xs[i] * pow(x, static_cast<long>(i));\n    }\n    return sum;\n}\n\ndouble find_zero(const std::vector<double>& xs) {\n    assert(xs.size() % 2 == 0); // Ensure the number of coefficients is even\n\n    double x = 0.0; // Initial guess\n    for (size_t i = 1; i < xs.size(); ++i) {\n        if (std::abs(xs[i]) > std::abs(xs[0])) { // Check if the largest non-zero coefficient is at an odd index\n            x = static_cast<double>(i);\n            break;\n        }\n    }\n\n    double zero_point = x; // Use the initial guess as the root\n\n    return std::round(zero_point); // Return the rounded root\n}\n\n"}
{"task_id": "CPP/33", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> sort_third(vector<int> l) {\n    // Extract elements at indices divisible by 3\n    vector<int> third_indices;\n    for (int i = 0; i < l.size(); i += 3) {\n        third_indices.push_back(l[i]);\n    }\n    \n    // Sort the extracted elements\n    sort(third_indices.begin(), third_indices.end());\n    \n    // Create a copy of the original list to store the result\n    vector<int> l_prime = l;\n    \n    // Replace elements at indices divisible by 3 with sorted values\n    for (int i = 0, j = 0; i < l.size(); i += 3) {\n        l_prime[i] = third_indices[j++];\n    }\n    \n    return l_prime;\n}\n\n// Function to print the vector\nvoid print_vector(const vector<int>& v) {\n    for (int val : v) {\n        cout << val << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/34", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> unique(vector<int> l) {\n    // Sort the input vector\n    sort(l.begin(), l.end());\n    \n    // Remove consecutive duplicate elements\n    auto last = unique(l.begin(), l.end());\n    \n    // Resize the vector to contain only the unique elements\n    l.resize(distance(l.begin(), last));\n    \n    return l;\n}\n\n"}
{"task_id": "CPP/35", "generation": "#include <iostream>\n#include <vector>\n\nfloat max_element(const std::vector<float>& l) {\n    if (l.empty()) {\n        throw std::invalid_argument(\"Vector is empty\");\n    }\n\n    float max_val = l[0];\n    for (size_t i = 1; i < l.size(); ++i) {\n        if (l[i] > max_val) {\n            max_val = l[i];\n        }\n    }\n    return max_val;\n}\n\n"}
{"task_id": "CPP/36", "generation": "#include <iostream>\nusing namespace std;\n\nint fizz_buzz(int n) {\n    int count = 0;\n    \n    for (int i = 1; i < n; ++i) {\n        if (i % 11 == 0 || i % 13 == 0) {\n            // Convert the number to a string and count occurrences of '7'\n            string num_str = to_string(i);\n            for (char c : num_str) {\n                if (c == '7') {\n                    ++count;\n                }\n            }\n        }\n    }\n    \n    return count;\n}\n\n"}
{"task_id": "CPP/37", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<float> sort_even(vector<float> l) {\n    // Extract elements at even indices\n    vector<float> evens;\n    for (size_t i = 0; i < l.size(); i += 2) {\n        evens.push_back(l[i]);\n    }\n\n    // Sort the extracted elements\n    sort(evens.begin(), evens.end());\n\n    // Place sorted elements back into their original positions\n    size_t evenIndex = 0;\n    for (size_t i = 0; i < l.size(); ++i) {\n        if (i % 2 == 0) {\n            l[i] = evens[evenIndex++];\n        }\n    }\n\n    return l;\n}\n\n// Function to check the correctness of the sort_even function\nvoid check() {\n    vector<float> result1 = sort_even({1, 2, 3});\n    assert(result1 == vector<float>({1, 2, 3}));\n\n    vector<float> result2 = sort_even({5, 6, 3, 4});\n    assert(result2 == vector<float>({3, 6, 5, 4}));\n\n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/38", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nstring encode_cyclic(string s) { \n    // returns encoded string by cycling groups of three characters.  \n    int l = s.length();\n    int num = (l + 2) / 3;\n    string x, output;\n    for (int i = 0; i * 3 < l; i++) {\n        x = s.substr(i * 3, 3);\n        if (x.length() == 3) x = x.substr(1) + x[0];\n        output += x;\n    }\n    return output;\n}\n\nstring decode_cyclic(string s) { \n    /*\n    takes as input string encoded with encode_cyclic function. Returns decoded string.\n    */\n    int l = s.length();\n    int num = (l + 2) / 3;\n    string x, output;\n    for (int i = 0; i * 3 < l; i++) {\n        x = s.substr(i * 3, 3);\n        if (x.length() == 3) x = x[2] + x.substr(0, 2); // Rotate one position to the left\n        output += x;\n    }\n    return output;\n}\n\n"}
{"task_id": "CPP/39", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    if (num == 2 || num == 3) return true;\n    if (num % 2 == 0 || num % 3 == 0) return false;\n    for (int i = 5; i * i <= num; i += 6) {\n        if (num % i == 0 || num % (i + 2) == 0)\n            return false;\n    }\n    return true;\n}\n\n// Function to generate the n-th prime Fibonacci number\nint prime_fib(int n) {\n    int count = 0; // Counter for prime Fibonacci numbers found\n    long fib1 = 0, fib2 = 1; // First two Fibonacci numbers\n\n    while (true) {\n        long next_fib = fib1 + fib2;\n        if (is_prime(next_fib)) {\n            count++;\n            if (count == n) return next_fib;\n        }\n        fib1 = fib2;\n        fib2 = next_fib;\n    }\n}\n\n"}
{"task_id": "CPP/40", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool triples_sum_to_zero(vector<int> l) {\n    int n = l.size();\n    \n    // Iterate through each element in the list\n    for (int i = 0; i < n - 2; ++i) {\n        // Iterate through elements after the current one\n        for (int j = i + 1; j < n - 1; ++j) {\n            // Iterate through elements after the second one\n            for (int k = j + 1; k < n; ++k) {\n                // Check if the sum of the three elements is zero\n                if (l[i] + l[j] + l[k] == 0) {\n                    return true;\n                }\n            }\n        }\n    }\n    \n    // Return false if no such triplet is found\n    return false;\n}\n\n"}
{"task_id": "CPP/41", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint car_race_collision(int n) {\n    // Since all cars are moving at the same speed and start far apart,\n    // each car from one direction will inevitably collide with exactly one car\n    // coming from the opposite direction.\n    return n;\n}\n\n"}
{"task_id": "CPP/42", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> incr_list(vector<int> l) {\n    for (int i = 0; i < l.size(); ++i) {\n        l[i] += 1;\n    }\n    return l;\n}\n\n// Function to check the correctness of the incr_list function\nvoid check_function() {\n    vector<int> test1 = {1, 2, 3};\n    vector<int> expected1 = {2, 3, 4};\n    assert(incr_list(test1) == expected1);\n\n    vector<int> test2 = {5, 3, 5, 2, 3, 3, 9, 0, 123};\n    vector<int> expected2 = {6, 4, 6, 3, 4, 4, 10, 1, 124};\n    assert(incr_list(test2) == expected2);\n\n    cout << \"All test cases passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/43", "generation": "#include <iostream>\n#include <vector>\n#include <set>\n\nusing namespace std;\n\nbool pairs_sum_to_zero(vector<int> l) {\n    // Use a set to store seen numbers\n    set<int> seen;\n    \n    for (int num : l) {\n        // Check if the negation of the current number is in the set\n        if (seen.find(-num) != seen.end()) {\n            return true;\n        }\n        // Add the current number to the set\n        seen.insert(num);\n    }\n    \n    // If no such pair is found, return false\n    return false;\n}\n\n"}
{"task_id": "CPP/44", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring change_base(int x, int base) {\n    if (x == 0) return \"0\"; // Handle the case where x is zero\n\n    string result = \"\";\n    while (x > 0) {\n        int remainder = x % base;\n        char digit = '0' + remainder; // Convert the integer to its character representation\n        result = digit + result; // Prepend the digit to the result string\n        x /= base; // Divide x by the base\n    }\n    return result;\n}\n\n"}
{"task_id": "CPP/45", "generation": "#include <iostream>\nusing namespace std;\n\nfloat triangle_area(float a, float h) {\n    return 0.5 * a * h;\n}\n\n"}
{"task_id": "CPP/46", "generation": "#include <stdio.h>\nusing namespace std;\n\nint fib4(int n) {\n    if (n == 0 || n == 1 || n == 3) return 0;\n    if (n == 2) return 2;\n\n    int a = 0, b = 0, c = 2, d = 0, result;\n    \n    for (int i = 4; i <= n; ++i) {\n        result = a + b + c + d;\n        a = b;\n        b = c;\n        c = d;\n        d = result;\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/47", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nfloat median(vector<float> l) {\n    // Sort the vector\n    sort(l.begin(), l.end());\n    \n    int n = l.size();\n    \n    if (n % 2 == 0) {\n        // If even number of elements, return the average of the two middle elements\n        return (l[n / 2 - 1] + l[n / 2]) / 2.0;\n    } else {\n        // If odd number of elements, return the middle element\n        return l[n / 2];\n    }\n}\n\n"}
{"task_id": "CPP/48", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_palindrome(string text) {\n    int left = 0;\n    int right = text.length() - 1;\n\n    while (left < right) {\n        if (text[left] != text[right]) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n\n    return true;\n}\n\n"}
{"task_id": "CPP/49", "generation": "#include <stdio.h>\nusing namespace std;\n\nint modp(int n, int p) {\n    if (n == 0)\n        return 1; // Any number to the power of 0 is 1\n\n    long result = 1;\n    long base = 2;\n\n    while (n > 0) {\n        // If n is odd, multiply the result by the current base\n        if (n % 2 == 1)\n            result = (result * base) % p;\n\n        // Square the base and reduce it modulo p\n        base = (base * base) % p;\n        n /= 2; // Divide n by 2\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/50", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nstring encode_shift(string s) {\n    // returns encoded string by shifting every character by 5 in the alphabet.\n    string out;\n    for (size_t i = 0; i < s.length(); ++i) {\n        if (isalpha(s[i]) && islower(s[i])) {  // Ensure it's a lowercase letter\n            int w = ((int)s[i] - 'a' + 5) % 26 + 'a';\n            out += (char)w;\n        } else {\n            out += s[i];  // Leave non-alphabetic characters unchanged\n        }\n    }\n    return out;\n}\n\nstring decode_shift(string s) {\n    // takes as input string encoded with encode_shift function. Returns decoded string.\n    string out;\n    for (size_t i = 0; i < s.length(); ++i) {\n        if (isalpha(s[i]) && islower(s[i])) {  // Ensure it's a lowercase letter\n            int w = ((int)s[i] - 'a' - 5 + 26) % 26 + 'a';\n            out += (char)w;\n        } else {\n            out += s[i];  // Leave non-alphabetic characters unchanged\n        }\n    }\n    return out;\n}\n\n"}
{"task_id": "CPP/51", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nbool is_vowel(char c) {\n    // Convert character to lowercase for simplicity\n    char lower_c = tolower(c);\n    return lower_c == 'a' || lower_c == 'e' || lower_c == 'i' || lower_c == 'o' || lower_c == 'u';\n}\n\nstring remove_vowels(string text) {\n    string result;\n    for (char c : text) {\n        if (!is_vowel(c)) {\n            result += c;\n        }\n    }\n    return result;\n}\n\n"}
{"task_id": "CPP/52", "generation": "#include <vector>\n#include <iostream>\n\n// Function to check if all elements in the vector are below the threshold\nbool below_threshold(const std::vector<int>& l, int t) {\n    for (int num : l) {\n        if (num >= t) {\n            return false;\n        }\n    }\n    return true;\n}\n\n// Function to test the below_threshold function with provided data points\nvoid check_function() {\n    assert(below_threshold({1, 2, 4, 10}, 100) == true);\n    assert(below_threshold({1, 20, 4, 10}, 5) == false);\n    std::cout << \"All tests passed successfully.\" << std::endl;\n}\n\n"}
{"task_id": "CPP/53", "generation": "#include <iostream>  // Include iostream for input/output operations\n\nusing namespace std;\n\nint add(int x, int y) {\n    return x + y;  // Return the sum of x and y\n}\n\n"}
{"task_id": "CPP/54", "generation": "#include <iostream>\n#include <string>\n#include <set>\n\nusing namespace std;\n\nbool same_chars(string s0, string s1) {\n    // Create a set for each string to store unique characters\n    set<char> chars_s0(s0.begin(), s0.end());\n    set<char> chars_s1(s1.begin(), s1.end());\n\n    // Compare the sets\n    return chars_s0 == chars_s1;\n}\n\n"}
{"task_id": "CPP/55", "generation": "#include <stdio.h>\nusing namespace std;\n\nint fib(int n) {\n    if (n <= 0) return 0;\n    else if (n == 1) return 1;\n    else return fib(n - 1) + fib(n - 2);\n}\n\n"}
{"task_id": "CPP/56", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    int count = 0;\n    \n    for (char c : brackets) {\n        if (c == '<') {\n            count++;\n        } else if (c == '>') {\n            count--;\n            if (count < 0) {\n                return false; // More closing brackets than opening ones\n            }\n        }\n    }\n    \n    return count == 0; // True if all brackets are correctly matched\n}\n\n"}
{"task_id": "CPP/57", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool monotonic(vector<float> l) {\n    if (l.size() <= 1) {\n        return true; // A vector with 0 or 1 element is trivially monotonic.\n    }\n\n    bool increasing = false;\n    bool decreasing = false;\n\n    for (size_t i = 1; i < l.size(); ++i) {\n        if (l[i] > l[i - 1]) {\n            increasing = true;\n        } else if (l[i] < l[i - 1]) {\n            decreasing = true;\n        }\n\n        // If both increasing and decreasing flags are set, the sequence is not monotonic.\n        if (increasing && decreasing) {\n            return false;\n        }\n    }\n\n    return true; // The sequence is either strictly increasing or strictly decreasing.\n}\n\n"}
{"task_id": "CPP/58", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\n\nusing namespace std;\n\nvector<int> common(vector<int> l1, vector<int> l2) {\n    // Create sets from both vectors\n    set<int> s1(l1.begin(), l1.end());\n    set<int> s2(l2.begin(), l2.end());\n\n    // Find the intersection of the two sets\n    set<int> result;\n    set_intersection(s1.begin(), s1.end(), s2.begin(), s2.end(), inserter(result, result.begin()));\n\n    // Convert the set to a vector and sort it\n    vector<int> commonElements(result.begin(), result.end());\n    sort(commonElements.begin(), commonElements.end());\n\n    return commonElements;\n}\n\n"}
{"task_id": "CPP/59", "generation": "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\nint largest_prime_factor(int n) {\n    // Remove all factors of 2\n    while (n % 2 == 0) {\n        n /= 2;\n    }\n\n    // Check for odd factors from 3 to sqrt(n)\n    int factor = 3;\n    while (factor * factor <= n) {\n        while (n % factor == 0) {\n            n /= factor;\n        }\n        factor += 2;\n    }\n\n    // If n is a prime number greater than 2\n    if (n > 2) {\n        return n;\n    } else {\n        return factor - 2; // The last factor found will be the largest prime factor\n    }\n}\n\n"}
{"task_id": "CPP/60", "generation": "#include <iostream>\nusing namespace std;\n\nint sum_to_n(int n) {\n    int sum = 0;\n    for (int i = 1; i <= n; ++i) {\n        sum += i;\n    }\n    return sum;\n}\n\n// Function to test the sum_to_n function with provided data points\nvoid test_sum_to_n() {\n    cout << \"Testing sum_to_n...\" << endl;\n    assert(sum_to_n(30) == 465);\n    assert(sum_to_n(100) == 5050);\n    assert(sum_to_n(5) == 15);\n    assert(sum_to_n(10) == 55);\n    assert(sum_to_n(1) == 1);\n\n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/61", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    int balance = 0;\n    \n    for (char bracket : brackets) {\n        if (bracket == '(') {\n            balance++;\n        } else if (bracket == ')') {\n            balance--;\n        }\n        \n        // If at any point the balance is negative, it means there's a closing bracket without an opening one\n        if (balance < 0) {\n            return false;\n        }\n    }\n    \n    // If the final balance is zero, all brackets are correctly matched\n    return balance == 0;\n}\n\n"}
{"task_id": "CPP/62", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// Function to compute the derivative of a polynomial represented by its coefficients\nvector<float> derivative(vector<float> xs) {\n    // Create a new vector to hold the derivatives, starting from index 1 (ignoring the constant term)\n    vector<float> result;\n    \n    for (size_t i = 1; i < xs.size(); ++i) {\n        // Multiply each coefficient by its corresponding power\n        result.push_back(xs[i] * static_cast<float>(i));\n    }\n    \n    return result;\n}\n\n// Function to print the polynomial coefficients\nvoid printPolynomial(const vector<float>& coeffs) {\n    for (size_t i = 0; i < coeffs.size(); ++i) {\n        cout << coeffs[i];\n        if (i != coeffs.size() - 1) {\n            cout << \" * x^\" << i;\n        }\n        if (i != coeffs.size() - 2) {\n            cout << \" + \";\n        }\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/63", "generation": "#include <iostream>\nusing namespace std;\n\nint fibfib(int n) {\n    // Base cases\n    if (n == 0 || n == 1) return 0;\n    if (n == 2) return 1;\n\n    // Array to store the computed values of FibFib sequence\n    int dp[n + 1];\n    dp[0] = 0; // fibfib(0)\n    dp[1] = 0; // fibfib(1)\n    dp[2] = 1; // fibfib(2)\n\n    // Fill the dp array using the recurrence relation\n    for (int i = 3; i <= n; ++i) {\n        dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3];\n    }\n\n    return dp[n];\n}\n\n"}
{"task_id": "CPP/64", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nint vowels_count(const string& s) {\n    // Define a set of vowels including 'y' which is considered a vowel only if it's at the end\n    const string vowels = \"aeiou\";\n    \n    int count = 0;\n    for (char ch : s) {\n        // Convert character to lowercase to handle case insensitivity\n        char lower_ch = tolower(ch);\n        \n        // Check if the character is a vowel\n        if (vowels.find(lower_ch) != string::npos) {\n            count++;\n        }\n    }\n\n    // Check if the last character is 'y' and increment count if it is\n    if (!s.empty() && s.back() == 'y') {\n        count++;\n    }\n    \n    return count;\n}\n\n"}
{"task_id": "CPP/65", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring circular_shift(int x, int shift) {\n    // Convert the integer to a string\n    string num_str = to_string(x);\n    int num_length = num_str.length();\n    \n    // If shift is greater than or equal to the number of digits, reverse the string\n    if (shift >= num_length) {\n        return string(num_str.rbegin(), num_str.rend());\n    }\n    \n    // Perform circular shift by moving the last 'shift' characters to the front\n    shift %= num_length;  // Handle cases where shift > num_length\n    \n    // Concatenate the shifted part with the non-shifted part\n    string shifted_str = num_str.substr(num_length - shift) + num_str.substr(0, num_length - shift);\n    \n    return shifted_str;\n}\n\n"}
{"task_id": "CPP/66", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint digitSum(const string& s) {\n    int sum = 0;\n    for (char c : s) {\n        if (isupper(c)) { // Check if the character is uppercase\n            sum += static_cast<int>(c); // Add its ASCII value to the sum\n        }\n    }\n    return sum;\n}\n\n// Function to test the digitSum function with provided examples\nvoid checkFunction() {\n    assert(digitSum(\"\") == 0);\n    assert(digitSum(\"abAB\") == 131);\n    assert(digitSum(\"abcCd\") == 67);\n    assert(digitSum(\"helloE\") == 69);\n    assert(digitSum(\"woArBld\") == 131);\n    assert(digitSum(\"aAaaaXa\") == 153);\n\n    cout << \"All test cases passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/67", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nint fruit_distribution(const string& s, int n) {\n    // Extract the number of apples and oranges from the string\n    int apples = 0, oranges = 0;\n    \n    // Use a stringstream to parse the input string\n    stringstream ss(s);\n    string temp;\n    getline(ss, temp, ' '); // Read \"apples\"\n    getline(ss, temp, ' '); // Read \"and\"\n    getline(ss, temp, ' '); // Read the number of apples\n    \n    // Convert the extracted substring to an integer\n    apples = stoi(temp);\n\n    getline(ss, temp, ' '); // Read \"oranges\"\n    getline(ss, temp, ' '); // Read the number of oranges\n    oranges = stoi(temp);\n\n    // Calculate the number of mangoes\n    int mangoes = n - (apples + oranges);\n    \n    return mangoes;\n}\n\n"}
{"task_id": "CPP/68", "generation": "#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> pluck(vector<int> arr) {\n    vector<pair<int, int>> evens;\n    \n    // Filter out even numbers and store them with their indices\n    for (int i = 0; i < arr.size(); ++i) {\n        if (arr[i] % 2 == 0) {\n            evens.push_back({arr[i], i});\n        }\n    }\n    \n    // If there are no even numbers, return an empty vector\n    if (evens.empty()) {\n        return {};\n    }\n    \n    // Sort the list of pairs by value and then by index\n    sort(evens.begin(), evens.end());\n    \n    // Return the smallest even number and its index\n    return {evens[0].first, evens[0].second};\n}\n"}
{"task_id": "CPP/69", "generation": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint search(vector<int> lst) {\n    // Create a frequency map to count occurrences of each integer\n    unordered_map<int, int> freqMap;\n    \n    // Count the frequency of each number in the vector\n    for (int num : lst) {\n        freqMap[num]++;\n    }\n    \n    // Initialize the result as -1\n    int result = -1;\n    \n    // Iterate through the unique numbers and check the condition\n    for (auto& pair : freqMap) {\n        if (pair.first <= pair.second && pair.first > result) {\n            result = pair.first;\n        }\n    }\n    \n    return result;\n}\n\n// Function to test the search function with provided examples\nvoid test() {\n    cout << \"search({4, 1, 2, 2, 3, 1}) == \" << search({4, 1, 2, 2, 3, 1}) << endl; // Should output 2\n    cout << \"search({1, 2, 2, 3, 3, 3, 4, 4, 4}) == \" << search({1, 2, 2, 3, 3, 3, 4, 4, 4}) << endl; // Should output 3\n    cout << \"search({5, 5, 4, 4, 4}) == \" << search({5, 5, 4, 4, 4}) << endl; // Should output -1\n}\n\n"}
{"task_id": "CPP/70", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> strange_sort_list(vector<int> lst) {\n    // Sort the input list in ascending order\n    sort(lst.begin(), lst.end());\n    \n    vector<int> result;\n    int left = 0; // Start from the beginning of the sorted list\n    int right = lst.size() - 1; // Start from the end of the sorted list\n    \n    while (left <= right) {\n        if (left == right) {\n            // If only one element is left, add it to the result\n            result.push_back(lst[left]);\n            break;\n        }\n        \n        // Append the minimum value\n        result.push_back(lst[left++]);\n        // Append the maximum value\n        result.push_back(lst[right--]);\n    }\n    \n    return result;\n}\n\n// Function to check and print the results\nvoid check() {\n    vector<int> lst1 = {1, 2, 3, 4};\n    vector<int> expected1 = {1, 4, 2, 3};\n    assert(strange_sort_list(lst1) == expected1);\n    \n    vector<int> lst2 = {5, 5, 5, 5};\n    vector<int> expected2 = {5, 5, 5, 5};\n    assert(strange_sort_list(lst2) == expected2);\n    \n    vector<int> lst3 = {};\n    vector<int> expected3 = {};\n    assert(strange_sort_list(lst3) == expected3);\n    \n    cout << \"All test cases passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/71", "generation": "#include <stdio.h>\n#include <math.h>\n\nusing namespace std;\n\nfloat triangle_area(float a, float b, float c) {\n    // Check if the sides form a valid triangle\n    if (a + b <= c || a + c <= b || b + c <= a) {\n        return -1;\n    }\n\n    // Calculate the semi-perimeter\n    float s = (a + b + c) / 2.0;\n\n    // Calculate the area using Heron's formula\n    float area = sqrt(s * (s - a) * (s - b) * (s - c));\n\n    // Round the result to 2 decimal points\n    return round(area * 100) / 100;\n}\n\n"}
{"task_id": "CPP/72", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool will_it_fly(vector<int> q, int w) {\n    // Check if the sum of elements is within the weight limit\n    int sum = 0;\n    for (int num : q) {\n        sum += num;\n    }\n    if (sum > w) return false;\n\n    // Check if the vector is a palindrome\n    for (size_t i = 0; i < q.size() / 2; ++i) {\n        if (q[i] != q[q.size() - 1 - i]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\n// Function to test the will_it_fly function with provided examples\nvoid check() {\n    cout << boolalpha; // Print bools as true/false instead of 1/0\n    cout << \"will_it_fly({1, 2}, 5): \" << will_it_fly({1, 2}, 5) << endl;\n    cout << \"will_it_fly({3, 2, 3}, 1): \" << will_it_fly({3, 2, 3}, 1) << endl;\n    cout << \"will_it_fly({3, 2, 3}, 9): \" << will_it_fly({3, 2, 3}, 9) << endl;\n    cout << \"will_it_fly({3}, 5): \" << will_it_fly({3}, 5) << endl;\n}\n\n"}
{"task_id": "CPP/73", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint smallest_change(vector<int> arr) {\n    int n = arr.size();\n    int left = 0;\n    int right = n - 1;\n    int changes = 0;\n\n    while (left < right) {\n        if (arr[left] != arr[right]) {\n            changes++;\n        }\n        left++;\n        right--;\n    }\n\n    return changes;\n}\n\n"}
{"task_id": "CPP/74", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to calculate the total number of characters in a vector of strings\nint total_chars(const vector<string>& vec) {\n    int sum = 0;\n    for (const auto& str : vec) {\n        sum += str.length();\n    }\n    return sum;\n}\n\nvector<string> total_match(vector<string> lst1, vector<string> lst2) {\n    // Calculate the total number of characters in both vectors\n    int chars_lst1 = total_chars(lst1);\n    int chars_lst2 = total_chars(lst2);\n\n    // Compare and return the appropriate vector\n    if (chars_lst1 < chars_lst2) {\n        return lst1;\n    } else if (chars_lst2 < chars_lst1) {\n        return lst2;\n    } else {\n        return lst1;  // Return the first vector if both have the same number of characters\n    }\n}\n\n// Function to test the total_match function with provided examples\nvoid test_total_match() {\n    cout << \"Test 1: \";\n    vector<string> result = total_match({}, {});\n    for (const auto& str : result) {\n        cout << str << \" \";\n    }\n    cout << endl;\n\n    cout << \"Test 2: \";\n    result = total_match({\"hi\", \"admin\"}, {\"hI\", \"Hi\"});\n    for (const auto& str : result) {\n        cout << str << \" \";\n    }\n    cout << endl;\n\n    cout << \"Test 3: \";\n    result = total_match({\"hi\", \"admin\"}, {\"hi\", \"hi\", \"admin\", \"project\"});\n    for (const auto& str : result) {\n        cout << str << \" \";\n    }\n    cout << endl;\n\n    cout << \"Test 4: \";\n    result = total_match({\"hi\", \"admin\"}, {\"hI\", \"hi\", \"hi\"});\n    for (const auto& str : result) {\n        cout << str << \" \";\n    }\n    cout << endl;\n\n    cout << \"Test 5: \";\n    result = total_match({\"4\"}, {\"1\", \"2\", \"3\", \"4\", \"5\"});\n    for (const auto& str : result) {\n        cout << str << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/75", "generation": "#include <iostream>\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    if (n == 2 || n == 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    for (int i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0)\n            return false;\n    }\n    return true;\n}\n\n// Function to check if the given number is a product of exactly three prime numbers\nbool is_multiply_prime(int a) {\n    // Generate all primes less than 100\n    int primes[] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97};\n    int num_primes = sizeof(primes) / sizeof(primes[0]);\n\n    // Try all combinations of three primes\n    for (int i = 0; i < num_primes; ++i) {\n        for (int j = i; j < num_primes; ++j) {\n            for (int k = j; k < num_primes; ++k) {\n                if (primes[i] * primes[j] * primes[k] == a)\n                    return true;\n            }\n        }\n    }\n\n    return false;\n}\n\n// Function to test the is_multiply_prime function\nvoid test() {\n    cout << \"Testing is_multiply_prime...\" << endl;\n    assert(is_multiply_prime(30) == true); // 2 * 3 * 5 = 30\n    assert(is_multiply_prime(60) == false); // Not a product of exactly three primes\n    assert(is_multiply_prime(105) == true); // 3 * 5 * 7 = 105\n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/76", "generation": "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\nbool is_simple_power(int x, int n) {\n    if (n == 1) {\n        return x == 1; // Special case: 1^any_number = 1\n    }\n    \n    double log_result = log(x) / log(n);\n    return floor(log_result) == log_result;\n}\n\n"}
{"task_id": "CPP/77", "generation": "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\nbool iscube(int a) {\n    // Calculate the cube root of the absolute value of 'a'\n    double cube_root = cbrt(abs(a));\n    \n    // Round the cube root to the nearest integer\n    int rounded_cube_root = round(cube_root);\n    \n    // Check if the cube of the rounded cube root equals the original number\n    return pow(rounded_cube_root, 3) == a;\n}\n\n"}
{"task_id": "CPP/78", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nint hex_key(string num) {\n    // Define a set of prime hexadecimal digits\n    const string primes = \"2357BD\";\n    \n    int count = 0;\n    \n    // Iterate through each character in the input string\n    for (char c : num) {\n        if (primes.find(c) != string::npos) {\n            ++count;  // Increment count if the digit is prime\n        }\n    }\n    \n    return count;\n}\n\n"}
{"task_id": "CPP/79", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\n// Function to convert decimal to binary\nstring decimal_to_binary(int decimal) {\n    if (decimal == 0) {\n        return \"db0db\";\n    }\n\n    string binary = \"\";\n    while (decimal > 0) {\n        int remainder = decimal % 2;\n        binary = to_string(remainder) + binary;\n        decimal /= 2;\n    }\n    \n    // Add the prefix and suffix\n    return \"db\" + binary + \"db\";\n}\n\n// Function to check the correctness of the conversion\nvoid check_conversion(int decimal, const string& expected) {\n    string result = decimal_to_binary(decimal);\n    cout << \"decimal: \" << decimal << \", expected: \" << expected << \", got: \" << result << endl;\n    if (result == expected) {\n        cout << \"Test passed.\" << endl;\n    } else {\n        cout << \"Test failed.\" << endl;\n    }\n}\n\n"}
{"task_id": "CPP/80", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_happy(string s) {\n    // Check if the string length is less than 3\n    if (s.length() < 3) return false;\n    \n    // Iterate through the string, checking every set of three consecutive characters\n    for (size_t i = 0; i <= s.length() - 3; ++i) {\n        // Check if any two out of the three consecutive characters are the same\n        if (s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]) {\n            return false;\n        }\n    }\n    \n    // If no three consecutive characters are the same, the string is happy\n    return true;\n}\n\n"}
{"task_id": "CPP/81", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\n// Function to convert GPA to letter grade\nstring gpa_to_letter(float gpa) {\n    if (gpa >= 4.0f) return \"A+\";\n    else if (gpa > 3.7f) return \"A\";\n    else if (gpa > 3.3f) return \"A-\";\n    else if (gpa > 3.0f) return \"B+\";\n    else if (gpa > 2.7f) return \"B\";\n    else if (gpa > 2.3f) return \"B-\";\n    else if (gpa > 2.0f) return \"C+\";\n    else if (gpa > 1.7f) return \"C\";\n    else if (gpa > 1.3f) return \"C-\";\n    else if (gpa > 1.0f) return \"D+\";\n    else if (gpa > 0.7f) return \"D\";\n    else if (gpa > 0.0f) return \"D-\";\n    else return \"E\";\n}\n\n// Function to convert vector of GPAs to vector of letter grades\nvector<string> numerical_letter_grade(vector<float> grades) {\n    vector<string> letter_grades;\n    for (float gpa : grades) {\n        letter_grades.push_back(gpa_to_letter(gpa));\n    }\n    return letter_grades;\n}\n\n// Function to check the correctness of the function\nvoid check() {\n    vector<float> test_grades = {4.0f, 3.0f, 1.7f, 2.0f, 3.5f};\n    vector<string> expected = {\"A+\", \"B\", \"C-\", \"C\", \"A-\"};\n    vector<string> result = numerical_letter_grade(test_grades);\n    \n    if (result == expected) {\n        cout << \"Test passed!\" << endl;\n    } else {\n        cout << \"Test failed. Expected: \";\n        for (const auto& grade : expected) {\n            cout << grade << \" \";\n        }\n        cout << \"\\nGot: \";\n        for (const auto& grade : result) {\n            cout << grade << \" \";\n        }\n        cout << endl;\n    }\n}\n\n"}
{"task_id": "CPP/82", "generation": "#include <iostream>\n#include <string>\n\n// Function to check if a number is prime\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    if (n == 2 || n == 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n\n    for (int i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0)\n            return false;\n    }\n    return true;\n}\n\n// Function to check if the length of a string is prime\nbool prime_length(string str) {\n    int len = str.length();\n    return is_prime(len);\n}\n\n"}
{"task_id": "CPP/83", "generation": "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\nint starts_one_ends(int n) {\n    if (n == 1) {\n        return 1;  // Only one 1-digit number that starts and ends with 1\n    }\n\n    // Calculate the count of numbers starting or ending with 1\n    int total_count = (9 * pow(10, n - 2)) + (8 * pow(10, n - 2));\n\n    return total_count;\n}\n\n"}
{"task_id": "CPP/84", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring solve(int N) {\n    int sum = 0;\n    \n    // Calculate the sum of digits\n    while (N > 0) {\n        sum += N % 10;  // Add the last digit to the sum\n        N /= 10;        // Remove the last digit from N\n    }\n    \n    // Convert the sum to binary string\n    string binarySum = \"\";\n    if (sum == 0) {\n        return \"0\";\n    }\n    \n    while (sum > 0) {\n        binarySum = to_string(sum % 2) + binarySum;  // Prepend the remainder when divided by 2\n        sum /= 2;                                    // Divide the sum by 2\n    }\n    \n    return binarySum;\n}\n\n"}
{"task_id": "CPP/85", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint add(vector<int> lst) {\n    int sum = 0;\n    \n    // Iterate through the vector starting from index 1 (second element)\n    for (size_t i = 1; i < lst.size(); i += 2) {\n        if (lst[i] % 2 == 0) {  // Check if the element at an odd index is even\n            sum += lst[i];\n        }\n    }\n    \n    return sum;\n}\n\n"}
{"task_id": "CPP/86", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nstring anti_shuffle(string s) {\n    // Split the string into words based on spaces\n    size_t start = 0;\n    vector<string> words;\n    while (start < s.length()) {\n        size_t end = s.find(' ', start);\n        if (end == string::npos) {\n            end = s.length();\n        }\n        words.push_back(s.substr(start, end - start));\n        start = end + 1;\n    }\n\n    // Process each word: sort its characters and join them back together\n    for (auto& word : words) {\n        sort(word.begin(), word.end());\n    }\n\n    // Reconstruct the sentence with sorted words\n    string result;\n    for (size_t i = 0; i < words.size(); ++i) {\n        if (!result.empty()) {\n            result += \" \";\n        }\n        result += words[i];\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/87", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to get the row and column indices where x appears\nvector<vector<int>> get_row(vector<vector<int>> lst, int x) {\n    vector<vector<int>> result;\n    \n    // Iterate through each row in the list\n    for (size_t i = 0; i < lst.size(); ++i) {\n        const auto& row = lst[i];\n        \n        // Iterate through each element in the current row\n        for (size_t j = 0; j < row.size(); ++j) {\n            if (row[j] == x) {\n                result.push_back({static_cast<int>(i), static_cast<int>(j)});\n            }\n        }\n    }\n\n    // Sort by rows in ascending order and then by columns in descending order within each row\n    sort(result.begin(), result.end(), [](const vector<int>& a, const vector<int>& b) {\n        if (a[0] == b[0]) return a[1] > b[1]; // Descending order for columns\n        return a[0] < b[0]; // Ascending order for rows\n    });\n\n    return result;\n}\n\n// Function to print the result for verification\nvoid print_result(const vector<vector<int>>& result) {\n    for (const auto& coord : result) {\n        cout << \"{\" << coord[0] << \", \" << coord[1] << \"} \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/88", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> sort_array(vector<int> array) {\n    // Check if the vector is empty or has only one element\n    if (array.empty() || array.size() == 1) {\n        return array;\n    }\n\n    int first = array.front();\n    int last = array.back();\n\n    // Calculate the sum of the first and last elements\n    int sum = first + last;\n\n    // Determine the sorting order based on the sum being odd or even\n    if (sum % 2 == 0) {\n        // Sort in descending order\n        vector<int> sorted_array(array);\n        sort(sorted_array.rbegin(), sorted_array.rend());\n        return sorted_array;\n    } else {\n        // Sort in ascending order\n        vector<int> sorted_array(array);\n        sort(sorted_array.begin(), sorted_array.end());\n        return sorted_array;\n    }\n}\n\n// Function to test the solution with provided examples\nvoid check() {\n    printf(\"{%s}\\n\", sort_array({}).empty() ? \"[]\" : \"{5, 4, 3, 2, 1}\"); // Example might be incorrect for empty vector\n    printf(\"{%d}\\n\", sort_array({5})[0]); // Should return {5}\n    printf(\"{%s}\\n\", sort_array({2, 4, 3, 0, 1, 5}).begin(), sort_array({2, 4, 3, 0, 1, 5}).end()); // Should return [0, 1, 2, 3, 4, 5]\n    printf(\"{%s}\\n\", sort_array({2, 4, 3, 0, 1, 5, 6}).rbegin(), sort_array({2, 4, 3, 0, 1, 5, 6}).rend()); // Should return [6, 5, 4, 3, 2, 1, 0]\n}\n\n"}
{"task_id": "CPP/89", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\n// Function to rotate a single character by 4 places\nchar rotateChar(char c) {\n    if (c >= 'a' && c <= 'z') {\n        return ((c - 'a' + 4) % 26) + 'a';\n    } else if (c >= 'A' && c <= 'Z') {\n        return ((c - 'A' + 4) % 26) + 'A';\n    }\n    // Non-alphabetic characters are not rotated\n    return c;\n}\n\n// Function to encrypt the string by rotating each character\nstring encrypt(string s) {\n    for (char &c : s) {\n        c = rotateChar(c);\n    }\n    return s;\n}\n\n"}
{"task_id": "CPP/90", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <optional>\n\nusing namespace std;\n\nstd::optional<int> next_smallest(const vector<int>& lst) {\n    if (lst.empty() || lst.size() < 2) {\n        return std::nullopt;\n    }\n\n    // Remove duplicates and sort the unique elements\n    auto it = unique(lst.begin(), lst.end());\n    lst.erase(it, lst.end());\n\n    if (lst.size() < 2) {\n        return std::nullopt;\n    }\n\n    // Sort the vector to find the second smallest element\n    sort(lst.begin(), lst.end());\n\n    // Return the second smallest element\n    return lst[1];\n}\n\n"}
{"task_id": "CPP/91", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nint is_bored(string S) {\n    int boredom_count = 0;\n    \n    // Split the string into sentences using '.', '?' or '!'\n    stringstream ss(S);\n    string sentence;\n    while (getline(ss, sentence, '.')) {\n        if (sentence.find('?') != string::npos) {\n            getline(ss, sentence, '?');\n        }\n        if (sentence.find('!') != string::npos) {\n            getline(ss, sentence, '!');\n        }\n        \n        // Trim leading and trailing whitespace\n        size_t start = sentence.find_first_not_of(\" \\t\");\n        size_t end = sentence.find_last_not_of(\" \\t\");\n        if (start == string::npos || end == string::npos) {\n            continue;\n        }\n        sentence = sentence.substr(start, end - start + 1);\n        \n        // Check if the sentence starts with \"I\"\n        if (!sentence.empty() && sentence[0] == 'I') {\n            boredom_count++;\n        }\n    }\n\n    return boredom_count;\n}\n\n"}
{"task_id": "CPP/92", "generation": "#include <iostream>\nusing namespace std;\n\nbool is_integer(float num) {\n    return floor(num) == num;\n}\n\nbool any_int(float a, float b, float c) {\n    // Check if all numbers are integers\n    if (is_integer(a) && is_integer(b) && is_integer(c)) {\n        // Check if one of the numbers is equal to the sum of the other two\n        return (a == b + c) || (b == a + c) || (c == a + b);\n    } else {\n        return false;\n    }\n}\n\n"}
{"task_id": "CPP/93", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to encode the message\nstring encode(string message) {\n    // Define vowels and their corresponding replacements\n    string vowels = \"aeiouAEIOU\";\n    string vowel_map = \"cgikqwCGIKQW\";\n\n    for (char &c : message) {\n        if (vowels.find(c) != string::npos) {\n            // Replace the vowel with its mapped character\n            c = vowel_map[vowels.find(c)];\n        } else if (isalpha(c)) {\n            // Swap case of the letter\n            c ^= 32; // XOR with 32 to swap case\n        }\n    }\n\n    return message;\n}\n\n"}
{"task_id": "CPP/94", "generation": "#include <iostream>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i <= sqrt(n); ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\nint sum_of_digits(int n) {\n    int sum = 0;\n    while (n > 0) {\n        sum += n % 10;\n        n /= 10;\n    }\n    return sum;\n}\n\nint find_largest_prime_sum(vector<int> lst) {\n    int max_prime = -1;\n    for (int num : lst) {\n        if (is_prime(num) && num > max_prime) {\n            max_prime = num;\n        }\n    }\n\n    if (max_prime == -1) return 0;\n    else return sum_of_digits(max_prime);\n}\n\n"}
{"task_id": "CPP/95", "generation": "#include <iostream>\n#include <string>\n#include <map>\n\nusing namespace std;\n\nbool check_dict_case(map<string, string> dict) {\n    // Check if the dictionary is empty\n    if (dict.empty()) {\n        return false;\n    }\n\n    bool allLower = true;\n    bool allUpper = true;\n\n    for (const auto &pair : dict) {\n        // Check if the key is not in lowercase or uppercase\n        if (!pair.first.empty() && !islower(pair.first[0])) {\n            allLower = false;\n        }\n        if (!pair.first.empty() && !isupper(pair.first[0])) {\n            allUpper = false;\n        }\n\n        // If both conditions fail, return false immediately\n        if (!allLower && !allUpper) {\n            return false;\n        }\n    }\n\n    // Return true if either all keys are lowercase or all keys are uppercase\n    return allLower || allUpper;\n}\n\n"}
{"task_id": "CPP/96", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Helper function to check if a number is prime\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    for (int i = 2; i * i <= num; ++i) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\n// Function to generate a vector of prime numbers less than n\nvector<int> count_up_to(int n) {\n    vector<int> primes;\n    for (int i = 2; i < n; ++i) {\n        if (is_prime(i)) {\n            primes.push_back(i);\n        }\n    }\n    return primes;\n}\n\n// Function to test the count_up_to function\nvoid test_count_up_to() {\n    assert(count_up_to(5) == vector<int>({2, 3}));\n    assert(count_up_to(11) == vector<int>({2, 3, 5, 7}));\n    assert(count_up_to(0).empty());\n    assert(count_up_to(20) == vector<int>({2, 3, 5, 7, 11, 13, 17, 19}));\n    assert(count_up_to(1).empty());\n    assert(count_up_to(18) == vector<int>({2, 3, 5, 7, 11, 13, 17}));\n\n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/97", "generation": "#include <iostream>\nusing namespace std;\n\nint multiply(int a, int b) {\n    // Extract the unit digit of both numbers\n    int unit_digit_a = abs(a % 10);\n    int unit_digit_b = abs(b % 10);\n\n    // Multiply the unit digits and return the result\n    return unit_digit_a * unit_digit_b;\n}\n\n"}
{"task_id": "CPP/98", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint count_upper(const string& s) {\n    int count = 0;\n    for (size_t i = 0; i < s.length(); i += 2) { // Iterate through even indices\n        char c = s[i];\n        if (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n            count++;\n        }\n    }\n    return count;\n}\n\n"}
{"task_id": "CPP/99", "generation": "#include <iostream>\n#include <cmath>\n#include <string>\nusing namespace std;\n\nint closest_integer(string value) {\n    // Convert string to double\n    double num = stod(value);\n    \n    // Determine the two nearest integers\n    int lower_int = static_cast<int>(floor(num));\n    int upper_int = static_cast<int>(ceil(num));\n    \n    // Check which integer is closer or if they are equidistant, round away from zero\n    if (num - lower_int == upper_int - num) {\n        return abs(num) > abs(lower_int) ? upper_int : lower_int;\n    } else {\n        return num - lower_int < 0.5 ? lower_int : upper_int;\n    }\n}\n\n"}
{"task_id": "CPP/100", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> make_a_pile(int n) {\n    vector<int> pile;\n    int current_stones = n;\n\n    for (int i = 0; i < n; ++i) {\n        pile.push_back(current_stones);\n        // Determine the next number of stones\n        if (current_stones % 2 == 0) {\n            current_stones += 2; // Next even number\n        } else {\n            current_stones += 2; // Next odd number\n        }\n    }\n\n    return pile;\n}\n\n// Function to check the correctness of the solution\nvoid check_solution() {\n    vector<int> result1 = make_a_pile(3);\n    assert(result1 == vector<int>({3, 5, 7}));\n\n    vector<int> result2 = make_a_pile(4);\n    assert(result2 == vector<int>({4, 6, 8, 10}));\n\n    vector<int> result3 = make_a_pile(1);\n    assert(result3 == vector<int>({1, 3}));\n\n    cout << \"All test cases passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/101", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nvector<string> words_string(string s) {\n    vector<string> result;\n    stringstream ss(s);\n    string word;\n\n    while (getline(ss, word, ',')) {  // Split by commas first\n        stringstream wordStream(word);  // Create a new stream for the current word\n        while (wordStream >> word) {  // Extract words from the current word\n            result.push_back(word);\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/102", "generation": "#include <iostream>\nusing namespace std;\n\nint choose_num(int x, int y) {\n    // Ensure x is less than or equal to y\n    if (x > y) {\n        return -1;\n    }\n\n    // Start from the end of the range and check for the largest even number\n    for (int i = y; i >= x; --i) {\n        if (i % 2 == 0) {\n            return i;\n        }\n    }\n\n    // If no even number is found, return -1\n    return -1;\n}\n\n// Function to test the choose_num function with some examples\nvoid test() {\n    cout << \"choose_num(12, 15): \" << choose_num(12, 15) << endl; // Should output 14\n    cout << \"choose_num(13, 12): \" << choose_num(13, 12) << endl; // Should output -1\n    cout << \"choose_num(10, 20): \" << choose_num(10, 20) << endl; // Should output 20\n    cout << \"choose_num(21, 25): \" << choose_num(21, 25) << endl; // Should output 24\n}\n\n"}
{"task_id": "CPP/103", "generation": "#include <stdio.h>\n#include <math.h>\n#include <string>\nusing namespace std;\n\nstring rounded_avg(int n, int m) {\n    // Check if n is greater than m\n    if (n > m) {\n        return \"-1\";\n    }\n\n    // Calculate the sum of integers from n to m\n    long long sum = 0;\n    for (int i = n; i <= m; ++i) {\n        sum += i;\n    }\n\n    // Calculate the average and round it down\n    int avg = sum / (m - n + 1);\n\n    // Convert the rounded average to binary string\n    string binary = \"\";\n    if (avg == 0) {\n        binary = \"0\";\n    } else {\n        while (avg > 0) {\n            binary = to_string(avg % 2) + binary;\n            avg /= 2;\n        }\n    }\n\n    return binary;\n}\n\n"}
{"task_id": "CPP/104", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nbool hasEvenDigit(int num) {\n    while (num > 0) {\n        int digit = num % 10;\n        if (digit % 2 == 0) {\n            return true; // Found an even digit\n        }\n        num /= 10;\n    }\n    return false; // No even digits found\n}\n\nvector<int> unique_digits(vector<int> x) {\n    vector<int> result;\n\n    for (int num : x) {\n        if (!hasEvenDigit(num)) {\n            result.push_back(num);\n        }\n    }\n\n    sort(result.begin(), result.end());\n    return result;\n}\n\n"}
{"task_id": "CPP/105", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to convert a digit to its corresponding name\nstring num_to_word(int n) {\n    map<int, string> digit_names = {\n        {1, \"One\"}, {2, \"Two\"}, {3, \"Three\"}, {4, \"Four\"},\n        {5, \"Five\"}, {6, \"Six\"}, {7, \"Seven\"}, {8, \"Eight\"}, {9, \"Nine\"}\n    };\n    return digit_names[n];\n}\n\n// Function to process the vector as per the problem statement\nvector<string> by_length(vector<int> arr) {\n    // Filter out numbers that are not between 1 and 9\n    vector<int> filtered_arr;\n    for (int num : arr) {\n        if (num >= 1 && num <= 9) {\n            filtered_arr.push_back(num);\n        }\n    }\n\n    // Sort the filtered array\n    sort(filtered_arr.begin(), filtered_arr.end());\n\n    // Reverse the sorted array\n    reverse(filtered_arr.begin(), filtered_arr.end());\n\n    // Convert each number to its corresponding name and store in a vector of strings\n    vector<string> result;\n    for (int num : filtered_arr) {\n        result.push_back(num_to_word(num));\n    }\n\n    return result;\n}\n\n// Function to check the correctness of the by_length function\nvoid check() {\n    vector<int> arr1 = {2, 1, 1, 4, 5, 8, 2, 3};\n    vector<string> expected1 = {\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"};\n    assert(by_length(arr1) == expected1);\n\n    vector<int> arr2 = {};\n    vector<string> expected2 = {};\n    assert(by_length(arr2) == expected2);\n\n    vector<int> arr3 = {1, -1, 55};\n    vector<string> expected3 = {\"One\"};\n    assert(by_length(arr3) == expected3);\n\n    printf(\"All test cases passed.\\n\");\n}\n\n"}
{"task_id": "CPP/106", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Function to compute the factorial of a number\nint factorial(int num) {\n    if (num == 0 || num == 1)\n        return 1;\n    int fact = 1;\n    for (int i = 2; i <= num; ++i) {\n        fact *= i;\n    }\n    return fact;\n}\n\n// Function to compute the sum of numbers from 1 to a number\nint sumTo(int num) {\n    return (num * (num + 1)) / 2;\n}\n\nvector<int> f(int n) {\n    vector<int> result(n);\n    \n    for (int i = 0; i < n; ++i) {\n        if ((i + 1) % 2 == 0) { // Check if the index is even\n            result[i] = factorial(i + 1); // Factorial of (i+1)\n        } else { // The index is odd\n            result[i] = sumTo(i + 1); // Sum from 1 to (i+1)\n        }\n    }\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/107", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nbool is_palindrome(int num) {\n    string str = to_string(num);\n    int left = 0;\n    int right = str.length() - 1;\n    \n    while (left < right) {\n        if (str[left] != str[right]) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n    return true;\n}\n\nvector<int> even_odd_palindrome(int n) {\n    vector<int> result(2, 0); // Initialize with two elements for even and odd counts\n    for (int i = 1; i <= n; ++i) {\n        if (is_palindrome(i)) {\n            if (i % 2 == 0) {\n                result[0]++; // Even palindrome count\n            } else {\n                result[1]++; // Odd palindrome count\n            }\n        }\n    }\n    return result;\n}\n\n"}
{"task_id": "CPP/108", "generation": "#include <vector>\n#include <cmath>\n\nint sum_of_digits(int num) {\n    if (num < 0) {\n        num = -num; // Make number positive for digit extraction\n    }\n    int total = 0;\n    while (num > 0) {\n        total += num % 10;\n        num /= 10;\n    }\n    return total;\n}\n\nint count_nums(std::vector<int> n) {\n    int count = 0;\n    for (int num : n) {\n        if (sum_of_digits(num) > 0) {\n            count++;\n        }\n    }\n    return count;\n}\n"}
{"task_id": "CPP/109", "generation": "#include <vector>\nusing namespace std;\n\nbool move_one_ball(vector<int> arr) {\n    int n = arr.size();\n    \n    if (n == 0) {\n        return true;\n    }\n    \n    // Find the index where the array is not sorted\n    bool isSorted = true;\n    for (int i = 1; i < n; ++i) {\n        if (arr[i] < arr[i - 1]) {\n            isSorted = false;\n            break;\n        }\n    }\n\n    // If no such index found, the array is already sorted\n    if (isSorted) {\n        return true;\n    }\n\n    // Check if we can sort by one right shift\n    for (int i = 0; i < n; ++i) {\n        if (arr[i] > arr[(i + 1) % n]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n"}
{"task_id": "CPP/110", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring exchange(vector<int> lst1, vector<int> lst2) {\n    // Check if there is at least one even number in lst2\n    bool has_even_in_lst2 = false;\n    for (int num : lst2) {\n        if (num % 2 == 0) {\n            has_even_in_lst2 = true;\n            break;\n        }\n    }\n\n    // If no even numbers exist in lst2, return \"NO\"\n    if (!has_even_in_lst2) {\n        return \"NO\";\n    }\n\n    // Count the number of odd numbers in lst1\n    int odd_count = 0;\n    for (int num : lst1) {\n        if (num % 2 != 0) {\n            ++odd_count;\n        }\n    }\n\n    // Check if there are enough even numbers in lst2 to replace all odd numbers in lst1\n    int even_count_in_lst2 = 0;\n    for (int num : lst2) {\n        if (num % 2 == 0) {\n            ++even_count_in_lst2;\n        }\n    }\n\n    // If the number of odd numbers in lst1 is less than or equal to the number of even numbers in lst2, return \"YES\"\n    if (odd_count <= even_count_in_lst2) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n\n"}
{"task_id": "CPP/111", "generation": "#include <iostream>\n#include <string>\n#include <map>\n#include <vector>\nusing namespace std;\n\nmap<char, int> histogram(string test) {\n    map<char, int> charCount;\n    \n    // Count occurrences of each character\n    for (char c : test) {\n        if (c != ' ') {  // Ignore spaces\n            charCount[c]++;\n        }\n    }\n\n    // Find the maximum count\n    int maxCount = 0;\n    for (const auto& pair : charCount) {\n        if (pair.second > maxCount) {\n            maxCount = pair.second;\n        }\n    }\n\n    // Collect characters with the highest frequency\n    map<char, int> result;\n    for (const auto& pair : charCount) {\n        if (pair.second == maxCount) {\n            result.insert(pair);\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/112", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to check if a string is a palindrome\nbool is_palindrome(const string& str) {\n    int left = 0;\n    int right = str.size() - 1;\n    while (left < right) {\n        if (str[left] != str[right]) {\n            return false;\n        }\n        ++left;\n        --right;\n    }\n    return true;\n}\n\n// Function to reverse delete characters\nvector<string> reverse_delete(string s, string c) {\n    // Remove all characters in s that are present in c\n    for (char ch : c) {\n        s.erase(remove(s.begin(), s.end(), ch), s.end());\n    }\n\n    // Check if the resulting string is a palindrome\n    bool result = is_palindrome(s);\n\n    // Return the result as a vector containing the modified string and the boolean\n    return {s, (result ? \"True\" : \"False\")};\n}\n\n"}
{"task_id": "CPP/113", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<string> odd_count(vector<string> lst) {\n    vector<string> result;\n    \n    for (const auto& str : lst) {\n        int count = 0;\n        \n        // Count the number of odd digits in the string\n        for (char c : str) {\n            if ((c - '0') % 2 != 0) {\n                count++;\n            }\n        }\n\n        // Construct the result string\n        string output = \"the number of odd elements \";\n        output += to_string(count);\n        output += \"n the str\";\n        output += to_string(count);\n        output += \"ng \";\n        output += to_string(count);\n        output += \" of the \";\n        output += to_string(count);\n        output += \"nput.\";\n        \n        result.push_back(output);\n    }\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/114", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nlong long minSubArraySum(vector<long long> nums) {\n    if (nums.empty()) return 0; // Handle empty vector case\n\n    long long current_min = nums[0];\n    long long global_min = nums[0];\n\n    for (size_t i = 1; i < nums.size(); ++i) {\n        // Update the current minimum sum ending at position i\n        current_min = min(nums[i], current_min + nums[i]);\n        \n        // Update the global minimum sum found so far\n        if (current_min < global_min) {\n            global_min = current_min;\n        }\n    }\n\n    return global_min;\n}\n\n"}
{"task_id": "CPP/115", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint max_fill(vector<vector<int>> grid, int capacity) {\n    int total_lowerings = 0;\n    \n    // Iterate through each well (row)\n    for (const auto& row : grid) {\n        int water_units = 0;\n        \n        // Count the number of units of water in the current well\n        for (int unit : row) {\n            if (unit == 1) {\n                ++water_units;\n            }\n        }\n        \n        // Calculate the number of times the bucket needs to be lowered\n        total_lowerings += (water_units + capacity - 1) / capacity;\n    }\n    \n    return total_lowerings;\n}\n\n"}
{"task_id": "CPP/116", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\n// Function to count the number of ones in the binary representation of a number\nint count_ones(int n) {\n    int count = 0;\n    while (n > 0) {\n        count += n & 1; // Check if the least significant bit is set\n        n >>= 1;       // Right shift to check the next bit\n    }\n    return count;\n}\n\n// Comparator function for sorting based on number of ones and decimal value\nbool compare(int a, int b) {\n    int count_a = count_ones(a);\n    int count_b = count_ones(b);\n\n    if (count_a == count_b) {\n        return a < b; // Sort by decimal value if the number of ones is the same\n    }\n    return count_a < count_b; // Otherwise, sort by the number of ones\n}\n\n// Function to sort the array based on the given criteria\nstd::vector<int> sort_array(std::vector<int> arr) {\n    std::sort(arr.begin(), arr.end(), compare);\n    return arr;\n}\n\n"}
{"task_id": "CPP/117", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nbool is_consonant(char c) {\n    return tolower(c) >= 'a' && tolower(c) <= 'z' && !(tolower(c) == 'a' || tolower(c) == 'e' || tolower(c) == 'i' || tolower(c) == 'o' || tolower(c) == 'u');\n}\n\nvector<string> select_words(const string& s, int n) {\n    vector<string> words;\n    vector<string> result;\n\n    // Split the input string into words\n    size_t start = 0;\n    for (size_t i = 0; i <= s.size(); ++i) {\n        if (i == s.size() || isspace(s[i])) {\n            if (start < i) {\n                words.push_back(s.substr(start, i - start));\n                start = i + 1;\n            }\n        }\n    }\n\n    // Check each word for the exact number of consonants\n    for (const string& word : words) {\n        int count = 0;\n        for (char c : word) {\n            if (is_consonant(c)) {\n                ++count;\n            }\n        }\n        if (count == n) {\n            result.push_back(word);\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/118", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nbool isVowel(char c) {\n    return \"aeiouAEIOU\".find(c) != string::npos;\n}\n\nstring get_closest_vowel(string word) {\n    int n = word.length();\n    \n    for (int i = n - 2; i >= 1; --i) {\n        if (isVowel(word[i]) && isalpha(word[i-1]) && !isalpha(word[i+1])) {\n            return string(1, word[i]);\n        }\n    }\n    \n    return \"\";\n}\n\n"}
{"task_id": "CPP/119", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nbool is_balanced(const string& s) {\n    int balance = 0;\n    for (char c : s) {\n        if (c == '(') {\n            balance += 1;\n        } else {\n            balance -= 1;\n        }\n        if (balance < 0) {\n            return false;\n        }\n    }\n    return balance == 0;\n}\n\nstring match_parens(vector<string> lst) {\n    // Check both possible concatenations\n    if (is_balanced(lst[0] + lst[1]) || is_balanced(lst[1] + lst[0])) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\n\n"}
{"task_id": "CPP/120", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> maximum(vector<int> arr, int k) {\n    // Sort the array in descending order\n    sort(arr.begin(), arr.end(), greater<int>());\n    \n    // If k is 0 or negative, return an empty vector\n    if (k <= 0 || k > arr.size()) {\n        return {};\n    }\n    \n    // Slice the first k elements from the sorted array\n    vector<int> result(arr.begin(), arr.begin() + k);\n    \n    // Sort the resulting vector in ascending order as required\n    sort(result.begin(), result.end());\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/121", "generation": "#include <vector>\nusing namespace std;\n\nint solution(vector<int> lst) {\n    int sum = 0;\n    for (size_t i = 0; i < lst.size(); ++i) {\n        // Check if the index is even and the element at that position is odd\n        if (i % 2 == 0 && lst[i] % 2 != 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n\n// Function to test the solution with provided examples\nvoid check_solution() {\n    assert(solution({5, 8, 7, 1}) == 12);\n    assert(solution({3, 3, 3, 3, 3}) == 9);\n    assert(solution({30, 13, 24, 321}) == 0);\n}\n\n"}
{"task_id": "CPP/122", "generation": "#include <vector>\n#include <algorithm>\n\nint add_elements(std::vector<int> arr, int k) {\n    // Filter the first k elements of the array for those with at most two digits\n    std::vector<int> filtered_elements;\n    for (int i = 0; i < k; ++i) {\n        if (arr[i] >= 0 && arr[i] <= 99) {\n            filtered_elements.push_back(arr[i]);\n        }\n    }\n\n    // Calculate the sum of these filtered elements\n    int sum = 0;\n    for (int num : filtered_elements) {\n        sum += num;\n    }\n\n    return sum;\n}\n"}
{"task_id": "CPP/123", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n// Function to generate and return the odd numbers in the Collatz sequence of n.\nvector<int> get_odd_collatz(int n) {\n    vector<int> result;\n    \n    // Generate the Collatz sequence until it reaches 1\n    while (n != 1) {\n        if (n % 2 == 0) {\n            n /= 2;  // If n is even, divide by 2\n        } else {\n            result.push_back(n);  // If n is odd, add to the result vector\n            n = 3 * n + 1;  // Apply the Collatz transformation\n        }\n    }\n    \n    // Add the final number (which is 1) to the result vector\n    result.push_back(1);\n    \n    // Sort the result vector in increasing order\n    sort(result.begin(), result.end());\n    \n    return result;\n}\n\n// Function to test the get_odd_collatz function with some examples.\nvoid test_get_odd_collatz() {\n    cout << \"Testing get_odd_collatz...\" << endl;\n    assert(get_odd_collatz(5) == vector<int>({1, 5}));\n    assert(get_odd_collatz(7) == vector<int>({1, 7, 11, 22}));\n    assert(get_odd_collatz(1) == vector<int>({1}));\n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/124", "generation": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nbool isLeapYear(int year) {\n    return (year % 4 == 0 && (year % 100 != 0 || year % 400 == 0));\n}\n\nint getDaysInMonth(int month, int year) {\n    if (month == 2) {\n        return isLeapYear(year) ? 29 : 28;\n    } else if (month == 4 || month == 6 || month == 9 || month == 11) {\n        return 30;\n    } else {\n        return 31;\n    }\n}\n\nbool valid_date(string date) {\n    // Check the format\n    size_t pos = date.find(\"-\");\n    if (pos == string::npos || pos != 2 || date.length() != 10) {\n        return false;\n    }\n\n    int month, day, year;\n    try {\n        month = std::stoi(date.substr(0, 2));\n        day = std::stoi(date.substr(3, 2));\n        year = std::stoi(date.substr(6, 4));\n    } catch (const std::invalid_argument& ia) {\n        return false; // Invalid conversion to integer\n    }\n\n    // Check if month and year are valid\n    if (month < 1 || month > 12 || year < 1) {\n        return false;\n    }\n\n    // Check the number of days in the given month\n    int max_days = getDaysInMonth(month, year);\n    if (day < 1 || day > max_days) {\n        return false;\n    }\n\n    return true;\n}\n\n"}
{"task_id": "CPP/125", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to count lowercase letters with odd ASCII values\nint count_odd_letters(const string& txt) {\n    int count = 0;\n    for (char c : txt) {\n        if ('a' <= c && c <= 'z' && (c - 'a') % 2 != 0) {\n            ++count;\n        }\n    }\n    return count;\n}\n\n// Function to split the string on whitespace\nvector<string> split_on_whitespace(const string& txt) {\n    size_t start = 0, end;\n    vector<string> words;\n\n    while ((end = txt.find(' ', start)) != string::npos) {\n        words.push_back(txt.substr(start, end - start));\n        start = end + 1;\n    }\n\n    // Add the last word\n    if (start < txt.length()) {\n        words.push_back(txt.substr(start));\n    }\n\n    return words;\n}\n\n// Function to split the string on commas\nvector<string> split_on_commas(const string& txt) {\n    size_t start = 0, end;\n    vector<string> words;\n\n    while ((end = txt.find(',', start)) != string::npos) {\n        words.push_back(txt.substr(start, end - start));\n        start = end + 1;\n    }\n\n    // Add the last word\n    if (start < txt.length()) {\n        words.push_back(txt.substr(start));\n    }\n\n    return words;\n}\n\n// Main function to split words based on given conditions\nvector<string> split_words(const string& txt) {\n    // Check for whitespace and split if present\n    size_t pos = txt.find(' ');\n    if (pos != string::npos) {\n        return split_on_whitespace(txt);\n    }\n    \n    // Check for commas and split if present\n    pos = txt.find(',');\n    if (pos != string::npos) {\n        return split_on_commas(txt);\n    }\n    \n    // Count the number of lowercase letters with odd ASCII values\n    int count = count_odd_letters(txt);\n\n    // Return the result as a vector containing either the list of words or the count\n    return count > 0 ? vector<string>{to_string(count)} : vector<string>{};\n}\n\n"}
{"task_id": "CPP/126", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nbool is_sorted(vector<int> lst) {\n    // Check if the list is already sorted or not\n    bool sorted = is_sorted(lst.begin(), lst.end());\n    \n    // If not sorted, return false immediately\n    if (!sorted) return false;\n    \n    // Count occurrences of each number in the vector\n    for (int i = 0; i < lst.size(); ++i) {\n        int count = 1;\n        while (i + 1 < lst.size() && lst[i] == lst[i + 1]) {\n            count++;\n            i++;\n        }\n        // If any number appears more than twice, return false\n        if (count > 2) return false;\n    }\n    \n    // If both conditions are met, return true\n    return true;\n}\n\n"}
{"task_id": "CPP/127", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\nstring intersection(vector<int> interval1, vector<int> interval2) {\n    int start_max = max(interval1[0], interval2[0]);\n    int end_min = min(interval1[1], interval2[1]);\n\n    if (start_max > end_min) {\n        return \"NO\";\n    }\n\n    int length = end_min - start_max + 1;\n    \n    if (is_prime(length)) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n\n"}
{"task_id": "CPP/128", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint prod_signs(vector<int> arr) {\n    if (arr.empty()) {\n        return -32768;\n    }\n\n    int sign_product = 1;\n    int magnitude_sum = 0;\n\n    for (int num : arr) {\n        // Calculate the product of signs\n        if (num < 0) {\n            sign_product *= -1;\n        } else if (num == 0) {\n            sign_product = 0; // If any number is zero, the product will be zero\n            break;\n        }\n\n        // Calculate the sum of magnitudes\n        magnitude_sum += abs(num);\n    }\n\n    return sign_product * magnitude_sum;\n}\n\n// Function to test the prod_signs function with provided examples\nvoid check() {\n    cout << \"Checking examples:\" << endl;\n    assert(prod_signs({1, 2, 2, -4}) == -9); // (-1) * (1 + 2 + 2 + 4) = -9\n    assert(prod_signs({0, 1}) == 0);         // 0 * (abs(0) + abs(1)) = 0\n    assert(prod_signs({}) == -32768);        // Empty vector case\n\n    cout << \"All checks passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/129", "generation": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nbool isValid(int x, int y, int n) {\n    return 0 <= x && x < n && 0 <= y && y < n;\n}\n\nvector<int> minPath(vector<vector<int>> grid, int k) {\n    int n = grid.size();\n    vector<pair<int, pair<int, int>>> directions = {{0, {1, 0}}, {1, {0, 1}}, {-1, {0, -1}}, {0, {-1, 0}}};\n    \n    queue<vector<int>> q;\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            q.push({grid[i][j], i, j});\n        }\n    }\n\n    while (!q.empty()) {\n        if (k == 1) return {q.front()[0]};\n\n        int size = q.size();\n        while (size--) {\n            auto path = q.front(); q.pop();\n            int val = path[0];\n            int x = path[1], y = path[2];\n\n            for (auto& dir : directions) {\n                int nx = x + dir.second.first, ny = y + dir.second.second;\n                if (isValid(nx, ny, n)) {\n                    q.push({val * 10 + grid[nx][ny], nx, ny});\n                }\n            }\n        }\n        --k;\n    }\n\n    return {};\n}\n\n"}
{"task_id": "CPP/130", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> tri(int n) {\n    if (n == 0) {\n        return {1};\n    } else if (n == 1) {\n        return {3, 2};\n    }\n\n    vector<int> sequence = {1, 3, 2};\n\n    for (int i = 3; i <= n; ++i) {\n        int next_value;\n        if (i % 2 == 0) {\n            next_value = 1 + (i / 2);\n        } else {\n            next_value = sequence[i - 1] + sequence[i - 2] + sequence[i + 1];\n        }\n        sequence.push_back(next_value);\n    }\n\n    return vector<int>(sequence.begin(), sequence.begin() + n + 1);\n}\n\n"}
{"task_id": "CPP/131", "generation": "#include <iostream>\nusing namespace std;\n\nint digits(int n) {\n    int product = 1;\n    bool hasOddDigit = false;\n\n    while (n > 0) {\n        int digit = n % 10; // Get the last digit of n\n        if (digit % 2 != 0) { // Check if the digit is odd\n            product *= digit; // Multiply it to the product\n            hasOddDigit = true;\n        }\n        n /= 10; // Remove the last digit from n\n    }\n\n    return hasOddDigit ? product : 0;\n}\n\n"}
{"task_id": "CPP/132", "generation": "#include <iostream>\n#include <string>\n\nbool is_nested(const std::string& str) {\n    int balance = 0;\n    bool has_nested = false;\n\n    for (char ch : str) {\n        if (ch == '[') {\n            balance++;\n            // Check for nested brackets\n            if (balance > 1) {\n                has_nested = true;\n            }\n        } else if (ch == ']') {\n            balance--;\n            if (balance < 0) {\n                return false; // Unbalanced brackets\n            }\n        }\n    }\n\n    // Ensure all brackets are balanced and there is at least one nested bracket\n    return balance == 0 && has_nested;\n}\n\n"}
{"task_id": "CPP/133", "generation": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nint sum_squares(vector<float> lst) {\n    int sum = 0;\n    \n    for (float num : lst) {\n        // Round up to the nearest integer\n        float ceil_num = ceil(num);\n        \n        // Add the square of the rounded number to the sum\n        sum += static_cast<int>(ceil_num * ceil_num);\n    }\n    \n    return sum;\n}\n\n"}
{"task_id": "CPP/134", "generation": "#include <iostream>\n#include <string>\n#include <cctype>  // For isalpha and isalnum functions\n\nusing namespace std;\n\nbool check_if_last_char_is_a_letter(string txt) {\n    // Check if the string is empty\n    if (txt.empty()) {\n        return false;\n    }\n    \n    // Get the last character of the string\n    char last_char = txt.back();\n    \n    // Check if the last character is an alphabetical character and not part of a word\n    if (isalpha(last_char) && \n        (txt.size() == 1 || !isalnum(txt[txt.size() - 2]))) {\n        return true;\n    } else {\n        return false;\n    }\n}\n\n// Function to test the check_if_last_char_is_a_letter function\nvoid test_check_if_last_char_is_a_letter() {\n    assert(check_if_last_char_is_a_letter(\"apple pie\") == false);\n    assert(check_if_last_char_is_a_letter(\"apple pi e\") == true);\n    assert(check_if_last_char_is_a_letter(\"apple pi e \") == false);\n    assert(check_if_last_char_is_a_letter(\"\") == false);\n    \n    cout << \"All tests passed.\" << endl;\n}\n\n"}
{"task_id": "CPP/135", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint can_arrange(vector<int> arr) {\n    int n = arr.size();\n    for (int i = 1; i < n; ++i) {\n        if (arr[i] < arr[i - 1]) {\n            return i;\n        }\n    }\n    return -1;\n}\n\n"}
{"task_id": "CPP/136", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> largest_smallest_integers(vector<int> lst) {\n    vector<int> result = {0, 0}; // Initialize with default values\n\n    int max_negative = INT_MIN; // Start with the smallest possible integer\n    int min_positive = INT_MAX; // Start with the largest possible integer\n\n    for (int num : lst) {\n        if (num < 0 && num > max_negative) {\n            max_negative = num;\n        } else if (num > 0 && num < min_positive) {\n            min_positive = num;\n        }\n    }\n\n    result[0] = max_negative; // Assign the largest negative integer\n    result[1] = min_positive; // Assign the smallest positive integer\n\n    return result;\n}\n\n// Function to check the correctness of the solution\nvoid check() {\n    assert(largest_smallest_integers({2, 4, 1, 3, 5, 7}) == vector<int>({0, 1}));\n    assert(largest_smallest_integers({}) == vector<int>({0, 0}));\n    assert(largest_smallest_integers({0}) == vector<int>({0, 0}));\n    assert(largest_smallest_integers({-2, -4, -1, -3, -5, -7}) == vector<int>({-1, 0}));\n    assert(largest_smallest_integers({-2, 4, -1, 3, 5, 7}) == vector<int>({-1, 3}));\n\n    cout << \"All test cases passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/137", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n\n// Function to convert string with comma as decimal separator to float\nfloat str_to_float(const std::string& str) {\n    size_t pos;\n    float value = std::stof(str, &pos);\n    // Check if the entire string was consumed by stof\n    return (str.length() == pos) ? value : -1.0f; // Return -1.0f to indicate invalid conversion\n}\n\n// Function to compare two values and return the larger one or \"None\" if they are equal\nboost::any compare_one(boost::any a, boost::any b) {\n    float val_a = -1.0f;\n    float val_b = -1.0f;\n\n    // Convert strings with comma as decimal separator to floats\n    if (a.type() == typeid(std::string)) {\n        std::string str_a = std::any_cast<std::string>(a);\n        val_a = str_to_float(str_a);\n    } else {\n        val_a = std::any_cast<float>(a);\n    }\n\n    if (b.type() == typeid(std::string)) {\n        std::string str_b = std::any_cast<std::string>(b);\n        val_b = str_to_float(str_b);\n    } else {\n        val_b = std::any_cast<float>(b);\n    }\n\n    // Compare the values\n    if (val_a > val_b) {\n        return a;\n    } else if (val_b > val_a) {\n        return b;\n    } else {\n        return boost::none; // Return \"None\" if they are equal\n    }\n}\n\n"}
{"task_id": "CPP/138", "generation": "#include <iostream>\n#include <vector>\n\nbool is_equal_to_sum_even(int n) {\n    // Since we need exactly 4 positive even numbers and the smallest sum of 4 positive even numbers (2+2+2+2) is 8,\n    // any number less than 8 cannot be expressed as such a sum.\n    if (n < 8) {\n        return false;\n    }\n    // If n is even, it can always be written as the sum of four even numbers because we can use 2 + 2 + (n-4) where (n-4) is also even.\n    return n % 2 == 0;\n}\n\n"}
{"task_id": "CPP/139", "generation": "#include <iostream>\n\n// Function to calculate factorial of a number\nlong long factorial(long long num) {\n    if (num == 0 || num == 1)\n        return 1;\n    else\n        return num * factorial(num - 1);\n}\n\n// Function to calculate Brazilian factorial\nlong long special_factorial(int n) {\n    long long result = 1;\n    for (int i = n; i > 0; --i) {\n        result *= factorial(i);\n    }\n    return result;\n}\n\n"}
{"task_id": "CPP/140", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring fix_spaces(string text) {\n    string result = \"\";\n    int consecutive_spaces_count = 0;\n\n    for (char ch : text) {\n        if (ch == ' ') {\n            consecutive_spaces_count++;\n        } else {\n            if (consecutive_spaces_count > 2) {\n                result += '-';\n                consecutive_spaces_count = 0;\n            } else if (consecutive_spaces_count >= 1) {\n                result.append(consecutive_spaces_count, '_');\n                consecutive_spaces_count = 0;\n            }\n            result += ch;\n        }\n    }\n\n    // Handle trailing spaces\n    if (consecutive_spaces_count > 2) {\n        result += '-';\n    } else if (consecutive_spaces_count >= 1) {\n        result.append(consecutive_spaces_count, '_');\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/141", "generation": "#include <iostream>\n#include <string>\n#include <regex>\n\nusing namespace std;\n\nstring file_name_check(const string& file_name) {\n    // Regular expression pattern for validation\n    const regex pattern(\"^[a-zA-Z][a-zA-Z0-9]{0,2}\\\\.txt|exe|dll$\");\n\n    // Check if the file name matches the pattern\n    if (regex_match(file_name, pattern)) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\n\n"}
{"task_id": "CPP/142", "generation": "#include <vector>\nusing namespace std;\n\nint sum_squares(vector<int> lst) {\n    int total_sum = 0;\n    \n    for (size_t i = 0; i < lst.size(); ++i) {\n        if ((i + 1) % 3 == 0) {\n            // Square the number at index i if it is a multiple of 3\n            total_sum += lst[i] * lst[i];\n        } else if ((i + 1) % 4 == 0) {\n            // Cube the number at index i if it is a multiple of 4 but not a multiple of 3\n            total_sum += lst[i] * lst[i] * lst[i];\n        }\n    }\n    \n    return total_sum;\n}\n"}
{"task_id": "CPP/143", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    if (n == 2 || n == 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    for (int i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0)\n            return false;\n    }\n    return true;\n}\n\n// Function to process the sentence and return words with prime length\nstring words_in_sentence(string sentence) {\n    stringstream ss(sentence);\n    string word;\n    string result = \"\";\n    \n    while (ss >> word) {\n        if (is_prime(word.length())) {\n            if (!result.empty()) result += \" \";\n            result += word;\n        }\n    }\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/144", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\n// Function to simplify two fractions and check if their product is a whole number\nbool simplify(string x, string n) {\n    // Helper function to parse fraction from string\n    auto parse_fraction = [](const string& frac) -> pair<int, int> {\n        size_t slash_pos = frac.find('/');\n        int numerator = stoi(frac.substr(0, slash_pos));\n        int denominator = stoi(frac.substr(slash_pos + 1));\n        return {numerator, denominator};\n    };\n\n    // Parse the fractions\n    auto [num_x, den_x] = parse_fraction(x);\n    auto [num_n, den_n] = parse_fraction(n);\n\n    // Calculate the product of the numerators and denominators\n    int numerator_product = num_x * num_n;\n    int denominator_product = den_x * den_n;\n\n    // Check if the result is a whole number\n    return (numerator_product % denominator_product) == 0;\n}\n\n"}
{"task_id": "CPP/145", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\n// Helper function to calculate the sum of digits of a number.\nint digit_sum(int n) {\n    if (n < 0) n = -n; // Make n positive for digit extraction\n    int sum = 0;\n    while (n > 0) {\n        sum += n % 10;\n        n /= 10;\n    }\n    return sum;\n}\n\n// Main function to sort the vector based on the sum of digits.\nstd::vector<int> order_by_points(std::vector<int> nums) {\n    // Create a vector of pairs where each pair contains an integer and its original index.\n    std::vector<std::pair<int, int>> nums_with_indices;\n    for (int i = 0; i < nums.size(); ++i) {\n        nums_with_indices.push_back({nums[i], i});\n    }\n\n    // Sort the vector of pairs based on digit sum. If digit sums are equal, maintain original order.\n    std::sort(nums_with_indices.begin(), nums_with_indices.end(),\n              [](const std::pair<int, int>& a, const std::pair<int, int>& b) {\n                  int sum_a = digit_sum(a.first);\n                  int sum_b = digit_sum(b.first);\n                  if (sum_a == sum_b) return a.second < b.second;\n                  return sum_a < sum_b;\n              });\n\n    // Extract the sorted integers from the vector of pairs.\n    std::vector<int> result;\n    for (const auto& p : nums_with_indices) {\n        result.push_back(p.first);\n    }\n\n    return result;\n}\n\n// Function to check the correctness of the order_by_points function.\nvoid check() {\n    assert(order_by_points({1, 11, -1, -11, -12}) == std::vector<int>{-1, -11, 1, -12, 11});\n    assert(order_by_points({}) == std::vector<int>{});\n    std::cout << \"All test cases passed!\" << std::endl;\n}\n\n"}
{"task_id": "CPP/146", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nint specialFilter(vector<int> nums) {\n    int count = 0;\n    \n    for (int num : nums) {\n        // Skip numbers that are not greater than 10\n        if (num <= 10) continue;\n        \n        string strNum = to_string(num);\n        int firstDigit = strNum[0] - '0';\n        int lastDigit = strNum[strNum.length() - 1] - '0';\n        \n        // Check if both the first and last digits are odd\n        if (firstDigit % 2 != 0 && lastDigit % 2 != 0) {\n            count++;\n        }\n    }\n    \n    return count;\n}\n\n"}
{"task_id": "CPP/147", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint get_max_triples(int n) {\n    // Step 1: Generate the vector a\n    vector<int> a(n);\n    for (int i = 1; i <= n; ++i) {\n        a[i - 1] = i * i - i + 1;\n    }\n\n    int count = 0;\n\n    // Step 2 and 3: Iterate through all possible triples (i, j, k)\n    for (int i = 0; i < n - 2; ++i) {\n        for (int j = i + 1; j < n - 1; ++j) {\n            for (int k = j + 1; k < n; ++k) {\n                if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                    count++;\n                }\n            }\n        }\n    }\n\n    return count;\n}\n\n// Function to test the solution\nvoid check() {\n    int result = get_max_triples(5);\n    cout << \"Output: \" << result << endl; // Expected output: 1\n}\n\n"}
{"task_id": "CPP/148", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\n// Define the list of planets in order from closest to farthest from the Sun.\nconst vector<string> planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n\nvector<string> bf(string planet1, string planet2) {\n    // Find the indices of the given planets in the list.\n    auto index1 = find(begin(planets), end(planets), planet1);\n    auto index2 = find(begin(planets), end(planets), planet2);\n\n    // Check if both planets are valid and ensure index1 is less than index2.\n    if (index1 == end(planets) || index2 == end(planets) || index1 >= index2) {\n        return {};  // Return an empty vector if either planet is invalid or indices are not in the correct order.\n    }\n\n    // Calculate the start and end indices for the sublist.\n    int start = min(distance(begin(planets), index1), distance(begin(planets), index2));\n    int end = max(distance(begin(planets), index1) + 1, distance(begin(planets), index2));\n\n    // Return the sublist of planets between the given indices.\n    return vector<string>(begin(planets) + start + 1, begin(planets) + end);\n}\n\n"}
{"task_id": "CPP/149", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nvector<string> vector_sort(const vector<string>& lst) {\n    // Filter out strings with odd lengths\n    vector<string> even_length_strings;\n    for (const string& s : lst) {\n        if (s.length() % 2 == 0) {\n            even_length_strings.push_back(s);\n        }\n    }\n\n    // Sort the list by length, and then alphabetically if lengths are equal\n    sort(even_length_strings.begin(), even_length_strings.end(),\n         [](const string& a, const string& b) {\n             return a.length() < b.length() || (a.length() == b.length() && a < b);\n         });\n\n    return even_length_strings;\n}\n\n"}
{"task_id": "CPP/150", "generation": "#include<stdio.h>\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int n) {\n    if (n <= 1) return false; // Numbers less than or equal to 1 are not prime\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\n// Function that returns x if n is a prime number, otherwise returns y\nint x_or_y(int n, int x, int y) {\n    return is_prime(n) ? x : y;\n}\n\n"}
{"task_id": "CPP/151", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nlong long double_the_difference(vector<float> lst) {\n    long long sum = 0;\n    \n    for (float num : lst) {\n        // Check if the number is positive, an integer, and odd\n        if (num > 0 && floor(num) == num && static_cast<int>(num) % 2 != 0) {\n            sum += pow(num, 2);\n        }\n    }\n    \n    return sum;\n}\n\n"}
{"task_id": "CPP/152", "generation": "#include <iostream>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\n// Function to compare the scores with guesses\nvector<int> compare(vector<int> game, vector<int> guess) {\n    vector<int> result;\n    \n    // Iterate through each match and calculate the absolute difference\n    for (size_t i = 0; i < game.size(); ++i) {\n        int diff = abs(game[i] - guess[i]);\n        result.push_back(diff);\n    }\n    \n    return result;\n}\n\n// Function to print a vector of integers\nvoid printVector(const vector<int>& vec) {\n    for (int num : vec) {\n        cout << num << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/153", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to calculate the strength of an extension\nint calculateStrength(const string& extension) {\n    int cap = 0, sm = 0;\n    for (char c : extension) {\n        if (isupper(c)) cap++;\n        else if (islower(c)) sm++;\n    }\n    return cap - sm;\n}\n\nstring Strongest_Extension(string class_name, vector<string> extensions) {\n    string strongest_extension = \"\";\n    int max_strength = INT_MIN;\n\n    for (const string& extension : extensions) {\n        int strength = calculateStrength(extension);\n        if (strength > max_strength) {\n            max_strength = strength;\n            strongest_extension = extension;\n        }\n    }\n\n    return class_name + \".\" + strongest_extension;\n}\n\n// Example usage\n"}
{"task_id": "CPP/154", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool cycpattern_check(string a, string b) {\n    int n = a.length();\n    for (int i = 0; i < b.length(); ++i) {\n        // Rotate b by i positions\n        string rotated_b = b.substr(i) + b.substr(0, i);\n        // Check if the rotated version of b is a substring of a\n        if (a.find(rotated_b) != string::npos) {\n            return true;\n        }\n    }\n    return false;\n}\n\n"}
{"task_id": "CPP/155", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// Function to count even and odd digits in an integer\nvector<int> even_odd_count(int num) {\n    // Convert the number to a string to easily iterate over each digit\n    string str_num = to_string(abs(num));\n    \n    int even_count = 0;\n    int odd_count = 0;\n    \n    for (char digit : str_num) {\n        if ((digit - '0') % 2 == 0) {\n            even_count++;\n        } else {\n            odd_count++;\n        }\n    }\n    \n    return {even_count, odd_count};\n}\n\n// Function to test the even_odd_count function\nvoid test_even_odd_count() {\n    assert(even_odd_count(-12) == vector<int>({1, 1}));\n    assert(even_odd_count(123) == vector<int>({1, 2}));\n    assert(even_odd_count(0) == vector<int>({1, 0})); // Edge case: single digit 0\n    assert(even_odd_count(-9876543210) == vector<int>({5, 5}));\n    \n    cout << \"All test cases passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/156", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to convert an integer to its Roman numeral equivalent in lowercase\nstring int_to_mini_roman(int number) {\n    // Mapping of integers to their corresponding Roman numerals\n    vector<pair<int, string>> roman_map = {\n        {1000, \"m\"}, {900, \"cm\"}, {500, \"d\"}, {400, \"cd\"},\n        {100, \"c\"}, {90, \"xc\"}, {50, \"l\"}, {40, \"xl\"},\n        {10, \"x\"}, {9, \"ix\"}, {5, \"v\"}, {4, \"iv\"}, {1, \"i\"}\n    };\n\n    string roman_numeral = \"\";\n\n    // Iterate through the map and construct the Roman numeral\n    for (const auto& [value, symbol] : roman_map) {\n        while (number >= value) {\n            roman_numeral += symbol;\n            number -= value;\n        }\n    }\n\n    return roman_numeral;\n}\n\n// Function to check the correctness of the int_to_mini_roman function\nvoid check() {\n    assert(int_to_mini_roman(19) == \"xix\");\n    assert(int_to_mini_roman(152) == \"clii\");\n    assert(int_to_mini_roman(426) == \"cdxxvi\");\n    cout << \"All test cases passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/157", "generation": "#include <stdio.h>\n#include <math.h>\n\nusing namespace std;\n\nbool right_angle_triangle(float a, float b, float c) {\n    // First, sort the sides so that 'c' is the longest side (hypotenuse)\n    if (a > c) swap(a, c);\n    if (b > c) swap(b, c);\n\n    // Check if the Pythagorean theorem holds\n    return fabs(a*a + b*b - c*c) < 1e-6; // Using a small epsilon to account for floating point precision issues\n}\n\n"}
{"task_id": "CPP/158", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to count unique characters in a string\nint count_unique_chars(const string& word) {\n    bool seen[256] = {false};\n    int count = 0;\n    for (char c : word) {\n        if (!seen[c]) {\n            seen[c] = true;\n            count++;\n        }\n    }\n    return count;\n}\n\n// Function to find the word with maximum unique characters\nstring find_max(vector<string> words) {\n    string max_word = \"\";\n    int max_unique_chars = 0;\n\n    for (const auto& word : words) {\n        int unique_chars = count_unique_chars(word);\n        if (unique_chars > max_unique_chars || \n            (unique_chars == max_unique_chars && word < max_word)) {\n            max_word = word;\n            max_unique_chars = unique_chars;\n        }\n    }\n\n    return max_word;\n}\n\n// Function to test the find_max function\nvoid test_find_max() {\n    assert(find_max({\"name\", \"of\", \"string\"}) == \"string\");\n    assert(find_max({\"name\", \"enam\", \"game\"}) == \"enam\");\n    assert(find_max({\"aaaaaaa\", \"bb\", \"cc\"}) == \"aaaaaaa\");\n    cout << \"All test cases passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/159", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nvector<int> eat(int number, int need, int remaining) {\n    // Calculate the maximum number of carrots that can be eaten from the remaining stock\n    int max_to_eat = min(need, remaining);\n    \n    // Update the total number of carrots eaten\n    int total_eaten = number + max_to_eat;\n    \n    // Update the remaining carrots in stock\n    int remaining_after_meal = remaining - max_to_eat;\n    \n    return {total_eaten, remaining_after_meal};\n}\n\n// Function to test the eat function with provided examples\nvoid check() {\n    vector<int> result1 = eat(5, 6, 10);\n    printf(\"eat(5, 6, 10) -> {%d, %d}\\n\", result1[0], result1[1]); // Expected: {11, 4}\n    \n    vector<int> result2 = eat(4, 8, 9);\n    printf(\"eat(4, 8, 9) -> {%d, %d}\\n\", result2[0], result2[1]); // Expected: {12, 1}\n    \n    vector<int> result3 = eat(1, 10, 10);\n    printf(\"eat(1, 10, 10) -> {%d, %d}\\n\", result3[0], result3[1]); // Expected: {11, 0}\n    \n    vector<int> result4 = eat(2, 11, 5);\n    printf(\"eat(2, 11, 5) -> {%d, %d}\\n\", result4[0], result4[1]); // Expected: {7, 0}\n}\n\n"}
{"task_id": "CPP/160", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nint do_algebra(const vector<string>& operators, const vector<int>& operands) {\n    // Initialize the expression with the first operand\n    string expression = to_string(operands[0]);\n    \n    // Construct the expression by iterating through the operators and operands\n    for (size_t i = 0; i < operators.size(); ++i) {\n        expression += \" \" + operators[i] + \" \" + to_string(operands[i + 1]);\n    }\n    \n    // Evaluate the constructed expression using C++'s stringstream\n    int result;\n    stringstream ss(expression);\n    ss >> result;\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/161", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\n// Function to solve the problem as described\nstring solve(string s) {\n    bool hasLetters = false;\n    \n    // Check if there are any letters in the string\n    for (char c : s) {\n        if (isalpha(c)) {\n            hasLetters = true;\n            break;\n        }\n    }\n\n    if (!hasLetters) {\n        // If no letters, reverse the entire string\n        reverse(s.begin(), s.end());\n    } else {\n        // If there are letters, convert them to their opposite case\n        for (char &c : s) {\n            if (islower(c)) {\n                c = toupper(c);\n            } else if (isupper(c)) {\n                c = tolower(c);\n            }\n        }\n    }\n\n    return s;\n}\n\n// Function to test the solve function with provided examples\nvoid test() {\n    cout << \"solve(\\\"1234\\\") = \\\"\" << solve(\"1234\") << \"\\\" (Expected: \\\"4321\\\")\" << endl;\n    cout << \"solve(\\\"ab\\\") = \\\"\" << solve(\"ab\") << \"\\\" (Expected: \\\"AB\\\")\" << endl;\n    cout << \"solve(\\\"#a@C\\\") = \\\"\" << solve(\"#a@C\") << \"\\\" (Expected: \\\"#A@c\\\")\" << endl;\n}\n\n"}
{"task_id": "CPP/162", "generation": "#include <iostream>\n#include <openssl/md5.h>\n#include <sstream>\n#include <iomanip>\n\n// Function to convert byte array to hex string\nstd::string bytes_to_hex(const unsigned char* bytes, size_t len) {\n    std::stringstream ss;\n    for (size_t i = 0; i < len; ++i) {\n        ss << std::hex << std::setw(2) << std::setfill('0') << static_cast<int>(bytes[i]);\n    }\n    return ss.str();\n}\n\n// Function to convert string to MD5 hash\nstd::string string_to_md5(const std::string& text) {\n    if (text.empty()) {\n        return \"None\";\n    }\n\n    unsigned char digest[MD5_DIGEST_LENGTH];\n    MD5(reinterpret_cast<const unsigned char*>(text.c_str()), text.length(), digest);\n\n    // Convert the hash to a hexadecimal string\n    return bytes_to_hex(digest, MD5_DIGEST_LENGTH);\n}\n\n"}
{"task_id": "CPP/163", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> generate_integers(int a, int b) {\n    vector<int> result;\n    for (int num = max(a, 2); num <= min(b + 1, 9); ++num) {\n        if (num % 2 == 0) {\n            result.push_back(num);\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/0", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // For std::sort\n\nbool has_close_elements(vector<float> numbers, float threshold) {\n    // Sort the vector first\n    sort(numbers.begin(), numbers.end());\n\n    // Iterate through adjacent elements to check if any pair is closer than the threshold\n    for (size_t i = 0; i < numbers.size() - 1; ++i) {\n        if (numbers[i + 1] - numbers[i] < threshold) {\n            return true;\n        }\n    }\n\n    // If no such pair found, return false\n    return false;\n}\n\n"}
{"task_id": "CPP/1", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> separate_paren_groups(string paren_string) {\n    vector<string> result;\n    string current_group;\n    int balance = 0;\n\n    for (char ch : paren_string) {\n        if (ch == '(') {\n            balance++;\n            current_group += ch;\n        } else if (ch == ')') {\n            balance--;\n            current_group += ch;\n            if (balance == 0) {\n                result.push_back(current_group);\n                current_group.clear();\n            }\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/2", "generation": "#include <stdio.h>\n#include <math.h>\n\nfloat truncate_number(float number) {\n    float integerPart;\n    modf(number, &integerPart);  // modf returns the fractional part and stores the integer part in `integerPart`\n    return number - integerPart; // Subtracting the integer part from the original number gives the decimal part\n}\n\n"}
{"task_id": "CPP/3", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool below_zero(vector<int> operations) {\n    int balance = 0; // Start with a zero balance\n\n    for (int op : operations) {\n        balance += op; // Update the balance after each operation\n\n        if (balance < 0) { // Check if the balance falls below zero\n            return true;\n        }\n    }\n\n    return false; // Return false if the balance never goes below zero\n}\n\n// Function to test the below_zero function with provided examples\nvoid check_function() {\n    vector<int> operations1 = {1, 2, 3};\n    vector<int> operations2 = {1, 2, -4, 5};\n\n    cout << \"Test Case 1: \" << (below_zero(operations1) ? \"Passed\" : \"Failed\") << endl;\n    cout << \"Test Case 2: \" << (below_zero(operations2) ? \"Passed\" : \"Failed\") << endl;\n}\n\n"}
{"task_id": "CPP/4", "generation": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nfloat mean_absolute_deviation(vector<float> numbers) {\n    // Step 1: Calculate the mean of the dataset\n    float sum = 0.0;\n    for (const auto& num : numbers) {\n        sum += num;\n    }\n    float mean = sum / numbers.size();\n\n    // Step 2 and 3: Compute the absolute differences and their average\n    float mad = 0.0;\n    for (const auto& num : numbers) {\n        mad += abs(num - mean);\n    }\n    mad /= numbers.size();\n\n    return mad;\n}\n\n"}
{"task_id": "CPP/5", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> intersperse(vector<int> numbers, int delimeter) {\n    vector<int> result;\n    \n    // Iterate through the original vector and insert each element followed by the delimiter\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        result.push_back(numbers[i]);\n        if (i != numbers.size() - 1) {  // Do not add a delimiter after the last element\n            result.push_back(delimeter);\n        }\n    }\n    \n    return result;\n}\n\n// Function to test the intersperse function\nvoid testIntersperse() {\n    vector<int> emptyVec = {};\n    vector<int> vec1 = {1, 2, 3};\n    vector<int> expected1 = {1, 4, 2, 4, 3};\n\n    cout << \"Testing with an empty vector:\" << endl;\n    for (int num : intersperse(emptyVec, 4)) {\n        cout << num << \" \";\n    }\n    cout << endl;\n\n    cout << \"Testing with a non-empty vector:\" << endl;\n    for (int num : intersperse(vec1, 4)) {\n        cout << num << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/6", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to parse and determine the deepest level of nesting for a single group of parentheses\nint maxDepthOfNesting(const string& group) {\n    int currentDepth = 0;\n    int maxDepth = 0;\n    \n    for (char ch : group) {\n        if (ch == '(') {\n            currentDepth++;\n            maxDepth = max(maxDepth, currentDepth);\n        } else if (ch == ')') {\n            currentDepth--;\n        }\n    }\n    \n    return maxDepth;\n}\n\n// Function to process the entire string and return a vector of maximum depths for each group\nvector<int> parse_nested_parens(string paren_string) {\n    vector<int> result;\n    size_t start = 0;\n    size_t end = paren_string.find(' ');\n    \n    while (end != string::npos) {\n        // Extract the current group from the string\n        string group = paren_string.substr(start, end - start);\n        \n        // Calculate the maximum depth of nesting for the current group\n        int maxDepth = maxDepthOfNesting(group);\n        \n        result.push_back(maxDepth);\n        \n        // Move to the next group\n        start = end + 1;\n        end = paren_string.find(' ', start);\n    }\n    \n    // Process the last group if there is one\n    if (start < paren_string.length()) {\n        string group = paren_string.substr(start);\n        int maxDepth = maxDepthOfNesting(group);\n        result.push_back(maxDepth);\n    }\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/7", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to filter strings containing a given substring\nvector<string> filter_by_substring(vector<string> strings, string substring) {\n    vector<string> filtered_strings;\n    \n    // Iterate through each string in the input vector\n    for (const auto& str : strings) {\n        // Check if the current string contains the substring\n        if (str.find(substring) != string::npos) {\n            // If it does, add it to the filtered list\n            filtered_strings.push_back(str);\n        }\n    }\n    \n    return filtered_strings;\n}\n\n// Function to test the filter_by_substring function\nvoid test_filter_by_substring() {\n    vector<string> input1 = {};\n    vector<string> expected1 = {};\n    assert(filter_by_substring(input1, \"a\") == expected1);\n\n    vector<string> input2 = {\"abc\", \"bacd\", \"cde\", \"vector\"};\n    vector<string> expected2 = {\"abc\", \"bacd\", \"vector\"};\n    assert(filter_by_substring(input2, \"a\") == expected2);\n\n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/8", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// Function to calculate the sum and product of elements in a vector\nvector<int> sum_product(vector<int> numbers) {\n    int sum = 0;\n    int product = 1;\n\n    // Iterate through each number in the vector\n    for (int num : numbers) {\n        sum += num;  // Add the current number to the sum\n        product *= num;  // Multiply the current number with the product\n    }\n\n    return {sum, product};\n}\n\n// Function to test the sum_product function\nvoid test_sum_product() {\n    vector<int> empty = {};\n    vector<int> result1 = sum_product(empty);\n    cout << \"Empty Vector: Sum = \" << result1[0] << \", Product = \" << result1[1] << endl;\n\n    vector<int> numbers = {1, 2, 3, 4};\n    vector<int> result2 = sum_product(numbers);\n    cout << \"Vector [1, 2, 3, 4]: Sum = \" << result2[0] << \", Product = \" << result2[1] << endl;\n}\n\n"}
{"task_id": "CPP/9", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> rolling_max(vector<int> numbers) {\n    if (numbers.empty()) return {};  // Return an empty vector if input is empty\n\n    vector<int> result;\n    int current_max = numbers[0];  // Initialize the current maximum with the first element\n    for (int num : numbers) {\n        if (num > current_max) {\n            current_max = num;  // Update the current maximum if a larger number is found\n        }\n        result.push_back(current_max);  // Add the current maximum to the result vector\n    }\n\n    return result;\n}\n\n// Function to print the vector for testing purposes\nvoid print_vector(const vector<int>& vec) {\n    for (int num : vec) {\n        cout << num << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/10", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_palindrome(const string& str) {\n    // Test if given string is a palindrome\n    int n = str.length();\n    for (int i = 0; i < n / 2; ++i) {\n        if (str[i] != str[n - i - 1]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nstring make_palindrome(const string& str) {\n    /*\n    Find the shortest palindrome that begins with a supplied string. \n    Algorithm idea is simple: \n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    */\n    \n    int n = str.length();\n    for (int i = 0; i < n; ++i) {\n        if (is_palindrome(str.substr(i))) {\n            // Found the longest palindromic suffix starting from index i\n            string prefix = str.substr(0, i);\n            reverse(prefix.begin(), prefix.end());\n            return str + prefix;\n        }\n    }\n\n    // If no palindromic suffix is found, the entire string itself is a palindrome.\n    return str;\n}\n\n"}
{"task_id": "CPP/11", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring string_xor(string a, string b) {\n    // Ensure both strings are of equal length by padding with leading zeros if necessary\n    int maxLength = max(a.length(), b.length());\n    a.insert(0, maxLength - a.length(), '0');\n    b.insert(0, maxLength - b.length(), '0');\n\n    string result(maxLength, '0');  // Initialize the result string\n\n    // Perform XOR operation character by character\n    for (int i = 0; i < maxLength; ++i) {\n        if (a[i] != b[i]) {\n            result[i] = '1';  // If characters are different, set result to '1'\n        }\n    }\n\n    return result;\n}\n\n// Function to test the string_xor function\nvoid test_string_xor() {\n    cout << \"Testing string_xor function:\" << endl;\n    cout << \"Input: \\\"010\\\", \\\"110\\\" - Output: \\\"\" << string_xor(\"010\", \"110\") << \"\\\" (Expected: \\\"100\\\")\" << endl;\n    cout << \"Input: \\\"10101\\\", \\\"11001\\\" - Output: \\\"\" << string_xor(\"10101\", \"11001\") << \"\\\" (Expected: \\\"01100\\\")\" << endl;\n}\n\n"}
{"task_id": "CPP/12", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring longest(const vector<string>& strings) {\n    if (strings.empty()) {\n        return \"\"; // Return an empty string to indicate None in this context.\n    }\n\n    const string* longestString = &strings[0];\n    for (const auto& str : strings) {\n        if (str.length() > longestString->length()) {\n            longestString = &str;\n        }\n    }\n\n    return *longestString;\n}\n\n"}
{"task_id": "CPP/13", "generation": "#include <stdio.h>\nusing namespace std;\n\nint greatest_common_divisor(int a, int b) {\n    // Ensure a >= b to simplify the logic\n    if (b > a) {\n        return greatest_common_divisor(b, a);\n    }\n\n    // Base case: if b is 0, then GCD is a\n    if (b == 0) {\n        return a;\n    }\n\n    // Recursive call with remainder of a divided by b\n    return greatest_common_divisor(b, a % b);\n}\n\n"}
{"task_id": "CPP/14", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to generate all prefixes of the input string\nvector<string> all_prefixes(string str) {\n    vector<string> prefixes;\n    for (size_t i = 1; i <= str.length(); ++i) {\n        prefixes.push_back(str.substr(0, i));\n    }\n    return prefixes;\n}\n\n"}
{"task_id": "CPP/15", "generation": "#include <iostream>\n#include <sstream>\n#include <string>\nusing namespace std;\n\nstring string_sequence(int n) {\n    stringstream ss;\n    for (int i = 0; i <= n; ++i) {\n        ss << i;\n        if (i < n) {\n            ss << \" \";\n        }\n    }\n    return ss.str();\n}\n\n// Function to test the string_sequence function\nvoid test_string_sequence() {\n    cout << \"Testing string_sequence...\" << endl;\n    assert(string_sequence(0) == \"0\");\n    assert(string_sequence(5) == \"0 1 2 3 4 5\");\n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/16", "generation": "#include <iostream>\n#include <string>\n#include <set>\n\nusing namespace std;\n\nint count_distinct_characters(string str) {\n    // Convert the string to lowercase to ensure case insensitivity\n    transform(str.begin(), str.end(), str.begin(), ::tolower);\n    \n    // Use a set to store distinct characters\n    set<char> distinct_chars(str.begin(), str.end());\n    \n    // The size of the set is the number of distinct characters\n    return distinct_chars.size();\n}\n\n"}
{"task_id": "CPP/17", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<int> parse_music(const string& music_string) {\n    // Define a mapping from note symbols to their corresponding beats\n    const vector<pair<string, int>> note_mapping = {{\"o\", 4}, {\"o|\", 2}, {\".|\", 1}};\n\n    // Split the music string into individual notes\n    vector<int> beats;\n    size_t start = 0;\n    while (start < music_string.length()) {\n        bool found = false;\n        for (const auto& note : note_mapping) {\n            if (music_string.substr(start, note.first.size()) == note.first) {\n                beats.push_back(note.second);\n                start += note.first.size();\n                found = true;\n                break;\n            }\n        }\n        if (!found) {\n            cerr << \"Invalid note at position: \" << start << endl;\n            return {}; // Return an empty vector if an invalid note is found\n        }\n    }\n\n    return beats;\n}\n\n"}
{"task_id": "CPP/18", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint how_many_times(const string& str, const string& substring) {\n    if (substring.empty()) return 0;\n    \n    int count = 0;\n    size_t pos = 0;\n    \n    while ((pos = str.find(substring, pos)) != string::npos) {\n        ++count;\n        pos++; // Move to the next character to allow overlapping matches\n    }\n    \n    return count;\n}\n\n"}
{"task_id": "CPP/19", "generation": "#include <iostream>\n#include <string>\n#include <map>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to convert word to number\nint word_to_number(const string& word) {\n    map<string, int> num_map = {{\"zero\", 0}, {\"one\", 1}, {\"two\", 2}, {\"three\", 3},\n                                {\"four\", 4}, {\"five\", 5}, {\"six\", 6}, {\"seven\", 7},\n                                {\"eight\", 8}, {\"nine\", 9}};\n    return num_map[word];\n}\n\n// Function to sort numbers\nstring sort_numbers(const string& numbers) {\n    vector<string> words;\n    string number;\n    \n    // Split the input string into individual words\n    for (char ch : numbers) {\n        if (ch == ' ') {\n            if (!number.empty()) {\n                words.push_back(number);\n                number.clear();\n            }\n        } else {\n            number += ch;\n        }\n    }\n    if (!number.empty()) {\n        words.push_back(number);\n    }\n\n    // Sort the words based on their numeric value\n    sort(words.begin(), words.end(), [](const string& a, const string& b) {\n        return word_to_number(a) < word_to_number(b);\n    });\n\n    // Join the sorted words back into a single string\n    string result;\n    for (const auto& word : words) {\n        if (!result.empty()) {\n            result += \" \";\n        }\n        result += word;\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/20", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<float> find_closest_elements(vector<float> numbers) {\n    // Sort the vector in ascending order\n    sort(numbers.begin(), numbers.end());\n    \n    // Initialize variables to store the closest pair and their difference\n    float min_diff = numeric_limits<float>::max();\n    vector<float> result = {0.0, 0.0};\n    \n    // Iterate through the sorted vector to find the closest pair\n    for (size_t i = 0; i < numbers.size() - 1; ++i) {\n        float diff = numbers[i + 1] - numbers[i];\n        if (diff < min_diff) {\n            min_diff = diff;\n            result[0] = numbers[i];\n            result[1] = numbers[i + 1];\n        }\n    }\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/21", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // For std::min_element and std::max_element\n\nusing namespace std;\n\nvector<float> rescale_to_unit(vector<float> numbers) {\n    if (numbers.size() < 2) {\n        throw invalid_argument(\"Vector must contain at least two elements.\");\n    }\n\n    float min_value = *std::min_element(numbers.begin(), numbers.end());\n    float max_value = *std::max_element(numbers.begin(), numbers.end());\n\n    vector<float> scaled_numbers;\n    for (float num : numbers) {\n        float new_value = (num - min_value) / (max_value - min_value);\n        scaled_numbers.push_back(new_value);\n    }\n\n    return scaled_numbers;\n}\n\n"}
{"task_id": "CPP/22", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <list>\n#include <boost/any.hpp>\n\ntypedef std::list<boost::any> list_any;\nusing namespace std;\n\nvector<int> filter_integers(list_any values) {\n    vector<int> result;\n    for (const auto& value : values) {\n        if (value.type() == typeid(int)) {\n            result.push_back(boost::any_cast<int>(value));\n        }\n    }\n    return result;\n}\n\n"}
{"task_id": "CPP/23", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint strlen(const string& str) {\n    // Return the size of the string, which is equivalent to its length.\n    return str.size();\n}\n\n// Function to test the strlen function with some examples\nvoid test_strlen() {\n    cout << \"Length of \\\"\\\" (empty string): \" << strlen(\"\") << endl;\n    cout << \"Length of \\\"abc\\\": \" << strlen(\"abc\") << endl;\n    cout << \"Length of \\\"hello world\\\": \" << strlen(\"hello world\") << endl;\n}\n\n"}
{"task_id": "CPP/24", "generation": "#include <iostream>\nusing namespace std;\n\nint largest_divisor(int n) {\n    for (int i = n - 1; i > 0; --i) {\n        if (n % i == 0) {\n            return i;\n        }\n    }\n    // If no divisor is found, which should not happen for positive integers,\n    // we can return -1 or throw an exception. For simplicity, returning -1.\n    return -1;\n}\n\n"}
{"task_id": "CPP/25", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> factorize(int n) {\n    vector<int> factors;\n    \n    // Divide by 2 to get rid of all even factors\n    while (n % 2 == 0) {\n        factors.push_back(2);\n        n /= 2;\n    }\n    \n    // Check for odd factors from 3 onwards\n    for (int i = 3; i * i <= n; i += 2) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n    \n    // If n is a prime number greater than 2\n    if (n > 2) {\n        factors.push_back(n);\n    }\n    \n    return factors;\n}\n\n"}
{"task_id": "CPP/26", "generation": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nvector<int> remove_duplicates(vector<int> numbers) {\n    // Create an unordered map to count occurrences of each element\n    unordered_map<int, int> counts;\n    \n    // Count the occurrences of each number in the input vector\n    for (int num : numbers) {\n        counts[num]++;\n    }\n    \n    // Create a new vector to store elements that occur exactly once\n    vector<int> result;\n    \n    // Iterate through the original vector and add elements to the result if they occur only once\n    for (int num : numbers) {\n        if (counts[num] == 1) {\n            result.push_back(num);\n        }\n    }\n    \n    return result;\n}\n\n// Function to check the correctness of the remove_duplicates function\nvoid check() {\n    vector<int> input = {1, 2, 3, 2, 4};\n    vector<int> expected_output = {1, 3, 4};\n    vector<int> output = remove_duplicates(input);\n    \n    if (output == expected_output) {\n        cout << \"Test passed.\" << endl;\n    } else {\n        cout << \"Test failed.\" << endl;\n    }\n}\n\n"}
{"task_id": "CPP/27", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring flip_case(string str) {\n    for (char &c : str) {\n        if (islower(c)) {\n            c = toupper(c);\n        } else if (isupper(c)) {\n            c = tolower(c);\n        }\n    }\n    return str;\n}\n\n"}
{"task_id": "CPP/28", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <numeric> // For std::accumulate\n\nusing namespace std;\n\nstring concatenate(vector<string> strings) {\n    // Use std::accumulate to concatenate all strings in the vector\n    return accumulate(strings.begin(), strings.end(), string(\"\"));\n}\n\n// Function to test the concatenate function\nvoid test_concatenate() {\n    assert(concatenate({}) == \"\");\n    assert(concatenate({\"a\", \"b\", \"c\"}) == \"abc\");\n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/29", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to filter strings based on the given prefix\nvector<string> filter_by_prefix(vector<string> strings, string prefix) {\n    vector<string> filtered_strings;\n    \n    // Iterate through each string in the input vector\n    for (const auto& str : strings) {\n        // Check if the current string starts with the given prefix\n        if (str.substr(0, prefix.length()) == prefix) {\n            // If it does, add it to the filtered list\n            filtered_strings.push_back(str);\n        }\n    }\n    \n    return filtered_strings;\n}\n\n// Function to test the filter_by_prefix function\nvoid test_filter_by_prefix() {\n    vector<string> input1 = {};\n    string prefix1 = \"a\";\n    vector<string> result1 = filter_by_prefix(input1, prefix1);\n    cout << \"Test 1: \";\n    if (result1.empty()) {\n        cout << \"Passed\" << endl;\n    } else {\n        cout << \"Failed\" << endl;\n    }\n\n    vector<string> input2 = {\"abc\", \"bcd\", \"cde\", \"vector\"};\n    string prefix2 = \"a\";\n    vector<string> result2 = filter_by_prefix(input2, prefix2);\n    cout << \"Test 2: \";\n    if (result2 == vector<string>{\"abc\", \"vector\"}) {\n        cout << \"Passed\" << endl;\n    } else {\n        cout << \"Failed\" << endl;\n    }\n}\n\n"}
{"task_id": "CPP/30", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvector<float> get_positive(vector<float> l) {\n    vector<float> result;\n    for (float num : l) {\n        if (num > 0) {\n            result.push_back(num);\n        }\n    }\n    return result;\n}\n\n"}
{"task_id": "CPP/31", "generation": "#include <iostream>\nusing namespace std;\n\nbool is_prime(long long n) {\n    // Handle edge cases for numbers less than or equal to 1\n    if (n <= 1) return false;\n    \n    // Check divisibility from 2 up to the square root of n\n    for (long long i = 2; i * i <= n; ++i) {\n        if (n % i == 0) {\n            return false; // Found a divisor, so it's not prime\n        }\n    }\n    \n    return true; // No divisors found, so it is prime\n}\n\n"}
{"task_id": "CPP/32", "generation": "#include <vector>\n#include <cmath>\n#include <iostream>\n#include <algorithm>\n#include <functional>\n#include <cassert>\n\nusing namespace std;\n\ndouble poly(const vector<double>& xs, double x) {\n    double sum = 0;\n    for (size_t i = 0; i < xs.size(); ++i) {\n        sum += xs[i] * pow(x, static_cast<int>(i));\n    }\n    return sum;\n}\n\ndouble find_zero(const vector<double>& xs) {\n    // Ensure xs has an even number of coefficients and the largest non-zero coefficient is at the end\n    if (xs.size() % 2 != 0 || !any_of(xs.begin(), xs.end() - 1, [](double coef) { return coef != 0; })) {\n        throw runtime_error(\"Invalid polynomial coefficients\");\n    }\n\n    // Use a numerical method to find a root of the polynomial\n    double x_initial_guess = 0.0;\n    vector<double> roots = fsolve(poly, xs, x_initial_guess);\n    assert(roots.size() == 1); // Ensure only one root is found\n\n    return roots[0];\n}\n\n// Custom implementation of fsolve for demonstration purposes\nvector<double> fsolve(const function<double(double)>& poly_func, const vector<double>& coefficients, double initial_guess) {\n    double x = initial_guess;\n    for (int i = 0; i < 100; ++i) { // Simple iteration to find a root\n        double y = poly_func(x);\n        if (abs(y) < 1e-6) return {x}; // Check if the function value is close to zero\n        x -= y / derivative(poly_func, x); // Newton's method approximation for the derivative\n    }\n    throw runtime_error(\"Failed to find a root\");\n}\n\ndouble derivative(const function<double(double)>& poly_func, double x) {\n    return (poly_func(x + 1e-6) - poly_func(x)) / 1e-6; // Simple numerical differentiation\n}\n\n"}
{"task_id": "CPP/33", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> sort_third(vector<int> l) {\n    // Extract elements at indices divisible by 3\n    vector<int> third_indices;\n    for (int i = 2; i < l.size(); i += 3) {\n        third_indices.push_back(l[i]);\n    }\n\n    // Sort the extracted elements\n    sort(third_indices.begin(), third_indices.end());\n\n    // Create a new list to store the result\n    vector<int> l_prime = l;\n\n    // Replace elements at indices divisible by three with sorted values\n    for (int i = 2, j = 0; i < l.size(); i += 3, ++j) {\n        l_prime[i] = third_indices[j];\n    }\n\n    return l_prime;\n}\n\n// Function to print the vector\nvoid print_vector(const vector<int>& v) {\n    for (int val : v) {\n        cout << val << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/34", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> unique(vector<int> l) {\n    // Sort the input vector\n    sort(l.begin(), l.end());\n    \n    // Remove consecutive duplicate elements\n    auto last = unique(l.begin(), l.end());\n    \n    // Resize the vector to contain only the unique elements\n    l.resize(distance(l.begin(), last));\n    \n    return l;\n}\n\n"}
{"task_id": "CPP/35", "generation": "#include <iostream>\n#include <vector>\n\nfloat max_element(const std::vector<float>& l) {\n    if (l.empty()) {\n        throw std::invalid_argument(\"Vector is empty\");\n    }\n\n    float max_val = l[0];\n    for (size_t i = 1; i < l.size(); ++i) {\n        if (l[i] > max_val) {\n            max_val = l[i];\n        }\n    }\n    return max_val;\n}\n\n"}
{"task_id": "CPP/36", "generation": "#include <iostream>\nusing namespace std;\n\nint fizz_buzz(int n) {\n    int count = 0;\n    \n    for (int i = 1; i < n; ++i) {\n        if (i % 11 == 0 || i % 13 == 0) {\n            // Convert the number to a string and count occurrences of '7'\n            string num_str = to_string(i);\n            for (char c : num_str) {\n                if (c == '7') {\n                    ++count;\n                }\n            }\n        }\n    }\n    \n    return count;\n}\n\n"}
{"task_id": "CPP/37", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<float> sort_even(vector<float> l) {\n    // Extract elements at even indices\n    vector<float> evens;\n    for (size_t i = 0; i < l.size(); i += 2) {\n        evens.push_back(l[i]);\n    }\n\n    // Sort the extracted elements\n    sort(evens.begin(), evens.end());\n\n    // Place sorted elements back into their original positions\n    size_t evenIndex = 0;\n    for (size_t i = 0; i < l.size(); ++i) {\n        if (i % 2 == 0) {\n            l[i] = evens[evenIndex++];\n        }\n    }\n\n    return l;\n}\n\n// Function to check the correctness of the sort_even function\nvoid check() {\n    vector<float> result1 = sort_even({1, 2, 3});\n    assert(result1 == vector<float>({1, 2, 3}));\n\n    vector<float> result2 = sort_even({5, 6, 3, 4});\n    assert(result2 == vector<float>({3, 6, 5, 4}));\n\n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/38", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nstring encode_cyclic(string s) { \n    // returns encoded string by cycling groups of three characters.  \n    int l = s.length();\n    int num = (l + 2) / 3;\n    string x, output;\n    for (int i = 0; i * 3 < l; i++) {\n        x = s.substr(i * 3, 3);\n        if (x.length() == 3) x = x.substr(1) + x[0];\n        output += x;\n    }\n    return output;\n}\n\nstring decode_cyclic(string s) { \n    /*\n    takes as input string encoded with encode_cyclic function. Returns decoded string.\n    */\n    int l = s.length();\n    int num = (l + 2) / 3;\n    string x, output;\n    for (int i = 0; i * 3 < l; i++) {\n        x = s.substr(i * 3, 3);\n        if (x.length() == 3) x = x[2] + x.substr(0, 2); // Rotate one position to the left\n        output += x;\n    }\n    return output;\n}\n\n"}
{"task_id": "CPP/39", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    if (num == 2 || num == 3) return true;\n    if (num % 2 == 0 || num % 3 == 0) return false;\n    for (int i = 5; i * i <= num; i += 6) {\n        if (num % i == 0 || num % (i + 2) == 0)\n            return false;\n    }\n    return true;\n}\n\n// Function to generate the n-th prime Fibonacci number\nint prime_fib(int n) {\n    int count = 0; // Counter for prime Fibonacci numbers found\n    long fib1 = 0, fib2 = 1; // First two Fibonacci numbers\n\n    while (true) {\n        long next_fib = fib1 + fib2;\n        if (is_prime(next_fib)) {\n            count++;\n            if (count == n) return next_fib;\n        }\n        fib1 = fib2;\n        fib2 = next_fib;\n    }\n}\n\n"}
{"task_id": "CPP/40", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nbool triples_sum_to_zero(vector<int> l) {\n    sort(l.begin(), l.end());\n    int n = l.size();\n    \n    for (int i = 0; i < n - 2; ++i) {\n        if (i > 0 && l[i] == l[i-1]) continue; // Skip duplicate elements\n        \n        int left = i + 1, right = n - 1;\n        \n        while (left < right) {\n            int current_sum = l[i] + l[left] + l[right];\n            \n            if (current_sum == 0) {\n                return true;\n            } else if (current_sum < 0) {\n                ++left; // Move left pointer to the right\n            } else {\n                --right; // Move right pointer to the left\n            }\n        }\n    }\n    \n    return false;\n}\n\n"}
{"task_id": "CPP/41", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint car_race_collision(int n) {\n    // Since all cars are moving at the same speed and start far apart,\n    // each car going left to right will eventually collide with each car\n    // coming from the opposite direction.\n    return n * n;\n}\n\n"}
{"task_id": "CPP/42", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> incr_list(vector<int> l) {\n    for (int i = 0; i < l.size(); ++i) {\n        l[i] += 1;\n    }\n    return l;\n}\n\n// Function to print the vector elements\nvoid print_vector(const vector<int>& v) {\n    for (const int& val : v) {\n        cout << val << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/43", "generation": "#include <iostream>\n#include <vector>\n#include <set>\n\nusing namespace std;\n\nbool pairs_sum_to_zero(vector<int> l) {\n    // Use a set to store seen numbers\n    set<int> seen;\n    \n    for (int num : l) {\n        // Check if the negation of the current number is in the set\n        if (seen.find(-num) != seen.end()) {\n            return true;\n        }\n        // Add the current number to the set\n        seen.insert(num);\n    }\n    \n    // If no such pair is found, return false\n    return false;\n}\n\n"}
{"task_id": "CPP/44", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring change_base(int x, int base) {\n    if (x == 0) return \"0\"; // Handle the case where x is zero\n\n    string result = \"\";\n    while (x > 0) {\n        int remainder = x % base;\n        char digit = '0' + remainder; // Convert the integer to its character representation\n        result = digit + result; // Prepend the digit to the result string\n        x /= base; // Divide x by the base\n    }\n    return result;\n}\n\n"}
{"task_id": "CPP/45", "generation": "#include <iostream>\nusing namespace std;\n\nfloat triangle_area(float a, float h) {\n    return 0.5 * a * h;\n}\n\n"}
{"task_id": "CPP/46", "generation": "#include <stdio.h>\nusing namespace std;\n\nint fib4(int n) {\n    if (n == 0 || n == 1 || n == 3) return 0;\n    if (n == 2) return 2;\n\n    int a = 0, b = 0, c = 2, d = 0, result;\n    \n    for (int i = 4; i <= n; ++i) {\n        result = a + b + c + d;\n        a = b;\n        b = c;\n        c = d;\n        d = result;\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/47", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nfloat median(vector<float> l) {\n    // Sort the vector\n    sort(l.begin(), l.end());\n    \n    int n = l.size();\n    \n    if (n % 2 == 0) {\n        // If even number of elements, return the average of the two middle elements\n        return (l[n / 2 - 1] + l[n / 2]) / 2.0;\n    } else {\n        // If odd number of elements, return the middle element\n        return l[n / 2];\n    }\n}\n\n"}
{"task_id": "CPP/48", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_palindrome(string text) {\n    int left = 0;\n    int right = text.length() - 1;\n\n    while (left < right) {\n        if (text[left] != text[right]) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n\n    return true;\n}\n\n"}
{"task_id": "CPP/49", "generation": "#include <stdio.h>\nusing namespace std;\n\nint modp(int n, int p) {\n    if (n == 0)\n        return 1; // Any number to the power of 0 is 1\n\n    long result = 1;\n    long base = 2;\n\n    while (n > 0) {\n        // If n is odd, multiply the result by the current base\n        if (n % 2 == 1)\n            result = (result * base) % p;\n\n        // Square the base and reduce it modulo p\n        base = (base * base) % p;\n        n /= 2; // Divide n by 2\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/50", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring encode_shift(string s) {\n    // returns encoded string by shifting every character by 5 in the alphabet.\n    string out;\n    for (size_t i = 0; i < s.length(); i++) {\n        if (isalpha(s[i])) {  // Check if the character is an alphabetic letter\n            char base = islower(s[i]) ? 'a' : 'A';\n            int w = ((int)s[i] - (int)base + 5) % 26;\n            out += (char)(w + base);\n        } else {\n            out += s[i];  // Non-alphabetic characters are appended as is\n        }\n    }\n    return out;\n}\n\nstring decode_shift(string s) {\n    // takes as input string encoded with encode_shift function. Returns decoded string.\n    string out;\n    for (size_t i = 0; i < s.length(); i++) {\n        if (isalpha(s[i])) {  // Check if the character is an alphabetic letter\n            char base = islower(s[i]) ? 'a' : 'A';\n            int w = ((int)s[i] - (int)base - 5 + 26) % 26;\n            out += (char)(w + base);\n        } else {\n            out += s[i];  // Non-alphabetic characters are appended as is\n        }\n    }\n    return out;\n}\n\n"}
{"task_id": "CPP/51", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nbool is_vowel(char c) {\n    // Convert character to lowercase for simplicity\n    char lower_c = tolower(c);\n    return lower_c == 'a' || lower_c == 'e' || lower_c == 'i' || lower_c == 'o' || lower_c == 'u';\n}\n\nstring remove_vowels(string text) {\n    string result;\n    for (char c : text) {\n        if (!is_vowel(c)) {\n            result += c;\n        }\n    }\n    return result;\n}\n\n"}
{"task_id": "CPP/52", "generation": "#include <vector>\n#include <iostream>\n\n// Function to check if all elements in the vector are below the threshold\nbool below_threshold(const std::vector<int>& l, int t) {\n    for (int num : l) {\n        if (num >= t) {\n            return false;\n        }\n    }\n    return true;\n}\n\n// Function to test the below_threshold function with provided data points\nvoid check_function() {\n    assert(below_threshold({1, 2, 4, 10}, 100) == true);\n    assert(below_threshold({1, 20, 4, 10}, 5) == false);\n    std::cout << \"All tests passed successfully.\" << std::endl;\n}\n\n"}
{"task_id": "CPP/53", "generation": "#include <iostream>  // Include iostream for input/output operations\n\nusing namespace std;\n\nint add(int x, int y) {\n    return x + y;  // Return the sum of x and y\n}\n\n"}
{"task_id": "CPP/54", "generation": "#include <iostream>\n#include <string>\n#include <set>\n\nusing namespace std;\n\nbool same_chars(string s0, string s1) {\n    // Create a set for each string to store unique characters\n    set<char> chars_s0(s0.begin(), s0.end());\n    set<char> chars_s1(s1.begin(), s1.end());\n\n    // Compare the sets\n    return chars_s0 == chars_s1;\n}\n\n"}
{"task_id": "CPP/55", "generation": "#include <stdio.h>\nusing namespace std;\n\nint fib(int n) {\n    if (n <= 0) return 0;\n    else if (n == 1) return 1;\n    else return fib(n - 1) + fib(n - 2);\n}\n\n"}
{"task_id": "CPP/56", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    int count = 0;\n    \n    for (char c : brackets) {\n        if (c == '<') {\n            count++;\n        } else if (c == '>') {\n            count--;\n            if (count < 0) {\n                return false; // More closing brackets than opening ones\n            }\n        }\n    }\n    \n    return count == 0; // True if all brackets are correctly matched\n}\n\n"}
{"task_id": "CPP/57", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool monotonic(vector<float> l) {\n    if (l.size() <= 1) {\n        return true; // A vector with 0 or 1 element is trivially monotonic.\n    }\n\n    bool increasing = false;\n    bool decreasing = false;\n\n    for (size_t i = 1; i < l.size(); ++i) {\n        if (l[i] > l[i - 1]) {\n            increasing = true;\n        } else if (l[i] < l[i - 1]) {\n            decreasing = true;\n        }\n\n        // If both increasing and decreasing flags are set, the sequence is not monotonic.\n        if (increasing && decreasing) {\n            return false;\n        }\n    }\n\n    return true; // The sequence is either strictly increasing or strictly decreasing.\n}\n\n"}
{"task_id": "CPP/58", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\n\nusing namespace std;\n\nvector<int> common(vector<int> l1, vector<int> l2) {\n    // Create sets from both vectors\n    set<int> s1(l1.begin(), l1.end());\n    set<int> s2(l2.begin(), l2.end());\n\n    // Find the intersection of the two sets\n    set<int> result;\n    set_intersection(s1.begin(), s1.end(), s2.begin(), s2.end(), inserter(result, result.begin()));\n\n    // Convert the set to a vector and sort it\n    vector<int> commonElements(result.begin(), result.end());\n    sort(commonElements.begin(), commonElements.end());\n\n    return commonElements;\n}\n\n"}
{"task_id": "CPP/59", "generation": "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\nint largest_prime_factor(int n) {\n    // Remove all factors of 2\n    while (n % 2 == 0) {\n        n /= 2;\n    }\n\n    // Check for odd factors from 3 to sqrt(n)\n    int factor = 3;\n    while (factor * factor <= n) {\n        while (n % factor == 0) {\n            n /= factor;\n        }\n        factor += 2;\n    }\n\n    // If n is a prime number greater than 2\n    if (n > 2) {\n        return n;\n    } else {\n        return factor - 2; // The last factor found will be the largest prime factor\n    }\n}\n\n"}
{"task_id": "CPP/60", "generation": "#include <iostream>\nusing namespace std;\n\nint sum_to_n(int n) {\n    int sum = 0;\n    for (int i = 1; i <= n; ++i) {\n        sum += i;\n    }\n    return sum;\n}\n\n// Function to test the sum_to_n function with provided data points\nvoid test_sum_to_n() {\n    cout << \"Testing sum_to_n...\" << endl;\n    assert(sum_to_n(30) == 465);\n    assert(sum_to_n(100) == 5050);\n    assert(sum_to_n(5) == 15);\n    assert(sum_to_n(10) == 55);\n    assert(sum_to_n(1) == 1);\n\n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/61", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    int balance = 0;\n    \n    for (char bracket : brackets) {\n        if (bracket == '(') {\n            balance++;\n        } else if (bracket == ')') {\n            balance--;\n        }\n        \n        // If at any point the balance is negative, it means there's a closing bracket without an opening one\n        if (balance < 0) {\n            return false;\n        }\n    }\n    \n    // If the final balance is zero, all brackets are correctly matched\n    return balance == 0;\n}\n\n"}
{"task_id": "CPP/62", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// Function to compute the derivative of a polynomial represented by its coefficients\nvector<float> derivative(vector<float> xs) {\n    // Create a new vector to hold the derivatives, starting from index 1 (ignoring the constant term)\n    vector<float> result;\n    \n    for (size_t i = 1; i < xs.size(); ++i) {\n        // Multiply each coefficient by its corresponding power\n        result.push_back(xs[i] * static_cast<float>(i));\n    }\n    \n    return result;\n}\n\n// Function to print the polynomial coefficients\nvoid printPolynomial(const vector<float>& coeffs) {\n    for (size_t i = 0; i < coeffs.size(); ++i) {\n        cout << coeffs[i];\n        if (i != coeffs.size() - 1) {\n            cout << \" * x^\" << i;\n        }\n        if (i != coeffs.size() - 2) {\n            cout << \" + \";\n        }\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/63", "generation": "#include <iostream>\nusing namespace std;\n\nint fibfib(int n) {\n    // Base cases\n    if (n == 0 || n == 1) return 0;\n    if (n == 2) return 1;\n\n    // Array to store the computed values of FibFib sequence\n    int dp[n + 1];\n    dp[0] = 0; // fibfib(0)\n    dp[1] = 0; // fibfib(1)\n    dp[2] = 1; // fibfib(2)\n\n    // Fill the dp array using the recurrence relation\n    for (int i = 3; i <= n; ++i) {\n        dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3];\n    }\n\n    return dp[n];\n}\n\n"}
{"task_id": "CPP/64", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nint vowels_count(string s) {\n    // Define a set of vowels including 'y' which is considered a vowel only if it is at the end of the word\n    string vowels = \"aeiou\";\n    int count = 0;\n    \n    for (size_t i = 0; i < s.length(); ++i) {\n        char c = tolower(s[i]);\n        \n        // Check if the character is a vowel\n        if (vowels.find(c) != string::npos) {\n            count += 1;\n        }\n        // Special check for 'y' at the end of the word\n        else if (c == 'y' && (i == s.length() - 1 || vowels.find(tolower(s[i + 1])) == string::npos)) {\n            count += 1;\n        }\n    }\n    \n    return count;\n}\n\n"}
{"task_id": "CPP/65", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring circular_shift(int x, int shift) {\n    // Convert the integer to a string\n    string num_str = to_string(x);\n    int num_length = num_str.length();\n    \n    // If shift is greater than or equal to the number of digits, reverse the string\n    if (shift >= num_length) {\n        return string(num_str.rbegin(), num_str.rend());\n    }\n    \n    // Perform circular shift by slicing and concatenating\n    string shifted_str = num_str.substr(num_length - shift) + num_str.substr(0, num_length - shift);\n    return shifted_str;\n}\n\n"}
{"task_id": "CPP/66", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint digitSum(const string& s) {\n    int sum = 0;\n    for (char c : s) {\n        if (isupper(c)) { // Check if the character is uppercase\n            sum += static_cast<int>(c); // Add its ASCII value to the sum\n        }\n    }\n    return sum;\n}\n\n// Function to test the digitSum function with provided examples\nvoid checkFunction() {\n    assert(digitSum(\"\") == 0);\n    assert(digitSum(\"abAB\") == 131);\n    assert(digitSum(\"abcCd\") == 67);\n    assert(digitSum(\"helloE\") == 69);\n    assert(digitSum(\"woArBld\") == 131);\n    assert(digitSum(\"aAaaaXa\") == 153);\n\n    cout << \"All test cases passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/67", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nint fruit_distribution(string s, int n) {\n    // Extract the numbers of apples and oranges from the string\n    stringstream ss(s);\n    string temp;\n    getline(ss, temp, ' ');  // Read \"apples\"\n    getline(ss, temp, ' ');  // Read \"and\"\n    getline(ss, temp, ' ');  // Read the number of apples\n\n    int apples = stoi(temp);\n\n    getline(ss, temp, ' ');  // Read \"oranges\"\n    getline(ss, temp);       // Read the number of oranges\n    int oranges = stoi(temp);\n\n    // Calculate the number of mangoes\n    int mangoes = n - (apples + oranges);\n    return mangoes;\n}\n\n"}
{"task_id": "CPP/68", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> pluck(vector<int> arr) {\n    vector<pair<int, int>> evenNodes; // Store pairs of (value, index)\n    \n    // Filter and store even nodes with their indices\n    for (int i = 0; i < arr.size(); ++i) {\n        if (arr[i] % 2 == 0) {\n            evenNodes.push_back({arr[i], i});\n        }\n    }\n\n    // If no even nodes, return an empty vector\n    if (evenNodes.empty()) {\n        return {};\n    }\n\n    // Sort the pairs by value and then by index\n    sort(evenNodes.begin(), evenNodes.end());\n\n    // Return the smallest even node with its index\n    return {evenNodes[0].first, evenNodes[0].second};\n}\n\n"}
{"task_id": "CPP/69", "generation": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint search(vector<int> lst) {\n    // Create a frequency map to count occurrences of each integer\n    unordered_map<int, int> freqMap;\n    \n    // Count the frequency of each number in the vector\n    for (int num : lst) {\n        freqMap[num]++;\n    }\n    \n    // Initialize the result as -1\n    int result = -1;\n    \n    // Iterate through the unique numbers and check the condition\n    for (auto& pair : freqMap) {\n        if (pair.first <= pair.second && pair.first > result) {\n            result = pair.first;\n        }\n    }\n    \n    return result;\n}\n\n// Function to test the search function with provided examples\nvoid test() {\n    cout << \"search({4, 1, 2, 2, 3, 1}) == \" << search({4, 1, 2, 2, 3, 1}) << endl; // Should output 2\n    cout << \"search({1, 2, 2, 3, 3, 3, 4, 4, 4}) == \" << search({1, 2, 2, 3, 3, 3, 4, 4, 4}) << endl; // Should output 3\n    cout << \"search({5, 5, 4, 4, 4}) == \" << search({5, 5, 4, 4, 4}) << endl; // Should output -1\n}\n\n"}
{"task_id": "CPP/70", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> strange_sort_list(vector<int> lst) {\n    // Sort the list in ascending order\n    sort(lst.begin(), lst.end());\n    \n    vector<int> result;\n    int start = 0;  // Start index for minimum values\n    int end = lst.size() - 1;  // End index for maximum values\n    \n    while (start <= end) {\n        if (start == end) {\n            // If only one element is left, add it to the result\n            result.push_back(lst[start]);\n        } else {\n            // Add minimum value from start\n            result.push_back(lst[start++]);\n            // Add maximum value from end\n            result.push_back(lst[end--]);\n        }\n    }\n    \n    return result;\n}\n\n// Function to check the correctness of the strange_sort_list function\nvoid check() {\n    assert(strange_sort_list({1, 2, 3, 4}) == vector<int>({1, 4, 2, 3}));\n    assert(strange_sort_list({5, 5, 5, 5}) == vector<int>({5, 5, 5, 5}));\n    assert(strange_sort_list({}) == vector<int>({}));\n    cout << \"All test cases passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/71", "generation": "#include <stdio.h>\n#include <math.h>\n\nusing namespace std;\n\nfloat triangle_area(float a, float b, float c) {\n    // Check if the sides form a valid triangle\n    if (a + b <= c || a + c <= b || b + c <= a) {\n        return -1;\n    }\n\n    // Calculate the semi-perimeter\n    float s = (a + b + c) / 2.0;\n\n    // Calculate the area using Heron's formula\n    float area = sqrt(s * (s - a) * (s - b) * (s - c));\n\n    // Round the result to 2 decimal points\n    return round(area * 100) / 100;\n}\n\n"}
{"task_id": "CPP/72", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool will_it_fly(vector<int> q, int w) {\n    // Check if the sum of elements is within the weight limit\n    int sum = 0;\n    for (int num : q) {\n        sum += num;\n    }\n    if (sum > w) return false;\n\n    // Check if the vector is a palindrome\n    for (size_t i = 0; i < q.size() / 2; ++i) {\n        if (q[i] != q[q.size() - 1 - i]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\n// Function to test the will_it_fly function with provided examples\nvoid check() {\n    cout << boolalpha; // Print bools as true/false instead of 1/0\n    cout << \"will_it_fly({1, 2}, 5): \" << will_it_fly({1, 2}, 5) << endl;\n    cout << \"will_it_fly({3, 2, 3}, 1): \" << will_it_fly({3, 2, 3}, 1) << endl;\n    cout << \"will_it_fly({3, 2, 3}, 9): \" << will_it_fly({3, 2, 3}, 9) << endl;\n    cout << \"will_it_fly({3}, 5): \" << will_it_fly({3}, 5) << endl;\n}\n\n"}
{"task_id": "CPP/73", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint smallest_change(vector<int> arr) {\n    int n = arr.size();\n    int left = 0;\n    int right = n - 1;\n    int changes = 0;\n\n    while (left < right) {\n        if (arr[left] != arr[right]) {\n            changes++;\n        }\n        left++;\n        right--;\n    }\n\n    return changes;\n}\n\n"}
{"task_id": "CPP/74", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to calculate the total number of characters in a vector of strings\nint total_chars(const vector<string>& vec) {\n    int sum = 0;\n    for (const auto& str : vec) {\n        sum += str.length();\n    }\n    return sum;\n}\n\nvector<string> total_match(vector<string> lst1, vector<string> lst2) {\n    // Calculate the total number of characters in both vectors\n    int chars_lst1 = total_chars(lst1);\n    int chars_lst2 = total_chars(lst2);\n\n    // Compare and return the appropriate vector\n    if (chars_lst1 < chars_lst2) {\n        return lst1;\n    } else if (chars_lst2 < chars_lst1) {\n        return lst2;\n    } else {\n        return lst1;  // Return the first vector if both have the same number of characters\n    }\n}\n\n// Function to test the total_match function with provided examples\nvoid test_total_match() {\n    cout << \"Test 1: \";\n    vector<string> result = total_match({}, {});\n    for (const auto& str : result) {\n        cout << str << \" \";\n    }\n    cout << endl;\n\n    cout << \"Test 2: \";\n    result = total_match({\"hi\", \"admin\"}, {\"hI\", \"Hi\"});\n    for (const auto& str : result) {\n        cout << str << \" \";\n    }\n    cout << endl;\n\n    cout << \"Test 3: \";\n    result = total_match({\"hi\", \"admin\"}, {\"hi\", \"hi\", \"admin\", \"project\"});\n    for (const auto& str : result) {\n        cout << str << \" \";\n    }\n    cout << endl;\n\n    cout << \"Test 4: \";\n    result = total_match({\"hi\", \"admin\"}, {\"hI\", \"hi\", \"hi\"});\n    for (const auto& str : result) {\n        cout << str << \" \";\n    }\n    cout << endl;\n\n    cout << \"Test 5: \";\n    result = total_match({\"4\"}, {\"1\", \"2\", \"3\", \"4\", \"5\"});\n    for (const auto& str : result) {\n        cout << str << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/75", "generation": "#include <iostream>\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    if (n == 2 || n == 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    for (int i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0)\n            return false;\n    }\n    return true;\n}\n\n// Function to check if the given number is a product of exactly three prime numbers\nbool is_multiply_prime(int a) {\n    // Generate all primes less than 100\n    int primes[] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97};\n    int num_primes = sizeof(primes) / sizeof(primes[0]);\n\n    // Try all combinations of three primes\n    for (int i = 0; i < num_primes; ++i) {\n        for (int j = i; j < num_primes; ++j) {\n            for (int k = j; k < num_primes; ++k) {\n                if (primes[i] * primes[j] * primes[k] == a)\n                    return true;\n            }\n        }\n    }\n\n    return false;\n}\n\n// Function to test the is_multiply_prime function\nvoid test() {\n    cout << \"Testing is_multiply_prime...\" << endl;\n    assert(is_multiply_prime(30) == true); // 2 * 3 * 5 = 30\n    assert(is_multiply_prime(60) == false); // Not a product of exactly three primes\n    assert(is_multiply_prime(105) == true); // 3 * 5 * 7 = 105\n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/76", "generation": "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\nbool is_simple_power(int x, int n) {\n    if (n == 1) {\n        return x == 1; // Special case: 1^any_number = 1\n    }\n    \n    double log_result = log(x) / log(n);\n    return floor(log_result) == log_result;\n}\n\n"}
{"task_id": "CPP/77", "generation": "#include <iostream>\n#include <cmath>\n\nbool iscube(int a) {\n    if (a == 0) {\n        return true;\n    }\n    \n    int abs_a = std::abs(a);\n    for (int i = 0; i <= round(cbrt(abs_a)); ++i) {\n        if (i * i * i == abs_a) {\n            return true;\n        }\n    }\n    \n    return false;\n}\n\n"}
{"task_id": "CPP/78", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nint hex_key(string num) {\n    // Define a set of prime hexadecimal digits\n    const string primes = \"2357BD\";\n    \n    int count = 0;\n    \n    // Iterate through each character in the input string\n    for (char c : num) {\n        if (primes.find(c) != string::npos) {\n            ++count;  // Increment count if the digit is prime\n        }\n    }\n    \n    return count;\n}\n\n"}
{"task_id": "CPP/79", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\n// Function to convert decimal to binary\nstring decimal_to_binary(int decimal) {\n    if (decimal == 0) {\n        return \"db0db\";\n    }\n\n    string binary = \"\";\n    while (decimal > 0) {\n        int remainder = decimal % 2;\n        binary = to_string(remainder) + binary;\n        decimal /= 2;\n    }\n    \n    // Add the prefix and suffix\n    return \"db\" + binary + \"db\";\n}\n\n// Function to check the correctness of the conversion\nvoid check_conversion(int decimal, const string& expected) {\n    string result = decimal_to_binary(decimal);\n    cout << \"decimal: \" << decimal << \", expected: \" << expected << \", got: \" << result << endl;\n    if (result == expected) {\n        cout << \"Test passed.\" << endl;\n    } else {\n        cout << \"Test failed.\" << endl;\n    }\n}\n\n"}
{"task_id": "CPP/80", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_happy(string s) {\n    // Check if the string length is less than 3\n    if (s.length() < 3) return false;\n    \n    // Iterate through the string, checking every set of three consecutive characters\n    for (size_t i = 0; i <= s.length() - 3; ++i) {\n        // Check if any two out of the three consecutive characters are the same\n        if (s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]) {\n            return false;\n        }\n    }\n    \n    // If no three consecutive characters are the same, the string is happy\n    return true;\n}\n\n"}
{"task_id": "CPP/81", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\n// Function to convert GPA to letter grade\nstring gpa_to_letter(float gpa) {\n    if (gpa >= 4.0f) return \"A+\";\n    else if (gpa > 3.7f) return \"A\";\n    else if (gpa > 3.3f) return \"A-\";\n    else if (gpa > 3.0f) return \"B+\";\n    else if (gpa > 2.7f) return \"B\";\n    else if (gpa > 2.3f) return \"B-\";\n    else if (gpa > 2.0f) return \"C+\";\n    else if (gpa > 1.7f) return \"C\";\n    else if (gpa > 1.3f) return \"C-\";\n    else if (gpa > 1.0f) return \"D+\";\n    else if (gpa > 0.7f) return \"D\";\n    else if (gpa > 0.0f) return \"D-\";\n    else return \"E\";\n}\n\n// Function to convert vector of GPAs to vector of letter grades\nvector<string> numerical_letter_grade(vector<float> grades) {\n    vector<string> letter_grades;\n    for (float gpa : grades) {\n        letter_grades.push_back(gpa_to_letter(gpa));\n    }\n    return letter_grades;\n}\n\n// Function to check the correctness of the function\nvoid check() {\n    vector<float> test_grades = {4.0f, 3.0f, 1.7f, 2.0f, 3.5f};\n    vector<string> expected = {\"A+\", \"B\", \"C-\", \"C\", \"A-\"};\n    vector<string> result = numerical_letter_grade(test_grades);\n    \n    if (result == expected) {\n        cout << \"Test passed!\" << endl;\n    } else {\n        cout << \"Test failed. Expected: \";\n        for (const auto& grade : expected) {\n            cout << grade << \" \";\n        }\n        cout << \"\\nGot: \";\n        for (const auto& grade : result) {\n            cout << grade << \" \";\n        }\n        cout << endl;\n    }\n}\n\n"}
{"task_id": "CPP/82", "generation": "#include <iostream>\n#include <string>\n\n// Function to check if a number is prime\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    if (n == 2 || n == 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n\n    for (int i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0)\n            return false;\n    }\n    return true;\n}\n\n// Function to check if the length of a string is prime\nbool prime_length(string str) {\n    int len = str.length();\n    return is_prime(len);\n}\n\n"}
{"task_id": "CPP/83", "generation": "#include <iostream>\n#include <vector>\n\nint starts_one_ends(int n) {\n    if (n == 1) {\n        return 1; // Only one 1-digit number that starts and ends with 1\n    }\n\n    // For n > 1, calculate the count of numbers starting or ending with 1\n    int total_count = (9 * static_cast<int>(pow(10, n - 2)) + 8 * static_cast<int>(pow(10, n - 2)));\n\n    return total_count;\n}\n\n"}
{"task_id": "CPP/84", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring solve(int N) {\n    int sum = 0;\n    \n    // Calculate the sum of digits\n    while (N > 0) {\n        sum += N % 10;  // Add the last digit to the sum\n        N /= 10;        // Remove the last digit from N\n    }\n    \n    // Convert the sum to binary string\n    string binarySum = \"\";\n    if (sum == 0) {\n        return \"0\";\n    }\n    \n    while (sum > 0) {\n        binarySum = to_string(sum % 2) + binarySum;  // Prepend the remainder when divided by 2\n        sum /= 2;                                    // Divide the sum by 2\n    }\n    \n    return binarySum;\n}\n\n"}
{"task_id": "CPP/85", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint add(vector<int> lst) {\n    int sum = 0;\n    \n    // Iterate through the vector starting from index 1 (second element)\n    for (size_t i = 1; i < lst.size(); i += 2) {\n        if (lst[i] % 2 == 0) {  // Check if the element at an odd index is even\n            sum += lst[i];\n        }\n    }\n    \n    return sum;\n}\n\n"}
{"task_id": "CPP/86", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nstring sort_word(const string& word) {\n    string sorted_word = word;\n    sort(sorted_word.begin(), sorted_word.end());\n    return sorted_word;\n}\n\nstring anti_shuffle(string s) {\n    // Split the input string into words based on spaces\n    int start = 0;\n    for (int i = 0; i <= s.length(); ++i) {\n        if (i == s.length() || s[i] == ' ') {\n            // Process the word from start to i-1\n            string word = s.substr(start, i - start);\n            string sorted_word = sort_word(word);\n            \n            // Replace the original word with the sorted one\n            s.replace(start, i - start, sorted_word);\n            \n            // Update the start index for the next word\n            if (i < s.length()) {\n                start += sorted_word.length() + 1; // Skip the space\n            } else {\n                break;\n            }\n        }\n    }\n    \n    return s;\n}\n\n"}
{"task_id": "CPP/87", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to get the row and column indices where x appears\nvector<vector<int>> get_row(vector<vector<int>> lst, int x) {\n    vector<vector<int>> result;\n    \n    // Iterate through each row in the list\n    for (size_t i = 0; i < lst.size(); ++i) {\n        const auto& row = lst[i];\n        \n        // Iterate through each element in the current row\n        for (size_t j = 0; j < row.size(); ++j) {\n            if (row[j] == x) {\n                result.push_back({static_cast<int>(i), static_cast<int>(j)});\n            }\n        }\n    }\n\n    // Sort by rows in ascending order and then by columns in descending order within each row\n    sort(result.begin(), result.end(), [](const vector<int>& a, const vector<int>& b) {\n        if (a[0] == b[0]) return a[1] > b[1]; // Descending order for columns\n        return a[0] < b[0]; // Ascending order for rows\n    });\n\n    return result;\n}\n\n// Function to print the result for verification\nvoid print_result(const vector<vector<int>>& result) {\n    for (const auto& coord : result) {\n        cout << \"{\" << coord[0] << \", \" << coord[1] << \"} \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/88", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> sort_array(vector<int> array) {\n    // Check if the vector is empty or has only one element\n    if (array.empty() || array.size() == 1) {\n        return array;\n    }\n\n    int first = array.front();\n    int last = array.back();\n\n    // Calculate the sum of the first and last elements\n    int sum = first + last;\n\n    // Determine the sorting order based on the sum being odd or even\n    if (sum % 2 == 0) {\n        // Sort in descending order\n        vector<int> sorted_array(array);\n        sort(sorted_array.rbegin(), sorted_array.rend());\n        return sorted_array;\n    } else {\n        // Sort in ascending order\n        vector<int> sorted_array(array);\n        sort(sorted_array.begin(), sorted_array.end());\n        return sorted_array;\n    }\n}\n\n// Function to test the solution with provided examples\nvoid check() {\n    printf(\"{%s}\\n\", sort_array({}).empty() ? \"[]\" : \"{5, 4, 3, 2, 1}\"); // Example might be incorrect for empty vector\n    printf(\"{%d}\\n\", sort_array({5})[0]); // Should return {5}\n    printf(\"{%s}\\n\", sort_array({2, 4, 3, 0, 1, 5}).begin(), sort_array({2, 4, 3, 0, 1, 5}).end()); // Should return [0, 1, 2, 3, 4, 5]\n    printf(\"{%s}\\n\", sort_array({2, 4, 3, 0, 1, 5, 6}).rbegin(), sort_array({2, 4, 3, 0, 1, 5, 6}).rend()); // Should return [6, 5, 4, 3, 2, 1, 0]\n}\n\n"}
{"task_id": "CPP/89", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\n// Function to rotate a single character by 4 places\nchar rotateChar(char c) {\n    if (c >= 'a' && c <= 'z') {\n        return ((c - 'a' + 4) % 26) + 'a';\n    } else if (c >= 'A' && c <= 'Z') {\n        return ((c - 'A' + 4) % 26) + 'A';\n    }\n    // Non-alphabetic characters are not rotated\n    return c;\n}\n\n// Function to encrypt the string by rotating each character\nstring encrypt(string s) {\n    for (char &c : s) {\n        c = rotateChar(c);\n    }\n    return s;\n}\n\n"}
{"task_id": "CPP/90", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint next_smallest(vector<int> lst) {\n    if (lst.size() < 2) {\n        return -1; // Return a sentinel value to indicate no second smallest element\n    }\n\n    vector<int> unique_sorted_lst(lst.begin(), lst.end());\n    sort(unique_sorted_lst.begin(), unique_sorted_lst.end());\n\n    auto it = unique(unique_sorted_lst.begin(), unique_sorted_lst.end());\n    unique_sorted_lst.erase(it, unique_sorted_lst.end()); // Remove duplicates\n\n    if (unique_sorted_lst.size() < 2) {\n        return -1; // Return a sentinel value to indicate no second smallest element\n    }\n\n    return unique_sorted_lst[1]; // Return the second smallest element\n}\n\n"}
{"task_id": "CPP/91", "generation": "#include <iostream>\n#include <string>\n#include <vector>\n#include <sstream>\nusing namespace std;\n\nint is_bored(string S) {\n    // Split the string into sentences based on '.', '?' or '!'\n    vector<string> sentences;\n    stringstream ss(S);\n    string sentence;\n    \n    while (getline(ss, sentence, '.')) {\n        if (!sentence.empty()) {\n            sentences.push_back(sentence);\n        }\n    }\n    while (getline(ss, sentence, '?')) {\n        if (!sentence.empty()) {\n            sentences.push_back(sentence);\n        }\n    }\n    while (getline(ss, sentence, '!')) {\n        if (!sentence.empty()) {\n            sentences.push_back(sentence);\n        }\n    }\n\n    // Count the number of sentences that start with \"I\"\n    int boredom_count = 0;\n    for (const string& s : sentences) {\n        if (s.find(\"I \") == 0 || s.find(\"I.\") == 0 || s.find(\"I?\") == 0 || s.find(\"I!\") == 0) {\n            ++boredom_count;\n        }\n    }\n\n    return boredom_count;\n}\n\n"}
{"task_id": "CPP/92", "generation": "#include <iostream>\nusing namespace std;\n\nbool is_integer(float num) {\n    return floor(num) == num;\n}\n\nbool any_int(float a, float b, float c) {\n    // Check if all numbers are integers\n    if (is_integer(a) && is_integer(b) && is_integer(c)) {\n        // Check if one of the numbers is equal to the sum of the other two\n        return (a == b + c) || (b == a + c) || (c == a + b);\n    } else {\n        return false;\n    }\n}\n\n"}
{"task_id": "CPP/93", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to encode the message\nstring encode(string message) {\n    // Define a mapping for vowels to their shifted counterparts\n    string vowel_shift = \"acgkqwACGKQW\";\n    \n    // Iterate through each character in the message\n    for (char &c : message) {\n        if (isalpha(c)) {\n            // Check if the character is a vowel and replace it with the corresponding shifted vowel\n            if (c == 'a' || c == 'A') c = 'c';\n            else if (c == 'e' || c == 'E') c = 'g';\n            else if (c == 'i' || c == 'I') c = 'k';\n            else if (c == 'o' || c == 'O') c = 'q';\n            else if (c == 'u' || c == 'U') c = 'w';\n            \n            // Swap the case of the character\n            else {\n                c ^= 32; // Toggle between uppercase and lowercase\n            }\n        }\n    }\n    \n    return message;\n}\n\n"}
{"task_id": "CPP/94", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\nint find_largest_prime_and_sum_digits(vector<int> lst) {\n    int max_prime = -1;\n    for (int num : lst) {\n        if (is_prime(num)) {\n            max_prime = max(max_prime, num);\n        }\n    }\n\n    if (max_prime == -1) return 0;\n\n    string prime_str = to_string(max_prime);\n    int sum_of_digits = 0;\n    for (char digit : prime_str) {\n        sum_of_digits += digit - '0';\n    }\n\n    return sum_of_digits;\n}\n\n"}
{"task_id": "CPP/95", "generation": "#include <iostream>\n#include <string>\n#include <map>\n\nusing namespace std;\n\nbool check_dict_case(map<string, string> dict) {\n    // Check if the dictionary is empty\n    if (dict.empty()) {\n        return false;\n    }\n\n    bool all_lower = true;\n    bool all_upper = true;\n\n    for (const auto& pair : dict) {\n        // Check if the key is not in lowercase or uppercase\n        if (!pair.first.empty() && !islower(pair.first[0])) {\n            all_lower = false;\n        }\n        if (!pair.first.empty() && !isupper(pair.first[0])) {\n            all_upper = false;\n        }\n\n        // If both conditions are false, break the loop early\n        if (!all_lower && !all_upper) {\n            break;\n        }\n    }\n\n    return all_lower || all_upper;\n}\n\n"}
{"task_id": "CPP/96", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Helper function to check if a number is prime\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    for (int i = 2; i * i <= num; ++i) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\n// Function to generate a vector of prime numbers less than n\nvector<int> count_up_to(int n) {\n    vector<int> primes;\n    for (int i = 2; i < n; ++i) {\n        if (is_prime(i)) {\n            primes.push_back(i);\n        }\n    }\n    return primes;\n}\n\n// Function to test the count_up_to function\nvoid test_count_up_to() {\n    assert(count_up_to(5) == vector<int>({2, 3}));\n    assert(count_up_to(11) == vector<int>({2, 3, 5, 7}));\n    assert(count_up_to(0).empty());\n    assert(count_up_to(20) == vector<int>({2, 3, 5, 7, 11, 13, 17, 19}));\n    assert(count_up_to(1).empty());\n    assert(count_up_to(18) == vector<int>({2, 3, 5, 7, 11, 13, 17}));\n\n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/97", "generation": "#include <iostream>\nusing namespace std;\n\nint multiply(int a, int b) {\n    // Extract the unit digit of both numbers\n    int unit_digit_a = abs(a % 10);\n    int unit_digit_b = abs(b % 10);\n\n    // Multiply the unit digits and return the result\n    return unit_digit_a * unit_digit_b;\n}\n\n"}
{"task_id": "CPP/98", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint count_upper(const string& s) {\n    int count = 0;\n    for (size_t i = 0; i < s.length(); i += 2) { // Iterate through even indices\n        char c = s[i];\n        if (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n            count++;\n        }\n    }\n    return count;\n}\n\n"}
{"task_id": "CPP/99", "generation": "#include <iostream>\n#include <cmath>\n#include <string>\nusing namespace std;\n\nint closest_integer(string value) {\n    // Convert string to double\n    double num = stod(value);\n    \n    // Determine the two nearest integers\n    int lower_int = static_cast<int>(floor(num));\n    int upper_int = static_cast<int>(ceil(num));\n    \n    // Check which integer is closer or if they are equidistant, round away from zero\n    if (num - lower_int == upper_int - num) {\n        return abs(num) > abs(lower_int) ? upper_int : lower_int;\n    } else {\n        return num - lower_int < 0.5 ? lower_int : upper_int;\n    }\n}\n\n"}
{"task_id": "CPP/100", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> make_a_pile(int n) {\n    vector<int> pile;\n    int current_stones = n;\n\n    for (int i = 0; i < n; ++i) {\n        pile.push_back(current_stones);\n        // Determine the next number of stones\n        if (current_stones % 2 == 0) {\n            current_stones += 2; // Next even number\n        } else {\n            current_stones += 2; // Next odd number\n        }\n    }\n\n    return pile;\n}\n\n// Function to check the correctness of the solution\nvoid check_solution() {\n    vector<int> result1 = make_a_pile(3);\n    assert(result1 == vector<int>({3, 5, 7}));\n\n    vector<int> result2 = make_a_pile(4);\n    assert(result2 == vector<int>({4, 6, 8, 10}));\n\n    vector<int> result3 = make_a_pile(1);\n    assert(result3 == vector<int>({1, 3}));\n\n    cout << \"All test cases passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/101", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nvector<string> words_string(string s) {\n    vector<string> result;\n    stringstream ss(s);\n    string word;\n\n    while (getline(ss, word, ',')) {  // Split by commas first\n        stringstream wordStream(word);  // Create a new stream for the current word\n        while (wordStream >> word) {  // Extract words from the current word\n            result.push_back(word);\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/102", "generation": "#include <iostream>\nusing namespace std;\n\nint choose_num(int x, int y) {\n    // Ensure x is less than or equal to y\n    if (x > y) {\n        return -1;\n    }\n\n    // Start from the end of the range and check for the largest even number\n    for (int i = y; i >= x; --i) {\n        if (i % 2 == 0) {\n            return i;\n        }\n    }\n\n    // If no even number is found, return -1\n    return -1;\n}\n\n// Function to test the choose_num function with some examples\nvoid test() {\n    cout << \"choose_num(12, 15): \" << choose_num(12, 15) << endl; // Should output 14\n    cout << \"choose_num(13, 12): \" << choose_num(13, 12) << endl; // Should output -1\n    cout << \"choose_num(10, 20): \" << choose_num(10, 20) << endl; // Should output 20\n    cout << \"choose_num(21, 25): \" << choose_num(21, 25) << endl; // Should output 24\n}\n\n"}
{"task_id": "CPP/103", "generation": "#include <stdio.h>\n#include <math.h>\n#include <string>\nusing namespace std;\n\nstring rounded_avg(int n, int m) {\n    // Check if n is greater than m\n    if (n > m) {\n        return \"-1\";\n    }\n\n    // Calculate the sum of integers from n to m\n    long long sum = 0;\n    for (int i = n; i <= m; ++i) {\n        sum += i;\n    }\n\n    // Calculate the average and round it down\n    int avg = sum / (m - n + 1);\n\n    // Convert the rounded average to binary string\n    string binary = \"\";\n    if (avg == 0) {\n        binary = \"0\";\n    } else {\n        while (avg > 0) {\n            binary = to_string(avg % 2) + binary;\n            avg /= 2;\n        }\n    }\n\n    return binary;\n}\n\n"}
{"task_id": "CPP/104", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nbool hasEvenDigit(int num) {\n    while (num > 0) {\n        int digit = num % 10;\n        if (digit % 2 == 0) {\n            return true; // Found an even digit\n        }\n        num /= 10;\n    }\n    return false; // No even digits found\n}\n\nvector<int> unique_digits(vector<int> x) {\n    vector<int> result;\n\n    for (int num : x) {\n        if (!hasEvenDigit(num)) {\n            result.push_back(num);\n        }\n    }\n\n    sort(result.begin(), result.end());\n    return result;\n}\n\n"}
{"task_id": "CPP/105", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to convert a digit to its corresponding name\nstring num_to_word(int n) {\n    map<int, string> digit_names = {\n        {1, \"One\"}, {2, \"Two\"}, {3, \"Three\"}, {4, \"Four\"},\n        {5, \"Five\"}, {6, \"Six\"}, {7, \"Seven\"}, {8, \"Eight\"}, {9, \"Nine\"}\n    };\n    return digit_names[n];\n}\n\n// Function to process the vector as per the problem statement\nvector<string> by_length(vector<int> arr) {\n    // Filter out numbers that are not between 1 and 9\n    vector<int> filtered_arr;\n    for (int num : arr) {\n        if (num >= 1 && num <= 9) {\n            filtered_arr.push_back(num);\n        }\n    }\n\n    // Sort the filtered array\n    sort(filtered_arr.begin(), filtered_arr.end());\n\n    // Reverse the sorted array\n    reverse(filtered_arr.begin(), filtered_arr.end());\n\n    // Convert each number to its corresponding name and store in a vector of strings\n    vector<string> result;\n    for (int num : filtered_arr) {\n        result.push_back(num_to_word(num));\n    }\n\n    return result;\n}\n\n// Function to check the correctness of the by_length function\nvoid check() {\n    vector<int> arr1 = {2, 1, 1, 4, 5, 8, 2, 3};\n    vector<string> expected1 = {\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"};\n    assert(by_length(arr1) == expected1);\n\n    vector<int> arr2 = {};\n    vector<string> expected2 = {};\n    assert(by_length(arr2) == expected2);\n\n    vector<int> arr3 = {1, -1, 55};\n    vector<string> expected3 = {\"One\"};\n    assert(by_length(arr3) == expected3);\n\n    printf(\"All test cases passed.\\n\");\n}\n\n"}
{"task_id": "CPP/106", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Function to compute the factorial of a number\nint factorial(int num) {\n    if (num == 0 || num == 1)\n        return 1;\n    int fact = 1;\n    for (int i = 2; i <= num; ++i) {\n        fact *= i;\n    }\n    return fact;\n}\n\n// Function to compute the sum of numbers from 1 to a number\nint sumTo(int num) {\n    return (num * (num + 1)) / 2;\n}\n\nvector<int> f(int n) {\n    vector<int> result(n);\n    \n    for (int i = 0; i < n; ++i) {\n        if ((i + 1) % 2 == 0) { // Check if the index is even\n            result[i] = factorial(i + 1); // Factorial of (i+1)\n        } else { // The index is odd\n            result[i] = sumTo(i + 1); // Sum from 1 to (i+1)\n        }\n    }\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/107", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nbool is_palindrome(int num) {\n    string str = to_string(num);\n    int left = 0;\n    int right = str.length() - 1;\n    \n    while (left < right) {\n        if (str[left] != str[right]) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n    return true;\n}\n\nvector<int> even_odd_palindrome(int n) {\n    vector<int> result(2, 0); // Initialize with two elements for even and odd counts\n    for (int i = 1; i <= n; ++i) {\n        if (is_palindrome(i)) {\n            if (i % 2 == 0) {\n                result[0]++; // Even palindrome count\n            } else {\n                result[1]++; // Odd palindrome count\n            }\n        }\n    }\n    return result;\n}\n\n"}
{"task_id": "CPP/108", "generation": "#include <vector>\nusing namespace std;\n\n// Helper function to calculate the sum of signed digits of an integer.\nint sum_of_digits(int x) {\n    if (x == 0) {\n        return 0;\n    } else if (x < 0) {\n        int result = -1 * (x % 10);\n        return result + sum_of_digits(x / 10);\n    } else {\n        return x % 10 + sum_of_digits(x / 10);\n    }\n}\n\n// Main function to count the number of elements with a sum of digits > 0.\nint count_nums(vector<int> n) {\n    int count = 0;\n    for (int num : n) {\n        if (sum_of_digits(num) > 0) {\n            count++;\n        }\n    }\n    return count;\n}\n\n// Function to check the correctness of the count_nums function.\nvoid check() {\n    assert(count_nums({}) == 0);\n    assert(count_nums({-1, 11, -11}) == 1);\n    assert(count_nums({1, 1, 2}) == 3);\n    cout << \"All test cases passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/109", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool move_one_ball(vector<int> arr) {\n    int n = arr.size();\n    \n    // Check for empty vector\n    if (n == 0) return true;\n    \n    // Find the index where the array is not sorted\n    int discontinuity_index = -1;\n    for (int i = 0; i < n - 1; ++i) {\n        if (arr[i] > arr[i + 1]) {\n            discontinuity_index = i;\n            break;\n        }\n    }\n    \n    // If no such index found, the array is already sorted\n    if (discontinuity_index == -1) return true;\n    \n    // Perform a right shift operation and check if it becomes sorted\n    vector<int> shifted_arr(arr.begin() + discontinuity_index + 1, arr.end());\n    shifted_arr.insert(shifted_arr.end(), arr.begin(), arr.begin() + discontinuity_index + 1);\n    \n    // Check if the shifted array is sorted\n    for (int i = 0; i < n - 1; ++i) {\n        if (shifted_arr[i] > shifted_arr[i + 1]) return false;\n    }\n    \n    return true;\n}\n\n// Function to test the move_one_ball function\nvoid test() {\n    vector<int> arr1 = {3, 4, 5, 1, 2};\n    cout << boolalpha << move_one_ball(arr1) << endl; // Expected: true\n    \n    vector<int> arr2 = {3, 5, 4, 1, 2};\n    cout << boolalpha << move_one_ball(arr2) << endl; // Expected: false\n}\n\n"}
{"task_id": "CPP/110", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nstring exchange(vector<int> lst1, vector<int> lst2) {\n    // Check if there are any even numbers in lst1 or enough odd numbers in lst2 to replace all odd numbers in lst1\n    bool has_even_in_lst1 = false;\n    for (int num : lst1) {\n        if (num % 2 == 0) {\n            has_even_in_lst1 = true;\n            break;\n        }\n    }\n\n    int odd_count_in_lst2 = 0;\n    for (int num : lst2) {\n        if (num % 2 != 0) {\n            odd_count_in_lst2++;\n        }\n    }\n\n    // Determine the result based on the conditions\n    if (has_even_in_lst1 || (odd_count_in_lst2 >= lst1.size() - has_even_in_lst1)) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n\n"}
{"task_id": "CPP/111", "generation": "#include <iostream>\n#include <string>\n#include <map>\n#include <vector>\nusing namespace std;\n\nmap<char, int> histogram(string test) {\n    map<char, int> charCount;\n    \n    // Count occurrences of each character\n    for (char c : test) {\n        if (c != ' ') {  // Ignore spaces\n            charCount[c]++;\n        }\n    }\n\n    // Find the maximum count\n    int maxCount = 0;\n    for (const auto& pair : charCount) {\n        if (pair.second > maxCount) {\n            maxCount = pair.second;\n        }\n    }\n\n    // Collect characters with the highest frequency\n    map<char, int> result;\n    for (const auto& pair : charCount) {\n        if (pair.second == maxCount) {\n            result.insert(pair);\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/112", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to check if a string is a palindrome\nbool is_palindrome(const string& str) {\n    int left = 0;\n    int right = str.size() - 1;\n    while (left < right) {\n        if (str[left] != str[right]) {\n            return false;\n        }\n        ++left;\n        --right;\n    }\n    return true;\n}\n\n// Function to reverse delete characters\nvector<string> reverse_delete(string s, string c) {\n    // Remove all characters in s that are present in c\n    for (char ch : c) {\n        s.erase(remove(s.begin(), s.end(), ch), s.end());\n    }\n\n    // Check if the resulting string is a palindrome\n    bool result = is_palindrome(s);\n\n    // Return the result as a vector containing the modified string and the boolean\n    return {s, (result ? \"True\" : \"False\")};\n}\n\n"}
{"task_id": "CPP/113", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<string> odd_count(vector<string> lst) {\n    vector<string> result;\n    \n    for (const auto& str : lst) {\n        int count = 0;\n        \n        // Count the number of odd digits in the string\n        for (char c : str) {\n            if ((c - '0') % 2 != 0) {\n                count++;\n            }\n        }\n\n        // Construct the result string\n        string output = \"the number of odd elements \";\n        output += to_string(count);\n        output += \"n the str\";\n        output += to_string(count);\n        output += \"ng \";\n        output += to_string(count);\n        output += \" of the \";\n        output += to_string(count);\n        output += \"nput.\";\n        \n        result.push_back(output);\n    }\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/114", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nlong long minSubArraySum(vector<long long> nums) {\n    if (nums.empty()) return 0; // Handle empty vector case\n\n    long long current_min = nums[0];\n    long long global_min = nums[0];\n\n    for (size_t i = 1; i < nums.size(); ++i) {\n        // Update the current minimum sum ending at position i\n        current_min = min(nums[i], current_min + nums[i]);\n        \n        // Update the global minimum sum found so far\n        if (current_min < global_min) {\n            global_min = current_min;\n        }\n    }\n\n    return global_min;\n}\n\n"}
{"task_id": "CPP/115", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint max_fill(vector<vector<int>> grid, int capacity) {\n    int total_lowerings = 0;\n    \n    // Iterate through each well (row)\n    for (const auto& row : grid) {\n        int water_units = 0;\n        \n        // Count the number of units of water in the current well\n        for (int unit : row) {\n            if (unit == 1) {\n                ++water_units;\n            }\n        }\n        \n        // Calculate the number of times the bucket needs to be lowered\n        total_lowerings += (water_units + capacity - 1) / capacity;\n    }\n    \n    return total_lowerings;\n}\n\n"}
{"task_id": "CPP/116", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\n// Function to count the number of ones in the binary representation of a number\nint count_ones(int n) {\n    int count = 0;\n    while (n > 0) {\n        count += n & 1; // Check if the least significant bit is set\n        n >>= 1;       // Right shift to check the next bit\n    }\n    return count;\n}\n\n// Function to sort the array based on the number of ones in binary representation and decimal value\nstd::vector<int> sort_array(std::vector<int> arr) {\n    std::sort(arr.begin(), arr.end(), [](int a, int b) {\n        int count_a = count_ones(a);\n        int count_b = count_ones(b);\n        \n        if (count_a == count_b) {\n            return a < b; // Sort by decimal value if the number of ones is the same\n        }\n        return count_a < count_b; // Sort by the number of ones in binary representation\n    });\n    \n    return arr;\n}\n\n// Function to print the vector for verification\nvoid print_array(const std::vector<int>& arr) {\n    for (int num : arr) {\n        std::cout << num << \" \";\n    }\n    std::cout << std::endl;\n}\n\n"}
{"task_id": "CPP/117", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nbool is_consonant(char c) {\n    return std::tolower(c) >= 'a' && std::tolower(c) <= 'z' && \n           std::string(\"aeiou\").find(std::tolower(c)) == std::string::npos;\n}\n\nstd::vector<std::string> select_words(const std::string& s, int n) {\n    if (s.empty()) {\n        return {};\n    }\n\n    std::vector<std::string> words;\n    std::istringstream iss(s);\n    std::string word;\n\n    while (iss >> word) {\n        int consonant_count = 0;\n        for (char c : word) {\n            if (is_consonant(c)) {\n                ++consonant_count;\n            }\n        }\n\n        if (consonant_count == n) {\n            words.push_back(word);\n        }\n    }\n\n    return words;\n}\n\n"}
{"task_id": "CPP/118", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nbool isVowel(char c) {\n    return c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' ||\n           c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U';\n}\n\nstring get_closest_vowel(string word) {\n    int n = word.length();\n    \n    // Start from the second last character and move left\n    for (int i = n - 2; i > 0; --i) {\n        if (isVowel(word[i]) && isalpha(word[i-1]) && !isalpha(word[i+1])) {\n            return string(1, word[i]);\n        }\n    }\n    \n    return \"\";\n}\n\n"}
{"task_id": "CPP/119", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nbool is_balanced(const string& s) {\n    int balance = 0;\n    for (char c : s) {\n        if (c == '(') {\n            balance += 1;\n        } else {\n            balance -= 1;\n        }\n        if (balance < 0) {\n            return false;\n        }\n    }\n    return balance == 0;\n}\n\nstring match_parens(vector<string> lst) {\n    // Check both possible concatenations\n    if (is_balanced(lst[0] + lst[1]) || is_balanced(lst[1] + lst[0])) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\n\n"}
{"task_id": "CPP/120", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> maximum(vector<int> arr, int k) {\n    // Sort the array in descending order\n    sort(arr.begin(), arr.end(), greater<int>());\n    \n    // If k is 0 or negative, return an empty vector\n    if (k <= 0 || k > arr.size()) {\n        return {};\n    }\n    \n    // Slice the first k elements from the sorted array\n    vector<int> result(arr.begin(), arr.begin() + k);\n    \n    // Sort the resulting vector in ascending order as required\n    sort(result.begin(), result.end());\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/121", "generation": "#include <vector>\nusing namespace std;\n\nint solution(vector<int> lst) {\n    int sum = 0;\n    for (size_t i = 0; i < lst.size(); ++i) {\n        // Check if the index is even and the element at that position is odd\n        if (i % 2 == 0 && lst[i] % 2 != 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n\n// Function to test the solution with provided examples\nvoid check_solution() {\n    assert(solution({5, 8, 7, 1}) == 12);\n    assert(solution({3, 3, 3, 3, 3}) == 9);\n    assert(solution({30, 13, 24, 321}) == 0);\n}\n\n"}
{"task_id": "CPP/122", "generation": "#include <vector>\nusing namespace std;\n\nint add_elements(vector<int> arr, int k) {\n    int sum = 0;\n    \n    // Iterate through the first k elements of the array\n    for (int i = 0; i < k; ++i) {\n        // Check if the element has at most two digits\n        if (arr[i] >= 0 && arr[i] < 100) {\n            sum += arr[i];\n        }\n    }\n    \n    return sum;\n}\n"}
{"task_id": "CPP/123", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n// Function to generate and return the odd numbers in the Collatz sequence of n.\nvector<int> get_odd_collatz(int n) {\n    vector<int> result;\n    \n    // Generate the Collatz sequence until it reaches 1\n    while (n != 1) {\n        if (n % 2 == 0) {\n            n /= 2;  // If n is even, divide by 2\n        } else {\n            result.push_back(n);  // If n is odd, add to the result vector\n            n = 3 * n + 1;  // Apply the Collatz transformation\n        }\n    }\n    \n    // Add the final number (which is 1) to the result vector\n    result.push_back(1);\n    \n    // Sort the result vector in increasing order\n    sort(result.begin(), result.end());\n    \n    return result;\n}\n\n// Function to test the get_odd_collatz function with some examples.\nvoid test_get_odd_collatz() {\n    cout << \"Testing get_odd_collatz...\" << endl;\n    assert(get_odd_collatz(5) == vector<int>({1, 5}));\n    assert(get_odd_collatz(7) == vector<int>({1, 7, 11, 22}));\n    assert(get_odd_collatz(1) == vector<int>({1}));\n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/124", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <vector>\n\nbool valid_date(const std::string& date) {\n    // Split the date string into month, day, and year\n    std::istringstream iss(date);\n    std::string token;\n    std::vector<std::string> parts;\n    while (std::getline(iss, token, '-')) {\n        parts.push_back(token);\n    }\n\n    if (parts.size() != 3) return false; // Ensure the date is in mm-dd-yyyy format\n\n    int month = std::stoi(parts[0]);\n    int day = std::stoi(parts[1]);\n    int year = std::stoi(parts[2]);\n\n    // Check if month, day, and year are within valid ranges\n    if (month < 1 || month > 12) return false; // Month should be between 1 and 12\n    if (day < 1 || day > 31) return false; // Day should be between 1 and 31\n\n    // Check for valid days based on the month\n    switch (month) {\n        case 4:\n        case 6:\n        case 9:\n        case 11: // Months with 30 days\n            if (day > 30) return false;\n            break;\n        case 2: // February, check for leap year\n            if ((year % 4 == 0 && year % 100 != 0) || (year % 400 == 0)) {\n                if (day > 29) return false; // Leap year, max 29 days\n            } else {\n                if (day > 28) return false; // Not a leap year, max 28 days\n            }\n            break;\n        default: // Months with 31 days\n            if (day > 31) return false;\n    }\n\n    return true; // All checks passed\n}\n\n"}
{"task_id": "CPP/125", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nvector<string> split_words(string txt) {\n    if (txt.find(' ') != string::npos) {\n        // Split on whitespace\n        vector<string> words;\n        size_t start = 0, end = 0;\n        while ((end = txt.find(' ', start)) != string::npos) {\n            words.push_back(txt.substr(start, end - start));\n            start = end + 1;\n        }\n        if (start < txt.length()) {\n            words.push_back(txt.substr(start));\n        }\n        return words;\n    } else if (txt.find(',') != string::npos) {\n        // Split on commas\n        vector<string> words;\n        size_t start = 0, end = 0;\n        while ((end = txt.find(',', start)) != string::npos) {\n            words.push_back(txt.substr(start, end - start));\n            start = end + 1;\n        }\n        if (start < txt.length()) {\n            words.push_back(txt.substr(start));\n        }\n        return words;\n    } else {\n        // Count lowercase letters with odd ordinal values\n        int count = 0;\n        for (char c : txt) {\n            if (islower(c) && (c - 'a') % 2 == 1) {\n                count++;\n            }\n        }\n        vector<string> result;\n        result.push_back(to_string(count));\n        return result;\n    }\n}\n\n"}
{"task_id": "CPP/126", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nbool is_sorted(vector<int> lst) {\n    // Check if the list is already sorted or not\n    bool sorted = is_sorted(lst.begin(), lst.end());\n    \n    // If not sorted, return false immediately\n    if (!sorted) return false;\n    \n    // Count occurrences of each number in the vector\n    for (int i = 0; i < lst.size(); ++i) {\n        int count = 1;\n        while (i + 1 < lst.size() && lst[i] == lst[i + 1]) {\n            count++;\n            i++;\n        }\n        // If any number appears more than twice, return false\n        if (count > 2) return false;\n    }\n    \n    // If both conditions are met, return true\n    return true;\n}\n\n"}
{"task_id": "CPP/127", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\nstd::string intersection(std::vector<int> interval1, std::vector<int> interval2) {\n    int start_max = std::max(interval1[0], interval2[0]);\n    int end_min = std::min(interval1[1], interval2[1]);\n\n    // Check for no intersection\n    if (start_max > end_min) return \"NO\";\n\n    int length_of_intersection = end_min - start_max + 1;\n\n    // Check if the length is a prime number\n    if (is_prime(length_of_intersection)) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n\n"}
{"task_id": "CPP/128", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint prod_signs(vector<int> arr) {\n    if (arr.empty()) {\n        return -32768;\n    }\n\n    int sign_product = 1;\n    int magnitude_sum = 0;\n\n    for (int num : arr) {\n        // Calculate the product of signs\n        if (num < 0) {\n            sign_product *= -1;\n        } else if (num == 0) {\n            sign_product = 0; // If any number is zero, the product will be zero\n            break;\n        }\n\n        // Calculate the sum of magnitudes\n        magnitude_sum += abs(num);\n    }\n\n    return sign_product * magnitude_sum;\n}\n\n// Function to test the prod_signs function with provided examples\nvoid check() {\n    cout << \"Checking examples:\" << endl;\n    assert(prod_signs({1, 2, 2, -4}) == -9); // (-1) * (1 + 2 + 2 + 4) = -9\n    assert(prod_signs({0, 1}) == 0);         // 0 * (abs(0) + abs(1)) = 0\n    assert(prod_signs({}) == -32768);        // Empty vector case\n\n    cout << \"All checks passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/129", "generation": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <set>\n#include <algorithm>\n\nusing namespace std;\n\nbool is_valid(int x, int y, int n) {\n    return 0 <= x && x < n && 0 <= y && y < n;\n}\n\nvector<int> minPath(const vector<vector<int>>& grid, int k) {\n    int n = grid.size();\n    vector<pair<int, pair<int, int>>> directions = {{0, {1, 0}}, {1, {0, 1}}, {-1, {0, -1}}, {0, {-1, 0}}};\n    \n    queue<vector<int>> q;\n    set<pair<int, pair<int, int>>> visited;\n    \n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            q.push({grid[i][j], i, j});\n            visited.insert({grid[i][j], {i, j}});\n        }\n    }\n    \n    while (!q.empty()) {\n        if (k == 1) break;\n        \n        int size = q.size();\n        for (int _ = 0; _ < size; ++_) {\n            auto path = q.front(); q.pop();\n            int val = path[0], x = path[1], y = path[2];\n            \n            for (auto& dir : directions) {\n                int nx = x + dir.second.first, ny = y + dir.second.second;\n                if (is_valid(nx, ny, n) && visited.find({grid[nx][ny], {nx, ny}}) == visited.end()) {\n                    q.push({val * 100000 + grid[nx][ny], nx, ny});\n                    visited.insert({val * 100000 + grid[nx][ny], {nx, ny}});\n                }\n            }\n        }\n        k--;\n    }\n    \n    vector<int> result;\n    while (!q.empty()) {\n        auto path = q.front(); q.pop();\n        for (int i = 0; i < path[0]; ++i) {\n            result.push_back(path[i] % 100000);\n        }\n    }\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/130", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> tri(int n) {\n    if (n == 0) return {1};\n    else if (n == 1) return {3};\n\n    vector<int> sequence = {1, 3};\n    for (int i = 2; i <= n; ++i) {\n        int next_value;\n        if (i % 2 == 0) {\n            next_value = 1 + (i / 2);\n        } else {\n            next_value = sequence[i - 1] + sequence[i - 2];\n            // Note: We don't need to calculate the value at `i + 1` here as it's not used in the current calculation.\n        }\n        sequence.push_back(next_value);\n    }\n\n    return {sequence.begin(), sequence.begin() + n + 1};\n}\n\n"}
{"task_id": "CPP/131", "generation": "#include <iostream>\nusing namespace std;\n\nint digits(int n) {\n    int product = 1;\n    bool hasOddDigit = false;\n\n    while (n > 0) {\n        int digit = n % 10; // Get the last digit of n\n        if (digit % 2 != 0) { // Check if the digit is odd\n            product *= digit; // Multiply it to the product\n            hasOddDigit = true;\n        }\n        n /= 10; // Remove the last digit from n\n    }\n\n    return hasOddDigit ? product : 0;\n}\n\n"}
{"task_id": "CPP/132", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_nested(string str) {\n    stack<char> brackets_stack;\n    bool nested_found = false;\n\n    for (char bracket : str) {\n        if (bracket == '[') {\n            brackets_stack.push(bracket);\n        } else if (bracket == ']') {\n            if (!brackets_stack.empty()) {\n                brackets_stack.pop();\n                // Check if there are still unmatched opening brackets\n                if (!brackets_stack.empty()) {\n                    nested_found = true;\n                }\n            } else {\n                continue;  // Ignore unmatched closing bracket\n            }\n        }\n    }\n\n    return nested_found;\n}\n\n"}
{"task_id": "CPP/133", "generation": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nint sum_squares(vector<float> lst) {\n    int sum = 0;\n    \n    for (float num : lst) {\n        // Round up to the nearest integer\n        float ceil_num = ceil(num);\n        \n        // Add the square of the rounded number to the sum\n        sum += static_cast<int>(ceil_num * ceil_num);\n    }\n    \n    return sum;\n}\n\n"}
{"task_id": "CPP/134", "generation": "#include <iostream>\n#include <string>\n#include <cctype> // For isalpha and isspace functions\n\nbool check_if_last_char_is_a_letter(const std::string& txt) {\n    if (txt.empty()) {\n        return false;\n    }\n\n    char lastChar = txt.back();\n\n    // Check if the last character is an alphabetical letter\n    if (!std::isalpha(lastChar)) {\n        return false;\n    }\n\n    // Check if the string has only one character or the second-to-last character is not alphanumeric\n    if (txt.size() == 1 || !std::isalnum(txt[txt.size() - 2])) {\n        return true;\n    } else {\n        return false;\n    }\n}\n\n"}
{"task_id": "CPP/135", "generation": "#include <vector>\nusing namespace std;\n\nint can_arrange(vector<int> arr) {\n    if (arr.size() <= 1) return -1;\n    \n    for (size_t i = 1; i < arr.size(); ++i) {\n        if (arr[i] < arr[i - 1]) {\n            return static_cast<int>(i);\n        }\n    }\n    return -1;\n}\n\n"}
{"task_id": "CPP/136", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> largest_smallest_integers(vector<int> lst) {\n    vector<int> result = {0, 0}; // Initialize result with default values\n    \n    int max_negative = INT_MIN; // Initialize to the smallest possible integer\n    bool has_negative = false;\n    \n    int min_positive = INT_MAX; // Initialize to the largest possible integer\n    bool has_positive = false;\n\n    for (int num : lst) {\n        if (num < 0) {\n            has_negative = true;\n            max_negative = max(max_negative, num);\n        } else if (num > 0) {\n            has_positive = true;\n            min_positive = min(min_positive, num);\n        }\n    }\n\n    // Update result based on whether negative or positive numbers were found\n    if (has_negative) {\n        result[0] = max_negative;\n    }\n    if (has_positive) {\n        result[1] = min_positive;\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/137", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <boost/any.hpp>\n\nusing namespace std;\n\nboost::any compare_one(boost::any a, boost::any b) {\n    // Check if both are integers or floats\n    if (a.type() == typeid(int) && b.type() == typeid(int)) {\n        int val_a = boost::any_cast<int>(a);\n        int val_b = boost::any_cast<int>(b);\n        return (val_a > val_b) ? a : ((val_b > val_a) ? b : boost::any());\n    } else if (a.type() == typeid(float) && b.type() == typeid(float)) {\n        float val_a = boost::any_cast<float>(a);\n        float val_b = boost::any_cast<float>(b);\n        return (val_a > val_b) ? a : ((val_b > val_a) ? b : boost::any());\n    } else if (a.type() == typeid(string) && b.type() == typeid(string)) {\n        string str_a = boost::any_cast<string>(a);\n        string str_b = boost::any_cast<string>(b);\n\n        // Convert strings to floats and compare\n        float num_a = stof(str_a.replace(str_a.find(','), 1, \".\"));\n        float num_b = stof(str_b.replace(str_b.find(','), 1, \".\"));\n\n        return (num_a > num_b) ? a : ((num_b > num_a) ? b : boost::any());\n    } else {\n        // Mixed types or other cases\n        return boost::any();\n    }\n}\n"}
{"task_id": "CPP/138", "generation": "#include <iostream>\n#include <vector>\n\nbool is_equal_to_sum_even(int n) {\n    // Since we need exactly 4 positive even numbers, the smallest sum of such numbers is 2 + 2 + 2 + 2 = 8.\n    // Any number less than 8 cannot be expressed as the sum of exactly 4 positive even numbers.\n    if (n < 8) {\n        return false;\n    }\n    // If n is even and greater than or equal to 8, it can always be written as the sum of 4 even numbers.\n    return n % 2 == 0;\n}\n\n"}
{"task_id": "CPP/139", "generation": "#include <iostream>\n\n// Function to calculate factorial of a number\nlong long factorial(long long num) {\n    if (num == 0 || num == 1)\n        return 1;\n    else\n        return num * factorial(num - 1);\n}\n\n// Function to calculate Brazilian factorial\nlong long special_factorial(int n) {\n    long long result = 1;\n    for (int i = n; i > 0; --i) {\n        result *= factorial(i);\n    }\n    return result;\n}\n\n"}
{"task_id": "CPP/140", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring fix_spaces(string text) {\n    string result = \"\";\n    int space_count = 0;\n    \n    for (char ch : text) {\n        if (ch == ' ') {\n            space_count++;\n        } else {\n            if (space_count > 2) {\n                result += '-';\n            } else if (space_count >= 1) {\n                result.append(space_count, '_');\n            }\n            space_count = 0;\n            result += ch;\n        }\n    }\n\n    // Handle trailing spaces\n    if (space_count > 2) {\n        result += '-';\n    } else if (space_count >= 1) {\n        result.append(space_count, '_');\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/141", "generation": "#include <iostream>\n#include <string>\n#include <regex>\n\nusing namespace std;\n\nstring file_name_check(string file_name) {\n    // Regular expression pattern for validation\n    string pattern = R\"(^[a-zA-Z][a-zA-Z0-9]{0,2}\\.[txt|exe|dll]{3}$)\";\n    \n    // Create a regex object from the pattern\n    regex re(pattern);\n    \n    // Check if the file name matches the pattern\n    if (regex_match(file_name, re)) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\n\n"}
{"task_id": "CPP/142", "generation": "#include <vector>\nusing namespace std;\n\nint sum_squares(vector<int> lst) {\n    int total_sum = 0;\n    for (size_t i = 0; i < lst.size(); ++i) {\n        if ((i % 3 == 0 && i != 0) || (i % 4 == 0 && i % 3 != 0)) {\n            if (i % 3 == 0 && i != 0) {\n                total_sum += lst[i] * lst[i]; // Square the number\n            } else if (i % 4 == 0 && i % 3 != 0) {\n                total_sum += lst[i] * lst[i] * lst[i]; // Cube the number\n            }\n        } else {\n            total_sum += lst[i];\n        }\n    }\n    return total_sum;\n}\n"}
{"task_id": "CPP/143", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    if (n == 2 || n == 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    for (int i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0)\n            return false;\n    }\n    return true;\n}\n\n// Function to process the sentence and return words with prime length\nstring words_in_sentence(string sentence) {\n    stringstream ss(sentence);\n    string word;\n    string result = \"\";\n    \n    while (ss >> word) {\n        if (is_prime(word.length())) {\n            if (!result.empty()) result += \" \";\n            result += word;\n        }\n    }\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/144", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\n// Function to simplify two fractions and check if their product is a whole number\nbool simplify(string x, string n) {\n    // Helper function to parse fraction from string\n    auto parse_fraction = [](const string& frac) -> pair<int, int> {\n        size_t slash_pos = frac.find('/');\n        int numerator = stoi(frac.substr(0, slash_pos));\n        int denominator = stoi(frac.substr(slash_pos + 1));\n        return {numerator, denominator};\n    };\n\n    // Parse the fractions\n    auto [num_x, den_x] = parse_fraction(x);\n    auto [num_n, den_n] = parse_fraction(n);\n\n    // Calculate the product of the numerators and denominators\n    int numerator_product = num_x * num_n;\n    int denominator_product = den_x * den_n;\n\n    // Check if the result is a whole number\n    return (numerator_product % denominator_product) == 0;\n}\n\n"}
{"task_id": "CPP/145", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\n// Helper function to calculate the sum of digits of an integer.\nint digit_sum(int n) {\n    if (n < 0) n = -n; // Make n positive for digit extraction\n    int sum = 0;\n    while (n > 0) {\n        sum += n % 10;\n        n /= 10;\n    }\n    return sum;\n}\n\n// Main function to sort the vector based on the sum of digits.\nstd::vector<int> order_by_points(std::vector<int> nums) {\n    // Define a custom comparator\n    auto comp = [&nums](int a, int b) {\n        int sum_a = digit_sum(a);\n        int sum_b = digit_sum(b);\n\n        if (sum_a == sum_b) {\n            return std::find(nums.begin(), nums.end(), a) < std::find(nums.begin(), nums.end(), b);\n        }\n        return sum_a < sum_b;\n    };\n\n    // Sort the vector using the custom comparator\n    std::sort(nums.begin(), nums.end(), comp);\n\n    return nums;\n}\n\n// Function to print the vector for verification\nvoid print_vector(const std::vector<int>& vec) {\n    for (int num : vec) {\n        std::cout << num << \" \";\n    }\n    std::cout << std::endl;\n}\n\n// Main function for testing\n"}
{"task_id": "CPP/146", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nint specialFilter(vector<int> nums) {\n    int count = 0;\n    \n    for (int num : nums) {\n        // Skip numbers that are not greater than 10\n        if (num <= 10) continue;\n        \n        string strNum = to_string(num);\n        int firstDigit = strNum[0] - '0';\n        int lastDigit = strNum[strNum.length() - 1] - '0';\n        \n        // Check if both the first and last digits are odd\n        if (firstDigit % 2 != 0 && lastDigit % 2 != 0) {\n            count++;\n        }\n    }\n    \n    return count;\n}\n\n"}
{"task_id": "CPP/147", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint get_max_triples(int n) {\n    // Step 1: Generate the vector a\n    vector<int> a(n);\n    for (int i = 1; i <= n; ++i) {\n        a[i - 1] = i * i - i + 1;\n    }\n\n    int count = 0;\n\n    // Step 2 and 3: Iterate through all possible triples (i, j, k)\n    for (int i = 0; i < n - 2; ++i) {\n        for (int j = i + 1; j < n - 1; ++j) {\n            for (int k = j + 1; k < n; ++k) {\n                if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                    count++;\n                }\n            }\n        }\n    }\n\n    return count;\n}\n\n// Function to test the solution\nvoid check() {\n    int result = get_max_triples(5);\n    cout << \"Output: \" << result << endl; // Expected output: 1\n}\n\n"}
{"task_id": "CPP/148", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\n// Define a list of planets in order from closest to farthest from the Sun.\nconst std::vector<std::string> planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n\nstd::vector<std::string> bf(std::string planet1, std::string planet2) {\n    // Find the indices of the input planets in the list.\n    auto index1 = std::find(planets.begin(), planets.end(), planet1);\n    auto index2 = std::find(planets.begin(), planets.end(), planet2);\n\n    // Check if both planets are valid and ensure index1 is less than index2.\n    if (index1 == planets.end() || index2 == planets.end()) {\n        return {};  // Return an empty vector if either planet is invalid.\n    }\n\n    int i = std::min(index1 - planets.begin(), index2 - planets.begin());\n    int j = std::max(index1 - planets.begin(), index2 - planets.begin());\n\n    // Ensure the indices are in the correct order for slicing.\n    if (i > j) {\n        std::swap(i, j);\n    }\n\n    // Return the sublist of planets between the two indices (exclusive).\n    return {planets.begin() + i + 1, planets.begin() + j};\n}\n\n// Function to check the correctness of the bf function.\nvoid check_function() {\n    assert(bf(\"Jupiter\", \"Neptune\") == std::vector<std::string>{\"Saturn\", \"Uranus\"});\n    assert(bf(\"Earth\", \"Mercury\") == std::vector<std::string>{\"Venus\"});\n    assert(bf(\"Mercury\", \"Uranus\") == std::vector<std::string>{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"});\n    assert(bf(\"Pluto\", \"Mars\").empty());  // Invalid planet name.\n}\n\n"}
{"task_id": "CPP/149", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nvector<string> vector_sort(vector<string> lst) {\n    // Filter out strings with odd lengths\n    lst.erase(remove_if(lst.begin(), lst.end(), [](const string& s) { return s.length() % 2 != 0; }), lst.end());\n    \n    // Sort the list by length, and then alphabetically if lengths are equal\n    sort(lst.begin(), lst.end(), [](const string& a, const string& b) {\n        if (a.length() == b.length()) {\n            return a < b;\n        }\n        return a.length() < b.length();\n    });\n    \n    return lst;\n}\n\n"}
{"task_id": "CPP/150", "generation": "#include<stdio.h>\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int n) {\n    if (n <= 1) return false; // Numbers less than or equal to 1 are not prime\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\n// Function that returns x if n is a prime number, otherwise returns y\nint x_or_y(int n, int x, int y) {\n    return is_prime(n) ? x : y;\n}\n\n"}
{"task_id": "CPP/151", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nlong long double_the_difference(vector<float> lst) {\n    long long sum = 0;\n    \n    for (float num : lst) {\n        // Check if the number is positive, an integer, and odd\n        if (num > 0 && floor(num) == num && static_cast<int>(num) % 2 != 0) {\n            sum += pow(num, 2);\n        }\n    }\n    \n    return sum;\n}\n\n"}
{"task_id": "CPP/152", "generation": "#include <iostream>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\n// Function to compare the scores with guesses\nvector<int> compare(vector<int> game, vector<int> guess) {\n    vector<int> result;\n    \n    // Iterate through each match and calculate the absolute difference\n    for (size_t i = 0; i < game.size(); ++i) {\n        int diff = abs(game[i] - guess[i]);\n        result.push_back(diff);\n    }\n    \n    return result;\n}\n\n// Function to print a vector of integers\nvoid printVector(const vector<int>& vec) {\n    for (int num : vec) {\n        cout << num << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/153", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to calculate the strength of an extension\nint calculateStrength(const string& extension) {\n    int cap = 0, sm = 0;\n    for (char c : extension) {\n        if (isupper(c)) cap++;\n        else if (islower(c)) sm++;\n    }\n    return cap - sm;\n}\n\nstring Strongest_Extension(string class_name, vector<string> extensions) {\n    string strongest_extension = \"\";\n    int max_strength = INT_MIN;\n\n    for (const string& extension : extensions) {\n        int strength = calculateStrength(extension);\n        if (strength > max_strength) {\n            max_strength = strength;\n            strongest_extension = extension;\n        }\n    }\n\n    return class_name + \".\" + strongest_extension;\n}\n\n// Example usage\n"}
{"task_id": "CPP/154", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nbool cycpattern_check(const string& a, const string& b) {\n    // Concatenate the first string with itself to handle rotations\n    string double_a = a + a;\n    \n    // Check if the second string or any of its rotations is a substring of the concatenated string\n    return double_a.find(b) != string::npos;\n}\n\n"}
{"task_id": "CPP/155", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// Function to count even and odd digits in an integer\nvector<int> even_odd_count(int num) {\n    // Convert the number to a string to easily iterate over each digit\n    string str_num = to_string(abs(num));\n    \n    int even_count = 0;\n    int odd_count = 0;\n    \n    for (char digit : str_num) {\n        if ((digit - '0') % 2 == 0) {\n            even_count++;\n        } else {\n            odd_count++;\n        }\n    }\n    \n    return {even_count, odd_count};\n}\n\n// Function to test the even_odd_count function\nvoid test_even_odd_count() {\n    assert(even_odd_count(-12) == vector<int>({1, 1}));\n    assert(even_odd_count(123) == vector<int>({1, 2}));\n    assert(even_odd_count(0) == vector<int>({1, 0})); // Edge case: single digit 0\n    assert(even_odd_count(-9876543210) == vector<int>({5, 5}));\n    \n    cout << \"All test cases passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/156", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to convert an integer to its Roman numeral equivalent in lowercase\nstring int_to_mini_roman(int number) {\n    // Mapping of integers to their corresponding Roman numerals\n    vector<pair<int, string>> roman_map = {\n        {1000, \"m\"}, {900, \"cm\"}, {500, \"d\"}, {400, \"cd\"},\n        {100, \"c\"}, {90, \"xc\"}, {50, \"l\"}, {40, \"xl\"},\n        {10, \"x\"}, {9, \"ix\"}, {5, \"v\"}, {4, \"iv\"}, {1, \"i\"}\n    };\n\n    string roman_numeral = \"\";\n\n    // Iterate through the map and construct the Roman numeral\n    for (const auto& [value, symbol] : roman_map) {\n        while (number >= value) {\n            roman_numeral += symbol;\n            number -= value;\n        }\n    }\n\n    return roman_numeral;\n}\n\n// Function to check the correctness of the int_to_mini_roman function\nvoid check() {\n    assert(int_to_mini_roman(19) == \"xix\");\n    assert(int_to_mini_roman(152) == \"clii\");\n    assert(int_to_mini_roman(426) == \"cdxxvi\");\n    cout << \"All test cases passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/157", "generation": "#include <stdio.h>\n#include <math.h>\n\nusing namespace std;\n\nbool right_angle_triangle(float a, float b, float c) {\n    // First, sort the sides so that 'c' is the longest side (hypotenuse)\n    if (a > c) swap(a, c);\n    if (b > c) swap(b, c);\n\n    // Check if the Pythagorean theorem holds\n    return fabs(a*a + b*b - c*c) < 1e-6; // Using a small epsilon to account for floating point precision issues\n}\n\n"}
{"task_id": "CPP/158", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to count unique characters in a string\nint count_unique_chars(const string& word) {\n    bool seen[256] = {false};\n    int count = 0;\n    for (char c : word) {\n        if (!seen[c]) {\n            seen[c] = true;\n            count++;\n        }\n    }\n    return count;\n}\n\n// Function to find the word with maximum unique characters\nstring find_max(vector<string> words) {\n    string max_word = \"\";\n    int max_unique_chars = 0;\n\n    for (const auto& word : words) {\n        int unique_chars = count_unique_chars(word);\n        if (unique_chars > max_unique_chars || \n            (unique_chars == max_unique_chars && word < max_word)) {\n            max_word = word;\n            max_unique_chars = unique_chars;\n        }\n    }\n\n    return max_word;\n}\n\n// Function to test the find_max function\nvoid test_find_max() {\n    assert(find_max({\"name\", \"of\", \"string\"}) == \"string\");\n    assert(find_max({\"name\", \"enam\", \"game\"}) == \"enam\");\n    assert(find_max({\"aaaaaaa\", \"bb\", \"cc\"}) == \"aaaaaaa\");\n    cout << \"All test cases passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/159", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nvector<int> eat(int number, int need, int remaining) {\n    // Calculate the maximum number of carrots that can be eaten from the remaining stock\n    int max_to_eat = min(need, remaining);\n    \n    // Update the total number of carrots eaten\n    int total_eaten = number + max_to_eat;\n    \n    // Update the remaining carrots in stock\n    int remaining_after_meal = remaining - max_to_eat;\n    \n    return {total_eaten, remaining_after_meal};\n}\n\n// Function to test the eat function with provided examples\nvoid check() {\n    vector<int> result1 = eat(5, 6, 10);\n    printf(\"eat(5, 6, 10) -> {%d, %d}\\n\", result1[0], result1[1]); // Expected: {11, 4}\n    \n    vector<int> result2 = eat(4, 8, 9);\n    printf(\"eat(4, 8, 9) -> {%d, %d}\\n\", result2[0], result2[1]); // Expected: {12, 1}\n    \n    vector<int> result3 = eat(1, 10, 10);\n    printf(\"eat(1, 10, 10) -> {%d, %d}\\n\", result3[0], result3[1]); // Expected: {11, 0}\n    \n    vector<int> result4 = eat(2, 11, 5);\n    printf(\"eat(2, 11, 5) -> {%d, %d}\\n\", result4[0], result4[1]); // Expected: {7, 0}\n}\n\n"}
{"task_id": "CPP/160", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nint do_algebra(const vector<string>& operators, const vector<int>& operands) {\n    // Initialize the expression with the first operand\n    string expression = to_string(operands[0]);\n    \n    // Iterate through the operators and append them along with the next operand\n    for (size_t i = 0; i < operators.size(); ++i) {\n        expression += \" \" + operators[i] + \" \" + to_string(operands[i + 1]);\n    }\n    \n    // Evaluate the constructed expression using C++'s `std::stof` and `atof`\n    int result = std::stoi(expression);\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/161", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\n// Function to solve the problem as described\nstring solve(string s) {\n    bool hasLetters = false;\n    \n    // Check if there are any letters in the string\n    for (char c : s) {\n        if (isalpha(c)) {\n            hasLetters = true;\n            break;\n        }\n    }\n\n    if (!hasLetters) {\n        // If no letters, reverse the entire string\n        reverse(s.begin(), s.end());\n    } else {\n        // If there are letters, convert them to their opposite case\n        for (char &c : s) {\n            if (islower(c)) {\n                c = toupper(c);\n            } else if (isupper(c)) {\n                c = tolower(c);\n            }\n        }\n    }\n\n    return s;\n}\n\n// Function to test the solve function with provided examples\nvoid test() {\n    cout << \"solve(\\\"1234\\\") = \\\"\" << solve(\"1234\") << \"\\\" (Expected: \\\"4321\\\")\" << endl;\n    cout << \"solve(\\\"ab\\\") = \\\"\" << solve(\"ab\") << \"\\\" (Expected: \\\"AB\\\")\" << endl;\n    cout << \"solve(\\\"#a@C\\\") = \\\"\" << solve(\"#a@C\") << \"\\\" (Expected: \\\"#A@c\\\")\" << endl;\n}\n\n"}
{"task_id": "CPP/162", "generation": "#include <iostream>\n#include <openssl/md5.h>\n#include <sstream>\n#include <iomanip>\n\n// Function to convert byte array to hex string\nstd::string bytes_to_hex(const unsigned char* bytes, size_t len) {\n    std::stringstream ss;\n    for (size_t i = 0; i < len; ++i) {\n        ss << std::hex << std::setw(2) << std::setfill('0') << static_cast<int>(bytes[i]);\n    }\n    return ss.str();\n}\n\n// Function to convert string to MD5 hash\nstd::string string_to_md5(const std::string& text) {\n    if (text.empty()) {\n        return \"None\";\n    }\n\n    unsigned char digest[MD5_DIGEST_LENGTH];\n    MD5(reinterpret_cast<const unsigned char*>(text.c_str()), text.length(), digest);\n\n    // Convert the hash to a hexadecimal string\n    return bytes_to_hex(digest, MD5_DIGEST_LENGTH);\n}\n\n"}
{"task_id": "CPP/163", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to find all even digits between two integers a and b (inclusive)\nvector<int> generate_integers(int a, int b) {\n    // List of even digits less than 10\n    vector<int> even_digits = {2, 4, 6, 8};\n    \n    // Ensure the range is in ascending order\n    if (a > b) swap(a, b);\n    \n    // Result list to store the even digits found\n    vector<int> result;\n    \n    // Iterate through each number in the range [a, b]\n    for (int num = a; num <= b; ++num) {\n        string num_str = to_string(num);  // Convert number to string\n        \n        // Check if any digit in the current number is an even digit\n        bool has_even_digit = false;\n        for (char digit : num_str) {\n            int digit_int = digit - '0';  // Convert char to int\n            if (find(even_digits.begin(), even_digits.end(), digit_int) != even_digits.end()) {\n                result.push_back(digit_int);\n                has_even_digit = true;\n            }\n        }\n        \n        // If the number contains any even digit, add it to the result list\n        if (has_even_digit) {\n            for (char digit : num_str) {\n                int digit_int = digit - '0';\n                if (find(even_digits.begin(), even_digits.end(), digit_int) != even_digits.end()) {\n                    result.push_back(digit_int);\n                }\n            }\n        }\n    }\n    \n    // Remove duplicates and sort the result list\n    sort(result.begin(), result.end());\n    auto last = unique(result.begin(), result.end());\n    result.erase(last, result.end());\n    \n    return result;\n}\n\n// Function to print the vector for testing purposes\nvoid print_vector(const vector<int>& vec) {\n    for (int num : vec) {\n        cout << num << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/0", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // For std::sort\n\nbool has_close_elements(vector<float> numbers, float threshold) {\n    // Sort the vector first\n    sort(numbers.begin(), numbers.end());\n\n    // Iterate through adjacent elements to check if any pair is closer than the threshold\n    for (size_t i = 0; i < numbers.size() - 1; ++i) {\n        if (numbers[i + 1] - numbers[i] < threshold) {\n            return true;\n        }\n    }\n\n    // If no such pair found, return false\n    return false;\n}\n\n"}
{"task_id": "CPP/1", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> separate_paren_groups(string paren_string) {\n    vector<string> result;\n    string current_group;\n    int balance = 0;\n\n    for (char ch : paren_string) {\n        if (ch == '(') {\n            balance++;\n            current_group += ch;\n        } else if (ch == ')') {\n            balance--;\n            current_group += ch;\n            if (balance == 0) {\n                result.push_back(current_group);\n                current_group.clear();\n            }\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/2", "generation": "#include <stdio.h>\n#include <math.h>\n\nfloat truncate_number(float number) {\n    float integerPart;\n    modf(number, &integerPart);  // modf returns the fractional part and stores the integer part in `integerPart`\n    return number - integerPart; // Subtracting the integer part from the original number gives the decimal part\n}\n\n"}
{"task_id": "CPP/3", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool below_zero(vector<int> operations) {\n    int balance = 0; // Start with a zero balance\n\n    for (int op : operations) {\n        balance += op; // Update the balance after each operation\n\n        if (balance < 0) { // Check if the balance falls below zero\n            return true;\n        }\n    }\n\n    return false; // Return false if the balance never goes below zero\n}\n\n// Function to test the below_zero function with provided examples\nvoid check_function() {\n    vector<int> operations1 = {1, 2, 3};\n    vector<int> operations2 = {1, 2, -4, 5};\n\n    cout << \"Test Case 1: \" << (below_zero(operations1) ? \"Passed\" : \"Failed\") << endl;\n    cout << \"Test Case 2: \" << (below_zero(operations2) ? \"Passed\" : \"Failed\") << endl;\n}\n\n"}
{"task_id": "CPP/4", "generation": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nfloat mean_absolute_deviation(vector<float> numbers) {\n    // Step 1: Calculate the mean of the dataset\n    float sum = 0.0;\n    for (const auto& num : numbers) {\n        sum += num;\n    }\n    float mean = sum / numbers.size();\n\n    // Step 2 and 3: Compute the absolute differences and their average\n    float mad = 0.0;\n    for (const auto& num : numbers) {\n        mad += abs(num - mean);\n    }\n    mad /= numbers.size();\n\n    return mad;\n}\n\n"}
{"task_id": "CPP/5", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> intersperse(vector<int> numbers, int delimeter) {\n    vector<int> result;\n    \n    // Iterate through the original vector and insert each element followed by the delimiter\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        result.push_back(numbers[i]);\n        if (i != numbers.size() - 1) {  // Do not add a delimiter after the last element\n            result.push_back(delimeter);\n        }\n    }\n    \n    return result;\n}\n\n// Function to test the intersperse function\nvoid testIntersperse() {\n    vector<int> emptyVec = {};\n    vector<int> vec1 = {1, 2, 3};\n    vector<int> expected1 = {1, 4, 2, 4, 3};\n\n    cout << \"Testing with an empty vector:\" << endl;\n    for (int num : intersperse(emptyVec, 4)) {\n        cout << num << \" \";\n    }\n    cout << endl;\n\n    cout << \"Testing with a non-empty vector:\" << endl;\n    for (int num : intersperse(vec1, 4)) {\n        cout << num << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/6", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to parse and determine the deepest level of nesting for a single group of parentheses\nint maxDepthOfNesting(const string& group) {\n    int currentDepth = 0;\n    int maxDepth = 0;\n    \n    for (char ch : group) {\n        if (ch == '(') {\n            currentDepth++;\n            maxDepth = max(maxDepth, currentDepth);\n        } else if (ch == ')') {\n            currentDepth--;\n        }\n    }\n    \n    return maxDepth;\n}\n\n// Function to process the entire string and return a vector of maximum depths for each group\nvector<int> parse_nested_parens(string paren_string) {\n    vector<int> result;\n    size_t start = 0;\n    size_t end = paren_string.find(' ');\n    \n    while (end != string::npos) {\n        // Extract the current group from the string\n        string group = paren_string.substr(start, end - start);\n        \n        // Calculate the maximum depth of nesting for the current group\n        int maxDepth = maxDepthOfNesting(group);\n        \n        result.push_back(maxDepth);\n        \n        // Move to the next group\n        start = end + 1;\n        end = paren_string.find(' ', start);\n    }\n    \n    // Process the last group if there is one\n    if (start < paren_string.length()) {\n        string group = paren_string.substr(start);\n        int maxDepth = maxDepthOfNesting(group);\n        result.push_back(maxDepth);\n    }\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/7", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to filter strings containing a given substring\nvector<string> filter_by_substring(vector<string> strings, string substring) {\n    vector<string> filtered_strings;\n    \n    // Iterate through each string in the input vector\n    for (const auto& str : strings) {\n        // Check if the current string contains the substring\n        if (str.find(substring) != string::npos) {\n            // If it does, add it to the filtered list\n            filtered_strings.push_back(str);\n        }\n    }\n    \n    return filtered_strings;\n}\n\n// Function to test the filter_by_substring function\nvoid test_filter_by_substring() {\n    vector<string> input1 = {};\n    vector<string> expected1 = {};\n    assert(filter_by_substring(input1, \"a\") == expected1);\n\n    vector<string> input2 = {\"abc\", \"bacd\", \"cde\", \"vector\"};\n    vector<string> expected2 = {\"abc\", \"bacd\", \"vector\"};\n    assert(filter_by_substring(input2, \"a\") == expected2);\n\n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/8", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// Function to calculate the sum and product of elements in a vector\nvector<int> sum_product(vector<int> numbers) {\n    int sum = 0;\n    int product = 1;\n\n    // Iterate through each number in the vector\n    for (int num : numbers) {\n        sum += num;  // Add the current number to the sum\n        product *= num;  // Multiply the current number with the product\n    }\n\n    return {sum, product};\n}\n\n// Function to test the sum_product function\nvoid test_sum_product() {\n    vector<int> empty = {};\n    vector<int> result1 = sum_product(empty);\n    cout << \"Empty Vector: Sum = \" << result1[0] << \", Product = \" << result1[1] << endl;\n\n    vector<int> numbers = {1, 2, 3, 4};\n    vector<int> result2 = sum_product(numbers);\n    cout << \"Vector [1, 2, 3, 4]: Sum = \" << result2[0] << \", Product = \" << result2[1] << endl;\n}\n\n"}
{"task_id": "CPP/9", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> rolling_max(vector<int> numbers) {\n    if (numbers.empty()) return {};  // Return an empty vector if input is empty\n\n    vector<int> result;\n    int current_max = numbers[0];  // Initialize the current maximum with the first element\n    for (int num : numbers) {\n        if (num > current_max) {\n            current_max = num;  // Update the current maximum if a larger number is found\n        }\n        result.push_back(current_max);  // Add the current maximum to the result vector\n    }\n\n    return result;\n}\n\n// Function to print the vector for testing purposes\nvoid print_vector(const vector<int>& vec) {\n    for (int num : vec) {\n        cout << num << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/10", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_palindrome(const string& str) {\n    // Test if given string is a palindrome\n    return string(str.rbegin(), str.rend()) == str;\n}\n\nstring make_palindrome(string str) {\n    /*\n    Find the shortest palindrome that begins with a supplied string. \n    Algorithm idea is simple: - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    */\n    \n    // Check if the input string is already a palindrome\n    if (is_palindrome(str)) {\n        return str;\n    }\n    \n    int n = str.length();\n    for (int i = 0; i < n; ++i) {\n        // Check if the substring starting from index i to the end is a palindrome\n        if (is_palindrome(str.substr(i))) {\n            // The longest palindromic postfix starts at index i\n            string prefix = str.substr(0, i);\n            // Reverse the prefix and append it to the original string\n            reverse(prefix.begin(), prefix.end());\n            return str + prefix;\n        }\n    }\n    \n    // If no palindromic suffix is found (which should not happen in valid cases), return the input string as a fallback\n    return str;\n}\n\n"}
{"task_id": "CPP/11", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring string_xor(string a, string b) {\n    // Ensure both strings are of equal length by padding with leading zeros if necessary\n    int maxLength = max(a.length(), b.length());\n    a.insert(0, maxLength - a.length(), '0');\n    b.insert(0, maxLength - b.length(), '0');\n\n    string result(maxLength, '0');  // Initialize the result string\n\n    // Perform XOR operation character by character\n    for (int i = 0; i < maxLength; ++i) {\n        if (a[i] != b[i]) {\n            result[i] = '1';  // If characters are different, set result to '1'\n        }\n    }\n\n    return result;\n}\n\n// Function to test the string_xor function\nvoid test_string_xor() {\n    cout << \"Testing string_xor function:\" << endl;\n    cout << \"Input: \\\"010\\\", \\\"110\\\" - Output: \\\"\" << string_xor(\"010\", \"110\") << \"\\\" (Expected: \\\"100\\\")\" << endl;\n    cout << \"Input: \\\"10101\\\", \\\"11001\\\" - Output: \\\"\" << string_xor(\"10101\", \"11001\") << \"\\\" (Expected: \\\"01100\\\")\" << endl;\n}\n\n"}
{"task_id": "CPP/12", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring longest(const vector<string>& strings) {\n    if (strings.empty()) {\n        return \"\"; // Return an empty string to indicate None in this context.\n    }\n\n    const string* longestString = &strings[0];\n    for (const auto& str : strings) {\n        if (str.length() > longestString->length()) {\n            longestString = &str;\n        }\n    }\n\n    return *longestString;\n}\n\n"}
{"task_id": "CPP/13", "generation": "#include <stdio.h>\nusing namespace std;\n\nint greatest_common_divisor(int a, int b) {\n    // Ensure a >= b to simplify the logic\n    if (b > a) {\n        return greatest_common_divisor(b, a);\n    }\n\n    // Base case: if b is 0, then GCD is a\n    if (b == 0) {\n        return a;\n    }\n\n    // Recursive call with remainder of a divided by b\n    return greatest_common_divisor(b, a % b);\n}\n\n"}
{"task_id": "CPP/14", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to generate all prefixes of the input string\nvector<string> all_prefixes(string str) {\n    vector<string> prefixes;\n    for (size_t i = 1; i <= str.length(); ++i) {\n        prefixes.push_back(str.substr(0, i));\n    }\n    return prefixes;\n}\n\n"}
{"task_id": "CPP/15", "generation": "#include <iostream>\n#include <sstream>\n#include <string>\nusing namespace std;\n\nstring string_sequence(int n) {\n    stringstream ss;\n    for (int i = 0; i <= n; ++i) {\n        ss << i;\n        if (i < n) {\n            ss << \" \";\n        }\n    }\n    return ss.str();\n}\n\n// Function to test the string_sequence function\nvoid test_string_sequence() {\n    cout << \"Testing string_sequence...\" << endl;\n    assert(string_sequence(0) == \"0\");\n    assert(string_sequence(5) == \"0 1 2 3 4 5\");\n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/16", "generation": "#include <iostream>\n#include <string>\n#include <set>\n\nusing namespace std;\n\nint count_distinct_characters(string str) {\n    // Convert the string to lowercase to ensure case insensitivity\n    transform(str.begin(), str.end(), str.begin(), ::tolower);\n    \n    // Use a set to store distinct characters\n    set<char> distinct_chars(str.begin(), str.end());\n    \n    // The size of the set is the number of distinct characters\n    return distinct_chars.size();\n}\n\n"}
{"task_id": "CPP/17", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\n// Define a mapping from musical notes to their corresponding beats\nconst vector<pair<string, int>> note_to_beats = {\n    {\"o\", 4},\n    {\"o|\", 2},\n    {\".|\", 1}\n};\n\nvector<int> parse_music(string music_string) {\n    // Split the input string into individual notes\n    vector<int> beats;\n    size_t start = 0, end = 0;\n\n    while ((end = music_string.find(' ', start)) != string::npos) {\n        string note = music_string.substr(start, end - start);\n        if (note.empty()) continue; // Skip empty substrings\n\n        // Find the corresponding beats for the note\n        auto it = find_if(note_to_beats.begin(), note_to_beats.end(),\n                          [&](const pair<string, int>& p) { return p.first == note; });\n        \n        if (it != note_to_beats.end()) {\n            beats.push_back(it->second);\n        } else {\n            cout << \"Warning: Unknown note '\" << note << \"' found.\" << endl;\n        }\n\n        start = end + 1;\n    }\n\n    // Handle the last note in case there is no trailing space\n    string last_note = music_string.substr(start);\n    if (!last_note.empty()) {\n        auto it = find_if(note_to_beats.begin(), note_to_beats.end(),\n                          [&](const pair<string, int>& p) { return p.first == last_note; });\n        \n        if (it != note_to_beats.end()) {\n            beats.push_back(it->second);\n        } else {\n            cout << \"Warning: Unknown note '\" << last_note << \"' found.\" << endl;\n        }\n    }\n\n    return beats;\n}\n\n"}
{"task_id": "CPP/18", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint how_many_times(const string& str, const string& substring) {\n    if (substring.empty()) return 0;\n    \n    int count = 0;\n    size_t pos = 0;\n    \n    while ((pos = str.find(substring, pos)) != string::npos) {\n        ++count;\n        pos++; // Move to the next character to allow overlapping matches\n    }\n    \n    return count;\n}\n\n"}
{"task_id": "CPP/19", "generation": "#include <iostream>\n#include <string>\n#include <map>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to convert word to number\nint word_to_number(const string& word) {\n    map<string, int> num_map = {{\"zero\", 0}, {\"one\", 1}, {\"two\", 2}, {\"three\", 3},\n                                {\"four\", 4}, {\"five\", 5}, {\"six\", 6}, {\"seven\", 7},\n                                {\"eight\", 8}, {\"nine\", 9}};\n    return num_map[word];\n}\n\n// Function to sort numbers\nstring sort_numbers(const string& numbers) {\n    vector<string> words;\n    string number;\n    \n    // Split the input string into individual words\n    for (char ch : numbers) {\n        if (ch == ' ') {\n            if (!number.empty()) {\n                words.push_back(number);\n                number.clear();\n            }\n        } else {\n            number += ch;\n        }\n    }\n    if (!number.empty()) {\n        words.push_back(number);\n    }\n\n    // Sort the words based on their numeric value\n    sort(words.begin(), words.end(), [](const string& a, const string& b) {\n        return word_to_number(a) < word_to_number(b);\n    });\n\n    // Join the sorted words back into a single string\n    string result;\n    for (const auto& word : words) {\n        if (!result.empty()) {\n            result += \" \";\n        }\n        result += word;\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/20", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<float> find_closest_elements(vector<float> numbers) {\n    // Sort the input vector in ascending order\n    sort(numbers.begin(), numbers.end());\n    \n    float min_diff = numeric_limits<float>::max();\n    pair<float, float> closest_pair(0.0f, 0.0f);\n    \n    // Iterate through the sorted list to find the two closest elements\n    for (size_t i = 0; i < numbers.size() - 1; ++i) {\n        float diff = numbers[i + 1] - numbers[i];\n        if (diff < min_diff) {\n            min_diff = diff;\n            closest_pair = make_pair(numbers[i], numbers[i + 1]);\n        }\n    }\n    \n    // Return the pair of closest elements\n    return {closest_pair.first, closest_pair.second};\n}\n\n// Function to check the correctness of the solution\nvoid check() {\n    vector<float> result1 = find_closest_elements({1.0f, 2.0f, 3.0f, 4.0f, 5.0f, 2.2f});\n    assert(abs(result1[0] - 2.0f) < 1e-6 && abs(result1[1] - 2.2f) < 1e-6);\n    \n    vector<float> result2 = find_closest_elements({1.0f, 2.0f, 3.0f, 4.0f, 5.0f, 2.0f});\n    assert(abs(result2[0] - 2.0f) < 1e-6 && abs(result2[1] - 2.0f) < 1e-6);\n    \n    cout << \"All test cases passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/21", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // For std::min_element and std::max_element\n\nusing namespace std;\n\nvector<float> rescale_to_unit(vector<float> numbers) {\n    if (numbers.size() < 2) {\n        throw invalid_argument(\"Vector must contain at least two elements.\");\n    }\n\n    float min_value = *std::min_element(numbers.begin(), numbers.end());\n    float max_value = *std::max_element(numbers.begin(), numbers.end());\n\n    vector<float> scaled_numbers;\n    for (float num : numbers) {\n        float new_value = (num - min_value) / (max_value - min_value);\n        scaled_numbers.push_back(new_value);\n    }\n\n    return scaled_numbers;\n}\n\n"}
{"task_id": "CPP/22", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <list>\n#include <boost/any.hpp>\n\ntypedef std::list<boost::any> list_any;\nusing namespace std;\n\nvector<int> filter_integers(list_any values) {\n    vector<int> result;\n    for (const auto& value : values) {\n        if (value.type() == typeid(int)) {\n            result.push_back(boost::any_cast<int>(value));\n        }\n    }\n    return result;\n}\n\n"}
{"task_id": "CPP/23", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint strlen(const string& str) {\n    // Return the size of the string, which is equivalent to its length.\n    return str.size();\n}\n\n// Function to test the strlen function with some examples\nvoid test_strlen() {\n    cout << \"Length of \\\"\\\" (empty string): \" << strlen(\"\") << endl;\n    cout << \"Length of \\\"abc\\\": \" << strlen(\"abc\") << endl;\n    cout << \"Length of \\\"hello world\\\": \" << strlen(\"hello world\") << endl;\n}\n\n"}
{"task_id": "CPP/24", "generation": "#include <iostream>\nusing namespace std;\n\nint largest_divisor(int n) {\n    for (int i = n - 1; i > 0; --i) {\n        if (n % i == 0) {\n            return i;\n        }\n    }\n    // If no divisor is found, which should not happen for positive integers,\n    // we can return -1 or throw an exception. For simplicity, returning -1.\n    return -1;\n}\n\n"}
{"task_id": "CPP/25", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> factorize(int n) {\n    vector<int> factors;\n    \n    // Divide by 2 to get rid of all even factors\n    while (n % 2 == 0) {\n        factors.push_back(2);\n        n /= 2;\n    }\n    \n    // Check for odd factors from 3 onwards\n    for (int i = 3; i * i <= n; i += 2) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n    \n    // If n is a prime number greater than 2\n    if (n > 2) {\n        factors.push_back(n);\n    }\n    \n    return factors;\n}\n\n"}
{"task_id": "CPP/26", "generation": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nvector<int> remove_duplicates(vector<int> numbers) {\n    // Create an unordered map to count occurrences of each element\n    unordered_map<int, int> counts;\n    \n    // Count the occurrences of each number in the input vector\n    for (int num : numbers) {\n        counts[num]++;\n    }\n    \n    // Create a new vector to store elements that occur exactly once\n    vector<int> result;\n    \n    // Iterate through the original vector and add elements to the result if they occur only once\n    for (int num : numbers) {\n        if (counts[num] == 1) {\n            result.push_back(num);\n        }\n    }\n    \n    return result;\n}\n\n// Function to check the correctness of the remove_duplicates function\nvoid check() {\n    vector<int> input = {1, 2, 3, 2, 4};\n    vector<int> expected_output = {1, 3, 4};\n    vector<int> output = remove_duplicates(input);\n    \n    if (output == expected_output) {\n        cout << \"Test passed.\" << endl;\n    } else {\n        cout << \"Test failed.\" << endl;\n    }\n}\n\n"}
{"task_id": "CPP/27", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring flip_case(string str) {\n    for (char &c : str) {\n        if (islower(c)) {\n            c = toupper(c);\n        } else if (isupper(c)) {\n            c = tolower(c);\n        }\n    }\n    return str;\n}\n\n"}
{"task_id": "CPP/28", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <numeric> // For std::accumulate\n\nusing namespace std;\n\nstring concatenate(vector<string> strings) {\n    // Use std::accumulate to concatenate all strings in the vector\n    return accumulate(strings.begin(), strings.end(), string(\"\"));\n}\n\n// Function to test the concatenate function\nvoid test_concatenate() {\n    assert(concatenate({}) == \"\");\n    assert(concatenate({\"a\", \"b\", \"c\"}) == \"abc\");\n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/29", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to filter strings based on the given prefix\nvector<string> filter_by_prefix(vector<string> strings, string prefix) {\n    vector<string> filtered_strings;\n    \n    // Iterate through each string in the input vector\n    for (const auto& str : strings) {\n        // Check if the current string starts with the given prefix\n        if (str.substr(0, prefix.length()) == prefix) {\n            // If it does, add it to the filtered list\n            filtered_strings.push_back(str);\n        }\n    }\n    \n    return filtered_strings;\n}\n\n// Function to test the filter_by_prefix function\nvoid test_filter_by_prefix() {\n    vector<string> input1 = {};\n    string prefix1 = \"a\";\n    vector<string> result1 = filter_by_prefix(input1, prefix1);\n    cout << \"Test 1: \";\n    if (result1.empty()) {\n        cout << \"Passed\" << endl;\n    } else {\n        cout << \"Failed\" << endl;\n    }\n\n    vector<string> input2 = {\"abc\", \"bcd\", \"cde\", \"vector\"};\n    string prefix2 = \"a\";\n    vector<string> result2 = filter_by_prefix(input2, prefix2);\n    cout << \"Test 2: \";\n    if (result2 == vector<string>{\"abc\", \"vector\"}) {\n        cout << \"Passed\" << endl;\n    } else {\n        cout << \"Failed\" << endl;\n    }\n}\n\n"}
{"task_id": "CPP/30", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvector<float> get_positive(vector<float> l) {\n    vector<float> result;\n    for (float num : l) {\n        if (num > 0) {\n            result.push_back(num);\n        }\n    }\n    return result;\n}\n\n"}
{"task_id": "CPP/31", "generation": "#include <iostream>\nusing namespace std;\n\nbool is_prime(long long n) {\n    // Handle edge cases for numbers less than or equal to 1\n    if (n <= 1) return false;\n    \n    // Check divisibility from 2 up to the square root of n\n    for (long long i = 2; i * i <= n; ++i) {\n        if (n % i == 0) {\n            return false; // Found a divisor, so it's not prime\n        }\n    }\n    \n    return true; // No divisors found, so it is prime\n}\n\n"}
{"task_id": "CPP/32", "generation": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <functional>\n\ndouble poly(const std::vector<double>& xs, double x) {\n    double sum = 0;\n    for (size_t i = 0; i < xs.size(); ++i) {\n        sum += xs[i] * pow(x, static_cast<int>(i));\n    }\n    return sum;\n}\n\ndouble find_zero(const std::vector<double>& xs) {\n    if (xs.size() % 2 != 0 || !std::any_of(xs.begin(), xs.end() - 1, [](double coef) { return coef != 0; })) {\n        throw std::invalid_argument(\"The polynomial must have an even number of coefficients and the largest non-zero coefficient should be the last one.\");\n    }\n\n    double x_initial_guess = 0.5 * (std::abs(xs.back()) + std::abs(xs[xs.size() - 2]));\n    double root;\n    // Using a simple iterative method to approximate the zero point\n    for (double guess = x_initial_guess; ; ++guess) {\n        if (poly(xs, guess) == 0.0 || std::fabs(poly(xs, guess)) < 1e-6) {\n            root = guess;\n            break;\n        }\n    }\n\n    return root;\n}\n\n"}
{"task_id": "CPP/33", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> sort_third(vector<int> l) {\n    vector<int> third_indices;\n    \n    // Extract elements at indices divisible by 3\n    for (int i = 2; i < l.size(); i += 3) {\n        third_indices.push_back(l[i]);\n    }\n    \n    // Sort the extracted elements\n    sort(third_indices.begin(), third_indices.end());\n    \n    // Create result list as a copy of the original list\n    vector<int> l_prime = l;\n    \n    // Place sorted elements back into the result list at indices divisible by 3\n    for (int i = 2, j = 0; i < l.size(); i += 3, ++j) {\n        l_prime[i] = third_indices[j];\n    }\n    \n    return l_prime;\n}\n\n// Function to print the vector\nvoid print_vector(const vector<int>& v) {\n    for (int val : v) {\n        cout << val << \" \";\n    }\n    cout << endl;\n}\n\n// Main function to test the sort_third function\n"}
{"task_id": "CPP/34", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> unique(vector<int> l) {\n    // Sort the input vector\n    sort(l.begin(), l.end());\n    \n    // Remove consecutive duplicate elements\n    auto last = unique(l.begin(), l.end());\n    \n    // Resize the vector to contain only the unique elements\n    l.resize(distance(l.begin(), last));\n    \n    return l;\n}\n\n"}
{"task_id": "CPP/35", "generation": "#include <iostream>\n#include <vector>\n\nfloat max_element(const std::vector<float>& l) {\n    if (l.empty()) {\n        throw std::invalid_argument(\"Vector is empty\");\n    }\n\n    float max_val = l[0];\n    for (size_t i = 1; i < l.size(); ++i) {\n        if (l[i] > max_val) {\n            max_val = l[i];\n        }\n    }\n    return max_val;\n}\n\n"}
{"task_id": "CPP/36", "generation": "#include <iostream>\nusing namespace std;\n\nint fizz_buzz(int n) {\n    int count = 0;\n    \n    for (int i = 1; i < n; ++i) {\n        if (i % 11 == 0 || i % 13 == 0) {\n            // Convert the number to a string and count occurrences of '7'\n            string num_str = to_string(i);\n            for (char c : num_str) {\n                if (c == '7') {\n                    ++count;\n                }\n            }\n        }\n    }\n    \n    return count;\n}\n\n"}
{"task_id": "CPP/37", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<float> sort_even(vector<float> l) {\n    // Extract elements at even indices\n    vector<float> evens;\n    for (size_t i = 0; i < l.size(); i += 2) {\n        evens.push_back(l[i]);\n    }\n\n    // Sort the extracted elements\n    sort(evens.begin(), evens.end());\n\n    // Place sorted elements back into their original positions\n    size_t evenIndex = 0;\n    for (size_t i = 0; i < l.size(); ++i) {\n        if (i % 2 == 0) {\n            l[i] = evens[evenIndex++];\n        }\n    }\n\n    return l;\n}\n\n// Function to check the correctness of the sort_even function\nvoid check() {\n    vector<float> result1 = sort_even({1, 2, 3});\n    assert(result1 == vector<float>({1, 2, 3}));\n\n    vector<float> result2 = sort_even({5, 6, 3, 4});\n    assert(result2 == vector<float>({3, 6, 5, 4}));\n\n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/38", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nstring encode_cyclic(string s) { \n    // returns encoded string by cycling groups of three characters.  \n    int l = s.length();\n    int num = (l + 2) / 3;\n    string x, output;\n    for (int i = 0; i * 3 < l; i++) {\n        x = s.substr(i * 3, 3);\n        if (x.length() == 3) x = x.substr(1) + x[0];\n        output += x;\n    }\n    return output;\n}\n\nstring decode_cyclic(string s) { \n    /*\n    takes as input string encoded with encode_cyclic function. Returns decoded string.\n    */\n    int l = s.length();\n    int num = (l + 2) / 3;\n    string x, output;\n    for (int i = 0; i * 3 < l; i++) {\n        x = s.substr(i * 3, 3);\n        if (x.length() == 3) x = x[2] + x.substr(0, 2); // Rotate one position to the left\n        output += x;\n    }\n    return output;\n}\n\n"}
{"task_id": "CPP/39", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    if (num == 2 || num == 3) return true;\n    if (num % 2 == 0 || num % 3 == 0) return false;\n    for (int i = 5; i * i <= num; i += 6) {\n        if (num % i == 0 || num % (i + 2) == 0)\n            return false;\n    }\n    return true;\n}\n\n// Function to generate the n-th prime Fibonacci number\nint prime_fib(int n) {\n    int count = 0; // Counter for prime Fibonacci numbers found\n    long fib1 = 0, fib2 = 1; // First two Fibonacci numbers\n\n    while (true) {\n        long next_fib = fib1 + fib2;\n        if (is_prime(next_fib)) {\n            count++;\n            if (count == n) return next_fib;\n        }\n        fib1 = fib2;\n        fib2 = next_fib;\n    }\n}\n\n"}
{"task_id": "CPP/40", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nbool triples_sum_to_zero(vector<int> l) {\n    int n = l.size();\n    \n    // Iterate through each element in the list using index i\n    for (int i = 0; i < n - 2; ++i) {\n        // Iterate over the remaining elements starting from j = i + 1\n        for (int j = i + 1; j < n - 1; ++j) {\n            // Iterate over the remaining elements starting from k = j + 1\n            for (int k = j + 1; k < n; ++k) {\n                // Check if the sum of the three elements is zero\n                if (l[i] + l[j] + l[k] == 0) {\n                    return true;\n                }\n            }\n        }\n    }\n    \n    // Return false if no such triplet is found\n    return false;\n}\n\n// Function to test the triples_sum_to_zero function with provided data points\nvoid test_triples_sum_to_zero() {\n    assert(triples_sum_to_zero({1, 3, 5, 0}) == false);\n    assert(triples_sum_to_zero({1, 3, -2, 1}) == true);\n    assert(triples_sum_to_zero({1, 2, 3, 7}) == false);\n    assert(triples_sum_to_zero({2, 4, -5, 3, 9, 7}) == true);\n    assert(triples_sum_to_zero({1}) == false);\n    \n    cout << \"All test cases passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/41", "generation": "#include <iostream>\n#include <vector>\n\nint car_race_collision(int n) {\n    // Since all cars are moving at the same speed and start far apart,\n    // each car going left to right will eventually collide with each car\n    // going right to left.\n    return n * n;\n}\n\n"}
{"task_id": "CPP/42", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> incr_list(vector<int> l) {\n    for (int i = 0; i < l.size(); ++i) {\n        l[i] += 1;\n    }\n    return l;\n}\n\n// Function to check the correctness of the incr_list function\nvoid check_function() {\n    vector<int> test1 = {1, 2, 3};\n    vector<int> expected1 = {2, 3, 4};\n    assert(incr_list(test1) == expected1);\n\n    vector<int> test2 = {5, 3, 5, 2, 3, 3, 9, 0, 123};\n    vector<int> expected2 = {6, 4, 6, 3, 4, 4, 10, 1, 124};\n    assert(incr_list(test2) == expected2);\n\n    cout << \"All test cases passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/43", "generation": "#include <iostream>\n#include <vector>\n#include <set>\n\nusing namespace std;\n\nbool pairs_sum_to_zero(vector<int> l) {\n    // Use a set to store seen numbers\n    set<int> seen;\n    \n    for (int num : l) {\n        // Check if the negation of the current number is in the set\n        if (seen.find(-num) != seen.end()) {\n            return true;\n        }\n        // Add the current number to the set\n        seen.insert(num);\n    }\n    \n    // If no such pair is found, return false\n    return false;\n}\n\n"}
{"task_id": "CPP/44", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring change_base(int x, int base) {\n    if (x == 0) return \"0\"; // Handle the case where x is zero\n\n    string result = \"\";\n    while (x > 0) {\n        int remainder = x % base;\n        char digit = '0' + remainder; // Convert the integer to its character representation\n        result = digit + result; // Prepend the digit to the result string\n        x /= base; // Divide x by the base\n    }\n    return result;\n}\n\n"}
{"task_id": "CPP/45", "generation": "#include <iostream>\nusing namespace std;\n\nfloat triangle_area(float a, float h) {\n    return 0.5 * a * h;\n}\n\n"}
{"task_id": "CPP/46", "generation": "#include <stdio.h>\nusing namespace std;\n\nint fib4(int n) {\n    if (n == 0 || n == 1 || n == 3) return 0;\n    if (n == 2) return 2;\n\n    int a = 0, b = 0, c = 2, d = 0, result;\n    \n    for (int i = 4; i <= n; ++i) {\n        result = a + b + c + d;\n        a = b;\n        b = c;\n        c = d;\n        d = result;\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/47", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nfloat median(vector<float> l) {\n    // Sort the vector\n    sort(l.begin(), l.end());\n    \n    int n = l.size();\n    \n    if (n % 2 == 0) {\n        // If even number of elements, return the average of the two middle elements\n        return (l[n / 2 - 1] + l[n / 2]) / 2.0;\n    } else {\n        // If odd number of elements, return the middle element\n        return l[n / 2];\n    }\n}\n\n"}
{"task_id": "CPP/48", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_palindrome(string text) {\n    int left = 0;\n    int right = text.length() - 1;\n\n    while (left < right) {\n        if (text[left] != text[right]) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n\n    return true;\n}\n\n"}
{"task_id": "CPP/49", "generation": "#include <stdio.h>\nusing namespace std;\n\nint modp(int n, int p) {\n    if (n == 0)\n        return 1; // Any number to the power of 0 is 1\n\n    long result = 1;\n    long base = 2;\n\n    while (n > 0) {\n        // If n is odd, multiply the result by the current base\n        if (n % 2 == 1)\n            result = (result * base) % p;\n\n        // Square the base and reduce it modulo p\n        base = (base * base) % p;\n        n /= 2; // Divide n by 2\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/50", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring encode_shift(string s) {\n    // returns encoded string by shifting every character by 5 in the alphabet.\n    string out;\n    for (int i = 0; i < s.length(); i++) {\n        if (isalpha(s[i])) {  // Check if the character is alphabetic\n            int w = ((s[i] - 'a' + 5) % 26) + 'a';   \n            out += static_cast<char>(w);\n        } else {\n            out += s[i];  // Non-alphabetic characters remain unchanged\n        }\n    }\n    return out;\n}\n\nstring decode_shift(string s) {\n    // takes as input string encoded with encode_shift function. Returns decoded string.\n    string out;\n    for (int i = 0; i < s.length(); i++) {\n        if (isalpha(s[i])) {  // Check if the character is alphabetic\n            int w = ((s[i] - 'a' - 5 + 26) % 26) + 'a';   \n            out += static_cast<char>(w);\n        } else {\n            out += s[i];  // Non-alphabetic characters remain unchanged\n        }\n    }\n    return out;\n}\n\n"}
{"task_id": "CPP/51", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nbool is_vowel(char c) {\n    // Convert character to lowercase for simplicity\n    char lower_c = tolower(c);\n    return lower_c == 'a' || lower_c == 'e' || lower_c == 'i' || lower_c == 'o' || lower_c == 'u';\n}\n\nstring remove_vowels(string text) {\n    string result;\n    for (char c : text) {\n        if (!is_vowel(c)) {\n            result += c;\n        }\n    }\n    return result;\n}\n\n"}
{"task_id": "CPP/52", "generation": "#include <vector>\n#include <iostream>\n\n// Function to check if all elements in the vector are below the threshold\nbool below_threshold(const std::vector<int>& l, int t) {\n    for (int num : l) {\n        if (num >= t) {\n            return false;\n        }\n    }\n    return true;\n}\n\n// Function to test the below_threshold function with provided data points\nvoid check_function() {\n    assert(below_threshold({1, 2, 4, 10}, 100) == true);\n    assert(below_threshold({1, 20, 4, 10}, 5) == false);\n    std::cout << \"All tests passed successfully.\" << std::endl;\n}\n\n"}
{"task_id": "CPP/53", "generation": "#include <iostream>  // Include iostream for input/output operations\n\nusing namespace std;\n\nint add(int x, int y) {\n    return x + y;  // Return the sum of x and y\n}\n\n"}
{"task_id": "CPP/54", "generation": "#include <iostream>\n#include <string>\n#include <set>\n\nusing namespace std;\n\nbool same_chars(string s0, string s1) {\n    // Create a set for each string to store unique characters\n    set<char> chars_s0(s0.begin(), s0.end());\n    set<char> chars_s1(s1.begin(), s1.end());\n\n    // Compare the sets\n    return chars_s0 == chars_s1;\n}\n\n"}
{"task_id": "CPP/55", "generation": "#include <stdio.h>\nusing namespace std;\n\nint fib(int n) {\n    if (n <= 0) return 0;\n    else if (n == 1) return 1;\n    else return fib(n - 1) + fib(n - 2);\n}\n\n"}
{"task_id": "CPP/56", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    int count = 0;\n    \n    for (char c : brackets) {\n        if (c == '<') {\n            count++;\n        } else if (c == '>') {\n            count--;\n            if (count < 0) {\n                return false; // More closing brackets than opening ones\n            }\n        }\n    }\n    \n    return count == 0; // True if all brackets are correctly matched\n}\n\n"}
{"task_id": "CPP/57", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool monotonic(vector<float> l) {\n    if (l.size() <= 1) {\n        return true; // A vector with 0 or 1 element is trivially monotonic.\n    }\n\n    bool increasing = false;\n    bool decreasing = false;\n\n    for (size_t i = 1; i < l.size(); ++i) {\n        if (l[i] > l[i - 1]) {\n            increasing = true;\n        } else if (l[i] < l[i - 1]) {\n            decreasing = true;\n        }\n\n        // If both increasing and decreasing flags are set, the sequence is not monotonic.\n        if (increasing && decreasing) {\n            return false;\n        }\n    }\n\n    return true; // The sequence is either strictly increasing or strictly decreasing.\n}\n\n"}
{"task_id": "CPP/58", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\n\nusing namespace std;\n\nvector<int> common(vector<int> l1, vector<int> l2) {\n    // Create sets from both vectors\n    set<int> s1(l1.begin(), l1.end());\n    set<int> s2(l2.begin(), l2.end());\n\n    // Find the intersection of the two sets\n    set<int> result;\n    set_intersection(s1.begin(), s1.end(), s2.begin(), s2.end(), inserter(result, result.begin()));\n\n    // Convert the set to a vector and sort it\n    vector<int> commonElements(result.begin(), result.end());\n    sort(commonElements.begin(), commonElements.end());\n\n    return commonElements;\n}\n\n"}
{"task_id": "CPP/59", "generation": "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\nint largest_prime_factor(int n) {\n    // Remove all factors of 2\n    while (n % 2 == 0) {\n        n /= 2;\n    }\n\n    // Check for odd factors from 3 to sqrt(n)\n    int factor = 3;\n    while (factor * factor <= n) {\n        while (n % factor == 0) {\n            n /= factor;\n        }\n        factor += 2;\n    }\n\n    // If n is a prime number greater than 2\n    if (n > 2) {\n        return n;\n    } else {\n        return factor - 2; // The last factor found will be the largest prime factor\n    }\n}\n\n"}
{"task_id": "CPP/60", "generation": "#include <iostream>\nusing namespace std;\n\nint sum_to_n(int n) {\n    int sum = 0;\n    for (int i = 1; i <= n; ++i) {\n        sum += i;\n    }\n    return sum;\n}\n\n// Function to test the sum_to_n function with provided data points\nvoid test_sum_to_n() {\n    cout << \"Testing sum_to_n...\" << endl;\n    assert(sum_to_n(30) == 465);\n    assert(sum_to_n(100) == 5050);\n    assert(sum_to_n(5) == 15);\n    assert(sum_to_n(10) == 55);\n    assert(sum_to_n(1) == 1);\n\n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/61", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    int balance = 0;\n    \n    for (char bracket : brackets) {\n        if (bracket == '(') {\n            balance++;\n        } else if (bracket == ')') {\n            balance--;\n        }\n        \n        // If at any point the balance is negative, it means there's a closing bracket without an opening one\n        if (balance < 0) {\n            return false;\n        }\n    }\n    \n    // If the final balance is zero, all brackets are correctly matched\n    return balance == 0;\n}\n\n"}
{"task_id": "CPP/62", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// Function to compute the derivative of a polynomial represented by its coefficients\nvector<float> derivative(vector<float> xs) {\n    // Create a new vector to hold the derivatives, starting from index 1 (ignoring the constant term)\n    vector<float> result;\n    \n    for (size_t i = 1; i < xs.size(); ++i) {\n        // Multiply each coefficient by its corresponding power\n        result.push_back(xs[i] * static_cast<float>(i));\n    }\n    \n    return result;\n}\n\n// Function to print the polynomial coefficients\nvoid printPolynomial(const vector<float>& coeffs) {\n    for (size_t i = 0; i < coeffs.size(); ++i) {\n        cout << coeffs[i];\n        if (i != coeffs.size() - 1) {\n            cout << \" * x^\" << i;\n        }\n        if (i != coeffs.size() - 2) {\n            cout << \" + \";\n        }\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/63", "generation": "#include <iostream>\nusing namespace std;\n\nint fibfib(int n) {\n    // Base cases\n    if (n == 0 || n == 1) return 0;\n    if (n == 2) return 1;\n\n    // Array to store the computed values of FibFib sequence\n    int dp[n + 1];\n    dp[0] = 0; // fibfib(0)\n    dp[1] = 0; // fibfib(1)\n    dp[2] = 1; // fibfib(2)\n\n    // Fill the dp array using the recurrence relation\n    for (int i = 3; i <= n; ++i) {\n        dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3];\n    }\n\n    return dp[n];\n}\n\n"}
{"task_id": "CPP/64", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nint vowels_count(string s) {\n    int count = 0;\n    string vowels = \"aeiou\";\n    \n    for (char ch : s) {\n        // Check if character is a vowel or 'y' at the end of the word\n        if (vowels.find(tolower(ch)) != string::npos || \n            (ch == 'y' && tolower(ch) == tolower(s.back()))) {\n            count++;\n        }\n    }\n    \n    return count;\n}\n\n"}
{"task_id": "CPP/65", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring circular_shift(int x, int shift) {\n    // Convert the integer to a string\n    string num_str = to_string(x);\n    int num_length = num_str.length();\n    \n    // If shift is greater than or equal to the number of digits, reverse the string\n    if (shift >= num_length) {\n        return string(num_str.rbegin(), num_str.rend());\n    }\n    \n    // Perform the circular right shift\n    string shifted_str = num_str.substr(num_length - shift) + num_str.substr(0, num_length - shift);\n    return shifted_str;\n}\n\n"}
{"task_id": "CPP/66", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint digitSum(const string& s) {\n    int sum = 0;\n    for (char c : s) {\n        if (isupper(c)) { // Check if the character is uppercase\n            sum += static_cast<int>(c); // Add its ASCII value to the sum\n        }\n    }\n    return sum;\n}\n\n// Function to test the digitSum function with provided examples\nvoid checkFunction() {\n    assert(digitSum(\"\") == 0);\n    assert(digitSum(\"abAB\") == 131);\n    assert(digitSum(\"abcCd\") == 67);\n    assert(digitSum(\"helloE\") == 69);\n    assert(digitSum(\"woArBld\") == 131);\n    assert(digitSum(\"aAaaaXa\") == 153);\n\n    cout << \"All test cases passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/67", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nint fruit_distribution(string s, int n) {\n    // Split the string into parts using stringstream\n    stringstream ss(s);\n    string part;\n    int apples = 0, oranges = 0;\n\n    // Extract the number of apples and oranges from the string\n    while (getline(ss, part, ' ')) {\n        if (part == \"apples\") {\n            getline(ss, part, ' ');\n            apples = stoi(part);\n        } else if (part == \"oranges\") {\n            getline(ss, part, ' ');\n            oranges = stoi(part);\n        }\n    }\n\n    // Calculate the number of mangoes\n    int mangoes = n - (apples + oranges);\n\n    return mangoes;\n}\n\n"}
{"task_id": "CPP/68", "generation": "#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> pluck(vector<int> arr) {\n    vector<pair<int, int>> evens;\n    \n    // Filter out even numbers and store them with their indices\n    for (int i = 0; i < arr.size(); ++i) {\n        if (arr[i] % 2 == 0) {\n            evens.push_back({arr[i], i});\n        }\n    }\n    \n    // If there are no even numbers, return an empty vector\n    if (evens.empty()) {\n        return {};\n    }\n    \n    // Sort the pairs by value and then by index\n    sort(evens.begin(), evens.end());\n    \n    // Return the smallest even number and its index\n    return {evens[0].first, evens[0].second};\n}\n"}
{"task_id": "CPP/69", "generation": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint search(vector<int> lst) {\n    // Create a frequency map to count occurrences of each integer\n    unordered_map<int, int> freqMap;\n    \n    // Count the frequency of each number in the vector\n    for (int num : lst) {\n        freqMap[num]++;\n    }\n    \n    // Initialize the result as -1\n    int result = -1;\n    \n    // Iterate through the unique numbers and check the condition\n    for (auto& pair : freqMap) {\n        if (pair.first <= pair.second && pair.first > result) {\n            result = pair.first;\n        }\n    }\n    \n    return result;\n}\n\n// Function to test the search function with provided examples\nvoid test() {\n    cout << \"search({4, 1, 2, 2, 3, 1}) == \" << search({4, 1, 2, 2, 3, 1}) << endl; // Should output 2\n    cout << \"search({1, 2, 2, 3, 3, 3, 4, 4, 4}) == \" << search({1, 2, 2, 3, 3, 3, 4, 4, 4}) << endl; // Should output 3\n    cout << \"search({5, 5, 4, 4, 4}) == \" << search({5, 5, 4, 4, 4}) << endl; // Should output -1\n}\n\n"}
{"task_id": "CPP/70", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> strange_sort_list(vector<int> lst) {\n    // Sort the input list in ascending order\n    sort(lst.begin(), lst.end());\n\n    vector<int> result;\n    int left = 0; // Start index for minimum values\n    int right = lst.size() - 1; // End index for maximum values\n\n    while (left <= right) {\n        if (left == right) {\n            // If only one element is left, add it to the result\n            result.push_back(lst[left]);\n        } else {\n            // Append the minimum value from the front\n            result.push_back(lst[left++]);\n            // Append the maximum value from the back\n            result.push_back(lst[right--]);\n        }\n    }\n\n    return result;\n}\n\n// Function to check the correctness of the solution\nvoid check() {\n    assert(strange_sort_list({1, 2, 3, 4}) == vector<int>({1, 4, 2, 3}));\n    assert(strange_sort_list({5, 5, 5, 5}) == vector<int>({5, 5, 5, 5}));\n    assert(strange_sort_list({}) == vector<int>({}));\n    cout << \"All test cases passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/71", "generation": "#include <stdio.h>\n#include <math.h>\n\nusing namespace std;\n\nfloat triangle_area(float a, float b, float c) {\n    // Check if the sides form a valid triangle\n    if (a + b <= c || a + c <= b || b + c <= a) {\n        return -1;\n    }\n\n    // Calculate the semi-perimeter\n    float s = (a + b + c) / 2.0;\n\n    // Calculate the area using Heron's formula\n    float area = sqrt(s * (s - a) * (s - b) * (s - c));\n\n    // Round the result to 2 decimal points\n    return round(area * 100) / 100;\n}\n\n"}
{"task_id": "CPP/72", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool will_it_fly(vector<int> q, int w) {\n    // Check if the sum of elements is within the weight limit\n    int sum = 0;\n    for (int num : q) {\n        sum += num;\n    }\n    if (sum > w) return false;\n\n    // Check if the vector is a palindrome\n    for (size_t i = 0; i < q.size() / 2; ++i) {\n        if (q[i] != q[q.size() - 1 - i]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\n// Function to test the will_it_fly function with provided examples\nvoid check() {\n    cout << boolalpha; // Print bools as true/false instead of 1/0\n    cout << \"will_it_fly({1, 2}, 5): \" << will_it_fly({1, 2}, 5) << endl;\n    cout << \"will_it_fly({3, 2, 3}, 1): \" << will_it_fly({3, 2, 3}, 1) << endl;\n    cout << \"will_it_fly({3, 2, 3}, 9): \" << will_it_fly({3, 2, 3}, 9) << endl;\n    cout << \"will_it_fly({3}, 5): \" << will_it_fly({3}, 5) << endl;\n}\n\n"}
{"task_id": "CPP/73", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint smallest_change(vector<int> arr) {\n    int n = arr.size();\n    int left = 0;\n    int right = n - 1;\n    int changes = 0;\n\n    while (left < right) {\n        if (arr[left] != arr[right]) {\n            changes++;\n        }\n        left++;\n        right--;\n    }\n\n    return changes;\n}\n\n"}
{"task_id": "CPP/74", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to calculate the total number of characters in a vector of strings\nint total_chars(const vector<string>& vec) {\n    int sum = 0;\n    for (const auto& str : vec) {\n        sum += str.length();\n    }\n    return sum;\n}\n\nvector<string> total_match(vector<string> lst1, vector<string> lst2) {\n    // Calculate the total number of characters in both vectors\n    int chars_lst1 = total_chars(lst1);\n    int chars_lst2 = total_chars(lst2);\n\n    // Compare and return the appropriate vector\n    if (chars_lst1 < chars_lst2) {\n        return lst1;\n    } else if (chars_lst2 < chars_lst1) {\n        return lst2;\n    } else {\n        return lst1;  // Return the first vector if both have the same number of characters\n    }\n}\n\n// Function to test the total_match function with provided examples\nvoid test_total_match() {\n    cout << \"Test 1: \";\n    vector<string> result = total_match({}, {});\n    for (const auto& str : result) {\n        cout << str << \" \";\n    }\n    cout << endl;\n\n    cout << \"Test 2: \";\n    result = total_match({\"hi\", \"admin\"}, {\"hI\", \"Hi\"});\n    for (const auto& str : result) {\n        cout << str << \" \";\n    }\n    cout << endl;\n\n    cout << \"Test 3: \";\n    result = total_match({\"hi\", \"admin\"}, {\"hi\", \"hi\", \"admin\", \"project\"});\n    for (const auto& str : result) {\n        cout << str << \" \";\n    }\n    cout << endl;\n\n    cout << \"Test 4: \";\n    result = total_match({\"hi\", \"admin\"}, {\"hI\", \"hi\", \"hi\"});\n    for (const auto& str : result) {\n        cout << str << \" \";\n    }\n    cout << endl;\n\n    cout << \"Test 5: \";\n    result = total_match({\"4\"}, {\"1\", \"2\", \"3\", \"4\", \"5\"});\n    for (const auto& str : result) {\n        cout << str << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/75", "generation": "#include <iostream>\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    if (n == 2 || n == 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    for (int i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0)\n            return false;\n    }\n    return true;\n}\n\n// Function to check if the given number is a product of exactly three prime numbers\nbool is_multiply_prime(int a) {\n    // Generate all primes less than 100\n    int primes[] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97};\n    int num_primes = sizeof(primes) / sizeof(primes[0]);\n\n    // Try all combinations of three primes\n    for (int i = 0; i < num_primes; ++i) {\n        for (int j = i; j < num_primes; ++j) {\n            for (int k = j; k < num_primes; ++k) {\n                if (primes[i] * primes[j] * primes[k] == a)\n                    return true;\n            }\n        }\n    }\n\n    return false;\n}\n\n// Function to test the is_multiply_prime function\nvoid test() {\n    cout << \"Testing is_multiply_prime...\" << endl;\n    assert(is_multiply_prime(30) == true); // 2 * 3 * 5 = 30\n    assert(is_multiply_prime(60) == false); // Not a product of exactly three primes\n    assert(is_multiply_prime(105) == true); // 3 * 5 * 7 = 105\n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/76", "generation": "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\nbool is_simple_power(int x, int n) {\n    if (n == 1) {\n        return x == 1; // Special case: 1^any_number = 1\n    }\n    \n    double log_result = log(x) / log(n);\n    return floor(log_result) == log_result;\n}\n\n"}
{"task_id": "CPP/77", "generation": "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\nbool iscube(int a) {\n    if (a == 0) {\n        return true;\n    }\n    \n    for (int i = 0; i <= abs(a); ++i) {\n        if (pow(i, 3) == abs(a)) {\n            return true;\n        }\n    }\n    \n    return false;\n}\n\n"}
{"task_id": "CPP/78", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nint hex_key(string num) {\n    // Define a set of prime hexadecimal digits\n    const string primes = \"2357BD\";\n    \n    int count = 0;\n    \n    // Iterate through each character in the input string\n    for (char c : num) {\n        if (primes.find(c) != string::npos) {\n            ++count;  // Increment count if the digit is prime\n        }\n    }\n    \n    return count;\n}\n\n"}
{"task_id": "CPP/79", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\n// Function to convert decimal to binary\nstring decimal_to_binary(int decimal) {\n    if (decimal == 0) {\n        return \"db0db\";\n    }\n\n    string binary = \"\";\n    while (decimal > 0) {\n        int remainder = decimal % 2;\n        binary = to_string(remainder) + binary;\n        decimal /= 2;\n    }\n    \n    // Add the prefix and suffix\n    return \"db\" + binary + \"db\";\n}\n\n// Function to check the correctness of the conversion\nvoid check_conversion(int decimal, const string& expected) {\n    string result = decimal_to_binary(decimal);\n    cout << \"decimal: \" << decimal << \", expected: \" << expected << \", got: \" << result << endl;\n    if (result == expected) {\n        cout << \"Test passed.\" << endl;\n    } else {\n        cout << \"Test failed.\" << endl;\n    }\n}\n\n"}
{"task_id": "CPP/80", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_happy(string s) {\n    // Check if the string length is less than 3\n    if (s.length() < 3) return false;\n    \n    // Iterate through the string, checking every set of three consecutive characters\n    for (size_t i = 0; i <= s.length() - 3; ++i) {\n        // Check if any two out of the three consecutive characters are the same\n        if (s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]) {\n            return false;\n        }\n    }\n    \n    // If no three consecutive characters are the same, the string is happy\n    return true;\n}\n\n"}
{"task_id": "CPP/81", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\n// Function to convert GPA to letter grade\nstring gpa_to_letter(float gpa) {\n    if (gpa >= 4.0f) return \"A+\";\n    else if (gpa > 3.7f) return \"A\";\n    else if (gpa > 3.3f) return \"A-\";\n    else if (gpa > 3.0f) return \"B+\";\n    else if (gpa > 2.7f) return \"B\";\n    else if (gpa > 2.3f) return \"B-\";\n    else if (gpa > 2.0f) return \"C+\";\n    else if (gpa > 1.7f) return \"C\";\n    else if (gpa > 1.3f) return \"C-\";\n    else if (gpa > 1.0f) return \"D+\";\n    else if (gpa > 0.7f) return \"D\";\n    else if (gpa > 0.0f) return \"D-\";\n    else return \"E\";\n}\n\n// Function to convert vector of GPAs to vector of letter grades\nvector<string> numerical_letter_grade(vector<float> grades) {\n    vector<string> letter_grades;\n    for (float gpa : grades) {\n        letter_grades.push_back(gpa_to_letter(gpa));\n    }\n    return letter_grades;\n}\n\n// Function to check the correctness of the function\nvoid check() {\n    vector<float> test_grades = {4.0f, 3.0f, 1.7f, 2.0f, 3.5f};\n    vector<string> expected = {\"A+\", \"B\", \"C-\", \"C\", \"A-\"};\n    vector<string> result = numerical_letter_grade(test_grades);\n    \n    if (result == expected) {\n        cout << \"Test passed!\" << endl;\n    } else {\n        cout << \"Test failed. Expected: \";\n        for (const auto& grade : expected) {\n            cout << grade << \" \";\n        }\n        cout << \"\\nGot: \";\n        for (const auto& grade : result) {\n            cout << grade << \" \";\n        }\n        cout << endl;\n    }\n}\n\n"}
{"task_id": "CPP/82", "generation": "#include <iostream>\n#include <string>\n\n// Function to check if a number is prime\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    if (n == 2 || n == 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n\n    for (int i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0)\n            return false;\n    }\n    return true;\n}\n\n// Function to check if the length of a string is prime\nbool prime_length(string str) {\n    int len = str.length();\n    return is_prime(len);\n}\n\n"}
{"task_id": "CPP/83", "generation": "#include <iostream>\n#include <cmath>\n\nint starts_one_ends(int n) {\n    if (n == 1) {\n        return 1;  // Only one 1-digit number that starts and ends with 1\n    }\n\n    // Calculate the count of numbers starting or ending with 1\n    int total_count = (9 * static_cast<int>(pow(10, n - 2))) * 2 - static_cast<int>(pow(10, n - 2));\n\n    return total_count;\n}\n\n"}
{"task_id": "CPP/84", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring solve(int N) {\n    int sum = 0;\n    \n    // Calculate the sum of digits\n    while (N > 0) {\n        sum += N % 10;  // Add the last digit to the sum\n        N /= 10;        // Remove the last digit from N\n    }\n    \n    // Convert the sum to binary string\n    string binarySum = \"\";\n    if (sum == 0) {\n        return \"0\";\n    }\n    \n    while (sum > 0) {\n        binarySum = to_string(sum % 2) + binarySum;  // Prepend the remainder when divided by 2\n        sum /= 2;                                    // Divide the sum by 2\n    }\n    \n    return binarySum;\n}\n\n"}
{"task_id": "CPP/85", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint add(vector<int> lst) {\n    int sum = 0;\n    \n    // Iterate through the vector starting from index 1 (second element)\n    for (size_t i = 1; i < lst.size(); i += 2) {\n        if (lst[i] % 2 == 0) {  // Check if the element at an odd index is even\n            sum += lst[i];\n        }\n    }\n    \n    return sum;\n}\n\n"}
{"task_id": "CPP/86", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n\nusing namespace std;\n\nstring anti_shuffle(string s) {\n    // Split the string into words based on spaces\n    stringstream ss(s);\n    vector<string> words;\n    string word;\n    \n    while (getline(ss, word, ' ')) {\n        words.push_back(word);\n    }\n    \n    // Process each word: sort its characters and join them back together\n    for (auto& w : words) {\n        sort(w.begin(), w.end());\n    }\n    \n    // Reconstruct the sentence with sorted words\n    string result;\n    for (size_t i = 0; i < words.size(); ++i) {\n        if (!result.empty()) {\n            result += \" \";\n        }\n        result += words[i];\n    }\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/87", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to get the row and column indices where x appears\nvector<vector<int>> get_row(vector<vector<int>> lst, int x) {\n    vector<vector<int>> result;\n    \n    // Iterate through each row in the list\n    for (size_t i = 0; i < lst.size(); ++i) {\n        const auto& row = lst[i];\n        \n        // Iterate through each element in the current row\n        for (size_t j = 0; j < row.size(); ++j) {\n            if (row[j] == x) {\n                result.push_back({static_cast<int>(i), static_cast<int>(j)});\n            }\n        }\n    }\n\n    // Sort by rows in ascending order and then by columns in descending order within each row\n    sort(result.begin(), result.end(), [](const vector<int>& a, const vector<int>& b) {\n        if (a[0] == b[0]) return a[1] > b[1]; // Descending order for columns\n        return a[0] < b[0]; // Ascending order for rows\n    });\n\n    return result;\n}\n\n// Function to print the result for verification\nvoid print_result(const vector<vector<int>>& result) {\n    for (const auto& coord : result) {\n        cout << \"{\" << coord[0] << \", \" << coord[1] << \"} \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/88", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> sort_array(vector<int> array) {\n    // Check if the vector is empty or has only one element\n    if (array.empty() || array.size() == 1) {\n        return array;\n    }\n\n    int first = array.front();\n    int last = array.back();\n\n    // Calculate the sum of the first and last elements\n    int sum = first + last;\n\n    // Determine the sorting order based on the sum being odd or even\n    if (sum % 2 == 0) {\n        // Sort in descending order\n        vector<int> sorted_array(array);\n        sort(sorted_array.rbegin(), sorted_array.rend());\n        return sorted_array;\n    } else {\n        // Sort in ascending order\n        vector<int> sorted_array(array);\n        sort(sorted_array.begin(), sorted_array.end());\n        return sorted_array;\n    }\n}\n\n// Function to test the solution with provided examples\nvoid check() {\n    printf(\"{%s}\\n\", sort_array({}).empty() ? \"[]\" : \"{5, 4, 3, 2, 1}\"); // Example might be incorrect for empty vector\n    printf(\"{%d}\\n\", sort_array({5})[0]); // Should return {5}\n    printf(\"{%s}\\n\", sort_array({2, 4, 3, 0, 1, 5}).begin(), sort_array({2, 4, 3, 0, 1, 5}).end()); // Should return [0, 1, 2, 3, 4, 5]\n    printf(\"{%s}\\n\", sort_array({2, 4, 3, 0, 1, 5, 6}).rbegin(), sort_array({2, 4, 3, 0, 1, 5, 6}).rend()); // Should return [6, 5, 4, 3, 2, 1, 0]\n}\n\n"}
{"task_id": "CPP/89", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\n// Function to rotate a single character by 4 places\nchar rotateChar(char c) {\n    if (c >= 'a' && c <= 'z') {\n        return ((c - 'a' + 4) % 26) + 'a';\n    } else if (c >= 'A' && c <= 'Z') {\n        return ((c - 'A' + 4) % 26) + 'A';\n    }\n    // Non-alphabetic characters are not rotated\n    return c;\n}\n\n// Function to encrypt the string by rotating each character\nstring encrypt(string s) {\n    for (char &c : s) {\n        c = rotateChar(c);\n    }\n    return s;\n}\n\n"}
{"task_id": "CPP/90", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to find the second smallest element in a vector\nint next_smallest(vector<int> lst) {\n    if (lst.size() < 2) {\n        return -1; // Return -1 to indicate no second smallest element\n    }\n\n    // Remove duplicates and sort the unique elements\n    auto it = unique(lst.begin(), lst.end());\n    lst.erase(it, lst.end());\n    \n    if (lst.size() < 2) {\n        return -1; // Return -1 to indicate no second smallest element\n    }\n    \n    // Sort the vector again after removing duplicates\n    sort(lst.begin(), lst.end());\n\n    // The second smallest element is now at index 1\n    return lst[1];\n}\n\n// Function to test the next_smallest function\nvoid test_next_smallest() {\n    assert(next_smallest({1, 2, 3, 4, 5}) == 2);\n    assert(next_smallest({5, 1, 4, 3, 2}) == 2);\n    assert(next_smallest({}) == -1);\n    assert(next_smallest({1, 1}) == -1);\n    cout << \"All test cases passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/91", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <vector>\n\nusing namespace std;\n\nint is_bored(const string& S) {\n    // Split the string into sentences based on '.', '?' or '!'\n    vector<string> sentences;\n    stringstream ss(S);\n    string sentence;\n    \n    while (getline(ss, sentence, '.')) {\n        if (!sentence.empty()) {\n            sentences.push_back(sentence);\n        }\n    }\n    while (getline(ss, sentence, '?')) {\n        if (!sentence.empty()) {\n            sentences.push_back(sentence);\n        }\n    }\n    while (getline(ss, sentence, '!')) {\n        if (!sentence.empty()) {\n            sentences.push_back(sentence);\n        }\n    }\n\n    // Count the number of sentences that start with \"I\"\n    int boredom_count = 0;\n    for (const string& s : sentences) {\n        size_t pos = s.find_first_not_of(\" \\t\");\n        if (pos != string::npos && s.substr(pos, 1) == \"I\") {\n            ++boredom_count;\n        }\n    }\n\n    return boredom_count;\n}\n\n"}
{"task_id": "CPP/92", "generation": "#include <iostream>\nusing namespace std;\n\nbool is_integer(float num) {\n    return floor(num) == num;\n}\n\nbool any_int(float a, float b, float c) {\n    // Check if all numbers are integers\n    if (is_integer(a) && is_integer(b) && is_integer(c)) {\n        // Check if one of the numbers is equal to the sum of the other two\n        return (a == b + c) || (b == a + c) || (c == a + b);\n    } else {\n        return false;\n    }\n}\n\n"}
{"task_id": "CPP/93", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to encode the message\nstring encode(string message) {\n    // Define vowels and their replacements\n    string vowels = \"aeiouAEIOU\";\n    string replacements = \"cgkqwuCGKQWU\";\n\n    for (char &c : message) {\n        // Swap case\n        if (isalpha(c)) {\n            c ^= 32; // Toggle between uppercase and lowercase\n\n            // Replace vowels with their corresponding replacement\n            auto it = find(vowels.begin(), vowels.end(), c);\n            if (it != vowels.end()) {\n                c = replacements[it - vowels.begin()];\n            }\n        }\n    }\n\n    return message;\n}\n\n"}
{"task_id": "CPP/94", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\nint sum_of_digits(int n) {\n    int sum = 0;\n    while (n > 0) {\n        sum += n % 10;\n        n /= 10;\n    }\n    return sum;\n}\n\nint find_largest_prime_sum(vector<int> lst) {\n    int max_prime = -1;\n    for (int num : lst) {\n        if (is_prime(num)) {\n            max_prime = max(max_prime, num);\n        }\n    }\n\n    if (max_prime == -1) {\n        return 0;\n    }\n\n    return sum_of_digits(max_prime);\n}\n\n"}
{"task_id": "CPP/95", "generation": "#include <iostream>\n#include <string>\n#include <map>\n\nbool check_dict_case(const std::map<std::string, std::string>& dict) {\n    if (dict.empty()) {\n        return false;\n    }\n\n    bool all_lower = true;\n    bool all_upper = true;\n\n    for (const auto& pair : dict) {\n        const std::string& key = pair.first;\n        if (!key.empty() && !std::islower(key[0])) {\n            all_lower = false;\n        }\n        if (!key.empty() && !std::isupper(key[0])) {\n            all_upper = false;\n        }\n\n        if (!all_lower && !all_upper) {\n            return false;\n        }\n    }\n\n    return all_lower || all_upper;\n}\n\n"}
{"task_id": "CPP/96", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Helper function to check if a number is prime\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    for (int i = 2; i * i <= num; ++i) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\n// Function to generate a vector of prime numbers less than n\nvector<int> count_up_to(int n) {\n    vector<int> primes;\n    for (int i = 2; i < n; ++i) {\n        if (is_prime(i)) {\n            primes.push_back(i);\n        }\n    }\n    return primes;\n}\n\n// Function to test the count_up_to function\nvoid test_count_up_to() {\n    assert(count_up_to(5) == vector<int>({2, 3}));\n    assert(count_up_to(11) == vector<int>({2, 3, 5, 7}));\n    assert(count_up_to(0).empty());\n    assert(count_up_to(20) == vector<int>({2, 3, 5, 7, 11, 13, 17, 19}));\n    assert(count_up_to(1).empty());\n    assert(count_up_to(18) == vector<int>({2, 3, 5, 7, 11, 13, 17}));\n\n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/97", "generation": "#include <iostream>\nusing namespace std;\n\nint multiply(int a, int b) {\n    // Extract the unit digit of both numbers\n    int unit_digit_a = abs(a % 10);\n    int unit_digit_b = abs(b % 10);\n\n    // Multiply the unit digits and return the result\n    return unit_digit_a * unit_digit_b;\n}\n\n"}
{"task_id": "CPP/98", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint count_upper(const string& s) {\n    int count = 0;\n    for (size_t i = 0; i < s.length(); i += 2) { // Iterate through even indices\n        char c = s[i];\n        if (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n            count++;\n        }\n    }\n    return count;\n}\n\n"}
{"task_id": "CPP/99", "generation": "#include <iostream>\n#include <cmath>\n#include <string>\nusing namespace std;\n\nint closest_integer(string value) {\n    // Convert string to double\n    double num = stod(value);\n    \n    // Determine the two nearest integers\n    int lower_int = static_cast<int>(floor(num));\n    int upper_int = static_cast<int>(ceil(num));\n    \n    // Check which integer is closer or if they are equidistant, round away from zero\n    if (num - lower_int == upper_int - num) {\n        return abs(num) > abs(lower_int) ? upper_int : lower_int;\n    } else {\n        return num - lower_int < 0.5 ? lower_int : upper_int;\n    }\n}\n\n"}
{"task_id": "CPP/100", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> make_a_pile(int n) {\n    vector<int> pile;\n    int current_stones = n;\n\n    for (int i = 0; i < n; ++i) {\n        pile.push_back(current_stones);\n        // Determine the next number of stones\n        if (current_stones % 2 == 0) {\n            current_stones += 2; // Next even number\n        } else {\n            current_stones += 2; // Next odd number\n        }\n    }\n\n    return pile;\n}\n\n// Function to check the correctness of the solution\nvoid check_solution() {\n    vector<int> result1 = make_a_pile(3);\n    assert(result1 == vector<int>({3, 5, 7}));\n\n    vector<int> result2 = make_a_pile(4);\n    assert(result2 == vector<int>({4, 6, 8, 10}));\n\n    vector<int> result3 = make_a_pile(1);\n    assert(result3 == vector<int>({1, 3}));\n\n    cout << \"All test cases passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/101", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nvector<string> words_string(string s) {\n    vector<string> result;\n    stringstream ss(s);\n    string word;\n\n    while (getline(ss, word, ',')) {  // Split by commas first\n        stringstream wordStream(word);  // Create a new stream for the current word\n        while (wordStream >> word) {  // Extract words from the current word\n            result.push_back(word);\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/102", "generation": "#include <iostream>\nusing namespace std;\n\nint choose_num(int x, int y) {\n    // Ensure x is less than or equal to y\n    if (x > y) {\n        return -1;\n    }\n\n    // Start from the end of the range and check for the largest even number\n    for (int i = y; i >= x; --i) {\n        if (i % 2 == 0) {\n            return i;\n        }\n    }\n\n    // If no even number is found, return -1\n    return -1;\n}\n\n// Function to test the choose_num function with some examples\nvoid test() {\n    cout << \"choose_num(12, 15): \" << choose_num(12, 15) << endl; // Should output 14\n    cout << \"choose_num(13, 12): \" << choose_num(13, 12) << endl; // Should output -1\n    cout << \"choose_num(10, 20): \" << choose_num(10, 20) << endl; // Should output 20\n    cout << \"choose_num(21, 25): \" << choose_num(21, 25) << endl; // Should output 24\n}\n\n"}
{"task_id": "CPP/103", "generation": "#include <stdio.h>\n#include <math.h>\n#include <string>\nusing namespace std;\n\nstring rounded_avg(int n, int m) {\n    // Check if n is greater than m\n    if (n > m) {\n        return \"-1\";\n    }\n\n    // Calculate the sum of integers from n to m\n    long long sum = 0;\n    for (int i = n; i <= m; ++i) {\n        sum += i;\n    }\n\n    // Calculate the average and round it down\n    int avg = sum / (m - n + 1);\n\n    // Convert the rounded average to binary string\n    string binary = \"\";\n    if (avg == 0) {\n        binary = \"0\";\n    } else {\n        while (avg > 0) {\n            binary = to_string(avg % 2) + binary;\n            avg /= 2;\n        }\n    }\n\n    return binary;\n}\n\n"}
{"task_id": "CPP/104", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nbool hasEvenDigit(int num) {\n    while (num > 0) {\n        int digit = num % 10;\n        if (digit % 2 == 0) {\n            return true; // Found an even digit\n        }\n        num /= 10;\n    }\n    return false; // No even digits found\n}\n\nvector<int> unique_digits(vector<int> x) {\n    vector<int> result;\n\n    for (int num : x) {\n        if (!hasEvenDigit(num)) {\n            result.push_back(num);\n        }\n    }\n\n    sort(result.begin(), result.end());\n    return result;\n}\n\n"}
{"task_id": "CPP/105", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to convert a digit to its corresponding name\nstring num_to_word(int n) {\n    map<int, string> digit_names = {\n        {1, \"One\"}, {2, \"Two\"}, {3, \"Three\"}, {4, \"Four\"},\n        {5, \"Five\"}, {6, \"Six\"}, {7, \"Seven\"}, {8, \"Eight\"}, {9, \"Nine\"}\n    };\n    return digit_names[n];\n}\n\n// Function to process the vector as per the problem statement\nvector<string> by_length(vector<int> arr) {\n    // Filter out numbers that are not between 1 and 9\n    vector<int> filtered_arr;\n    for (int num : arr) {\n        if (num >= 1 && num <= 9) {\n            filtered_arr.push_back(num);\n        }\n    }\n\n    // Sort the filtered array\n    sort(filtered_arr.begin(), filtered_arr.end());\n\n    // Reverse the sorted array\n    reverse(filtered_arr.begin(), filtered_arr.end());\n\n    // Convert each number to its corresponding name and store in a vector of strings\n    vector<string> result;\n    for (int num : filtered_arr) {\n        result.push_back(num_to_word(num));\n    }\n\n    return result;\n}\n\n// Function to check the correctness of the by_length function\nvoid check() {\n    vector<int> arr1 = {2, 1, 1, 4, 5, 8, 2, 3};\n    vector<string> expected1 = {\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"};\n    assert(by_length(arr1) == expected1);\n\n    vector<int> arr2 = {};\n    vector<string> expected2 = {};\n    assert(by_length(arr2) == expected2);\n\n    vector<int> arr3 = {1, -1, 55};\n    vector<string> expected3 = {\"One\"};\n    assert(by_length(arr3) == expected3);\n\n    printf(\"All test cases passed.\\n\");\n}\n\n"}
{"task_id": "CPP/106", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Function to compute the factorial of a number\nint factorial(int num) {\n    if (num == 0 || num == 1)\n        return 1;\n    int fact = 1;\n    for (int i = 2; i <= num; ++i) {\n        fact *= i;\n    }\n    return fact;\n}\n\n// Function to compute the sum of numbers from 1 to a number\nint sumTo(int num) {\n    return (num * (num + 1)) / 2;\n}\n\nvector<int> f(int n) {\n    vector<int> result(n);\n    \n    for (int i = 0; i < n; ++i) {\n        if ((i + 1) % 2 == 0) { // Check if the index is even\n            result[i] = factorial(i + 1); // Factorial of (i+1)\n        } else { // The index is odd\n            result[i] = sumTo(i + 1); // Sum from 1 to (i+1)\n        }\n    }\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/107", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nbool is_palindrome(int num) {\n    string str = to_string(num);\n    int left = 0;\n    int right = str.length() - 1;\n    \n    while (left < right) {\n        if (str[left] != str[right]) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n    return true;\n}\n\nvector<int> even_odd_palindrome(int n) {\n    vector<int> result(2, 0); // Initialize with two elements for even and odd counts\n    for (int i = 1; i <= n; ++i) {\n        if (is_palindrome(i)) {\n            if (i % 2 == 0) {\n                result[0]++; // Even palindrome count\n            } else {\n                result[1]++; // Odd palindrome count\n            }\n        }\n    }\n    return result;\n}\n\n"}
{"task_id": "CPP/108", "generation": "#include <vector>\nusing namespace std;\n\n// Helper function to calculate the sum of signed digits of a number.\nint sum_of_digits(int num) {\n    if (num == 0) {\n        return 0;\n    } else if (num < 0) {\n        int abs_num = -num;\n        int sum = 0;\n        while (abs_num > 0) {\n            int digit = abs_num % 10;\n            sum += (digit * ((num < 0) ? -1 : 1));\n            abs_num /= 10;\n        }\n        return sum;\n    } else {\n        int sum = 0;\n        while (num > 0) {\n            int digit = num % 10;\n            sum += digit;\n            num /= 10;\n        }\n        return sum;\n    }\n}\n\n// Main function to count the number of elements with a sum of digits > 0.\nint count_nums(vector<int> n) {\n    int count = 0;\n    for (int num : n) {\n        if (sum_of_digits(num) > 0) {\n            count++;\n        }\n    }\n    return count;\n}\n\n// Function to check the correctness of the count_nums function.\nvoid check() {\n    assert(count_nums({}) == 0);\n    assert(count_nums({-1, 11, -11}) == 1);\n    assert(count_nums({1, 1, 2}) == 3);\n    cout << \"All test cases passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/109", "generation": "#include <vector>\nusing namespace std;\n\nbool move_one_ball(vector<int> arr) {\n    int n = arr.size();\n    \n    if (n == 0) {\n        return true;\n    }\n    \n    // Find the index where a right shift would make the array sorted in non-decreasing order\n    int i = 0;\n    for (; i < n - 1; ++i) {\n        if (arr[i] > arr[i + 1]) {\n            break;\n        }\n    }\n    if (i == n - 1) { // If no such index is found, the array is already sorted or has only one element\n        return true;\n    }\n    \n    // Perform a right shift and check if the array becomes sorted\n    vector<int> shifted_arr(arr.begin() + i + 1, arr.end());\n    shifted_arr.insert(shifted_arr.end(), arr.begin(), arr.begin() + i + 1);\n    \n    for (int j = 0; j < n - 1; ++j) {\n        if (shifted_arr[j] > shifted_arr[j + 1]) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n"}
{"task_id": "CPP/110", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nstring exchange(vector<int> lst1, vector<int> lst2) {\n    // Check if there is at least one even number in lst1 or all numbers in lst2 are odd\n    bool has_even_in_lst1 = any_of(lst1.begin(), lst1.end(), [](int num){ return num % 2 == 0; });\n    bool all_odd_in_lst2 = all_of(lst2.begin(), lst2.end(), [](int num){ return num % 2 != 0; });\n\n    // If there is an even number in lst1 or if all numbers in lst2 are odd, return \"YES\"\n    // Otherwise, return \"NO\"\n    if (has_even_in_lst1 || all_odd_in_lst2) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n\n"}
{"task_id": "CPP/111", "generation": "#include <iostream>\n#include <string>\n#include <map>\n#include <vector>\nusing namespace std;\n\nmap<char, int> histogram(string test) {\n    map<char, int> charCount;\n    \n    // Count occurrences of each character\n    for (char c : test) {\n        if (c != ' ') {  // Ignore spaces\n            charCount[c]++;\n        }\n    }\n\n    // Find the maximum count\n    int maxCount = 0;\n    for (const auto& pair : charCount) {\n        if (pair.second > maxCount) {\n            maxCount = pair.second;\n        }\n    }\n\n    // Collect characters with the highest frequency\n    map<char, int> result;\n    for (const auto& pair : charCount) {\n        if (pair.second == maxCount) {\n            result.insert(pair);\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/112", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to check if a string is a palindrome\nbool is_palindrome(const string& str) {\n    int left = 0;\n    int right = str.size() - 1;\n    while (left < right) {\n        if (str[left] != str[right]) {\n            return false;\n        }\n        ++left;\n        --right;\n    }\n    return true;\n}\n\n// Function to reverse delete characters\nvector<string> reverse_delete(string s, string c) {\n    // Remove all characters in s that are present in c\n    for (char ch : c) {\n        s.erase(remove(s.begin(), s.end(), ch), s.end());\n    }\n\n    // Check if the resulting string is a palindrome\n    bool result = is_palindrome(s);\n\n    // Return the result as a vector containing the modified string and the boolean\n    return {s, (result ? \"True\" : \"False\")};\n}\n\n"}
{"task_id": "CPP/113", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<string> odd_count(vector<string> lst) {\n    vector<string> result;\n    \n    for (const auto& str : lst) {\n        int count = 0;\n        \n        // Count the number of odd digits in the string\n        for (char c : str) {\n            if ((c - '0') % 2 != 0) {\n                count++;\n            }\n        }\n\n        // Construct the result string\n        string output = \"the number of odd elements \";\n        output += to_string(count);\n        output += \"n the str\";\n        output += to_string(count);\n        output += \"ng \";\n        output += to_string(count);\n        output += \" of the \";\n        output += to_string(count);\n        output += \"nput.\";\n        \n        result.push_back(output);\n    }\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/114", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nlong long minSubArraySum(vector<long long> nums) {\n    if (nums.empty()) return 0; // Handle empty vector case\n\n    long long current_min = nums[0];\n    long long global_min = nums[0];\n\n    for (size_t i = 1; i < nums.size(); ++i) {\n        // Update the current minimum sum ending at position i\n        current_min = min(nums[i], current_min + nums[i]);\n        \n        // Update the global minimum sum found so far\n        if (current_min < global_min) {\n            global_min = current_min;\n        }\n    }\n\n    return global_min;\n}\n\n"}
{"task_id": "CPP/115", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint max_fill(vector<vector<int>> grid, int capacity) {\n    int total_lowerings = 0;\n    \n    // Iterate through each well (row)\n    for (const auto& row : grid) {\n        int water_units = 0;\n        \n        // Count the number of units of water in the current well\n        for (int unit : row) {\n            if (unit == 1) {\n                ++water_units;\n            }\n        }\n        \n        // Calculate the number of times the bucket needs to be lowered\n        total_lowerings += (water_units + capacity - 1) / capacity;\n    }\n    \n    return total_lowerings;\n}\n\n"}
{"task_id": "CPP/116", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\n// Function to count the number of ones in the binary representation of a number\nint count_ones(int n) {\n    int count = 0;\n    while (n > 0) {\n        count += n & 1; // Check if the least significant bit is set\n        n >>= 1;       // Right shift to check the next bit\n    }\n    return count;\n}\n\n// Comparator function for sorting based on number of ones and decimal value\nbool compare(int a, int b) {\n    int ones_a = count_ones(a);\n    int ones_b = count_ones(b);\n\n    if (ones_a == ones_b) {\n        return a < b; // Sort by decimal value if the number of ones is the same\n    }\n    return ones_a < ones_b; // Otherwise, sort by the number of ones\n}\n\n// Function to sort the array based on the specified criteria\nstd::vector<int> sort_array(std::vector<int> arr) {\n    std::sort(arr.begin(), arr.end(), compare);\n    return arr;\n}\n\n"}
{"task_id": "CPP/117", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nbool is_consonant(char c) {\n    return std::isalpha(c) && !(std::tolower(c) == 'a' || std::tolower(c) == 'e' || std::tolower(c) == 'i' || std::tolower(c) == 'o' || std::tolower(c) == 'u');\n}\n\nvector<string> select_words(string s, int n) {\n    if (s.empty()) {\n        return {};\n    }\n\n    vector<string> result;\n    string word;\n\n    for (char c : s) {\n        if (c != ' ') {\n            // Add character to the current word\n            word += c;\n        } else {\n            // Check if the current word has exactly n consonants\n            int consonant_count = std::count_if(word.begin(), word.end(), is_consonant);\n            if (consonant_count == n) {\n                result.push_back(word);\n            }\n            // Reset word for the next word\n            word.clear();\n        }\n    }\n\n    // Check the last word in case it doesn't end with a space\n    int consonant_count = std::count_if(word.begin(), word.end(), is_consonant);\n    if (consonant_count == n) {\n        result.push_back(word);\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/118", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nbool isVowel(char c) {\n    return c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' ||\n           c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U';\n}\n\nstring get_closest_vowel(string word) {\n    int n = word.length();\n    \n    // Iterate from right to left, starting from the second last character\n    for (int i = n - 2; i > 0; --i) {\n        if (isVowel(word[i]) && isalpha(word[i-1]) && !isalpha(word[i+1])) {\n            return string(1, word[i]);\n        }\n    }\n    \n    return \"\";\n}\n\n"}
{"task_id": "CPP/119", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nbool is_balanced(const string& s) {\n    int balance = 0;\n    for (char c : s) {\n        if (c == '(') {\n            balance += 1;\n        } else {\n            balance -= 1;\n        }\n        if (balance < 0) {\n            return false;\n        }\n    }\n    return balance == 0;\n}\n\nstring match_parens(vector<string> lst) {\n    // Check both possible concatenations\n    if (is_balanced(lst[0] + lst[1]) || is_balanced(lst[1] + lst[0])) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\n\n"}
{"task_id": "CPP/120", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> maximum(vector<int> arr, int k) {\n    // Sort the array in descending order\n    sort(arr.begin(), arr.end(), greater<int>());\n    \n    // If k is 0 or negative, return an empty vector\n    if (k <= 0 || k > arr.size()) {\n        return {};\n    }\n    \n    // Slice the first k elements from the sorted array\n    vector<int> result(arr.begin(), arr.begin() + k);\n    \n    // Sort the resulting vector in ascending order as required\n    sort(result.begin(), result.end());\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/121", "generation": "#include <vector>\nusing namespace std;\n\nint solution(vector<int> lst) {\n    int sum = 0;\n    for (size_t i = 0; i < lst.size(); ++i) {\n        // Check if the index is even and the element at that position is odd\n        if (i % 2 == 0 && lst[i] % 2 != 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n\n// Function to test the solution with provided examples\nvoid check_solution() {\n    assert(solution({5, 8, 7, 1}) == 12);\n    assert(solution({3, 3, 3, 3, 3}) == 9);\n    assert(solution({30, 13, 24, 321}) == 0);\n}\n\n"}
{"task_id": "CPP/122", "generation": "#include <vector>\n#include <iostream>\n\nint add_elements(std::vector<int> arr, int k) {\n    int sum = 0;\n    \n    // Iterate through the first k elements of the array\n    for (int i = 0; i < k; ++i) {\n        // Check if the element has at most two digits\n        if (arr[i] >= 0 && arr[i] < 100) {\n            sum += arr[i];\n        }\n    }\n    \n    return sum;\n}\n\n"}
{"task_id": "CPP/123", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n// Function to generate and return the odd numbers in the Collatz sequence of n.\nvector<int> get_odd_collatz(int n) {\n    vector<int> result;\n    \n    // Generate the Collatz sequence until it reaches 1\n    while (n != 1) {\n        if (n % 2 == 0) {\n            n /= 2;  // If n is even, divide by 2\n        } else {\n            result.push_back(n);  // If n is odd, add to the result vector\n            n = 3 * n + 1;  // Apply the Collatz transformation\n        }\n    }\n    \n    // Add the final number (which is 1) to the result vector\n    result.push_back(1);\n    \n    // Sort the result vector in increasing order\n    sort(result.begin(), result.end());\n    \n    return result;\n}\n\n// Function to test the get_odd_collatz function with some examples.\nvoid test_get_odd_collatz() {\n    cout << \"Testing get_odd_collatz...\" << endl;\n    assert(get_odd_collatz(5) == vector<int>({1, 5}));\n    assert(get_odd_collatz(7) == vector<int>({1, 7, 11, 22}));\n    assert(get_odd_collatz(1) == vector<int>({1}));\n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/124", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <vector>\n\nbool valid_date(const std::string& date) {\n    // Split the date string into month, day, and year\n    std::istringstream iss(date);\n    std::string token;\n    std::vector<std::string> parts;\n    while (std::getline(iss, token, '-')) {\n        parts.push_back(token);\n    }\n\n    if (parts.size() != 3) {\n        return false; // The date string is not in the correct format\n    }\n\n    int month = std::stoi(parts[0]);\n    int day = std::stoi(parts[1]);\n    int year = std::stoi(parts[2]);\n\n    // Check if the number of days is valid for each month\n    if (month < 1 || month > 12) {\n        return false; // Invalid month\n    }\n\n    bool isLeapYear = (year % 4 == 0 && (year % 100 != 0 || year % 400 == 0));\n    int max_days[] = {31, 29 + isLeapYear, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\n\n    if (day < 1 || day > max_days[month - 1]) {\n        return false; // Invalid day\n    }\n\n    return true;\n}\n\n"}
{"task_id": "CPP/125", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\n// Helper function to split on whitespace\nvector<string> split_on_whitespace(const string& txt) {\n    size_t start = 0, end = 0;\n    vector<string> result;\n    while ((end = txt.find(' ', start)) != string::npos) {\n        result.push_back(txt.substr(start, end - start));\n        start = end + 1;\n    }\n    // Add the last word\n    if (start < txt.length()) {\n        result.push_back(txt.substr(start));\n    }\n    return result;\n}\n\n// Helper function to split on commas\nvector<string> split_on_commas(const string& txt) {\n    size_t start = 0, end = 0;\n    vector<string> result;\n    while ((end = txt.find(',', start)) != string::npos) {\n        result.push_back(txt.substr(start, end - start));\n        start = end + 1;\n    }\n    // Add the last word\n    if (start < txt.length()) {\n        result.push_back(txt.substr(start));\n    }\n    return result;\n}\n\nvector<string> split_words(const string& txt) {\n    // Check for whitespace and split if present\n    size_t pos = txt.find(' ');\n    if (pos != string::npos) {\n        return split_on_whitespace(txt);\n    }\n    \n    // Check for commas and split if present\n    pos = txt.find(',');\n    if (pos != string::npos) {\n        return split_on_commas(txt);\n    }\n    \n    // Count the number of lowercase letters with odd order in the alphabet\n    int count = 0;\n    for (char c : txt) {\n        if (islower(c)) {\n            count += (c - 'a') % 2 == 1 ? 1 : 0;\n        }\n    }\n    \n    // Return a vector containing the count as a string\n    return {to_string(count)};\n}\n\n"}
{"task_id": "CPP/126", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nbool is_sorted(vector<int> lst) {\n    // Check if the list is already sorted or not\n    bool sorted = is_sorted(lst.begin(), lst.end());\n    \n    // If not sorted, return false immediately\n    if (!sorted) return false;\n    \n    // Count occurrences of each number in the vector\n    for (int i = 0; i < lst.size(); ++i) {\n        int count = 1;\n        while (i + 1 < lst.size() && lst[i] == lst[i + 1]) {\n            count++;\n            i++;\n        }\n        // If any number appears more than twice, return false\n        if (count > 2) return false;\n    }\n    \n    // If both conditions are met, return true\n    return true;\n}\n\n"}
{"task_id": "CPP/127", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\nstring intersection(vector<int> interval1, vector<int> interval2) {\n    int start = max(interval1[0], interval2[0]);\n    int end = min(interval1[1], interval2[1]);\n\n    if (start > end) {\n        return \"NO\";\n    }\n\n    int length = end - start + 1;\n\n    if (is_prime(length)) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n\n"}
{"task_id": "CPP/128", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint prod_signs(vector<int> arr) {\n    if (arr.empty()) {\n        return -32768;\n    }\n\n    int sign_product = 1;\n    int magnitude_sum = 0;\n\n    for (int num : arr) {\n        // Calculate the product of signs\n        if (num < 0) {\n            sign_product *= -1;\n        } else if (num == 0) {\n            sign_product = 0; // If any number is zero, the product will be zero\n            break;\n        }\n\n        // Calculate the sum of magnitudes\n        magnitude_sum += abs(num);\n    }\n\n    return sign_product * magnitude_sum;\n}\n\n// Function to test the prod_signs function with provided examples\nvoid check() {\n    cout << \"Checking examples:\" << endl;\n    assert(prod_signs({1, 2, 2, -4}) == -9); // (-1) * (1 + 2 + 2 + 4) = -9\n    assert(prod_signs({0, 1}) == 0);         // 0 * (abs(0) + abs(1)) = 0\n    assert(prod_signs({}) == -32768);        // Empty vector case\n\n    cout << \"All checks passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/129", "generation": "#include <vector>\n#include <set>\n#include <utility> // for std::pair\n\nstd::vector<int> minPath(const std::vector<std::vector<int>>& grid, int start) {\n    int rows = grid.size();\n    int cols = grid[0].size();\n\n    std::set<std::pair<int, int>> visited;\n    // Example initialization of the set with some values\n    visited.insert({start / cols, start % cols});\n\n    for (int i = 0; i < rows; ++i) {\n        for (int j = 0; j < cols; ++j) {\n            std::pair<int, int> currentPair(i, j);\n            if (visited.find(currentPair) != visited.end()) {\n                // The pair is already in the set\n            }\n        }\n    }\n\n    return {}; // Return an empty vector as a placeholder\n}\n\n"}
{"task_id": "CPP/130", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> tri(int n) {\n    if (n == 0) return {1};\n    \n    vector<int> sequence = {1, 3};\n    for (int i = 2; i <= n; ++i) {\n        int next_value;\n        if (i % 2 == 0) {\n            next_value = 1 + (i / 2);\n        } else {\n            next_value = sequence[i - 1] + sequence[i - 2];\n        }\n        sequence.push_back(next_value);\n    }\n    \n    return sequence;\n}\n\n"}
{"task_id": "CPP/131", "generation": "#include <iostream>\nusing namespace std;\n\nint digits(int n) {\n    int product = 1;\n    bool hasOddDigit = false;\n\n    while (n > 0) {\n        int digit = n % 10; // Get the last digit of n\n        if (digit % 2 != 0) { // Check if the digit is odd\n            product *= digit; // Multiply it to the product\n            hasOddDigit = true;\n        }\n        n /= 10; // Remove the last digit from n\n    }\n\n    return hasOddDigit ? product : 0;\n}\n\n"}
{"task_id": "CPP/132", "generation": "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nbool is_nested(string str) {\n    vector<char> stack;  // Stack to keep track of opening brackets\n    bool nested = false; // Flag to check if nesting has occurred\n\n    for (char ch : str) {\n        if (ch == '[') {\n            stack.push_back(ch);  // Push opening bracket onto the stack\n        } else if (ch == ']') {\n            if (!stack.empty()) {\n                stack.pop_back();  // Pop matching opening bracket\n                if (!stack.empty()) {\n                    nested = true;  // If stack is not empty, nesting has occurred\n                }\n            } else {\n                return false;  // Mismatched closing bracket without a corresponding opening bracket\n            }\n        }\n    }\n\n    return nested;\n}\n\n"}
{"task_id": "CPP/133", "generation": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nint sum_squares(vector<float> lst) {\n    int sum = 0;\n    \n    for (float num : lst) {\n        // Round up to the nearest integer\n        float ceil_num = ceil(num);\n        \n        // Add the square of the rounded number to the sum\n        sum += static_cast<int>(ceil_num * ceil_num);\n    }\n    \n    return sum;\n}\n\n"}
{"task_id": "CPP/134", "generation": "#include <iostream>\n#include <string>\n#include <cctype>  // For isalpha and isalnum functions\n\nbool check_if_last_char_is_a_letter(const std::string& txt) {\n    if (txt.empty()) {\n        return false;\n    }\n\n    char last_char = txt.back();\n\n    // Check if the last character is an alphabetical letter\n    if (!std::isalpha(last_char)) {\n        return false;\n    }\n\n    // Check if the string has only one character or the second-to-last character is not alphanumeric\n    if (txt.size() == 1 || !std::isalnum(txt[txt.size() - 2])) {\n        return true;\n    } else {\n        return false;\n    }\n}\n\n"}
{"task_id": "CPP/135", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint can_arrange(vector<int> arr) {\n    int n = arr.size();\n    for (int i = 1; i < n; ++i) {\n        if (arr[i] < arr[i - 1]) {\n            return i;\n        }\n    }\n    return -1;\n}\n\n"}
{"task_id": "CPP/136", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> largest_smallest_integers(vector<int> lst) {\n    vector<int> result = {0, 0}; // Initialize with default values (0 for both negative and positive)\n\n    int max_negative = INT_MIN;  // Start with the smallest possible integer\n    int min_positive = INT_MAX;  // Start with the largest possible integer\n\n    for (int num : lst) {\n        if (num < 0 && num > max_negative) {\n            max_negative = num;\n        } else if (num > 0 && num < min_positive) {\n            min_positive = num;\n        }\n    }\n\n    result[0] = max_negative; // Assign the largest negative integer\n    result[1] = min_positive; // Assign the smallest positive integer\n\n    return result;\n}\n\n"}
{"task_id": "CPP/137", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n\n// Function to convert string with comma as decimal separator to float\nfloat stringToFloat(const std::string& str) {\n    size_t pos;\n    float value = std::stof(str, &pos);\n    return value;\n}\n\nboost::any compare_one(boost::any a, boost::any b) {\n    // Convert strings with comma as decimal separator to float\n    if (a.type() == typeid(std::string)) {\n        a = stringToFloat(std::any_cast<std::string>(a));\n    }\n    if (b.type() == typeid(std::string)) {\n        b = stringToFloat(std::any_cast<std::string>(b));\n    }\n\n    // Compare the values\n    float va = std::any_cast<float>(a);\n    float vb = std::any_cast<float>(b);\n\n    if (va > vb) {\n        return a;\n    } else if (vb > va) {\n        return b;\n    } else {\n        return boost::none;\n    }\n}\n\n"}
{"task_id": "CPP/138", "generation": "#include <iostream>\n#include <vector>\n\nbool is_equal_to_sum_even(int n) {\n    // Since we need exactly 4 positive even numbers and the smallest sum of 4 such numbers is 2 + 2 + 2 + 2 = 8,\n    // any number less than 8 cannot be expressed as the sum of exactly 4 positive even numbers.\n    if (n < 8) {\n        return false;\n    }\n    \n    // If n - 8 is even, then we can express n as the sum of 2 + 2 + 2 + (n-6), which are all even numbers.\n    return (n - 8) % 2 == 0;\n}\n\n"}
{"task_id": "CPP/139", "generation": "#include <iostream>\n\n// Function to calculate factorial of a number\nlong long factorial(long long num) {\n    if (num == 0 || num == 1)\n        return 1;\n    else\n        return num * factorial(num - 1);\n}\n\n// Function to calculate Brazilian factorial\nlong long special_factorial(int n) {\n    long long result = 1;\n    for (int i = n; i > 0; --i) {\n        result *= factorial(i);\n    }\n    return result;\n}\n\n"}
{"task_id": "CPP/140", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring fix_spaces(string text) {\n    string result = \"\";\n    int consecutiveSpacesCount = 0;\n\n    for (char ch : text) {\n        if (ch == ' ') {\n            consecutiveSpacesCount++;\n        } else {\n            if (consecutiveSpacesCount > 2) {\n                result += '-';\n            } else if (consecutiveSpacesCount >= 1) {\n                result.append(consecutiveSpacesCount, '_');\n            }\n            result += ch;\n            consecutiveSpacesCount = 0;\n        }\n    }\n\n    // Handle trailing spaces\n    if (consecutiveSpacesCount > 2) {\n        result += '-';\n    } else if (consecutiveSpacesCount >= 1) {\n        result.append(consecutiveSpacesCount, '_');\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/141", "generation": "#include <iostream>\n#include <string>\n#include <regex>\n\nusing namespace std;\n\nstring file_name_check(string file_name) {\n    // Regular expression pattern based on the given conditions\n    string pattern = R\"(^[a-zA-Z][a-zA-Z0-9]{0,2}\\.[txt|exe|dll]{3}$)\";\n    \n    // Check if the file name matches the pattern using regex_match\n    if (regex_match(file_name, regex(pattern))) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\n\n"}
{"task_id": "CPP/142", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint sum_squares(vector<int> lst) {\n    for (size_t i = 0; i < lst.size(); ++i) {\n        if (i % 3 == 0 && i != 0) {\n            lst[i] = lst[i] * lst[i]; // Square the element\n        } else if (i % 4 == 0 && i % 3 != 0) {\n            lst[i] = lst[i] * lst[i] * lst[i]; // Cube the element\n        }\n    }\n\n    int sum = 0;\n    for (int num : lst) {\n        sum += num; // Sum all elements in the vector\n    }\n\n    return sum;\n}\n\n"}
{"task_id": "CPP/143", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    if (n == 2 || n == 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    for (int i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0)\n            return false;\n    }\n    return true;\n}\n\n// Function to process the sentence and return words with prime length\nstring words_in_sentence(string sentence) {\n    stringstream ss(sentence);\n    string word;\n    string result = \"\";\n    \n    while (ss >> word) {\n        if (is_prime(word.length())) {\n            if (!result.empty()) result += \" \";\n            result += word;\n        }\n    }\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/144", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\n// Function to simplify two fractions and check if their product is a whole number\nbool simplify(string x, string n) {\n    // Helper function to parse fraction from string\n    auto parse_fraction = [](const string& frac) -> pair<int, int> {\n        size_t slash_pos = frac.find('/');\n        int numerator = stoi(frac.substr(0, slash_pos));\n        int denominator = stoi(frac.substr(slash_pos + 1));\n        return {numerator, denominator};\n    };\n\n    // Parse the fractions\n    auto [num_x, den_x] = parse_fraction(x);\n    auto [num_n, den_n] = parse_fraction(n);\n\n    // Calculate the product of the numerators and denominators\n    int numerator_product = num_x * num_n;\n    int denominator_product = den_x * den_n;\n\n    // Check if the result is a whole number\n    return (numerator_product % denominator_product) == 0;\n}\n\n"}
{"task_id": "CPP/145", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\n// Function to calculate the sum of digits of an integer.\nint digit_sum(int n) {\n    if (n < 0) n = -n; // Make n positive for digit extraction\n    int sum = 0;\n    while (n > 0) {\n        sum += n % 10;\n        n /= 10;\n    }\n    return sum;\n}\n\n// Comparator function to sort based on the sum of digits and original index.\nbool compare_by_points(int a, int b) {\n    int sum_a = digit_sum(a);\n    int sum_b = digit_sum(b);\n    \n    if (sum_a == sum_b) {\n        // If sums are equal, maintain original order\n        return std::find(nums.begin(), nums.end(), a) < std::find(nums.begin(), nums.end(), b);\n    }\n    return sum_a < sum_b;\n}\n\n// Function to sort the vector based on the sum of digits.\nstd::vector<int> order_by_points(std::vector<int> nums) {\n    // Sort using the custom comparator\n    std::sort(nums.begin(), nums.end(), compare_by_points);\n    return nums;\n}\n\n"}
{"task_id": "CPP/146", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nint specialFilter(vector<int> nums) {\n    int count = 0;\n    \n    for (int num : nums) {\n        // Skip numbers that are not greater than 10\n        if (num <= 10) continue;\n        \n        string strNum = to_string(num);\n        int firstDigit = strNum[0] - '0';\n        int lastDigit = strNum[strNum.length() - 1] - '0';\n        \n        // Check if both the first and last digits are odd\n        if (firstDigit % 2 != 0 && lastDigit % 2 != 0) {\n            count++;\n        }\n    }\n    \n    return count;\n}\n\n"}
{"task_id": "CPP/147", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint get_max_triples(int n) {\n    // Step 1: Generate the vector a\n    vector<int> a(n);\n    for (int i = 1; i <= n; ++i) {\n        a[i - 1] = i * i - i + 1;\n    }\n\n    int count = 0;\n\n    // Step 2 and 3: Iterate through all possible triples (i, j, k)\n    for (int i = 0; i < n - 2; ++i) {\n        for (int j = i + 1; j < n - 1; ++j) {\n            for (int k = j + 1; k < n; ++k) {\n                if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                    count++;\n                }\n            }\n        }\n    }\n\n    return count;\n}\n\n// Function to test the solution\nvoid check() {\n    int result = get_max_triples(5);\n    cout << \"Output: \" << result << endl; // Expected output: 1\n}\n\n"}
{"task_id": "CPP/148", "generation": "#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> bf(string planet1, string planet2) {\n    vector<string> planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n    \n    // Check if both input planets are valid\n    if (find(planets.begin(), planets.end(), planet1) == planets.end() || \n        find(planets.begin(), planets.end(), planet2) == planets.end()) {\n        return {};\n    }\n    \n    // Find the indices of the input planets\n    size_t index1 = find(planets.begin(), planets.end(), planet1) - planets.begin();\n    size_t index2 = find(planets.begin(), planets.end(), planet2) - planets.begin();\n    \n    // Ensure index1 is less than index2 for correct sorting\n    if (index1 > index2) {\n        swap(index1, index2);\n    }\n    \n    // Return the sublist of planets between the two indices (inclusive)\n    vector<string> result(planets.begin() + index1 + 1, planets.begin() + index2);\n    return result;\n}\n"}
{"task_id": "CPP/149", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nvector<string> vector_sort(const vector<string>& lst) {\n    // Filter out strings with odd lengths\n    vector<string> even_length_strings;\n    for (const string& s : lst) {\n        if (s.length() % 2 == 0) {\n            even_length_strings.push_back(s);\n        }\n    }\n\n    // Sort the filtered list by length, then alphabetically\n    sort(even_length_strings.begin(), even_length_strings.end(),\n         [](const string& a, const string& b) {\n             if (a.length() == b.length()) {\n                 return a < b;  // Alphabetical order if lengths are equal\n             }\n             return a.length() < b.length();  // Length order first\n         });\n\n    return even_length_strings;\n}\n\n// Function to check the correctness of the vector_sort function\nvoid check_function() {\n    assert(vector_sort({\"aa\", \"a\", \"aaa\"}) == vector<string>{\"aa\"});\n    assert(vector_sort({\"ab\", \"a\", \"aaa\", \"cd\"}) == vector<string>{\"ab\", \"cd\"});\n    cout << \"All test cases passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/150", "generation": "#include<stdio.h>\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int n) {\n    if (n <= 1) return false; // Numbers less than or equal to 1 are not prime\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\n// Function that returns x if n is a prime number, otherwise returns y\nint x_or_y(int n, int x, int y) {\n    return is_prime(n) ? x : y;\n}\n\n"}
{"task_id": "CPP/151", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nlong long double_the_difference(vector<float> lst) {\n    long long sum = 0;\n    \n    for (float num : lst) {\n        // Check if the number is positive, an integer, and odd\n        if (num > 0 && floor(num) == num && static_cast<int>(num) % 2 != 0) {\n            sum += pow(num, 2);\n        }\n    }\n    \n    return sum;\n}\n\n"}
{"task_id": "CPP/152", "generation": "#include <iostream>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\n// Function to compare the scores with guesses\nvector<int> compare(vector<int> game, vector<int> guess) {\n    vector<int> result;\n    \n    // Iterate through each match and calculate the absolute difference\n    for (size_t i = 0; i < game.size(); ++i) {\n        int diff = abs(game[i] - guess[i]);\n        result.push_back(diff);\n    }\n    \n    return result;\n}\n\n// Function to print a vector of integers\nvoid printVector(const vector<int>& vec) {\n    for (int num : vec) {\n        cout << num << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/153", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to calculate the strength of an extension\nint calculateStrength(const string& extension) {\n    int cap = 0, sm = 0;\n    for (char c : extension) {\n        if (isupper(c)) cap++;\n        else if (islower(c)) sm++;\n    }\n    return cap - sm;\n}\n\nstring Strongest_Extension(string class_name, vector<string> extensions) {\n    string strongest_extension = \"\";\n    int max_strength = INT_MIN;\n\n    for (const string& extension : extensions) {\n        int strength = calculateStrength(extension);\n        if (strength > max_strength) {\n            max_strength = strength;\n            strongest_extension = extension;\n        }\n    }\n\n    return class_name + \".\" + strongest_extension;\n}\n\n// Example usage\n"}
{"task_id": "CPP/154", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool cycpattern_check(const string& a, const string& b) {\n    // Concatenate the first string with itself to handle rotations\n    string doubled_a = a + a;\n    \n    // Check if the second string or any of its rotations is a substring of the doubled first string\n    return doubled_a.find(b) != string::npos;\n}\n\n"}
{"task_id": "CPP/155", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// Function to count even and odd digits in an integer\nvector<int> even_odd_count(int num) {\n    // Convert the number to a string to easily iterate over each digit\n    string str_num = to_string(abs(num));\n    \n    int even_count = 0;\n    int odd_count = 0;\n    \n    for (char digit : str_num) {\n        if ((digit - '0') % 2 == 0) {\n            even_count++;\n        } else {\n            odd_count++;\n        }\n    }\n    \n    return {even_count, odd_count};\n}\n\n// Function to test the even_odd_count function\nvoid test_even_odd_count() {\n    assert(even_odd_count(-12) == vector<int>({1, 1}));\n    assert(even_odd_count(123) == vector<int>({1, 2}));\n    assert(even_odd_count(0) == vector<int>({1, 0})); // Edge case: single digit 0\n    assert(even_odd_count(-9876543210) == vector<int>({5, 5}));\n    \n    cout << \"All test cases passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/156", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to convert an integer to its Roman numeral equivalent in lowercase\nstring int_to_mini_roman(int number) {\n    // Mapping of integers to their corresponding Roman numerals\n    vector<pair<int, string>> roman_map = {\n        {1000, \"m\"}, {900, \"cm\"}, {500, \"d\"}, {400, \"cd\"},\n        {100, \"c\"}, {90, \"xc\"}, {50, \"l\"}, {40, \"xl\"},\n        {10, \"x\"}, {9, \"ix\"}, {5, \"v\"}, {4, \"iv\"}, {1, \"i\"}\n    };\n\n    string roman_numeral = \"\";\n\n    // Iterate through the map and construct the Roman numeral\n    for (const auto& [value, symbol] : roman_map) {\n        while (number >= value) {\n            roman_numeral += symbol;\n            number -= value;\n        }\n    }\n\n    return roman_numeral;\n}\n\n// Function to check the correctness of the int_to_mini_roman function\nvoid check() {\n    assert(int_to_mini_roman(19) == \"xix\");\n    assert(int_to_mini_roman(152) == \"clii\");\n    assert(int_to_mini_roman(426) == \"cdxxvi\");\n    cout << \"All test cases passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/157", "generation": "#include <stdio.h>\n#include <math.h>\n\nusing namespace std;\n\nbool right_angle_triangle(float a, float b, float c) {\n    // First, sort the sides so that 'c' is the longest side (hypotenuse)\n    if (a > c) swap(a, c);\n    if (b > c) swap(b, c);\n\n    // Check if the Pythagorean theorem holds\n    return fabs(a*a + b*b - c*c) < 1e-6; // Using a small epsilon to account for floating point precision issues\n}\n\n"}
{"task_id": "CPP/158", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to count unique characters in a string\nint count_unique_chars(const string& word) {\n    bool seen[256] = {false};\n    int count = 0;\n    for (char c : word) {\n        if (!seen[c]) {\n            seen[c] = true;\n            count++;\n        }\n    }\n    return count;\n}\n\n// Function to find the word with maximum unique characters\nstring find_max(vector<string> words) {\n    string max_word = \"\";\n    int max_unique_chars = 0;\n\n    for (const auto& word : words) {\n        int unique_chars = count_unique_chars(word);\n        if (unique_chars > max_unique_chars || \n            (unique_chars == max_unique_chars && word < max_word)) {\n            max_word = word;\n            max_unique_chars = unique_chars;\n        }\n    }\n\n    return max_word;\n}\n\n// Function to test the find_max function\nvoid test_find_max() {\n    assert(find_max({\"name\", \"of\", \"string\"}) == \"string\");\n    assert(find_max({\"name\", \"enam\", \"game\"}) == \"enam\");\n    assert(find_max({\"aaaaaaa\", \"bb\", \"cc\"}) == \"aaaaaaa\");\n    cout << \"All test cases passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/159", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nvector<int> eat(int number, int need, int remaining) {\n    // Calculate the maximum number of carrots that can be eaten from the remaining stock\n    int max_to_eat = min(need, remaining);\n    \n    // Update the total number of carrots eaten\n    int total_eaten = number + max_to_eat;\n    \n    // Update the remaining carrots in stock\n    int remaining_after_meal = remaining - max_to_eat;\n    \n    return {total_eaten, remaining_after_meal};\n}\n\n// Function to test the eat function with provided examples\nvoid check() {\n    vector<int> result1 = eat(5, 6, 10);\n    printf(\"eat(5, 6, 10) -> {%d, %d}\\n\", result1[0], result1[1]); // Expected: {11, 4}\n    \n    vector<int> result2 = eat(4, 8, 9);\n    printf(\"eat(4, 8, 9) -> {%d, %d}\\n\", result2[0], result2[1]); // Expected: {12, 1}\n    \n    vector<int> result3 = eat(1, 10, 10);\n    printf(\"eat(1, 10, 10) -> {%d, %d}\\n\", result3[0], result3[1]); // Expected: {11, 0}\n    \n    vector<int> result4 = eat(2, 11, 5);\n    printf(\"eat(2, 11, 5) -> {%d, %d}\\n\", result4[0], result4[1]); // Expected: {7, 0}\n}\n\n"}
{"task_id": "CPP/160", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nint do_algebra(vector<string> operators, vector<int> operands) {\n    // Initialize the expression with the first operand\n    string expression = to_string(operands[0]);\n    \n    // Build the expression by iterating through the operators and operands\n    for (size_t i = 0; i < operators.size(); ++i) {\n        expression += \" \" + operators[i] + \" \" + to_string(operands[i + 1]);\n    }\n    \n    // Evaluate the constructed expression using C++'s stringstream\n    int result;\n    stringstream ss(expression);\n    ss >> result;\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/161", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\n// Function to solve the problem as described\nstring solve(string s) {\n    bool hasLetters = false;\n    \n    // Check if there are any letters in the string\n    for (char c : s) {\n        if (isalpha(c)) {\n            hasLetters = true;\n            break;\n        }\n    }\n\n    if (!hasLetters) {\n        // If no letters, reverse the entire string\n        reverse(s.begin(), s.end());\n    } else {\n        // If there are letters, convert them to their opposite case\n        for (char &c : s) {\n            if (islower(c)) {\n                c = toupper(c);\n            } else if (isupper(c)) {\n                c = tolower(c);\n            }\n        }\n    }\n\n    return s;\n}\n\n// Function to test the solve function with provided examples\nvoid test() {\n    cout << \"solve(\\\"1234\\\") = \\\"\" << solve(\"1234\") << \"\\\" (Expected: \\\"4321\\\")\" << endl;\n    cout << \"solve(\\\"ab\\\") = \\\"\" << solve(\"ab\") << \"\\\" (Expected: \\\"AB\\\")\" << endl;\n    cout << \"solve(\\\"#a@C\\\") = \\\"\" << solve(\"#a@C\") << \"\\\" (Expected: \\\"#A@c\\\")\" << endl;\n}\n\n"}
{"task_id": "CPP/162", "generation": "#include <iostream>\n#include <openssl/md5.h>\n#include <sstream>\n#include <iomanip>\n\n// Function to convert byte array to hex string\nstd::string bytes_to_hex(const unsigned char* bytes, size_t len) {\n    std::stringstream ss;\n    for (size_t i = 0; i < len; ++i) {\n        ss << std::hex << std::setw(2) << std::setfill('0') << static_cast<int>(bytes[i]);\n    }\n    return ss.str();\n}\n\n// Function to convert string to MD5 hash\nstd::string string_to_md5(const std::string& text) {\n    if (text.empty()) {\n        return \"None\";\n    }\n\n    unsigned char digest[MD5_DIGEST_LENGTH];\n    MD5(reinterpret_cast<const unsigned char*>(text.c_str()), text.length(), digest);\n\n    // Convert the hash to a hexadecimal string\n    return bytes_to_hex(digest, MD5_DIGEST_LENGTH);\n}\n\n"}
{"task_id": "CPP/163", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> generate_integers(int a, int b) {\n    vector<int> even_digits = {2, 4, 6, 8};\n    vector<int> result;\n    \n    // Ensure a is less than or equal to b\n    if (a > b) {\n        swap(a, b);\n    }\n    \n    // Iterate through the even digits and check if they fall within the range [a, b]\n    for (int digit : even_digits) {\n        if (digit >= a && digit <= b) {\n            result.push_back(digit);\n        }\n    }\n    \n    return result;\n}\n\n// Function to test the generate_integers function\nvoid test() {\n    vector<int> result1 = generate_integers(2, 8);\n    for (int num : result1) {\n        cout << num << \" \";\n    }\n    cout << endl;\n\n    vector<int> result2 = generate_integers(8, 2);\n    for (int num : result2) {\n        cout << num << \" \";\n    }\n    cout << endl;\n\n    vector<int> result3 = generate_integers(10, 14);\n    for (int num : result3) {\n        cout << num << \" \";\n    }\n    cout << endl;\n}\n\n"}
