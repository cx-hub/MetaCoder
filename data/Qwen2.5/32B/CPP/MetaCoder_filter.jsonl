{"task_id": "CPP/0", "generation": "#include <algorithm> // For std::sort\n\nbool has_close_elements(std::vector<float> numbers, float threshold) {\n    if (numbers.size() < 2) return false; // If there are less than two elements, we can't have any pairs.\n\n    // Sort the vector to bring closer elements next to each other.\n    std::sort(numbers.begin(), numbers.end());\n\n    for(size_t i = 0; i < numbers.size() - 1; ++i) {\n        if (std::abs(numbers[i] - numbers[i + 1]) < threshold) {\n            return true;\n        }\n    }\n\n    return false;\n}\n"}
{"task_id": "CPP/1", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> separate_paren_groups(string paren_string){\n    vector<string> result;\n    int balance = 0; // Keeps track of open parentheses\n    string current_group = \"\"; // Current group being processed\n\n    for (char c : paren_string) {\n        if (c == '(' || c == ')') { // Ignore spaces and only consider parentheses\n            current_group += c; // Add the character to the current group\n            balance += (c == '(' ? 1 : -1); // Update balance based on the character\n\n            if (balance == 0) { // When balance is zero, a complete group has been found\n                result.push_back(current_group);\n                current_group = \"\"; // Reset for the next group\n            }\n        }\n    }\n\n    return result;\n}\n\n// Function to test the solution with provided data points\nvoid check() {\n    vector<string> expected1 = {\"()\", \"(())\", \"(()())\"};\n    assert(separate_paren_groups(\"( ) (( )) (( )( ))\") == expected1);\n\n    // Additional checks can be added here as needed\n\n    cout << \"All tests passed successfully.\" << endl;\n}\n\n"}
{"task_id": "CPP/2", "generation": "#include<stdio.h>\n#include<math.h>\n\nfloat truncate_number(float number){\n    float integerPart = floor(number);\n    return number - integerPart;\n}\n\n"}
{"task_id": "CPP/3", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nbool below_zero(vector<int> operations) {\n    int balance = 0; // Start with a zero balance\n\n    for (int op : operations) { // Iterate through each operation\n        balance += op; // Update the balance according to the current operation\n        \n        if (balance < 0) { // Check if balance falls below zero\n            return true;\n        }\n    }\n\n    return false; // Return false if no point in time the balance was below zero\n}\n\n"}
{"task_id": "CPP/4", "generation": "#include <iostream>\n#include <vector>\n#include <numeric> // for std::accumulate\n#include <cmath>   // for std::abs\n\nusing namespace std;\n\nfloat mean_absolute_deviation(vector<float> numbers) {\n    if (numbers.empty()) return 0.0f; // Handle empty vector case\n    \n    float sum = accumulate(numbers.begin(), numbers.end(), 0.0f);\n    float mean = sum / numbers.size();\n    \n    float mad_sum = 0.0f;\n    for (float num : numbers) {\n        mad_sum += std::abs(num - mean); // Calculate the absolute difference and add it to the sum\n    }\n    \n    return mad_sum / numbers.size(); // Average of all absolute differences\n}\n\n"}
{"task_id": "CPP/5", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> intersperse(vector<int> numbers, int delimeter) {\n    vector<int> result;\n    \n    // If the input vector is empty, return it as is.\n    if (numbers.empty()) {\n        return result;\n    }\n    \n    // Iterate through each element in the input vector\n    for(size_t i = 0; i < numbers.size(); ++i) {\n        // Add the current number to the result vector\n        result.push_back(numbers[i]);\n        \n        // If it's not the last element, add the delimiter after it.\n        if (i != numbers.size() - 1) {\n            result.push_back(delimeter);\n        }\n    }\n\n    return result;\n}\n\n// Example usage:\n"}
{"task_id": "CPP/6", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<int> parse_nested_parens(string paren_string) {\n    vector<int> max_depths;\n    int current_depth = 0, max_depth = 0;\n    \n    for (char c : paren_string) {\n        if (c == '(') {\n            // Increase depth when encountering an opening parenthesis\n            ++current_depth;\n            // Update the maximum depth found so far in this group\n            if (current_depth > max_depth)\n                max_depth = current_depth;\n        } else if (c == ')') {\n            // Decrease depth when encountering a closing parenthesis\n            --current_depth;\n        } else if (c == ' ') {\n            // When we encounter a space, it means the end of one group.\n            // Add the maximum depth found for this group to our result vector,\n            // and reset max_depth and current_depth for the next group.\n            max_depths.push_back(max_depth);\n            max_depth = 0;\n            current_depth = 0;\n        }\n    }\n\n    // Handle the last group if there is no trailing space\n    if (max_depth > 0) {\n        max_depths.push_back(max_depth);\n    }\n\n    return max_depths;\n}\n\n"}
{"task_id": "CPP/7", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\n// Function to filter strings containing a specific substring.\nvector<string> filter_by_substring(vector<string> strings, string substring) {\n    vector<string> filteredStrings; // Vector to store the result.\n\n    for (const auto& str : strings) { // Iterate through each string in the input vector.\n        if (str.find(substring) != string::npos) { // Check if the current string contains the substring.\n            filteredStrings.push_back(str); // If it does, add it to the result vector.\n        }\n    }\n\n    return filteredStrings; // Return the filtered list of strings.\n}\n\n// Function to test the filter_by_substring function with given data points.\nvoid check() {\n    vector<string> empty;\n    auto res1 = filter_by_substring(empty, \"a\");\n    assert(res1.empty()); // Should be an empty vector.\n\n    vector<string> input2{\"abc\", \"bacd\", \"cde\", \"vector\"};\n    auto res2 = filter_by_substring(input2, \"a\");\n    vector<string> expected2{\"abc\", \"bacd\", \"vector\"};\n    assert(res2 == expected2); // Should match the expected result.\n\n    cout << \"All tests passed successfully.\" << endl;\n}\n\n"}
{"task_id": "CPP/8", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> sum_product(vector<int> numbers) {\n    vector<int> result(2); // Initialize a vector with size 2 for storing sum and product\n\n    if (numbers.empty()) { // Check if the input vector is empty\n        result[0] = 0;     // Empty sum should be equal to 0\n        result[1] = 1;     // Empty product should be equal to 1\n        return result;\n    }\n\n    int total_sum = 0;     // Initialize sum variable\n    int product = 1;       // Initialize product variable\n\n    for (int num : numbers) {\n        total_sum += num;  // Calculate the sum of all elements in the vector\n        product *= num;    // Calculate the product of all elements in the vector\n    }\n\n    result[0] = total_sum; // Store the calculated sum\n    result[1] = product;   // Store the calculated product\n\n    return result;\n}\n"}
{"task_id": "CPP/9", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> rolling_max(vector<int> numbers) {\n    // Check if the input vector is empty to avoid undefined behavior.\n    if (numbers.empty()) return {};\n\n    vector<int> result;\n    int currentMax = numbers[0];  // Initialize with the first element of the sequence.\n\n    for (int num : numbers) {\n        // Update the current maximum value if the current number is greater than it.\n        if (num > currentMax) {\n            currentMax = num;\n        }\n        // Append the current maximum to the result vector.\n        result.push_back(currentMax);\n    }\n\n    return result;\n}\n\n// Example usage\n"}
{"task_id": "CPP/10", "generation": "#include <string>\nusing namespace std;\n\nbool is_palindrome(string str) {\n    string s(str.rbegin(), str.rend());\n    return s == str;\n}\n\nstring make_palindrome(string str) {\n    if (str.empty()) {\n        return \"\";\n    }\n\n    for (size_t i = 0; i < str.size(); ++i) {\n        string suffix = str.substr(i);\n        if (is_palindrome(suffix)) {\n            string prefix_to_reverse = str.substr(0, i);\n            reverse(prefix_to_reverse.begin(), prefix_to_reverse.end());\n            return str + prefix_to_reverse;\n        }\n    }\n\n    // In case no palindrome is found in the loop above\n    return str;  // This line should theoretically never be reached.\n}\n"}
{"task_id": "CPP/11", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring string_xor(string a, string b) {\n    // Ensure both strings are of equal length by padding with zeros if necessary.\n    int len_a = a.length();\n    int len_b = b.length();\n\n    // Pad the shorter string with leading '0's to match lengths\n    while (len_a < len_b) { a = \"0\" + a; ++len_a; }\n    while (len_b < len_a) { b = \"0\" + b; ++len_b; }\n\n    string result;\n    \n    // Perform XOR on each pair of characters and append to the result\n    for(int i = 0; i < len_a; ++i){\n        if(a[i] == b[i]) {\n            result += '0'; // If both are same, XOR is 0\n        } else {\n            result += '1'; // If different, XOR is 1\n        }\n    }\n\n    return result;\n}\n\n// Function to test the string_xor function\nvoid check() {\n    cout << (string_xor(\"010\", \"110\") == \"100\" ? \"Test Passed\\n\" : \"Test Failed\\n\");\n}\n\n"}
{"task_id": "CPP/12", "generation": "#include <vector>\n#include <string>\nusing namespace std;\n\nstring longest(vector<string> strings) {\n    if (strings.empty()) return \"\"; // Return an empty string to represent None\n\n    string maxString = strings[0]; // Assume the first string is the longest initially\n    size_t maxLength = maxString.length();\n\n    for (size_t i = 1; i < strings.size(); ++i) { // Start from the second element\n        if (strings[i].length() > maxLength) {\n            maxString = strings[i];\n            maxLength = strings[i].length();\n        }\n    }\n\n    return maxString;\n}\n"}
{"task_id": "CPP/13", "generation": "#include <iostream>\nusing namespace std;\n\nint greatest_common_divisor(int a, int b) {\n    while (b != 0) {\n        int temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n\n"}
{"task_id": "CPP/14", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> all_prefixes(string str){\n    vector<string> prefixes;\n    for(size_t i = 0; i < str.length(); ++i) {\n        // Create a substring from the start to the current position (inclusive)\n        string prefix = str.substr(0, i + 1);\n        // Add this prefix to the vector\n        prefixes.push_back(prefix);\n    }\n    return prefixes;\n}\n\n// Example usage:\n"}
{"task_id": "CPP/15", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nstring string_sequence(int n) {\n    string result = \"\";\n    \n    for (int i = 0; i <= n; ++i) {\n        // Convert integer to string and append it to the result string.\n        result += to_string(i);\n        \n        // Add a space after each number except the last one\n        if (i < n) {\n            result += \" \";\n        }\n    }\n\n    return result;\n}\n\n// Function to test the correctness of the solution\nvoid check() {\n    cout << (string_sequence(0) == \"0\" ? \"Test 1 Passed\\n\" : \"Test 1 Failed\\n\");\n    cout << (string_sequence(5) == \"0 1 2 3 4 5\" ? \"Test 2 Passed\\n\" : \"Test 2 Failed\\n\");\n}\n\n"}
{"task_id": "CPP/16", "generation": "#include <iostream>\n#include <set>\n#include <string>\nusing namespace std;\n\nint count_distinct_characters(string str) {\n    // Convert string to lower case for case-insensitive comparison\n    transform(str.begin(), str.end(), str.begin(), ::tolower);\n    \n    // Use a set to store unique characters\n    set<char> distinctChars;\n    \n    // Iterate through each character and add it to the set\n    for (char c : str) {\n        distinctChars.insert(c);\n    }\n    \n    // The size of the set is the number of distinct characters\n    return distinctChars.size();\n}\n\n"}
{"task_id": "CPP/17", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<int> parse_music(string music_string){\n    vector<int> beats;\n    int i = 0;\n    \n    while (i < music_string.length()) {\n        if(music_string[i] == 'o') { // Check for whole note\n            if(i + 1 < music_string.length() && music_string[i+1] == '|') {\n                beats.push_back(2); // Half note\n                i += 2; // Skip the next character as well since it's part of the half note\n            } else {\n                beats.push_back(4); // Whole note\n                i++;\n            }\n        } else if(music_string[i] == '.') { // Check for quarter note\n            if(i + 1 < music_string.length() && music_string[i+1] == '|') {\n                beats.push_back(1); // Quarter note\n                i += 2; // Skip the next character as well since it's part of the quarter note\n            } else {\n                cout << \"Invalid input: Expected '|' after '.'\" << endl;\n                return vector<int>(); // Return an empty vector in case of invalid input\n            }\n        } else if(music_string[i] == ' ') { // Skip spaces\n            i++;\n        } else {\n            cout << \"Invalid character encountered: \" << music_string[i] << endl;\n            return vector<int>(); // Return an empty vector in case of invalid input\n        }\n    }\n\n    return beats;\n}\n\n"}
{"task_id": "CPP/18", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint how_many_times(string str, string substring) {\n    if (substring.empty() || str.empty()) return 0; // If either string is empty, no matches are possible.\n    \n    int count = 0;\n    size_t pos = 0;\n    \n    while ((pos = str.find(substring, pos)) != string::npos) { // Find the substring starting from 'pos'.\n        ++count; // Increment count for each match found.\n        ++pos;   // Move to the next character after the current match to find overlapping occurrences.\n    }\n    \n    return count;\n}\n\n"}
{"task_id": "CPP/19", "generation": "#include <iostream>\n#include <string>\n#include <vector>\n#include <map>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to sort numbers given as words from \"zero\" to \"nine\"\nstring sort_numbers(string numbers) {\n    // Mapping of number words to their numeric values\n    map<string, int> num_map = {\n        {\"zero\", 0}, {\"one\", 1}, {\"two\", 2}, {\"three\", 3},\n        {\"four\", 4}, {\"five\", 5}, {\"six\", 6}, {\"seven\", 7},\n        {\"eight\", 8}, {\"nine\", 9}\n    };\n\n    // Reverse mapping for converting numeric values back to words\n    map<int, string> reverse_map;\n    for (auto &p : num_map) {\n        reverse_map[p.second] = p.first;\n    }\n\n    // Split the input string into individual number words\n    vector<string> num_words;\n    string word;\n    for (char c : numbers) {\n        if (c == ' ') {\n            if (!word.empty()) {\n                num_words.push_back(word);\n                word.clear();\n            }\n        } else {\n            word += c;\n        }\n    }\n    if (!word.empty()) {\n        num_words.push_back(word);\n    }\n\n    // Sort the number words based on their numeric values\n    sort(num_words.begin(), num_words.end(),\n         [&num_map](const string &a, const string &b) { return num_map[a] < num_map[b]; });\n\n    // Convert back to a space-delimited string of sorted number words\n    string result;\n    for (size_t i = 0; i < num_words.size(); ++i) {\n        if (i > 0) result += \" \";\n        result += reverse_map[num_map[num_words[i]]];\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/20", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <limits>\n\nusing namespace std;\n\nvector<float> find_closest_elements(vector<float> numbers) {\n    // Sort the vector in ascending order.\n    sort(numbers.begin(), numbers.end());\n\n    float min_diff = numeric_limits<float>::max();\n    pair<float, float> result(0.0f, 0.0f);\n\n    for (size_t i = 0; i < numbers.size() - 1; ++i) {\n        float diff = numbers[i + 1] - numbers[i];\n        if (diff < min_diff) {\n            min_diff = diff;\n            result.first = numbers[i];\n            result.second = numbers[i + 1];\n        }\n    }\n\n    // Convert the pair to a vector and return.\n    vector<float> out{result.first, result.second};\n    return out;\n}\n"}
{"task_id": "CPP/21", "generation": "#include <vector>\n#include <algorithm> // for std::min_element and std::max_element\n\nusing namespace std;\n\nvector<float> rescale_to_unit(vector<float> numbers){\n    float min_val = *std::min_element(numbers.begin(), numbers.end());\n    float max_val = *std::max_element(numbers.begin(), numbers.end());\n\n    vector<float> scaled_numbers;\n    for (float num : numbers) {\n        // Apply the linear transformation\n        float scaled_num = (num - min_val) / (max_val - min_val);\n        scaled_numbers.push_back(scaled_num);\n    }\n\n    return scaled_numbers;\n}\n\n// Example usage:\n"}
{"task_id": "CPP/22", "generation": "#include <iostream>\n#include <vector>\n#include <list>\n#include <boost/any.hpp>\n\ntypedef std::list<boost::any> list_any;\n\nstd::vector<int> filter_integers(list_any values) {\n    std::vector<int> integers;\n    \n    for (auto it = values.begin(); it != values.end(); ++it) {\n        if (it->type() == typeid(int)) { // Check if the type is int\n            integers.push_back(boost::any_cast<int>(*it)); // Cast and add to vector\n        }\n    }\n\n    return integers;\n}\n\n"}
{"task_id": "CPP/23", "generation": "#include <iostream>\n#include <string>\n\nint stringLength(const std::string& str) {\n    return str.length();\n}\n\n"}
{"task_id": "CPP/24", "generation": "#include<stdio.h>\n\nint largest_divisor(int n) {\n    // Start from half of n because no number greater than n/2 can be a divisor of n (except n itself)\n    for (int i = n / 2; i >= 1; --i) {\n        if (n % i == 0) {\n            return i;\n        }\n    }\n    // If no divisor is found, which theoretically shouldn't happen unless n <= 1\n    return -1;\n}\n\n"}
{"task_id": "CPP/25", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvector<int> factorize(int n) {\n    vector<int> factors;\n    \n    // Divide by 2 until odd\n    while (n % 2 == 0) {\n        factors.push_back(2);\n        n /= 2;\n    }\n    \n    // Check for odd factors from 3 onwards\n    for (int i = 3; i * i <= n; i += 2) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n    \n    // If n is a prime number greater than 2\n    if (n > 2) {\n        factors.push_back(n);\n    }\n\n    return factors;\n}\n\n"}
{"task_id": "CPP/26", "generation": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nvector<int> remove_duplicates(vector<int> numbers) {\n    unordered_map<int, int> occurrences;\n    \n    // Count the occurrences of each number.\n    for (int num : numbers) {\n        occurrences[num]++;\n    }\n    \n    vector<int> result;\n    \n    // Add to result only those elements that occur once.\n    for (int num : numbers) {\n        if (occurrences[num] == 1) {\n            result.push_back(num);\n        }\n    }\n    \n    return result;\n}\n\n// Function to print the vector\nvoid print_vector(const vector<int>& v) {\n    cout << \"{\";\n    for(size_t i = 0; i < v.size(); ++i) {\n        cout << v[i];\n        if (i != v.size() - 1) cout << \", \";\n    }\n    cout << \"}\" << endl;\n}\n\n"}
{"task_id": "CPP/27", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring flip_case(string str) {\n    for (size_t i = 0; i < str.length(); ++i) {\n        if (isupper(str[i])) {\n            // Convert uppercase to lowercase\n            str[i] = tolower(str[i]);\n        } else if (islower(str[i])) {\n            // Convert lowercase to uppercase\n            str[i] = toupper(str[i]);\n        }\n    }\n    return str;\n}\n\n"}
{"task_id": "CPP/28", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring concatenate(vector<string> strings) {\n    // Initialize an empty string for storing the concatenated result.\n    string result = \"\";\n    \n    // Iterate through each element in the vector and append it to the result.\n    for (const auto& str : strings) {\n        result += str;\n    }\n    \n    return result;\n}\n\n// Function to test the concatenate function with some test cases\nvoid test_concatenate() {\n    cout << \"Test Case 1: Empty Vector -> Expected: \\\"\\\", Actual: \\\"\" << concatenate({}) << \"\\\"\" << endl;\n    cout << \"Test Case 2: {\\\"a\\\", \\\"b\\\", \\\"c\\\"} -> Expected: \\\"abc\\\", Actual: \\\"\" << concatenate({\"a\", \"b\", \"c\"}) << \"\\\"\" << endl;\n}\n\n"}
{"task_id": "CPP/29", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> filter_by_prefix(vector<string> strings, string prefix) {\n    vector<string> filteredStrings; // This will store the results\n\n    for (const auto& str : strings) { // Iterate through each string in the input\n        if (!str.empty() && str.substr(0, prefix.size()) == prefix) {\n            // Check if the current string starts with the given prefix\n            filteredStrings.push_back(str); // Add to result vector if condition is met\n        }\n    }\n\n    return filteredStrings; // Return the filtered list of strings\n}\n\n// Function to test the filter_by_prefix function\nvoid check() {\n    auto result1 = filter_by_prefix({}, \"a\");\n    cout << \"Test 1: \";\n    for (const auto& str : result1) {\n        cout << str << \" \";\n    }\n    cout << endl;\n\n    auto result2 = filter_by_prefix({\"abc\", \"bcd\", \"cde\", \"vector\"}, \"a\");\n    cout << \"Test 2: \";\n    for (const auto& str : result2) {\n        cout << str << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/30", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // For std::copy_if\n\nusing namespace std;\n\nvector<float> get_positive(vector<float> l) {\n    vector<float> result;  // This will store the positive numbers.\n    \n    // Use copy_if to filter only positive numbers into 'result'.\n    copy_if(l.begin(), l.end(), back_inserter(result), [](float x){ return x > 0; });\n    \n    return result;\n}\n\n// Function to print a vector\nvoid print_vector(const vector<float>& v) {\n    for (auto num : v) {\n        cout << num << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/31", "generation": "#include <iostream>\nusing namespace std;\n\nbool is_prime(long long n) {\n    // Handle edge cases for 0, 1 and negative numbers.\n    if (n <= 1) return false;\n    \n    // Check divisibility from 2 up to the square root of n.\n    for (long long i = 2; i * i <= n; ++i) {\n        if (n % i == 0)\n            return false;\n    }\n    return true;\n}\n\n"}
{"task_id": "CPP/32", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\ndouble poly(vector<double> xs, double x){\n    /* \n    Evaluates polynomial with coefficients xs at point x. return xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n \n    */\n    double sum=0;\n    int i;\n    for (i=0;i<xs.size();i++)\n    {\n        sum+=xs[i]*pow(x,i);\n    }\n    return sum;\n}\n\ndouble find_zero(vector<double> xs){\n    /*\n    xs are coefficients of a polynomial. find_zero finds x such that poly(x) = 0. find_zero returns only one zero point, even if there are many. \n    Moreover, find_zero only takes list xs having an even number of coefficients and the largest non-zero coefficient as it guarantees a solution.\n    \n    Example:\n    >>> round(find_zero({1, 2}), 2); // f(x) = 1 + 2x\n    -0.5\n    >>> round(find_zero({-6, 11, -6, 1}), 2); // (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3 \n    1.0\n    */\n}\n"}
{"task_id": "CPP/33", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // for std::sort\n\nusing namespace std;\n\nvector<int> sort_third(vector<int> l) {\n    vector<int> to_sort;\n    \n    // Extract values from indices divisible by 3 (0-based indexing)\n    for(size_t i = 0; i < l.size(); i += 3) {\n        to_sort.push_back(l[i]);\n    }\n    \n    // Sort the extracted values\n    sort(to_sort.begin(), to_sort.end());\n    \n    // Replace original elements with sorted ones\n    for(size_t i = 0, j = 0; i < l.size() && j < to_sort.size(); i += 3, ++j) {\n        l[i] = to_sort[j];\n    }\n    \n    return l;\n}\n\n// Function to test the correctness of sort_third function\nvoid check_function() {\n    vector<int> test1 = {1, 2, 3};\n    vector<int> expected1 = {1, 2, 3};\n    assert(sort_third(test1) == expected1);\n\n    vector<int> test2 = {5, 6, 3, 4, 8, 9, 2};\n    vector<int> expected2 = {2, 6, 3, 4, 8, 9, 5};\n    assert(sort_third(test2) == expected2);\n\n    cout << \"All tests passed successfully.\" << endl;\n}\n\n"}
{"task_id": "CPP/34", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // for std::sort and std::unique\n\nusing namespace std;\n\nvector<int> unique(vector<int> l) {\n    // First, sort the vector so that duplicate elements are adjacent.\n    sort(l.begin(), l.end());\n    \n    // Use std::unique to remove consecutive duplicates. It returns a past-the-end iterator for the new range of unique elements.\n    auto last = unique(l.begin(), l.end());\n    \n    // Erase the non-unique part of the vector\n    l.erase(last, l.end());\n    \n    return l;\n}\n\n// Function to print the contents of a vector\nvoid printVector(const vector<int>& v) {\n    for (int i : v) {\n        cout << i << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/35", "generation": "#include <vector>\n#include <algorithm> // For std::numeric_limits\n\nusing namespace std;\n\nfloat max_element(vector<float> l) {\n    if (l.empty()) {  // Check if the vector is empty to avoid undefined behavior.\n        return numeric_limits<float>::lowest(); // Return the lowest possible float value if the vector is empty\n    }\n\n    float max_val = l[0];  // Initialize max_val with the first element of the vector\n\n    for (size_t i = 1; i < l.size(); ++i) {  // Start from the second element and iterate through the rest\n        if (l[i] > max_val) {\n            max_val = l[i];  // Update max_val if a larger value is found\n        }\n    }\n\n    return max_val;\n}\n"}
{"task_id": "CPP/36", "generation": "#include <iostream>\nusing namespace std;\n\nint fizz_buzz(int n) {\n    int count = 0;\n    \n    for (int i = 1; i < n; ++i) {\n        if ((i % 11 == 0 || i % 13 == 0)) { // Check divisibility by 11 or 13\n            int temp = i;\n            while (temp > 0) {\n                if (temp % 10 == 7) count++; // Count digit '7'\n                temp /= 10; // Move to the next digit\n            }\n        }\n    }\n    \n    return count;\n}\n\n"}
{"task_id": "CPP/37", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // for std::sort\n\nusing namespace std;\n\nvector<float> sort_even(vector<float> l) {\n    vector<float> even_elements;\n    \n    // Extract elements at even indices and store them in a separate vector.\n    for (size_t i = 0; i < l.size(); i += 2) {\n        even_elements.push_back(l[i]);\n    }\n    \n    // Sort the extracted even-indexed elements.\n    sort(even_elements.begin(), even_elements.end());\n    \n    // Place sorted elements back into their original positions in vector `l`.\n    for (size_t i = 0, j = 0; i < l.size(); i += 2) {\n        l[i] = even_elements[j++];\n    }\n    \n    return l;\n}\n\n// Function to test the sort_even function with provided data points.\nvoid check() {\n    vector<float> result;\n\n    // Test case 1\n    result = sort_even({1, 2, 3});\n    for (float num : result) cout << num << \" \";\n    cout << endl; // Expected: 1 2 3\n\n    // Test case 2\n    result = sort_even({5, 6, 3, 4});\n    for (float num : result) cout << num << \" \";\n    cout << endl; // Expected: 3 6 5 4\n}\n\n"}
{"task_id": "CPP/38", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\n// Function to encode a string by cycling groups of three characters.\nstring encode_cyclic(string s) { \n    int l = s.length();\n    string output;\n    for (int i = 0; i * 3 < l; i++) {\n        string x = s.substr(i * 3, 3);\n        if (x.length() == 3) x = x.substr(1) + x[0];\n        output += x;\n    }\n    return output;\n}\n\n// Function to decode a string that was encoded with encode_cyclic.\nstring decode_cyclic(string s) { \n    int l = s.length();\n    string output;\n    for (int i = 0; i * 3 < l; i++) {\n        string x = s.substr(i * 3, 3);\n        if (x.length() == 3) x = x[2] + x.substr(0, 2); // Rotate right\n        output += x;\n    }\n    return output;\n}\n\n"}
{"task_id": "CPP/39", "generation": "#include <stdio.h>\n#include <math.h>\n\n// Function to check if a number is prime\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    if (num == 2 || num == 3) return true;\n    if (num % 2 == 0 || num % 3 == 0) return false;\n\n    for (int i = 5; i * i <= num; i += 6) {\n        if (num % i == 0 || num % (i + 2) == 0)\n            return false;\n    }\n    return true;\n}\n\n// Function to find the n-th Fibonacci number that is also prime\nint prime_fib(int n) {\n    int fib1 = 0, fib2 = 1; // First two Fibonacci numbers\n    int count = 0;\n\n    while (true) {\n        int nextFib = fib1 + fib2;\n        if (is_prime(nextFib)) {\n            count++;\n            if (count == n)\n                return nextFib;\n        }\n        fib1 = fib2;\n        fib2 = nextFib;\n    }\n\n    // This line should never be reached\n    return -1;\n}\n\n"}
{"task_id": "CPP/40", "generation": "#include <vector>\n#include <algorithm> // For std::sort\n\nusing namespace std;\n\nbool triples_sum_to_zero(vector<int> l) {\n    int n = l.size();\n    \n    if (n < 3) return false; // Early exit for vectors with less than 3 elements\n    \n    sort(l.begin(), l.end()); // Sort the vector to use two-pointer technique\n    \n    for(int i = 0; i < n-2; ++i) {\n        int left = i + 1, right = n - 1;\n        \n        while(left < right) {\n            int sum = l[i] + l[left] + l[right];\n            \n            if(sum == 0) return true; // Found three numbers that sum to zero\n            else if(sum < 0) ++left; // Need a larger number, move left pointer to the right\n            else --right; // Need a smaller number, move right pointer to the left\n        }\n    }\n    \n    return false; // No triplet found that sums up to zero\n}\n\n// Example usage:\n"}
{"task_id": "CPP/41", "generation": "#include <iostream>\nusing namespace std;\n\nint car_race_collision(int n) {\n    // Since all cars move at the same speed and the road is infinitely long,\n    // each left-to-right moving car will eventually collide with exactly one right-to-left moving car.\n    return n;\n}\n\n"}
{"task_id": "CPP/42", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> incr_list(vector<int> l) {\n    // Iterate over all elements of the vector.\n    for (size_t i = 0; i < l.size(); ++i) {\n        // Increment each element by 1.\n        l[i] += 1;\n    }\n    return l;\n}\n\n// Function to test the correctness of incr_list function\nvoid check() {\n    vector<int> test1 = {1, 2, 3};\n    vector<int> expected1 = {2, 3, 4};\n    assert(incr_list(test1) == expected1);\n\n    vector<int> test2 = {5, 3, 5, 2, 3, 3, 9, 0, 123};\n    vector<int> expected2 = {6, 4, 6, 3, 4, 4, 10, 1, 124};\n    assert(incr_list(test2) == expected2);\n\n    cout << \"All tests passed successfully.\" << endl;\n}\n\n"}
{"task_id": "CPP/43", "generation": "#include <iostream>\n#include <vector>\n#include <unordered_set> // Use unordered_set for efficient lookup\n\nusing namespace std;\n\nbool pairs_sum_to_zero(vector<int> l) {\n    unordered_set<int> seenNumbers; // Set to keep track of numbers we've seen\n    \n    for (int num : l) { // Iterate through each number in the vector\n        if (seenNumbers.find(-num) != seenNumbers.end()) { // Check if -num is already in the set\n            return true; // Found two numbers that sum to zero\n        }\n        seenNumbers.insert(num); // Add current number to the set\n    }\n    \n    return false; // No pair found that sums to zero\n}\n\n// Function to test the pairs_sum_to_zero function with given data points\nvoid check() {\n    cout << boolalpha; // Print true/false instead of 1/0 for boolean values\n    cout << \"Test Case 1: \" << pairs_sum_to_zero({1, 3, 5, 0}) << endl;\n    cout << \"Test Case 2: \" << pairs_sum_to_zero({1, 3, -2, 1}) << endl;\n    cout << \"Test Case 3: \" << pairs_sum_to_zero({1, 2, 3, 7}) << endl;\n    cout << \"Test Case 4: \" << pairs_sum_to_zero({2, 4, -5, 3, 5, 7}) << endl;\n    cout << \"Test Case 5: \" << pairs_sum_to_zero({1}) << endl;\n}\n\n"}
{"task_id": "CPP/44", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring change_base(int x, int base) {\n    if (base <= 1 || base >= 10) return \"Invalid base\"; // Ensure base is valid\n\n    string result = \"\";\n    while (x > 0) {\n        int remainder = x % base;\n        result = to_string(remainder) + result; // Prepend the remainder\n        x /= base;\n    }\n\n    if(result == \"\") result = \"0\"; // Handle case where x was 0 initially\n\n    return result;\n}\n\n"}
{"task_id": "CPP/45", "generation": "#include<stdio.h>\n\nfloat triangle_area(float a, float h) {\n    // Area of a triangle is 0.5 * base * height\n    return 0.5 * a * h;\n}\n\n"}
{"task_id": "CPP/46", "generation": "#include <iostream>\n#include <vector>\n\nint fib4(int n) {\n    // Base cases for the first four elements of the sequence.\n    if (n == 0 || n == 1)\n        return 0;\n    else if (n == 2)\n        return 2;\n    else if (n == 3)\n        return 0;\n\n    // Initialize an array to store the computed values up to n\n    std::vector<int> fib4_values(n + 1);\n    \n    // Set the base cases.\n    fib4_values[0] = 0;\n    fib4_values[1] = 0;\n    fib4_values[2] = 2;\n    fib4_values[3] = 0;\n\n    // Compute each value from 4 to n using the formula\n    for (int i = 4; i <= n; ++i) {\n        fib4_values[i] = fib4_values[i - 1] + fib4_values[i - 2] + fib4_values[i - 3] + fib4_values[i - 4];\n    }\n\n    // Return the nth value\n    return fib4_values[n];\n}\n\n"}
{"task_id": "CPP/47", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // for std::sort\n\nusing namespace std;\n\nfloat median(vector<float> l){\n    size_t n = l.size();\n    \n    if (n == 0) {\n        throw invalid_argument(\"Vector is empty\");\n    }\n    \n    sort(l.begin(), l.end()); // Sort the vector\n    \n    if (n % 2 != 0) { // If odd number of elements\n        return l[n / 2];\n    } else { // If even number of elements\n        return (l[(n - 1) / 2] + l[n / 2]) / 2.0;\n    }\n}\n\n"}
{"task_id": "CPP/48", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_palindrome(string text) {\n    int left = 0;\n    int right = text.length() - 1;\n\n    while (left < right) {\n        if (text[left] != text[right]) {\n            return false; // Characters do not match\n        }\n        left++;\n        right--;\n    }\n\n    return true; // All characters matched, it's a palindrome\n}\n\n"}
{"task_id": "CPP/49", "generation": "#include <iostream>\nusing namespace std;\n\n// Function to perform modular exponentiation\nint modp(int n, int p) {\n    long long result = 1;\n    long long base = 2 % p; // Ensure the base is within modulo range\n\n    while (n > 0) {\n        if (n & 1) { // If n is odd, multiply result with base\n            result = (result * base) % p;\n        }\n        n >>= 1; // Divide exponent by 2\n        base = (base * base) % p; // Square the base and take modulo\n    }\n\n    return static_cast<int>(result);\n}\n"}
{"task_id": "CPP/50", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nstring encode_shift(string s) {\n    // returns encoded string by shifting every character by 5 in the alphabet.\n    string out;\n    int i;\n    for (i = 0; i < s.length(); i++) {\n        int w = ((int)s[i] + 5 - (int)'a') % 26 + (int)'a';\n        out += (char)w;\n    }\n    return out;\n}\n\nstring decode_shift(string s) {\n    // takes as input string encoded with encode_shift function. Returns decoded string.\n    string out;\n    int i;\n    for (i = 0; i < s.length(); i++) {\n        int w = ((int)s[i] - 5 - (int)'a' + 26) % 26 + (int)'a'; // Adding 26 to ensure positive result\n        out += (char)w;\n    }\n    return out;\n}\n\n// Example usage:\n"}
{"task_id": "CPP/51", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool isVowel(char c) {\n    // Convert character to lowercase for simplicity and check if it's a vowel.\n    char lower_c = tolower(c);\n    return (lower_c == 'a' || lower_c == 'e' || lower_c == 'i' || lower_c == 'o' || lower_c == 'u');\n}\n\nstring remove_vowels(string text) {\n    string result;\n    for(char c : text) {\n        if(!isVowel(c)) { // If the character is not a vowel, add it to the result.\n            result += c;\n        }\n    }\n    return result;\n}\n\n"}
{"task_id": "CPP/52", "generation": "#include <vector>\nusing namespace std;\n\nbool below_threshold(vector<int> l, int t) {\n    // Iterate through each element in the vector\n    for (int num : l) {\n        // If any number is greater than or equal to the threshold, return false\n        if (num >= t) {\n            return false;\n        }\n    }\n    // If all numbers are below the threshold, return true\n    return true;\n}\n\n// Example usage:\n/*\nbool result1 = below_threshold({1, 2, 4, 10}, 100); // Should be true\nbool result2 = below_threshold({1, 20, 4, 10}, 5);   // Should be false\n*/\n"}
{"task_id": "CPP/53", "generation": "#include<iostream>\nusing namespace std;\n\nint add(int x, int y) {\n    return x + y;\n}\n\n// Example usage\n"}
{"task_id": "CPP/54", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nbool same_chars(string s0, string s1) {\n    // Sort both strings to bring identical characters together.\n    sort(s0.begin(), s0.end());\n    sort(s1.begin(), s1.end());\n\n    // Remove duplicate characters from each sorted string.\n    auto last_unique_s0 = unique(s0.begin(), s0.end());\n    auto last_unique_s1 = unique(s1.begin(), s1.end());\n\n    // Erase the duplicates in place to get only unique characters.\n    s0.erase(last_unique_s0, s0.end());\n    s1.erase(last_unique_s1, s1.end());\n\n    // Compare the two strings for equality after processing.\n    return s0 == s1;\n}\n\n"}
{"task_id": "CPP/55", "generation": "#include<stdio.h>\n\nint fib(int n) {\n    if (n <= 1)\n        return n;\n    else\n        return fib(n-1) + fib(n-2);\n}\n\n"}
{"task_id": "CPP/56", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    int balance = 0;\n    \n    for (char c : brackets) {\n        if (c == '<') {\n            ++balance; // Increment for an opening bracket\n        } else if (c == '>') {\n            --balance; // Decrement for a closing bracket\n            \n            // If balance goes below zero, there's an unmatched closing bracket\n            if (balance < 0) return false;\n        }\n    }\n    \n    // Return true only if the balance is back to zero at the end\n    return balance == 0;\n}\n\n"}
{"task_id": "CPP/57", "generation": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nbool isMonotonicIncreasing(const vector<float>& l) {\n    for (size_t i = 1; i < l.size(); ++i) {\n        if (l[i - 1] > l[i]) return false;\n    }\n    return true;\n}\n\nbool isMonotonicDecreasing(const vector<float>& l) {\n    for (size_t i = 1; i < l.size(); ++i) {\n        if (l[i - 1] < l[i]) return false;\n    }\n    return true;\n}\n\nbool monotonic(vector<float> l) {\n    return isMonotonicIncreasing(l) || isMonotonicDecreasing(l);\n}\n"}
{"task_id": "CPP/58", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // For sort function\n#include <set>       // To store unique elements\n\nusing namespace std;\n\nvector<int> common(vector<int> l1, vector<int> l2) {\n    // Sort both vectors to make it easier to find common elements.\n    sort(l1.begin(), l1.end());\n    sort(l2.begin(), l2.end());\n\n    set<int> result;  // Use a set to store unique and sorted results\n    auto it1 = l1.begin();\n    auto it2 = l2.begin();\n\n    // Traverse both vectors to find common elements\n    while (it1 != l1.end() && it2 != l2.end()) {\n        if (*it1 == *it2) {\n            result.insert(*it1);\n            ++it1;\n            ++it2;\n        } else if (*it1 < *it2) {\n            ++it1;\n        } else {\n            ++it2;\n        }\n    }\n\n    // Convert set to vector\n    return vector<int>(result.begin(), result.end());\n}\n\n// Function to print the elements of a vector\nvoid printVector(const vector<int>& vec) {\n    for (int num : vec) {\n        cout << num << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/59", "generation": "#include <stdio.h>\n#include <stdbool.h>\n\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    for (int i = 2; i * i <= num; ++i) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\nint largest_prime_factor(int n){\n    int largestFactor = -1;\n\n    // Divide n by 2 to remove all even factors\n    while (n % 2 == 0) {\n        largestFactor = 2;\n        n /= 2;\n    }\n\n    // Now we only have odd factors left, start from 3 and check each odd number.\n    for (int i = 3; i * i <= n; i += 2) {\n        while (n % i == 0) {\n            largestFactor = i;\n            n /= i;\n        }\n    }\n\n    // If n is a prime number greater than 2\n    if (n > 2)\n        largestFactor = n;\n\n    return largestFactor;\n}\n\n"}
{"task_id": "CPP/60", "generation": "#include<iostream>\nusing namespace std;\n\nint sum_to_n(int n){\n    int sum = 0;\n    for (int i = 1; i <= n; ++i) {\n        sum += i;\n    }\n    return sum;\n}\n\n// Function to test the correctness of sum_to_n\nvoid check_function() {\n    cout << \"sum_to_n(30): \" << sum_to_n(30) << endl; // Expected output: 465\n    cout << \"sum_to_n(100): \" << sum_to_n(100) << endl; // Expected output: 5050\n    cout << \"sum_to_n(5): \" << sum_to_n(5) << endl; // Expected output: 15\n    cout << \"sum_to_n(10): \" << sum_to_n(10) << endl; // Expected output: 55\n    cout << \"sum_to_n(1): \" << sum_to_n(1) << endl; // Expected output: 1\n}\n\n"}
{"task_id": "CPP/61", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    int balance = 0; // Initialize balance counter\n\n    for (char c : brackets) { // Iterate through each character in the string\n        if (c == '(') {\n            ++balance; // Increment balance for an opening bracket\n        } else if (c == ')') {\n            --balance; // Decrement balance for a closing bracket\n            if (balance < 0) return false; // If balance is negative, there's a closing bracket without a matching opening one\n        }\n    }\n\n    return balance == 0; // True if all brackets are correctly matched and balanced\n}\n\n"}
{"task_id": "CPP/62", "generation": "#include <iostream>\n#include <vector>\n\nstd::vector<float> derivative(const std::vector<float>& xs) {\n    // Create an empty vector to store the coefficients of the derivative polynomial\n    std::vector<float> result;\n\n    // Iterate through each coefficient starting from the first non-constant term (index 1)\n    for(size_t i = 1; i < xs.size(); ++i) {\n        // Multiply the current coefficient by its index and add it to the result vector\n        result.push_back(xs[i] * static_cast<float>(i));\n    }\n\n    return result;\n}\n\n// Function to test the derivative function with given examples\nvoid check_derivative() {\n    std::vector<float> example1 = {3, 1, 2, 4, 5};\n    std::vector<float> expected1 = {1, 4, 12, 20};\n    \n    std::vector<float> result1 = derivative(example1);\n    assert(result1 == expected1);\n\n    std::vector<float> example2 = {1, 2, 3};\n    std::vector<float> expected2 = {2, 6};\n\n    std::vector<float> result2 = derivative(example2);\n    assert(result2 == expected2);\n\n    std::cout << \"All tests passed successfully.\" << std::endl;\n}\n\n"}
{"task_id": "CPP/63", "generation": "#include <iostream>\n#include <vector>\n\nint fibfib(int n) {\n    // Base cases\n    if (n == 0 || n == 1)\n        return 0;\n    else if (n == 2)\n        return 1;\n\n    // Initialize a vector to store the computed values of fibfib sequence.\n    std::vector<int> dp(n + 1);\n    dp[0] = 0;   // fibfib(0) is 0\n    dp[1] = 0;   // fibfib(1) is 0\n    dp[2] = 1;   // fibfib(2) is 1\n\n    // Compute the values from 3 to n using the recurrence relation.\n    for (int i = 3; i <= n; ++i)\n        dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3];\n\n    return dp[n];\n}\n\n// Function to test the fibfib function with given data points\nvoid check() {\n    std::cout << \"fibfib(1) should be 0: \" << (fibfib(1) == 0 ? \"Passed\" : \"Failed\") << std::endl;\n    std::cout << \"fibfib(5) should be 4: \" << (fibfib(5) == 4 ? \"Passed\" : \"Failed\") << std::endl;\n    std::cout << \"fibfib(8) should be 24: \" << (fibfib(8) == 24 ? \"Passed\" : \"Failed\") << std::endl;\n}\n\n"}
{"task_id": "CPP/64", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint vowels_count(string s) {\n    int count = 0;\n    // Convert string to lowercase for simplicity\n    transform(s.begin(), s.end(), s.begin(), ::tolower);\n\n    // Check each character in the string\n    for (size_t i = 0; i < s.length(); ++i) {\n        char c = s[i];\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n            count++;\n        }\n        // Check for 'y' at the end of the string\n        else if (c == 'y' && i == s.length() - 1) {\n            count++;\n        }\n    }\n\n    return count;\n}\n\n"}
{"task_id": "CPP/65", "generation": "#include <iostream>\n#include <string>\n#include <algorithm> // for std::reverse\nusing namespace std;\n\nstring circular_shift(int x, int shift) {\n    string digits = to_string(x);\n    int num_digits = digits.length();\n    \n    // If shift is greater than number of digits, reverse the digits.\n    if (shift >= num_digits) {\n        reverse(digits.begin(), digits.end());\n        return digits;\n    }\n    \n    int effective_shift = shift % num_digits;\n    string shifted_digits = digits.substr(num_digits - effective_shift) + \n                            digits.substr(0, num_digits - effective_shift);\n    \n    return shifted_digits;\n}\n"}
{"task_id": "CPP/66", "generation": "#include <iostream>\n#include <string>\n#include <cctype> // For isupper() function\n\nusing namespace std;\n\nint digitSum(string s) {\n    int sum = 0;\n    for (char c : s) { // Iterate through each character in the string\n        if (isupper(c)) { // Check if the character is an uppercase letter\n            sum += static_cast<int>(c); // Add its ASCII value to sum\n        }\n    }\n    return sum; // Return the total sum of ASCII values of uppercase letters\n}\n\n"}
{"task_id": "CPP/67", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <vector>\nusing namespace std;\n\nint fruit_distribution(string s, int n) {\n    vector<int> nums;\n    stringstream ss(s);\n    string word;\n    \n    // Extracting numbers from the string using stringstream and pushing them into a vector\n    while (ss >> word) {\n        if (stringstream(word) >> word) {\n            nums.push_back(stoi(word));\n        }\n    }\n\n    // Calculating the number of mangoes by subtracting apples and oranges from total fruits\n    int mango_count = n - accumulate(nums.begin(), nums.end(), 0);\n    \n    return mango_count;\n}\n\n"}
{"task_id": "CPP/68", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> pluck(vector<int> arr) {\n    int minValue = INT_MAX; // Initialize to a very large number.\n    int minIndex = -1;      // No valid index found initially.\n\n    for (int i = 0; i < arr.size(); ++i) {\n        if (arr[i] % 2 == 0 && arr[i] <= minValue) { // Check if the value is even and smaller or equal to current min.\n            if (arr[i] < minValue || (arr[i] == minValue && i < minIndex)) {\n                minValue = arr[i];\n                minIndex = i;\n            }\n        }\n    }\n\n    if (minIndex != -1) { // If a valid index was found, return the value and its index.\n        return {minValue, minIndex};\n    } else { // No even number found or vector is empty.\n        return {};\n    }\n}\n"}
{"task_id": "CPP/69", "generation": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint search(vector<int> lst) {\n    unordered_map<int, int> freqMap;\n    \n    // Count frequencies of each element in the list\n    for (int num : lst) {\n        freqMap[num]++;\n    }\n    \n    int result = -1;  // Initialize result as -1\n    \n    // Check each frequency against its value\n    for (auto &entry : freqMap) {\n        if (entry.first <= entry.second && entry.first > result) {\n            result = entry.first;\n        }\n    }\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/70", "generation": "#include <vector>\n#include <algorithm>\n\nstd::vector<int> strange_sort_list(std::vector<int> lst) {\n    // Sort the vector initially.\n    std::sort(lst.begin(), lst.end());\n    \n    std::vector<int> result;\n    int left = 0; // Start index for minimum value\n    int right = lst.size() - 1; // End index for maximum value\n    \n    while (left <= right) {\n        if (left == right) {\n            // If there's only one element left, add it to the result.\n            result.push_back(lst[left]);\n            break;\n        }\n        \n        // Add the minimum value\n        result.push_back(lst[left++]);\n        // Add the maximum value\n        result.push_back(lst[right--]);\n    }\n\n    return result;\n}\n\n// Example usage:\n"}
{"task_id": "CPP/71", "generation": "#include<stdio.h>\n#include<math.h>\n\nfloat triangle_area(float a, float b, float c){\n    // Check if sides form a valid triangle\n    if (a + b <= c || a + c <= b || b + c <= a) {\n        return -1;\n    }\n\n    // Calculate the semi-perimeter\n    float s = (a + b + c) / 2;\n\n    // Use Heron's formula to calculate area\n    float area = sqrt(s * (s - a) * (s - b) * (s - c));\n\n    // Round the result to two decimal points and return\n    return round(area * 100) / 100;\n}\n\n"}
{"task_id": "CPP/72", "generation": "#include <vector>\nusing namespace std;\n\nbool will_it_fly(vector<int> q, int w) {\n    // Check if the vector is balanced (palindromic)\n    for(int i = 0; i < q.size() / 2; ++i) {\n        if(q[i] != q[q.size() - 1 - i]) return false;\n    }\n\n    // Calculate the sum of elements in the vector\n    int sum = 0;\n    for(int num : q) {\n        sum += num;\n    }\n\n    // Check if the sum is less than or equal to the maximum possible weight w\n    return sum <= w;\n}\n"}
{"task_id": "CPP/73", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint smallest_change(vector<int> arr) {\n    int changes = 0;\n    int left = 0;\n    int right = arr.size() - 1;\n\n    while (left < right) {\n        if (arr[left] != arr[right]) {\n            ++changes; // Increment the change count when elements don't match\n        }\n        ++left;\n        --right;\n    }\n\n    return changes;\n}\n\n"}
{"task_id": "CPP/74", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to calculate the total number of characters in a vector of strings.\nint countChars(const vector<string>& lst) {\n    int count = 0;\n    for (const string& str : lst) {\n        count += str.length();\n    }\n    return count;\n}\n\nvector<string> total_match(vector<string> lst1, vector<string> lst2) {\n    // Calculate the number of characters in each list\n    int charsInLst1 = countChars(lst1);\n    int charsInLst2 = countChars(lst2);\n\n    // Compare and return the appropriate list\n    if (charsInLst1 <= charsInLst2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n\n// Function to test the solution with given examples.\nvoid check() {\n    vector<string> empty = {};\n    vector<string> result;\n\n    // Example 1\n    result = total_match(empty, empty);\n    cout << \"Example 1: \";\n    for (const string& str : result) cout << str << \" \";\n    cout << endl;\n\n    // Example 2\n    result = total_match({\"hi\", \"admin\"}, {\"hI\", \"Hi\"});\n    cout << \"Example 2: \";\n    for (const string& str : result) cout << str << \" \";\n    cout << endl;\n\n    // Example 3\n    result = total_match({\"hi\", \"admin\"}, {\"hi\", \"hi\", \"admin\", \"project\"});\n    cout << \"Example 3: \";\n    for (const string& str : result) cout << str << \" \";\n    cout << endl;\n\n    // Example 4\n    result = total_match({\"hi\", \"admin\"}, {\"hI\", \"hi\", \"hi\"});\n    cout << \"Example 4: \";\n    for (const string& str : result) cout << str << \" \";\n    cout << endl;\n\n    // Example 5\n    result = total_match({\"4\"}, {\"1\", \"2\", \"3\", \"4\", \"5\"});\n    cout << \"Example 5: \";\n    for (const string& str : result) cout << str << \" \";\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/75", "generation": "#include <iostream>\nusing namespace std;\n\n// Function to check if a number is prime.\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0)\n            return false;\n    }\n    return true;\n}\n\n// Function to check if a number can be expressed as the product of exactly three prime numbers.\nbool is_multiply_prime(int a) {\n    // Iterate through all possible combinations of primes less than 100\n    for (int i = 2; i < 100 && i * i * i <= a; ++i) {\n        if (!is_prime(i)) continue;\n        \n        for (int j = i; j < 100 && i * j * j <= a; ++j) {\n            if (!is_prime(j)) continue;\n\n            for (int k = j; k < 100; ++k) {\n                if (!is_prime(k)) continue;\n                \n                // Check if the product of these three primes equals 'a'\n                if (i * j * k == a)\n                    return true;\n            }\n        }\n    }\n\n    return false;\n}\n\n"}
{"task_id": "CPP/76", "generation": "#include <cmath> // For log and pow functions\n\nbool is_simple_power(int x, int n) {\n    if (n == 1) return x == 1; // Special case: only 1^k = 1 for any k.\n    \n    double log_result = std::log(x) / std::log(n); // Calculate the logarithm of x with base n\n    \n    // Check if the result is an integer by comparing it to its rounded value\n    return std::abs(log_result - std::round(log_result)) < 1e-9; \n}\n\n"}
{"task_id": "CPP/77", "generation": "#include <cmath> // For std::cbrt and std::round\n\nbool iscube(int a) {\n    double cubeRoot = std::cbrt(a); // Calculate the cube root of 'a'\n    int nearestInt = std::round(cubeRoot); // Round to the nearest integer\n    \n    // Check if the cube of the rounded value equals 'a'\n    return (nearestInt * nearestInt * nearestInt == a);\n}\n\n"}
{"task_id": "CPP/78", "generation": "#include <iostream>\n#include <string>\n#include <set>\n\nusing namespace std;\n\nint hex_key(string num) {\n    // Set of prime hexadecimal digits\n    set<char> primes = {'2', '3', '5', '7', 'B', 'D'};\n    \n    int count = 0;\n    for (char c : num) {\n        if (primes.find(c) != primes.end()) {\n            ++count;\n        }\n    }\n    \n    return count;\n}\n\n"}
{"task_id": "CPP/79", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring decimal_to_binary(int decimal) {\n    // Convert the number to binary using bit manipulation.\n    string binary = \"\";\n    \n    if (decimal == 0) {\n        return \"db0db\"; // Special case for zero\n    }\n    \n    while (decimal > 0) {\n        int remainder = decimal % 2;\n        binary = char('0' + remainder) + binary; // Convert the remainder to a character and prepend it.\n        decimal /= 2;\n    }\n\n    return \"db\" + binary + \"db\"; // Add 'db' at both ends\n}\n\n"}
{"task_id": "CPP/80", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_happy(string s) {\n    // Check if the length of the string is less than 3, return false immediately.\n    if (s.length() < 3) {\n        return false;\n    }\n\n    // Iterate through the string to check every set of three consecutive characters\n    for (int i = 0; i <= s.length() - 3; ++i) {\n        // Check if any two out of three consecutive characters are the same.\n        if (s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]) {\n            return false;\n        }\n    }\n\n    // If all checks pass, the string is happy\n    return true;\n}\n\n"}
{"task_id": "CPP/81", "generation": "#include <vector>\n#include <string>\n\nusing namespace std;\n\n// Renaming the function to match the one used in main()\nvector<string> numerical_letter_grade(vector<float> gpa_list) {\n    vector<string> letter_grades;\n    \n    for (float gpa : gpa_list) {\n        if (gpa == 4.0f)\n            letter_grades.push_back(\"A+\");\n        else if (gpa > 3.7f && gpa <= 4.0f)\n            letter_grades.push_back(\"A\");\n        else if (gpa > 3.3f && gpa <= 3.7f)\n            letter_grades.push_back(\"A-\");\n        else if (gpa > 3.0f && gpa <= 3.3f)\n            letter_grades.push_back(\"B+\");\n        else if (gpa > 2.7f && gpa <= 3.0f)\n            letter_grades.push_back(\"B\");\n        else if (gpa > 2.3f && gpa <= 2.7f)\n            letter_grades.push_back(\"B-\");\n        else if (gpa > 2.0f && gpa <= 2.3f)\n            letter_grades.push_back(\"C+\");\n        else if (gpa > 1.7f && gpa <= 2.0f)\n            letter_grades.push_back(\"C\");\n        else if (gpa > 1.3f && gpa <= 1.7f)\n            letter_grades.push_back(\"C-\");\n        else if (gpa > 1.0f && gpa <= 1.3f)\n            letter_grades.push_back(\"D+\");\n        else if (gpa > 0.7f && gpa <= 1.0f)\n            letter_grades.push_back(\"D\");\n        else if (gpa > 0.0f && gpa <= 0.7f)\n            letter_grades.push_back(\"D-\");\n        else\n            letter_grades.push_back(\"E\"); // GPA is 0 or below\n    }\n    \n    return letter_grades;\n}\n"}
{"task_id": "CPP/82", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\n// Helper function to check if a number is prime.\nbool is_prime(int n) {\n    if (n <= 1) return false; // 0 and 1 are not primes\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\n// Main function to check if the length of a string is prime.\nbool prime_length(string str){\n    int len = str.length();\n    return is_prime(len);\n}\n\n"}
{"task_id": "CPP/83", "generation": "#include <cmath>\n#include <iostream>\nusing namespace std;\n\nlong long starts_one_ends(int n) {\n    if (n == 1) return 1;\n    \n    // Calculate the number of possibilities for each case.\n    long long count_start_with_1 = pow(9, n - 1);\n    long long count_end_with_1 = pow(9, n - 1);\n    long long overlap_count = pow(9, n - 2);\n\n    return static_cast<int>(count_start_with_1 + count_end_with_1 - overlap_count);\n}\n"}
{"task_id": "CPP/84", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\n// Function to calculate the sum of digits of N\nint sumOfDigits(int N) {\n    int sum = 0;\n    while (N > 0) {\n        sum += N % 10; // Add the last digit to sum\n        N /= 10;       // Remove the last digit from N\n    }\n    return sum;\n}\n\n// Function to convert an integer to its binary string representation\nstring intToBinary(int num) {\n    if (num == 0) return \"0\"; // Special case for zero\n\n    string binary = \"\";\n    while (num > 0) {\n        binary = to_string(num % 2) + binary; // Prepend the remainder of division by 2\n        num /= 2;\n    }\n    return binary;\n}\n\nstring solve(int N){\n    int sumDigits = sumOfDigits(N); // Calculate the sum of digits\n    string resultBinary = intToBinary(sumDigits); // Convert the sum to binary string\n    return resultBinary; // Return the binary representation as a string\n}\n\n// Example usage:\n"}
{"task_id": "CPP/85", "generation": "#include <vector>\nusing namespace std;\n\nint add(vector<int> lst) {\n    int sum = 0;\n    \n    // Iterate through the list with an index starting from 1 (the first odd index)\n    for(int i = 1; i < lst.size(); i += 2) { // Increment by 2 to stay at odd indices\n        if(lst[i] % 2 == 0) { // Check if the element is even\n            sum += lst[i]; // Add it to the sum\n        }\n    }\n\n    return sum;\n}\n"}
{"task_id": "CPP/86", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nstring anti_shuffle(string s) {\n    // Temporary variables to hold the current word and its sorted version.\n    string tempWord = \"\";\n    string result = \"\";\n\n    for (char c : s) {\n        if (c == ' ') {  // If we encounter a space, process the collected word\n            sort(tempWord.begin(), tempWord.end());  // Sort characters in ascending order based on ASCII value\n            result += tempWord + \" \";  // Append sorted word and space to the result\n            tempWord = \"\";  // Reset for next word\n        } else {\n            tempWord += c;  // Collect characters of current word\n        }\n    }\n\n    if (!tempWord.empty()) {  // Process any remaining word after last space or at end of string\n        sort(tempWord.begin(), tempWord.end());\n        result += tempWord;\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/87", "generation": "#include <vector>\n#include <algorithm> // for std::sort\n\nusing namespace std;\n\nbool compare(const vector<int>& a, const vector<int>& b) {\n    if (a[0] != b[0]) return a[0] < b[0]; // sort by row in ascending order\n    else return a[1] > b[1];              // then by column in descending order within the same row\n}\n\nvector<vector<int>> get_row(vector<vector<int>> lst, int x) {\n    vector<vector<int>> coordinates;\n    \n    for (int i = 0; i < lst.size(); ++i) { // iterate through each row\n        for (int j = 0; j < lst[i].size(); ++j) { // iterate through each element in the current row\n            if (lst[i][j] == x) {\n                coordinates.push_back({i, j}); // store the coordinate of found integer\n            }\n        }\n    }\n\n    sort(coordinates.begin(), coordinates.end(), compare); // sort according to specified rules\n\n    return coordinates;\n}\n\n// Example usage:\n"}
{"task_id": "CPP/88", "generation": "#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> sort_array(vector<int> array) {\n    // Check if the vector is empty or contains only one element\n    if (array.size() <= 1) return array;\n    \n    // Calculate the sum of the first and last elements\n    int sum = array.front() + array.back();\n    \n    // Create a copy to avoid modifying the original vector\n    vector<int> sortedArray(array);\n    \n    // Sort based on whether the sum is odd or even\n    if (sum % 2 == 0) {\n        sort(sortedArray.begin(), sortedArray.end(), greater<int>());\n    } else {\n        sort(sortedArray.begin(), sortedArray.end());\n    }\n    \n    return sortedArray;\n}\n\n// Example usage:\n"}
{"task_id": "CPP/89", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring encrypt(string s){\n    for (int i = 0; i < s.length(); ++i) {\n        char c = s[i];\n        \n        // Check if the character is a lowercase letter.\n        if ('a' <= c && c <= 'z') {\n            // Shift by 4 positions and wrap around using modulo operation\n            s[i] = ((c - 'a' + 4) % 26) + 'a';\n        }\n        \n        // Check if the character is an uppercase letter.\n        else if ('A' <= c && c <= 'Z') {\n            // Shift by 4 positions and wrap around using modulo operation\n            s[i] = ((c - 'A' + 4) % 26) + 'A';\n        }\n    }\n    \n    return s;\n}\n\n"}
{"task_id": "CPP/90", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint next_smallest(vector<int> lst) {\n    if (lst.size() < 2) { // If the list has less than two elements, return -1.\n        return -1;\n    }\n\n    sort(lst.begin(), lst.end()); // Sort the vector to find the smallest and second smallest elements easily.\n\n    int first = lst[0]; // The smallest element is now at index 0 after sorting.\n    \n    for (int i = 1; i < lst.size(); ++i) {\n        if (lst[i] != first) { // Find the next unique element which will be the second smallest.\n            return lst[i];\n        }\n    }\n\n    // If all elements are the same, there is no second smallest element.\n    return -1;\n}\n\n"}
{"task_id": "CPP/91", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nint is_bored(string S) {\n    int boredom_count = 0;\n    \n    // Use a stringstream to split the string into sentences.\n    stringstream ss(S);\n    string sentence;\n    char delimiters[] = {'.', '?', '!'};\n\n    while (getline(ss, sentence)) {\n        bool found_delimiter = false;\n\n        for(char delimiter : delimiters) {\n            size_t pos = 0;\n            while ((pos = sentence.find(delimiter, pos)) != string::npos) {\n                // Extract the substring up to the current delimiter.\n                string sub_sentence = sentence.substr(0, pos);\n                \n                // Trim leading spaces from the extracted substring.\n                sub_sentence.erase(0, sub_sentence.find_first_not_of(\" \"));\n                \n                if (!sub_sentence.empty() && sub_sentence[0] == 'I' && (sub_sentence.size() > 1 ? isspace(sub_sentence[1]) : true)) {\n                    boredom_count++;\n                }\n                \n                // Move past the delimiter for next iteration.\n                pos += 1;\n            }\n\n            found_delimiter = true;\n        }\n\n        if (!found_delimiter) {\n            sentence.erase(0, sentence.find_first_not_of(\" \"));\n            \n            if (!sentence.empty() && sentence[0] == 'I' && (sentence.size() > 1 ? isspace(sentence[1]) : true)) {\n                boredom_count++;\n            }\n        }\n    }\n\n    return boredom_count;\n}\n\n"}
{"task_id": "CPP/92", "generation": "#include <iostream>\n#include <cmath>\n\nbool any_int(float a, float b, float c) {\n    // Check if all numbers are integers by comparing them with their floor values.\n    bool is_a_integer = (a == std::floor(a));\n    bool is_b_integer = (b == std::floor(b));\n    bool is_c_integer = (c == std::floor(c));\n\n    // If any of the numbers are not integers, return false\n    if (!is_a_integer || !is_b_integer || !is_c_integer) {\n        return false;\n    }\n\n    // Check if one number equals the sum of the other two.\n    if ((a + b == c) || (b + c == a) || (c + a == b)) {\n        return true;\n    } else {\n        return false;\n    }\n}\n\n"}
{"task_id": "CPP/93", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\n// Function to encode a message according to the given rules.\nstring encode(string message) {\n    // Iterate through each character of the string.\n    for (char &c : message) {\n        // Swap case: if lowercase, convert to uppercase and vice versa.\n        if (islower(c)) c = toupper(c);\n        else if (isupper(c)) c = tolower(c);\n\n        // Replace vowels with the letter that appears 2 places ahead in the alphabet.\n        switch (tolower(c)) {\n            case 'a': c = islower(c) ? 'c' : 'C'; break;\n            case 'e': c = islower(c) ? 'g' : 'G'; break;\n            case 'i': c = islower(c) ? 'k' : 'K'; break;\n            case 'o': c = islower(c) ? 'q' : 'Q'; break;\n            case 'u': c = islower(c) ? 'w' : 'W'; break;\n        }\n    }\n\n    return message;\n}\n\n"}
{"task_id": "CPP/94", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to check if a number is prime\nbool isPrime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\n// Function to calculate the sum of digits of a number\nint sumOfDigits(int num) {\n    int sum = 0;\n    while (num > 0) {\n        sum += num % 10;\n        num /= 10;\n    }\n    return sum;\n}\n\n// Main function to find the largest prime and sum its digits\nint skjkasdkd(vector<int> lst){\n    int maxPrime = -1; // Initialize with a non-prime value\n    \n    // Iterate through the list to find the largest prime number\n    for (int num : lst) {\n        if (isPrime(num)) {\n            maxPrime = max(maxPrime, num);\n        }\n    }\n\n    // If no prime was found, return 0 or handle as needed\n    if (maxPrime == -1) return 0;\n\n    // Calculate and return the sum of digits of the largest prime number\n    return sumOfDigits(maxPrime);\n}\n\n// Function to test the solution with given examples\nvoid check() {\n    cout << skjkasdkd({0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3}) << endl; // 10\n    cout << skjkasdkd({1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1}) << endl; // 25\n    cout << skjkasdkd({1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3}) << endl; // 13\n    cout << skjkasdkd({0,724,32,71,99,32,6,0,5,91,83,0,5,6}) << endl; // 11\n    cout << skjkasdkd({0,81,12,3,1,21}) << endl; // 3\n    cout << skjkasdkd({0,8,1,2,1,7}) << endl; // 7\n}\n\n"}
{"task_id": "CPP/95", "generation": "#include <iostream>\n#include <string>\n#include <map>\n#include <cctype>\nusing namespace std;\n\nbool is_all_lower(const string& str) {\n    for (char c : str) {\n        if (!islower(c)) return false;\n    }\n    return true;\n}\n\nbool is_all_upper(const string& str) {\n    for (char c : str) {\n        if (!isupper(c)) return false;\n    }\n    return true;\n}\n\nbool check_dict_case(map<string, string> dict) {\n    if (dict.empty()) return false;\n\n    bool all_lower = true;\n    bool all_upper = true;\n\n    for (const auto& kv : dict) {\n        const string& key = kv.first;\n        if (!is_all_lower(key)) all_lower = false;\n        if (!is_all_upper(key)) all_upper = false;\n    }\n\n    return all_lower || all_upper;\n}\n"}
{"task_id": "CPP/96", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// Helper function to check if a number is prime\nbool is_prime(int num) {\n    if (num <= 1) return false; // 0 and 1 are not primes\n    for (int i = 2; i * i <= num; ++i) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\nvector<int> count_up_to(int n){\n    vector<int> primes;\n    \n    // Iterate through all numbers from 2 up to but not including n\n    for (int i = 2; i < n; ++i) {\n        if (is_prime(i)) {\n            primes.push_back(i);\n        }\n    }\n\n    return primes;\n}\n\n// Function to test the implementation with given examples\nvoid check() {\n    vector<int> result;\n\n    result = count_up_to(5); // Expected: {2, 3}\n    for(int num : result) cout << num << \" \";\n    cout << endl;\n\n    result = count_up_to(11); // Expected: {2, 3, 5, 7}\n    for(int num : result) cout << num << \" \";\n    cout << endl;\n\n    result = count_up_to(0); // Expected: {}\n    if(result.empty()) cout << \"{}\" << endl;\n    \n    result = count_up_to(20); // Expected: {2, 3, 5, 7, 11, 13, 17, 19}\n    for(int num : result) cout << num << \" \";\n    cout << endl;\n\n    result = count_up_to(1); // Expected: {}\n    if(result.empty()) cout << \"{}\" << endl;\n    \n    result = count_up_to(18); // Expected: {2, 3, 5, 7, 11, 13, 17}\n    for(int num : result) cout << num << \" \";\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/97", "generation": "#include<stdio.h>\n\nint multiply(int a, int b) {\n    // Extracting the unit digits\n    int unitDigitA = abs(a) % 10;\n    int unitDigitB = abs(b) % 10;\n\n    // Calculating and returning the product of the unit digits\n    return unitDigitA * unitDigitB;\n}\n\n"}
{"task_id": "CPP/98", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint count_upper(string s) {\n    int count = 0;\n    \n    // Iterate through the string with even indices only.\n    for (size_t i = 0; i < s.length(); i += 2) { // Start from index 0 and increment by 2\n        char c = s[i];\n        \n        // Check if it's an uppercase vowel\n        if (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n            count++;\n        }\n    }\n\n    return count;\n}\n\n"}
{"task_id": "CPP/99", "generation": "#include <iostream>\n#include <cmath>\n#include <string>\n\nusing namespace std;\n\nint closest_integer(string value) {\n    // Convert string to double for precision handling\n    double num = stod(value);\n    \n    // Check if the number is positive or negative\n    bool isPositive = num > 0;\n    \n    // Calculate the floor and ceil values of the number\n    int floorValue = static_cast<int>(floor(num));\n    int ceilValue = static_cast<int>(ceil(num));\n    \n    // Determine which integer to round towards based on the distance from the decimal part\n    double fractionalPart = num - floorValue;\n    \n    if (fractionalPart == 0.5) {\n        // If equidistant, round away from zero\n        return isPositive ? ceilValue : floorValue;\n    } else {\n        // Otherwise, use standard rounding rules\n        return static_cast<int>(round(num));\n    }\n}\n\n// Function to test the closest_integer function with given examples\nvoid check() {\n    cout << \"Testing '10': Expected 10, Got: \" << closest_integer(\"10\") << endl;\n    cout << \"Testing '15.3': Expected 15, Got: \" << closest_integer(\"15.3\") << endl;\n    cout << \"Testing '14.5': Expected 15, Got: \" << closest_integer(\"14.5\") << endl;\n    cout << \"Testing '-14.5': Expected -15, Got: \" << closest_integer(\"-14.5\") << endl;\n}\n\n"}
{"task_id": "CPP/100", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> make_a_pile(int n) {\n    vector<int> pile;\n    \n    // Start with the first level having 'n' stones.\n    int current_stones = n;\n    \n    for (int i = 0; i < n; ++i) {\n        pile.push_back(current_stones);\n        \n        // Determine the next number of stones based on whether current is odd or even\n        if (current_stones % 2 == 0) { // If current_stones is even, add 2 to get the next even number.\n            current_stones += 2;\n        } else { // If current_stones is odd, add 2 to get the next odd number.\n            current_stones += 2;\n        }\n    }\n\n    return pile;\n}\n\n// Example usage\n"}
{"task_id": "CPP/101", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> words_string(string s) {\n    vector<string> result;\n    string word = \"\";\n    \n    for (char c : s) {\n        if (c == ' ' || c == ',') {  // Check if the character is a space or comma\n            if (!word.empty()) {      // If there's a word, add it to the result vector\n                result.push_back(word);\n                word = \"\";            // Reset the word for the next iteration\n            }\n        } else {\n            word += c;  // Append the current character to the word\n        }\n    }\n\n    if (!word.empty()) {  // Add any remaining word after the loop ends\n        result.push_back(word);\n    }\n\n    return result;\n}\n\n// Function to test the implementation with example inputs\nvoid check() {\n    vector<string> res1 = words_string(\"Hi, my name is John\");\n    for (string s : res1) cout << s << \" \";\n    cout << endl;\n\n    vector<string> res2 = words_string(\"One, two, three, four, five, six\");\n    for (string s : res2) cout << s << \" \";\n}\n\n"}
{"task_id": "CPP/102", "generation": "#include<iostream>\nusing namespace std;\n\nint choose_num(int x, int y) {\n    // Check if the range is valid.\n    if (y < x)\n        return -1;\n    \n    // If 'y' itself is even and within the range, return it.\n    if (y % 2 == 0 && y >= x)\n        return y;\n\n    // Otherwise, check for the next lower number that could be even.\n    int candidate = y - 1;\n    while(candidate >= x) {\n        if (candidate % 2 == 0)\n            return candidate;\n        --candidate; // Move to the next lower number\n    }\n\n    // If no even number is found in the range, return -1.\n    return -1;\n}\n\n"}
{"task_id": "CPP/103", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\n// Function to convert an integer to a binary string\nstring int_to_binary(int num) {\n    if (num == 0) return \"0\";\n    string binary = \"\";\n    while (num > 0) {\n        binary = (num % 2 == 0 ? \"0\" : \"1\") + binary;\n        num /= 2;\n    }\n    return binary;\n}\n\nstring rounded_avg(int n, int m) {\n    if (n > m) return \"-1\";\n    \n    // Calculate the sum of integers from n to m\n    long long sum = ((long long)m * (m + 1) - (n * (n - 1))) / 2;\n    int count = m - n + 1; // Number of terms\n    \n    // Compute average and round down\n    int avg = sum / count;\n    \n    // Convert to binary string\n    return int_to_binary(avg);\n}\n\n"}
{"task_id": "CPP/104", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to check if a number contains only odd digits.\nbool hasOnlyOddDigits(int num) {\n    while (num > 0) {\n        int digit = num % 10;\n        if (digit % 2 == 0) return false; // If any digit is even, return false\n        num /= 10;\n    }\n    return true;\n}\n\nvector<int> unique_digits(vector<int> x) {\n    vector<int> result;\n\n    // Filter numbers that have only odd digits.\n    for (int num : x) {\n        if (hasOnlyOddDigits(num)) {\n            result.push_back(num);\n        }\n    }\n\n    // Sort the filtered numbers in increasing order\n    sort(result.begin(), result.end());\n\n    return result;\n}\n\n// Function to test the solution with given examples\nvoid check() {\n    vector<int> test1 = {15, 33, 1422, 1};\n    vector<int> expected1 = {1, 15, 33};\n    assert(unique_digits(test1) == expected1);\n\n    vector<int> test2 = {152, 323, 1422, 10};\n    vector<int> expected2 = {};\n    assert(unique_digits(test2) == expected2);\n    \n    cout << \"All tests passed successfully.\" << endl;\n}\n\n"}
{"task_id": "CPP/105", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\n\nusing namespace std;\n\nvector<string> by_length(vector<int> arr) {\n    // Map to store the digit-to-name mapping.\n    map<int, string> numberNames = {\n        {1, \"One\"}, {2, \"Two\"}, {3, \"Three\"},\n        {4, \"Four\"}, {5, \"Five\"}, {6, \"Six\"},\n        {7, \"Seven\"}, {8, \"Eight\"}, {9, \"Nine\"}\n    };\n\n    // Filter out numbers not between 1 and 9.\n    vector<int> filteredArr;\n    for (int num : arr) {\n        if (num >= 1 && num <= 9) {\n            filteredArr.push_back(num);\n        }\n    }\n\n    // Sort the filtered array.\n    sort(filteredArr.begin(), filteredArr.end());\n\n    // Reverse the sorted array.\n    reverse(filteredArr.begin(), filteredArr.end());\n\n    // Replace each digit with its corresponding name.\n    vector<string> result;\n    for (int num : filteredArr) {\n        result.push_back(numberNames[num]);\n    }\n\n    return result;\n}\n\n// Function to test the solution\nvoid check() {\n    vector<int> arr1 = {2, 1, 1, 4, 5, 8, 2, 3};\n    vector<string> expected1 = {\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"};\n    assert(by_length(arr1) == expected1);\n\n    vector<int> arr2 = {};\n    vector<string> expected2 = {};\n    assert(by_length(arr2) == expected2);\n\n    vector<int> arr3 = {1, -1, 55};\n    vector<string> expected3 = {\"One\"};\n    assert(by_length(arr3) == expected3);\n\n    cout << \"All tests passed successfully.\" << endl;\n}\n\n"}
{"task_id": "CPP/106", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// Function to calculate factorial\nint factorial(int num) {\n    int result = 1;\n    for (int i = 2; i <= num; ++i) {\n        result *= i;\n    }\n    return result;\n}\n\n// Function to calculate the sum of numbers from 1 to num\nint sumToN(int num) {\n    return (num * (num + 1)) / 2;\n}\n\nvector<int> f(int n) {\n    vector<int> result(n);\n    \n    for (int i = 0; i < n; ++i) {\n        if ((i + 1) % 2 == 0) { // Check if the index+1 is even\n            result[i] = factorial(i + 1); // Calculate factorial\n        } else {\n            result[i] = sumToN(i + 1); // Calculate sum from 1 to i+1\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/107", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\n// Function to check if a number is a palindrome\nbool isPalindrome(int num) {\n    string str = to_string(num);\n    int len = str.length();\n    for (int i = 0; i < len / 2; ++i) {\n        if (str[i] != str[len - i - 1]) return false;\n    }\n    return true;\n}\n\nvector<int> even_odd_palindrome(int n){\n    vector<int> result(2, 0); // Initialize a vector with two elements set to zero\n    for (int i = 1; i <= n; ++i) {\n        if (isPalindrome(i)) { // Check if the number is a palindrome\n            if (i % 2 == 0) {\n                result[0]++; // Increment even count\n            } else {\n                result[1]++; // Increment odd count\n            }\n        }\n    }\n    return result;\n}\n\n"}
{"task_id": "CPP/108", "generation": "#include <vector>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\n\nint sum_of_digits(int num) {\n    int sum = 0;\n    bool is_negative = num < 0;\n    while (num != 0) {\n        int digit = abs(num % 10);\n        if (is_negative && sum == 0) { // Only apply the negative sign to the first digit\n            digit *= -1;\n            is_negative = false; // Ensure only the first digit is negative\n        }\n        sum += digit;\n        num /= 10;\n    }\n    return sum;\n}\n\nint count_nums(vector<int> n) {\n    int count = 0;\n    for (int num : n) {\n        if (sum_of_digits(num) > 0) {\n            ++count;\n        }\n    }\n    return count;\n}\n"}
{"task_id": "CPP/109", "generation": "#include <vector>\nusing namespace std;\n\nbool move_one_ball(vector<int> arr) {\n    if (arr.empty()) return true;\n    \n    int n = arr.size();\n    int disorder_count = 0;\n    \n    // Check for disorder points\n    for (int i = 1; i < n; ++i) {\n        if (arr[i] < arr[i - 1]) {\n            disorder_count++;\n        }\n    }\n\n    // Special case: check the wrap-around condition between last and first element\n    if (disorder_count == 0 || (disorder_count == 1 && arr[n-1] <= arr[0])) {\n        return true;\n    } else {\n        return false;\n    }\n}\n"}
{"task_id": "CPP/110", "generation": "#include <vector>\n#include <string>\nusing namespace std;\n\nstring exchange(vector<int> lst1, vector<int> lst2) {\n    // Count odd numbers in lst1 and even numbers in lst2.\n    int oddCountInLst1 = 0;\n    for (int num : lst1) {\n        if (num % 2 != 0) {\n            ++oddCountInLst1;\n        }\n    }\n\n    int evenCountInLst2 = 0;\n    for (int num : lst2) {\n        if (num % 2 == 0) {\n            ++evenCountInLst2;\n        }\n    }\n\n    // If there are enough even numbers in lst2 to replace all odd numbers in lst1, return \"YES\".\n    if (oddCountInLst1 <= evenCountInLst2) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n"}
{"task_id": "CPP/111", "generation": "#include <iostream>\n#include <string>\n#include <map>\n#include <sstream> // For std::istringstream\n\nusing namespace std;\n\nmap<char, int> histogram(string test) {\n    map<char, int> charCount;\n    map<char, int> result;\n    \n    if (test.empty()) return result; // Return empty map for empty input\n    \n    istringstream iss(test);\n    string word;\n    \n    // Count occurrences of each character\n    while (iss >> word && !word.empty()) {\n        ++charCount[word[0]];\n    }\n    \n    int maxCount = 0;\n    \n    // Find the maximum count\n    for (const auto& pair : charCount) {\n        if (pair.second > maxCount) {\n            maxCount = pair.second;\n        }\n    }\n    \n    // Collect characters with the maximum count into result map\n    for (const auto& pair : charCount) {\n        if (pair.second == maxCount) {\n            result.insert(pair);\n        }\n    }\n    \n    return result;\n}\n\n// Function to print the map for testing purposes\nvoid printMap(const map<char, int>& m) {\n    for (const auto& pair : m) {\n        cout << \"{\" << pair.first << \", \" << pair.second << \"} \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/112", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nbool is_palindrome(const string& str) {\n    int left = 0, right = str.size() - 1;\n    while (left < right) {\n        if (str[left] != str[right]) return false;\n        ++left; --right;\n    }\n    return true;\n}\n\nvector<string> reverse_delete(string s, string c){\n    // Remove all characters in 's' that are present in 'c'\n    for(char ch : c) {\n        s.erase(remove(s.begin(), s.end(), ch), s.end());\n    }\n\n    // Check if the resulting string is a palindrome\n    bool is_pal = is_palindrome(s);\n\n    vector<string> result;\n    result.push_back(s);\n    result.push_back(is_pal ? \"True\" : \"False\");\n\n    return result;\n}\n"}
{"task_id": "CPP/113", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nvector<string> odd_count(vector<string> lst) {\n    vector<string> result;\n    \n    for (const auto& s : lst) {\n        int num_odds = 0;\n        \n        // Count the number of odd digits in the string\n        for (char c : s) {\n            if (isdigit(c)) {\n                if ((c - '0') % 2 != 0) {\n                    ++num_odds;\n                }\n            }\n        }\n\n        // Create the formatted output string with replacements\n        string output_str = \"the number of odd elements \";\n        for (int i = 0; i < 4; ++i) { // Replace all occurrences of {} with num_odds\n            output_str += to_string(num_odds);\n            if (i == 1 || i == 2) {\n                output_str += \"n the str\";\n            } else if (i == 3) {\n                output_str += \"ng \";\n            }\n        }\n        \n        // Add the last part of the string\n        output_str += to_string(num_odds);\n        output_str += \" of the \";\n        output_str += to_string(num_odds);\n        output_str += \"nput.\";\n        \n        result.push_back(output_str);\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/114", "generation": "#include <iostream>\n#include <vector>\n#include <climits> // For INT_MAX\n\nusing namespace std;\n\nlong long minSubArraySum(vector<long long> nums) {\n    if (nums.empty()) return 0; // Handle empty vector case\n    \n    long long currentSum = 0;\n    long long minSum = LLONG_MAX; // Initialize to the largest possible value\n    \n    for (auto num : nums) {\n        currentSum += num;\n        \n        // Update minSum if currentSum is smaller\n        if (currentSum < minSum)\n            minSum = currentSum;\n            \n        // Reset currentSum to 0 if it becomes non-negative\n        if (currentSum >= 0)\n            currentSum = 0;\n    }\n    \n    return minSum;\n}\n\n"}
{"task_id": "CPP/115", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint max_fill(vector<vector<int>> grid, int capacity) {\n    int total_drops = 0;\n    \n    // Iterate over each well (row)\n    for (auto& row : grid) {\n        int water_units = 0;\n        \n        // Count the number of units of water in this well\n        for (int unit : row) {\n            if (unit == 1) {\n                ++water_units;\n            }\n        }\n        \n        // Calculate how many times we need to lower the bucket for this well\n        int drops_for_well = (water_units + capacity - 1) / capacity; // Equivalent to ceil(water_units / capacity)\n        \n        total_drops += drops_for_well;\n    }\n    \n    return total_drops;\n}\n\n"}
{"task_id": "CPP/116", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to count the number of 1s in binary representation of a number.\nint countOnes(int n) {\n    int ones = 0;\n    while (n != 0) {\n        if (n % 2 == 1)\n            ++ones;\n        n /= 2;\n    }\n    return ones;\n}\n\n// Comparator function for sorting based on the number of ones and then by value.\nbool compare(int a, int b) {\n    int countA = countOnes(abs(a));\n    int countB = countOnes(abs(b));\n\n    if (countA == countB)\n        return a < b; // If same number of 1s, sort by decimal value\n    else\n        return countA < countB; // Otherwise, sort by the number of 1s\n}\n\nvector<int> sort_array(vector<int> arr) {\n    sort(arr.begin(), arr.end(), compare);\n    return arr;\n}\n\n"}
{"task_id": "CPP/117", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Helper function to count consonants in a word\nint count_consonants(const string& word) {\n    int count = 0;\n    for (char ch : word) {\n        // Convert character to lowercase and check if it's a consonant\n        char lower_ch = tolower(ch);\n        if ((lower_ch >= 'a' && lower_ch <= 'z') && !(lower_ch == 'a' || lower_ch == 'e' || lower_ch == 'i' || lower_ch == 'o' || lower_ch == 'u')) {\n            count++;\n        }\n    }\n    return count;\n}\n\nvector<string> select_words(string s, int n) {\n    vector<string> result;\n    string word = \"\";\n    \n    // Split the string into words and check consonant count\n    for (char ch : s) {\n        if (ch == ' ') {\n            if (!word.empty()) {\n                if (count_consonants(word) == n) {\n                    result.push_back(word);\n                }\n                word = \"\";  // Reset word after processing it\n            }\n        } else {\n            word += ch;\n        }\n    }\n\n    // Check the last word in case there's no trailing space\n    if (!word.empty()) {\n        if (count_consonants(word) == n) {\n            result.push_back(word);\n        }\n    }\n\n    return result;\n}\n\n// Function to test the implementation with given examples\nvoid check() {\n    vector<string> res;\n\n    res = select_words(\"Mary had a little lamb\", 4);\n    for (const auto& word : res) cout << word << \" \";\n    cout << endl; // Expected: {\"little\"}\n\n    res = select_words(\"Mary had a little lamb\", 3);\n    for (const auto& word : res) cout << word << \" \";\n    cout << endl; // Expected: {\"Mary\", \"lamb\"}\n\n    res = select_words(\"simple white space\", 2);\n    for (const auto& word : res) cout << word << \" \";\n    cout << endl; // Expected: {}\n\n    res = select_words(\"Hello world\", 4);\n    for (const auto& word : res) cout << word << \" \";\n    cout << endl; // Expected: {\"world\"}\n\n    res = select_words(\"Uncle sam\", 3);\n    for (const auto& word : res) cout << word << \" \";\n    cout << endl; // Expected: {\"Uncle\"}\n}\n\n"}
{"task_id": "CPP/118", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_vowel(char c) {\n    string vowels = \"aeiouAEIOU\";\n    return vowels.find(c) != string::npos;\n}\n\nstring get_closest_vowel(string word){\n    int len = word.length();\n    \n    // Iterate from the end of the string to the beginning\n    for (int i = len - 2; i > 0; --i) {\n        // Check if current character is a vowel and surrounded by consonants\n        if (is_vowel(word[i]) && !is_vowel(word[i-1]) && !is_vowel(word[i+1])) {\n            return string(1, word[i]);\n        }\n    }\n    \n    // Return empty string if no such vowel found\n    return \"\";\n}\n\n"}
{"task_id": "CPP/119", "generation": "#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nbool is_good(const string& s) {\n    int balance = 0;\n    for (char c : s) {\n        if (c == '(') {\n            ++balance;\n        } else {\n            --balance;\n            if (balance < 0) {\n                return false;\n            }\n        }\n    }\n    return balance == 0;\n}\n\nstring match_parens(vector<string> lst) {\n    string str1 = lst[0];\n    string str2 = lst[1];\n\n    // Check both concatenation orders\n    if (is_good(str1 + str2) || is_good(str2 + str1)) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\n"}
{"task_id": "CPP/120", "generation": "#include <vector>\n#include <algorithm> // for std::sort\n\nusing namespace std;\n\nvector<int> maximum(vector<int> arr, int k) {\n    // Step 1: Sort the array in ascending order.\n    sort(arr.begin(), arr.end());\n    \n    // Step 2: Extract the last k elements from the sorted vector.\n    vector<int> result;\n    for (int i = arr.size() - k; i < arr.size(); ++i) {\n        result.push_back(arr[i]);\n    }\n    \n    return result;\n}\n\n// Example usage:\n/*\nvector<int> example1 = {-3, -4, 5};\nvector<int> output1 = maximum(example1, 3); // Output: {-4, -3, 5}\n\nvector<int> example2 = {4, -4, 4};\nvector<int> output2 = maximum(example2, 2); // Output: {4, 4}\n\nvector<int> example3 = {-3, 2, 1, 2, -1, -2, 1};\nvector<int> output3 = maximum(example3, 1); // Output: {2}\n*/\n"}
{"task_id": "CPP/121", "generation": "#include <vector>\nusing namespace std;\n\nint solution(vector<int> lst) {\n    int sum = 0;\n    \n    // Iterate through the vector with a step of 2 to check even positions (0-indexed)\n    for(int i = 0; i < lst.size(); i += 2) {\n        if(lst[i] % 2 != 0) { // Check if the element is odd\n            sum += lst[i];\n        }\n    }\n    \n    return sum;\n}\n"}
{"task_id": "CPP/122", "generation": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint add_elements(vector<int> arr, int k) {\n    int sum = 0;\n    for (int i = 0; i < k; ++i) {\n        if (arr[i] >= -99 && arr[i] <= 99) {\n            sum += arr[i];\n        }\n    }\n    return sum;\n}\n"}
{"task_id": "CPP/123", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // For std::sort\n\nusing namespace std;\n\nvector<int> get_odd_collatz(int n) {\n    vector<int> oddNumbers;\n    \n    while (n != 1) {\n        if (n % 2 == 1) { // Check if the number is odd\n            oddNumbers.push_back(n);\n        }\n        if (n % 2 == 0) { // If even, divide by 2\n            n /= 2;\n        } else { // If odd, apply the Collatz formula\n            n = 3 * n + 1;\n        }\n    }\n    \n    // Add the last number in the sequence which is always 1 and is odd.\n    oddNumbers.push_back(1);\n    \n    // Sort the vector of odd numbers before returning it.\n    sort(oddNumbers.begin(), oddNumbers.end());\n    \n    return oddNumbers;\n}\n\n// Function to test the get_odd_collatz function\nvoid check() {\n    vector<int> result = get_odd_collatz(5);\n    for (int num : result) {\n        cout << num << \" \";\n    }\n    // Expected output: 1 5\n    cout << endl;\n    \n    result = get_odd_collatz(7); \n    for (int num : result) {\n        cout << num << \" \";\n    }\n    // Expected output: 1 7 11 22\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/124", "generation": "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nbool valid_date(const string& date) {\n    // Check if the date string is empty or not in mm-dd-yyyy format.\n    if (date.length() != 10 || date[2] != '-' || date[5] != '-') return false;\n    \n    vector<int> days_in_month = {31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\n    \n    // Extract month, day and year from the date string.\n    int month = stoi(date.substr(0, 2));\n    int day = stoi(date.substr(3, 2));\n    int year = stoi(date.substr(6, 4));\n\n    // Validate month\n    if (month < 1 || month > 12) return false;\n\n    // Validate day based on the month and leap year for February.\n    if (day < 1 || day > days_in_month[month - 1]) return false;\n    \n    // Special case for February in a non-leap year\n    if (month == 2 && day == 29) {\n        bool is_leap_year = ((year % 4 == 0 && year % 100 != 0) || (year % 400 == 0));\n        if (!is_leap_year) return false;\n    }\n\n    // If all checks pass, the date is valid.\n    return true;\n}\n\n"}
{"task_id": "CPP/125", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nvector<string> split_words(const string& txt) {\n    vector<string> result;\n    \n    // Check for spaces in the text\n    if (txt.find(' ') != string::npos) {\n        size_t start = 0, end = 0;\n        while ((end = txt.find(' ', start)) != string::npos) {\n            result.push_back(txt.substr(start, end - start));\n            start = end + 1;\n        }\n        result.push_back(txt.substr(start));\n    } \n    // Check for commas in the text\n    else if (txt.find(',') != string::npos) {\n        size_t start = 0, end = 0;\n        while ((end = txt.find(',', start)) != string::npos) {\n            result.push_back(txt.substr(start, end - start));\n            start = end + 1;\n        }\n        result.push_back(txt.substr(start));\n    } \n    // If no spaces or commas exist\n    else {\n        int count = 0;\n        for (char c : txt) {\n            if (islower(c)) {\n                if ((c - 'a') % 2 == 0) {\n                    ++count;\n                }\n            }\n        }\n        result.push_back(to_string(count));\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/126", "generation": "#include <vector>\n#include <algorithm>\n\nbool is_sorted(std::vector<int> lst) {\n    // Check if the list is empty or has only one element, which is always sorted.\n    if (lst.size() <= 1) return true;\n\n    int count = 1; // To keep track of how many times a number appears consecutively.\n\n    for (size_t i = 1; i < lst.size(); ++i) {\n        // If the current element is less than the previous one, it's not sorted.\n        if (lst[i] < lst[i - 1]) return false;\n\n        // Check how many times a number appears consecutively.\n        if (lst[i] == lst[i - 1]) {\n            count++;\n            // If any number appears more than twice, return false.\n            if (count > 2) return false;\n        } else {\n            count = 1; // Reset the counter for different numbers.\n        }\n    }\n\n    return true;\n}\n"}
{"task_id": "CPP/127", "generation": "#include <vector>\n#include <string>\n#include <cmath>\n\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\nstd::string intersection(std::vector<int> interval1, std::vector<int> interval2) {\n    int start_max = std::max(interval1[0], interval2[0]);\n    int end_min = std::min(interval1[1], interval2[1]);\n\n    // Check if there is an intersection\n    if (start_max > end_min) return \"NO\";\n\n    int length_of_intersection = end_min - start_max + 1;\n\n    // Check if the length of intersection is a prime number\n    if (is_prime(length_of_intersection)) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n"}
{"task_id": "CPP/128", "generation": "#include <vector>\n#include <cmath> // For std::abs\n\nint prod_signs(std::vector<int> arr) {\n    if (arr.empty()) return -32768; // Return special value for empty vector\n    \n    int signProduct = 1;\n    int magnitudeSum = 0;\n\n    for (auto num : arr) {\n        magnitudeSum += std::abs(num); // Sum of magnitudes\n        if (num == 0) { \n            signProduct = 0; // If any number is zero, the product of signs will be zero.\n            break;\n        } else if (num < 0) {\n            signProduct *= -1; // Multiply by -1 for negative numbers\n        }\n    }\n\n    return magnitudeSum * signProduct;\n}\n\n// Example usage:\n"}
{"task_id": "CPP/129", "generation": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> dfs(const vector<vector<int>>& grid, int x, int y, const vector<int>& path, int k) {\n    if (path.size() == k)\n        return path;\n    \n    vector<int> best_path;\n    \n    for (const auto& dir : vector<pair<int,int>>{{-1, 0}, {1, 0}, {0, -1}, {0, 1}}) {\n        int dx = dir.first, dy = dir.second;\n        int nx = x + dx, ny = y + dy;\n        \n        if (nx >= 0 && nx < grid.size() && ny >= 0 && ny < grid.size()) {\n            vector<int> new_path = dfs(grid, nx, ny, path, k);\n            new_path.push_back(grid[nx][ny]);\n            \n            if (best_path.empty() || (!new_path.empty() && new_path < best_path))\n                best_path = new_path;\n        }\n    }\n    \n    return best_path;\n}\n\nvector<int> minPath(const vector<vector<int>>& grid, int k) {\n    int n = grid.size();\n    \n    vector<int> min_path;\n    \n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            vector<int> current_path = dfs(grid, i, j, {grid[i][j]}, k);\n            \n            if (min_path.empty() || (!current_path.empty() && current_path < min_path))\n                min_path = current_path;\n        }\n    }\n\n    return min_path;\n}\n"}
{"task_id": "CPP/130", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> tri(int n) {\n    if (n == 0) return {1};\n\n    vector<int> tribonacci(n + 1, 1);\n    tribonacci[1] = 3;\n    \n    for (int i = 2; i <= n; ++i) {\n        if (i % 2 == 0) {\n            tribonacci[i] = 1 + i / 2;\n        } else {\n            // For odd indices, we need to handle the future value carefully\n            if (i < n) {\n                tribonacci[i] = tribonacci[i - 1] + tribonacci[i - 2] + tribonacci[i + 1];\n            } else {\n                // If i is the last element, it cannot use a future value.\n                // We assume that for the last odd index, we only sum up to the previous two elements.\n                tribonacci[i] = tribonacci[i - 1] + tribonacci[i - 2];\n            }\n        }\n    }\n\n    return tribonacci;\n}\n"}
{"task_id": "CPP/131", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint digits(int n) {\n    string numStr = to_string(n); // Convert integer to string for easy digit access\n    int product = 1; // Initialize product with 1\n    \n    bool hasOddDigit = false;\n    \n    for (char c : numStr) { // Iterate through each character in the string\n        int digit = c - '0'; // Convert char to int\n        \n        if (digit % 2 != 0) { // Check if the digit is odd\n            product *= digit; // Multiply it into the product\n            hasOddDigit = true;\n        }\n    }\n    \n    return hasOddDigit ? product : 0; // Return product or 0 based on whether there was an odd digit\n}\n\n"}
{"task_id": "CPP/132", "generation": "#include <string>\nusing namespace std;\n\nbool is_nested(string str) {\n    int max_depth = 0;\n    int current_depth = 0;\n\n    for (char c : str) {\n        if (c == '[') {\n            current_depth += 1;\n            max_depth = max(max_depth, current_depth);\n        } else if (c == ']') {\n            current_depth -= 1;\n        }\n    }\n\n    return max_depth > 1;\n}\n"}
{"task_id": "CPP/133", "generation": "#include <iostream>\n#include <vector>\n#include <cmath> // for ceil and pow functions\n\nusing namespace std;\n\nint sum_squares(vector<float> lst){\n    int sum = 0;\n    for (float num : lst) {\n        float ceilingValue = ceil(num); // Round up to the nearest integer\n        sum += pow(ceilingValue, 2); // Square it and add to sum\n    }\n    return sum;\n}\n\n"}
{"task_id": "CPP/134", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool check_if_last_char_is_a_letter(string txt) {\n    // Check if string is empty or ends with a space.\n    if (txt.empty() || txt.back() == ' ') return false;\n    \n    // Get the last character of the string.\n    char lastChar = txt.back();\n    \n    // Check if it's an alphabetical character and not part of a word.\n    bool isAlphabetical = isalpha(lastChar);\n    bool isNotPartOfWord = (txt.size() == 1 || txt[txt.size()-2] == ' ');\n    \n    return isAlphabetical && isNotPartOfWord;\n}\n\n"}
{"task_id": "CPP/135", "generation": "#include <vector>\nusing namespace std;\n\nint can_arrange(vector<int> arr) {\n    for (size_t i = 1; i < arr.size(); ++i) {\n        if (arr[i] < arr[i - 1]) {\n            return static_cast<int>(i);\n        }\n    }\n    return -1;\n}\n"}
{"task_id": "CPP/136", "generation": "#include <vector>\n#include <algorithm> // For std::min and std::max\n\nusing namespace std;\n\nvector<int> largest_smallest_integers(vector<int> lst){\n    int largestNegative = 0;\n    int smallestPositive = 0;\n    \n    bool foundNegative = false;\n    bool foundPositive = false;\n    \n    for(int num : lst) {\n        if(num < 0) {\n            // Update the largest negative number\n            if(!foundNegative || num > largestNegative) {\n                largestNegative = num;\n                foundNegative = true;\n            }\n        } else if (num > 0) {\n            // Update the smallest positive number\n            if(!foundPositive || num < smallestPositive) {\n                smallestPositive = num;\n                foundPositive = true;\n            }\n        }\n    }\n\n    return {largestNegative, smallestPositive};\n}\n\n// Example usage:\n"}
{"task_id": "CPP/137", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <any>\nusing namespace std;\n\nfloat normalize_value(const any& value) {\n    if (value.type() == typeid(string)) {\n        string str = any_cast<string>(value);\n        replace(str.begin(), str.end(), ',', '.');\n        return stof(str);\n    } else if (value.type() == typeid(int)) {\n        return static_cast<float>(any_cast<int>(value));\n    } else if (value.type() == typeid(float)) {\n        return any_cast<float>(value);\n    }\n    throw invalid_argument(\"Unsupported type\");\n}\n\nany compare_one(any a, any b) {\n    float a_normalized = normalize_value(a);\n    float b_normalized = normalize_value(b);\n\n    if (a_normalized > b_normalized) {\n        return a;\n    } else if (b_normalized > a_normalized) {\n        return b;\n    } else {\n        return string(\"None\");\n    }\n}\n\n"}
{"task_id": "CPP/138", "generation": "#include <iostream>\nusing namespace std;\n\nbool is_equal_to_sum_even(int n) {\n    // Check if n is at least 8 and an even number.\n    return (n >= 8 && n % 2 == 0);\n}\n\n"}
{"task_id": "CPP/139", "generation": "#include <iostream>\nusing namespace std;\n\n// Function to calculate factorial of a given number\nlong long factorial(int num) {\n    if (num == 0 || num == 1)\n        return 1;\n    else\n        return num * factorial(num - 1);\n}\n\n// Function to calculate the Brazilian factorial as defined\nlong long special_factorial(int n){\n    long long result = 1;\n    for(int i = 1; i <= n; ++i) {\n        result *= factorial(i);\n    }\n    return result;\n}\n\n"}
{"task_id": "CPP/140", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring fix_spaces(string text) {\n    string result;\n    int spaceCount = 0; // Counter for consecutive spaces\n\n    for (char c : text) {\n        if (c == ' ') {\n            ++spaceCount;\n        } else {\n            if (spaceCount > 2) {\n                result += '-';\n            } else {\n                while (spaceCount > 0) {\n                    result += '_';\n                    --spaceCount;\n                }\n            }\n            spaceCount = 0; // Reset the counter\n            result += c;\n        }\n    }\n\n    // Handle trailing spaces if any\n    if (spaceCount > 2) {\n        result += '-';\n    } else {\n        while (spaceCount > 0) {\n            result += '_';\n            --spaceCount;\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/141", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring file_name_check(string file_name) {\n    // Check for exactly one dot in the name.\n    size_t dotPos = file_name.find('.');\n    if (dotPos == string::npos || file_name.find('.', dotPos + 1) != string::npos)\n        return \"No\";\n\n    // Split the filename into two parts: before and after the dot\n    string prefix = file_name.substr(0, dotPos);\n    string suffix = file_name.substr(dotPos + 1);\n\n    // Check if there are more than three digits in the prefix.\n    int digitCount = 0;\n    for (char c : prefix) {\n        if (isdigit(c)) digitCount++;\n        if (digitCount > 3) return \"No\";\n    }\n\n    // Validate that the prefix starts with a letter and is not empty\n    if (prefix.empty() || !isalpha(prefix[0])) \n        return \"No\";\n\n    // Check valid extensions.\n    string validExtensions[] = {\"txt\", \"exe\", \"dll\"};\n    bool isValidExtension = false;\n    for (string ext : validExtensions) {\n        if (ext == suffix) {\n            isValidExtension = true;\n            break;\n        }\n    }\n\n    if (!isValidExtension)\n        return \"No\";\n\n    // If all checks pass, the filename is valid.\n    return \"Yes\";\n}\n\n"}
{"task_id": "CPP/142", "generation": "#include <vector>\nusing namespace std;\n\nint sum_squares(vector<int> lst) {\n    int sum = 0;\n    \n    for (size_t i = 0; i < lst.size(); ++i) {\n        if (i % 3 == 0) { // If index is a multiple of 3\n            sum += lst[i] * lst[i]; // Square the element and add to sum\n        } else if (i % 4 == 0 && i % 3 != 0) { // If index is a multiple of 4 but not 3\n            sum += lst[i] * lst[i] * lst[i]; // Cube the element and add to sum\n        } else {\n            sum += lst[i]; // Add the element as it is if no condition matches\n        }\n    }\n\n    return sum;\n}\n\n// Example usage:\n"}
{"task_id": "CPP/143", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\n// Helper function to check if a number is prime\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    for (int i = 2; i * i <= num; ++i) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\n// Main function to filter words based on prime length\nstring words_in_sentence(string sentence) {\n    stringstream ss(sentence);\n    string word, result;\n    \n    while (ss >> word) { // Extract each word from the sentence\n        if (is_prime(word.length())) {\n            if (!result.empty()) result += \" \"; // Add space before appending new word\n            result += word; // Append prime length words to result\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/144", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool simplify(string x, string n) {\n    // Parsing fractions\n    size_t slashPos;\n    \n    int numX = stoi(x.substr(0, (slashPos = x.find('/'))));\n    int denX = stoi(x.substr(slashPos + 1));\n\n    int numN = stoi(n.substr(0, (slashPos = n.find('/'))));\n    int denN = stoi(n.substr(slashPos + 1));\n\n    // Multiplying the fractions\n    int numeratorResult = numX * numN;\n    int denominatorResult = denX * denN;\n\n    // Simplifying to check if it's a whole number\n    return (numeratorResult % denominatorResult == 0);\n}\n\n"}
{"task_id": "CPP/145", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nint sum_of_digits(int n) {\n    int sum = 0;\n    while (n != 0) {\n        sum += n % 10;\n        n /= 10;\n    }\n    return sum;\n}\n\nbool compare(const std::pair<int, int>& a, const std::pair<int, int>& b) {\n    int sum_a = sum_of_digits(a.first);\n    int sum_b = sum_of_digits(b.first);\n\n    if (sum_a == sum_b)\n        return a.second < b.second; // maintain original order\n    else\n        return sum_a < sum_b;\n}\n\nstd::vector<int> order_by_points(std::vector<int> nums) {\n    std::vector<std::pair<int, int>> indexed_nums;\n\n    for (int i = 0; i < nums.size(); ++i)\n        indexed_nums.push_back({nums[i], i});\n\n    // Sort based on the sum of digits and then by original index\n    std::sort(indexed_nums.begin(), indexed_nums.end(), compare);\n\n    std::vector<int> sorted_nums;\n    for (const auto& p : indexed_nums)\n        sorted_nums.push_back(p.first);\n\n    return sorted_nums;\n}\n\n"}
{"task_id": "CPP/146", "generation": "#include <vector>\n#include <string>\nusing namespace std;\n\nbool isFirstAndLastDigitOdd(int num) {\n    // Convert to string to easily access first and last digit\n    string strNum = to_string(abs(num));  // Use abs to handle negative numbers\n    char firstDigit = strNum[0];\n    char lastDigit = strNum[strNum.length() - 1];\n\n    // Check if both digits are odd\n    return (firstDigit == '1' || firstDigit == '3' || firstDigit == '5' || \n            firstDigit == '7' || firstDigit == '9') &&\n           (lastDigit == '1' || lastDigit == '3' || lastDigit == '5' ||\n            lastDigit == '7' || lastDigit == '9');\n}\n\nint specialFilter(vector<int> nums) {\n    int count = 0;\n    for(int num : nums) {\n        if(num > 10 && isFirstAndLastDigitOdd(num)) {\n            ++count;\n        }\n    }\n    return count;\n}\n"}
{"task_id": "CPP/147", "generation": "#include<iostream>\n#include<vector>\n\nusing namespace std;\n\nint get_max_triples(int n) {\n    vector<int> a(n);\n    \n    // Fill the array with values according to the given formula.\n    for (int i = 0; i < n; ++i) {\n        a[i] = (i + 1) * (i + 1) - (i + 1) + 1;\n    }\n    \n    int count = 0;\n\n    // Iterate through all possible triples and check the condition.\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            for (int k = j + 1; k < n; ++k) {\n                if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                    count++;\n                }\n            }\n        }\n    }\n\n    return count;\n}\n\n// Function to test the solution with given data points.\nvoid check_solution() {\n    cout << \"For n = 5, Expected: 1, Got: \" << get_max_triples(5) << endl;\n    // You can add more tests here as needed\n}\n\n"}
{"task_id": "CPP/148", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to find planets between two given planets.\nvector<string> bf(string planet1, string planet2) {\n    // Mapping of each planet name to its position relative to the Sun.\n    vector<pair<string, int>> solarSystem = {\n        {\"Mercury\", 1}, {\"Venus\", 2}, {\"Earth\", 3},\n        {\"Mars\", 4}, {\"Jupiter\", 5}, {\"Saturn\", 6},\n        {\"Uranus\", 7}, {\"Neptune\", 8}\n    };\n\n    // Find the positions of planet1 and planet2.\n    int pos1 = -1, pos2 = -1;\n    for (const auto& planet : solarSystem) {\n        if (planet.first == planet1)\n            pos1 = planet.second;\n        else if (planet.first == planet2)\n            pos2 = planet.second;\n\n        // If both positions are found, break the loop.\n        if (pos1 != -1 && pos2 != -1)\n            break;\n    }\n\n    // Check if either of the planets was not found.\n    if (pos1 == -1 || pos2 == -1) {\n        return {};  // Return an empty vector if any planet is invalid.\n    }\n\n    // Ensure pos1 < pos2 for simplicity in the loop below.\n    if (pos1 > pos2)\n        swap(pos1, pos2);\n\n    // Collect all planets between pos1 and pos2.\n    vector<string> result;\n    for (const auto& planet : solarSystem) {\n        int position = planet.second;\n        if (position > pos1 && position < pos2) {\n            result.push_back(planet.first);\n        }\n    }\n\n    return result;\n}\n\n// Function to test the bf function with examples.\nvoid check() {\n    vector<string> res;\n\n    // Example 1\n    res = bf(\"Jupiter\", \"Neptune\");\n    for (const auto& planet : res)\n        cout << planet << \" \";\n    cout << endl;  // Expected: Saturn Uranus\n\n    // Example 2\n    res = bf(\"Earth\", \"Mercury\");\n    for (const auto& planet : res)\n        cout << planet << \" \";\n    cout << endl;  // Expected: Venus\n\n    // Example 3\n    res = bf(\"Mercury\", \"Uranus\");\n    for (const auto& planet : res)\n        cout << planet << \" \";\n    cout << endl;  // Expected: Venus Earth Mars Jupiter Saturn\n}\n\n"}
{"task_id": "CPP/149", "generation": "#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\n// Function to sort and filter the vector of strings based on given criteria.\nvector<string> sorted_list_sum(vector<string> lst) {\n    // Remove elements with odd lengths\n    auto new_end = remove_if(lst.begin(), lst.end(), [](const string& s) { return s.size() % 2 != 0; });\n    lst.erase(new_end, lst.end());\n\n    // Sort the list by length and then alphabetically if lengths are equal.\n    sort(lst.begin(), lst.end(), [](const string& a, const string& b) {\n        if (a.length() == b.length()) return a < b;\n        else return a.length() < b.length();\n    });\n\n    return lst;\n}\n"}
{"task_id": "CPP/150", "generation": "#include <cmath> // For sqrt function\n#include <iostream>\n\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    for (int i = 2; i <= std::sqrt(num); ++i) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\nint x_or_y(int n, int x, int y) {\n    if (is_prime(n)) {\n        return x;\n    } else {\n        return y;\n    }\n}\n"}
{"task_id": "CPP/151", "generation": "#include <vector>\n#include <cmath> // For std::pow\n\nusing namespace std;\n\nlong long double_the_difference(vector<float> lst) {\n    long long sum = 0;\n    \n    for (float num : lst) {\n        if (num > 0 && floor(num) == num && static_cast<int>(num) % 2 != 0) { // Check if positive, integer and odd\n            int n = static_cast<int>(num);\n            sum += pow(n, 2); // Square the number and add to sum\n        }\n    }\n\n    return sum;\n}\n\n// Test cases\n"}
{"task_id": "CPP/152", "generation": "#include <iostream>\n#include <cmath>\n#include <vector>\nusing namespace std;\n\nvector<int> compare(vector<int> game, vector<int> guess) {\n    vector<int> result;\n    for (size_t i = 0; i < game.size(); ++i) {\n        int diff = abs(game[i] - guess[i]);\n        result.push_back(diff);\n    }\n    return result;\n}\n"}
{"task_id": "CPP/153", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to calculate the strength of an extension.\nint CalculateStrength(const string& extension) {\n    int uppercase = 0;\n    int lowercase = 0;\n    \n    for (char c : extension) {\n        if (isupper(c)) uppercase++;\n        else if (islower(c)) lowercase++;\n    }\n    \n    return uppercase - lowercase;\n}\n\nstring Strongest_Extension(string class_name, vector<string> extensions) {\n    string strongest_extension = \"\";\n    int max_strength = INT_MIN; // Initialize with the smallest possible integer.\n    \n    for (const auto& extension : extensions) {\n        int strength = CalculateStrength(extension);\n        \n        if (strength > max_strength || (strength == max_strength && strongest_extension.empty())) {\n            max_strength = strength;\n            strongest_extension = extension;\n        }\n    }\n    \n    return class_name + \".\" + strongest_extension;\n}\n\n"}
{"task_id": "CPP/154", "generation": "#include <string>\n#include <algorithm>\nusing namespace std;\n\nbool cycpattern_check(string a, string b) {\n    if (b.length() > a.length()) return false;\n\n    // Concatenate string 'a' with itself to handle rotations.\n    string a_doubled = a + a;\n    \n    for (size_t i = 0; i < b.length(); ++i) {\n        string rotated_b = b.substr(i) + b.substr(0, i);\n        if (a_doubled.find(rotated_b) != string::npos) return true;\n    }\n    return false;\n}\n"}
{"task_id": "CPP/155", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<int> even_odd_count(int num){\n    // Convert number to its absolute value to handle negative numbers\n    int absNum = abs(num);\n    \n    // Convert integer to string for easy digit extraction\n    string strNum = to_string(absNum);\n\n    // Initialize counters for even and odd digits\n    int evenCount = 0;\n    int oddCount = 0;\n\n    // Iterate through each character in the string\n    for (char c : strNum) {\n        // Convert char to integer digit\n        int digit = c - '0';\n        \n        // Check if the digit is even or odd and increment respective counter\n        if (digit % 2 == 0) {\n            evenCount++;\n        } else {\n            oddCount++;\n        }\n    }\n\n    // Return a vector containing counts of even and odd digits respectively\n    return {evenCount, oddCount};\n}\n\n// Function to test the solution with given examples\nvoid check() {\n    vector<int> result = even_odd_count(-12);\n    cout << \"even_odd_count(-12) -> {\" << result[0] << \", \" << result[1] << \"}\\n\";\n    \n    result = even_odd_count(123);\n    cout << \"even_odd_count(123) -> {\" << result[0] << \", \" << result[1] << \"}\\n\";\n}\n\n"}
{"task_id": "CPP/156", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring int_to_mini_roman(int number) {\n    // Define the values and corresponding symbols\n    vector<int> values = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    vector<string> symbols = {\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n\n    string roman = \"\";\n    \n    // Iterate over the values and construct the Roman numeral\n    for (int i = 0; number > 0; ++i) {\n        while (number >= values[i]) {\n            roman += symbols[i];\n            number -= values[i];\n        }\n    }\n\n    return roman;\n}\n\n// Example usage:\n"}
{"task_id": "CPP/157", "generation": "#include <iostream>\n#include <cmath>\n\nbool right_angle_triangle(float a, float b, float c){\n    // First, sort the sides so that c is the longest side (hypotenuse)\n    if(a > c) std::swap(a, c);\n    if(b > c) std::swap(b, c);\n\n    // Check the Pythagorean theorem\n    return fabs(a*a + b*b - c*c) < 1e-6; // Using a small threshold to account for floating point precision issues.\n}\n\n"}
{"task_id": "CPP/158", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <set>\nusing namespace std;\n\nstring find_max(vector<string> words) {\n    string result;\n    int max_unique = 0; // To keep track of maximum unique characters\n\n    for (const auto& word : words) {\n        set<char> unique_chars(word.begin(), word.end()); // Use a set to get unique characters\n        int count_unique = unique_chars.size();\n\n        if (count_unique > max_unique || \n            (count_unique == max_unique && word < result)) { // Check lexicographical order as well\n            max_unique = count_unique;\n            result = word;\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/159", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> eat(int number, int need, int remaining) {\n    // Calculate the total number of carrots eaten after trying to eat 'need' more.\n    int totalEaten = number + min(need, remaining);\n    \n    // Calculate how many carrots are left after eating as much as possible.\n    int carrotsLeft = max(0, remaining - need);\n\n    return {totalEaten, carrotsLeft};\n}\n"}
{"task_id": "CPP/160", "generation": "#include <vector>\n#include <string>\n#include <cmath>\nusing namespace std;\n\n// Function to evaluate a single operation between two operands.\nint eval_operation(int op1, int op2, string operator_str) {\n    if (operator_str == \"+\") return op1 + op2;\n    else if (operator_str == \"-\") return op1 - op2;\n    else if (operator_str == \"*\") return op1 * op2;\n    else if (operator_str == \"//\") return op1 / op2; // Floor division\n    else if (operator_str == \"**\") return static_cast<int>(pow(op1, op2));\n    return 0; // Default case to avoid warnings.\n}\n\nint do_algebra(vector<string> operators, vector<int> operands) {\n    int result = operands[0];\n    \n    for(size_t i = 0; i < operators.size(); ++i) {\n        string operator_str = operators[i];\n        int next_operand = operands[i + 1];\n\n        // Evaluate the current operation and update the result.\n        result = eval_operation(result, next_operand, operator_str);\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/161", "generation": "#include <iostream>\n#include <string>\n#include <cctype> // For std::isalpha and std::islower\n\nusing namespace std;\n\nstring solve(string s) {\n    bool hasLetters = false;\n    \n    // Check if the string contains any letters.\n    for (char c : s) {\n        if (std::isalpha(c)) {\n            hasLetters = true;\n            break;\n        }\n    }\n\n    // If no letters are present, reverse the entire string.\n    if (!hasLetters) {\n        std::reverse(s.begin(), s.end());\n        return s;\n    }\n\n    // Otherwise, change the case of each letter and keep other characters as they are.\n    for (char &c : s) {\n        if (std::isalpha(c)) {\n            c = std::islower(c) ? toupper(c) : tolower(c);\n        }\n    }\n\n    return s;\n}\n\n"}
{"task_id": "CPP/162", "generation": "#include <iostream>\n#include <string>\n#include <openssl/md5.h>\n\nusing namespace std;\n\nstring string_to_md5(string text) {\n    if (text.empty()) return \"None\"; // Return \"None\" for empty strings\n\n    unsigned char digest[MD5_DIGEST_LENGTH];\n    MD5((unsigned char*)text.c_str(), text.length(), (unsigned char*)&digest);    \n\n    char mdString[33];\n    for(int i = 0; i < 16; ++i)\n        sprintf(&mdString[i*2], \"%02x\", (unsigned int)digest[i]);\n\n    return string(mdString);\n}\n\n"}
{"task_id": "CPP/163", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // For std::min and std::max\n\nusing namespace std;\n\nvector<int> generate_integers(int a, int b) {\n    vector<int> evenDigits = {2, 4, 6, 8}; // All possible even digits less than 10\n    vector<int> result;\n    \n    // Ensure a is the smaller number and b is the larger one\n    int start = min(a, b);\n    int end = max(a, b);\n\n    for (int digit : evenDigits) {\n        if (digit >= start && digit <= end) {\n            result.push_back(digit);\n        }\n    }\n\n    return result;\n}\n\n// Function to print vector elements\nvoid printVector(const vector<int>& vec) {\n    cout << \"{\";\n    for(size_t i = 0; i < vec.size(); ++i) {\n        if (i != 0) cout << \", \";\n        cout << vec[i];\n    }\n    cout << \"}\" << endl;\n}\n\n"}
{"task_id": "CPP/0", "generation": "#include <algorithm> // For std::sort\n\nbool has_close_elements(std::vector<float> numbers, float threshold) {\n    if (numbers.size() < 2) return false; // If there are less than two elements, we can't have any pairs.\n\n    // Sort the vector to bring closer elements next to each other.\n    std::sort(numbers.begin(), numbers.end());\n\n    for(size_t i = 0; i < numbers.size() - 1; ++i) {\n        if (std::abs(numbers[i] - numbers[i + 1]) < threshold) {\n            return true;\n        }\n    }\n\n    return false;\n}\n"}
{"task_id": "CPP/1", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> separate_paren_groups(string paren_string){\n    vector<string> result;\n    int balance = 0; // Keeps track of open parentheses\n    string current_group = \"\"; // Current group being processed\n\n    for (char c : paren_string) {\n        if (c == '(' || c == ')') { // Ignore spaces and only consider parentheses\n            current_group += c; // Add the character to the current group\n            balance += (c == '(' ? 1 : -1); // Update balance based on the character\n\n            if (balance == 0) { // When balance is zero, a complete group has been found\n                result.push_back(current_group);\n                current_group = \"\"; // Reset for the next group\n            }\n        }\n    }\n\n    return result;\n}\n\n// Function to test the solution with provided data points\nvoid check() {\n    vector<string> expected1 = {\"()\", \"(())\", \"(()())\"};\n    assert(separate_paren_groups(\"( ) (( )) (( )( ))\") == expected1);\n\n    // Additional checks can be added here as needed\n\n    cout << \"All tests passed successfully.\" << endl;\n}\n\n"}
{"task_id": "CPP/2", "generation": "#include<stdio.h>\n#include<math.h>\n\nfloat truncate_number(float number){\n    float integerPart = floor(number);\n    return number - integerPart;\n}\n\n"}
{"task_id": "CPP/3", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nbool below_zero(vector<int> operations) {\n    int balance = 0; // Start with a zero balance\n\n    for (int op : operations) { // Iterate through each operation\n        balance += op; // Update the balance according to the current operation\n        \n        if (balance < 0) { // Check if balance falls below zero\n            return true;\n        }\n    }\n\n    return false; // Return false if no point in time the balance was below zero\n}\n\n"}
{"task_id": "CPP/4", "generation": "#include <iostream>\n#include <vector>\n#include <numeric> // for std::accumulate\n#include <cmath>   // for std::abs\n\nusing namespace std;\n\nfloat mean_absolute_deviation(vector<float> numbers) {\n    if (numbers.empty()) return 0.0f; // Handle empty vector case\n    \n    float sum = accumulate(numbers.begin(), numbers.end(), 0.0f);\n    float mean = sum / numbers.size();\n    \n    float mad_sum = 0.0f;\n    for (float num : numbers) {\n        mad_sum += std::abs(num - mean); // Calculate the absolute difference and add it to the sum\n    }\n    \n    return mad_sum / numbers.size(); // Average of all absolute differences\n}\n\n"}
{"task_id": "CPP/5", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> intersperse(vector<int> numbers, int delimeter) {\n    vector<int> result;\n    \n    // If the input vector is empty, return it as is.\n    if (numbers.empty()) {\n        return result;\n    }\n    \n    // Iterate through each element in the input vector\n    for(size_t i = 0; i < numbers.size(); ++i) {\n        // Add the current number to the result vector\n        result.push_back(numbers[i]);\n        \n        // If it's not the last element, add the delimiter after it.\n        if (i != numbers.size() - 1) {\n            result.push_back(delimeter);\n        }\n    }\n\n    return result;\n}\n\n// Example usage:\n"}
{"task_id": "CPP/6", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<int> parse_nested_parens(string paren_string) {\n    vector<int> max_depths;\n    int current_depth = 0, max_depth = 0;\n    \n    for (char c : paren_string) {\n        if (c == '(') {\n            // Increase depth when encountering an opening parenthesis\n            ++current_depth;\n            // Update the maximum depth found so far in this group\n            if (current_depth > max_depth)\n                max_depth = current_depth;\n        } else if (c == ')') {\n            // Decrease depth when encountering a closing parenthesis\n            --current_depth;\n        } else if (c == ' ') {\n            // When we encounter a space, it means the end of one group.\n            // Add the maximum depth found for this group to our result vector,\n            // and reset max_depth and current_depth for the next group.\n            max_depths.push_back(max_depth);\n            max_depth = 0;\n            current_depth = 0;\n        }\n    }\n\n    // Handle the last group if there is no trailing space\n    if (max_depth > 0) {\n        max_depths.push_back(max_depth);\n    }\n\n    return max_depths;\n}\n\n"}
{"task_id": "CPP/7", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\n// Function to filter strings containing a specific substring.\nvector<string> filter_by_substring(vector<string> strings, string substring) {\n    vector<string> filteredStrings; // Vector to store the result.\n\n    for (const auto& str : strings) { // Iterate through each string in the input vector.\n        if (str.find(substring) != string::npos) { // Check if the current string contains the substring.\n            filteredStrings.push_back(str); // If it does, add it to the result vector.\n        }\n    }\n\n    return filteredStrings; // Return the filtered list of strings.\n}\n\n// Function to test the filter_by_substring function with given data points.\nvoid check() {\n    vector<string> empty;\n    auto res1 = filter_by_substring(empty, \"a\");\n    assert(res1.empty()); // Should be an empty vector.\n\n    vector<string> input2{\"abc\", \"bacd\", \"cde\", \"vector\"};\n    auto res2 = filter_by_substring(input2, \"a\");\n    vector<string> expected2{\"abc\", \"bacd\", \"vector\"};\n    assert(res2 == expected2); // Should match the expected result.\n\n    cout << \"All tests passed successfully.\" << endl;\n}\n\n"}
{"task_id": "CPP/8", "generation": "#include <vector>\n#include <utility>\nusing namespace std;\n\nvector<int> sum_product(vector<int> numbers) {\n    if (numbers.empty()) {\n        return {0, 1};\n    }\n\n    int total_sum = 0;\n    int product = 1;\n\n    for (int num : numbers) {\n        total_sum += num;\n        product *= num;\n    }\n\n    return {total_sum, product};\n}\n"}
{"task_id": "CPP/9", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> rolling_max(vector<int> numbers) {\n    // Check if the input vector is empty to avoid undefined behavior.\n    if (numbers.empty()) return {};\n\n    vector<int> result;\n    int currentMax = numbers[0];  // Initialize with the first element of the sequence.\n\n    for (int num : numbers) {\n        // Update the current maximum value if the current number is greater than it.\n        if (num > currentMax) {\n            currentMax = num;\n        }\n        // Append the current maximum to the result vector.\n        result.push_back(currentMax);\n    }\n\n    return result;\n}\n\n// Example usage\n"}
{"task_id": "CPP/10", "generation": "#include <string>\n#include <algorithm>\nusing namespace std;\n\nbool is_palindrome(string str) {\n    // Test if given string is a palindrome\n    string reversed_str = str;\n    reverse(reversed_str.begin(), reversed_str.end());\n    return str == reversed_str;\n}\n\nstring make_palindrome(string str) {\n    int n = str.length();\n    \n    for (int i = 0; i < n; ++i) {\n        if (is_palindrome(str.substr(i))) {\n            string non_palindromic_part = str.substr(0, i);\n            reverse(non_palindromic_part.begin(), non_palindromic_part.end());\n            return str + non_palindromic_part;\n        }\n    }\n\n    // If no palindromic suffix is found (which means the entire string needs to be reversed and appended)\n    reverse(str.begin(), str.end());\n    return str + str;\n}\n"}
{"task_id": "CPP/11", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring string_xor(string a, string b) {\n    // Ensure both strings are of equal length by padding with zeros if necessary.\n    int len_a = a.length();\n    int len_b = b.length();\n\n    // Pad the shorter string with leading '0's to match lengths\n    while (len_a < len_b) { a = \"0\" + a; ++len_a; }\n    while (len_b < len_a) { b = \"0\" + b; ++len_b; }\n\n    string result;\n    \n    // Perform XOR on each pair of characters and append to the result\n    for(int i = 0; i < len_a; ++i){\n        if(a[i] == b[i]) {\n            result += '0'; // If both are same, XOR is 0\n        } else {\n            result += '1'; // If different, XOR is 1\n        }\n    }\n\n    return result;\n}\n\n// Function to test the string_xor function\nvoid check() {\n    cout << (string_xor(\"010\", \"110\") == \"100\" ? \"Test Passed\\n\" : \"Test Failed\\n\");\n}\n\n"}
{"task_id": "CPP/12", "generation": "#include <vector>\n#include <string>\nusing namespace std;\n\nstring longest(vector<string> strings) {\n    if (strings.empty()) return \"\"; // Return an empty string to represent None\n\n    string maxString = strings[0]; // Assume the first string is the longest initially\n    size_t maxLength = maxString.length();\n\n    for (size_t i = 1; i < strings.size(); ++i) { // Start from the second element\n        if (strings[i].length() > maxLength) {\n            maxString = strings[i];\n            maxLength = strings[i].length();\n        }\n    }\n\n    return maxString;\n}\n"}
{"task_id": "CPP/13", "generation": "#include <iostream>\nusing namespace std;\n\nint greatest_common_divisor(int a, int b) {\n    while (b != 0) {\n        int temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n"}
{"task_id": "CPP/14", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> all_prefixes(string str){\n    vector<string> prefixes;\n    for(size_t i = 0; i < str.length(); ++i) {\n        // Create a substring from the start to the current position (inclusive)\n        string prefix = str.substr(0, i + 1);\n        // Add this prefix to the vector\n        prefixes.push_back(prefix);\n    }\n    return prefixes;\n}\n\n// Example usage:\n"}
{"task_id": "CPP/15", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nstring string_sequence(int n) {\n    string result = \"\";\n    \n    for (int i = 0; i <= n; ++i) {\n        // Convert integer to string and append it to the result string.\n        result += to_string(i);\n        \n        // Add a space after each number except the last one\n        if (i < n) {\n            result += \" \";\n        }\n    }\n\n    return result;\n}\n\n// Function to test the correctness of the solution\nvoid check() {\n    cout << (string_sequence(0) == \"0\" ? \"Test 1 Passed\\n\" : \"Test 1 Failed\\n\");\n    cout << (string_sequence(5) == \"0 1 2 3 4 5\" ? \"Test 2 Passed\\n\" : \"Test 2 Failed\\n\");\n}\n\n"}
{"task_id": "CPP/16", "generation": "#include <iostream>\n#include <set>\n#include <string>\nusing namespace std;\n\nint count_distinct_characters(string str) {\n    // Convert string to lower case for case-insensitive comparison\n    transform(str.begin(), str.end(), str.begin(), ::tolower);\n    \n    // Use a set to store unique characters\n    set<char> distinctChars;\n    \n    // Iterate through each character and add it to the set\n    for (char c : str) {\n        distinctChars.insert(c);\n    }\n    \n    // The size of the set is the number of distinct characters\n    return distinctChars.size();\n}\n\n"}
{"task_id": "CPP/17", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<int> parse_music(string music_string){\n    vector<int> beats;\n    int i = 0;\n    \n    while (i < music_string.length()) {\n        if(music_string[i] == 'o') { // Check for whole note\n            if(i + 1 < music_string.length() && music_string[i+1] == '|') {\n                beats.push_back(2); // Half note\n                i += 2; // Skip the next character as well since it's part of the half note\n            } else {\n                beats.push_back(4); // Whole note\n                i++;\n            }\n        } else if(music_string[i] == '.') { // Check for quarter note\n            if(i + 1 < music_string.length() && music_string[i+1] == '|') {\n                beats.push_back(1); // Quarter note\n                i += 2; // Skip the next character as well since it's part of the quarter note\n            } else {\n                cout << \"Invalid input: Expected '|' after '.'\" << endl;\n                return vector<int>(); // Return an empty vector in case of invalid input\n            }\n        } else if(music_string[i] == ' ') { // Skip spaces\n            i++;\n        } else {\n            cout << \"Invalid character encountered: \" << music_string[i] << endl;\n            return vector<int>(); // Return an empty vector in case of invalid input\n        }\n    }\n\n    return beats;\n}\n\n"}
{"task_id": "CPP/18", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint how_many_times(string str, string substring) {\n    if (substring.empty() || str.empty()) return 0; // If either string is empty, no matches are possible.\n    \n    int count = 0;\n    size_t pos = 0;\n    \n    while ((pos = str.find(substring, pos)) != string::npos) { // Find the substring starting from 'pos'.\n        ++count; // Increment count for each match found.\n        ++pos;   // Move to the next character after the current match to find overlapping occurrences.\n    }\n    \n    return count;\n}\n\n"}
{"task_id": "CPP/19", "generation": "#include <iostream>\n#include <string>\n#include <vector>\n#include <map>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to sort numbers given as words from \"zero\" to \"nine\"\nstring sort_numbers(string numbers) {\n    // Mapping of number words to their numeric values\n    map<string, int> num_map = {\n        {\"zero\", 0}, {\"one\", 1}, {\"two\", 2}, {\"three\", 3},\n        {\"four\", 4}, {\"five\", 5}, {\"six\", 6}, {\"seven\", 7},\n        {\"eight\", 8}, {\"nine\", 9}\n    };\n\n    // Reverse mapping for converting numeric values back to words\n    map<int, string> reverse_map;\n    for (auto &p : num_map) {\n        reverse_map[p.second] = p.first;\n    }\n\n    // Split the input string into individual number words\n    vector<string> num_words;\n    string word;\n    for (char c : numbers) {\n        if (c == ' ') {\n            if (!word.empty()) {\n                num_words.push_back(word);\n                word.clear();\n            }\n        } else {\n            word += c;\n        }\n    }\n    if (!word.empty()) {\n        num_words.push_back(word);\n    }\n\n    // Sort the number words based on their numeric values\n    sort(num_words.begin(), num_words.end(),\n         [&num_map](const string &a, const string &b) { return num_map[a] < num_map[b]; });\n\n    // Convert back to a space-delimited string of sorted number words\n    string result;\n    for (size_t i = 0; i < num_words.size(); ++i) {\n        if (i > 0) result += \" \";\n        result += reverse_map[num_map[num_words[i]]];\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/20", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <limits>\n\nusing namespace std;\n\nvector<float> find_closest_elements(vector<float> numbers) {\n    // Sort the vector in ascending order.\n    sort(numbers.begin(), numbers.end());\n\n    float min_diff = numeric_limits<float>::max();\n    pair<float, float> closest_pair;\n\n    for (size_t i = 0; i < numbers.size() - 1; ++i) {\n        float diff = numbers[i + 1] - numbers[i];\n        if (diff < min_diff) {\n            min_diff = diff;\n            closest_pair = {numbers[i], numbers[i + 1]};\n        }\n    }\n\n    // Convert the pair to a vector for returning.\n    return {closest_pair.first, closest_pair.second};\n}\n\n"}
{"task_id": "CPP/21", "generation": "#include <vector>\n#include <algorithm> // for std::min_element and std::max_element\n\nusing namespace std;\n\nvector<float> rescale_to_unit(vector<float> numbers){\n    float min_val = *std::min_element(numbers.begin(), numbers.end());\n    float max_val = *std::max_element(numbers.begin(), numbers.end());\n\n    vector<float> scaled_numbers;\n    for (float num : numbers) {\n        // Apply the linear transformation\n        float scaled_num = (num - min_val) / (max_val - min_val);\n        scaled_numbers.push_back(scaled_num);\n    }\n\n    return scaled_numbers;\n}\n\n// Example usage:\n"}
{"task_id": "CPP/22", "generation": "#include <iostream>\n#include <vector>\n#include <list>\n#include <boost/any.hpp>\n\ntypedef std::list<boost::any> list_any;\n\nstd::vector<int> filter_integers(list_any values) {\n    std::vector<int> integers;\n    \n    for (auto it = values.begin(); it != values.end(); ++it) {\n        if (it->type() == typeid(int)) { // Check if the type is int\n            integers.push_back(boost::any_cast<int>(*it)); // Cast and add to vector\n        }\n    }\n\n    return integers;\n}\n\n"}
{"task_id": "CPP/23", "generation": "#include <iostream>\n#include <string>\n\nint stringLength(const std::string& str) {\n    return str.length();\n}\n\n"}
{"task_id": "CPP/24", "generation": "#include<stdio.h>\n\nint largest_divisor(int n) {\n    // Start from half of n because no number greater than n/2 can be a divisor of n (except n itself)\n    for (int i = n / 2; i >= 1; --i) {\n        if (n % i == 0) {\n            return i;\n        }\n    }\n    // If no divisor is found, which theoretically shouldn't happen unless n <= 1\n    return -1;\n}\n\n"}
{"task_id": "CPP/25", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvector<int> factorize(int n) {\n    vector<int> factors;\n    \n    // Divide by 2 until odd\n    while (n % 2 == 0) {\n        factors.push_back(2);\n        n /= 2;\n    }\n    \n    // Check for odd factors from 3 onwards\n    for (int i = 3; i * i <= n; i += 2) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n    \n    // If n is a prime number greater than 2\n    if (n > 2) {\n        factors.push_back(n);\n    }\n\n    return factors;\n}\n\n"}
{"task_id": "CPP/26", "generation": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nvector<int> remove_duplicates(vector<int> numbers) {\n    unordered_map<int, int> occurrences;\n    \n    // Count the occurrences of each number.\n    for (int num : numbers) {\n        occurrences[num]++;\n    }\n    \n    vector<int> result;\n    \n    // Add to result only those elements that occur once.\n    for (int num : numbers) {\n        if (occurrences[num] == 1) {\n            result.push_back(num);\n        }\n    }\n    \n    return result;\n}\n\n// Function to print the vector\nvoid print_vector(const vector<int>& v) {\n    cout << \"{\";\n    for(size_t i = 0; i < v.size(); ++i) {\n        cout << v[i];\n        if (i != v.size() - 1) cout << \", \";\n    }\n    cout << \"}\" << endl;\n}\n\n"}
{"task_id": "CPP/27", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring flip_case(string str) {\n    for (size_t i = 0; i < str.length(); ++i) {\n        if (isupper(str[i])) {\n            // Convert uppercase to lowercase\n            str[i] = tolower(str[i]);\n        } else if (islower(str[i])) {\n            // Convert lowercase to uppercase\n            str[i] = toupper(str[i]);\n        }\n    }\n    return str;\n}\n\n"}
{"task_id": "CPP/28", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring concatenate(vector<string> strings) {\n    // Initialize an empty string for storing the concatenated result.\n    string result = \"\";\n    \n    // Iterate through each element in the vector and append it to the result.\n    for (const auto& str : strings) {\n        result += str;\n    }\n    \n    return result;\n}\n\n// Function to test the concatenate function with some test cases\nvoid test_concatenate() {\n    cout << \"Test Case 1: Empty Vector -> Expected: \\\"\\\", Actual: \\\"\" << concatenate({}) << \"\\\"\" << endl;\n    cout << \"Test Case 2: {\\\"a\\\", \\\"b\\\", \\\"c\\\"} -> Expected: \\\"abc\\\", Actual: \\\"\" << concatenate({\"a\", \"b\", \"c\"}) << \"\\\"\" << endl;\n}\n\n"}
{"task_id": "CPP/29", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> filter_by_prefix(vector<string> strings, string prefix) {\n    vector<string> filteredStrings; // This will store the results\n\n    for (const auto& str : strings) { // Iterate through each string in the input\n        if (!str.empty() && str.substr(0, prefix.size()) == prefix) {\n            // Check if the current string starts with the given prefix\n            filteredStrings.push_back(str); // Add to result vector if condition is met\n        }\n    }\n\n    return filteredStrings; // Return the filtered list of strings\n}\n\n// Function to test the filter_by_prefix function\nvoid check() {\n    auto result1 = filter_by_prefix({}, \"a\");\n    cout << \"Test 1: \";\n    for (const auto& str : result1) {\n        cout << str << \" \";\n    }\n    cout << endl;\n\n    auto result2 = filter_by_prefix({\"abc\", \"bcd\", \"cde\", \"vector\"}, \"a\");\n    cout << \"Test 2: \";\n    for (const auto& str : result2) {\n        cout << str << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/30", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // For std::copy_if\n\nusing namespace std;\n\nvector<float> get_positive(vector<float> l) {\n    vector<float> result;  // This will store the positive numbers.\n    \n    // Use copy_if to filter only positive numbers into 'result'.\n    copy_if(l.begin(), l.end(), back_inserter(result), [](float x){ return x > 0; });\n    \n    return result;\n}\n\n// Function to print a vector\nvoid print_vector(const vector<float>& v) {\n    for (auto num : v) {\n        cout << num << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/31", "generation": "#include <iostream>\nusing namespace std;\n\nbool is_prime(long long n) {\n    // Handle edge cases for 0, 1 and negative numbers.\n    if (n <= 1) return false;\n    \n    // Check divisibility from 2 up to the square root of n.\n    for (long long i = 2; i * i <= n; ++i) {\n        if (n % i == 0)\n            return false;\n    }\n    return true;\n}\n\n"}
{"task_id": "CPP/32", "generation": "#include <vector>\n#include <cmath>\n#include <stdexcept>\n\ndouble poly(const std::vector<double>& xs, double x) {\n    /*\n    Evaluates polynomial with coefficients xs at point x.\n    return xs[0] + xs[1] * x + xs[2] * x^2 + .... + xs[n] * x^n\n    */\n    double sum = 0;\n    for (size_t i = 0; i < xs.size(); ++i) {\n        sum += xs[i] * std::pow(x, i);\n    }\n    return sum;\n}\n\ndouble find_zero(const std::vector<double>& xs) {\n    /*\n    xs are coefficients of a polynomial. find_zero finds x such that poly(x) = 0.\n    find_zero returns only one zero point, even if there are many.\n    Moreover, find_zero only takes list xs having an even number of coefficients and the largest non-zero coefficient,\n    as it guarantees at least one real root exists.\n\n    >>> round(find_zero({1, 2}), 2) // f(x) = 1 + 2x\n    -0.5 \n    >>> round(find_zero({-6, 11, -6, 1}), 2) // (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n    1.0\n    */\n    \n    if (xs.size() % 2 != 0 || xs.back() == 0) {\n        throw std::invalid_argument(\"The list of coefficients must have an even number of elements and the largest coefficient must be non-zero.\");\n    }\n\n    double low = -1000.0;\n    double high = 1000.0;\n\n    while (high - low > 1e-6) {\n        double mid = (low + high) / 2.0;\n        if (poly(xs, low) * poly(xs, mid) < 0) {\n            high = mid;\n        } else {\n            low = mid;\n        }\n    }\n\n    return (low + high) / 2.0;\n}\n"}
{"task_id": "CPP/33", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // for std::sort\n\nusing namespace std;\n\nvector<int> sort_third(vector<int> l) {\n    vector<int> to_sort;\n    \n    // Extract values from indices divisible by 3 (0-based indexing)\n    for(size_t i = 0; i < l.size(); i += 3) {\n        to_sort.push_back(l[i]);\n    }\n    \n    // Sort the extracted values\n    sort(to_sort.begin(), to_sort.end());\n    \n    // Replace original elements with sorted ones\n    for(size_t i = 0, j = 0; i < l.size() && j < to_sort.size(); i += 3, ++j) {\n        l[i] = to_sort[j];\n    }\n    \n    return l;\n}\n\n// Function to test the correctness of sort_third function\nvoid check_function() {\n    vector<int> test1 = {1, 2, 3};\n    vector<int> expected1 = {1, 2, 3};\n    assert(sort_third(test1) == expected1);\n\n    vector<int> test2 = {5, 6, 3, 4, 8, 9, 2};\n    vector<int> expected2 = {2, 6, 3, 4, 8, 9, 5};\n    assert(sort_third(test2) == expected2);\n\n    cout << \"All tests passed successfully.\" << endl;\n}\n\n"}
{"task_id": "CPP/34", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // for std::sort and std::unique\n\nusing namespace std;\n\nvector<int> unique(vector<int> l) {\n    // First, sort the vector so that duplicate elements are adjacent.\n    sort(l.begin(), l.end());\n    \n    // Use std::unique to remove consecutive duplicates. It returns a past-the-end iterator for the new range of unique elements.\n    auto last = unique(l.begin(), l.end());\n    \n    // Erase the non-unique part of the vector\n    l.erase(last, l.end());\n    \n    return l;\n}\n\n// Function to print the contents of a vector\nvoid printVector(const vector<int>& v) {\n    for (int i : v) {\n        cout << i << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/35", "generation": "#include <vector>\n#include <algorithm> // For std::numeric_limits\n\nusing namespace std;\n\nfloat max_element(vector<float> l) {\n    if (l.empty()) {  // Check if the vector is empty to avoid undefined behavior.\n        return numeric_limits<float>::lowest(); // Return the lowest possible float value if the vector is empty\n    }\n\n    float max_val = l[0];  // Initialize max_val with the first element of the vector\n\n    for (size_t i = 1; i < l.size(); ++i) {  // Start from the second element and iterate through the rest\n        if (l[i] > max_val) {\n            max_val = l[i];  // Update max_val if a larger value is found\n        }\n    }\n\n    return max_val;\n}\n"}
{"task_id": "CPP/36", "generation": "#include <iostream>\nusing namespace std;\n\nint fizz_buzz(int n) {\n    int count = 0;\n    \n    for (int i = 1; i < n; ++i) {\n        if ((i % 11 == 0 || i % 13 == 0)) { // Check divisibility by 11 or 13\n            int temp = i;\n            while (temp > 0) {\n                if (temp % 10 == 7) count++; // Count digit '7'\n                temp /= 10; // Move to the next digit\n            }\n        }\n    }\n    \n    return count;\n}\n\n"}
{"task_id": "CPP/37", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // for std::sort\n\nusing namespace std;\n\nvector<float> sort_even(vector<float> l) {\n    vector<float> even_elements;\n    \n    // Extract elements at even indices and store them in a separate vector.\n    for (size_t i = 0; i < l.size(); i += 2) {\n        even_elements.push_back(l[i]);\n    }\n    \n    // Sort the extracted even-indexed elements.\n    sort(even_elements.begin(), even_elements.end());\n    \n    // Place sorted elements back into their original positions in vector `l`.\n    for (size_t i = 0, j = 0; i < l.size(); i += 2) {\n        l[i] = even_elements[j++];\n    }\n    \n    return l;\n}\n\n// Function to test the sort_even function with provided data points.\nvoid check() {\n    vector<float> result;\n\n    // Test case 1\n    result = sort_even({1, 2, 3});\n    for (float num : result) cout << num << \" \";\n    cout << endl; // Expected: 1 2 3\n\n    // Test case 2\n    result = sort_even({5, 6, 3, 4});\n    for (float num : result) cout << num << \" \";\n    cout << endl; // Expected: 3 6 5 4\n}\n\n"}
{"task_id": "CPP/38", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\n// Function to encode a string by cycling groups of three characters.\nstring encode_cyclic(string s) { \n    int l = s.length();\n    string output;\n    for (int i = 0; i * 3 < l; i++) {\n        string x = s.substr(i * 3, 3);\n        if (x.length() == 3) x = x.substr(1) + x[0];\n        output += x;\n    }\n    return output;\n}\n\n// Function to decode a string that was encoded with encode_cyclic.\nstring decode_cyclic(string s) { \n    int l = s.length();\n    string output;\n    for (int i = 0; i * 3 < l; i++) {\n        string x = s.substr(i * 3, 3);\n        if (x.length() == 3) x = x[2] + x.substr(0, 2); // Rotate right\n        output += x;\n    }\n    return output;\n}\n\n"}
{"task_id": "CPP/39", "generation": "#include <stdio.h>\n#include <math.h>\n\n// Function to check if a number is prime\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    if (num == 2 || num == 3) return true;\n    if (num % 2 == 0 || num % 3 == 0) return false;\n\n    for (int i = 5; i * i <= num; i += 6) {\n        if (num % i == 0 || num % (i + 2) == 0)\n            return false;\n    }\n    return true;\n}\n\n// Function to find the n-th Fibonacci number that is also prime\nint prime_fib(int n) {\n    int fib1 = 0, fib2 = 1; // First two Fibonacci numbers\n    int count = 0;\n\n    while (true) {\n        int nextFib = fib1 + fib2;\n        if (is_prime(nextFib)) {\n            count++;\n            if (count == n)\n                return nextFib;\n        }\n        fib1 = fib2;\n        fib2 = nextFib;\n    }\n\n    // This line should never be reached\n    return -1;\n}\n\n"}
{"task_id": "CPP/40", "generation": "#include <vector>\n#include <algorithm> // For std::sort\n\nusing namespace std;\n\nbool triples_sum_to_zero(vector<int> l) {\n    int n = l.size();\n    \n    if (n < 3) return false; // Early exit for vectors with less than 3 elements\n    \n    sort(l.begin(), l.end()); // Sort the vector to use two-pointer technique\n    \n    for(int i = 0; i < n-2; ++i) {\n        int left = i + 1, right = n - 1;\n        \n        while(left < right) {\n            int sum = l[i] + l[left] + l[right];\n            \n            if(sum == 0) return true; // Found three numbers that sum to zero\n            else if(sum < 0) ++left; // Need a larger number, move left pointer to the right\n            else --right; // Need a smaller number, move right pointer to the left\n        }\n    }\n    \n    return false; // No triplet found that sums up to zero\n}\n\n// Example usage:\n"}
{"task_id": "CPP/41", "generation": "#include <iostream>\nusing namespace std;\n\nint car_race_collision(int n) {\n    // Since all cars are moving at the same speed and will eventually collide with a car from the opposite direction,\n    // each of the n left-to-right cars will collide with one of the n right-to-left cars.\n    return n;\n}\n"}
{"task_id": "CPP/42", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> incr_list(vector<int> l) {\n    // Iterate over all elements of the vector.\n    for (size_t i = 0; i < l.size(); ++i) {\n        // Increment each element by 1.\n        l[i] += 1;\n    }\n    return l;\n}\n\n// Function to test the correctness of incr_list function\nvoid check() {\n    vector<int> test1 = {1, 2, 3};\n    vector<int> expected1 = {2, 3, 4};\n    assert(incr_list(test1) == expected1);\n\n    vector<int> test2 = {5, 3, 5, 2, 3, 3, 9, 0, 123};\n    vector<int> expected2 = {6, 4, 6, 3, 4, 4, 10, 1, 124};\n    assert(incr_list(test2) == expected2);\n\n    cout << \"All tests passed successfully.\" << endl;\n}\n\n"}
{"task_id": "CPP/43", "generation": "#include <iostream>\n#include <vector>\n#include <unordered_set> // Use unordered_set for efficient lookup\n\nusing namespace std;\n\nbool pairs_sum_to_zero(vector<int> l) {\n    unordered_set<int> seenNumbers; // Set to keep track of numbers we've seen\n    \n    for (int num : l) { // Iterate through each number in the vector\n        if (seenNumbers.find(-num) != seenNumbers.end()) { // Check if -num is already in the set\n            return true; // Found two numbers that sum to zero\n        }\n        seenNumbers.insert(num); // Add current number to the set\n    }\n    \n    return false; // No pair found that sums to zero\n}\n\n// Function to test the pairs_sum_to_zero function with given data points\nvoid check() {\n    cout << boolalpha; // Print true/false instead of 1/0 for boolean values\n    cout << \"Test Case 1: \" << pairs_sum_to_zero({1, 3, 5, 0}) << endl;\n    cout << \"Test Case 2: \" << pairs_sum_to_zero({1, 3, -2, 1}) << endl;\n    cout << \"Test Case 3: \" << pairs_sum_to_zero({1, 2, 3, 7}) << endl;\n    cout << \"Test Case 4: \" << pairs_sum_to_zero({2, 4, -5, 3, 5, 7}) << endl;\n    cout << \"Test Case 5: \" << pairs_sum_to_zero({1}) << endl;\n}\n\n"}
{"task_id": "CPP/44", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring change_base(int x, int base) {\n    if (base <= 1 || base >= 10) return \"Invalid base\"; // Ensure base is valid\n\n    string result = \"\";\n    while (x > 0) {\n        int remainder = x % base;\n        result = to_string(remainder) + result; // Prepend the remainder\n        x /= base;\n    }\n\n    if(result == \"\") result = \"0\"; // Handle case where x was 0 initially\n\n    return result;\n}\n\n"}
{"task_id": "CPP/45", "generation": "#include<stdio.h>\n\nfloat triangle_area(float a, float h) {\n    // Area of a triangle is 0.5 * base * height\n    return 0.5 * a * h;\n}\n\n"}
{"task_id": "CPP/46", "generation": "#include <iostream>\n#include <vector>\n\nint fib4(int n) {\n    // Base cases for the first four elements of the sequence.\n    if (n == 0 || n == 1)\n        return 0;\n    else if (n == 2)\n        return 2;\n    else if (n == 3)\n        return 0;\n\n    // Initialize an array to store the computed values up to n\n    std::vector<int> fib4_values(n + 1);\n    \n    // Set the base cases.\n    fib4_values[0] = 0;\n    fib4_values[1] = 0;\n    fib4_values[2] = 2;\n    fib4_values[3] = 0;\n\n    // Compute each value from 4 to n using the formula\n    for (int i = 4; i <= n; ++i) {\n        fib4_values[i] = fib4_values[i - 1] + fib4_values[i - 2] + fib4_values[i - 3] + fib4_values[i - 4];\n    }\n\n    // Return the nth value\n    return fib4_values[n];\n}\n\n"}
{"task_id": "CPP/47", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // for std::sort\n\nusing namespace std;\n\nfloat median(vector<float> l){\n    size_t n = l.size();\n    \n    if (n == 0) {\n        throw invalid_argument(\"Vector is empty\");\n    }\n    \n    sort(l.begin(), l.end()); // Sort the vector\n    \n    if (n % 2 != 0) { // If odd number of elements\n        return l[n / 2];\n    } else { // If even number of elements\n        return (l[(n - 1) / 2] + l[n / 2]) / 2.0;\n    }\n}\n\n"}
{"task_id": "CPP/48", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_palindrome(string text) {\n    int left = 0;\n    int right = text.length() - 1;\n\n    while (left < right) {\n        if (text[left] != text[right]) {\n            return false; // Characters do not match\n        }\n        left++;\n        right--;\n    }\n\n    return true; // All characters matched, it's a palindrome\n}\n\n"}
{"task_id": "CPP/49", "generation": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\n// Function to calculate (base^exponent) % mod using iterative method to avoid overflow.\nint modpow(int base, int exponent, int mod) {\n    long long result = 1;\n    long long b = base % mod; // Ensure the base is within modulo range\n    while (exponent > 0) {\n        if (exponent & 1) { // If exponent is odd, multiply base with result\n            result = (result * b) % mod;\n        }\n        exponent >>= 1; // Divide exponent by 2\n        b = (b * b) % mod; // Square the base and take modulo\n    }\n    return static_cast<int>(result);\n}\n\nint modp(int n, int p) {\n    return modpow(2, n, p);\n}\n"}
{"task_id": "CPP/50", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nstring encode_shift(string s) {\n    // returns encoded string by shifting every character by 5 in the alphabet.\n    string out;\n    int i;\n    for (i = 0; i < s.length(); i++) {\n        int w = ((int)s[i] + 5 - (int)'a') % 26 + (int)'a';\n        out += (char)w;\n    }\n    return out;\n}\n\nstring decode_shift(string s) {\n    // takes as input string encoded with encode_shift function. Returns decoded string.\n    string out;\n    int i;\n    for (i = 0; i < s.length(); i++) {\n        int w = ((int)s[i] - 5 - (int)'a' + 26) % 26 + (int)'a'; // Adding 26 to ensure positive result\n        out += (char)w;\n    }\n    return out;\n}\n\n// Example usage:\n"}
{"task_id": "CPP/51", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool isVowel(char c) {\n    // Convert character to lowercase for simplicity and check if it's a vowel.\n    char lower_c = tolower(c);\n    return (lower_c == 'a' || lower_c == 'e' || lower_c == 'i' || lower_c == 'o' || lower_c == 'u');\n}\n\nstring remove_vowels(string text) {\n    string result;\n    for(char c : text) {\n        if(!isVowel(c)) { // If the character is not a vowel, add it to the result.\n            result += c;\n        }\n    }\n    return result;\n}\n\n"}
{"task_id": "CPP/52", "generation": "#include <vector>\nusing namespace std;\n\nbool below_threshold(vector<int> l, int t) {\n    // Iterate through each element in the vector\n    for (int num : l) {\n        // If any number is greater than or equal to the threshold, return false\n        if (num >= t) {\n            return false;\n        }\n    }\n    // If all numbers are below the threshold, return true\n    return true;\n}\n\n// Example usage:\n/*\nbool result1 = below_threshold({1, 2, 4, 10}, 100); // Should be true\nbool result2 = below_threshold({1, 20, 4, 10}, 5);   // Should be false\n*/\n"}
{"task_id": "CPP/53", "generation": "#include<iostream>\nusing namespace std;\n\nint add(int x, int y) {\n    return x + y;\n}\n\n// Example usage\n"}
{"task_id": "CPP/54", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nbool same_chars(string s0, string s1) {\n    // Sort both strings to bring identical characters together.\n    sort(s0.begin(), s0.end());\n    sort(s1.begin(), s1.end());\n\n    // Remove duplicate characters from each sorted string.\n    auto last_unique_s0 = unique(s0.begin(), s0.end());\n    auto last_unique_s1 = unique(s1.begin(), s1.end());\n\n    // Erase the duplicates in place to get only unique characters.\n    s0.erase(last_unique_s0, s0.end());\n    s1.erase(last_unique_s1, s1.end());\n\n    // Compare the two strings for equality after processing.\n    return s0 == s1;\n}\n\n"}
{"task_id": "CPP/55", "generation": "#include<stdio.h>\n\nint fib(int n) {\n    if (n <= 1)\n        return n;\n    else\n        return fib(n-1) + fib(n-2);\n}\n\n"}
{"task_id": "CPP/56", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    int balance = 0;\n    \n    for (char c : brackets) {\n        if (c == '<') {\n            ++balance; // Increment for an opening bracket\n        } else if (c == '>') {\n            --balance; // Decrement for a closing bracket\n            \n            // If balance goes below zero, there's an unmatched closing bracket\n            if (balance < 0) return false;\n        }\n    }\n    \n    // Return true only if the balance is back to zero at the end\n    return balance == 0;\n}\n\n"}
{"task_id": "CPP/57", "generation": "#include <vector>\nusing namespace std;\n\nbool monotonic(vector<float> l) {\n    bool increasing = true;\n    bool decreasing = true;\n\n    for (size_t i = 1; i < l.size(); ++i) {\n        if (l[i] > l[i - 1]) {\n            decreasing = false;\n        } else if (l[i] < l[i - 1]) {\n            increasing = false;\n        }\n    }\n\n    return increasing || decreasing;\n}\n"}
{"task_id": "CPP/58", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // For sort function\n#include <set>       // To store unique elements\n\nusing namespace std;\n\nvector<int> common(vector<int> l1, vector<int> l2) {\n    // Sort both vectors to make it easier to find common elements.\n    sort(l1.begin(), l1.end());\n    sort(l2.begin(), l2.end());\n\n    set<int> result;  // Use a set to store unique and sorted results\n    auto it1 = l1.begin();\n    auto it2 = l2.begin();\n\n    // Traverse both vectors to find common elements\n    while (it1 != l1.end() && it2 != l2.end()) {\n        if (*it1 == *it2) {\n            result.insert(*it1);\n            ++it1;\n            ++it2;\n        } else if (*it1 < *it2) {\n            ++it1;\n        } else {\n            ++it2;\n        }\n    }\n\n    // Convert set to vector\n    return vector<int>(result.begin(), result.end());\n}\n\n// Function to print the elements of a vector\nvoid printVector(const vector<int>& vec) {\n    for (int num : vec) {\n        cout << num << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/59", "generation": "#include <stdio.h>\n#include <stdbool.h>\n\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    for (int i = 2; i * i <= num; ++i) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\nint largest_prime_factor(int n){\n    int largestFactor = -1;\n\n    // Divide n by 2 to remove all even factors\n    while (n % 2 == 0) {\n        largestFactor = 2;\n        n /= 2;\n    }\n\n    // Now we only have odd factors left, start from 3 and check each odd number.\n    for (int i = 3; i * i <= n; i += 2) {\n        while (n % i == 0) {\n            largestFactor = i;\n            n /= i;\n        }\n    }\n\n    // If n is a prime number greater than 2\n    if (n > 2)\n        largestFactor = n;\n\n    return largestFactor;\n}\n\n"}
{"task_id": "CPP/60", "generation": "#include<iostream>\nusing namespace std;\n\nint sum_to_n(int n){\n    int sum = 0;\n    for (int i = 1; i <= n; ++i) {\n        sum += i;\n    }\n    return sum;\n}\n\n// Function to test the correctness of sum_to_n\nvoid check_function() {\n    cout << \"sum_to_n(30): \" << sum_to_n(30) << endl; // Expected output: 465\n    cout << \"sum_to_n(100): \" << sum_to_n(100) << endl; // Expected output: 5050\n    cout << \"sum_to_n(5): \" << sum_to_n(5) << endl; // Expected output: 15\n    cout << \"sum_to_n(10): \" << sum_to_n(10) << endl; // Expected output: 55\n    cout << \"sum_to_n(1): \" << sum_to_n(1) << endl; // Expected output: 1\n}\n\n"}
{"task_id": "CPP/61", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    int balance = 0; // Initialize balance counter\n\n    for (char c : brackets) { // Iterate through each character in the string\n        if (c == '(') {\n            ++balance; // Increment balance for an opening bracket\n        } else if (c == ')') {\n            --balance; // Decrement balance for a closing bracket\n            if (balance < 0) return false; // If balance is negative, there's a closing bracket without a matching opening one\n        }\n    }\n\n    return balance == 0; // True if all brackets are correctly matched and balanced\n}\n\n"}
{"task_id": "CPP/62", "generation": "#include <iostream>\n#include <vector>\n\nstd::vector<float> derivative(const std::vector<float>& xs) {\n    // Create an empty vector to store the coefficients of the derivative polynomial\n    std::vector<float> result;\n\n    // Iterate through each coefficient starting from the first non-constant term (index 1)\n    for(size_t i = 1; i < xs.size(); ++i) {\n        // Multiply the current coefficient by its index and add it to the result vector\n        result.push_back(xs[i] * static_cast<float>(i));\n    }\n\n    return result;\n}\n\n// Function to test the derivative function with given examples\nvoid check_derivative() {\n    std::vector<float> example1 = {3, 1, 2, 4, 5};\n    std::vector<float> expected1 = {1, 4, 12, 20};\n    \n    std::vector<float> result1 = derivative(example1);\n    assert(result1 == expected1);\n\n    std::vector<float> example2 = {1, 2, 3};\n    std::vector<float> expected2 = {2, 6};\n\n    std::vector<float> result2 = derivative(example2);\n    assert(result2 == expected2);\n\n    std::cout << \"All tests passed successfully.\" << std::endl;\n}\n\n"}
{"task_id": "CPP/63", "generation": "#include <iostream>\n#include <vector>\n\nint fibfib(int n) {\n    // Base cases\n    if (n == 0 || n == 1)\n        return 0;\n    else if (n == 2)\n        return 1;\n\n    // Initialize a vector to store the computed values of fibfib sequence.\n    std::vector<int> dp(n + 1);\n    dp[0] = 0;   // fibfib(0) is 0\n    dp[1] = 0;   // fibfib(1) is 0\n    dp[2] = 1;   // fibfib(2) is 1\n\n    // Compute the values from 3 to n using the recurrence relation.\n    for (int i = 3; i <= n; ++i)\n        dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3];\n\n    return dp[n];\n}\n\n// Function to test the fibfib function with given data points\nvoid check() {\n    std::cout << \"fibfib(1) should be 0: \" << (fibfib(1) == 0 ? \"Passed\" : \"Failed\") << std::endl;\n    std::cout << \"fibfib(5) should be 4: \" << (fibfib(5) == 4 ? \"Passed\" : \"Failed\") << std::endl;\n    std::cout << \"fibfib(8) should be 24: \" << (fibfib(8) == 24 ? \"Passed\" : \"Failed\") << std::endl;\n}\n\n"}
{"task_id": "CPP/64", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint vowels_count(string s) {\n    int count = 0;\n    // Convert string to lowercase for simplicity\n    transform(s.begin(), s.end(), s.begin(), ::tolower);\n\n    // Check each character in the string\n    for (size_t i = 0; i < s.length(); ++i) {\n        char c = s[i];\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n            count++;\n        }\n        // Check for 'y' at the end of the string\n        else if (c == 'y' && i == s.length() - 1) {\n            count++;\n        }\n    }\n\n    return count;\n}\n\n"}
{"task_id": "CPP/65", "generation": "#include <iostream>\n#include <string>\n#include <algorithm> // for std::reverse\nusing namespace std;\n\nstring circular_shift(int x, int shift) {\n    string digits = to_string(x);\n    int num_digits = digits.size();\n    \n    if (shift >= num_digits) {\n        reverse(digits.begin(), digits.end());\n        return digits;\n    }\n    \n    int actual_shift = shift % num_digits; // handle shifts larger than the number of digits\n    rotate(digits.rbegin(), digits.rbegin() + actual_shift, digits.rend()); // right circular rotation\n    \n    return digits;\n}\n"}
{"task_id": "CPP/66", "generation": "#include <iostream>\n#include <string>\n#include <cctype> // For isupper() function\n\nusing namespace std;\n\nint digitSum(string s) {\n    int sum = 0;\n    for (char c : s) { // Iterate through each character in the string\n        if (isupper(c)) { // Check if the character is an uppercase letter\n            sum += static_cast<int>(c); // Add its ASCII value to sum\n        }\n    }\n    return sum; // Return the total sum of ASCII values of uppercase letters\n}\n\n"}
{"task_id": "CPP/67", "generation": "#include <iostream>\n#include <string>\n#include <vector>\n#include <sstream>\n#include <regex>\n\nusing namespace std;\n\nint fruit_distribution(string s, int n) {\n    // Extracting numbers from the string using regex\n    regex number_pattern(\"\\\\d+\");\n    auto words_begin = sregex_iterator(s.begin(), s.end(), number_pattern);\n    auto words_end = sregex_iterator();\n\n    vector<int> numbers;\n    for (sregex_iterator i = words_begin; i != words_end; ++i) {\n        smatch match = *i;\n        string match_str = match.str();\n        numbers.push_back(stoi(match_str));\n    }\n\n    // Calculating mangoes by subtracting apples and oranges from total fruits\n    int mango_count = n - accumulate(numbers.begin(), numbers.end(), 0);\n\n    return mango_count;\n}\n"}
{"task_id": "CPP/68", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> pluck(vector<int> arr) {\n    int minValue = INT_MAX; // Initialize to a very large number.\n    int minIndex = -1;      // No valid index found initially.\n\n    for (int i = 0; i < arr.size(); ++i) {\n        if (arr[i] % 2 == 0 && arr[i] <= minValue) { // Check if the value is even and smaller or equal to current min.\n            if (arr[i] < minValue || (arr[i] == minValue && i < minIndex)) {\n                minValue = arr[i];\n                minIndex = i;\n            }\n        }\n    }\n\n    if (minIndex != -1) { // If a valid index was found, return the value and its index.\n        return {minValue, minIndex};\n    } else { // No even number found or vector is empty.\n        return {};\n    }\n}\n"}
{"task_id": "CPP/69", "generation": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint search(vector<int> lst) {\n    unordered_map<int, int> freqMap;\n    \n    // Count frequencies of each element in the list\n    for (int num : lst) {\n        freqMap[num]++;\n    }\n    \n    int result = -1;  // Initialize result as -1\n    \n    // Check each frequency against its value\n    for (auto &entry : freqMap) {\n        if (entry.first <= entry.second && entry.first > result) {\n            result = entry.first;\n        }\n    }\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/70", "generation": "#include <vector>\n#include <algorithm>\n\nstd::vector<int> strange_sort_list(std::vector<int> lst) {\n    // Sort the vector initially.\n    std::sort(lst.begin(), lst.end());\n    \n    std::vector<int> result;\n    int left = 0; // Start index for minimum value\n    int right = lst.size() - 1; // End index for maximum value\n    \n    while (left <= right) {\n        if (left == right) {\n            // If there's only one element left, add it to the result.\n            result.push_back(lst[left]);\n            break;\n        }\n        \n        // Add the minimum value\n        result.push_back(lst[left++]);\n        // Add the maximum value\n        result.push_back(lst[right--]);\n    }\n\n    return result;\n}\n\n// Example usage:\n"}
{"task_id": "CPP/71", "generation": "#include<stdio.h>\n#include<math.h>\n\nfloat triangle_area(float a, float b, float c){\n    // Check if sides form a valid triangle\n    if (a + b <= c || a + c <= b || b + c <= a) {\n        return -1;\n    }\n\n    // Calculate the semi-perimeter\n    float s = (a + b + c) / 2;\n\n    // Use Heron's formula to calculate area\n    float area = sqrt(s * (s - a) * (s - b) * (s - c));\n\n    // Round the result to two decimal points and return\n    return round(area * 100) / 100;\n}\n\n"}
{"task_id": "CPP/72", "generation": "#include <vector>\nusing namespace std;\n\nbool will_it_fly(vector<int> q, int w) {\n    // Check if the vector is balanced (palindromic)\n    for(int i = 0; i < q.size() / 2; ++i) {\n        if(q[i] != q[q.size() - 1 - i]) return false;\n    }\n\n    // Calculate the sum of elements in the vector\n    int sum = 0;\n    for(int num : q) {\n        sum += num;\n    }\n\n    // Check if the sum is less than or equal to the maximum possible weight w\n    return sum <= w;\n}\n"}
{"task_id": "CPP/73", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint smallest_change(vector<int> arr) {\n    int changes = 0;\n    int left = 0;\n    int right = arr.size() - 1;\n\n    while (left < right) {\n        if (arr[left] != arr[right]) {\n            ++changes; // Increment the change count when elements don't match\n        }\n        ++left;\n        --right;\n    }\n\n    return changes;\n}\n\n"}
{"task_id": "CPP/74", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to calculate the total number of characters in a vector of strings.\nint countChars(const vector<string>& lst) {\n    int count = 0;\n    for (const string& str : lst) {\n        count += str.length();\n    }\n    return count;\n}\n\nvector<string> total_match(vector<string> lst1, vector<string> lst2) {\n    // Calculate the number of characters in each list\n    int charsInLst1 = countChars(lst1);\n    int charsInLst2 = countChars(lst2);\n\n    // Compare and return the appropriate list\n    if (charsInLst1 <= charsInLst2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n\n// Function to test the solution with given examples.\nvoid check() {\n    vector<string> empty = {};\n    vector<string> result;\n\n    // Example 1\n    result = total_match(empty, empty);\n    cout << \"Example 1: \";\n    for (const string& str : result) cout << str << \" \";\n    cout << endl;\n\n    // Example 2\n    result = total_match({\"hi\", \"admin\"}, {\"hI\", \"Hi\"});\n    cout << \"Example 2: \";\n    for (const string& str : result) cout << str << \" \";\n    cout << endl;\n\n    // Example 3\n    result = total_match({\"hi\", \"admin\"}, {\"hi\", \"hi\", \"admin\", \"project\"});\n    cout << \"Example 3: \";\n    for (const string& str : result) cout << str << \" \";\n    cout << endl;\n\n    // Example 4\n    result = total_match({\"hi\", \"admin\"}, {\"hI\", \"hi\", \"hi\"});\n    cout << \"Example 4: \";\n    for (const string& str : result) cout << str << \" \";\n    cout << endl;\n\n    // Example 5\n    result = total_match({\"4\"}, {\"1\", \"2\", \"3\", \"4\", \"5\"});\n    cout << \"Example 5: \";\n    for (const string& str : result) cout << str << \" \";\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/75", "generation": "#include <iostream>\nusing namespace std;\n\n// Function to check if a number is prime.\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0)\n            return false;\n    }\n    return true;\n}\n\n// Function to check if a number can be expressed as the product of exactly three prime numbers.\nbool is_multiply_prime(int a) {\n    // Iterate through all possible combinations of primes less than 100\n    for (int i = 2; i < 100 && i * i * i <= a; ++i) {\n        if (!is_prime(i)) continue;\n        \n        for (int j = i; j < 100 && i * j * j <= a; ++j) {\n            if (!is_prime(j)) continue;\n\n            for (int k = j; k < 100; ++k) {\n                if (!is_prime(k)) continue;\n                \n                // Check if the product of these three primes equals 'a'\n                if (i * j * k == a)\n                    return true;\n            }\n        }\n    }\n\n    return false;\n}\n\n"}
{"task_id": "CPP/76", "generation": "#include <cmath> // For log and pow functions\n\nbool is_simple_power(int x, int n) {\n    if (n == 1) return x == 1; // Special case: only 1^k = 1 for any k.\n    \n    double log_result = std::log(x) / std::log(n); // Calculate the logarithm of x with base n\n    \n    // Check if the result is an integer by comparing it to its rounded value\n    return std::abs(log_result - std::round(log_result)) < 1e-9; \n}\n\n"}
{"task_id": "CPP/77", "generation": "#include <cmath> // For std::cbrt and std::round\n\nbool iscube(int a) {\n    double cubeRoot = std::cbrt(a); // Calculate the cube root of 'a'\n    int nearestInt = std::round(cubeRoot); // Round to the nearest integer\n    \n    // Check if the cube of the rounded value equals 'a'\n    return (nearestInt * nearestInt * nearestInt == a);\n}\n\n"}
{"task_id": "CPP/78", "generation": "#include <iostream>\n#include <string>\n#include <set>\n\nusing namespace std;\n\nint hex_key(string num) {\n    // Set of prime hexadecimal digits\n    set<char> primes = {'2', '3', '5', '7', 'B', 'D'};\n    \n    int count = 0;\n    for (char c : num) {\n        if (primes.find(c) != primes.end()) {\n            ++count;\n        }\n    }\n    \n    return count;\n}\n\n"}
{"task_id": "CPP/79", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring decimal_to_binary(int decimal) {\n    // Convert the number to binary using bit manipulation.\n    string binary = \"\";\n    \n    if (decimal == 0) {\n        return \"db0db\"; // Special case for zero\n    }\n    \n    while (decimal > 0) {\n        int remainder = decimal % 2;\n        binary = char('0' + remainder) + binary; // Convert the remainder to a character and prepend it.\n        decimal /= 2;\n    }\n\n    return \"db\" + binary + \"db\"; // Add 'db' at both ends\n}\n\n"}
{"task_id": "CPP/80", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_happy(string s) {\n    // Check if the length of the string is less than 3, return false immediately.\n    if (s.length() < 3) {\n        return false;\n    }\n\n    // Iterate through the string to check every set of three consecutive characters\n    for (int i = 0; i <= s.length() - 3; ++i) {\n        // Check if any two out of three consecutive characters are the same.\n        if (s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]) {\n            return false;\n        }\n    }\n\n    // If all checks pass, the string is happy\n    return true;\n}\n\n"}
{"task_id": "CPP/81", "generation": "#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<string> numerical_letter_grade(vector<float> gpas) {\n    vector<string> letter_grades;\n    \n    for (float gpa : gpas) {\n        if (gpa == 4.0f) {\n            letter_grades.push_back(\"A+\");\n        } else if (gpa > 3.7f) {\n            letter_grades.push_back(\"A\");\n        } else if (gpa > 3.3f) {\n            letter_grades.push_back(\"A-\");\n        } else if (gpa > 3.0f) {\n            letter_grades.push_back(\"B+\");\n        } else if (gpa > 2.7f) {\n            letter_grades.push_back(\"B\");\n        } else if (gpa > 2.3f) {\n            letter_grades.push_back(\"B-\");\n        } else if (gpa > 2.0f) {\n            letter_grades.push_back(\"C+\");\n        } else if (gpa > 1.7f) {\n            letter_grades.push_back(\"C\");\n        } else if (gpa > 1.3f) {\n            letter_grades.push_back(\"C-\");\n        } else if (gpa > 1.0f) {\n            letter_grades.push_back(\"D+\");\n        } else if (gpa > 0.7f) {\n            letter_grades.push_back(\"D\");\n        } else if (gpa > 0.0f) {\n            letter_grades.push_back(\"D-\");\n        } else {\n            letter_grades.push_back(\"E\");\n        }\n    }\n\n    return letter_grades;\n}\n"}
{"task_id": "CPP/82", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\n// Helper function to check if a number is prime.\nbool is_prime(int n) {\n    if (n <= 1) return false; // 0 and 1 are not primes\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\n// Main function to check if the length of a string is prime.\nbool prime_length(string str){\n    int len = str.length();\n    return is_prime(len);\n}\n\n"}
{"task_id": "CPP/83", "generation": "#include <cmath>\n#include <iostream>\n\nint starts_one_ends(int n) {\n    if (n == 1) {\n        return 1;\n    }\n    // Calculate the count of numbers that start or end with '1'\n    int count = 2 * static_cast<int>(std::pow(9, n - 1)) - static_cast<int>(std::pow(9, n - 2));\n    return count;\n}\n"}
{"task_id": "CPP/84", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\n// Function to calculate the sum of digits of N\nint sumOfDigits(int N) {\n    int sum = 0;\n    while (N > 0) {\n        sum += N % 10; // Add the last digit to sum\n        N /= 10;       // Remove the last digit from N\n    }\n    return sum;\n}\n\n// Function to convert an integer to its binary string representation\nstring intToBinary(int num) {\n    if (num == 0) return \"0\"; // Special case for zero\n\n    string binary = \"\";\n    while (num > 0) {\n        binary = to_string(num % 2) + binary; // Prepend the remainder of division by 2\n        num /= 2;\n    }\n    return binary;\n}\n\nstring solve(int N){\n    int sumDigits = sumOfDigits(N); // Calculate the sum of digits\n    string resultBinary = intToBinary(sumDigits); // Convert the sum to binary string\n    return resultBinary; // Return the binary representation as a string\n}\n\n// Example usage:\n"}
{"task_id": "CPP/85", "generation": "#include <vector>\nusing namespace std;\n\nint add(vector<int> lst) {\n    int sum = 0;\n    \n    // Iterate through the list with an index starting from 1 (the first odd index)\n    for(int i = 1; i < lst.size(); i += 2) { // Increment by 2 to stay at odd indices\n        if(lst[i] % 2 == 0) { // Check if the element is even\n            sum += lst[i]; // Add it to the sum\n        }\n    }\n\n    return sum;\n}\n"}
{"task_id": "CPP/86", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nstring anti_shuffle(string s) {\n    // Temporary variables to hold the current word and its sorted version.\n    string tempWord = \"\";\n    string result = \"\";\n\n    for (char c : s) {\n        if (c == ' ') {  // If we encounter a space, process the collected word\n            sort(tempWord.begin(), tempWord.end());  // Sort characters in ascending order based on ASCII value\n            result += tempWord + \" \";  // Append sorted word and space to the result\n            tempWord = \"\";  // Reset for next word\n        } else {\n            tempWord += c;  // Collect characters of current word\n        }\n    }\n\n    if (!tempWord.empty()) {  // Process any remaining word after last space or at end of string\n        sort(tempWord.begin(), tempWord.end());\n        result += tempWord;\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/87", "generation": "#include <vector>\n#include <algorithm> // for std::sort\n\nusing namespace std;\n\nbool compare(const vector<int>& a, const vector<int>& b) {\n    if (a[0] != b[0]) return a[0] < b[0]; // sort by row in ascending order\n    else return a[1] > b[1];              // then by column in descending order within the same row\n}\n\nvector<vector<int>> get_row(vector<vector<int>> lst, int x) {\n    vector<vector<int>> coordinates;\n    \n    for (int i = 0; i < lst.size(); ++i) { // iterate through each row\n        for (int j = 0; j < lst[i].size(); ++j) { // iterate through each element in the current row\n            if (lst[i][j] == x) {\n                coordinates.push_back({i, j}); // store the coordinate of found integer\n            }\n        }\n    }\n\n    sort(coordinates.begin(), coordinates.end(), compare); // sort according to specified rules\n\n    return coordinates;\n}\n\n// Example usage:\n"}
{"task_id": "CPP/88", "generation": "#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> sort_array(vector<int> array) {\n    // Check if the vector is empty or contains only one element\n    if (array.size() <= 1) return array;\n    \n    // Calculate the sum of the first and last elements\n    int sum = array.front() + array.back();\n    \n    // Create a copy to avoid modifying the original vector\n    vector<int> sortedArray(array);\n    \n    // Sort based on whether the sum is odd or even\n    if (sum % 2 == 0) {\n        sort(sortedArray.begin(), sortedArray.end(), greater<int>());\n    } else {\n        sort(sortedArray.begin(), sortedArray.end());\n    }\n    \n    return sortedArray;\n}\n\n// Example usage:\n"}
{"task_id": "CPP/89", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring encrypt(string s){\n    for (int i = 0; i < s.length(); ++i) {\n        char c = s[i];\n        \n        // Check if the character is a lowercase letter.\n        if ('a' <= c && c <= 'z') {\n            // Shift by 4 positions and wrap around using modulo operation\n            s[i] = ((c - 'a' + 4) % 26) + 'a';\n        }\n        \n        // Check if the character is an uppercase letter.\n        else if ('A' <= c && c <= 'Z') {\n            // Shift by 4 positions and wrap around using modulo operation\n            s[i] = ((c - 'A' + 4) % 26) + 'A';\n        }\n    }\n    \n    return s;\n}\n\n"}
{"task_id": "CPP/90", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint next_smallest(vector<int> lst) {\n    if (lst.size() < 2) { // If the list has less than two elements, return -1.\n        return -1;\n    }\n\n    sort(lst.begin(), lst.end()); // Sort the vector to find the smallest and second smallest elements easily.\n\n    int first = lst[0]; // The smallest element is now at index 0 after sorting.\n    \n    for (int i = 1; i < lst.size(); ++i) {\n        if (lst[i] != first) { // Find the next unique element which will be the second smallest.\n            return lst[i];\n        }\n    }\n\n    // If all elements are the same, there is no second smallest element.\n    return -1;\n}\n\n"}
{"task_id": "CPP/91", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nint is_bored(string S) {\n    int boredom_count = 0;\n    \n    // Use a stringstream to split the string into sentences.\n    stringstream ss(S);\n    string sentence;\n    char delimiters[] = {'.', '?', '!'};\n\n    while (getline(ss, sentence)) {\n        bool found_delimiter = false;\n\n        for(char delimiter : delimiters) {\n            size_t pos = 0;\n            while ((pos = sentence.find(delimiter, pos)) != string::npos) {\n                // Extract the substring up to the current delimiter.\n                string sub_sentence = sentence.substr(0, pos);\n                \n                // Trim leading spaces from the extracted substring.\n                sub_sentence.erase(0, sub_sentence.find_first_not_of(\" \"));\n                \n                if (!sub_sentence.empty() && sub_sentence[0] == 'I' && (sub_sentence.size() > 1 ? isspace(sub_sentence[1]) : true)) {\n                    boredom_count++;\n                }\n                \n                // Move past the delimiter for next iteration.\n                pos += 1;\n            }\n\n            found_delimiter = true;\n        }\n\n        if (!found_delimiter) {\n            sentence.erase(0, sentence.find_first_not_of(\" \"));\n            \n            if (!sentence.empty() && sentence[0] == 'I' && (sentence.size() > 1 ? isspace(sentence[1]) : true)) {\n                boredom_count++;\n            }\n        }\n    }\n\n    return boredom_count;\n}\n\n"}
{"task_id": "CPP/92", "generation": "#include <iostream>\n#include <cmath>\n\nbool any_int(float a, float b, float c) {\n    // Check if all numbers are integers by comparing them with their floor values.\n    bool is_a_integer = (a == std::floor(a));\n    bool is_b_integer = (b == std::floor(b));\n    bool is_c_integer = (c == std::floor(c));\n\n    // If any of the numbers are not integers, return false\n    if (!is_a_integer || !is_b_integer || !is_c_integer) {\n        return false;\n    }\n\n    // Check if one number equals the sum of the other two.\n    if ((a + b == c) || (b + c == a) || (c + a == b)) {\n        return true;\n    } else {\n        return false;\n    }\n}\n\n"}
{"task_id": "CPP/93", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\n// Function to encode a message according to the given rules.\nstring encode(string message) {\n    // Iterate through each character of the string.\n    for (char &c : message) {\n        // Swap case: if lowercase, convert to uppercase and vice versa.\n        if (islower(c)) c = toupper(c);\n        else if (isupper(c)) c = tolower(c);\n\n        // Replace vowels with the letter that appears 2 places ahead in the alphabet.\n        switch (tolower(c)) {\n            case 'a': c = islower(c) ? 'c' : 'C'; break;\n            case 'e': c = islower(c) ? 'g' : 'G'; break;\n            case 'i': c = islower(c) ? 'k' : 'K'; break;\n            case 'o': c = islower(c) ? 'q' : 'Q'; break;\n            case 'u': c = islower(c) ? 'w' : 'W'; break;\n        }\n    }\n\n    return message;\n}\n\n"}
{"task_id": "CPP/94", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to check if a number is prime\nbool isPrime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\n// Function to calculate the sum of digits of a number\nint sumOfDigits(int num) {\n    int sum = 0;\n    while (num > 0) {\n        sum += num % 10;\n        num /= 10;\n    }\n    return sum;\n}\n\n// Main function to find the largest prime and sum its digits\nint skjkasdkd(vector<int> lst){\n    int maxPrime = -1; // Initialize with a non-prime value\n    \n    // Iterate through the list to find the largest prime number\n    for (int num : lst) {\n        if (isPrime(num)) {\n            maxPrime = max(maxPrime, num);\n        }\n    }\n\n    // If no prime was found, return 0 or handle as needed\n    if (maxPrime == -1) return 0;\n\n    // Calculate and return the sum of digits of the largest prime number\n    return sumOfDigits(maxPrime);\n}\n\n// Function to test the solution with given examples\nvoid check() {\n    cout << skjkasdkd({0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3}) << endl; // 10\n    cout << skjkasdkd({1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1}) << endl; // 25\n    cout << skjkasdkd({1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3}) << endl; // 13\n    cout << skjkasdkd({0,724,32,71,99,32,6,0,5,91,83,0,5,6}) << endl; // 11\n    cout << skjkasdkd({0,81,12,3,1,21}) << endl; // 3\n    cout << skjkasdkd({0,8,1,2,1,7}) << endl; // 7\n}\n\n"}
{"task_id": "CPP/95", "generation": "#include <iostream>\n#include <string>\n#include <map>\n#include <cctype>\nusing namespace std;\n\nbool is_lowercase(const string& str) {\n    for (char c : str) {\n        if (!islower(c)) return false;\n    }\n    return true;\n}\n\nbool is_uppercase(const string& str) {\n    for (char c : str) {\n        if (!isupper(c)) return false;\n    }\n    return true;\n}\n\nbool check_dict_case(map<string, string> dict) {\n    if (dict.empty()) return false;\n\n    bool all_lower = true;\n    bool all_upper = true;\n\n    for (const auto& kv : dict) {\n        const string& key = kv.first;\n        if (!is_lowercase(key)) all_lower = false;\n        if (!is_uppercase(key)) all_upper = false;\n    }\n\n    return all_lower || all_upper;\n}\n"}
{"task_id": "CPP/96", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// Helper function to check if a number is prime\nbool is_prime(int num) {\n    if (num <= 1) return false; // 0 and 1 are not primes\n    for (int i = 2; i * i <= num; ++i) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\nvector<int> count_up_to(int n){\n    vector<int> primes;\n    \n    // Iterate through all numbers from 2 up to but not including n\n    for (int i = 2; i < n; ++i) {\n        if (is_prime(i)) {\n            primes.push_back(i);\n        }\n    }\n\n    return primes;\n}\n\n// Function to test the implementation with given examples\nvoid check() {\n    vector<int> result;\n\n    result = count_up_to(5); // Expected: {2, 3}\n    for(int num : result) cout << num << \" \";\n    cout << endl;\n\n    result = count_up_to(11); // Expected: {2, 3, 5, 7}\n    for(int num : result) cout << num << \" \";\n    cout << endl;\n\n    result = count_up_to(0); // Expected: {}\n    if(result.empty()) cout << \"{}\" << endl;\n    \n    result = count_up_to(20); // Expected: {2, 3, 5, 7, 11, 13, 17, 19}\n    for(int num : result) cout << num << \" \";\n    cout << endl;\n\n    result = count_up_to(1); // Expected: {}\n    if(result.empty()) cout << \"{}\" << endl;\n    \n    result = count_up_to(18); // Expected: {2, 3, 5, 7, 11, 13, 17}\n    for(int num : result) cout << num << \" \";\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/97", "generation": "#include<stdio.h>\n\nint multiply(int a, int b) {\n    // Extracting the unit digits\n    int unitDigitA = abs(a) % 10;\n    int unitDigitB = abs(b) % 10;\n\n    // Calculating and returning the product of the unit digits\n    return unitDigitA * unitDigitB;\n}\n\n"}
{"task_id": "CPP/98", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint count_upper(string s) {\n    int count = 0;\n    \n    // Iterate through the string with even indices only.\n    for (size_t i = 0; i < s.length(); i += 2) { // Start from index 0 and increment by 2\n        char c = s[i];\n        \n        // Check if it's an uppercase vowel\n        if (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n            count++;\n        }\n    }\n\n    return count;\n}\n\n"}
{"task_id": "CPP/99", "generation": "#include <iostream>\n#include <cmath>\n#include <string>\n\nusing namespace std;\n\nint closest_integer(string value) {\n    // Convert string to double for precision handling\n    double num = stod(value);\n    \n    // Check if the number is positive or negative\n    bool isPositive = num > 0;\n    \n    // Calculate the floor and ceil values of the number\n    int floorValue = static_cast<int>(floor(num));\n    int ceilValue = static_cast<int>(ceil(num));\n    \n    // Determine which integer to round towards based on the distance from the decimal part\n    double fractionalPart = num - floorValue;\n    \n    if (fractionalPart == 0.5) {\n        // If equidistant, round away from zero\n        return isPositive ? ceilValue : floorValue;\n    } else {\n        // Otherwise, use standard rounding rules\n        return static_cast<int>(round(num));\n    }\n}\n\n// Function to test the closest_integer function with given examples\nvoid check() {\n    cout << \"Testing '10': Expected 10, Got: \" << closest_integer(\"10\") << endl;\n    cout << \"Testing '15.3': Expected 15, Got: \" << closest_integer(\"15.3\") << endl;\n    cout << \"Testing '14.5': Expected 15, Got: \" << closest_integer(\"14.5\") << endl;\n    cout << \"Testing '-14.5': Expected -15, Got: \" << closest_integer(\"-14.5\") << endl;\n}\n\n"}
{"task_id": "CPP/100", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> make_a_pile(int n) {\n    vector<int> pile;\n    \n    // Start with the first level having 'n' stones.\n    int current_stones = n;\n    \n    for (int i = 0; i < n; ++i) {\n        pile.push_back(current_stones);\n        \n        // Determine the next number of stones based on whether current is odd or even\n        if (current_stones % 2 == 0) { // If current_stones is even, add 2 to get the next even number.\n            current_stones += 2;\n        } else { // If current_stones is odd, add 2 to get the next odd number.\n            current_stones += 2;\n        }\n    }\n\n    return pile;\n}\n\n// Example usage\n"}
{"task_id": "CPP/101", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> words_string(string s) {\n    vector<string> result;\n    string word = \"\";\n    \n    for (char c : s) {\n        if (c == ' ' || c == ',') {  // Check if the character is a space or comma\n            if (!word.empty()) {      // If there's a word, add it to the result vector\n                result.push_back(word);\n                word = \"\";            // Reset the word for the next iteration\n            }\n        } else {\n            word += c;  // Append the current character to the word\n        }\n    }\n\n    if (!word.empty()) {  // Add any remaining word after the loop ends\n        result.push_back(word);\n    }\n\n    return result;\n}\n\n// Function to test the implementation with example inputs\nvoid check() {\n    vector<string> res1 = words_string(\"Hi, my name is John\");\n    for (string s : res1) cout << s << \" \";\n    cout << endl;\n\n    vector<string> res2 = words_string(\"One, two, three, four, five, six\");\n    for (string s : res2) cout << s << \" \";\n}\n\n"}
{"task_id": "CPP/102", "generation": "#include<iostream>\nusing namespace std;\n\nint choose_num(int x, int y) {\n    // Check if the range is valid.\n    if (y < x)\n        return -1;\n    \n    // If 'y' itself is even and within the range, return it.\n    if (y % 2 == 0 && y >= x)\n        return y;\n\n    // Otherwise, check for the next lower number that could be even.\n    int candidate = y - 1;\n    while(candidate >= x) {\n        if (candidate % 2 == 0)\n            return candidate;\n        --candidate; // Move to the next lower number\n    }\n\n    // If no even number is found in the range, return -1.\n    return -1;\n}\n\n"}
{"task_id": "CPP/103", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\n// Function to convert an integer to a binary string\nstring int_to_binary(int num) {\n    if (num == 0) return \"0\";\n    string binary = \"\";\n    while (num > 0) {\n        binary = (num % 2 == 0 ? \"0\" : \"1\") + binary;\n        num /= 2;\n    }\n    return binary;\n}\n\nstring rounded_avg(int n, int m) {\n    if (n > m) return \"-1\";\n    \n    // Calculate the sum of integers from n to m\n    long long sum = ((long long)m * (m + 1) - (n * (n - 1))) / 2;\n    int count = m - n + 1; // Number of terms\n    \n    // Compute average and round down\n    int avg = sum / count;\n    \n    // Convert to binary string\n    return int_to_binary(avg);\n}\n\n"}
{"task_id": "CPP/104", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to check if a number contains only odd digits.\nbool hasOnlyOddDigits(int num) {\n    while (num > 0) {\n        int digit = num % 10;\n        if (digit % 2 == 0) return false; // If any digit is even, return false\n        num /= 10;\n    }\n    return true;\n}\n\nvector<int> unique_digits(vector<int> x) {\n    vector<int> result;\n\n    // Filter numbers that have only odd digits.\n    for (int num : x) {\n        if (hasOnlyOddDigits(num)) {\n            result.push_back(num);\n        }\n    }\n\n    // Sort the filtered numbers in increasing order\n    sort(result.begin(), result.end());\n\n    return result;\n}\n\n// Function to test the solution with given examples\nvoid check() {\n    vector<int> test1 = {15, 33, 1422, 1};\n    vector<int> expected1 = {1, 15, 33};\n    assert(unique_digits(test1) == expected1);\n\n    vector<int> test2 = {152, 323, 1422, 10};\n    vector<int> expected2 = {};\n    assert(unique_digits(test2) == expected2);\n    \n    cout << \"All tests passed successfully.\" << endl;\n}\n\n"}
{"task_id": "CPP/105", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\n\nusing namespace std;\n\nvector<string> by_length(vector<int> arr) {\n    // Map to store the digit-to-name mapping.\n    map<int, string> numberNames = {\n        {1, \"One\"}, {2, \"Two\"}, {3, \"Three\"},\n        {4, \"Four\"}, {5, \"Five\"}, {6, \"Six\"},\n        {7, \"Seven\"}, {8, \"Eight\"}, {9, \"Nine\"}\n    };\n\n    // Filter out numbers not between 1 and 9.\n    vector<int> filteredArr;\n    for (int num : arr) {\n        if (num >= 1 && num <= 9) {\n            filteredArr.push_back(num);\n        }\n    }\n\n    // Sort the filtered array.\n    sort(filteredArr.begin(), filteredArr.end());\n\n    // Reverse the sorted array.\n    reverse(filteredArr.begin(), filteredArr.end());\n\n    // Replace each digit with its corresponding name.\n    vector<string> result;\n    for (int num : filteredArr) {\n        result.push_back(numberNames[num]);\n    }\n\n    return result;\n}\n\n// Function to test the solution\nvoid check() {\n    vector<int> arr1 = {2, 1, 1, 4, 5, 8, 2, 3};\n    vector<string> expected1 = {\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"};\n    assert(by_length(arr1) == expected1);\n\n    vector<int> arr2 = {};\n    vector<string> expected2 = {};\n    assert(by_length(arr2) == expected2);\n\n    vector<int> arr3 = {1, -1, 55};\n    vector<string> expected3 = {\"One\"};\n    assert(by_length(arr3) == expected3);\n\n    cout << \"All tests passed successfully.\" << endl;\n}\n\n"}
{"task_id": "CPP/106", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// Function to calculate factorial\nint factorial(int num) {\n    int result = 1;\n    for (int i = 2; i <= num; ++i) {\n        result *= i;\n    }\n    return result;\n}\n\n// Function to calculate the sum of numbers from 1 to num\nint sumToN(int num) {\n    return (num * (num + 1)) / 2;\n}\n\nvector<int> f(int n) {\n    vector<int> result(n);\n    \n    for (int i = 0; i < n; ++i) {\n        if ((i + 1) % 2 == 0) { // Check if the index+1 is even\n            result[i] = factorial(i + 1); // Calculate factorial\n        } else {\n            result[i] = sumToN(i + 1); // Calculate sum from 1 to i+1\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/107", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\n// Function to check if a number is a palindrome\nbool isPalindrome(int num) {\n    string str = to_string(num);\n    int len = str.length();\n    for (int i = 0; i < len / 2; ++i) {\n        if (str[i] != str[len - i - 1]) return false;\n    }\n    return true;\n}\n\nvector<int> even_odd_palindrome(int n){\n    vector<int> result(2, 0); // Initialize a vector with two elements set to zero\n    for (int i = 1; i <= n; ++i) {\n        if (isPalindrome(i)) { // Check if the number is a palindrome\n            if (i % 2 == 0) {\n                result[0]++; // Increment even count\n            } else {\n                result[1]++; // Increment odd count\n            }\n        }\n    }\n    return result;\n}\n\n"}
{"task_id": "CPP/108", "generation": "#include <vector>\n#include <cmath>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to calculate sum of digits considering sign for negative numbers.\nint sum_of_digits(int num) {\n    int sum = 0;\n    bool is_negative = num < 0;\n    while (num != 0) {\n        int digit = num % 10;\n        if (is_negative && sum == 0) { // Only apply the sign to the first digit.\n            digit *= -1;\n            is_negative = false; // Ensure only the first digit is negative.\n        }\n        sum += digit;\n        num /= 10;\n    }\n    return sum;\n}\n\nint count_nums(vector<int> n) {\n    int count = 0;\n    for (auto num : n) {\n        if (sum_of_digits(num) > 0) {\n            ++count;\n        }\n    }\n    return count;\n}\n"}
{"task_id": "CPP/109", "generation": "#include <vector>\nusing namespace std;\n\nbool move_one_ball(vector<int> arr) {\n    if (arr.empty()) return true;\n    \n    int n = arr.size();\n    int disorder_count = 0;\n    \n    // Check for disorder points\n    for (int i = 1; i < n; ++i) {\n        if (arr[i] < arr[i - 1]) {\n            disorder_count++;\n        }\n    }\n\n    // Special case: check the wrap-around condition between last and first element\n    if (disorder_count == 0 || (disorder_count == 1 && arr[n-1] <= arr[0])) {\n        return true;\n    } else {\n        return false;\n    }\n}\n"}
{"task_id": "CPP/110", "generation": "#include <vector>\n#include <string>\nusing namespace std;\n\nstring exchange(vector<int> lst1, vector<int> lst2) {\n    // Count odd numbers in lst1 and even numbers in lst2.\n    int oddCountInLst1 = 0;\n    for (int num : lst1) {\n        if (num % 2 != 0) {\n            ++oddCountInLst1;\n        }\n    }\n\n    int evenCountInLst2 = 0;\n    for (int num : lst2) {\n        if (num % 2 == 0) {\n            ++evenCountInLst2;\n        }\n    }\n\n    // If there are enough even numbers in lst2 to replace all odd numbers in lst1, return \"YES\".\n    if (oddCountInLst1 <= evenCountInLst2) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n"}
{"task_id": "CPP/111", "generation": "#include <iostream>\n#include <string>\n#include <map>\n#include <sstream> // For std::istringstream\n\nusing namespace std;\n\nmap<char, int> histogram(string test) {\n    map<char, int> charCount;\n    map<char, int> result;\n    \n    if (test.empty()) return result; // Return empty map for empty input\n    \n    istringstream iss(test);\n    string word;\n    \n    // Count occurrences of each character\n    while (iss >> word && !word.empty()) {\n        ++charCount[word[0]];\n    }\n    \n    int maxCount = 0;\n    \n    // Find the maximum count\n    for (const auto& pair : charCount) {\n        if (pair.second > maxCount) {\n            maxCount = pair.second;\n        }\n    }\n    \n    // Collect characters with the maximum count into result map\n    for (const auto& pair : charCount) {\n        if (pair.second == maxCount) {\n            result.insert(pair);\n        }\n    }\n    \n    return result;\n}\n\n// Function to print the map for testing purposes\nvoid printMap(const map<char, int>& m) {\n    for (const auto& pair : m) {\n        cout << \"{\" << pair.first << \", \" << pair.second << \"} \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/112", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nbool is_palindrome(const string& str) {\n    int left = 0, right = str.size() - 1;\n    while (left < right) {\n        if (str[left] != str[right]) return false;\n        ++left; --right;\n    }\n    return true;\n}\n\nvector<string> reverse_delete(string s, string c) {\n    string result_string;\n    \n    // Remove characters from s that are present in c\n    for (char ch : s) {\n        if (c.find(ch) == string::npos) {\n            result_string += ch;\n        }\n    }\n\n    // Check if the resulting string is a palindrome\n    bool is_palindrome_result = is_palindrome(result_string);\n\n    vector<string> output(2);\n    output[0] = result_string;\n    output[1] = (is_palindrome_result ? \"True\" : \"False\");\n\n    return output;\n}\n"}
{"task_id": "CPP/113", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nstd::vector<std::string> odd_count(std::vector<std::string> lst) {\n    std::vector<std::string> result;\n    for (const auto& s : lst) {\n        int num_odds = 0;\n        for (char c : s) {\n            if (isdigit(c) && ((c - '0') % 2 != 0)) {\n                ++num_odds;\n            }\n        }\n        std::string output_str = \"the number of odd elements \";\n        output_str += std::to_string(num_odds);\n        output_str += \"n the str\";\n        output_str += std::to_string(num_odds);\n        output_str += \"ng \";\n        output_str += std::to_string(num_odds);\n        output_str += \" of the \";\n        output_str += std::to_string(num_odds);\n        output_str += \"nput.\";\n        result.push_back(output_str);\n    }\n    return result;\n}\n"}
{"task_id": "CPP/114", "generation": "#include <iostream>\n#include <vector>\n#include <climits> // For INT_MAX\n\nusing namespace std;\n\nlong long minSubArraySum(vector<long long> nums) {\n    if (nums.empty()) return 0; // Handle empty vector case\n    \n    long long currentSum = 0;\n    long long minSum = LLONG_MAX; // Initialize to the largest possible value\n    \n    for (auto num : nums) {\n        currentSum += num;\n        \n        // Update minSum if currentSum is smaller\n        if (currentSum < minSum)\n            minSum = currentSum;\n            \n        // Reset currentSum to 0 if it becomes non-negative\n        if (currentSum >= 0)\n            currentSum = 0;\n    }\n    \n    return minSum;\n}\n\n"}
{"task_id": "CPP/115", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint max_fill(vector<vector<int>> grid, int capacity) {\n    int total_drops = 0;\n    \n    // Iterate over each well (row)\n    for (auto& row : grid) {\n        int water_units = 0;\n        \n        // Count the number of units of water in this well\n        for (int unit : row) {\n            if (unit == 1) {\n                ++water_units;\n            }\n        }\n        \n        // Calculate how many times we need to lower the bucket for this well\n        int drops_for_well = (water_units + capacity - 1) / capacity; // Equivalent to ceil(water_units / capacity)\n        \n        total_drops += drops_for_well;\n    }\n    \n    return total_drops;\n}\n\n"}
{"task_id": "CPP/116", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to count the number of 1s in binary representation of a number.\nint countOnes(int n) {\n    int ones = 0;\n    while (n != 0) {\n        if (n % 2 == 1)\n            ++ones;\n        n /= 2;\n    }\n    return ones;\n}\n\n// Comparator function for sorting based on the number of ones and then by value.\nbool compare(int a, int b) {\n    int countA = countOnes(abs(a));\n    int countB = countOnes(abs(b));\n\n    if (countA == countB)\n        return a < b; // If same number of 1s, sort by decimal value\n    else\n        return countA < countB; // Otherwise, sort by the number of 1s\n}\n\nvector<int> sort_array(vector<int> arr) {\n    sort(arr.begin(), arr.end(), compare);\n    return arr;\n}\n\n"}
{"task_id": "CPP/117", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Helper function to count consonants in a word\nint count_consonants(const string& word) {\n    int count = 0;\n    for (char ch : word) {\n        // Convert character to lowercase and check if it's a consonant\n        char lower_ch = tolower(ch);\n        if ((lower_ch >= 'a' && lower_ch <= 'z') && !(lower_ch == 'a' || lower_ch == 'e' || lower_ch == 'i' || lower_ch == 'o' || lower_ch == 'u')) {\n            count++;\n        }\n    }\n    return count;\n}\n\nvector<string> select_words(string s, int n) {\n    vector<string> result;\n    string word = \"\";\n    \n    // Split the string into words and check consonant count\n    for (char ch : s) {\n        if (ch == ' ') {\n            if (!word.empty()) {\n                if (count_consonants(word) == n) {\n                    result.push_back(word);\n                }\n                word = \"\";  // Reset word after processing it\n            }\n        } else {\n            word += ch;\n        }\n    }\n\n    // Check the last word in case there's no trailing space\n    if (!word.empty()) {\n        if (count_consonants(word) == n) {\n            result.push_back(word);\n        }\n    }\n\n    return result;\n}\n\n// Function to test the implementation with given examples\nvoid check() {\n    vector<string> res;\n\n    res = select_words(\"Mary had a little lamb\", 4);\n    for (const auto& word : res) cout << word << \" \";\n    cout << endl; // Expected: {\"little\"}\n\n    res = select_words(\"Mary had a little lamb\", 3);\n    for (const auto& word : res) cout << word << \" \";\n    cout << endl; // Expected: {\"Mary\", \"lamb\"}\n\n    res = select_words(\"simple white space\", 2);\n    for (const auto& word : res) cout << word << \" \";\n    cout << endl; // Expected: {}\n\n    res = select_words(\"Hello world\", 4);\n    for (const auto& word : res) cout << word << \" \";\n    cout << endl; // Expected: {\"world\"}\n\n    res = select_words(\"Uncle sam\", 3);\n    for (const auto& word : res) cout << word << \" \";\n    cout << endl; // Expected: {\"Uncle\"}\n}\n\n"}
{"task_id": "CPP/118", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_vowel(char c) {\n    string vowels = \"aeiouAEIOU\";\n    return vowels.find(c) != string::npos;\n}\n\nstring get_closest_vowel(string word){\n    int len = word.length();\n    \n    // Iterate from the end of the string to the beginning\n    for (int i = len - 2; i > 0; --i) {\n        // Check if current character is a vowel and surrounded by consonants\n        if (is_vowel(word[i]) && !is_vowel(word[i-1]) && !is_vowel(word[i+1])) {\n            return string(1, word[i]);\n        }\n    }\n    \n    // Return empty string if no such vowel found\n    return \"\";\n}\n\n"}
{"task_id": "CPP/119", "generation": "#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nbool is_balanced(const string& s) {\n    int balance = 0;\n    for (char c : s) {\n        if (c == '(') {\n            ++balance;\n        } else { // char must be ')'\n            --balance;\n            if (balance < 0) {\n                return false; // more closing parentheses than opening ones\n            }\n        }\n    }\n    return balance == 0; // true if balanced, otherwise false\n}\n\nstring match_parens(vector<string> lst) {\n    string s1 = lst[0];\n    string s2 = lst[1];\n\n    if (is_balanced(s1 + s2)) {\n        return \"Yes\";\n    } else if (is_balanced(s2 + s1)) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\n"}
{"task_id": "CPP/120", "generation": "#include <vector>\n#include <algorithm> // for std::sort\n\nusing namespace std;\n\nvector<int> maximum(vector<int> arr, int k) {\n    // Step 1: Sort the array in ascending order.\n    sort(arr.begin(), arr.end());\n    \n    // Step 2: Extract the last k elements from the sorted vector.\n    vector<int> result;\n    for (int i = arr.size() - k; i < arr.size(); ++i) {\n        result.push_back(arr[i]);\n    }\n    \n    return result;\n}\n\n// Example usage:\n/*\nvector<int> example1 = {-3, -4, 5};\nvector<int> output1 = maximum(example1, 3); // Output: {-4, -3, 5}\n\nvector<int> example2 = {4, -4, 4};\nvector<int> output2 = maximum(example2, 2); // Output: {4, 4}\n\nvector<int> example3 = {-3, 2, 1, 2, -1, -2, 1};\nvector<int> output3 = maximum(example3, 1); // Output: {2}\n*/\n"}
{"task_id": "CPP/121", "generation": "#include <vector>\nusing namespace std;\n\nint solution(vector<int> lst) {\n    int sum = 0;\n    \n    // Iterate through the vector with a step of 2 to check even positions (0-indexed)\n    for(int i = 0; i < lst.size(); i += 2) {\n        if(lst[i] % 2 != 0) { // Check if the element is odd\n            sum += lst[i];\n        }\n    }\n    \n    return sum;\n}\n"}
{"task_id": "CPP/122", "generation": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint add_elements(vector<int> arr, int k) {\n    int sum = 0;\n    for (int i = 0; i < k; ++i) {\n        if (arr[i] >= -99 && arr[i] <= 99) {\n            sum += arr[i];\n        }\n    }\n    return sum;\n}\n"}
{"task_id": "CPP/123", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // For std::sort\n\nusing namespace std;\n\nvector<int> get_odd_collatz(int n) {\n    vector<int> oddNumbers;\n    \n    while (n != 1) {\n        if (n % 2 == 1) { // Check if the number is odd\n            oddNumbers.push_back(n);\n        }\n        if (n % 2 == 0) { // If even, divide by 2\n            n /= 2;\n        } else { // If odd, apply the Collatz formula\n            n = 3 * n + 1;\n        }\n    }\n    \n    // Add the last number in the sequence which is always 1 and is odd.\n    oddNumbers.push_back(1);\n    \n    // Sort the vector of odd numbers before returning it.\n    sort(oddNumbers.begin(), oddNumbers.end());\n    \n    return oddNumbers;\n}\n\n// Function to test the get_odd_collatz function\nvoid check() {\n    vector<int> result = get_odd_collatz(5);\n    for (int num : result) {\n        cout << num << \" \";\n    }\n    // Expected output: 1 5\n    cout << endl;\n    \n    result = get_odd_collatz(7); \n    for (int num : result) {\n        cout << num << \" \";\n    }\n    // Expected output: 1 7 11 22\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/124", "generation": "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nbool valid_date(const string& date) {\n    // Check if the date string is empty or not in mm-dd-yyyy format.\n    if (date.length() != 10 || date[2] != '-' || date[5] != '-') return false;\n    \n    vector<int> days_in_month = {31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\n    \n    // Extract month, day and year from the date string.\n    int month = stoi(date.substr(0, 2));\n    int day = stoi(date.substr(3, 2));\n    int year = stoi(date.substr(6, 4));\n\n    // Validate month\n    if (month < 1 || month > 12) return false;\n\n    // Validate day based on the month and leap year for February.\n    if (day < 1 || day > days_in_month[month - 1]) return false;\n    \n    // Special case for February in a non-leap year\n    if (month == 2 && day == 29) {\n        bool is_leap_year = ((year % 4 == 0 && year % 100 != 0) || (year % 400 == 0));\n        if (!is_leap_year) return false;\n    }\n\n    // If all checks pass, the date is valid.\n    return true;\n}\n\n"}
{"task_id": "CPP/125", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n\nusing namespace std;\n\nvector<string> split_words(string txt) {\n    if (txt.find(' ') != string::npos) {\n        stringstream ss(txt);\n        string word;\n        vector<string> result;\n        while (ss >> word) {\n            result.push_back(word);\n        }\n        return result;\n    } else if (txt.find(',') != string::npos) {\n        vector<string> result;\n        size_t start = 0, end = txt.find(',');\n        while (end != string::npos) {\n            result.push_back(txt.substr(start, end - start));\n            start = end + 1;\n            end = txt.find(',', start);\n        }\n        result.push_back(txt.substr(start)); // Add the last part\n        return result;\n    } else {\n        int count = 0;\n        for (char c : txt) {\n            if (islower(c) && ((c - 'a') % 2 == 1)) { // Check for lowercase letters with odd order positions.\n                ++count;\n            }\n        }\n        vector<string> result(1, to_string(count));\n        return result;\n    }\n}\n"}
{"task_id": "CPP/126", "generation": "#include <vector>\n#include <algorithm>\n\nbool is_sorted(std::vector<int> lst) {\n    // Check if the list is empty or has only one element, which is always sorted.\n    if (lst.size() <= 1) return true;\n\n    int count = 1; // To keep track of how many times a number appears consecutively.\n\n    for (size_t i = 1; i < lst.size(); ++i) {\n        // If the current element is less than the previous one, it's not sorted.\n        if (lst[i] < lst[i - 1]) return false;\n\n        // Check how many times a number appears consecutively.\n        if (lst[i] == lst[i - 1]) {\n            count++;\n            // If any number appears more than twice, return false.\n            if (count > 2) return false;\n        } else {\n            count = 1; // Reset the counter for different numbers.\n        }\n    }\n\n    return true;\n}\n"}
{"task_id": "CPP/127", "generation": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <string>\nusing namespace std;\n\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\nstring intersection(vector<int> interval1, vector<int> interval2) {\n    int start_max = max(interval1[0], interval2[0]);\n    int end_min = min(interval1[1], interval2[1]);\n\n    if (start_max > end_min) {\n        // No intersection\n        return \"NO\";\n    }\n\n    int length_of_intersection = end_min - start_max + 1;\n\n    if (is_prime(length_of_intersection)) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n\n"}
{"task_id": "CPP/128", "generation": "#include <vector>\n#include <cmath> // For std::abs\n\nint prod_signs(std::vector<int> arr) {\n    if (arr.empty()) return -32768; // Return special value for empty vector\n    \n    int signProduct = 1;\n    int magnitudeSum = 0;\n\n    for (auto num : arr) {\n        magnitudeSum += std::abs(num); // Sum of magnitudes\n        if (num == 0) { \n            signProduct = 0; // If any number is zero, the product of signs will be zero.\n            break;\n        } else if (num < 0) {\n            signProduct *= -1; // Multiply by -1 for negative numbers\n        }\n    }\n\n    return magnitudeSum * signProduct;\n}\n\n// Example usage:\n"}
{"task_id": "CPP/129", "generation": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nbool is_valid(int x, int y, int N) {\n    return 0 <= x && x < N && 0 <= y && y < N;\n}\n\nvoid dfs(const vector<vector<int>>& grid, vector<int>& min_path, vector<int> path, int k, int x, int y) {\n    if (path.size() == k) {\n        if (path < min_path)\n            min_path = path;\n        return;\n    }\n    \n    static const int directions[4][2] = {{0, 1}, {1, 0}, {-1, 0}, {0, -1}};\n    \n    for (const auto& dir : directions) {\n        int nx = x + dir[0];\n        int ny = y + dir[1];\n        \n        if (is_valid(nx, ny, grid.size())) {\n            path.push_back(grid[nx][ny]);\n            dfs(grid, min_path, path, k, nx, ny);\n            path.pop_back();\n        }\n    }\n}\n\nvector<int> minPath(const vector<vector<int>>& grid, int k) { // Changed to const reference\n    vector<int> min_path(k, INT_MAX);\n    \n    for (int i = 0; i < grid.size(); ++i)\n        for (int j = 0; j < grid[0].size(); ++j)\n            dfs(grid, min_path, {grid[i][j]}, k, i, j);\n\n    return min_path;\n}\n"}
{"task_id": "CPP/130", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> tri(int n) {\n    // Base cases\n    if (n == 0) return {1};\n    if (n == 1) return {1, 3};\n\n    vector<int> tribonacci(n + 1);\n    \n    // Initialize the first three elements of the sequence.\n    tribonacci[0] = 1;\n    tribonacci[1] = 3;\n    tribonacci[2] = 2;\n\n    // Fill in the rest of the Tribonacci sequence\n    for (int i = 3; i <= n; ++i) {\n        if (i % 2 == 0) { \n            // If even, use the formula tri(n) = 1 + n / 2\n            tribonacci[i] = 1 + i / 2;\n        } else {\n            // For odd indices, calculate using previous values.\n            // Note: We do not need to access tribonacci[i+1], as it is not required for the calculation.\n            tribonacci[i] = tribonacci[i - 1] + tribonacci[i - 2];\n        }\n    }\n\n    return tribonacci;\n}\n\n"}
{"task_id": "CPP/131", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint digits(int n) {\n    string numStr = to_string(n); // Convert integer to string for easy digit access\n    int product = 1; // Initialize product with 1\n    \n    bool hasOddDigit = false;\n    \n    for (char c : numStr) { // Iterate through each character in the string\n        int digit = c - '0'; // Convert char to int\n        \n        if (digit % 2 != 0) { // Check if the digit is odd\n            product *= digit; // Multiply it into the product\n            hasOddDigit = true;\n        }\n    }\n    \n    return hasOddDigit ? product : 0; // Return product or 0 based on whether there was an odd digit\n}\n\n"}
{"task_id": "CPP/132", "generation": "#include <string>\nusing namespace std;\n\nbool is_nested(string str) {\n    int max_depth = 0;\n    int current_depth = 0;\n\n    for (char c : str) {\n        if (c == '[') {\n            current_depth += 1;\n            max_depth = max(max_depth, current_depth);\n        } else if (c == ']') {\n            current_depth -= 1;\n        }\n\n        // If the depth goes negative, it means there's an unmatched closing bracket.\n        if (current_depth < 0) {\n            return false;\n        }\n    }\n\n    // Return true only if the maximum depth is greater than 1 (indicating nesting).\n    return max_depth > 1;\n}\n"}
{"task_id": "CPP/133", "generation": "#include <iostream>\n#include <vector>\n#include <cmath> // for ceil and pow functions\n\nusing namespace std;\n\nint sum_squares(vector<float> lst){\n    int sum = 0;\n    for (float num : lst) {\n        float ceilingValue = ceil(num); // Round up to the nearest integer\n        sum += pow(ceilingValue, 2); // Square it and add to sum\n    }\n    return sum;\n}\n\n"}
{"task_id": "CPP/134", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool check_if_last_char_is_a_letter(string txt) {\n    // Check if string is empty or ends with a space.\n    if (txt.empty() || txt.back() == ' ') return false;\n    \n    // Get the last character of the string.\n    char lastChar = txt.back();\n    \n    // Check if it's an alphabetical character and not part of a word.\n    bool isAlphabetical = isalpha(lastChar);\n    bool isNotPartOfWord = (txt.size() == 1 || txt[txt.size()-2] == ' ');\n    \n    return isAlphabetical && isNotPartOfWord;\n}\n\n"}
{"task_id": "CPP/135", "generation": "#include <vector>\nusing namespace std;\n\nint can_arrange(vector<int> arr) {\n    for (size_t i = 1; i < arr.size(); ++i) {\n        if (arr[i] < arr[i - 1]) {\n            return static_cast<int>(i);\n        }\n    }\n    return -1;\n}\n"}
{"task_id": "CPP/136", "generation": "#include <vector>\n#include <algorithm> // For std::min and std::max\n\nusing namespace std;\n\nvector<int> largest_smallest_integers(vector<int> lst){\n    int largestNegative = 0;\n    int smallestPositive = 0;\n    \n    bool foundNegative = false;\n    bool foundPositive = false;\n    \n    for(int num : lst) {\n        if(num < 0) {\n            // Update the largest negative number\n            if(!foundNegative || num > largestNegative) {\n                largestNegative = num;\n                foundNegative = true;\n            }\n        } else if (num > 0) {\n            // Update the smallest positive number\n            if(!foundPositive || num < smallestPositive) {\n                smallestPositive = num;\n                foundPositive = true;\n            }\n        }\n    }\n\n    return {largestNegative, smallestPositive};\n}\n\n// Example usage:\n"}
{"task_id": "CPP/137", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <variant>\n#include <vector>\n\nusing namespace std;\n\nboost::any compare_one(boost::any a, boost::any b) {\n    // Helper function to convert strings with commas to floats\n    auto to_float = [](const string& str) -> float {\n        string temp_str = str;\n        replace(temp_str.begin(), temp_str.end(), ',', '.');\n        return stof(temp_str);\n    };\n\n    float a_val, b_val;\n\n    if (a.type() == typeid(int)) {\n        a_val = boost::any_cast<int>(a);\n    } else if (a.type() == typeid(float)) {\n        a_val = boost::any_cast<float>(a);\n    } else if (a.type() == typeid(string)) {\n        a_val = to_float(boost::any_cast<string>(a));\n    }\n\n    if (b.type() == typeid(int)) {\n        b_val = boost::any_cast<int>(b);\n    } else if (b.type() == typeid(float)) {\n        b_val = boost::any_cast<float>(b);\n    } else if (b.type() == typeid(string)) {\n        b_val = to_float(boost::any_cast<string>(b));\n    }\n\n    // Compare the values\n    if (a_val > b_val) {\n        return a;\n    } else if (b_val > a_val) {\n        return b;\n    } else {\n        return string(\"None\");\n    }\n}\n\n"}
{"task_id": "CPP/138", "generation": "#include <iostream>\nusing namespace std;\n\nbool is_equal_to_sum_even(int n) {\n    // Check if n is at least 8 and an even number.\n    return (n >= 8 && n % 2 == 0);\n}\n\n"}
{"task_id": "CPP/139", "generation": "#include <iostream>\nusing namespace std;\n\n// Function to calculate factorial of a given number\nlong long factorial(int num) {\n    if (num == 0 || num == 1)\n        return 1;\n    else\n        return num * factorial(num - 1);\n}\n\n// Function to calculate the Brazilian factorial as defined\nlong long special_factorial(int n){\n    long long result = 1;\n    for(int i = 1; i <= n; ++i) {\n        result *= factorial(i);\n    }\n    return result;\n}\n\n"}
{"task_id": "CPP/140", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring fix_spaces(string text) {\n    string result;\n    int spaceCount = 0; // Counter for consecutive spaces\n\n    for (char c : text) {\n        if (c == ' ') {\n            ++spaceCount;\n        } else {\n            if (spaceCount > 2) {\n                result += '-';\n            } else {\n                while (spaceCount > 0) {\n                    result += '_';\n                    --spaceCount;\n                }\n            }\n            spaceCount = 0; // Reset the counter\n            result += c;\n        }\n    }\n\n    // Handle trailing spaces if any\n    if (spaceCount > 2) {\n        result += '-';\n    } else {\n        while (spaceCount > 0) {\n            result += '_';\n            --spaceCount;\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/141", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring file_name_check(string file_name) {\n    // Check for exactly one dot in the name.\n    size_t dotPos = file_name.find('.');\n    if (dotPos == string::npos || file_name.find('.', dotPos + 1) != string::npos)\n        return \"No\";\n\n    // Split the filename into two parts: before and after the dot\n    string prefix = file_name.substr(0, dotPos);\n    string suffix = file_name.substr(dotPos + 1);\n\n    // Check if there are more than three digits in the prefix.\n    int digitCount = 0;\n    for (char c : prefix) {\n        if (isdigit(c)) digitCount++;\n        if (digitCount > 3) return \"No\";\n    }\n\n    // Validate that the prefix starts with a letter and is not empty\n    if (prefix.empty() || !isalpha(prefix[0])) \n        return \"No\";\n\n    // Check valid extensions.\n    string validExtensions[] = {\"txt\", \"exe\", \"dll\"};\n    bool isValidExtension = false;\n    for (string ext : validExtensions) {\n        if (ext == suffix) {\n            isValidExtension = true;\n            break;\n        }\n    }\n\n    if (!isValidExtension)\n        return \"No\";\n\n    // If all checks pass, the filename is valid.\n    return \"Yes\";\n}\n\n"}
{"task_id": "CPP/142", "generation": "#include <vector>\nusing namespace std;\n\nint sum_squares(vector<int> lst) {\n    int sum = 0;\n    \n    for (size_t i = 0; i < lst.size(); ++i) {\n        if (i % 3 == 0) { // If index is a multiple of 3\n            sum += lst[i] * lst[i]; // Square the element and add to sum\n        } else if (i % 4 == 0 && i % 3 != 0) { // If index is a multiple of 4 but not 3\n            sum += lst[i] * lst[i] * lst[i]; // Cube the element and add to sum\n        } else {\n            sum += lst[i]; // Add the element as it is if no condition matches\n        }\n    }\n\n    return sum;\n}\n\n// Example usage:\n"}
{"task_id": "CPP/143", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\n// Helper function to check if a number is prime\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    for (int i = 2; i * i <= num; ++i) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\n// Main function to filter words based on prime length\nstring words_in_sentence(string sentence) {\n    stringstream ss(sentence);\n    string word, result;\n    \n    while (ss >> word) { // Extract each word from the sentence\n        if (is_prime(word.length())) {\n            if (!result.empty()) result += \" \"; // Add space before appending new word\n            result += word; // Append prime length words to result\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/144", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool simplify(string x, string n) {\n    // Parsing fractions\n    size_t slashPos;\n    \n    int numX = stoi(x.substr(0, (slashPos = x.find('/'))));\n    int denX = stoi(x.substr(slashPos + 1));\n\n    int numN = stoi(n.substr(0, (slashPos = n.find('/'))));\n    int denN = stoi(n.substr(slashPos + 1));\n\n    // Multiplying the fractions\n    int numeratorResult = numX * numN;\n    int denominatorResult = denX * denN;\n\n    // Simplifying to check if it's a whole number\n    return (numeratorResult % denominatorResult == 0);\n}\n\n"}
{"task_id": "CPP/145", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nint sum_of_digits(int n) {\n    int sum = 0;\n    bool is_negative = n < 0;\n    while (n != 0) {\n        sum += n % 10;\n        n /= 10;\n    }\n    if (is_negative && sum != 0) {\n        sum -= 2 * (sum % 10); // Adjust for the negative sign being counted as a digit\n    }\n    return sum;\n}\n\nstruct CustomComparator {\n    std::vector<int> original_nums;\n\n    CustomComparator(const std::vector<int>& nums) : original_nums(nums) {}\n\n    bool operator()(int a, int b) const {\n        int sum_a = sum_of_digits(a);\n        int sum_b = sum_of_digits(b);\n\n        if (sum_a != sum_b) {\n            return sum_a < sum_b;\n        } else {\n            auto it_a = std::find(original_nums.begin(), original_nums.end(), a);\n            auto it_b = std::find(original_nums.begin(), original_nums.end(), b);\n            return it_a < it_b;\n        }\n    }\n};\n\nstd::vector<int> order_by_points(std::vector<int> nums) {\n    CustomComparator comp(nums);\n    std::sort(nums.begin(), nums.end(), comp);\n    return nums;\n}\n\n"}
{"task_id": "CPP/146", "generation": "#include <vector>\n#include <string>\nusing namespace std;\n\nbool isFirstAndLastDigitOdd(int num) {\n    // Convert to string to easily access first and last digit\n    string strNum = to_string(abs(num));  // Use abs to handle negative numbers\n    char firstDigit = strNum[0];\n    char lastDigit = strNum[strNum.length() - 1];\n\n    // Check if both digits are odd\n    return (firstDigit == '1' || firstDigit == '3' || firstDigit == '5' || \n            firstDigit == '7' || firstDigit == '9') &&\n           (lastDigit == '1' || lastDigit == '3' || lastDigit == '5' ||\n            lastDigit == '7' || lastDigit == '9');\n}\n\nint specialFilter(vector<int> nums) {\n    int count = 0;\n    for(int num : nums) {\n        if(num > 10 && isFirstAndLastDigitOdd(num)) {\n            ++count;\n        }\n    }\n    return count;\n}\n"}
{"task_id": "CPP/147", "generation": "#include<iostream>\n#include<vector>\n\nusing namespace std;\n\nint get_max_triples(int n) {\n    vector<int> a(n);\n    \n    // Fill the array with values according to the given formula.\n    for (int i = 0; i < n; ++i) {\n        a[i] = (i + 1) * (i + 1) - (i + 1) + 1;\n    }\n    \n    int count = 0;\n\n    // Iterate through all possible triples and check the condition.\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            for (int k = j + 1; k < n; ++k) {\n                if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                    count++;\n                }\n            }\n        }\n    }\n\n    return count;\n}\n\n// Function to test the solution with given data points.\nvoid check_solution() {\n    cout << \"For n = 5, Expected: 1, Got: \" << get_max_triples(5) << endl;\n    // You can add more tests here as needed\n}\n\n"}
{"task_id": "CPP/148", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to find planets between two given planets.\nvector<string> bf(string planet1, string planet2) {\n    // Mapping of each planet name to its position relative to the Sun.\n    vector<pair<string, int>> solarSystem = {\n        {\"Mercury\", 1}, {\"Venus\", 2}, {\"Earth\", 3},\n        {\"Mars\", 4}, {\"Jupiter\", 5}, {\"Saturn\", 6},\n        {\"Uranus\", 7}, {\"Neptune\", 8}\n    };\n\n    // Find the positions of planet1 and planet2.\n    int pos1 = -1, pos2 = -1;\n    for (const auto& planet : solarSystem) {\n        if (planet.first == planet1)\n            pos1 = planet.second;\n        else if (planet.first == planet2)\n            pos2 = planet.second;\n\n        // If both positions are found, break the loop.\n        if (pos1 != -1 && pos2 != -1)\n            break;\n    }\n\n    // Check if either of the planets was not found.\n    if (pos1 == -1 || pos2 == -1) {\n        return {};  // Return an empty vector if any planet is invalid.\n    }\n\n    // Ensure pos1 < pos2 for simplicity in the loop below.\n    if (pos1 > pos2)\n        swap(pos1, pos2);\n\n    // Collect all planets between pos1 and pos2.\n    vector<string> result;\n    for (const auto& planet : solarSystem) {\n        int position = planet.second;\n        if (position > pos1 && position < pos2) {\n            result.push_back(planet.first);\n        }\n    }\n\n    return result;\n}\n\n// Function to test the bf function with examples.\nvoid check() {\n    vector<string> res;\n\n    // Example 1\n    res = bf(\"Jupiter\", \"Neptune\");\n    for (const auto& planet : res)\n        cout << planet << \" \";\n    cout << endl;  // Expected: Saturn Uranus\n\n    // Example 2\n    res = bf(\"Earth\", \"Mercury\");\n    for (const auto& planet : res)\n        cout << planet << \" \";\n    cout << endl;  // Expected: Venus\n\n    // Example 3\n    res = bf(\"Mercury\", \"Uranus\");\n    for (const auto& planet : res)\n        cout << planet << \" \";\n    cout << endl;  // Expected: Venus Earth Mars Jupiter Saturn\n}\n\n"}
{"task_id": "CPP/149", "generation": "#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to sort a vector of strings by length (ascending) and alphabetically if lengths are equal.\nvector<string> vector_sort(vector<string> lst){\n    // Filter out strings with odd lengths\n    vector<string> filtered_lst;\n    for(const auto& s : lst) {\n        if(s.length() % 2 == 0) {\n            filtered_lst.push_back(s);\n        }\n    }\n\n    // Sort the list by length and then alphabetically\n    sort(filtered_lst.begin(), filtered_lst.end(), [](const string &a, const string &b){\n        return a.size() != b.size() ? a.size() < b.size() : a < b;\n    });\n\n    return filtered_lst;\n}\n\n"}
{"task_id": "CPP/150", "generation": "#include <cmath> // for sqrt function\nusing namespace std;\n\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    for (int i = 2; i <= sqrt(num); ++i) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\nint x_or_y(int n, int x, int y) {\n    if (is_prime(n)) {\n        return x;\n    } else {\n        return y;\n    }\n}\n"}
{"task_id": "CPP/151", "generation": "#include <vector>\n#include <cmath> // For std::pow\n\nusing namespace std;\n\nlong long double_the_difference(vector<float> lst) {\n    long long sum = 0;\n    \n    for (float num : lst) {\n        if (num > 0 && floor(num) == num && static_cast<int>(num) % 2 != 0) { // Check if positive, integer and odd\n            int n = static_cast<int>(num);\n            sum += pow(n, 2); // Square the number and add to sum\n        }\n    }\n\n    return sum;\n}\n\n// Test cases\n"}
{"task_id": "CPP/152", "generation": "#include <iostream>\n#include <cmath>\n#include <vector>\n\nstd::vector<int> compare(std::vector<int> game, std::vector<int> guess) {\n    std::vector<int> result;\n    for (size_t i = 0; i < game.size(); ++i) {\n        int diff = abs(game[i] - guess[i]);\n        result.push_back(diff);\n    }\n    return result;\n}\n"}
{"task_id": "CPP/153", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to calculate the strength of an extension.\nint CalculateStrength(const string& extension) {\n    int uppercase = 0;\n    int lowercase = 0;\n    \n    for (char c : extension) {\n        if (isupper(c)) uppercase++;\n        else if (islower(c)) lowercase++;\n    }\n    \n    return uppercase - lowercase;\n}\n\nstring Strongest_Extension(string class_name, vector<string> extensions) {\n    string strongest_extension = \"\";\n    int max_strength = INT_MIN; // Initialize with the smallest possible integer.\n    \n    for (const auto& extension : extensions) {\n        int strength = CalculateStrength(extension);\n        \n        if (strength > max_strength || (strength == max_strength && strongest_extension.empty())) {\n            max_strength = strength;\n            strongest_extension = extension;\n        }\n    }\n    \n    return class_name + \".\" + strongest_extension;\n}\n\n"}
{"task_id": "CPP/154", "generation": "#include <string>\n#include <algorithm>\nusing namespace std;\n\nbool cycpattern_check(std::string a, std::string b) {\n    if (b.length() > a.length()) return false;\n\n    // Concatenate string 'a' with itself to handle rotations\n    std::string a_doubled = a + a;\n\n    for (size_t i = 0; i < b.length(); ++i) {\n        std::string rotated_b = b.substr(i) + b.substr(0, i);\n        if (a_doubled.find(rotated_b) != std::string::npos) return true;\n    }\n    return false;\n}\n"}
{"task_id": "CPP/155", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<int> even_odd_count(int num){\n    // Convert number to its absolute value to handle negative numbers\n    int absNum = abs(num);\n    \n    // Convert integer to string for easy digit extraction\n    string strNum = to_string(absNum);\n\n    // Initialize counters for even and odd digits\n    int evenCount = 0;\n    int oddCount = 0;\n\n    // Iterate through each character in the string\n    for (char c : strNum) {\n        // Convert char to integer digit\n        int digit = c - '0';\n        \n        // Check if the digit is even or odd and increment respective counter\n        if (digit % 2 == 0) {\n            evenCount++;\n        } else {\n            oddCount++;\n        }\n    }\n\n    // Return a vector containing counts of even and odd digits respectively\n    return {evenCount, oddCount};\n}\n\n// Function to test the solution with given examples\nvoid check() {\n    vector<int> result = even_odd_count(-12);\n    cout << \"even_odd_count(-12) -> {\" << result[0] << \", \" << result[1] << \"}\\n\";\n    \n    result = even_odd_count(123);\n    cout << \"even_odd_count(123) -> {\" << result[0] << \", \" << result[1] << \"}\\n\";\n}\n\n"}
{"task_id": "CPP/156", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring int_to_mini_roman(int number) {\n    // Define the values and corresponding symbols\n    vector<int> values = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    vector<string> symbols = {\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n\n    string roman = \"\";\n    \n    // Iterate over the values and construct the Roman numeral\n    for (int i = 0; number > 0; ++i) {\n        while (number >= values[i]) {\n            roman += symbols[i];\n            number -= values[i];\n        }\n    }\n\n    return roman;\n}\n\n// Example usage:\n"}
{"task_id": "CPP/157", "generation": "#include <iostream>\n#include <cmath>\n\nbool right_angle_triangle(float a, float b, float c){\n    // First, sort the sides so that c is the longest side (hypotenuse)\n    if(a > c) std::swap(a, c);\n    if(b > c) std::swap(b, c);\n\n    // Check the Pythagorean theorem\n    return fabs(a*a + b*b - c*c) < 1e-6; // Using a small threshold to account for floating point precision issues.\n}\n\n"}
{"task_id": "CPP/158", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <set>\nusing namespace std;\n\nstring find_max(vector<string> words) {\n    string result;\n    int max_unique = 0; // To keep track of maximum unique characters\n\n    for (const auto& word : words) {\n        set<char> unique_chars(word.begin(), word.end()); // Use a set to get unique characters\n        int count_unique = unique_chars.size();\n\n        if (count_unique > max_unique || \n            (count_unique == max_unique && word < result)) { // Check lexicographical order as well\n            max_unique = count_unique;\n            result = word;\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/159", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> eat(int number, int need, int remaining) {\n    // Calculate the total number of carrots eaten after trying to eat 'need' more.\n    int totalEaten = number + min(need, remaining);\n    \n    // Calculate how many carrots are left after eating as much as possible.\n    int carrotsLeft = max(0, remaining - need);\n\n    return {totalEaten, carrotsLeft};\n}\n"}
{"task_id": "CPP/160", "generation": "#include <vector>\n#include <string>\n#include <cmath>\nusing namespace std;\n\n// Function to evaluate the algebraic expression based on operators and operands.\nint do_algebra(vector<string> operators, vector<int> operands) {\n    // Initialize the result with the first operand.\n    int result = operands[0];\n\n    for (size_t i = 0; i < operators.size(); ++i) {\n        string op = operators[i];\n        int next_operand = operands[i + 1];\n\n        if (op == \"+\") {\n            result += next_operand;\n        } else if (op == \"-\") {\n            result -= next_operand;\n        } else if (op == \"*\") {\n            result *= next_operand;\n        } else if (op == \"//\") {\n            // Floor division\n            result = static_cast<int>(floor(static_cast<double>(result) / next_operand));\n        } else if (op == \"**\") {\n            // Exponentiation\n            result = pow(result, next_operand);\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/161", "generation": "#include <iostream>\n#include <string>\n#include <cctype> // For std::isalpha and std::islower\n\nusing namespace std;\n\nstring solve(string s) {\n    bool hasLetters = false;\n    \n    // Check if the string contains any letters.\n    for (char c : s) {\n        if (std::isalpha(c)) {\n            hasLetters = true;\n            break;\n        }\n    }\n\n    // If no letters are present, reverse the entire string.\n    if (!hasLetters) {\n        std::reverse(s.begin(), s.end());\n        return s;\n    }\n\n    // Otherwise, change the case of each letter and keep other characters as they are.\n    for (char &c : s) {\n        if (std::isalpha(c)) {\n            c = std::islower(c) ? toupper(c) : tolower(c);\n        }\n    }\n\n    return s;\n}\n\n"}
{"task_id": "CPP/162", "generation": "#include <iostream>\n#include <string>\n#include <openssl/md5.h>\n\nusing namespace std;\n\nstring string_to_md5(string text) {\n    if (text.empty()) return \"None\"; // Return \"None\" for empty strings\n\n    unsigned char digest[MD5_DIGEST_LENGTH];\n    MD5((unsigned char*)text.c_str(), text.length(), (unsigned char*)&digest);    \n\n    char mdString[33];\n    for(int i = 0; i < 16; ++i)\n        sprintf(&mdString[i*2], \"%02x\", (unsigned int)digest[i]);\n\n    return string(mdString);\n}\n\n"}
{"task_id": "CPP/163", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // For std::min and std::max\n\nusing namespace std;\n\nvector<int> generate_integers(int a, int b) {\n    vector<int> evenDigits = {2, 4, 6, 8}; // All possible even digits less than 10\n    vector<int> result;\n    \n    // Ensure a is the smaller number and b is the larger one\n    int start = min(a, b);\n    int end = max(a, b);\n\n    for (int digit : evenDigits) {\n        if (digit >= start && digit <= end) {\n            result.push_back(digit);\n        }\n    }\n\n    return result;\n}\n\n// Function to print vector elements\nvoid printVector(const vector<int>& vec) {\n    cout << \"{\";\n    for(size_t i = 0; i < vec.size(); ++i) {\n        if (i != 0) cout << \", \";\n        cout << vec[i];\n    }\n    cout << \"}\" << endl;\n}\n\n"}
{"task_id": "CPP/0", "generation": "#include <algorithm> // For std::sort\n\nbool has_close_elements(std::vector<float> numbers, float threshold) {\n    if (numbers.size() < 2) return false; // If there are less than two elements, we can't have any pairs.\n\n    // Sort the vector to bring closer elements next to each other.\n    std::sort(numbers.begin(), numbers.end());\n\n    for(size_t i = 0; i < numbers.size() - 1; ++i) {\n        if (std::abs(numbers[i] - numbers[i + 1]) < threshold) {\n            return true;\n        }\n    }\n\n    return false;\n}\n"}
{"task_id": "CPP/1", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> separate_paren_groups(string paren_string){\n    vector<string> result;\n    int balance = 0; // Keeps track of open parentheses\n    string current_group = \"\"; // Current group being processed\n\n    for (char c : paren_string) {\n        if (c == '(' || c == ')') { // Ignore spaces and only consider parentheses\n            current_group += c; // Add the character to the current group\n            balance += (c == '(' ? 1 : -1); // Update balance based on the character\n\n            if (balance == 0) { // When balance is zero, a complete group has been found\n                result.push_back(current_group);\n                current_group = \"\"; // Reset for the next group\n            }\n        }\n    }\n\n    return result;\n}\n\n// Function to test the solution with provided data points\nvoid check() {\n    vector<string> expected1 = {\"()\", \"(())\", \"(()())\"};\n    assert(separate_paren_groups(\"( ) (( )) (( )( ))\") == expected1);\n\n    // Additional checks can be added here as needed\n\n    cout << \"All tests passed successfully.\" << endl;\n}\n\n"}
{"task_id": "CPP/2", "generation": "#include<stdio.h>\n#include<math.h>\n\nfloat truncate_number(float number){\n    float integerPart = floor(number);\n    return number - integerPart;\n}\n\n"}
{"task_id": "CPP/3", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nbool below_zero(vector<int> operations) {\n    int balance = 0; // Start with a zero balance\n\n    for (int op : operations) { // Iterate through each operation\n        balance += op; // Update the balance according to the current operation\n        \n        if (balance < 0) { // Check if balance falls below zero\n            return true;\n        }\n    }\n\n    return false; // Return false if no point in time the balance was below zero\n}\n\n"}
{"task_id": "CPP/4", "generation": "#include <iostream>\n#include <vector>\n#include <numeric> // for std::accumulate\n#include <cmath>   // for std::abs\n\nusing namespace std;\n\nfloat mean_absolute_deviation(vector<float> numbers) {\n    if (numbers.empty()) return 0.0f; // Handle empty vector case\n    \n    float sum = accumulate(numbers.begin(), numbers.end(), 0.0f);\n    float mean = sum / numbers.size();\n    \n    float mad_sum = 0.0f;\n    for (float num : numbers) {\n        mad_sum += std::abs(num - mean); // Calculate the absolute difference and add it to the sum\n    }\n    \n    return mad_sum / numbers.size(); // Average of all absolute differences\n}\n\n"}
{"task_id": "CPP/5", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> intersperse(vector<int> numbers, int delimeter) {\n    vector<int> result;\n    \n    // If the input vector is empty, return it as is.\n    if (numbers.empty()) {\n        return result;\n    }\n    \n    // Iterate through each element in the input vector\n    for(size_t i = 0; i < numbers.size(); ++i) {\n        // Add the current number to the result vector\n        result.push_back(numbers[i]);\n        \n        // If it's not the last element, add the delimiter after it.\n        if (i != numbers.size() - 1) {\n            result.push_back(delimeter);\n        }\n    }\n\n    return result;\n}\n\n// Example usage:\n"}
{"task_id": "CPP/6", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<int> parse_nested_parens(string paren_string) {\n    vector<int> max_depths;\n    int current_depth = 0, max_depth = 0;\n    \n    for (char c : paren_string) {\n        if (c == '(') {\n            // Increase depth when encountering an opening parenthesis\n            ++current_depth;\n            // Update the maximum depth found so far in this group\n            if (current_depth > max_depth)\n                max_depth = current_depth;\n        } else if (c == ')') {\n            // Decrease depth when encountering a closing parenthesis\n            --current_depth;\n        } else if (c == ' ') {\n            // When we encounter a space, it means the end of one group.\n            // Add the maximum depth found for this group to our result vector,\n            // and reset max_depth and current_depth for the next group.\n            max_depths.push_back(max_depth);\n            max_depth = 0;\n            current_depth = 0;\n        }\n    }\n\n    // Handle the last group if there is no trailing space\n    if (max_depth > 0) {\n        max_depths.push_back(max_depth);\n    }\n\n    return max_depths;\n}\n\n"}
{"task_id": "CPP/7", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\n// Function to filter strings containing a specific substring.\nvector<string> filter_by_substring(vector<string> strings, string substring) {\n    vector<string> filteredStrings; // Vector to store the result.\n\n    for (const auto& str : strings) { // Iterate through each string in the input vector.\n        if (str.find(substring) != string::npos) { // Check if the current string contains the substring.\n            filteredStrings.push_back(str); // If it does, add it to the result vector.\n        }\n    }\n\n    return filteredStrings; // Return the filtered list of strings.\n}\n\n// Function to test the filter_by_substring function with given data points.\nvoid check() {\n    vector<string> empty;\n    auto res1 = filter_by_substring(empty, \"a\");\n    assert(res1.empty()); // Should be an empty vector.\n\n    vector<string> input2{\"abc\", \"bacd\", \"cde\", \"vector\"};\n    auto res2 = filter_by_substring(input2, \"a\");\n    vector<string> expected2{\"abc\", \"bacd\", \"vector\"};\n    assert(res2 == expected2); // Should match the expected result.\n\n    cout << \"All tests passed successfully.\" << endl;\n}\n\n"}
{"task_id": "CPP/8", "generation": "#include <vector>\n#include <utility>\nusing namespace std;\n\npair<int, int> sum_product(const vector<int>& numbers) {\n    if (numbers.empty()) {\n        return {0, 1};\n    }\n\n    int total_sum = 0;\n    int product = 1;\n\n    for (int num : numbers) {\n        total_sum += num;\n        product *= num;\n    }\n\n    return {total_sum, product};\n}\n"}
{"task_id": "CPP/9", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> rolling_max(vector<int> numbers) {\n    // Check if the input vector is empty to avoid undefined behavior.\n    if (numbers.empty()) return {};\n\n    vector<int> result;\n    int currentMax = numbers[0];  // Initialize with the first element of the sequence.\n\n    for (int num : numbers) {\n        // Update the current maximum value if the current number is greater than it.\n        if (num > currentMax) {\n            currentMax = num;\n        }\n        // Append the current maximum to the result vector.\n        result.push_back(currentMax);\n    }\n\n    return result;\n}\n\n// Example usage\n"}
{"task_id": "CPP/10", "generation": "#include <string>\nusing namespace std;\n\nbool is_palindrome(string str) {\n    string s(str.rbegin(), str.rend());\n    return s == str;\n}\n\nstring make_palindrome(string str) {\n    if (is_palindrome(str)) {\n        return str;\n    }\n\n    for (size_t i = 0; i < str.size(); ++i) {\n        string suffix = str.substr(i);\n        if (is_palindrome(suffix)) {\n            string prefix_to_reverse = str.substr(0, i);\n            reverse(prefix_to_reverse.begin(), prefix_to_reverse.end());\n            return str + prefix_to_reverse;\n        }\n    }\n\n    // In case no palindrome is found in the loop above\n    // This line should never be reached due to logic but added for completeness.\n    string reversed_str(str.rbegin(), str.rend());\n    return str + reversed_str;\n}\n"}
{"task_id": "CPP/11", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring string_xor(string a, string b) {\n    // Ensure both strings are of equal length by padding with zeros if necessary.\n    int len_a = a.length();\n    int len_b = b.length();\n\n    // Pad the shorter string with leading '0's to match lengths\n    while (len_a < len_b) { a = \"0\" + a; ++len_a; }\n    while (len_b < len_a) { b = \"0\" + b; ++len_b; }\n\n    string result;\n    \n    // Perform XOR on each pair of characters and append to the result\n    for(int i = 0; i < len_a; ++i){\n        if(a[i] == b[i]) {\n            result += '0'; // If both are same, XOR is 0\n        } else {\n            result += '1'; // If different, XOR is 1\n        }\n    }\n\n    return result;\n}\n\n// Function to test the string_xor function\nvoid check() {\n    cout << (string_xor(\"010\", \"110\") == \"100\" ? \"Test Passed\\n\" : \"Test Failed\\n\");\n}\n\n"}
{"task_id": "CPP/12", "generation": "#include <vector>\n#include <string>\nusing namespace std;\n\nstring longest(vector<string> strings) {\n    if (strings.empty()) return \"\"; // Return an empty string to represent None\n\n    string maxString = strings[0]; // Assume the first string is the longest initially\n    size_t maxLength = maxString.length();\n\n    for (size_t i = 1; i < strings.size(); ++i) { // Start from the second element\n        if (strings[i].length() > maxLength) {\n            maxString = strings[i];\n            maxLength = strings[i].length();\n        }\n    }\n\n    return maxString;\n}\n"}
{"task_id": "CPP/13", "generation": "#include <iostream>\nusing namespace std;\n\nint greatest_common_divisor(int a, int b) {\n    while (b != 0) {\n        int temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n\n"}
{"task_id": "CPP/14", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> all_prefixes(string str){\n    vector<string> prefixes;\n    for(size_t i = 0; i < str.length(); ++i) {\n        // Create a substring from the start to the current position (inclusive)\n        string prefix = str.substr(0, i + 1);\n        // Add this prefix to the vector\n        prefixes.push_back(prefix);\n    }\n    return prefixes;\n}\n\n// Example usage:\n"}
{"task_id": "CPP/15", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nstring string_sequence(int n) {\n    string result = \"\";\n    \n    for (int i = 0; i <= n; ++i) {\n        // Convert integer to string and append it to the result string.\n        result += to_string(i);\n        \n        // Add a space after each number except the last one\n        if (i < n) {\n            result += \" \";\n        }\n    }\n\n    return result;\n}\n\n// Function to test the correctness of the solution\nvoid check() {\n    cout << (string_sequence(0) == \"0\" ? \"Test 1 Passed\\n\" : \"Test 1 Failed\\n\");\n    cout << (string_sequence(5) == \"0 1 2 3 4 5\" ? \"Test 2 Passed\\n\" : \"Test 2 Failed\\n\");\n}\n\n"}
{"task_id": "CPP/16", "generation": "#include <iostream>\n#include <set>\n#include <string>\nusing namespace std;\n\nint count_distinct_characters(string str) {\n    // Convert string to lower case for case-insensitive comparison\n    transform(str.begin(), str.end(), str.begin(), ::tolower);\n    \n    // Use a set to store unique characters\n    set<char> distinctChars;\n    \n    // Iterate through each character and add it to the set\n    for (char c : str) {\n        distinctChars.insert(c);\n    }\n    \n    // The size of the set is the number of distinct characters\n    return distinctChars.size();\n}\n\n"}
{"task_id": "CPP/17", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<int> parse_music(string music_string){\n    vector<int> beats;\n    int i = 0;\n    \n    while (i < music_string.length()) {\n        if(music_string[i] == 'o') { // Check for whole note\n            if(i + 1 < music_string.length() && music_string[i+1] == '|') {\n                beats.push_back(2); // Half note\n                i += 2; // Skip the next character as well since it's part of the half note\n            } else {\n                beats.push_back(4); // Whole note\n                i++;\n            }\n        } else if(music_string[i] == '.') { // Check for quarter note\n            if(i + 1 < music_string.length() && music_string[i+1] == '|') {\n                beats.push_back(1); // Quarter note\n                i += 2; // Skip the next character as well since it's part of the quarter note\n            } else {\n                cout << \"Invalid input: Expected '|' after '.'\" << endl;\n                return vector<int>(); // Return an empty vector in case of invalid input\n            }\n        } else if(music_string[i] == ' ') { // Skip spaces\n            i++;\n        } else {\n            cout << \"Invalid character encountered: \" << music_string[i] << endl;\n            return vector<int>(); // Return an empty vector in case of invalid input\n        }\n    }\n\n    return beats;\n}\n\n"}
{"task_id": "CPP/18", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint how_many_times(string str, string substring) {\n    if (substring.empty() || str.empty()) return 0; // If either string is empty, no matches are possible.\n    \n    int count = 0;\n    size_t pos = 0;\n    \n    while ((pos = str.find(substring, pos)) != string::npos) { // Find the substring starting from 'pos'.\n        ++count; // Increment count for each match found.\n        ++pos;   // Move to the next character after the current match to find overlapping occurrences.\n    }\n    \n    return count;\n}\n\n"}
{"task_id": "CPP/19", "generation": "#include <iostream>\n#include <string>\n#include <vector>\n#include <map>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to sort numbers given as words from \"zero\" to \"nine\"\nstring sort_numbers(string numbers) {\n    // Mapping of number words to their numeric values\n    map<string, int> num_map = {\n        {\"zero\", 0}, {\"one\", 1}, {\"two\", 2}, {\"three\", 3},\n        {\"four\", 4}, {\"five\", 5}, {\"six\", 6}, {\"seven\", 7},\n        {\"eight\", 8}, {\"nine\", 9}\n    };\n\n    // Reverse mapping for converting numeric values back to words\n    map<int, string> reverse_map;\n    for (auto &p : num_map) {\n        reverse_map[p.second] = p.first;\n    }\n\n    // Split the input string into individual number words\n    vector<string> num_words;\n    string word;\n    for (char c : numbers) {\n        if (c == ' ') {\n            if (!word.empty()) {\n                num_words.push_back(word);\n                word.clear();\n            }\n        } else {\n            word += c;\n        }\n    }\n    if (!word.empty()) {\n        num_words.push_back(word);\n    }\n\n    // Sort the number words based on their numeric values\n    sort(num_words.begin(), num_words.end(),\n         [&num_map](const string &a, const string &b) { return num_map[a] < num_map[b]; });\n\n    // Convert back to a space-delimited string of sorted number words\n    string result;\n    for (size_t i = 0; i < num_words.size(); ++i) {\n        if (i > 0) result += \" \";\n        result += reverse_map[num_map[num_words[i]]];\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/20", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> find_closest_elements(std::vector<float> numbers) {\n    // Sort the vector in ascending order.\n    std::sort(numbers.begin(), numbers.end());\n\n    float min_diff = INFINITY;\n    std::pair<float, float> result(0.0f, 0.0f);\n\n    for (size_t i = 0; i < numbers.size() - 1; ++i) {\n        // Calculate the difference between consecutive elements.\n        float diff = numbers[i + 1] - numbers[i];\n\n        // Update min_diff and result if a smaller difference is found.\n        if (diff < min_diff) {\n            min_diff = diff;\n            result.first = numbers[i];\n            result.second = numbers[i + 1];\n        }\n    }\n\n    // Convert the pair to vector for return.\n    std::vector<float> out = {result.first, result.second};\n    return out;\n}\n"}
{"task_id": "CPP/21", "generation": "#include <vector>\n#include <algorithm> // for std::min_element and std::max_element\n\nusing namespace std;\n\nvector<float> rescale_to_unit(vector<float> numbers){\n    float min_val = *std::min_element(numbers.begin(), numbers.end());\n    float max_val = *std::max_element(numbers.begin(), numbers.end());\n\n    vector<float> scaled_numbers;\n    for (float num : numbers) {\n        // Apply the linear transformation\n        float scaled_num = (num - min_val) / (max_val - min_val);\n        scaled_numbers.push_back(scaled_num);\n    }\n\n    return scaled_numbers;\n}\n\n// Example usage:\n"}
{"task_id": "CPP/22", "generation": "#include <iostream>\n#include <vector>\n#include <list>\n#include <boost/any.hpp>\n\ntypedef std::list<boost::any> list_any;\n\nstd::vector<int> filter_integers(list_any values) {\n    std::vector<int> integers;\n    \n    for (auto it = values.begin(); it != values.end(); ++it) {\n        if (it->type() == typeid(int)) { // Check if the type is int\n            integers.push_back(boost::any_cast<int>(*it)); // Cast and add to vector\n        }\n    }\n\n    return integers;\n}\n\n"}
{"task_id": "CPP/23", "generation": "#include <iostream>\n#include <string>\n\nint stringLength(const std::string& str) {\n    return str.length();\n}\n\n"}
{"task_id": "CPP/24", "generation": "#include<stdio.h>\n\nint largest_divisor(int n) {\n    // Start from half of n because no number greater than n/2 can be a divisor of n (except n itself)\n    for (int i = n / 2; i >= 1; --i) {\n        if (n % i == 0) {\n            return i;\n        }\n    }\n    // If no divisor is found, which theoretically shouldn't happen unless n <= 1\n    return -1;\n}\n\n"}
{"task_id": "CPP/25", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvector<int> factorize(int n) {\n    vector<int> factors;\n    \n    // Divide by 2 until odd\n    while (n % 2 == 0) {\n        factors.push_back(2);\n        n /= 2;\n    }\n    \n    // Check for odd factors from 3 onwards\n    for (int i = 3; i * i <= n; i += 2) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n    \n    // If n is a prime number greater than 2\n    if (n > 2) {\n        factors.push_back(n);\n    }\n\n    return factors;\n}\n\n"}
{"task_id": "CPP/26", "generation": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nvector<int> remove_duplicates(vector<int> numbers) {\n    unordered_map<int, int> occurrences;\n    \n    // Count the occurrences of each number.\n    for (int num : numbers) {\n        occurrences[num]++;\n    }\n    \n    vector<int> result;\n    \n    // Add to result only those elements that occur once.\n    for (int num : numbers) {\n        if (occurrences[num] == 1) {\n            result.push_back(num);\n        }\n    }\n    \n    return result;\n}\n\n// Function to print the vector\nvoid print_vector(const vector<int>& v) {\n    cout << \"{\";\n    for(size_t i = 0; i < v.size(); ++i) {\n        cout << v[i];\n        if (i != v.size() - 1) cout << \", \";\n    }\n    cout << \"}\" << endl;\n}\n\n"}
{"task_id": "CPP/27", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring flip_case(string str) {\n    for (size_t i = 0; i < str.length(); ++i) {\n        if (isupper(str[i])) {\n            // Convert uppercase to lowercase\n            str[i] = tolower(str[i]);\n        } else if (islower(str[i])) {\n            // Convert lowercase to uppercase\n            str[i] = toupper(str[i]);\n        }\n    }\n    return str;\n}\n\n"}
{"task_id": "CPP/28", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring concatenate(vector<string> strings) {\n    // Initialize an empty string for storing the concatenated result.\n    string result = \"\";\n    \n    // Iterate through each element in the vector and append it to the result.\n    for (const auto& str : strings) {\n        result += str;\n    }\n    \n    return result;\n}\n\n// Function to test the concatenate function with some test cases\nvoid test_concatenate() {\n    cout << \"Test Case 1: Empty Vector -> Expected: \\\"\\\", Actual: \\\"\" << concatenate({}) << \"\\\"\" << endl;\n    cout << \"Test Case 2: {\\\"a\\\", \\\"b\\\", \\\"c\\\"} -> Expected: \\\"abc\\\", Actual: \\\"\" << concatenate({\"a\", \"b\", \"c\"}) << \"\\\"\" << endl;\n}\n\n"}
{"task_id": "CPP/29", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> filter_by_prefix(vector<string> strings, string prefix) {\n    vector<string> filteredStrings; // This will store the results\n\n    for (const auto& str : strings) { // Iterate through each string in the input\n        if (!str.empty() && str.substr(0, prefix.size()) == prefix) {\n            // Check if the current string starts with the given prefix\n            filteredStrings.push_back(str); // Add to result vector if condition is met\n        }\n    }\n\n    return filteredStrings; // Return the filtered list of strings\n}\n\n// Function to test the filter_by_prefix function\nvoid check() {\n    auto result1 = filter_by_prefix({}, \"a\");\n    cout << \"Test 1: \";\n    for (const auto& str : result1) {\n        cout << str << \" \";\n    }\n    cout << endl;\n\n    auto result2 = filter_by_prefix({\"abc\", \"bcd\", \"cde\", \"vector\"}, \"a\");\n    cout << \"Test 2: \";\n    for (const auto& str : result2) {\n        cout << str << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/30", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // For std::copy_if\n\nusing namespace std;\n\nvector<float> get_positive(vector<float> l) {\n    vector<float> result;  // This will store the positive numbers.\n    \n    // Use copy_if to filter only positive numbers into 'result'.\n    copy_if(l.begin(), l.end(), back_inserter(result), [](float x){ return x > 0; });\n    \n    return result;\n}\n\n// Function to print a vector\nvoid print_vector(const vector<float>& v) {\n    for (auto num : v) {\n        cout << num << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/31", "generation": "#include <iostream>\nusing namespace std;\n\nbool is_prime(long long n) {\n    // Handle edge cases for 0, 1 and negative numbers.\n    if (n <= 1) return false;\n    \n    // Check divisibility from 2 up to the square root of n.\n    for (long long i = 2; i * i <= n; ++i) {\n        if (n % i == 0)\n            return false;\n    }\n    return true;\n}\n\n"}
{"task_id": "CPP/32", "generation": "#include <vector>\n#include <cmath>\n#include <iostream>\n#include <cassert>\n\ndouble poly(const std::vector<double>& xs, double x) {\n    /*\n    Evaluates polynomial with coefficients xs at point x.\n    Returns xs[0] + xs[1] * x + xs[2] * x^2 + .... + xs[n] * x^n\n    */\n    double sum = 0;\n    for (size_t i = 0; i < xs.size(); ++i) {\n        sum += xs[i] * std::pow(x, i);\n    }\n    return sum;\n}\n\ndouble find_zero(const std::vector<double>& xs) {\n    /*\n    xs are coefficients of a polynomial. find_zero finds x such that poly(x) = 0.\n    find_zero returns only one zero point, even if there are many.\n    Moreover, find_zero only takes list xs having an even number of coefficients and the largest non-zero coefficient,\n    as it guarantees a solution.\n\n    >>> round(find_zero({1, 2}), 2) // f(x) = 1 + 2x\n    -0.5 \n    >>> round(find_zero({-6, 11, -6, 1}), 2) // (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n    1.0\n    */\n    \n    double a = -100;\n    double b = 100;\n\n    // Ensure there is a sign change in the interval [a, b]\n    while (poly(xs, a) * poly(xs, b) > 0) {\n        if (std::abs(poly(xs, a)) < std::abs(poly(xs, b))) {\n            a *= 2;\n        } else {\n            b *= 2;\n        }\n    }\n\n    // Bisection method\n    double tol = 1e-6; // Tolerance for the root finding\n    while (std::abs(b - a) > tol) {\n        double c = (a + b) / 2.0;\n        if (poly(xs, c) == 0 || std::abs(poly(xs, c)) < tol) {\n            return c; // Found the root within tolerance\n        } else if (poly(xs, a) * poly(xs, c) < 0) {\n            b = c;\n        } else {\n            a = c;\n        }\n    }\n\n    return (a + b) / 2.0; // Return midpoint as the approximate root\n}\n\n"}
{"task_id": "CPP/33", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // for std::sort\n\nusing namespace std;\n\nvector<int> sort_third(vector<int> l) {\n    vector<int> to_sort;\n    \n    // Extract values from indices divisible by 3 (0-based indexing)\n    for(size_t i = 0; i < l.size(); i += 3) {\n        to_sort.push_back(l[i]);\n    }\n    \n    // Sort the extracted values\n    sort(to_sort.begin(), to_sort.end());\n    \n    // Replace original elements with sorted ones\n    for(size_t i = 0, j = 0; i < l.size() && j < to_sort.size(); i += 3, ++j) {\n        l[i] = to_sort[j];\n    }\n    \n    return l;\n}\n\n// Function to test the correctness of sort_third function\nvoid check_function() {\n    vector<int> test1 = {1, 2, 3};\n    vector<int> expected1 = {1, 2, 3};\n    assert(sort_third(test1) == expected1);\n\n    vector<int> test2 = {5, 6, 3, 4, 8, 9, 2};\n    vector<int> expected2 = {2, 6, 3, 4, 8, 9, 5};\n    assert(sort_third(test2) == expected2);\n\n    cout << \"All tests passed successfully.\" << endl;\n}\n\n"}
{"task_id": "CPP/34", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // for std::sort and std::unique\n\nusing namespace std;\n\nvector<int> unique(vector<int> l) {\n    // First, sort the vector so that duplicate elements are adjacent.\n    sort(l.begin(), l.end());\n    \n    // Use std::unique to remove consecutive duplicates. It returns a past-the-end iterator for the new range of unique elements.\n    auto last = unique(l.begin(), l.end());\n    \n    // Erase the non-unique part of the vector\n    l.erase(last, l.end());\n    \n    return l;\n}\n\n// Function to print the contents of a vector\nvoid printVector(const vector<int>& v) {\n    for (int i : v) {\n        cout << i << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/35", "generation": "#include <vector>\n#include <algorithm> // For std::numeric_limits\n\nusing namespace std;\n\nfloat max_element(vector<float> l) {\n    if (l.empty()) {  // Check if the vector is empty to avoid undefined behavior.\n        return numeric_limits<float>::lowest(); // Return the lowest possible float value if the vector is empty\n    }\n\n    float max_val = l[0];  // Initialize max_val with the first element of the vector\n\n    for (size_t i = 1; i < l.size(); ++i) {  // Start from the second element and iterate through the rest\n        if (l[i] > max_val) {\n            max_val = l[i];  // Update max_val if a larger value is found\n        }\n    }\n\n    return max_val;\n}\n"}
{"task_id": "CPP/36", "generation": "#include <iostream>\nusing namespace std;\n\nint fizz_buzz(int n) {\n    int count = 0;\n    \n    for (int i = 1; i < n; ++i) {\n        if ((i % 11 == 0 || i % 13 == 0)) { // Check divisibility by 11 or 13\n            int temp = i;\n            while (temp > 0) {\n                if (temp % 10 == 7) count++; // Count digit '7'\n                temp /= 10; // Move to the next digit\n            }\n        }\n    }\n    \n    return count;\n}\n\n"}
{"task_id": "CPP/37", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // for std::sort\n\nusing namespace std;\n\nvector<float> sort_even(vector<float> l) {\n    vector<float> even_elements;\n    \n    // Extract elements at even indices and store them in a separate vector.\n    for (size_t i = 0; i < l.size(); i += 2) {\n        even_elements.push_back(l[i]);\n    }\n    \n    // Sort the extracted even-indexed elements.\n    sort(even_elements.begin(), even_elements.end());\n    \n    // Place sorted elements back into their original positions in vector `l`.\n    for (size_t i = 0, j = 0; i < l.size(); i += 2) {\n        l[i] = even_elements[j++];\n    }\n    \n    return l;\n}\n\n// Function to test the sort_even function with provided data points.\nvoid check() {\n    vector<float> result;\n\n    // Test case 1\n    result = sort_even({1, 2, 3});\n    for (float num : result) cout << num << \" \";\n    cout << endl; // Expected: 1 2 3\n\n    // Test case 2\n    result = sort_even({5, 6, 3, 4});\n    for (float num : result) cout << num << \" \";\n    cout << endl; // Expected: 3 6 5 4\n}\n\n"}
{"task_id": "CPP/38", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\n// Function to encode a string by cycling groups of three characters.\nstring encode_cyclic(string s) { \n    int l = s.length();\n    string output;\n    for (int i = 0; i * 3 < l; i++) {\n        string x = s.substr(i * 3, 3);\n        if (x.length() == 3) x = x.substr(1) + x[0];\n        output += x;\n    }\n    return output;\n}\n\n// Function to decode a string that was encoded with encode_cyclic.\nstring decode_cyclic(string s) { \n    int l = s.length();\n    string output;\n    for (int i = 0; i * 3 < l; i++) {\n        string x = s.substr(i * 3, 3);\n        if (x.length() == 3) x = x[2] + x.substr(0, 2); // Rotate right\n        output += x;\n    }\n    return output;\n}\n\n"}
{"task_id": "CPP/39", "generation": "#include <stdio.h>\n#include <math.h>\n\n// Function to check if a number is prime\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    if (num == 2 || num == 3) return true;\n    if (num % 2 == 0 || num % 3 == 0) return false;\n\n    for (int i = 5; i * i <= num; i += 6) {\n        if (num % i == 0 || num % (i + 2) == 0)\n            return false;\n    }\n    return true;\n}\n\n// Function to find the n-th Fibonacci number that is also prime\nint prime_fib(int n) {\n    int fib1 = 0, fib2 = 1; // First two Fibonacci numbers\n    int count = 0;\n\n    while (true) {\n        int nextFib = fib1 + fib2;\n        if (is_prime(nextFib)) {\n            count++;\n            if (count == n)\n                return nextFib;\n        }\n        fib1 = fib2;\n        fib2 = nextFib;\n    }\n\n    // This line should never be reached\n    return -1;\n}\n\n"}
{"task_id": "CPP/40", "generation": "#include <vector>\n#include <algorithm> // For std::sort\n\nusing namespace std;\n\nbool triples_sum_to_zero(vector<int> l) {\n    int n = l.size();\n    \n    if (n < 3) return false; // Early exit for vectors with less than 3 elements\n    \n    sort(l.begin(), l.end()); // Sort the vector to use two-pointer technique\n    \n    for(int i = 0; i < n-2; ++i) {\n        int left = i + 1, right = n - 1;\n        \n        while(left < right) {\n            int sum = l[i] + l[left] + l[right];\n            \n            if(sum == 0) return true; // Found three numbers that sum to zero\n            else if(sum < 0) ++left; // Need a larger number, move left pointer to the right\n            else --right; // Need a smaller number, move right pointer to the left\n        }\n    }\n    \n    return false; // No triplet found that sums up to zero\n}\n\n// Example usage:\n"}
{"task_id": "CPP/41", "generation": "#include <iostream>\nusing namespace std;\n\nint car_race_collision(int n) {\n    // Since each left-to-right car will eventually collide with exactly one right-to-left car,\n    // and vice versa, the number of collisions is simply equal to n.\n    return n;\n}\n\n"}
{"task_id": "CPP/42", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> incr_list(vector<int> l) {\n    // Iterate over all elements of the vector.\n    for (size_t i = 0; i < l.size(); ++i) {\n        // Increment each element by 1.\n        l[i] += 1;\n    }\n    return l;\n}\n\n// Function to test the correctness of incr_list function\nvoid check() {\n    vector<int> test1 = {1, 2, 3};\n    vector<int> expected1 = {2, 3, 4};\n    assert(incr_list(test1) == expected1);\n\n    vector<int> test2 = {5, 3, 5, 2, 3, 3, 9, 0, 123};\n    vector<int> expected2 = {6, 4, 6, 3, 4, 4, 10, 1, 124};\n    assert(incr_list(test2) == expected2);\n\n    cout << \"All tests passed successfully.\" << endl;\n}\n\n"}
{"task_id": "CPP/43", "generation": "#include <iostream>\n#include <vector>\n#include <unordered_set> // Use unordered_set for efficient lookup\n\nusing namespace std;\n\nbool pairs_sum_to_zero(vector<int> l) {\n    unordered_set<int> seenNumbers; // Set to keep track of numbers we've seen\n    \n    for (int num : l) { // Iterate through each number in the vector\n        if (seenNumbers.find(-num) != seenNumbers.end()) { // Check if -num is already in the set\n            return true; // Found two numbers that sum to zero\n        }\n        seenNumbers.insert(num); // Add current number to the set\n    }\n    \n    return false; // No pair found that sums to zero\n}\n\n// Function to test the pairs_sum_to_zero function with given data points\nvoid check() {\n    cout << boolalpha; // Print true/false instead of 1/0 for boolean values\n    cout << \"Test Case 1: \" << pairs_sum_to_zero({1, 3, 5, 0}) << endl;\n    cout << \"Test Case 2: \" << pairs_sum_to_zero({1, 3, -2, 1}) << endl;\n    cout << \"Test Case 3: \" << pairs_sum_to_zero({1, 2, 3, 7}) << endl;\n    cout << \"Test Case 4: \" << pairs_sum_to_zero({2, 4, -5, 3, 5, 7}) << endl;\n    cout << \"Test Case 5: \" << pairs_sum_to_zero({1}) << endl;\n}\n\n"}
{"task_id": "CPP/44", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring change_base(int x, int base) {\n    if (base <= 1 || base >= 10) return \"Invalid base\"; // Ensure base is valid\n\n    string result = \"\";\n    while (x > 0) {\n        int remainder = x % base;\n        result = to_string(remainder) + result; // Prepend the remainder\n        x /= base;\n    }\n\n    if(result == \"\") result = \"0\"; // Handle case where x was 0 initially\n\n    return result;\n}\n\n"}
{"task_id": "CPP/45", "generation": "#include<stdio.h>\n\nfloat triangle_area(float a, float h) {\n    // Area of a triangle is 0.5 * base * height\n    return 0.5 * a * h;\n}\n\n"}
{"task_id": "CPP/46", "generation": "#include <iostream>\n#include <vector>\n\nint fib4(int n) {\n    // Base cases for the first four elements of the sequence.\n    if (n == 0 || n == 1)\n        return 0;\n    else if (n == 2)\n        return 2;\n    else if (n == 3)\n        return 0;\n\n    // Initialize an array to store the computed values up to n\n    std::vector<int> fib4_values(n + 1);\n    \n    // Set the base cases.\n    fib4_values[0] = 0;\n    fib4_values[1] = 0;\n    fib4_values[2] = 2;\n    fib4_values[3] = 0;\n\n    // Compute each value from 4 to n using the formula\n    for (int i = 4; i <= n; ++i) {\n        fib4_values[i] = fib4_values[i - 1] + fib4_values[i - 2] + fib4_values[i - 3] + fib4_values[i - 4];\n    }\n\n    // Return the nth value\n    return fib4_values[n];\n}\n\n"}
{"task_id": "CPP/47", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // for std::sort\n\nusing namespace std;\n\nfloat median(vector<float> l){\n    size_t n = l.size();\n    \n    if (n == 0) {\n        throw invalid_argument(\"Vector is empty\");\n    }\n    \n    sort(l.begin(), l.end()); // Sort the vector\n    \n    if (n % 2 != 0) { // If odd number of elements\n        return l[n / 2];\n    } else { // If even number of elements\n        return (l[(n - 1) / 2] + l[n / 2]) / 2.0;\n    }\n}\n\n"}
{"task_id": "CPP/48", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_palindrome(string text) {\n    int left = 0;\n    int right = text.length() - 1;\n\n    while (left < right) {\n        if (text[left] != text[right]) {\n            return false; // Characters do not match\n        }\n        left++;\n        right--;\n    }\n\n    return true; // All characters matched, it's a palindrome\n}\n\n"}
{"task_id": "CPP/49", "generation": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\n// Function to perform modular exponentiation\nint modp(int n, int p) {\n    long long result = 1; // Use long long to avoid overflow issues\n    long long base = 2;\n    \n    while (n > 0) {\n        if (n % 2 == 1) { // If n is odd, multiply the result by the current base value\n            result = (result * base) % p;\n        }\n        base = (base * base) % p; // Square the base and take modulo p to avoid overflow\n        n /= 2; // Divide n by 2 for the next iteration\n    }\n\n    return static_cast<int>(result);\n}\n\n"}
{"task_id": "CPP/50", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nstring encode_shift(string s) {\n    // returns encoded string by shifting every character by 5 in the alphabet.\n    string out;\n    int i;\n    for (i = 0; i < s.length(); i++) {\n        int w = ((int)s[i] + 5 - (int)'a') % 26 + (int)'a';\n        out += (char)w;\n    }\n    return out;\n}\n\nstring decode_shift(string s) {\n    // takes as input string encoded with encode_shift function. Returns decoded string.\n    string out;\n    int i;\n    for (i = 0; i < s.length(); i++) {\n        int w = ((int)s[i] - 5 - (int)'a' + 26) % 26 + (int)'a'; // Adding 26 to ensure positive result\n        out += (char)w;\n    }\n    return out;\n}\n\n// Example usage:\n"}
{"task_id": "CPP/51", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool isVowel(char c) {\n    // Convert character to lowercase for simplicity and check if it's a vowel.\n    char lower_c = tolower(c);\n    return (lower_c == 'a' || lower_c == 'e' || lower_c == 'i' || lower_c == 'o' || lower_c == 'u');\n}\n\nstring remove_vowels(string text) {\n    string result;\n    for(char c : text) {\n        if(!isVowel(c)) { // If the character is not a vowel, add it to the result.\n            result += c;\n        }\n    }\n    return result;\n}\n\n"}
{"task_id": "CPP/52", "generation": "#include <vector>\nusing namespace std;\n\nbool below_threshold(vector<int> l, int t) {\n    // Iterate through each element in the vector\n    for (int num : l) {\n        // If any number is greater than or equal to the threshold, return false\n        if (num >= t) {\n            return false;\n        }\n    }\n    // If all numbers are below the threshold, return true\n    return true;\n}\n\n// Example usage:\n/*\nbool result1 = below_threshold({1, 2, 4, 10}, 100); // Should be true\nbool result2 = below_threshold({1, 20, 4, 10}, 5);   // Should be false\n*/\n"}
{"task_id": "CPP/53", "generation": "#include<iostream>\nusing namespace std;\n\nint add(int x, int y) {\n    return x + y;\n}\n\n// Example usage\n"}
{"task_id": "CPP/54", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nbool same_chars(string s0, string s1) {\n    // Sort both strings to bring identical characters together.\n    sort(s0.begin(), s0.end());\n    sort(s1.begin(), s1.end());\n\n    // Remove duplicate characters from each sorted string.\n    auto last_unique_s0 = unique(s0.begin(), s0.end());\n    auto last_unique_s1 = unique(s1.begin(), s1.end());\n\n    // Erase the duplicates in place to get only unique characters.\n    s0.erase(last_unique_s0, s0.end());\n    s1.erase(last_unique_s1, s1.end());\n\n    // Compare the two strings for equality after processing.\n    return s0 == s1;\n}\n\n"}
{"task_id": "CPP/55", "generation": "#include<stdio.h>\n\nint fib(int n) {\n    if (n <= 1)\n        return n;\n    else\n        return fib(n-1) + fib(n-2);\n}\n\n"}
{"task_id": "CPP/56", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    int balance = 0;\n    \n    for (char c : brackets) {\n        if (c == '<') {\n            ++balance; // Increment for an opening bracket\n        } else if (c == '>') {\n            --balance; // Decrement for a closing bracket\n            \n            // If balance goes below zero, there's an unmatched closing bracket\n            if (balance < 0) return false;\n        }\n    }\n    \n    // Return true only if the balance is back to zero at the end\n    return balance == 0;\n}\n\n"}
{"task_id": "CPP/57", "generation": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nbool isMonotonicIncreasing(const vector<float>& l) {\n    for (size_t i = 1; i < l.size(); ++i) {\n        if (l[i - 1] > l[i]) return false;\n    }\n    return true;\n}\n\nbool isMonotonicDecreasing(const vector<float>& l) {\n    for (size_t i = 1; i < l.size(); ++i) {\n        if (l[i - 1] < l[i]) return false;\n    }\n    return true;\n}\n\nbool monotonic(vector<float> l) {\n    return isMonotonicIncreasing(l) || isMonotonicDecreasing(l);\n}\n"}
{"task_id": "CPP/58", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // For sort function\n#include <set>       // To store unique elements\n\nusing namespace std;\n\nvector<int> common(vector<int> l1, vector<int> l2) {\n    // Sort both vectors to make it easier to find common elements.\n    sort(l1.begin(), l1.end());\n    sort(l2.begin(), l2.end());\n\n    set<int> result;  // Use a set to store unique and sorted results\n    auto it1 = l1.begin();\n    auto it2 = l2.begin();\n\n    // Traverse both vectors to find common elements\n    while (it1 != l1.end() && it2 != l2.end()) {\n        if (*it1 == *it2) {\n            result.insert(*it1);\n            ++it1;\n            ++it2;\n        } else if (*it1 < *it2) {\n            ++it1;\n        } else {\n            ++it2;\n        }\n    }\n\n    // Convert set to vector\n    return vector<int>(result.begin(), result.end());\n}\n\n// Function to print the elements of a vector\nvoid printVector(const vector<int>& vec) {\n    for (int num : vec) {\n        cout << num << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/59", "generation": "#include <stdio.h>\n#include <stdbool.h>\n\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    for (int i = 2; i * i <= num; ++i) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\nint largest_prime_factor(int n){\n    int largestFactor = -1;\n\n    // Divide n by 2 to remove all even factors\n    while (n % 2 == 0) {\n        largestFactor = 2;\n        n /= 2;\n    }\n\n    // Now we only have odd factors left, start from 3 and check each odd number.\n    for (int i = 3; i * i <= n; i += 2) {\n        while (n % i == 0) {\n            largestFactor = i;\n            n /= i;\n        }\n    }\n\n    // If n is a prime number greater than 2\n    if (n > 2)\n        largestFactor = n;\n\n    return largestFactor;\n}\n\n"}
{"task_id": "CPP/60", "generation": "#include<iostream>\nusing namespace std;\n\nint sum_to_n(int n){\n    int sum = 0;\n    for (int i = 1; i <= n; ++i) {\n        sum += i;\n    }\n    return sum;\n}\n\n// Function to test the correctness of sum_to_n\nvoid check_function() {\n    cout << \"sum_to_n(30): \" << sum_to_n(30) << endl; // Expected output: 465\n    cout << \"sum_to_n(100): \" << sum_to_n(100) << endl; // Expected output: 5050\n    cout << \"sum_to_n(5): \" << sum_to_n(5) << endl; // Expected output: 15\n    cout << \"sum_to_n(10): \" << sum_to_n(10) << endl; // Expected output: 55\n    cout << \"sum_to_n(1): \" << sum_to_n(1) << endl; // Expected output: 1\n}\n\n"}
{"task_id": "CPP/61", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    int balance = 0; // Initialize balance counter\n\n    for (char c : brackets) { // Iterate through each character in the string\n        if (c == '(') {\n            ++balance; // Increment balance for an opening bracket\n        } else if (c == ')') {\n            --balance; // Decrement balance for a closing bracket\n            if (balance < 0) return false; // If balance is negative, there's a closing bracket without a matching opening one\n        }\n    }\n\n    return balance == 0; // True if all brackets are correctly matched and balanced\n}\n\n"}
{"task_id": "CPP/62", "generation": "#include <iostream>\n#include <vector>\n\nstd::vector<float> derivative(const std::vector<float>& xs) {\n    // Create an empty vector to store the coefficients of the derivative polynomial\n    std::vector<float> result;\n\n    // Iterate through each coefficient starting from the first non-constant term (index 1)\n    for(size_t i = 1; i < xs.size(); ++i) {\n        // Multiply the current coefficient by its index and add it to the result vector\n        result.push_back(xs[i] * static_cast<float>(i));\n    }\n\n    return result;\n}\n\n// Function to test the derivative function with given examples\nvoid check_derivative() {\n    std::vector<float> example1 = {3, 1, 2, 4, 5};\n    std::vector<float> expected1 = {1, 4, 12, 20};\n    \n    std::vector<float> result1 = derivative(example1);\n    assert(result1 == expected1);\n\n    std::vector<float> example2 = {1, 2, 3};\n    std::vector<float> expected2 = {2, 6};\n\n    std::vector<float> result2 = derivative(example2);\n    assert(result2 == expected2);\n\n    std::cout << \"All tests passed successfully.\" << std::endl;\n}\n\n"}
{"task_id": "CPP/63", "generation": "#include <iostream>\n#include <vector>\n\nint fibfib(int n) {\n    // Base cases\n    if (n == 0 || n == 1)\n        return 0;\n    else if (n == 2)\n        return 1;\n\n    // Initialize a vector to store the computed values of fibfib sequence.\n    std::vector<int> dp(n + 1);\n    dp[0] = 0;   // fibfib(0) is 0\n    dp[1] = 0;   // fibfib(1) is 0\n    dp[2] = 1;   // fibfib(2) is 1\n\n    // Compute the values from 3 to n using the recurrence relation.\n    for (int i = 3; i <= n; ++i)\n        dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3];\n\n    return dp[n];\n}\n\n// Function to test the fibfib function with given data points\nvoid check() {\n    std::cout << \"fibfib(1) should be 0: \" << (fibfib(1) == 0 ? \"Passed\" : \"Failed\") << std::endl;\n    std::cout << \"fibfib(5) should be 4: \" << (fibfib(5) == 4 ? \"Passed\" : \"Failed\") << std::endl;\n    std::cout << \"fibfib(8) should be 24: \" << (fibfib(8) == 24 ? \"Passed\" : \"Failed\") << std::endl;\n}\n\n"}
{"task_id": "CPP/64", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint vowels_count(string s) {\n    int count = 0;\n    // Convert string to lowercase for simplicity\n    transform(s.begin(), s.end(), s.begin(), ::tolower);\n\n    // Check each character in the string\n    for (size_t i = 0; i < s.length(); ++i) {\n        char c = s[i];\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n            count++;\n        }\n        // Check for 'y' at the end of the string\n        else if (c == 'y' && i == s.length() - 1) {\n            count++;\n        }\n    }\n\n    return count;\n}\n\n"}
{"task_id": "CPP/65", "generation": "#include <iostream>\n#include <string>\n#include <algorithm> // for std::reverse\nusing namespace std;\n\nstring circular_shift(int x, int shift) {\n    string digits = to_string(x);\n    size_t num_digits = digits.size();\n    \n    if (shift >= num_digits) {\n        reverse(digits.begin(), digits.end());\n        return digits;\n    }\n    \n    size_t actual_shift = shift % num_digits;\n    \n    rotate(digits.rbegin(), digits.rbegin() + actual_shift, digits.rend());\n    \n    return digits;\n}\n"}
{"task_id": "CPP/66", "generation": "#include <iostream>\n#include <string>\n#include <cctype> // For isupper() function\n\nusing namespace std;\n\nint digitSum(string s) {\n    int sum = 0;\n    for (char c : s) { // Iterate through each character in the string\n        if (isupper(c)) { // Check if the character is an uppercase letter\n            sum += static_cast<int>(c); // Add its ASCII value to sum\n        }\n    }\n    return sum; // Return the total sum of ASCII values of uppercase letters\n}\n\n"}
{"task_id": "CPP/67", "generation": "#include <string>\n#include <sstream>\nusing namespace std;\n\nint fruit_distribution(string s, int n) {\n    stringstream ss(s);\n    string part;\n    int apples = 0, oranges = 0;\n    \n    // Extracting the number of apples and oranges from the string\n    getline(ss, part, ' ');\n    apples = stoi(part); // Convert string to integer for apples\n    \n    getline(ss, part, ' '); // Skip \"apples\"\n    getline(ss, part, ' '); // Skip \"and\"\n    \n    getline(ss, part, ' ');\n    oranges = stoi(part); // Convert string to integer for oranges\n    \n    int mangoes = n - (apples + oranges);\n    return mangoes;\n}\n"}
{"task_id": "CPP/68", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> pluck(vector<int> arr) {\n    int minValue = INT_MAX; // Initialize to a very large number.\n    int minIndex = -1;      // No valid index found initially.\n\n    for (int i = 0; i < arr.size(); ++i) {\n        if (arr[i] % 2 == 0 && arr[i] <= minValue) { // Check if the value is even and smaller or equal to current min.\n            if (arr[i] < minValue || (arr[i] == minValue && i < minIndex)) {\n                minValue = arr[i];\n                minIndex = i;\n            }\n        }\n    }\n\n    if (minIndex != -1) { // If a valid index was found, return the value and its index.\n        return {minValue, minIndex};\n    } else { // No even number found or vector is empty.\n        return {};\n    }\n}\n"}
{"task_id": "CPP/69", "generation": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint search(vector<int> lst) {\n    unordered_map<int, int> freqMap;\n    \n    // Count frequencies of each element in the list\n    for (int num : lst) {\n        freqMap[num]++;\n    }\n    \n    int result = -1;  // Initialize result as -1\n    \n    // Check each frequency against its value\n    for (auto &entry : freqMap) {\n        if (entry.first <= entry.second && entry.first > result) {\n            result = entry.first;\n        }\n    }\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/70", "generation": "#include <vector>\n#include <algorithm>\n\nstd::vector<int> strange_sort_list(std::vector<int> lst) {\n    // Sort the vector initially.\n    std::sort(lst.begin(), lst.end());\n    \n    std::vector<int> result;\n    int left = 0; // Start index for minimum value\n    int right = lst.size() - 1; // End index for maximum value\n    \n    while (left <= right) {\n        if (left == right) {\n            // If there's only one element left, add it to the result.\n            result.push_back(lst[left]);\n            break;\n        }\n        \n        // Add the minimum value\n        result.push_back(lst[left++]);\n        // Add the maximum value\n        result.push_back(lst[right--]);\n    }\n\n    return result;\n}\n\n// Example usage:\n"}
{"task_id": "CPP/71", "generation": "#include<stdio.h>\n#include<math.h>\n\nfloat triangle_area(float a, float b, float c){\n    // Check if sides form a valid triangle\n    if (a + b <= c || a + c <= b || b + c <= a) {\n        return -1;\n    }\n\n    // Calculate the semi-perimeter\n    float s = (a + b + c) / 2;\n\n    // Use Heron's formula to calculate area\n    float area = sqrt(s * (s - a) * (s - b) * (s - c));\n\n    // Round the result to two decimal points and return\n    return round(area * 100) / 100;\n}\n\n"}
{"task_id": "CPP/72", "generation": "#include <vector>\nusing namespace std;\n\nbool will_it_fly(vector<int> q, int w) {\n    // Check if the vector is balanced (palindromic)\n    for(int i = 0; i < q.size() / 2; ++i) {\n        if(q[i] != q[q.size() - 1 - i]) return false;\n    }\n\n    // Calculate the sum of elements in the vector\n    int sum = 0;\n    for(int num : q) {\n        sum += num;\n    }\n\n    // Check if the sum is less than or equal to the maximum possible weight w\n    return sum <= w;\n}\n"}
{"task_id": "CPP/73", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint smallest_change(vector<int> arr) {\n    int changes = 0;\n    int left = 0;\n    int right = arr.size() - 1;\n\n    while (left < right) {\n        if (arr[left] != arr[right]) {\n            ++changes; // Increment the change count when elements don't match\n        }\n        ++left;\n        --right;\n    }\n\n    return changes;\n}\n\n"}
{"task_id": "CPP/74", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to calculate the total number of characters in a vector of strings.\nint countChars(const vector<string>& lst) {\n    int count = 0;\n    for (const string& str : lst) {\n        count += str.length();\n    }\n    return count;\n}\n\nvector<string> total_match(vector<string> lst1, vector<string> lst2) {\n    // Calculate the number of characters in each list\n    int charsInLst1 = countChars(lst1);\n    int charsInLst2 = countChars(lst2);\n\n    // Compare and return the appropriate list\n    if (charsInLst1 <= charsInLst2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n\n// Function to test the solution with given examples.\nvoid check() {\n    vector<string> empty = {};\n    vector<string> result;\n\n    // Example 1\n    result = total_match(empty, empty);\n    cout << \"Example 1: \";\n    for (const string& str : result) cout << str << \" \";\n    cout << endl;\n\n    // Example 2\n    result = total_match({\"hi\", \"admin\"}, {\"hI\", \"Hi\"});\n    cout << \"Example 2: \";\n    for (const string& str : result) cout << str << \" \";\n    cout << endl;\n\n    // Example 3\n    result = total_match({\"hi\", \"admin\"}, {\"hi\", \"hi\", \"admin\", \"project\"});\n    cout << \"Example 3: \";\n    for (const string& str : result) cout << str << \" \";\n    cout << endl;\n\n    // Example 4\n    result = total_match({\"hi\", \"admin\"}, {\"hI\", \"hi\", \"hi\"});\n    cout << \"Example 4: \";\n    for (const string& str : result) cout << str << \" \";\n    cout << endl;\n\n    // Example 5\n    result = total_match({\"4\"}, {\"1\", \"2\", \"3\", \"4\", \"5\"});\n    cout << \"Example 5: \";\n    for (const string& str : result) cout << str << \" \";\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/75", "generation": "#include <iostream>\nusing namespace std;\n\n// Function to check if a number is prime.\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0)\n            return false;\n    }\n    return true;\n}\n\n// Function to check if a number can be expressed as the product of exactly three prime numbers.\nbool is_multiply_prime(int a) {\n    // Iterate through all possible combinations of primes less than 100\n    for (int i = 2; i < 100 && i * i * i <= a; ++i) {\n        if (!is_prime(i)) continue;\n        \n        for (int j = i; j < 100 && i * j * j <= a; ++j) {\n            if (!is_prime(j)) continue;\n\n            for (int k = j; k < 100; ++k) {\n                if (!is_prime(k)) continue;\n                \n                // Check if the product of these three primes equals 'a'\n                if (i * j * k == a)\n                    return true;\n            }\n        }\n    }\n\n    return false;\n}\n\n"}
{"task_id": "CPP/76", "generation": "#include <cmath> // For log and pow functions\n\nbool is_simple_power(int x, int n) {\n    if (n == 1) return x == 1; // Special case: only 1^k = 1 for any k.\n    \n    double log_result = std::log(x) / std::log(n); // Calculate the logarithm of x with base n\n    \n    // Check if the result is an integer by comparing it to its rounded value\n    return std::abs(log_result - std::round(log_result)) < 1e-9; \n}\n\n"}
{"task_id": "CPP/77", "generation": "#include <cmath> // For std::cbrt and std::round\n\nbool iscube(int a) {\n    double cubeRoot = std::cbrt(a); // Calculate the cube root of 'a'\n    int nearestInt = std::round(cubeRoot); // Round to the nearest integer\n    \n    // Check if the cube of the rounded value equals 'a'\n    return (nearestInt * nearestInt * nearestInt == a);\n}\n\n"}
{"task_id": "CPP/78", "generation": "#include <iostream>\n#include <string>\n#include <set>\n\nusing namespace std;\n\nint hex_key(string num) {\n    // Set of prime hexadecimal digits\n    set<char> primes = {'2', '3', '5', '7', 'B', 'D'};\n    \n    int count = 0;\n    for (char c : num) {\n        if (primes.find(c) != primes.end()) {\n            ++count;\n        }\n    }\n    \n    return count;\n}\n\n"}
{"task_id": "CPP/79", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring decimal_to_binary(int decimal) {\n    // Convert the number to binary using bit manipulation.\n    string binary = \"\";\n    \n    if (decimal == 0) {\n        return \"db0db\"; // Special case for zero\n    }\n    \n    while (decimal > 0) {\n        int remainder = decimal % 2;\n        binary = char('0' + remainder) + binary; // Convert the remainder to a character and prepend it.\n        decimal /= 2;\n    }\n\n    return \"db\" + binary + \"db\"; // Add 'db' at both ends\n}\n\n"}
{"task_id": "CPP/80", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_happy(string s) {\n    // Check if the length of the string is less than 3, return false immediately.\n    if (s.length() < 3) {\n        return false;\n    }\n\n    // Iterate through the string to check every set of three consecutive characters\n    for (int i = 0; i <= s.length() - 3; ++i) {\n        // Check if any two out of three consecutive characters are the same.\n        if (s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]) {\n            return false;\n        }\n    }\n\n    // If all checks pass, the string is happy\n    return true;\n}\n\n"}
{"task_id": "CPP/81", "generation": "#include <vector>\n#include <string>\n#include <algorithm>\n\nstd::vector<std::string> grade_equation(std::vector<float> gpas) {\n    std::vector<std::string> letter_grades;\n    \n    for (float gpa : gpas) {\n        if (gpa == 4.0f)\n            letter_grades.push_back(\"A+\");\n        else if (gpa > 3.7f)\n            letter_grades.push_back(\"A\");\n        else if (gpa > 3.3f)\n            letter_grades.push_back(\"A-\");\n        else if (gpa > 3.0f)\n            letter_grades.push_back(\"B+\");\n        else if (gpa > 2.7f)\n            letter_grades.push_back(\"B\");\n        else if (gpa > 2.3f)\n            letter_grades.push_back(\"B-\");\n        else if (gpa > 2.0f)\n            letter_grades.push_back(\"C+\");\n        else if (gpa > 1.7f)\n            letter_grades.push_back(\"C\");\n        else if (gpa > 1.3f)\n            letter_grades.push_back(\"C-\");\n        else if (gpa > 1.0f)\n            letter_grades.push_back(\"D+\");\n        else if (gpa > 0.7f)\n            letter_grades.push_back(\"D\");\n        else if (gpa > 0.0f)\n            letter_grades.push_back(\"D-\");\n        else\n            letter_grades.push_back(\"E\");\n    }\n    \n    return letter_grades;\n}\n"}
{"task_id": "CPP/82", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\n// Helper function to check if a number is prime.\nbool is_prime(int n) {\n    if (n <= 1) return false; // 0 and 1 are not primes\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\n// Main function to check if the length of a string is prime.\nbool prime_length(string str){\n    int len = str.length();\n    return is_prime(len);\n}\n\n"}
{"task_id": "CPP/83", "generation": "#include <cmath> // for pow function\n#include <iostream>\n\nint starts_one_ends(int n) {\n    if (n == 1) {\n        return 1;\n    }\n    long long start_with_1 = static_cast<long long>(pow(10, n - 1));\n    long long end_with_1 = static_cast<long long>(pow(10, n - 1));\n    long long overlap = static_cast<long long>(pow(10, n - 2));\n\n    return 2 * start_with_1 - overlap;\n}\n"}
{"task_id": "CPP/84", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\n// Function to calculate the sum of digits of N\nint sumOfDigits(int N) {\n    int sum = 0;\n    while (N > 0) {\n        sum += N % 10; // Add the last digit to sum\n        N /= 10;       // Remove the last digit from N\n    }\n    return sum;\n}\n\n// Function to convert an integer to its binary string representation\nstring intToBinary(int num) {\n    if (num == 0) return \"0\"; // Special case for zero\n\n    string binary = \"\";\n    while (num > 0) {\n        binary = to_string(num % 2) + binary; // Prepend the remainder of division by 2\n        num /= 2;\n    }\n    return binary;\n}\n\nstring solve(int N){\n    int sumDigits = sumOfDigits(N); // Calculate the sum of digits\n    string resultBinary = intToBinary(sumDigits); // Convert the sum to binary string\n    return resultBinary; // Return the binary representation as a string\n}\n\n// Example usage:\n"}
{"task_id": "CPP/85", "generation": "#include <vector>\nusing namespace std;\n\nint add(vector<int> lst) {\n    int sum = 0;\n    \n    // Iterate through the list with an index starting from 1 (the first odd index)\n    for(int i = 1; i < lst.size(); i += 2) { // Increment by 2 to stay at odd indices\n        if(lst[i] % 2 == 0) { // Check if the element is even\n            sum += lst[i]; // Add it to the sum\n        }\n    }\n\n    return sum;\n}\n"}
{"task_id": "CPP/86", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nstring anti_shuffle(string s) {\n    // Temporary variables to hold the current word and its sorted version.\n    string tempWord = \"\";\n    string result = \"\";\n\n    for (char c : s) {\n        if (c == ' ') {  // If we encounter a space, process the collected word\n            sort(tempWord.begin(), tempWord.end());  // Sort characters in ascending order based on ASCII value\n            result += tempWord + \" \";  // Append sorted word and space to the result\n            tempWord = \"\";  // Reset for next word\n        } else {\n            tempWord += c;  // Collect characters of current word\n        }\n    }\n\n    if (!tempWord.empty()) {  // Process any remaining word after last space or at end of string\n        sort(tempWord.begin(), tempWord.end());\n        result += tempWord;\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/87", "generation": "#include <vector>\n#include <algorithm> // for std::sort\n\nusing namespace std;\n\nbool compare(const vector<int>& a, const vector<int>& b) {\n    if (a[0] != b[0]) return a[0] < b[0]; // sort by row in ascending order\n    else return a[1] > b[1];              // then by column in descending order within the same row\n}\n\nvector<vector<int>> get_row(vector<vector<int>> lst, int x) {\n    vector<vector<int>> coordinates;\n    \n    for (int i = 0; i < lst.size(); ++i) { // iterate through each row\n        for (int j = 0; j < lst[i].size(); ++j) { // iterate through each element in the current row\n            if (lst[i][j] == x) {\n                coordinates.push_back({i, j}); // store the coordinate of found integer\n            }\n        }\n    }\n\n    sort(coordinates.begin(), coordinates.end(), compare); // sort according to specified rules\n\n    return coordinates;\n}\n\n// Example usage:\n"}
{"task_id": "CPP/88", "generation": "#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> sort_array(vector<int> array) {\n    // Check if the vector is empty or contains only one element\n    if (array.size() <= 1) return array;\n    \n    // Calculate the sum of the first and last elements\n    int sum = array.front() + array.back();\n    \n    // Create a copy to avoid modifying the original vector\n    vector<int> sortedArray(array);\n    \n    // Sort based on whether the sum is odd or even\n    if (sum % 2 == 0) {\n        sort(sortedArray.begin(), sortedArray.end(), greater<int>());\n    } else {\n        sort(sortedArray.begin(), sortedArray.end());\n    }\n    \n    return sortedArray;\n}\n\n// Example usage:\n"}
{"task_id": "CPP/89", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring encrypt(string s){\n    for (int i = 0; i < s.length(); ++i) {\n        char c = s[i];\n        \n        // Check if the character is a lowercase letter.\n        if ('a' <= c && c <= 'z') {\n            // Shift by 4 positions and wrap around using modulo operation\n            s[i] = ((c - 'a' + 4) % 26) + 'a';\n        }\n        \n        // Check if the character is an uppercase letter.\n        else if ('A' <= c && c <= 'Z') {\n            // Shift by 4 positions and wrap around using modulo operation\n            s[i] = ((c - 'A' + 4) % 26) + 'A';\n        }\n    }\n    \n    return s;\n}\n\n"}
{"task_id": "CPP/90", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint next_smallest(vector<int> lst) {\n    if (lst.size() < 2) { // If the list has less than two elements, return -1.\n        return -1;\n    }\n\n    sort(lst.begin(), lst.end()); // Sort the vector to find the smallest and second smallest elements easily.\n\n    int first = lst[0]; // The smallest element is now at index 0 after sorting.\n    \n    for (int i = 1; i < lst.size(); ++i) {\n        if (lst[i] != first) { // Find the next unique element which will be the second smallest.\n            return lst[i];\n        }\n    }\n\n    // If all elements are the same, there is no second smallest element.\n    return -1;\n}\n\n"}
{"task_id": "CPP/91", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nint is_bored(string S) {\n    int boredom_count = 0;\n    \n    // Use a stringstream to split the string into sentences.\n    stringstream ss(S);\n    string sentence;\n    char delimiters[] = {'.', '?', '!'};\n\n    while (getline(ss, sentence)) {\n        bool found_delimiter = false;\n\n        for(char delimiter : delimiters) {\n            size_t pos = 0;\n            while ((pos = sentence.find(delimiter, pos)) != string::npos) {\n                // Extract the substring up to the current delimiter.\n                string sub_sentence = sentence.substr(0, pos);\n                \n                // Trim leading spaces from the extracted substring.\n                sub_sentence.erase(0, sub_sentence.find_first_not_of(\" \"));\n                \n                if (!sub_sentence.empty() && sub_sentence[0] == 'I' && (sub_sentence.size() > 1 ? isspace(sub_sentence[1]) : true)) {\n                    boredom_count++;\n                }\n                \n                // Move past the delimiter for next iteration.\n                pos += 1;\n            }\n\n            found_delimiter = true;\n        }\n\n        if (!found_delimiter) {\n            sentence.erase(0, sentence.find_first_not_of(\" \"));\n            \n            if (!sentence.empty() && sentence[0] == 'I' && (sentence.size() > 1 ? isspace(sentence[1]) : true)) {\n                boredom_count++;\n            }\n        }\n    }\n\n    return boredom_count;\n}\n\n"}
{"task_id": "CPP/92", "generation": "#include <iostream>\n#include <cmath>\n\nbool any_int(float a, float b, float c) {\n    // Check if all numbers are integers by comparing them with their floor values.\n    bool is_a_integer = (a == std::floor(a));\n    bool is_b_integer = (b == std::floor(b));\n    bool is_c_integer = (c == std::floor(c));\n\n    // If any of the numbers are not integers, return false\n    if (!is_a_integer || !is_b_integer || !is_c_integer) {\n        return false;\n    }\n\n    // Check if one number equals the sum of the other two.\n    if ((a + b == c) || (b + c == a) || (c + a == b)) {\n        return true;\n    } else {\n        return false;\n    }\n}\n\n"}
{"task_id": "CPP/93", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\n// Function to encode a message according to the given rules.\nstring encode(string message) {\n    // Iterate through each character of the string.\n    for (char &c : message) {\n        // Swap case: if lowercase, convert to uppercase and vice versa.\n        if (islower(c)) c = toupper(c);\n        else if (isupper(c)) c = tolower(c);\n\n        // Replace vowels with the letter that appears 2 places ahead in the alphabet.\n        switch (tolower(c)) {\n            case 'a': c = islower(c) ? 'c' : 'C'; break;\n            case 'e': c = islower(c) ? 'g' : 'G'; break;\n            case 'i': c = islower(c) ? 'k' : 'K'; break;\n            case 'o': c = islower(c) ? 'q' : 'Q'; break;\n            case 'u': c = islower(c) ? 'w' : 'W'; break;\n        }\n    }\n\n    return message;\n}\n\n"}
{"task_id": "CPP/94", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to check if a number is prime\nbool isPrime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\n// Function to calculate the sum of digits of a number\nint sumOfDigits(int num) {\n    int sum = 0;\n    while (num > 0) {\n        sum += num % 10;\n        num /= 10;\n    }\n    return sum;\n}\n\n// Main function to find the largest prime and sum its digits\nint skjkasdkd(vector<int> lst){\n    int maxPrime = -1; // Initialize with a non-prime value\n    \n    // Iterate through the list to find the largest prime number\n    for (int num : lst) {\n        if (isPrime(num)) {\n            maxPrime = max(maxPrime, num);\n        }\n    }\n\n    // If no prime was found, return 0 or handle as needed\n    if (maxPrime == -1) return 0;\n\n    // Calculate and return the sum of digits of the largest prime number\n    return sumOfDigits(maxPrime);\n}\n\n// Function to test the solution with given examples\nvoid check() {\n    cout << skjkasdkd({0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3}) << endl; // 10\n    cout << skjkasdkd({1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1}) << endl; // 25\n    cout << skjkasdkd({1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3}) << endl; // 13\n    cout << skjkasdkd({0,724,32,71,99,32,6,0,5,91,83,0,5,6}) << endl; // 11\n    cout << skjkasdkd({0,81,12,3,1,21}) << endl; // 3\n    cout << skjkasdkd({0,8,1,2,1,7}) << endl; // 7\n}\n\n"}
{"task_id": "CPP/95", "generation": "#include <string>\n#include <map>\n#include <cctype>\n#include <algorithm>\n\nusing namespace std;\n\nbool check_dict_case(map<string, string> dict) {\n    if (dict.empty()) return false;\n\n    bool all_lower = true;\n    bool all_upper = true;\n\n    for (const auto& kv : dict) {\n        const string& key = kv.first;\n        \n        // Check each character in the key\n        for (char ch : key) {\n            if (!islower(ch)) all_lower = false;\n            if (!isupper(ch)) all_upper = false;\n        }\n    }\n\n    return all_lower || all_upper;\n}\n"}
{"task_id": "CPP/96", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// Helper function to check if a number is prime\nbool is_prime(int num) {\n    if (num <= 1) return false; // 0 and 1 are not primes\n    for (int i = 2; i * i <= num; ++i) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\nvector<int> count_up_to(int n){\n    vector<int> primes;\n    \n    // Iterate through all numbers from 2 up to but not including n\n    for (int i = 2; i < n; ++i) {\n        if (is_prime(i)) {\n            primes.push_back(i);\n        }\n    }\n\n    return primes;\n}\n\n// Function to test the implementation with given examples\nvoid check() {\n    vector<int> result;\n\n    result = count_up_to(5); // Expected: {2, 3}\n    for(int num : result) cout << num << \" \";\n    cout << endl;\n\n    result = count_up_to(11); // Expected: {2, 3, 5, 7}\n    for(int num : result) cout << num << \" \";\n    cout << endl;\n\n    result = count_up_to(0); // Expected: {}\n    if(result.empty()) cout << \"{}\" << endl;\n    \n    result = count_up_to(20); // Expected: {2, 3, 5, 7, 11, 13, 17, 19}\n    for(int num : result) cout << num << \" \";\n    cout << endl;\n\n    result = count_up_to(1); // Expected: {}\n    if(result.empty()) cout << \"{}\" << endl;\n    \n    result = count_up_to(18); // Expected: {2, 3, 5, 7, 11, 13, 17}\n    for(int num : result) cout << num << \" \";\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/97", "generation": "#include<stdio.h>\n\nint multiply(int a, int b) {\n    // Extracting the unit digits\n    int unitDigitA = abs(a) % 10;\n    int unitDigitB = abs(b) % 10;\n\n    // Calculating and returning the product of the unit digits\n    return unitDigitA * unitDigitB;\n}\n\n"}
{"task_id": "CPP/98", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint count_upper(string s) {\n    int count = 0;\n    \n    // Iterate through the string with even indices only.\n    for (size_t i = 0; i < s.length(); i += 2) { // Start from index 0 and increment by 2\n        char c = s[i];\n        \n        // Check if it's an uppercase vowel\n        if (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n            count++;\n        }\n    }\n\n    return count;\n}\n\n"}
{"task_id": "CPP/99", "generation": "#include <iostream>\n#include <cmath>\n#include <string>\n\nusing namespace std;\n\nint closest_integer(string value) {\n    // Convert string to double for precision handling\n    double num = stod(value);\n    \n    // Check if the number is positive or negative\n    bool isPositive = num > 0;\n    \n    // Calculate the floor and ceil values of the number\n    int floorValue = static_cast<int>(floor(num));\n    int ceilValue = static_cast<int>(ceil(num));\n    \n    // Determine which integer to round towards based on the distance from the decimal part\n    double fractionalPart = num - floorValue;\n    \n    if (fractionalPart == 0.5) {\n        // If equidistant, round away from zero\n        return isPositive ? ceilValue : floorValue;\n    } else {\n        // Otherwise, use standard rounding rules\n        return static_cast<int>(round(num));\n    }\n}\n\n// Function to test the closest_integer function with given examples\nvoid check() {\n    cout << \"Testing '10': Expected 10, Got: \" << closest_integer(\"10\") << endl;\n    cout << \"Testing '15.3': Expected 15, Got: \" << closest_integer(\"15.3\") << endl;\n    cout << \"Testing '14.5': Expected 15, Got: \" << closest_integer(\"14.5\") << endl;\n    cout << \"Testing '-14.5': Expected -15, Got: \" << closest_integer(\"-14.5\") << endl;\n}\n\n"}
{"task_id": "CPP/100", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> make_a_pile(int n) {\n    vector<int> pile;\n    \n    // Start with the first level having 'n' stones.\n    int current_stones = n;\n    \n    for (int i = 0; i < n; ++i) {\n        pile.push_back(current_stones);\n        \n        // Determine the next number of stones based on whether current is odd or even\n        if (current_stones % 2 == 0) { // If current_stones is even, add 2 to get the next even number.\n            current_stones += 2;\n        } else { // If current_stones is odd, add 2 to get the next odd number.\n            current_stones += 2;\n        }\n    }\n\n    return pile;\n}\n\n// Example usage\n"}
{"task_id": "CPP/101", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> words_string(string s) {\n    vector<string> result;\n    string word = \"\";\n    \n    for (char c : s) {\n        if (c == ' ' || c == ',') {  // Check if the character is a space or comma\n            if (!word.empty()) {      // If there's a word, add it to the result vector\n                result.push_back(word);\n                word = \"\";            // Reset the word for the next iteration\n            }\n        } else {\n            word += c;  // Append the current character to the word\n        }\n    }\n\n    if (!word.empty()) {  // Add any remaining word after the loop ends\n        result.push_back(word);\n    }\n\n    return result;\n}\n\n// Function to test the implementation with example inputs\nvoid check() {\n    vector<string> res1 = words_string(\"Hi, my name is John\");\n    for (string s : res1) cout << s << \" \";\n    cout << endl;\n\n    vector<string> res2 = words_string(\"One, two, three, four, five, six\");\n    for (string s : res2) cout << s << \" \";\n}\n\n"}
{"task_id": "CPP/102", "generation": "#include<iostream>\nusing namespace std;\n\nint choose_num(int x, int y) {\n    // Check if the range is valid.\n    if (y < x)\n        return -1;\n    \n    // If 'y' itself is even and within the range, return it.\n    if (y % 2 == 0 && y >= x)\n        return y;\n\n    // Otherwise, check for the next lower number that could be even.\n    int candidate = y - 1;\n    while(candidate >= x) {\n        if (candidate % 2 == 0)\n            return candidate;\n        --candidate; // Move to the next lower number\n    }\n\n    // If no even number is found in the range, return -1.\n    return -1;\n}\n\n"}
{"task_id": "CPP/103", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\n// Function to convert an integer to a binary string\nstring int_to_binary(int num) {\n    if (num == 0) return \"0\";\n    string binary = \"\";\n    while (num > 0) {\n        binary = (num % 2 == 0 ? \"0\" : \"1\") + binary;\n        num /= 2;\n    }\n    return binary;\n}\n\nstring rounded_avg(int n, int m) {\n    if (n > m) return \"-1\";\n    \n    // Calculate the sum of integers from n to m\n    long long sum = ((long long)m * (m + 1) - (n * (n - 1))) / 2;\n    int count = m - n + 1; // Number of terms\n    \n    // Compute average and round down\n    int avg = sum / count;\n    \n    // Convert to binary string\n    return int_to_binary(avg);\n}\n\n"}
{"task_id": "CPP/104", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to check if a number contains only odd digits.\nbool hasOnlyOddDigits(int num) {\n    while (num > 0) {\n        int digit = num % 10;\n        if (digit % 2 == 0) return false; // If any digit is even, return false\n        num /= 10;\n    }\n    return true;\n}\n\nvector<int> unique_digits(vector<int> x) {\n    vector<int> result;\n\n    // Filter numbers that have only odd digits.\n    for (int num : x) {\n        if (hasOnlyOddDigits(num)) {\n            result.push_back(num);\n        }\n    }\n\n    // Sort the filtered numbers in increasing order\n    sort(result.begin(), result.end());\n\n    return result;\n}\n\n// Function to test the solution with given examples\nvoid check() {\n    vector<int> test1 = {15, 33, 1422, 1};\n    vector<int> expected1 = {1, 15, 33};\n    assert(unique_digits(test1) == expected1);\n\n    vector<int> test2 = {152, 323, 1422, 10};\n    vector<int> expected2 = {};\n    assert(unique_digits(test2) == expected2);\n    \n    cout << \"All tests passed successfully.\" << endl;\n}\n\n"}
{"task_id": "CPP/105", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\n\nusing namespace std;\n\nvector<string> by_length(vector<int> arr) {\n    // Map to store the digit-to-name mapping.\n    map<int, string> numberNames = {\n        {1, \"One\"}, {2, \"Two\"}, {3, \"Three\"},\n        {4, \"Four\"}, {5, \"Five\"}, {6, \"Six\"},\n        {7, \"Seven\"}, {8, \"Eight\"}, {9, \"Nine\"}\n    };\n\n    // Filter out numbers not between 1 and 9.\n    vector<int> filteredArr;\n    for (int num : arr) {\n        if (num >= 1 && num <= 9) {\n            filteredArr.push_back(num);\n        }\n    }\n\n    // Sort the filtered array.\n    sort(filteredArr.begin(), filteredArr.end());\n\n    // Reverse the sorted array.\n    reverse(filteredArr.begin(), filteredArr.end());\n\n    // Replace each digit with its corresponding name.\n    vector<string> result;\n    for (int num : filteredArr) {\n        result.push_back(numberNames[num]);\n    }\n\n    return result;\n}\n\n// Function to test the solution\nvoid check() {\n    vector<int> arr1 = {2, 1, 1, 4, 5, 8, 2, 3};\n    vector<string> expected1 = {\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"};\n    assert(by_length(arr1) == expected1);\n\n    vector<int> arr2 = {};\n    vector<string> expected2 = {};\n    assert(by_length(arr2) == expected2);\n\n    vector<int> arr3 = {1, -1, 55};\n    vector<string> expected3 = {\"One\"};\n    assert(by_length(arr3) == expected3);\n\n    cout << \"All tests passed successfully.\" << endl;\n}\n\n"}
{"task_id": "CPP/106", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// Function to calculate factorial\nint factorial(int num) {\n    int result = 1;\n    for (int i = 2; i <= num; ++i) {\n        result *= i;\n    }\n    return result;\n}\n\n// Function to calculate the sum of numbers from 1 to num\nint sumToN(int num) {\n    return (num * (num + 1)) / 2;\n}\n\nvector<int> f(int n) {\n    vector<int> result(n);\n    \n    for (int i = 0; i < n; ++i) {\n        if ((i + 1) % 2 == 0) { // Check if the index+1 is even\n            result[i] = factorial(i + 1); // Calculate factorial\n        } else {\n            result[i] = sumToN(i + 1); // Calculate sum from 1 to i+1\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/107", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\n// Function to check if a number is a palindrome\nbool isPalindrome(int num) {\n    string str = to_string(num);\n    int len = str.length();\n    for (int i = 0; i < len / 2; ++i) {\n        if (str[i] != str[len - i - 1]) return false;\n    }\n    return true;\n}\n\nvector<int> even_odd_palindrome(int n){\n    vector<int> result(2, 0); // Initialize a vector with two elements set to zero\n    for (int i = 1; i <= n; ++i) {\n        if (isPalindrome(i)) { // Check if the number is a palindrome\n            if (i % 2 == 0) {\n                result[0]++; // Increment even count\n            } else {\n                result[1]++; // Increment odd count\n            }\n        }\n    }\n    return result;\n}\n\n"}
{"task_id": "CPP/108", "generation": "#include <vector>\n#include <cmath>\n#include <algorithm>\n\nint sum_of_digits(int num) {\n    int sum = 0;\n    bool is_negative = num < 0;\n    while (num != 0) {\n        int digit = num % 10;\n        if (is_negative && sum == 0)\n            digit *= -1; // Only the first signed digit will be negative\n        sum += digit;\n        num /= 10;\n    }\n    return sum;\n}\n\nint count_nums(std::vector<int> n) {\n    int count = 0;\n    for (const auto& num : n) {\n        if (sum_of_digits(num) > 0)\n            ++count;\n    }\n    return count;\n}\n"}
{"task_id": "CPP/109", "generation": "#include <vector>\nusing namespace std;\n\nbool move_one_ball(vector<int> arr) {\n    if (arr.empty()) return true;\n    \n    int n = arr.size();\n    int disorder_count = 0;\n    \n    // Check for disorder points\n    for (int i = 1; i < n; ++i) {\n        if (arr[i] < arr[i - 1]) {\n            disorder_count++;\n        }\n    }\n\n    // Special case: check the wrap-around condition between last and first element\n    if (disorder_count == 0 || (disorder_count == 1 && arr[n-1] <= arr[0])) {\n        return true;\n    } else {\n        return false;\n    }\n}\n"}
{"task_id": "CPP/110", "generation": "#include <vector>\n#include <string>\nusing namespace std;\n\nstring exchange(vector<int> lst1, vector<int> lst2) {\n    // Count odd numbers in lst1 and even numbers in lst2.\n    int oddCountInLst1 = 0;\n    for (int num : lst1) {\n        if (num % 2 != 0) {\n            ++oddCountInLst1;\n        }\n    }\n\n    int evenCountInLst2 = 0;\n    for (int num : lst2) {\n        if (num % 2 == 0) {\n            ++evenCountInLst2;\n        }\n    }\n\n    // If there are enough even numbers in lst2 to replace all odd numbers in lst1, return \"YES\".\n    if (oddCountInLst1 <= evenCountInLst2) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n"}
{"task_id": "CPP/111", "generation": "#include <iostream>\n#include <string>\n#include <map>\n#include <sstream> // For std::istringstream\n\nusing namespace std;\n\nmap<char, int> histogram(string test) {\n    map<char, int> charCount;\n    map<char, int> result;\n    \n    if (test.empty()) return result; // Return empty map for empty input\n    \n    istringstream iss(test);\n    string word;\n    \n    // Count occurrences of each character\n    while (iss >> word && !word.empty()) {\n        ++charCount[word[0]];\n    }\n    \n    int maxCount = 0;\n    \n    // Find the maximum count\n    for (const auto& pair : charCount) {\n        if (pair.second > maxCount) {\n            maxCount = pair.second;\n        }\n    }\n    \n    // Collect characters with the maximum count into result map\n    for (const auto& pair : charCount) {\n        if (pair.second == maxCount) {\n            result.insert(pair);\n        }\n    }\n    \n    return result;\n}\n\n// Function to print the map for testing purposes\nvoid printMap(const map<char, int>& m) {\n    for (const auto& pair : m) {\n        cout << \"{\" << pair.first << \", \" << pair.second << \"} \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/112", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nbool is_palindrome(const string& str) {\n    int n = str.size();\n    for (int i = 0; i < n / 2; ++i) {\n        if (str[i] != str[n - i - 1]) return false;\n    }\n    return true;\n}\n\nvector<string> reverse_delete(string s, string c) {\n    // Remove characters from `s` that are present in `c`\n    string result_string = \"\";\n    for (char ch : s) {\n        if (c.find(ch) == string::npos) {\n            result_string += ch;\n        }\n    }\n\n    // Check if the resulting string is a palindrome\n    bool is_palindrome_result = is_palindrome(result_string);\n\n    vector<string> res{result_string, is_palindrome_result ? \"True\" : \"False\"};\n    return res;\n}\n"}
{"task_id": "CPP/113", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nstd::vector<std::string> odd_count(std::vector<std::string> lst) {\n    std::vector<std::string> result;\n    for (const auto& s : lst) {\n        int num_odds = 0;\n        for (char c : s) {\n            if (c == '1' || c == '3' || c == '5' || c == '7' || c == '9') {\n                ++num_odds;\n            }\n        }\n\n        std::string new_str = \"the number of odd elements \";\n        for (int i = 0; i < 4; ++i) { // Replace all placeholders with the count\n            if (i == 1)\n                new_str += std::to_string(num_odds);\n            else {\n                new_str += std::to_string(num_odds);\n                new_str += \"n\";\n            }\n        }\n\n        new_str += \"the str\";\n        new_str += std::to_string(num_odds);\n        new_str += \"ng \";\n        new_str += std::to_string(num_odds);\n        new_str += \" of the \";\n        new_str += std::to_string(num_odds);\n        new_str += \"nput.\";\n        \n        result.push_back(new_str);\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/114", "generation": "#include <iostream>\n#include <vector>\n#include <climits> // For INT_MAX\n\nusing namespace std;\n\nlong long minSubArraySum(vector<long long> nums) {\n    if (nums.empty()) return 0; // Handle empty vector case\n    \n    long long currentSum = 0;\n    long long minSum = LLONG_MAX; // Initialize to the largest possible value\n    \n    for (auto num : nums) {\n        currentSum += num;\n        \n        // Update minSum if currentSum is smaller\n        if (currentSum < minSum)\n            minSum = currentSum;\n            \n        // Reset currentSum to 0 if it becomes non-negative\n        if (currentSum >= 0)\n            currentSum = 0;\n    }\n    \n    return minSum;\n}\n\n"}
{"task_id": "CPP/115", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint max_fill(vector<vector<int>> grid, int capacity) {\n    int total_drops = 0;\n    \n    // Iterate over each well (row)\n    for (auto& row : grid) {\n        int water_units = 0;\n        \n        // Count the number of units of water in this well\n        for (int unit : row) {\n            if (unit == 1) {\n                ++water_units;\n            }\n        }\n        \n        // Calculate how many times we need to lower the bucket for this well\n        int drops_for_well = (water_units + capacity - 1) / capacity; // Equivalent to ceil(water_units / capacity)\n        \n        total_drops += drops_for_well;\n    }\n    \n    return total_drops;\n}\n\n"}
{"task_id": "CPP/116", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to count the number of 1s in binary representation of a number.\nint countOnes(int n) {\n    int ones = 0;\n    while (n != 0) {\n        if (n % 2 == 1)\n            ++ones;\n        n /= 2;\n    }\n    return ones;\n}\n\n// Comparator function for sorting based on the number of ones and then by value.\nbool compare(int a, int b) {\n    int countA = countOnes(abs(a));\n    int countB = countOnes(abs(b));\n\n    if (countA == countB)\n        return a < b; // If same number of 1s, sort by decimal value\n    else\n        return countA < countB; // Otherwise, sort by the number of 1s\n}\n\nvector<int> sort_array(vector<int> arr) {\n    sort(arr.begin(), arr.end(), compare);\n    return arr;\n}\n\n"}
{"task_id": "CPP/117", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Helper function to count consonants in a word\nint count_consonants(const string& word) {\n    int count = 0;\n    for (char ch : word) {\n        // Convert character to lowercase and check if it's a consonant\n        char lower_ch = tolower(ch);\n        if ((lower_ch >= 'a' && lower_ch <= 'z') && !(lower_ch == 'a' || lower_ch == 'e' || lower_ch == 'i' || lower_ch == 'o' || lower_ch == 'u')) {\n            count++;\n        }\n    }\n    return count;\n}\n\nvector<string> select_words(string s, int n) {\n    vector<string> result;\n    string word = \"\";\n    \n    // Split the string into words and check consonant count\n    for (char ch : s) {\n        if (ch == ' ') {\n            if (!word.empty()) {\n                if (count_consonants(word) == n) {\n                    result.push_back(word);\n                }\n                word = \"\";  // Reset word after processing it\n            }\n        } else {\n            word += ch;\n        }\n    }\n\n    // Check the last word in case there's no trailing space\n    if (!word.empty()) {\n        if (count_consonants(word) == n) {\n            result.push_back(word);\n        }\n    }\n\n    return result;\n}\n\n// Function to test the implementation with given examples\nvoid check() {\n    vector<string> res;\n\n    res = select_words(\"Mary had a little lamb\", 4);\n    for (const auto& word : res) cout << word << \" \";\n    cout << endl; // Expected: {\"little\"}\n\n    res = select_words(\"Mary had a little lamb\", 3);\n    for (const auto& word : res) cout << word << \" \";\n    cout << endl; // Expected: {\"Mary\", \"lamb\"}\n\n    res = select_words(\"simple white space\", 2);\n    for (const auto& word : res) cout << word << \" \";\n    cout << endl; // Expected: {}\n\n    res = select_words(\"Hello world\", 4);\n    for (const auto& word : res) cout << word << \" \";\n    cout << endl; // Expected: {\"world\"}\n\n    res = select_words(\"Uncle sam\", 3);\n    for (const auto& word : res) cout << word << \" \";\n    cout << endl; // Expected: {\"Uncle\"}\n}\n\n"}
{"task_id": "CPP/118", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_vowel(char c) {\n    string vowels = \"aeiouAEIOU\";\n    return vowels.find(c) != string::npos;\n}\n\nstring get_closest_vowel(string word){\n    int len = word.length();\n    \n    // Iterate from the end of the string to the beginning\n    for (int i = len - 2; i > 0; --i) {\n        // Check if current character is a vowel and surrounded by consonants\n        if (is_vowel(word[i]) && !is_vowel(word[i-1]) && !is_vowel(word[i+1])) {\n            return string(1, word[i]);\n        }\n    }\n    \n    // Return empty string if no such vowel found\n    return \"\";\n}\n\n"}
{"task_id": "CPP/119", "generation": "#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nbool is_balanced(const string& s) {\n    int balance = 0;\n    for (char c : s) {\n        if (c == '(') {\n            ++balance;\n        } else {\n            --balance;\n            if (balance < 0) {\n                return false;\n            }\n        }\n    }\n    return balance == 0;\n}\n\nstring match_parens(vector<string> lst) {\n    string first_concatenation = lst[0] + lst[1];\n    string second_concatenation = lst[1] + lst[0];\n\n    if (is_balanced(first_concatenation) || is_balanced(second_concatenation)) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\n"}
{"task_id": "CPP/120", "generation": "#include <vector>\n#include <algorithm> // for std::sort\n\nusing namespace std;\n\nvector<int> maximum(vector<int> arr, int k) {\n    // Step 1: Sort the array in ascending order.\n    sort(arr.begin(), arr.end());\n    \n    // Step 2: Extract the last k elements from the sorted vector.\n    vector<int> result;\n    for (int i = arr.size() - k; i < arr.size(); ++i) {\n        result.push_back(arr[i]);\n    }\n    \n    return result;\n}\n\n// Example usage:\n/*\nvector<int> example1 = {-3, -4, 5};\nvector<int> output1 = maximum(example1, 3); // Output: {-4, -3, 5}\n\nvector<int> example2 = {4, -4, 4};\nvector<int> output2 = maximum(example2, 2); // Output: {4, 4}\n\nvector<int> example3 = {-3, 2, 1, 2, -1, -2, 1};\nvector<int> output3 = maximum(example3, 1); // Output: {2}\n*/\n"}
{"task_id": "CPP/121", "generation": "#include <vector>\nusing namespace std;\n\nint solution(vector<int> lst) {\n    int sum = 0;\n    \n    // Iterate through the vector with a step of 2 to check even positions (0-indexed)\n    for(int i = 0; i < lst.size(); i += 2) {\n        if(lst[i] % 2 != 0) { // Check if the element is odd\n            sum += lst[i];\n        }\n    }\n    \n    return sum;\n}\n"}
{"task_id": "CPP/122", "generation": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint add_elements(vector<int> arr, int k) {\n    int sum = 0;\n    for (int i = 0; i < k; ++i) {\n        if (arr[i] >= -99 && arr[i] <= 99) {\n            sum += arr[i];\n        }\n    }\n    return sum;\n}\n"}
{"task_id": "CPP/123", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // For std::sort\n\nusing namespace std;\n\nvector<int> get_odd_collatz(int n) {\n    vector<int> oddNumbers;\n    \n    while (n != 1) {\n        if (n % 2 == 1) { // Check if the number is odd\n            oddNumbers.push_back(n);\n        }\n        if (n % 2 == 0) { // If even, divide by 2\n            n /= 2;\n        } else { // If odd, apply the Collatz formula\n            n = 3 * n + 1;\n        }\n    }\n    \n    // Add the last number in the sequence which is always 1 and is odd.\n    oddNumbers.push_back(1);\n    \n    // Sort the vector of odd numbers before returning it.\n    sort(oddNumbers.begin(), oddNumbers.end());\n    \n    return oddNumbers;\n}\n\n// Function to test the get_odd_collatz function\nvoid check() {\n    vector<int> result = get_odd_collatz(5);\n    for (int num : result) {\n        cout << num << \" \";\n    }\n    // Expected output: 1 5\n    cout << endl;\n    \n    result = get_odd_collatz(7); \n    for (int num : result) {\n        cout << num << \" \";\n    }\n    // Expected output: 1 7 11 22\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/124", "generation": "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nbool valid_date(const string& date) {\n    // Check if the date string is empty or not in mm-dd-yyyy format.\n    if (date.length() != 10 || date[2] != '-' || date[5] != '-') return false;\n    \n    vector<int> days_in_month = {31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\n    \n    // Extract month, day and year from the date string.\n    int month = stoi(date.substr(0, 2));\n    int day = stoi(date.substr(3, 2));\n    int year = stoi(date.substr(6, 4));\n\n    // Validate month\n    if (month < 1 || month > 12) return false;\n\n    // Validate day based on the month and leap year for February.\n    if (day < 1 || day > days_in_month[month - 1]) return false;\n    \n    // Special case for February in a non-leap year\n    if (month == 2 && day == 29) {\n        bool is_leap_year = ((year % 4 == 0 && year % 100 != 0) || (year % 400 == 0));\n        if (!is_leap_year) return false;\n    }\n\n    // If all checks pass, the date is valid.\n    return true;\n}\n\n"}
{"task_id": "CPP/125", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <cctype>\n\nusing namespace std;\n\nvector<string> split_words(string txt) {\n    if (txt.find(' ') != string::npos) {\n        stringstream ss(txt);\n        vector<string> words;\n        string word;\n\n        while (getline(ss, word, ' ')) {\n            words.push_back(word);\n        }\n        return words;\n    } else if (txt.find(',') != string::npos) {\n        stringstream ss(txt);\n        vector<string> words;\n        string word;\n\n        while (getline(ss, word, ',')) {\n            words.push_back(word);\n        }\n        return words;\n    } else {\n        int count = 0;\n        for (char c : txt) {\n            if (islower(c)) {\n                if ((c - 'a') % 2 == 1) { // Check for odd order in the alphabet\n                    ++count;\n                }\n            }\n        }\n        return {to_string(count)};\n    }\n}\n"}
{"task_id": "CPP/126", "generation": "#include <vector>\n#include <algorithm>\n\nbool is_sorted(std::vector<int> lst) {\n    // Check if the list is empty or has only one element, which is always sorted.\n    if (lst.size() <= 1) return true;\n\n    int count = 1; // To keep track of how many times a number appears consecutively.\n\n    for (size_t i = 1; i < lst.size(); ++i) {\n        // If the current element is less than the previous one, it's not sorted.\n        if (lst[i] < lst[i - 1]) return false;\n\n        // Check how many times a number appears consecutively.\n        if (lst[i] == lst[i - 1]) {\n            count++;\n            // If any number appears more than twice, return false.\n            if (count > 2) return false;\n        } else {\n            count = 1; // Reset the counter for different numbers.\n        }\n    }\n\n    return true;\n}\n"}
{"task_id": "CPP/127", "generation": "#include <vector>\n#include <string>\n#include <cmath>\nusing namespace std;\n\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\nstring intersection(vector<int> interval1, vector<int> interval2) {\n    int start_max = max(interval1[0], interval2[0]);\n    int end_min = min(interval1[1], interval2[1]);\n\n    if (start_max > end_min) {\n        return \"NO\";\n    }\n\n    int intersection_length = end_min - start_max + 1;\n\n    if (is_prime(intersection_length)) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n"}
{"task_id": "CPP/128", "generation": "#include <vector>\n#include <cmath> // For std::abs\n\nint prod_signs(std::vector<int> arr) {\n    if (arr.empty()) return -32768; // Return special value for empty vector\n    \n    int signProduct = 1;\n    int magnitudeSum = 0;\n\n    for (auto num : arr) {\n        magnitudeSum += std::abs(num); // Sum of magnitudes\n        if (num == 0) { \n            signProduct = 0; // If any number is zero, the product of signs will be zero.\n            break;\n        } else if (num < 0) {\n            signProduct *= -1; // Multiply by -1 for negative numbers\n        }\n    }\n\n    return magnitudeSum * signProduct;\n}\n\n// Example usage:\n"}
{"task_id": "CPP/129", "generation": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint N;\nvector<int> minPath(vector<vector<int>> grid, int k) {\n    function<bool(int, int, vector<int>&)> dfs = [&](int x, int y, vector<int>& result) -> bool {\n        if (result.size() == k) return true;\n        \n        const vector<pair<int, int>> directions{{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n        for (const auto& dir : directions) {\n            int nx = x + dir.first, ny = y + dir.second;\n            if (nx >= 0 && nx < N && ny >= 0 && ny < N) {\n                result.push_back(grid[nx][ny]);\n                if (dfs(nx, ny, result)) return true;\n                result.pop_back();\n            }\n        }\n        \n        return false;\n    };\n    \n    vector<int> min_path(k + 1);\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            vector<int> result{k};\n            result[0] = grid[i][j];\n            if (dfs(i, j, result)) {\n                if (min_path.empty() || result < min_path) {\n                    min_path = result;\n                }\n            }\n        }\n    }\n\n    return vector<int>(min_path.begin(), min_path.begin() + k);\n}\n"}
{"task_id": "CPP/130", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> tri(int n) {\n    if (n == 0) \n        return {1};\n\n    // Initialize the sequence with known values.\n    vector<int> tribonacci(n + 1, 0);\n    \n    tribonacci[0] = 1;\n    tribonacci[1] = 3;\n\n    for (int i = 2; i <= n; ++i) {\n        if (i % 2 == 0) {\n            tribonacci[i] = 1 + i / 2;\n        } else {\n            // Handle the case where we need to calculate tri(n+1) which is out of bounds.\n            if (i + 1 <= n)\n                tribonacci[i] = tribonacci[i - 1] + tribonacci[i - 2] + tribonacci[i + 1];\n            else\n                // Calculate tri(n+1) recursively when it's not yet in the list\n                tribonacci[i] = tribonacci[i - 1] + tribonacci[i - 2] + (1 + (i + 1) / 2);\n        }\n    }\n\n    return tribonacci;\n}\n\n"}
{"task_id": "CPP/131", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint digits(int n) {\n    string numStr = to_string(n); // Convert integer to string for easy digit access\n    int product = 1; // Initialize product with 1\n    \n    bool hasOddDigit = false;\n    \n    for (char c : numStr) { // Iterate through each character in the string\n        int digit = c - '0'; // Convert char to int\n        \n        if (digit % 2 != 0) { // Check if the digit is odd\n            product *= digit; // Multiply it into the product\n            hasOddDigit = true;\n        }\n    }\n    \n    return hasOddDigit ? product : 0; // Return product or 0 based on whether there was an odd digit\n}\n\n"}
{"task_id": "CPP/132", "generation": "#include <string>\nusing namespace std;\n\nbool is_nested(string str) {\n    int max_depth = 0;\n    int current_depth = 0;\n\n    for (char c : str) {\n        if (c == '[') {\n            current_depth += 1;\n            max_depth = max(max_depth, current_depth);\n        } else if (c == ']') {\n            current_depth -= 1;\n        }\n\n        // If at any point the depth is less than zero, it means there are more closing brackets than opening ones.\n        if (current_depth < 0) {\n            return false;\n        }\n    }\n\n    // A valid nested subsequence must have a maximum depth greater than one\n    return max_depth > 1 && current_depth == 0;\n}\n"}
{"task_id": "CPP/133", "generation": "#include <iostream>\n#include <vector>\n#include <cmath> // for ceil and pow functions\n\nusing namespace std;\n\nint sum_squares(vector<float> lst){\n    int sum = 0;\n    for (float num : lst) {\n        float ceilingValue = ceil(num); // Round up to the nearest integer\n        sum += pow(ceilingValue, 2); // Square it and add to sum\n    }\n    return sum;\n}\n\n"}
{"task_id": "CPP/134", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool check_if_last_char_is_a_letter(string txt) {\n    // Check if string is empty or ends with a space.\n    if (txt.empty() || txt.back() == ' ') return false;\n    \n    // Get the last character of the string.\n    char lastChar = txt.back();\n    \n    // Check if it's an alphabetical character and not part of a word.\n    bool isAlphabetical = isalpha(lastChar);\n    bool isNotPartOfWord = (txt.size() == 1 || txt[txt.size()-2] == ' ');\n    \n    return isAlphabetical && isNotPartOfWord;\n}\n\n"}
{"task_id": "CPP/135", "generation": "#include <vector>\nusing namespace std;\n\nint can_arrange(vector<int> arr) {\n    for (size_t i = 1; i < arr.size(); ++i) {\n        if (arr[i] < arr[i - 1]) {\n            return static_cast<int>(i);\n        }\n    }\n    return -1;\n}\n"}
{"task_id": "CPP/136", "generation": "#include <vector>\n#include <algorithm> // For std::min and std::max\n\nusing namespace std;\n\nvector<int> largest_smallest_integers(vector<int> lst){\n    int largestNegative = 0;\n    int smallestPositive = 0;\n    \n    bool foundNegative = false;\n    bool foundPositive = false;\n    \n    for(int num : lst) {\n        if(num < 0) {\n            // Update the largest negative number\n            if(!foundNegative || num > largestNegative) {\n                largestNegative = num;\n                foundNegative = true;\n            }\n        } else if (num > 0) {\n            // Update the smallest positive number\n            if(!foundPositive || num < smallestPositive) {\n                smallestPositive = num;\n                foundPositive = true;\n            }\n        }\n    }\n\n    return {largestNegative, smallestPositive};\n}\n\n// Example usage:\n"}
{"task_id": "CPP/137", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <cmath>\n\nusing namespace std;\n\nboost::any compare_one(boost::any a, boost::any b) {\n    float a_val = 0.0f;\n    float b_val = 0.0f;\n\n    // Convert string to float if necessary\n    if (a.type() == typeid(string)) {\n        string str_a = any_cast<string>(a);\n        replace(str_a.begin(), str_a.end(), ',', '.');\n        a_val = stof(str_a);\n    } else if (a.type() == typeid(int)) {\n        a_val = static_cast<float>(any_cast<int>(a));\n    } else if (a.type() == typeid(float)) {\n        a_val = any_cast<float>(a);\n    }\n\n    // Convert string to float if necessary\n    if (b.type() == typeid(string)) {\n        string str_b = any_cast<string>(b);\n        replace(str_b.begin(), str_b.end(), ',', '.');\n        b_val = stof(str_b);\n    } else if (b.type() == typeid(int)) {\n        b_val = static_cast<float>(any_cast<int>(b));\n    } else if (b.type() == typeid(float)) {\n        b_val = any_cast<float>(b);\n    }\n\n    // Compare the values\n    if (a_val > b_val) {\n        return a;\n    } else if (b_val > a_val) {\n        return b;\n    } else {\n        return string(\"None\");\n    }\n}\n\n"}
{"task_id": "CPP/138", "generation": "#include <iostream>\nusing namespace std;\n\nbool is_equal_to_sum_even(int n) {\n    // Check if n is at least 8 and an even number.\n    return (n >= 8 && n % 2 == 0);\n}\n\n"}
{"task_id": "CPP/139", "generation": "#include <iostream>\nusing namespace std;\n\n// Function to calculate factorial of a given number\nlong long factorial(int num) {\n    if (num == 0 || num == 1)\n        return 1;\n    else\n        return num * factorial(num - 1);\n}\n\n// Function to calculate the Brazilian factorial as defined\nlong long special_factorial(int n){\n    long long result = 1;\n    for(int i = 1; i <= n; ++i) {\n        result *= factorial(i);\n    }\n    return result;\n}\n\n"}
{"task_id": "CPP/140", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring fix_spaces(string text) {\n    string result;\n    int spaceCount = 0; // Counter for consecutive spaces\n\n    for (char c : text) {\n        if (c == ' ') {\n            ++spaceCount;\n        } else {\n            if (spaceCount > 2) {\n                result += '-';\n            } else {\n                while (spaceCount > 0) {\n                    result += '_';\n                    --spaceCount;\n                }\n            }\n            spaceCount = 0; // Reset the counter\n            result += c;\n        }\n    }\n\n    // Handle trailing spaces if any\n    if (spaceCount > 2) {\n        result += '-';\n    } else {\n        while (spaceCount > 0) {\n            result += '_';\n            --spaceCount;\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/141", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring file_name_check(string file_name) {\n    // Check for exactly one dot in the name.\n    size_t dotPos = file_name.find('.');\n    if (dotPos == string::npos || file_name.find('.', dotPos + 1) != string::npos)\n        return \"No\";\n\n    // Split the filename into two parts: before and after the dot\n    string prefix = file_name.substr(0, dotPos);\n    string suffix = file_name.substr(dotPos + 1);\n\n    // Check if there are more than three digits in the prefix.\n    int digitCount = 0;\n    for (char c : prefix) {\n        if (isdigit(c)) digitCount++;\n        if (digitCount > 3) return \"No\";\n    }\n\n    // Validate that the prefix starts with a letter and is not empty\n    if (prefix.empty() || !isalpha(prefix[0])) \n        return \"No\";\n\n    // Check valid extensions.\n    string validExtensions[] = {\"txt\", \"exe\", \"dll\"};\n    bool isValidExtension = false;\n    for (string ext : validExtensions) {\n        if (ext == suffix) {\n            isValidExtension = true;\n            break;\n        }\n    }\n\n    if (!isValidExtension)\n        return \"No\";\n\n    // If all checks pass, the filename is valid.\n    return \"Yes\";\n}\n\n"}
{"task_id": "CPP/142", "generation": "#include <vector>\nusing namespace std;\n\nint sum_squares(vector<int> lst) {\n    int sum = 0;\n    \n    for (size_t i = 0; i < lst.size(); ++i) {\n        if (i % 3 == 0) { // If index is a multiple of 3\n            sum += lst[i] * lst[i]; // Square the element and add to sum\n        } else if (i % 4 == 0 && i % 3 != 0) { // If index is a multiple of 4 but not 3\n            sum += lst[i] * lst[i] * lst[i]; // Cube the element and add to sum\n        } else {\n            sum += lst[i]; // Add the element as it is if no condition matches\n        }\n    }\n\n    return sum;\n}\n\n// Example usage:\n"}
{"task_id": "CPP/143", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\n// Helper function to check if a number is prime\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    for (int i = 2; i * i <= num; ++i) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\n// Main function to filter words based on prime length\nstring words_in_sentence(string sentence) {\n    stringstream ss(sentence);\n    string word, result;\n    \n    while (ss >> word) { // Extract each word from the sentence\n        if (is_prime(word.length())) {\n            if (!result.empty()) result += \" \"; // Add space before appending new word\n            result += word; // Append prime length words to result\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/144", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool simplify(string x, string n) {\n    // Parsing fractions\n    size_t slashPos;\n    \n    int numX = stoi(x.substr(0, (slashPos = x.find('/'))));\n    int denX = stoi(x.substr(slashPos + 1));\n\n    int numN = stoi(n.substr(0, (slashPos = n.find('/'))));\n    int denN = stoi(n.substr(slashPos + 1));\n\n    // Multiplying the fractions\n    int numeratorResult = numX * numN;\n    int denominatorResult = denX * denN;\n\n    // Simplifying to check if it's a whole number\n    return (numeratorResult % denominatorResult == 0);\n}\n\n"}
{"task_id": "CPP/145", "generation": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nint sum_of_digits(int n) {\n    int sum = 0;\n    bool is_negative = n < 0;\n    while (n != 0) {\n        sum += n % 10;\n        n /= 10;\n    }\n    return is_negative ? -sum : sum;\n}\n\nvector<int> order_by_points(vector<int> nums) {\n    std::vector<std::pair<int, int>> indexed_nums;\n\n    // Pair each number with its index\n    for (int i = 0; i < nums.size(); ++i) {\n        indexed_nums.push_back({nums[i], i});\n    }\n\n    // Sort based on the sum of digits and then by original index\n    std::sort(indexed_nums.begin(), indexed_nums.end(),\n              [](const std::pair<int, int>& a, const std::pair<int, int>& b) {\n                  int sum_a = sum_of_digits(a.first);\n                  int sum_b = sum_of_digits(b.first);\n                  if (sum_a == sum_b)\n                      return a.second < b.second;\n                  else\n                      return sum_a < sum_b;\n              });\n\n    // Extract the sorted numbers from pairs\n    std::vector<int> result;\n    for (const auto& p : indexed_nums) {\n        result.push_back(p.first);\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/146", "generation": "#include <vector>\n#include <string>\nusing namespace std;\n\nbool isFirstAndLastDigitOdd(int num) {\n    // Convert to string to easily access first and last digit\n    string strNum = to_string(abs(num));  // Use abs to handle negative numbers\n    char firstDigit = strNum[0];\n    char lastDigit = strNum[strNum.length() - 1];\n\n    // Check if both digits are odd\n    return (firstDigit == '1' || firstDigit == '3' || firstDigit == '5' || \n            firstDigit == '7' || firstDigit == '9') &&\n           (lastDigit == '1' || lastDigit == '3' || lastDigit == '5' ||\n            lastDigit == '7' || lastDigit == '9');\n}\n\nint specialFilter(vector<int> nums) {\n    int count = 0;\n    for(int num : nums) {\n        if(num > 10 && isFirstAndLastDigitOdd(num)) {\n            ++count;\n        }\n    }\n    return count;\n}\n"}
{"task_id": "CPP/147", "generation": "#include<iostream>\n#include<vector>\n\nusing namespace std;\n\nint get_max_triples(int n) {\n    vector<int> a(n);\n    \n    // Fill the array with values according to the given formula.\n    for (int i = 0; i < n; ++i) {\n        a[i] = (i + 1) * (i + 1) - (i + 1) + 1;\n    }\n    \n    int count = 0;\n\n    // Iterate through all possible triples and check the condition.\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            for (int k = j + 1; k < n; ++k) {\n                if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                    count++;\n                }\n            }\n        }\n    }\n\n    return count;\n}\n\n// Function to test the solution with given data points.\nvoid check_solution() {\n    cout << \"For n = 5, Expected: 1, Got: \" << get_max_triples(5) << endl;\n    // You can add more tests here as needed\n}\n\n"}
{"task_id": "CPP/148", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to find planets between two given planets.\nvector<string> bf(string planet1, string planet2) {\n    // Mapping of each planet name to its position relative to the Sun.\n    vector<pair<string, int>> solarSystem = {\n        {\"Mercury\", 1}, {\"Venus\", 2}, {\"Earth\", 3},\n        {\"Mars\", 4}, {\"Jupiter\", 5}, {\"Saturn\", 6},\n        {\"Uranus\", 7}, {\"Neptune\", 8}\n    };\n\n    // Find the positions of planet1 and planet2.\n    int pos1 = -1, pos2 = -1;\n    for (const auto& planet : solarSystem) {\n        if (planet.first == planet1)\n            pos1 = planet.second;\n        else if (planet.first == planet2)\n            pos2 = planet.second;\n\n        // If both positions are found, break the loop.\n        if (pos1 != -1 && pos2 != -1)\n            break;\n    }\n\n    // Check if either of the planets was not found.\n    if (pos1 == -1 || pos2 == -1) {\n        return {};  // Return an empty vector if any planet is invalid.\n    }\n\n    // Ensure pos1 < pos2 for simplicity in the loop below.\n    if (pos1 > pos2)\n        swap(pos1, pos2);\n\n    // Collect all planets between pos1 and pos2.\n    vector<string> result;\n    for (const auto& planet : solarSystem) {\n        int position = planet.second;\n        if (position > pos1 && position < pos2) {\n            result.push_back(planet.first);\n        }\n    }\n\n    return result;\n}\n\n// Function to test the bf function with examples.\nvoid check() {\n    vector<string> res;\n\n    // Example 1\n    res = bf(\"Jupiter\", \"Neptune\");\n    for (const auto& planet : res)\n        cout << planet << \" \";\n    cout << endl;  // Expected: Saturn Uranus\n\n    // Example 2\n    res = bf(\"Earth\", \"Mercury\");\n    for (const auto& planet : res)\n        cout << planet << \" \";\n    cout << endl;  // Expected: Venus\n\n    // Example 3\n    res = bf(\"Mercury\", \"Uranus\");\n    for (const auto& planet : res)\n        cout << planet << \" \";\n    cout << endl;  // Expected: Venus Earth Mars Jupiter Saturn\n}\n\n"}
{"task_id": "CPP/149", "generation": "#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to sort a vector of strings by length (ascending) and alphabetically for equal lengths.\nvector<string> vector_sort(vector<string> lst) {\n    // Filter out strings with odd lengths\n    vector<string> filtered_lst;\n    for(const auto& str : lst) {\n        if(str.length() % 2 == 0) {\n            filtered_lst.push_back(str);\n        }\n    }\n\n    // Sort the list by length, and then alphabetically for equal lengths\n    sort(filtered_lst.begin(), filtered_lst.end(), [](const string &a, const string &b){\n        return (a.size() != b.size()) ? a.size() < b.size() : a < b;\n    });\n\n    return filtered_lst;\n}\n\n"}
{"task_id": "CPP/150", "generation": "#include <cmath> // For sqrt function\n#include <iostream>\n\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    for (int i = 2; i <= static_cast<int>(std::sqrt(num)); ++i) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\nint x_or_y(int n, int x, int y) {\n    if (is_prime(n)) {\n        return x;\n    } else {\n        return y;\n    }\n}\n"}
{"task_id": "CPP/151", "generation": "#include <vector>\n#include <cmath> // For std::pow\n\nusing namespace std;\n\nlong long double_the_difference(vector<float> lst) {\n    long long sum = 0;\n    \n    for (float num : lst) {\n        if (num > 0 && floor(num) == num && static_cast<int>(num) % 2 != 0) { // Check if positive, integer and odd\n            int n = static_cast<int>(num);\n            sum += pow(n, 2); // Square the number and add to sum\n        }\n    }\n\n    return sum;\n}\n\n// Test cases\n"}
{"task_id": "CPP/152", "generation": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nvector<int> compare(vector<int> game, vector<int> guess) {\n    vector<int> result;\n    for (size_t i = 0; i < game.size(); ++i) {\n        int diff = abs(game[i] - guess[i]);\n        result.push_back(diff);\n    }\n    return result;\n}\n\n"}
{"task_id": "CPP/153", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to calculate the strength of an extension.\nint CalculateStrength(const string& extension) {\n    int uppercase = 0;\n    int lowercase = 0;\n    \n    for (char c : extension) {\n        if (isupper(c)) uppercase++;\n        else if (islower(c)) lowercase++;\n    }\n    \n    return uppercase - lowercase;\n}\n\nstring Strongest_Extension(string class_name, vector<string> extensions) {\n    string strongest_extension = \"\";\n    int max_strength = INT_MIN; // Initialize with the smallest possible integer.\n    \n    for (const auto& extension : extensions) {\n        int strength = CalculateStrength(extension);\n        \n        if (strength > max_strength || (strength == max_strength && strongest_extension.empty())) {\n            max_strength = strength;\n            strongest_extension = extension;\n        }\n    }\n    \n    return class_name + \".\" + strongest_extension;\n}\n\n"}
{"task_id": "CPP/154", "generation": "#include <string>\n#include <algorithm>\nusing namespace std;\n\nbool cycpattern_check(string a, string b) {\n    if (b.length() > a.length()) return false;\n\n    // Concatenate string 'a' with itself to handle rotations\n    string a_double = a + a;\n    \n    for (size_t i = 0; i < b.length(); ++i) {\n        string rotated_b = b.substr(i) + b.substr(0, i);\n        if (a_double.find(rotated_b) != string::npos) return true;\n    }\n    return false;\n}\n"}
{"task_id": "CPP/155", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<int> even_odd_count(int num){\n    // Convert number to its absolute value to handle negative numbers\n    int absNum = abs(num);\n    \n    // Convert integer to string for easy digit extraction\n    string strNum = to_string(absNum);\n\n    // Initialize counters for even and odd digits\n    int evenCount = 0;\n    int oddCount = 0;\n\n    // Iterate through each character in the string\n    for (char c : strNum) {\n        // Convert char to integer digit\n        int digit = c - '0';\n        \n        // Check if the digit is even or odd and increment respective counter\n        if (digit % 2 == 0) {\n            evenCount++;\n        } else {\n            oddCount++;\n        }\n    }\n\n    // Return a vector containing counts of even and odd digits respectively\n    return {evenCount, oddCount};\n}\n\n// Function to test the solution with given examples\nvoid check() {\n    vector<int> result = even_odd_count(-12);\n    cout << \"even_odd_count(-12) -> {\" << result[0] << \", \" << result[1] << \"}\\n\";\n    \n    result = even_odd_count(123);\n    cout << \"even_odd_count(123) -> {\" << result[0] << \", \" << result[1] << \"}\\n\";\n}\n\n"}
{"task_id": "CPP/156", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring int_to_mini_roman(int number) {\n    // Define the values and corresponding symbols\n    vector<int> values = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    vector<string> symbols = {\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n\n    string roman = \"\";\n    \n    // Iterate over the values and construct the Roman numeral\n    for (int i = 0; number > 0; ++i) {\n        while (number >= values[i]) {\n            roman += symbols[i];\n            number -= values[i];\n        }\n    }\n\n    return roman;\n}\n\n// Example usage:\n"}
{"task_id": "CPP/157", "generation": "#include <iostream>\n#include <cmath>\n\nbool right_angle_triangle(float a, float b, float c){\n    // First, sort the sides so that c is the longest side (hypotenuse)\n    if(a > c) std::swap(a, c);\n    if(b > c) std::swap(b, c);\n\n    // Check the Pythagorean theorem\n    return fabs(a*a + b*b - c*c) < 1e-6; // Using a small threshold to account for floating point precision issues.\n}\n\n"}
{"task_id": "CPP/158", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <set>\nusing namespace std;\n\nstring find_max(vector<string> words) {\n    string result;\n    int max_unique = 0; // To keep track of maximum unique characters\n\n    for (const auto& word : words) {\n        set<char> unique_chars(word.begin(), word.end()); // Use a set to get unique characters\n        int count_unique = unique_chars.size();\n\n        if (count_unique > max_unique || \n            (count_unique == max_unique && word < result)) { // Check lexicographical order as well\n            max_unique = count_unique;\n            result = word;\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/159", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> eat(int number, int need, int remaining) {\n    // Calculate the total number of carrots eaten after trying to eat 'need' more.\n    int totalEaten = number + min(need, remaining);\n    \n    // Calculate how many carrots are left after eating as much as possible.\n    int carrotsLeft = max(0, remaining - need);\n\n    return {totalEaten, carrotsLeft};\n}\n"}
{"task_id": "CPP/160", "generation": "#include <vector>\n#include <string>\n#include <cmath>\nusing namespace std;\n\n// Function to evaluate an expression with given operators and operands.\nint do_algebra(vector<string> operators, vector<int> operands) {\n    // Initialize the result with the first operand.\n    int result = operands[0];\n    \n    for (size_t i = 0; i < operators.size(); ++i) {\n        string op = operators[i];\n        int next_operand = operands[i + 1];\n\n        if (op == \"+\") {\n            result += next_operand;\n        } else if (op == \"-\") {\n            result -= next_operand;\n        } else if (op == \"*\") {\n            result *= next_operand;\n        } else if (op == \"//\") {\n            // Floor division\n            result = static_cast<int>(floor(static_cast<double>(result) / next_operand));\n        } else if (op == \"**\") {\n            // Exponentiation\n            result = pow(result, next_operand);\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/161", "generation": "#include <iostream>\n#include <string>\n#include <cctype> // For std::isalpha and std::islower\n\nusing namespace std;\n\nstring solve(string s) {\n    bool hasLetters = false;\n    \n    // Check if the string contains any letters.\n    for (char c : s) {\n        if (std::isalpha(c)) {\n            hasLetters = true;\n            break;\n        }\n    }\n\n    // If no letters are present, reverse the entire string.\n    if (!hasLetters) {\n        std::reverse(s.begin(), s.end());\n        return s;\n    }\n\n    // Otherwise, change the case of each letter and keep other characters as they are.\n    for (char &c : s) {\n        if (std::isalpha(c)) {\n            c = std::islower(c) ? toupper(c) : tolower(c);\n        }\n    }\n\n    return s;\n}\n\n"}
{"task_id": "CPP/162", "generation": "#include <iostream>\n#include <string>\n#include <openssl/md5.h>\n\nusing namespace std;\n\nstring string_to_md5(string text) {\n    if (text.empty()) return \"None\"; // Return \"None\" for empty strings\n\n    unsigned char digest[MD5_DIGEST_LENGTH];\n    MD5((unsigned char*)text.c_str(), text.length(), (unsigned char*)&digest);    \n\n    char mdString[33];\n    for(int i = 0; i < 16; ++i)\n        sprintf(&mdString[i*2], \"%02x\", (unsigned int)digest[i]);\n\n    return string(mdString);\n}\n\n"}
{"task_id": "CPP/163", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // For std::min and std::max\n\nusing namespace std;\n\nvector<int> generate_integers(int a, int b) {\n    vector<int> evenDigits = {2, 4, 6, 8}; // All possible even digits less than 10\n    vector<int> result;\n    \n    // Ensure a is the smaller number and b is the larger one\n    int start = min(a, b);\n    int end = max(a, b);\n\n    for (int digit : evenDigits) {\n        if (digit >= start && digit <= end) {\n            result.push_back(digit);\n        }\n    }\n\n    return result;\n}\n\n// Function to print vector elements\nvoid printVector(const vector<int>& vec) {\n    cout << \"{\";\n    for(size_t i = 0; i < vec.size(); ++i) {\n        if (i != 0) cout << \", \";\n        cout << vec[i];\n    }\n    cout << \"}\" << endl;\n}\n\n"}
{"task_id": "CPP/0", "generation": "#include <algorithm> // For std::sort\n\nbool has_close_elements(std::vector<float> numbers, float threshold) {\n    if (numbers.size() < 2) return false; // If there are less than two elements, we can't have any pairs.\n\n    // Sort the vector to bring closer elements next to each other.\n    std::sort(numbers.begin(), numbers.end());\n\n    for(size_t i = 0; i < numbers.size() - 1; ++i) {\n        if (std::abs(numbers[i] - numbers[i + 1]) < threshold) {\n            return true;\n        }\n    }\n\n    return false;\n}\n"}
{"task_id": "CPP/1", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> separate_paren_groups(string paren_string){\n    vector<string> result;\n    int balance = 0; // Keeps track of open parentheses\n    string current_group = \"\"; // Current group being processed\n\n    for (char c : paren_string) {\n        if (c == '(' || c == ')') { // Ignore spaces and only consider parentheses\n            current_group += c; // Add the character to the current group\n            balance += (c == '(' ? 1 : -1); // Update balance based on the character\n\n            if (balance == 0) { // When balance is zero, a complete group has been found\n                result.push_back(current_group);\n                current_group = \"\"; // Reset for the next group\n            }\n        }\n    }\n\n    return result;\n}\n\n// Function to test the solution with provided data points\nvoid check() {\n    vector<string> expected1 = {\"()\", \"(())\", \"(()())\"};\n    assert(separate_paren_groups(\"( ) (( )) (( )( ))\") == expected1);\n\n    // Additional checks can be added here as needed\n\n    cout << \"All tests passed successfully.\" << endl;\n}\n\n"}
{"task_id": "CPP/2", "generation": "#include<stdio.h>\n#include<math.h>\n\nfloat truncate_number(float number){\n    float integerPart = floor(number);\n    return number - integerPart;\n}\n\n"}
{"task_id": "CPP/3", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nbool below_zero(vector<int> operations) {\n    int balance = 0; // Start with a zero balance\n\n    for (int op : operations) { // Iterate through each operation\n        balance += op; // Update the balance according to the current operation\n        \n        if (balance < 0) { // Check if balance falls below zero\n            return true;\n        }\n    }\n\n    return false; // Return false if no point in time the balance was below zero\n}\n\n"}
{"task_id": "CPP/4", "generation": "#include <iostream>\n#include <vector>\n#include <numeric> // for std::accumulate\n#include <cmath>   // for std::abs\n\nusing namespace std;\n\nfloat mean_absolute_deviation(vector<float> numbers) {\n    if (numbers.empty()) return 0.0f; // Handle empty vector case\n    \n    float sum = accumulate(numbers.begin(), numbers.end(), 0.0f);\n    float mean = sum / numbers.size();\n    \n    float mad_sum = 0.0f;\n    for (float num : numbers) {\n        mad_sum += std::abs(num - mean); // Calculate the absolute difference and add it to the sum\n    }\n    \n    return mad_sum / numbers.size(); // Average of all absolute differences\n}\n\n"}
{"task_id": "CPP/5", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> intersperse(vector<int> numbers, int delimeter) {\n    vector<int> result;\n    \n    // If the input vector is empty, return it as is.\n    if (numbers.empty()) {\n        return result;\n    }\n    \n    // Iterate through each element in the input vector\n    for(size_t i = 0; i < numbers.size(); ++i) {\n        // Add the current number to the result vector\n        result.push_back(numbers[i]);\n        \n        // If it's not the last element, add the delimiter after it.\n        if (i != numbers.size() - 1) {\n            result.push_back(delimeter);\n        }\n    }\n\n    return result;\n}\n\n// Example usage:\n"}
{"task_id": "CPP/6", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<int> parse_nested_parens(string paren_string) {\n    vector<int> max_depths;\n    int current_depth = 0, max_depth = 0;\n    \n    for (char c : paren_string) {\n        if (c == '(') {\n            // Increase depth when encountering an opening parenthesis\n            ++current_depth;\n            // Update the maximum depth found so far in this group\n            if (current_depth > max_depth)\n                max_depth = current_depth;\n        } else if (c == ')') {\n            // Decrease depth when encountering a closing parenthesis\n            --current_depth;\n        } else if (c == ' ') {\n            // When we encounter a space, it means the end of one group.\n            // Add the maximum depth found for this group to our result vector,\n            // and reset max_depth and current_depth for the next group.\n            max_depths.push_back(max_depth);\n            max_depth = 0;\n            current_depth = 0;\n        }\n    }\n\n    // Handle the last group if there is no trailing space\n    if (max_depth > 0) {\n        max_depths.push_back(max_depth);\n    }\n\n    return max_depths;\n}\n\n"}
{"task_id": "CPP/7", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\n// Function to filter strings containing a specific substring.\nvector<string> filter_by_substring(vector<string> strings, string substring) {\n    vector<string> filteredStrings; // Vector to store the result.\n\n    for (const auto& str : strings) { // Iterate through each string in the input vector.\n        if (str.find(substring) != string::npos) { // Check if the current string contains the substring.\n            filteredStrings.push_back(str); // If it does, add it to the result vector.\n        }\n    }\n\n    return filteredStrings; // Return the filtered list of strings.\n}\n\n// Function to test the filter_by_substring function with given data points.\nvoid check() {\n    vector<string> empty;\n    auto res1 = filter_by_substring(empty, \"a\");\n    assert(res1.empty()); // Should be an empty vector.\n\n    vector<string> input2{\"abc\", \"bacd\", \"cde\", \"vector\"};\n    auto res2 = filter_by_substring(input2, \"a\");\n    vector<string> expected2{\"abc\", \"bacd\", \"vector\"};\n    assert(res2 == expected2); // Should match the expected result.\n\n    cout << \"All tests passed successfully.\" << endl;\n}\n\n"}
{"task_id": "CPP/8", "generation": "#include <iostream>\n#include <vector>\n#include <utility>\nusing namespace std;\n\nvector<int> sum_product(vector<int> numbers) {\n    int total_sum = 0;\n    long long product = 1; // Use long long to handle large products\n\n    if (numbers.empty()) {\n        return {0, 1};\n    }\n\n    for (int num : numbers) {\n        total_sum += num;\n        product *= num;\n    }\n\n    vector<int> result(2);\n    result[0] = total_sum;\n    // Convert product to int before storing in the result\n    if (product > INT_MAX || product < INT_MIN) {\n        throw std::overflow_error(\"Product overflow\");\n    }\n    result[1] = static_cast<int>(product);\n\n    return result;\n}\n"}
{"task_id": "CPP/9", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> rolling_max(vector<int> numbers) {\n    // Check if the input vector is empty to avoid undefined behavior.\n    if (numbers.empty()) return {};\n\n    vector<int> result;\n    int currentMax = numbers[0];  // Initialize with the first element of the sequence.\n\n    for (int num : numbers) {\n        // Update the current maximum value if the current number is greater than it.\n        if (num > currentMax) {\n            currentMax = num;\n        }\n        // Append the current maximum to the result vector.\n        result.push_back(currentMax);\n    }\n\n    return result;\n}\n\n// Example usage\n"}
{"task_id": "CPP/10", "generation": "#include <string>\nusing namespace std;\n\nbool is_palindrome(string str) {\n    string reversed_str(str.rbegin(), str.rend());\n    return str == reversed_str;\n}\n\nstring make_palindrome(string str) {\n    if (str.empty()) {\n        return \"\";\n    }\n\n    for (size_t i = 0; i < str.size(); ++i) {\n        string suffix = str.substr(i);\n        if (is_palindrome(suffix)) {\n            string prefix_to_reverse = str.substr(0, i);\n            reverse(prefix_to_reverse.begin(), prefix_to_reverse.end());\n            return str + prefix_to_reverse;\n        }\n    }\n\n    // Fallback case: should not happen\n    string reversed_str(str.rbegin(), str.rend());\n    return str + reversed_str;\n}\n"}
{"task_id": "CPP/11", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring string_xor(string a, string b) {\n    // Ensure both strings are of equal length by padding with zeros if necessary.\n    int len_a = a.length();\n    int len_b = b.length();\n\n    // Pad the shorter string with leading '0's to match lengths\n    while (len_a < len_b) { a = \"0\" + a; ++len_a; }\n    while (len_b < len_a) { b = \"0\" + b; ++len_b; }\n\n    string result;\n    \n    // Perform XOR on each pair of characters and append to the result\n    for(int i = 0; i < len_a; ++i){\n        if(a[i] == b[i]) {\n            result += '0'; // If both are same, XOR is 0\n        } else {\n            result += '1'; // If different, XOR is 1\n        }\n    }\n\n    return result;\n}\n\n// Function to test the string_xor function\nvoid check() {\n    cout << (string_xor(\"010\", \"110\") == \"100\" ? \"Test Passed\\n\" : \"Test Failed\\n\");\n}\n\n"}
{"task_id": "CPP/12", "generation": "#include <vector>\n#include <string>\nusing namespace std;\n\nstring longest(vector<string> strings) {\n    if (strings.empty()) return \"\"; // Return an empty string to represent None\n\n    string maxString = strings[0]; // Assume the first string is the longest initially\n    size_t maxLength = maxString.length();\n\n    for (size_t i = 1; i < strings.size(); ++i) { // Start from the second element\n        if (strings[i].length() > maxLength) {\n            maxString = strings[i];\n            maxLength = strings[i].length();\n        }\n    }\n\n    return maxString;\n}\n"}
{"task_id": "CPP/13", "generation": "#include <iostream>\nusing namespace std;\n\nint greatest_common_divisor(int a, int b) {\n    while (b != 0) {\n        int temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n\n"}
{"task_id": "CPP/14", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> all_prefixes(string str){\n    vector<string> prefixes;\n    for(size_t i = 0; i < str.length(); ++i) {\n        // Create a substring from the start to the current position (inclusive)\n        string prefix = str.substr(0, i + 1);\n        // Add this prefix to the vector\n        prefixes.push_back(prefix);\n    }\n    return prefixes;\n}\n\n// Example usage:\n"}
{"task_id": "CPP/15", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nstring string_sequence(int n) {\n    string result = \"\";\n    \n    for (int i = 0; i <= n; ++i) {\n        // Convert integer to string and append it to the result string.\n        result += to_string(i);\n        \n        // Add a space after each number except the last one\n        if (i < n) {\n            result += \" \";\n        }\n    }\n\n    return result;\n}\n\n// Function to test the correctness of the solution\nvoid check() {\n    cout << (string_sequence(0) == \"0\" ? \"Test 1 Passed\\n\" : \"Test 1 Failed\\n\");\n    cout << (string_sequence(5) == \"0 1 2 3 4 5\" ? \"Test 2 Passed\\n\" : \"Test 2 Failed\\n\");\n}\n\n"}
{"task_id": "CPP/16", "generation": "#include <iostream>\n#include <set>\n#include <string>\nusing namespace std;\n\nint count_distinct_characters(string str) {\n    // Convert string to lower case for case-insensitive comparison\n    transform(str.begin(), str.end(), str.begin(), ::tolower);\n    \n    // Use a set to store unique characters\n    set<char> distinctChars;\n    \n    // Iterate through each character and add it to the set\n    for (char c : str) {\n        distinctChars.insert(c);\n    }\n    \n    // The size of the set is the number of distinct characters\n    return distinctChars.size();\n}\n\n"}
{"task_id": "CPP/17", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<int> parse_music(string music_string){\n    vector<int> beats;\n    int i = 0;\n    \n    while (i < music_string.length()) {\n        if(music_string[i] == 'o') { // Check for whole note\n            if(i + 1 < music_string.length() && music_string[i+1] == '|') {\n                beats.push_back(2); // Half note\n                i += 2; // Skip the next character as well since it's part of the half note\n            } else {\n                beats.push_back(4); // Whole note\n                i++;\n            }\n        } else if(music_string[i] == '.') { // Check for quarter note\n            if(i + 1 < music_string.length() && music_string[i+1] == '|') {\n                beats.push_back(1); // Quarter note\n                i += 2; // Skip the next character as well since it's part of the quarter note\n            } else {\n                cout << \"Invalid input: Expected '|' after '.'\" << endl;\n                return vector<int>(); // Return an empty vector in case of invalid input\n            }\n        } else if(music_string[i] == ' ') { // Skip spaces\n            i++;\n        } else {\n            cout << \"Invalid character encountered: \" << music_string[i] << endl;\n            return vector<int>(); // Return an empty vector in case of invalid input\n        }\n    }\n\n    return beats;\n}\n\n"}
{"task_id": "CPP/18", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint how_many_times(string str, string substring) {\n    if (substring.empty() || str.empty()) return 0; // If either string is empty, no matches are possible.\n    \n    int count = 0;\n    size_t pos = 0;\n    \n    while ((pos = str.find(substring, pos)) != string::npos) { // Find the substring starting from 'pos'.\n        ++count; // Increment count for each match found.\n        ++pos;   // Move to the next character after the current match to find overlapping occurrences.\n    }\n    \n    return count;\n}\n\n"}
{"task_id": "CPP/19", "generation": "#include <iostream>\n#include <string>\n#include <vector>\n#include <map>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to sort numbers given as words from \"zero\" to \"nine\"\nstring sort_numbers(string numbers) {\n    // Mapping of number words to their numeric values\n    map<string, int> num_map = {\n        {\"zero\", 0}, {\"one\", 1}, {\"two\", 2}, {\"three\", 3},\n        {\"four\", 4}, {\"five\", 5}, {\"six\", 6}, {\"seven\", 7},\n        {\"eight\", 8}, {\"nine\", 9}\n    };\n\n    // Reverse mapping for converting numeric values back to words\n    map<int, string> reverse_map;\n    for (auto &p : num_map) {\n        reverse_map[p.second] = p.first;\n    }\n\n    // Split the input string into individual number words\n    vector<string> num_words;\n    string word;\n    for (char c : numbers) {\n        if (c == ' ') {\n            if (!word.empty()) {\n                num_words.push_back(word);\n                word.clear();\n            }\n        } else {\n            word += c;\n        }\n    }\n    if (!word.empty()) {\n        num_words.push_back(word);\n    }\n\n    // Sort the number words based on their numeric values\n    sort(num_words.begin(), num_words.end(),\n         [&num_map](const string &a, const string &b) { return num_map[a] < num_map[b]; });\n\n    // Convert back to a space-delimited string of sorted number words\n    string result;\n    for (size_t i = 0; i < num_words.size(); ++i) {\n        if (i > 0) result += \" \";\n        result += reverse_map[num_map[num_words[i]]];\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/20", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <limits>\n\nusing namespace std;\n\nvector<float> find_closest_elements(vector<float> numbers) {\n    // Sort the vector in ascending order.\n    sort(numbers.begin(), numbers.end());\n\n    float min_diff = numeric_limits<float>::max();\n    pair<float, float> closest_pair(0.0f, 0.0f);\n\n    for (size_t i = 0; i < numbers.size() - 1; ++i) {\n        float diff = numbers[i + 1] - numbers[i];\n        if (diff < min_diff) {\n            min_diff = diff;\n            closest_pair.first = numbers[i];\n            closest_pair.second = numbers[i + 1];\n        }\n    }\n\n    // Convert the pair to a vector for returning.\n    return {closest_pair.first, closest_pair.second};\n}\n"}
{"task_id": "CPP/21", "generation": "#include <vector>\n#include <algorithm> // for std::min_element and std::max_element\n\nusing namespace std;\n\nvector<float> rescale_to_unit(vector<float> numbers){\n    float min_val = *std::min_element(numbers.begin(), numbers.end());\n    float max_val = *std::max_element(numbers.begin(), numbers.end());\n\n    vector<float> scaled_numbers;\n    for (float num : numbers) {\n        // Apply the linear transformation\n        float scaled_num = (num - min_val) / (max_val - min_val);\n        scaled_numbers.push_back(scaled_num);\n    }\n\n    return scaled_numbers;\n}\n\n// Example usage:\n"}
{"task_id": "CPP/22", "generation": "#include <iostream>\n#include <vector>\n#include <list>\n#include <boost/any.hpp>\n\ntypedef std::list<boost::any> list_any;\n\nstd::vector<int> filter_integers(list_any values) {\n    std::vector<int> integers;\n    \n    for (auto it = values.begin(); it != values.end(); ++it) {\n        if (it->type() == typeid(int)) { // Check if the type is int\n            integers.push_back(boost::any_cast<int>(*it)); // Cast and add to vector\n        }\n    }\n\n    return integers;\n}\n\n"}
{"task_id": "CPP/23", "generation": "#include <iostream>\n#include <string>\n\nint stringLength(const std::string& str) {\n    return str.length();\n}\n\n"}
{"task_id": "CPP/24", "generation": "#include<stdio.h>\n\nint largest_divisor(int n) {\n    // Start from half of n because no number greater than n/2 can be a divisor of n (except n itself)\n    for (int i = n / 2; i >= 1; --i) {\n        if (n % i == 0) {\n            return i;\n        }\n    }\n    // If no divisor is found, which theoretically shouldn't happen unless n <= 1\n    return -1;\n}\n\n"}
{"task_id": "CPP/25", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvector<int> factorize(int n) {\n    vector<int> factors;\n    \n    // Divide by 2 until odd\n    while (n % 2 == 0) {\n        factors.push_back(2);\n        n /= 2;\n    }\n    \n    // Check for odd factors from 3 onwards\n    for (int i = 3; i * i <= n; i += 2) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n    \n    // If n is a prime number greater than 2\n    if (n > 2) {\n        factors.push_back(n);\n    }\n\n    return factors;\n}\n\n"}
{"task_id": "CPP/26", "generation": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nvector<int> remove_duplicates(vector<int> numbers) {\n    unordered_map<int, int> occurrences;\n    \n    // Count the occurrences of each number.\n    for (int num : numbers) {\n        occurrences[num]++;\n    }\n    \n    vector<int> result;\n    \n    // Add to result only those elements that occur once.\n    for (int num : numbers) {\n        if (occurrences[num] == 1) {\n            result.push_back(num);\n        }\n    }\n    \n    return result;\n}\n\n// Function to print the vector\nvoid print_vector(const vector<int>& v) {\n    cout << \"{\";\n    for(size_t i = 0; i < v.size(); ++i) {\n        cout << v[i];\n        if (i != v.size() - 1) cout << \", \";\n    }\n    cout << \"}\" << endl;\n}\n\n"}
{"task_id": "CPP/27", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring flip_case(string str) {\n    for (size_t i = 0; i < str.length(); ++i) {\n        if (isupper(str[i])) {\n            // Convert uppercase to lowercase\n            str[i] = tolower(str[i]);\n        } else if (islower(str[i])) {\n            // Convert lowercase to uppercase\n            str[i] = toupper(str[i]);\n        }\n    }\n    return str;\n}\n\n"}
{"task_id": "CPP/28", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring concatenate(vector<string> strings) {\n    // Initialize an empty string for storing the concatenated result.\n    string result = \"\";\n    \n    // Iterate through each element in the vector and append it to the result.\n    for (const auto& str : strings) {\n        result += str;\n    }\n    \n    return result;\n}\n\n// Function to test the concatenate function with some test cases\nvoid test_concatenate() {\n    cout << \"Test Case 1: Empty Vector -> Expected: \\\"\\\", Actual: \\\"\" << concatenate({}) << \"\\\"\" << endl;\n    cout << \"Test Case 2: {\\\"a\\\", \\\"b\\\", \\\"c\\\"} -> Expected: \\\"abc\\\", Actual: \\\"\" << concatenate({\"a\", \"b\", \"c\"}) << \"\\\"\" << endl;\n}\n\n"}
{"task_id": "CPP/29", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> filter_by_prefix(vector<string> strings, string prefix) {\n    vector<string> filteredStrings; // This will store the results\n\n    for (const auto& str : strings) { // Iterate through each string in the input\n        if (!str.empty() && str.substr(0, prefix.size()) == prefix) {\n            // Check if the current string starts with the given prefix\n            filteredStrings.push_back(str); // Add to result vector if condition is met\n        }\n    }\n\n    return filteredStrings; // Return the filtered list of strings\n}\n\n// Function to test the filter_by_prefix function\nvoid check() {\n    auto result1 = filter_by_prefix({}, \"a\");\n    cout << \"Test 1: \";\n    for (const auto& str : result1) {\n        cout << str << \" \";\n    }\n    cout << endl;\n\n    auto result2 = filter_by_prefix({\"abc\", \"bcd\", \"cde\", \"vector\"}, \"a\");\n    cout << \"Test 2: \";\n    for (const auto& str : result2) {\n        cout << str << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/30", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // For std::copy_if\n\nusing namespace std;\n\nvector<float> get_positive(vector<float> l) {\n    vector<float> result;  // This will store the positive numbers.\n    \n    // Use copy_if to filter only positive numbers into 'result'.\n    copy_if(l.begin(), l.end(), back_inserter(result), [](float x){ return x > 0; });\n    \n    return result;\n}\n\n// Function to print a vector\nvoid print_vector(const vector<float>& v) {\n    for (auto num : v) {\n        cout << num << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/31", "generation": "#include <iostream>\nusing namespace std;\n\nbool is_prime(long long n) {\n    // Handle edge cases for 0, 1 and negative numbers.\n    if (n <= 1) return false;\n    \n    // Check divisibility from 2 up to the square root of n.\n    for (long long i = 2; i * i <= n; ++i) {\n        if (n % i == 0)\n            return false;\n    }\n    return true;\n}\n\n"}
{"task_id": "CPP/32", "generation": "#include <iostream>\n#include <vector>\n#include <cmath>\n\ndouble poly(std::vector<double> xs, double x) {\n    /*\n    Evaluates polynomial with coefficients xs at point x.\n    Returns xs[0] + xs[1] * x + xs[2] * x^2 + .... xs[n] * x^n\n    */\n    double sum = 0;\n    for (size_t i = 0; i < xs.size(); ++i) {\n        sum += xs[i] * std::pow(x, i);\n    }\n    return sum;\n}\n\ndouble find_zero(std::vector<double> xs) {\n    /*\n    xs are coefficients of a polynomial. find_zero finds x such that poly(x) = 0.\n    find_zero returns only one zero point, even if there are many.\n    Moreover, find_zero only takes list xs having an even number of coefficients and the largest non-zero coefficient,\n    which guarantees a solution.\n\n    >>> round(find_zero({1, 2}), 2) // f(x) = 1 + 2x\n    -0.5 \n    >>> round(find_zero({-6, 11, -6, 1}), 2) // (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n    1.0\n    */\n    \n    double low = -1000, high = 1000;\n    double tol = 1e-6;\n\n    // Ensure the interval [low, high] contains a root by checking for sign change.\n    while (poly(xs, low) * poly(xs, high) > 0) {\n        if (std::abs(poly(xs, low)) < std::abs(poly(xs, high))) {\n            low -= 100;\n        } else {\n            high += 100;\n        }\n    }\n\n    // Bisection method to find the root.\n    while ((high - low) > tol) {\n        double mid = (low + high) / 2.0;\n\n        if (poly(xs, mid) == 0 || std::abs(poly(xs, mid)) < tol) {\n            return mid;\n        } else if (poly(xs, low) * poly(xs, mid) < 0) {\n            high = mid;\n        } else {\n            low = mid;\n        }\n    }\n\n    // Return the midpoint as the root.\n    return (low + high) / 2.0;\n}\n\n"}
{"task_id": "CPP/33", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // for std::sort\n\nusing namespace std;\n\nvector<int> sort_third(vector<int> l) {\n    vector<int> to_sort;\n    \n    // Extract values from indices divisible by 3 (0-based indexing)\n    for(size_t i = 0; i < l.size(); i += 3) {\n        to_sort.push_back(l[i]);\n    }\n    \n    // Sort the extracted values\n    sort(to_sort.begin(), to_sort.end());\n    \n    // Replace original elements with sorted ones\n    for(size_t i = 0, j = 0; i < l.size() && j < to_sort.size(); i += 3, ++j) {\n        l[i] = to_sort[j];\n    }\n    \n    return l;\n}\n\n// Function to test the correctness of sort_third function\nvoid check_function() {\n    vector<int> test1 = {1, 2, 3};\n    vector<int> expected1 = {1, 2, 3};\n    assert(sort_third(test1) == expected1);\n\n    vector<int> test2 = {5, 6, 3, 4, 8, 9, 2};\n    vector<int> expected2 = {2, 6, 3, 4, 8, 9, 5};\n    assert(sort_third(test2) == expected2);\n\n    cout << \"All tests passed successfully.\" << endl;\n}\n\n"}
{"task_id": "CPP/34", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // for std::sort and std::unique\n\nusing namespace std;\n\nvector<int> unique(vector<int> l) {\n    // First, sort the vector so that duplicate elements are adjacent.\n    sort(l.begin(), l.end());\n    \n    // Use std::unique to remove consecutive duplicates. It returns a past-the-end iterator for the new range of unique elements.\n    auto last = unique(l.begin(), l.end());\n    \n    // Erase the non-unique part of the vector\n    l.erase(last, l.end());\n    \n    return l;\n}\n\n// Function to print the contents of a vector\nvoid printVector(const vector<int>& v) {\n    for (int i : v) {\n        cout << i << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/35", "generation": "#include <vector>\n#include <algorithm> // For std::numeric_limits\n\nusing namespace std;\n\nfloat max_element(vector<float> l) {\n    if (l.empty()) {  // Check if the vector is empty to avoid undefined behavior.\n        return numeric_limits<float>::lowest(); // Return the lowest possible float value if the vector is empty\n    }\n\n    float max_val = l[0];  // Initialize max_val with the first element of the vector\n\n    for (size_t i = 1; i < l.size(); ++i) {  // Start from the second element and iterate through the rest\n        if (l[i] > max_val) {\n            max_val = l[i];  // Update max_val if a larger value is found\n        }\n    }\n\n    return max_val;\n}\n"}
{"task_id": "CPP/36", "generation": "#include <iostream>\nusing namespace std;\n\nint fizz_buzz(int n) {\n    int count = 0;\n    \n    for (int i = 1; i < n; ++i) {\n        if ((i % 11 == 0 || i % 13 == 0)) { // Check divisibility by 11 or 13\n            int temp = i;\n            while (temp > 0) {\n                if (temp % 10 == 7) count++; // Count digit '7'\n                temp /= 10; // Move to the next digit\n            }\n        }\n    }\n    \n    return count;\n}\n\n"}
{"task_id": "CPP/37", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // for std::sort\n\nusing namespace std;\n\nvector<float> sort_even(vector<float> l) {\n    vector<float> even_elements;\n    \n    // Extract elements at even indices and store them in a separate vector.\n    for (size_t i = 0; i < l.size(); i += 2) {\n        even_elements.push_back(l[i]);\n    }\n    \n    // Sort the extracted even-indexed elements.\n    sort(even_elements.begin(), even_elements.end());\n    \n    // Place sorted elements back into their original positions in vector `l`.\n    for (size_t i = 0, j = 0; i < l.size(); i += 2) {\n        l[i] = even_elements[j++];\n    }\n    \n    return l;\n}\n\n// Function to test the sort_even function with provided data points.\nvoid check() {\n    vector<float> result;\n\n    // Test case 1\n    result = sort_even({1, 2, 3});\n    for (float num : result) cout << num << \" \";\n    cout << endl; // Expected: 1 2 3\n\n    // Test case 2\n    result = sort_even({5, 6, 3, 4});\n    for (float num : result) cout << num << \" \";\n    cout << endl; // Expected: 3 6 5 4\n}\n\n"}
{"task_id": "CPP/38", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\n// Function to encode a string by cycling groups of three characters.\nstring encode_cyclic(string s) { \n    int l = s.length();\n    string output;\n    for (int i = 0; i * 3 < l; i++) {\n        string x = s.substr(i * 3, 3);\n        if (x.length() == 3) x = x.substr(1) + x[0];\n        output += x;\n    }\n    return output;\n}\n\n// Function to decode a string that was encoded with encode_cyclic.\nstring decode_cyclic(string s) { \n    int l = s.length();\n    string output;\n    for (int i = 0; i * 3 < l; i++) {\n        string x = s.substr(i * 3, 3);\n        if (x.length() == 3) x = x[2] + x.substr(0, 2); // Rotate right\n        output += x;\n    }\n    return output;\n}\n\n"}
{"task_id": "CPP/39", "generation": "#include <stdio.h>\n#include <math.h>\n\n// Function to check if a number is prime\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    if (num == 2 || num == 3) return true;\n    if (num % 2 == 0 || num % 3 == 0) return false;\n\n    for (int i = 5; i * i <= num; i += 6) {\n        if (num % i == 0 || num % (i + 2) == 0)\n            return false;\n    }\n    return true;\n}\n\n// Function to find the n-th Fibonacci number that is also prime\nint prime_fib(int n) {\n    int fib1 = 0, fib2 = 1; // First two Fibonacci numbers\n    int count = 0;\n\n    while (true) {\n        int nextFib = fib1 + fib2;\n        if (is_prime(nextFib)) {\n            count++;\n            if (count == n)\n                return nextFib;\n        }\n        fib1 = fib2;\n        fib2 = nextFib;\n    }\n\n    // This line should never be reached\n    return -1;\n}\n\n"}
{"task_id": "CPP/40", "generation": "#include <vector>\n#include <algorithm> // For std::sort\n\nusing namespace std;\n\nbool triples_sum_to_zero(vector<int> l) {\n    int n = l.size();\n    \n    if (n < 3) return false; // Early exit for vectors with less than 3 elements\n    \n    sort(l.begin(), l.end()); // Sort the vector to use two-pointer technique\n    \n    for(int i = 0; i < n-2; ++i) {\n        int left = i + 1, right = n - 1;\n        \n        while(left < right) {\n            int sum = l[i] + l[left] + l[right];\n            \n            if(sum == 0) return true; // Found three numbers that sum to zero\n            else if(sum < 0) ++left; // Need a larger number, move left pointer to the right\n            else --right; // Need a smaller number, move right pointer to the left\n        }\n    }\n    \n    return false; // No triplet found that sums up to zero\n}\n\n// Example usage:\n"}
{"task_id": "CPP/41", "generation": "#include <iostream>\nusing namespace std;\n\nint car_race_collision(int n) {\n    // Since each left-to-right car will eventually collide with exactly one right-to-left car,\n    // and vice versa, the total number of collisions is simply n.\n    return n;\n}\n\n"}
{"task_id": "CPP/42", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> incr_list(vector<int> l) {\n    // Iterate over all elements of the vector.\n    for (size_t i = 0; i < l.size(); ++i) {\n        // Increment each element by 1.\n        l[i] += 1;\n    }\n    return l;\n}\n\n// Function to test the correctness of incr_list function\nvoid check() {\n    vector<int> test1 = {1, 2, 3};\n    vector<int> expected1 = {2, 3, 4};\n    assert(incr_list(test1) == expected1);\n\n    vector<int> test2 = {5, 3, 5, 2, 3, 3, 9, 0, 123};\n    vector<int> expected2 = {6, 4, 6, 3, 4, 4, 10, 1, 124};\n    assert(incr_list(test2) == expected2);\n\n    cout << \"All tests passed successfully.\" << endl;\n}\n\n"}
{"task_id": "CPP/43", "generation": "#include <iostream>\n#include <vector>\n#include <unordered_set> // Use unordered_set for efficient lookup\n\nusing namespace std;\n\nbool pairs_sum_to_zero(vector<int> l) {\n    unordered_set<int> seenNumbers; // Set to keep track of numbers we've seen\n    \n    for (int num : l) { // Iterate through each number in the vector\n        if (seenNumbers.find(-num) != seenNumbers.end()) { // Check if -num is already in the set\n            return true; // Found two numbers that sum to zero\n        }\n        seenNumbers.insert(num); // Add current number to the set\n    }\n    \n    return false; // No pair found that sums to zero\n}\n\n// Function to test the pairs_sum_to_zero function with given data points\nvoid check() {\n    cout << boolalpha; // Print true/false instead of 1/0 for boolean values\n    cout << \"Test Case 1: \" << pairs_sum_to_zero({1, 3, 5, 0}) << endl;\n    cout << \"Test Case 2: \" << pairs_sum_to_zero({1, 3, -2, 1}) << endl;\n    cout << \"Test Case 3: \" << pairs_sum_to_zero({1, 2, 3, 7}) << endl;\n    cout << \"Test Case 4: \" << pairs_sum_to_zero({2, 4, -5, 3, 5, 7}) << endl;\n    cout << \"Test Case 5: \" << pairs_sum_to_zero({1}) << endl;\n}\n\n"}
{"task_id": "CPP/44", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring change_base(int x, int base) {\n    if (base <= 1 || base >= 10) return \"Invalid base\"; // Ensure base is valid\n\n    string result = \"\";\n    while (x > 0) {\n        int remainder = x % base;\n        result = to_string(remainder) + result; // Prepend the remainder\n        x /= base;\n    }\n\n    if(result == \"\") result = \"0\"; // Handle case where x was 0 initially\n\n    return result;\n}\n\n"}
{"task_id": "CPP/45", "generation": "#include<stdio.h>\n\nfloat triangle_area(float a, float h) {\n    // Area of a triangle is 0.5 * base * height\n    return 0.5 * a * h;\n}\n\n"}
{"task_id": "CPP/46", "generation": "#include <iostream>\n#include <vector>\n\nint fib4(int n) {\n    // Base cases for the first four elements of the sequence.\n    if (n == 0 || n == 1)\n        return 0;\n    else if (n == 2)\n        return 2;\n    else if (n == 3)\n        return 0;\n\n    // Initialize an array to store the computed values up to n\n    std::vector<int> fib4_values(n + 1);\n    \n    // Set the base cases.\n    fib4_values[0] = 0;\n    fib4_values[1] = 0;\n    fib4_values[2] = 2;\n    fib4_values[3] = 0;\n\n    // Compute each value from 4 to n using the formula\n    for (int i = 4; i <= n; ++i) {\n        fib4_values[i] = fib4_values[i - 1] + fib4_values[i - 2] + fib4_values[i - 3] + fib4_values[i - 4];\n    }\n\n    // Return the nth value\n    return fib4_values[n];\n}\n\n"}
{"task_id": "CPP/47", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // for std::sort\n\nusing namespace std;\n\nfloat median(vector<float> l){\n    size_t n = l.size();\n    \n    if (n == 0) {\n        throw invalid_argument(\"Vector is empty\");\n    }\n    \n    sort(l.begin(), l.end()); // Sort the vector\n    \n    if (n % 2 != 0) { // If odd number of elements\n        return l[n / 2];\n    } else { // If even number of elements\n        return (l[(n - 1) / 2] + l[n / 2]) / 2.0;\n    }\n}\n\n"}
{"task_id": "CPP/48", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_palindrome(string text) {\n    int left = 0;\n    int right = text.length() - 1;\n\n    while (left < right) {\n        if (text[left] != text[right]) {\n            return false; // Characters do not match\n        }\n        left++;\n        right--;\n    }\n\n    return true; // All characters matched, it's a palindrome\n}\n\n"}
{"task_id": "CPP/49", "generation": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\n// Function to calculate (base^exponent) % mod using iterative method to avoid overflow.\nint modpow(int base, int exponent, int mod) {\n    long long result = 1;\n    long long b = base % mod; // Ensure the base is within modulo range\n    while (exponent > 0) {\n        if (exponent & 1)\n            result = (result * b) % mod;\n        exponent >>= 1;\n        b = (b * b) % mod;\n    }\n    return result;\n}\n\nint modp(int n, int p) {\n    // Calculate 2^n modulo p\n    return modpow(2, n, p);\n}\n"}
{"task_id": "CPP/50", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nstring encode_shift(string s) {\n    // returns encoded string by shifting every character by 5 in the alphabet.\n    string out;\n    int i;\n    for (i = 0; i < s.length(); i++) {\n        int w = ((int)s[i] + 5 - (int)'a') % 26 + (int)'a';\n        out += (char)w;\n    }\n    return out;\n}\n\nstring decode_shift(string s) {\n    // takes as input string encoded with encode_shift function. Returns decoded string.\n    string out;\n    int i;\n    for (i = 0; i < s.length(); i++) {\n        int w = ((int)s[i] - 5 - (int)'a' + 26) % 26 + (int)'a'; // Adding 26 to ensure positive result\n        out += (char)w;\n    }\n    return out;\n}\n\n// Example usage:\n"}
{"task_id": "CPP/51", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool isVowel(char c) {\n    // Convert character to lowercase for simplicity and check if it's a vowel.\n    char lower_c = tolower(c);\n    return (lower_c == 'a' || lower_c == 'e' || lower_c == 'i' || lower_c == 'o' || lower_c == 'u');\n}\n\nstring remove_vowels(string text) {\n    string result;\n    for(char c : text) {\n        if(!isVowel(c)) { // If the character is not a vowel, add it to the result.\n            result += c;\n        }\n    }\n    return result;\n}\n\n"}
{"task_id": "CPP/52", "generation": "#include <vector>\nusing namespace std;\n\nbool below_threshold(vector<int> l, int t) {\n    // Iterate through each element in the vector\n    for (int num : l) {\n        // If any number is greater than or equal to the threshold, return false\n        if (num >= t) {\n            return false;\n        }\n    }\n    // If all numbers are below the threshold, return true\n    return true;\n}\n\n// Example usage:\n/*\nbool result1 = below_threshold({1, 2, 4, 10}, 100); // Should be true\nbool result2 = below_threshold({1, 20, 4, 10}, 5);   // Should be false\n*/\n"}
{"task_id": "CPP/53", "generation": "#include<iostream>\nusing namespace std;\n\nint add(int x, int y) {\n    return x + y;\n}\n\n// Example usage\n"}
{"task_id": "CPP/54", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nbool same_chars(string s0, string s1) {\n    // Sort both strings to bring identical characters together.\n    sort(s0.begin(), s0.end());\n    sort(s1.begin(), s1.end());\n\n    // Remove duplicate characters from each sorted string.\n    auto last_unique_s0 = unique(s0.begin(), s0.end());\n    auto last_unique_s1 = unique(s1.begin(), s1.end());\n\n    // Erase the duplicates in place to get only unique characters.\n    s0.erase(last_unique_s0, s0.end());\n    s1.erase(last_unique_s1, s1.end());\n\n    // Compare the two strings for equality after processing.\n    return s0 == s1;\n}\n\n"}
{"task_id": "CPP/55", "generation": "#include<stdio.h>\n\nint fib(int n) {\n    if (n <= 1)\n        return n;\n    else\n        return fib(n-1) + fib(n-2);\n}\n\n"}
{"task_id": "CPP/56", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    int balance = 0;\n    \n    for (char c : brackets) {\n        if (c == '<') {\n            ++balance; // Increment for an opening bracket\n        } else if (c == '>') {\n            --balance; // Decrement for a closing bracket\n            \n            // If balance goes below zero, there's an unmatched closing bracket\n            if (balance < 0) return false;\n        }\n    }\n    \n    // Return true only if the balance is back to zero at the end\n    return balance == 0;\n}\n\n"}
{"task_id": "CPP/57", "generation": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nbool isMonotonicIncreasing(const vector<float>& l) {\n    for (size_t i = 1; i < l.size(); ++i) {\n        if (l[i - 1] > l[i]) return false;\n    }\n    return true;\n}\n\nbool isMonotonicDecreasing(const vector<float>& l) {\n    for (size_t i = 1; i < l.size(); ++i) {\n        if (l[i - 1] < l[i]) return false;\n    }\n    return true;\n}\n\nbool monotonic(vector<float> l) {\n    return isMonotonicIncreasing(l) || isMonotonicDecreasing(l);\n}\n"}
{"task_id": "CPP/58", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // For sort function\n#include <set>       // To store unique elements\n\nusing namespace std;\n\nvector<int> common(vector<int> l1, vector<int> l2) {\n    // Sort both vectors to make it easier to find common elements.\n    sort(l1.begin(), l1.end());\n    sort(l2.begin(), l2.end());\n\n    set<int> result;  // Use a set to store unique and sorted results\n    auto it1 = l1.begin();\n    auto it2 = l2.begin();\n\n    // Traverse both vectors to find common elements\n    while (it1 != l1.end() && it2 != l2.end()) {\n        if (*it1 == *it2) {\n            result.insert(*it1);\n            ++it1;\n            ++it2;\n        } else if (*it1 < *it2) {\n            ++it1;\n        } else {\n            ++it2;\n        }\n    }\n\n    // Convert set to vector\n    return vector<int>(result.begin(), result.end());\n}\n\n// Function to print the elements of a vector\nvoid printVector(const vector<int>& vec) {\n    for (int num : vec) {\n        cout << num << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/59", "generation": "#include <stdio.h>\n#include <stdbool.h>\n\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    for (int i = 2; i * i <= num; ++i) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\nint largest_prime_factor(int n){\n    int largestFactor = -1;\n\n    // Divide n by 2 to remove all even factors\n    while (n % 2 == 0) {\n        largestFactor = 2;\n        n /= 2;\n    }\n\n    // Now we only have odd factors left, start from 3 and check each odd number.\n    for (int i = 3; i * i <= n; i += 2) {\n        while (n % i == 0) {\n            largestFactor = i;\n            n /= i;\n        }\n    }\n\n    // If n is a prime number greater than 2\n    if (n > 2)\n        largestFactor = n;\n\n    return largestFactor;\n}\n\n"}
{"task_id": "CPP/60", "generation": "#include<iostream>\nusing namespace std;\n\nint sum_to_n(int n){\n    int sum = 0;\n    for (int i = 1; i <= n; ++i) {\n        sum += i;\n    }\n    return sum;\n}\n\n// Function to test the correctness of sum_to_n\nvoid check_function() {\n    cout << \"sum_to_n(30): \" << sum_to_n(30) << endl; // Expected output: 465\n    cout << \"sum_to_n(100): \" << sum_to_n(100) << endl; // Expected output: 5050\n    cout << \"sum_to_n(5): \" << sum_to_n(5) << endl; // Expected output: 15\n    cout << \"sum_to_n(10): \" << sum_to_n(10) << endl; // Expected output: 55\n    cout << \"sum_to_n(1): \" << sum_to_n(1) << endl; // Expected output: 1\n}\n\n"}
{"task_id": "CPP/61", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    int balance = 0; // Initialize balance counter\n\n    for (char c : brackets) { // Iterate through each character in the string\n        if (c == '(') {\n            ++balance; // Increment balance for an opening bracket\n        } else if (c == ')') {\n            --balance; // Decrement balance for a closing bracket\n            if (balance < 0) return false; // If balance is negative, there's a closing bracket without a matching opening one\n        }\n    }\n\n    return balance == 0; // True if all brackets are correctly matched and balanced\n}\n\n"}
{"task_id": "CPP/62", "generation": "#include <iostream>\n#include <vector>\n\nstd::vector<float> derivative(const std::vector<float>& xs) {\n    // Create an empty vector to store the coefficients of the derivative polynomial\n    std::vector<float> result;\n\n    // Iterate through each coefficient starting from the first non-constant term (index 1)\n    for(size_t i = 1; i < xs.size(); ++i) {\n        // Multiply the current coefficient by its index and add it to the result vector\n        result.push_back(xs[i] * static_cast<float>(i));\n    }\n\n    return result;\n}\n\n// Function to test the derivative function with given examples\nvoid check_derivative() {\n    std::vector<float> example1 = {3, 1, 2, 4, 5};\n    std::vector<float> expected1 = {1, 4, 12, 20};\n    \n    std::vector<float> result1 = derivative(example1);\n    assert(result1 == expected1);\n\n    std::vector<float> example2 = {1, 2, 3};\n    std::vector<float> expected2 = {2, 6};\n\n    std::vector<float> result2 = derivative(example2);\n    assert(result2 == expected2);\n\n    std::cout << \"All tests passed successfully.\" << std::endl;\n}\n\n"}
{"task_id": "CPP/63", "generation": "#include <iostream>\n#include <vector>\n\nint fibfib(int n) {\n    // Base cases\n    if (n == 0 || n == 1)\n        return 0;\n    else if (n == 2)\n        return 1;\n\n    // Initialize a vector to store the computed values of fibfib sequence.\n    std::vector<int> dp(n + 1);\n    dp[0] = 0;   // fibfib(0) is 0\n    dp[1] = 0;   // fibfib(1) is 0\n    dp[2] = 1;   // fibfib(2) is 1\n\n    // Compute the values from 3 to n using the recurrence relation.\n    for (int i = 3; i <= n; ++i)\n        dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3];\n\n    return dp[n];\n}\n\n// Function to test the fibfib function with given data points\nvoid check() {\n    std::cout << \"fibfib(1) should be 0: \" << (fibfib(1) == 0 ? \"Passed\" : \"Failed\") << std::endl;\n    std::cout << \"fibfib(5) should be 4: \" << (fibfib(5) == 4 ? \"Passed\" : \"Failed\") << std::endl;\n    std::cout << \"fibfib(8) should be 24: \" << (fibfib(8) == 24 ? \"Passed\" : \"Failed\") << std::endl;\n}\n\n"}
{"task_id": "CPP/64", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint vowels_count(string s) {\n    int count = 0;\n    // Convert string to lowercase for simplicity\n    transform(s.begin(), s.end(), s.begin(), ::tolower);\n\n    // Check each character in the string\n    for (size_t i = 0; i < s.length(); ++i) {\n        char c = s[i];\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n            count++;\n        }\n        // Check for 'y' at the end of the string\n        else if (c == 'y' && i == s.length() - 1) {\n            count++;\n        }\n    }\n\n    return count;\n}\n\n"}
{"task_id": "CPP/65", "generation": "#include <iostream>\n#include <string>\n#include <algorithm> // for std::reverse\nusing namespace std;\n\nstring circular_shift(int x, int shift) {\n    string digits = to_string(x);\n    size_t num_digits = digits.size();\n    \n    if (shift >= num_digits) {\n        reverse(digits.begin(), digits.end());\n        return digits;\n    }\n    \n    size_t actual_shift = shift % num_digits;\n    rotate(digits.rbegin(), digits.rbegin() + actual_shift, digits.rend());\n    return digits;\n}\n"}
{"task_id": "CPP/66", "generation": "#include <iostream>\n#include <string>\n#include <cctype> // For isupper() function\n\nusing namespace std;\n\nint digitSum(string s) {\n    int sum = 0;\n    for (char c : s) { // Iterate through each character in the string\n        if (isupper(c)) { // Check if the character is an uppercase letter\n            sum += static_cast<int>(c); // Add its ASCII value to sum\n        }\n    }\n    return sum; // Return the total sum of ASCII values of uppercase letters\n}\n\n"}
{"task_id": "CPP/67", "generation": "#include <iostream>\n#include <string>\n#include <vector>\n#include <sstream>\nusing namespace std;\n\nint fruit_distribution(string s, int n) {\n    vector<int> nums;\n    stringstream ss(s);\n    string word;\n    \n    while (ss >> word) {\n        if (stringstream(word) >> word) {\n            nums.push_back(stoi(word));\n        }\n    }\n\n    // Extracting the number of apples and oranges\n    int apples = nums[0];\n    int oranges = nums[1];\n\n    // Calculating the number of mangoes\n    int mangoes = n - (apples + oranges);\n    \n    return mangoes;\n}\n"}
{"task_id": "CPP/68", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> pluck(vector<int> arr) {\n    int minValue = INT_MAX; // Initialize to a very large number.\n    int minIndex = -1;      // No valid index found initially.\n\n    for (int i = 0; i < arr.size(); ++i) {\n        if (arr[i] % 2 == 0 && arr[i] <= minValue) { // Check if the value is even and smaller or equal to current min.\n            if (arr[i] < minValue || (arr[i] == minValue && i < minIndex)) {\n                minValue = arr[i];\n                minIndex = i;\n            }\n        }\n    }\n\n    if (minIndex != -1) { // If a valid index was found, return the value and its index.\n        return {minValue, minIndex};\n    } else { // No even number found or vector is empty.\n        return {};\n    }\n}\n"}
{"task_id": "CPP/69", "generation": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint search(vector<int> lst) {\n    unordered_map<int, int> freqMap;\n    \n    // Count frequencies of each element in the list\n    for (int num : lst) {\n        freqMap[num]++;\n    }\n    \n    int result = -1;  // Initialize result as -1\n    \n    // Check each frequency against its value\n    for (auto &entry : freqMap) {\n        if (entry.first <= entry.second && entry.first > result) {\n            result = entry.first;\n        }\n    }\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/70", "generation": "#include <vector>\n#include <algorithm>\n\nstd::vector<int> strange_sort_list(std::vector<int> lst) {\n    // Sort the vector initially.\n    std::sort(lst.begin(), lst.end());\n    \n    std::vector<int> result;\n    int left = 0; // Start index for minimum value\n    int right = lst.size() - 1; // End index for maximum value\n    \n    while (left <= right) {\n        if (left == right) {\n            // If there's only one element left, add it to the result.\n            result.push_back(lst[left]);\n            break;\n        }\n        \n        // Add the minimum value\n        result.push_back(lst[left++]);\n        // Add the maximum value\n        result.push_back(lst[right--]);\n    }\n\n    return result;\n}\n\n// Example usage:\n"}
{"task_id": "CPP/71", "generation": "#include<stdio.h>\n#include<math.h>\n\nfloat triangle_area(float a, float b, float c){\n    // Check if sides form a valid triangle\n    if (a + b <= c || a + c <= b || b + c <= a) {\n        return -1;\n    }\n\n    // Calculate the semi-perimeter\n    float s = (a + b + c) / 2;\n\n    // Use Heron's formula to calculate area\n    float area = sqrt(s * (s - a) * (s - b) * (s - c));\n\n    // Round the result to two decimal points and return\n    return round(area * 100) / 100;\n}\n\n"}
{"task_id": "CPP/72", "generation": "#include <vector>\nusing namespace std;\n\nbool will_it_fly(vector<int> q, int w) {\n    // Check if the vector is balanced (palindromic)\n    for(int i = 0; i < q.size() / 2; ++i) {\n        if(q[i] != q[q.size() - 1 - i]) return false;\n    }\n\n    // Calculate the sum of elements in the vector\n    int sum = 0;\n    for(int num : q) {\n        sum += num;\n    }\n\n    // Check if the sum is less than or equal to the maximum possible weight w\n    return sum <= w;\n}\n"}
{"task_id": "CPP/73", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint smallest_change(vector<int> arr) {\n    int changes = 0;\n    int left = 0;\n    int right = arr.size() - 1;\n\n    while (left < right) {\n        if (arr[left] != arr[right]) {\n            ++changes; // Increment the change count when elements don't match\n        }\n        ++left;\n        --right;\n    }\n\n    return changes;\n}\n\n"}
{"task_id": "CPP/74", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to calculate the total number of characters in a vector of strings.\nint countChars(const vector<string>& lst) {\n    int count = 0;\n    for (const string& str : lst) {\n        count += str.length();\n    }\n    return count;\n}\n\nvector<string> total_match(vector<string> lst1, vector<string> lst2) {\n    // Calculate the number of characters in each list\n    int charsInLst1 = countChars(lst1);\n    int charsInLst2 = countChars(lst2);\n\n    // Compare and return the appropriate list\n    if (charsInLst1 <= charsInLst2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n\n// Function to test the solution with given examples.\nvoid check() {\n    vector<string> empty = {};\n    vector<string> result;\n\n    // Example 1\n    result = total_match(empty, empty);\n    cout << \"Example 1: \";\n    for (const string& str : result) cout << str << \" \";\n    cout << endl;\n\n    // Example 2\n    result = total_match({\"hi\", \"admin\"}, {\"hI\", \"Hi\"});\n    cout << \"Example 2: \";\n    for (const string& str : result) cout << str << \" \";\n    cout << endl;\n\n    // Example 3\n    result = total_match({\"hi\", \"admin\"}, {\"hi\", \"hi\", \"admin\", \"project\"});\n    cout << \"Example 3: \";\n    for (const string& str : result) cout << str << \" \";\n    cout << endl;\n\n    // Example 4\n    result = total_match({\"hi\", \"admin\"}, {\"hI\", \"hi\", \"hi\"});\n    cout << \"Example 4: \";\n    for (const string& str : result) cout << str << \" \";\n    cout << endl;\n\n    // Example 5\n    result = total_match({\"4\"}, {\"1\", \"2\", \"3\", \"4\", \"5\"});\n    cout << \"Example 5: \";\n    for (const string& str : result) cout << str << \" \";\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/75", "generation": "#include <iostream>\nusing namespace std;\n\n// Function to check if a number is prime.\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0)\n            return false;\n    }\n    return true;\n}\n\n// Function to check if a number can be expressed as the product of exactly three prime numbers.\nbool is_multiply_prime(int a) {\n    // Iterate through all possible combinations of primes less than 100\n    for (int i = 2; i < 100 && i * i * i <= a; ++i) {\n        if (!is_prime(i)) continue;\n        \n        for (int j = i; j < 100 && i * j * j <= a; ++j) {\n            if (!is_prime(j)) continue;\n\n            for (int k = j; k < 100; ++k) {\n                if (!is_prime(k)) continue;\n                \n                // Check if the product of these three primes equals 'a'\n                if (i * j * k == a)\n                    return true;\n            }\n        }\n    }\n\n    return false;\n}\n\n"}
{"task_id": "CPP/76", "generation": "#include <cmath> // For log and pow functions\n\nbool is_simple_power(int x, int n) {\n    if (n == 1) return x == 1; // Special case: only 1^k = 1 for any k.\n    \n    double log_result = std::log(x) / std::log(n); // Calculate the logarithm of x with base n\n    \n    // Check if the result is an integer by comparing it to its rounded value\n    return std::abs(log_result - std::round(log_result)) < 1e-9; \n}\n\n"}
{"task_id": "CPP/77", "generation": "#include <cmath> // For std::cbrt and std::round\n\nbool iscube(int a) {\n    double cubeRoot = std::cbrt(a); // Calculate the cube root of 'a'\n    int nearestInt = std::round(cubeRoot); // Round to the nearest integer\n    \n    // Check if the cube of the rounded value equals 'a'\n    return (nearestInt * nearestInt * nearestInt == a);\n}\n\n"}
{"task_id": "CPP/78", "generation": "#include <iostream>\n#include <string>\n#include <set>\n\nusing namespace std;\n\nint hex_key(string num) {\n    // Set of prime hexadecimal digits\n    set<char> primes = {'2', '3', '5', '7', 'B', 'D'};\n    \n    int count = 0;\n    for (char c : num) {\n        if (primes.find(c) != primes.end()) {\n            ++count;\n        }\n    }\n    \n    return count;\n}\n\n"}
{"task_id": "CPP/79", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring decimal_to_binary(int decimal) {\n    // Convert the number to binary using bit manipulation.\n    string binary = \"\";\n    \n    if (decimal == 0) {\n        return \"db0db\"; // Special case for zero\n    }\n    \n    while (decimal > 0) {\n        int remainder = decimal % 2;\n        binary = char('0' + remainder) + binary; // Convert the remainder to a character and prepend it.\n        decimal /= 2;\n    }\n\n    return \"db\" + binary + \"db\"; // Add 'db' at both ends\n}\n\n"}
{"task_id": "CPP/80", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_happy(string s) {\n    // Check if the length of the string is less than 3, return false immediately.\n    if (s.length() < 3) {\n        return false;\n    }\n\n    // Iterate through the string to check every set of three consecutive characters\n    for (int i = 0; i <= s.length() - 3; ++i) {\n        // Check if any two out of three consecutive characters are the same.\n        if (s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]) {\n            return false;\n        }\n    }\n\n    // If all checks pass, the string is happy\n    return true;\n}\n\n"}
{"task_id": "CPP/81", "generation": "#include <vector>\n#include <string>\n\nusing namespace std;\n\n// Renamed the function to match the original name given in the problem statement.\nvector<string> numerical_letter_grade(vector<float> gpas) {\n    vector<string> letter_grades;\n    \n    for (float gpa : gpas) {\n        if (gpa == 4.0f)\n            letter_grades.push_back(\"A+\");\n        else if (gpa > 3.7f)\n            letter_grades.push_back(\"A\");\n        else if (gpa > 3.3f)\n            letter_grades.push_back(\"A-\");\n        else if (gpa > 3.0f)\n            letter_grades.push_back(\"B+\");\n        else if (gpa > 2.7f)\n            letter_grades.push_back(\"B\");\n        else if (gpa > 2.3f)\n            letter_grades.push_back(\"B-\");\n        else if (gpa > 2.0f)\n            letter_grades.push_back(\"C+\");\n        else if (gpa > 1.7f)\n            letter_grades.push_back(\"C\");\n        else if (gpa > 1.3f)\n            letter_grades.push_back(\"C-\");\n        else if (gpa > 1.0f)\n            letter_grades.push_back(\"D+\");\n        else if (gpa > 0.7f)\n            letter_grades.push_back(\"D\");\n        else if (gpa > 0.0f)\n            letter_grades.push_back(\"D-\");\n        else\n            letter_grades.push_back(\"E\");\n    }\n    \n    return letter_grades;\n}\n"}
{"task_id": "CPP/82", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\n// Helper function to check if a number is prime.\nbool is_prime(int n) {\n    if (n <= 1) return false; // 0 and 1 are not primes\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\n// Main function to check if the length of a string is prime.\nbool prime_length(string str){\n    int len = str.length();\n    return is_prime(len);\n}\n\n"}
{"task_id": "CPP/83", "generation": "#include <cmath> // For pow function\n#include <iostream>\n\nint starts_one_ends(int n) {\n    if (n == 1)\n        return 1;\n\n    long long count = 2 * static_cast<long long>(pow(10, n - 1)) - static_cast<long long>(pow(10, n - 2));\n    return static_cast<int>(count);\n}\n"}
{"task_id": "CPP/84", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\n// Function to calculate the sum of digits of N\nint sumOfDigits(int N) {\n    int sum = 0;\n    while (N > 0) {\n        sum += N % 10; // Add the last digit to sum\n        N /= 10;       // Remove the last digit from N\n    }\n    return sum;\n}\n\n// Function to convert an integer to its binary string representation\nstring intToBinary(int num) {\n    if (num == 0) return \"0\"; // Special case for zero\n\n    string binary = \"\";\n    while (num > 0) {\n        binary = to_string(num % 2) + binary; // Prepend the remainder of division by 2\n        num /= 2;\n    }\n    return binary;\n}\n\nstring solve(int N){\n    int sumDigits = sumOfDigits(N); // Calculate the sum of digits\n    string resultBinary = intToBinary(sumDigits); // Convert the sum to binary string\n    return resultBinary; // Return the binary representation as a string\n}\n\n// Example usage:\n"}
{"task_id": "CPP/85", "generation": "#include <vector>\nusing namespace std;\n\nint add(vector<int> lst) {\n    int sum = 0;\n    \n    // Iterate through the list with an index starting from 1 (the first odd index)\n    for(int i = 1; i < lst.size(); i += 2) { // Increment by 2 to stay at odd indices\n        if(lst[i] % 2 == 0) { // Check if the element is even\n            sum += lst[i]; // Add it to the sum\n        }\n    }\n\n    return sum;\n}\n"}
{"task_id": "CPP/86", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nstring anti_shuffle(string s) {\n    // Temporary variables to hold the current word and its sorted version.\n    string tempWord = \"\";\n    string result = \"\";\n\n    for (char c : s) {\n        if (c == ' ') {  // If we encounter a space, process the collected word\n            sort(tempWord.begin(), tempWord.end());  // Sort characters in ascending order based on ASCII value\n            result += tempWord + \" \";  // Append sorted word and space to the result\n            tempWord = \"\";  // Reset for next word\n        } else {\n            tempWord += c;  // Collect characters of current word\n        }\n    }\n\n    if (!tempWord.empty()) {  // Process any remaining word after last space or at end of string\n        sort(tempWord.begin(), tempWord.end());\n        result += tempWord;\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/87", "generation": "#include <vector>\n#include <algorithm> // for std::sort\n\nusing namespace std;\n\nbool compare(const vector<int>& a, const vector<int>& b) {\n    if (a[0] != b[0]) return a[0] < b[0]; // sort by row in ascending order\n    else return a[1] > b[1];              // then by column in descending order within the same row\n}\n\nvector<vector<int>> get_row(vector<vector<int>> lst, int x) {\n    vector<vector<int>> coordinates;\n    \n    for (int i = 0; i < lst.size(); ++i) { // iterate through each row\n        for (int j = 0; j < lst[i].size(); ++j) { // iterate through each element in the current row\n            if (lst[i][j] == x) {\n                coordinates.push_back({i, j}); // store the coordinate of found integer\n            }\n        }\n    }\n\n    sort(coordinates.begin(), coordinates.end(), compare); // sort according to specified rules\n\n    return coordinates;\n}\n\n// Example usage:\n"}
{"task_id": "CPP/88", "generation": "#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> sort_array(vector<int> array) {\n    // Check if the vector is empty or contains only one element\n    if (array.size() <= 1) return array;\n    \n    // Calculate the sum of the first and last elements\n    int sum = array.front() + array.back();\n    \n    // Create a copy to avoid modifying the original vector\n    vector<int> sortedArray(array);\n    \n    // Sort based on whether the sum is odd or even\n    if (sum % 2 == 0) {\n        sort(sortedArray.begin(), sortedArray.end(), greater<int>());\n    } else {\n        sort(sortedArray.begin(), sortedArray.end());\n    }\n    \n    return sortedArray;\n}\n\n// Example usage:\n"}
{"task_id": "CPP/89", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring encrypt(string s){\n    for (int i = 0; i < s.length(); ++i) {\n        char c = s[i];\n        \n        // Check if the character is a lowercase letter.\n        if ('a' <= c && c <= 'z') {\n            // Shift by 4 positions and wrap around using modulo operation\n            s[i] = ((c - 'a' + 4) % 26) + 'a';\n        }\n        \n        // Check if the character is an uppercase letter.\n        else if ('A' <= c && c <= 'Z') {\n            // Shift by 4 positions and wrap around using modulo operation\n            s[i] = ((c - 'A' + 4) % 26) + 'A';\n        }\n    }\n    \n    return s;\n}\n\n"}
{"task_id": "CPP/90", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint next_smallest(vector<int> lst) {\n    if (lst.size() < 2) { // If the list has less than two elements, return -1.\n        return -1;\n    }\n\n    sort(lst.begin(), lst.end()); // Sort the vector to find the smallest and second smallest elements easily.\n\n    int first = lst[0]; // The smallest element is now at index 0 after sorting.\n    \n    for (int i = 1; i < lst.size(); ++i) {\n        if (lst[i] != first) { // Find the next unique element which will be the second smallest.\n            return lst[i];\n        }\n    }\n\n    // If all elements are the same, there is no second smallest element.\n    return -1;\n}\n\n"}
{"task_id": "CPP/91", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nint is_bored(string S) {\n    int boredom_count = 0;\n    \n    // Use a stringstream to split the string into sentences.\n    stringstream ss(S);\n    string sentence;\n    char delimiters[] = {'.', '?', '!'};\n\n    while (getline(ss, sentence)) {\n        bool found_delimiter = false;\n\n        for(char delimiter : delimiters) {\n            size_t pos = 0;\n            while ((pos = sentence.find(delimiter, pos)) != string::npos) {\n                // Extract the substring up to the current delimiter.\n                string sub_sentence = sentence.substr(0, pos);\n                \n                // Trim leading spaces from the extracted substring.\n                sub_sentence.erase(0, sub_sentence.find_first_not_of(\" \"));\n                \n                if (!sub_sentence.empty() && sub_sentence[0] == 'I' && (sub_sentence.size() > 1 ? isspace(sub_sentence[1]) : true)) {\n                    boredom_count++;\n                }\n                \n                // Move past the delimiter for next iteration.\n                pos += 1;\n            }\n\n            found_delimiter = true;\n        }\n\n        if (!found_delimiter) {\n            sentence.erase(0, sentence.find_first_not_of(\" \"));\n            \n            if (!sentence.empty() && sentence[0] == 'I' && (sentence.size() > 1 ? isspace(sentence[1]) : true)) {\n                boredom_count++;\n            }\n        }\n    }\n\n    return boredom_count;\n}\n\n"}
{"task_id": "CPP/92", "generation": "#include <iostream>\n#include <cmath>\n\nbool any_int(float a, float b, float c) {\n    // Check if all numbers are integers by comparing them with their floor values.\n    bool is_a_integer = (a == std::floor(a));\n    bool is_b_integer = (b == std::floor(b));\n    bool is_c_integer = (c == std::floor(c));\n\n    // If any of the numbers are not integers, return false\n    if (!is_a_integer || !is_b_integer || !is_c_integer) {\n        return false;\n    }\n\n    // Check if one number equals the sum of the other two.\n    if ((a + b == c) || (b + c == a) || (c + a == b)) {\n        return true;\n    } else {\n        return false;\n    }\n}\n\n"}
{"task_id": "CPP/93", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\n// Function to encode a message according to the given rules.\nstring encode(string message) {\n    // Iterate through each character of the string.\n    for (char &c : message) {\n        // Swap case: if lowercase, convert to uppercase and vice versa.\n        if (islower(c)) c = toupper(c);\n        else if (isupper(c)) c = tolower(c);\n\n        // Replace vowels with the letter that appears 2 places ahead in the alphabet.\n        switch (tolower(c)) {\n            case 'a': c = islower(c) ? 'c' : 'C'; break;\n            case 'e': c = islower(c) ? 'g' : 'G'; break;\n            case 'i': c = islower(c) ? 'k' : 'K'; break;\n            case 'o': c = islower(c) ? 'q' : 'Q'; break;\n            case 'u': c = islower(c) ? 'w' : 'W'; break;\n        }\n    }\n\n    return message;\n}\n\n"}
{"task_id": "CPP/94", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to check if a number is prime\nbool isPrime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\n// Function to calculate the sum of digits of a number\nint sumOfDigits(int num) {\n    int sum = 0;\n    while (num > 0) {\n        sum += num % 10;\n        num /= 10;\n    }\n    return sum;\n}\n\n// Main function to find the largest prime and sum its digits\nint skjkasdkd(vector<int> lst){\n    int maxPrime = -1; // Initialize with a non-prime value\n    \n    // Iterate through the list to find the largest prime number\n    for (int num : lst) {\n        if (isPrime(num)) {\n            maxPrime = max(maxPrime, num);\n        }\n    }\n\n    // If no prime was found, return 0 or handle as needed\n    if (maxPrime == -1) return 0;\n\n    // Calculate and return the sum of digits of the largest prime number\n    return sumOfDigits(maxPrime);\n}\n\n// Function to test the solution with given examples\nvoid check() {\n    cout << skjkasdkd({0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3}) << endl; // 10\n    cout << skjkasdkd({1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1}) << endl; // 25\n    cout << skjkasdkd({1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3}) << endl; // 13\n    cout << skjkasdkd({0,724,32,71,99,32,6,0,5,91,83,0,5,6}) << endl; // 11\n    cout << skjkasdkd({0,81,12,3,1,21}) << endl; // 3\n    cout << skjkasdkd({0,8,1,2,1,7}) << endl; // 7\n}\n\n"}
{"task_id": "CPP/95", "generation": "#include <string>\n#include <map>\n#include <cctype>\nusing namespace std;\n\nbool check_dict_case(map<string, string> dict) {\n    if (dict.empty()) return false;\n    \n    bool all_lower = true;\n    bool all_upper = true;\n    \n    for (const auto& kv : dict) {\n        const string& key = kv.first;\n        \n        // Check each character in the key\n        for (char c : key) {\n            if (!islower(c)) all_lower = false;\n            if (!isupper(c)) all_upper = false;\n        }\n    }\n\n    return all_lower || all_upper;\n}\n"}
{"task_id": "CPP/96", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// Helper function to check if a number is prime\nbool is_prime(int num) {\n    if (num <= 1) return false; // 0 and 1 are not primes\n    for (int i = 2; i * i <= num; ++i) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\nvector<int> count_up_to(int n){\n    vector<int> primes;\n    \n    // Iterate through all numbers from 2 up to but not including n\n    for (int i = 2; i < n; ++i) {\n        if (is_prime(i)) {\n            primes.push_back(i);\n        }\n    }\n\n    return primes;\n}\n\n// Function to test the implementation with given examples\nvoid check() {\n    vector<int> result;\n\n    result = count_up_to(5); // Expected: {2, 3}\n    for(int num : result) cout << num << \" \";\n    cout << endl;\n\n    result = count_up_to(11); // Expected: {2, 3, 5, 7}\n    for(int num : result) cout << num << \" \";\n    cout << endl;\n\n    result = count_up_to(0); // Expected: {}\n    if(result.empty()) cout << \"{}\" << endl;\n    \n    result = count_up_to(20); // Expected: {2, 3, 5, 7, 11, 13, 17, 19}\n    for(int num : result) cout << num << \" \";\n    cout << endl;\n\n    result = count_up_to(1); // Expected: {}\n    if(result.empty()) cout << \"{}\" << endl;\n    \n    result = count_up_to(18); // Expected: {2, 3, 5, 7, 11, 13, 17}\n    for(int num : result) cout << num << \" \";\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/97", "generation": "#include<stdio.h>\n\nint multiply(int a, int b) {\n    // Extracting the unit digits\n    int unitDigitA = abs(a) % 10;\n    int unitDigitB = abs(b) % 10;\n\n    // Calculating and returning the product of the unit digits\n    return unitDigitA * unitDigitB;\n}\n\n"}
{"task_id": "CPP/98", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint count_upper(string s) {\n    int count = 0;\n    \n    // Iterate through the string with even indices only.\n    for (size_t i = 0; i < s.length(); i += 2) { // Start from index 0 and increment by 2\n        char c = s[i];\n        \n        // Check if it's an uppercase vowel\n        if (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n            count++;\n        }\n    }\n\n    return count;\n}\n\n"}
{"task_id": "CPP/99", "generation": "#include <iostream>\n#include <cmath>\n#include <string>\n\nusing namespace std;\n\nint closest_integer(string value) {\n    // Convert string to double for precision handling\n    double num = stod(value);\n    \n    // Check if the number is positive or negative\n    bool isPositive = num > 0;\n    \n    // Calculate the floor and ceil values of the number\n    int floorValue = static_cast<int>(floor(num));\n    int ceilValue = static_cast<int>(ceil(num));\n    \n    // Determine which integer to round towards based on the distance from the decimal part\n    double fractionalPart = num - floorValue;\n    \n    if (fractionalPart == 0.5) {\n        // If equidistant, round away from zero\n        return isPositive ? ceilValue : floorValue;\n    } else {\n        // Otherwise, use standard rounding rules\n        return static_cast<int>(round(num));\n    }\n}\n\n// Function to test the closest_integer function with given examples\nvoid check() {\n    cout << \"Testing '10': Expected 10, Got: \" << closest_integer(\"10\") << endl;\n    cout << \"Testing '15.3': Expected 15, Got: \" << closest_integer(\"15.3\") << endl;\n    cout << \"Testing '14.5': Expected 15, Got: \" << closest_integer(\"14.5\") << endl;\n    cout << \"Testing '-14.5': Expected -15, Got: \" << closest_integer(\"-14.5\") << endl;\n}\n\n"}
{"task_id": "CPP/100", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> make_a_pile(int n) {\n    vector<int> pile;\n    \n    // Start with the first level having 'n' stones.\n    int current_stones = n;\n    \n    for (int i = 0; i < n; ++i) {\n        pile.push_back(current_stones);\n        \n        // Determine the next number of stones based on whether current is odd or even\n        if (current_stones % 2 == 0) { // If current_stones is even, add 2 to get the next even number.\n            current_stones += 2;\n        } else { // If current_stones is odd, add 2 to get the next odd number.\n            current_stones += 2;\n        }\n    }\n\n    return pile;\n}\n\n// Example usage\n"}
{"task_id": "CPP/101", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> words_string(string s) {\n    vector<string> result;\n    string word = \"\";\n    \n    for (char c : s) {\n        if (c == ' ' || c == ',') {  // Check if the character is a space or comma\n            if (!word.empty()) {      // If there's a word, add it to the result vector\n                result.push_back(word);\n                word = \"\";            // Reset the word for the next iteration\n            }\n        } else {\n            word += c;  // Append the current character to the word\n        }\n    }\n\n    if (!word.empty()) {  // Add any remaining word after the loop ends\n        result.push_back(word);\n    }\n\n    return result;\n}\n\n// Function to test the implementation with example inputs\nvoid check() {\n    vector<string> res1 = words_string(\"Hi, my name is John\");\n    for (string s : res1) cout << s << \" \";\n    cout << endl;\n\n    vector<string> res2 = words_string(\"One, two, three, four, five, six\");\n    for (string s : res2) cout << s << \" \";\n}\n\n"}
{"task_id": "CPP/102", "generation": "#include<iostream>\nusing namespace std;\n\nint choose_num(int x, int y) {\n    // Check if the range is valid.\n    if (y < x)\n        return -1;\n    \n    // If 'y' itself is even and within the range, return it.\n    if (y % 2 == 0 && y >= x)\n        return y;\n\n    // Otherwise, check for the next lower number that could be even.\n    int candidate = y - 1;\n    while(candidate >= x) {\n        if (candidate % 2 == 0)\n            return candidate;\n        --candidate; // Move to the next lower number\n    }\n\n    // If no even number is found in the range, return -1.\n    return -1;\n}\n\n"}
{"task_id": "CPP/103", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\n// Function to convert an integer to a binary string\nstring int_to_binary(int num) {\n    if (num == 0) return \"0\";\n    string binary = \"\";\n    while (num > 0) {\n        binary = (num % 2 == 0 ? \"0\" : \"1\") + binary;\n        num /= 2;\n    }\n    return binary;\n}\n\nstring rounded_avg(int n, int m) {\n    if (n > m) return \"-1\";\n    \n    // Calculate the sum of integers from n to m\n    long long sum = ((long long)m * (m + 1) - (n * (n - 1))) / 2;\n    int count = m - n + 1; // Number of terms\n    \n    // Compute average and round down\n    int avg = sum / count;\n    \n    // Convert to binary string\n    return int_to_binary(avg);\n}\n\n"}
{"task_id": "CPP/104", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to check if a number contains only odd digits.\nbool hasOnlyOddDigits(int num) {\n    while (num > 0) {\n        int digit = num % 10;\n        if (digit % 2 == 0) return false; // If any digit is even, return false\n        num /= 10;\n    }\n    return true;\n}\n\nvector<int> unique_digits(vector<int> x) {\n    vector<int> result;\n\n    // Filter numbers that have only odd digits.\n    for (int num : x) {\n        if (hasOnlyOddDigits(num)) {\n            result.push_back(num);\n        }\n    }\n\n    // Sort the filtered numbers in increasing order\n    sort(result.begin(), result.end());\n\n    return result;\n}\n\n// Function to test the solution with given examples\nvoid check() {\n    vector<int> test1 = {15, 33, 1422, 1};\n    vector<int> expected1 = {1, 15, 33};\n    assert(unique_digits(test1) == expected1);\n\n    vector<int> test2 = {152, 323, 1422, 10};\n    vector<int> expected2 = {};\n    assert(unique_digits(test2) == expected2);\n    \n    cout << \"All tests passed successfully.\" << endl;\n}\n\n"}
{"task_id": "CPP/105", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\n\nusing namespace std;\n\nvector<string> by_length(vector<int> arr) {\n    // Map to store the digit-to-name mapping.\n    map<int, string> numberNames = {\n        {1, \"One\"}, {2, \"Two\"}, {3, \"Three\"},\n        {4, \"Four\"}, {5, \"Five\"}, {6, \"Six\"},\n        {7, \"Seven\"}, {8, \"Eight\"}, {9, \"Nine\"}\n    };\n\n    // Filter out numbers not between 1 and 9.\n    vector<int> filteredArr;\n    for (int num : arr) {\n        if (num >= 1 && num <= 9) {\n            filteredArr.push_back(num);\n        }\n    }\n\n    // Sort the filtered array.\n    sort(filteredArr.begin(), filteredArr.end());\n\n    // Reverse the sorted array.\n    reverse(filteredArr.begin(), filteredArr.end());\n\n    // Replace each digit with its corresponding name.\n    vector<string> result;\n    for (int num : filteredArr) {\n        result.push_back(numberNames[num]);\n    }\n\n    return result;\n}\n\n// Function to test the solution\nvoid check() {\n    vector<int> arr1 = {2, 1, 1, 4, 5, 8, 2, 3};\n    vector<string> expected1 = {\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"};\n    assert(by_length(arr1) == expected1);\n\n    vector<int> arr2 = {};\n    vector<string> expected2 = {};\n    assert(by_length(arr2) == expected2);\n\n    vector<int> arr3 = {1, -1, 55};\n    vector<string> expected3 = {\"One\"};\n    assert(by_length(arr3) == expected3);\n\n    cout << \"All tests passed successfully.\" << endl;\n}\n\n"}
{"task_id": "CPP/106", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// Function to calculate factorial\nint factorial(int num) {\n    int result = 1;\n    for (int i = 2; i <= num; ++i) {\n        result *= i;\n    }\n    return result;\n}\n\n// Function to calculate the sum of numbers from 1 to num\nint sumToN(int num) {\n    return (num * (num + 1)) / 2;\n}\n\nvector<int> f(int n) {\n    vector<int> result(n);\n    \n    for (int i = 0; i < n; ++i) {\n        if ((i + 1) % 2 == 0) { // Check if the index+1 is even\n            result[i] = factorial(i + 1); // Calculate factorial\n        } else {\n            result[i] = sumToN(i + 1); // Calculate sum from 1 to i+1\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/107", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\n// Function to check if a number is a palindrome\nbool isPalindrome(int num) {\n    string str = to_string(num);\n    int len = str.length();\n    for (int i = 0; i < len / 2; ++i) {\n        if (str[i] != str[len - i - 1]) return false;\n    }\n    return true;\n}\n\nvector<int> even_odd_palindrome(int n){\n    vector<int> result(2, 0); // Initialize a vector with two elements set to zero\n    for (int i = 1; i <= n; ++i) {\n        if (isPalindrome(i)) { // Check if the number is a palindrome\n            if (i % 2 == 0) {\n                result[0]++; // Increment even count\n            } else {\n                result[1]++; // Increment odd count\n            }\n        }\n    }\n    return result;\n}\n\n"}
{"task_id": "CPP/108", "generation": "#include <vector>\n#include <cmath>\n#include <algorithm>\n\nusing namespace std;\n\nint sum_of_digits(int num) {\n    int sum = 0;\n    bool is_negative = num < 0;\n    while (num != 0) {\n        sum += abs(num % 10);\n        num /= 10;\n    }\n    return sum;\n}\n\nint count_nums(vector<int> n) {\n    int count = 0;\n    for(int num : n) {\n        if(sum_of_digits(num) > 0) {\n            ++count;\n        }\n    }\n    return count;\n}\n"}
{"task_id": "CPP/109", "generation": "#include <vector>\nusing namespace std;\n\nbool move_one_ball(vector<int> arr) {\n    if (arr.empty()) return true;\n    \n    int n = arr.size();\n    int disorder_count = 0;\n    \n    // Check for disorder points\n    for (int i = 1; i < n; ++i) {\n        if (arr[i] < arr[i - 1]) {\n            disorder_count++;\n        }\n    }\n\n    // Special case: check the wrap-around condition between last and first element\n    if (disorder_count == 0 || (disorder_count == 1 && arr[n-1] <= arr[0])) {\n        return true;\n    } else {\n        return false;\n    }\n}\n"}
{"task_id": "CPP/110", "generation": "#include <vector>\n#include <string>\nusing namespace std;\n\nstring exchange(vector<int> lst1, vector<int> lst2) {\n    // Count odd numbers in lst1 and even numbers in lst2.\n    int oddCountInLst1 = 0;\n    for (int num : lst1) {\n        if (num % 2 != 0) {\n            ++oddCountInLst1;\n        }\n    }\n\n    int evenCountInLst2 = 0;\n    for (int num : lst2) {\n        if (num % 2 == 0) {\n            ++evenCountInLst2;\n        }\n    }\n\n    // If there are enough even numbers in lst2 to replace all odd numbers in lst1, return \"YES\".\n    if (oddCountInLst1 <= evenCountInLst2) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n"}
{"task_id": "CPP/111", "generation": "#include <iostream>\n#include <string>\n#include <map>\n#include <sstream> // For std::istringstream\n\nusing namespace std;\n\nmap<char, int> histogram(string test) {\n    map<char, int> charCount;\n    map<char, int> result;\n    \n    if (test.empty()) return result; // Return empty map for empty input\n    \n    istringstream iss(test);\n    string word;\n    \n    // Count occurrences of each character\n    while (iss >> word && !word.empty()) {\n        ++charCount[word[0]];\n    }\n    \n    int maxCount = 0;\n    \n    // Find the maximum count\n    for (const auto& pair : charCount) {\n        if (pair.second > maxCount) {\n            maxCount = pair.second;\n        }\n    }\n    \n    // Collect characters with the maximum count into result map\n    for (const auto& pair : charCount) {\n        if (pair.second == maxCount) {\n            result.insert(pair);\n        }\n    }\n    \n    return result;\n}\n\n// Function to print the map for testing purposes\nvoid printMap(const map<char, int>& m) {\n    for (const auto& pair : m) {\n        cout << \"{\" << pair.first << \", \" << pair.second << \"} \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/112", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nbool is_palindrome(const string& str) {\n    int left = 0, right = str.size() - 1;\n    while (left < right) {\n        if (str[left] != str[right]) return false;\n        ++left; --right;\n    }\n    return true;\n}\n\nvector<string> reverse_delete(string s, string c){\n    // Remove characters in `s` that are present in `c`\n    for(char ch : c) {\n        s.erase(remove(s.begin(), s.end(), ch), s.end());\n    }\n\n    // Check if the resulting string is a palindrome\n    bool is_pal = is_palindrome(s);\n\n    vector<string> result;\n    result.push_back(s);\n    result.push_back(is_pal ? \"True\" : \"False\");\n\n    return result;\n}\n"}
{"task_id": "CPP/113", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nstd::vector<std::string> odd_count(std::vector<std::string> lst) {\n    std::vector<std::string> result;\n    \n    for (const auto& s : lst) {\n        int count = 0;\n        \n        // Count the number of odd digits in the string\n        for (char c : s) {\n            if ((c - '0') % 2 != 0) {\n                ++count;\n            }\n        }\n\n        // Construct the output string with replacements\n        std::string output_str = \"the number of odd elements \";\n        for (size_t i = 0; i < output_str.length(); ++i) {\n            if (output_str[i] == 'n') {\n                output_str.insert(i, std::to_string(count));\n                i += std::to_string(count).length() - 1;\n            }\n        }\n\n        result.push_back(output_str);\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/114", "generation": "#include <iostream>\n#include <vector>\n#include <climits> // For INT_MAX\n\nusing namespace std;\n\nlong long minSubArraySum(vector<long long> nums) {\n    if (nums.empty()) return 0; // Handle empty vector case\n    \n    long long currentSum = 0;\n    long long minSum = LLONG_MAX; // Initialize to the largest possible value\n    \n    for (auto num : nums) {\n        currentSum += num;\n        \n        // Update minSum if currentSum is smaller\n        if (currentSum < minSum)\n            minSum = currentSum;\n            \n        // Reset currentSum to 0 if it becomes non-negative\n        if (currentSum >= 0)\n            currentSum = 0;\n    }\n    \n    return minSum;\n}\n\n"}
{"task_id": "CPP/115", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint max_fill(vector<vector<int>> grid, int capacity) {\n    int total_drops = 0;\n    \n    // Iterate over each well (row)\n    for (auto& row : grid) {\n        int water_units = 0;\n        \n        // Count the number of units of water in this well\n        for (int unit : row) {\n            if (unit == 1) {\n                ++water_units;\n            }\n        }\n        \n        // Calculate how many times we need to lower the bucket for this well\n        int drops_for_well = (water_units + capacity - 1) / capacity; // Equivalent to ceil(water_units / capacity)\n        \n        total_drops += drops_for_well;\n    }\n    \n    return total_drops;\n}\n\n"}
{"task_id": "CPP/116", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to count the number of 1s in binary representation of a number.\nint countOnes(int n) {\n    int ones = 0;\n    while (n != 0) {\n        if (n % 2 == 1)\n            ++ones;\n        n /= 2;\n    }\n    return ones;\n}\n\n// Comparator function for sorting based on the number of ones and then by value.\nbool compare(int a, int b) {\n    int countA = countOnes(abs(a));\n    int countB = countOnes(abs(b));\n\n    if (countA == countB)\n        return a < b; // If same number of 1s, sort by decimal value\n    else\n        return countA < countB; // Otherwise, sort by the number of 1s\n}\n\nvector<int> sort_array(vector<int> arr) {\n    sort(arr.begin(), arr.end(), compare);\n    return arr;\n}\n\n"}
{"task_id": "CPP/117", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Helper function to count consonants in a word\nint count_consonants(const string& word) {\n    int count = 0;\n    for (char ch : word) {\n        // Convert character to lowercase and check if it's a consonant\n        char lower_ch = tolower(ch);\n        if ((lower_ch >= 'a' && lower_ch <= 'z') && !(lower_ch == 'a' || lower_ch == 'e' || lower_ch == 'i' || lower_ch == 'o' || lower_ch == 'u')) {\n            count++;\n        }\n    }\n    return count;\n}\n\nvector<string> select_words(string s, int n) {\n    vector<string> result;\n    string word = \"\";\n    \n    // Split the string into words and check consonant count\n    for (char ch : s) {\n        if (ch == ' ') {\n            if (!word.empty()) {\n                if (count_consonants(word) == n) {\n                    result.push_back(word);\n                }\n                word = \"\";  // Reset word after processing it\n            }\n        } else {\n            word += ch;\n        }\n    }\n\n    // Check the last word in case there's no trailing space\n    if (!word.empty()) {\n        if (count_consonants(word) == n) {\n            result.push_back(word);\n        }\n    }\n\n    return result;\n}\n\n// Function to test the implementation with given examples\nvoid check() {\n    vector<string> res;\n\n    res = select_words(\"Mary had a little lamb\", 4);\n    for (const auto& word : res) cout << word << \" \";\n    cout << endl; // Expected: {\"little\"}\n\n    res = select_words(\"Mary had a little lamb\", 3);\n    for (const auto& word : res) cout << word << \" \";\n    cout << endl; // Expected: {\"Mary\", \"lamb\"}\n\n    res = select_words(\"simple white space\", 2);\n    for (const auto& word : res) cout << word << \" \";\n    cout << endl; // Expected: {}\n\n    res = select_words(\"Hello world\", 4);\n    for (const auto& word : res) cout << word << \" \";\n    cout << endl; // Expected: {\"world\"}\n\n    res = select_words(\"Uncle sam\", 3);\n    for (const auto& word : res) cout << word << \" \";\n    cout << endl; // Expected: {\"Uncle\"}\n}\n\n"}
{"task_id": "CPP/118", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_vowel(char c) {\n    string vowels = \"aeiouAEIOU\";\n    return vowels.find(c) != string::npos;\n}\n\nstring get_closest_vowel(string word){\n    int len = word.length();\n    \n    // Iterate from the end of the string to the beginning\n    for (int i = len - 2; i > 0; --i) {\n        // Check if current character is a vowel and surrounded by consonants\n        if (is_vowel(word[i]) && !is_vowel(word[i-1]) && !is_vowel(word[i+1])) {\n            return string(1, word[i]);\n        }\n    }\n    \n    // Return empty string if no such vowel found\n    return \"\";\n}\n\n"}
{"task_id": "CPP/119", "generation": "#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nbool is_balanced(const string& s) {\n    int balance = 0;\n    for (char c : s) {\n        if (c == '(') {\n            ++balance;\n        } else {\n            --balance;\n            if (balance < 0) {\n                return false; // Unbalanced, closing before opening\n            }\n        }\n    }\n    return balance == 0; // Balanced if no open parentheses left\n}\n\nstring match_parens(vector<string> lst) {\n    string first_concat = lst[0] + lst[1];\n    string second_concat = lst[1] + lst[0];\n\n    if (is_balanced(first_concat) || is_balanced(second_concat)) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\n"}
{"task_id": "CPP/120", "generation": "#include <vector>\n#include <algorithm> // for std::sort\n\nusing namespace std;\n\nvector<int> maximum(vector<int> arr, int k) {\n    // Step 1: Sort the array in ascending order.\n    sort(arr.begin(), arr.end());\n    \n    // Step 2: Extract the last k elements from the sorted vector.\n    vector<int> result;\n    for (int i = arr.size() - k; i < arr.size(); ++i) {\n        result.push_back(arr[i]);\n    }\n    \n    return result;\n}\n\n// Example usage:\n/*\nvector<int> example1 = {-3, -4, 5};\nvector<int> output1 = maximum(example1, 3); // Output: {-4, -3, 5}\n\nvector<int> example2 = {4, -4, 4};\nvector<int> output2 = maximum(example2, 2); // Output: {4, 4}\n\nvector<int> example3 = {-3, 2, 1, 2, -1, -2, 1};\nvector<int> output3 = maximum(example3, 1); // Output: {2}\n*/\n"}
{"task_id": "CPP/121", "generation": "#include <vector>\nusing namespace std;\n\nint solution(vector<int> lst) {\n    int sum = 0;\n    \n    // Iterate through the vector with a step of 2 to check even positions (0-indexed)\n    for(int i = 0; i < lst.size(); i += 2) {\n        if(lst[i] % 2 != 0) { // Check if the element is odd\n            sum += lst[i];\n        }\n    }\n    \n    return sum;\n}\n"}
{"task_id": "CPP/122", "generation": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint add_elements(vector<int> arr, int k) {\n    int sum = 0;\n    for (int i = 0; i < k; ++i) {\n        if (arr[i] >= -99 && arr[i] <= 99) {\n            sum += arr[i];\n        }\n    }\n    return sum;\n}\n"}
{"task_id": "CPP/123", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // For std::sort\n\nusing namespace std;\n\nvector<int> get_odd_collatz(int n) {\n    vector<int> oddNumbers;\n    \n    while (n != 1) {\n        if (n % 2 == 1) { // Check if the number is odd\n            oddNumbers.push_back(n);\n        }\n        if (n % 2 == 0) { // If even, divide by 2\n            n /= 2;\n        } else { // If odd, apply the Collatz formula\n            n = 3 * n + 1;\n        }\n    }\n    \n    // Add the last number in the sequence which is always 1 and is odd.\n    oddNumbers.push_back(1);\n    \n    // Sort the vector of odd numbers before returning it.\n    sort(oddNumbers.begin(), oddNumbers.end());\n    \n    return oddNumbers;\n}\n\n// Function to test the get_odd_collatz function\nvoid check() {\n    vector<int> result = get_odd_collatz(5);\n    for (int num : result) {\n        cout << num << \" \";\n    }\n    // Expected output: 1 5\n    cout << endl;\n    \n    result = get_odd_collatz(7); \n    for (int num : result) {\n        cout << num << \" \";\n    }\n    // Expected output: 1 7 11 22\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/124", "generation": "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nbool valid_date(const string& date) {\n    // Check if the date string is empty or not in mm-dd-yyyy format.\n    if (date.length() != 10 || date[2] != '-' || date[5] != '-') return false;\n    \n    vector<int> days_in_month = {31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\n    \n    // Extract month, day and year from the date string.\n    int month = stoi(date.substr(0, 2));\n    int day = stoi(date.substr(3, 2));\n    int year = stoi(date.substr(6, 4));\n\n    // Validate month\n    if (month < 1 || month > 12) return false;\n\n    // Validate day based on the month and leap year for February.\n    if (day < 1 || day > days_in_month[month - 1]) return false;\n    \n    // Special case for February in a non-leap year\n    if (month == 2 && day == 29) {\n        bool is_leap_year = ((year % 4 == 0 && year % 100 != 0) || (year % 400 == 0));\n        if (!is_leap_year) return false;\n    }\n\n    // If all checks pass, the date is valid.\n    return true;\n}\n\n"}
{"task_id": "CPP/125", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cctype>\nusing namespace std;\n\nvector<string> split_words(string txt) {\n    vector<string> result;\n    \n    // Check for whitespace and split on it if present\n    size_t start = 0, end = txt.find(' ');\n    while (end != string::npos) {\n        result.push_back(txt.substr(start, end - start));\n        start = end + 1;\n        end = txt.find(' ', start);\n    }\n    \n    // If there are whitespaces, add the last word\n    if (!result.empty()) {\n        result.push_back(txt.substr(start));\n        return result;\n    }\n\n    // Check for commas and split on it if present\n    start = 0;\n    end = txt.find(',');\n    while (end != string::npos) {\n        result.push_back(txt.substr(start, end - start));\n        start = end + 1;\n        end = txt.find(',', start);\n    }\n    \n    // If there are commas, add the last word\n    if (!result.empty()) {\n        result.push_back(txt.substr(start));\n        return result;\n    }\n\n    // Count lowercase letters with odd order positions in the alphabet\n    int count = 0;\n    for (char c : txt) {\n        if (islower(c)) {\n            if ((c - 'a') % 2 == 1) {\n                ++count;\n            }\n        }\n    }\n    \n    result.push_back(to_string(count));\n    return result;\n}\n"}
{"task_id": "CPP/126", "generation": "#include <vector>\n#include <algorithm>\n\nbool is_sorted(std::vector<int> lst) {\n    // Check if the list is empty or has only one element, which is always sorted.\n    if (lst.size() <= 1) return true;\n\n    int count = 1; // To keep track of how many times a number appears consecutively.\n\n    for (size_t i = 1; i < lst.size(); ++i) {\n        // If the current element is less than the previous one, it's not sorted.\n        if (lst[i] < lst[i - 1]) return false;\n\n        // Check how many times a number appears consecutively.\n        if (lst[i] == lst[i - 1]) {\n            count++;\n            // If any number appears more than twice, return false.\n            if (count > 2) return false;\n        } else {\n            count = 1; // Reset the counter for different numbers.\n        }\n    }\n\n    return true;\n}\n"}
{"task_id": "CPP/127", "generation": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <string>\nusing namespace std;\n\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\nstring intersection(vector<int> interval1, vector<int> interval2) {\n    int start = max(interval1[0], interval2[0]);\n    int end = min(interval1[1], interval2[1]);\n\n    if (start > end) {\n        return \"NO\";\n    }\n\n    int length_of_intersection = end - start + 1;\n\n    if (is_prime(length_of_intersection)) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n\n"}
{"task_id": "CPP/128", "generation": "#include <vector>\n#include <cmath> // For std::abs\n\nint prod_signs(std::vector<int> arr) {\n    if (arr.empty()) return -32768; // Return special value for empty vector\n    \n    int signProduct = 1;\n    int magnitudeSum = 0;\n\n    for (auto num : arr) {\n        magnitudeSum += std::abs(num); // Sum of magnitudes\n        if (num == 0) { \n            signProduct = 0; // If any number is zero, the product of signs will be zero.\n            break;\n        } else if (num < 0) {\n            signProduct *= -1; // Multiply by -1 for negative numbers\n        }\n    }\n\n    return magnitudeSum * signProduct;\n}\n\n// Example usage:\n"}
{"task_id": "CPP/129", "generation": "#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> minPath(const vector<vector<int>>& grid, int k) {\n    int N = grid.size();\n    \n    vector<int> result(k, INT_MAX);\n    \n    function<void(int, int, vector<int>&)> dfs;\n    dfs = [&](int x, int y, vector<int>& path) -> void {\n        if (path.size() == k) {\n            if (lexicographical_compare(path.begin(), path.end(), result.begin(), result.end())) {\n                result = path;\n            }\n            return;\n        }\n\n        for (int dx = -1; dx <= 1; ++dx) {\n            for (int dy = -1; dy <= 1; ++dy) {\n                if ((abs(dx) + abs(dy)) == 1 && x+dx >= 0 && x+dx < N && y+dy >= 0 && y+dy < N) {\n                    path.push_back(grid[x+dx][y+dy]);\n                    dfs(x+dx, y+dy, path);\n                    path.pop_back();\n                }\n            }\n        }\n    };\n    \n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            vector<int> current_path {grid[i][j]};\n            dfs(i, j, current_path);\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/130", "generation": "#include <vector>\nusing namespace std;\n\n// Helper function for calculating Tribonacci values recursively.\nint tri_helper(int i) {\n    if (i == 1)\n        return 3;\n    else if (i % 2 == 0)\n        return 1 + i / 2;\n    else\n        return tri_helper(i - 1) + tri_helper(i - 2) + tri_helper(i + 1);\n}\n\nvector<int> tri(int n) {\n    vector<int> tribonacci = {1, 3};\n    \n    if (n == 0)\n        return {1};\n\n    for (int i = 2; i <= n; ++i) {\n        if (i % 2 == 0)\n            tribonacci.push_back(1 + i / 2);\n        else\n            tribonacci.push_back(tri_helper(i - 1) + tri_helper(i - 2) + tri_helper(i));\n    }\n    \n    return tribonacci;\n}\n"}
{"task_id": "CPP/131", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint digits(int n) {\n    string numStr = to_string(n); // Convert integer to string for easy digit access\n    int product = 1; // Initialize product with 1\n    \n    bool hasOddDigit = false;\n    \n    for (char c : numStr) { // Iterate through each character in the string\n        int digit = c - '0'; // Convert char to int\n        \n        if (digit % 2 != 0) { // Check if the digit is odd\n            product *= digit; // Multiply it into the product\n            hasOddDigit = true;\n        }\n    }\n    \n    return hasOddDigit ? product : 0; // Return product or 0 based on whether there was an odd digit\n}\n\n"}
{"task_id": "CPP/132", "generation": "#include <string>\nusing namespace std;\n\nbool is_nested(string str) {\n    int max_depth = 0;\n    int current_depth = 0;\n\n    for (char c : str) {\n        if (c == '[') {\n            current_depth += 1;\n            max_depth = max(max_depth, current_depth);\n        } else if (c == ']') {\n            current_depth -= 1;\n        }\n\n        // If the depth becomes negative, it means there is an unmatched closing bracket.\n        if (current_depth < 0) {\n            return false;\n        }\n    }\n\n    // A valid nested subsequence must have a maximum depth greater than 1\n    return max_depth > 1 && current_depth == 0;\n}\n"}
{"task_id": "CPP/133", "generation": "#include <iostream>\n#include <vector>\n#include <cmath> // for ceil and pow functions\n\nusing namespace std;\n\nint sum_squares(vector<float> lst){\n    int sum = 0;\n    for (float num : lst) {\n        float ceilingValue = ceil(num); // Round up to the nearest integer\n        sum += pow(ceilingValue, 2); // Square it and add to sum\n    }\n    return sum;\n}\n\n"}
{"task_id": "CPP/134", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool check_if_last_char_is_a_letter(string txt) {\n    // Check if string is empty or ends with a space.\n    if (txt.empty() || txt.back() == ' ') return false;\n    \n    // Get the last character of the string.\n    char lastChar = txt.back();\n    \n    // Check if it's an alphabetical character and not part of a word.\n    bool isAlphabetical = isalpha(lastChar);\n    bool isNotPartOfWord = (txt.size() == 1 || txt[txt.size()-2] == ' ');\n    \n    return isAlphabetical && isNotPartOfWord;\n}\n\n"}
{"task_id": "CPP/135", "generation": "#include <vector>\nusing namespace std;\n\nint can_arrange(vector<int> arr) {\n    for (size_t i = 1; i < arr.size(); ++i) {\n        if (arr[i] < arr[i - 1]) {\n            return static_cast<int>(i);\n        }\n    }\n    return -1;\n}\n"}
{"task_id": "CPP/136", "generation": "#include <vector>\n#include <algorithm> // For std::min and std::max\n\nusing namespace std;\n\nvector<int> largest_smallest_integers(vector<int> lst){\n    int largestNegative = 0;\n    int smallestPositive = 0;\n    \n    bool foundNegative = false;\n    bool foundPositive = false;\n    \n    for(int num : lst) {\n        if(num < 0) {\n            // Update the largest negative number\n            if(!foundNegative || num > largestNegative) {\n                largestNegative = num;\n                foundNegative = true;\n            }\n        } else if (num > 0) {\n            // Update the smallest positive number\n            if(!foundPositive || num < smallestPositive) {\n                smallestPositive = num;\n                foundPositive = true;\n            }\n        }\n    }\n\n    return {largestNegative, smallestPositive};\n}\n\n// Example usage:\n"}
{"task_id": "CPP/137", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <boost/any.hpp>\n\nusing namespace std;\n\n// Helper function to convert string with dot or comma to float\nauto toFloat = [](const string& str) -> float {\n    string temp_str = str;\n    replace(temp_str.begin(), temp_str.end(), ',', '.');\n    return stof(temp_str);\n};\n\nboost::any compare_one(boost::any a, boost::any b) {\n    float a_float = 0;\n    float b_float = 0;\n\n    if (a.type() == typeid(string)) {\n        a_float = toFloat(boost::any_cast<string>(a));\n    } else if (a.type() == typeid(float)) {\n        a_float = boost::any_cast<float>(a);\n    } else if (a.type() == typeid(int)) {\n        a_float = static_cast<float>(boost::any_cast<int>(a));\n    }\n\n    if (b.type() == typeid(string)) {\n        b_float = toFloat(boost::any_cast<string>(b));\n    } else if (b.type() == typeid(float)) {\n        b_float = boost::any_cast<float>(b);\n    } else if (b.type() == typeid(int)) {\n        b_float = static_cast<float>(boost::any_cast<int>(b));\n    }\n\n    // Compare the float representations\n    if (a_float > b_float) {\n        return a;\n    } else if (b_float > a_float) {\n        return b;\n    } else {\n        return string(\"None\");\n    }\n}\n"}
{"task_id": "CPP/138", "generation": "#include <iostream>\nusing namespace std;\n\nbool is_equal_to_sum_even(int n) {\n    // Check if n is at least 8 and an even number.\n    return (n >= 8 && n % 2 == 0);\n}\n\n"}
{"task_id": "CPP/139", "generation": "#include <iostream>\nusing namespace std;\n\n// Function to calculate factorial of a given number\nlong long factorial(int num) {\n    if (num == 0 || num == 1)\n        return 1;\n    else\n        return num * factorial(num - 1);\n}\n\n// Function to calculate the Brazilian factorial as defined\nlong long special_factorial(int n){\n    long long result = 1;\n    for(int i = 1; i <= n; ++i) {\n        result *= factorial(i);\n    }\n    return result;\n}\n\n"}
{"task_id": "CPP/140", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring fix_spaces(string text) {\n    string result;\n    int spaceCount = 0; // Counter for consecutive spaces\n\n    for (char c : text) {\n        if (c == ' ') {\n            ++spaceCount;\n        } else {\n            if (spaceCount > 2) {\n                result += '-';\n            } else {\n                while (spaceCount > 0) {\n                    result += '_';\n                    --spaceCount;\n                }\n            }\n            spaceCount = 0; // Reset the counter\n            result += c;\n        }\n    }\n\n    // Handle trailing spaces if any\n    if (spaceCount > 2) {\n        result += '-';\n    } else {\n        while (spaceCount > 0) {\n            result += '_';\n            --spaceCount;\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/141", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring file_name_check(string file_name) {\n    // Check for exactly one dot in the name.\n    size_t dotPos = file_name.find('.');\n    if (dotPos == string::npos || file_name.find('.', dotPos + 1) != string::npos)\n        return \"No\";\n\n    // Split the filename into two parts: before and after the dot\n    string prefix = file_name.substr(0, dotPos);\n    string suffix = file_name.substr(dotPos + 1);\n\n    // Check if there are more than three digits in the prefix.\n    int digitCount = 0;\n    for (char c : prefix) {\n        if (isdigit(c)) digitCount++;\n        if (digitCount > 3) return \"No\";\n    }\n\n    // Validate that the prefix starts with a letter and is not empty\n    if (prefix.empty() || !isalpha(prefix[0])) \n        return \"No\";\n\n    // Check valid extensions.\n    string validExtensions[] = {\"txt\", \"exe\", \"dll\"};\n    bool isValidExtension = false;\n    for (string ext : validExtensions) {\n        if (ext == suffix) {\n            isValidExtension = true;\n            break;\n        }\n    }\n\n    if (!isValidExtension)\n        return \"No\";\n\n    // If all checks pass, the filename is valid.\n    return \"Yes\";\n}\n\n"}
{"task_id": "CPP/142", "generation": "#include <vector>\nusing namespace std;\n\nint sum_squares(vector<int> lst) {\n    int sum = 0;\n    \n    for (size_t i = 0; i < lst.size(); ++i) {\n        if (i % 3 == 0) { // If index is a multiple of 3\n            sum += lst[i] * lst[i]; // Square the element and add to sum\n        } else if (i % 4 == 0 && i % 3 != 0) { // If index is a multiple of 4 but not 3\n            sum += lst[i] * lst[i] * lst[i]; // Cube the element and add to sum\n        } else {\n            sum += lst[i]; // Add the element as it is if no condition matches\n        }\n    }\n\n    return sum;\n}\n\n// Example usage:\n"}
{"task_id": "CPP/143", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\n// Helper function to check if a number is prime\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    for (int i = 2; i * i <= num; ++i) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\n// Main function to filter words based on prime length\nstring words_in_sentence(string sentence) {\n    stringstream ss(sentence);\n    string word, result;\n    \n    while (ss >> word) { // Extract each word from the sentence\n        if (is_prime(word.length())) {\n            if (!result.empty()) result += \" \"; // Add space before appending new word\n            result += word; // Append prime length words to result\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/144", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool simplify(string x, string n) {\n    // Parsing fractions\n    size_t slashPos;\n    \n    int numX = stoi(x.substr(0, (slashPos = x.find('/'))));\n    int denX = stoi(x.substr(slashPos + 1));\n\n    int numN = stoi(n.substr(0, (slashPos = n.find('/'))));\n    int denN = stoi(n.substr(slashPos + 1));\n\n    // Multiplying the fractions\n    int numeratorResult = numX * numN;\n    int denominatorResult = denX * denN;\n\n    // Simplifying to check if it's a whole number\n    return (numeratorResult % denominatorResult == 0);\n}\n\n"}
{"task_id": "CPP/145", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n\nint sum_of_digits(int n) {\n    std::string num_str = std::to_string(n);\n    int sum = 0;\n    bool is_negative = (num_str[0] == '-');\n    \n    for(size_t i = is_negative; i < num_str.length(); ++i) {\n        sum += (is_negative && i == 1 ? -1 : 1) * (num_str[i] - '0');\n    }\n    return sum;\n}\n\nbool compare_by_points(const std::pair<int, int>& a, const std::pair<int, int>& b) {\n    if(sum_of_digits(a.first) != sum_of_digits(b.first)) {\n        return sum_of_digits(a.first) < sum_of_digits(b.first);\n    } else {\n        return a.second < b.second;\n    }\n}\n\nstd::vector<int> order_by_points(std::vector<int> nums) {\n    std::vector<std::pair<int, int>> indexed_nums(nums.size());\n    \n    for(size_t i = 0; i < nums.size(); ++i) {\n        indexed_nums[i] = {nums[i], static_cast<int>(i)};\n    }\n    \n    std::sort(indexed_nums.begin(), indexed_nums.end(), compare_by_points);\n    \n    std::vector<int> sorted_nums(nums.size());\n    for(size_t i = 0; i < nums.size(); ++i) {\n        sorted_nums[i] = indexed_nums[i].first;\n    }\n    \n    return sorted_nums;\n}\n\n"}
{"task_id": "CPP/146", "generation": "#include <vector>\n#include <string>\nusing namespace std;\n\nbool isFirstAndLastDigitOdd(int num) {\n    // Convert to string to easily access first and last digit\n    string strNum = to_string(abs(num));  // Use abs to handle negative numbers\n    char firstDigit = strNum[0];\n    char lastDigit = strNum[strNum.length() - 1];\n\n    // Check if both digits are odd\n    return (firstDigit == '1' || firstDigit == '3' || firstDigit == '5' || \n            firstDigit == '7' || firstDigit == '9') &&\n           (lastDigit == '1' || lastDigit == '3' || lastDigit == '5' ||\n            lastDigit == '7' || lastDigit == '9');\n}\n\nint specialFilter(vector<int> nums) {\n    int count = 0;\n    for(int num : nums) {\n        if(num > 10 && isFirstAndLastDigitOdd(num)) {\n            ++count;\n        }\n    }\n    return count;\n}\n"}
{"task_id": "CPP/147", "generation": "#include<iostream>\n#include<vector>\n\nusing namespace std;\n\nint get_max_triples(int n) {\n    vector<int> a(n);\n    \n    // Fill the array with values according to the given formula.\n    for (int i = 0; i < n; ++i) {\n        a[i] = (i + 1) * (i + 1) - (i + 1) + 1;\n    }\n    \n    int count = 0;\n\n    // Iterate through all possible triples and check the condition.\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            for (int k = j + 1; k < n; ++k) {\n                if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                    count++;\n                }\n            }\n        }\n    }\n\n    return count;\n}\n\n// Function to test the solution with given data points.\nvoid check_solution() {\n    cout << \"For n = 5, Expected: 1, Got: \" << get_max_triples(5) << endl;\n    // You can add more tests here as needed\n}\n\n"}
{"task_id": "CPP/148", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to find planets between two given planets.\nvector<string> bf(string planet1, string planet2) {\n    // Mapping of each planet name to its position relative to the Sun.\n    vector<pair<string, int>> solarSystem = {\n        {\"Mercury\", 1}, {\"Venus\", 2}, {\"Earth\", 3},\n        {\"Mars\", 4}, {\"Jupiter\", 5}, {\"Saturn\", 6},\n        {\"Uranus\", 7}, {\"Neptune\", 8}\n    };\n\n    // Find the positions of planet1 and planet2.\n    int pos1 = -1, pos2 = -1;\n    for (const auto& planet : solarSystem) {\n        if (planet.first == planet1)\n            pos1 = planet.second;\n        else if (planet.first == planet2)\n            pos2 = planet.second;\n\n        // If both positions are found, break the loop.\n        if (pos1 != -1 && pos2 != -1)\n            break;\n    }\n\n    // Check if either of the planets was not found.\n    if (pos1 == -1 || pos2 == -1) {\n        return {};  // Return an empty vector if any planet is invalid.\n    }\n\n    // Ensure pos1 < pos2 for simplicity in the loop below.\n    if (pos1 > pos2)\n        swap(pos1, pos2);\n\n    // Collect all planets between pos1 and pos2.\n    vector<string> result;\n    for (const auto& planet : solarSystem) {\n        int position = planet.second;\n        if (position > pos1 && position < pos2) {\n            result.push_back(planet.first);\n        }\n    }\n\n    return result;\n}\n\n// Function to test the bf function with examples.\nvoid check() {\n    vector<string> res;\n\n    // Example 1\n    res = bf(\"Jupiter\", \"Neptune\");\n    for (const auto& planet : res)\n        cout << planet << \" \";\n    cout << endl;  // Expected: Saturn Uranus\n\n    // Example 2\n    res = bf(\"Earth\", \"Mercury\");\n    for (const auto& planet : res)\n        cout << planet << \" \";\n    cout << endl;  // Expected: Venus\n\n    // Example 3\n    res = bf(\"Mercury\", \"Uranus\");\n    for (const auto& planet : res)\n        cout << planet << \" \";\n    cout << endl;  // Expected: Venus Earth Mars Jupiter Saturn\n}\n\n"}
{"task_id": "CPP/149", "generation": "#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nvector<string> vector_sort(vector<string> lst) {\n    // Filter out strings with odd lengths\n    vector<string> filtered_lst;\n    for (const auto& s : lst) {\n        if (s.length() % 2 == 0) {\n            filtered_lst.push_back(s);\n        }\n    }\n\n    // Sort the list by length and then alphabetically\n    sort(filtered_lst.begin(), filtered_lst.end(),\n         [](const string &a, const string &b) {\n             return make_pair(a.length(), a) < make_pair(b.length(), b);\n         });\n\n    return filtered_lst;\n}\n"}
{"task_id": "CPP/150", "generation": "#include <cmath> // For sqrt function\nusing namespace std;\n\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    for (int i = 2; i <= static_cast<int>(sqrt(num)); ++i) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\nint x_or_y(int n, int x, int y) {\n    return is_prime(n) ? x : y;\n}\n"}
{"task_id": "CPP/151", "generation": "#include <vector>\n#include <cmath> // For std::pow\n\nusing namespace std;\n\nlong long double_the_difference(vector<float> lst) {\n    long long sum = 0;\n    \n    for (float num : lst) {\n        if (num > 0 && floor(num) == num && static_cast<int>(num) % 2 != 0) { // Check if positive, integer and odd\n            int n = static_cast<int>(num);\n            sum += pow(n, 2); // Square the number and add to sum\n        }\n    }\n\n    return sum;\n}\n\n// Test cases\n"}
{"task_id": "CPP/152", "generation": "#include <iostream>\n#include <cmath>\n#include <vector>\nusing namespace std;\n\nvector<int> compare(vector<int> game, vector<int> guess) {\n    vector<int> result;\n    for (size_t i = 0; i < game.size(); ++i) {\n        int diff = abs(game[i] - guess[i]);\n        result.push_back(diff);\n    }\n    return result;\n}\n"}
{"task_id": "CPP/153", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to calculate the strength of an extension.\nint CalculateStrength(const string& extension) {\n    int uppercase = 0;\n    int lowercase = 0;\n    \n    for (char c : extension) {\n        if (isupper(c)) uppercase++;\n        else if (islower(c)) lowercase++;\n    }\n    \n    return uppercase - lowercase;\n}\n\nstring Strongest_Extension(string class_name, vector<string> extensions) {\n    string strongest_extension = \"\";\n    int max_strength = INT_MIN; // Initialize with the smallest possible integer.\n    \n    for (const auto& extension : extensions) {\n        int strength = CalculateStrength(extension);\n        \n        if (strength > max_strength || (strength == max_strength && strongest_extension.empty())) {\n            max_strength = strength;\n            strongest_extension = extension;\n        }\n    }\n    \n    return class_name + \".\" + strongest_extension;\n}\n\n"}
{"task_id": "CPP/154", "generation": "#include <string>\n#include <algorithm>\nusing namespace std;\n\nbool cycpattern_check(string a, string b) {\n    if (b.length() > a.length()) return false;\n\n    // Concatenate string 'a' with itself to handle rotations\n    string a_doubled = a + a;\n    \n    for (size_t i = 0; i < b.length(); ++i) {\n        // Generate the rotated version of b\n        string rotated_b = b.substr(i) + b.substr(0, i);\n        \n        // Check if this rotation is a substring in a_doubled\n        if (a_doubled.find(rotated_b) != std::string::npos) {\n            return true;\n        }\n    }\n\n    return false;\n}\n"}
{"task_id": "CPP/155", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<int> even_odd_count(int num){\n    // Convert number to its absolute value to handle negative numbers\n    int absNum = abs(num);\n    \n    // Convert integer to string for easy digit extraction\n    string strNum = to_string(absNum);\n\n    // Initialize counters for even and odd digits\n    int evenCount = 0;\n    int oddCount = 0;\n\n    // Iterate through each character in the string\n    for (char c : strNum) {\n        // Convert char to integer digit\n        int digit = c - '0';\n        \n        // Check if the digit is even or odd and increment respective counter\n        if (digit % 2 == 0) {\n            evenCount++;\n        } else {\n            oddCount++;\n        }\n    }\n\n    // Return a vector containing counts of even and odd digits respectively\n    return {evenCount, oddCount};\n}\n\n// Function to test the solution with given examples\nvoid check() {\n    vector<int> result = even_odd_count(-12);\n    cout << \"even_odd_count(-12) -> {\" << result[0] << \", \" << result[1] << \"}\\n\";\n    \n    result = even_odd_count(123);\n    cout << \"even_odd_count(123) -> {\" << result[0] << \", \" << result[1] << \"}\\n\";\n}\n\n"}
{"task_id": "CPP/156", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring int_to_mini_roman(int number) {\n    // Define the values and corresponding symbols\n    vector<int> values = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    vector<string> symbols = {\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n\n    string roman = \"\";\n    \n    // Iterate over the values and construct the Roman numeral\n    for (int i = 0; number > 0; ++i) {\n        while (number >= values[i]) {\n            roman += symbols[i];\n            number -= values[i];\n        }\n    }\n\n    return roman;\n}\n\n// Example usage:\n"}
{"task_id": "CPP/157", "generation": "#include <iostream>\n#include <cmath>\n\nbool right_angle_triangle(float a, float b, float c){\n    // First, sort the sides so that c is the longest side (hypotenuse)\n    if(a > c) std::swap(a, c);\n    if(b > c) std::swap(b, c);\n\n    // Check the Pythagorean theorem\n    return fabs(a*a + b*b - c*c) < 1e-6; // Using a small threshold to account for floating point precision issues.\n}\n\n"}
{"task_id": "CPP/158", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <set>\nusing namespace std;\n\nstring find_max(vector<string> words) {\n    string result;\n    int max_unique = 0; // To keep track of maximum unique characters\n\n    for (const auto& word : words) {\n        set<char> unique_chars(word.begin(), word.end()); // Use a set to get unique characters\n        int count_unique = unique_chars.size();\n\n        if (count_unique > max_unique || \n            (count_unique == max_unique && word < result)) { // Check lexicographical order as well\n            max_unique = count_unique;\n            result = word;\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/159", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> eat(int number, int need, int remaining) {\n    // Calculate the total number of carrots eaten after trying to eat 'need' more.\n    int totalEaten = number + min(need, remaining);\n    \n    // Calculate how many carrots are left after eating as much as possible.\n    int carrotsLeft = max(0, remaining - need);\n\n    return {totalEaten, carrotsLeft};\n}\n"}
{"task_id": "CPP/160", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\nusing namespace std;\n\n// Function to evaluate the expression using a stack-based approach.\nint do_algebra(vector<string> operators, vector<int> operands) {\n    // Initialize the result with the first operand.\n    int result = operands[0];\n\n    for (size_t i = 0; i < operators.size(); ++i) {\n        string op = operators[i];\n        int next_operand = operands[i + 1];\n\n        if (op == \"+\") {\n            result += next_operand;\n        } else if (op == \"-\") {\n            result -= next_operand;\n        } else if (op == \"*\") {\n            result *= next_operand;\n        } else if (op == \"//\") {\n            result /= next_operand; // Floor division\n        } else if (op == \"**\") {\n            result = pow(result, next_operand); // Exponentiation\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/161", "generation": "#include <iostream>\n#include <string>\n#include <cctype> // For std::isalpha and std::islower\n\nusing namespace std;\n\nstring solve(string s) {\n    bool hasLetters = false;\n    \n    // Check if the string contains any letters.\n    for (char c : s) {\n        if (std::isalpha(c)) {\n            hasLetters = true;\n            break;\n        }\n    }\n\n    // If no letters are present, reverse the entire string.\n    if (!hasLetters) {\n        std::reverse(s.begin(), s.end());\n        return s;\n    }\n\n    // Otherwise, change the case of each letter and keep other characters as they are.\n    for (char &c : s) {\n        if (std::isalpha(c)) {\n            c = std::islower(c) ? toupper(c) : tolower(c);\n        }\n    }\n\n    return s;\n}\n\n"}
{"task_id": "CPP/162", "generation": "#include <iostream>\n#include <string>\n#include <openssl/md5.h>\n\nusing namespace std;\n\nstring string_to_md5(string text) {\n    if (text.empty()) return \"None\"; // Return \"None\" for empty strings\n\n    unsigned char digest[MD5_DIGEST_LENGTH];\n    MD5((unsigned char*)text.c_str(), text.length(), (unsigned char*)&digest);    \n\n    char mdString[33];\n    for(int i = 0; i < 16; ++i)\n        sprintf(&mdString[i*2], \"%02x\", (unsigned int)digest[i]);\n\n    return string(mdString);\n}\n\n"}
{"task_id": "CPP/163", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // For std::min and std::max\n\nusing namespace std;\n\nvector<int> generate_integers(int a, int b) {\n    vector<int> evenDigits = {2, 4, 6, 8}; // All possible even digits less than 10\n    vector<int> result;\n    \n    // Ensure a is the smaller number and b is the larger one\n    int start = min(a, b);\n    int end = max(a, b);\n\n    for (int digit : evenDigits) {\n        if (digit >= start && digit <= end) {\n            result.push_back(digit);\n        }\n    }\n\n    return result;\n}\n\n// Function to print vector elements\nvoid printVector(const vector<int>& vec) {\n    cout << \"{\";\n    for(size_t i = 0; i < vec.size(); ++i) {\n        if (i != 0) cout << \", \";\n        cout << vec[i];\n    }\n    cout << \"}\" << endl;\n}\n\n"}
{"task_id": "CPP/0", "generation": "#include <algorithm> // For std::sort\n\nbool has_close_elements(std::vector<float> numbers, float threshold) {\n    if (numbers.size() < 2) return false; // If there are less than two elements, we can't have any pairs.\n\n    // Sort the vector to bring closer elements next to each other.\n    std::sort(numbers.begin(), numbers.end());\n\n    for(size_t i = 0; i < numbers.size() - 1; ++i) {\n        if (std::abs(numbers[i] - numbers[i + 1]) < threshold) {\n            return true;\n        }\n    }\n\n    return false;\n}\n"}
{"task_id": "CPP/1", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> separate_paren_groups(string paren_string){\n    vector<string> result;\n    int balance = 0; // Keeps track of open parentheses\n    string current_group = \"\"; // Current group being processed\n\n    for (char c : paren_string) {\n        if (c == '(' || c == ')') { // Ignore spaces and only consider parentheses\n            current_group += c; // Add the character to the current group\n            balance += (c == '(' ? 1 : -1); // Update balance based on the character\n\n            if (balance == 0) { // When balance is zero, a complete group has been found\n                result.push_back(current_group);\n                current_group = \"\"; // Reset for the next group\n            }\n        }\n    }\n\n    return result;\n}\n\n// Function to test the solution with provided data points\nvoid check() {\n    vector<string> expected1 = {\"()\", \"(())\", \"(()())\"};\n    assert(separate_paren_groups(\"( ) (( )) (( )( ))\") == expected1);\n\n    // Additional checks can be added here as needed\n\n    cout << \"All tests passed successfully.\" << endl;\n}\n\n"}
{"task_id": "CPP/2", "generation": "#include<stdio.h>\n#include<math.h>\n\nfloat truncate_number(float number){\n    float integerPart = floor(number);\n    return number - integerPart;\n}\n\n"}
{"task_id": "CPP/3", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nbool below_zero(vector<int> operations) {\n    int balance = 0; // Start with a zero balance\n\n    for (int op : operations) { // Iterate through each operation\n        balance += op; // Update the balance according to the current operation\n        \n        if (balance < 0) { // Check if balance falls below zero\n            return true;\n        }\n    }\n\n    return false; // Return false if no point in time the balance was below zero\n}\n\n"}
{"task_id": "CPP/4", "generation": "#include <iostream>\n#include <vector>\n#include <numeric> // for std::accumulate\n#include <cmath>   // for std::abs\n\nusing namespace std;\n\nfloat mean_absolute_deviation(vector<float> numbers) {\n    if (numbers.empty()) return 0.0f; // Handle empty vector case\n    \n    float sum = accumulate(numbers.begin(), numbers.end(), 0.0f);\n    float mean = sum / numbers.size();\n    \n    float mad_sum = 0.0f;\n    for (float num : numbers) {\n        mad_sum += std::abs(num - mean); // Calculate the absolute difference and add it to the sum\n    }\n    \n    return mad_sum / numbers.size(); // Average of all absolute differences\n}\n\n"}
{"task_id": "CPP/5", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> intersperse(vector<int> numbers, int delimeter) {\n    vector<int> result;\n    \n    // If the input vector is empty, return it as is.\n    if (numbers.empty()) {\n        return result;\n    }\n    \n    // Iterate through each element in the input vector\n    for(size_t i = 0; i < numbers.size(); ++i) {\n        // Add the current number to the result vector\n        result.push_back(numbers[i]);\n        \n        // If it's not the last element, add the delimiter after it.\n        if (i != numbers.size() - 1) {\n            result.push_back(delimeter);\n        }\n    }\n\n    return result;\n}\n\n// Example usage:\n"}
{"task_id": "CPP/6", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<int> parse_nested_parens(string paren_string) {\n    vector<int> max_depths;\n    int current_depth = 0, max_depth = 0;\n    \n    for (char c : paren_string) {\n        if (c == '(') {\n            // Increase depth when encountering an opening parenthesis\n            ++current_depth;\n            // Update the maximum depth found so far in this group\n            if (current_depth > max_depth)\n                max_depth = current_depth;\n        } else if (c == ')') {\n            // Decrease depth when encountering a closing parenthesis\n            --current_depth;\n        } else if (c == ' ') {\n            // When we encounter a space, it means the end of one group.\n            // Add the maximum depth found for this group to our result vector,\n            // and reset max_depth and current_depth for the next group.\n            max_depths.push_back(max_depth);\n            max_depth = 0;\n            current_depth = 0;\n        }\n    }\n\n    // Handle the last group if there is no trailing space\n    if (max_depth > 0) {\n        max_depths.push_back(max_depth);\n    }\n\n    return max_depths;\n}\n\n"}
{"task_id": "CPP/7", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\n// Function to filter strings containing a specific substring.\nvector<string> filter_by_substring(vector<string> strings, string substring) {\n    vector<string> filteredStrings; // Vector to store the result.\n\n    for (const auto& str : strings) { // Iterate through each string in the input vector.\n        if (str.find(substring) != string::npos) { // Check if the current string contains the substring.\n            filteredStrings.push_back(str); // If it does, add it to the result vector.\n        }\n    }\n\n    return filteredStrings; // Return the filtered list of strings.\n}\n\n// Function to test the filter_by_substring function with given data points.\nvoid check() {\n    vector<string> empty;\n    auto res1 = filter_by_substring(empty, \"a\");\n    assert(res1.empty()); // Should be an empty vector.\n\n    vector<string> input2{\"abc\", \"bacd\", \"cde\", \"vector\"};\n    auto res2 = filter_by_substring(input2, \"a\");\n    vector<string> expected2{\"abc\", \"bacd\", \"vector\"};\n    assert(res2 == expected2); // Should match the expected result.\n\n    cout << \"All tests passed successfully.\" << endl;\n}\n\n"}
{"task_id": "CPP/8", "generation": "#include <iostream>\n#include <vector>\n#include <utility> // for std::pair\n\nstd::pair<int, int> sum_product(std::vector<int> numbers) {\n    if (numbers.empty()) {\n        return {0, 1};\n    }\n\n    int total_sum = 0;\n    int product = 1;\n\n    for (int num : numbers) {\n        total_sum += num;\n        product *= num;\n    }\n\n    return {total_sum, product};\n}\n\n"}
{"task_id": "CPP/9", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> rolling_max(vector<int> numbers) {\n    // Check if the input vector is empty to avoid undefined behavior.\n    if (numbers.empty()) return {};\n\n    vector<int> result;\n    int currentMax = numbers[0];  // Initialize with the first element of the sequence.\n\n    for (int num : numbers) {\n        // Update the current maximum value if the current number is greater than it.\n        if (num > currentMax) {\n            currentMax = num;\n        }\n        // Append the current maximum to the result vector.\n        result.push_back(currentMax);\n    }\n\n    return result;\n}\n\n// Example usage\n"}
{"task_id": "CPP/10", "generation": "#include <string>\n#include <algorithm> // for std::reverse\nusing namespace std;\n\nbool is_palindrome(string str) {\n    string reversed_str = str;\n    reverse(reversed_str.begin(), reversed_str.end());\n    return str == reversed_str;\n}\n\nstring make_palindrome(string str) {\n    int n = str.length();\n    for (int i = 0; i < n; ++i) {\n        if (is_palindrome(str.substr(i))) {\n            string prefix = str.substr(0, i);\n            reverse(prefix.begin(), prefix.end());\n            return str + prefix;\n        }\n    }\n    // If no palindromic suffix is found, append the entire reversed string\n    reverse(str.begin(), str.end());\n    return str + str;\n}\n"}
{"task_id": "CPP/11", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring string_xor(string a, string b) {\n    // Ensure both strings are of equal length by padding with zeros if necessary.\n    int len_a = a.length();\n    int len_b = b.length();\n\n    // Pad the shorter string with leading '0's to match lengths\n    while (len_a < len_b) { a = \"0\" + a; ++len_a; }\n    while (len_b < len_a) { b = \"0\" + b; ++len_b; }\n\n    string result;\n    \n    // Perform XOR on each pair of characters and append to the result\n    for(int i = 0; i < len_a; ++i){\n        if(a[i] == b[i]) {\n            result += '0'; // If both are same, XOR is 0\n        } else {\n            result += '1'; // If different, XOR is 1\n        }\n    }\n\n    return result;\n}\n\n// Function to test the string_xor function\nvoid check() {\n    cout << (string_xor(\"010\", \"110\") == \"100\" ? \"Test Passed\\n\" : \"Test Failed\\n\");\n}\n\n"}
{"task_id": "CPP/12", "generation": "#include <vector>\n#include <string>\nusing namespace std;\n\nstring longest(vector<string> strings) {\n    if (strings.empty()) return \"\"; // Return an empty string to represent None\n\n    string maxString = strings[0]; // Assume the first string is the longest initially\n    size_t maxLength = maxString.length();\n\n    for (size_t i = 1; i < strings.size(); ++i) { // Start from the second element\n        if (strings[i].length() > maxLength) {\n            maxString = strings[i];\n            maxLength = strings[i].length();\n        }\n    }\n\n    return maxString;\n}\n"}
{"task_id": "CPP/13", "generation": "#include <iostream>\nusing namespace std;\n\nint greatest_common_divisor(int a, int b) {\n    while (b != 0) {\n        int temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n"}
{"task_id": "CPP/14", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> all_prefixes(string str){\n    vector<string> prefixes;\n    for(size_t i = 0; i < str.length(); ++i) {\n        // Create a substring from the start to the current position (inclusive)\n        string prefix = str.substr(0, i + 1);\n        // Add this prefix to the vector\n        prefixes.push_back(prefix);\n    }\n    return prefixes;\n}\n\n// Example usage:\n"}
{"task_id": "CPP/15", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nstring string_sequence(int n) {\n    string result = \"\";\n    \n    for (int i = 0; i <= n; ++i) {\n        // Convert integer to string and append it to the result string.\n        result += to_string(i);\n        \n        // Add a space after each number except the last one\n        if (i < n) {\n            result += \" \";\n        }\n    }\n\n    return result;\n}\n\n// Function to test the correctness of the solution\nvoid check() {\n    cout << (string_sequence(0) == \"0\" ? \"Test 1 Passed\\n\" : \"Test 1 Failed\\n\");\n    cout << (string_sequence(5) == \"0 1 2 3 4 5\" ? \"Test 2 Passed\\n\" : \"Test 2 Failed\\n\");\n}\n\n"}
{"task_id": "CPP/16", "generation": "#include <iostream>\n#include <set>\n#include <string>\nusing namespace std;\n\nint count_distinct_characters(string str) {\n    // Convert string to lower case for case-insensitive comparison\n    transform(str.begin(), str.end(), str.begin(), ::tolower);\n    \n    // Use a set to store unique characters\n    set<char> distinctChars;\n    \n    // Iterate through each character and add it to the set\n    for (char c : str) {\n        distinctChars.insert(c);\n    }\n    \n    // The size of the set is the number of distinct characters\n    return distinctChars.size();\n}\n\n"}
{"task_id": "CPP/17", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<int> parse_music(string music_string){\n    vector<int> beats;\n    int i = 0;\n    \n    while (i < music_string.length()) {\n        if(music_string[i] == 'o') { // Check for whole note\n            if(i + 1 < music_string.length() && music_string[i+1] == '|') {\n                beats.push_back(2); // Half note\n                i += 2; // Skip the next character as well since it's part of the half note\n            } else {\n                beats.push_back(4); // Whole note\n                i++;\n            }\n        } else if(music_string[i] == '.') { // Check for quarter note\n            if(i + 1 < music_string.length() && music_string[i+1] == '|') {\n                beats.push_back(1); // Quarter note\n                i += 2; // Skip the next character as well since it's part of the quarter note\n            } else {\n                cout << \"Invalid input: Expected '|' after '.'\" << endl;\n                return vector<int>(); // Return an empty vector in case of invalid input\n            }\n        } else if(music_string[i] == ' ') { // Skip spaces\n            i++;\n        } else {\n            cout << \"Invalid character encountered: \" << music_string[i] << endl;\n            return vector<int>(); // Return an empty vector in case of invalid input\n        }\n    }\n\n    return beats;\n}\n\n"}
{"task_id": "CPP/18", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint how_many_times(string str, string substring) {\n    if (substring.empty() || str.empty()) return 0; // If either string is empty, no matches are possible.\n    \n    int count = 0;\n    size_t pos = 0;\n    \n    while ((pos = str.find(substring, pos)) != string::npos) { // Find the substring starting from 'pos'.\n        ++count; // Increment count for each match found.\n        ++pos;   // Move to the next character after the current match to find overlapping occurrences.\n    }\n    \n    return count;\n}\n\n"}
{"task_id": "CPP/19", "generation": "#include <iostream>\n#include <string>\n#include <vector>\n#include <map>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to sort numbers given as words from \"zero\" to \"nine\"\nstring sort_numbers(string numbers) {\n    // Mapping of number words to their numeric values\n    map<string, int> num_map = {\n        {\"zero\", 0}, {\"one\", 1}, {\"two\", 2}, {\"three\", 3},\n        {\"four\", 4}, {\"five\", 5}, {\"six\", 6}, {\"seven\", 7},\n        {\"eight\", 8}, {\"nine\", 9}\n    };\n\n    // Reverse mapping for converting numeric values back to words\n    map<int, string> reverse_map;\n    for (auto &p : num_map) {\n        reverse_map[p.second] = p.first;\n    }\n\n    // Split the input string into individual number words\n    vector<string> num_words;\n    string word;\n    for (char c : numbers) {\n        if (c == ' ') {\n            if (!word.empty()) {\n                num_words.push_back(word);\n                word.clear();\n            }\n        } else {\n            word += c;\n        }\n    }\n    if (!word.empty()) {\n        num_words.push_back(word);\n    }\n\n    // Sort the number words based on their numeric values\n    sort(num_words.begin(), num_words.end(),\n         [&num_map](const string &a, const string &b) { return num_map[a] < num_map[b]; });\n\n    // Convert back to a space-delimited string of sorted number words\n    string result;\n    for (size_t i = 0; i < num_words.size(); ++i) {\n        if (i > 0) result += \" \";\n        result += reverse_map[num_map[num_words[i]]];\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/20", "generation": "#include <algorithm>\n#include <vector>\n#include <cmath>\n\nstd::vector<float> find_closest_elements(std::vector<float> numbers) {\n    // Sort the vector in ascending order.\n    std::sort(numbers.begin(), numbers.end());\n\n    float min_diff = INFINITY;\n    std::pair<float, float> result;\n\n    for (size_t i = 0; i < numbers.size() - 1; ++i) {\n        float diff = numbers[i + 1] - numbers[i];\n        if (diff < min_diff) {\n            min_diff = diff;\n            result = {numbers[i], numbers[i + 1]};\n        }\n    }\n\n    // Convert the pair to a vector and return.\n    std::vector<float> out{result.first, result.second};\n    return out;\n}\n"}
{"task_id": "CPP/21", "generation": "#include <vector>\n#include <algorithm> // for std::min_element and std::max_element\n\nusing namespace std;\n\nvector<float> rescale_to_unit(vector<float> numbers){\n    float min_val = *std::min_element(numbers.begin(), numbers.end());\n    float max_val = *std::max_element(numbers.begin(), numbers.end());\n\n    vector<float> scaled_numbers;\n    for (float num : numbers) {\n        // Apply the linear transformation\n        float scaled_num = (num - min_val) / (max_val - min_val);\n        scaled_numbers.push_back(scaled_num);\n    }\n\n    return scaled_numbers;\n}\n\n// Example usage:\n"}
{"task_id": "CPP/22", "generation": "#include <iostream>\n#include <vector>\n#include <list>\n#include <boost/any.hpp>\n\ntypedef std::list<boost::any> list_any;\n\nstd::vector<int> filter_integers(list_any values) {\n    std::vector<int> integers;\n    \n    for (auto it = values.begin(); it != values.end(); ++it) {\n        if (it->type() == typeid(int)) { // Check if the type is int\n            integers.push_back(boost::any_cast<int>(*it)); // Cast and add to vector\n        }\n    }\n\n    return integers;\n}\n\n"}
{"task_id": "CPP/23", "generation": "#include <iostream>\n#include <string>\n\nint stringLength(const std::string& str) {\n    return str.length();\n}\n\n"}
{"task_id": "CPP/24", "generation": "#include<stdio.h>\n\nint largest_divisor(int n) {\n    // Start from half of n because no number greater than n/2 can be a divisor of n (except n itself)\n    for (int i = n / 2; i >= 1; --i) {\n        if (n % i == 0) {\n            return i;\n        }\n    }\n    // If no divisor is found, which theoretically shouldn't happen unless n <= 1\n    return -1;\n}\n\n"}
{"task_id": "CPP/25", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvector<int> factorize(int n) {\n    vector<int> factors;\n    \n    // Divide by 2 until odd\n    while (n % 2 == 0) {\n        factors.push_back(2);\n        n /= 2;\n    }\n    \n    // Check for odd factors from 3 onwards\n    for (int i = 3; i * i <= n; i += 2) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n    \n    // If n is a prime number greater than 2\n    if (n > 2) {\n        factors.push_back(n);\n    }\n\n    return factors;\n}\n\n"}
{"task_id": "CPP/26", "generation": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nvector<int> remove_duplicates(vector<int> numbers) {\n    unordered_map<int, int> occurrences;\n    \n    // Count the occurrences of each number.\n    for (int num : numbers) {\n        occurrences[num]++;\n    }\n    \n    vector<int> result;\n    \n    // Add to result only those elements that occur once.\n    for (int num : numbers) {\n        if (occurrences[num] == 1) {\n            result.push_back(num);\n        }\n    }\n    \n    return result;\n}\n\n// Function to print the vector\nvoid print_vector(const vector<int>& v) {\n    cout << \"{\";\n    for(size_t i = 0; i < v.size(); ++i) {\n        cout << v[i];\n        if (i != v.size() - 1) cout << \", \";\n    }\n    cout << \"}\" << endl;\n}\n\n"}
{"task_id": "CPP/27", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring flip_case(string str) {\n    for (size_t i = 0; i < str.length(); ++i) {\n        if (isupper(str[i])) {\n            // Convert uppercase to lowercase\n            str[i] = tolower(str[i]);\n        } else if (islower(str[i])) {\n            // Convert lowercase to uppercase\n            str[i] = toupper(str[i]);\n        }\n    }\n    return str;\n}\n\n"}
{"task_id": "CPP/28", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring concatenate(vector<string> strings) {\n    // Initialize an empty string for storing the concatenated result.\n    string result = \"\";\n    \n    // Iterate through each element in the vector and append it to the result.\n    for (const auto& str : strings) {\n        result += str;\n    }\n    \n    return result;\n}\n\n// Function to test the concatenate function with some test cases\nvoid test_concatenate() {\n    cout << \"Test Case 1: Empty Vector -> Expected: \\\"\\\", Actual: \\\"\" << concatenate({}) << \"\\\"\" << endl;\n    cout << \"Test Case 2: {\\\"a\\\", \\\"b\\\", \\\"c\\\"} -> Expected: \\\"abc\\\", Actual: \\\"\" << concatenate({\"a\", \"b\", \"c\"}) << \"\\\"\" << endl;\n}\n\n"}
{"task_id": "CPP/29", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> filter_by_prefix(vector<string> strings, string prefix) {\n    vector<string> filteredStrings; // This will store the results\n\n    for (const auto& str : strings) { // Iterate through each string in the input\n        if (!str.empty() && str.substr(0, prefix.size()) == prefix) {\n            // Check if the current string starts with the given prefix\n            filteredStrings.push_back(str); // Add to result vector if condition is met\n        }\n    }\n\n    return filteredStrings; // Return the filtered list of strings\n}\n\n// Function to test the filter_by_prefix function\nvoid check() {\n    auto result1 = filter_by_prefix({}, \"a\");\n    cout << \"Test 1: \";\n    for (const auto& str : result1) {\n        cout << str << \" \";\n    }\n    cout << endl;\n\n    auto result2 = filter_by_prefix({\"abc\", \"bcd\", \"cde\", \"vector\"}, \"a\");\n    cout << \"Test 2: \";\n    for (const auto& str : result2) {\n        cout << str << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/30", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // For std::copy_if\n\nusing namespace std;\n\nvector<float> get_positive(vector<float> l) {\n    vector<float> result;  // This will store the positive numbers.\n    \n    // Use copy_if to filter only positive numbers into 'result'.\n    copy_if(l.begin(), l.end(), back_inserter(result), [](float x){ return x > 0; });\n    \n    return result;\n}\n\n// Function to print a vector\nvoid print_vector(const vector<float>& v) {\n    for (auto num : v) {\n        cout << num << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/31", "generation": "#include <iostream>\nusing namespace std;\n\nbool is_prime(long long n) {\n    // Handle edge cases for 0, 1 and negative numbers.\n    if (n <= 1) return false;\n    \n    // Check divisibility from 2 up to the square root of n.\n    for (long long i = 2; i * i <= n; ++i) {\n        if (n % i == 0)\n            return false;\n    }\n    return true;\n}\n\n"}
{"task_id": "CPP/32", "generation": "#include <iostream>\n#include <vector>\n#include <cmath>\n\ndouble poly(const std::vector<double>& xs, double x) {\n    /*\n     * Evaluates polynomial with coefficients xs at point x.\n     * Returns xs[0] + xs[1] * x + xs[2] * x^2 + .... xs[n] * x^n\n     */\n    double sum = 0;\n    for (size_t i = 0; i < xs.size(); ++i) {\n        sum += xs[i] * std::pow(x, i);\n    }\n    return sum;\n}\n\ndouble find_zero(const std::vector<double>& xs) {\n    /*\n     * xs are coefficients of a polynomial. find_zero finds x such that poly(x) = 0.\n     * find_zero returns only one zero point, even if there are many.\n     */\n    \n    // Bisection method parameters\n    double a = -1000;   // Lower bound for the root search interval\n    double b = 1000;    // Upper bound for the root search interval\n    const double tol = 1e-6; // Tolerance level\n    \n    if (poly(xs, a) * poly(xs, b) > 0) {\n        std::cerr << \"The function does not change sign in the given interval.\" << std::endl;\n        return NAN;\n    }\n    \n    while ((b - a) / 2.0 > tol) {\n        double c = (a + b) / 2.0;\n        \n        if (poly(xs, c) == 0 || (b - a) / 2.0 < tol)\n            return c;\n        \n        // Check which subinterval to continue with\n        if (poly(xs, a) * poly(xs, c) < 0)\n            b = c;\n        else\n            a = c;\n    }\n    \n    return (a + b) / 2.0;\n}\n\n"}
{"task_id": "CPP/33", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // for std::sort\n\nusing namespace std;\n\nvector<int> sort_third(vector<int> l) {\n    vector<int> to_sort;\n    \n    // Extract values from indices divisible by 3 (0-based indexing)\n    for(size_t i = 0; i < l.size(); i += 3) {\n        to_sort.push_back(l[i]);\n    }\n    \n    // Sort the extracted values\n    sort(to_sort.begin(), to_sort.end());\n    \n    // Replace original elements with sorted ones\n    for(size_t i = 0, j = 0; i < l.size() && j < to_sort.size(); i += 3, ++j) {\n        l[i] = to_sort[j];\n    }\n    \n    return l;\n}\n\n// Function to test the correctness of sort_third function\nvoid check_function() {\n    vector<int> test1 = {1, 2, 3};\n    vector<int> expected1 = {1, 2, 3};\n    assert(sort_third(test1) == expected1);\n\n    vector<int> test2 = {5, 6, 3, 4, 8, 9, 2};\n    vector<int> expected2 = {2, 6, 3, 4, 8, 9, 5};\n    assert(sort_third(test2) == expected2);\n\n    cout << \"All tests passed successfully.\" << endl;\n}\n\n"}
{"task_id": "CPP/34", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // for std::sort and std::unique\n\nusing namespace std;\n\nvector<int> unique(vector<int> l) {\n    // First, sort the vector so that duplicate elements are adjacent.\n    sort(l.begin(), l.end());\n    \n    // Use std::unique to remove consecutive duplicates. It returns a past-the-end iterator for the new range of unique elements.\n    auto last = unique(l.begin(), l.end());\n    \n    // Erase the non-unique part of the vector\n    l.erase(last, l.end());\n    \n    return l;\n}\n\n// Function to print the contents of a vector\nvoid printVector(const vector<int>& v) {\n    for (int i : v) {\n        cout << i << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/35", "generation": "#include <vector>\n#include <algorithm> // For std::numeric_limits\n\nusing namespace std;\n\nfloat max_element(vector<float> l) {\n    if (l.empty()) {  // Check if the vector is empty to avoid undefined behavior.\n        return numeric_limits<float>::lowest(); // Return the lowest possible float value if the vector is empty\n    }\n\n    float max_val = l[0];  // Initialize max_val with the first element of the vector\n\n    for (size_t i = 1; i < l.size(); ++i) {  // Start from the second element and iterate through the rest\n        if (l[i] > max_val) {\n            max_val = l[i];  // Update max_val if a larger value is found\n        }\n    }\n\n    return max_val;\n}\n"}
{"task_id": "CPP/36", "generation": "#include <iostream>\nusing namespace std;\n\nint fizz_buzz(int n) {\n    int count = 0;\n    \n    for (int i = 1; i < n; ++i) {\n        if ((i % 11 == 0 || i % 13 == 0)) { // Check divisibility by 11 or 13\n            int temp = i;\n            while (temp > 0) {\n                if (temp % 10 == 7) count++; // Count digit '7'\n                temp /= 10; // Move to the next digit\n            }\n        }\n    }\n    \n    return count;\n}\n\n"}
{"task_id": "CPP/37", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // for std::sort\n\nusing namespace std;\n\nvector<float> sort_even(vector<float> l) {\n    vector<float> even_elements;\n    \n    // Extract elements at even indices and store them in a separate vector.\n    for (size_t i = 0; i < l.size(); i += 2) {\n        even_elements.push_back(l[i]);\n    }\n    \n    // Sort the extracted even-indexed elements.\n    sort(even_elements.begin(), even_elements.end());\n    \n    // Place sorted elements back into their original positions in vector `l`.\n    for (size_t i = 0, j = 0; i < l.size(); i += 2) {\n        l[i] = even_elements[j++];\n    }\n    \n    return l;\n}\n\n// Function to test the sort_even function with provided data points.\nvoid check() {\n    vector<float> result;\n\n    // Test case 1\n    result = sort_even({1, 2, 3});\n    for (float num : result) cout << num << \" \";\n    cout << endl; // Expected: 1 2 3\n\n    // Test case 2\n    result = sort_even({5, 6, 3, 4});\n    for (float num : result) cout << num << \" \";\n    cout << endl; // Expected: 3 6 5 4\n}\n\n"}
{"task_id": "CPP/38", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\n// Function to encode a string by cycling groups of three characters.\nstring encode_cyclic(string s) { \n    int l = s.length();\n    string output;\n    for (int i = 0; i * 3 < l; i++) {\n        string x = s.substr(i * 3, 3);\n        if (x.length() == 3) x = x.substr(1) + x[0];\n        output += x;\n    }\n    return output;\n}\n\n// Function to decode a string that was encoded with encode_cyclic.\nstring decode_cyclic(string s) { \n    int l = s.length();\n    string output;\n    for (int i = 0; i * 3 < l; i++) {\n        string x = s.substr(i * 3, 3);\n        if (x.length() == 3) x = x[2] + x.substr(0, 2); // Rotate right\n        output += x;\n    }\n    return output;\n}\n\n"}
{"task_id": "CPP/39", "generation": "#include <stdio.h>\n#include <math.h>\n\n// Function to check if a number is prime\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    if (num == 2 || num == 3) return true;\n    if (num % 2 == 0 || num % 3 == 0) return false;\n\n    for (int i = 5; i * i <= num; i += 6) {\n        if (num % i == 0 || num % (i + 2) == 0)\n            return false;\n    }\n    return true;\n}\n\n// Function to find the n-th Fibonacci number that is also prime\nint prime_fib(int n) {\n    int fib1 = 0, fib2 = 1; // First two Fibonacci numbers\n    int count = 0;\n\n    while (true) {\n        int nextFib = fib1 + fib2;\n        if (is_prime(nextFib)) {\n            count++;\n            if (count == n)\n                return nextFib;\n        }\n        fib1 = fib2;\n        fib2 = nextFib;\n    }\n\n    // This line should never be reached\n    return -1;\n}\n\n"}
{"task_id": "CPP/40", "generation": "#include <vector>\n#include <algorithm> // For std::sort\n\nusing namespace std;\n\nbool triples_sum_to_zero(vector<int> l) {\n    int n = l.size();\n    \n    if (n < 3) return false; // Early exit for vectors with less than 3 elements\n    \n    sort(l.begin(), l.end()); // Sort the vector to use two-pointer technique\n    \n    for(int i = 0; i < n-2; ++i) {\n        int left = i + 1, right = n - 1;\n        \n        while(left < right) {\n            int sum = l[i] + l[left] + l[right];\n            \n            if(sum == 0) return true; // Found three numbers that sum to zero\n            else if(sum < 0) ++left; // Need a larger number, move left pointer to the right\n            else --right; // Need a smaller number, move right pointer to the left\n        }\n    }\n    \n    return false; // No triplet found that sums up to zero\n}\n\n// Example usage:\n"}
{"task_id": "CPP/41", "generation": "#include <iostream>\nusing namespace std;\n\nint car_race_collision(int n) {\n    // Since all cars move at the same speed and continue their trajectory after collision,\n    // each left-to-right car will collide with exactly one right-to-left car.\n    return n;\n}\n\n"}
{"task_id": "CPP/42", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> incr_list(vector<int> l) {\n    // Iterate over all elements of the vector.\n    for (size_t i = 0; i < l.size(); ++i) {\n        // Increment each element by 1.\n        l[i] += 1;\n    }\n    return l;\n}\n\n// Function to test the correctness of incr_list function\nvoid check() {\n    vector<int> test1 = {1, 2, 3};\n    vector<int> expected1 = {2, 3, 4};\n    assert(incr_list(test1) == expected1);\n\n    vector<int> test2 = {5, 3, 5, 2, 3, 3, 9, 0, 123};\n    vector<int> expected2 = {6, 4, 6, 3, 4, 4, 10, 1, 124};\n    assert(incr_list(test2) == expected2);\n\n    cout << \"All tests passed successfully.\" << endl;\n}\n\n"}
{"task_id": "CPP/43", "generation": "#include <iostream>\n#include <vector>\n#include <unordered_set> // Use unordered_set for efficient lookup\n\nusing namespace std;\n\nbool pairs_sum_to_zero(vector<int> l) {\n    unordered_set<int> seenNumbers; // Set to keep track of numbers we've seen\n    \n    for (int num : l) { // Iterate through each number in the vector\n        if (seenNumbers.find(-num) != seenNumbers.end()) { // Check if -num is already in the set\n            return true; // Found two numbers that sum to zero\n        }\n        seenNumbers.insert(num); // Add current number to the set\n    }\n    \n    return false; // No pair found that sums to zero\n}\n\n// Function to test the pairs_sum_to_zero function with given data points\nvoid check() {\n    cout << boolalpha; // Print true/false instead of 1/0 for boolean values\n    cout << \"Test Case 1: \" << pairs_sum_to_zero({1, 3, 5, 0}) << endl;\n    cout << \"Test Case 2: \" << pairs_sum_to_zero({1, 3, -2, 1}) << endl;\n    cout << \"Test Case 3: \" << pairs_sum_to_zero({1, 2, 3, 7}) << endl;\n    cout << \"Test Case 4: \" << pairs_sum_to_zero({2, 4, -5, 3, 5, 7}) << endl;\n    cout << \"Test Case 5: \" << pairs_sum_to_zero({1}) << endl;\n}\n\n"}
{"task_id": "CPP/44", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring change_base(int x, int base) {\n    if (base <= 1 || base >= 10) return \"Invalid base\"; // Ensure base is valid\n\n    string result = \"\";\n    while (x > 0) {\n        int remainder = x % base;\n        result = to_string(remainder) + result; // Prepend the remainder\n        x /= base;\n    }\n\n    if(result == \"\") result = \"0\"; // Handle case where x was 0 initially\n\n    return result;\n}\n\n"}
{"task_id": "CPP/45", "generation": "#include<stdio.h>\n\nfloat triangle_area(float a, float h) {\n    // Area of a triangle is 0.5 * base * height\n    return 0.5 * a * h;\n}\n\n"}
{"task_id": "CPP/46", "generation": "#include <iostream>\n#include <vector>\n\nint fib4(int n) {\n    // Base cases for the first four elements of the sequence.\n    if (n == 0 || n == 1)\n        return 0;\n    else if (n == 2)\n        return 2;\n    else if (n == 3)\n        return 0;\n\n    // Initialize an array to store the computed values up to n\n    std::vector<int> fib4_values(n + 1);\n    \n    // Set the base cases.\n    fib4_values[0] = 0;\n    fib4_values[1] = 0;\n    fib4_values[2] = 2;\n    fib4_values[3] = 0;\n\n    // Compute each value from 4 to n using the formula\n    for (int i = 4; i <= n; ++i) {\n        fib4_values[i] = fib4_values[i - 1] + fib4_values[i - 2] + fib4_values[i - 3] + fib4_values[i - 4];\n    }\n\n    // Return the nth value\n    return fib4_values[n];\n}\n\n"}
{"task_id": "CPP/47", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // for std::sort\n\nusing namespace std;\n\nfloat median(vector<float> l){\n    size_t n = l.size();\n    \n    if (n == 0) {\n        throw invalid_argument(\"Vector is empty\");\n    }\n    \n    sort(l.begin(), l.end()); // Sort the vector\n    \n    if (n % 2 != 0) { // If odd number of elements\n        return l[n / 2];\n    } else { // If even number of elements\n        return (l[(n - 1) / 2] + l[n / 2]) / 2.0;\n    }\n}\n\n"}
{"task_id": "CPP/48", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_palindrome(string text) {\n    int left = 0;\n    int right = text.length() - 1;\n\n    while (left < right) {\n        if (text[left] != text[right]) {\n            return false; // Characters do not match\n        }\n        left++;\n        right--;\n    }\n\n    return true; // All characters matched, it's a palindrome\n}\n\n"}
{"task_id": "CPP/49", "generation": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nlong long modpow(long long base, long long exp, long long mod) {\n    long long result = 1;\n    while (exp > 0) {\n        if (exp & 1)\n            result = (result * base) % mod;\n        exp >>= 1;\n        base = (base * base) % mod;\n    }\n    return result;\n}\n\nint modp(int n, int p) {\n    return modpow(2, n, p);\n}\n"}
{"task_id": "CPP/50", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nstring encode_shift(string s) {\n    // returns encoded string by shifting every character by 5 in the alphabet.\n    string out;\n    int i;\n    for (i = 0; i < s.length(); i++) {\n        int w = ((int)s[i] + 5 - (int)'a') % 26 + (int)'a';\n        out += (char)w;\n    }\n    return out;\n}\n\nstring decode_shift(string s) {\n    // takes as input string encoded with encode_shift function. Returns decoded string.\n    string out;\n    int i;\n    for (i = 0; i < s.length(); i++) {\n        int w = ((int)s[i] - 5 - (int)'a' + 26) % 26 + (int)'a'; // Adding 26 to ensure positive result\n        out += (char)w;\n    }\n    return out;\n}\n\n// Example usage:\n"}
{"task_id": "CPP/51", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool isVowel(char c) {\n    // Convert character to lowercase for simplicity and check if it's a vowel.\n    char lower_c = tolower(c);\n    return (lower_c == 'a' || lower_c == 'e' || lower_c == 'i' || lower_c == 'o' || lower_c == 'u');\n}\n\nstring remove_vowels(string text) {\n    string result;\n    for(char c : text) {\n        if(!isVowel(c)) { // If the character is not a vowel, add it to the result.\n            result += c;\n        }\n    }\n    return result;\n}\n\n"}
{"task_id": "CPP/52", "generation": "#include <vector>\nusing namespace std;\n\nbool below_threshold(vector<int> l, int t) {\n    // Iterate through each element in the vector\n    for (int num : l) {\n        // If any number is greater than or equal to the threshold, return false\n        if (num >= t) {\n            return false;\n        }\n    }\n    // If all numbers are below the threshold, return true\n    return true;\n}\n\n// Example usage:\n/*\nbool result1 = below_threshold({1, 2, 4, 10}, 100); // Should be true\nbool result2 = below_threshold({1, 20, 4, 10}, 5);   // Should be false\n*/\n"}
{"task_id": "CPP/53", "generation": "#include<iostream>\nusing namespace std;\n\nint add(int x, int y) {\n    return x + y;\n}\n\n// Example usage\n"}
{"task_id": "CPP/54", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nbool same_chars(string s0, string s1) {\n    // Sort both strings to bring identical characters together.\n    sort(s0.begin(), s0.end());\n    sort(s1.begin(), s1.end());\n\n    // Remove duplicate characters from each sorted string.\n    auto last_unique_s0 = unique(s0.begin(), s0.end());\n    auto last_unique_s1 = unique(s1.begin(), s1.end());\n\n    // Erase the duplicates in place to get only unique characters.\n    s0.erase(last_unique_s0, s0.end());\n    s1.erase(last_unique_s1, s1.end());\n\n    // Compare the two strings for equality after processing.\n    return s0 == s1;\n}\n\n"}
{"task_id": "CPP/55", "generation": "#include<stdio.h>\n\nint fib(int n) {\n    if (n <= 1)\n        return n;\n    else\n        return fib(n-1) + fib(n-2);\n}\n\n"}
{"task_id": "CPP/56", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    int balance = 0;\n    \n    for (char c : brackets) {\n        if (c == '<') {\n            ++balance; // Increment for an opening bracket\n        } else if (c == '>') {\n            --balance; // Decrement for a closing bracket\n            \n            // If balance goes below zero, there's an unmatched closing bracket\n            if (balance < 0) return false;\n        }\n    }\n    \n    // Return true only if the balance is back to zero at the end\n    return balance == 0;\n}\n\n"}
{"task_id": "CPP/57", "generation": "#include <vector>\nusing namespace std;\n\nbool monotonic(const vector<float>& l) {\n    bool increasing = true;\n    bool decreasing = true;\n\n    for (size_t i = 1; i < l.size(); ++i) {\n        if (l[i] > l[i - 1]) {\n            decreasing = false;\n        }\n        if (l[i] < l[i - 1]) {\n            increasing = false;\n        }\n    }\n\n    return increasing || decreasing;\n}\n"}
{"task_id": "CPP/58", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // For sort function\n#include <set>       // To store unique elements\n\nusing namespace std;\n\nvector<int> common(vector<int> l1, vector<int> l2) {\n    // Sort both vectors to make it easier to find common elements.\n    sort(l1.begin(), l1.end());\n    sort(l2.begin(), l2.end());\n\n    set<int> result;  // Use a set to store unique and sorted results\n    auto it1 = l1.begin();\n    auto it2 = l2.begin();\n\n    // Traverse both vectors to find common elements\n    while (it1 != l1.end() && it2 != l2.end()) {\n        if (*it1 == *it2) {\n            result.insert(*it1);\n            ++it1;\n            ++it2;\n        } else if (*it1 < *it2) {\n            ++it1;\n        } else {\n            ++it2;\n        }\n    }\n\n    // Convert set to vector\n    return vector<int>(result.begin(), result.end());\n}\n\n// Function to print the elements of a vector\nvoid printVector(const vector<int>& vec) {\n    for (int num : vec) {\n        cout << num << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/59", "generation": "#include <stdio.h>\n#include <stdbool.h>\n\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    for (int i = 2; i * i <= num; ++i) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\nint largest_prime_factor(int n){\n    int largestFactor = -1;\n\n    // Divide n by 2 to remove all even factors\n    while (n % 2 == 0) {\n        largestFactor = 2;\n        n /= 2;\n    }\n\n    // Now we only have odd factors left, start from 3 and check each odd number.\n    for (int i = 3; i * i <= n; i += 2) {\n        while (n % i == 0) {\n            largestFactor = i;\n            n /= i;\n        }\n    }\n\n    // If n is a prime number greater than 2\n    if (n > 2)\n        largestFactor = n;\n\n    return largestFactor;\n}\n\n"}
{"task_id": "CPP/60", "generation": "#include<iostream>\nusing namespace std;\n\nint sum_to_n(int n){\n    int sum = 0;\n    for (int i = 1; i <= n; ++i) {\n        sum += i;\n    }\n    return sum;\n}\n\n// Function to test the correctness of sum_to_n\nvoid check_function() {\n    cout << \"sum_to_n(30): \" << sum_to_n(30) << endl; // Expected output: 465\n    cout << \"sum_to_n(100): \" << sum_to_n(100) << endl; // Expected output: 5050\n    cout << \"sum_to_n(5): \" << sum_to_n(5) << endl; // Expected output: 15\n    cout << \"sum_to_n(10): \" << sum_to_n(10) << endl; // Expected output: 55\n    cout << \"sum_to_n(1): \" << sum_to_n(1) << endl; // Expected output: 1\n}\n\n"}
{"task_id": "CPP/61", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    int balance = 0; // Initialize balance counter\n\n    for (char c : brackets) { // Iterate through each character in the string\n        if (c == '(') {\n            ++balance; // Increment balance for an opening bracket\n        } else if (c == ')') {\n            --balance; // Decrement balance for a closing bracket\n            if (balance < 0) return false; // If balance is negative, there's a closing bracket without a matching opening one\n        }\n    }\n\n    return balance == 0; // True if all brackets are correctly matched and balanced\n}\n\n"}
{"task_id": "CPP/62", "generation": "#include <iostream>\n#include <vector>\n\nstd::vector<float> derivative(const std::vector<float>& xs) {\n    // Create an empty vector to store the coefficients of the derivative polynomial\n    std::vector<float> result;\n\n    // Iterate through each coefficient starting from the first non-constant term (index 1)\n    for(size_t i = 1; i < xs.size(); ++i) {\n        // Multiply the current coefficient by its index and add it to the result vector\n        result.push_back(xs[i] * static_cast<float>(i));\n    }\n\n    return result;\n}\n\n// Function to test the derivative function with given examples\nvoid check_derivative() {\n    std::vector<float> example1 = {3, 1, 2, 4, 5};\n    std::vector<float> expected1 = {1, 4, 12, 20};\n    \n    std::vector<float> result1 = derivative(example1);\n    assert(result1 == expected1);\n\n    std::vector<float> example2 = {1, 2, 3};\n    std::vector<float> expected2 = {2, 6};\n\n    std::vector<float> result2 = derivative(example2);\n    assert(result2 == expected2);\n\n    std::cout << \"All tests passed successfully.\" << std::endl;\n}\n\n"}
{"task_id": "CPP/63", "generation": "#include <iostream>\n#include <vector>\n\nint fibfib(int n) {\n    // Base cases\n    if (n == 0 || n == 1)\n        return 0;\n    else if (n == 2)\n        return 1;\n\n    // Initialize a vector to store the computed values of fibfib sequence.\n    std::vector<int> dp(n + 1);\n    dp[0] = 0;   // fibfib(0) is 0\n    dp[1] = 0;   // fibfib(1) is 0\n    dp[2] = 1;   // fibfib(2) is 1\n\n    // Compute the values from 3 to n using the recurrence relation.\n    for (int i = 3; i <= n; ++i)\n        dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3];\n\n    return dp[n];\n}\n\n// Function to test the fibfib function with given data points\nvoid check() {\n    std::cout << \"fibfib(1) should be 0: \" << (fibfib(1) == 0 ? \"Passed\" : \"Failed\") << std::endl;\n    std::cout << \"fibfib(5) should be 4: \" << (fibfib(5) == 4 ? \"Passed\" : \"Failed\") << std::endl;\n    std::cout << \"fibfib(8) should be 24: \" << (fibfib(8) == 24 ? \"Passed\" : \"Failed\") << std::endl;\n}\n\n"}
{"task_id": "CPP/64", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint vowels_count(string s) {\n    int count = 0;\n    // Convert string to lowercase for simplicity\n    transform(s.begin(), s.end(), s.begin(), ::tolower);\n\n    // Check each character in the string\n    for (size_t i = 0; i < s.length(); ++i) {\n        char c = s[i];\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n            count++;\n        }\n        // Check for 'y' at the end of the string\n        else if (c == 'y' && i == s.length() - 1) {\n            count++;\n        }\n    }\n\n    return count;\n}\n\n"}
{"task_id": "CPP/65", "generation": "#include <iostream>\n#include <string>\n#include <algorithm> // for std::reverse\nusing namespace std;\n\nstring circular_shift(int x, int shift) {\n    string digits = to_string(x);\n    int num_digits = digits.size();\n\n    // If shift is greater than or equal to the number of digits, reverse the digits.\n    if (shift >= num_digits) {\n        reverse(digits.begin(), digits.end());\n        return digits;\n    }\n\n    int effective_shift = shift % num_digits;\n\n    // Perform circular shift\n    rotate(digits.rbegin(), digits.rbegin() + effective_shift, digits.rend());\n\n    return digits;\n}\n"}
{"task_id": "CPP/66", "generation": "#include <iostream>\n#include <string>\n#include <cctype> // For isupper() function\n\nusing namespace std;\n\nint digitSum(string s) {\n    int sum = 0;\n    for (char c : s) { // Iterate through each character in the string\n        if (isupper(c)) { // Check if the character is an uppercase letter\n            sum += static_cast<int>(c); // Add its ASCII value to sum\n        }\n    }\n    return sum; // Return the total sum of ASCII values of uppercase letters\n}\n\n"}
{"task_id": "CPP/67", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <vector>\nusing namespace std;\n\nint fruit_distribution(string s, int n) {\n    vector<int> nums;\n    stringstream ss(s);\n    string word;\n    \n    // Extract numbers from the string using stringstream\n    while (ss >> word) {\n        if (stringstream(word) >> n) {\n            nums.push_back(n);\n        }\n    }\n\n    // Calculate mango count by subtracting apples and oranges from total fruits\n    int mango_count = n - accumulate(nums.begin(), nums.end(), 0);\n\n    return mango_count;\n}\n\n"}
{"task_id": "CPP/68", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> pluck(vector<int> arr) {\n    int minValue = INT_MAX; // Initialize to a very large number.\n    int minIndex = -1;      // No valid index found initially.\n\n    for (int i = 0; i < arr.size(); ++i) {\n        if (arr[i] % 2 == 0 && arr[i] <= minValue) { // Check if the value is even and smaller or equal to current min.\n            if (arr[i] < minValue || (arr[i] == minValue && i < minIndex)) {\n                minValue = arr[i];\n                minIndex = i;\n            }\n        }\n    }\n\n    if (minIndex != -1) { // If a valid index was found, return the value and its index.\n        return {minValue, minIndex};\n    } else { // No even number found or vector is empty.\n        return {};\n    }\n}\n"}
{"task_id": "CPP/69", "generation": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint search(vector<int> lst) {\n    unordered_map<int, int> freqMap;\n    \n    // Count frequencies of each element in the list\n    for (int num : lst) {\n        freqMap[num]++;\n    }\n    \n    int result = -1;  // Initialize result as -1\n    \n    // Check each frequency against its value\n    for (auto &entry : freqMap) {\n        if (entry.first <= entry.second && entry.first > result) {\n            result = entry.first;\n        }\n    }\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/70", "generation": "#include <vector>\n#include <algorithm>\n\nstd::vector<int> strange_sort_list(std::vector<int> lst) {\n    // Sort the vector initially.\n    std::sort(lst.begin(), lst.end());\n    \n    std::vector<int> result;\n    int left = 0; // Start index for minimum value\n    int right = lst.size() - 1; // End index for maximum value\n    \n    while (left <= right) {\n        if (left == right) {\n            // If there's only one element left, add it to the result.\n            result.push_back(lst[left]);\n            break;\n        }\n        \n        // Add the minimum value\n        result.push_back(lst[left++]);\n        // Add the maximum value\n        result.push_back(lst[right--]);\n    }\n\n    return result;\n}\n\n// Example usage:\n"}
{"task_id": "CPP/71", "generation": "#include<stdio.h>\n#include<math.h>\n\nfloat triangle_area(float a, float b, float c){\n    // Check if sides form a valid triangle\n    if (a + b <= c || a + c <= b || b + c <= a) {\n        return -1;\n    }\n\n    // Calculate the semi-perimeter\n    float s = (a + b + c) / 2;\n\n    // Use Heron's formula to calculate area\n    float area = sqrt(s * (s - a) * (s - b) * (s - c));\n\n    // Round the result to two decimal points and return\n    return round(area * 100) / 100;\n}\n\n"}
{"task_id": "CPP/72", "generation": "#include <vector>\nusing namespace std;\n\nbool will_it_fly(vector<int> q, int w) {\n    // Check if the vector is balanced (palindromic)\n    for(int i = 0; i < q.size() / 2; ++i) {\n        if(q[i] != q[q.size() - 1 - i]) return false;\n    }\n\n    // Calculate the sum of elements in the vector\n    int sum = 0;\n    for(int num : q) {\n        sum += num;\n    }\n\n    // Check if the sum is less than or equal to the maximum possible weight w\n    return sum <= w;\n}\n"}
{"task_id": "CPP/73", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint smallest_change(vector<int> arr) {\n    int changes = 0;\n    int left = 0;\n    int right = arr.size() - 1;\n\n    while (left < right) {\n        if (arr[left] != arr[right]) {\n            ++changes; // Increment the change count when elements don't match\n        }\n        ++left;\n        --right;\n    }\n\n    return changes;\n}\n\n"}
{"task_id": "CPP/74", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to calculate the total number of characters in a vector of strings.\nint countChars(const vector<string>& lst) {\n    int count = 0;\n    for (const string& str : lst) {\n        count += str.length();\n    }\n    return count;\n}\n\nvector<string> total_match(vector<string> lst1, vector<string> lst2) {\n    // Calculate the number of characters in each list\n    int charsInLst1 = countChars(lst1);\n    int charsInLst2 = countChars(lst2);\n\n    // Compare and return the appropriate list\n    if (charsInLst1 <= charsInLst2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n\n// Function to test the solution with given examples.\nvoid check() {\n    vector<string> empty = {};\n    vector<string> result;\n\n    // Example 1\n    result = total_match(empty, empty);\n    cout << \"Example 1: \";\n    for (const string& str : result) cout << str << \" \";\n    cout << endl;\n\n    // Example 2\n    result = total_match({\"hi\", \"admin\"}, {\"hI\", \"Hi\"});\n    cout << \"Example 2: \";\n    for (const string& str : result) cout << str << \" \";\n    cout << endl;\n\n    // Example 3\n    result = total_match({\"hi\", \"admin\"}, {\"hi\", \"hi\", \"admin\", \"project\"});\n    cout << \"Example 3: \";\n    for (const string& str : result) cout << str << \" \";\n    cout << endl;\n\n    // Example 4\n    result = total_match({\"hi\", \"admin\"}, {\"hI\", \"hi\", \"hi\"});\n    cout << \"Example 4: \";\n    for (const string& str : result) cout << str << \" \";\n    cout << endl;\n\n    // Example 5\n    result = total_match({\"4\"}, {\"1\", \"2\", \"3\", \"4\", \"5\"});\n    cout << \"Example 5: \";\n    for (const string& str : result) cout << str << \" \";\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/75", "generation": "#include <iostream>\nusing namespace std;\n\n// Function to check if a number is prime.\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0)\n            return false;\n    }\n    return true;\n}\n\n// Function to check if a number can be expressed as the product of exactly three prime numbers.\nbool is_multiply_prime(int a) {\n    // Iterate through all possible combinations of primes less than 100\n    for (int i = 2; i < 100 && i * i * i <= a; ++i) {\n        if (!is_prime(i)) continue;\n        \n        for (int j = i; j < 100 && i * j * j <= a; ++j) {\n            if (!is_prime(j)) continue;\n\n            for (int k = j; k < 100; ++k) {\n                if (!is_prime(k)) continue;\n                \n                // Check if the product of these three primes equals 'a'\n                if (i * j * k == a)\n                    return true;\n            }\n        }\n    }\n\n    return false;\n}\n\n"}
{"task_id": "CPP/76", "generation": "#include <cmath> // For log and pow functions\n\nbool is_simple_power(int x, int n) {\n    if (n == 1) return x == 1; // Special case: only 1^k = 1 for any k.\n    \n    double log_result = std::log(x) / std::log(n); // Calculate the logarithm of x with base n\n    \n    // Check if the result is an integer by comparing it to its rounded value\n    return std::abs(log_result - std::round(log_result)) < 1e-9; \n}\n\n"}
{"task_id": "CPP/77", "generation": "#include <cmath> // For std::cbrt and std::round\n\nbool iscube(int a) {\n    double cubeRoot = std::cbrt(a); // Calculate the cube root of 'a'\n    int nearestInt = std::round(cubeRoot); // Round to the nearest integer\n    \n    // Check if the cube of the rounded value equals 'a'\n    return (nearestInt * nearestInt * nearestInt == a);\n}\n\n"}
{"task_id": "CPP/78", "generation": "#include <iostream>\n#include <string>\n#include <set>\n\nusing namespace std;\n\nint hex_key(string num) {\n    // Set of prime hexadecimal digits\n    set<char> primes = {'2', '3', '5', '7', 'B', 'D'};\n    \n    int count = 0;\n    for (char c : num) {\n        if (primes.find(c) != primes.end()) {\n            ++count;\n        }\n    }\n    \n    return count;\n}\n\n"}
{"task_id": "CPP/79", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring decimal_to_binary(int decimal) {\n    // Convert the number to binary using bit manipulation.\n    string binary = \"\";\n    \n    if (decimal == 0) {\n        return \"db0db\"; // Special case for zero\n    }\n    \n    while (decimal > 0) {\n        int remainder = decimal % 2;\n        binary = char('0' + remainder) + binary; // Convert the remainder to a character and prepend it.\n        decimal /= 2;\n    }\n\n    return \"db\" + binary + \"db\"; // Add 'db' at both ends\n}\n\n"}
{"task_id": "CPP/80", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_happy(string s) {\n    // Check if the length of the string is less than 3, return false immediately.\n    if (s.length() < 3) {\n        return false;\n    }\n\n    // Iterate through the string to check every set of three consecutive characters\n    for (int i = 0; i <= s.length() - 3; ++i) {\n        // Check if any two out of three consecutive characters are the same.\n        if (s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]) {\n            return false;\n        }\n    }\n\n    // If all checks pass, the string is happy\n    return true;\n}\n\n"}
{"task_id": "CPP/81", "generation": "#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<string> numerical_letter_grade(vector<float> grades) {\n    vector<string> letter_grades;\n    \n    for (float gpa : grades) {\n        if (gpa == 4.0f)\n            letter_grades.push_back(\"A+\");\n        else if (gpa > 3.7f)\n            letter_grades.push_back(\"A\");\n        else if (gpa > 3.3f)\n            letter_grades.push_back(\"A-\");\n        else if (gpa > 3.0f)\n            letter_grades.push_back(\"B+\");\n        else if (gpa > 2.7f)\n            letter_grades.push_back(\"B\");\n        else if (gpa > 2.3f)\n            letter_grades.push_back(\"B-\");\n        else if (gpa > 2.0f)\n            letter_grades.push_back(\"C+\");\n        else if (gpa > 1.7f)\n            letter_grades.push_back(\"C\");\n        else if (gpa > 1.3f)\n            letter_grades.push_back(\"C-\");\n        else if (gpa > 1.0f)\n            letter_grades.push_back(\"D+\");\n        else if (gpa > 0.7f)\n            letter_grades.push_back(\"D\");\n        else if (gpa > 0.0f)\n            letter_grades.push_back(\"D-\");\n        else\n            letter_grades.push_back(\"E\");\n    }\n    \n    return letter_grades;\n}\n"}
{"task_id": "CPP/82", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\n// Helper function to check if a number is prime.\nbool is_prime(int n) {\n    if (n <= 1) return false; // 0 and 1 are not primes\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\n// Main function to check if the length of a string is prime.\nbool prime_length(string str){\n    int len = str.length();\n    return is_prime(len);\n}\n\n"}
{"task_id": "CPP/83", "generation": "#include <cmath>\n#include <iostream>\nusing namespace std;\n\nlong long starts_one_ends(int n) {\n    if (n == 1)\n        return 1;\n    \n    // Calculate the number of n-digit numbers that start with 1.\n    long long count_starts_with_1 = static_cast<long long>(pow(9, n - 1));\n    \n    // Calculate the number of n-digit numbers that end with 1 but do not start with 1.\n    long long count_ends_with_1_not_starting_with_1 = 8 * static_cast<long long>(pow(9, n - 2));\n\n    return count_starts_with_1 + count_ends_with_1_not_starting_with_1;\n}\n"}
{"task_id": "CPP/84", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\n// Function to calculate the sum of digits of N\nint sumOfDigits(int N) {\n    int sum = 0;\n    while (N > 0) {\n        sum += N % 10; // Add the last digit to sum\n        N /= 10;       // Remove the last digit from N\n    }\n    return sum;\n}\n\n// Function to convert an integer to its binary string representation\nstring intToBinary(int num) {\n    if (num == 0) return \"0\"; // Special case for zero\n\n    string binary = \"\";\n    while (num > 0) {\n        binary = to_string(num % 2) + binary; // Prepend the remainder of division by 2\n        num /= 2;\n    }\n    return binary;\n}\n\nstring solve(int N){\n    int sumDigits = sumOfDigits(N); // Calculate the sum of digits\n    string resultBinary = intToBinary(sumDigits); // Convert the sum to binary string\n    return resultBinary; // Return the binary representation as a string\n}\n\n// Example usage:\n"}
{"task_id": "CPP/85", "generation": "#include <vector>\nusing namespace std;\n\nint add(vector<int> lst) {\n    int sum = 0;\n    \n    // Iterate through the list with an index starting from 1 (the first odd index)\n    for(int i = 1; i < lst.size(); i += 2) { // Increment by 2 to stay at odd indices\n        if(lst[i] % 2 == 0) { // Check if the element is even\n            sum += lst[i]; // Add it to the sum\n        }\n    }\n\n    return sum;\n}\n"}
{"task_id": "CPP/86", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nstring anti_shuffle(string s) {\n    // Temporary variables to hold the current word and its sorted version.\n    string tempWord = \"\";\n    string result = \"\";\n\n    for (char c : s) {\n        if (c == ' ') {  // If we encounter a space, process the collected word\n            sort(tempWord.begin(), tempWord.end());  // Sort characters in ascending order based on ASCII value\n            result += tempWord + \" \";  // Append sorted word and space to the result\n            tempWord = \"\";  // Reset for next word\n        } else {\n            tempWord += c;  // Collect characters of current word\n        }\n    }\n\n    if (!tempWord.empty()) {  // Process any remaining word after last space or at end of string\n        sort(tempWord.begin(), tempWord.end());\n        result += tempWord;\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/87", "generation": "#include <vector>\n#include <algorithm> // for std::sort\n\nusing namespace std;\n\nbool compare(const vector<int>& a, const vector<int>& b) {\n    if (a[0] != b[0]) return a[0] < b[0]; // sort by row in ascending order\n    else return a[1] > b[1];              // then by column in descending order within the same row\n}\n\nvector<vector<int>> get_row(vector<vector<int>> lst, int x) {\n    vector<vector<int>> coordinates;\n    \n    for (int i = 0; i < lst.size(); ++i) { // iterate through each row\n        for (int j = 0; j < lst[i].size(); ++j) { // iterate through each element in the current row\n            if (lst[i][j] == x) {\n                coordinates.push_back({i, j}); // store the coordinate of found integer\n            }\n        }\n    }\n\n    sort(coordinates.begin(), coordinates.end(), compare); // sort according to specified rules\n\n    return coordinates;\n}\n\n// Example usage:\n"}
{"task_id": "CPP/88", "generation": "#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> sort_array(vector<int> array) {\n    // Check if the vector is empty or contains only one element\n    if (array.size() <= 1) return array;\n    \n    // Calculate the sum of the first and last elements\n    int sum = array.front() + array.back();\n    \n    // Create a copy to avoid modifying the original vector\n    vector<int> sortedArray(array);\n    \n    // Sort based on whether the sum is odd or even\n    if (sum % 2 == 0) {\n        sort(sortedArray.begin(), sortedArray.end(), greater<int>());\n    } else {\n        sort(sortedArray.begin(), sortedArray.end());\n    }\n    \n    return sortedArray;\n}\n\n// Example usage:\n"}
{"task_id": "CPP/89", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring encrypt(string s){\n    for (int i = 0; i < s.length(); ++i) {\n        char c = s[i];\n        \n        // Check if the character is a lowercase letter.\n        if ('a' <= c && c <= 'z') {\n            // Shift by 4 positions and wrap around using modulo operation\n            s[i] = ((c - 'a' + 4) % 26) + 'a';\n        }\n        \n        // Check if the character is an uppercase letter.\n        else if ('A' <= c && c <= 'Z') {\n            // Shift by 4 positions and wrap around using modulo operation\n            s[i] = ((c - 'A' + 4) % 26) + 'A';\n        }\n    }\n    \n    return s;\n}\n\n"}
{"task_id": "CPP/90", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint next_smallest(vector<int> lst) {\n    if (lst.size() < 2) { // If the list has less than two elements, return -1.\n        return -1;\n    }\n\n    sort(lst.begin(), lst.end()); // Sort the vector to find the smallest and second smallest elements easily.\n\n    int first = lst[0]; // The smallest element is now at index 0 after sorting.\n    \n    for (int i = 1; i < lst.size(); ++i) {\n        if (lst[i] != first) { // Find the next unique element which will be the second smallest.\n            return lst[i];\n        }\n    }\n\n    // If all elements are the same, there is no second smallest element.\n    return -1;\n}\n\n"}
{"task_id": "CPP/91", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nint is_bored(string S) {\n    int boredom_count = 0;\n    \n    // Use a stringstream to split the string into sentences.\n    stringstream ss(S);\n    string sentence;\n    char delimiters[] = {'.', '?', '!'};\n\n    while (getline(ss, sentence)) {\n        bool found_delimiter = false;\n\n        for(char delimiter : delimiters) {\n            size_t pos = 0;\n            while ((pos = sentence.find(delimiter, pos)) != string::npos) {\n                // Extract the substring up to the current delimiter.\n                string sub_sentence = sentence.substr(0, pos);\n                \n                // Trim leading spaces from the extracted substring.\n                sub_sentence.erase(0, sub_sentence.find_first_not_of(\" \"));\n                \n                if (!sub_sentence.empty() && sub_sentence[0] == 'I' && (sub_sentence.size() > 1 ? isspace(sub_sentence[1]) : true)) {\n                    boredom_count++;\n                }\n                \n                // Move past the delimiter for next iteration.\n                pos += 1;\n            }\n\n            found_delimiter = true;\n        }\n\n        if (!found_delimiter) {\n            sentence.erase(0, sentence.find_first_not_of(\" \"));\n            \n            if (!sentence.empty() && sentence[0] == 'I' && (sentence.size() > 1 ? isspace(sentence[1]) : true)) {\n                boredom_count++;\n            }\n        }\n    }\n\n    return boredom_count;\n}\n\n"}
{"task_id": "CPP/92", "generation": "#include <iostream>\n#include <cmath>\n\nbool any_int(float a, float b, float c) {\n    // Check if all numbers are integers by comparing them with their floor values.\n    bool is_a_integer = (a == std::floor(a));\n    bool is_b_integer = (b == std::floor(b));\n    bool is_c_integer = (c == std::floor(c));\n\n    // If any of the numbers are not integers, return false\n    if (!is_a_integer || !is_b_integer || !is_c_integer) {\n        return false;\n    }\n\n    // Check if one number equals the sum of the other two.\n    if ((a + b == c) || (b + c == a) || (c + a == b)) {\n        return true;\n    } else {\n        return false;\n    }\n}\n\n"}
{"task_id": "CPP/93", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\n// Function to encode a message according to the given rules.\nstring encode(string message) {\n    // Iterate through each character of the string.\n    for (char &c : message) {\n        // Swap case: if lowercase, convert to uppercase and vice versa.\n        if (islower(c)) c = toupper(c);\n        else if (isupper(c)) c = tolower(c);\n\n        // Replace vowels with the letter that appears 2 places ahead in the alphabet.\n        switch (tolower(c)) {\n            case 'a': c = islower(c) ? 'c' : 'C'; break;\n            case 'e': c = islower(c) ? 'g' : 'G'; break;\n            case 'i': c = islower(c) ? 'k' : 'K'; break;\n            case 'o': c = islower(c) ? 'q' : 'Q'; break;\n            case 'u': c = islower(c) ? 'w' : 'W'; break;\n        }\n    }\n\n    return message;\n}\n\n"}
{"task_id": "CPP/94", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to check if a number is prime\nbool isPrime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\n// Function to calculate the sum of digits of a number\nint sumOfDigits(int num) {\n    int sum = 0;\n    while (num > 0) {\n        sum += num % 10;\n        num /= 10;\n    }\n    return sum;\n}\n\n// Main function to find the largest prime and sum its digits\nint skjkasdkd(vector<int> lst){\n    int maxPrime = -1; // Initialize with a non-prime value\n    \n    // Iterate through the list to find the largest prime number\n    for (int num : lst) {\n        if (isPrime(num)) {\n            maxPrime = max(maxPrime, num);\n        }\n    }\n\n    // If no prime was found, return 0 or handle as needed\n    if (maxPrime == -1) return 0;\n\n    // Calculate and return the sum of digits of the largest prime number\n    return sumOfDigits(maxPrime);\n}\n\n// Function to test the solution with given examples\nvoid check() {\n    cout << skjkasdkd({0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3}) << endl; // 10\n    cout << skjkasdkd({1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1}) << endl; // 25\n    cout << skjkasdkd({1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3}) << endl; // 13\n    cout << skjkasdkd({0,724,32,71,99,32,6,0,5,91,83,0,5,6}) << endl; // 11\n    cout << skjkasdkd({0,81,12,3,1,21}) << endl; // 3\n    cout << skjkasdkd({0,8,1,2,1,7}) << endl; // 7\n}\n\n"}
{"task_id": "CPP/95", "generation": "#include <iostream>\n#include <string>\n#include <map>\n#include <cctype>\nusing namespace std;\n\nbool isLowercase(const string& str) {\n    for (char c : str) {\n        if (!islower(c)) return false;\n    }\n    return true;\n}\n\nbool isUppercase(const string& str) {\n    for (char c : str) {\n        if (!isupper(c)) return false;\n    }\n    return true;\n}\n\nbool check_dict_case(map<string, string> dict) {\n    if (dict.empty()) return false;\n\n    bool allLower = true;\n    bool allUpper = true;\n\n    for (const auto& kv : dict) {\n        const string& key = kv.first;\n        if (!isLowercase(key)) allLower = false;\n        if (!isUppercase(key)) allUpper = false;\n    }\n\n    return allLower || allUpper;\n}\n\n"}
{"task_id": "CPP/96", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// Helper function to check if a number is prime\nbool is_prime(int num) {\n    if (num <= 1) return false; // 0 and 1 are not primes\n    for (int i = 2; i * i <= num; ++i) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\nvector<int> count_up_to(int n){\n    vector<int> primes;\n    \n    // Iterate through all numbers from 2 up to but not including n\n    for (int i = 2; i < n; ++i) {\n        if (is_prime(i)) {\n            primes.push_back(i);\n        }\n    }\n\n    return primes;\n}\n\n// Function to test the implementation with given examples\nvoid check() {\n    vector<int> result;\n\n    result = count_up_to(5); // Expected: {2, 3}\n    for(int num : result) cout << num << \" \";\n    cout << endl;\n\n    result = count_up_to(11); // Expected: {2, 3, 5, 7}\n    for(int num : result) cout << num << \" \";\n    cout << endl;\n\n    result = count_up_to(0); // Expected: {}\n    if(result.empty()) cout << \"{}\" << endl;\n    \n    result = count_up_to(20); // Expected: {2, 3, 5, 7, 11, 13, 17, 19}\n    for(int num : result) cout << num << \" \";\n    cout << endl;\n\n    result = count_up_to(1); // Expected: {}\n    if(result.empty()) cout << \"{}\" << endl;\n    \n    result = count_up_to(18); // Expected: {2, 3, 5, 7, 11, 13, 17}\n    for(int num : result) cout << num << \" \";\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/97", "generation": "#include<stdio.h>\n\nint multiply(int a, int b) {\n    // Extracting the unit digits\n    int unitDigitA = abs(a) % 10;\n    int unitDigitB = abs(b) % 10;\n\n    // Calculating and returning the product of the unit digits\n    return unitDigitA * unitDigitB;\n}\n\n"}
{"task_id": "CPP/98", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint count_upper(string s) {\n    int count = 0;\n    \n    // Iterate through the string with even indices only.\n    for (size_t i = 0; i < s.length(); i += 2) { // Start from index 0 and increment by 2\n        char c = s[i];\n        \n        // Check if it's an uppercase vowel\n        if (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n            count++;\n        }\n    }\n\n    return count;\n}\n\n"}
{"task_id": "CPP/99", "generation": "#include <iostream>\n#include <cmath>\n#include <string>\n\nusing namespace std;\n\nint closest_integer(string value) {\n    // Convert string to double for precision handling\n    double num = stod(value);\n    \n    // Check if the number is positive or negative\n    bool isPositive = num > 0;\n    \n    // Calculate the floor and ceil values of the number\n    int floorValue = static_cast<int>(floor(num));\n    int ceilValue = static_cast<int>(ceil(num));\n    \n    // Determine which integer to round towards based on the distance from the decimal part\n    double fractionalPart = num - floorValue;\n    \n    if (fractionalPart == 0.5) {\n        // If equidistant, round away from zero\n        return isPositive ? ceilValue : floorValue;\n    } else {\n        // Otherwise, use standard rounding rules\n        return static_cast<int>(round(num));\n    }\n}\n\n// Function to test the closest_integer function with given examples\nvoid check() {\n    cout << \"Testing '10': Expected 10, Got: \" << closest_integer(\"10\") << endl;\n    cout << \"Testing '15.3': Expected 15, Got: \" << closest_integer(\"15.3\") << endl;\n    cout << \"Testing '14.5': Expected 15, Got: \" << closest_integer(\"14.5\") << endl;\n    cout << \"Testing '-14.5': Expected -15, Got: \" << closest_integer(\"-14.5\") << endl;\n}\n\n"}
{"task_id": "CPP/100", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> make_a_pile(int n) {\n    vector<int> pile;\n    \n    // Start with the first level having 'n' stones.\n    int current_stones = n;\n    \n    for (int i = 0; i < n; ++i) {\n        pile.push_back(current_stones);\n        \n        // Determine the next number of stones based on whether current is odd or even\n        if (current_stones % 2 == 0) { // If current_stones is even, add 2 to get the next even number.\n            current_stones += 2;\n        } else { // If current_stones is odd, add 2 to get the next odd number.\n            current_stones += 2;\n        }\n    }\n\n    return pile;\n}\n\n// Example usage\n"}
{"task_id": "CPP/101", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> words_string(string s) {\n    vector<string> result;\n    string word = \"\";\n    \n    for (char c : s) {\n        if (c == ' ' || c == ',') {  // Check if the character is a space or comma\n            if (!word.empty()) {      // If there's a word, add it to the result vector\n                result.push_back(word);\n                word = \"\";            // Reset the word for the next iteration\n            }\n        } else {\n            word += c;  // Append the current character to the word\n        }\n    }\n\n    if (!word.empty()) {  // Add any remaining word after the loop ends\n        result.push_back(word);\n    }\n\n    return result;\n}\n\n// Function to test the implementation with example inputs\nvoid check() {\n    vector<string> res1 = words_string(\"Hi, my name is John\");\n    for (string s : res1) cout << s << \" \";\n    cout << endl;\n\n    vector<string> res2 = words_string(\"One, two, three, four, five, six\");\n    for (string s : res2) cout << s << \" \";\n}\n\n"}
{"task_id": "CPP/102", "generation": "#include<iostream>\nusing namespace std;\n\nint choose_num(int x, int y) {\n    // Check if the range is valid.\n    if (y < x)\n        return -1;\n    \n    // If 'y' itself is even and within the range, return it.\n    if (y % 2 == 0 && y >= x)\n        return y;\n\n    // Otherwise, check for the next lower number that could be even.\n    int candidate = y - 1;\n    while(candidate >= x) {\n        if (candidate % 2 == 0)\n            return candidate;\n        --candidate; // Move to the next lower number\n    }\n\n    // If no even number is found in the range, return -1.\n    return -1;\n}\n\n"}
{"task_id": "CPP/103", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\n// Function to convert an integer to a binary string\nstring int_to_binary(int num) {\n    if (num == 0) return \"0\";\n    string binary = \"\";\n    while (num > 0) {\n        binary = (num % 2 == 0 ? \"0\" : \"1\") + binary;\n        num /= 2;\n    }\n    return binary;\n}\n\nstring rounded_avg(int n, int m) {\n    if (n > m) return \"-1\";\n    \n    // Calculate the sum of integers from n to m\n    long long sum = ((long long)m * (m + 1) - (n * (n - 1))) / 2;\n    int count = m - n + 1; // Number of terms\n    \n    // Compute average and round down\n    int avg = sum / count;\n    \n    // Convert to binary string\n    return int_to_binary(avg);\n}\n\n"}
{"task_id": "CPP/104", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to check if a number contains only odd digits.\nbool hasOnlyOddDigits(int num) {\n    while (num > 0) {\n        int digit = num % 10;\n        if (digit % 2 == 0) return false; // If any digit is even, return false\n        num /= 10;\n    }\n    return true;\n}\n\nvector<int> unique_digits(vector<int> x) {\n    vector<int> result;\n\n    // Filter numbers that have only odd digits.\n    for (int num : x) {\n        if (hasOnlyOddDigits(num)) {\n            result.push_back(num);\n        }\n    }\n\n    // Sort the filtered numbers in increasing order\n    sort(result.begin(), result.end());\n\n    return result;\n}\n\n// Function to test the solution with given examples\nvoid check() {\n    vector<int> test1 = {15, 33, 1422, 1};\n    vector<int> expected1 = {1, 15, 33};\n    assert(unique_digits(test1) == expected1);\n\n    vector<int> test2 = {152, 323, 1422, 10};\n    vector<int> expected2 = {};\n    assert(unique_digits(test2) == expected2);\n    \n    cout << \"All tests passed successfully.\" << endl;\n}\n\n"}
{"task_id": "CPP/105", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\n\nusing namespace std;\n\nvector<string> by_length(vector<int> arr) {\n    // Map to store the digit-to-name mapping.\n    map<int, string> numberNames = {\n        {1, \"One\"}, {2, \"Two\"}, {3, \"Three\"},\n        {4, \"Four\"}, {5, \"Five\"}, {6, \"Six\"},\n        {7, \"Seven\"}, {8, \"Eight\"}, {9, \"Nine\"}\n    };\n\n    // Filter out numbers not between 1 and 9.\n    vector<int> filteredArr;\n    for (int num : arr) {\n        if (num >= 1 && num <= 9) {\n            filteredArr.push_back(num);\n        }\n    }\n\n    // Sort the filtered array.\n    sort(filteredArr.begin(), filteredArr.end());\n\n    // Reverse the sorted array.\n    reverse(filteredArr.begin(), filteredArr.end());\n\n    // Replace each digit with its corresponding name.\n    vector<string> result;\n    for (int num : filteredArr) {\n        result.push_back(numberNames[num]);\n    }\n\n    return result;\n}\n\n// Function to test the solution\nvoid check() {\n    vector<int> arr1 = {2, 1, 1, 4, 5, 8, 2, 3};\n    vector<string> expected1 = {\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"};\n    assert(by_length(arr1) == expected1);\n\n    vector<int> arr2 = {};\n    vector<string> expected2 = {};\n    assert(by_length(arr2) == expected2);\n\n    vector<int> arr3 = {1, -1, 55};\n    vector<string> expected3 = {\"One\"};\n    assert(by_length(arr3) == expected3);\n\n    cout << \"All tests passed successfully.\" << endl;\n}\n\n"}
{"task_id": "CPP/106", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// Function to calculate factorial\nint factorial(int num) {\n    int result = 1;\n    for (int i = 2; i <= num; ++i) {\n        result *= i;\n    }\n    return result;\n}\n\n// Function to calculate the sum of numbers from 1 to num\nint sumToN(int num) {\n    return (num * (num + 1)) / 2;\n}\n\nvector<int> f(int n) {\n    vector<int> result(n);\n    \n    for (int i = 0; i < n; ++i) {\n        if ((i + 1) % 2 == 0) { // Check if the index+1 is even\n            result[i] = factorial(i + 1); // Calculate factorial\n        } else {\n            result[i] = sumToN(i + 1); // Calculate sum from 1 to i+1\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/107", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\n// Function to check if a number is a palindrome\nbool isPalindrome(int num) {\n    string str = to_string(num);\n    int len = str.length();\n    for (int i = 0; i < len / 2; ++i) {\n        if (str[i] != str[len - i - 1]) return false;\n    }\n    return true;\n}\n\nvector<int> even_odd_palindrome(int n){\n    vector<int> result(2, 0); // Initialize a vector with two elements set to zero\n    for (int i = 1; i <= n; ++i) {\n        if (isPalindrome(i)) { // Check if the number is a palindrome\n            if (i % 2 == 0) {\n                result[0]++; // Increment even count\n            } else {\n                result[1]++; // Increment odd count\n            }\n        }\n    }\n    return result;\n}\n\n"}
{"task_id": "CPP/108", "generation": "#include <vector>\n#include <cmath>\n#include <algorithm>\n\nint sum_of_digits(int num) {\n    int sum = 0;\n    bool is_negative = num < 0;\n    while (num != 0) {\n        int digit = num % 10;\n        sum += digit;\n        num /= 10;\n    }\n    if (is_negative && sum != 0) {\n        sum -= 2 * (sum % 10); // Adjust the first digit to be negative\n    }\n    return sum;\n}\n\nint count_nums(std::vector<int> n) {\n    int count = 0;\n    for (int num : n) {\n        if (sum_of_digits(num) > 0) {\n            count++;\n        }\n    }\n    return count;\n}\n"}
{"task_id": "CPP/109", "generation": "#include <vector>\nusing namespace std;\n\nbool move_one_ball(vector<int> arr) {\n    if (arr.empty()) return true;\n    \n    int n = arr.size();\n    int disorder_count = 0;\n    \n    // Check for disorder points\n    for (int i = 1; i < n; ++i) {\n        if (arr[i] < arr[i - 1]) {\n            disorder_count++;\n        }\n    }\n\n    // Special case: check the wrap-around condition between last and first element\n    if (disorder_count == 0 || (disorder_count == 1 && arr[n-1] <= arr[0])) {\n        return true;\n    } else {\n        return false;\n    }\n}\n"}
{"task_id": "CPP/110", "generation": "#include <vector>\n#include <string>\nusing namespace std;\n\nstring exchange(vector<int> lst1, vector<int> lst2) {\n    // Count odd numbers in lst1 and even numbers in lst2.\n    int oddCountInLst1 = 0;\n    for (int num : lst1) {\n        if (num % 2 != 0) {\n            ++oddCountInLst1;\n        }\n    }\n\n    int evenCountInLst2 = 0;\n    for (int num : lst2) {\n        if (num % 2 == 0) {\n            ++evenCountInLst2;\n        }\n    }\n\n    // If there are enough even numbers in lst2 to replace all odd numbers in lst1, return \"YES\".\n    if (oddCountInLst1 <= evenCountInLst2) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n"}
{"task_id": "CPP/111", "generation": "#include <iostream>\n#include <string>\n#include <map>\n#include <sstream> // For std::istringstream\n\nusing namespace std;\n\nmap<char, int> histogram(string test) {\n    map<char, int> charCount;\n    map<char, int> result;\n    \n    if (test.empty()) return result; // Return empty map for empty input\n    \n    istringstream iss(test);\n    string word;\n    \n    // Count occurrences of each character\n    while (iss >> word && !word.empty()) {\n        ++charCount[word[0]];\n    }\n    \n    int maxCount = 0;\n    \n    // Find the maximum count\n    for (const auto& pair : charCount) {\n        if (pair.second > maxCount) {\n            maxCount = pair.second;\n        }\n    }\n    \n    // Collect characters with the maximum count into result map\n    for (const auto& pair : charCount) {\n        if (pair.second == maxCount) {\n            result.insert(pair);\n        }\n    }\n    \n    return result;\n}\n\n// Function to print the map for testing purposes\nvoid printMap(const map<char, int>& m) {\n    for (const auto& pair : m) {\n        cout << \"{\" << pair.first << \", \" << pair.second << \"} \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/112", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nbool is_palindrome(const string& str) {\n    int len = str.length();\n    for (int i = 0; i < len / 2; ++i) {\n        if (str[i] != str[len - i - 1]) return false;\n    }\n    return true;\n}\n\nvector<string> reverse_delete(string s, string c) {\n    string result_string;\n\n    // Remove characters from s that are present in c\n    for (char ch : s) {\n        if (c.find(ch) == string::npos) {\n            result_string += ch;\n        }\n    }\n\n    // Check if the resulting string is a palindrome\n    bool is_palindrome_result = is_palindrome(result_string);\n\n    vector<string> res{result_string, is_palindrome_result ? \"True\" : \"False\"};\n    \n    return res;\n}\n"}
{"task_id": "CPP/113", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nstd::vector<std::string> odd_count(std::vector<std::string> lst) {\n    std::vector<std::string> result;\n    \n    for (const auto& s : lst) {\n        int count_odd = 0;\n        \n        // Count the number of odd digits in the string\n        for (char c : s) {\n            if ((c - '0') % 2 != 0) { \n                ++count_odd; \n            }\n        }\n\n        // Construct the output string with replacements\n        std::string output_str = \"the number of odd elements \";\n        output_str += std::to_string(count_odd);\n        output_str += \"n the str\";\n        output_str += std::to_string(count_odd);\n        output_str += \"ng \";\n        output_str += std::to_string(count_odd);\n        output_str += \" of the \";\n        output_str += std::to_string(count_odd);\n        output_str += \"nput.\";\n        \n        result.push_back(output_str);\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/114", "generation": "#include <iostream>\n#include <vector>\n#include <climits> // For INT_MAX\n\nusing namespace std;\n\nlong long minSubArraySum(vector<long long> nums) {\n    if (nums.empty()) return 0; // Handle empty vector case\n    \n    long long currentSum = 0;\n    long long minSum = LLONG_MAX; // Initialize to the largest possible value\n    \n    for (auto num : nums) {\n        currentSum += num;\n        \n        // Update minSum if currentSum is smaller\n        if (currentSum < minSum)\n            minSum = currentSum;\n            \n        // Reset currentSum to 0 if it becomes non-negative\n        if (currentSum >= 0)\n            currentSum = 0;\n    }\n    \n    return minSum;\n}\n\n"}
{"task_id": "CPP/115", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint max_fill(vector<vector<int>> grid, int capacity) {\n    int total_drops = 0;\n    \n    // Iterate over each well (row)\n    for (auto& row : grid) {\n        int water_units = 0;\n        \n        // Count the number of units of water in this well\n        for (int unit : row) {\n            if (unit == 1) {\n                ++water_units;\n            }\n        }\n        \n        // Calculate how many times we need to lower the bucket for this well\n        int drops_for_well = (water_units + capacity - 1) / capacity; // Equivalent to ceil(water_units / capacity)\n        \n        total_drops += drops_for_well;\n    }\n    \n    return total_drops;\n}\n\n"}
{"task_id": "CPP/116", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to count the number of 1s in binary representation of a number.\nint countOnes(int n) {\n    int ones = 0;\n    while (n != 0) {\n        if (n % 2 == 1)\n            ++ones;\n        n /= 2;\n    }\n    return ones;\n}\n\n// Comparator function for sorting based on the number of ones and then by value.\nbool compare(int a, int b) {\n    int countA = countOnes(abs(a));\n    int countB = countOnes(abs(b));\n\n    if (countA == countB)\n        return a < b; // If same number of 1s, sort by decimal value\n    else\n        return countA < countB; // Otherwise, sort by the number of 1s\n}\n\nvector<int> sort_array(vector<int> arr) {\n    sort(arr.begin(), arr.end(), compare);\n    return arr;\n}\n\n"}
{"task_id": "CPP/117", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Helper function to count consonants in a word\nint count_consonants(const string& word) {\n    int count = 0;\n    for (char ch : word) {\n        // Convert character to lowercase and check if it's a consonant\n        char lower_ch = tolower(ch);\n        if ((lower_ch >= 'a' && lower_ch <= 'z') && !(lower_ch == 'a' || lower_ch == 'e' || lower_ch == 'i' || lower_ch == 'o' || lower_ch == 'u')) {\n            count++;\n        }\n    }\n    return count;\n}\n\nvector<string> select_words(string s, int n) {\n    vector<string> result;\n    string word = \"\";\n    \n    // Split the string into words and check consonant count\n    for (char ch : s) {\n        if (ch == ' ') {\n            if (!word.empty()) {\n                if (count_consonants(word) == n) {\n                    result.push_back(word);\n                }\n                word = \"\";  // Reset word after processing it\n            }\n        } else {\n            word += ch;\n        }\n    }\n\n    // Check the last word in case there's no trailing space\n    if (!word.empty()) {\n        if (count_consonants(word) == n) {\n            result.push_back(word);\n        }\n    }\n\n    return result;\n}\n\n// Function to test the implementation with given examples\nvoid check() {\n    vector<string> res;\n\n    res = select_words(\"Mary had a little lamb\", 4);\n    for (const auto& word : res) cout << word << \" \";\n    cout << endl; // Expected: {\"little\"}\n\n    res = select_words(\"Mary had a little lamb\", 3);\n    for (const auto& word : res) cout << word << \" \";\n    cout << endl; // Expected: {\"Mary\", \"lamb\"}\n\n    res = select_words(\"simple white space\", 2);\n    for (const auto& word : res) cout << word << \" \";\n    cout << endl; // Expected: {}\n\n    res = select_words(\"Hello world\", 4);\n    for (const auto& word : res) cout << word << \" \";\n    cout << endl; // Expected: {\"world\"}\n\n    res = select_words(\"Uncle sam\", 3);\n    for (const auto& word : res) cout << word << \" \";\n    cout << endl; // Expected: {\"Uncle\"}\n}\n\n"}
{"task_id": "CPP/118", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_vowel(char c) {\n    string vowels = \"aeiouAEIOU\";\n    return vowels.find(c) != string::npos;\n}\n\nstring get_closest_vowel(string word){\n    int len = word.length();\n    \n    // Iterate from the end of the string to the beginning\n    for (int i = len - 2; i > 0; --i) {\n        // Check if current character is a vowel and surrounded by consonants\n        if (is_vowel(word[i]) && !is_vowel(word[i-1]) && !is_vowel(word[i+1])) {\n            return string(1, word[i]);\n        }\n    }\n    \n    // Return empty string if no such vowel found\n    return \"\";\n}\n\n"}
{"task_id": "CPP/119", "generation": "#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nbool is_balanced(const string& s) {\n    int balance = 0;\n    for (char c : s) {\n        if (c == '(') {\n            ++balance;\n        } else {\n            --balance;\n            if (balance < 0) {\n                return false; // More closing than opening parentheses\n            }\n        }\n    }\n    return balance == 0; // Balanced if no open parentheses left\n}\n\nstring match_parens(vector<string> lst) {\n    string first_concat = lst[0] + lst[1];\n    string second_concat = lst[1] + lst[0];\n\n    if (is_balanced(first_concat) || is_balanced(second_concat)) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\n"}
{"task_id": "CPP/120", "generation": "#include <vector>\n#include <algorithm> // for std::sort\n\nusing namespace std;\n\nvector<int> maximum(vector<int> arr, int k) {\n    // Step 1: Sort the array in ascending order.\n    sort(arr.begin(), arr.end());\n    \n    // Step 2: Extract the last k elements from the sorted vector.\n    vector<int> result;\n    for (int i = arr.size() - k; i < arr.size(); ++i) {\n        result.push_back(arr[i]);\n    }\n    \n    return result;\n}\n\n// Example usage:\n/*\nvector<int> example1 = {-3, -4, 5};\nvector<int> output1 = maximum(example1, 3); // Output: {-4, -3, 5}\n\nvector<int> example2 = {4, -4, 4};\nvector<int> output2 = maximum(example2, 2); // Output: {4, 4}\n\nvector<int> example3 = {-3, 2, 1, 2, -1, -2, 1};\nvector<int> output3 = maximum(example3, 1); // Output: {2}\n*/\n"}
{"task_id": "CPP/121", "generation": "#include <vector>\nusing namespace std;\n\nint solution(vector<int> lst) {\n    int sum = 0;\n    \n    // Iterate through the vector with a step of 2 to check even positions (0-indexed)\n    for(int i = 0; i < lst.size(); i += 2) {\n        if(lst[i] % 2 != 0) { // Check if the element is odd\n            sum += lst[i];\n        }\n    }\n    \n    return sum;\n}\n"}
{"task_id": "CPP/122", "generation": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint add_elements(vector<int> arr, int k) {\n    int sum = 0;\n    for (int i = 0; i < k; ++i) {\n        if (arr[i] >= -99 && arr[i] <= 99) {\n            sum += arr[i];\n        }\n    }\n    return sum;\n}\n"}
{"task_id": "CPP/123", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // For std::sort\n\nusing namespace std;\n\nvector<int> get_odd_collatz(int n) {\n    vector<int> oddNumbers;\n    \n    while (n != 1) {\n        if (n % 2 == 1) { // Check if the number is odd\n            oddNumbers.push_back(n);\n        }\n        if (n % 2 == 0) { // If even, divide by 2\n            n /= 2;\n        } else { // If odd, apply the Collatz formula\n            n = 3 * n + 1;\n        }\n    }\n    \n    // Add the last number in the sequence which is always 1 and is odd.\n    oddNumbers.push_back(1);\n    \n    // Sort the vector of odd numbers before returning it.\n    sort(oddNumbers.begin(), oddNumbers.end());\n    \n    return oddNumbers;\n}\n\n// Function to test the get_odd_collatz function\nvoid check() {\n    vector<int> result = get_odd_collatz(5);\n    for (int num : result) {\n        cout << num << \" \";\n    }\n    // Expected output: 1 5\n    cout << endl;\n    \n    result = get_odd_collatz(7); \n    for (int num : result) {\n        cout << num << \" \";\n    }\n    // Expected output: 1 7 11 22\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/124", "generation": "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nbool valid_date(const string& date) {\n    // Check if the date string is empty or not in mm-dd-yyyy format.\n    if (date.length() != 10 || date[2] != '-' || date[5] != '-') return false;\n    \n    vector<int> days_in_month = {31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\n    \n    // Extract month, day and year from the date string.\n    int month = stoi(date.substr(0, 2));\n    int day = stoi(date.substr(3, 2));\n    int year = stoi(date.substr(6, 4));\n\n    // Validate month\n    if (month < 1 || month > 12) return false;\n\n    // Validate day based on the month and leap year for February.\n    if (day < 1 || day > days_in_month[month - 1]) return false;\n    \n    // Special case for February in a non-leap year\n    if (month == 2 && day == 29) {\n        bool is_leap_year = ((year % 4 == 0 && year % 100 != 0) || (year % 400 == 0));\n        if (!is_leap_year) return false;\n    }\n\n    // If all checks pass, the date is valid.\n    return true;\n}\n\n"}
{"task_id": "CPP/125", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n\nusing namespace std;\n\nvector<string> split_words(const string& txt) {\n    vector<string> result;\n    \n    // Check for whitespace and split accordingly\n    if (txt.find(' ') != string::npos) {\n        stringstream ss(txt);\n        string word;\n        while (getline(ss, word, ' ')) {\n            result.push_back(word);\n        }\n    } \n    // Check for commas and split accordingly\n    else if (txt.find(',') != string::npos) {\n        stringstream ss(txt);\n        string word;\n        while (getline(ss, word, ',')) {\n            result.push_back(word);\n        }\n    } \n    // Count the number of lower-case letters with even order in the alphabet\n    else {\n        int count = 0;\n        for (char c : txt) {\n            if (islower(c) && ((c - 'a') % 2 == 0)) {\n                ++count;\n            }\n        }\n        result.push_back(to_string(count));\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/126", "generation": "#include <vector>\n#include <algorithm>\n\nbool is_sorted(std::vector<int> lst) {\n    // Check if the list is empty or has only one element, which is always sorted.\n    if (lst.size() <= 1) return true;\n\n    int count = 1; // To keep track of how many times a number appears consecutively.\n\n    for (size_t i = 1; i < lst.size(); ++i) {\n        // If the current element is less than the previous one, it's not sorted.\n        if (lst[i] < lst[i - 1]) return false;\n\n        // Check how many times a number appears consecutively.\n        if (lst[i] == lst[i - 1]) {\n            count++;\n            // If any number appears more than twice, return false.\n            if (count > 2) return false;\n        } else {\n            count = 1; // Reset the counter for different numbers.\n        }\n    }\n\n    return true;\n}\n"}
{"task_id": "CPP/127", "generation": "#include <vector>\n#include <string>\n#include <cmath>\nusing namespace std;\n\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\nstring intersection(vector<int> interval1, vector<int> interval2) {\n    int start_max = max(interval1[0], interval2[0]);\n    int end_min = min(interval1[1], interval2[1]);\n\n    if (start_max > end_min) {\n        // No intersection\n        return \"NO\";\n    }\n\n    int length_of_intersection = end_min - start_max + 1;\n\n    if (is_prime(length_of_intersection)) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n"}
{"task_id": "CPP/128", "generation": "#include <vector>\n#include <cmath> // For std::abs\n\nint prod_signs(std::vector<int> arr) {\n    if (arr.empty()) return -32768; // Return special value for empty vector\n    \n    int signProduct = 1;\n    int magnitudeSum = 0;\n\n    for (auto num : arr) {\n        magnitudeSum += std::abs(num); // Sum of magnitudes\n        if (num == 0) { \n            signProduct = 0; // If any number is zero, the product of signs will be zero.\n            break;\n        } else if (num < 0) {\n            signProduct *= -1; // Multiply by -1 for negative numbers\n        }\n    }\n\n    return magnitudeSum * signProduct;\n}\n\n// Example usage:\n"}
{"task_id": "CPP/129", "generation": "#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// Define dfs outside of minPath but within the same scope.\nvector<int> dfs(const vector<vector<int>>& grid, int n, int x, int y, vector<int>& path, int k) {\n    if (path.size() == k)\n        return path;\n    \n    vector<int> best_path;\n    \n    for (auto [dx, dy] : vector<pair<int,int>>{{-1, 0}, {1, 0}, {0, -1}, {0, 1}}) {\n        int nx = x + dx, ny = y + dy;\n        if (nx >= 0 && nx < n && ny >= 0 && ny < n) {\n            path.push_back(grid[nx][ny]);\n            vector<int> new_path = dfs(grid, n, nx, ny, path, k);\n            if (new_path.size() == k && (best_path.empty() || new_path < best_path))\n                best_path = new_path;\n            path.pop_back();\n        }\n    }\n    \n    return best_path;\n}\n\nvector<int> minPath(const vector<vector<int>>& grid, int k) {\n    int n = grid.size();\n    vector<int> min_path;\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            vector<int> current_path{grid[i][j]};\n            auto path = dfs(grid, n, i, j, current_path, k);\n            if (!min_path.empty() && !path.empty() && path < min_path)\n                min_path = path;\n            else if (min_path.empty())\n                min_path = path;\n        }\n    }\n\n    return min_path;\n}\n"}
{"task_id": "CPP/130", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> tri(int n) {\n    if (n == 0)\n        return {1};\n    \n    vector<int> tribonacci(n + 1, 1);\n    tribonacci[1] = 3;\n    \n    for (int i = 2; i <= n; ++i) {\n        if (i % 2 == 0) {\n            tribonacci[i] = 1 + i / 2;\n        } else {\n            // Handle the case where we need to calculate tri(n+1) which is out of bounds.\n            if (i + 1 <= n)\n                tribonacci[i] = tribonacci[i - 1] + tribonacci[i - 2] + tribonacci[i + 1];\n            else\n                tribonacci[i] = tribonacci[i - 1] + tribonacci[i - 2] + (1 + (i + 1) / 2);\n        }\n    }\n    \n    return tribonacci;\n}\n"}
{"task_id": "CPP/131", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint digits(int n) {\n    string numStr = to_string(n); // Convert integer to string for easy digit access\n    int product = 1; // Initialize product with 1\n    \n    bool hasOddDigit = false;\n    \n    for (char c : numStr) { // Iterate through each character in the string\n        int digit = c - '0'; // Convert char to int\n        \n        if (digit % 2 != 0) { // Check if the digit is odd\n            product *= digit; // Multiply it into the product\n            hasOddDigit = true;\n        }\n    }\n    \n    return hasOddDigit ? product : 0; // Return product or 0 based on whether there was an odd digit\n}\n\n"}
{"task_id": "CPP/132", "generation": "#include <string>\nusing namespace std;\n\nbool is_nested(string str) {\n    int max_depth = 0;\n    int current_depth = 0;\n\n    for (char& ch : str) {\n        if (ch == '[') {\n            current_depth += 1;\n            max_depth = max(max_depth, current_depth);\n        } else if (ch == ']') {\n            current_depth -= 1;\n        }\n        if (current_depth < 0) {\n            return false;\n        }\n    }\n\n    // If the string is balanced and has a depth greater than 1 at some point, it means there's nesting.\n    return max_depth > 1 && current_depth == 0;\n}\n"}
{"task_id": "CPP/133", "generation": "#include <iostream>\n#include <vector>\n#include <cmath> // for ceil and pow functions\n\nusing namespace std;\n\nint sum_squares(vector<float> lst){\n    int sum = 0;\n    for (float num : lst) {\n        float ceilingValue = ceil(num); // Round up to the nearest integer\n        sum += pow(ceilingValue, 2); // Square it and add to sum\n    }\n    return sum;\n}\n\n"}
{"task_id": "CPP/134", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool check_if_last_char_is_a_letter(string txt) {\n    // Check if string is empty or ends with a space.\n    if (txt.empty() || txt.back() == ' ') return false;\n    \n    // Get the last character of the string.\n    char lastChar = txt.back();\n    \n    // Check if it's an alphabetical character and not part of a word.\n    bool isAlphabetical = isalpha(lastChar);\n    bool isNotPartOfWord = (txt.size() == 1 || txt[txt.size()-2] == ' ');\n    \n    return isAlphabetical && isNotPartOfWord;\n}\n\n"}
{"task_id": "CPP/135", "generation": "#include <vector>\nusing namespace std;\n\nint can_arrange(vector<int> arr) {\n    for (size_t i = 1; i < arr.size(); ++i) {\n        if (arr[i] < arr[i - 1]) {\n            return static_cast<int>(i);\n        }\n    }\n    return -1;\n}\n"}
{"task_id": "CPP/136", "generation": "#include <vector>\n#include <algorithm> // For std::min and std::max\n\nusing namespace std;\n\nvector<int> largest_smallest_integers(vector<int> lst){\n    int largestNegative = 0;\n    int smallestPositive = 0;\n    \n    bool foundNegative = false;\n    bool foundPositive = false;\n    \n    for(int num : lst) {\n        if(num < 0) {\n            // Update the largest negative number\n            if(!foundNegative || num > largestNegative) {\n                largestNegative = num;\n                foundNegative = true;\n            }\n        } else if (num > 0) {\n            // Update the smallest positive number\n            if(!foundPositive || num < smallestPositive) {\n                smallestPositive = num;\n                foundPositive = true;\n            }\n        }\n    }\n\n    return {largestNegative, smallestPositive};\n}\n\n// Example usage:\n"}
{"task_id": "CPP/137", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <variant>\n\nusing namespace std;\n\nboost::any compare_one(boost::any a, boost::any b) {\n    // Helper function to convert string with comma or dot as decimal separator to float\n    auto toFloat = [](const string& str) -> float {\n        string temp = str;\n        replace(temp.begin(), temp.end(), ',', '.');\n        return stof(temp);\n    };\n\n    // Extract values from variant and handle different types\n    if (a.type() == typeid(int)) {\n        int a_val = boost::any_cast<int>(a);\n        if (b.type() == typeid(int)) {\n            int b_val = boost::any_cast<int>(b);\n            return a_val > b_val ? a : (b_val > a_val ? b : \"None\");\n        } else if (b.type() == typeid(float)) {\n            float b_val = boost::any_cast<float>(b);\n            return a_val > b_val ? a : (b_val > a_val ? b : \"None\");\n        } else if (b.type() == typeid(string)) {\n            string b_str = boost::any_cast<string>(b);\n            float b_val = toFloat(b_str);\n            return a_val > b_val ? a : (b_val > a_val ? b_str : \"None\");\n        }\n    } else if (a.type() == typeid(float)) {\n        float a_val = boost::any_cast<float>(a);\n        if (b.type() == typeid(int)) {\n            int b_val = boost::any_cast<int>(b);\n            return a_val > b_val ? a : (b_val > a_val ? b : \"None\");\n        } else if (b.type() == typeid(float)) {\n            float b_val = boost::any_cast<float>(b);\n            return a_val > b_val ? a : (b_val > a_val ? b : \"None\");\n        } else if (b.type() == typeid(string)) {\n            string b_str = boost::any_cast<string>(b);\n            float b_val = toFloat(b_str);\n            return a_val > b_val ? a : (b_val > a_val ? b_str : \"None\");\n        }\n    } else if (a.type() == typeid(string)) {\n        string a_str = boost::any_cast<string>(a);\n        float a_val = toFloat(a_str);\n        if (b.type() == typeid(int)) {\n            int b_val = boost::any_cast<int>(b);\n            return a_val > b_val ? a_str : (b_val > a_val ? b : \"None\");\n        } else if (b.type() == typeid(float)) {\n            float b_val = boost::any_cast<float>(b);\n            return a_val > b_val ? a_str : (b_val > a_val ? b : \"None\");\n        } else if (b.type() == typeid(string)) {\n            string b_str = boost::any_cast<string>(b);\n            float b_val = toFloat(b_str);\n            return a_val > b_val ? a_str : (b_val > a_val ? b_str : \"None\");\n        }\n    }\n\n    // If types are not handled, return \"None\"\n    return \"None\";\n}\n\n"}
{"task_id": "CPP/138", "generation": "#include <iostream>\nusing namespace std;\n\nbool is_equal_to_sum_even(int n) {\n    // Check if n is at least 8 and an even number.\n    return (n >= 8 && n % 2 == 0);\n}\n\n"}
{"task_id": "CPP/139", "generation": "#include <iostream>\nusing namespace std;\n\n// Function to calculate factorial of a given number\nlong long factorial(int num) {\n    if (num == 0 || num == 1)\n        return 1;\n    else\n        return num * factorial(num - 1);\n}\n\n// Function to calculate the Brazilian factorial as defined\nlong long special_factorial(int n){\n    long long result = 1;\n    for(int i = 1; i <= n; ++i) {\n        result *= factorial(i);\n    }\n    return result;\n}\n\n"}
{"task_id": "CPP/140", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring fix_spaces(string text) {\n    string result;\n    int spaceCount = 0; // Counter for consecutive spaces\n\n    for (char c : text) {\n        if (c == ' ') {\n            ++spaceCount;\n        } else {\n            if (spaceCount > 2) {\n                result += '-';\n            } else {\n                while (spaceCount > 0) {\n                    result += '_';\n                    --spaceCount;\n                }\n            }\n            spaceCount = 0; // Reset the counter\n            result += c;\n        }\n    }\n\n    // Handle trailing spaces if any\n    if (spaceCount > 2) {\n        result += '-';\n    } else {\n        while (spaceCount > 0) {\n            result += '_';\n            --spaceCount;\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/141", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring file_name_check(string file_name) {\n    // Check for exactly one dot in the name.\n    size_t dotPos = file_name.find('.');\n    if (dotPos == string::npos || file_name.find('.', dotPos + 1) != string::npos)\n        return \"No\";\n\n    // Split the filename into two parts: before and after the dot\n    string prefix = file_name.substr(0, dotPos);\n    string suffix = file_name.substr(dotPos + 1);\n\n    // Check if there are more than three digits in the prefix.\n    int digitCount = 0;\n    for (char c : prefix) {\n        if (isdigit(c)) digitCount++;\n        if (digitCount > 3) return \"No\";\n    }\n\n    // Validate that the prefix starts with a letter and is not empty\n    if (prefix.empty() || !isalpha(prefix[0])) \n        return \"No\";\n\n    // Check valid extensions.\n    string validExtensions[] = {\"txt\", \"exe\", \"dll\"};\n    bool isValidExtension = false;\n    for (string ext : validExtensions) {\n        if (ext == suffix) {\n            isValidExtension = true;\n            break;\n        }\n    }\n\n    if (!isValidExtension)\n        return \"No\";\n\n    // If all checks pass, the filename is valid.\n    return \"Yes\";\n}\n\n"}
{"task_id": "CPP/142", "generation": "#include <vector>\nusing namespace std;\n\nint sum_squares(vector<int> lst) {\n    int sum = 0;\n    \n    for (size_t i = 0; i < lst.size(); ++i) {\n        if (i % 3 == 0) { // If index is a multiple of 3\n            sum += lst[i] * lst[i]; // Square the element and add to sum\n        } else if (i % 4 == 0 && i % 3 != 0) { // If index is a multiple of 4 but not 3\n            sum += lst[i] * lst[i] * lst[i]; // Cube the element and add to sum\n        } else {\n            sum += lst[i]; // Add the element as it is if no condition matches\n        }\n    }\n\n    return sum;\n}\n\n// Example usage:\n"}
{"task_id": "CPP/143", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\n// Helper function to check if a number is prime\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    for (int i = 2; i * i <= num; ++i) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\n// Main function to filter words based on prime length\nstring words_in_sentence(string sentence) {\n    stringstream ss(sentence);\n    string word, result;\n    \n    while (ss >> word) { // Extract each word from the sentence\n        if (is_prime(word.length())) {\n            if (!result.empty()) result += \" \"; // Add space before appending new word\n            result += word; // Append prime length words to result\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/144", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool simplify(string x, string n) {\n    // Parsing fractions\n    size_t slashPos;\n    \n    int numX = stoi(x.substr(0, (slashPos = x.find('/'))));\n    int denX = stoi(x.substr(slashPos + 1));\n\n    int numN = stoi(n.substr(0, (slashPos = n.find('/'))));\n    int denN = stoi(n.substr(slashPos + 1));\n\n    // Multiplying the fractions\n    int numeratorResult = numX * numN;\n    int denominatorResult = denX * denN;\n\n    // Simplifying to check if it's a whole number\n    return (numeratorResult % denominatorResult == 0);\n}\n\n"}
{"task_id": "CPP/145", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nint sum_of_digits(int n) {\n    int sum = 0;\n    bool is_negative = n < 0;\n    while (n != 0) {\n        sum += n % 10;\n        n /= 10;\n    }\n    return is_negative ? -sum : sum;\n}\n\nvector<int> order_by_points(vector<int> nums) {\n    // Pair each number with its index and sum of digits\n    std::vector<std::pair<std::pair<int, int>, int>> indexed_nums;\n    \n    for (size_t i = 0; i < nums.size(); ++i) {\n        indexed_nums.push_back({{sum_of_digits(nums[i]), static_cast<int>(i)}, nums[i]});\n    }\n    \n    // Sort based on the sum of digits, then by original index if sums are equal\n    std::sort(indexed_nums.begin(), indexed_nums.end());\n    \n    // Extract and return only the numbers from the sorted list\n    vector<int> result;\n    for (const auto& item : indexed_nums) {\n        result.push_back(item.second);\n    }\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/146", "generation": "#include <vector>\n#include <string>\nusing namespace std;\n\nbool isFirstAndLastDigitOdd(int num) {\n    // Convert to string to easily access first and last digit\n    string strNum = to_string(abs(num));  // Use abs to handle negative numbers\n    char firstDigit = strNum[0];\n    char lastDigit = strNum[strNum.length() - 1];\n\n    // Check if both digits are odd\n    return (firstDigit == '1' || firstDigit == '3' || firstDigit == '5' || \n            firstDigit == '7' || firstDigit == '9') &&\n           (lastDigit == '1' || lastDigit == '3' || lastDigit == '5' ||\n            lastDigit == '7' || lastDigit == '9');\n}\n\nint specialFilter(vector<int> nums) {\n    int count = 0;\n    for(int num : nums) {\n        if(num > 10 && isFirstAndLastDigitOdd(num)) {\n            ++count;\n        }\n    }\n    return count;\n}\n"}
{"task_id": "CPP/147", "generation": "#include<iostream>\n#include<vector>\n\nusing namespace std;\n\nint get_max_triples(int n) {\n    vector<int> a(n);\n    \n    // Fill the array with values according to the given formula.\n    for (int i = 0; i < n; ++i) {\n        a[i] = (i + 1) * (i + 1) - (i + 1) + 1;\n    }\n    \n    int count = 0;\n\n    // Iterate through all possible triples and check the condition.\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            for (int k = j + 1; k < n; ++k) {\n                if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                    count++;\n                }\n            }\n        }\n    }\n\n    return count;\n}\n\n// Function to test the solution with given data points.\nvoid check_solution() {\n    cout << \"For n = 5, Expected: 1, Got: \" << get_max_triples(5) << endl;\n    // You can add more tests here as needed\n}\n\n"}
{"task_id": "CPP/148", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to find planets between two given planets.\nvector<string> bf(string planet1, string planet2) {\n    // Mapping of each planet name to its position relative to the Sun.\n    vector<pair<string, int>> solarSystem = {\n        {\"Mercury\", 1}, {\"Venus\", 2}, {\"Earth\", 3},\n        {\"Mars\", 4}, {\"Jupiter\", 5}, {\"Saturn\", 6},\n        {\"Uranus\", 7}, {\"Neptune\", 8}\n    };\n\n    // Find the positions of planet1 and planet2.\n    int pos1 = -1, pos2 = -1;\n    for (const auto& planet : solarSystem) {\n        if (planet.first == planet1)\n            pos1 = planet.second;\n        else if (planet.first == planet2)\n            pos2 = planet.second;\n\n        // If both positions are found, break the loop.\n        if (pos1 != -1 && pos2 != -1)\n            break;\n    }\n\n    // Check if either of the planets was not found.\n    if (pos1 == -1 || pos2 == -1) {\n        return {};  // Return an empty vector if any planet is invalid.\n    }\n\n    // Ensure pos1 < pos2 for simplicity in the loop below.\n    if (pos1 > pos2)\n        swap(pos1, pos2);\n\n    // Collect all planets between pos1 and pos2.\n    vector<string> result;\n    for (const auto& planet : solarSystem) {\n        int position = planet.second;\n        if (position > pos1 && position < pos2) {\n            result.push_back(planet.first);\n        }\n    }\n\n    return result;\n}\n\n// Function to test the bf function with examples.\nvoid check() {\n    vector<string> res;\n\n    // Example 1\n    res = bf(\"Jupiter\", \"Neptune\");\n    for (const auto& planet : res)\n        cout << planet << \" \";\n    cout << endl;  // Expected: Saturn Uranus\n\n    // Example 2\n    res = bf(\"Earth\", \"Mercury\");\n    for (const auto& planet : res)\n        cout << planet << \" \";\n    cout << endl;  // Expected: Venus\n\n    // Example 3\n    res = bf(\"Mercury\", \"Uranus\");\n    for (const auto& planet : res)\n        cout << planet << \" \";\n    cout << endl;  // Expected: Venus Earth Mars Jupiter Saturn\n}\n\n"}
{"task_id": "CPP/149", "generation": "#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nvector<string> vector_sort(vector<string> lst) {\n    // Filter out strings with odd lengths\n    vector<string> filtered_lst;\n    for (const auto& s : lst) {\n        if (s.length() % 2 == 0) {\n            filtered_lst.push_back(s);\n        }\n    }\n\n    // Sort by length, and then alphabetically if the lengths are equal\n    sort(filtered_lst.begin(), filtered_lst.end(),\n         [](const string &a, const string &b) {\n             return a.size() != b.size() ? a.size() < b.size() : a < b;\n         });\n\n    return filtered_lst;\n}\n"}
{"task_id": "CPP/150", "generation": "#include <cmath> // for sqrt function\nusing namespace std;\n\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    for (int i = 2; i <= sqrt(num); ++i) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\nint x_or_y(int n, int x, int y) {\n    return is_prime(n) ? x : y;\n}\n"}
{"task_id": "CPP/151", "generation": "#include <vector>\n#include <cmath> // For std::pow\n\nusing namespace std;\n\nlong long double_the_difference(vector<float> lst) {\n    long long sum = 0;\n    \n    for (float num : lst) {\n        if (num > 0 && floor(num) == num && static_cast<int>(num) % 2 != 0) { // Check if positive, integer and odd\n            int n = static_cast<int>(num);\n            sum += pow(n, 2); // Square the number and add to sum\n        }\n    }\n\n    return sum;\n}\n\n// Test cases\n"}
{"task_id": "CPP/152", "generation": "#include <iostream>\n#include <cmath>\n#include <vector>\nusing namespace std;\n\nvector<int> compare(vector<int> game, vector<int> guess) {\n    vector<int> result;\n    for (size_t i = 0; i < game.size(); ++i) {\n        int diff = abs(game[i] - guess[i]);\n        result.push_back(diff);\n    }\n    return result;\n}\n"}
{"task_id": "CPP/153", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to calculate the strength of an extension.\nint CalculateStrength(const string& extension) {\n    int uppercase = 0;\n    int lowercase = 0;\n    \n    for (char c : extension) {\n        if (isupper(c)) uppercase++;\n        else if (islower(c)) lowercase++;\n    }\n    \n    return uppercase - lowercase;\n}\n\nstring Strongest_Extension(string class_name, vector<string> extensions) {\n    string strongest_extension = \"\";\n    int max_strength = INT_MIN; // Initialize with the smallest possible integer.\n    \n    for (const auto& extension : extensions) {\n        int strength = CalculateStrength(extension);\n        \n        if (strength > max_strength || (strength == max_strength && strongest_extension.empty())) {\n            max_strength = strength;\n            strongest_extension = extension;\n        }\n    }\n    \n    return class_name + \".\" + strongest_extension;\n}\n\n"}
{"task_id": "CPP/154", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool cycpattern_check(string a, string b) {\n    if (b.length() > a.length()) return false;\n    \n    // Concatenate string 'a' with itself to handle rotations\n    string a_doubled = a + a;\n    \n    for (size_t i = 0; i < b.length(); ++i) {\n        // Generate the rotated version of b\n        string rotated_b = b.substr(i) + b.substr(0, i);\n        \n        // Check if this rotation is a substring in 'a_doubled'\n        if (a_doubled.find(rotated_b) != string::npos) return true;\n    }\n    \n    return false;\n}\n\n"}
{"task_id": "CPP/155", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<int> even_odd_count(int num){\n    // Convert number to its absolute value to handle negative numbers\n    int absNum = abs(num);\n    \n    // Convert integer to string for easy digit extraction\n    string strNum = to_string(absNum);\n\n    // Initialize counters for even and odd digits\n    int evenCount = 0;\n    int oddCount = 0;\n\n    // Iterate through each character in the string\n    for (char c : strNum) {\n        // Convert char to integer digit\n        int digit = c - '0';\n        \n        // Check if the digit is even or odd and increment respective counter\n        if (digit % 2 == 0) {\n            evenCount++;\n        } else {\n            oddCount++;\n        }\n    }\n\n    // Return a vector containing counts of even and odd digits respectively\n    return {evenCount, oddCount};\n}\n\n// Function to test the solution with given examples\nvoid check() {\n    vector<int> result = even_odd_count(-12);\n    cout << \"even_odd_count(-12) -> {\" << result[0] << \", \" << result[1] << \"}\\n\";\n    \n    result = even_odd_count(123);\n    cout << \"even_odd_count(123) -> {\" << result[0] << \", \" << result[1] << \"}\\n\";\n}\n\n"}
{"task_id": "CPP/156", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring int_to_mini_roman(int number) {\n    // Define the values and corresponding symbols\n    vector<int> values = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    vector<string> symbols = {\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n\n    string roman = \"\";\n    \n    // Iterate over the values and construct the Roman numeral\n    for (int i = 0; number > 0; ++i) {\n        while (number >= values[i]) {\n            roman += symbols[i];\n            number -= values[i];\n        }\n    }\n\n    return roman;\n}\n\n// Example usage:\n"}
{"task_id": "CPP/157", "generation": "#include <iostream>\n#include <cmath>\n\nbool right_angle_triangle(float a, float b, float c){\n    // First, sort the sides so that c is the longest side (hypotenuse)\n    if(a > c) std::swap(a, c);\n    if(b > c) std::swap(b, c);\n\n    // Check the Pythagorean theorem\n    return fabs(a*a + b*b - c*c) < 1e-6; // Using a small threshold to account for floating point precision issues.\n}\n\n"}
{"task_id": "CPP/158", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <set>\nusing namespace std;\n\nstring find_max(vector<string> words) {\n    string result;\n    int max_unique = 0; // To keep track of maximum unique characters\n\n    for (const auto& word : words) {\n        set<char> unique_chars(word.begin(), word.end()); // Use a set to get unique characters\n        int count_unique = unique_chars.size();\n\n        if (count_unique > max_unique || \n            (count_unique == max_unique && word < result)) { // Check lexicographical order as well\n            max_unique = count_unique;\n            result = word;\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/159", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> eat(int number, int need, int remaining) {\n    // Calculate the total number of carrots eaten after trying to eat 'need' more.\n    int totalEaten = number + min(need, remaining);\n    \n    // Calculate how many carrots are left after eating as much as possible.\n    int carrotsLeft = max(0, remaining - need);\n\n    return {totalEaten, carrotsLeft};\n}\n"}
{"task_id": "CPP/160", "generation": "#include <vector>\n#include <string>\n#include <cmath>\nusing namespace std;\n\nint evaluateExpression(const string& expression) {\n    // Use a simple parser for basic operations. For more complex expressions,\n    // consider using a library or implementing a proper parsing algorithm.\n    int result = 0;\n    char operation = '+';\n    size_t pos = 0;\n    while (pos < expression.size()) {\n        size_t nextPos = expression.find_first_of(\"+-*/^\", pos);\n        string token = expression.substr(pos, nextPos - pos);\n\n        if (!token.empty()) {\n            int value = stoi(token);\n            switch(operation) {\n                case '+': result += value; break;\n                case '-': result -= value; break;\n                case '*': result *= value; break;\n                case '/': result /= value; break;\n                case '^': result = pow(result, value); break;\n            }\n        }\n\n        if (nextPos != string::npos) {\n            operation = expression[nextPos];\n            pos = nextPos + 1;\n        } else {\n            break;\n        }\n    }\n    return result;\n}\n\nint do_algebra(vector<string> operators, vector<int> operands) {\n    string expression = to_string(operands[0]);\n    \n    for (size_t i = 0; i < operators.size(); ++i) {\n        const auto& op = operators[i];\n        int operand = operands[i + 1];\n\n        if (op == \"+\") {\n            expression += \" + \" + to_string(operand);\n        } else if (op == \"-\") {\n            expression += \" - \" + to_string(operand);\n        } else if (op == \"*\") {\n            expression += \" * \" + to_string(operand);\n        } else if (op == \"//\") {\n            // C++ uses / for floor division\n            expression += \" / \" + to_string(operand);\n        } else if (op == \"**\") {\n            expression += \" ^ \" + to_string(operand);  // Using '^' as a placeholder for exponentiation\n        }\n    }\n\n    return evaluateExpression(expression);\n}\n"}
{"task_id": "CPP/161", "generation": "#include <iostream>\n#include <string>\n#include <cctype> // For std::isalpha and std::islower\n\nusing namespace std;\n\nstring solve(string s) {\n    bool hasLetters = false;\n    \n    // Check if the string contains any letters.\n    for (char c : s) {\n        if (std::isalpha(c)) {\n            hasLetters = true;\n            break;\n        }\n    }\n\n    // If no letters are present, reverse the entire string.\n    if (!hasLetters) {\n        std::reverse(s.begin(), s.end());\n        return s;\n    }\n\n    // Otherwise, change the case of each letter and keep other characters as they are.\n    for (char &c : s) {\n        if (std::isalpha(c)) {\n            c = std::islower(c) ? toupper(c) : tolower(c);\n        }\n    }\n\n    return s;\n}\n\n"}
{"task_id": "CPP/162", "generation": "#include <iostream>\n#include <string>\n#include <openssl/md5.h>\n\nusing namespace std;\n\nstring string_to_md5(string text) {\n    if (text.empty()) return \"None\"; // Return \"None\" for empty strings\n\n    unsigned char digest[MD5_DIGEST_LENGTH];\n    MD5((unsigned char*)text.c_str(), text.length(), (unsigned char*)&digest);    \n\n    char mdString[33];\n    for(int i = 0; i < 16; ++i)\n        sprintf(&mdString[i*2], \"%02x\", (unsigned int)digest[i]);\n\n    return string(mdString);\n}\n\n"}
{"task_id": "CPP/163", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // For std::min and std::max\n\nusing namespace std;\n\nvector<int> generate_integers(int a, int b) {\n    vector<int> evenDigits = {2, 4, 6, 8}; // All possible even digits less than 10\n    vector<int> result;\n    \n    // Ensure a is the smaller number and b is the larger one\n    int start = min(a, b);\n    int end = max(a, b);\n\n    for (int digit : evenDigits) {\n        if (digit >= start && digit <= end) {\n            result.push_back(digit);\n        }\n    }\n\n    return result;\n}\n\n// Function to print vector elements\nvoid printVector(const vector<int>& vec) {\n    cout << \"{\";\n    for(size_t i = 0; i < vec.size(); ++i) {\n        if (i != 0) cout << \", \";\n        cout << vec[i];\n    }\n    cout << \"}\" << endl;\n}\n\n"}
