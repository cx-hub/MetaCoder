{"task_id": "CPP/41", "generation": "#include<stdio.h>\nusing namespace std;\n\nint car_race_collision(int n) {\n    // Since all cars move at the same speed and continue their trajectory after collision,\n    // each left-to-right car will collide with exactly one right-to-left car.\n    return n;\n}\n", "py_code": "def car_race_collision(n):\n    # Since all cars move at the same speed and continue their trajectory after collision,\n    # each left-to-right car will collide with exactly one right-to-left car.\n    return n\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `car_race_collision` takes an integer `n`, which represents the number of cars driving in each direction (left-to-right and right-to-left). The problem states that all cars move at the same speed and continue their trajectory after a collision. Given these conditions, every car moving left-to-right will inevitably collide with exactly one car moving right-to-left. Therefore, the total number of collisions is equal to `n`, as each car in one direction collides with one car from the opposite direction. The function simply returns this value `n` as the result.```"}
{"task_id": "CPP/116", "generation": "#include <stdio.h>\n#include <math.h>\n#include <vector>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n\nint count_ones(int n) {\n    int count = 0;\n    while (n != 0) {\n        count += abs(n & 1);\n        n >>= 1;\n    }\n    return count;\n}\n\nbool custom_compare(int a, int b) {\n    int ones_a = count_ones(a);\n    int ones_b = count_ones(b);\n\n    if (ones_a == ones_b)\n        return a < b;\n\n    return ones_a < ones_b;\n}\n\nvector<int> sort_array(vector<int> arr){\n    sort(arr.begin(), arr.end(), custom_compare);\n    return arr;\n}\n", "py_code": "from typing import List\n\ndef count_ones(n: int) -> int:\n    return bin(abs(n)).count('1')\n\ndef sort_array(arr: List[int]) -> List[int]:\n    return sorted(arr, key=lambda x: (count_ones(x), x))\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python code defines a function `sort_array` that takes a list of integers and returns them sorted based on two criteria: first by the number of ones in their binary representation (using the helper function `count_ones`) and then by their decimal value if they have the same number of ones. The `count_ones` function converts each integer to its absolute value's binary form, counts the number of '1's, and returns that count. The main function uses Python's built-in `sorted()` function with a custom key that sorts based on the tuple `(number_of_ones, decimal_value)`. This ensures that elements are primarily sorted by their binary ones count and secondarily by their value if they have an equal number of ones.```\n\n"}
{"task_id": "CPP/61", "generation": "#include <string>\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    int balance = 0;\n    for (char& c : brackets) {\n        if (c == '(') {\n            ++balance;\n        } else if (c == ')') {\n            --balance;\n        }\n        if (balance < 0) {\n            return false; // More closing brackets than opening ones\n        }\n    }\n    return balance == 0; // All brackets are correctly matched\n}\n", "py_code": "def correct_bracketing(brackets: str) -> bool:\n    balance = 0\n    for char in brackets:\n        if char == '(':\n            balance += 1\n        elif char == ')':\n            balance -= 1\n        if balance < 0:\n            return False\n    return balance == 0\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `correct_bracketing` checks whether a string of parentheses is correctly bracketed. It iterates through each character in the input string and maintains a balance counter to track the number of open parentheses that have not yet been closed.\n\n- If an opening parenthesis '(' is encountered, the balance counter is incremented.\n- If a closing parenthesis ')' is encountered, the balance counter is decremented.\n- At any point during iteration, if the balance counter becomes negative, it means there are more closing parentheses than opening ones before them, which indicates incorrect bracketing. In such cases, the function immediately returns `False`.\n- After iterating through all characters in the string, if the balance counter equals zero, it implies that every opening parenthesis has a corresponding closing parenthesis and the function returns `True`. Otherwise, it returns `False`.\n\nThis approach ensures that the parentheses are correctly nested without any unmatched or improperly ordered brackets.\n\n"}
{"task_id": "CPP/25", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nvector<int> factorize(int n) {\n    vector<int> factors;\n    for (int i = 2; i * i <= n; ++i) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n    if (n > 1) {\n        factors.push_back(n);\n    }\n    return factors;\n}\n", "py_code": "def factorize(n):\n    i = 2\n    factors = []\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            factors.append(i)\n    if n > 1:\n        factors.append(n)\n    return factors\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `factorize` takes an integer `n` and returns a list of its prime factors in ascending order. The algorithm works as follows:\n1. Initialize a variable `i` to 2, which is the smallest prime number.\n2. Use a while loop that continues until `i * i > n`. This ensures that we only check up to the square root of `n`, which is sufficient for finding all factors.\n3. Inside the loop, if `n % i != 0` (meaning `i` is not a factor), increment `i`.\n4. If `i` is a factor (`n % i == 0`), divide `n` by `i` and append `i` to the list of factors.\n5. After exiting the loop, if `n > 1`, it means that there's still a prime factor greater than the square root of the original number (which is `n` itself at this point). Append `n` to the list of factors.\n\nThe function returns the list of prime factors in ascending order as required by the problem statement. \n\n"}
{"task_id": "CPP/137", "generation": "#include <iostream>\n#include <string>\n#include <boost/any.hpp>\n#include <sstream>\n\nusing namespace std;\n\nboost::any compare_one(boost::any a, boost::any b) {\n    float a_val = 0.0;\n    float b_val = 0.0;\n\n    // Convert input to floats if they are strings\n    if (a.type() == typeid(string)) {\n        string str_a = boost::any_cast<string>(a);\n        replace(str_a.begin(), str_a.end(), ',', '.');\n        stringstream ss_a(str_a);\n        ss_a >> a_val;\n    } else {\n        a_val = boost::any_cast<float>(a);\n    }\n\n    if (b.type() == typeid(string)) {\n        string str_b = boost::any_cast<string>(b);\n        replace(str_b.begin(), str_b.end(), ',', '.');\n        stringstream ss_b(str_b);\n        ss_b >> b_val;\n    } else {\n        b_val = boost::any_cast<float>(b);\n    }\n\n    // Compare the values\n    if (a_val > b_val) {\n        return a;\n    } else if (b_val > a_val) {\n        return b;\n    } else {\n        return string(\"None\");\n    }\n}\n", "py_code": "def compare_one(a, b):\n    # Convert strings with ',' to '.' for uniformity and then convert to float if needed\n    a_val = float(a.replace(',', '.')) if isinstance(a, str) else a\n    b_val = float(b.replace(',', '.')) if isinstance(b, str) else b\n\n    # Compare the values\n    if a_val > b_val:\n        return a\n    elif b_val > a_val:\n        return b\n    else:\n        return \"None\"\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `compare_one` takes two arguments `a` and `b`, which can be integers, floats, or strings representing real numbers. The goal is to return the larger of the two values in their original type (integer, float, or string). If both values are equal, it returns \"None\".\n\n1. **Conversion Handling**: \n   - First, the function checks if `a` and `b` are strings. If they are, it replaces any commas with dots to ensure uniformity for floating point representation.\n   - Then, it converts these strings into floats so that numerical comparison can be performed.\n\n2. **Comparison**:\n   - The values of `a_val` and `b_val` (which may have been converted from their original types) are compared numerically.\n   \n3. **Return the Larger Value in Original Type**:\n   - If `a_val` is greater than `b_val`, it returns `a` in its original type.\n   - If `b_val` is greater, it returns `b` in its original type.\n   - If both values are equal, it returns \"None\".\n\nThis approach ensures that the function can handle different types and formats of input while returning the result in a consistent manner.\n\n"}
{"task_id": "CPP/102", "generation": "#include <stdio.h>\nusing namespace std;\n\nint choose_num(int x, int y) {\n    if (x > y) {\n        return -1;\n    }\n    // Start from y and go down until we find an even number or reach below x\n    for (int num = y; num >= x; --num) {\n        if (num % 2 == 0) {\n            return num;\n        }\n    }\n    return -1;\n}\n", "py_code": "def choose_num(x, y):\n    if x > y:\n        return -1\n    # Start from y and go down until we find an even number or reach below x\n    for num in range(y, x-1, -1):\n        if num % 2 == 0:\n            return num\n    return -1\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `choose_num` takes two positive integers `x` and `y`, and returns the largest even integer within the range `[x, y]`. If there is no such number in the given range or if `x > y`, it returns `-1`.\n\nHere's a step-by-step breakdown of how the code works:\n1. The function first checks if `x` is greater than `y`. If so, it immediately returns `-1` because an invalid range has been provided.\n2. It then iterates from `y` down to `x`, checking each number in this range.\n3. For each number, the code checks whether it's even by using the modulus operator (`num % 2 == 0`). If a number is found that satisfies this condition, it returns that number as the largest even integer within the given range.\n4. If no even numbers are found during the iteration (i.e., all numbers in the range are odd), the function will return `-1`.\n\nThis approach ensures that we find the largest possible even number in the specified range or determine if such a number does not exist.\n\n"}
{"task_id": "CPP/10", "generation": "#include <string>\nusing namespace std;\n\nbool is_palindrome(string str) {\n    string reversed_str = str;\n    reverse(reversed_str.begin(), reversed_str.end());\n    return str == reversed_str;\n}\n\nstring make_palindrome(string str) {\n    if (str.length() == 0) {\n        return \"\";\n    }\n\n    for (size_t i = 0; i < str.length(); ++i) {\n        string suffix = str.substr(i);\n        if (is_palindrome(suffix)) {\n            string prefix_to_reverse = str.substr(0, i);\n            reverse(prefix_to_reverse.begin(), prefix_to_reverse.end());\n            return str + prefix_to_reverse;\n        }\n    }\n\n    // This case should not happen as the whole string itself would be a palindrome when i=0\n    string reversed_str = str;\n    reverse(reversed_str.begin(), reversed_str.end());\n    return str + reversed_str;\n}\n", "py_code": "def is_palindrome(s):\n    return s == s[::-1]\n\ndef make_palindrome(str):\n    if len(str) == 0:\n        return \"\"\n    \n    for i in range(len(str)):\n        suffix = str[i:]\n        if is_palindrome(suffix):\n            prefix_to_reverse = str[:i]\n            return str + prefix_to_reverse[::-1]\n    return str + str[::-1]  # This case should not happen as the whole string itself would be a palindrome when i=0\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python solution consists of two functions: `is_palindrome` and `make_palindrome`.\n\n1. **Function `is_palindrome(s)`**: This function checks if a given string `s` is a palindrome by comparing it to its reverse (`s[::-1]`). If they are equal, the function returns `True`; otherwise, it returns `False`.\n\n2. **Function `make_palindrome(str)`**:\n    - The function first checks if the input string `str` has zero length and immediately returns an empty string in that case.\n    - It then iterates over each index `i` of the string to find the longest suffix (substring from index `i` to the end) that is a palindrome using the `is_palindrome` function. \n    - Once it finds such a palindromic suffix, it identifies the prefix before this suffix (`str[:i]`) and appends its reverse to the original string.\n    - The result is the shortest palindrome starting with the supplied string.\n\nThe algorithm ensures that the returned string is indeed a palindrome by appending the necessary characters from the reversed non-palindromic part of the input string. If no palindromic suffix is found, it appends the entire reverse of the original string to itself, which should not happen as the whole string would be considered a palindrome when `i=0`.\n\n"}
{"task_id": "CPP/76", "generation": "#include <stdio.h>\n#include <math.h>\nusing namespace std;\n\nbool is_simple_power(int x, int n) {\n    if (n == 1) {\n        return x == 1;\n    }\n    long power = 1; // Use long to avoid overflow issues during multiplication.\n    while (power < x) {\n        power *= n;\n    }\n    return power == x;\n}\n", "py_code": "def is_simple_power(x, n):\n    if n == 1:\n        return x == 1\n    power = 1\n    while power < x:\n        power *= n\n    return power == x\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `is_simple_power(x, n)` checks whether a number `x` is a simple power of another number `n`. The logic follows these steps:\n1. If `n` equals 1, then it returns `True` only if `x` also equals 1 (since the only power of 1 that equals itself is \\(1^0 = 1\\)).\n2. It initializes a variable `power` to 1.\n3. The function enters a loop where it multiplies `power` by `n` until `power` becomes greater than or equal to `x`.\n4. After exiting the loop, it checks if `power` is exactly equal to `x`. If so, it returns `True`, indicating that `x` is indeed a simple power of `n`; otherwise, it returns `False`.\n\nThis approach ensures that we only consider integer powers and avoids floating-point inaccuracies by using an iterative multiplication process.\n\n"}
{"task_id": "CPP/94", "generation": "#include <vector>\n#include <string>\nusing namespace std;\n\nbool is_prime(int n) {\n    if (n <= 1)\n        return false;\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0)\n            return false;\n    }\n    return true;\n}\n\nint sum_of_digits(int n) {\n    int sum = 0;\n    while (n > 0) {\n        sum += n % 10;\n        n /= 10;\n    }\n    return sum;\n}\n\nint skjkasdkd(vector<int> lst) {\n    int max_prime = -1;\n    for (auto num : lst) {\n        if (is_prime(num)) {\n            max_prime = std::max(max_prime, num);\n        }\n    }\n\n    if (max_prime == -1)\n        return 0;\n\n    return sum_of_digits(max_prime);\n}\n", "py_code": "from typing import List\n\ndef is_prime(n: int) -> bool:\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef sum_of_digits(n: int) -> int:\n    return sum(int(digit) for digit in str(n))\n\ndef skjkasdkd(lst: List[int]) -> int:\n    max_prime = -1\n    for num in lst:\n        if is_prime(num):\n            max_prime = max(max_prime, num)\n    \n    if max_prime == -1:\n        return 0\n    \n    return sum_of_digits(max_prime)\n```\n", "py_summary": "### Analysis of Python Code:\n\nThe provided Python function `skjkasdkd` is designed to find the largest prime number in a given list of integers and then calculate the sum of its digits.\n\n1. **Helper Function: `is_prime(n)`**:\n    - This helper function checks if a given integer `n` is a prime number.\n    - It returns `False` for numbers less than or equal to 1, as they are not considered prime.\n    - For other integers, it iterates from 2 up to the square root of `n`. If any divisor is found, it returns `False`; otherwise, it returns `True`.\n\n2. **Helper Function: `sum_of_digits(n)`**:\n    - This helper function calculates and returns the sum of digits of a given integer `n`.\n    - It converts the number to a string, iterates over each character (digit), converts it back to an integer, and sums these integers.\n\n3. **Main Function: `skjkasdkd(lst)`**:\n    - This function takes a list of integers (`lst`) as input.\n    - It initializes `max_prime` to `-1`, which will store the largest prime number found in the list.\n    - The function iterates over each element in the list. If an element is identified as a prime number using the `is_prime()` helper function, it updates `max_prime` if this prime number is larger than the current value of `max_prime`.\n    - After identifying the largest prime number (or determining that no primes are present), the function calculates and returns the sum of its digits using the `sum_of_digits()` helper function.\n    - If no prime numbers are found in the list, it returns 0.\n\n### Next Step:\nNow we will generate an equivalent C++ solution based on this logic."}
{"task_id": "CPP/32", "generation": "#include <iostream>\n#include <vector>\n#include <cmath>\n\ndouble poly(const std::vector<double>& xs, double x) {\n    /*\n    Evaluates polynomial with coefficients xs at point x.\n    Returns xs[0] + xs[1] * x + xs[2] * x^2 + .... + xs[n] * x^n\n    */\n    double sum = 0;\n    for (size_t i = 0; i < xs.size(); ++i) {\n        sum += xs[i] * std::pow(x, i);\n    }\n    return sum;\n}\n\ndouble find_zero(const std::vector<double>& xs) {\n    /*\n    xs are coefficients of a polynomial. find_zero finds x such that poly(x) = 0.\n    find_zero returns only one zero point, even if there are many.\n    Moreover, find_zero only takes list xs having even number of coefficients and largest non-zero coefficient as it guarantees a solution.\n\n    >>> round(find_zero({1, 2}), 2); // f(x) = 1 + 2x\n    -0.5 \n    >>> round(find_zero({-6, 11, -6, 1}), 2); // (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n    1.0\n    */\n\n    double a = -100; // Initial lower bound for the root search\n    double b = 100;  // Initial upper bound for the root search\n\n    if (poly(xs, a) * poly(xs, b) > 0) {\n        std::cerr << \"The initial bounds do not bracket a root.\" << std::endl;\n        return NAN;\n    }\n\n    while ((b - a) / 2.0 > 1e-6) { // Tolerance for the root\n        double c = (a + b) / 2.0;   // Midpoint\n\n        if (poly(xs, c) == 0 || std::abs(b - a) < 1e-6) {\n            return c;\n        } else if (poly(xs, a) * poly(xs, c) < 0) {\n            b = c;\n        } else {\n            a = c;\n        }\n    }\n\n    return (a + b) / 2.0; // Return the midpoint as the approximate root\n}\n\n", "py_code": "from typing import List\nimport numpy as np\n\ndef poly(xs: List[float], x: float) -> float:\n    return sum(coef * (x ** i) for i, coef in enumerate(xs))\n\ndef find_zero(xs: List[float]) -> float:\n    # Use NumPy's roots function to find the roots of the polynomial\n    roots = np.roots(xs[::-1])\n    # Filter out complex roots and take the real part of any remaining complex numbers\n    real_roots = [root.real for root in roots if np.isreal(root)]\n    return min(real_roots, key=lambda r: abs(poly(xs, r)))\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python solution consists of two functions:\n1. `poly(xs: List[float], x: float) -> float`: This function evaluates a polynomial with coefficients given in the list `xs` at point `x`. It calculates the sum of each coefficient multiplied by `x` raised to its corresponding power.\n\n2. `find_zero(xs: List[float]) -> float`: This function aims to find one zero (root) of the polynomial defined by the coefficients in `xs`. The approach taken is to use NumPy's `roots` function, which computes all roots of a polynomial with given coefficients. Since the problem guarantees that there will be at least one real root due to the constraints on the list `xs`, we filter out any complex roots and return the real root that minimizes the absolute value of the polynomial evaluated at that point.\n\nThe NumPy library is used here for its efficient handling of numerical operations, particularly in finding polynomial roots. The function `find_zero` ensures that only one zero (root) is returned by selecting the closest to zero among all real roots found using the `roots` method.\n\n"}
{"task_id": "CPP/33", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> sort_third(vector<int> l) {\n    vector<int> divisible_by_three;\n    \n    // Extract elements at indices divisible by 3 (1-indexed)\n    for(size_t i = 2; i < l.size(); i += 3) {\n        divisible_by_three.push_back(l[i]);\n    }\n    \n    // Sort these extracted elements\n    sort(divisible_by_three.begin(), divisible_by_three.end());\n    \n    // Replace the original elements with the sorted ones\n    size_t j = 0;\n    for(size_t i = 2; i < l.size() && j < divisible_by_three.size(); i += 3, ++j) {\n        l[i] = divisible_by_three[j];\n    }\n    \n    return l;\n}\n", "py_code": "def sort_third(l):\n    # Extract elements at indices divisible by 3 (0-indexed)\n    divisible_by_three = [l[i] for i in range(len(l)) if (i + 1) % 3 == 0]\n    \n    # Sort these extracted elements\n    sorted_divisible_by_three = sorted(divisible_by_three)\n    \n    # Replace the original elements with the sorted ones\n    result = l[:]\n    j = 0\n    for i in range(len(l)):\n        if (i + 1) % 3 == 0:\n            result[i] = sorted_divisible_by_three[j]\n            j += 1\n    \n    return result\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `sort_third` takes a list of integers and returns a new list where elements at indices divisible by three (considering 1-indexed positions) are sorted in ascending order while keeping other elements unchanged.\n\nHere's how it works:\n1. **Extract Elements**: It first extracts all elements from the input list that are located at indices which, when incremented by one to convert them into 1-based indexing, are divisible by three.\n2. **Sort Extracted Elements**: The extracted elements are then sorted in ascending order.\n3. **Replace Original Elements**: A new result list is created as a copy of the original list. It iterates through the indices of the input list and replaces the values at positions that are divisible by three (1-based indexing) with the corresponding sorted values from step 2.\n\nThis approach ensures that only elements at specific indices are modified, while others remain unchanged.\n\n"}
{"task_id": "CPP/88", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> sort_array(vector<int> array) {\n    // Base case handling\n    if (array.empty() || array.size() == 1) {\n        return array;\n    }\n\n    // Determine sorting order based on sum of first and last elements\n    bool is_odd = (array[0] + array.back()) % 2 != 0;\n\n    // Create a copy of the array to avoid modifying the original one\n    vector<int> sorted_array(array);\n\n    if (is_odd) {\n        sort(sorted_array.begin(), sorted_array.end());\n    } else {\n        sort(sorted_array.rbegin(), sorted_array.rend());\n    }\n\n    return sorted_array;\n}\n", "py_code": "from typing import List\n\ndef sort_vector(array: List[int]) -> List[int]:\n    if not array or len(array) == 1:\n        return array\n    \n    # Determine sorting order based on sum of first and last elements\n    is_odd = (array[0] + array[-1]) % 2 != 0\n    \n    # Create a copy of the array to avoid modifying the original one\n    sorted_array = array[:]\n    \n    if is_odd:\n        sorted_array.sort()\n    else:\n        sorted_array.sort(reverse=True)\n        \n    return sorted_array\n```\n\n", "py_summary": "### Second Step: Analyse the Python Code\n\nThe provided Python function `sort_vector` takes a list of non-negative integers and returns a new list that is sorted based on a specific condition. The function does not modify the original input list.\n\n1. **Base Case Handling**: \n   - If the input list (`array`) is empty or contains only one element, it directly returns the input list as no sorting is required.\n   \n2. **Determine Sorting Order**:\n   - It checks if the sum of the first and last elements in the array is odd by using `(array[0] + array[-1]) % 2 != 0`. If true, it sets `is_odd` to True indicating that the list should be sorted in ascending order.\n   \n3. **Copy and Sort**:\n   - It creates a copy of the input list (`sorted_array = array[:]`) to avoid modifying the original list.\n   - Depending on the value of `is_odd`, it sorts the copied list either in ascending or descending order using Python's built-in `.sort()` method.\n\n4. **Return Sorted List**: \n   - Finally, it returns the sorted copy of the input list (`sorted_array`).\n\nThis approach ensures that the original array remains unchanged and that the sorting is done based on the specified condition (sum of first and last elements being odd or even).\n\n### Last Step: Generate C++ Solution According to the Python Code Summary\n\n"}
{"task_id": "CPP/15", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\nusing namespace std;\n\nstring string_sequence(int n) {\n    stringstream ss;\n    for (int i = 0; i <= n; ++i) {\n        ss << i;\n        if (i != n) {\n            ss << \" \";\n        }\n    }\n    return ss.str();\n}\n", "py_code": "def string_sequence(n):\n    return ' '.join(str(i) for i in range(n + 1))\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `string_sequence` takes an integer `n` as input and returns a string containing space-delimited numbers starting from 0 up to n inclusive. The function uses a generator expression inside the `join` method to convert each number in the range `[0, n]` into a string and then joins them with spaces. This results in a single string that contains all the numbers in the specified range separated by spaces.```\n"}
{"task_id": "CPP/163", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> generate_integers(int a, int b) {\n    if (a > b) {\n        swap(a, b);\n    }\n\n    vector<int> even_digits = {0, 2, 4, 6, 8};\n    vector<int> result;\n\n    for (int num = max(0, a); num < min(b + 1, 10); ++num) {\n        if (find(even_digits.begin(), even_digits.end(), num) != even_digits.end()) {\n            result.push_back(num);\n        }\n    }\n\n    sort(result.begin(), result.end());\n    return result;\n}\n", "py_code": "def generate_integers(a, b):\n    # Ensure a is less than or equal to b for simplicity\n    if a > b:\n        a, b = b, a\n\n    even_digits = {0, 2, 4, 6, 8}\n    result = set()\n\n    for num in range(max(0, a), min(b + 1, 10)):\n        if num in even_digits:\n            result.add(num)\n\n    return sorted(list(result))\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `generate_integers(a, b)` is designed to find and return all even digits (0, 2, 4, 6, 8) that lie between two given integers `a` and `b`, inclusive. The function first ensures that `a` is less than or equal to `b` by swapping their values if necessary.\n\nThe set of even digits (`even_digits`) contains the possible even numbers less than 10. A result set (`result`) is initialized to store the even digits found within the range `[max(0, a), min(b + 1, 10)]`. This ensures that the function only considers values between `a` and `b`, but also restricts the search to numbers less than 10.\n\nThe loop iterates over all integers in the specified range. If an integer is found within the set of even digits, it is added to the result set. Finally, the result set is converted to a sorted list before being returned.\n\n"}
{"task_id": "CPP/1", "generation": "#include <string>\n#include <vector>\n#include <cctype>\nusing namespace std;\n\nvector<string> separate_paren_groups(string paren_string) {\n    string cleanedString = \"\";\n    for (char c : paren_string) {\n        if (!isspace(c)) {\n            cleanedString += c;\n        }\n    }\n\n    vector<string> result;\n    int balance = 0;\n    size_t start_index = 0;\n\n    for (size_t i = 0; i < cleanedString.length(); ++i) {\n        char c = cleanedString[i];\n        if (c == '(') {\n            if (balance == 0) {\n                start_index = i;\n            }\n            balance++;\n        } else if (c == ')') {\n            balance--;\n            if (balance == 0) {\n                result.push_back(cleanedString.substr(start_index, i - start_index + 1));\n            }\n        }\n    }\n\n    return result;\n}\n", "py_code": "def separate_paren_groups(paren_string):\n    paren_string = paren_string.replace(\" \", \"\")\n    result = []\n    balance = 0\n    start_index = 0\n    \n    for i, char in enumerate(paren_string):\n        if char == '(':\n            if balance == 0:\n                start_index = i\n            balance += 1\n        elif char == ')':\n            balance -= 1\n            if balance == 0:\n                result.append(paren_string[start_index:i+1])\n    \n    return result\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `separate_paren_groups` takes a string containing groups of nested parentheses and separates those groups into separate strings, returning them as a list.\n\n1. The input string is first stripped of any spaces using `replace(\" \", \"\")`.\n2. An empty list named `result` is initialized to store the separated groups.\n3. A variable `balance` is used to keep track of the number of open parentheses that need to be closed, and `start_index` keeps track of where a new group starts.\n4. The function iterates through each character in the string using an index-based loop:\n   - If the current character is '(', it checks if `balance` is 0 (indicating the start of a new group) and updates `start_index`. It then increments `balance`.\n   - If the current character is ')', it decrements `balance`. When `balance` reaches 0, it means that the current group has been fully closed. The function extracts this group from `paren_string[start_index:i+1]` and appends it to `result`.\n\nThe function returns a list of separated groups of parentheses.\n\n"}
{"task_id": "CPP/69", "generation": "#include <vector>\n#include <unordered_map>\n#include <algorithm>\nusing namespace std;\n\nint search(vector<int> lst) {\n    unordered_map<int, int> frequency;\n    \n    // Counting frequencies of each number in the list.\n    for (int num : lst) {\n        frequency[num]++;\n    }\n    \n    int max_val = -1;\n    \n    // Checking if any number's frequency is greater than or equal to its value\n    for (const auto& entry : frequency) {\n        if (entry.first <= entry.second) {\n            max_val = max(max_val, entry.first);\n        }\n    }\n\n    return max_val;\n}\n", "py_code": "from collections import Counter\n\ndef search(lst):\n    frequency = Counter(lst)\n    max_val = -1\n    for num in frequency:\n        if num <= frequency[num]:\n            max_val = max(max_val, num)\n    return max_val\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `search` takes a list of positive integers and returns the greatest integer that has a frequency greater than or equal to its value. The function first uses the `Counter` class from the `collections` module to count the occurrences (frequency) of each number in the input list.\n\nIt then iterates through these counted numbers, checking if the current number's frequency is greater than or equal to the number itself. If it is, and this number is larger than any previously found valid number (`max_val`), `max_val` is updated with the current number. After iterating through all elements, the function returns `max_val`, which will be either the greatest integer meeting the criteria or `-1` if no such integer exists.\n\n"}
{"task_id": "CPP/31", "generation": "#include <cmath>\nusing namespace std;\n\nbool is_prime(long long n) {\n    if (n <= 1) {\n        return false;\n    }\n    for (long long i = 2; i <= sqrt(n); ++i) {\n        if (n % i == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n", "py_code": "def is_prime(n):\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `is_prime` checks whether a given number `n` is prime or not. The function first handles edge cases where numbers less than or equal to 1 are considered non-prime and returns `False`. For other values of `n`, it iterates from 2 up to the square root of `n` (inclusive). If any integer in this range divides `n` evenly, then `n` is not prime, and the function returns `False`. Otherwise, if no divisors are found within that range, the number is considered prime, and the function returns `True`.\n\nThis approach leverages the fact that a larger factor of `n` must be paired with a smaller factor that has already been checked by the time the loop reaches it. Therefore, checking up to the square root of `n` is sufficient for determining primality.\n"}
{"task_id": "CPP/147", "generation": "#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint get_max_triples(int n) {\n    vector<int> a(n);\n    for (int i = 1; i <= n; ++i) {\n        a[i - 1] = i * i - i + 1;\n    }\n    \n    int count = 0;\n    for (int i = 0; i < n - 2; ++i) {\n        for (int j = i + 1; j < n - 1; ++j) {\n            for (int k = j + 1; k < n; ++k) {\n                if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                    count++;\n                }\n            }\n        }\n    }\n    \n    return count;\n}\n", "py_code": "def get_max_triples(n):\n    a = [i * i - i + 1 for i in range(1, n+1)]\n    count = 0\n    for i in range(n-2):\n        for j in range(i+1, n-1):\n            for k in range(j+1, n):\n                if (a[i] + a[j] + a[k]) % 3 == 0:\n                    count += 1\n    return count\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `get_max_triples` takes an integer `n` as input and returns the number of valid triples `(a[i], a[j], a[k])` from the array `a`, where `i < j < k` and the sum of the triple is divisible by 3. \n\n1. The first step in the function is to generate the list `a` using a list comprehension, where each element `a[i] = i * i - i + 1`.\n2. It then initializes a counter variable `count` to zero.\n3. Using three nested loops, it iterates over all possible triples `(i, j, k)` such that `0 <= i < j < k < n`. \n4. For each triple, the function checks if the sum of the elements at indices `i`, `j`, and `k` is divisible by 3.\n5. If the condition is satisfied, it increments the counter `count`.\n6. Finally, the function returns the value of `count`.\n\nThis approach ensures that all possible triples are checked for divisibility by 3, and the count of valid triples is returned.\n\n"}
{"task_id": "CPP/105", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\nvector<string> by_length(vector<int> arr) {\n    // Filter out numbers that are not between 1 and 9 inclusive.\n    vector<int> filtered_arr;\n    for (int num : arr) {\n        if (num >= 1 && num <= 9) {\n            filtered_arr.push_back(num);\n        }\n    }\n\n    // Sort the filtered array.\n    sort(filtered_arr.begin(), filtered_arr.end());\n\n    // Reverse the sorted array.\n    reverse(filtered_arr.begin(), filtered_arr.end());\n\n    // Map each digit to its corresponding name.\n    map<int, string> number_names = {\n        {1, \"One\"}, {2, \"Two\"}, {3, \"Three\"},\n        {4, \"Four\"}, {5, \"Five\"}, {6, \"Six\"},\n        {7, \"Seven\"}, {8, \"Eight\"}, {9, \"Nine\"}\n    };\n\n    // Replace each digit with its corresponding name.\n    vector<string> result;\n    for (int num : filtered_arr) {\n        result.push_back(number_names[num]);\n    }\n\n    return result;\n}\n", "py_code": "def by_length(arr):\n    # Filter out numbers that are not between 1 and 9 inclusive.\n    filtered_arr = [num for num in arr if 1 <= num <= 9]\n    \n    # Sort the filtered array.\n    sorted_arr = sorted(filtered_arr)\n    \n    # Reverse the sorted array.\n    reversed_arr = list(reversed(sorted_arr))\n    \n    # Map each digit to its corresponding name.\n    number_names = {\n        1: \"One\", 2: \"Two\", 3: \"Three\",\n        4: \"Four\", 5: \"Five\", 6: \"Six\",\n        7: \"Seven\", 8: \"Eight\", 9: \"Nine\"\n    }\n    \n    # Replace each digit with its corresponding name.\n    result = [number_names[num] for num in reversed_arr]\n    \n    return result\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `by_length` takes a list of integers as input and processes it according to the problem requirements:\n1. **Filtering**: It first filters out any numbers that are not between 1 and 9 inclusive using a list comprehension.\n2. **Sorting**: The filtered list is then sorted in ascending order.\n3. **Reversing**: After sorting, the list is reversed so that it goes from highest to lowest within the range of 1-9.\n4. **Mapping**: A dictionary `number_names` maps each digit (from 1 to 9) to its corresponding English name.\n5. **Replacement and Result Construction**: The function replaces each number in the reversed, sorted list with its corresponding string representation from the `number_names` dictionary.\n\nThe final result is a list of strings representing the names of numbers in reverse order after sorting and filtering out invalid numbers.\n\n"}
{"task_id": "CPP/22", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <boost/any.hpp>\n#include <list>\n#include <typeinfo>\n\ntypedef std::list<boost::any> list_any;\nusing namespace std;\n\nvector<int> filter_integers(list_any values) {\n    vector<int> result;\n    for (const auto& value : values) {\n        if (value.type() == typeid(int)) {\n            result.push_back(boost::any_cast<int>(value));\n        }\n    }\n    return result;\n}\n", "py_code": "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> set:\n    return {x for x in values if isinstance(x, int)}\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `filter_integers` takes a list of mixed-type elements (`values`) and returns a set containing only those elements that are integers. The function uses a set comprehension to iterate over each element in the input list and checks if it is an instance of the integer type using `isinstance(x, int)`. If the condition is true, the element is added to the resulting set.\n\n"}
{"task_id": "CPP/52", "generation": "#include <vector>\nusing namespace std;\n\nbool below_threshold(vector<int> l, int t) {\n    for (int x : l) {\n        if (x >= t) {\n            return false;\n        }\n    }\n    return true;\n}\n", "py_code": "def below_threshold(l, t):\n    return all(x < t for x in l)\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `below_threshold` takes a list of integers `l` and an integer threshold `t`. It returns `True` if all elements in the list are below the given threshold `t`, otherwise it returns `False`. The function uses the built-in `all()` function which checks whether all elements in the provided iterable (in this case, a generator expression) satisfy the condition `x < t`. If they do, `all()` returns `True`; otherwise, it returns `False`.\n```\n\n"}
{"task_id": "CPP/154", "generation": "#include <string>\n#include <algorithm>\nusing namespace std;\n\nbool cycpattern_check(string a, string b) {\n    if (b.length() > a.length()) return false;\n\n    // Concatenate string 'a' with itself to handle rotations\n    string a_double = a + a;\n\n    for (size_t i = 0; i < b.length(); ++i) {\n        string rotated_b = b.substr(i) + b.substr(0, i);\n        if (a_double.find(rotated_b) != std::string::npos)\n            return true;\n    }\n    return false;\n}\n", "py_code": "def cycpattern_check(a: str, b: str) -> bool:\n    if len(b) > len(a):\n        return False\n    \n    # Concatenate string 'a' with itself to handle rotations\n    a_double = a + a\n\n    for i in range(len(b)):\n        rotated_b = b[i:] + b[:i]\n        if rotated_b in a_double:\n            return True\n    return False\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `cycpattern_check` takes two strings `a` and `b` as input and checks if string `b` or any of its rotations is a substring in string `a`. The function first checks if the length of `b` is greater than that of `a`, returning `False` immediately if it is, since a longer string cannot be a substring of a shorter one.\n\nTo handle all possible rotations of `b`, the function concatenates `a` with itself (`a_double = a + a`). This concatenated version allows for checking substrings across the boundary where the original string ends and begins again. \n\nThe function then iterates over each possible rotation of `b`. For each iteration, it creates a rotated version of `b` by slicing from index `i` to the end and appending the slice from the beginning up to index `i`. It checks if this rotated substring is present in `a_double`, returning `True` as soon as it finds a match. If no rotations are found within `a_double`, the function returns `False`.\n\nThis approach ensures that all possible rotations of `b` are checked against `a` efficiently by leveraging string concatenation and slicing operations.\n\n"}
{"task_id": "CPP/115", "generation": "#include <vector>\n#include <algorithm> // for std::accumulate\n\nusing namespace std;\n\nint max_fill(vector<vector<int>> grid, int capacity) {\n    int total_drops = 0;\n    \n    for (const auto& row : grid) {\n        int water_units = accumulate(row.begin(), row.end(), 0);\n        total_drops += (water_units + capacity - 1) / capacity; // Ceiling division\n    }\n    \n    return total_drops;\n}\n", "py_code": "from typing import List\n\ndef max_fill(grid: List[List[int]], capacity: int) -> int:\n    total_drops = 0\n    for row in grid:\n        water_units = sum(row)\n        total_drops += (water_units + capacity - 1) // capacity\n    return total_drops\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `max_fill` takes a grid representing wells and their water units (where each well is represented by a row in the grid) and an integer `capacity` indicating the capacity of the buckets used to extract water from these wells.\n\n1. The function iterates over each row (`row`) in the grid.\n2. For each row, it calculates the total number of water units present using the `sum(row)` method.\n3. It then computes how many times a bucket with the given capacity needs to be lowered to empty that well by performing `(water_units + capacity - 1) // capacity`. This formula ensures that if there is any remainder after dividing `water_units` by `capacity`, it will still count as one additional drop (ceiling division).\n4. The total number of drops required for all wells is accumulated in the variable `total_drops`.\n5. Finally, the function returns the total number of bucket drops needed to empty all the wells.\n\nThis approach ensures that each well's water units are emptied using the minimum number of bucket drops based on its capacity.\n```\n\n"}
{"task_id": "CPP/131", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nint digits(int n) {\n    int product = 1;\n    bool has_odd_digit = false;\n    \n    while (n > 0) {\n        int digit = n % 10;\n        if (digit % 2 != 0) {\n            product *= digit;\n            has_odd_digit = true;\n        }\n        n /= 10;\n    }\n\n    return has_odd_digit ? product : 0;\n}\n", "py_code": "def digits(n):\n    product = 1\n    has_odd_digit = False\n    while n > 0:\n        digit = n % 10\n        if digit % 2 != 0:\n            product *= digit\n            has_odd_digit = True\n        n //= 10\n    return product if has_odd_digit else 0\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `digits(n)` calculates the product of all odd digits in a given positive integer `n`. If there are no odd digits, it returns 0.\n\n1. The function initializes `product` to 1 and `has_odd_digit` to False.\n2. It enters a loop that continues as long as `n` is greater than 0.\n3. Inside the loop:\n   - It extracts the last digit of `n` using `digit = n % 10`.\n   - Checks if this digit is odd (`digit % 2 != 0`). If it is, it multiplies the current product by this digit and sets `has_odd_digit` to True.\n4. The function then removes the last digit from `n` with integer division: `n //= 10`.\n5. After exiting the loop, if there was at least one odd digit (`has_odd_digit == True`), it returns the calculated product; otherwise, it returns 0.\n\nThis approach ensures that all digits are processed and only odd digits contribute to the final product.\n```\n\n<|im_start|>\n<|im_start|>user\n"}
{"task_id": "CPP/37", "generation": "#include <stdio.h>\n#include <math.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<float> sort_even(vector<float> l) {\n    vector<float> even_indices_values;\n    \n    // Extract and sort the values at even indices.\n    for (size_t i = 0; i < l.size(); i += 2) {\n        even_indices_values.push_back(l[i]);\n    }\n    sort(even_indices_values.begin(), even_indices_values.end());\n    \n    vector<float> result;\n    size_t even_index = 0;\n\n    // Construct the resulting list.\n    for (size_t i = 0; i < l.size(); ++i) {\n        if (i % 2 == 0) {\n            result.push_back(even_indices_values[even_index++]);\n        } else {\n            result.push_back(l[i]);\n        }\n    }\n\n    return result;\n}\n", "py_code": "from typing import List\n\ndef sort_even(l: List[float]) -> List[float]:\n    even_indices_values = sorted([l[i] for i in range(0, len(l), 2)])\n    result = []\n    even_index = 0\n    \n    for i in range(len(l)):\n        if i % 2 == 0:\n            result.append(even_indices_values[even_index])\n            even_index += 1\n        else:\n            result.append(l[i])\n            \n    return result\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `sort_even` takes a list of floats as input and returns a new list where the values at even indices are sorted while keeping the odd index values unchanged.\n\n1. The first line extracts all elements from even indices (0-based) into a new list and sorts them.\n2. An empty result list is initialized to store the final output.\n3. A variable `even_index` is used as an iterator for the sorted even-indexed values.\n4. The function then iterates through each index of the input list:\n   - If the current index is even, it appends the next value from the sorted even indices list to the result and increments the `even_index`.\n   - If the current index is odd, it directly appends the corresponding value from the original list.\n5. Finally, the function returns the constructed result list.\n\nThis approach ensures that all elements at even positions are sorted while maintaining the order of elements at odd positions as they were in the input list.\n\n\n"}
{"task_id": "CPP/92", "generation": "#include <cmath> // For fabs and isfinite functions\nusing namespace std;\n\nbool any_int(float a, float b, float c) {\n    // Check if all numbers are integers by ensuring their fractional part is 0.\n    bool a_is_integer = fabs(a - round(a)) < 1e-9;\n    bool b_is_integer = fabs(b - round(b)) < 1e-9;\n    bool c_is_integer = fabs(c - round(c)) < 1e-9;\n\n    // If any number is not an integer, return false.\n    if (!a_is_integer || !b_is_integer || !c_is_integer) {\n        return false;\n    }\n\n    // Check if one of the numbers equals the sum of the other two\n    if (a == b + c || b == a + c || c == a + b) {\n        return true;\n    } else {\n        return false;\n    }\n}\n", "py_code": "def any_int(a, b, c):\n    # Check if all numbers are integers\n    if not (a.is_integer() and b.is_integer() and c.is_integer()):\n        return False\n    \n    # Check if one of the numbers is equal to the sum of the other two\n    if a == b + c or b == a + c or c == a + b:\n        return True\n    else:\n        return False\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `any_int` takes three floating-point numbers as input and checks if any one of them is equal to the sum of the other two while ensuring all numbers are integers.\n\n1. The first condition checks whether all three inputs (`a`, `b`, `c`) are integers by using the `.is_integer()` method, which returns `True` if the float value is an integer and `False` otherwise.\n2. If any of the numbers are not integers, the function immediately returns `False`.\n3. The second condition checks whether one number equals the sum of the other two:\n   - It verifies if `a == b + c`, or\n   - `b == a + c`, or\n   - `c == a + b`.\n\nIf any of these conditions are met, it returns `True`. Otherwise, it returns `False`.\n\n"}
{"task_id": "CPP/118", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nstring get_closest_vowel(string word) {\n    string vowels = \"aeiouAEIOU\";\n    for (int i = word.length() - 2; i > 0; --i) { // Start from second last character and go leftwards.\n        if (vowels.find(word[i]) != string::npos && \n            vowels.find(word[i-1]) == string::npos &&\n            vowels.find(word[i+1]) == string::npos) {\n            return string(1, word[i]);  // Return the vowel as a single-character string\n        }\n    }\n    return \"\";  // Return empty string if no such vowel is found.\n}\n", "py_code": "def get_closest_vowel(word):\n    vowels = \"aeiouAEIOU\"\n    for i in range(len(word) - 2, 0, -1): # Start from second last character and go leftwards.\n        if word[i] in vowels and word[i-1] not in vowels and word[i+1] not in vowels:\n            return word[i]\n    return \"\"\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `get_closest_vowel` is designed to find the closest vowel that stands between two consonants from the right side of a given word (case sensitive). The function starts by defining a string containing all vowels in both lowercase and uppercase. It then iterates over the characters of the input word starting from the second last character and moving leftwards, checking if each character is a vowel surrounded by consonants.\n\nThe loop checks three conditions for each character:\n1. Whether the current character (`word[i]`) is a vowel.\n2. Whether the preceding character (`word[i-1]`) is not a vowel (i.e., it's a consonant).\n3. Whether the following character (`word[i+1]`) is not a vowel (i.e., it's also a consonant).\n\nIf all three conditions are met, the function immediately returns the current character as it satisfies the requirement of being between two consonants from the right side.\n\nIf no such vowel is found by the end of the loop, an empty string is returned to indicate that there was no vowel meeting the specified condition in the word. \n\nThis approach ensures that only vowels surrounded by consonants are considered and that the search starts from the rightmost part of the word as required.\n```\n\n"}
{"task_id": "CPP/6", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\nusing namespace std;\n\nvector<int> parse_nested_parens(string paren_string) {\n    vector<int> max_depths;\n    stringstream ss(paren_string);\n    string group;\n\n    while (getline(ss, group, ' ')) {\n        int current_depth = 0;\n        int max_depth = 0;\n        \n        for (char c : group) {\n            if (c == '(') {\n                current_depth += 1;\n                max_depth = std::max(max_depth, current_depth);\n            } else if (c == ')') {\n                current_depth -= 1;\n            }\n        }\n\n        max_depths.push_back(max_depth);\n    }\n\n    return max_depths;\n}\n", "py_code": "def parse_nested_parens(paren_string):\n    groups = paren_string.split()\n    max_depths = []\n    for group in groups:\n        current_depth = 0\n        max_depth = 0\n        for char in group:\n            if char == '(':\n                current_depth += 1\n                max_depth = max(max_depth, current_depth)\n            elif char == ')':\n                current_depth -= 1\n        max_depths.append(max_depth)\n    return max_depths\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `parse_nested_parens` takes a string of multiple groups of nested parentheses separated by spaces as input and returns a list containing the deepest level of nesting for each group.\n\n1. The input string is split into individual groups using the `split()` method.\n2. An empty list, `max_depths`, is initialized to store the maximum depth of nesting for each group.\n3. For each group in the list:\n   - A variable `current_depth` is used to track the current level of nesting within that group.\n   - Another variable `max_depth` keeps track of the highest level of nesting encountered so far within that group.\n4. The function iterates through each character in a group:\n   - If an opening parenthesis '(' is found, it increments `current_depth` and updates `max_depth`.\n   - If a closing parenthesis ')' is found, it decrements `current_depth`.\n5. After processing all characters in the current group, the maximum depth of nesting (`max_depth`) for that group is appended to the `max_depths` list.\n6. Finally, the function returns the `max_depths` list containing the deepest level of nesting for each group.\n\nThis approach ensures that we correctly track and record the maximum depth of nested parentheses in each group within the input string.```\n\n"}
{"task_id": "CPP/87", "generation": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nbool compare(const vector<int>& a, const vector<int>& b) {\n    if (a[0] == b[0]) return a[1] > b[1]; // Sort columns in descending order within each row\n    return a[0] < b[0]; // Sort rows in ascending order\n}\n\nvector<vector<int>> get_row(vector<vector<int>> lst, int x) {\n    vector<vector<int>> coordinates;\n    \n    for (size_t i = 0; i < lst.size(); ++i) {\n        for (size_t j = 0; j < lst[i].size(); ++j) {\n            if (lst[i][j] == x) {\n                coordinates.push_back({static_cast<int>(i), static_cast<int>(j)});\n            }\n        }\n    }\n\n    // Sort the coordinates by rows in ascending order and columns in descending order within each row\n    sort(coordinates.begin(), coordinates.end(), compare);\n    \n    return coordinates;\n}\n", "py_code": "def get_row(lst, x):\n    coordinates = []\n    for row_idx, row in enumerate(lst):\n        for col_idx, value in enumerate(row):\n            if value == x:\n                coordinates.append([row_idx, col_idx])\n    \n    # Sort by rows in ascending order and columns in descending order within each row\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    return coordinates\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `get_row` takes a nested list (`lst`) and an integer (`x`). It searches for occurrences of `x` within the nested list and records their coordinates (row index and column index). The coordinates are stored in a list called `coordinates`. After collecting all the coordinates, the list is sorted first by row indices in ascending order and then by column indices in descending order within each row. Finally, the function returns the sorted list of coordinates.\n\nThe nested loop iterates over each element in the 2D structure (`lst`). If an element matches `x`, its coordinates are added to the `coordinates` list as a sublist `[row_idx, col_idx]`. The sorting step ensures that the output is organized by rows and then by columns in descending order.```\n\n"}
{"task_id": "CPP/2", "generation": "#include <cmath> // Include cmath for using floor function\n\nfloat truncate_number(float number) {\n    float integer_part = std::floor(number);\n    float decimal_part = number - integer_part;\n    return decimal_part;\n}\n", "py_code": "def truncate_number(number):\n    integer_part = int(number)\n    decimal_part = number - integer_part\n    return decimal_part\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `truncate_number` takes a floating point number as input and returns its decimal part. The function first calculates the integer part of the given number by converting it to an integer using the `int()` function. This effectively truncates the decimal portion of the number. Then, it subtracts this integer part from the original number to obtain the decimal part. Finally, the function returns the calculated decimal part.\n```"}
{"task_id": "CPP/16", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <unordered_set>\nusing namespace std;\n\nint count_distinct_characters(string str) {\n    transform(str.begin(), str.end(), str.begin(), ::tolower); // Convert string to lowercase\n    unordered_set<char> distinct_chars(str.begin(), str.end()); // Create a set of characters from the string\n    return distinct_chars.size(); // Return the size of the set, which is the number of distinct characters\n}\n", "py_code": "def count_distinct_characters(str):\n    return len(set(str.lower()))\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `count_distinct_characters` takes a string as input and returns the number of distinct characters in it, ignoring case differences. The function converts the entire string to lowercase using `.lower()` to ensure that character comparison is case-insensitive. It then creates a set from this modified string, which automatically removes duplicate characters due to the properties of sets. Finally, the length of this set is returned as the count of distinct characters.```\n\n"}
{"task_id": "CPP/135", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nint can_arrange(vector<int> arr) {\n    for (size_t i = 1; i < arr.size(); ++i) {\n        if (arr[i] < arr[i-1]) {\n            return static_cast<int>(i);\n        }\n    }\n    return -1;\n}\n", "py_code": "def can_arrange(arr):\n    for i in range(1, len(arr)):\n        if arr[i] < arr[i-1]:\n            return i\n    return -1\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `can_arrange` takes a list of integers as input and returns the largest index where an element is not greater than or equal to its preceding element. The function iterates through the list starting from the second element (index 1) and checks if the current element is less than the previous one. If such an element is found, it immediately returns the index of that element. If no such element exists in the entire list, the function returns -1. This approach ensures that we find the largest index where the condition fails, as the loop will naturally stop at the first occurrence from left to right.```\n\n"}
{"task_id": "CPP/106", "generation": "#include <stdio.h>\n#include <vector>\n#include <numeric> // For std::iota\n\nusing namespace std;\n\nint factorial(int num) {\n    int result = 1;\n    for (int i = 2; i <= num; ++i) {\n        result *= i;\n    }\n    return result;\n}\n\nvector<int> f(int n) {\n    vector<int> result(n);\n    for (int i = 1; i <= n; ++i) {\n        if (i % 2 == 0) {\n            result[i - 1] = factorial(i); // Adjust index to match C++ zero-based indexing\n        } else {\n            int sum = (i * (i + 1)) / 2; // Sum of numbers from 1 to i using arithmetic series formula\n            result[i - 1] = sum;\n        }\n    }\n    return result;\n}\n", "py_code": "from math import factorial\n\ndef f(n):\n    result = []\n    for i in range(1, n + 1):\n        if i % 2 == 0:\n            result.append(factorial(i))\n        else:\n            result.append(sum(range(1, i + 1)))\n    return result\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `f` takes an integer `n` as input and returns a list of size `n`. The value at index `i` (starting from 1) in this list is determined based on whether `i` is even or odd. If `i` is even, the value is the factorial of `i`, calculated using Python's built-in `factorial` function from the math module. If `i` is odd, the value is the sum of all integers from 1 to `i`. The function iterates through each integer from 1 to `n`, calculates the appropriate value based on its parity (even or odd), and appends it to the result list.\n\nFinally, the function returns this list. For example, if `n` is 5, the returned list would be `[1, 2, 6, 24, 15]`. Here's a breakdown of how each value in the list is calculated:\n- i=1 (odd): sum(1) = 1\n- i=2 (even): factorial(2) = 2\n- i=3 (odd): sum(1 to 3) = 6\n- i=4 (even): factorial(4) = 24\n- i=5 (odd): sum(1 to 5) = 15\n\n"}
{"task_id": "CPP/162", "generation": "#include <iostream>\n#include <string>\n#include <openssl/md5.h>\n#include <iomanip>\n#include <sstream>\nusing namespace std;\n\nstring string_to_md5(string text) {\n    if (text.empty()) return \"None\"; // Return \"None\" as a string since C++ does not have None like Python\n\n    unsigned char digest[MD5_DIGEST_LENGTH];\n    MD5((unsigned char*)text.c_str(), text.length(), (unsigned char*)&digest);    \n\n    stringstream ss;\n    for(int i = 0; i < MD5_DIGEST_LENGTH; i++) {\n        ss << hex << setw(2) << setfill('0') << (int)digest[i];\n    }\n\n    return ss.str();\n}\n", "py_code": "import hashlib\n\ndef string_to_md5(text):\n    if not text: \n        return None\n    md5_hash = hashlib.md5()\n    md5_hash.update(text.encode('utf-8'))\n    return md5_hash.hexdigest()\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `string_to_md5` takes a string input and returns its MD5 hash equivalent as another string. If the input string is empty, it returns None. The function uses the hashlib library to create an MD5 hash object (`md5_hash`). It then updates this object with the encoded version of the input text (converted to bytes using UTF-8 encoding). Finally, it retrieves and returns the hexadecimal representation of the hash value via `hexdigest()`.``` \n\n"}
{"task_id": "CPP/5", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nvector<int> intersperse(vector<int> numbers, int delimiter) {\n    vector<int> result;\n    \n    if (numbers.empty()) {\n        return result; // Return an empty vector if input is empty.\n    }\n    \n    // Add the first element to the result\n    result.push_back(numbers[0]);\n    \n    // Iterate over the remaining elements and intersperse with the delimiter\n    for (size_t i = 1; i < numbers.size(); ++i) {\n        result.push_back(delimiter);\n        result.push_back(numbers[i]);\n    }\n    \n    return result;\n}\n", "py_code": "def intersperse(numbers, delimiter):\n    if not numbers:\n        return []\n    \n    result = [numbers[0]]\n    for num in numbers[1:]:\n        result.extend([delimiter, num])\n    return result\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `intersperse` takes two arguments: a list of integers (`numbers`) and an integer (`delimiter`). The goal is to insert the delimiter between every pair of consecutive elements in the input list.\n\n1. If the input list `numbers` is empty, the function returns an empty list.\n2. Otherwise, it initializes a new list `result` with the first element from `numbers`.\n3. It then iterates over the remaining elements in `numbers`, appending the delimiter and each subsequent number to the `result` list.\n4. Finally, the function returns the constructed `result` list.\n\nThis approach ensures that the delimiter is placed between every pair of consecutive numbers while maintaining the order of the original numbers.\n\n"}
{"task_id": "CPP/97", "generation": "#include <cmath> // Include cmath for abs function\n\nint multiply(int a, int b) {\n    int unit_digit_a = std::abs(a) % 10;\n    int unit_digit_b = std::abs(b) % 10;\n    return unit_digit_a * unit_digit_b;\n}\n", "py_code": "def multiply(a, b):\n    unit_digit_a = abs(a) % 10\n    unit_digit_b = abs(b) % 10\n    return unit_digit_a * unit_digit_b\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `multiply` takes two integers as input and returns the product of their unit digits (the last digit). The function first calculates the absolute value of each integer to handle negative numbers correctly. It then uses the modulo operator `%` with 10 to extract the unit digit from both inputs. Finally, it multiplies these unit digits together and returns the result. This approach ensures that even if one or both input integers are negative, their unit digits will be treated as positive values for the multiplication operation.```\n\n"}
{"task_id": "CPP/44", "generation": "#include <stdio.h>\n#include <string>\n#include <vector>\nusing namespace std;\n\nstring change_base(int x, int base) {\n    if (x == 0) return \"0\";\n    \n    vector<int> digits;\n    while (x > 0) {\n        digits.push_back(x % base);\n        x /= base;\n    }\n    \n    string result = \"\";\n    for (int i = digits.size() - 1; i >= 0; --i) {\n        result += to_string(digits[i]);\n    }\n    \n    return result;\n}\n", "py_code": "def change_base(x: int, base: int) -> str:\n    if x == 0:\n        return \"0\"\n    digits = []\n    while x > 0:\n        digits.append(str(x % base))\n        x //= base\n    return ''.join(digits[::-1])\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `change_base` takes two parameters: an integer `x`, which is the number to be converted, and another integer `base`, which represents the target base for conversion (with a constraint that the base must be less than 10). The goal of this function is to convert the given number `x` into its string representation in the specified base.\n\nThe function first checks if `x` is zero. If it is, then \"0\" is returned immediately as the result since any number represented in any base would still be \"0\".\n\nIf `x` is not zero, an empty list named `digits` is initialized to store individual digits of the converted number. The function enters a loop where it repeatedly divides `x` by the target `base`, appending the remainder (which represents the current digit) to the `digits` list as a string.\n\nAfter exiting the loop when `x` becomes zero, the list of digits is reversed and joined into a single string using `''.join(digits[::-1])`. This step ensures that the most significant digit comes first in the final string representation. The function then returns this string.\n\nThis approach effectively converts the number from its original base (assumed to be 10) to the specified target base by repeatedly dividing and taking remainders, which is a standard algorithm for base conversion.\n```\n\n"}
{"task_id": "CPP/161", "generation": "#include <iostream>\n#include <string>\n#include <cctype> // for isalpha, tolower, and toupper functions\nusing namespace std;\n\nstring solve(string s) {\n    bool has_letters = false;\n    \n    // Check if the string contains any letters\n    for (char c : s) {\n        if (isalpha(c)) {\n            has_letters = true;\n            break;\n        }\n    }\n\n    if (!has_letters) {\n        // Reverse the string if no letters are found\n        reverse(s.begin(), s.end());\n        return s;\n    } else {\n        // Process each character in the string\n        for (char &c : s) {\n            if (isalpha(c)) {\n                // Swap case of letter characters\n                if (islower(c))\n                    c = toupper(c);\n                else\n                    c = tolower(c);\n            }\n        }\n    }\n\n    return s;\n}\n", "py_code": "def solve(s):\n    has_letters = any(c.isalpha() for c in s)\n    if not has_letters:\n        return s[::-1]\n    result = \"\"\n    for char in s:\n        if char.isalpha():\n            result += char.swapcase()\n        else:\n            result += char\n    return result\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `solve` takes a string `s` as input and processes it according to specific rules based on whether the characters are letters or not.\n\n1. **Check for Letters**: The function first checks if there is at least one letter in the string using the `any()` function combined with `c.isalpha()`. This returns `True` if any character in the string is a letter and `False` otherwise.\n2. **Reverse String if No Letters**: If no letters are found, it reverses the entire string using slicing (`s[::-1]`) and returns the reversed string.\n3. **Process Each Character**: If there are letters present, the function iterates over each character in the input string:\n   - For characters that are letters (checked with `char.isalpha()`), their case is reversed using `char.swapcase()`.\n   - Non-letter characters remain unchanged and are directly added to the result.\n4. **Return Result**: The processed string is returned as the final output.\n\nThis approach ensures that the function meets all the specified conditions: it reverses the case of letters, leaves non-letters untouched, and reverses the entire string if no letters are present.\n\n"}
{"task_id": "CPP/38", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring encode_cyclic(string s) {\n    // returns encoded string by cycling groups of three characters.\n    int l = s.length();\n    int num_groups = (l + 2) / 3;\n    string output = \"\";\n    \n    for (int i = 0; i * 3 < l; i++) {\n        // Extract substring of length up to 3\n        string x = s.substr(i * 3, 3);\n        \n        if (x.length() == 3) {\n            // Rotate the group by moving the first character to the end\n            x = x.substr(1) + x[0];\n        }\n        \n        output += x;\n    }\n    \n    return output;\n}\n\nstring decode_cyclic(string s) {\n    /*\n    takes as input string encoded with encode_cyclic function. Returns decoded string.\n    */\n    int l = s.length();\n    int num_groups = (l + 2) / 3;\n    string output = \"\";\n    \n    for (int i = 0; i * 3 < l; i++) {\n        // Extract substring of length up to 3\n        string x = s.substr(i * 3, 3);\n        \n        if (x.length() == 3) {\n            // Rotate the group by moving the last character to the front\n            x = x[x.length() - 1] + x.substr(0, x.length() - 1);\n        }\n        \n        output += x;\n    }\n    \n    return output;\n}\n", "py_code": "def encode_cyclic(s: str) -> str:\n    l = len(s)\n    num_groups = (l + 2) // 3\n    output = \"\"\n    \n    for i in range(num_groups):\n        x = s[i * 3:(i + 1) * 3]\n        if len(x) == 3:\n            x = x[1:] + x[0]\n        output += x\n    \n    return output\n\ndef decode_cyclic(s: str) -> str:\n    l = len(s)\n    num_groups = (l + 2) // 3\n    output = \"\"\n    \n    for i in range(num_groups):\n        x = s[i * 3:(i + 1) * 3]\n        if len(x) == 3:\n            x = x[-1] + x[:-1]\n        output += x\n    \n    return output\n```\n\n", "py_summary": "### Analysis of Python Code:\n\nThe provided Python functions `encode_cyclic` and `decode_cyclic` are designed to encode and decode a string by cycling groups of three characters.\n\n1. **Function: `encode_cyclic(s)`**\n   - The function takes a single argument, `s`, which is the input string.\n   - It calculates the length of the string (`l`) and determines the number of groups needed for encoding (`num_groups`), where each group contains up to three characters.\n   - A loop iterates over these groups. For each group:\n     - The substring of length 3 (or less if at the end) is extracted from `s`.\n     - If the group has exactly three characters, it rotates them by moving the first character to the end (`x[1:] + x[0]`).\n   - The modified groups are concatenated into a new string (`output`) which is returned as the encoded result.\n\n2. **Function: `decode_cyclic(s)`**\n   - This function takes an encoded string `s` and reverses the encoding process.\n   - Similar to `encode_cyclic`, it calculates the length of the string and determines the number of groups needed for decoding.\n   - A loop iterates over these groups, extracting substrings of up to three characters.\n     - If a group has exactly three characters, it rotates them by moving the last character to the front (`x[-1] + x[:-1]`).\n   - The modified groups are concatenated into `output`, which is returned as the decoded result.\n\n### Summary:\n- **Encoding**: Groups of up to 3 characters are rotated such that the first character moves to the end.\n- **Decoding**: Reverses the encoding by moving the last character in each group to the front, effectively undoing the rotation performed during encoding.\n\nNow let's translate this logic into C++ code.\n\n"}
{"task_id": "CPP/93", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nstring encode(string message) {\n    string vowels = \"aeiouAEIOU\";\n    string encoded_message = \"\";\n    \n    for (char& c : message) {\n        char encoded_char;\n        \n        // Check if the character is a vowel and replace it\n        size_t pos = vowels.find(c);\n        if (pos != string::npos) {\n            // Determine replacement based on position in vowels string\n            if (c >= 'a' && c <= 'u') {  // lowercase\n                encoded_char = c + 2;\n            } else if (c >= 'A' && c <= 'U') {  // uppercase\n                encoded_char = c + 2;\n            }\n        } else {\n            encoded_char = c;  // Not a vowel, keep the character as is\n        }\n\n        // Swap case of the character\n        if (islower(encoded_char)) {\n            encoded_char = toupper(encoded_char);\n        } else if (isupper(encoded_char)) {\n            encoded_char = tolower(encoded_char);\n        }\n        \n        encoded_message += encoded_char;\n    }\n    \n    return encoded_message;\n}\n", "py_code": "def encode(message):\n    vowels = {'a': 'c', 'e': 'g', 'i': 'k', 'o': 'q', 'u': 'w',\n              'A': 'C', 'E': 'G', 'I': 'K', 'O': 'Q', 'U': 'W'}\n    \n    encoded_message = \"\"\n    for char in message:\n        if char.lower() in vowels:\n            encoded_char = vowels[char]\n        else:\n            encoded_char = char\n        # Swap case of the character\n        if encoded_char.islower():\n            encoded_char = encoded_char.upper()\n        elif encoded_char.isupper():\n            encoded_char = encoded_char.lower()\n        \n        encoded_message += encoded_char\n    \n    return encoded_message\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `encode` takes a string message as input and returns an encoded version of it according to specific rules: swapping case for all letters and replacing vowels with the letter that appears two places ahead in the English alphabet. The function first defines a dictionary `vowels` which maps each vowel (both lowercase and uppercase) to its corresponding replacement character.\n\nThe function then initializes an empty string `encoded_message`. It iterates over each character in the input message, checking if it is a vowel by looking up its lowercased version in the `vowels` dictionary. If it's a vowel, it replaces it with the mapped value from the dictionary; otherwise, it keeps the original character.\n\nAfter determining the encoded character (either replaced or unchanged), the function checks and swaps the case of the character: if the character is lowercase, it converts it to uppercase, and vice versa. The transformed character is then appended to `encoded_message`.\n\nFinally, the function returns the fully encoded message string.\n```\n\n"}
{"task_id": "CPP/152", "generation": "#include <stdio.h>\n#include <cmath>\n#include <vector>\nusing namespace std;\n\nvector<int> compare(vector<int> game, vector<int> guess) {\n    vector<int> result;\n    for (size_t i = 0; i < game.size(); ++i) {\n        int diff = abs(game[i] - guess[i]);\n        result.push_back(diff);\n    }\n    return result;\n}\n", "py_code": "from typing import List\n\ndef compare(game: List[int], guess: List[int]) -> List[int]:\n    result = []\n    for g, gu in zip(game, guess):\n        result.append(abs(g - gu))\n    return result\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `compare` takes two lists of integers as input: `game`, which represents the actual scores of matches, and `guess`, which represents the guessed scores for those matches. The function returns a list where each element is either 0 (if the guess was correct) or the absolute difference between the actual score and the guessed score.\n\nThe function iterates through both lists simultaneously using the `zip` function to pair corresponding elements from `game` and `guess`. For each pair, it calculates the absolute difference between the game's score (`g`) and the guess (`gu`). The result is appended to a list called `result`, which is returned at the end of the function.```\n\n"}
{"task_id": "CPP/62", "generation": "#include <stdio.h>\n#include <math.h>\n#include <vector>\nusing namespace std;\n\nvector<float> derivative(vector<float> xs) {\n    vector<float> result;\n    for (size_t i = 1; i < xs.size(); ++i) {\n        result.push_back(i * xs[i]);\n    }\n    return result;\n}\n", "py_code": "from typing import List\n\ndef derivative(xs: List[float]) -> List[float]:\n    return [i * coeff for i, coeff in enumerate(xs)][1:]\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `derivative` takes a list of coefficients (`xs`) representing a polynomial and returns a new list of coefficients that represent the derivative of this polynomial. The function uses a list comprehension to iterate over each coefficient in the input list along with its index (representing the power of x). For each term, it multiplies the coefficient by its corresponding power (index) to get the derivative's coefficient for that term. Since the derivative reduces the degree of each term by 1, the first element (the constant term) is not included in the result, hence `[i * coeff for i, coeff in enumerate(xs)][1:]` skips the zeroth index.\n```\n\n"}
{"task_id": "CPP/7", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nvector<string> filter_by_substring(vector<string> strings, string substring) {\n    vector<string> filtered_strings;\n    for (const auto& s : strings) {\n        if (s.find(substring) != string::npos) {\n            filtered_strings.push_back(s);\n        }\n    }\n    return filtered_strings;\n}\n", "py_code": "def filter_by_substring(strings, substring):\n    return [s for s in strings if substring in s]\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `filter_by_substring` takes two arguments: a list of strings (`strings`) and a substring (`substring`). The function returns a new list containing only those strings from the input list that contain the given substring.\n\nThis is achieved using a list comprehension which iterates over each string in the input list. For each string, it checks if the `substring` exists within the string using the `in` operator. If the condition evaluates to true, the string is included in the resulting list. The function then returns this filtered list.\n``` \n\n"}
{"task_id": "CPP/24", "generation": "#include <iostream>\nusing namespace std;\n\nint largest_divisor(int n) {\n    for (int i = n / 2; i > 0; --i) {\n        if (n % i == 0) {\n            return i;\n        }\n    }\n    // In case no divisor is found, which theoretically should not happen as '1' will always be a divisor.\n    return -1;\n}\n\n", "py_code": "def largest_divisor(n):\n    for i in range(n // 2, 0, -1):\n        if n % i == 0:\n            return i\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `largest_divisor` is designed to find the largest divisor of a given number `n`, which is smaller than `n`. The function starts by iterating from `n // 2` down to `1` in reverse order. For each value `i` within this range, it checks if `n % i == 0`, meaning that `i` divides `n` evenly (without a remainder). If such an `i` is found, the function immediately returns `i` as the largest divisor smaller than `n`. This approach ensures that the first divisor found in descending order will be the largest possible one. \n\nThe use of reverse iteration from `n // 2` to `1` guarantees that we find the largest divisor efficiently without needing to check all numbers up to `n`.\n\n"}
{"task_id": "CPP/79", "generation": "#include <bitset>\n#include <string>\nusing namespace std;\n\nstring decimal_to_binary(int decimal) {\n    // Convert integer to binary string using bitset.\n    bitset<32> binary(decimal);\n    string binary_str = binary.to_string();\n\n    // Remove leading zeros.\n    size_t first_one = binary_str.find('1');\n    if (first_one != string::npos) {\n        binary_str = binary_str.substr(first_one);\n    }\n\n    // Add \"db\" at the beginning and end of the binary string.\n    return \"db\" + binary_str + \"db\";\n}\n", "py_code": "def decimal_to_binary(decimal):\n    binary_str = bin(decimal)[2:]  # Convert to binary and remove the '0b' prefix.\n    return f\"db{binary_str}db\"\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `decimal_to_binary` takes an integer in decimal form and converts it to a binary string representation. The built-in `bin()` function is used to convert the given decimal number into its binary equivalent, which includes a '0b' prefix indicating that the number is in binary format. To remove this prefix, we slice the resulting string starting from index 2 (`[2:]`). Finally, the function returns the formatted string with \"db\" prepended and appended to the binary representation of the input decimal number.```\n\n"}
{"task_id": "CPP/155", "generation": "#include <stdio.h>\n#include <math.h>\n#include <string>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> even_odd_count(int num) {\n    // Convert number to string and remove any negative sign for processing\n    string digits = to_string(abs(num));\n    \n    int even_count = 0;\n    int odd_count = 0;\n    \n    // Iterate through each digit in the string representation of the number\n    for (char& c : digits) {\n        if ((c - '0') % 2 == 0) {\n            even_count += 1;\n        } else {\n            odd_count += 1;\n        }\n    }\n\n    return {even_count, odd_count};\n}\n", "py_code": "def even_odd_count(num):\n    # Convert number to string and remove any negative sign for processing\n    digits = str(abs(num))\n    \n    # Initialize counters for even and odd digits\n    even_count = 0\n    odd_count = 0\n    \n    # Iterate through each digit in the string representation of the number\n    for digit in digits:\n        if int(digit) % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n            \n    return [even_count, odd_count]\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `even_odd_count` takes an integer as input and returns a list containing two elements: the count of even digits and the count of odd digits in the given number.\n\n1. The function first converts the absolute value of the input number to its string representation to facilitate digit-wise processing.\n2. It initializes counters for even (`even_count`) and odd (`odd_count`) digits, both set to zero initially.\n3. The function then iterates over each character (digit) in this string representation:\n   - If the integer value of a digit is divisible by 2 with no remainder (i.e., it's an even number), `even_count` is incremented.\n   - Otherwise, `odd_count` is incremented.\n4. Finally, the function returns a list containing the counts of even and odd digits.\n\nThis approach ensures that all digits are processed individually, and their parity is determined to update the respective counters accordingly.\n\n"}
{"task_id": "CPP/4", "generation": "#include <vector>\n#include <cmath>\n#include <numeric> // for std::accumulate\n\nusing namespace std;\n\nfloat mean_absolute_deviation(vector<float> numbers) {\n    float n = numbers.size();\n    float sum = accumulate(numbers.begin(), numbers.end(), 0.0);\n    float mean_value = sum / n;\n    \n    float total_abs_diff = 0.0;\n    for (auto x : numbers) {\n        total_abs_diff += std::abs(x - mean_value);\n    }\n    \n    return total_abs_diff / n;\n}\n", "py_code": "from typing import List\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    n = len(numbers)\n    mean_value = sum(numbers) / n\n    mad = sum(abs(x - mean_value) for x in numbers) / n\n    return mad\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `mean_absolute_deviation` calculates the Mean Absolute Deviation (MAD) of a list of numbers. The MAD is defined as the average absolute difference between each element and the mean of the dataset.\n\n1. First, it determines the length of the input list (`n`).\n2. It then computes the mean value by summing all elements in the list and dividing by `n`.\n3. Next, it calculates the total absolute deviation from the mean for all elements.\n4. Finally, it returns the average of these absolute deviations as the MAD.\n\nThis approach ensures that the function accurately computes the MAD according to its definition.```\n\n"}
{"task_id": "CPP/56", "generation": "#include <string>\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    int balance = 0;\n    for (char c : brackets) { // Renamed 'char' to 'c'\n        if (c == '<') {       // Updated variable name here\n            balance += 1;\n        } else if (c == '>') { // Updated variable name here\n            balance -= 1;\n        }\n        if (balance < 0) {\n            return false;\n        }\n    }\n    return balance == 0;\n}\n", "py_code": "def correct_bracketing(brackets):\n    balance = 0\n    for char in brackets:\n        if char == '<':\n            balance += 1\n        elif char == '>':\n            balance -= 1\n        if balance < 0:\n            return False\n    return balance == 0\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `correct_bracketing` checks whether a string of '<' and '>' brackets is correctly balanced. The function iterates over each character in the input string `brackets`. It maintains a balance counter that increments when an opening bracket ('<') is encountered and decrements when a closing bracket ('>') is found.\n\nIf at any point during this iteration, the balance becomes negative (`balance < 0`), it means there's a closing bracket without a corresponding opening bracket, so the function returns `False`. After iterating through all characters in the string, if the final value of `balance` is zero, then every opening bracket has been matched with a closing one and the function returns `True`.\n\n"}
{"task_id": "CPP/159", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm> // for std::min and std::max\n\nusing namespace std;\n\nvector<int> eat(int number, int need, int remaining) {\n    int total_eaten = number + min(need, remaining);\n    int left_over = max(0, remaining - need);\n    return {total_eaten, left_over};\n}\n", "py_code": "def eat(number, need, remaining):\n    total_eaten = number + min(need, remaining)\n    left_over = max(0, remaining - need)\n    return [total_eaten, left_over]\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `eat` takes three parameters: `number`, `need`, and `remaining`. The function calculates how many carrots a rabbit will eat in total after its meals and how many carrots are left over.\n\n- `total_eaten`: This is calculated by adding the number of carrots already eaten (`number`) to the minimum between the number of carrots needed (`need`) and the remaining carrots available (`remaining`). If there aren't enough remaining carrots, it eats all that are available.\n  \n- `left_over`: This represents the number of carrots left after eating. It is calculated as the maximum between 0 and the difference between the remaining carrots and the need for more carrots.\n\nThe function returns a list containing these two values: `[total_eaten, left_over]`. If there aren't enough remaining carrots to satisfy `need`, it eats all available ones, but still indicates how many were needed in total.```\n\n"}
{"task_id": "CPP/83", "generation": "#include <cmath> // For pow function\n\nint starts_one_ends(int n) {\n    if (n == 1) {\n        return 1;\n    }\n    long long start_with_1 = static_cast<long long>(pow(10, n - 1));\n    long long end_with_1_not_start_with_1 = 9 * static_cast<long long>(pow(10, n - 2));\n    \n    // Total count is the sum of numbers starting with '1' and ending with '1', minus those that start and end with '1'\n    return static_cast<int>(start_with_1 + end_with_1_not_start_with_1);\n}\n", "py_code": "def starts_one_ends(n):\n    if n == 1:\n        return 1\n    # For a number with n digits, there are two cases: \n    # 1) Numbers starting with 1 (10^(n-1))\n    # 2) Numbers ending with 1 but not starting with 1 (9 * 10^(n-2))\n    return 2 * (10 ** (n - 1)) - 9 ** (n - 1)\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `starts_one_ends(n)` calculates and returns the count of n-digit positive integers that start or end with the digit '1'. The logic is as follows:\n\n- If `n` equals 1, there's only one such number (the number 1 itself), so it directly returns 1.\n- For numbers with more than one digit (`n > 1`):\n    - There are \\(10^{(n-1)}\\) n-digit numbers that start with '1'.\n    - Additionally, for numbers ending in '1', we exclude those starting with '1' to avoid double counting. This gives us \\(9 \\times 10^{(n-2)}\\) possibilities (since the first digit can be anything but '1').\n    \nThe formula `2 * (10 ** (n - 1)) - 9 ** (n - 1)` is used to calculate these counts, where:\n    - `2 * (10 ** (n - 1))` accounts for both starting and ending with '1'.\n    - Subtracting `9 ** (n - 1)` corrects the overcount of numbers that start and end with '1'.\n\nThe function then returns this calculated count.```\n\n"}
{"task_id": "CPP/27", "generation": "#include <cctype> // for isupper(), toupper(), and tolower() functions\n#include <string>\nusing namespace std;\n\nstring flip_case(string str) {\n    string result = \"\";\n    for (char c : str) {\n        if (isupper(c)) {\n            result += tolower(c);\n        } else {\n            result += toupper(c);\n        }\n    }\n    return result;\n}\n", "py_code": "def flip_case(s):\n    return ''.join(c.lower() if c.isupper() else c.upper() for c in s)\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `flip_case` takes a string as input and returns a new string where each character's case is flipped. Specifically, if a character in the original string is uppercase, it becomes lowercase in the returned string, and vice versa. The function uses a generator expression within the `join()` method to iterate over each character of the input string. For each character, it checks whether the character is uppercase using the `isupper()` method; if so, it converts it to lowercase with `lower()`. If the character is not uppercase (meaning it's either lowercase or non-alphabetic), it uses `upper()` to convert it to uppercase. The resulting characters are then concatenated into a new string and returned.```\n\n"}
{"task_id": "CPP/146", "generation": "#include <vector>\n#include <string>\n#include <cmath>\nusing namespace std;\n\nbool isFirstAndLastDigitOdd(int num) {\n    string strNum = to_string(abs(num));\n    int firstDigit = strNum[0] - '0';\n    int lastDigit = strNum[strNum.length() - 1] - '0';\n    return (firstDigit % 2 != 0 && lastDigit % 2 != 0);\n}\n\nint specialFilter(vector<int> nums) {\n    int count = 0;\n    for (int num : nums) {\n        if (num > 10 && isFirstAndLastDigitOdd(num)) {\n            count++;\n        }\n    }\n    return count;\n}\n", "py_code": "def specialFilter(nums):\n    count = 0\n    for num in nums:\n        if num > 10 and int(str(abs(num))[0]) % 2 != 0 and int(str(abs(num))[-1]) % 2 != 0:\n            count += 1\n    return count\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `specialFilter` takes a list of integers (`nums`) as input and returns an integer representing the number of elements in the list that satisfy two conditions:\n1. The element is greater than 10.\n2. Both the first and last digits of the element are odd (i.e., 1, 3, 5, 7, or 9).\n\nThe function iterates through each number (`num`) in `nums`. For each number, it checks if the number is greater than 10. If so, it converts the absolute value of the number to a string and extracts its first and last digits by indexing into the string representation. It then checks whether both these digits are odd (i.e., not divisible by 2). If all conditions are met, it increments the `count` variable.\n\nFinally, the function returns the count of numbers that satisfy the given conditions.\n\n"}
{"task_id": "CPP/81", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> numerical_letter_grade(vector<float> grades) {\n    vector<string> letter_grades;\n    \n    for (float gpa : grades) {\n        if (gpa == 4.0) {\n            letter_grades.push_back(\"A+\");\n        } else if (gpa > 3.7) {\n            letter_grades.push_back(\"A\");\n        } else if (gpa > 3.3) {\n            letter_grades.push_back(\"A-\");\n        } else if (gpa > 3.0) {\n            letter_grades.push_back(\"B+\");\n        } else if (gpa > 2.7) {\n            letter_grades.push_back(\"B\");\n        } else if (gpa > 2.3) {\n            letter_grades.push_back(\"B-\");\n        } else if (gpa > 2.0) {\n            letter_grades.push_back(\"C+\");\n        } else if (gpa > 1.7) {\n            letter_grades.push_back(\"C\");\n        } else if (gpa > 1.3) {\n            letter_grades.push_back(\"C-\");\n        } else if (gpa > 1.0) {\n            letter_grades.push_back(\"D+\");\n        } else if (gpa > 0.7) {\n            letter_grades.push_back(\"D\");\n        } else if (gpa > 0.0) {\n            letter_grades.push_back(\"D-\");\n        } else {\n            letter_grades.push_back(\"E\");\n        }\n    }\n\n    return letter_grades;\n}\n", "py_code": "from typing import List\n\ndef grade_equation(grades: List[float]) -> List[str]:\n    letter_grades = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grades.append(\"A+\")\n        elif gpa > 3.7:\n            letter_grades.append(\"A\")\n        elif gpa > 3.3:\n            letter_grades.append(\"A-\")\n        elif gpa > 3.0:\n            letter_grades.append(\"B+\")\n        elif gpa > 2.7:\n            letter_grades.append(\"B\")\n        elif gpa > 2.3:\n            letter_grades.append(\"B-\")\n        elif gpa > 2.0:\n            letter_grades.append(\"C+\")\n        elif gpa > 1.7:\n            letter_grades.append(\"C\")\n        elif gpa > 1.3:\n            letter_grades.append(\"C-\")\n        elif gpa > 1.0:\n            letter_grades.append(\"D+\")\n        elif gpa > 0.7:\n            letter_grades.append(\"D\")\n        elif gpa > 0.0:\n            letter_grades.append(\"D-\")\n        else:\n            letter_grades.append(\"E\")\n    return letter_grades\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `grade_equation` takes a list of GPAs as input and returns a list of corresponding letter grades based on the provided grading scale. The function iterates through each GPA in the input list and uses a series of conditional statements to determine the appropriate letter grade for that GPA.\n\n- If the GPA is exactly 4.0, it assigns an \"A+\".\n- For GPAs greater than specific thresholds (e.g., >3.7), it assigns grades such as \"A\", \"B+\", etc.\n- The function continues with these conditional checks until all possible ranges are covered.\n- Finally, if the GPA is less than or equal to 0.0, it assigns an \"E\".\n\nThe resulting letter grades are collected in a list and returned at the end of the function.\n\n"}
{"task_id": "CPP/136", "generation": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> largest_smallest_integers(vector<int> lst) {\n    int max_negative = INT_MIN; // Initialize to the smallest possible integer value.\n    int min_positive = INT_MAX; // Initialize to the largest possible integer value.\n\n    for (int num : lst) {\n        if (num < 0 && num > max_negative) {\n            max_negative = num;\n        } else if (num > 0 && num < min_positive) {\n            min_positive = num;\n        }\n    }\n\n    // If no negative or positive integers were found, return them as 0.\n    if (max_negative == INT_MIN) max_negative = 0;\n    if (min_positive == INT_MAX) min_positive = 0;\n\n    return {max_negative, min_positive};\n}\n", "py_code": "def largest_smallest_integers(lst):\n    max_negative = float('-inf')\n    min_positive = float('inf')\n\n    for num in lst:\n        if num < 0 and num > max_negative:\n            max_negative = num\n        elif num > 0 and num < min_positive:\n            min_positive = num\n\n    return [max_negative if max_negative != float('-inf') else 0, \n            min_positive if min_positive != float('inf') else 0]\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `largest_smallest_integers` takes a list of integers as input and returns a tuple containing two values: the largest negative integer and the smallest positive integer from the list. If there are no negative or positive integers in the list, it returns 0 for those respective positions.\n\n1. The function initializes `max_negative` to negative infinity (`float('-inf')`) and `min_positive` to positive infinity (`float('inf')`). These variables will be used to track the largest negative integer and the smallest positive integer found during iteration.\n2. It then iterates through each number in the input list:\n   - If a number is less than 0 (negative) and greater than the current `max_negative`, it updates `max_negative`.\n   - If a number is greater than 0 (positive) and smaller than the current `min_positive`, it updates `min_positive`.\n3. After iterating through all numbers, the function checks if `max_negative` or `min_positive` were updated from their initial values:\n   - If not, it means there were no negative or positive integers in the list, so it returns 0 for those positions.\n4. Finally, it returns a list containing the largest negative integer and the smallest positive integer found.\n\nThis approach ensures that if there are no negative or positive numbers, the function correctly returns 0 for those values.```\n\n"}
{"task_id": "CPP/67", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\nusing namespace std;\n\nint fruit_distribution(string s, int n) {\n    stringstream ss(s);\n    string word;\n    int apples = 0, oranges = 0;\n    \n    // Extracting numbers from the string using stringstream and parsing integers\n    while (ss >> word) {\n        if (word == \"apples\" || word == \"oranges\") {\n            ss >> word; // Skip \"and\"\n            continue;\n        }\n        \n        int num;\n        stringstream convert(word);\n        if (!(convert >> num)) { \n            continue;  // If conversion fails, skip\n        }\n\n        if (ss.peek() == 'a') { // Check next character to determine fruit type\n            apples = num;\n        } else {\n            oranges = num;\n        }\n    }\n    \n    // Calculating mangoes by subtracting apples and oranges from total fruits\n    int mango_count = n - (apples + oranges);\n    return mango_count;\n}\n", "py_code": "def fruit_distribution(s: str, n: int) -> int:\n    # Extracting numbers from the string using split and list comprehension\n    nums = [int(word) for word in s.split() if word.isdigit()]\n    # Calculating mangoes by subtracting apples and oranges from total fruits\n    mango_count = n - sum(nums)\n    return mango_count\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `fruit_distribution` takes a string `s` and an integer `n`. The string `s` contains information about the number of apples and oranges in the format \"X apples and Y oranges\". The goal is to determine how many mangoes are in the basket given that there are `n` total fruits.\n\nThe function first uses list comprehension along with the `split()` method to extract all digits from the string, which represent the numbers of apples and oranges. It then calculates the number of mangoes by subtracting the sum of these extracted numbers (apples + oranges) from the total number of fruits (`n`). Finally, it returns the calculated count of mangoes.\n\nThis approach ensures that we correctly parse the input string to find out how many apples and oranges are present and use this information to determine the remaining quantity of mangoes.```\n\n\n"}
{"task_id": "CPP/48", "generation": "#include <string>\nusing namespace std;\n\nbool is_palindrome(string text) {\n    int left = 0;\n    int right = text.size() - 1;\n    \n    while (left < right) {\n        if (text[left] != text[right]) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n    return true;\n}\n", "py_code": "def is_palindrome(text):\n    return text == text[::-1]\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `is_palindrome` checks whether a given string `text` is a palindrome. A palindrome is a word, phrase, or sequence of characters that reads the same backward as forward (ignoring spaces, punctuation, and capitalization). The function simply compares the original string with its reversed version (`text[::-1]`). If both are equal, it returns `True`, indicating that the string is a palindrome; otherwise, it returns `False`.```\n\n"}
{"task_id": "CPP/125", "generation": "#include <vector>\n#include <string>\n#include <sstream>\nusing namespace std;\n\n// Helper function to split string by delimiter\nvector<string> split(const string &s, char delim) {\n    stringstream ss(s);\n    string item;\n    vector<string> tokens;\n    while (getline(ss, item, delim)) {\n        tokens.push_back(item);\n    }\n    return tokens;\n}\n\nvector<string> split_words(string txt){\n    if (txt.find(' ') != string::npos) {\n        return split(txt, ' ');\n    } else if (txt.find(',') != string::npos) {\n        return split(txt, ',');\n    } else {\n        int count = 0;\n        for (char c : txt) {\n            if ((c - 'a') % 2 == 1 && islower(c)) {\n                ++count;\n            }\n        }\n        return {to_string(count)};\n    }\n}\n", "py_code": "def split_words(txt):\n    if ' ' in txt:\n        return txt.split(' ')\n    elif ',' in txt:\n        return txt.split(',')\n    else:\n        count = sum(1 for c in txt if (ord(c) - ord('a')) % 2 == 0)\n        return [str(count)]\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `split_words` takes a string `txt` as input and returns a list of strings based on specific conditions. If there is at least one whitespace character in the string, it splits the string by whitespaces using `split(' ')`. If no whitespaces are found but commas exist, it splits the string by commas using `split(',')`. In cases where neither whitespaces nor commas are present, the function counts the number of lowercase letters with even order positions in the alphabet (where 'a' is considered to have an order position of 0). It then returns a list containing this count as a single-element list. The function uses the `ord` function to determine the alphabetical order and checks if it's even using modulo operation.\n```\n\n"}
{"task_id": "CPP/160", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nint do_algebra(vector<string> operators, vector<int> operands) {\n    int result = operands[0];\n    \n    for (size_t i = 0; i < operators.size(); ++i) {\n        if (operators[i] == \"+\") {\n            result += operands[i + 1];\n        } else if (operators[i] == \"-\") {\n            result -= operands[i + 1];\n        } else if (operators[i] == \"*\") {\n            result *= operands[i + 1];\n        } else if (operators[i] == \"//\") {\n            result /= operands[i + 1]; // Floor division in C++\n        } else if (operators[i] == \"**\") {\n            result = pow(result, operands[i + 1]);\n        }\n    }\n\n    return result;\n}\n", "py_code": "from typing import List\n\ndef do_algebra(operators: List[str], operands: List[int]) -> int:\n    expression = str(operands[0])\n    \n    for i in range(len(operators)):\n        operator = operators[i]\n        operand = operands[i + 1]\n\n        if operator == \"//\":\n            expression += f\" // {operand}\"\n        elif operator == \"**\":\n            expression += f\" ** {operand}\"\n        else:\n            expression += f\" {operator} {operand}\"\n\n    return eval(expression)\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `do_algebra` takes two lists as input: `operators`, which contains strings representing algebraic operations, and `operands`, a list of integers to be used in those operations.\n\n1. The function starts by initializing an empty string `expression` with the first operand.\n2. It then iterates over each operator in the `operators` list:\n   - For each operator, it checks if the operator is \"//\" (floor division) or \"**\" (exponentiation), and appends the corresponding operation to the expression string.\n   - If the operator is not one of these special cases, it assumes a standard arithmetic operation (+, -, *) and appends that to the `expression` string along with the next operand from the `operands` list.\n3. After constructing the full algebraic expression as a string, the function uses Python's built-in `eval()` function to evaluate the constructed expression and return its result.\n\nThis approach builds an algebraic expression dynamically based on the provided operators and operands and evaluates it using Python's powerful eval() function.\n\n"}
{"task_id": "CPP/151", "generation": "#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nlong long double_the_difference(vector<float> lst) {\n    long long sum = 0;\n    for (float x : lst) {\n        if (x > 0 && floor(x) == x && static_cast<int>(x) % 2 != 0) {\n            sum += pow(x, 2);\n        }\n    }\n    return sum;\n}\n", "py_code": "from typing import List\n\ndef double_the_difference(lst: List[float]) -> int:\n    return sum(x**2 for x in lst if x > 0 and x == int(x) and x % 2 != 0)\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `double_the_difference` takes a list of floating-point numbers (`lst`) as input and returns an integer representing the sum of squares of all positive odd integers in the list.\n\n1. The function uses a generator expression inside the `sum()` function to iterate over each element `x` in the list.\n2. For each number, it checks if the number is greater than 0 (`x > 0`), an integer (`x == int(x)`), and odd (`x % 2 != 0`).\n3. If all conditions are met, the square of that number (`x**2`) is included in the sum.\n4. The `sum()` function then adds up these squares to produce the final result.\n\nThe function returns an integer value as required by the problem statement.\n\n"}
{"task_id": "CPP/117", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nint count_consonants(const string& word) {\n    const string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    int count = 0;\n    for (char c : word) {\n        if (consonants.find(c) != string::npos) {\n            ++count;\n        }\n    }\n    return count;\n}\n\nvector<string> select_words(string s, int n) {\n    vector<string> result;\n    string word;\n    stringstream ss(s);\n\n    while (ss >> word) {\n        if (count_consonants(word) == n) {\n            result.push_back(word);\n        }\n    }\n\n    return result;\n}\n", "py_code": "def select_words(s: str, n: int) -> list:\n    def count_consonants(word):\n        consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\n        return sum(1 for char in word if char in consonants)\n\n    words = s.split()\n    result = [word for word in words if count_consonants(word) == n]\n    return result\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `select_words` takes a string `s` and an integer `n`, and returns a list of words from `s` that contain exactly `n` consonants. The function first defines a nested helper function `count_consonants` which counts the number of consonants in a given word by iterating over each character and checking if it is part of a predefined string of consonants (both lowercase and uppercase). \n\nThe main function then splits the input string into individual words using the `split()` method. It iterates through these words, uses the helper function to count the number of consonants in each word, and checks if this count matches `n`. If it does, the word is added to the result list.\n\nFinally, the function returns the list of words that meet the criteria.```\n\n"}
{"task_id": "CPP/78", "generation": "#include <string>\n#include <set>\nusing namespace std;\n\nint hex_key(std::string num) {\n    // Define a set of prime hexadecimal digits.\n    std::set<char> prime_hex_digits = {'2', '3', '5', '7', 'B', 'D'};\n    \n    int count = 0;\n    for (char digit : num) {\n        if (prime_hex_digits.find(digit) != prime_hex_digits.end()) {\n            ++count;\n        }\n    }\n    return count;\n}\n", "py_code": "def hex_key(num):\n    prime_hex_digits = {'2', '3', '5', '7', 'B', 'D'}\n    return sum(1 for digit in num if digit in prime_hex_digits)\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `hex_key` takes a string `num`, which represents a hexadecimal number, and returns the count of digits that are considered prime in the hexadecimal system. The set `prime_hex_digits` contains the characters representing the prime numbers in hexadecimal notation ('2', '3', '5', '7', 'B', 'D'). \n\nThe function uses a generator expression within the `sum()` function to iterate over each digit in the input string and checks if it is present in the `prime_hex_digits` set. If the digit is found in the set, it contributes 1 to the sum; otherwise, it does not contribute anything. The final result is the total count of prime hexadecimal digits within the given number.\n```\n\n"}
{"task_id": "CPP/74", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> total_match(vector<string> lst1, vector<string> lst2) {\n    // Calculate the total number of characters in each list\n    int count_lst1 = 0;\n    for (const string& s : lst1) {\n        count_lst1 += s.length();\n    }\n\n    int count_lst2 = 0;\n    for (const string& s : lst2) {\n        count_lst2 += s.length();\n    }\n\n    // Compare and return the appropriate list based on character counts\n    if (count_lst1 <= count_lst2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n", "py_code": "def total_match(lst1, lst2):\n    # Calculate the total number of characters in each list\n    count_lst1 = sum(len(s) for s in lst1)\n    count_lst2 = sum(len(s) for s in lst2)\n\n    # Compare and return the appropriate list based on character counts\n    if count_lst1 <= count_lst2:\n        return lst1\n    else:\n        return lst2\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `total_match` takes two lists of strings (`lst1` and `lst2`) as input and returns one of these lists based on a comparison of their total number of characters.\n\n- The function first calculates the total number of characters in each list by summing up the lengths of all strings within each list.\n  - `count_lst1 = sum(len(s) for s in lst1)` computes the total character count for `lst1`.\n  - `count_lst2 = sum(len(s) for s in lst2)` does the same for `lst2`.\n\n- The function then compares these counts:\n  - If `count_lst1` is less than or equal to `count_lst2`, it returns `lst1`.\n  - Otherwise, it returns `lst2`.\n\nThis approach ensures that the list with fewer total characters is returned. In case both lists have an equal number of characters, the function prefers and returns `lst1`. \n\n"}
{"task_id": "CPP/53", "generation": "#include<stdio.h>\n#include<stdlib.h>\nusing namespace std;\n\nint add(int x, int y) {\n    return x + y;\n}\n", "py_code": "def add(x, y):\n    return x + y\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `add` takes two integer arguments `x` and `y`, and returns their sum. It simply uses the addition operator (`+`) to add the two numbers together and return the result. This is a straightforward implementation of an addition operation between two integers.\n```\n\n"}
{"task_id": "CPP/98", "generation": "#include <string>\n#include <algorithm>\nusing namespace std;\n\nint count_upper(string s) {\n    string vowels = \"AEIOU\";\n    int count = 0;\n    for (size_t i = 0; i < s.length(); i += 2) {\n        if (vowels.find(s[i]) != string::npos) {\n            ++count;\n        }\n    }\n    return count;\n}\n", "py_code": "def count_upper(s):\n    vowels = \"AEIOU\"\n    return sum(1 for i in range(len(s)) if i % 2 == 0 and s[i] in vowels)\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `count_upper` takes a string `s` as input and returns the count of uppercase vowels found at even indices within the string. The function first defines a string containing all uppercase vowels (\"AEIOU\"). It then uses a generator expression inside the `sum()` function to iterate over each character in the string by its index. For each even index (i.e., where `i % 2 == 0`), it checks if the character at that position is an uppercase vowel by verifying if it exists within the predefined vowels string. If both conditions are met, a count of 1 is added to the sum for every such occurrence. The final result is the total number of uppercase vowels found at even indices in the input string.\n```"}
{"task_id": "CPP/140", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring fix_spaces(string text) {\n    string result = \"\";\n    int space_count = 0;\n\n    for (char c : text) {\n        if (c == ' ') {\n            space_count++;\n        } else {\n            if (space_count == 1) {\n                result += '_';\n            } else if (space_count > 2) {\n                result += '-';\n            }\n            space_count = 0;\n            result += c;\n        }\n    }\n\n    if (space_count == 1) {\n        result += '_';\n    } else if (space_count > 2) {\n        result += '-';\n    }\n\n    return result;\n}\n", "py_code": "def fix_spaces(text):\n    result = []\n    space_count = 0\n    \n    for char in text:\n        if char == ' ':\n            space_count += 1\n        else:\n            if space_count == 1:\n                result.append('_')\n            elif space_count > 2:\n                result.append('-')\n            space_count = 0\n            result.append(char)\n    \n    if space_count == 1:\n        result.append('_')\n    elif space_count > 2:\n        result.append('-')\n\n    return ''.join(result)\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `fix_spaces` takes a string `text` as input and processes it to replace spaces according to specific rules: single spaces are replaced with underscores ('_'), and more than two consecutive spaces are replaced with a dash ('-'). The function works by iterating through each character in the input string. It maintains a count of consecutive spaces (`space_count`). \n\nIf a non-space character is encountered, it checks `space_count`:\n- If there was exactly one space before this character, an underscore ('_') is added to the result.\n- If there were more than two consecutive spaces, a dash ('-') is added.\n\nAfter processing all characters in the string, if any trailing spaces remain (i.e., at the end of the string), they are also replaced according to their count. Finally, the list `result` containing the processed characters and replacements is joined into a single string and returned as the output.\n\n"}
{"task_id": "CPP/34", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\n#include <set>\nusing namespace std;\n\nvector<int> unique(vector<int> l) {\n    set<int> s(l.begin(), l.end());\n    vector<int> result(s.begin(), s.end());\n    return result;\n}\n", "py_code": "def unique(l):\n    return sorted(set(l))\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `unique` takes a list of integers as input and returns a new list containing only the unique elements from the original list in sorted order. This is achieved by first converting the list to a set, which automatically removes any duplicate values since sets cannot contain duplicates. The set is then converted back into a list and sorted before being returned.```\n\n"}
{"task_id": "CPP/66", "generation": "#include <string>\nusing namespace std;\n\nint digitSum(string s) {\n    int sum = 0;\n    for (char c : s) {\n        if (isupper(c)) {\n            sum += static_cast<int>(c);\n        }\n    }\n    return sum;\n}\n", "py_code": "def digitSum(s):\n    return sum(ord(char) for char in s if char.isupper())\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `digitSum` takes a string as input and returns the sum of ASCII values of all uppercase characters within that string. The function uses a generator expression inside the `sum()` function to iterate over each character in the string. For each character, it checks if the character is an uppercase letter using the `isupper()` method. If true, it calculates the ASCII value of the character with the `ord()` function and adds it to the sum. The result is the total sum of ASCII values for all uppercase characters in the input string.``` \n\n"}
{"task_id": "CPP/120", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> maximum(vector<int> arr, int k) {\n    // Sort the array in descending order.\n    sort(arr.begin(), arr.end(), greater<int>());\n    \n    // Take the first k elements from the sorted array.\n    vector<int> max_k_elements(arr.begin(), arr.begin() + k);\n    \n    // Sort these k elements in ascending order before returning.\n    sort(max_k_elements.begin(), max_k_elements.end());\n    \n    return max_k_elements;\n}\n", "py_code": "from typing import List\n\ndef maximum(arr: List[int], k: int) -> List[int]:\n    # Sort the array in descending order and take the first k elements.\n    sorted_arr = sorted(arr, reverse=True)[:k]\n    # Return these elements in ascending order.\n    return sorted(sorted_arr)\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `maximum` takes a list of integers (`arr`) and an integer (`k`). The goal is to find the maximum k numbers in the array and return them in ascending order.\n\n1. First, it sorts the input list `arr` in descending order using the `sorted()` function with the `reverse=True` parameter.\n2. It then slices this sorted list to get only the first `k` elements which are the largest ones due to the reverse sorting.\n3. Finally, it returns these `k` maximum numbers by sorting them again but in ascending order.\n\nThis approach ensures that we get the k largest values from the array and return them in an ordered manner as required by the problem statement.```\n\n"}
{"task_id": "CPP/139", "generation": "#include <iostream>\nusing namespace std;\n\nlong long factorial(long long num) {\n    if (num == 0 || num == 1)\n        return 1;\n    else\n        return num * factorial(num - 1);\n}\n\nlong long special_factorial(int n) {\n    long long result = 1;\n    for (int i = 1; i <= n; ++i) {\n        result *= factorial(i);\n    }\n    return result;\n}\n", "py_code": "def factorial(num):\n    if num == 0 or num == 1:\n        return 1\n    else:\n        return num * factorial(num - 1)\n\ndef special_factorial(n):\n    result = 1\n    for i in range(1, n + 1):\n        result *= factorial(i)\n    return result\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python solution consists of two functions: `factorial` and `special_factorial`. The `factorial` function is a recursive function that calculates the factorial of a given number. It returns 1 if the input is either 0 or 1 (base case), otherwise it multiplies the input by the result of calling itself with the input decremented by one.\n\nThe `special_factorial` function computes the Brazilian factorial as defined in the problem statement, which involves multiplying factorials from n down to 1. It initializes a variable `result` to 1 and iterates through each integer i from 1 up to n (inclusive). For each iteration, it multiplies `result` by the factorial of i using the previously defined `factorial` function.\n\nFinally, the `special_factorial` function returns the computed result.```\n"}
{"task_id": "CPP/12", "generation": "#include <vector>\n#include <string>\n#include <optional>\nusing namespace std;\n\nstring longest(vector<string> strings) {\n    if (strings.empty()) {\n        return {}; // Return an empty string to represent None in C++\n    }\n    \n    int max_length = -1;\n    string result = \"\";\n    \n    for (const auto& s : strings) {\n        if (s.length() > max_length) {\n            max_length = s.length();\n            result = s;\n        }\n    }\n    \n    return result;\n}\n", "py_code": "def longest(strings):\n    if not strings:\n        return None\n    max_length = -1\n    result = \"\"\n    for s in strings:\n        if len(s) > max_length:\n            max_length = len(s)\n            result = s\n    return result\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `longest` takes a list of strings as input and returns the longest string from that list. If multiple strings have the same length (and it's the maximum), the first one encountered is returned. The function also handles an empty list by returning `None`.\n\nHere\u2019s how the function works:\n1. It checks if the input list `strings` is empty, and if so, returns `None`.\n2. It initializes two variables: `max_length` to keep track of the length of the longest string found so far (initialized to -1) and `result` to store the longest string.\n3. The function iterates over each string in the list:\n   - For each string, it checks if its length is greater than `max_length`.\n   - If it is, then `max_length` is updated with the new maximum length, and `result` is set to this current string.\n4. After iterating through all strings, the function returns `result`, which contains the longest string found.\n\nThis approach ensures that the first string of the maximum length encountered during iteration is returned if there are multiple strings with the same maximum length.\n\n"}
{"task_id": "CPP/121", "generation": "#include <vector>\nusing namespace std;\n\nint solution(vector<int> lst) {\n    int sum = 0;\n    for (size_t i = 0; i < lst.size(); i += 2) { // Iterate over even positions.\n        if (lst[i] % 2 != 0) { // Check if the element is odd.\n            sum += lst[i]; // Add to sum if conditions are met.\n        }\n    }\n    return sum;\n}\n", "py_code": "def solution(lst):\n    return sum(x for i, x in enumerate(lst) if i % 2 == 0 and x % 2 != 0)\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `solution` takes a list of integers as input and returns the sum of all odd elements that are located at even positions (considering 0-based indexing). The function uses a generator expression within the `sum()` function to iterate over the enumerated list. For each element in the list, it checks if its index is even (`i % 2 == 0`) and if the value itself is odd (`x % 2 != 0`). If both conditions are met, the value is included in the sum. The result of this summation is returned as the output.\n```"}
{"task_id": "CPP/35", "generation": "#include <vector>\n#include <algorithm> // for std::max_element\nusing namespace std;\n\nfloat max_element(vector<float> l) {\n    return *std::max_element(l.begin(), l.end());\n}\n", "py_code": "def max_element(l):\n    return max(l)\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `max_element` takes a list of numbers as input and returns the maximum element in that list using the built-in `max()` function. The `max()` function iterates through the elements of the list to find and return the largest value present.```\n\n"}
{"task_id": "CPP/20", "generation": "#include <algorithm>\n#include <vector>\nusing namespace std;\n\nvector<float> find_closest_elements(vector<float> numbers) {\n    // Sort the vector to ensure elements are in ascending order.\n    sort(numbers.begin(), numbers.end());\n\n    float min_diff = INFINITY;\n    vector<float> result(2);\n\n    for (size_t i = 0; i < numbers.size() - 1; ++i) {\n        float diff = numbers[i + 1] - numbers[i];\n        if (diff < min_diff) {\n            min_diff = diff;\n            result[0] = numbers[i];\n            result[1] = numbers[i + 1];\n        }\n    }\n\n    return result;\n}\n", "py_code": "from typing import List\n\ndef find_closest_elements(numbers: List[float]) -> tuple:\n    numbers.sort()\n    min_diff = float('inf')\n    result = (0, 0)\n    \n    for i in range(len(numbers) - 1):\n        diff = numbers[i + 1] - numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            result = (numbers[i], numbers[i + 1])\n            \n    return result\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `find_closest_elements` takes a list of floating-point numbers as input and returns a tuple containing the two closest elements from that list in ascending order.\n\n1. The function first sorts the list of numbers to ensure they are in ascending order.\n2. It initializes `min_diff` with positive infinity (`float('inf')`) to keep track of the minimum difference between any pair of adjacent elements found so far, and `result` as a tuple `(0, 0)` to store the closest pair.\n3. The function then iterates through the sorted list using a for loop from index `i = 0` to `len(numbers) - 2`. For each element at index `i`, it calculates the difference between that element and its next neighbor (`numbers[i + 1]`). \n4. If this calculated difference is smaller than the current minimum difference, it updates `min_diff` with the new value and sets `result` to be the pair `(numbers[i], numbers[i + 1])`.\n5. After completing the loop, the function returns the tuple `result`, which contains the two closest elements in ascending order.\n\nThis approach ensures that we find the two closest elements efficiently by leveraging sorting and a single pass through the sorted list.\n```\n\n"}
{"task_id": "CPP/19", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <vector>\n#include <algorithm>\n#include <map>\n\nusing namespace std;\n\nstring sort_numbers(string numbers) {\n    // Define a map to convert number words to their integer values.\n    map<string, int> numeral_map = {\n        {\"zero\", 0},\n        {\"one\", 1},\n        {\"two\", 2},\n        {\"three\", 3},\n        {\"four\", 4},\n        {\"five\", 5},\n        {\"six\", 6},\n        {\"seven\", 7},\n        {\"eight\", 8},\n        {\"nine\", 9}\n    };\n\n    // Split the input string into a vector of number words.\n    stringstream ss(numbers);\n    string word;\n    vector<string> num_list;\n    while (ss >> word) {\n        num_list.push_back(word);\n    }\n\n    // Convert each number word to its corresponding integer value and sort them.\n    vector<int> int_list;\n    for (const auto& num : num_list) {\n        int_list.push_back(numeral_map[num]);\n    }\n    sort(int_list.begin(), int_list.end());\n\n    // Convert back to the string representation and join them into a single string.\n    stringstream sorted_ss;\n    for (int i = 0; i < int_list.size(); ++i) {\n        if (i > 0) {\n            sorted_ss << \" \";\n        }\n        for (const auto& kv : numeral_map) {\n            if (kv.second == int_list[i]) {\n                sorted_ss << kv.first;\n                break;\n            }\n        }\n    }\n\n    return sorted_ss.str();\n}\n", "py_code": "def sort_numbers(numbers):\n    numeral_map = {\n        \"zero\": 0,\n        \"one\": 1,\n        \"two\": 2,\n        \"three\": 3,\n        \"four\": 4,\n        \"five\": 5,\n        \"six\": 6,\n        \"seven\": 7,\n        \"eight\": 8,\n        \"nine\": 9\n    }\n    \n    # Split the input string into a list of numerals.\n    num_list = numbers.split()\n    \n    # Convert each numeral to its corresponding integer value using the map.\n    int_list = [numeral_map[num] for num in num_list]\n    \n    # Sort the integers.\n    int_list.sort()\n    \n    # Convert back to the string representation and join them into a single string.\n    sorted_numbers = ' '.join([k for k, v in numeral_map.items() if v in int_list])\n    \n    return sorted_numbers\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `sort_numbers` takes a space-delimited string of number words (from \"zero\" to \"nine\") and returns them in sorted order as a single string.\n\n1. A dictionary (`numeral_map`) is defined that maps each word representation (\"zero\", \"one\", etc.) to its corresponding integer value.\n2. The input string `numbers` is split into individual words using the `split()` method, resulting in a list of number words.\n3. Each word in this list is converted to its corresponding integer value by looking up the dictionary (`numeral_map`). This results in an intermediate list of integers.\n4. The list of integers is then sorted in ascending order.\n5. Finally, each integer in the sorted list is mapped back to its string representation using a comprehension that iterates over the items in `numeral_map` and checks if the value matches any item in the sorted list of integers. These strings are joined into a single space-delimited string which is returned as the output.\n\nThis approach ensures that the number words are correctly converted, sorted by their numeric values, and then transformed back to their word forms for the final output.\n```\n\n"}
{"task_id": "CPP/85", "generation": "#include <vector>\nusing namespace std;\n\nint add(vector<int> lst) {\n    int total = 0;\n    for (size_t i = 1; i < lst.size(); i += 2) { // Start from index 1 and increment by 2 (odd indices)\n        if (lst[i] % 2 == 0) {                   // Check if the element at odd index is even\n            total += lst[i];\n        }\n    }\n    return total;\n}\n", "py_code": "def add(lst):\n    total = 0\n    for i in range(1, len(lst), 2): # Start from index 1 and increment by 2 (odd indices)\n        if lst[i] % 2 == 0:          # Check if the element at odd index is even\n            total += lst[i]\n    return total\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `add` takes a list of integers as input and returns the sum of all even elements that are located at odd indices in the list. The function initializes a variable `total` to zero which will hold the cumulative sum of the targeted elements.\n\nA for loop is used with a step size of 2, starting from index 1 (the second element) to ensure only odd indices are considered. Within this loop, each element at an odd index is checked if it's even using the modulo operator (`%`). If the condition is met, the value of that element is added to `total`. After iterating through all elements in the list, the function returns the final sum stored in `total`.\n``` \n\n"}
{"task_id": "CPP/21", "generation": "#include <stdio.h>\n#include <math.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<float> rescale_to_unit(vector<float> numbers) {\n    float min_val = *min_element(numbers.begin(), numbers.end());\n    float max_val = *max_element(numbers.begin(), numbers.end());\n    float range_val = max_val - min_val;\n    \n    vector<float> result;\n    for (float x : numbers) {\n        result.push_back((x - min_val) / range_val);\n    }\n    return result;\n}\n", "py_code": "from typing import List\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    min_val = min(numbers)\n    max_val = max(numbers)\n    range_val = max_val - min_val\n    return [(x - min_val) / range_val for x in numbers]\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `rescale_to_unit` takes a list of floating-point numbers as input and returns a new list where each number is rescaled such that the smallest number in the original list becomes 0 and the largest becomes 1. The function first calculates the minimum (`min_val`) and maximum (`max_val`) values from the input list. It then computes the range of these values (`range_val`). \n\nFor each element `x` in the input list, it applies a linear transformation to rescale the value: `(x - min_val) / range_val`. This formula ensures that the smallest number is mapped to 0 and the largest to 1, with all other numbers scaled proportionally between these two values. The function returns this transformed list of numbers.\n```\n\n"}
{"task_id": "CPP/119", "generation": "#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nbool is_balanced(const string& s) {\n    int balance = 0;\n    for (char c : s) {\n        if (c == '(') {\n            ++balance;\n        } else {\n            --balance;\n            if (balance < 0) {\n                return false; // More closing parentheses before an opening one\n            }\n        }\n    }\n    return balance == 0; // All parentheses are balanced\n}\n\nstring match_parens(vector<string> lst) {\n    string first_concat = lst[0] + lst[1];\n    string second_concat = lst[1] + lst[0];\n\n    if (is_balanced(first_concat) || is_balanced(second_concat)) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\n", "py_code": "def match_parens(lst):\n    def is_balanced(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            else:\n                balance -= 1\n                if balance < 0:\n                    return False\n        return balance == 0\n\n    # Check both possible concatenations of the two strings\n    first_concat = lst[0] + lst[1]\n    second_concat = lst[1] + lst[0]\n\n    if is_balanced(first_concat) or is_balanced(second_concat):\n        return \"Yes\"\n    else:\n        return \"No\"\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `match_parens` takes a list of two strings (`lst`) as input and checks if it is possible to concatenate these strings in some order such that the resulting string has balanced parentheses.\n\n1. **Helper Function**: The helper function `is_balanced(s)` determines whether a given string `s` has balanced parentheses by maintaining a balance counter. It increments the counter for an opening parenthesis '(' and decrements it for a closing parenthesis ')'. If at any point the balance becomes negative, it means there are more closing parentheses than opening ones before that point, so the function returns `False`. The function also checks if the final balance is zero to ensure all parentheses are balanced.\n\n2. **Concatenation Check**: The main function concatenates the two strings in both possible orders (`first_concat` and `second_concat`) and uses the helper function `is_balanced()` to check if either of these concatenated strings has balanced parentheses.\n\n3. **Return Value**: If any of the concatenated strings is balanced, the function returns `\"Yes\"`. Otherwise, it returns `\"No\"`.\n\n"}
{"task_id": "CPP/30", "generation": "#include <stdio.h>\n#include <math.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<float> get_positive(vector<float> l) {\n    vector<float> result;\n    for (float num : l) {\n        if (num > 0) {\n            result.push_back(num);\n        }\n    }\n    return result;\n}\n", "py_code": "def get_positive(l):\n    return [x for x in l if x > 0]\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python code defines a function `get_positive` that takes a list of numbers (`l`) as input and returns a new list containing only the positive numbers from the original list. This is achieved using a list comprehension which iterates over each element in the input list and includes it in the output list if it is greater than zero (i.e., positive).```\n\n"}
{"task_id": "CPP/64", "generation": "#include <string>\n#include <algorithm>\nusing namespace std;\n\nbool is_vowel(char c) {\n    return c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' ||\n           c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U';\n}\n\nint vowels_count(string s) {\n    int count = 0;\n    for (char c : s) {\n        if (is_vowel(c)) {\n            ++count;\n        }\n    }\n\n    // Check if the last character is a vowel 'y' or 'Y'\n    if (!s.empty() && (s.back() == 'y' || s.back() == 'Y')) {\n        ++count;\n    }\n\n    return count;\n}\n", "py_code": "def vowels_count(s):\n    vowels = \"aeiouAEIOU\"\n    count = sum(1 for char in s if char in vowels)\n    # Check if last character is 'y' or 'Y'\n    if s and (s[-1] == 'y' or s[-1] == 'Y'):\n        count += 1\n    return count\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `vowels_count` takes a string as input and returns the number of vowels in that string. The vowels considered are 'a', 'e', 'i', 'o', 'u' (both lowercase and uppercase). Additionally, if the last character of the string is 'y' or 'Y', it is also counted as a vowel.\n\nThe function first defines a string `vowels` containing all the vowels in both lowercase and uppercase. It then uses a generator expression within the `sum()` function to count how many characters in the input string are present in the `vowels` string. After counting the standard vowels, it checks if the last character of the string is 'y' or 'Y'. If so, it increments the vowel count by one.\n\nFinally, the function returns the total count of vowels found in the string.\n```\n\n"}
{"task_id": "CPP/128", "generation": "#include <vector>\n#include <cmath>\n\nint prod_signs(std::vector<int> arr) {\n    if (arr.empty()) {\n        return -32768;\n    }\n\n    int magnitude_sum = 0;\n    int sign_product = 1;\n\n    for (const auto& num : arr) {\n        magnitude_sum += std::abs(num);\n        if (num < 0) {\n            sign_product *= -1;\n        } else if (num == 0) {\n            sign_product = 0;\n            break;\n        }\n    }\n\n    return magnitude_sum * sign_product;\n}\n", "py_code": "from typing import List\n\ndef prod_signs(arr: List[int]) -> int:\n    if not arr:\n        return -32768\n    \n    magnitude_sum = 0\n    sign_product = 1\n    \n    for num in arr:\n        magnitude_sum += abs(num)\n        if num < 0:\n            sign_product *= -1\n        elif num == 0:\n            sign_product = 0\n            break\n            \n    return magnitude_sum * sign_product\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `prod_signs` takes a list of integers (`arr`) as input and returns an integer value based on specific conditions. The function first checks if the input list is empty; if it is, it immediately returns `-32768`. If not, it initializes two variables: `magnitude_sum`, which accumulates the sum of absolute values (magnitudes) of the integers in the list, and `sign_product`, which keeps track of the product of signs for each number.\n\nThe function then iterates through each integer (`num`) in the input list. For each integer:\n- It adds the absolute value of `num` to `magnitude_sum`.\n- If `num` is negative, it multiplies `sign_product` by `-1`, effectively updating the sign product.\n- If `num` equals zero, it sets `sign_product` to 0 and breaks out of the loop since any multiplication with zero will result in zero.\n\nFinally, the function returns the product of `magnitude_sum` and `sign_product`.\n\n"}
{"task_id": "CPP/127", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int n) {\n    if (n <= 1)\n        return false;\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0)\n            return false;\n    }\n    return true;\n}\n\n// Function to determine whether the length of intersection is a prime number\nstring intersection(vector<int> interval1, vector<int> interval2) {\n    int start_max = max(interval1[0], interval2[0]);\n    int end_min = min(interval1[1], interval2[1]);\n\n    // Check if there's an overlap between the intervals\n    if (start_max > end_min)\n        return \"NO\";\n\n    // Calculate the length of intersection\n    int length_of_intersection = end_min - start_max + 1;\n\n    // Check if the length is a prime number\n    if (is_prime(length_of_intersection))\n        return \"YES\";\n    else\n        return \"NO\";\n}\n\n", "py_code": "def is_prime(n):\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef intersection(interval1, interval2):\n    start_max = max(interval1[0], interval2[0])\n    end_min = min(interval1[1], interval2[1])\n\n    # Check for no intersection\n    if start_max > end_min:\n        return \"NO\"\n\n    length_of_intersection = end_min - start_max + 1\n\n    if is_prime(length_of_intersection):\n        return \"YES\"\n    else:\n        return \"NO\"\n```\n\n", "py_summary": "### Second Step: Analyse the Python Code\n\nThe provided Python solution consists of two functions:\n\n1. `is_prime(n)`: This function checks whether a given number `n` is prime or not.\n   - It first checks if `n` is less than or equal to 1, in which case it returns `False`.\n   - Then, it iterates from 2 up to the square root of `n`, checking if any number divides `n`. If a divisor is found, it returns `False`; otherwise, it returns `True`.\n\n2. `intersection(interval1, interval2)`: This function determines whether the length of intersection between two intervals is a prime number.\n   - It calculates the maximum start point (`start_max`) and minimum end point (`end_min`) to determine if there's an overlap between the intervals.\n   - If `start_max` is greater than `end_min`, it means that the intervals do not intersect, so the function returns `\"NO\"`.\n   - Otherwise, it computes the length of intersection as `end_min - start_max + 1`. It then checks whether this length is a prime number using the `is_prime` function.\n   - If the length is prime, it returns `\"YES\"`, otherwise it returns `\"NO\"`.\n\n"}
{"task_id": "CPP/122", "generation": "#include <vector>\nusing namespace std;\n\nint add_elements(vector<int> arr, int k) {\n    int sum = 0;\n    for (int i = 0; i < k; ++i) {\n        if (arr[i] >= -99 && arr[i] <= 99) {\n            sum += arr[i];\n        }\n    }\n    return sum;\n}\n", "py_code": "def add_elements(arr, k):\n    return sum(x for x in arr[:k] if -100 < x < 100)\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `add_elements` takes a list of integers (`arr`) and an integer (`k`). It returns the sum of elements from the first `k` elements in the array that have at most two digits (i.e., their absolute value is less than 100). The function uses a generator expression within the `sum()` function to iterate over the first `k` elements of the list and filter out those with more than two digits. It then calculates the sum of the filtered elements and returns it.\n```\n\n"}
{"task_id": "CPP/59", "generation": "#include <iostream>\nusing namespace std;\n\nint largest_prime_factor(int n) {\n    int i = 2;\n    while (i * i <= n) {\n        if (n % i != 0) {\n            i += 1;\n        } else {\n            n /= i;\n        }\n    }\n    return n;\n}\n", "py_code": "def largest_prime_factor(n):\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `largest_prime_factor` is designed to find and return the largest prime factor of a given integer `n`. The algorithm works as follows:\n1. Initialize a variable `i` with 2, which is the smallest prime number.\n2. Use a while loop that continues until `i * i` exceeds `n`.\n3. Inside the loop, check if `n` is divisible by `i` using the modulus operator (`%`). If it's not divisible (i.e., `n % i != 0`), increment `i` to test the next potential factor.\n4. If `n` is divisible by `i`, divide `n` by `i` and update `n` with the result of this division, effectively removing that prime factor from `n`.\n5. The loop continues until no further factors are found within the range up to the square root of `n`. At this point, if there's any remaining value in `n`, it must be a prime number greater than or equal to `i` and is thus the largest prime factor.\n\nThe function returns `n` as the result since by the end of the loop, `n` will hold the largest prime factor.\n"}
{"task_id": "CPP/134", "generation": "#include <string>\nusing namespace std;\n\nbool check_if_last_char_is_a_letter(string txt) {\n    if (txt.empty() || (!txt.empty() && txt.back() == ' '))\n        return false;\n    \n    string stripped_txt = txt;\n    // Remove trailing spaces\n    while (!stripped_txt.empty() && stripped_txt.back() == ' ') {\n        stripped_txt.pop_back();\n    }\n    \n    char last_char = stripped_txt.back();\n    bool is_last_char_alphabetic = isalpha(last_char);\n    bool is_preceded_by_space_or_single_char = (stripped_txt.size() > 1 && stripped_txt[stripped_txt.size() - 2] == ' ') || stripped_txt.size() == 1;\n    \n    return is_last_char_alphabetic && is_preceded_by_space_or_single_char;\n}\n", "py_code": "def check_if_last_char_is_a_letter(txt):\n    if not txt or (len(txt) > 0 and txt[-1] == ' '): \n        return False\n    stripped_txt = txt.rstrip()\n    last_char = stripped_txt[-1]\n    return last_char.isalpha() and (' ' in stripped_txt[-2:] or len(stripped_txt) == 1)\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `check_if_last_char_is_a_letter` checks if the last character of a given string is an alphabetical character and not part of a word. The function first handles edge cases: it returns False if the input string is empty or ends with a space. It then strips trailing spaces from the string to get the actual last character. If this last character is alphabetic and either preceded by a space (indicating that it's not part of a word) or is the only character in the stripped string, the function returns True; otherwise, it returns False.```\n\n"}
{"task_id": "CPP/42", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nvector<int> incr_list(vector<int> l) {\n    for (size_t i = 0; i < l.size(); ++i) {\n        l[i] += 1;\n    }\n    return l;\n}\n", "py_code": "def incr_vector(l):\n    return [x + 1 for x in l]\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `incr_vector` takes a list of integers as input and returns a new list where each element is incremented by 1. This is achieved using a list comprehension that iterates over each element in the input list `l`, adds 1 to it, and collects these values into a new list which is then returned.\n```"}
{"task_id": "CPP/11", "generation": "#include <string>\nusing namespace std;\n\nstring string_xor(string a, string b) {\n    string result = \"\";\n    for(size_t i = 0; i < a.size(); ++i) {\n        // Perform XOR on each bit and append to the result.\n        char xor_result = (a[i] - '0') ^ (b[i] - '0') + '0';\n        result += xor_result;\n    }\n    return result;\n}\n", "py_code": "def string_xor(a: str, b: str) -> str:\n    # Perform XOR on each bit and join results into a single string.\n    return ''.join(str(int(x) ^ int(y)) for x, y in zip(a, b))\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `string_xor` takes two binary strings `a` and `b` as input and returns their bitwise XOR result also in string format. The function uses a generator expression inside the `join()` method to iterate over pairs of characters from both strings simultaneously using `zip(a, b)`. For each pair `(x, y)` of corresponding bits from `a` and `b`, it converts them into integers with `int(x)` and `int(y)`, performs XOR operation (`^`) on these integer values, converts the result back to a string, and finally joins all resulting characters together into one final output string. This approach ensures that each bit is processed correctly according to binary XOR rules (0 ^ 0 = 0, 1 ^ 1 = 0, 0 ^ 1 = 1, 1 ^ 0 = 1).```\n\n"}
{"task_id": "CPP/40", "generation": "#include <vector>\nusing namespace std;\n\nbool triples_sum_to_zero(vector<int> l) {\n    int n = l.size();\n    for (int i = 0; i < n - 2; ++i) {\n        for (int j = i + 1; j < n - 1; ++j) {\n            for (int k = j + 1; k < n; ++k) {\n                if (l[i] + l[j] + l[k] == 0) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n", "py_code": "def triples_sum_to_zero(l):\n    n = len(l)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                if l[i] + l[j] + l[k] == 0:\n                    return True\n    return False\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `triples_sum_to_zero` checks whether there exist three distinct elements in a given list of integers that sum to zero. The function iterates through all possible combinations of three numbers from the input list using nested loops. For each combination, it calculates the sum and checks if it equals zero. If such a combination is found, the function returns `True`. If no such combination exists after checking all possibilities, the function returns `False`.\n\nThe approach uses a brute-force method to check every possible triplet in the list, which has a time complexity of O(n^3) where n is the length of the input list. This can be optimized further by using sorting and two-pointer technique for better performance, but this solution directly follows the problem statement requirements.\n\n"}
{"task_id": "CPP/13", "generation": "#include <iostream>\n\nint greatest_common_divisor(int a, int b) {\n    while (b != 0) {\n        int temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n\n", "py_code": "def greatest_common_divisor(a, b):\n    while b != 0:\n        a, b = b, a % b\n    return a\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `greatest_common_divisor(a, b)` calculates and returns the greatest common divisor (GCD) of two integers `a` and `b`. The algorithm used is the Euclidean algorithm, which repeatedly replaces `a` with `b` and `b` with the remainder of `a` divided by `b`, until `b` becomes zero. At this point, `a` contains the GCD of the original two numbers.\n\nThe function uses a while loop to perform these replacements until `b` is reduced to 0. The final value of `a` after exiting the loop is returned as the result.\n"}
{"task_id": "CPP/130", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> tri(int n) {\n    if (n == 0) {\n        return {1};\n    } else if (n == 1) {\n        return {1, 3};\n    }\n\n    vector<int> result = {1, 3};\n\n    for (int i = 2; i <= n; ++i) {\n        if (i % 2 == 0) {\n            result.push_back(1 + i / 2);\n        } else {\n            int next_val = result[i - 1] + result[i - 2] + (1 + (i + 1) / 2);\n            result.push_back(next_val);\n        }\n    }\n\n    return result;\n}\n", "py_code": "def tri(n):\n    if n == 0:\n        return [1]\n    elif n == 1:\n        return [1, 3]\n    \n    result = [1, 3]\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            result.append(1 + i // 2)\n        else:\n            next_val = result[-1] + result[-2] + tri(i + 1)[i + 1]\n            result.append(next_val)\n    return result\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `tri(n)` is intended to generate a list containing the first `n+1` numbers of the Tribonacci sequence as defined in the problem statement. However, there are some issues with the current implementation that need addressing:\n- The base cases for `n == 0` and `n == 1` return lists `[1]` and `[1, 3]`, respectively.\n- For even values of `i`, it correctly calculates `tri(i) = 1 + i // 2`.\n- For odd values of `i`, the function attempts to calculate `tri(n - 1) + tri(n - 2) + tri(n + 1)` recursively, which is problematic because:\n    - The recursive call for `tri(i+1)` will lead to an infinite recursion since it keeps calling itself with increasing indices.\n    - This approach does not align well with the problem's definition and would be computationally expensive.\n\nTo correct this, we should use dynamic programming or memoization to avoid redundant calculations. We can store previously computed values in a list and reuse them for future computations.\n\nLet's revise the Python code accordingly:\n\n```python\ndef tri(n):\n    if n == 0:\n        return [1]\n    elif n == 1:\n        return [1, 3]\n\n    result = [1, 3]\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            result.append(1 + i // 2)\n        else:\n            next_val = result[-1] + result[-2] + (1 + (i + 1) // 2)\n            result.append(next_val)\n    return result\n```\n\nThis revised function avoids the infinite recursion issue and correctly computes the Tribonacci sequence up to `n`.\n\n"}
{"task_id": "CPP/60", "generation": "#include<stdio.h>\nusing namespace std;\n\nint sum_to_n(int n) {\n    return n * (n + 1) / 2;\n}\n", "py_code": "def sum_to_n(n):\n    return n * (n + 1) // 2\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `sum_to_n` calculates the sum of all integers from 1 to n using a mathematical formula: \\( \\frac{n(n + 1)}{2} \\). This formula is derived from the arithmetic series sum formula and allows for an efficient calculation without needing to iterate through each number. The function takes an integer `n` as input, performs the calculation, and returns the result.\n```"}
{"task_id": "CPP/23", "generation": "#include <string>\nusing namespace std;\n\nint strlen(string str) {\n    return str.length();\n}\n", "py_code": "def strlen(str):\n    return len(str)\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `strlen` takes a string as input and returns its length using the built-in `len()` function. This function is straightforward and utilizes Python's standard library to determine the number of characters in the given string.\n```\n\n"}
{"task_id": "CPP/46", "generation": "#include <vector>\nusing namespace std;\n\nint fib4(int n) {\n    if (n < 0) return -1; // Assuming a negative input is invalid and returning -1 as an error indicator.\n    \n    // Base cases\n    if (n == 0 || n == 1 || n == 3) return 0;\n    else if (n == 2) return 2;\n\n    // Initialize the first four values of the sequence\n    vector<int> fib_values = {0, 0, 2, 0};\n    \n    // Compute the nth element iteratively\n    for (int i = 4; i <= n; ++i) {\n        int next_value = fib_values[i-1] + fib_values[i-2] + fib_values[i-3] + fib_values[i-4];\n        fib_values.push_back(next_value);\n    }\n    \n    return fib_values[n];\n}\n", "py_code": "def fib4(n):\n    if n < 0:\n        return None\n    # Base cases\n    if n == 0 or n == 1 or n == 3:\n        return 0\n    elif n == 2:\n        return 2\n    \n    # Initialize the first four values of the sequence\n    fib_values = [0, 0, 2, 0]\n    \n    # Compute the nth element iteratively\n    for i in range(4, n + 1):\n        next_value = sum(fib_values[-4:])\n        fib_values.append(next_value)\n        \n    return fib_values[n]\n```\n\n", "py_summary": "### Second step, analyse the python code:\nThe Python function `fib4(n)` computes the n-th element of a sequence similar to the Fibonacci sequence but with different initial values and a sum involving four previous elements instead of two. The function avoids recursion for efficiency.\n\n1. **Base Cases**: It first checks if `n` is less than 0, returning `None` in that case (though this scenario isn't part of the problem's requirements). For `n = 0`, `n = 1`, and `n = 3`, it returns `0`. For `n = 2`, it returns `2`.\n\n2. **Initialization**: If `n` is greater than or equal to 4, it initializes a list `fib_values` with the first four elements of the sequence: `[0, 0, 2, 0]`.\n\n3. **Iterative Computation**: The function then iterates from `i = 4` up to `n`, computing each new value as the sum of the last four values in `fib_values`. It appends this computed value to `fib_values`.\n\n4. **Return Value**: Finally, it returns the n-th element of `fib_values`, which is now populated with all necessary elements up to index `n`.\n\nThis approach ensures that each element is computed only once and stored for future use, making the function efficient.\n\n"}
{"task_id": "CPP/51", "generation": "#include <stdio.h>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nstring remove_vowels(string text) {\n    string vowels = \"aeiouAEIOU\";\n    string result = \"\";\n    for (char c : text) {\n        if (vowels.find(c) == string::npos) {\n            result += c;\n        }\n    }\n    return result;\n}\n", "py_code": "def remove_vowels(text):\n    vowels = \"aeiouAEIOU\"\n    return ''.join([char for char in text if char not in vowels])\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `remove_vowels` takes a string as input and returns a new string with all vowels removed. It defines a string of vowels (both lowercase and uppercase) and uses a list comprehension to iterate over each character in the input text. If the character is not found within the defined set of vowels, it includes that character in the resulting list. Finally, it joins the list into a single string and returns this new string without any vowels.\n```"}
{"task_id": "CPP/18", "generation": "#include <string>\nusing namespace std;\n\nint how_many_times(string str, string substring) {\n    int count = 0;\n    int sub_len = substring.length();\n    \n    for (size_t i = 0; i <= str.length() - sub_len; ++i) {\n        if (str.substr(i, sub_len) == substring) {\n            count++;\n        }\n    }\n\n    return count;\n}\n", "py_code": "def how_many_times(str, substring):\n    count = 0\n    sub_len = len(substring)\n    for i in range(len(str) - sub_len + 1):\n        if str[i:i+sub_len] == substring:\n            count += 1\n    return count\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `how_many_times` takes two string arguments: `str`, which is the original string to search within, and `substring`, which is the substring we are looking for in the original string. The function counts how many times the `substring` appears in `str`, including overlapping occurrences.\n\n1. **Initialization**: \n   - A variable `count` is initialized to 0 to keep track of the number of occurrences.\n   - Another variable `sub_len` stores the length of the substring for convenience and efficiency.\n\n2. **Loop through the string**:\n   - The function iterates over each possible starting index `i` in the original string where a substring of the same length as `substring` can fit (`len(str) - sub_len + 1`). This ensures that we do not go out of bounds when checking for substrings.\n   \n3. **Check for matches**:\n   - For each position `i`, it checks if the slice of `str` from index `i` to `i+sub_len` is equal to `substring`.\n   - If a match is found, `count` is incremented by 1.\n\n4. **Return result**:\n   - After completing the loop, the function returns the total count of occurrences.\n\nThis approach ensures that all possible overlapping instances are counted correctly.\n```\n\n<|im_start|>\n<|im_start|>user\n"}
{"task_id": "CPP/143", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\nusing namespace std;\n\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\nstring words_in_sentence(string sentence) {\n    stringstream ss(sentence);\n    string word, result;\n    while (ss >> word) {\n        if (is_prime(word.length())) {\n            if (!result.empty()) result += \" \";\n            result += word;\n        }\n    }\n    return result;\n}\n", "py_code": "def is_prime(n):\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef words_in_sentence(sentence):\n    words = sentence.split()\n    prime_length_words = [word for word in words if is_prime(len(word))]\n    return ' '.join(prime_length_words)\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python solution consists of two functions: `is_prime` and `words_in_sentence`. The `is_prime` function checks if a given number is prime by iterating from 2 to the square root of the number and checking for any divisors. If no divisors are found, it returns True indicating that the number is prime.\n\nThe `words_in_sentence` function takes a sentence as input and splits it into individual words using the split method. It then creates a list comprehension that filters out only those words whose lengths are prime numbers by calling the `is_prime` function on each word's length. Finally, it joins these filtered words back into a string with spaces in between and returns this new string.\n\nThis approach ensures that the order of the words in the output is preserved as they appear in the original sentence, and only those words whose lengths are prime numbers are included in the final result.```\n\n"}
{"task_id": "CPP/108", "generation": "#include <vector>\nusing namespace std;\n\nint count_nums(vector<int> n) {\n    int count = 0;\n    for (auto num : n) {\n        int sum = 0, temp = abs(num);\n        while (temp > 0) {\n            sum += temp % 10;\n            temp /= 10;\n        }\n        if ((num < 0 && sum - 2 * (abs(num) % 10) > 0) || (num >= 0 && sum > 0)) {\n            ++count;\n        }\n    }\n    return count;\n}\n", "py_code": "def count_nums(n):\n    def sum_of_digits(num):\n        return sum(int(digit) for digit in str(num)) if num >= 0 else -int(str(num)[1]) + sum(int(digit) for digit in str(num)[2:])\n    \n    return sum(1 for num in n if sum_of_digits(num) > 0)\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `count_nums` takes a list of integers as input and returns the count of elements whose sum of digits is greater than zero. The function defines an inner helper function `sum_of_digits`, which calculates the sum of the signed digits of a given number.\n\nFor positive numbers, it converts the number to a string and sums up each digit's integer value. For negative numbers, it treats the first character as a negative digit by subtracting its absolute value from the total sum of the rest of the digits (converted similarly).\n\nThe main function then iterates over the list `n`, using a generator expression that counts how many elements have a positive sum of digits according to the helper function. The result is returned as an integer count.\n\nThis approach ensures that both positive and negative numbers are handled correctly, with their signed digits contributing appropriately to the overall digit sum calculation.\n```\n\n"}
{"task_id": "CPP/43", "generation": "#include <vector>\n#include <unordered_set>\nusing namespace std;\n\nbool pairs_sum_to_zero(vector<int> l) {\n    unordered_set<int> seen;\n    for (int num : l) {\n        if (seen.find(-num) != seen.end()) {\n            return true;\n        }\n        seen.insert(num);\n    }\n    return false;\n}\n", "py_code": "def pairs_sum_to_zero(l):\n    seen = set()\n    for num in l:\n        if -num in seen:\n            return True\n        seen.add(num)\n    return False\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `pairs_sum_to_zero` checks whether there are two distinct elements in a list that sum to zero. It uses a set named `seen` to keep track of the numbers encountered so far. For each number in the input list, it checks if its negation (i.e., `-num`) is already in the `seen` set. If it is, this means there exists another element in the list that sums with the current number to zero, and the function returns `True`. Otherwise, the current number is added to the `seen` set. If no such pair is found after iterating through the entire list, the function returns `False`.\n```\n\n"}
{"task_id": "CPP/70", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<int> strange_sort_list(vector<int> lst) {\n    sort(lst.begin(), lst.end());\n    vector<int> result;\n    while (!lst.empty()) {\n        // Append minimum value\n        if (!lst.empty()) {\n            result.push_back(lst.front());\n            lst.erase(lst.begin());\n        }\n        // Append maximum value\n        if (!lst.empty()) {\n            result.push_back(lst.back());\n            lst.pop_back();\n        }\n    }\n    return result;\n}\n", "py_code": "def strange_sort_list(lst):\n    sorted_lst = sorted(lst)\n    result = []\n    while sorted_lst:\n        # Append minimum value\n        if sorted_lst:\n            result.append(sorted_lst.pop(0))\n        # Append maximum value\n        if sorted_lst:\n            result.append(sorted_lst.pop(-1))\n    return result\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `strange_sort_list` takes a list of integers and returns a new list sorted in a \"strange\" order as described in the problem statement. The steps are as follows:\n1. **Sorting**: The input list is first sorted in ascending order.\n2. **Building Result List**:\n    - A while loop runs until all elements from the sorted list have been processed.\n    - In each iteration, it appends the minimum value (the first element of the sorted list) to the result and removes this element from the sorted list.\n    - Then, if there are still elements left in the sorted list, it appends the maximum value (the last element of the sorted list) to the result and also removes this element from the sorted list.\n\nThis process continues until all elements have been processed. The function finally returns the constructed \"strange\" ordered list.\n\n"}
{"task_id": "CPP/63", "generation": "#include <iostream>\n\nint fibfib(int n) {\n    if (n == 0 || n == 1) return 0;\n    else if (n == 2) return 1;\n\n    int a = 0, b = 0, c = 1, d;\n    \n    for (int i = 3; i <= n; ++i) {\n        d = a + b + c;\n        a = b;\n        b = c;\n        c = d;\n    }\n\n    return c;\n}\n", "py_code": "def fibfib(n):\n    if n == 0 or n == 1:\n        return 0\n    elif n == 2:\n        return 1\n    \n    # Initialize base cases\n    a, b, c = 0, 0, 1\n\n    for i in range(3, n + 1):\n        a, b, c = b, c, a + b + c\n\n    return c\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `fibfib(n)` is designed to compute the n-th element of the FibFib number sequence efficiently. The FibFib sequence is defined such that fibfib(0) = 0, fibfib(1) = 0, fibfib(2) = 1, and for any other value of n, fibfib(n) = fibfib(n-1) + fibfib(n-2) + fibfib(n-3). \n\nThe function starts by handling the base cases directly: if `n` is 0 or 1, it returns 0; if `n` is 2, it returns 1. For values of `n` greater than 2, the function uses a loop to iteratively compute the sequence up to the n-th element. It maintains three variables (`a`, `b`, and `c`) representing the last three elements in the sequence. In each iteration, these variables are updated such that they always hold the values of fibfib(n-3), fibfib(n-2), and fibfib(n-1) respectively. The loop runs from 3 to n (inclusive), ensuring that all necessary computations are performed. Finally, the function returns `c`, which holds the value of fibfib(n).```\n\n"}
{"task_id": "CPP/89", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring encrypt(string s) {\n    string encrypted_str = \"\";\n    int shift = 4; // two multiplied by two places\n\n    for (char &c : s) {\n        if (isalpha(c)) {\n            char base = islower(c) ? 'a' : 'A';\n            c = ((c - base + shift) % 26) + base;\n        }\n        encrypted_str += c;\n    }\n\n    return encrypted_str;\n}\n", "py_code": "def encrypt(s):\n    encrypted_str = \"\"\n    for char in s:\n        if char.isalpha():\n            shift = 4  # two multiplied by two places\n            base = ord('a') if char.islower() else ord('A')\n            new_char = chr((ord(char) - base + shift) % 26 + base)\n            encrypted_str += new_char\n        else:\n            encrypted_str += char\n    return encrypted_str\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `encrypt` takes a string `s` as input and returns an encrypted version of it by rotating each alphabetical character down by four places (two multiplied by two). The function iterates through each character in the given string. If the character is an alphabet letter, it calculates its new position based on the rotation shift while preserving the case (lowercase or uppercase) of the original character.\n\nThe `base` variable is set to the ASCII value of 'a' for lowercase letters and 'A' for uppercase letters. The function then computes the new character by shifting the current character's ASCII value down by four places within the range of 26 letters in the alphabet, wrapping around if necessary using modulo operation.\n\nNon-alphabetical characters are not modified and are directly added to the encrypted string `encrypted_str`. Finally, the function returns the fully encrypted string. \n\nThis approach ensures that each alphabetical character is shifted correctly while maintaining its case and non-alphabetical characters remain unchanged.\n"}
{"task_id": "CPP/26", "generation": "#include <stdio.h>\n#include <vector>\n#include <unordered_set>\nusing namespace std;\n\nvector<int> remove_duplicates(vector<int> numbers) {\n    unordered_set<int> seen;\n    vector<int> result;\n    \n    for (int number : numbers) {\n        if (!seen.count(number)) {\n            result.push_back(number);\n            seen.insert(number);\n        }\n    }\n\n    return result;\n}\n", "py_code": "def remove_duplicates(numbers):\n    seen = set()\n    result = []\n    for number in numbers:\n        if number not in seen:\n            result.append(number)\n            seen.add(number)\n    return result\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `remove_duplicates` takes a list of integers as input and returns a new list with all duplicates removed while preserving the original order of elements that are not duplicated.\n\n1. It initializes an empty set called `seen`, which will be used to keep track of numbers that have already been encountered.\n2. An empty list named `result` is created to store the final sequence of unique numbers in their original order.\n3. The function iterates through each number in the input list (`numbers`). For each number:\n   - It checks if the number has not been seen before by verifying its absence from the `seen` set.\n   - If the number hasn't been seen, it appends the number to the `result` list and adds the number to the `seen` set.\n4. After processing all numbers in the input list, the function returns the `result` list containing only unique elements in their original order.\n\nThis approach ensures that each element is processed once, resulting in a time complexity of O(n), where n is the length of the input list. The space complexity is also O(n) due to the additional storage required for the `seen` set and the `result` list. \n\n"}
{"task_id": "CPP/104", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nbool has_no_even_digit(int num) {\n    while (num > 0) {\n        int digit = num % 10;\n        if (digit % 2 == 0) return false;\n        num /= 10;\n    }\n    return true;\n}\n\nvector<int> unique_digits(vector<int> x) {\n    vector<int> result;\n\n    for (int num : x) {\n        if (has_no_even_digit(num)) {\n            result.push_back(num);\n        }\n    }\n\n    sort(result.begin(), result.end());\n    return result;\n}\n", "py_code": "def unique_digits(x):\n    result = []\n    for num in x:\n        if all(int(digit) % 2 != 0 for digit in str(num)):\n            result.append(num)\n    return sorted(result)\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `unique_digits` takes a list of positive integers as input and returns a new list containing only those numbers that do not have any even digits. The returned list is sorted in increasing order.\n\nHere's how it works:\n1. Initialize an empty list called `result`.\n2. Iterate through each number (`num`) in the input list `x`.\n3. Convert the current number to a string and check if all its digits are odd using the `all` function combined with a generator expression that checks if each digit is not even.\n4. If the condition is met, append the number to the `result` list.\n5. After iterating through all numbers in `x`, sort the `result` list in increasing order and return it.\n\nThis approach ensures that only integers without any even digits are included in the final sorted output. \n\n"}
{"task_id": "CPP/90", "generation": "#include <vector>\n#include <set>\n#include <optional>\n\nusing namespace std;\n\n// Function to find the second smallest element in a vector.\nint next_smallest(vector<int> lst) {\n    set<int> unique_elements(lst.begin(), lst.end());\n    \n    if (unique_elements.size() < 2) {\n        return numeric_limits<int>::min(); // Return minimum int value as equivalent of None\n    }\n    \n    auto it = unique_elements.begin();\n    advance(it, 1); // Move iterator to the second element in set\n    \n    return *it;\n}\n", "py_code": "def next_smallest(lst):\n    unique_elements = set(lst)\n    if len(unique_elements) < 2:\n        return None\n    sorted_unique_elements = sorted(unique_elements)\n    return sorted_unique_elements[1]\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `next_smallest` takes a list of integers as input and returns the second smallest unique element in the list. If there is no such element (i.e., if the list has fewer than two distinct elements), it returns `None`.\n\nHere's how the function works:\n1. It first converts the list to a set (`unique_elements`) to remove any duplicate values, ensuring that only unique integers are considered.\n2. The function then checks if there are at least two unique elements in the set by comparing its length with 2. If not, it returns `None`.\n3. If there are at least two unique elements, the set is converted back into a sorted list (`sorted_unique_elements`).\n4. Finally, the second element of this sorted list (i.e., the second smallest unique integer) is returned.\n\nThis approach ensures that we correctly handle cases with duplicates and lists with fewer than two distinct values.\n\n"}
{"task_id": "CPP/126", "generation": "#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nbool is_sorted(vector<int> lst) {\n    if (lst.size() <= 1) return true;\n    \n    vector<int> count(256, 0); // Assuming a reasonable upper bound for integers in the list.\n    \n    for(int i = 0; i < lst.size(); ++i){\n        int num = lst[i];\n        \n        // Check if current number is less than previous one\n        if(i > 0 && num < lst[i - 1]) return false;\n        \n        // Count occurrences of each number\n        count[num]++;\n        \n        // If any number appears more than twice, return false\n        if(count[num] > 2) return false;\n    }\n    \n    return true;\n}\n", "py_code": "def is_sorted(lst):\n    if len(lst) <= 1:\n        return True\n\n    count = {}\n    for i in range(len(lst)):\n        if lst[i] not in count:\n            count[lst[i]] = 1\n        else:\n            count[lst[i]] += 1\n            if count[lst[i]] > 2:\n                return False\n        \n        if i > 0 and lst[i] < lst[i-1]:\n            return False\n\n    return True\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `is_sorted` checks whether a given list of integers is sorted in ascending order and ensures that no number appears more than twice. The function first handles edge cases where the length of the list is less than or equal to 1 by returning True.\n\nIt then initializes an empty dictionary `count` to keep track of the occurrences of each integer in the list. As it iterates through the list, for each element:\n- It checks if the number has been seen before and updates its count.\n- If any number appears more than twice (`count[lst[i]] > 2`), the function immediately returns False.\n- Additionally, it checks whether the current number is less than the previous one to ensure that the list is sorted in ascending order. If this condition fails at any point, the function also returns False.\n\nIf both conditions are satisfied throughout the iteration, the function finally returns True, indicating that the list is sorted and no number appears more than twice.\n\n"}
{"task_id": "CPP/68", "generation": "#include <stdio.h>\n#include <vector>\n#include <limits>\nusing namespace std;\n\nvector<int> pluck(vector<int> arr) {\n    int smallest_even_value = numeric_limits<int>::max();\n    int smallest_index = -1;\n    \n    for (int i = 0; i < arr.size(); ++i) {\n        if (arr[i] % 2 == 0 && arr[i] <= smallest_even_value) {\n            if (arr[i] < smallest_even_value || (arr[i] == smallest_even_value && i < smallest_index)) {\n                smallest_even_value = arr[i];\n                smallest_index = i;\n            }\n        }\n    }\n\n    if (smallest_index != -1) {\n        return {smallest_even_value, smallest_index};\n    } else {\n        return {};\n    }\n}\n", "py_code": "def pluck(arr):\n    smallest_even_value = float('inf')\n    smallest_index = -1\n\n    for index, value in enumerate(arr):\n        if value % 2 == 0 and value < smallest_even_value:\n            smallest_even_value = value\n            smallest_index = index\n    \n    if smallest_index != -1:\n        return [smallest_even_value, smallest_index]\n    else:\n        return []\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `pluck` takes a list of integers (`arr`) as input and returns a list containing the smallest even value in the array along with its index. If there are no even values or if the given vector is empty, it returns an empty list.\n\n1. The function initializes two variables: `smallest_even_value` to positive infinity and `smallest_index` to -1.\n2. It iterates over each element of the input list using a for loop with `enumerate`, which provides both the index (`index`) and value (`value`) of each element in the array.\n3. For each element, it checks if the value is even (i.e., `value % 2 == 0`) and smaller than the current smallest even value. If so, it updates `smallest_even_value` to the new minimum even value and sets `smallest_index` to the index of this value.\n4. After iterating through all elements, if a valid even number was found (`smallest_index != -1`), it returns a list containing `[smallest_even_value, smallest_index]`.\n5. If no even numbers were found (i.e., `smallest_index` remains `-1`), the function returns an empty list.\n\nThis approach ensures that we find the smallest even value and its index efficiently in one pass through the array.\n\n"}
{"task_id": "CPP/58", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\n#include <set>\nusing namespace std;\n\nvector<int> common(vector<int> l1, vector<int> l2) {\n    sort(l1.begin(), l1.end());\n    sort(l2.begin(), l2.end());\n\n    vector<int> result;\n    set_intersection(l1.begin(), l1.end(), l2.begin(), l2.end(), back_inserter(result));\n\n    // Remove duplicates from the result\n    auto last = unique(result.begin(), result.end());\n    result.erase(last, result.end());\n\n    return result;\n}\n", "py_code": "def common(l1, l2):\n    # Convert both lists to sets and find intersection\n    result = set(l1).intersection(set(l2))\n    # Return sorted list of unique elements\n    return sorted(result)\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `common` takes two lists (`l1` and `l2`) as input and returns a list of their common elements in sorted order. The function first converts both lists into sets to eliminate any duplicates within each list and then finds the intersection of these sets using the `.intersection()` method, which gives us all unique elements that are present in both lists. Finally, it sorts the resulting set and returns it as a list. This approach ensures that the returned list contains only unique common elements from `l1` and `l2`, sorted in ascending order.```\n\n"}
{"task_id": "CPP/112", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nvector<string> reverse_delete(string s, string c) {\n    // Remove characters from `s` that are present in `c`\n    string result_string;\n    for (char ch : s) {\n        if (c.find(ch) == string::npos) {\n            result_string += ch;\n        }\n    }\n\n    // Check if the resulting string is a palindrome\n    string reversed_string = result_string;\n    reverse(reversed_string.begin(), reversed_string.end());\n    \n    bool is_palindrome = (result_string == reversed_string);\n    \n    vector<string> output(2);\n    output[0] = result_string;\n    output[1] = is_palindrome ? \"True\" : \"False\";\n    \n    return output;\n}\n", "py_code": "def reverse_delete(s: str, c: str) -> list:\n    # Remove characters from `s` that are present in `c`\n    result_string = ''.join([char for char in s if char not in c])\n    \n    # Check if the resulting string is a palindrome\n    is_palindrome = result_string == result_string[::-1]\n    \n    return [result_string, str(is_palindrome).lower()]\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `reverse_delete` takes two string arguments: `s` and `c`. It first constructs a new string (`result_string`) by filtering out all characters from `s` that are present in `c`. This is done using a list comprehension to iterate over each character in `s`, checking if it's not in `c`.\n\nAfter constructing the filtered string, the function checks whether this resulting string is a palindrome. A string is considered a palindrome if it reads the same backward as forward. The function uses Python slicing (`[::-1]`) to reverse the string and compares it with the original result string.\n\nFinally, the function returns a list containing the `result_string` and a boolean value indicating whether the string is a palindrome (converted to lowercase for consistency).\n\nThis approach ensures that all characters in `s` which are present in `c` are removed, and then checks if the remaining string forms a palindrome.```\n\n"}
{"task_id": "CPP/96", "generation": "#include <stdio.h>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    for (int i = 2; i <= sqrt(num); ++i) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\nvector<int> count_up_to(int n) {\n    vector<int> primes;\n    for (int number = 2; number < n; ++number) {\n        if (is_prime(number)) {\n            primes.push_back(number);\n        }\n    }\n    return primes;\n}\n", "py_code": "def is_prime(num):\n    if num <= 1:\n        return False\n    for i in range(2, int(num**0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef count_up_to(n):\n    primes = []\n    for number in range(2, n):\n        if is_prime(number):\n            primes.append(number)\n    return primes\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python solution consists of two functions: `is_prime` and `count_up_to`. The function `is_prime(num)` checks if a given number is prime by iterating from 2 to the square root of the number (inclusive) and checking for any divisors. If no divisors are found, it returns True indicating that the number is prime.\n\nThe main function `count_up_to(n)` generates a list of all prime numbers less than n. It initializes an empty list called `primes` and iterates through each integer from 2 to (n-1). For each integer, it calls the `is_prime` function to check if the number is prime. If it is, the number is appended to the `primes` list. Finally, the function returns the list of primes.\n\nThis approach ensures that only numbers less than n are considered and checks for primality efficiently by limiting the range of divisors checked in the `is_prime` function.\n```\n\n"}
{"task_id": "CPP/157", "generation": "#include <algorithm> // for std::sort\n#include <vector>\n\nbool right_angle_triangle(float a, float b, float c) {\n    // Create a vector to hold the sides and sort it so that c is the longest side (hypotenuse)\n    std::vector<float> sides = {a, b, c};\n    std::sort(sides.begin(), sides.end());\n    \n    // Assign sorted values back to a, b, c\n    a = sides[0];\n    b = sides[1];\n    c = sides[2];\n\n    // Check if the triangle satisfies Pythagoras' theorem: a^2 + b^2 == c^2\n    return (a * a) + (b * b) == (c * c);\n}\n", "py_code": "def right_angle_triangle(a, b, c):\n    # Sort the sides so that c is the longest side (hypotenuse)\n    sides = sorted([a, b, c])\n    a, b, c = sides\n\n    # Check if the triangle satisfies Pythagoras' theorem: a^2 + b^2 == c^2\n    return a**2 + b**2 == c**2\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `right_angle_triangle` takes three side lengths of a triangle as input and returns a boolean indicating whether these sides form a right-angled triangle. The function first sorts the side lengths to ensure that the longest side (hypotenuse) is assigned to variable `c`. It then checks if the square of the hypotenuse (`c^2`) equals the sum of the squares of the other two sides (`a^2 + b^2`), which is a condition derived from Pythagoras' theorem. If this condition holds true, it returns `True`, indicating that the triangle is right-angled; otherwise, it returns `False`.```"}
{"task_id": "CPP/99", "generation": "#include <cmath>\n#include <string>\nusing namespace std;\n\nint closest_integer(string value) {\n    float num = stof(value);\n    if (num - floor(num) == 0.5 || num - ceil(num) == -0.5) {\n        return num > 0 ? ceil(num) : floor(num);\n    }\n    return round(num);\n}\n", "py_code": "def closest_integer(value: str) -> int:\n    num = float(value)\n    if num - int(num) == 0.5 or num - int(num) == -0.5:\n        return int(num + (1 if num > 0 else -1))\n    return round(num)\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `closest_integer` takes a string representing a number and returns the closest integer to it, rounding away from zero if necessary.\n\n1. The input value is first converted into a floating-point number.\n2. It checks whether the fractional part of the number is exactly 0.5 or -0.5 using the condition `num - int(num) == 0.5` or `num - int(num) == -0.5`.\n3. If the condition is true, it rounds away from zero by adding 1 if the number is positive and subtracting 1 if the number is negative.\n4. Otherwise, it uses Python's built-in `round()` function to round the number to the nearest integer.\n\nThis approach ensures that numbers equidistant between two integers are rounded in a way that moves them farther from zero.\n\n"}
{"task_id": "CPP/149", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\n// Function to sort and filter strings based on their lengths.\nbool custom_compare(const string& a, const string& b) {\n    if (a.length() == b.length()) {\n        return a < b; // Alphabetical order for same length\n    }\n    return a.length() < b.length(); // Ascending by length\n}\n\nvector<string> sorted_list_sum(vector<string> lst){\n    vector<string> filtered_list;\n    \n    // Filter out strings with odd lengths.\n    for (const string& word : lst) {\n        if (word.length() % 2 == 0) {\n            filtered_list.push_back(word);\n        }\n    }\n\n    // Sort the list by length and then alphabetically\n    sort(filtered_list.begin(), filtered_list.end(), custom_compare);\n\n    return filtered_list;\n}\n", "py_code": "from typing import List\n\ndef vector_sort(lst: List[str]) -> List[str]:\n    # Filter out strings with odd lengths\n    filtered_list = [word for word in lst if len(word) % 2 == 0]\n    \n    # Sort the list by length and then alphabetically\n    sorted_list = sorted(filtered_list, key=lambda x: (len(x), x))\n    \n    return sorted_list\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `vector_sort` takes a list of strings as input and returns a new list that has been filtered to exclude any strings with odd lengths. The remaining strings are then sorted first by their length in ascending order and secondly alphabetically if they have the same length.\n\n1. **Filtering**: A list comprehension is used to iterate through each string `word` in the input list `lst`. It checks whether the length of `word` is even (`len(word) % 2 == 0`). If it is, the word is included in the new list `filtered_list`.\n\n2. **Sorting**: The function then sorts `filtered_list` using Python's built-in `sorted()` function with a custom key that first considers the string length and then its alphabetical order if lengths are equal.\n\n3. **Return**: Finally, the sorted list of strings is returned.\n```\n\n"}
{"task_id": "CPP/86", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nstring anti_shuffle(string s) {\n    string result = \"\";\n    string word = \"\";\n    \n    for (char c : s) {\n        if (c == ' ') {\n            // Sort the current word and append to result\n            sort(word.begin(), word.end());\n            result += word + \" \";\n            word = \"\";  // Reset word for next iteration\n        } else {\n            word += c;\n        }\n    }\n\n    // Handle the last word in the string\n    if (!word.empty()) {\n        sort(word.begin(), word.end());\n        result += word;\n    }\n\n    return result;\n}\n", "py_code": "def anti_shuffle(s):\n    words = s.split(\" \")\n    ordered_words = []\n    for word in words:\n        sorted_word = \"\".join(sorted(word))\n        ordered_words.append(sorted_word)\n    return \" \".join(ordered_words)\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `anti_shuffle` takes a string `s` as input and returns an ordered version of it where each word's characters are sorted in ascending order based on their ASCII values while preserving the original order of words and spaces.\n\n1. The function first splits the input string into individual words using the `split(\" \")` method, which separates the string by spaces.\n2. It then iterates over each word in the list of words.\n3. For each word, it sorts its characters in ascending ASCII order using the `sorted()` function and joins them back together to form a new sorted word with `\"\".join(sorted(word))`.\n4. The newly formed ordered words are appended to a list called `ordered_words`.\n5. Finally, the function returns a string where all the ordered words from the `ordered_words` list are joined by spaces using `\" \".join(ordered_words)`.\n\nThis approach ensures that each word in the input string is transformed into its ordered version while maintaining the original order of words and blank spaces in the sentence.\n\n"}
{"task_id": "CPP/129", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> minPath(vector<vector<int>> grid, int k) {\n    int n = grid.size();\n    vector<pair<int, int>> directions{{0, 1}, {1, 0}, {-1, 0}, {0, -1}};\n    \n    function<vector<int>(int, int, vector<int>)> dfs;\n    dfs = [&] (int x, int y, vector<int> path) -> vector<int> {\n        if (path.size() == k)\n            return path;\n        \n        vector<int> min_path(k, INT_MAX);\n        for (auto& dir : directions) {\n            int dx = dir.first, dy = dir.second;\n            int nx = x + dx, ny = y + dy;\n            if (0 <= nx && nx < n && 0 <= ny && ny < n) {\n                auto new_path = dfs(nx, ny, path);\n                new_path.push_back(grid[nx][ny]);\n                \n                if (new_path.size() == k && (min_path.empty() || new_path < min_path))\n                    min_path = new_path;\n            }\n        }\n        \n        return min_path;\n    };\n    \n    vector<int> result(k, INT_MAX);\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            auto path = dfs(i, j, {grid[i][j]});\n            \n            if (path.size() == k && (result.empty() || path < result))\n                result = path;\n        }\n    }\n    \n    return result;\n}\n", "py_code": "from typing import List\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    N = len(grid)\n    \n    def dfs(x, y, path):\n        if len(path) == k:\n            return path[:]\n        \n        min_path = [float('inf')] * k\n        \n        for dx, dy in [(0, 1), (1, 0), (-1, 0), (0, -1)]:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < N and 0 <= ny < N:\n                new_path = dfs(nx, ny, path + [grid[nx][ny]])\n                if len(new_path) == k and new_path < min_path:\n                    min_path = new_path[:]\n        \n        return min_path\n    \n    result = [float('inf')] * k\n    for i in range(N):\n        for j in range(N):\n            current_path = dfs(i, j, [grid[i][j]])\n            if len(current_path) == k and current_path < result:\n                result = current_path[:]\n    \n    return result\n\n```\n", "py_summary": "### Second Step: Analyse the Python Code\n\nThe provided Python function `minPath` aims to find the lexicographically smallest path of length `k` in a given grid. The function takes two parameters: a 2D list (`grid`) representing the grid and an integer `k`, which is the desired path length.\n\n1. **Initialization**:\n   - `N = len(grid)` determines the size of the grid.\n   \n2. **Helper Function (dfs)**:\n   - A recursive helper function `dfs(x, y, path)` is defined to explore all possible paths starting from a given cell `(x, y)`.\n   - The base case checks if the length of the current path equals `k`. If so, it returns the current path.\n   - Otherwise, it initializes `min_path` with an array filled with infinity values (to ensure any valid path will be smaller).\n   \n3. **Recursive Exploration**:\n   - For each direction (right, down, left, up), the function calculates the new coordinates `(nx, ny)`.\n   - If these new coordinates are within bounds of the grid, it recursively calls `dfs` with the new position and appends the value at this new cell to the current path.\n   \n4. **Path Comparison**:\n   - The result from the recursive call is compared lexicographically against `min_path`. If a smaller path is found, it updates `min_path`.\n   \n5. **Main Function Logic**:\n   - The main function initializes `result` with an array filled with infinity values.\n   - It iterates over all cells in the grid and starts a DFS from each cell.\n   - For each starting point, if a valid path is found that is lexicographically smaller than the current result, it updates `result`.\n   \n6. **Return**:\n   - Finally, the function returns the smallest path found.\n\nThis approach ensures that all possible paths of length `k` are explored and the lexicographically smallest one is returned.\n\n### Last Step: Generate C++ Solution\n\nNow we will translate this logic into a C++ solution.\n"}
{"task_id": "CPP/49", "generation": "#include <iostream>\n#include <algorithm> // for std::swap if needed\n\n// Function to perform modular exponentiation\nint modp(int n, int p) {\n    long long result = 1;\n    long long base = 2;\n\n    while (n > 0) {\n        if (n % 2 == 1) { // If n is odd, multiply the result by the current base value\n            result = (result * base) % p;\n        }\n        base = (base * base) % p; // Square the base and take modulo p to prevent overflow\n        n /= 2; // Divide n by 2 for the next iteration\n    }\n\n    return static_cast<int>(result);\n}\n\n", "py_code": "def modp(n, p):\n    return pow(2, n, p)\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `modp` takes two integers `n` and `p` as input parameters and returns 2 raised to the power of `n`, modulo `p`. The built-in `pow()` function in Python is used for this purpose. This function efficiently computes large powers modulo a number, which avoids potential numeric overflow issues that could arise from directly computing the power before taking the modulus.```\n\n"}
{"task_id": "CPP/156", "generation": "#include <vector>\n#include <string>\nusing namespace std;\n\nstring int_to_mini_roman(int number) {\n    vector<pair<int, string>> roman_map = {\n        {1000, \"m\"}, {900, \"cm\"}, {500, \"d\"}, {400, \"cd\"},\n        {100, \"c\"}, {90, \"xc\"}, {50, \"l\"}, {40, \"xl\"},\n        {10, \"x\"}, {9, \"ix\"}, {5, \"v\"}, {4, \"iv\"}, {1, \"i\"}\n    };\n    \n    string roman_numeral = \"\";\n    for (const auto &p : roman_map) {\n        while (number >= p.first) {\n            roman_numeral += p.second;\n            number -= p.first;\n        }\n    }\n    return roman_numeral;\n}\n", "py_code": "def int_to_mini_roman(number):\n    roman_map = [\n        (1000, 'm'), (900, 'cm'), (500, 'd'), (400, 'cd'),\n        (100, 'c'), (90, 'xc'), (50, 'l'), (40, 'xl'),\n        (10, 'x'), (9, 'ix'), (5, 'v'), (4, 'iv'), (1, 'i')\n    ]\n    roman_numeral = ''\n    for value, numeral in roman_map:\n        while number >= value:\n            roman_numeral += numeral\n            number -= value\n    return roman_numeral\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `int_to_mini_roman` converts an integer to its lowercase Roman numeral equivalent as a string. The function uses a list of tuples called `roman_map`, where each tuple contains an integer value and its corresponding lowercase Roman numeral representation.\n\nThe function iterates over this list in descending order of the values, checking if the current number is greater than or equal to the value from the tuple. If it is, the corresponding Roman numeral string is appended to `roman_numeral` and the value is subtracted from the number. This process repeats until the entire number has been converted into its Roman numeral representation.\n\nFinally, the function returns the constructed Roman numeral string in lowercase.\n\n"}
{"task_id": "CPP/65", "generation": "#include <string>\n#include <algorithm>\nusing namespace std;\n\nstring circular_shift(int x, int shift) {\n    string digits = to_string(x);\n    int num_digits = digits.size();\n    \n    if (shift >= num_digits) {\n        reverse(digits.begin(), digits.end());\n        return digits;\n    }\n\n    int actual_shift = shift % num_digits;  // To handle shifts larger than the number of digits\n    rotate(digits.rbegin(), digits.rbegin() + actual_shift, digits.rend());\n    return digits;\n}\n", "py_code": "def circular_shift(x: int, shift: int) -> str:\n    digits = list(str(x))\n    num_digits = len(digits)\n    \n    if shift >= num_digits:\n        return ''.join(reversed(digits))\n\n    actual_shift = shift % num_digits  # To handle shifts larger than the number of digits\n    shifted_digits = digits[-actual_shift:] + digits[:-actual_shift]\n    return ''.join(shifted_digits)\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `circular_shift` takes an integer `x` and a shift value as input and returns a string representing the digits of `x` after performing a circular right shift by the specified number of positions (`shift`). The function first converts the integer into a list of its individual digit characters. It then determines the length of this list to know how many digits are present.\n\nIf the shift value is greater than or equal to the number of digits, it reverses the order of the digits and returns them as a string. Otherwise, it calculates an effective shift amount by taking `shift % num_digits` to handle cases where the shift might be larger than the total number of digits (since shifting by the length of the number results in no change).\n\nThe function then performs the circular shift by slicing the list into two parts: the last `actual_shift` elements and the remaining elements. These slices are concatenated with the latter part coming first, effectively performing a right rotation.\n\nFinally, it joins these digit characters back together into a single string and returns this as the result.\n```"}
{"task_id": "CPP/9", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm> // for std::max\nusing namespace std;\n\nvector<int> rolling_max(vector<int> numbers) {\n    int max_so_far = INT_MIN;  // Initialize with the smallest possible integer value.\n    vector<int> result;\n    \n    for (int number : numbers) {\n        max_so_far = std::max(max_so_far, number);  // Update max_so_far if current number is larger\n        result.push_back(max_so_far);               // Append the rolling maximum to the result list\n    }\n    \n    return result;\n}\n", "py_code": "def rolling_max(numbers):\n    max_so_far = float('-inf')\n    result = []\n    for number in numbers:\n        if number > max_so_far:\n            max_so_far = number\n        result.append(max_so_far)\n    return result\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `rolling_max` takes a list of integers as input and returns a new list where each element at index `i` is the maximum value found in the original list up to that point (inclusive). The function initializes `max_so_far` with negative infinity (`float('-inf')`) to ensure any number from the input list will be larger initially. It then iterates through the input list, updating `max_so_far` whenever a new maximum is encountered and appending this value to the result list.\n\nThis approach ensures that each element in the returned list represents the rolling (or cumulative) maximum up to its position in the sequence.\n\n"}
{"task_id": "CPP/158", "generation": "#include <vector>\n#include <string>\n#include <algorithm>\n#include <unordered_set>\nusing namespace std;\n\nstring find_max(vector<string> words) {\n    int max_unique = 0;\n    string result_word = \"\";\n\n    for (const auto& word : words) {\n        unordered_set<char> unique_chars(word.begin(), word.end());\n        \n        if (unique_chars.size() > max_unique || \n            (unique_chars.size() == max_unique && word < result_word)) {\n            max_unique = unique_chars.size();\n            result_word = word;\n        }\n    }\n\n    return result_word;\n}\n", "py_code": "def find_max(words):\n    max_unique = 0\n    result_word = \"\"\n    \n    for word in words:\n        unique_chars = len(set(word))\n        \n        if unique_chars > max_unique or (unique_chars == max_unique and word < result_word):\n            max_unique = unique_chars\n            result_word = word\n            \n    return result_word\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `find_max` takes a list of strings as input and returns the string with the maximum number of unique characters. If there are multiple strings with the same number of unique characters, it returns the one that comes first in lexicographical order.\n\nThe function initializes two variables: `max_unique`, which keeps track of the highest count of unique characters found so far, and `result_word`, which stores the current word with the maximum number of unique characters. \n\nFor each word in the input list:\n1. It calculates the number of unique characters by converting the string to a set (which removes duplicates) and taking its length.\n2. If this count is greater than `max_unique` or if it's equal but the current word comes before `result_word` lexicographically, then `max_unique` and `result_word` are updated.\n\nFinally, the function returns `result_word`, which contains the string with the maximum number of unique characters (or the first one in case of a tie).```\n\n"}
{"task_id": "CPP/8", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> sum_product(vector<int> numbers) {\n    int total_sum = 0;\n    int product = 1;\n\n    if (numbers.empty()) {\n        return {0, 1};\n    }\n\n    for (int num : numbers) {\n        total_sum += num;\n        product *= num;\n    }\n\n    return {total_sum, product};\n}\n", "py_code": "from typing import List, Tuple\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    if not numbers:\n        return (0, 1)\n    \n    total_sum = sum(numbers)\n    product = 1\n    for num in numbers:\n        product *= num\n    \n    return (total_sum, product)\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `sum_product` takes a list of integers as input and returns a tuple containing two values: the sum of all elements in the list and the product of all elements in the list. If the input list is empty, it returns `(0, 1)` by default.\n\n- The function first checks if the list `numbers` is empty. If so, it directly returns `(0, 1)`.\n- Otherwise, it calculates the sum of all integers in the list using Python's built-in `sum()` function.\n- It then initializes a variable `product` to 1 and iterates through each number in the list, multiplying the current value of `product` by the number. This way, it computes the product of all elements in the list.\n- Finally, it returns a tuple containing the sum and the product.\n\n"}
{"task_id": "CPP/95", "generation": "#include <string>\n#include <map>\n#include <cctype>\nusing namespace std;\n\nbool is_all_lower(const string& str) {\n    for (char ch : str) {\n        if (!islower(ch)) return false;\n    }\n    return true;\n}\n\nbool is_all_upper(const string& str) {\n    for (char ch : str) {\n        if (!isupper(ch)) return false;\n    }\n    return true;\n}\n\nbool check_dict_case(map<string, string> dict) {\n    if (dict.empty()) return false;\n\n    bool all_lower = true, all_upper = true;\n\n    for (const auto& pair : dict) {\n        const string& key = pair.first;\n        if (!is_all_lower(key)) all_lower = false;\n        if (!is_all_upper(key)) all_upper = false;\n    }\n\n    return all_lower || all_upper;\n}\n", "py_code": "def check_dict_case(dict):\n    if not dict:\n        return False\n\n    all_lower = all(key.islower() for key in dict.keys())\n    all_upper = all(key.isupper() for key in dict.keys())\n\n    return all_lower or all_upper\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `check_dict_case` checks whether a given dictionary has keys that are either all lowercase strings or all uppercase strings and returns a boolean value accordingly. The function first checks if the input dictionary is empty; if it is, it immediately returns False as per the problem statement.\n\nIf the dictionary is not empty, the function then uses two generator expressions within `all()` to check whether all keys in the dictionary are lowercase (`key.islower()`) or uppercase (`key.isupper()`). The `all_lower` variable will be True if every key in the dictionary is a lowercase string and False otherwise. Similarly, the `all_upper` variable will be True if every key in the dictionary is an uppercase string.\n\nThe function returns True only if either all keys are lowercase or all keys are uppercase; otherwise, it returns False.\n```\n\n"}
{"task_id": "CPP/55", "generation": "#include <iostream>\nusing namespace std;\n\nint fib(int n) {\n    if (n <= 0) {\n        return 0;\n    } else if (n == 1) {\n        return 1;\n    } else {\n        int a = 0, b = 1;\n        for (int i = 2; i <= n; ++i) {\n            int temp = a + b;\n            a = b;\n            b = temp;\n        }\n        return b;\n    }\n}\n", "py_code": "def fib(n):\n    if n <= 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        a, b = 0, 1\n        for _ in range(2, n + 1):\n            a, b = b, a + b\n        return b\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `fib(n)` calculates the n-th Fibonacci number using an iterative approach to avoid potential stack overflow issues that can arise with recursive solutions for large values of n. The function first checks if n is less than or equal to 0 and returns 0 in such cases since there are no negative indices in the Fibonacci sequence, and the 0th element is defined as 0.\n\nIf n equals 1, it directly returns 1 because the first element (index 1) of the Fibonacci sequence is 1. For values of n greater than 1, the function initializes two variables `a` and `b` to represent the last two numbers in the current iteration of the Fibonacci sequence (`0` and `1`, respectively). It then iterates from 2 up to n, updating these variables such that `a` takes on the value of `b`, and `b` becomes the sum of `a` and `b`. This process effectively moves through the Fibonacci sequence until it reaches the desired index. The function finally returns the value of `b`, which is the n-th Fibonacci number.\n```\n\n"}
{"task_id": "CPP/29", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> filter_by_prefix(vector<string> strings, string prefix) {\n    vector<string> filtered_strings;\n    for (const auto& s : strings) {\n        if (s.find(prefix) == 0) { // Check if the string starts with the given prefix\n            filtered_strings.push_back(s);\n        }\n    }\n    return filtered_strings;\n}\n", "py_code": "def filter_by_prefix(strings, prefix):\n    return [s for s in strings if s.startswith(prefix)]\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `filter_by_prefix` takes two parameters: a list of strings (`strings`) and a string (`prefix`). It returns a new list containing only those strings from the input list that start with the specified prefix. The function uses a list comprehension to iterate over each string in the input list, checking if it starts with the given prefix using the `startswith` method. If the condition is met, the string is included in the resulting list.\n```"}
{"task_id": "CPP/72", "generation": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nbool will_it_fly(vector<int> q, int w) {\n    // Check if the list is a palindrome (balanced)\n    vector<int> reversed_q(q.rbegin(), q.rend());\n    bool is_balanced = (q == reversed_q);\n    \n    // Calculate the sum of elements in the list\n    int total_weight = 0;\n    for(int num : q) {\n        total_weight += num;\n    }\n    \n    // Return true if it's balanced and its weight is less than or equal to w\n    return is_balanced && (total_weight <= w);\n}\n", "py_code": "def will_it_fly(q, w):\n    # Check if the list is a palindrome (balanced)\n    is_balanced = q == q[::-1]\n    \n    # Calculate the sum of elements in the list\n    total_weight = sum(q)\n    \n    # Return True if it's balanced and its weight is less than or equal to w\n    return is_balanced and total_weight <= w\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `will_it_fly` takes a list of integers `q` and an integer `w` as input parameters. The function checks if the list is balanced by comparing it to its reversed version (`q == q[::-1]`). It then calculates the sum of all elements in the list using the built-in `sum()` function. Finally, it returns `True` if both conditions are met: the list is a palindrome (balanced) and the total weight of the elements does not exceed the maximum possible weight `w`. If either condition fails, the function returns `False`.\n```\n\n"}
{"task_id": "CPP/54", "generation": "#include <string>\n#include <set>\n#include <algorithm>\nusing namespace std;\n\nbool same_chars(string s0, string s1) {\n    set<char> chars_s0(s0.begin(), s0.end());\n    set<char> chars_s1(s1.begin(), s1.end());\n\n    return (chars_s0 == chars_s1);\n}\n", "py_code": "def same_chars(s0, s1):\n    return set(s0) == set(s1)\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `same_chars` takes two strings as input and checks if they contain the same kinds of characters (regardless of their frequency or order). It does this by converting each string into a set of its unique characters using the `set()` function. If both sets are equal, it means that both strings have the exact same types of characters, and the function returns `True`. Otherwise, it returns `False`. This approach effectively ignores the number of occurrences of each character in the strings and focuses only on the distinct characters present.\n```"}
{"task_id": "CPP/91", "generation": "#include <iostream>\n#include <string>\n#include <vector>\n#include <sstream>\nusing namespace std;\n\nint is_bored(string S) {\n    vector<string> sentences;\n    stringstream ss(S);\n    string token, sentence;\n    \n    // Split the input string into sentences based on delimiters '.', '?' and '!'\n    while (getline(ss, token, '.')) {\n        if (!token.empty()) sentences.push_back(token);\n        getline(ss, token, '?');\n        if (!token.empty()) sentences.push_back(token);\n        getline(ss, token, '!');\n        if (!token.empty()) sentences.push_back(token);\n    }\n\n    int boredom_count = 0;\n    \n    // Check each sentence for the condition of starting with \"I\"\n    for (const auto& s : sentences) {\n        stringstream ss(s);\n        string word;\n        ss >> word; // Extract the first word\n        if (word == \"I\") {\n            boredom_count++;\n        }\n    }\n\n    return boredom_count;\n}\n", "py_code": "def is_bored(S):\n    sentences = [sentence.strip() for sentence in re.split(r'[.?!]', S) if sentence]\n    boredom_count = sum(sentence.startswith(\"I \") or sentence == \"I\" for sentence in sentences)\n    return boredom_count\n\nimport re\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `is_bored` takes a string `S` as input and returns an integer representing the number of sentences that start with \"I\". The function first splits the input string into individual sentences using regular expressions to identify sentence delimiters ('.', '?', '!'). It then strips any leading or trailing whitespace from each sentence. \n\nThe function uses a generator expression inside the `sum` function to count how many sentences start with the word \"I\" (either followed by a space or as the only word in the sentence). The result is returned as an integer indicating the number of boredoms found in the input string.```\n\n"}
{"task_id": "CPP/77", "generation": "#include <cmath> // for cbrt function\n\nbool iscube(int a) {\n    if (a == 0 || a == 1 || a == -1) {\n        return true;\n    }\n\n    int cube_root = round(cbrt(a));\n    \n    return cube_root * cube_root * cube_root == a;\n}\n", "py_code": "def iscube(a):\n    if a == 0 or a == 1 or a == -1:\n        return True\n    \n    cube_root = round(a ** (1/3))\n    \n    return cube_root**3 == a\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `iscube` checks whether an integer `a` is a perfect cube of some integer number. The logic follows these steps:\n1. It first handles special cases where `a` can be 0, 1, or -1, which are all cubes of integers (0, 1, and -1 respectively).\n2. For other values, it calculates the cube root of `a` using exponentiation (`a ** (1/3)`) and rounds this value to the nearest integer.\n3. It then checks if raising this rounded cube root back to the power of three equals the original number `a`.\n4. If they are equal, it means that `a` is a perfect cube, so the function returns `True`. Otherwise, it returns `False`.\n\nThis approach ensures that we correctly identify whether an integer is a perfect cube by leveraging mathematical operations and rounding.\n"}
{"task_id": "CPP/73", "generation": "#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint smallest_change(vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n    int left = 0;\n    int right = n - 1;\n    \n    while (left < right) {\n        if (arr[left] != arr[right]) {\n            changes += 1;\n        }\n        left += 1;\n        right -= 1;\n    }\n    \n    return changes;\n}\n", "py_code": "def smallest_change(arr):\n    n = len(arr)\n    changes = 0\n    left = 0\n    right = n - 1\n    \n    while left < right:\n        if arr[left] != arr[right]:\n            changes += 1\n        left += 1\n        right -= 1\n    \n    return changes\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `smallest_change` takes a list of integers (`arr`) and returns the minimum number of changes required to make the list palindromic. The approach involves comparing elements from both ends of the list towards the center.\n\n1. **Initialization**: \n   - `n`: Length of the input array.\n   - `changes`: Counter for the number of changes needed, initialized to 0.\n   - `left` and `right`: Pointers starting at the beginning and end of the array respectively.\n\n2. **Iteration**:\n   - The function uses a while loop that continues as long as `left < right`.\n   - Inside the loop, it checks if the elements at positions `left` and `right` are different.\n     - If they are not equal, it increments the `changes` counter by 1 because one of these elements needs to be changed to make them equal.\n   - The pointers `left` and `right` move towards each other (`left += 1`, `right -= 1`).\n\n3. **Return**:\n   - After exiting the loop, the function returns the total number of changes needed.\n\nThis approach ensures that we only count the differences between mirrored elements in the array, which is sufficient to determine how many changes are required for a palindromic transformation.\n\n"}
{"task_id": "CPP/71", "generation": "#include <cmath> // For sqrt function\nusing namespace std;\n\nfloat triangle_area(float a, float b, float c) {\n    // Check if the sides form a valid triangle\n    if ((a + b <= c) || (a + c <= b) || (b + c <= a)) {\n        return -1;\n    }\n    \n    // Calculate the semi-perimeter\n    float s = (a + b + c) / 2.0;\n\n    // Use Heron's formula to calculate area\n    float area = sqrt(s * (s - a) * (s - b) * (s - c));\n    \n    // Round to two decimal points and return\n    return round(area * 100) / 100;\n}\n", "py_code": "import math\n\ndef triangle_area(a, b, c):\n    # Check if the sides form a valid triangle\n    if (a + b <= c) or (a + c <= b) or (b + c <= a):\n        return -1\n    \n    # Calculate the semi-perimeter\n    s = (a + b + c) / 2.0\n\n    # Use Heron's formula to calculate area\n    area = math.sqrt(s * (s - a) * (s - b) * (s - c))\n    \n    return round(area, 2)\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `triangle_area` takes three arguments representing the lengths of the sides of a triangle (a, b, c). The first check ensures that these sides can form a valid triangle by verifying if the sum of any two sides is greater than the third side. If this condition fails, the function returns -1 indicating an invalid triangle.\n\nIf the sides do form a valid triangle, the function calculates the semi-perimeter (s) as half the perimeter of the triangle. It then uses Heron's formula to compute the area of the triangle based on its sides and semi-perimeter. The result is rounded to two decimal points before being returned.\n``` \n\n"}
{"task_id": "CPP/82", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\nbool prime_length(string str) {\n    int length = str.length();\n    return is_prime(length);\n}\n", "py_code": "def is_prime(n):\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef prime_length(str):\n    length = len(str)\n    return is_prime(length)\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python solution consists of two functions: `is_prime` and `prime_length`. \n\n1. The function `is_prime(n)` checks if a given number `n` is prime or not. It first handles edge cases where numbers less than or equal to 1 are considered non-prime. Then, it iterates from 2 up to the square root of `n`, checking for any divisors that would indicate `n` is not prime.\n\n2. The function `prime_length(str)` calculates the length of the input string and uses the `is_prime` function to determine if this length is a prime number. It returns `True` if the length is prime, otherwise it returns `False`.\n\nThis approach ensures that we correctly identify whether the length of any given string is a prime number by leveraging an efficient primality test.\n\n"}
{"task_id": "CPP/114", "generation": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nlong long minSubArraySum(vector<long long> nums) {\n    if (nums.empty()) return 0;\n\n    long long current_sum = nums[0];\n    long long min_sum = nums[0];\n\n    for (size_t i = 1; i < nums.size(); ++i) {\n        // Decide whether to add the current number to the existing subarray or start a new subarray\n        current_sum = min(nums[i], current_sum + nums[i]);\n        min_sum = min(min_sum, current_sum);\n    }\n\n    return min_sum;\n}\n", "py_code": "from typing import List\n\ndef minSubArraySum(nums: List[int]) -> int:\n    if not nums:\n        return 0\n    \n    current_sum = min_sum = nums[0]\n    \n    for num in nums[1:]:\n        # Decide whether to add the current number to the existing subarray or start a new subarray\n        current_sum = min(num, current_sum + num)\n        min_sum = min(min_sum, current_sum)\n        \n    return min_sum\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `minSubArraySum` calculates the minimum sum of any non-empty subarray within a given list of integers (`nums`). The algorithm uses Kadane's Algorithm in a slightly modified form to find the minimum subarray sum instead of the maximum.\n\n1. **Initialization**: \n   - `current_sum` and `min_sum` are initialized with the first element of the array.\n   \n2. **Iteration**:\n   - For each subsequent number (`num`) in the list, the function decides whether to add this number to the current subarray sum or start a new subarray from this number by comparing `num` with `current_sum + num`.\n   - The minimum value between these two options is assigned back to `current_sum`.\n\n3. **Tracking Minimum**:\n   - During each iteration, `min_sum` keeps track of the smallest subarray sum encountered so far.\n\n4. **Return Value**:\n   - Finally, the function returns `min_sum`, which holds the minimum sum of any non-empty subarray in the input list.\n```\n\n"}
{"task_id": "CPP/138", "generation": "#include <iostream>\nusing namespace std;\n\nbool is_equal_to_sum_even(int n) {\n    // Check if the number is less than 8, in which case it cannot be expressed as a sum of four even numbers.\n    if (n < 8) {\n        return false;\n    }\n    // If the number is greater or equal to 8 and is even, then it can always be written as a sum of four even numbers.\n    return n % 2 == 0;\n}\n", "py_code": "def is_equal_to_sum_even(n):\n    # The smallest sum of 4 positive even numbers is 2 + 2 + 2 + 2 = 8.\n    # Any number less than 8 cannot be expressed as a sum of exactly four positive even numbers.\n    if n < 8:\n        return False\n    # If the number is even and greater or equal to 8, it can always be written as a sum of 4 even numbers.\n    # For example: n = 2k (where k >= 4), then we have 2 + 2 + 2 + (n - 6) which is also an even number.\n    return n % 2 == 0\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `is_equal_to_sum_even` checks if a given integer `n` can be expressed as the sum of exactly four positive even numbers. The logic is based on two key observations:\n\n1. The smallest possible sum of four positive even numbers is 8 (2+2+2+2).\n2. Any number that is greater than or equal to 8 and is also an even number can be written as a sum of four even numbers.\n\nThe function first checks if `n` is less than 8, in which case it returns `False`, because no such combination exists for numbers smaller than 8. If `n` is greater than or equal to 8 and is even (i.e., divisible by 2), the function returns `True`. This is because any even number can be broken down into a sum of four even numbers, given that it's at least 8.\n```\n\n"}
{"task_id": "CPP/132", "generation": "#include <string>\nusing namespace std;\n\nbool is_nested(string str) {\n    int max_depth = 0;\n    int current_depth = 0;\n\n    for (char c : str) {\n        if (c == '[') {\n            current_depth += 1;\n            max_depth = max(max_depth, current_depth);\n        } else if (c == ']') {\n            current_depth -= 1;\n        }\n\n        // If at any point the depth is less than zero, it means there's an unmatched closing bracket.\n        if (current_depth < 0) {\n            return false;\n        }\n    }\n\n    // Return true only if the maximum depth reached was greater than one (indicating nesting).\n    return max_depth > 1;\n}\n", "py_code": "def is_nested(s):\n    max_depth = 0\n    current_depth = 0\n    \n    for char in s:\n        if char == '[':\n            current_depth += 1\n            max_depth = max(max_depth, current_depth)\n        elif char == ']':\n            current_depth -= 1\n            \n        # If at any point the depth is less than zero, it means there's an unmatched closing bracket.\n        if current_depth < 0:\n            return False\n    \n    # Return true only if the maximum depth reached was greater than one (indicating nesting).\n    return max_depth > 1\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `is_nested` checks whether a given string of square brackets contains at least one nested subsequence of brackets. The function iterates through each character in the input string and maintains two variables: `current_depth` to track the current depth of nesting and `max_depth` to keep track of the maximum depth encountered during iteration.\n\n- If an opening bracket `[` is found, `current_depth` is incremented by 1.\n- If a closing bracket `]` is found, `current_depth` is decremented by 1.\n- The function checks if at any point `current_depth` becomes less than zero. This would indicate that there are more closing brackets than opening ones, which means the string is not valid.\n\nFinally, the function returns `True` only if `max_depth` is greater than one, indicating that there was at least one nested subsequence of brackets during the iteration.\n\n"}
{"task_id": "CPP/3", "generation": "#include <vector>\nusing namespace std;\n\nbool below_zero(vector<int> operations) {\n    int balance = 0; // Initialize balance to zero.\n    \n    for (int op : operations) { // Iterate through each operation in the vector.\n        balance += op; // Update the balance by adding or subtracting the current operation value.\n        \n        if (balance < 0) { // Check if the balance falls below zero at any point.\n            return true; // If it does, return true immediately.\n        }\n    }\n\n    return false; // If no point in operations makes the balance negative, return false.\n}\n", "py_code": "def below_zero(operations):\n    balance = 0\n    for op in operations:\n        balance += op\n        if balance < 0:\n            return True\n    return False\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `below_zero` takes a list of integers representing deposit and withdrawal operations on a bank account that starts with zero balance. The function iterates through each operation in the list, updating the current balance by adding or subtracting the value of the operation. If at any point during this iteration the balance falls below zero, the function immediately returns `True`. If the loop completes without the balance falling below zero, the function returns `False`.\n\nThis approach ensures that we can quickly determine if there is a time when the account balance goes negative by maintaining a running total of the operations and checking it against zero after each operation.\n\n"}
{"task_id": "CPP/142", "generation": "#include <vector>\nusing namespace std;\n\nint sum_squares(vector<int> lst) {\n    int result = 0;\n    for (size_t i = 0; i < lst.size(); ++i) {\n        if (i % 3 == 0) {\n            result += lst[i] * lst[i]; // Square the integer\n        } else if (i % 4 == 0 && i % 3 != 0) {\n            result += lst[i] * lst[i] * lst[i]; // Cube the integer\n        } else {\n            result += lst[i];\n        }\n    }\n    return result;\n}\n", "py_code": "def sum_squares(lst):\n    result = 0\n    for i in range(len(lst)):\n        if i % 3 == 0:\n            result += lst[i] ** 2\n        elif i % 4 == 0:\n            result += lst[i] ** 3\n        else:\n            result += lst[i]\n    return result\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `sum_squares` takes a list of integers as input and calculates the sum of all entries in the list according to specific rules based on their index positions:\n- If an entry's index is a multiple of 3 (i.e., `index % 3 == 0`), it squares that integer.\n- If an entry's index is a multiple of 4 but not a multiple of 3 (i.e., `index % 4 == 0 and index % 3 != 0`), it cubes that integer.\n- For all other indices, the function adds the integer as-is to the sum.\n\nThe function iterates through each element in the list using its index. It checks whether the current index meets any of the conditions for squaring or cubing and performs the appropriate operation before adding the result to a running total (`result`). Finally, it returns the accumulated sum after processing all elements in the list.\n\n"}
{"task_id": "CPP/50", "generation": "#include <string>\nusing namespace std;\n\n// Function to encode a string by shifting every character by 5 in the alphabet.\nstring encode_shift(string s) {\n    string out;\n    int i;\n    for (i = 0; i < s.length(); i++) {\n        // Shift each character by 5 positions within the range of 'a' to 'z'\n        int w = ((int)s[i] + 5 - (int)'a') % 26 + (int)'a';\n        out += (char)w;\n    }\n    return out;\n}\n\n// Function to decode a string that was encoded with encode_shift function.\nstring decode_shift(string s) {\n    string out;\n    int i;\n    for (i = 0; i < s.length(); i++) {\n        // Reverse the shift by moving backward by 5 positions within the range of 'a' to 'z'\n        int w = ((int)s[i] - (int)'a' - 5 + 26) % 26 + (int)'a';\n        out += (char)w;\n    }\n    return out;\n}\n", "py_code": "def encode_shift(s):\n    # returns encoded string by shifting every character by 5 in the alphabet.\n    out = \"\"\n    for char in s:\n        shifted_char = chr(((ord(char) - ord('a') + 5) % 26) + ord('a'))\n        out += shifted_char\n    return out\n\ndef decode_shift(s):\n    # takes as input string encoded with encode_shift function. Returns decoded string.\n    out = \"\"\n    for char in s:\n        original_char = chr(((ord(char) - ord('a') - 5 + 26) % 26) + ord('a'))\n        out += original_char\n    return out\n```\n\n", "py_summary": "### Second Step: Analyse the Python Code\n\nThe provided Python code consists of two functions: `encode_shift` and `decode_shift`. Both functions operate on strings by shifting each character in the string by a fixed number (5) within the range of lowercase alphabets ('a' to 'z').\n\n1. **Function `encode_shift(s)`**:\n   - This function takes a string `s` as input.\n   - It iterates over each character in the string, converts it to its corresponding ASCII value using `ord()`, and then shifts this value by 5 positions within the range of lowercase alphabets ('a' to 'z').\n   - The formula used for shifting is: \n     \\[\n     \\text{shifted\\_char} = ((\\text{ASCII\\_value\\_of\\_char} - \\text{ASCII\\_value\\_of\\_'}a'\\) + 5) \\% 26) + \\text{ASCII\\_value\\_of\\_'}a'\\\n     \\]\n   - The shifted character is then converted back to a character using `chr()` and appended to the output string.\n   \n2. **Function `decode_shift(s)`**:\n   - This function takes an encoded string `s` as input, which was previously encoded by `encode_shift`.\n   - It reverses the encoding process by shifting each character in the string back by 5 positions within the range of lowercase alphabets ('a' to 'z').\n   - The formula used for reversing the shift is:\n     \\[\n     \\text{original\\_char} = ((\\text{ASCII\\_value\\_of\\_char} - \\text{ASCII\\_value\\_of\\_'}a'\\) - 5 + 26) \\% 26) + \\text{ASCII\\_value\\_of\\_'}a'\\\n     \\]\n   - The original character is then converted back to a character using `chr()` and appended to the output string.\n\n### Summary:\n- Both functions handle lowercase alphabets only.\n- They use modular arithmetic to ensure that characters wrap around within the range of 'a' to 'z'.\n- The encoding function shifts each character by 5 positions forward, while the decoding function reverses this shift by moving backward by 5 positions.\n\n### Last Step: Generate C++ Solution\n\nBased on the Python code and its analysis, we can now generate the equivalent C++ functions for `encode_shift` and `decode_shift`.\n\n"}
{"task_id": "CPP/103", "generation": "#include <iostream>\n#include <cmath>\n#include <string>\n#include <bitset>\nusing namespace std;\n\nstring rounded_avg(int n, int m) {\n    if (n > m) return \"-1\";\n\n    long total_sum = 0;\n    for (int i = n; i <= m; ++i) {\n        total_sum += i;\n    }\n    \n    int count = m - n + 1;\n    int average = total_sum / count;\n\n    string binary_representation = bitset<32>(average).to_string();\n    // Remove leading zeros\n    size_t first_one = binary_representation.find('1');\n    if (first_one != string::npos) {\n        return binary_representation.substr(first_one);\n    }\n    return \"0\";  // In case the average is zero.\n}\n", "py_code": "def rounded_avg(n, m):\n    if n > m:\n        return \"-1\"\n    \n    total_sum = sum(range(n, m + 1))\n    count = m - n + 1\n    average = total_sum // count\n    \n    return bin(average)[2:]\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `rounded_avg` calculates the rounded average of integers from n to m (inclusive) and returns this value in binary format as a string. If n is greater than m, it immediately returns \"-1\". The function first checks if n is greater than m; if so, it returns \"-1\" indicating an invalid range. Otherwise, it computes the sum of all integers between n and m using `sum(range(n, m + 1))`. It then calculates the count of numbers in this range as `(m - n + 1)`. The average is computed by integer division (`//`) to ensure rounding down to the nearest whole number. Finally, it converts this average into a binary string using `bin()` and slices off the '0b' prefix with `[2:]` before returning it.\n``` \n\n"}
{"task_id": "CPP/57", "generation": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nbool monotonic(vector<float> l) {\n    bool increasing = true;\n    bool decreasing = true;\n    \n    for (size_t i = 1; i < l.size(); ++i) {\n        if (l[i] < l[i - 1]) {\n            increasing = false;\n        }\n        if (l[i] > l[i - 1]) {\n            decreasing = false;\n        }\n    }\n\n    return increasing || decreasing;\n}\n", "py_code": "def monotonic(l):\n    increasing = all(x <= y for x, y in zip(l, l[1:]))\n    decreasing = all(x >= y for x, y in zip(l, l[1:]))\n    return increasing or decreasing\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `monotonic` checks whether a list of numbers is either monotonically increasing or decreasing. It does this by using two generator expressions within the built-in `all()` function to check if all adjacent pairs in the list satisfy the conditions for being monotonically increasing (`x <= y`) and monotonically decreasing (`x >= y`). The `zip(l, l[1:])` creates pairs of consecutive elements from the list. If either condition is true (i.e., all pairs are in non-decreasing order or all pairs are in non-increasing order), the function returns `True`. Otherwise, it returns `False`.\n```\n\n"}
{"task_id": "CPP/28", "generation": "#include <vector>\n#include <string>\nusing namespace std;\n\nstring concatenate(vector<string> strings) {\n    string result = \"\";\n    for (const auto& str : strings) {\n        result += str;\n    }\n    return result;\n}\n", "py_code": "from typing import List\n\ndef concatenate(strings: List[str]) -> str:\n    return ''.join(strings)\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `concatenate` takes a list of strings as input and returns a single string that is the concatenation of all the strings in the list. The function uses the built-in `join` method to concatenate the elements of the list without any separator between them. If the input list is empty, it simply returns an empty string.\n```\n\n\n"}
{"task_id": "CPP/39", "generation": "#include <cmath>\n#include <vector>\n\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    for (int i = 2; i * i <= num; ++i) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\nint prime_fib(int n) {\n    std::vector<int> fib{0, 1};\n    int count = 0;\n\n    while (count < n) {\n        int next_fib = fib.back() + fib[fib.size() - 2];\n        fib.push_back(next_fib);\n\n        if (is_prime(next_fib)) {\n            ++count;\n        }\n\n        if (count == n) {\n            return next_fib;\n        }\n    }\n}\n", "py_code": "def is_prime(num):\n    if num <= 1:\n        return False\n    for i in range(2, int(num**0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef prime_fib(n):\n    fib = [0, 1]\n    count = 0\n    index = 2\n    \n    while count < n:\n        next_fib = fib[-1] + fib[-2]\n        fib.append(next_fib)\n        \n        if is_prime(next_fib):\n            count += 1\n        \n        if count == n:\n            return next_fib\n        \n        index += 1\n```\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python solution consists of two functions: `is_prime` and `prime_fib`. \n\n- The function `is_prime(num)` checks if a given number is prime by iterating from 2 to the square root of the number and checking for any divisors. If no divisor is found, it returns True indicating that the number is prime.\n\n- The function `prime_fib(n)` generates Fibonacci numbers until it finds the n-th Fibonacci number that is also prime:\n    - It initializes a list `fib` with the first two Fibonacci numbers `[0, 1]`.\n    - A counter `count` keeps track of how many prime Fibonacci numbers have been found.\n    - The loop continues to generate new Fibonacci numbers and checks if they are prime using the `is_prime` function. If a number is prime, it increments the count.\n    - Once the required n-th prime Fibonacci number is found (when `count == n`), the function returns that number.\n\nThis approach ensures that we find the exact n-th Fibonacci number which is also prime by generating and checking each subsequent Fibonacci number until the condition is met. \n\n"}
{"task_id": "CPP/45", "generation": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n\nfloat triangle_area(float a, float h) {\n    return 0.5 * a * h;\n}\n", "py_code": "def triangle_area(a, h):\n    return 0.5 * a * h\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `triangle_area` calculates and returns the area of a triangle given its base length (`a`) and height (`h`). The formula used is `(0.5 * a * h)`, which is derived from the standard geometric formula for calculating the area of a triangle: half the product of the base and the height.``` \n\n"}
{"task_id": "CPP/145", "generation": "#include <stdio.h>\n#include <math.h>\n#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nint sum_of_digits(int n) {\n    int sum = 0;\n    bool is_negative = n < 0;\n    while (n != 0) {\n        sum += n % 10;\n        n /= 10;\n    }\n    return is_negative ? -sum : sum;\n}\n\nstruct CustomComparator {\n    vector<int>& nums;\n    explicit CustomComparator(vector<int>& nums) : nums(nums) {}\n\n    bool operator()(int a, int b) {\n        int sum_a = sum_of_digits(a);\n        int sum_b = sum_of_digits(b);\n\n        if (sum_a != sum_b) return sum_a < sum_b;\n\n        // If sums are equal, compare based on original index\n        auto it_a = find(nums.begin(), nums.end(), a);\n        auto it_b = find(nums.begin(), nums.end(), b);\n        return distance(nums.begin(), it_a) < distance(nums.begin(), it_b);\n    }\n};\n\nvector<int> order_by_points(vector<int> nums) {\n    CustomComparator comp(nums);\n    sort(nums.begin(), nums.end(), comp);\n    return nums;\n}\n", "py_code": "from typing import List\n\ndef sum_of_digits(n: int) -> int:\n    return sum(int(digit) for digit in str(n))\n\ndef order_by_points(nums: List[int]) -> List[int]:\n    return sorted(nums, key=lambda x: (sum_of_digits(x), nums.index(x)))\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python code defines a function `order_by_points` that takes a list of integers as input and returns a new list sorted in ascending order based on the sum of their digits. The function uses an auxiliary function `sum_of_digits` to calculate the sum of digits for each integer.\n\n1. **Auxiliary Function (`sum_of_digits`)**: This function converts the number into its string representation, iterates over each character (digit), and calculates the sum of these digits by converting them back to integers.\n2. **Main Function (`order_by_points`)**: The main function uses Python's `sorted()` method with a custom key. The key is defined as a lambda function that returns a tuple `(sum_of_digits(x), nums.index(x))`. This ensures that the list is first sorted by the sum of digits and then, in case of ties (i.e., if two numbers have the same digit sum), by their original index in the input list.\n\nThe result is a new list where integers are ordered based on the criteria specified.```\n\n"}
{"task_id": "CPP/84", "generation": "#include <iostream>\n#include <string>\n#include <bitset>\nusing namespace std;\n\nstring solve(int N) {\n    int digit_sum = 0;\n    while (N > 0) {\n        digit_sum += N % 10;\n        N /= 10;\n    }\n    \n    // Convert the sum to binary using bitset\n    bitset<14> binary(digit_sum); // 14 bits is enough for max possible sum of digits (36 in decimal)\n    string result = binary.to_string();\n    \n    // Remove leading zeros\n    size_t first_one = result.find('1');\n    if (first_one != string::npos) {\n        result = result.substr(first_one);\n    } else {\n        result = \"0\";  // In case the sum is zero\n    }\n    \n    return result;\n}\n", "py_code": "def solve(N):\n    # Calculate the sum of digits of N\n    digit_sum = sum(int(digit) for digit in str(N))\n    # Convert the sum to binary and remove the '0b' prefix\n    return bin(digit_sum)[2:]\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `solve(N)` takes an integer N as input and returns a string representing the binary form of the sum of its digits. The function first converts the integer to a string in order to iterate over each digit. It then calculates the sum of these digits by converting each character back into an integer and using the built-in `sum` function on this sequence.\n\nAfter calculating the sum, the function uses Python's built-in `bin()` function to convert the sum into its binary representation. The result from `bin()` includes a '0b' prefix which indicates that the number is in binary format; however, since we only want the binary digits themselves, we slice off this prefix using `[2:]`.\n\nFinally, the function returns the resulting string of binary digits.\n```\n\n"}
{"task_id": "CPP/113", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nvector<string> odd_count(vector<string> lst) {\n    vector<string> result;\n    for (const string& s : lst) {\n        int count = 0;\n        // Count the number of odd digits in the current string\n        for (char c : s) {\n            if (c == '1' || c == '3' || c == '5' || c == '7' || c == '9') {\n                ++count;\n            }\n        }\n\n        // Construct the output string with replacements\n        string output_str = \"the number of odd elements \" + to_string(count) +\n                            \"n the str\" + to_string(count) +\n                            \"ng \" + to_string(count) +\n                            \" of the \" + to_string(count) + \"nput.\";\n        \n        result.push_back(output_str);\n    }\n    \n    return result;\n}\n", "py_code": "def odd_count(lst):\n    result = []\n    for s in lst:\n        count = sum(c in '13579' for c in s)\n        output_str = \"the number of odd elements {}n the str{}ng {} of the {}nput.\".format(count, count, count, count)\n        result.append(output_str)\n    return result\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `odd_count` takes a list of strings (`lst`) as input and returns a list of formatted strings based on the number of odd digits in each string from the input list.\n\n1. For each string `s` in the input list `lst`, it counts how many characters are odd digits (i.e., '1', '3', '5', '7', or '9') using a generator expression inside the `sum()` function.\n2. It then constructs an output string by replacing all occurrences of `{}` with the count of odd digits in the template string `\"the number of odd elements {}n the str{}ng {} of the {}nput.\"`.\n3. The constructed string is appended to the result list.\n4. Finally, it returns the result list containing the formatted strings for each input string.\n\nThis approach ensures that each output string reflects the count of odd digits in its corresponding input string and follows the specified format.```"}
{"task_id": "CPP/36", "generation": "#include <string>\n#include <algorithm>\n\nint fizz_buzz(int n) {\n    int count = 0;\n    for (int i = 1; i < n; ++i) {\n        if ((i % 11 == 0 || i % 13 == 0)) {\n            std::string num_str = std::to_string(i);\n            // Count the number of '7's in the string representation\n            count += std::count(num_str.begin(), num_str.end(), '7');\n        }\n    }\n    return count;\n}\n", "py_code": "def fizz_buzz(n):\n    count = 0\n    for i in range(1, n):\n        if (i % 11 == 0 or i % 13 == 0) and '7' in str(i):\n            count += str(i).count('7')\n    return count\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `fizz_buzz` takes an integer `n` as input and returns the number of times the digit '7' appears in integers less than `n` that are divisible by either 11 or 13.\n\nThe function iterates over all numbers from 1 to n-1. For each number, it checks if the number is divisible by 11 or 13 using the modulo operator (`%`). If the condition is met, it converts the number into a string and checks whether '7' appears in that string representation of the number.\n\nIf '7' is found within the string representation, `str(i).count('7')` counts how many times '7' occurs in the number. The count is then added to the total count variable `count`. Finally, after iterating through all numbers less than `n`, the function returns the accumulated count of occurrences of the digit '7'.```\n\n"}
{"task_id": "CPP/144", "generation": "#include <string>\n#include <sstream>\nusing namespace std;\n\nbool simplify(string x, string n) {\n    int num1, den1, num2, den2;\n    \n    // Extracting numerator and denominator from the fractions.\n    size_t slashPos = x.find('/');\n    stringstream(x.substr(0, slashPos)) >> num1;\n    stringstream(x.substr(slashPos + 1)) >> den1;\n\n    slashPos = n.find('/');\n    stringstream(n.substr(0, slashPos)) >> num2;\n    stringstream(n.substr(slashPos + 1)) >> den2;\n\n    // Simplify by multiplying numerator of one fraction with denominator of another.\n    int result_num = num1 * num2;\n    int result_den = den1 * den2;\n\n    return (result_num % result_den == 0);\n}\n", "py_code": "def simplify(x: str, n: str) -> bool:\n    num1, den1 = map(int, x.split('/'))\n    num2, den2 = map(int, n.split('/'))\n\n    # Simplify by multiplying numerator of one fraction with denominator of another.\n    result_num = num1 * num2\n    result_den = den1 * den2\n\n    return result_num % result_den == 0\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `simplify` takes two string arguments representing fractions and returns a boolean indicating whether their product is a whole number. The function first splits each fraction into its numerator and denominator parts by splitting on the '/' character and converts them to integers.\n\nIt then calculates the result of multiplying these fractions as if they were being multiplied together, which involves multiplying the numerators together and the denominators together. \n\nThe function checks whether this product is a whole number by verifying if `result_num` (the numerator of the resulting fraction) is divisible by `result_den` (the denominator). If it is, then the result is a whole number, and the function returns True; otherwise, it returns False.\n```\n\n"}
{"task_id": "CPP/0", "generation": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nbool has_close_elements(vector<float> numbers, float threshold) {\n    sort(numbers.begin(), numbers.end());\n    for (size_t i = 0; i < numbers.size() - 1; ++i) {\n        if (abs(numbers[i] - numbers[i + 1]) < threshold) {\n            return true;\n        }\n    }\n    return false;\n}\n", "py_code": "from typing import List\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    numbers.sort()\n    for i in range(len(numbers) - 1):\n        if abs(numbers[i] - numbers[i + 1]) < threshold:\n            return True\n    return False\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `has_close_elements` takes a list of floating-point numbers and a threshold value as input parameters. The goal is to determine if there are any two consecutive elements in the sorted list that have an absolute difference less than the given threshold.\n\n1. **Sorting**: The function first sorts the list of numbers in ascending order using the `sort()` method.\n2. **Iteration and Comparison**: It then iterates through the sorted list, comparing each element with its next neighbor to check if their absolute difference is smaller than the provided threshold.\n3. **Return Value**: If such a pair is found where the difference between two consecutive elements is less than the threshold, the function returns `True`. Otherwise, it continues checking until all pairs have been evaluated and eventually returns `False` if no such pair exists.\n\nThis approach ensures that we only need to check adjacent elements in the sorted list for closeness, which simplifies the problem significantly. The time complexity of this solution is dominated by the sorting step, making it O(n log n), where n is the number of elements in the input list.\n```\n\n"}
{"task_id": "CPP/17", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <sstream>\nusing namespace std;\n\nvector<int> parse_music(string music_string) {\n    vector<int> beats;\n    stringstream ss(music_string);\n    string note;\n    \n    while (getline(ss, note, ' ')) {\n        if (note == \"o\") {\n            beats.push_back(4);\n        } else if (note == \"o|\") {\n            beats.push_back(2);\n        } else if (note == \".|\") {\n            beats.push_back(1);\n        }\n    }\n    \n    return beats;\n}\n", "py_code": "def parse_music(music_string):\n    notes = music_string.split()\n    beats = []\n    for note in notes:\n        if note == \"o\":\n            beats.append(4)\n        elif note == \"o|\":\n            beats.append(2)\n        elif note == \".|\":\n            beats.append(1)\n    return beats\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `parse_music` takes a string representing musical notes in a special ASCII format and returns a list of integers corresponding to how many beats each note lasts. The input string is split into individual notes using spaces as delimiters. For each note, the function checks its type based on the legend provided (\"o\" for whole notes, \"o|\" for half notes, and \".|\" for quarter notes) and appends the corresponding number of beats (4, 2, or 1 respectively) to a list called `beats`. Finally, the function returns this list.```\n\n"}
{"task_id": "CPP/47", "generation": "#include <stdio.h>\n#include <math.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nfloat median(vector<float> l) {\n    sort(l.begin(), l.end());\n    int n = l.size();\n    if (n % 2 == 1) {\n        return l[n / 2];\n    } else {\n        float mid_index = n / 2;\n        return (l[mid_index - 1] + l[mid_index]) / 2.0;\n    }\n}\n", "py_code": "from typing import List\n\ndef median(l: List[float]) -> float:\n    sorted_l = sorted(l)\n    n = len(sorted_l)\n    if n % 2 == 1:\n        return sorted_l[n // 2]\n    else:\n        mid_index = n // 2\n        return (sorted_l[mid_index - 1] + sorted_l[mid_index]) / 2.0\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `median` calculates and returns the median of a list of numbers (`l`). The steps are as follows:\n1. **Sorting**: It first sorts the input list `l`.\n2. **Length Check**: It checks if the length of the sorted list is odd or even.\n3. **Odd Length Case**: If the length is odd, it returns the middle element directly.\n4. **Even Length Case**: If the length is even, it calculates the average of the two middle elements and returns this value.\n\nThis approach ensures that the median is correctly computed for both odd and even lengths of input lists.\n\n\n"}
{"task_id": "CPP/75", "generation": "#include <vector>\n#include <cmath>\nusing namespace std;\n\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\nbool is_multiply_prime(int a) {\n    vector<int> primes;\n    // Generate list of prime numbers less than 100\n    for (int i = 2; i < 100; ++i) {\n        if (is_prime(i)) {\n            primes.push_back(i);\n        }\n    }\n\n    // Check all combinations of three primes to see if their product equals 'a'\n    for (size_t i = 0; i < primes.size(); ++i) {\n        for (size_t j = i; j < primes.size(); ++j) {\n            for (size_t k = j; k < primes.size(); ++k) {\n                if (primes[i] * primes[j] * primes[k] == a) {\n                    return true;\n                }\n            }\n        }\n    }\n\n    // If no combination of three primes multiplies to 'a', return false\n    return false;\n}\n", "py_code": "def is_multiply_prime(a):\n    def is_prime(n):\n        if n <= 1:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    primes = [i for i in range(2, 100) if is_prime(i)]\n    \n    for i in primes:\n        for j in primes:\n            for k in primes:\n                if i * j * k == a:\n                    return True\n    return False\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `is_multiply_prime(a)` checks whether the given number `a` can be expressed as the product of three prime numbers, with each prime being less than 100.\n\n1. **Helper Function**: The inner function `is_prime(n)` determines if a number `n` is prime by checking divisibility from 2 up to the square root of `n`. If any divisor exists, it returns `False`; otherwise, it returns `True`.\n\n2. **Prime List Generation**: A list comprehension generates all prime numbers less than 100 using the `is_prime` function.\n\n3. **Triple Nested Loops**: The main logic uses three nested loops to iterate over the generated primes and checks if any combination of three primes (i, j, k) multiplies to equal `a`. If such a combination is found, it returns `True`.\n\n4. **Return Statement**: If no valid combination is found after exhausting all possibilities, the function returns `False`.\n\nThis approach ensures that we check every possible triplet of prime numbers less than 100 and determine if their product equals the input number `a`. \n\n"}
{"task_id": "CPP/124", "generation": "#include <string>\n#include <vector>\n#include <sstream>\nusing namespace std;\n\nbool valid_date(string date) {\n    // Check if the string is empty or does not contain exactly two hyphens.\n    if (date.empty() || count(date.begin(), date.end(), '-') != 2)\n        return false;\n    \n    vector<string> parts;\n    stringstream ss(date);\n    string part;\n    \n    // Split the date into month, day, and year components\n    while (getline(ss, part, '-')) {\n        parts.push_back(part);\n    }\n    \n    if (parts.size() != 3)\n        return false;\n\n    int month = stoi(parts[0]);\n    int day = stoi(parts[1]);\n    int year = stoi(parts[2]);\n\n    // Check the validity of the month\n    if (month < 1 || month > 12) \n        return false;\n    \n    // Check the validity of the day based on the month\n    if ((month == 4 || month == 6 || month == 9 || month == 11) && (day < 1 || day > 30)) {\n        return false;\n    } else if ((month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) && (day < 1 || day > 31)) {\n        return false;\n    } else if (month == 2 && (day < 1 || day > 29)) { // February\n        return false;\n    }\n\n    return true;\n}\n", "py_code": "def valid_date(date: str) -> bool:\n    if not date or len(date.split('-')) != 3:\n        return False\n\n    month, day, year = date.split('-')\n    \n    # Check for correct format and range of values\n    if not (month.isdigit() and day.isdigit() and year.isdigit()):\n        return False\n    \n    month, day, year = int(month), int(day), int(year)\n    \n    if month < 1 or month > 12:\n        return False\n\n    if month in [1,3,5,7,8,10,12]:\n        if day < 1 or day > 31:\n            return False\n    elif month in [4,6,9,11]:\n        if day < 1 or day > 30:\n            return False\n    else: # February\n        if day < 1 or day > 29:\n            return False\n\n    return True\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `valid_date` takes a string representing a date and checks if it is valid according to specific rules.\n\n1. **Initial Checks**: The function first ensures that the input string is not empty and contains exactly three parts separated by hyphens (`-`). If these conditions are not met, the function returns `False`.\n\n2. **Splitting the Date String**: The date string is split into month, day, and year components using the `-` delimiter.\n\n3. **Type Validation**: It checks if each component (month, day, year) consists only of digits by verifying that they can be converted to integers without raising an exception. If any part contains non-digit characters, the function returns `False`.\n\n4. **Month Range Check**: The month is checked to ensure it falls within the valid range from 1 to 12.\n\n5. **Day Range Checks**:\n   - For months with 31 days (January, March, May, July, August, October, December), the day must be between 1 and 31.\n   - For months with 30 days (April, June, September, November), the day must be between 1 and 30.\n   - For February, the day must be between 1 and 29.\n\n6. **Return Value**: If all checks pass, the function returns `True`, indicating that the date is valid according to the specified rules.\n\n"}
{"task_id": "CPP/101", "generation": "#include <string>\n#include <vector>\n#include <sstream>\nusing namespace std;\n\nvector<string> words_string(string s) {\n    // Replace all commas with spaces.\n    for (size_t pos = 0; (pos = s.find(',')) != string::npos;) {\n        s.replace(pos, 1, \" \");\n    }\n\n    vector<string> result;\n    stringstream ss(s);\n    string word;\n\n    // Split the modified string by spaces and store in a vector.\n    while (ss >> word) {\n        result.push_back(word);\n    }\n    \n    return result;\n}\n", "py_code": "def words_string(s):\n    # Replace commas with spaces and then split by spaces.\n    return [word for word in s.replace(',', '').split()]\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `words_string` takes a string as input and returns a list of words that were originally separated by commas or spaces in the input string. The function first replaces all commas with spaces using the `replace` method to ensure consistent delimiters for splitting. It then splits the modified string into individual words based on spaces using the `split` method, which returns a list of these words. This approach ensures that both commas and spaces are treated as word separators, resulting in a clean list of words without any punctuation or extra spacing issues.\n```\n\n\n"}
{"task_id": "CPP/14", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> all_prefixes(string str) {\n    vector<string> prefixes;\n    for (size_t i = 1; i <= str.size(); ++i) {\n        prefixes.push_back(str.substr(0, i));\n    }\n    return prefixes;\n}\n", "py_code": "def all_prefixes(str):\n    return [str[:i+1] for i in range(len(str))]\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `all_prefixes` takes a string as input and returns a list of all possible prefixes of that string, from shortest to longest. The function uses a list comprehension to generate these prefixes by slicing the input string up to each index (inclusive) in its length range. For example, for an input string \"abc\", it will return [\"a\", \"ab\", \"abc\"].```\n\n"}
{"task_id": "CPP/141", "generation": "#include <iostream>\n#include <string>\n#include <cctype> // for isalpha function\n\nusing namespace std;\n\nstring file_name_check(string file_name) {\n    // Check if there is exactly one dot in the filename\n    int dot_count = 0;\n    for (char c : file_name) {\n        if (c == '.') dot_count++;\n    }\n    if (dot_count != 1) return \"No\";\n    \n    // Split the filename into two parts: before and after the dot\n    size_t dot_position = file_name.find('.');\n    string name_part = file_name.substr(0, dot_position);\n    string extension_part = file_name.substr(dot_position + 1);\n\n    // Validate the part before the dot\n    if (name_part.empty() || !isalpha(name_part[0])) return \"No\";\n    \n    int digit_count = 0;\n    for (char c : name_part) {\n        if (isdigit(c)) digit_count++;\n    }\n    if (digit_count > 3) return \"No\";\n\n    // Validate the part after the dot\n    string valid_extensions[] = {\"txt\", \"exe\", \"dll\"};\n    bool is_valid_extension = false;\n    for (const auto& ext : valid_extensions) {\n        if (extension_part == ext) {\n            is_valid_extension = true;\n            break;\n        }\n    }\n\n    if (!is_valid_extension) return \"No\";\n\n    return \"Yes\";\n}\n", "py_code": "def file_name_check(file_name):\n    # Check if there is exactly one dot in the filename\n    if file_name.count('.') != 1:\n        return \"No\"\n    \n    # Split the filename into two parts: before and after the dot\n    name_parts = file_name.split('.')\n    \n    # Validate the part before the dot\n    if not (name_parts[0] and name_parts[0][0].isalpha() and sum(c.isdigit() for c in name_parts[0]) <= 3):\n        return \"No\"\n    \n    # Validate the part after the dot\n    valid_extensions = {\"txt\", \"exe\", \"dll\"}\n    if name_parts[1] not in valid_extensions:\n        return \"No\"\n    \n    return \"Yes\"\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `file_name_check` is designed to validate a file name based on specific criteria. The function takes a string representing a file's name and returns \"Yes\" if the filename meets all of the given conditions or \"No\" otherwise.\n\n1. **Dot Count Check**: The first condition checks whether there is exactly one dot in the filename using `file_name.count('.') != 1`. If this condition fails, the function immediately returns \"No\".\n\n2. **Splitting the Filename**: The filename is split into two parts: before and after the dot, using `name_parts = file_name.split('.')`.\n\n3. **Validation of the Prefix**:\n    - Checks if the prefix (part before the dot) is not empty.\n    - Ensures that the first character of the prefix is a letter from the Latin alphabet (`isalpha()`).\n    - Counts and checks whether there are no more than three digits in the prefix using `sum(c.isdigit() for c in name_parts[0]) <= 3`.\n\n4. **Validation of the Extension**: The function checks if the extension (part after the dot) is one of the valid extensions: \"txt\", \"exe\", or \"dll\". This is done by checking membership in a set of valid extensions.\n\n5. If all conditions are met, the function returns \"Yes\".\n\n"}
{"task_id": "CPP/123", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> get_odd_collatz(int n) {\n    vector<int> sequence;\n    while (n != 1) {\n        sequence.push_back(n);\n        if (n % 2 == 0) {\n            n /= 2;\n        } else {\n            n = 3 * n + 1;\n        }\n    }\n    sequence.push_back(1); // Adding the final term, which is always 1.\n\n    vector<int> odd_numbers;\n    for (int num : sequence) {\n        if (num % 2 != 0) {\n            odd_numbers.push_back(num);\n        }\n    }\n\n    sort(odd_numbers.begin(), odd_numbers.end());\n    return odd_numbers;\n}\n", "py_code": "def get_odd_collatz(n):\n    sequence = []\n    while n != 1:\n        sequence.append(n)\n        if n % 2 == 0:\n            n //= 2\n        else:\n            n = 3 * n + 1\n    sequence.append(1) # Adding the final term, which is always 1.\n    \n    odd_numbers = [num for num in sequence if num % 2 != 0]\n    return sorted(odd_numbers)\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `get_odd_collatz` takes a positive integer `n` and returns a sorted list of odd numbers in its Collatz sequence. The Collatz sequence is generated by repeatedly applying the following rules: if `n` is even, divide it by 2; if `n` is odd, multiply it by 3 and add 1. This process continues until `n` becomes 1.\n\nThe function initializes an empty list called `sequence`. It then enters a loop that continues until `n` equals 1. During each iteration of the loop:\n- The current value of `n` is appended to the sequence.\n- If `n` is even, it is divided by 2 (using integer division).\n- If `n` is odd, it is transformed into `3 * n + 1`.\n\nAfter exiting the loop, the function appends the final term, which is always 1. It then creates a list of only the odd numbers from the sequence using a list comprehension and returns this sorted list.\n\nThis approach ensures that all odd numbers in the Collatz sequence are captured and returned in increasing order.\n```\n\n"}
{"task_id": "CPP/148", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nvector<string> bf(string planet1, string planet2) {\n    vector<string> planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n    \n    auto it1 = find(planets.begin(), planets.end(), planet1);\n    auto it2 = find(planets.begin(), planets.end(), planet2);\n\n    if (it1 == planets.end() || it2 == planets.end()) {\n        return {};\n    }\n\n    int index1 = distance(planets.begin(), it1);\n    int index2 = distance(planets.begin(), it2);\n\n    // Ensure the indices are sorted\n    int start_index = min(index1, index2);\n    int end_index = max(index1, index2);\n\n    vector<string> result;\n    for (int i = start_index + 1; i < end_index; ++i) {\n        result.push_back(planets[i]);\n    }\n\n    return result;\n}\n", "py_code": "def bf(planet1: str, planet2: str) -> list:\n    planets = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n    \n    if planet1 not in planets or planet2 not in planets:\n        return []\n    \n    index1, index2 = planets.index(planet1), planets.index(planet2)\n    \n    # Ensure the indices are sorted\n    start_index, end_index = min(index1, index2), max(index1, index2)\n\n    return planets[start_index + 1:end_index]\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `bf` takes two strings representing planet names and returns a list of planet names that are located between these two planets in terms of their distance from the Sun. The function first defines an ordered list of all eight planets in our solar system according to their proximity to the Sun.\n\nIt then checks if both input planet names exist within this predefined list. If either name is not found, it returns an empty list indicating that one or both inputs are invalid.\n\nIf both planet names are valid, the function finds their indices in the ordered list and determines which index comes first (closer to the Sun). It then slices the list from the position just after the smaller index up to but not including the larger index. This slice contains all planets located between the two input planets, sorted by proximity to the Sun.\n\nFinally, it returns this sliced list of planet names.\n```\n\n"}
{"task_id": "CPP/133", "generation": "#include <stdio.h>\n#include <math.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint sum_squares(vector<float> lst) {\n    int result = 0;\n    for (float num : lst) {\n        float ceil_num = ceil(num);\n        result += static_cast<int>(ceil_num * ceil_num);\n    }\n    return result;\n}\n", "py_code": "from math import ceil\n\ndef sum_squares(lst):\n    return sum(ceil(x) ** 2 for x in lst)\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `sum_squares` takes a list of floating-point numbers as input and returns the sum of their squared values after rounding each number to the nearest integer towards positive infinity (ceiling). The function uses a generator expression inside the `sum()` function to iterate over each element in the list, apply the ceiling operation using `ceil()`, square it, and then sum up all these squared values. This approach ensures that each number is rounded up before squaring and summing, as required by the problem statement.```\n\n"}
{"task_id": "CPP/109", "generation": "#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nbool move_one_ball(vector<int> arr) {\n    if (arr.empty()) {  // If the array is empty, return true.\n        return true;\n    }\n\n    int n = arr.size();\n    int count = 0;\n    int index = -1;  // To store the position where an element is smaller than its predecessor.\n\n    for (int i = 1; i < n; ++i) {\n        if (arr[i] < arr[i-1]) {\n            count++;\n            index = i;\n        }\n    }\n\n    // Check conditions based on the analysis from Python code.\n    if ((count == 1 && arr[0] >= arr.back()) || count == 0) {\n        return true;\n    } else {\n        return false;\n    }\n}\n", "py_code": "def move_one_ball(arr):\n    if not arr:  # If the array is empty, return True.\n        return True\n\n    n = len(arr)\n    count = 0\n    \n    for i in range(1, n):\n        if arr[i] < arr[i-1]:\n            count += 1\n            index = i\n            \n    if count == 1 and arr[0] >= arr[-1]: \n        return True\n    elif count == 0:  \n        return True\n    \n    return False\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `move_one_ball` checks if it is possible to sort a given list of integers into non-decreasing order by performing right shift operations. The function first handles the case where the input array is empty and returns True in that scenario.\n\nFor non-empty arrays, the function iterates through the elements to count how many times an element is smaller than its predecessor (indicating a potential need for shifting). If there's exactly one such instance (`count == 1`) and if the first element of the list is greater or equal to the last element, it means that performing right shifts can potentially sort the array. The function also returns True if no elements are out of order (`count == 0`), indicating the array is already sorted.\n\nIf neither condition is met, the function returns False, implying that sorting through right shift operations is not possible.\n```\n\n"}
{"task_id": "CPP/100", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nvector<int> make_a_pile(int n) {\n    vector<int> stones;\n    int current_stones = n;\n    \n    for (int i = 0; i < n; ++i) {\n        stones.push_back(current_stones);\n        // The next number of stones is always the next odd or even number, which means adding 2\n        current_stones += 2;\n    }\n    \n    return stones;\n}\n", "py_code": "def make_a_pile(n):\n    stones = []\n    current_stones = n\n    for _ in range(n):\n        stones.append(current_stones)\n        if n % 2 == 0:  # If n is even\n            current_stones += 2  # Next even number\n        else:\n            current_stones += 2  # Next odd number (same as adding 2 to an odd number)\n    return stones\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `make_a_pile` takes a positive integer `n` and returns a list of integers representing the number of stones in each level of a pile with `n` levels.\n\n1. The function initializes an empty list `stones` to store the number of stones at each level.\n2. It sets `current_stones` to `n`, which represents the number of stones in the first level.\n3. A loop runs `n` times, where for each iteration:\n   - The current number of stones (`current_stones`) is appended to the list `stones`.\n   - If `n` is even, the next number of stones will be the next even number (i.e., add 2).\n   - If `n` is odd, the next number of stones will be the next odd number (which also means adding 2 since the next odd number after an odd number is always two steps away).\n\nThe function returns the list `stones`, where each element at index `i` represents the number of stones in level `(i+1)`.\n\n"}
{"task_id": "CPP/150", "generation": "#include <cmath> // For sqrt function\nusing namespace std;\n\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    for (int i = 2; i <= sqrt(num); ++i) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\nint x_or_y(int n, int x, int y) {\n    if (is_prime(n)) {\n        return x;\n    } else {\n        return y;\n    }\n}\n", "py_code": "def is_prime(num):\n    if num <= 1:\n        return False\n    for i in range(2, int(num**0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef x_or_y(n, x, y):\n    if is_prime(n):\n        return x\n    else:\n        return y\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python solution consists of two functions: `is_prime` and `x_or_y`. \n\n1. The function `is_prime(num)` checks whether a given number `num` is prime or not:\n   - It first checks if `num` is less than or equal to 1; if so, it returns `False`, as numbers less than or equal to 1 are not considered prime.\n   - Then, the function iterates from 2 up to the square root of `num`. If any number in this range divides `num` evenly (i.e., `num % i == 0`), then `num` is not a prime and the function returns `False`.\n   - If no divisors are found within the loop, the function concludes that `num` is prime and returns `True`.\n\n2. The function `x_or_y(n, x, y)` uses the result of `is_prime(n)` to determine whether to return `x` or `y`:\n   - It calls `is_prime(n)`. If `n` is a prime number, it returns `x`.\n   - Otherwise (if `n` is not a prime), it returns `y`.\n\nThis approach ensures that the function correctly identifies whether `n` is a prime and then selects between `x` or `y` based on this determination.\n\n"}
{"task_id": "CPP/153", "generation": "#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nbool compare_strength(const string& a, const string& b) {\n    int cap_a = count_if(a.begin(), a.end(), ::isupper);\n    int sm_a = count_if(a.begin(), a.end(), ::islower);\n    int strength_a = cap_a - sm_a;\n    \n    int cap_b = count_if(b.begin(), b.end(), ::isupper);\n    int sm_b = count_if(b.begin(), b.end(), ::islower);\n    int strength_b = cap_b - sm_b;\n\n    return strength_a > strength_b || (strength_a == strength_b && a < b);\n}\n\nstring Strongest_Extension(string class_name, vector<string> extensions) {\n    auto strongest_ext_it = max_element(extensions.begin(), extensions.end(), [](const string& a, const string& b){\n        int cap_a = count_if(a.begin(), a.end(), ::isupper);\n        int sm_a = count_if(a.begin(), a.end(), ::islower);\n        int strength_a = cap_a - sm_a;\n        \n        int cap_b = count_if(b.begin(), b.end(), ::isupper);\n        int sm_b = count_if(b.begin(), b.end(), ::islower);\n        int strength_b = cap_b - sm_b;\n\n        return strength_a > strength_b || (strength_a == strength_b && a < b);\n    });\n\n    string strongest_ext = *strongest_ext_it;\n    \n    return class_name + \".\" + strongest_ext;\n}\n", "py_code": "def strongest_extension(class_name, extensions):\n    max_strength = float('-inf')\n    strongest_ext = \"\"\n    \n    for ext in extensions:\n        cap = sum(1 for c in ext if c.isupper())\n        sm = sum(1 for c in ext if c.islower())\n        strength = cap - sm\n        \n        if strength > max_strength or (strength == max_strength and extensions.index(ext) < extensions.index(strongest_ext)):\n            strongest_ext = ext\n            max_strength = strength\n    \n    return f\"{class_name}.{strongest_ext}\"\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `strongest_extension` takes a class name and a list of extension names as input and returns the strongest extension in the format \"ClassName.StrongestExtensionName\". The strength of each extension is calculated based on the difference between the number of uppercase letters (CAP) and lowercase letters (SM) in its name.\n\nThe function iterates through each extension, calculating its strength by counting the number of uppercase and lowercase characters. It then compares this strength to the current maximum strength (`max_strength`). If the new extension's strength is greater than `max_strength`, or if it has the same strength but appears earlier in the list (to handle ties), the function updates `strongest_ext` with the name of the new strongest extension and sets `max_strength` to its calculated strength.\n\nFinally, the function returns a string that concatenates the class name and the strongest extension name found.```\n\n"}
{"task_id": "CPP/107", "generation": "#include <stdio.h>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nbool is_palindrome(int num) {\n    string str_num = to_string(num);\n    string reversed_str_num = str_num;\n    reverse(reversed_str_num.begin(), reversed_str_num.end());\n    return str_num == reversed_str_num;\n}\n\nvector<int> even_odd_palindrome(int n){\n    int even_count = 0, odd_count = 0;\n\n    for (int i = 1; i <= n; ++i) {\n        if (is_palindrome(i)) {\n            if (i % 2 == 0)\n                even_count++;\n            else\n                odd_count++;\n        }\n    }\n\n    return {even_count, odd_count};\n}\n", "py_code": "def is_palindrome(num):\n    return str(num) == str(num)[::-1]\n\ndef even_odd_palindrome(n):\n    even_count = 0\n    odd_count = 0\n    for i in range(1, n + 1):\n        if is_palindrome(i):\n            if i % 2 == 0:\n                even_count += 1\n            else:\n                odd_count += 1\n    return (even_count, odd_count)\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `even_odd_palindrome(n)` calculates and returns a tuple containing the number of even and odd integer palindromes within the range from 1 to n (inclusive). The function first defines an auxiliary function `is_palindrome(num)`, which checks if a given number is a palindrome by comparing its string representation with its reverse.\n\nThe main function iterates through all integers in the specified range. For each integer, it uses the `is_palindrome` function to check whether the current number is a palindrome. If it is, the function then determines whether the number is even or odd and increments the respective counter (`even_count` for even numbers and `odd_count` for odd numbers). Finally, the function returns a tuple containing the counts of even and odd palindromes.\n\n"}
{"task_id": "CPP/110", "generation": "#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nstring exchange(vector<int> lst1, vector<int> lst2) {\n    int odd_count = 0;\n    \n    // Count the number of odd numbers in lst1\n    for (int num : lst1) {\n        if (num % 2 != 0) {\n            ++odd_count;\n        }\n    }\n\n    int even_in_lst2_count = 0;\n\n    // Count the number of even numbers in lst2\n    for (int num : lst2) {\n        if (num % 2 == 0) {\n            ++even_in_lst2_count;\n        }\n    }\n\n    // Check if there are enough even numbers in lst2 to replace all odd numbers in lst1\n    return (even_in_lst2_count >= odd_count) ? \"YES\" : \"NO\";\n}\n", "py_code": "from typing import List\n\ndef exchange(lst1: List[int], lst2: List[int]) -> str:\n    odd_count = sum(x % 2 != 0 for x in lst1)\n    even_in_lst2 = [x for x in lst2 if x % 2 == 0]\n    \n    return \"YES\" if len(even_in_lst2) >= odd_count else \"NO\"\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `exchange` takes two lists of integers (`lst1` and `lst2`) as input and determines whether it is possible to exchange elements between them so that all elements in `lst1` become even numbers.\n\nFirstly, the function counts how many odd numbers are present in `lst1`. This count is stored in `odd_count`.\n\nNext, a list comprehension creates a new list (`even_in_lst2`) containing only the even numbers from `lst2`.\n\nFinally, the function checks if there are enough even numbers in `lst2` to replace all the odd numbers in `lst1`. If the number of even elements in `lst2` is greater than or equal to `odd_count`, it returns \"YES\", indicating that an exchange can be made. Otherwise, it returns \"NO\".```\n\n\n"}
{"task_id": "CPP/111", "generation": "#include <iostream>\n#include <string>\n#include <map>\n#include <sstream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nmap<char, int> histogram(string test) {\n    map<char, int> counts;\n    \n    if (test.empty()) return counts; // Return empty map for empty input\n    \n    stringstream ss(test);\n    string word;\n    \n    while (ss >> word) {  // Count occurrences of each character\n        char ch = word[0];\n        counts[ch]++;\n    }\n    \n    if (counts.empty()) return counts; // Handle case where no characters are present\n    \n    int max_count = 0;\n    for (const auto& pair : counts) {\n        max_count = max(max_count, pair.second); // Find the maximum count\n    }\n\n    map<char, int> result;\n    \n    for (const auto& pair : counts) { // Filter characters that have the maximum count\n        if (pair.second == max_count) {\n            result.insert(pair);\n        }\n    }\n    \n    return result;\n}\n", "py_code": "from collections import Counter\n\ndef histogram(test):\n    if not test: \n        return {}\n    \n    # Count occurrences of each character\n    counts = Counter(test.split())\n    \n    # Find the maximum count\n    max_count = max(counts.values(), default=0)\n    \n    # Filter characters that have the maximum count\n    result = {char: count for char, count in counts.items() if count == max_count}\n    \n    return result\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `histogram` takes a string of space-separated lowercase letters as input and returns a dictionary mapping each letter with the highest frequency to its count. The function first checks if the input string is empty; if so, it returns an empty dictionary.\n\nIf the input is not empty, the function uses the `Counter` class from the `collections` module to create a dictionary (`counts`) that maps each character in the input string (split by spaces) to its frequency. It then finds the maximum count of any letter using the `max` function on the values of `counts`.\n\nFinally, it constructs and returns a new dictionary containing only those letters whose counts match the maximum count found earlier.\n\nThis approach ensures that if multiple letters have the same highest frequency, all such letters are included in the returned dictionary.```\n\n"}
{"task_id": "CPP/80", "generation": "#include <string>\nusing namespace std;\n\nbool is_happy(string s) {\n    if (s.length() < 3) {\n        return false;\n    }\n    for (size_t i = 0; i <= s.length() - 3; ++i) {\n        if (s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]) {\n            return false;\n        }\n    }\n    return true;\n}\n", "py_code": "def is_happy(s):\n    if len(s) < 3:\n        return False\n    for i in range(len(s) - 2):\n        if s[i] == s[i+1] or s[i] == s[i+2] or s[i+1] == s[i+2]:\n            return False\n    return True\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `is_happy` checks if a given string `s` is \"happy\" based on specific criteria. The function first verifies that the length of the string is at least 3 characters; if not, it immediately returns `False`. If the string has at least three characters, the function iterates through each character in the string (up to the third last one) and checks whether any of the three consecutive characters are identical. If any set of three consecutive characters contains duplicates, the function returns `False`, indicating that the string is not happy. If no such duplicates are found throughout the iteration, the function concludes by returning `True`, signifying that the string meets the criteria for being \"happy\".```"}
{"task_id": "CPP/41", "generation": "#include<stdio.h>\nusing namespace std;\n\nint car_race_collision(int n) {\n    // Since all cars move at the same speed and continue their trajectory after collision,\n    // each left-to-right moving car will eventually collide with exactly one right-to-left moving car.\n    return n;\n}\n", "py_code": "def car_race_collision(n):\n    # Since all cars move at the same speed and continue their trajectory after collision,\n    # each left-to-right moving car will eventually collide with exactly one right-to-left moving car.\n    return n\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `car_race_collision` takes an integer `n` as input and returns the number of collisions that occur between two sets of cars moving in opposite directions on a straight road. The problem states that there are `n` cars driving left to right and another set of `n` cars driving right to left, all at the same speed. Since each car from one direction will inevitably collide with exactly one car coming from the opposite direction (and continue their trajectory), the total number of collisions is equal to `n`. The function simply returns this value without any further computation or iteration.```"}
{"task_id": "CPP/116", "generation": "#include <stdio.h>\n#include <math.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint count_ones(int n) {\n    int count = 0;\n    while (n != 0) {\n        count += n & 1;\n        n >>= 1;\n    }\n    return count;\n}\n\nbool compare(const int& a, const int& b) {\n    int ones_a = count_ones(abs(a));\n    int ones_b = count_ones(abs(b));\n\n    if (ones_a == ones_b)\n        return a < b;\n\n    return ones_a < ones_b;\n}\n\nvector<int> sort_array(vector<int> arr){\n    sort(arr.begin(), arr.end(), compare);\n    return arr;\n}\n", "py_code": "from typing import List\n\ndef count_ones(n: int) -> int:\n    return bin(abs(n)).count('1')\n\ndef sort_array(arr: List[int]) -> List[int]:\n    arr.sort(key=lambda x: (count_ones(x), x))\n    return arr\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python code defines a function `sort_array` that takes a list of integers as input and returns a sorted version of this list based on two criteria: first, by the number of ones in their binary representation; second, by their decimal value if they have an equal number of ones. \n\nTo achieve this, it uses a helper function `count_ones`, which calculates the number of ones ('1's) in the binary representation of the absolute value of an integer. The main function then sorts the input list using Python's built-in sort method with a custom key that first compares based on the count of ones and secondly by the decimal value if the counts are equal.\n\nThis approach ensures that the integers are sorted primarily according to their binary structure, which is a unique way of sorting numbers beyond just their decimal values.```\n\n"}
{"task_id": "CPP/61", "generation": "#include <string>\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    int balance = 0;\n    for (char c : brackets) { // Renamed 'char' to 'c'\n        if (c == '(') {       // Using 'c' instead of 'char'\n            balance += 1;\n        } else if (c == ')') { // Using 'c' instead of 'char'\n            balance -= 1;\n        }\n        if (balance < 0) {\n            return false;\n        }\n    }\n    return balance == 0;\n}\n", "py_code": "def correct_bracketing(brackets: str) -> bool:\n    balance = 0\n    for char in brackets:\n        if char == '(':\n            balance += 1\n        elif char == ')':\n            balance -= 1\n        if balance < 0:\n            return False\n    return balance == 0\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `correct_bracketing` checks whether a string of parentheses is correctly bracketed, meaning every opening parenthesis '(' has a corresponding closing parenthesis ')'. The function iterates through each character in the input string and maintains a balance counter.\n\n- When an opening parenthesis '(' is encountered, the balance increases by 1.\n- When a closing parenthesis ')' is encountered, the balance decreases by 1.\n- If at any point the balance becomes negative (`balance < 0`), it means there are more closing parentheses than opening ones up to that point, and thus the string cannot be correctly bracketed. The function returns `False`.\n- After iterating through all characters in the string, if the final balance is zero (`balance == 0`), then every opening parenthesis has a corresponding closing parenthesis, and the function returns `True`.\n\nThis approach ensures that the parentheses are balanced throughout the string.\n\n"}
{"task_id": "CPP/25", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nvector<int> factorize(int n) {\n    vector<int> factors;\n    for (int i = 2; i * i <= n; ++i) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n    if (n > 1) {\n        factors.push_back(n);\n    }\n    return factors;\n}\n", "py_code": "def factorize(n):\n    i = 2\n    factors = []\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            factors.append(i)\n    if n > 1:\n        factors.append(n)\n    return factors\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `factorize` takes an integer `n` and returns a list of its prime factors in ascending order. The algorithm works as follows:\n1. Initialize `i` to 2, which is the smallest prime number.\n2. Use a while loop that continues until `i * i` exceeds `n`. This ensures we only check up to the square root of `n`, optimizing the factorization process.\n3. Inside the loop, if `n % i` (remainder when `n` is divided by `i`) is not zero, increment `i` and continue checking for factors.\n4. If `n % i` equals zero, it means `i` is a prime factor of `n`. Append `i` to the list of factors and divide `n` by `i`, updating `n` to reflect this division.\n5. After exiting the loop, if `n` is still greater than 1 (meaning there's one more prime factor left), append `n` to the list of factors.\n6. Return the list of factors.\n\nThis approach ensures that all prime factors are found and listed in ascending order, with each factor appearing as many times as it divides into `n`.\n\n"}
{"task_id": "CPP/137", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <boost/any.hpp>\n\nusing namespace std;\n\n// Function to convert string with comma or dot decimal separator to float\nfloat str_to_float(const string& s) {\n    string temp = s;\n    replace(temp.begin(), temp.end(), ',', '.');\n    return stof(temp);\n}\n\n// Main comparison function using boost::any for handling different types\nboost::any compare_one(boost::any a, boost::any b) {\n    float a_val, b_val;\n\n    // Convert any to string and then to float if necessary\n    try {\n        a_val = boost::any_cast<int>(a);\n    } catch (const boost::bad_any_cast&) {  // Corrected namespace here\n        try {\n            a_val = boost::any_cast<float>(a);\n        } catch (const boost::bad_any_cast&) {  // And here\n            a_val = str_to_float(boost::any_cast<string>(a));\n        }\n    }\n\n    try {\n        b_val = boost::any_cast<int>(b);\n    } catch (const boost::bad_any_cast&) {  // Corrected namespace here\n        try {\n            b_val = boost::any_cast<float>(b);\n        } catch (const boost::bad_any_cast&) {  // And here\n            b_val = str_to_float(boost::any_cast<string>(b));\n        }\n    }\n\n    // Compare the values\n    if (a_val > b_val) {\n        return a;\n    } else if (b_val > a_val) {\n        return b;\n    } else {\n        return string(\"None\");\n    }\n}\n", "py_code": "def compare_one(a, b):\n    # Convert strings with commas to dots for uniformity and convert to float if necessary\n    a_val = float(str(a).replace(',', '.')) if isinstance(a, str) else a\n    b_val = float(str(b).replace(',', '.')) if isinstance(b, str) else b\n\n    # Compare the values after conversion\n    if a_val > b_val:\n        return a\n    elif b_val > a_val:\n        return b\n    else:\n        return \"None\"\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `compare_one` takes two arguments (`a` and `b`) which can be integers, floats, or strings representing real numbers (with either a dot or comma as the decimal separator). The goal is to compare these values and return the larger one in its original type. If both are equal, it returns \"None\".\n\n1. **Conversion of Strings**: \n   - For string inputs, the function replaces any commas with dots for uniformity.\n   - It then converts strings to floats using `float()`.\n   \n2. **Comparison**:\n   - The values (after conversion if necessary) are compared numerically.\n   - If `a_val` is greater than `b_val`, it returns the original value of `a`.\n   - If `b_val` is greater, it returns the original value of `b`.\n   - If both values are equal, it returns the string \"None\".\n\nThis approach ensures that the comparison is done numerically while preserving the original type of the larger number.\n\n"}
{"task_id": "CPP/102", "generation": "#include <stdio.h>\n\nint choose_num(int x, int y) {\n    if (x > y) {\n        return -1;\n    }\n    // If y is even and within range, return it; otherwise, subtract 1 until an even number is found.\n    while (y >= x) {\n        if (y % 2 == 0) {\n            return y;\n        }\n        y -= 1;\n    }\n    return -1;\n}\n", "py_code": "def choose_num(x, y):\n    if x > y:\n        return -1\n    # If y is even and within range, return it; otherwise, subtract 1 until an even number is found.\n    while y >= x:\n        if y % 2 == 0:\n            return y\n        y -= 1\n    return -1\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `choose_num(x, y)` is designed to find and return the largest even integer within a given range `[x, y]`, inclusive. If no such number exists (i.e., if `x` is greater than `y`), it returns `-1`.\n\nHere's how the function works:\n1. The function first checks whether `x > y`. If this condition holds true, it means that there are no numbers in the range `[x, y]`, and thus, the function immediately returns `-1`.\n2. Next, if `y` is an even number within the range `[x, y]`, the function returns `y`.\n3. If `y` is not even, the function enters a loop where it decrements `y` by 1 until it finds an even number that lies in the range `[x, y]`. The decrement continues as long as `y >= x`.\n4. If no even number within the specified range is found (which should only happen if `x > y`, but this case has already been handled), `-1` is returned.\n\nThis approach ensures that the function efficiently finds and returns the largest even integer in the given range, or `-1` if such a number does not exist. \n\n"}
{"task_id": "CPP/10", "generation": "#include <string>\nusing namespace std;\n\nbool is_palindrome(string str) {\n    string s(str.rbegin(), str.rend());\n    return s == str;\n}\n\nstring make_palindrome(string str) {\n    if (str.empty()) {\n        return \"\";\n    }\n\n    for (size_t i = 0; i < str.size(); ++i) {\n        string suffix = str.substr(i);\n        if (is_palindrome(suffix)) {\n            string prefix_to_reverse = str.substr(0, i);\n            reverse(prefix_to_reverse.begin(), prefix_to_reverse.end());\n            return str + prefix_to_reverse;\n        }\n    }\n\n    // In case no palindrome is found in the loop, which shouldn't happen\n    return \"\";\n}\n", "py_code": "def is_palindrome(s):\n    return s == s[::-1]\n\ndef make_palindrome(str):\n    if len(str) == 0:\n        return \"\"\n    \n    for i in range(len(str)):\n        suffix = str[i:]\n        if is_palindrome(suffix):\n            prefix_to_reverse = str[:i]\n            return str + prefix_to_reverse[::-1]\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python solution consists of two functions: `is_palindrome` and `make_palindrome`.\n\n- The function `is_palindrome(s)` checks whether a given string `s` is a palindrome by comparing it to its reverse (`s[::-1]`). If they are equal, the string is a palindrome.\n\n- The function `make_palindrome(str)` aims to find the shortest palindrome that starts with the supplied string. It does this by:\n  - Checking if the input string is empty and returning an empty string immediately in such cases.\n  - Iterating through each character index of the string to identify the longest suffix that forms a palindrome (`suffix = str[i:]`).\n  - Once it finds such a palindromic suffix, it takes the prefix before this suffix (`prefix_to_reverse = str[:i]`) and appends its reverse to the end of the original string. This ensures the result is a palindrome starting with the given string.\n\nThe algorithm efficiently constructs the shortest possible palindrome by leveraging the properties of palindromes and reversing only necessary parts of the input string.\n\n"}
{"task_id": "CPP/76", "generation": "#include <stdio.h>\n#include <math.h>\nusing namespace std;\n\nbool is_simple_power(int x, int n) {\n    if (n == 1) {\n        return x == 1;\n    }\n    long power = 1; // Use long to avoid overflow issues.\n    while (power < x) {\n        power *= n;\n    }\n    return power == x;\n}\n", "py_code": "def is_simple_power(x, n):\n    if n == 1:\n        return x == 1\n    power = 1\n    while power < x:\n        power *= n\n    return power == x\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `is_simple_power(x, n)` checks if a number `x` is a simple power of another number `n`. It returns `True` if there exists an integer such that raising `n` to this integer equals `x`, and `False` otherwise.\n\n1. The function first handles the special case where `n == 1`. In this scenario, it checks whether `x` is also equal to 1 because any power of 1 will always be 1.\n2. If `n` is not 1, the function initializes a variable `power` to 1 and enters a loop that multiplies `power` by `n` until `power` becomes greater than or equal to `x`.\n3. After exiting the loop, it checks if `power` is exactly equal to `x`. If so, it means `x` can be expressed as an integer power of `n`, and the function returns `True`. Otherwise, it returns `False`.\n\nThis approach ensures that we correctly identify whether `x` is a simple power of `n` by iteratively multiplying `n` until reaching or exceeding `x`.\n"}
{"task_id": "CPP/94", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nbool is_prime(int n) {\n    if (n <= 1)\n        return false;\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0)\n            return false;\n    }\n    return true;\n}\n\nint sum_of_digits(int n) {\n    int sum = 0;\n    while (n > 0) {\n        sum += n % 10;\n        n /= 10;\n    }\n    return sum;\n}\n\nint skjkasdkd(vector<int> lst) {\n    int max_prime = -1;\n    for (auto num : lst) {\n        if (is_prime(num)) {\n            max_prime = std::max(max_prime, num);\n        }\n    }\n\n    if (max_prime == -1)\n        return 0;\n\n    return sum_of_digits(max_prime);\n}\n", "py_code": "from typing import List\n\ndef is_prime(n: int) -> bool:\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef sum_of_digits(n: int) -> int:\n    return sum(int(digit) for digit in str(n))\n\ndef skjkasdkd(lst: List[int]) -> int:\n    max_prime = -1\n    for num in lst:\n        if is_prime(num):\n            max_prime = max(max_prime, num)\n    \n    if max_prime == -1:\n        return 0\n    \n    return sum_of_digits(max_prime)\n```\n\n", "py_summary": "### Second Step: Analyse the Python Code\n\nThe provided Python function `skjkasdkd` is designed to solve a problem where we need to find the largest prime number in a list of integers and return the sum of its digits.\n\n1. **Helper Function - `is_prime`:** This function checks if a given integer `n` is a prime number. It returns `False` for numbers less than or equal to 1, and then iterates from 2 up to the square root of `n`. If any number in this range divides `n`, it means `n` is not a prime number.\n\n2. **Helper Function - `sum_of_digits`:** This function takes an integer `n` as input and returns the sum of its digits by converting the integer into a string, iterating over each character (digit), converting them back to integers, and then summing these values.\n\n3. **Main Function - `skjkasdkd`:**\n   - The main function iterates through each number in the provided list `lst`.\n   - For each number, it checks if the number is a prime using the `is_prime` helper function.\n   - If the number is a prime and greater than the current maximum prime (`max_prime`), it updates `max_prime`.\n\n4. **Return Value:**\n   - After iterating through all numbers in the list, if no prime number was found (i.e., `max_prime` remains `-1`), the function returns 0.\n   - Otherwise, it calculates and returns the sum of digits of the largest prime using the `sum_of_digits` helper function.\n\n### Summary\nThe Python code effectively finds the largest prime in a list and computes the sum of its digits by leveraging two helper functions for checking primality and calculating digit sums. The main function iterates through the list to find the maximum prime number, then uses the helper functions to compute the final result.\n\nNow let's translate this logic into C++.\n```\n\n<|im_start|>assistant\n### Last Step: Generate the C++ Solution\n\nBased on the Python code analysis, here is the equivalent C++ solution:\n\n"}
{"task_id": "CPP/32", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\ndouble poly(vector<double> xs, double x) {\n    /* \n    Evaluates polynomial with coefficients xs at point x. return xs[0] + xs[1] * x + xs[2] * x^2 + .... xs[n] * x^n \n    */\n    double sum = 0;\n    for (size_t i = 0; i < xs.size(); ++i) {\n        sum += xs[i] * pow(x, i);\n    }\n    return sum;\n}\n\ndouble find_zero(vector<double> xs) {\n    /*\n    xs are coefficients of a polynomial. find_zero finds x such that poly(x) = 0. find_zero returns only one zero point, even if there are many.\n    Moreover, find_zero only takes list xs having an even number of coefficients and the largest non-zero coefficient as it guarantees a solution.\n    */\n    \n    double lower_bound = -100;\n    double upper_bound = 100;\n\n    // Check for sign change in the interval\n    if (poly(xs, lower_bound) * poly(xs, upper_bound) > 0) {\n        throw std::runtime_error(\"No guaranteed root within [-100, 100]\");\n    }\n\n    // Bisection method to find a zero point\n    double tol = 1e-6; // Tolerance for the bisection method\n    while (upper_bound - lower_bound > tol) {\n        double mid = (lower_bound + upper_bound) / 2;\n        if (poly(xs, mid) == 0 || abs(poly(xs, mid)) < tol) {\n            return mid;\n        } else if (poly(xs, lower_bound) * poly(xs, mid) < 0) {\n            upper_bound = mid;\n        } else {\n            lower_bound = mid;\n        }\n    }\n\n    // Return the midpoint of the final interval\n    return (lower_bound + upper_bound) / 2;\n}\n", "py_code": "from typing import List\n\ndef poly(xs: List[float], x: float) -> float:\n    return sum(coef * (x ** i) for i, coef in enumerate(xs))\n\ndef find_zero(xs: List[float]) -> float:\n    # Use bisection method or other root-finding methods to find a zero of the polynomial\n    from scipy.optimize import bisect\n\n    # Define the range based on the nature of polynomials and coefficients.\n    # For simplicity, we assume that there is at least one real root in [-100, 100]\n    lower_bound = -100.0\n    upper_bound = 100.0\n    \n    # Check if poly(lower_bound) * poly(upper_bound) <= 0 to ensure a sign change within the interval.\n    if poly(xs, lower_bound) * poly(xs, upper_bound) > 0:\n        raise ValueError(\"The polynomial does not have a root in the given range.\")\n    \n    return bisect(lambda x: poly(xs, x), lower_bound, upper_bound)\n```\n\n", "py_summary": "### Analysis of Python Code:\n\nThe provided Python solution consists of two functions:\n1. `poly`: This function evaluates a polynomial at a given point `x`. It takes in a list of coefficients (`xs`) and a value for `x`, then computes the sum of each coefficient multiplied by `x` raised to its corresponding power (based on index).\n\n2. `find_zero`: This function aims to find one root (zero) of the polynomial defined by the coefficients in `xs`. The approach used is the bisection method, which requires an interval where the polynomial changes sign (i.e., there's a zero within that interval). \n   - It first defines a range (`lower_bound` and `upper_bound`) to search for the root. For simplicity, it assumes this range to be [-100, 100].\n   - The function checks if the product of polynomial values at these bounds is non-positive (indicating a sign change within the interval), which guarantees that there's at least one zero in between.\n   - If the condition is met, `scipy.optimize.bisect` is used to find and return an approximate root. Otherwise, it raises a ValueError indicating no guaranteed root exists within the specified range.\n\n"}
{"task_id": "CPP/33", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> sort_third(vector<int> l) {\n    vector<int> divisible_by_three;\n\n    // Extract elements at indices divisible by three (1-indexed)\n    for (int i = 0; i < l.size(); ++i) {\n        if ((i + 1) % 3 == 0) {\n            divisible_by_three.push_back(l[i]);\n        }\n    }\n\n    // Sort these extracted elements\n    sort(divisible_by_three.begin(), divisible_by_three.end());\n\n    int j = 0;\n    for (int i = 0; i < l.size(); ++i) {\n        if ((i + 1) % 3 == 0) {\n            l[i] = divisible_by_three[j++];\n        }\n    }\n\n    return l;\n}\n", "py_code": "def sort_third(l):\n    # Extract elements at indices divisible by three (0-indexed)\n    divisible_by_three = [l[i] for i in range(len(l)) if (i + 1) % 3 == 0]\n    \n    # Sort these extracted elements\n    sorted_divisible_by_three = sorted(divisible_by_three)\n\n    # Replace the original indices with the sorted values\n    j = 0\n    l_prime = []\n    for i in range(len(l)):\n        if (i + 1) % 3 == 0:\n            l_prime.append(sorted_divisible_by_three[j])\n            j += 1\n        else:\n            l_prime.append(l[i])\n\n    return l_prime\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `sort_third` takes a list `l` and returns a new list `l'`. The elements of `l'` are identical to those in `l` at indices that are not divisible by three (considering 1-indexed positions). For indices that are divisible by three, the corresponding values from `l` are sorted in ascending order and placed back into their original positions.\n\nThe function first creates a list called `divisible_by_three`, which contains elements from `l` at indices where `(i + 1) % 3 == 0`. It then sorts this list to get `sorted_divisible_by_three`.\n\nNext, the function constructs the new list `l_prime` by iterating over the original list `l`. For each index `i`, if `(i + 1) % 3 == 0`, it appends the next value from `sorted_divisible_by_three`; otherwise, it appends the element directly from `l`.\n\nFinally, the function returns the new list `l_prime` with sorted elements at indices divisible by three.\n\n"}
{"task_id": "CPP/88", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> sort_array(vector<int> array) {\n    if (array.empty()) return {};\n\n    // Determine sorting order based on sum of first and last elements\n    bool is_odd = ((array[0] + array.back()) % 2 != 0);\n\n    // Create a copy of the array to avoid modifying the original one\n    vector<int> sorted_array(array);\n\n    if (is_odd) {\n        sort(sorted_array.begin(), sorted_array.end());\n    } else {\n        sort(sorted_array.rbegin(), sorted_array.rend());\n    }\n\n    return sorted_array;\n}\n", "py_code": "def sort_vector(array):\n    if not array:\n        return []\n    \n    # Determine sorting order based on sum of first and last elements\n    is_odd = (array[0] + array[-1]) % 2 != 0\n    \n    # Create a copy of the array to avoid modifying the original one\n    sorted_array = array[:]\n    \n    if is_odd:\n        sorted_array.sort()\n    else:\n        sorted_array.sort(reverse=True)\n        \n    return sorted_array\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `sort_vector` takes a list of non-negative integers as input and returns a new list that is either sorted in ascending or descending order based on the sum of the first and last elements of the original list.\n\n1. The function first checks if the array is empty; if so, it immediately returns an empty list.\n2. It then calculates whether the sum of the first and last elements is odd by using modulo 2 operation (`(array[0] + array[-1]) % 2 != 0`). If this condition evaluates to `True`, the variable `is_odd` will be set to `True`; otherwise, it will be `False`.\n3. The function creates a copy of the input list (`sorted_array = array[:]`) to avoid modifying the original list.\n4. Depending on the value of `is_odd`, the copied list is sorted either in ascending order (if `is_odd` is `True`) or descending order (if `is_odd` is `False`).\n5. Finally, the function returns the sorted copy of the array.\n\nThis approach ensures that the original input vector remains unchanged and that the returned vector is sorted according to the specified criteria based on the sum of its first and last elements.\n\n"}
{"task_id": "CPP/15", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\nusing namespace std;\n\nstring string_sequence(int n) {\n    stringstream ss;\n    for (int i = 0; i <= n; ++i) {\n        ss << i;\n        if (i != n) {\n            ss << \" \";\n        }\n    }\n    return ss.str();\n}\n", "py_code": "def string_sequence(n):\n    return ' '.join(str(i) for i in range(n + 1))\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `string_sequence` takes an integer `n` as input and returns a string containing space-delimited numbers starting from 0 up to n inclusive. The function uses a generator expression inside the `join()` method to convert each number in the range `[0, n]` into a string and then joins them with spaces between each pair of consecutive elements. This results in a single string that contains all the numbers in the specified range separated by spaces.```\n"}
{"task_id": "CPP/163", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> generate_integers(int a, int b) {\n    if (a > b) {\n        swap(a, b);\n    }\n\n    vector<int> even_digits = {0, 2, 4, 6, 8};\n    vector<int> result;\n    \n    for (int num : even_digits) {\n        if (num >= a && num <= min(b, 9)) {\n            result.push_back(num);\n        }\n    }\n\n    return result;\n}\n", "py_code": "def generate_integers(a, b):\n    # Ensure a is less than or equal to b for simplicity\n    if a > b:\n        a, b = b, a\n    \n    even_digits = {0, 2, 4, 6, 8}\n    result = set()\n    \n    for num in range(max(0, a), min(b + 1, 10)):\n        if num in even_digits:\n            result.add(num)\n            \n    return sorted(result)\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `generate_integers(a, b)` is designed to find and return all even digits (0, 2, 4, 6, 8) that fall within the range `[a, b]` in ascending order. The function first ensures that `a` is less than or equal to `b` by swapping their values if necessary.\n\nThe set of even digits (`even_digits`) contains all possible even single-digit numbers (0 through 8). A result set (`result`) is initialized to store the even digits found within the range `[max(0, a), min(b + 1, 10)]`. The loop iterates over this adjusted range and checks if each number is in `even_digits`, adding it to the `result` set if so.\n\nFinally, the function returns the sorted list of unique even digits that fall within the specified range. This ensures that the output is always in ascending order and contains no duplicates.\n\n"}
{"task_id": "CPP/1", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nvector<string> separate_paren_groups(string paren_string) {\n    // Remove spaces from the input string\n    paren_string.erase(remove(paren_string.begin(), paren_string.end(), ' '), paren_string.end());\n    \n    vector<string> result;\n    int balance = 0;\n    size_t start_index = 0;\n\n    for (size_t i = 0; i < paren_string.length(); ++i) {\n        if (paren_string[i] == '(') {\n            if (balance == 0) {\n                start_index = i;\n            }\n            balance += 1;\n        } else if (paren_string[i] == ')') {\n            balance -= 1;\n            if (balance == 0) {\n                result.push_back(paren_string.substr(start_index, i - start_index + 1));\n            }\n        }\n    }\n\n    return result;\n}\n", "py_code": "def separate_paren_groups(paren_string):\n    paren_string = paren_string.replace(\" \", \"\")\n    result = []\n    balance = 0\n    start_index = 0\n    \n    for i, char in enumerate(paren_string):\n        if char == '(':\n            if balance == 0:\n                start_index = i\n            balance += 1\n        elif char == ')':\n            balance -= 1\n            if balance == 0:\n                result.append(paren_string[start_index:i+1])\n                \n    return result\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `separate_paren_groups` takes a string containing multiple groups of nested parentheses and separates those groups into separate strings, returning them as a list.\n\n1. The input string is first stripped of any spaces using `replace(\" \", \"\")`.\n2. An empty list `result` is initialized to store the separated groups.\n3. A variable `balance` is used to keep track of the balance between opening and closing parentheses within each group.\n4. Another variable `start_index` keeps track of where a new group starts.\n\nThe function iterates through each character in the string:\n- If an opening parenthesis `'('` is encountered, it checks if the current balance is zero (indicating the start of a new group). It then increments the balance and updates the `start_index`.\n- If a closing parenthesis `')'` is encountered, it decrements the balance. When the balance returns to zero, it means that a complete group has been found from `start_index` to the current index (`i`). This group is appended to the result list.\n\nFinally, the function returns the list of separated groups.\n\n"}
{"task_id": "CPP/69", "generation": "#include <vector>\n#include <algorithm>\n#include <unordered_map>\nusing namespace std;\n\nint search(vector<int> lst) {\n    unordered_map<int, int> frequency;\n    \n    // Calculate frequencies of each element in the list.\n    for (int num : lst) {\n        frequency[num]++;\n    }\n    \n    int max_val = -1;\n    \n    // Iterate over the unique elements and their frequencies.\n    for (const auto& entry : frequency) {\n        int num = entry.first;\n        int freq = entry.second;\n        \n        // Check if the frequency is greater than or equal to the number itself.\n        if (num <= freq) {\n            max_val = max(max_val, num);\n        }\n    }\n\n    return max_val;\n}\n", "py_code": "from collections import Counter\n\ndef search(lst):\n    frequency = Counter(lst)\n    max_val = -1\n    \n    for num in frequency:\n        if num <= frequency[num]:\n            max_val = max(max_val, num)\n    \n    return max_val\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `search` takes a list of positive integers and returns the greatest integer that has a frequency greater than or equal to its value. The function uses the `Counter` class from the `collections` module to count the occurrences (frequency) of each number in the input list.\n\n1. **Frequency Calculation**: It first calculates the frequency of each element using `Counter(lst)` and stores it in the variable `frequency`.\n2. **Initialization**: A variable `max_val` is initialized with `-1`, which will be used to store the maximum value that meets the criteria.\n3. **Iteration and Condition Check**: The function iterates over each unique number (`num`) in the frequency dictionary. For each number, it checks if its frequency (i.e., how many times it appears) is greater than or equal to the number itself (`if num <= frequency[num]`).\n4. **Update Maximum Value**: If the condition is met, `max_val` is updated with the maximum of the current value and `num`.\n5. **Return Result**: Finally, the function returns `max_val`, which will be either the greatest integer that meets the criteria or `-1` if no such integer exists.\n\nThis approach ensures that we find the largest number whose frequency is at least as large as its own value by iterating through all unique numbers and checking their frequencies. \n\n"}
{"task_id": "CPP/31", "generation": "#include <cmath>\nusing namespace std;\n\nbool is_prime(long long n) {\n    if (n <= 1) {\n        return false;\n    }\n    for (long long i = 2; i <= sqrt(n); ++i) {\n        if (n % i == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n", "py_code": "def is_prime(n):\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `is_prime(n)` checks whether a given number `n` is prime or not. The function first handles edge cases where numbers less than or equal to 1 are considered non-prime and returns `False`. For other values of `n`, it iterates from 2 up to the square root of `n` (inclusive). If any integer in this range divides `n` evenly, then `n` is not a prime number, and the function returns `False`. If no divisors are found within this range, the function concludes that `n` is a prime number and returns `True`.\n\nThis approach leverages the fact that if `n` has any factors other than 1 and itself, at least one of those factors must be less than or equal to the square root of `n`. Therefore, checking up to the square root of `n` is sufficient for determining primality.\n\n"}
{"task_id": "CPP/147", "generation": "#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint get_max_triples(int n) {\n    vector<int> a(n);\n    for (int i = 1; i <= n; ++i) {\n        a[i-1] = i * i - i + 1;\n    }\n    \n    int count = 0;\n    for (int i = 0; i < n - 2; ++i) {\n        for (int j = i + 1; j < n - 1; ++j) {\n            for (int k = j + 1; k < n; ++k) {\n                if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                    count++;\n                }\n            }\n        }\n    }\n\n    return count;\n}\n", "py_code": "def get_max_triples(n):\n    a = [i * i - i + 1 for i in range(1, n+1)]\n    count = 0\n    for i in range(n-2):\n        for j in range(i+1, n-1):\n            for k in range(j+1, n):\n                if (a[i] + a[j] + a[k]) % 3 == 0:\n                    count += 1\n    return count\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `get_max_triples` is designed to solve a problem where we need to find the number of valid triples `(a[i], a[j], a[k])` from an array `a`, such that `i < j < k` and the sum of these three elements is divisible by 3. The array `a` is constructed based on the formula `a[i] = i * i - i + 1`.\n\nHere's how the function works:\n- First, it generates the list `a` using a list comprehension where each element `a[i]` is calculated as `i * i - i + 1`.\n- Then, it initializes a counter variable `count` to zero.\n- The function uses three nested loops to iterate through all possible triples `(i, j, k)` with the condition that `i < j < k`. \n- For each triple, it checks if the sum of elements at indices `i`, `j`, and `k` is divisible by 3. If so, it increments the counter.\n- Finally, the function returns the count of such valid triples.\n\nThis approach ensures all possible combinations are checked for validity according to the given conditions.\n\n"}
{"task_id": "CPP/105", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\nvector<string> by_length(vector<int> arr) {\n    // Filter out numbers not between 1 and 9 inclusive\n    vector<int> filtered_arr;\n    for (int num : arr) {\n        if (num >= 1 && num <= 9) {\n            filtered_arr.push_back(num);\n        }\n    }\n\n    // Sort the filtered array in ascending order\n    sort(filtered_arr.begin(), filtered_arr.end());\n\n    // Reverse the sorted array to get descending order\n    reverse(filtered_arr.begin(), filtered_arr.end());\n\n    // Map numbers to their corresponding names\n    map<int, string> number_names = {\n        {1, \"One\"}, {2, \"Two\"}, {3, \"Three\"},\n        {4, \"Four\"}, {5, \"Five\"}, {6, \"Six\"},\n        {7, \"Seven\"}, {8, \"Eight\"}, {9, \"Nine\"}\n    };\n\n    // Replace each digit with its corresponding name\n    vector<string> result;\n    for (int num : filtered_arr) {\n        result.push_back(number_names[num]);\n    }\n\n    return result;\n}\n", "py_code": "def by_length(arr):\n    # Filter out numbers not between 1 and 9 inclusive\n    filtered_arr = [num for num in arr if 1 <= num <= 9]\n    \n    # Sort the filtered array\n    sorted_arr = sorted(filtered_arr)\n    \n    # Reverse the sorted array\n    reversed_arr = list(reversed(sorted_arr))\n    \n    # Map numbers to their corresponding names\n    number_names = {\n        1: \"One\", 2: \"Two\", 3: \"Three\",\n        4: \"Four\", 5: \"Five\", 6: \"Six\",\n        7: \"Seven\", 8: \"Eight\", 9: \"Nine\"\n    }\n    \n    # Replace each digit with its corresponding name\n    result = [number_names[num] for num in reversed_arr]\n    \n    return result\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `by_length` takes a list of integers as input and processes it according to the problem requirements. First, it filters out any numbers that are not between 1 and 9 inclusive using a list comprehension. The filtered list is then sorted in ascending order. After sorting, the list is reversed to put the elements in descending order.\n\nA dictionary `number_names` maps each integer from 1 to 9 to its corresponding English name (e.g., 1 -> \"One\", 2 -> \"Two\"). Finally, another list comprehension replaces each number in the reversed and sorted array with its corresponding name using this mapping. The function returns the resulting list of names.\n\nIf the input list is empty or contains no numbers between 1 and 9 inclusive, the function will return an empty list as required by the problem statement.\n```\n\n"}
{"task_id": "CPP/22", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <boost/any.hpp>\n#include <list>\n#include <typeinfo>\n\ntypedef std::list<boost::any> list_any;\nusing namespace std;\n\nvector<int> filter_integers(list_any values) {\n    vector<int> result;\n    for (const auto& value : values) {\n        if (value.type() == typeid(int)) {\n            result.push_back(boost::any_cast<int>(value));\n        }\n    }\n    return result;\n}\n", "py_code": "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> set:\n    return {value for value in values if isinstance(value, int)}\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `filter_integers` takes a list of mixed-type elements (`values`) and returns a set containing only those elements that are integers. It uses a set comprehension to iterate over each element in the input list and checks if the type of the element is an integer using the `isinstance()` function. If the condition is met, the element is added to the resulting set.\n\n"}
{"task_id": "CPP/52", "generation": "#include <vector>\nusing namespace std;\n\nbool below_threshold(vector<int> l, int t) {\n    for (int x : l) {\n        if (x >= t) {\n            return false;\n        }\n    }\n    return true;\n}\n", "py_code": "def below_threshold(l, t):\n    return all(x < t for x in l)\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `below_threshold` takes a list of integers `l` and an integer threshold `t`. It returns `True` if all elements in the list are below the threshold `t`, otherwise it returns `False`. The function uses the built-in `all()` function to check if every element `x` in the list `l` satisfies the condition `x < t`. If all elements satisfy this condition, `all()` will return `True`; otherwise, it will return `False`.```\n\n"}
{"task_id": "CPP/154", "generation": "#include <string>\n#include <algorithm>\nusing namespace std;\n\nbool cycpattern_check(string a, string b) {\n    if (b.length() > a.length()) return false;\n    \n    // Concatenate 'a' with itself to handle rotations\n    string a_double = a + a;\n    \n    for (size_t i = 0; i < b.length(); ++i) {\n        // Generate the rotated version of 'b'\n        string rotated_b = b.substr(i) + b.substr(0, i);\n        \n        // Check if the rotated version is a substring in 'a_double'\n        if (a_double.find(rotated_b) != std::string::npos) return true;\n    }\n    \n    return false;\n}\n", "py_code": "def cycpattern_check(a: str, b: str) -> bool:\n    if len(b) > len(a):\n        return False\n    # Concatenate string 'a' with itself to handle rotations\n    a_double = a + a\n    for i in range(len(b)):\n        rotated_b = b[i:] + b[:i]\n        if rotated_b in a_double:\n            return True\n    return False\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `cycpattern_check` takes two strings `a` and `b` as input and checks if string `b` or any of its rotations is a substring in string `a`. The function first checks if the length of `b` is greater than that of `a`, returning `False` immediately if so, since it's impossible for `b` to be a substring of `a`.\n\nTo handle all possible rotations of `b`, the function concatenates `a` with itself (`a_double = a + a`). This concatenated string allows us to check for any rotation of `b` as a substring in one go. The function then iterates through each possible rotation of `b`. For each rotation, it checks if that rotated version is a substring of the doubled string `a_double`. If any rotation of `b` is found within `a_double`, the function returns `True`; otherwise, after all rotations are checked and none match, it returns `False`.\n\n"}
{"task_id": "CPP/115", "generation": "#include <vector>\n#include <algorithm> // for std::max\n\nusing namespace std;\n\nint max_fill(vector<vector<int>> grid, int capacity) {\n    int num_buckets = 0; // Initialize bucket count\n    \n    // Iterate through each well (row in the grid)\n    for(auto& row : grid){\n        int water_units = 0;\n        \n        // Calculate total water units in this well\n        for(int unit : row){\n            if(unit == 1) {\n                ++water_units;\n            }\n        }\n\n        // If there are any water units, calculate bucket fills needed\n        if(water_units > 0) {\n            num_buckets += (water_units + capacity - 1) / capacity; \n        }\n    }\n    \n    return num_buckets; // Return total number of bucket fills required\n}\n", "py_code": "from typing import List\n\ndef max_fill(grid: List[List[int]], capacity: int) -> int:\n    num_buckets = 0\n    for row in grid:\n        water_units = sum(row)\n        if water_units > 0:\n            num_buckets += (water_units + capacity - 1) // capacity\n    return num_buckets\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `max_fill` takes a grid representing wells and their water units (where each well is represented by a row in the grid) and an integer for bucket capacity as input. The goal of this function is to determine how many times buckets need to be lowered to empty all the wells.\n\n1. **Initialization**: A variable `num_buckets` is initialized to 0, which will count the total number of bucket fills required.\n2. **Iterate through each well (row)**: For every row in the grid:\n   - The function calculates the sum of water units (`water_units`) present in that particular well (i.e., the sum of all `1`s in the row).\n3. **Calculate Bucket Fills**: If there are any water units in the well, the number of bucket fills required to empty it is calculated using `(water_units + capacity - 1) // capacity`. This formula ensures that if the division does not result in a whole number (i.e., some remainder exists), an additional fill operation is counted.\n4. **Update Total Bucket Fills**: The total count `num_buckets` is updated by adding the bucket fills required for each well.\n5. **Return Result**: Finally, the function returns the total number of times buckets need to be lowered (`num_buckets`) to empty all wells.\n\nThis approach ensures that we account for partial fills and correctly compute the total operations needed based on the given capacity of the buckets.\n\n"}
{"task_id": "CPP/131", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nint digits(int n) {\n    int product = 1;\n    bool has_odd_digit = false;\n    \n    while (n > 0) {\n        int digit = n % 10;\n        if (digit % 2 != 0) {\n            product *= digit;\n            has_odd_digit = true;\n        }\n        n /= 10;\n    }\n\n    return has_odd_digit ? product : 0;\n}\n", "py_code": "def digits(n):\n    product = 1\n    has_odd_digit = False\n    while n > 0:\n        digit = n % 10\n        if digit % 2 != 0:\n            product *= digit\n            has_odd_digit = True\n        n //= 10\n    return product if has_odd_digit else 0\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `digits(n)` calculates the product of all odd digits in a given positive integer `n`. If there are no odd digits, it returns 0.\n\n1. The variable `product` is initialized to 1 as the neutral element for multiplication.\n2. A boolean flag `has_odd_digit` is set to False initially to check if any odd digit exists within the number.\n3. The function enters a while loop that continues until all digits of `n` are processed (`n > 0`).\n4. Inside the loop, the last digit of `n` (obtained using `digit = n % 10`) is checked to see if it's odd by evaluating `digit % 2 != 0`.\n5. If an odd digit is found, its value is multiplied with `product`, and `has_odd_digit` is set to True.\n6. The last digit of `n` is removed using integer division (`n //= 10`).\n7. After the loop ends, if any odd digits were encountered (i.e., `has_odd_digit == True`), the function returns the product; otherwise, it returns 0.\n\nThis approach ensures that all odd digits are multiplied together and handles cases where there are no odd digits by returning 0.\n"}
{"task_id": "CPP/37", "generation": "#include <stdio.h>\n#include <math.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<float> sort_even(vector<float> l) {\n    vector<float> even_indices_values;\n    \n    // Extract and sort the values at even indices.\n    for (size_t i = 0; i < l.size(); i += 2) {\n        even_indices_values.push_back(l[i]);\n    }\n    sort(even_indices_values.begin(), even_indices_values.end());\n    \n    vector<float> result;\n    size_t even_idx = 0;\n\n    // Reconstruct the list with sorted values at even indices.\n    for (size_t idx = 0; idx < l.size(); ++idx) {\n        if (idx % 2 == 0) {\n            result.push_back(even_indices_values[even_idx++]);\n        } else {\n            result.push_back(l[idx]);\n        }\n    }\n\n    return result;\n}\n", "py_code": "from typing import List\n\ndef sort_even(l: List[float]) -> List[float]:\n    even_indices_values = sorted([l[i] for i in range(0, len(l), 2)])\n    result = []\n    even_idx = 0\n    \n    for idx in range(len(l)):\n        if idx % 2 == 0:\n            result.append(even_indices_values[even_idx])\n            even_idx += 1\n        else:\n            result.append(l[idx])\n            \n    return result\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `sort_even` takes a list of floats (`l`) and returns a new list where the elements at even indices are sorted while keeping the elements at odd indices in their original positions.\n\n1. The first line extracts all values from even indices (0-based) into a new list, which is then sorted.\n2. An empty `result` list is initialized to store the final output.\n3. A variable `even_idx` is used as an index for iterating through the sorted even-indexed elements.\n4. The function iterates over each index of the input list (`l`). If the current index is even, it appends the next value from the sorted even indices list to the result; otherwise, it appends the original element at that odd index.\n5. Finally, the `result` list is returned.\n\nThis approach ensures that elements at even positions are sorted while maintaining the order of elements at odd positions as they were in the input list.\n\n\n"}
{"task_id": "CPP/92", "generation": "#include <cmath>\n#include <iostream>\nusing namespace std;\n\nbool any_int(float a, float b, float c) {\n    // Check if all numbers are integers\n    if (floor(a) != a || floor(b) != b || floor(c) != c) {\n        return false;\n    }\n    \n    // Check if one of the numbers is equal to the sum of the other two\n    return (a == b + c) || (b == a + c) || (c == a + b);\n}\n", "py_code": "def any_int(a, b, c):\n    # Check if all numbers are integers\n    if not (a.is_integer() and b.is_integer() and c.is_integer()):\n        return False\n    \n    # Check if one of the numbers is equal to the sum of the other two\n    return a == b + c or b == a + c or c == a + b\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `any_int` takes three float arguments (a, b, c) and checks if any one of them is equal to the sum of the other two while also ensuring that all numbers are integers. The function first verifies whether each number is an integer using the `.is_integer()` method. If any of the numbers are not integers, it returns `False`. Otherwise, it proceeds to check if any of the three conditions (a == b + c, b == a + c, or c == a + b) hold true and returns `True` if one of them does; otherwise, it returns `False`.```\n\n\n"}
{"task_id": "CPP/118", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nstring get_closest_vowel(string word) {\n    string vowels = \"aeiouAEIOU\";\n    for (int i = word.length() - 2; i > 0; --i) {\n        if (vowels.find(word[i]) != string::npos && \n            vowels.find(word[i-1]) == string::npos &&\n            vowels.find(word[i+1]) == string::npos) {\n            return string(1, word[i]);\n        }\n    }\n    return \"\";\n}\n", "py_code": "def get_closest_vowel(word):\n    vowels = \"aeiouAEIOU\"\n    for i in range(len(word) - 2, 0, -1):\n        if word[i] in vowels and word[i-1] not in vowels and word[i+1] not in vowels:\n            return word[i]\n    return \"\"\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `get_closest_vowel` is designed to find the closest vowel that stands between two consonants from the right side of a given word (case sensitive). The function works as follows:\n1. It defines a string `vowels` containing all vowels in both lowercase and uppercase.\n2. It iterates over the characters of the input word from second last character to the second character (`range(len(word) - 2, 0, -1)`), checking each position for a vowel that is surrounded by consonants on either side.\n3. If it finds such a vowel (i.e., `word[i]` is in `vowels`, and both `word[i-1]` and `word[i+1]` are not vowels), the function returns this vowel immediately, as it's the closest one from the right that meets the condition.\n4. If no such vowel is found after iterating through all possible positions, the function returns an empty string.\n\nThis approach ensures that only vowels surrounded by consonants and located between the first and last characters of the word are considered, meeting the problem requirements.\n\n"}
{"task_id": "CPP/6", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\nusing namespace std;\n\nvector<int> parse_nested_parens(string paren_string) {\n    istringstream iss(paren_string);\n    string group;\n    vector<int> max_depths;\n\n    while (getline(iss, group, ' ')) {\n        int current_depth = 0;\n        int max_depth = 0;\n        \n        for (char c : group) {\n            if (c == '(') {\n                current_depth += 1;\n                max_depth = std::max(max_depth, current_depth);\n            } else if (c == ')') {\n                current_depth -= 1;\n            }\n        }\n\n        max_depths.push_back(max_depth);\n    }\n\n    return max_depths;\n}\n", "py_code": "def parse_nested_parens(paren_string):\n    groups = paren_string.split()\n    max_depths = []\n    for group in groups:\n        current_depth = 0\n        max_depth = 0\n        for char in group:\n            if char == '(':\n                current_depth += 1\n                max_depth = max(max_depth, current_depth)\n            elif char == ')':\n                current_depth -= 1\n        max_depths.append(max_depth)\n    return max_depths\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `parse_nested_parens` takes a string of groups of nested parentheses separated by spaces as input and returns a list containing the deepest level of nesting for each group.\n\n1. The input string is split into individual groups using the `split()` method.\n2. An empty list, `max_depths`, is initialized to store the maximum depth of nesting for each group.\n3. For each group in the list:\n   - A variable `current_depth` is used to track the current level of nesting within the group.\n   - Another variable `max_depth` keeps track of the highest level of nesting encountered so far in that group.\n4. The function iterates through each character in a group:\n   - If an opening parenthesis '(' is found, it increments `current_depth` and updates `max_depth` if necessary.\n   - If a closing parenthesis ')' is found, it decrements `current_depth`.\n5. After processing all characters of the current group, the maximum depth (`max_depth`) for that group is appended to the `max_depths` list.\n6. Finally, the function returns the `max_depths` list containing the deepest level of nesting for each group in the input string.```\n\n"}
{"task_id": "CPP/87", "generation": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nbool compare(const vector<int>& a, const vector<int>& b) {\n    if (a[0] == b[0]) return a[1] > b[1]; // sort columns in descending order within each row\n    return a[0] < b[0]; // sort rows in ascending order\n}\n\nvector<vector<int>> get_row(vector<vector<int>> lst, int x) {\n    vector<vector<int>> coordinates;\n    \n    for (size_t i = 0; i < lst.size(); ++i) { // iterate through each row\n        for (size_t j = 0; j < lst[i].size(); ++j) { // iterate through each column in the current row\n            if (lst[i][j] == x) {\n                coordinates.push_back({static_cast<int>(i), static_cast<int>(j)}); // add coordinate to list\n            }\n        }\n    }\n\n    sort(coordinates.begin(), coordinates.end(), compare); // sort by rows and columns as specified\n\n    return coordinates;\n}\n", "py_code": "def get_row(lst, x):\n    coordinates = []\n    for row_idx, row in enumerate(lst):\n        for col_idx, value in enumerate(row):\n            if value == x:\n                coordinates.append([row_idx, col_idx])\n    \n    # Sort by rows in ascending order and then columns in descending order within each row\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    return coordinates\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `get_row` takes a nested list (`lst`) and an integer (`x`). It searches for occurrences of `x` within the nested list and records their coordinates (row index and column index). The coordinates are stored in a list named `coordinates`. After collecting all the coordinates, the function sorts them first by row indices in ascending order. Within each row, it further sorts the columns in descending order. Finally, the function returns the sorted list of coordinates.\n\nThe nested for-loop iterates through each element in the 2D list to find matches with `x`, and if a match is found, its coordinate (row index, column index) is added to the `coordinates` list. The sorting step ensures that the output is organized as required by the problem statement.\n```\n\n"}
{"task_id": "CPP/2", "generation": "#include <cmath> // for using floor function\n\nfloat truncate_number(float number) {\n    int integer_part = static_cast<int>(std::floor(number));\n    float decimal_part = number - integer_part;\n    return decimal_part;\n}\n", "py_code": "def truncate_number(number):\n    integer_part = int(number)\n    decimal_part = number - integer_part\n    return decimal_part\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `truncate_number` takes a floating point number as input and returns its decimal part. The function first calculates the integer part of the given number by converting it to an integer using the `int()` function. This operation effectively truncates the decimal part of the number. Then, the function subtracts this integer part from the original number to obtain the decimal part. Finally, the function returns the calculated decimal part.\n```\n\n"}
{"task_id": "CPP/16", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <unordered_set>\nusing namespace std;\n\nint count_distinct_characters(string str) {\n    transform(str.begin(), str.end(), str.begin(), ::tolower); // Convert string to lowercase\n    unordered_set<char> distinct_chars(str.begin(), str.end()); // Create a set of unique characters\n    return distinct_chars.size(); // Return the size of the set, which is the number of distinct characters\n}\n", "py_code": "def count_distinct_characters(str):\n    return len(set(str.lower()))\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `count_distinct_characters` takes a string as input and returns the number of distinct characters in it, ignoring case differences. The function converts the entire string to lowercase using `.lower()` to ensure that character comparison is case-insensitive. It then creates a set from this lowercase version of the string, which automatically removes duplicate characters since sets only store unique elements. Finally, the length of this set is returned as the count of distinct characters in the input string.```\n\n"}
{"task_id": "CPP/135", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nint can_arrange(vector<int> arr) {\n    for (size_t i = 1; i < arr.size(); ++i) {\n        if (arr[i] < arr[i-1]) {\n            return static_cast<int>(i);\n        }\n    }\n    return -1;\n}\n", "py_code": "def can_arrange(arr):\n    for i in range(1, len(arr)):\n        if arr[i] < arr[i-1]:\n            return i\n    return -1\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `can_arrange` takes a list of integers as input and returns the largest index where an element is not greater than or equal to its preceding element. The function iterates through the list starting from the second element (index 1). For each element, it checks if the current element is less than the previous one. If such an element is found, the function immediately returns the index of that element. If no such element exists in the entire list, the function returns -1 after completing the loop.\n```\n\n"}
{"task_id": "CPP/106", "generation": "#include <stdio.h>\n#include <vector>\n#include <numeric> // for std::iota\n\nusing namespace std;\n\nint factorial(int num) {\n    int result = 1;\n    for (int i = 2; i <= num; ++i) {\n        result *= i;\n    }\n    return result;\n}\n\nint sum_to_i(int num) {\n    return (num * (num + 1)) / 2; // Using the formula n*(n+1)/2\n}\n\nvector<int> f(int n) {\n    vector<int> result(n);\n    for (int i = 1; i <= n; ++i) {\n        if (i % 2 == 0) {\n            result[i - 1] = factorial(i); // Adjusting index to match C++ zero-based indexing\n        } else {\n            result[i - 1] = sum_to_i(i);\n        }\n    }\n    return result;\n}\n", "py_code": "from math import factorial\n\ndef f(n):\n    result = []\n    for i in range(1, n + 1):\n        if i % 2 == 0:\n            result.append(factorial(i))\n        else:\n            result.append(sum(range(1, i + 1)))\n    return result\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `f` takes an integer `n` as input and returns a list of size `n`. The value at each index `i` (starting from 1) in this list is determined based on whether `i` is even or odd. If `i` is even, the value is the factorial of `i`; if `i` is odd, the value is the sum of numbers from 1 to `i`. The function uses a loop that iterates over each integer from 1 to `n`, calculates the appropriate value based on the parity of `i`, and appends it to the result list. Finally, the function returns this list.\n\n"}
{"task_id": "CPP/162", "generation": "#include <stdio.h>\n#include <string>\n#include <openssl/md5.h>\n#include <sstream>\nusing namespace std;\n\nstring string_to_md5(string text) {\n    if (text.empty()) return \"None\";\n\n    unsigned char digest[MD5_DIGEST_LENGTH];\n    MD5((unsigned char*)text.c_str(), text.length(), (unsigned char*)&digest);    \n\n    stringstream ss;\n    for(int i = 0; i < MD5_DIGEST_LENGTH; i++) {\n        ss << hex << setw(2) << setfill('0') << (int)digest[i];\n    }\n\n    return ss.str();\n}\n", "py_code": "import hashlib\n\ndef string_to_md5(text):\n    if not text:\n        return None\n    md5_hash = hashlib.md5(text.encode()).hexdigest()\n    return md5_hash\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `string_to_md5` takes a string input and returns its MD5 hash equivalent as another string. If the input string is empty, it returns `None`. The function first checks if the input text is an empty string using `if not text:`. If the condition is true (i.e., the text is empty), it directly returns `None`.\n\nIf the text is not empty, the function uses Python's built-in `hashlib` library to compute the MD5 hash of the given text. The `text.encode()` method encodes the string into bytes, which is required by the `md5()` function from the hashlib module. Then `.hexdigest()` converts the binary hash output into a hexadecimal string representation.\n\nFinally, the function returns this hexadecimal string as the result.\n\n"}
{"task_id": "CPP/5", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> intersperse(vector<int> numbers, int delimiter) {\n    if (numbers.empty()) {\n        return {};\n    }\n\n    vector<int> result = {numbers[0]};\n    \n    for (size_t i = 1; i < numbers.size(); ++i) {\n        result.push_back(delimiter);\n        result.push_back(numbers[i]);\n    }\n    \n    return result;\n}\n", "py_code": "def intersperse(numbers, delimiter):\n    if not numbers:\n        return []\n    \n    result = [numbers[0]]\n    for num in numbers[1:]:\n        result.extend([delimiter, num])\n        \n    return result\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `intersperse` takes two arguments: a list of integers (`numbers`) and an integer (`delimiter`). The goal is to insert the delimiter between every pair of consecutive elements in the input list.\n\n1. If the input list `numbers` is empty, the function returns an empty list.\n2. Otherwise, it initializes the result list with the first element from `numbers`.\n3. It then iterates over the remaining elements in `numbers`, appending the delimiter and each subsequent number to the result list.\n4. Finally, the function returns the constructed result list.\n\nThis approach ensures that the delimiter is placed between every pair of consecutive numbers while maintaining the order of the original numbers.```"}
{"task_id": "CPP/97", "generation": "#include <cmath> // For abs function\n\nint multiply(int a, int b) {\n    int unit_digit_a = std::abs(a) % 10;\n    int unit_digit_b = std::abs(b) % 10;\n    return unit_digit_a * unit_digit_b;\n}\n", "py_code": "def multiply(a, b):\n    unit_digit_a = abs(a) % 10\n    unit_digit_b = abs(b) % 10\n    return unit_digit_a * unit_digit_b\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `multiply` takes two integers as input and returns the product of their unit digits (the last digit). The function first calculates the absolute value of each integer to handle negative numbers correctly. It then uses the modulo operator `%` with 10 to extract the unit digit from both inputs (`unit_digit_a` for the first number, `unit_digit_b` for the second). Finally, it returns the product of these two unit digits.\n\nThis approach ensures that even if one or both of the input numbers are negative, their last digits will still be correctly identified and multiplied.```\n\n"}
{"task_id": "CPP/44", "generation": "#include <stdio.h>\n#include <string>\n#include <vector>\nusing namespace std;\n\nstring change_base(int x, int base) {\n    if (x == 0) return \"0\";\n    \n    vector<int> digits;\n    while (x > 0) {\n        digits.push_back(x % base);\n        x /= base;\n    }\n    \n    string result = \"\";\n    for (int i = digits.size() - 1; i >= 0; --i) {\n        result += to_string(digits[i]);\n    }\n    \n    return result;\n}\n", "py_code": "def change_base(x: int, base: int) -> str:\n    if x == 0:\n        return \"0\"\n    digits = []\n    while x > 0:\n        digits.append(str(x % base))\n        x //= base\n    return ''.join(digits[::-1])\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `change_base` takes two parameters: an integer `x` and a target numerical `base`. The goal is to convert the number `x` from its original base (assumed to be 10) into the specified `base`, and return the result as a string.\n\nHere's how it works:\n- If `x` is zero, the function immediately returns `\"0\"`.\n- Otherwise, an empty list named `digits` is initialized.\n- The function then enters a loop where it repeatedly divides `x` by the target base. During each iteration, the remainder of this division (`x % base`) is appended to `digits` as a string.\n- After each iteration, `x` is updated to be the integer quotient of its previous value divided by `base`.\n- This process continues until `x` becomes zero.\n- Finally, the function reverses the list `digits`, joins all elements into a single string, and returns this string.\n\nThis approach effectively converts the number from base 10 to any other base less than 10 as required. The reversed order of digits is necessary because the remainders are calculated in reverse order during the conversion process.\n\n"}
{"task_id": "CPP/161", "generation": "#include <iostream>\n#include <string>\n#include <cctype> // for isalpha, islower, isupper, tolower, toupper\nusing namespace std;\n\nstring solve(string s) {\n    bool has_letters = false;\n    \n    // Check if the string contains any letters\n    for (char c : s) {\n        if (isalpha(c)) {\n            has_letters = true;\n            break;\n        }\n    }\n\n    if (!has_letters) {\n        reverse(s.begin(), s.end());\n        return s;\n    }\n\n    string result = \"\";\n    \n    // Process each character in the string\n    for (char c : s) {\n        if (isalpha(c)) {\n            if (islower(c)) {\n                result += toupper(c);\n            } else {\n                result += tolower(c);\n            }\n        } else {\n            result += c;\n        }\n    }\n\n    return result;\n}\n", "py_code": "def solve(s):\n    has_letters = any(c.isalpha() for c in s)\n    if not has_letters:\n        return s[::-1]\n    \n    result = []\n    for char in s:\n        if char.isalpha():\n            if char.islower():\n                result.append(char.upper())\n            else:\n                result.append(char.lower())\n        else:\n            result.append(char)\n    return ''.join(result)\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `solve` takes a string `s` as input and processes it according to specific rules:\n1. It first checks if there are any alphabetic characters in the string using the `any()` function combined with `isalpha()`. If no letters are found (`has_letters` is False), the function reverses the entire string and returns it.\n2. If there are letters, the function iterates through each character of the string:\n   - For alphabetic characters, it checks if they are lowercase or uppercase using `islower()` and `isupper()`, respectively. It then appends the reversed case version to a list (`result`).\n   - Non-alphabetic characters are appended as-is.\n3. Finally, the function joins all elements in the `result` list into a single string and returns it.\n\nThis approach ensures that letters have their cases reversed while non-letter characters remain unchanged unless there are no letters at all, in which case the entire string is reversed."}
{"task_id": "CPP/38", "generation": "#include <string>\nusing namespace std;\n\nstring encode_cyclic(string s) { \n    // returns encoded string by cycling groups of three characters.  \n    int l = s.length();\n    int num_groups = (l + 2) / 3;\n    string output = \"\";\n    \n    for (int i = 0; i * 3 < l; i++) {\n        // Extract substring of length up to 3\n        string x = s.substr(i * 3, 3);\n        \n        // Perform cyclic shift if the group has exactly 3 characters\n        if (x.length() == 3) \n            x = x.substr(1) + x[0];\n        \n        output += x;\n    }\n    \n    return output;\n}\n\nstring decode_cyclic(string s) { \n    /*\n    takes as input string encoded with encode_cyclic function. Returns decoded string.\n    */\n    int l = s.length();\n    int num_groups = (l + 2) / 3;\n    string output = \"\";\n    \n    for (int i = 0; i * 3 < l; i++) {\n        // Extract substring of length up to 3\n        string x = s.substr(i * 3, 3);\n        \n        // Reverse cyclic shift if the group has exactly 3 characters\n        if (x.length() == 3) \n            x = x.back() + x.substr(0, x.size() - 1);\n        \n        output += x;\n    }\n    \n    return output;\n}\n", "py_code": "def encode_cyclic(s):\n    # Split the string into groups of three characters.\n    l = len(s)\n    num_groups = (l + 2) // 3\n    output = \"\"\n    \n    for i in range(num_groups):\n        x = s[i * 3:(i + 1) * 3]\n        if len(x) == 3:\n            # Cycle the elements within each group.\n            x = x[1:] + x[0]\n        output += x\n    \n    return output\n\ndef decode_cyclic(s):\n    l = len(s)\n    num_groups = (l + 2) // 3\n    output = \"\"\n    \n    for i in range(num_groups):\n        x = s[i * 3:(i + 1) * 3]\n        if len(x) == 3:\n            # Reverse the cyclic operation to decode.\n            x = x[-1] + x[:-1]\n        output += x\n    \n    return output\n```\n\n", "py_summary": "### Analysis of the Python Code:\n\nThe provided Python functions `encode_cyclic` and `decode_cyclic` are designed to encode and decode a string by cycling groups of three characters.\n\n1. **Function: `encode_cyclic(s)`**\n   - The function takes a string `s` as input.\n   - It calculates the length of the string (`l`) and determines the number of groups needed, where each group consists of up to 3 characters (`num_groups = (l + 2) // 3`).\n   - A loop iterates over these groups. For each group:\n     - The substring `x` is extracted from the input string.\n     - If the length of `x` is exactly 3, it performs a cyclic shift by moving the first character to the end (`x = x[1:] + x[0]`).\n   - The modified groups are concatenated and returned as the encoded string.\n\n2. **Function: `decode_cyclic(s)`**\n   - This function takes an encoded string `s` as input.\n   - It calculates the length of the string (`l`) and determines the number of groups needed, similar to the encoding process.\n   - A loop iterates over these groups. For each group:\n     - The substring `x` is extracted from the input string.\n     - If the length of `x` is exactly 3, it reverses the cyclic shift by moving the last character to the beginning (`x = x[-1] + x[:-1]`).\n   - The modified groups are concatenated and returned as the decoded string.\n\nThe encoding process shifts characters within each group of three, while decoding reverses this operation to restore the original string. Both functions handle cases where the final group has fewer than 3 characters by not performing any cyclic shift on such groups.\n\n"}
{"task_id": "CPP/93", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <unordered_map>\nusing namespace std;\n\nstring encode(string message) {\n    unordered_map<char, char> vowels = {\n        {'a', 'c'}, {'e', 'g'}, {'i', 'k'}, {'o', 'q'}, {'u', 'w'},\n        {'A', 'C'}, {'E', 'G'}, {'I', 'K'}, {'O', 'Q'}, {'U', 'W'}\n    };\n\n    string encoded_message = \"\";\n    for (char& c : message) {\n        if (vowels.find(c) != vowels.end()) {\n            // Replace vowel with the mapped value\n            encoded_message += vowels[c];\n        } else {\n            // Swap case of non-vowel characters\n            if (islower(c)) {\n                encoded_message += toupper(c);\n            } else {\n                encoded_message += tolower(c);\n            }\n        }\n    }\n\n    return encoded_message;\n}\n", "py_code": "def encode(message):\n    vowels = {'a': 'c', 'e': 'g', 'i': 'k', 'o': 'q', 'u': 'w',\n              'A': 'C', 'E': 'G', 'I': 'K', 'O': 'Q', 'U': 'W'}\n    \n    encoded_message = \"\"\n    for char in message:\n        if char.lower() in vowels:\n            encoded_message += vowels[char]\n        else:\n            encoded_message += char.swapcase()\n    return encoded_message\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `encode` takes a string message as input and performs two operations on each character of the message:\n1. It swaps the case of all letters (lowercase to uppercase and vice versa).\n2. If the letter is a vowel ('a', 'e', 'i', 'o', 'u' in lowercase or their uppercase counterparts), it replaces the vowel with the letter that appears two places ahead in the English alphabet.\n\nThe function uses a dictionary `vowels` to map each vowel to its corresponding replacement character. It iterates through each character of the input message, checks if the character is a vowel by looking up its lowercase version in the `vowels` dictionary, and replaces it with the mapped value from the dictionary if it's a vowel. If the character is not a vowel, it swaps its case using the `swapcase()` method.\n\nThe function then concatenates each processed character to form the encoded message and returns this final string.\n\n"}
{"task_id": "CPP/152", "generation": "#include <stdio.h>\n#include <cmath>\n#include <vector>\nusing namespace std;\n\nvector<int> compare(vector<int> game, vector<int> guess) {\n    vector<int> result;\n    for (size_t i = 0; i < game.size(); ++i) {\n        int diff = abs(game[i] - guess[i]);\n        result.push_back(diff);\n    }\n    return result;\n}\n", "py_code": "from typing import List\n\ndef compare(game: List[int], guess: List[int]) -> List[int]:\n    result = []\n    for g, gu in zip(game, guess):\n        result.append(abs(g - gu))\n    return result\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `compare` takes two lists of integers as input: `game`, which represents the actual scores of matches, and `guess`, which represents the guessed scores for those matches. The function returns a list where each element is either 0 if the guess was correct or the absolute difference between the guess and the score if it was incorrect.\n\nThe function iterates over pairs of elements from `game` and `guess` using the `zip` function, calculates the absolute difference between each pair, and appends this value to a result list. Finally, the function returns the result list containing the differences or zeros for correct guesses.\n```\n\n\n"}
{"task_id": "CPP/62", "generation": "#include <stdio.h>\n#include <math.h>\n#include <vector>\nusing namespace std;\n\nvector<float> derivative(vector<float> xs) {\n    vector<float> result;\n    for (size_t i = 1; i < xs.size(); ++i) {\n        result.push_back(i * xs[i]);\n    }\n    return result;\n}\n", "py_code": "from typing import List\n\ndef derivative(xs: List[float]) -> List[float]:\n    return [i * coeff for i, coeff in enumerate(xs)][1:]\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `derivative` takes a list of coefficients (`xs`) representing a polynomial and returns the derivative of that polynomial as another list of coefficients. The input list `xs` represents the polynomial in the form xs[0] + xs[1]*x + xs[2]*x^2 + ..., where each element corresponds to the coefficient of x raised to an increasing power.\n\nThe function uses a list comprehension to generate the derivative's coefficients by multiplying each coefficient (except for the constant term) with its corresponding exponent and then skipping the first element, which is the constant term. The resulting list contains the coefficients of the polynomial's derivative in the same form as the input.\n```\n\n"}
{"task_id": "CPP/7", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nvector<string> filter_by_substring(vector<string> strings, string substring) {\n    vector<string> filtered_strings;\n    for (const auto& str : strings) {\n        if (str.find(substring) != string::npos) {\n            filtered_strings.push_back(str);\n        }\n    }\n    return filtered_strings;\n}\n", "py_code": "from typing import List\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    return [s for s in strings if substring in s]\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `filter_by_substring` takes two arguments: a list of strings (`strings`) and a substring (`substring`). It returns a new list containing only those strings from the input list that contain the specified substring.\n\nThe function uses a list comprehension to iterate over each string in the input list. For each string, it checks if the `substring` is present within the string using the `in` operator. If the condition evaluates to True, the string is included in the resulting list. The final result is returned as a list of strings that contain the specified substring.\n```\n\n"}
{"task_id": "CPP/24", "generation": "#include <iostream>\nusing namespace std;\n\nint largest_divisor(int n) {\n    for (int i = n / 2; i > 0; --i) {\n        if (n % i == 0) {\n            return i;\n        }\n    }\n    // In case no divisor is found, which shouldn't happen for any positive integer n > 1\n    return -1;\n}\n", "py_code": "def largest_divisor(n):\n    for i in range(n // 2, 0, -1):\n        if n % i == 0:\n            return i\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `largest_divisor` takes an integer `n` as input and returns the largest divisor of `n` that is smaller than `n`. The function starts by iterating from `n // 2` down to `1`, checking if each number divides `n` evenly (i.e., `n % i == 0`). When it finds such a divisor, it immediately returns it as the result. This ensures that the first (and largest) divisor found is returned.\n\n"}
{"task_id": "CPP/79", "generation": "#include <bitset>\n#include <string>\nusing namespace std;\n\nstring decimal_to_binary(int decimal) {\n    string binary_str = bitset<32>(decimal).to_string(); // Convert to 32-bit binary string.\n    \n    // Find the first '1' from left, which indicates the start of significant bits.\n    size_t first_one_pos = binary_str.find('1');\n    if (first_one_pos != string::npos) {\n        // Trim leading zeros\n        binary_str = binary_str.substr(first_one_pos);\n    } else {\n        // If no '1's are found, it means decimal is 0.\n        binary_str = \"0\";\n    }\n\n    return \"db\" + binary_str + \"db\";\n}\n", "py_code": "def decimal_to_binary(decimal):\n    binary_str = bin(decimal)[2:]  # Convert to binary and remove the '0b' prefix.\n    return f\"db{binary_str}db\"\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `decimal_to_binary` takes an integer in decimal form and converts it to a binary string representation. The built-in `bin()` function is used to convert the given decimal number into its binary equivalent, which includes a '0b' prefix indicating that the following digits are in binary format. To remove this prefix, we use slicing with `[2:]`. Finally, the function returns a new string formatted as \"db{binary_str}db\", where `{binary_str}` is the binary representation of the input decimal number without the '0b' prefix.\n```\n\n\n"}
{"task_id": "CPP/155", "generation": "#include <stdio.h>\n#include <math.h>\n#include <string>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> even_odd_count(int num) {\n    // Convert number to string and remove possible negative sign\n    string str_num = to_string(abs(num));\n    \n    int even_count = 0;\n    int odd_count = 0;\n    \n    for (char digit : str_num) {\n        if ((digit - '0') % 2 == 0) {\n            even_count += 1;\n        } else {\n            odd_count += 1;\n        }\n    }\n    \n    return {even_count, odd_count};\n}\n", "py_code": "def even_odd_count(num):\n    # Convert number to string and remove possible negative sign\n    str_num = str(abs(num))\n    even_count = 0\n    odd_count = 0\n    \n    for digit in str_num:\n        if int(digit) % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n            \n    return [even_count, odd_count]\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `even_odd_count` takes an integer as input and returns a list containing two elements: the count of even digits and the count of odd digits in the given number.\n\n1. The function first converts the absolute value of the input number to a string (`str_num`). This conversion allows easy iteration over each digit.\n2. Two counters, `even_count` and `odd_count`, are initialized to zero.\n3. A loop iterates through each character (digit) in `str_num`. For each digit:\n   - It converts the character back into an integer.\n   - Checks if the digit is even or odd by using the modulo operator (`% 2 == 0` for even).\n   - Updates the respective counter based on whether the digit is even or odd.\n4. Finally, it returns a list containing `even_count` and `odd_count`.\n\nThis approach ensures that all digits in the number are processed correctly, regardless of their position within the integer.\n\n"}
{"task_id": "CPP/4", "generation": "#include <stdio.h>\n#include <math.h>\n#include <vector>\n#include <numeric> // for std::accumulate\nusing namespace std;\n\nfloat mean_absolute_deviation(vector<float> numbers) {\n    float sum = accumulate(numbers.begin(), numbers.end(), 0.0);\n    float mean_value = sum / numbers.size();\n    \n    float mad_sum = 0.0;\n    for (const auto& x : numbers) {\n        mad_sum += fabs(x - mean_value);\n    }\n    \n    float mad = mad_sum / numbers.size();\n    return mad;\n}\n", "py_code": "from typing import List\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    mean_value = sum(numbers) / len(numbers)\n    mad = sum(abs(x - mean_value) for x in numbers) / len(numbers)\n    return mad\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `mean_absolute_deviation` calculates the Mean Absolute Deviation (MAD) of a list of numbers. The MAD is defined as the average absolute difference between each element and the mean of the dataset.\n\n1. First, it computes the mean (`mean_value`) of the input list by summing all elements and dividing by the length of the list.\n2. Then, it calculates the sum of the absolute differences between each number in the list and the computed mean.\n3. Finally, it divides this sum by the length of the list to get the average (MAD) and returns this value.\n\nThis approach ensures that the function correctly computes the MAD as required by the problem statement.```\n\n"}
{"task_id": "CPP/56", "generation": "#include <string>\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    int balance = 0;\n    for (char c : brackets) {\n        if (c == '<') {\n            balance += 1;\n        } else if (c == '>') {\n            balance -= 1;\n        }\n        if (balance < 0) {\n            return false;\n        }\n    }\n    return balance == 0;\n}\n", "py_code": "def correct_bracketing(brackets):\n    balance = 0\n    for char in brackets:\n        if char == '<':\n            balance += 1\n        elif char == '>':\n            balance -= 1\n        if balance < 0:\n            return False\n    return balance == 0\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `correct_bracketing` checks whether a string of angle brackets (`<` and `>`) is correctly bracketed. The function iterates through each character in the input string `brackets`. It maintains a balance counter that increments when an opening bracket `<` is encountered and decrements when a closing bracket `>` is found.\n\nIf at any point during this iteration, the balance becomes negative (`balance < 0`), it means there's a closing bracket without a corresponding opening bracket, so the function immediately returns `False`. After iterating through all characters in the string, if the balance is zero (`balance == 0`), it indicates that every opening bracket has a matching closing bracket and the function returns `True`.\n\n"}
{"task_id": "CPP/159", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm> // for std::min and std::max\n\nusing namespace std;\n\nvector<int> eat(int number, int need, int remaining) {\n    int total_eaten = number + min(need, remaining);\n    int left_over = max(0, remaining - need);\n\n    return {total_eaten, left_over};\n}\n", "py_code": "def eat(number, need, remaining):\n    total_eaten = number + min(need, remaining)\n    left_over = max(0, remaining - need)\n    return [total_eaten, left_over]\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `eat` takes three parameters: `number`, `need`, and `remaining`. These represent the number of carrots already eaten, the number needed to be eaten, and the remaining available carrots, respectively.\n\n1. The function calculates the total number of carrots that will have been eaten after attempting to eat the required amount by adding the initial number of eaten carrots (`number`) with the minimum between what is needed (`need`) and what remains in stock (`remaining`). This ensures that if there are not enough remaining carrots, all available ones will be consumed.\n\n2. It then calculates how many carrots will remain after eating as much as possible. If the required amount exceeds the number of remaining carrots, it sets the leftover to zero; otherwise, it subtracts the needed amount from the remaining stock.\n\n3. Finally, the function returns a list containing two elements: the total number of eaten carrots and the number of carrots left over.\n```"}
{"task_id": "CPP/83", "generation": "#include<iostream>\n#include<cmath>\nusing namespace std;\n\nint starts_one_ends(int n) {\n    if (n == 1) {\n        return 1;\n    }\n    // Calculate the count of numbers that start or end with '1'\n    int count = 2 * static_cast<int>(pow(10, n - 1)) - static_cast<int>(pow(10, n - 2));\n    return count;\n}\n", "py_code": "def starts_one_ends(n):\n    if n == 1:\n        return 1\n    # There are 2 * (10^(n-1)) numbers that start or end with 1.\n    # However, we have counted twice those numbers which both start and end with 1,\n    # so we need to subtract the count of such numbers (which is 10^(n-2)).\n    return 2 * (10 ** (n - 1)) - (10 ** (n - 2))\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `starts_one_ends` calculates the count of n-digit positive integers that start or end with the digit '1'. The logic is as follows:\n\n- If `n == 1`, there's only one such number (the number itself), which is '1'.\n- For numbers greater than 1 digit, we calculate the total count by considering two cases:\n    - Numbers starting with '1': There are \\(10^{(n-1)}\\) such numbers.\n    - Numbers ending with '1': Similarly, there are \\(10^{(n-1)}\\) such numbers.\n  \nHowever, this double-counts numbers that both start and end with '1'. To correct for this overcounting:\n- Subtract the count of n-digit numbers that both start and end with '1', which is \\(10^{(n-2)}\\).\n\nThe final result is given by: `2 * (10 ** (n - 1)) - (10 ** (n - 2))`.\n```\n\n"}
{"task_id": "CPP/27", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring flip_case(string str) {\n    for (size_t i = 0; i < str.length(); ++i) {\n        if (islower(str[i])) {\n            str[i] = toupper(str[i]);\n        } else if (isupper(str[i])) {\n            str[i] = tolower(str[i]);\n        }\n    }\n    return str;\n}\n", "py_code": "def flip_case(s):\n    return s.swapcase()\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `flip_case` takes a string as input and returns a new string with all lowercase characters converted to uppercase and vice versa. This is achieved using the built-in method `swapcase()`, which automatically handles the conversion of each character in the string according to its case (lowercase or uppercase). The function simply calls this method on the input string and returns the result.\n```"}
{"task_id": "CPP/146", "generation": "#include <vector>\n#include <string>\n#include <cmath>\nusing namespace std;\n\nbool isFirstAndLastDigitOdd(int num) {\n    string strNum = to_string(abs(num));\n    int firstDigit = strNum[0] - '0';\n    int lastDigit = strNum[strNum.length() - 1] - '0';\n    return (firstDigit % 2 != 0 && lastDigit % 2 != 0);\n}\n\nint specialFilter(vector<int> nums) {\n    int count = 0;\n    for (int num : nums) {\n        if (num > 10 && isFirstAndLastDigitOdd(num)) {\n            count++;\n        }\n    }\n    return count;\n}\n", "py_code": "def specialFilter(nums):\n    count = 0\n    for num in nums:\n        if num > 10 and int(str(abs(num))[0]) % 2 != 0 and int(str(abs(num))[-1]) % 2 != 0:\n            count += 1\n    return count\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `specialFilter` takes a list of integers (`nums`) as input and returns an integer representing the number of elements in the list that satisfy two conditions:\n1. The element is greater than 10.\n2. Both the first and last digits of the element are odd (i.e., one of {1, 3, 5, 7, 9}).\n\nThe function iterates over each number (`num`) in `nums`. For each number, it checks if the number is greater than 10. If so, it converts the absolute value of the number to a string and extracts its first and last digits by indexing the string representation. It then checks whether both these digits are odd (i.e., not divisible by 2). If both conditions are met, the count (`count`) is incremented.\n\nFinally, the function returns the total count of numbers that satisfy the given criteria.\n\n"}
{"task_id": "CPP/81", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> numerical_letter_grade(vector<float> grades) {\n    vector<string> letter_grades;\n    \n    for (float gpa : grades) {\n        if (gpa == 4.0)\n            letter_grades.push_back(\"A+\");\n        else if (gpa > 3.7)\n            letter_grades.push_back(\"A\");\n        else if (gpa > 3.3)\n            letter_grades.push_back(\"A-\");\n        else if (gpa > 3.0)\n            letter_grades.push_back(\"B+\");\n        else if (gpa > 2.7)\n            letter_grades.push_back(\"B\");\n        else if (gpa > 2.3)\n            letter_grades.push_back(\"B-\");\n        else if (gpa > 2.0)\n            letter_grades.push_back(\"C+\");\n        else if (gpa > 1.7)\n            letter_grades.push_back(\"C\");\n        else if (gpa > 1.3)\n            letter_grades.push_back(\"C-\");\n        else if (gpa > 1.0)\n            letter_grades.push_back(\"D+\");\n        else if (gpa > 0.7)\n            letter_grades.push_back(\"D\");\n        else if (gpa > 0.0)\n            letter_grades.push_back(\"D-\");\n        else\n            letter_grades.push_back(\"E\");\n    }\n    \n    return letter_grades;\n}\n", "py_code": "from typing import List\n\ndef grade_equation(grades: List[float]) -> List[str]:\n    letter_grades = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grades.append(\"A+\")\n        elif gpa > 3.7:\n            letter_grades.append(\"A\")\n        elif gpa > 3.3:\n            letter_grades.append(\"A-\")\n        elif gpa > 3.0:\n            letter_grades.append(\"B+\")\n        elif gpa > 2.7:\n            letter_grades.append(\"B\")\n        elif gpa > 2.3:\n            letter_grades.append(\"B-\")\n        elif gpa > 2.0:\n            letter_grades.append(\"C+\")\n        elif gpa > 1.7:\n            letter_grades.append(\"C\")\n        elif gpa > 1.3:\n            letter_grades.append(\"C-\")\n        elif gpa > 1.0:\n            letter_grades.append(\"D+\")\n        elif gpa > 0.7:\n            letter_grades.append(\"D\")\n        elif gpa > 0.0:\n            letter_grades.append(\"D-\")\n        else:\n            letter_grades.append(\"E\")\n    return letter_grades\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `grade_equation` takes a list of GPAs and returns a corresponding list of letter grades based on predefined GPA thresholds. The function iterates through each GPA in the input list and uses a series of conditional statements to determine the appropriate letter grade for that GPA.\n\nHere is a breakdown of how it works:\n1. For each GPA, the function checks if it matches or falls within specific ranges.\n2. If the GPA equals 4.0, it assigns \"A+\" as the letter grade.\n3. It then uses a series of `elif` statements to check for other GPA ranges and assign corresponding grades such as \"A\", \"A-\", \"B+\", etc.\n4. The function handles all possible GPA values from 4.0 down to 0.0, with each range mapped to a specific letter grade.\n5. If the GPA is less than or equal to 0.0, it assigns an \"E\" as the letter grade.\n\nThe resulting list of letter grades is returned at the end of the function.\n\n"}
{"task_id": "CPP/136", "generation": "#include <stdio.h>\n#include <vector>\n#include <limits>\nusing namespace std;\n\nvector<int> largest_smallest_integers(vector<int> lst) {\n    int max_negative = numeric_limits<int>::min();\n    int min_positive = numeric_limits<int>::max();\n\n    for (int num : lst) {\n        if (num < 0 && num > max_negative) {\n            max_negative = num;\n        } else if (num > 0 && num < min_positive) {\n            min_positive = num;\n        }\n    }\n\n    return {max_negative == numeric_limits<int>::min() ? 0 : max_negative,\n            min_positive == numeric_limits<int>::max() ? 0 : min_positive};\n}\n", "py_code": "def largest_smallest_integers(lst):\n    max_negative = float('-inf')\n    min_positive = float('inf')\n\n    for num in lst:\n        if num < 0 and num > max_negative:\n            max_negative = num\n        elif num > 0 and num < min_positive:\n            min_positive = num\n\n    return [max_negative if max_negative != float('-inf') else 0, \n            min_positive if min_positive != float('inf') else 0]\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `largest_smallest_integers` takes a list of integers as input and returns a tuple containing two values: the largest negative integer and the smallest positive integer from the list. If there are no negative or positive integers in the list, it returns 0 for those respective positions.\n\n1. The function initializes `max_negative` to negative infinity (`float('-inf')`) and `min_positive` to positive infinity (`float('inf')`). These variables will be used to track the largest negative integer and the smallest positive integer found in the list.\n2. It then iterates through each number in the input list:\n   - If a number is less than 0 (negative) and greater than the current `max_negative`, it updates `max_negative` with this new value.\n   - Similarly, if a number is greater than 0 (positive) and smaller than the current `min_positive`, it updates `min_positive` with this new value.\n3. After iterating through all numbers in the list, the function checks whether `max_negative` or `min_positive` were updated from their initial values:\n   - If not (`max_negative` is still negative infinity), it sets `max_negative` to 0 (indicating no negative integers).\n   - Similarly, if `min_positive` is still positive infinity, it sets `min_positive` to 0 (indicating no positive integers).\n4. Finally, the function returns a list containing these two values.\n```\n\n"}
{"task_id": "CPP/67", "generation": "#include <iostream>\n#include <string>\n#include <vector>\n#include <sstream>\nusing namespace std;\n\nint fruit_distribution(string s, int n) {\n    vector<int> nums;\n    stringstream ss(s);\n    string word;\n    \n    while (ss >> word) {\n        if (word == \"and\") continue; // Skip the 'and' keyword\n        try {\n            int num = stoi(word); // Convert to integer and add to vector\n            nums.push_back(num);\n        } catch (...) { // Ignore non-numeric words\n            continue;\n        }\n    }\n\n    // Calculate the number of mangoes by subtracting apples and oranges from total fruits\n    return n - (nums[0] + nums[1]);\n}\n", "py_code": "def fruit_distribution(s: str, n: int) -> int:\n    # Extracting numbers from the string using regex\n    import re\n    nums = [int(num) for num in re.findall(r'\\d+', s)]\n    # Calculating mangoes by subtracting apples and oranges from total fruits\n    return n - sum(nums)\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `fruit_distribution` takes a string `s` that contains the number of apples and oranges in a basket, along with an integer `n` representing the total number of fruits in the basket. The goal is to calculate and return the number of mangoes in the basket.\n\n1. **Regex Extraction**: The function uses regular expressions (`re.findall(r'\\d+', s)`) to extract all numbers from the string `s`. These numbers represent the quantities of apples and oranges.\n2. **Summation**: It then sums these extracted numbers (apples + oranges).\n3. **Subtraction**: Finally, it subtracts this sum from the total number of fruits (`n`) to find out how many mangoes are in the basket.\n\nThe function returns the calculated number of mangoes as an integer.\n```\n\n"}
{"task_id": "CPP/48", "generation": "#include <string>\nusing namespace std;\n\nbool is_palindrome(string text) {\n    int left = 0;\n    int right = text.size() - 1;\n    \n    while (left < right) {\n        if (text[left] != text[right]) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n    return true;\n}\n", "py_code": "def is_palindrome(text):\n    return text == text[::-1]\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `is_palindrome` checks if a given string is a palindrome. A palindrome is a word, phrase, or sequence of characters that reads the same backward as forward (ignoring spaces, punctuation, and capitalization). The function takes a single argument `text`, which represents the input string to be checked.\n\nThe function uses Python's slicing feature (`[::-1]`) to reverse the entire string. It then compares the original string with its reversed version using the equality operator (`==`). If they are equal, it means that the string is a palindrome and the function returns `True`. Otherwise, it returns `False`.\n\nThis approach is concise and leverages Python's powerful slicing capabilities for an efficient solution to check palindromes.```\n\n"}
{"task_id": "CPP/125", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nvector<string> split_words(string txt) {\n    vector<string> result;\n    \n    // Check for spaces and split on them if they exist.\n    size_t pos = 0;\n    string delimiter_space = \" \";\n    while ((pos = txt.find(delimiter_space)) != string::npos) {\n        result.push_back(txt.substr(0, pos));\n        txt.erase(0, pos + delimiter_space.length());\n    }\n    \n    // If there are no spaces left but commas exist, split on them.\n    if (result.empty()) {\n        size_t comma_pos = 0;\n        string delimiter_comma = \",\";\n        while ((comma_pos = txt.find(delimiter_comma)) != string::npos) {\n            result.push_back(txt.substr(0, comma_pos));\n            txt.erase(0, comma_pos + delimiter_comma.length());\n        }\n    }\n\n    // If there are no spaces or commas, count the lowercase letters with odd order positions.\n    if (result.empty()) {\n        int count = 0;\n        for (char c : txt) {\n            if (islower(c) && ((c - 'a') % 2 == 1)) {\n                ++count;\n            }\n        }\n        result.push_back(to_string(count));\n    }\n\n    // Add the remaining part of the string to the result.\n    if (!txt.empty()) {\n        result.push_back(txt);\n    }\n\n    return result;\n}\n", "py_code": "def split_words(txt):\n    if ' ' in txt:\n        return txt.split(' ')\n    elif ',' in txt:\n        return txt.split(',')\n    else:\n        count = sum(1 for c in txt if (ord(c) - ord('a')) % 2 == 0)\n        return [str(count)]\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `split_words` takes a string `txt` as input and returns a list of strings based on specific conditions. The function first checks if there are any spaces in the text; if so, it splits the text by spaces and returns the resulting list. If no spaces exist but commas do, it splits the text by commas instead. Finally, if neither spaces nor commas are present, the function counts the number of lowercase letters with even order positions in the alphabet (where 'a' is at position 0) and returns a list containing this count as a string.\n\nThe `ord` function is used to get the ASCII value of characters, which helps determine their position in the alphabet. The condition `(ord(c) - ord('a')) % 2 == 0` checks if the character's order position is even (considering 'a' at position 0).```\n\n"}
{"task_id": "CPP/160", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\n// Function to evaluate the algebraic expression based on operators and operands.\nint do_algebra(vector<string> operators, vector<int> operands) {\n    int result = operands[0];\n    \n    for (size_t i = 0; i < operators.size(); ++i) {\n        if (operators[i] == \"+\") {\n            result += operands[i + 1];\n        } else if (operators[i] == \"-\") {\n            result -= operands[i + 1];\n        } else if (operators[i] == \"*\") {\n            result *= operands[i + 1];\n        } else if (operators[i] == \"//\") {\n            result /= operands[i + 1]; // Floor division\n        } else if (operators[i] == \"**\") {\n            result = pow(result, operands[i + 1]); // Exponentiation\n        }\n    }\n\n    return result;\n}\n", "py_code": "from typing import List\n\ndef do_algebra(operators: List[str], operands: List[int]) -> int:\n    expression = str(operands[0])\n    for i in range(len(operators)):\n        op = operators[i]\n        if op == \"//\":\n            expression += f\" // {operands[i+1]}\"\n        elif op == \"**\":\n            expression += f\" ** {operands[i+1]}\"\n        else:\n            expression += f\" {op} {operands[i+1]}\"\n    return eval(expression)\n```\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `do_algebra` takes two lists as input: `operators`, which contains strings representing algebraic operations, and `operands`, a list of integers to be used in those operations.\n\n1. The function starts by initializing an empty string `expression` with the first operand.\n2. It then iterates through each operator in the `operators` list:\n   - If the operator is `\"//\"` (floor division) or `\"**\"` (exponentiation), it appends the appropriate operation and the next operand to the expression string.\n   - For other operators (`+`, `-`, `*`), it simply concatenates them with a space before and after for readability, along with the next operand.\n3. After constructing the full algebraic expression as a string, the function uses Python's built-in `eval()` function to evaluate this string as an actual mathematical expression and returns the result.\n\nThis approach constructs the entire expression as a string and evaluates it in one go, which is straightforward but relies on Python\u2019s dynamic evaluation capabilities.\n\n"}
{"task_id": "CPP/151", "generation": "#include <vector>\n#include <cmath>\n\nlong long double_the_difference(std::vector<float> lst) {\n    long long sum = 0;\n    for (float x : lst) {\n        if (x > 0 && std::floor(x) == x && static_cast<int>(x) % 2 != 0) {\n            sum += static_cast<long long>(std::pow(x, 2));\n        }\n    }\n    return sum;\n}\n", "py_code": "from typing import List\n\ndef double_the_difference(lst: List[float]) -> int:\n    return sum(x**2 for x in lst if x > 0 and x == int(x) and x % 2 != 0)\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `double_the_difference` takes a list of floating-point numbers (`lst`) as input and returns an integer representing the sum of squares of odd positive integers in the list.\n\n1. The function uses a generator expression inside the `sum()` function to iterate over each element `x` in the list.\n2. For each number, it checks three conditions:\n   - `x > 0`: Ensures that only positive numbers are considered.\n   - `x == int(x)`: Checks if the number is an integer (i.e., no fractional part).\n   - `x % 2 != 0`: Verifies that the number is odd.\n3. If all conditions are met, it squares the number (`x**2`) and includes it in the sum.\n4. The function returns the total sum of these squared values.\n\nIf there are no numbers meeting the criteria or if the list is empty, the function will return `0`.\n\n"}
{"task_id": "CPP/117", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nbool is_consonant(char c) {\n    string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    return consonants.find(c) != string::npos;\n}\n\nint count_consonants(const string& word) {\n    int count = 0;\n    for (char c : word) {\n        if (is_consonant(c)) {\n            ++count;\n        }\n    }\n    return count;\n}\n\nvector<string> select_words(string s, int n) {\n    vector<string> result;\n    string word;\n    stringstream ss(s);\n    \n    while (ss >> word) {\n        if (count_consonants(word) == n) {\n            result.push_back(word);\n        }\n    }\n\n    return result;\n}\n", "py_code": "def select_words(s: str, n: int) -> list:\n    def count_consonants(word):\n        consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\n        return sum(1 for char in word if char in consonants)\n\n    words = s.split()\n    result = [word for word in words if count_consonants(word) == n]\n    return result\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `select_words` takes a string `s` and an integer `n`, and returns a list of words from `s` that contain exactly `n` consonants. The function first defines a helper function `count_consonants` which counts the number of consonants in a given word by iterating over each character and checking if it is part of a predefined string of consonants.\n\nThe main function then splits the input string into words using the `split()` method, which divides the string at spaces. It uses a list comprehension to iterate through these words and applies the `count_consonants` function to each word. If the number of consonants in a word matches `n`, that word is included in the result list.\n\nFinally, the function returns the list of words with exactly `n` consonants, maintaining their order from the original string.\n```\n\n"}
{"task_id": "CPP/78", "generation": "#include <string>\n#include <algorithm>\nusing namespace std;\n\nint hex_key(std::string num) {\n    const char* prime_hex_digits = \"2357BD\";\n    int count = 0;\n    \n    for (char digit : num) {\n        if (strchr(prime_hex_digits, digit)) {\n            ++count;\n        }\n    }\n\n    return count;\n}\n", "py_code": "def hex_key(num):\n    prime_hex_digits = {'2', '3', '5', '7', 'B', 'D'}\n    return sum(1 for digit in num if digit in prime_hex_digits)\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `hex_key` takes a string `num`, which represents a hexadecimal number, and returns the count of digits that are considered prime in the hexadecimal system. The set `prime_hex_digits` contains the characters representing the prime hexadecimal digits ('2', '3', '5', '7', 'B', 'D'). \n\nThe function uses a generator expression within the `sum()` function to iterate over each digit in the input string and checks if it is present in the `prime_hex_digits` set. If the digit is found, it contributes 1 to the sum; otherwise, it contributes nothing (0). The final result is the total count of prime hexadecimal digits in the input string.\n```\n\n\n"}
{"task_id": "CPP/74", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> total_match(vector<string> lst1, vector<string> lst2) {\n    // Calculate the total number of characters in each list\n    int count_lst1 = 0;\n    for (const string& s : lst1) {\n        count_lst1 += s.length();\n    }\n\n    int count_lst2 = 0;\n    for (const string& s : lst2) {\n        count_lst2 += s.length();\n    }\n    \n    // Compare and return the appropriate list based on character counts\n    if (count_lst1 <= count_lst2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n", "py_code": "def total_match(lst1, lst2):\n    # Calculate the total number of characters in each list\n    count_lst1 = sum(len(s) for s in lst1)\n    count_lst2 = sum(len(s) for s in lst2)\n\n    # Compare and return the appropriate list based on character counts\n    if count_lst1 <= count_lst2:\n        return lst1\n    else:\n        return lst2\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `total_match` takes two lists of strings (`lst1` and `lst2`) as input and returns one of these lists based on the total number of characters in each list.\n\n- The function first calculates the total number of characters for both lists using a generator expression inside the `sum()` function. For `lst1`, it sums up the lengths of all strings, and similarly for `lst2`.\n  \n- It then compares the two counts (`count_lst1` and `count_lst2`). If `count_lst1` is less than or equal to `count_lst2`, the function returns `lst1`. Otherwise, it returns `lst2`.\n\nThis approach ensures that if both lists have an equal number of characters, `lst1` will be returned as per the problem statement.\n\n"}
{"task_id": "CPP/53", "generation": "#include<stdio.h>\n#include<stdlib.h>\nusing namespace std;\n\nint add(int x, int y) {\n    return x + y;\n}\n", "py_code": "def add(x, y):\n    return x + y\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `add` takes two integer arguments `x` and `y`, and returns their sum. The function simply adds the two numbers together using the addition operator (`+`) and returns the result. This is a straightforward implementation of an addition operation between two integers.\n```\n\n"}
{"task_id": "CPP/98", "generation": "#include <string>\n#include <algorithm>\nusing namespace std;\n\nint count_upper(string s) {\n    string vowels = \"AEIOU\";\n    int count = 0;\n    for (size_t i = 0; i < s.length(); i += 2) { // Iterate over even indices\n        if (vowels.find(s[i]) != string::npos) { // Check if the character is an uppercase vowel\n            ++count;\n        }\n    }\n    return count;\n}\n", "py_code": "def count_upper(s):\n    vowels = \"AEIOU\"\n    return sum(1 for i in range(len(s)) if i % 2 == 0 and s[i] in vowels)\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `count_upper` takes a string `s` as input and returns the count of uppercase vowels found at even indices within the string. The function first defines a string `vowels` containing all uppercase vowel characters ('AEIOU'). It then uses a generator expression inside the `sum()` function to iterate over each character in the string by its index. For each index, it checks if the index is even (`i % 2 == 0`) and whether the character at that index is an uppercase vowel (`s[i] in vowels`). If both conditions are met, the generator expression yields a `1`, which contributes to the sum. The total count of such characters is returned as the result.\n```"}
{"task_id": "CPP/140", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring fix_spaces(string text) {\n    string result = \"\";\n    int space_count = 0;\n\n    for (char c : text) {\n        if (c == ' ') {\n            space_count += 1;\n        } else {\n            if (space_count == 1) {\n                result += '_';\n            } else if (space_count > 2) {\n                result += '-';\n            }\n            space_count = 0;\n            result += c;\n        }\n    }\n\n    if (space_count == 1) {\n        result += '_';\n    } else if (space_count > 2) {\n        result += '-';\n    }\n\n    return result;\n}\n", "py_code": "def fix_spaces(text):\n    result = []\n    space_count = 0\n    \n    for char in text:\n        if char == ' ':\n            space_count += 1\n        else:\n            if space_count == 1:\n                result.append('_')\n            elif space_count > 2:\n                result.append('-')\n            space_count = 0\n            result.append(char)\n    \n    if space_count == 1:\n        result.append('_')\n    elif space_count > 2:\n        result.append('-')\n\n    return ''.join(result)\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `fix_spaces` takes a string as input and processes it to replace spaces according to specific rules: single spaces are replaced with underscores ('_'), and more than two consecutive spaces are replaced with a dash ('-'). The function iterates through each character in the input string. It maintains a count of consecutive spaces (`space_count`). When encountering non-space characters, it checks `space_count` to determine whether to append an underscore or a dash based on the number of preceding spaces and then resets `space_count`. After processing all characters, if there are trailing spaces, they are handled according to their count. Finally, the list of processed characters is joined into a string and returned.\n\n"}
{"task_id": "CPP/34", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\n#include <set>\nusing namespace std;\n\nvector<int> unique(vector<int> l) {\n    set<int> s(l.begin(), l.end());\n    vector<int> result(s.begin(), s.end());\n    return result;\n}\n", "py_code": "def unique(l):\n    return sorted(set(l))\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `unique` takes a list of integers as input and returns a new list containing only the unique elements from the original list in sorted order. The function achieves this by first converting the list into a set, which automatically removes any duplicate values since sets cannot contain duplicates. Then, it converts the set back to a list and sorts it before returning. This ensures that the output contains all unique elements from the input list, with no duplicates and in ascending order.```\n\n"}
{"task_id": "CPP/66", "generation": "#include <string>\nusing namespace std;\n\nint digitSum(string s) {\n    int sum = 0;\n    for (char c : s) {\n        if (isupper(c)) {\n            sum += static_cast<int>(c);\n        }\n    }\n    return sum;\n}\n", "py_code": "def digitSum(s):\n    return sum(ord(c) for c in s if c.isupper())\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `digitSum` takes a string as input and returns the sum of ASCII values of all uppercase characters within that string. The function uses a generator expression inside the `sum()` function to iterate over each character in the string (`s`). For each character, it checks if the character is an uppercase letter using the `isupper()` method. If true, it calculates the ASCII value of the character with the `ord()` function and adds it to the sum. The final result is the total sum of ASCII values for all uppercase characters in the string.\n```\n\n"}
{"task_id": "CPP/120", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> maximum(vector<int> arr, int k) {\n    // Sort the array in descending order.\n    sort(arr.begin(), arr.end(), greater<int>());\n    \n    // Take the first k elements from the sorted array.\n    vector<int> result(arr.begin(), arr.begin() + k);\n    \n    // Sort the resulting array in ascending order before returning it.\n    sort(result.begin(), result.end());\n    \n    return result;\n}\n", "py_code": "from typing import List\n\ndef maximum(arr: List[int], k: int) -> List[int]:\n    # Sort the array in descending order and take the first k elements.\n    sorted_arr = sorted(arr, reverse=True)[:k]\n    # Return the result in ascending order.\n    return sorted(sorted_arr)\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `maximum` takes a list of integers (`arr`) and an integer (`k`). The goal is to find the maximum k numbers from the array and return them in ascending order.\n\n1. First, the input list `arr` is sorted in descending order using the built-in `sorted()` function with the parameter `reverse=True`. This ensures that the largest elements come first.\n2. Next, a slice of the first `k` elements from this sorted list is taken to get the maximum k numbers.\n3. Finally, these k elements are sorted again but in ascending order and returned as the result.\n\nThis approach guarantees that we have the k largest values from the input array, and they are presented in ascending order as required by the problem statement.```\n\n"}
{"task_id": "CPP/139", "generation": "#include <iostream>\nusing namespace std;\n\nlong long factorial(long long num) {\n    if (num == 0 || num == 1)\n        return 1;\n    else\n        return num * factorial(num - 1);\n}\n\nlong long special_factorial(int n) {\n    long long result = 1;\n    for (int i = 1; i <= n; ++i) {\n        result *= factorial(i);\n    }\n    return result;\n}\n", "py_code": "def factorial(num):\n    if num == 0 or num == 1:\n        return 1\n    else:\n        return num * factorial(num - 1)\n\ndef special_factorial(n):\n    result = 1\n    for i in range(1, n + 1):\n        result *= factorial(i)\n    return result\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python solution consists of two functions: `factorial` and `special_factorial`. The `factorial` function calculates the factorial of a given number using recursion. It returns 1 if the input is 0 or 1 (base case), otherwise it multiplies the input by the result of calling itself with the input decremented by one.\n\nThe `special_factorial` function computes the Brazilian factorial as defined in the problem statement. It initializes a variable `result` to 1 and iterates from 1 up to `n`, multiplying `result` by the factorial of each integer within this range using the previously defined `factorial` function. Finally, it returns the computed result.\n\nThis approach ensures that all factorials from 1! to n! are multiplied together in order to compute the Brazilian factorial for a given input number `n`.```\n\n"}
{"task_id": "CPP/12", "generation": "#include <vector>\n#include <string>\nusing namespace std;\n\nstring longest(vector<string> strings) {\n    if (strings.empty()) {\n        return \"\"; // In C++, we can't return None, so returning an empty string to represent no value.\n    }\n    \n    int max_length = -1;\n    string result = \"\";\n    \n    for (const auto& s : strings) {\n        if (s.length() > max_length) {\n            max_length = s.length();\n            result = s;\n        }\n    }\n    \n    return result;\n}\n", "py_code": "def longest(strings):\n    if not strings:\n        return None\n    max_length = -1\n    result = \"\"\n    for s in strings:\n        if len(s) > max_length:\n            max_length = len(s)\n            result = s\n    return result\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `longest` takes a list of strings as input and returns the longest string from that list. If there are multiple strings with the same maximum length, it returns the first one encountered. In case the input list is empty, it returns `None`.\n\nHere's how the function works:\n1. It first checks if the input list `strings` is empty. If so, it immediately returns `None`.\n2. The function initializes two variables: `max_length`, which keeps track of the length of the longest string found so far (initialized to -1), and `result`, which stores the current longest string.\n3. It then iterates through each string in the list:\n   - For each string, it checks if its length is greater than `max_length`.\n   - If it is, it updates `max_length` with the new maximum length and sets `result` to the current string.\n4. After iterating through all strings, the function returns `result`, which contains the longest string found.\n\nThis approach ensures that in case of multiple strings having the same length (the longest), the first one encountered is returned as per the problem statement.\n\n"}
{"task_id": "CPP/121", "generation": "#include <vector>\nusing namespace std;\n\nint solution(vector<int> lst) {\n    int sum = 0;\n    for (size_t i = 0; i < lst.size(); i += 2) { // Iterate over even positions\n        if (lst[i] % 2 != 0) { // Check if the element is odd\n            sum += lst[i]; // Add to sum if conditions are met\n        }\n    }\n    return sum;\n}\n", "py_code": "def solution(lst):\n    return sum(x for i, x in enumerate(lst) if i % 2 == 0 and x % 2 != 0)\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `solution` takes a list of integers as input and returns the sum of all odd elements that are located at even positions in the list (considering 0-based indexing). The function uses a generator expression within the `sum()` function to iterate over each element with its index. It checks if the index is even (`i % 2 == 0`) and if the value at that index is an odd number (`x % 2 != 0`). If both conditions are met, it includes the value in the sum. The result of this generator expression is then summed up and returned as the final output.\n```"}
{"task_id": "CPP/35", "generation": "#include <vector>\n#include <algorithm> // for std::max_element\nusing namespace std;\n\nfloat max_element(vector<float> l) {\n    return *std::max_element(l.begin(), l.end());\n}\n", "py_code": "def max_element(l):\n    return max(l)\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `max_element` takes a list of numbers (`l`) as input and returns the maximum element from that list using the built-in `max()` function. The `max()` function iterates through the elements in the list to find and return the largest value.```\n\n"}
{"task_id": "CPP/20", "generation": "#include <algorithm>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nvector<float> find_closest_elements(vector<float> numbers) {\n    // Sort the vector in ascending order.\n    sort(numbers.begin(), numbers.end());\n\n    float min_diff = INFINITY;\n    vector<float> result(2);\n\n    for (size_t i = 0; i < numbers.size() - 1; ++i) {\n        float diff = numbers[i + 1] - numbers[i];\n        if (diff < min_diff) {\n            min_diff = diff;\n            result[0] = numbers[i];\n            result[1] = numbers[i + 1];\n        }\n    }\n\n    return result;\n}\n", "py_code": "from typing import List\n\ndef find_closest_elements(numbers: List[float]) -> tuple:\n    numbers.sort()\n    min_diff = float('inf')\n    result = (0, 0)\n    \n    for i in range(len(numbers) - 1):\n        diff = numbers[i + 1] - numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            result = (numbers[i], numbers[i + 1])\n            \n    return result\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `find_closest_elements` takes a list of floating-point numbers as input and returns a tuple containing two elements that are closest to each other in value from the given list. The steps taken by the function are as follows:\n1. **Sorting**: The input list is first sorted in ascending order.\n2. **Initialization**: Two variables, `min_diff` and `result`, are initialized. `min_diff` is set to positive infinity (`float('inf')`) to ensure that any difference between two numbers will be smaller initially. `result` is a tuple initialized with `(0, 0)` which will store the pair of closest elements.\n3. **Iterating through sorted list**: The function iterates over the sorted list using an index `i`, and for each element at position `i`, it calculates the difference between this element and the next one (`numbers[i + 1] - numbers[i]`).\n4. **Updating minimum difference**: If the calculated difference is smaller than the current value of `min_diff`, then `min_diff` is updated to this new difference, and `result` is set to the pair `(numbers[i], numbers[i+1])`.\n5. **Returning result**: After iterating through all elements in the list, the function returns the tuple `result` containing the two closest elements.\n\nThis approach ensures that the returned values are always in order (smaller number first), due to the sorting step at the beginning of the function.\n```\n\n"}
{"task_id": "CPP/19", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <vector>\n#include <algorithm>\n#include <map>\nusing namespace std;\n\nstring sort_numbers(string numbers) {\n    map<string, int> numeral_map = {\n        {\"zero\", 0},\n        {\"one\", 1},\n        {\"two\", 2},\n        {\"three\", 3},\n        {\"four\", 4},\n        {\"five\", 5},\n        {\"six\", 6},\n        {\"seven\", 7},\n        {\"eight\", 8},\n        {\"nine\", 9}\n    };\n\n    vector<string> num_list;\n    stringstream ss(numbers);\n    string item;\n\n    // Split the input string into a list of individual numerals\n    while (getline(ss, item, ' ')) {\n        num_list.push_back(item);\n    }\n\n    // Convert each numeral to its corresponding integer value using the map and sort them\n    vector<int> int_list;\n    for (const auto& num : num_list) {\n        int_list.push_back(numeral_map[num]);\n    }\n    sort(int_list.begin(), int_list.end());\n\n    // Convert back to numerals and join into a string\n    stringstream sorted_str;\n    for (int val : int_list) {\n        for (auto const& pair : numeral_map) {\n            if (pair.second == val) {\n                sorted_str << pair.first << \" \";\n                break;\n            }\n        }\n    }\n\n    // Remove the trailing space\n    string result = sorted_str.str();\n    if (!result.empty()) {\n        result.pop_back();  // remove last space\n    }\n\n    return result;\n}\n", "py_code": "def sort_numbers(numbers):\n    numeral_map = {\n        \"zero\": 0,\n        \"one\": 1,\n        \"two\": 2,\n        \"three\": 3,\n        \"four\": 4,\n        \"five\": 5,\n        \"six\": 6,\n        \"seven\": 7,\n        \"eight\": 8,\n        \"nine\": 9\n    }\n    \n    # Split the input string into a list of numerals\n    num_list = numbers.split()\n    \n    # Convert each numeral to its corresponding integer value using the map\n    int_list = [numeral_map[num] for num in num_list]\n    \n    # Sort the integers\n    int_list.sort()\n    \n    # Convert back to numerals and join into a string\n    sorted_num_str = ' '.join([k for k, v in numeral_map.items() if v in int_list])\n    \n    return sorted_num_str\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `sort_numbers` takes a space-delimited string of numberals (from \"zero\" to \"nine\") as input and returns a string with these numerals sorted from smallest to largest.\n\n1. The function first defines a dictionary (`numeral_map`) that maps each numeral to its corresponding integer value.\n2. It then splits the input string into a list of individual numerals using `split()`.\n3. Each numeral in this list is converted to its integer equivalent by looking up the `numeral_map` and creating a new list (`int_list`) with these integer values.\n4. The integers are sorted in ascending order using the `sort()` method.\n5. Finally, the function converts each integer back into its corresponding numeral string by iterating over the items of `numeral_map`, checking if the value is present in `int_list` and joining them into a single space-delimited string (`sorted_num_str`). This final string is returned as the output.\n\nThis approach ensures that the numerals are sorted correctly based on their integer values while preserving their original string representation.```\n\n"}
{"task_id": "CPP/85", "generation": "#include <vector>\nusing namespace std;\n\nint add(vector<int> lst) {\n    int result = 0;\n    for (size_t i = 1; i < lst.size(); i += 2) { // Start from index 1 and increment by 2 (odd indices)\n        if (lst[i] % 2 == 0) {                   // Check if the element at odd index is even\n            result += lst[i];\n        }\n    }\n    return result;\n}\n", "py_code": "def add(lst):\n    result = 0\n    for i in range(1, len(lst), 2):  # Start from index 1 and increment by 2 (odd indices)\n        if lst[i] % 2 == 0:           # Check if the element at odd index is even\n            result += lst[i]\n    return result\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `add` takes a list of integers as input and returns the sum of all even elements that are located at odd indices in the list. The function iterates over the list starting from index 1 (the second element) with a step size of 2 to ensure only odd indices are considered. For each element at an odd index, it checks if the element is even by using the modulo operator (`%`). If the element is even, its value is added to `result`. Finally, the function returns the accumulated sum stored in `result`.\n```\n\n"}
{"task_id": "CPP/21", "generation": "#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nvector<float> rescale_to_unit(vector<float> numbers) {\n    float min_val = *min_element(numbers.begin(), numbers.end());\n    float max_val = *max_element(numbers.begin(), numbers.end());\n    float range_val = max_val - min_val;\n    \n    vector<float> rescaled_numbers;\n    if (range_val == 0) {\n        // Handle the case where all numbers are the same.\n        for (size_t i = 0; i < numbers.size(); ++i) {\n            rescaled_numbers.push_back(1.0);\n        }\n    } else {\n        for (float num : numbers) {\n            float rescaled_num = (num - min_val) / range_val;\n            rescaled_numbers.push_back(rescaled_num);\n        }\n    }\n\n    return rescaled_numbers;\n}\n", "py_code": "from typing import List\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    min_val = min(numbers)\n    max_val = max(numbers)\n    range_val = max_val - min_val\n    \n    if range_val == 0:\n        return [1.0] * len(numbers)  # Handle the case where all numbers are the same.\n    \n    rescaled_numbers = [(num - min_val) / range_val for num in numbers]\n    return rescaled_numbers\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `rescale_to_unit` takes a list of floating-point numbers and applies a linear transformation to scale these values such that the smallest number in the list becomes 0 and the largest becomes 1. The function first determines the minimum (`min_val`) and maximum (`max_val`) values from the input list. It then calculates the range of the numbers as `range_val = max_val - min_val`. If all numbers are the same (i.e., `range_val == 0`), it returns a list where each element is set to 1.0.\n\nFor cases where there is variation in the values, the function rescales each number by subtracting the minimum value and dividing by the range (`(num - min_val) / range_val`). This transformation ensures that the smallest number becomes 0 and the largest becomes 1 while maintaining the relative spacing between all numbers. The transformed list of numbers is then returned.\n```\n\n"}
{"task_id": "CPP/119", "generation": "#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nbool is_balanced(const string& s) {\n    int balance = 0;\n    for (char c : s) {\n        if (c == '(') {\n            ++balance;\n        } else {\n            --balance;\n            if (balance < 0) {\n                return false; // More closing parentheses than opening ones\n            }\n        }\n    }\n    return balance == 0; // Balanced if and only if the balance is zero at the end\n}\n\nstring match_parens(vector<string> lst) {\n    string first_concatenation = lst[0] + lst[1];\n    string second_concatenation = lst[1] + lst[0];\n\n    if (is_balanced(first_concatenation) || is_balanced(second_concatenation)) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\n", "py_code": "def match_parens(lst):\n    def is_balanced(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            else:\n                balance -= 1\n                if balance < 0:\n                    return False\n        return balance == 0\n\n    # Check both possible concatenations of the two strings.\n    first_concatenation = lst[0] + lst[1]\n    second_concatenation = lst[1] + lst[0]\n\n    if is_balanced(first_concatenation) or is_balanced(second_concatenation):\n        return \"Yes\"\n    else:\n        return \"No\"\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `match_parens` takes a list of two strings as input and checks if it is possible to concatenate these strings in some order such that the resulting string has balanced parentheses.\n\n1. **Helper Function (`is_balanced`)**: This function checks whether a given string `s` has balanced parentheses by iterating through each character:\n   - If an opening parenthesis `'('` is encountered, the balance counter is incremented.\n   - If a closing parenthesis `')'` is encountered, the balance counter is decremented. If at any point the balance becomes negative, it means there are more closing parentheses than opening ones before that point, and thus the string cannot be balanced.\n\n2. **Concatenation Check**: The function checks both possible concatenations of the two input strings:\n   - `first_concatenation`: Concatenate the first string with the second.\n   - `second_concatenation`: Concatenate the second string with the first.\n\n3. **Balanced Check**: For each concatenated string, it uses the helper function `is_balanced` to check if the resulting string is balanced. If either of these concatenations results in a balanced string, the function returns `\"Yes\"`. Otherwise, it returns `\"No\"`.\n\n"}
{"task_id": "CPP/30", "generation": "#include <stdio.h>\n#include <math.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<float> get_positive(vector<float> l) {\n    vector<float> result;\n    for (float num : l) {\n        if (num > 0) {\n            result.push_back(num);\n        }\n    }\n    return result;\n}\n", "py_code": "def get_positive(l):\n    return [x for x in l if x > 0]\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `get_positive` takes a list of numbers (`l`) as input and returns a new list containing only the positive numbers from the original list. This is achieved using a list comprehension that iterates through each element in the input list and includes it in the output list if it is greater than zero (i.e., positive). The function effectively filters out all non-positive values, such as negative numbers and zero.```\n\n"}
{"task_id": "CPP/64", "generation": "#include <string>\n#include <algorithm>\nusing namespace std;\n\nbool is_vowel(char c) {\n    return c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' ||\n           c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U';\n}\n\nint vowels_count(string s) {\n    int count = 0;\n    for (char c : s) {\n        if (is_vowel(c)) {\n            ++count;\n        }\n    }\n\n    // Check if the last character is a vowel 'y' or 'Y'\n    if (!s.empty() && (s.back() == 'y' || s.back() == 'Y')) {\n        ++count;\n    }\n\n    return count;\n}\n", "py_code": "def vowels_count(s):\n    vowels = \"aeiouAEIOU\"\n    count = sum(1 for char in s if char in vowels)\n    # Check if last character is 'y' or 'Y'\n    if s and (s[-1] == 'y' or s[-1] == 'Y'):\n        count += 1\n    return count\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `vowels_count` takes a string as input and returns the number of vowels in that string. The vowels considered are 'a', 'e', 'i', 'o', 'u' (both lowercase and uppercase). Additionally, if the last character of the string is 'y' or 'Y', it is also counted as a vowel.\n\nThe function first defines a string `vowels` containing all the vowels. It then uses a generator expression within the `sum()` function to count how many characters in the input string are present in the `vowels` string. After counting the standard vowels, the function checks if the last character of the string is 'y' or 'Y'. If it is, the vowel count is incremented by one.\n\nFinally, the function returns the total count of vowels found in the string.\n```\n\n"}
{"task_id": "CPP/128", "generation": "#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nint prod_signs(vector<int> arr) {\n    if (arr.empty()) {\n        return -32768;\n    }\n    \n    int sum_of_magnitudes = 0;\n    int product_of_signs = 1;\n    \n    for (int num : arr) {\n        sum_of_magnitudes += abs(num);\n        if (num == 0) {\n            product_of_signs = 0;\n            break; // No need to continue as the result will be zero.\n        } else if (num < 0) {\n            product_of_signs *= -1;\n        }\n    }\n\n    return sum_of_magnitudes * product_of_signs;\n}\n", "py_code": "from typing import List\n\ndef prod_signs(arr: List[int]) -> int:\n    if not arr:\n        return -32768\n    \n    sum_of_magnitudes = 0\n    product_of_signs = 1\n    \n    for num in arr:\n        sum_of_magnitudes += abs(num)\n        if num == 0:\n            product_of_signs = 0\n            break\n        elif num < 0:\n            product_of_signs *= -1\n            \n    return sum_of_magnitudes * product_of_signs\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `prod_signs` takes a list of integers (`arr`) as input and returns an integer that represents the sum of magnitudes of the numbers in the list multiplied by the product of their signs (1 for positive, -1 for negative, 0 for zero). If the input list is empty, it returns `-32768`.\n\nThe function first checks if `arr` is empty and returns `-32768` immediately if so. It then initializes two variables: `sum_of_magnitudes`, which accumulates the sum of absolute values (magnitudes) of the numbers in the list, and `product_of_signs`, which keeps track of the product of signs.\n\nThe function iterates through each number in the list:\n- If a number is zero (`num == 0`), it sets `product_of_signs` to `0` since any multiplication by zero will result in zero.\n- For negative numbers, it multiplies `product_of_signs` by `-1`.\n- Positive numbers do not change the value of `product_of_signs`.\n\nFinally, the function returns the product of `sum_of_magnitudes` and `product_of_signs`. This approach ensures that if any number is zero, the result will be zero regardless of other values. If there are an odd number of negative numbers, the sign of the final result will be negative; otherwise, it will be positive.\n\n"}
{"task_id": "CPP/127", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <cmath>\n\nusing namespace std;\n\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i <= sqrt(n); ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\nstring intersection(vector<int> interval1, vector<int> interval2) {\n    int start_max = max(interval1[0], interval2[0]);\n    int end_min = min(interval1[1], interval2[1]);\n\n    // Check for no intersection\n    if (start_max > end_min) return \"NO\";\n\n    int length_of_intersection = end_min - start_max + 1;\n\n    if (is_prime(length_of_intersection)) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n", "py_code": "def is_prime(n):\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef intersection(interval1, interval2):\n    start_max = max(interval1[0], interval2[0])\n    end_min = min(interval1[1], interval2[1])\n\n    # Check for no intersection\n    if start_max > end_min:\n        return \"NO\"\n\n    length_of_intersection = end_min - start_max + 1\n\n    if is_prime(length_of_intersection):\n        return \"YES\"\n    else:\n        return \"NO\"\n```\n\n", "py_summary": "### Second Step: Analyse the Python Code\n\nThe provided Python function `intersection` takes two intervals as input and determines whether the length of their intersection is a prime number.\n\n1. **Prime Check Function**: The helper function `is_prime(n)` checks if a given integer `n` is a prime number by iterating from 2 to the square root of `n`. If any divisor is found, it returns `False`; otherwise, it returns `True`.\n\n2. **Intersection Calculation**:\n   - The start and end points of the intersection are calculated using `start_max = max(interval1[0], interval2[0])` and `end_min = min(interval1[1], interval2[1])`.\n   - If there is no overlap (i.e., `start_max > end_min`), the function returns \"NO\".\n   \n3. **Length of Intersection**:\n   - The length of the intersection is calculated as `length_of_intersection = end_min - start_max + 1`. \n   - This value is then checked using the `is_prime` function to determine if it's a prime number.\n   - If the length is prime, \"YES\" is returned; otherwise, \"NO\" is returned.\n\n"}
{"task_id": "CPP/122", "generation": "#include <vector>\nusing namespace std;\n\nint add_elements(vector<int> arr, int k) {\n    int sum = 0;\n    for (int i = 0; i < k; ++i) {\n        if (-100 < arr[i] && arr[i] < 100) {\n            sum += arr[i];\n        }\n    }\n    return sum;\n}\n", "py_code": "def add_elements(arr, k):\n    return sum(x for x in arr[:k] if -100 < x < 100)\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `add_elements` takes a list of integers (`arr`) and an integer (`k`). It returns the sum of elements from the first `k` elements in `arr` that have at most two digits (i.e., their absolute value is less than 100). The function uses a generator expression within the `sum()` function to iterate over the first `k` elements of `arr`, filtering out those with more than two digits, and then sums up the remaining values.```\n\n"}
{"task_id": "CPP/59", "generation": "#include <iostream>\nusing namespace std;\n\nint largest_prime_factor(int n) {\n    int i = 2;\n    while (i * i <= n) {\n        if (n % i != 0) {\n            ++i; // Increment i if n is not divisible by i.\n        } else {\n            n /= i; // Divide n by i if it's a factor.\n        }\n    }\n    return n; // The remaining value of n will be the largest prime factor.\n}\n\n", "py_code": "def largest_prime_factor(n):\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `largest_prime_factor` is designed to find and return the largest prime factor of a given integer `n`, where it's assumed that `n > 1` and `n` itself is not a prime number.\n\nHere\u2019s how the function works:\n- The function starts by initializing `i` to 2, which is the smallest prime number.\n- It then enters a while loop that continues as long as `i * i <= n`. This condition ensures that we only need to check up to the square root of `n`, optimizing the search for factors.\n- Inside the loop, it checks if `n` is divisible by `i` using the modulus operator (`%`). If `n % i` is not zero (meaning `n` is not divisible by `i`), then `i` is incremented to check the next potential factor.\n- If `n` is divisible by `i`, it means that `i` is a prime factor of `n`. The function divides `n` by `i` (`n //= i`) and continues checking with the same value of `i`.\n- Once the loop exits, the remaining value of `n` will be its largest prime factor because all smaller factors have been divided out.\n\nThe function finally returns this value as the largest prime factor. This approach ensures that we efficiently find the largest prime factor by continuously reducing `n` and checking divisibility starting from the smallest primes.\n\n"}
{"task_id": "CPP/134", "generation": "#include <string>\nusing namespace std;\n\nbool check_if_last_char_is_a_letter(string txt) {\n    if (txt.empty() || (!txt.empty() && txt.back() == ' '))\n        return false;\n    \n    // Remove trailing spaces\n    while (!txt.empty() && isspace(txt.back())) {\n        txt.pop_back();\n    }\n    \n    if (txt.empty()) \n        return false;\n\n    char last_char = txt.back();\n\n    bool is_last_char_alpha = isalpha(last_char);\n    bool has_space_before_last_char_or_single_char = (txt.size() == 1 || txt[txt.size() - 2] == ' ');\n\n    return is_last_char_alpha && has_space_before_last_char_or_single_char;\n}\n", "py_code": "def check_if_last_char_is_a_letter(txt):\n    if not txt or (len(txt) > 0 and txt[-1] == ' '): \n        return False\n    stripped_txt = txt.rstrip()\n    last_char = stripped_txt[-1]\n    return last_char.isalpha() and (' ' in stripped_txt[-2:] or len(stripped_txt) == 1)\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `check_if_last_char_is_a_letter` checks if the last character of a given string is an alphabetical character and not part of a word. The function first handles edge cases where the input string is empty or ends with a space, returning False in these scenarios.\n\nNext, it strips any trailing spaces from the end of the string using `rstrip()`. It then checks the last character of this stripped string to see if it's an alphabetical character using `isalpha()`.\n\nThe function also ensures that the last character is not part of a word by checking whether there is a space before the last character or if the length of the stripped text is only one character. If both conditions are met, the function returns True; otherwise, it returns False.\n```\n\n"}
{"task_id": "CPP/42", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nvector<int> incr_list(vector<int> l) {\n    for (size_t i = 0; i < l.size(); ++i) {\n        l[i] += 1;\n    }\n    return l;\n}\n", "py_code": "def incr_vector(l):\n    return [x + 1 for x in l]\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `incr_vector` takes a list of integers as input and returns a new list where each element is incremented by 1. This is achieved using a list comprehension that iterates over each element in the input list `l`, adds 1 to it, and collects these values into a new list which is then returned.\n```"}
{"task_id": "CPP/11", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring string_xor(string a, string b) {\n    string result = \"\";\n    for (size_t i = 0; i < a.size(); ++i) {\n        // Perform XOR on each bit and append to the result.\n        char xor_result = ((a[i] - '0') ^ (b[i] - '0')) + '0';\n        result += xor_result;\n    }\n    return result;\n}\n", "py_code": "def string_xor(a: str, b: str) -> str:\n    # Perform XOR on each bit and join results into a single string.\n    return ''.join(str(int(x) ^ int(y)) for x, y in zip(a, b))\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `string_xor` takes two string inputs `a` and `b`, both consisting only of '1's and '0's. The function performs a bitwise XOR operation on corresponding characters from each string and returns the result as a new string.\n\nThe function uses a generator expression inside the `join()` method to iterate over pairs of characters from strings `a` and `b`. For each pair, it converts the characters into integers using `int()`, performs the XOR operation with `^`, and then converts the result back into a string. The resulting sequence of '1's and '0's is concatenated into a single output string representing the bitwise XOR of the two input strings.\n```\n\n"}
{"task_id": "CPP/40", "generation": "#include <vector>\nusing namespace std;\n\nbool triples_sum_to_zero(vector<int> l) {\n    int n = l.size();\n    for (int i = 0; i < n - 2; ++i) {\n        for (int j = i + 1; j < n - 1; ++j) {\n            for (int k = j + 1; k < n; ++k) {\n                if (l[i] + l[j] + l[k] == 0) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n", "py_code": "def triples_sum_to_zero(l):\n    n = len(l)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                if l[i] + l[j] + l[k] == 0:\n                    return True\n    return False\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `triples_sum_to_zero` takes a list of integers as input and checks whether there are three distinct elements in the list that sum to zero. The function uses nested loops to iterate through all possible combinations of three different numbers from the list.\n\n1. The outer loop iterates over each element, starting from the first one.\n2. The middle loop starts from the next element after the current element from the outer loop and goes up to the second last element in the list.\n3. The innermost loop starts from the next element after the current element from the middle loop and checks all remaining elements.\n\nFor each combination of three numbers, it calculates their sum and checks if it equals zero. If such a combination is found, the function returns `True`. If no such combination exists by the end of the loops, the function returns `False`.\n\nThis approach ensures that every possible triplet in the list is checked for the condition without repeating any elements within a single check.\n\n"}
{"task_id": "CPP/13", "generation": "#include<stdio.h>\nusing namespace std;\n\nint greatest_common_divisor(int a, int b) {\n    while (b != 0) {\n        int temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n", "py_code": "def greatest_common_divisor(a, b):\n    while b != 0:\n        a, b = b, a % b\n    return a\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `greatest_common_divisor` calculates and returns the greatest common divisor (GCD) of two integers `a` and `b`. The algorithm used is the Euclidean algorithm, which repeatedly replaces `a` with `b` and `b` with `a % b` until `b` becomes zero. At that point, `a` contains the GCD of the original values of `a` and `b`, which is then returned by the function.\n```\n\n"}
{"task_id": "CPP/130", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> tri(int n) {\n    if (n == 0)\n        return {1};\n    \n    vector<int> tribonacci(n + 1, 1);\n    tribonacci[1] = 3;\n    \n    for (int i = 2; i <= n; ++i) {\n        if (i % 2 == 0) \n            tribonacci[i] = 1 + i / 2;\n        else\n            // Calculate the value based on previous values.\n            tribonacci[i] = tribonacci[i - 1] + tribonacci[i - 2];\n    }\n    \n    return tribonacci;\n}\n", "py_code": "def tri(n):\n    if n == 0:\n        return [1]\n    elif n == 1:\n        return [1, 3]\n    \n    result = [1, 3]\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            result.append(1 + i // 2)\n        else:\n            next_value = result[-1] + result[-2] + tri(i + 1)[i + 1]\n            result.append(next_value)\n    return result\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `tri(n)` is intended to generate a list of the first n+1 numbers in the Tribonacci sequence as defined by specific rules for even and odd indices. However, there are some issues with the current implementation:\n\n- The base cases for `n == 0` and `n == 1` return lists `[1]` and `[1, 3]`, respectively.\n- For `i >= 2`, if `i` is even, it calculates `tri(i)` as `1 + i // 2`.\n- If `i` is odd, the function attempts to calculate `tri(i)` by recursively calling itself for `tri(i+1)`. This recursive call is problematic because it will lead to an infinite recursion and incorrect values.\n\nTo fix this, we need a proper implementation that avoids unnecessary recursive calls. We should precompute all required Tribonacci numbers up to `n + 1` in a single pass without making additional recursive calls for odd indices.\n```\n\n### Corrected Python Code:\n```python\ndef tri(n):\n    if n == 0:\n        return [1]\n    elif n == 1:\n        return [1, 3]\n\n    result = [1, 3]\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            result.append(1 + i // 2)\n        else:\n            next_value = result[-1] + result[-2] + (1 + (i + 1) // 2)\n            result.append(next_value)\n    return result\n```\n\n### Explanation of the Corrected Code:\n- The base cases for `n == 0` and `n == 1` remain unchanged.\n- For even indices, we calculate `tri(i)` as `1 + i // 2`.\n- For odd indices, instead of making a recursive call to `tri(i+1)`, we directly compute the value using the formula `result[-1] + result[-2] + (1 + (i + 1) // 2)`.\n\nThis approach ensures that each Tribonacci number is computed in constant time without unnecessary recursion.\n\n"}
{"task_id": "CPP/60", "generation": "#include <stdio.h>\nusing namespace std;\n\nint sum_to_n(int n) {\n    return n * (n + 1) / 2;\n}\n", "py_code": "def sum_to_n(n):\n    return n * (n + 1) // 2\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `sum_to_n` calculates the sum of all integers from 1 to `n`. It uses a well-known formula for the sum of an arithmetic series: \\( \\text{Sum} = \\frac{n(n + 1)}{2} \\). This formula allows the function to compute the result in constant time, O(1), without needing to iterate through each number. The function takes an integer `n` as input and returns the computed sum as an integer.\n```"}
{"task_id": "CPP/23", "generation": "#include <string>\nusing namespace std;\n\nint strlen(string str) {\n    return str.length();\n}\n", "py_code": "def strlen(str):\n    return len(str)\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `strlen` takes a string as input and returns its length using the built-in `len()` function. This function is straightforward and leverages Python's standard library to determine the number of characters in the given string.```\n\n"}
{"task_id": "CPP/46", "generation": "#include <iostream>\nusing namespace std;\n\nint fib4(int n) {\n    if (n < 0) {\n        return -1; // Indicate an error since negative input is not valid for this context.\n    }\n    \n    // Base cases\n    if (n == 0 || n == 1 || n == 3) {\n        return 0;\n    } else if (n == 2) {\n        return 2;\n    }\n\n    // Initialize the first four values of the sequence\n    int a = 0, b = 0, c = 2, d = 0;\n\n    for (int i = 4; i <= n; ++i) {\n        int next_val = a + b + c + d;\n        a = b;\n        b = c;\n        c = d;\n        d = next_val;\n    }\n\n    return d;\n}\n\n", "py_code": "def fib4(n):\n    if n < 0:\n        return None\n    # Base cases\n    if n == 0 or n == 1 or n == 3:\n        return 0\n    elif n == 2:\n        return 2\n    \n    # Initialize the first four values of the sequence\n    a, b, c, d = 0, 0, 2, 0\n\n    for i in range(4, n + 1):\n        next_val = a + b + c + d\n        a, b, c, d = b, c, d, next_val\n    \n    return d\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `fib4` computes the n-th element of a sequence similar to the Fibonacci sequence but with different base cases and a sum involving four previous terms instead of two. The function avoids recursion for efficiency.\n\n- If `n < 0`, it returns `None`.\n- For base cases (`n = 0, 1, 3`), it directly returns `0`. For `n = 2`, it returns `2`.\n\nThe function then initializes the first four values of the sequence: `a=0`, `b=0`, `c=2`, and `d=0`. It iterates from `4` to `n`, calculating each subsequent value as the sum of the previous four values (`a + b + c + d`). After computing a new value, it shifts the variables to represent the next set of four consecutive terms in the sequence.\n\nFinally, after completing the loop, the function returns `d`, which holds the n-th element of the Fib4 sequence.```\n\n"}
{"task_id": "CPP/51", "generation": "#include <stdio.h>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nstring remove_vowels(string text) {\n    string vowels = \"aeiouAEIOU\";\n    string result = \"\";\n    for (char c : text) {\n        if (vowels.find(c) == string::npos) {\n            result += c;\n        }\n    }\n    return result;\n}\n", "py_code": "def remove_vowels(text):\n    vowels = \"aeiouAEIOU\"\n    return ''.join([char for char in text if char not in vowels])\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `remove_vowels` takes a string as input and returns a new string with all vowels removed. The function defines a string of vowels (both lowercase and uppercase) and uses a list comprehension to iterate over each character in the input text. If the character is not found within the defined vowels, it is included in the resulting list. Finally, the `join` method concatenates the characters from the filtered list into a new string without any vowels.\n```\n\n"}
{"task_id": "CPP/18", "generation": "#include <string>\nusing namespace std;\n\nint how_many_times(string str, string substring) {\n    int count = 0;\n    size_t sub_len = substring.length();\n    \n    for (size_t i = 0; i <= str.length() - sub_len; ++i) {\n        if (str.substr(i, sub_len) == substring) {\n            count += 1;\n        }\n    }\n\n    return count;\n}\n", "py_code": "def how_many_times(str, substring):\n    count = 0\n    sub_len = len(substring)\n    for i in range(len(str) - sub_len + 1):\n        if str[i:i+sub_len] == substring:\n            count += 1\n    return count\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `how_many_times` is designed to find how many times a given substring can be found in an original string, including overlapping cases. The function takes two parameters: `str`, which represents the original string, and `substring`, which represents the substring we are searching for within the original string.\n\n1. **Initialization**: \n   - A variable `count` is initialized to 0 to keep track of how many times the substring appears in the original string.\n   - The length of the substring (`sub_len`) is calculated using `len(substring)`.\n\n2. **Iteration**:\n   - The function iterates over each possible starting index for a substring within the original string, from `0` up to and including `len(str) - sub_len`. This ensures that we do not go out of bounds when checking substrings.\n   \n3. **Comparison**:\n   - For each iteration, it checks if the slice of the original string from the current index (`i`) to `i + sub_len` matches the given substring.\n   - If a match is found, the `count` variable is incremented by 1.\n\n4. **Return Value**:\n   - After completing the loop, the function returns the total count of occurrences of the substring in the original string.\n\nThis approach ensures that all possible overlapping cases are counted as well since it checks every position where the substring could start within the original string.\n```\n\n<|im_start|>\n<|im_start|>user\n"}
{"task_id": "CPP/143", "generation": "#include <iostream>\n#include <vector>\n#include <sstream>\n#include <cmath>\nusing namespace std;\n\nbool is_prime(int n) {\n    if (n <= 1)\n        return false;\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0)\n            return false;\n    }\n    return true;\n}\n\nstring words_in_sentence(string sentence) {\n    stringstream ss(sentence);\n    string word, result;\n    while (ss >> word) {\n        if (is_prime(word.length())) {\n            if (!result.empty()) {\n                result += \" \";\n            }\n            result += word;\n        }\n    }\n    return result;\n}\n", "py_code": "def is_prime(n):\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef words_in_sentence(sentence):\n    words = sentence.split()\n    prime_length_words = [word for word in words if is_prime(len(word))]\n    return ' '.join(prime_length_words)\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python solution consists of two functions: `is_prime` and `words_in_sentence`. The `is_prime` function checks if a given number is prime by iterating from 2 to the square root of the number and checking for any divisors. If no divisor is found, it returns True indicating that the number is prime.\n\nThe `words_in_sentence` function takes a sentence as input, splits it into words using the split() method, and then filters out those words whose lengths are prime numbers by utilizing the `is_prime` function within a list comprehension. The filtered words are then joined back together with spaces in between to form the final string that is returned.\n\nThis approach ensures that only words of prime length from the original sentence are included in the output while maintaining their order.```\n\n"}
{"task_id": "CPP/108", "generation": "#include <vector>\n#include <cmath>\n#include <algorithm>\n\nusing namespace std;\n\nint sum_of_digits(int num) {\n    int sum = 0;\n    bool is_negative = num < 0;\n    while (num != 0) {\n        int digit = num % 10;\n        if (!(is_negative && digit == 0)) { // Avoid counting '-' as a digit\n            sum += digit;\n        }\n        num /= 10;\n    }\n    return is_negative ? -sum : sum; \n}\n\nint count_nums(vector<int> n) {\n    int count = 0;\n    for (int num : n) {\n        if (sum_of_digits(num) > 0) {\n            ++count;\n        }\n    }\n    return count;\n}\n", "py_code": "def count_nums(n):\n    def sum_of_digits(num):\n        return sum(int(digit) if digit != '-' else 0 for digit in str(num))\n    \n    return sum(1 for num in n if sum_of_digits(num) > 0)\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `count_nums` takes a list of integers and returns the count of numbers whose sum of digits is greater than zero. The function defines an inner helper function `sum_of_digits`, which calculates the sum of digits for each number in the input list. This helper function converts the number to a string, iterates over its characters (digits), and sums them up while treating '-' as 0.\n\nThe main function then uses a generator expression within the built-in `sum` function to iterate through the input list `n`. For each element, it checks if the sum of digits is greater than zero using the helper function. If true, it contributes 1 to the total count; otherwise, it does not contribute anything.\n\nFinally, the main function returns the total count of numbers that satisfy the condition.\n```\n\n"}
{"task_id": "CPP/43", "generation": "#include <vector>\n#include <unordered_set>\nusing namespace std;\n\nbool pairs_sum_to_zero(vector<int> l) {\n    unordered_set<int> seen;\n    for (int num : l) {\n        if (seen.find(-num) != seen.end()) {\n            return true;\n        }\n        seen.insert(num);\n    }\n    return false;\n}\n", "py_code": "def pairs_sum_to_zero(l):\n    seen = set()\n    for num in l:\n        if -num in seen:\n            return True\n        seen.add(num)\n    return False\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `pairs_sum_to_zero` checks whether there are two distinct elements in a list that sum to zero. The function uses a set named `seen` to keep track of the numbers encountered so far.\n\nFor each number `num` in the input list `l`, it checks if `-num` is already present in the `seen` set. If `-num` exists, this means there are two distinct elements that sum to zero (i.e., `num` and `-num`). In such a case, the function returns `True`.\n\nIf `-num` does not exist in the set, it adds `num` to the set and continues checking the next number. If no pair is found by the end of the list, the function returns `False`. This approach ensures that each element is checked only once against all previously seen elements, making the solution efficient.\n\n"}
{"task_id": "CPP/70", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> strange_sort_list(vector<int> lst) {\n    sort(lst.begin(), lst.end()); // Sort the list in ascending order\n    vector<int> result;           // Initialize an empty result vector\n\n    while (!lst.empty()) {\n        // Append minimum value (first element)\n        if (!lst.empty()) {\n            result.push_back(lst.front());\n            lst.erase(lst.begin());\n        }\n        // Append maximum value (last element)\n        if (!lst.empty()) {\n            result.push_back(lst.back());\n            lst.pop_back();\n        }\n    }\n\n    return result;\n}\n", "py_code": "def strange_sort_list(lst):\n    sorted_lst = sorted(lst)\n    result = []\n    while sorted_lst:\n        # Append minimum value\n        if sorted_lst:\n            result.append(sorted_lst.pop(0))\n        # Append maximum value\n        if sorted_lst:\n            result.append(sorted_lst.pop(-1))\n    return result\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `strange_sort_list` takes a list of integers as input and returns a new list sorted in a \"strange\" order. The strange sorting order alternates between selecting the minimum value from the remaining elements and then the maximum value from the remaining elements until all elements are used.\n\n1. **Sorting**: The function first sorts the input list `lst` in ascending order to easily access the minimum and maximum values.\n2. **Initialization**: An empty list `result` is initialized to store the final sorted sequence.\n3. **Looping through the list**: A while loop runs as long as there are elements left in the `sorted_lst`.\n4. **Appending Minimum Value**: Inside the loop, if `sorted_lst` still has elements, it appends the minimum value (the first element) of `sorted_lst` to `result`, and removes this element from `sorted_lst`.\n5. **Appending Maximum Value**: If there are still elements left in `sorted_lst`, it then appends the maximum value (the last element) of `sorted_lst` to `result`, and also removes this element from `sorted_lst`.\n6. **Return Result**: Finally, the function returns the `result` list which contains the integers sorted in strange order.\n\nThis approach ensures that the smallest and largest values are alternated until all elements have been processed.\n"}
{"task_id": "CPP/63", "generation": "#include <iostream>\n\nint fibfib(int n) {\n    if (n == 0 || n == 1) return 0;\n    else if (n == 2) return 1;\n\n    int a = 0, b = 0, c = 1, d;\n\n    for (int i = 3; i <= n; ++i) {\n        d = a + b + c;\n        a = b;\n        b = c;\n        c = d;\n    }\n\n    return c;\n}\n", "py_code": "def fibfib(n):\n    if n == 0 or n == 1:\n        return 0\n    elif n == 2:\n        return 1\n    \n    # Initialize base cases\n    a, b, c = 0, 0, 1\n\n    for i in range(3, n + 1):\n        a, b, c = b, c, a + b + c\n        \n    return c\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `fibfib(n)` calculates the n-th element of the FibFib number sequence efficiently using an iterative approach rather than a recursive one to avoid redundant calculations and improve performance.\n\n1. The function first checks for base cases: if `n` is 0 or 1, it returns 0; if `n` is 2, it returns 1.\n   \n2. For values of `n` greater than 2, the function initializes three variables (`a`, `b`, and `c`) to represent the first three elements of the sequence (fibfib(0), fibfib(1), and fibfib(2)).\n\n3. The function then iterates from 3 up to `n`. In each iteration, it updates the values of `a`, `b`, and `c` such that:\n   - `a` takes the value of `b`\n   - `b` takes the value of `c`\n   - `c` is updated as the sum of the previous three elements (`a + b + c`).\n\n4. After completing the loop, the function returns the value of `c`, which represents fibfib(n).\n```\n\n"}
{"task_id": "CPP/89", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring encrypt(string s) {\n    string encrypted_str = \"\";\n    for (char& c : s) {\n        if ('a' <= c && c <= 'z') {\n            char new_char = ((c - 'a' + 4) % 26) + 'a';\n            encrypted_str += new_char;\n        } else {\n            encrypted_str += c;\n        }\n    }\n    return encrypted_str;\n}\n", "py_code": "def encrypt(s):\n    encrypted_str = \"\"\n    for char in s:\n        if 'a' <= char <= 'z':\n            new_char = chr(((ord(char) - ord('a') + 4) % 26) + ord('a'))\n            encrypted_str += new_char\n        else:\n            encrypted_str += char\n    return encrypted_str\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `encrypt` takes a string `s` as input and returns an encrypted version of it by rotating each letter in the string down by 4 places (since two multiplied by two is four). The rotation wraps around the alphabet if necessary. \n\nHere's how the function works:\n1. It initializes an empty string `encrypted_str` to store the result.\n2. For each character `char` in the input string `s`, it checks whether the character is a lowercase letter (between 'a' and 'z').\n3. If the character is a lowercase letter, it calculates its new position by:\n   - Converting the character to its ASCII value using `ord(char)`.\n   - Subtracting the ASCII value of 'a' from this value.\n   - Adding 4 to shift down by four places.\n   - Taking modulo 26 to wrap around the alphabet if necessary.\n   - Adding back the ASCII value of 'a'.\n   - Converting the resulting ASCII value back to a character using `chr()`.\n4. If the character is not a lowercase letter, it leaves it unchanged and appends it directly to `encrypted_str`.\n5. Finally, it returns the encrypted string.\n\nThis function ensures that only lowercase letters are rotated while other characters remain as they are in the input string.\n"}
{"task_id": "CPP/26", "generation": "#include <stdio.h>\n#include <vector>\n#include <unordered_set>\nusing namespace std;\n\nvector<int> remove_duplicates(vector<int> numbers) {\n    unordered_set<int> seen;\n    vector<int> result;\n    \n    for (int number : numbers) {\n        if (seen.find(number) == seen.end()) {\n            result.push_back(number);\n            seen.insert(number);\n        }\n    }\n\n    return result;\n}\n", "py_code": "def remove_duplicates(numbers):\n    seen = set()\n    result = []\n    for number in numbers:\n        if number not in seen:\n            result.append(number)\n            seen.add(number)\n    return result\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `remove_duplicates` takes a list of integers as input and returns a new list with all duplicates removed while preserving the original order of elements that remain. The function uses a set named `seen` to keep track of numbers that have already been encountered in the iteration over the input list.\n\nFor each number in the input list:\n- If the number is not present in the `seen` set, it gets added to the result list and also marked as seen by adding it to the `seen` set.\n- If the number has already been seen (i.e., it's a duplicate), it is skipped.\n\nThis approach ensures that only unique elements are included in the final output list while maintaining their original order from the input. The use of a set for tracking duplicates provides an efficient O(1) average time complexity for checking membership, making the overall function run efficiently with a time complexity of O(n).\n\n"}
{"task_id": "CPP/104", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nbool has_no_even_digit(int n) {\n    while (n > 0) {\n        int digit = n % 10;\n        if (digit % 2 == 0) return false;\n        n /= 10;\n    }\n    return true;\n}\n\nvector<int> unique_digits(vector<int> x) {\n    vector<int> result;\n    for (int num : x) {\n        if (has_no_even_digit(num)) {\n            result.push_back(num);\n        }\n    }\n    sort(result.begin(), result.end());\n    return result;\n}\n", "py_code": "def unique_digits(x):\n    def has_no_even_digit(n):\n        return all(int(digit) % 2 != 0 for digit in str(n))\n    \n    result = [num for num in x if has_no_even_digit(num)]\n    return sorted(result)\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `unique_digits` takes a list of positive integers as input and returns a new list containing only those numbers that do not have any even digits. The returned list is sorted in increasing order.\n\n1. A helper function `has_no_even_digit(n)` is defined to check if all digits of the number `n` are odd.\n2. Using a list comprehension, it filters out the numbers from the input list `x` for which `has_no_even_digit(num)` returns True.\n3. The filtered list is then sorted in increasing order using the `sorted()` function and returned as the result.\n\nThis approach ensures that only integers without any even digits are included in the final output, and they are presented in a sorted manner.```\n\n\n"}
{"task_id": "CPP/90", "generation": "#include <vector>\n#include <algorithm>\n#include <set>\nusing namespace std;\n\n// Function to find the second smallest element in a vector.\nint next_smallest(vector<int> lst) {\n    set<int> unique_elements(lst.begin(), lst.end()); // Convert list to set to remove duplicates and sort elements.\n\n    if (unique_elements.size() < 2) { // Check if there are less than two unique elements.\n        return -1; // Return -1 as a representation of None in C++ for this context.\n    }\n\n    auto it = unique_elements.begin();\n    advance(it, 1); // Advance the iterator to point to the second element.\n\n    return *it; // Dereference the iterator and return the value.\n}\n", "py_code": "def next_smallest(lst):\n    unique_elements = list(set(lst))\n    if len(unique_elements) < 2:\n        return None\n    unique_elements.sort()\n    return unique_elements[1]\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `next_smallest` is designed to find and return the second smallest element in a list of integers (`lst`). The function first converts the input list into a set to remove any duplicate elements, then it checks if there are fewer than two unique elements. If so, it returns `None`, indicating that there isn't enough data to determine a second smallest value.\n\nIf there are at least two unique elements, the function sorts these unique elements in ascending order and returns the element at index 1 (the second smallest). This approach ensures that we correctly identify the second smallest distinct number in the list. If the input list is empty or contains only one unique element, the function appropriately returns `None`.\n\n"}
{"task_id": "CPP/126", "generation": "#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nbool is_sorted(vector<int> lst) {\n    if (lst.size() <= 1) return true;\n\n    int prev = lst[0];\n    int count = 1;\n    \n    for (size_t i = 1; i < lst.size(); ++i) {\n        if (lst[i] < prev) return false;\n        else if (lst[i] == prev) {\n            count++;\n            if (count > 2) return false;\n        } else {\n            prev = lst[i];\n            count = 1;\n        }\n    }\n\n    return true;\n}\n", "py_code": "def is_sorted(lst):\n    if len(lst) <= 1:\n        return True\n\n    prev = lst[0]\n    count = 1\n    for i in range(1, len(lst)):\n        if lst[i] < prev:\n            return False\n        elif lst[i] == prev:\n            count += 1\n            if count > 2:\n                return False\n        else:\n            prev = lst[i]\n            count = 1\n\n    return True\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `is_sorted` checks whether a given list of integers is sorted in ascending order and ensures that no number appears more than twice. The function starts by checking if the length of the list is less than or equal to 1, returning `True` immediately since such lists are trivially sorted.\n\nIt then initializes two variables: `prev`, which holds the previous element for comparison, and `count`, which tracks how many times a number has appeared consecutively. The function iterates through the list starting from the second element:\n\n- If an element is less than its predecessor (`lst[i] < prev`), it means the list is not sorted in ascending order, so the function returns `False`.\n- If an element equals its predecessor (`lst[i] == prev`), the count of consecutive appearances increases. If this count exceeds 2, the function returns `False`, indicating that a number appears more than twice.\n- Otherwise, if the current element is greater than the previous one, it updates `prev` to the current element and resets the count.\n\nIf the loop completes without returning `False`, the list meets both conditions (sorted in ascending order with no number appearing more than twice), so the function returns `True`.\n\n"}
{"task_id": "CPP/68", "generation": "#include <stdio.h>\n#include <vector>\n#include <limits>\nusing namespace std;\n\nvector<int> pluck(vector<int> arr) {\n    int smallest_even_value = numeric_limits<int>::max();\n    int smallest_index = -1;\n    \n    for (int i = 0; i < arr.size(); ++i) {\n        if (arr[i] % 2 == 0 && arr[i] <= smallest_even_value) {\n            if (arr[i] < smallest_even_value || (arr[i] == smallest_even_value && i < smallest_index)) {\n                smallest_even_value = arr[i];\n                smallest_index = i;\n            }\n        }\n    }\n\n    if (smallest_index != -1) {\n        return {smallest_even_value, smallest_index};\n    } else {\n        return {};\n    }\n}\n", "py_code": "def pluck(arr):\n    smallest_even_value = float('inf')\n    smallest_index = -1\n\n    for index, value in enumerate(arr):\n        if value % 2 == 0 and value < smallest_even_value:\n            smallest_even_value = value\n            smallest_index = index\n    \n    if smallest_index != -1:\n        return [smallest_even_value, smallest_index]\n    else:\n        return []\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `pluck` takes a list of integers (`arr`) as input and returns a list containing the smallest even value in the array along with its index. If there are no even values or if the given list is empty, it returns an empty list.\n\n1. The function initializes two variables: `smallest_even_value` to positive infinity and `smallest_index` to -1.\n2. It then iterates over each element of the input array using a for loop with `enumerate`, which provides both the index and value of each element.\n3. For each element, it checks if the value is even (`value % 2 == 0`) and smaller than the current smallest even value found so far.\n4. If these conditions are met, it updates `smallest_even_value` to the new smallest even value and sets `smallest_index` to the index of this value.\n5. After iterating through all elements, if a valid smallest even value was found (i.e., `smallest_index` is not -1), it returns a list containing `[smallest_even_value, smallest_index]`.\n6. If no even values were found (`smallest_index` remains -1), the function returns an empty list.\n\nThis approach ensures that we find the smallest even value and its index efficiently in one pass through the array.\n\n"}
{"task_id": "CPP/58", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\n#include <set>\nusing namespace std;\n\nvector<int> common(vector<int> l1, vector<int> l2) {\n    // Convert vectors to sets for unique elements\n    set<int> s1(l1.begin(), l1.end());\n    set<int> s2(l2.begin(), l2.end());\n\n    // Find intersection of both sets\n    vector<int> result;\n    set_intersection(s1.begin(), s1.end(), s2.begin(), s2.end(), back_inserter(result));\n\n    return result;\n}\n", "py_code": "def common(l1, l2):\n    # Convert both lists to sets and find intersection\n    result = set(l1).intersection(set(l2))\n    # Return sorted list of unique elements\n    return sorted(result)\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `common` takes two lists (`l1` and `l2`) as input and returns a list of their common elements in sorted order. The function first converts both lists into sets to eliminate any duplicate values within each list and then finds the intersection between these sets using the `.intersection()` method, which gives us all unique elements that are present in both lists. Finally, it sorts the resulting set of common elements and returns this as a list.\n```\n\n"}
{"task_id": "CPP/112", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nbool is_palindrome(const string& str) {\n    int len = str.length();\n    for (int i = 0; i < len / 2; ++i) {\n        if (str[i] != str[len - i - 1]) return false;\n    }\n    return true;\n}\n\nvector<string> reverse_delete(string s, string c){\n    string result_string;\n    \n    // Remove characters from `s` that are present in `c`\n    for (char ch : s) {\n        if (c.find(ch) == string::npos) {\n            result_string += ch;\n        }\n    }\n\n    // Check if the resulting string is a palindrome\n    bool is_palindrome_result = is_palindrome(result_string);\n\n    vector<string> output(2);\n    output[0] = result_string;\n    output[1] = (is_palindrome_result ? \"True\" : \"False\");\n\n    return output;\n}\n", "py_code": "def reverse_delete(s: str, c: str) -> list:\n    # Remove characters from `s` that are present in `c`\n    result_string = ''.join([char for char in s if char not in c])\n    \n    # Check if the resulting string is a palindrome\n    is_palindrome = result_string == result_string[::-1]\n    \n    return [result_string, str(is_palindrome).lower()]\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `reverse_delete` takes two string arguments: `s` and `c`. The goal is to remove all characters from `s` that are present in `c`, then check if the resulting string is a palindrome.\n\n1. The list comprehension `[char for char in s if char not in c]` iterates over each character in `s` and includes it in the new list only if it does not appear in `c`. This effectively removes all characters from `s` that are present in `c`.\n2. `''.join(...)` converts the filtered list of characters back into a string, which is stored in `result_string`.\n3. The function checks whether `result_string` reads the same forward and backward by comparing it to its reverse (`result_string[::-1]`). This determines if the resulting string is a palindrome.\n4. Finally, the function returns a list containing the `result_string` and a lowercase `\"true\"` or `\"false\"`, depending on whether the result string is a palindrome.\n\nThis approach ensures that all characters in `s` that are present in `c` are removed before checking for palindromicity.```\n\n"}
{"task_id": "CPP/96", "generation": "#include <stdio.h>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    for (int i = 2; i <= sqrt(num); ++i) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\nvector<int> count_up_to(int n) {\n    vector<int> primes;\n    for (int i = 2; i < n; ++i) {\n        if (is_prime(i)) {\n            primes.push_back(i);\n        }\n    }\n    return primes;\n}\n", "py_code": "def is_prime(num):\n    if num <= 1:\n        return False\n    for i in range(2, int(num**0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef count_up_to(n):\n    primes = []\n    for i in range(2, n):\n        if is_prime(i):\n            primes.append(i)\n    return primes\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python solution consists of two functions: `is_prime` and `count_up_to`. The `is_prime` function checks if a given number is prime by iterating from 2 to the square root of the number and checking for divisibility. If any divisor is found, it returns False; otherwise, it returns True.\n\nThe `count_up_to` function generates a list of prime numbers less than a specified integer n. It iterates through all integers from 2 up to (but not including) n, using the `is_prime` function to check if each number is prime. If a number is determined to be prime, it is added to the primes list. Finally, the function returns this list of prime numbers.\n``` \n\n"}
{"task_id": "CPP/157", "generation": "#include <algorithm> // for std::sort\n#include <array>     // for std::array\n\nbool right_angle_triangle(float a, float b, float c) {\n    // Store the sides in an array and sort it to ensure that 'c' is the longest side.\n    std::array<float, 3> sides = {a, b, c};\n    std::sort(sides.begin(), sides.end());\n    \n    // Assign sorted values back to a, b, c\n    a = sides[0];\n    b = sides[1];\n    c = sides[2];\n\n    // Check if the triangle satisfies Pythagoras' theorem: a^2 + b^2 == c^2\n    return (a * a) + (b * b) == (c * c);\n}\n", "py_code": "def right_angle_triangle(a, b, c):\n    # Sort the sides so that c is the longest side (hypotenuse)\n    sides = sorted([a, b, c])\n    a, b, c = sides\n    \n    # Check if the triangle satisfies Pythagoras' theorem: a^2 + b^2 == c^2\n    return a**2 + b**2 == c**2\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `right_angle_triangle` takes three side lengths of a triangle as input and determines whether these sides form a right-angled triangle. The function first sorts the given side lengths to ensure that the longest side (hypotenuse) is assigned to variable `c`. It then checks if the square of the hypotenuse (`c^2`) equals the sum of squares of the other two sides (`a^2 + b^2`). This check is based on Pythagoras' theorem, which states that in a right-angled triangle, the square of the length of the hypotenuse (the side opposite the right angle) is equal to the sum of the squares of the lengths of the other two sides. If this condition holds true, the function returns `True`, indicating that the given sides form a right-angled triangle; otherwise, it returns `False`.```"}
{"task_id": "CPP/99", "generation": "#include <cmath>\n#include <string>\nusing namespace std;\n\nint closest_integer(string value) {\n    float num = stof(value);\n    if (fabs(num - round(num)) == 0.5f) {\n        return num > 0 ? ceil(num) : floor(num);\n    } else {\n        return round(num);\n    }\n}\n", "py_code": "def closest_integer(value: str) -> int:\n    num = float(value)\n    if num - int(num) == 0.5 or num - int(num) == -0.5:\n        return int(num + (1 if num > 0 else -1))\n    else:\n        return round(num)\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `closest_integer` takes a string input representing a number and returns the closest integer to it. If the number is equidistant from two integers (i.e., ends in `.5` or `-.5`), it rounds away from zero.\n\n1. The function first converts the string value into a floating-point number.\n2. It then checks if the fractional part of the number is exactly 0.5 or -0.5 using the condition `(num - int(num) == 0.5)` or `(num - int(num) == -0.5)`.\n3. If this condition is true, it rounds away from zero by adding `1` if the number is positive and subtracting `1` if the number is negative.\n4. Otherwise, it uses Python's built-in `round()` function to round the number to the nearest integer.\n\nThis approach ensures that numbers equidistant between two integers are rounded in a way that moves them farther from zero as required by the problem statement.\n\n"}
{"task_id": "CPP/149", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nvector<string> sorted_list_sum(vector<string> lst) {\n    vector<string> filtered_lst;\n\n    // Filter out strings with odd lengths\n    for (const auto& s : lst) {\n        if (s.length() % 2 == 0) {\n            filtered_lst.push_back(s);\n        }\n    }\n\n    // Sort by length, and then alphabetically if lengths are the same\n    sort(filtered_lst.begin(), filtered_lst.end(),\n         [](const string &a, const string &b) {\n             return a.size() != b.size() ? a.size() < b.size() : a < b;\n         });\n\n    return filtered_lst;\n}\n", "py_code": "from typing import List\n\ndef vector_sort(lst: List[str]) -> List[str]:\n    # Filter out strings with odd lengths\n    filtered_lst = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort by length, and then alphabetically if lengths are the same\n    sorted_lst = sorted(filtered_lst, key=lambda x: (len(x), x))\n    \n    return sorted_lst\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `vector_sort` takes a list of strings as input and returns a new list with certain modifications. First, it filters out all strings that have odd lengths using a list comprehension. Then, it sorts the remaining strings based on two criteria: first by their length in ascending order, and if there are strings of equal length, then alphabetically. The function finally returns this sorted list.\n\nThe filtering step ensures only even-lengthed strings remain, while the sorting step organizes these strings according to the specified rules. This approach guarantees that the returned vector is both filtered and sorted as required by the problem statement.```\n\n"}
{"task_id": "CPP/86", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nstring anti_shuffle(string s) {\n    string result = \"\";\n    string word = \"\";\n\n    for (char c : s) {\n        if (c == ' ') {\n            // Sort the current word and append to result\n            sort(word.begin(), word.end());\n            result += word + \" \";\n            word = \"\";  // Reset word for next iteration\n        } else {\n            word += c;\n        }\n    }\n\n    // Handle the last word in the string\n    if (!word.empty()) {\n        sort(word.begin(), word.end());\n        result += word;\n    }\n\n    return result;\n}\n", "py_code": "def anti_shuffle(s):\n    words = s.split(\" \")\n    ordered_words = []\n    for word in words:\n        sorted_word = \"\".join(sorted(word))\n        ordered_words.append(sorted_word)\n    return \" \".join(ordered_words)\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `anti_shuffle` takes a string `s` as input and returns an ordered version of it where each word's characters are sorted in ascending order based on their ASCII values while maintaining the original order of words and blank spaces.\n\n1. The function first splits the input string into a list of words using the `split(\" \")` method, which separates the string at every space.\n2. It then initializes an empty list called `ordered_words`.\n3. For each word in the list of words:\n   - The characters within the word are sorted in ascending order based on their ASCII values using the `sorted()` function and joined back into a string with `\"\".join()`.\n   - This newly ordered word is appended to the `ordered_words` list.\n4. Finally, the function joins all the ordered words back together into a single string with spaces between them using `\" \".join(ordered_words)` and returns this new string.\n\nThis approach ensures that each word in the input string has its characters sorted while preserving the original order of words and blank spaces within the sentence.\n\n"}
{"task_id": "CPP/129", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> minPath(vector<vector<int>> grid, int k) {\n    int N = grid.size();\n    \n    vector<int> dfs(int x, int y, vector<int>& path) {\n        if (path.size() == k)\n            return path;\n        \n        vector<int> best_path;\n        \n        for (auto [dx, dy] : vector<pair<int,int>>{{-1, 0}, {1, 0}, {0, -1}, {0, 1}}) {\n            int nx = x + dx, ny = y + dy;\n            if (nx >= 0 && nx < N && ny >= 0 && ny < N) {\n                path.push_back(grid[nx][ny]);\n                vector<int> new_path = dfs(nx, ny, path);\n                if (best_path.empty() || (!new_path.empty() && new_path < best_path))\n                    best_path = new_path;\n                path.pop_back();\n            }\n        }\n        \n        return best_path;\n    }\n\n    vector<int> min_path;\n    \n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            vector<int> current_path{grid[i][j]};\n            vector<int> new_min_path = dfs(i, j, current_path);\n            if (min_path.empty() || (!new_min_path.empty() && new_min_path < min_path))\n                min_path = new_min_path;\n        }\n    }\n\n    return min_path;\n}\n", "py_code": "from typing import List\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    N = len(grid)\n    \n    # Function to get all valid neighbors of a cell\n    def get_neighbors(x, y):\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < N and 0 <= ny < N:\n                yield nx, ny\n    \n    # Initialize the minimum path with a large value\n    min_path = [float('inf')] * k\n\n    def dfs(x: int, y: int, path: List[int]):\n        nonlocal min_path\n        if len(path) == k:\n            if path < min_path:\n                min_path[:] = path[:]\n            return\n        \n        for nx, ny in get_neighbors(x, y):\n            dfs(nx, ny, path + [grid[nx][ny]])\n    \n    # Start DFS from every cell\n    for i in range(N):\n        for j in range(N):\n            dfs(i, j, [grid[i][j]])\n\n    return min_path\n```\n\n", "py_summary": "### Analysis of the Python Code:\n\nThe provided Python function `minPath` aims to find the lexicographically smallest path of length `k` in a given grid. The solution uses Depth-First Search (DFS) to explore all possible paths starting from each cell and keeps track of the minimum path found.\n\n1. **Grid Size Initialization**: The size of the grid, `N`, is determined by taking the length of the grid.\n2. **Neighbor Function**: A helper function `get_neighbors` generates valid neighboring cells for a given cell `(x, y)`. It checks all four possible directions (up, down, left, right).\n3. **DFS Initialization**: The minimum path is initialized with an array filled with infinity (`float('inf')`) to ensure any valid path will be smaller.\n4. **DFS Function**: A recursive function `dfs` explores paths starting from a given cell `(x, y)` and builds the current path by appending values of neighboring cells. If the length of the current path equals `k`, it compares this path with the minimum path found so far (`min_path`). If the current path is lexicographically smaller than `min_path`, it updates `min_path`.\n5. **Starting DFS from Every Cell**: The function starts a DFS from every cell in the grid to ensure all possible paths are explored.\n6. **Return Minimum Path**: Finally, after exploring all possible paths, the minimum path found (`min_path`) is returned.\n\nThis approach ensures that we find the lexicographically smallest path of length `k` by exhaustively checking all possibilities and keeping track of the best result so far.\n\n"}
{"task_id": "CPP/49", "generation": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint modp(int n, int p) {\n    long long result = 1;\n    long long base = 2;\n\n    while (n > 0) {\n        if (n % 2 == 1) {\n            result = (result * base) % p;\n        }\n        base = (base * base) % p;\n        n /= 2;\n    }\n\n    return static_cast<int>(result);\n}\n", "py_code": "def modp(n, p):\n    return pow(2, n, p)\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `modp` calculates 2 raised to the power of `n`, and then takes the result modulo `p`. The built-in `pow` function in Python is used for this purpose, which efficiently computes `(2**n) % p`. This approach ensures that the computation remains within numeric limits by performing the modulo operation during the exponentiation process.```\n\n"}
{"task_id": "CPP/156", "generation": "#include <vector>\n#include <string>\nusing namespace std;\n\nstring int_to_mini_roman(int number) {\n    vector<pair<int, string>> roman_map = {\n        {1000, \"m\"}, {900, \"cm\"}, {500, \"d\"}, {400, \"cd\"},\n        {100, \"c\"}, {90, \"xc\"}, {50, \"l\"}, {40, \"xl\"},\n        {10, \"x\"}, {9, \"ix\"}, {5, \"v\"}, {4, \"iv\"}, {1, \"i\"}\n    };\n    \n    string roman_numeral = \"\";\n    for (const auto& [value, numeral] : roman_map) {\n        while (number >= value) {\n            roman_numeral += numeral;\n            number -= value;\n        }\n    }\n    return roman_numeral;\n}\n", "py_code": "def int_to_mini_roman(number):\n    roman_map = [\n        (1000, 'm'), (900, 'cm'), (500, 'd'), (400, 'cd'),\n        (100, 'c'), (90, 'xc'), (50, 'l'), (40, 'xl'),\n        (10, 'x'), (9, 'ix'), (5, 'v'), (4, 'iv'), (1, 'i')\n    ]\n    roman_numeral = ''\n    for value, numeral in roman_map:\n        while number >= value:\n            roman_numeral += numeral\n            number -= value\n    return roman_numeral\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `int_to_mini_roman` converts an integer to its lowercase Roman numeral equivalent as a string. The function uses a list of tuples called `roman_map`, where each tuple contains an integer value and its corresponding lowercase Roman numeral representation.\n\nThe function initializes an empty string `roman_numeral`. It then iterates over the `roman_map` list, checking if the current number is greater than or equal to the integer value in the tuple. If it is, the function appends the corresponding Roman numeral to `roman_numeral`, and subtracts the integer value from the number.\n\nThis process continues until the entire number has been converted into its Roman numeral representation. The function then returns the resulting string.\n\n"}
{"task_id": "CPP/65", "generation": "#include <algorithm> // for std::reverse\n#include <string>\nusing namespace std;\n\nstring circular_shift(int x, int shift) {\n    string digits = to_string(x);\n    size_t num_digits = digits.size();\n    \n    if (shift >= num_digits) {\n        reverse(digits.begin(), digits.end());\n        return digits;\n    }\n    \n    size_t actual_shift = shift % num_digits;\n    \n    rotate(digits.rbegin(), digits.rbegin() + actual_shift, digits.rend());\n    \n    return digits;\n}\n", "py_code": "def circular_shift(x: int, shift: int) -> str:\n    digits = list(str(x))\n    num_digits = len(digits)\n    \n    if shift >= num_digits:\n        return ''.join(reversed(digits))\n    \n    actual_shift = shift % num_digits\n    \n    shifted_part1 = digits[-actual_shift:]\n    shifted_part2 = digits[:-actual_shift]\n    \n    result = shifted_part1 + shifted_part2\n    return ''.join(result)\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `circular_shift` takes an integer `x` and a shift value `shift`, and returns a string representing the digits of `x` circularly shifted to the right by `shift` positions. If `shift` is greater than or equal to the number of digits in `x`, it reverses the digits.\n\nThe function first converts the integer `x` into a list of its individual digit characters. It then checks if `shift` is greater than or equal to the length of this list (i.e., the number of digits). If so, it returns the reversed string representation of these digits.\n\nIf not, it calculates an effective shift value (`actual_shift`) by taking the modulus of `shift` with the number of digits. This ensures that if `shift` is larger than the number of digits but not large enough to reverse them, only a necessary circular shift occurs.\n\nThe function then splits the list into two parts: the last `actual_shift` elements and the remaining elements before these. It concatenates these two parts in reversed order (the latter part followed by the former) to achieve the circular shift effect. Finally, it joins this list back into a string and returns it.\n```\n\n"}
{"task_id": "CPP/9", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> rolling_max(vector<int> numbers) {\n    if (numbers.empty()) {\n        return {};\n    }\n\n    vector<int> result;\n    int max_so_far = numbers[0];\n    \n    for (int num : numbers) {\n        max_so_far = max(max_so_far, num);\n        result.push_back(max_so_far);\n    }\n    \n    return result;\n}\n", "py_code": "from typing import List\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    if not numbers:\n        return []\n    \n    max_so_far = numbers[0]\n    result = [max_so_far]\n\n    for num in numbers[1:]:\n        if num > max_so_far:\n            max_so_far = num\n        result.append(max_so_far)\n        \n    return result\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `rolling_max` takes a list of integers as input and returns a new list where each element at index `i` represents the maximum value encountered in the original list up to that point (inclusive). The function initializes `max_so_far` with the first element of the input list, and then iterates through the remaining elements. For each number, it updates `max_so_far` if the current number is greater than `max_so_far`. It appends `max_so_far` to the result list after each iteration.\n\nThe function handles an empty list by returning an empty list as well. This ensures that the function behaves correctly for edge cases where no elements are provided in the input list.\n\n"}
{"task_id": "CPP/158", "generation": "#include <vector>\n#include <string>\n#include <algorithm>\n#include <unordered_set>\nusing namespace std;\n\nstring find_max(vector<string> words) {\n    int max_unique = 0;\n    string result_word = \"\";\n    \n    for (const auto& word : words) {\n        unordered_set<char> unique_chars(word.begin(), word.end());\n        int num_unique_chars = unique_chars.size();\n        \n        if (num_unique_chars > max_unique || \n            (num_unique_chars == max_unique && word < result_word)) {\n            max_unique = num_unique_chars;\n            result_word = word;\n        }\n    }\n    \n    return result_word;\n}\n", "py_code": "def find_max(words):\n    max_unique = 0\n    result_word = \"\"\n    for word in words:\n        unique_chars = len(set(word))\n        if unique_chars > max_unique or (unique_chars == max_unique and word < result_word):\n            max_unique = unique_chars\n            result_word = word\n    return result_word\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `find_max` takes a list of strings as input and returns the string with the maximum number of unique characters. If there are multiple strings with the same number of unique characters, it returns the one that comes first in lexicographical order.\n\n1. The function initializes two variables: `max_unique`, which keeps track of the highest count of unique characters found so far, and `result_word`, which stores the current word with the maximum unique characters.\n2. It iterates through each word in the input list.\n3. For each word, it calculates the number of unique characters by converting the word into a set (which removes duplicates) and then taking its length.\n4. If this count is greater than `max_unique`, or if it's equal but the current word comes before `result_word` lexicographically, it updates `max_unique` and sets `result_word` to the current word.\n5. Finally, after iterating through all words, it returns `result_word`.\n\nThis approach ensures that the function finds the string with the maximum number of unique characters while also considering lexicographical order when there are ties.```\n\n\n"}
{"task_id": "CPP/8", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> sum_product(vector<int> numbers) {\n    int total_sum = 0;\n    int product = 1;\n\n    if (numbers.empty()) {\n        return {0, 1};\n    }\n\n    for (int num : numbers) {\n        total_sum += num;\n        product *= num;\n    }\n\n    return {total_sum, product};\n}\n", "py_code": "from typing import List, Tuple\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    if not numbers:\n        return (0, 1)\n    \n    total_sum = sum(numbers)\n    product = 1\n    for num in numbers:\n        product *= num\n    \n    return (total_sum, product)\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `sum_product` takes a list of integers as input and returns a tuple containing two values: the sum of all elements in the list and the product of all elements in the list.\n\n1. The function first checks if the input list is empty (`if not numbers`). If it is, it immediately returns `(0, 1)` since an empty sum should be `0` and an empty product should be `1`.\n\n2. If the list is not empty, it calculates the total sum of all elements in the list using Python's built-in `sum()` function.\n\n3. It then initializes a variable `product` to `1`. This will hold the cumulative product of all numbers in the list.\n\n4. The function iterates through each number in the input list and multiplies it with the current value of `product`.\n\n5. Finally, the function returns a tuple containing the total sum and the product calculated above.\n\nThis approach ensures that both the sum and product are computed correctly for any given list of integers, including an empty list.\n```\n\n"}
{"task_id": "CPP/95", "generation": "#include <string>\n#include <map>\n#include <cctype>\nusing namespace std;\n\nbool check_dict_case(map<string, string> dict) {\n    if (dict.empty()) return false;\n    \n    bool lower_case = false;\n    bool upper_case = false;\n    \n    for (const auto& pair : dict) {\n        const string& key = pair.first;\n        \n        // Check if the key is entirely lowercase or uppercase\n        bool all_lower = true, all_upper = true;\n        for (char c : key) {\n            if (!islower(c)) all_lower = false;\n            if (!isupper(c)) all_upper = false;\n        }\n        \n        if (all_lower && !all_upper) lower_case = true;\n        else if (!all_lower && all_upper) upper_case = true;\n        else return false; // Mixed case or invalid key\n        \n        // If both lower and upper cases are found, return false\n        if (lower_case && upper_case) return false;\n    }\n    \n    // Return true if either all keys are lowercase or uppercase\n    return lower_case || upper_case;\n}\n", "py_code": "def check_dict_case(dict):\n    if not dict:\n        return False\n\n    lower_case = 0\n    upper_case = 0\n    \n    for key in dict.keys():\n        if isinstance(key, str):\n            if key.islower():\n                lower_case += 1\n            elif key.isupper():\n                upper_case += 1\n        else:\n            return False\n            \n    if (lower_case > 0 and upper_case == 0) or (upper_case > 0 and lower_case == 0):\n        return True\n    else:\n        return False\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `check_dict_case` takes a dictionary as input and checks if all keys are strings and whether they are consistently in lower case or upper case. The function returns `False` if the dictionary is empty.\n\n1. **Initial Check**: If the dictionary is empty (`if not dict:`), it immediately returns `False`.\n2. **Initialization**: Two counters, `lower_case` and `upper_case`, are initialized to zero.\n3. **Iteration Over Keys**:\n   - The function iterates over each key in the dictionary using a for loop.\n   - It checks if the key is an instance of string (`if isinstance(key, str):`). If not, it returns `False`.\n   - For each string key, it determines whether the key is entirely lowercase or uppercase and increments the respective counter (`lower_case` or `upper_case`).\n4. **Consistency Check**: After iterating through all keys:\n   - The function checks if either all keys are in lower case (`lower_case > 0 and upper_case == 0`) or all keys are in upper case (`upper_case > 0 and lower_case == 0`). If so, it returns `True`.\n   - Otherwise, it returns `False`.\n\nThis ensures that the dictionary has consistent key casing (all lowercase or all uppercase) and no non-string keys.\n\n"}
{"task_id": "CPP/55", "generation": "#include <iostream>\nusing namespace std;\n\nint fib(int n) {\n    if (n <= 0) {\n        return 0;\n    } else if (n == 1) {\n        return 1;\n    } else {\n        int a = 0, b = 1;\n        for (int i = 2; i <= n; ++i) {\n            int temp = a + b;\n            a = b;\n            b = temp;\n        }\n        return b;\n    }\n}\n", "py_code": "def fib(n):\n    if n <= 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        a, b = 0, 1\n        for _ in range(2, n + 1):\n            a, b = b, a + b\n        return b\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `fib(n)` calculates the n-th Fibonacci number using an iterative approach. The function first checks if `n` is less than or equal to 0 and returns 0 in that case since there are no negative indices in the Fibonacci sequence and the 0th element is defined as 0. If `n` equals 1, it directly returns 1 because the first Fibonacci number (index 1) is 1.\n\nFor any other value of `n`, the function initializes two variables `a` and `b` to represent the last two numbers in the sequence (`a = 0` and `b = 1`). It then iterates from 2 up to `n`. In each iteration, it updates `a` to be the previous value of `b` (the current Fibonacci number) and `b` to be the sum of the previous values of `a` and `b` (the next Fibonacci number). After completing the loop, the function returns `b`, which holds the n-th Fibonacci number.```\n\n"}
{"task_id": "CPP/29", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> filter_by_prefix(vector<string> strings, string prefix) {\n    vector<string> filtered_strings;\n    for (const auto& s : strings) {\n        if (s.find(prefix) == 0) { // Check if the string starts with the given prefix\n            filtered_strings.push_back(s);\n        }\n    }\n    return filtered_strings;\n}\n", "py_code": "def filter_by_prefix(strings, prefix):\n    return [s for s in strings if s.startswith(prefix)]\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `filter_by_prefix` takes two arguments: a list of strings (`strings`) and a prefix string (`prefix`). It returns a new list containing only those strings from the input list that start with the specified prefix. The function uses a list comprehension to iterate over each string in the input list, checking if it starts with the given prefix using the `startswith` method. If the condition is met, the string is included in the resulting list.```\n\n"}
{"task_id": "CPP/72", "generation": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nbool will_it_fly(vector<int> q, int w) {\n    // Check if the vector is palindromic (balanced)\n    bool is_balanced = true;\n    for(size_t i = 0; i < q.size() / 2; ++i) {\n        if(q[i] != q[q.size() - 1 - i]) {\n            is_balanced = false;\n            break;\n        }\n    }\n\n    // Calculate the sum of elements in the vector\n    int total_weight = 0;\n    for(int num : q) {\n        total_weight += num;\n    }\n\n    // Return true if it's balanced and the sum is less than or equal to the maximum weight, false otherwise\n    return is_balanced && (total_weight <= w);\n}\n", "py_code": "def will_it_fly(q, w):\n    # Check if the vector is palindromic (balanced)\n    is_balanced = q == q[::-1]\n    \n    # Calculate the sum of elements in the vector\n    total_weight = sum(q)\n    \n    # Return True if it's balanced and the sum is less than or equal to the maximum weight, False otherwise\n    return is_balanced and total_weight <= w\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `will_it_fly` checks whether a given vector `q` can \"fly\" based on two conditions: it must be balanced (palindromic) and its total weight must not exceed the maximum allowed weight `w`. \n\n1. The function first determines if the list `q` is palindromic by comparing it to its reversed version (`q == q[::-1]`). If they are equal, then the vector is considered balanced.\n2. It calculates the sum of all elements in the list using the built-in `sum()` function and stores this value in `total_weight`.\n3. Finally, the function returns `True` if both conditions (being palindromic and having a total weight less than or equal to `w`) are met; otherwise, it returns `False`.```\n\n\n"}
{"task_id": "CPP/54", "generation": "#include <iostream>\n#include <string>\n#include <set>\n#include <algorithm>\nusing namespace std;\n\nbool same_chars(string s0, string s1) {\n    set<char> chars_s0(s0.begin(), s0.end());\n    set<char> chars_s1(s1.begin(), s1.end());\n\n    return (chars_s0 == chars_s1);\n}\n", "py_code": "def same_chars(s0, s1):\n    return set(s0) == set(s1)\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `same_chars` takes two strings as input and checks whether they contain the same unique characters. It does this by converting each string into a set of its characters. A set in Python is an unordered collection of unique elements. By comparing these sets with the equality operator (`==`), we can determine if both strings have exactly the same unique characters, regardless of their order or frequency within the original strings. If the sets are equal, it means that both strings contain the exact same kind of characters and the function returns `True`. Otherwise, it returns `False`.\n```\n\n"}
{"task_id": "CPP/91", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\nusing namespace std;\n\nbool starts_with_i(const string& sentence) {\n    // Trim leading spaces\n    size_t start = sentence.find_first_not_of(\" \\t\");\n    if (start == string::npos || sentence.substr(start, 1) != \"I\") return false;\n    // Check for space or end of sentence after 'I'\n    size_t next_char_pos = start + 1;\n    return next_char_pos == sentence.size() || sentence[next_char_pos] == ' ';\n}\n\nint is_bored(string S) {\n    int boredom_count = 0;\n    string delimiter = \"?.!\";\n    stringstream ss(S);\n    string token;\n\n    while (getline(ss, token, '.')) {\n        for (char c : delimiter) {\n            size_t pos;\n            while ((pos = token.find(c)) != string::npos) {\n                if (!token.substr(0, pos).empty()) {\n                    boredom_count += starts_with_i(token.substr(0, pos));\n                }\n                token.erase(0, pos + 1);\n            }\n        }\n\n        // Check the remaining part of the sentence\n        if (!token.empty()) {\n            boredom_count += starts_with_i(token);\n        }\n    }\n\n    return boredom_count;\n}\n", "py_code": "def is_bored(S):\n    sentences = [sentence.strip() for sentence in re.split(r'[.?!]', S) if sentence.strip()]\n    boredom_count = sum(sentence.startswith(\"I \") or sentence == \"I\" for sentence in sentences)\n    return boredom_count\n\nimport re\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `is_bored` takes a string `S` as input and returns an integer representing the number of sentences that start with \"I\". The function first splits the input string into individual sentences using regular expressions to match sentence delimiters ('.', '?', '!'). It then strips any leading or trailing whitespace from each sentence. \n\nThe function uses a list comprehension to filter out empty strings resulting from splitting and creates a list of valid sentences. Next, it counts how many of these sentences start with the word \"I\" (either followed by a space for longer sentences or as a single-word sentence). The `sum` function is used to count the number of True values returned by the condition inside the comprehension.\n\nFinally, the function returns the total count of such sentences.```\n\n"}
{"task_id": "CPP/77", "generation": "#include <cmath> // for cbrt function\n\nbool iscube(int a) {\n    if (a == 0) {\n        return true;\n    }\n    int cube_root = round(cbrt(a));\n    return cube_root * cube_root * cube_root == a;\n}\n", "py_code": "def iscube(a):\n    if a == 0:\n        return True\n    cube_root = round(a ** (1/3))\n    return cube_root**3 == a\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `iscube` checks whether an integer `a` is a perfect cube of some integer number. The function first handles the special case where `a` is 0, returning `True` since \\(0^3 = 0\\). For other values of `a`, it calculates the cube root using exponentiation (`a ** (1/3)`) and rounds this value to the nearest integer with `round()`. It then checks if cubing this rounded value equals the original number `a`. If they are equal, `a` is a perfect cube, and the function returns `True`; otherwise, it returns `False`.\n\n"}
{"task_id": "CPP/73", "generation": "#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint smallest_change(vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n    int left = 0;\n    int right = n - 1;\n    \n    while (left < right) {\n        if (arr[left] != arr[right]) {\n            changes += 1;\n        }\n        left += 1;\n        right -= 1;\n    }\n\n    return changes;\n}\n", "py_code": "def smallest_change(arr):\n    n = len(arr)\n    changes = 0\n    left = 0\n    right = n - 1\n    \n    while left < right:\n        if arr[left] != arr[right]:\n            changes += 1\n        left += 1\n        right -= 1\n    \n    return changes\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `smallest_change` takes a list of integers (`arr`) as input and returns an integer representing the minimum number of elements that need to be changed to make the vector palindromic.\n\n1. The length of the array is calculated and stored in variable `n`.\n2. A counter `changes` is initialized to 0, which will keep track of the number of changes required.\n3. Two pointers are used: `left`, starting at index 0, and `right`, starting at the last index (`n-1`).\n4. The function enters a while loop that continues as long as `left < right`.\n5. Inside the loop:\n   - If the elements at positions `left` and `right` are not equal, it means they need to be changed for the array to become palindromic; hence, the `changes` counter is incremented.\n   - The `left` pointer moves one step forward (`left += 1`), and the `right` pointer moves one step backward (`right -= 1`).\n6. Once the loop ends (when all elements have been checked or when `left >= right`), the function returns the total number of changes required.\n\nThis approach ensures that each pair of corresponding elements from both ends is compared, and any discrepancies are counted as necessary changes to achieve a palindromic sequence.\n\n"}
{"task_id": "CPP/71", "generation": "#include <cmath> // For sqrt function\nusing namespace std;\n\nfloat triangle_area(float a, float b, float c) {\n    // Check if the sides form a valid triangle\n    if ((a + b <= c) || (a + c <= b) || (b + c <= a)) {\n        return -1;\n    }\n    \n    // Calculate the semi-perimeter\n    float s = (a + b + c) / 2.0;\n    \n    // Use Heron's formula to calculate the area of the triangle\n    float area = sqrt(s * (s - a) * (s - b) * (s - c));\n    \n    // Round the calculated area to two decimal points and return it\n    return round(area * 100.0) / 100.0;\n}\n", "py_code": "import math\n\ndef triangle_area(a, b, c):\n    # Check if the sides form a valid triangle\n    if (a + b <= c) or (a + c <= b) or (b + c <= a):\n        return -1\n    \n    # Calculate the semi-perimeter\n    s = (a + b + c) / 2\n    \n    # Use Heron's formula to calculate the area of the triangle\n    area = math.sqrt(s * (s - a) * (s - b) * (s - c))\n    \n    return round(area, 2)\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `triangle_area(a, b, c)` calculates and returns the area of a triangle given its three sides (a, b, c). The function first checks if the provided sides can form a valid triangle by ensuring that the sum of any two sides is greater than the third side. If this condition is not met, it immediately returns `-1`.\n\nIf the sides do form a valid triangle, the function proceeds to calculate the semi-perimeter `s` as half the perimeter of the triangle (i.e., `(a + b + c) / 2`). It then uses Heron's formula to compute the area: \n\n\\[ \\text{Area} = \\sqrt{s(s-a)(s-b)(s-c)} \\]\n\nFinally, it rounds the calculated area to two decimal points and returns this value.\n\n"}
{"task_id": "CPP/82", "generation": "#include <string>\n#include <cmath>\nusing namespace std;\n\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i <= sqrt(n); ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\nbool prime_length(string str) {\n    int length = str.length();\n    return is_prime(length);\n}\n", "py_code": "def is_prime(n):\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef prime_length(str):\n    length = len(str)\n    return is_prime(length)\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python solution consists of two functions: `is_prime` and `prime_length`. The function `is_prime(n)` checks if a given number `n` is prime by iterating from 2 to the square root of `n`, checking for any divisors. If it finds a divisor, it returns False; otherwise, it returns True.\n\nThe function `prime_length(str)` calculates the length of the input string and then uses the `is_prime` function to determine if this length is prime. It returns `True` if the length is prime and `False` otherwise.\n\n"}
{"task_id": "CPP/114", "generation": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nlong long minSubArraySum(vector<long long> nums) {\n    if (nums.empty()) return 0;\n    \n    long long current_sum = nums[0];\n    long long min_sum = nums[0];\n\n    for (size_t i = 1; i < nums.size(); ++i) {\n        // Decide whether to add the current number to the existing subarray or start a new subarray\n        current_sum = min(nums[i], current_sum + nums[i]);\n        min_sum = min(min_sum, current_sum);\n    }\n\n    return min_sum;\n}\n", "py_code": "from typing import List\n\ndef minSubArraySum(nums: List[int]) -> int:\n    if not nums:\n        return 0\n    \n    current_sum = min_sum = nums[0]\n    \n    for num in nums[1:]:\n        # Decide whether to add the current number to the existing subarray or start a new subarray\n        current_sum = min(num, current_sum + num)\n        min_sum = min(min_sum, current_sum)\n\n    return min_sum\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `minSubArraySum` calculates the minimum sum of any non-empty sub-vector from a given list of integers (`nums`). The algorithm uses Kadane's Algorithm in a slightly modified form to find the minimum subarray sum instead of the maximum subarray sum.\n\n1. The function first checks if the input list is empty and returns 0 if it is.\n2. It initializes `current_sum` and `min_sum` with the first element of the list (`nums[0]`). These variables keep track of the current minimum subarray sum ending at the current index and the overall minimum subarray sum found so far, respectively.\n3. The function then iterates through the rest of the elements in the list starting from the second element (`nums[1:]`).\n4. For each number `num`, it updates `current_sum` to be the minimum between `num` (starting a new subarray) and `current_sum + num` (extending the current subarray). This step decides whether to start a new subarray or continue with the existing one.\n5. It also updates `min_sum` if the updated `current_sum` is less than the previous `min_sum`.\n6. Finally, it returns `min_sum`, which holds the minimum sum of any non-empty sub-vector found in the list.\n\nThis approach ensures that all possible sub-vectors are considered and finds the one with the smallest sum efficiently.\n```\n\n"}
{"task_id": "CPP/138", "generation": "#include <iostream>\nusing namespace std;\n\nbool is_equal_to_sum_even(int n) {\n    // The smallest sum of 4 positive even numbers is 2 + 2 + 2 + 2 = 8.\n    if (n < 8) {\n        return false;\n    }\n    \n    // If the number is even and greater than or equal to 8, it can always\n    // be written as the sum of four positive even numbers.\n    return n % 2 == 0;\n}\n", "py_code": "def is_equal_to_sum_even(n):\n    # The smallest sum of 4 positive even numbers is 2 + 2 + 2 + 2 = 8.\n    # Any number less than 8 cannot be expressed as such a sum.\n    if n < 8:\n        return False\n    \n    # If the number is even and greater than or equal to 8, it can always\n    # be written as the sum of four positive even numbers.\n    # For example: \n    #   - for n = 8, we have 2 + 2 + 2 + 2\n    #   - for n > 8 and even, we can use (n-6) + 2 + 2 + 2\n    return n % 2 == 0\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `is_equal_to_sum_even` evaluates whether a given number `n` can be expressed as the sum of exactly four positive even numbers. The logic is based on two key points:\n\n1. **Minimum Sum**: The smallest possible sum of four positive even numbers is 8 (2+2+2+2). Therefore, any number less than 8 cannot be written as such a sum.\n   \n2. **Even Numbers**: For `n` to be the sum of exactly four positive even numbers, it must itself be an even number greater than or equal to 8.\n\nThe function checks if `n` is less than 8 and returns `False` in that case. If `n` is greater than or equal to 8 and is even (i.e., `n % 2 == 0`), it can always be expressed as the sum of four positive even numbers, so the function returns `True`.```\n\n"}
{"task_id": "CPP/132", "generation": "#include <string>\nusing namespace std;\n\nbool is_nested(string str) {\n    int max_depth = 0;\n    int current_depth = 0;\n\n    for (char c : str) {\n        if (c == '[') {\n            current_depth += 1;\n            max_depth = max(max_depth, current_depth);\n        } else if (c == ']') {\n            current_depth -= 1;\n        }\n\n        // Early exit condition: if current depth is negative, it means there's an unmatched closing bracket.\n        if (current_depth < 0) {\n            return false;\n        }\n    }\n\n    // Check for valid nested brackets\n    return max_depth > 1 && current_depth == 0;\n}\n", "py_code": "def is_nested(s):\n    max_depth = 0\n    current_depth = 0\n    \n    for char in s:\n        if char == '[':\n            current_depth += 1\n            max_depth = max(max_depth, current_depth)\n        elif char == ']':\n            current_depth -= 1\n            \n        # Early exit condition: if current depth is negative, it means there's an unmatched closing bracket.\n        if current_depth < 0:\n            return False\n    \n    # Check for valid nested brackets\n    return max_depth > 1 and current_depth == 0\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `is_nested` checks if a given string of square brackets contains at least one valid nested subsequence of brackets. The function iterates through each character in the input string and maintains two variables: `current_depth`, which tracks the current depth (number of open brackets without corresponding closing ones), and `max_depth`, which keeps track of the maximum depth encountered during the iteration.\n\n- When an opening bracket `[` is encountered, `current_depth` is incremented by 1.\n- When a closing bracket `]` is encountered, `current_depth` is decremented by 1. If at any point `current_depth` becomes negative, it means there's an unmatched closing bracket, and the function returns `False`.\n- After iterating through all characters in the string, if `max_depth > 1`, it indicates that there was at least one nested pair of brackets (since a depth greater than 1 implies nesting), and if `current_depth == 0`, it means every opening bracket has been matched with a closing one.\n\nThe function returns `True` only if both conditions (`max_depth > 1` and `current_depth == 0`) are met, indicating the presence of at least one nested pair of brackets in the string.\n\n"}
{"task_id": "CPP/3", "generation": "#include <vector>\nusing namespace std;\n\nbool below_zero(vector<int> operations) {\n    int balance = 0; // Initialize the starting balance to zero.\n    \n    for (int op : operations) { // Iterate through each operation in the vector.\n        balance += op; // Update the balance based on the current operation.\n        \n        if (balance < 0) { // Check if the updated balance is below zero.\n            return true; // If it is, return true immediately.\n        }\n    }\n\n    return false; // If no point during operations did the balance fall below zero, return false.\n}\n", "py_code": "def below_zero(operations):\n    balance = 0\n    for op in operations:\n        balance += op\n        if balance < 0:\n            return True\n    return False\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `below_zero` takes a list of integers representing deposit and withdrawal operations on a bank account that starts with zero balance. The goal is to determine if at any point during these operations the balance falls below zero.\n\n1. **Initialization**: A variable `balance` is initialized to 0, which represents the starting balance of the account.\n2. **Iteration through Operations**: The function iterates over each operation in the list `operations`.\n3. **Update Balance**: For each operation, the value is added to or subtracted from the current balance (depending on whether it's a deposit or withdrawal).\n4. **Check for Negative Balance**: After updating the balance with each operation, the function checks if the new balance is less than 0.\n5. **Return True if Below Zero**: If at any point the balance falls below zero, the function immediately returns `True`.\n6. **Return False if No Negative Balance**: If the loop completes without finding a negative balance, the function returns `False`.\n\nThis approach ensures that we can detect as soon as the account goes into deficit and stop further processing, which is efficient.\n\n"}
{"task_id": "CPP/142", "generation": "#include <vector>\nusing namespace std;\n\nint sum_squares(vector<int> lst) {\n    int total_sum = 0;\n    for (size_t i = 0; i < lst.size(); ++i) {\n        if (i % 3 == 0) {\n            total_sum += lst[i] * lst[i];\n        } else if (i % 4 == 0) {\n            total_sum += lst[i] * lst[i] * lst[i];\n        } else {\n            total_sum += lst[i];\n        }\n    }\n    return total_sum;\n}\n", "py_code": "def sum_squares(lst):\n    total_sum = 0\n    for i in range(len(lst)):\n        if i % 3 == 0:\n            total_sum += lst[i] ** 2\n        elif i % 4 == 0:\n            total_sum += lst[i] ** 3\n        else:\n            total_sum += lst[i]\n    return total_sum\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `sum_squares` takes a list of integers and computes the sum of its elements based on specific conditions related to their indices:\n- If an index is a multiple of 3 (i.e., `index % 3 == 0`), the corresponding element is squared.\n- If an index is a multiple of 4 but not a multiple of 3, the corresponding element is cubed.\n- For all other elements, they are added to the sum as-is.\n\nThe function iterates through each element in the list using its index. It checks whether the current index meets any of the conditions and performs the appropriate operation (squaring or cubing) before adding it to `total_sum`. Finally, the total sum is returned.\n\n"}
{"task_id": "CPP/50", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nstring encode_shift(string s) {\n    // returns encoded string by shifting every character by 5 in the alphabet.\n    string out;\n    int i;\n    for (i = 0; i < s.length(); i++) {\n        int w = ((int)s[i] + 5 - (int)'a') % 26 + (int)'a';\n        out += (char)w;\n    }\n    return out;\n}\n\nstring decode_shift(string s) {\n    // takes as input string encoded with encode_shift function. Returns decoded string.\n    string out;\n    int i;\n    for (i = 0; i < s.length(); i++) {\n        int w = ((int)s[i] - 5 - (int)'a' + 26) % 26 + (int)'a';\n        out += (char)w;\n    }\n    return out;\n}\n", "py_code": "def encode_shift(s):\n    # returns encoded string by shifting every character by 5 in the alphabet.\n    out = \"\"\n    for char in s:\n        w = ((ord(char) + 5 - ord('a')) % 26) + ord('a')\n        out += chr(w)\n    return out\n\ndef decode_shift(s):\n    # takes as input string encoded with encode_shift function. Returns decoded string.\n    out = \"\"\n    for char in s:\n        w = ((ord(char) - 5 - ord('a')) % 26 + 26) % 26 + ord('a')\n        out += chr(w)\n    return out\n```\n\n", "py_summary": "### Second Step: Analyse the Python Code\n\nThe provided Python code consists of two functions:\n1. `encode_shift(s)`: This function takes a string `s` and returns an encoded version where each character is shifted by 5 positions in the alphabet. The shifting wraps around using modulo operation to ensure that it stays within the range 'a' to 'z'. For example, if the input character is 'y', adding 5 would result in 'd'.\n\n2. `decode_shift(s)`: This function takes a string `s` encoded by the `encode_shift` function and returns its decoded version. It reverses the shift operation performed by `encode_shift`. The decoding process involves subtracting 5 from each character's ASCII value, wrapping around using modulo operations to ensure it remains within 'a' to 'z'.\n\nThe encoding and decoding functions work as follows:\n- Convert each character in the string to its corresponding integer (ASCII) value.\n- For encoding: Add 5 to this integer value, apply modulo 26 to wrap around the alphabet, then convert back to a character by adding the ASCII value of 'a'.\n- For decoding: Subtract 5 from this integer value, adjust for negative values using additional modulo operations, and finally convert it back to a character.\n\n"}
{"task_id": "CPP/103", "generation": "#include <iostream>\n#include <cmath>\n#include <string>\n#include <bitset>\nusing namespace std;\n\nstring rounded_avg(int n, int m) {\n    if (n > m) return \"-1\";\n\n    long total_sum = 0;\n    for (int i = n; i <= m; ++i) {\n        total_sum += i;\n    }\n    \n    int count = m - n + 1;\n    int average = total_sum / count;\n\n    // Convert the integer to binary string\n    bitset<32> binary(average);\n    string binary_str = binary.to_string();\n\n    // Find the first '1' and remove leading zeros\n    size_t first_one_pos = binary_str.find('1');\n    if (first_one_pos != string::npos) {\n        return binary_str.substr(first_one_pos);\n    } else {\n        return \"0\";  // In case average is zero.\n    }\n}\n", "py_code": "def rounded_avg(n, m):\n    if n > m:\n        return \"-1\"\n    \n    total_sum = sum(range(n, m + 1))\n    count = m - n + 1\n    average = total_sum // count\n    \n    return bin(average)[2:]\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `rounded_avg` takes two integers, n and m, as input parameters. If n is greater than m, it returns \"-1\" immediately since there are no valid numbers to average in this case.\n\nIf n is less than or equal to m, the function calculates the sum of all integers from n through m (inclusive) using Python's `sum` function on a range object created with `range(n, m + 1)`. It then determines the count of these integers as `m - n + 1`.\n\nThe average is calculated by integer division (`//`) of the total sum by the count to ensure rounding down. Finally, it converts this rounded average into its binary representation using Python's built-in `bin` function and slices off the '0b' prefix with `[2:]`. The resulting string representing the binary number is returned.\n```\n\n"}
{"task_id": "CPP/57", "generation": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nbool monotonic(vector<float> l) {\n    bool increasing = true;\n    bool decreasing = true;\n    \n    for (size_t i = 1; i < l.size(); ++i) {\n        if (l[i] > l[i - 1]) {\n            decreasing = false;\n        }\n        if (l[i] < l[i - 1]) {\n            increasing = false;\n        }\n    }\n\n    return increasing || decreasing;\n}\n", "py_code": "def monotonic(l):\n    increasing = all(x <= y for x, y in zip(l, l[1:]))\n    decreasing = all(x >= y for x, y in zip(l, l[1:]))\n    return increasing or decreasing\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `monotonic` checks if a list of numbers is either monotonically increasing or decreasing. It does this by using two generator expressions within the `all()` function to check for both conditions:\n\n1. **Increasing Condition**: The expression `all(x <= y for x, y in zip(l, l[1:]))` iterates through pairs of consecutive elements `(x, y)` from the list and checks if each element is less than or equal to the next one (`x <= y`). If all such comparisons are true, then the list is monotonically increasing.\n\n2. **Decreasing Condition**: Similarly, `all(x >= y for x, y in zip(l, l[1:]))` checks if each element is greater than or equal to the next one (`x >= y`). This verifies if the list is monotonically decreasing.\n\nThe function returns `True` if either of these conditions holds true; otherwise, it returns `False`.```\n\n"}
{"task_id": "CPP/28", "generation": "#include <vector>\n#include <string>\nusing namespace std;\n\nstring concatenate(vector<string> strings) {\n    string result = \"\";\n    for (const auto& str : strings) {\n        result += str;\n    }\n    return result;\n}\n", "py_code": "from typing import List\n\ndef concatenate(strings: List[str]) -> str:\n    return ''.join(strings)\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `concatenate` takes a list of strings as input and returns a single string that is the concatenation of all the strings in the list. The function uses the built-in `join` method to concatenate the elements of the list into one string without any separator between them.\n\n- If the input list is empty, it will return an empty string.\n- For non-empty lists, each element (string) from the list is concatenated in order to form a single continuous string.\n\n"}
{"task_id": "CPP/39", "generation": "#include <cmath>\n#include <iostream>\n\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    for (int i = 2; i * i <= num; ++i) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\nint prime_fib(int n) {\n    int count = 0, a = 0, b = 1;\n\n    while (true) {\n        // Generate next Fibonacci number\n        int fib_num = a + b;\n        a = b;\n        b = fib_num;\n\n        if (is_prime(fib_num)) {\n            ++count;\n            if (count == n) return fib_num;\n        }\n    }\n\n    return -1; // This line should never be reached.\n}\n", "py_code": "def is_prime(num):\n    if num <= 1:\n        return False\n    for i in range(2, int(num**0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef prime_fib(n):\n    def fib():\n        a, b = 0, 1\n        while True:\n            yield a\n            a, b = b, a + b\n    \n    count = 0\n    for f in fib():\n        if is_prime(f):\n            count += 1\n            if count == n:\n                return f\n```\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python solution consists of two functions: `is_prime` and `prime_fib`. \n\n- The function `is_prime(num)` checks if a given number is prime by iterating from 2 to the square root of the number (inclusive) and checking for any divisors. If no divisor is found, it returns True indicating that the number is prime; otherwise, it returns False.\n\n- The function `prime_fib(n)` generates Fibonacci numbers using a generator function called `fib()`. This generator yields Fibonacci numbers indefinitely by starting with 0 and 1 and then generating subsequent numbers as the sum of the previous two. \n\nThe main logic in `prime_fib` iterates over these generated Fibonacci numbers, checking each one to see if it is prime using the `is_prime` function. It maintains a count of how many prime Fibonacci numbers have been found so far. When this count reaches `n`, the current Fibonacci number (which is also prime) is returned as the result.\n\n"}
{"task_id": "CPP/45", "generation": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n\nfloat triangle_area(float a, float h) {\n    return 0.5 * a * h;\n}\n", "py_code": "def triangle_area(a, h):\n    return 0.5 * a * h\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `triangle_area` takes two arguments: `a`, which represents the length of a side (base) of the triangle, and `h`, which represents the height of the triangle perpendicular to that side. The area of a triangle is calculated using the formula `(1/2) * base * height`. This function simply multiplies half of the base (`0.5 * a`) by the height (`h`), returning the computed area as a float value.\n```\n\n"}
{"task_id": "CPP/145", "generation": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <cmath>\n\nusing namespace std;\n\nint sum_of_digits(int n) {\n    int sum = 0;\n    while (n != 0) {\n        sum += abs(n % 10);\n        n /= 10;\n    }\n    return sum * (abs(n) == -n ? -1 : 1); // Adjust for negative numbers\n}\n\nbool compare(const pair<int, int>& a, const pair<int, int>& b) {\n    if (sum_of_digits(a.first) != sum_of_digits(b.first)) {\n        return sum_of_digits(a.first) < sum_of_digits(b.first);\n    }\n    return a.second < b.second;\n}\n\nvector<int> order_by_points(vector<int> nums) {\n    vector<pair<int, int>> indexed_nums;\n\n    // Pair each number with its index\n    for (int i = 0; i < nums.size(); ++i) {\n        indexed_nums.push_back({nums[i], i});\n    }\n\n    // Sort based on the sum of digits and then by original index if sums are equal.\n    sort(indexed_nums.begin(), indexed_nums.end(), compare);\n\n    vector<int> sorted_nums;\n    for (const auto& p : indexed_nums) {\n        sorted_nums.push_back(p.first);\n    }\n    \n    return sorted_nums;\n}\n\n", "py_code": "from typing import List\n\ndef sum_of_digits(n: int) -> int:\n    return sum(int(digit) for digit in str(n))\n\ndef order_by_points(nums: List[int]) -> List[int]:\n    # Sort based on the sum of digits and then by original index if sums are equal.\n    sorted_nums = sorted((num for num in nums), key=lambda x: (sum_of_digits(x), nums.index(x)))\n    return sorted_nums\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `order_by_points` sorts a list of integers based on the sum of their digits in ascending order. If multiple numbers have the same digit sum, they are ordered by their original index in the input list.\n\n1. The helper function `sum_of_digits(n)` calculates the sum of the digits of an integer `n`. It converts the number to a string and then sums up each character (digit) after converting it back to an integer.\n2. In the main function, a generator expression `(num for num in nums)` is used to iterate over the input list `nums`.\n3. The `sorted` function sorts this iterable based on two criteria:\n   - First, by the sum of digits using the lambda function `lambda x: (sum_of_digits(x), nums.index(x))`. This ensures that numbers with smaller digit sums come first.\n   - Second, if there are ties in the digit sums, it uses the original index of each number to maintain their order from the input list. The `nums.index(x)` part of the lambda function achieves this by returning the position of `x` in the original list.\n\nThe sorted list is then returned as the output.\n```\n\n"}
{"task_id": "CPP/84", "generation": "#include <iostream>\n#include <string>\n#include <bitset>\nusing namespace std;\n\nstring solve(int N) {\n    int digit_sum = 0;\n    while (N > 0) {\n        digit_sum += N % 10;\n        N /= 10;\n    }\n    return bitset<14>(digit_sum).to_string().substr(14 - to_string(digit_sum).length());\n}\n", "py_code": "def solve(N):\n    digit_sum = sum(int(digit) for digit in str(N))\n    return bin(digit_sum)[2:]\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `solve` takes an integer N as input and returns a string representing the binary form of the sum of its digits. The function first converts the integer to a string to iterate over each digit, then calculates the sum of these digits by converting them back into integers. After obtaining the sum of the digits, it uses Python's built-in `bin` function to convert this sum into a binary string. Since `bin()` returns a string that starts with '0b', we slice off the first two characters using `[2:]` to get the pure binary representation without the prefix.\n```\n\n"}
{"task_id": "CPP/113", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nvector<string> odd_count(vector<string> lst) {\n    vector<string> result;\n    for (const auto& s : lst) {\n        int count = 0;\n        // Count the number of odd digits in the string\n        for (char c : s) {\n            if ((c - '0') % 2 != 0) {\n                ++count;\n            }\n        }\n\n        // Construct the output string with replacements\n        string output_str = \"the number of odd elements \";\n        for (size_t i = 0; i < output_str.length(); ++i) {\n            if (output_str[i] == 'n') {\n                output_str.insert(i, to_string(count));\n                i += to_string(count).length();\n            }\n        }\n\n        // Append the constructed string to the result vector\n        result.push_back(output_str);\n    }\n    return result;\n}\n", "py_code": "def odd_count(lst):\n    result = []\n    for s in lst:\n        count = sum(1 for c in s if int(c) % 2 != 0)\n        output_str = \"the number of odd elements {}n the str{}ng {} of the {}nput.\".format(count, count, count, count)\n        result.append(output_str)\n    return result\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `odd_count` takes a list of strings as input and returns a list of formatted strings based on the count of odd digits in each string from the input list.\n\n1. The function iterates over each string `s` in the input list.\n2. For each string, it calculates the number of odd digits by using a generator expression inside the `sum()` function. This counts how many characters (`c`) in the string are odd when converted to integers.\n3. It then constructs an output string with placeholders for the count of odd digits and formats this string using the `format` method, replacing each `{}` placeholder with the calculated count.\n4. The formatted string is appended to a result list.\n5. Finally, the function returns the list of formatted strings.\n\nThis approach ensures that each element in the returned list corresponds to an input string and contains the correct number of odd digits as specified by the problem statement.```\n\n"}
{"task_id": "CPP/36", "generation": "#include <string>\n#include <algorithm>\nusing namespace std;\n\nint count_digit_seven(const string& number) {\n    int count = 0;\n    for (char digit : number) {\n        if (digit == '7') {\n            ++count;\n        }\n    }\n    return count;\n}\n\nint fizz_buzz(int n) {\n    int count = 0;\n    for (int i = 1; i < n; ++i) {\n        if ((i % 11 == 0 || i % 13 == 0) && to_string(i).find('7') != string::npos) {\n            count += count_digit_seven(to_string(i));\n        }\n    }\n    return count;\n}\n", "py_code": "def fizz_buzz(n):\n    count = 0\n    for i in range(1, n):\n        if (i % 11 == 0 or i % 13 == 0) and '7' in str(i):\n            count += str(i).count('7')\n    return count\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `fizz_buzz` takes an integer `n` as input and returns the number of times the digit '7' appears in integers less than `n` which are divisible by either 11 or 13. The function iterates over all numbers from 1 to n-1, checking if each number is divisible by 11 or 13 using the modulo operator (`%`). If a number meets this condition and contains the digit '7', it counts how many times '7' appears in that number using `str(i).count('7')` and increments the count accordingly. Finally, the function returns the total count of occurrences of the digit '7'.```\n\n\n"}
{"task_id": "CPP/144", "generation": "#include <string>\n#include <sstream>\nusing namespace std;\n\nbool simplify(string x, string n) {\n    int num1, den1, num2, den2;\n    \n    // Extracting numerator and denominator from fractions.\n    size_t slashPos = x.find('/');\n    stringstream(x.substr(0, slashPos)) >> num1;\n    stringstream(x.substr(slashPos + 1)) >> den1;\n\n    slashPos = n.find('/');\n    stringstream(n.substr(0, slashPos)) >> num2;\n    stringstream(n.substr(slashPos + 1)) >> den2;\n\n    // Simplify the expression by multiplying the numerators and denominators.\n    int numerator_product = num1 * num2;\n    int denominator_product = den1 * den2;\n\n    // Check if the result is a whole number.\n    return (numerator_product % denominator_product == 0);\n}\n", "py_code": "def simplify(x: str, n: str) -> bool:\n    num1, den1 = map(int, x.split('/'))\n    num2, den2 = map(int, n.split('/'))\n\n    # Simplify the expression by multiplying the numerators and denominators.\n    numerator_product = num1 * num2\n    denominator_product = den1 * den2\n\n    # Check if the result is a whole number.\n    return numerator_product % denominator_product == 0\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `simplify` takes two string arguments representing fractions and determines whether their product is a whole number. The function first splits each fraction into its numerator and denominator using the `split('/')` method and converts them to integers with `map(int, ...)`. It then calculates the product of the numerators (`numerator_product`) and the product of the denominators (`denominator_product`). Finally, it checks if the `numerator_product` is divisible by the `denominator_product`, which would indicate that the result of multiplying the two fractions is a whole number. The function returns `True` if this condition holds and `False` otherwise.```\n\n"}
{"task_id": "CPP/0", "generation": "#include <vector>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\nbool has_close_elements(vector<float> numbers, float threshold) {\n    sort(numbers.begin(), numbers.end());\n    for (size_t i = 0; i < numbers.size() - 1; ++i) {\n        if (fabs(numbers[i] - numbers[i + 1]) < threshold) {\n            return true;\n        }\n    }\n    return false;\n}\n", "py_code": "from typing import List\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    numbers.sort()\n    for i in range(len(numbers) - 1):\n        if abs(numbers[i] - numbers[i + 1]) < threshold:\n            return True\n    return False\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `has_close_elements` takes a list of floating-point numbers and a threshold value as input parameters. The goal is to determine if there are any two adjacent elements in the sorted list that have an absolute difference less than the given threshold.\n\n1. **Sorting**: The first operation performed by the function is sorting the list of numbers in ascending order using `numbers.sort()`. Sorting helps in easily comparing each number with its immediate successor.\n2. **Iteration and Comparison**: After sorting, the function iterates through the sorted list up to the second last element (using a for loop). For each pair of adjacent elements (`numbers[i]` and `numbers[i + 1]`), it calculates their absolute difference using `abs(numbers[i] - numbers[i + 1])`.\n3. **Threshold Check**: If this calculated difference is less than the threshold, the function immediately returns `True`, indicating that there are indeed two numbers closer to each other than the given threshold.\n4. **Return False if No Close Elements Found**: If no such pair of elements is found during the iteration (i.e., all differences are greater than or equal to the threshold), the function returns `False`.\n\nThis approach ensures an efficient check by leveraging sorting and a single pass through the list, making it both time-efficient and straightforward.\n\n"}
{"task_id": "CPP/17", "generation": "#include <string>\n#include <vector>\n#include <sstream>\nusing namespace std;\n\nvector<int> parse_music(string music_string) {\n    vector<int> beats;\n    stringstream ss(music_string);\n    string note;\n    \n    while (getline(ss, note, ' ')) {\n        if (note == \"o\") {\n            beats.push_back(4);\n        } else if (note == \"o|\") {\n            beats.push_back(2);\n        } else if (note == \".|\") {\n            beats.push_back(1);\n        }\n    }\n\n    return beats;\n}\n", "py_code": "def parse_music(music_string):\n    notes = music_string.split()\n    beats = []\n    for note in notes:\n        if note == \"o\":\n            beats.append(4)\n        elif note == \"o|\":\n            beats.append(2)\n        elif note == \".|\":\n            beats.append(1)\n    return beats\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `parse_music` takes a string representing musical notes in a special ASCII format and returns a list of integers corresponding to how many beats each note lasts. The input string is split into individual notes using spaces as delimiters. For each note, the function checks its type based on the legend provided: \"o\" for whole notes (4 beats), \"o|\" for half notes (2 beats), and \".|\" for quarter notes (1 beat). It then appends the corresponding number of beats to a list called `beats`. Finally, it returns this list.``` \n\n"}
{"task_id": "CPP/47", "generation": "#include <stdio.h>\n#include <math.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nfloat median(vector<float> l) {\n    sort(l.begin(), l.end());\n    int n = l.size();\n    if (n % 2 == 1) {\n        return l[n / 2];\n    } else {\n        float mid_index = n / 2;\n        return (l[mid_index - 1] + l[mid_index]) / 2.0;\n    }\n}\n", "py_code": "from typing import List\n\ndef median(l: List[float]) -> float:\n    sorted_l = sorted(l)\n    n = len(sorted_l)\n    if n % 2 == 1:\n        return sorted_l[n // 2]\n    else:\n        mid_index = n // 2\n        return (sorted_l[mid_index - 1] + sorted_l[mid_index]) / 2.0\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `median` calculates and returns the median of a list of numbers (`l`). The steps are as follows:\n1. **Sorting**: The input list `l` is first sorted in ascending order to ensure that the middle elements can be easily accessed.\n2. **Length Check**: The length of the sorted list (`n`) is checked to determine if it's odd or even.\n3. **Odd Length Case**: If the length is odd, the median is simply the element at index `n // 2` (integer division).\n4. **Even Length Case**: If the length is even, the median is calculated as the average of the two middle elements: `sorted_l[n // 2 - 1]` and `sorted_l[n // 2]`.\n\nThe function returns a float value representing the median.\n\n"}
{"task_id": "CPP/75", "generation": "#include <vector>\n#include <cmath>\nusing namespace std;\n\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\nvector<int> generate_primes() {\n    vector<int> primes;\n    for (int i = 2; i < 100; ++i) {\n        if (is_prime(i)) {\n            primes.push_back(i);\n        }\n    }\n    return primes;\n}\n\nbool is_multiply_prime(int a) {\n    vector<int> primes = generate_primes();\n    \n    for (auto& i : primes) {\n        for (auto& j : primes) {\n            for (auto& k : primes) {\n                if (i * j * k == a) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n", "py_code": "def is_multiply_prime(a):\n    def is_prime(n):\n        if n <= 1:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    primes = [i for i in range(2, 100) if is_prime(i)]\n    \n    for i in primes:\n        for j in primes:\n            for k in primes:\n                if i * j * k == a:\n                    return True\n    return False\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `is_multiply_prime(a)` checks whether the given number `a` can be expressed as the product of three prime numbers (each less than 100). The function first defines a helper function `is_prime(n)` to determine if a number is prime. It then generates a list of all prime numbers less than 100 using this helper function.\n\nThe main logic iterates over all combinations of three primes from the generated list and checks whether their product equals the input number `a`. If such a combination exists, it returns `True`, indicating that `a` is indeed the multiplication of three prime numbers. Otherwise, if no such combination is found after checking all possibilities, the function returns `False`.\n\nThis approach ensures that we check every possible triplet of primes less than 100 to see if their product matches the input number `a`. The nested loops ensure a thorough examination of all combinations.\n\n"}
{"task_id": "CPP/124", "generation": "#include <string>\n#include <vector>\n#include <sstream>\nusing namespace std;\n\nbool valid_date(string date) {\n    // Check if the string is empty or does not contain exactly two hyphens.\n    if (date.empty() || count(date.begin(), date.end(), '-') != 2) return false;\n    \n    vector<string> parts;\n    stringstream ss(date);\n    string part;\n    \n    // Split the date into month, day and year components\n    while(getline(ss, part, '-')) {\n        parts.push_back(part);\n    }\n    \n    if (parts.size() != 3) return false; // Ensure there are exactly three parts\n    \n    int month = stoi(parts[0]);\n    int day = stoi(parts[1]);\n    int year = stoi(parts[2]);\n    \n    // Check the validity of the month\n    if (month < 1 || month > 12) return false;\n    \n    // Define days in each month, considering February has a maximum of 29 days for simplicity.\n    vector<int> days_in_month = {31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\n    \n    // Check the validity of the day\n    if (day < 1 || day > days_in_month[month - 1]) return false;\n    \n    // If all checks pass, the date is valid.\n    return true;\n}\n", "py_code": "def valid_date(date: str) -> bool:\n    if not date or len(date.split('-')) != 3:\n        return False\n\n    month, day, year = date.split('-')\n    \n    # Check for correct format and range of values\n    if not (month.isdigit() and day.isdigit() and year.isdigit()):\n        return False\n    \n    month, day, year = int(month), int(day), int(year)\n    \n    if month < 1 or month > 12:\n        return False\n\n    days_in_month = {\n        1: 31, 3: 31, 5: 31, 7: 31, 8: 31, 10: 31, 12: 31,\n        4: 30, 6: 30, 9: 30, 11: 30,\n        2: 29\n    }\n    \n    if day < 1 or (month in days_in_month and day > days_in_month[month]):\n        return False\n    \n    return True\n```\n\n", "py_summary": "### Second step, analyse the python code:\nThe Python function `valid_date` takes a string representing a date in the format \"mm-dd-yyyy\" and checks if it is valid according to specific rules.\n\n1. **Initial Checks**: The function first ensures that the input string is not empty and contains exactly three parts separated by hyphens (indicating the correct mm-dd-yyyy format).\n2. **Type Validation**: It then splits the date into month, day, and year components and checks if each component consists of digits only.\n3. **Month Range Check**: The function converts these strings to integers and verifies that the month is within the valid range of 1-12.\n4. **Day Range Check**: A dictionary `days_in_month` maps months to their maximum number of days (considering February has a maximum of 29 days for simplicity). It checks if the day falls within the allowed range for the given month.\n\nIf all these conditions are met, the function returns `True`, indicating that the date is valid. Otherwise, it returns `False`.\n\n"}
{"task_id": "CPP/101", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\nusing namespace std;\n\nvector<string> words_string(string s) {\n    // Replace all commas with spaces.\n    for (size_t pos = 0; (pos = s.find(',')) != string::npos;) {\n        s.replace(pos, 1, \" \");\n    }\n\n    vector<string> result;\n    stringstream ss(s);\n    string word;\n\n    // Split the string by whitespace and store each word in the vector.\n    while (ss >> word) {\n        result.push_back(word);\n    }\n    \n    return result;\n}\n", "py_code": "def words_string(s):\n    # Replace commas with spaces and then split by spaces.\n    return [word for word in s.replace(',', '').split()]\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `words_string` takes a string `s` as input and returns a list of words from that string. The function first replaces all commas in the string with spaces using the `replace` method to ensure consistent delimiters for splitting. Then it uses the `split` method, which splits the string by whitespace (spaces) into a list of words. This approach ensures that both commas and spaces are treated as word separators, resulting in a clean list of individual words without any punctuation or extra spaces.```\n\n\n"}
{"task_id": "CPP/14", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> all_prefixes(string str) {\n    vector<string> prefixes;\n    for (size_t i = 1; i <= str.size(); ++i) {\n        prefixes.push_back(str.substr(0, i));\n    }\n    return prefixes;\n}\n", "py_code": "def all_prefixes(str):\n    return [str[:i+1] for i in range(len(str))]\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `all_prefixes` takes a string as input and returns a list of all possible prefixes of that string, ordered from shortest to longest. The function uses a list comprehension to generate these prefixes by slicing the input string up to each index position (from 0 to the length of the string minus one). For example, for an input string \"abc\", it will return [\"a\", \"ab\", \"abc\"].```\n\n"}
{"task_id": "CPP/141", "generation": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nbool is_valid_extension(const string& ext) {\n    vector<string> valid_extensions = {\"txt\", \"exe\", \"dll\"};\n    return find(valid_extensions.begin(), valid_extensions.end(), ext) != valid_extensions.end();\n}\n\nstring file_name_check(string file_name){\n    // Check if there is exactly one dot in the filename\n    int dot_count = count(file_name.begin(), file_name.end(), '.');\n    if (dot_count != 1)\n        return \"No\";\n    \n    // Split the filename into two parts: before and after the dot\n    size_t dot_position = file_name.find('.');\n    string name_before_dot = file_name.substr(0, dot_position);\n    string name_after_dot = file_name.substr(dot_position + 1);\n\n    // Validate the part before the dot\n    if (name_before_dot.empty() || !isalpha(name_before_dot[0]) || count_if(name_before_dot.begin(), name_before_dot.end(), ::isdigit) > 3)\n        return \"No\";\n    \n    // Validate the part after the dot\n    if (!is_valid_extension(name_after_dot))\n        return \"No\";\n\n    return \"Yes\";\n}\n", "py_code": "def file_name_check(file_name):\n    # Check if there is exactly one dot in the filename\n    if file_name.count('.') != 1:\n        return \"No\"\n    \n    # Split the filename into two parts: before and after the dot\n    name_parts = file_name.split('.')\n    \n    # Validate the part before the dot\n    if not (name_parts[0] and name_parts[0][0].isalpha() and sum(c.isdigit() for c in name_parts[0]) <= 3):\n        return \"No\"\n    \n    # Validate the part after the dot\n    valid_extensions = {\"txt\", \"exe\", \"dll\"}\n    if name_parts[1] not in valid_extensions:\n        return \"No\"\n\n    return \"Yes\"\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `file_name_check` is designed to validate a file name based on specific criteria. The function takes a string representing a filename and returns \"Yes\" if the filename meets all validation conditions or \"No\" otherwise.\n\n1. **Dot Count Check**: The first condition checks whether there is exactly one dot in the filename using `file_name.count('.') != 1`. If not, it immediately returns \"No\".\n2. **Splitting the Filename**: The function splits the filename into two parts: before and after the dot using `name_parts = file_name.split('.')`.\n3. **Validation of Name Before Dot**:\n   - It checks if the part before the dot is non-empty.\n   - Ensures that it starts with a letter from the Latin alphabet by checking `name_parts[0][0].isalpha()`.\n   - Verifies that there are no more than three digits in this substring using `sum(c.isdigit() for c in name_parts[0]) <= 3`.\n4. **Validation of Name After Dot**: The function checks if the part after the dot is one of the valid extensions (\"txt\", \"exe\", or \"dll\") by checking membership in a set `valid_extensions`.\n\nIf all conditions are met, the function returns \"Yes\"; otherwise, it returns \"No\".\n\n"}
{"task_id": "CPP/123", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> get_odd_collatz(int n) {\n    vector<int> sequence;\n    while (n != 1) {\n        sequence.push_back(n);\n        if (n % 2 == 0) {\n            n /= 2;\n        } else {\n            n = 3 * n + 1;\n        }\n    }\n    sequence.push_back(1); // Adding the final term, which is always 1.\n\n    vector<int> odd_numbers;\n    for (int num : sequence) {\n        if (num % 2 != 0) {\n            odd_numbers.push_back(num);\n        }\n    }\n\n    sort(odd_numbers.begin(), odd_numbers.end());\n    return odd_numbers;\n}\n", "py_code": "def get_odd_collatz(n):\n    sequence = []\n    while n != 1:\n        sequence.append(n)\n        if n % 2 == 0:\n            n //= 2\n        else:\n            n = 3 * n + 1\n    sequence.append(1)  # Adding the final term, which is always 1.\n    \n    odd_numbers = [num for num in sequence if num % 2 != 0]\n    return sorted(odd_numbers)\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `get_odd_collatz` generates a Collatz sequence for a given positive integer `n`. The Collatz sequence is constructed by repeatedly applying the following rules: if the current number `n` is even, divide it by 2; if `n` is odd, multiply it by 3 and add 1. This process continues until `n` becomes 1.\n\nThe function maintains a list called `sequence`, which stores all numbers in the Collatz sequence up to (and including) the number 1. After constructing the full sequence, the function filters out only the odd numbers from this sequence using a list comprehension and returns them sorted in increasing order.\n\nThis approach ensures that we capture all odd numbers in the Collatz sequence for `n` and return them in a sorted vector as required by the problem statement.```\n\n"}
{"task_id": "CPP/148", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <algorithm> // for std::sort\nusing namespace std;\n\nvector<string> bf(string planet1, string planet2) {\n    vector<string> planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n    \n    auto it1 = find(planets.begin(), planets.end(), planet1);\n    auto it2 = find(planets.begin(), planets.end(), planet2);\n\n    if (it1 == planets.end() || it2 == planets.end()) {\n        return {}; // Return an empty vector if either planet is not found\n    }\n\n    int index1 = distance(planets.begin(), it1);\n    int index2 = distance(planets.begin(), it2);\n\n    int start_index = min(index1, index2) + 1;\n    int end_index = max(index1, index2);\n\n    vector<string> result;\n\n    for (int i = start_index; i < end_index; ++i) {\n        result.push_back(planets[i]);\n    }\n\n    return result;\n}\n", "py_code": "def bf(planet1: str, planet2: str) -> list:\n    planets = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n    \n    # Check if both planets are valid\n    if planet1 not in planets or planet2 not in planets:\n        return []\n    \n    index1, index2 = planets.index(planet1), planets.index(planet2)\n    \n    # Ensure the indices are sorted for slicing\n    start_index, end_index = min(index1, index2) + 1, max(index1, index2)\n    \n    return planets[start_index:end_index]\n```\n\n", "py_summary": "### Second Step: Analyse the Python Code\n\nThe provided Python function `bf` takes two strings as input parameters representing planet names and returns a list of strings containing the names of planets that are located between the orbits of these two given planets.\n\n1. **Initialization**: The function starts by defining a list named `planets`, which contains all eight planets in our solar system, ordered from closest to farthest from the Sun.\n   \n2. **Validation Check**: It checks if both input planet names (`planet1` and `planet2`) are valid (i.e., they exist within the predefined `planets` list). If either of them is not found in this list, an empty list is returned immediately.\n\n3. **Index Calculation**: The function then calculates the indices of the two given planets in the `planets` list using the `.index()` method. These indices are stored in variables `index1` and `index2`.\n\n4. **Sorting Indices for Slicing**: To ensure that slicing works correctly, it determines which index is smaller (`start_index`) and which one is larger (`end_index`). The `+ 1` adjustment on `min(index1, index2)` ensures that the starting planet itself is not included in the result.\n\n5. **Return Result**: Finally, the function returns a slice of the `planets` list from `start_index` to `end_index`, which contains all planets located between the orbits of `planet1` and `planet2`.\n\nThis approach guarantees that the returned list is sorted by proximity to the Sun and only includes valid planet names.\n\n"}
{"task_id": "CPP/133", "generation": "#include <stdio.h>\n#include <math.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint sum_squares(vector<float> lst) {\n    int sum = 0;\n    for (float num : lst) {\n        float ceil_num = ceil(num);\n        sum += static_cast<int>(ceil_num * ceil_num);\n    }\n    return sum;\n}\n", "py_code": "from math import ceil\n\ndef sum_squares(lst):\n    return sum(ceil(x) ** 2 for x in lst)\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `sum_squares` takes a list of numbers (`lst`) as input and returns the sum of the squares of each number after rounding up to the nearest integer (ceiling). The function uses a generator expression within the `sum()` function to iterate over each element in the list, apply the ceiling operation using `ceil()`, square it, and then sum all these squared values. This approach ensures that each number is rounded up before squaring and adding to the total sum.```\n\n"}
{"task_id": "CPP/109", "generation": "#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nbool move_one_ball(vector<int> arr) {\n    // Check if the array is empty\n    if (arr.empty()) return true;\n    \n    int n = arr.size();\n    bool found_split_point = false;\n    int split_index = -1;\n\n    // Find a potential split point where the order breaks\n    for (int i = 0; i < n - 1; ++i) {\n        if (arr[i] > arr[i + 1]) {\n            if (!found_split_point) {\n                found_split_point = true;\n                split_index = i;\n            } else {\n                // More than one break point, cannot be sorted by rotation\n                return false;\n            }\n        }\n    }\n\n    // If no split point is found, the array is already sorted\n    if (!found_split_point) return true;\n\n    // Check if the last element is less than or equal to the first element\n    if (arr[n - 1] > arr[0]) {\n        return false;\n    }\n\n    // Verify that all elements after the split point are in non-decreasing order\n    for (int i = split_index + 1; i < n - 1; ++i) {\n        if (arr[i] > arr[i + 1]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n", "py_code": "def move_one_ball(arr):\n    if not arr:  # If the array is empty, return True.\n        return True\n    \n    n = len(arr)\n    \n    # Find the index where the array would be split into two sorted parts.\n    for i in range(n - 1):\n        if arr[i] > arr[i + 1]:\n            break\n    else:\n        # If no such point is found, the array is already sorted.\n        return True\n    \n    # Check if the second part of the array and the first element form a valid rotation.\n    if arr[-1] <= arr[0]:\n        for j in range(i + 1, n - 1):\n            if arr[j] > arr[j + 1]:\n                return False\n        return True\n    \n    return False\n```\n\n", "py_summary": "### Analysis of the Python Code:\n\nThe provided Python function `move_one_ball` checks whether it is possible to sort a given list (`arr`) in non-decreasing order by performing right shift operations.\n\n1. **Empty List Check**: The function first checks if the input list `arr` is empty, and if so, returns `True`. An empty list is considered sorted.\n   \n2. **Finding Split Point**: It then iterates through the list to find an index where the elements are no longer in non-decreasing order (i.e., `arr[i] > arr[i + 1]`). This identifies a potential split point that could be used for rotation.\n\n3. **Checking Valid Rotation**:\n   - If such a split is found, it checks whether the last element of the list (`arr[-1]`) is less than or equal to the first element (`arr[0]`), which would indicate a valid rotation.\n   - It then verifies that all elements after the identified split point are in non-decreasing order.\n\n4. **Return Result**: If both conditions are satisfied, it returns `True`, indicating that the list can be sorted by performing right shift operations; otherwise, it returns `False`.\n\n"}
{"task_id": "CPP/100", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nvector<int> make_a_pile(int n) {\n    vector<int> stones;\n    int current_stones = n;\n    for (int i = 0; i < n; ++i) {\n        stones.push_back(current_stones);\n        // Increment by 2 to get the next odd or even number\n        current_stones += 2;\n    }\n    return stones;\n}\n", "py_code": "def make_a_pile(n):\n    stones = []\n    current_stones = n\n    for _ in range(n):\n        stones.append(current_stones)\n        if n % 2 == 0:  # If n is even\n            current_stones += 2  # Next even number\n        else:  # If n is odd\n            current_stones += 2  # Next odd number\n    return stones\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `make_a_pile` takes a positive integer `n` and returns a list representing the number of stones in each level of a pile with `n` levels. The first level has `n` stones. For subsequent levels, if `n` is even, the next level will have the next even number of stones; if `n` is odd, it will have the next odd number of stones.\n\nThe function initializes an empty list `stones` and a variable `current_stones` set to `n`. It then iterates `n` times. In each iteration, it appends `current_stones` to the `stones` list and increments `current_stones` by 2 (regardless of whether `n` is even or odd). This ensures that the next number added will be either the next even or odd number as required.\n\nFinally, the function returns the `stones` list.```\n\n"}
{"task_id": "CPP/150", "generation": "#include <cmath>\nusing namespace std;\n\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    for (int i = 2; i <= sqrt(num); ++i) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\nint x_or_y(int n, int x, int y) {\n    if (is_prime(n)) {\n        return x;\n    } else {\n        return y;\n    }\n}\n", "py_code": "def is_prime(num):\n    if num <= 1:\n        return False\n    for i in range(2, int(num**0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef x_or_y(n, x, y):\n    if is_prime(n):\n        return x\n    else:\n        return y\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python solution consists of two functions: `is_prime` and `x_or_y`. \n\n1. The `is_prime(num)` function checks whether a given number `num` is prime or not. It returns `False` if the number is less than or equal to 1 (since primes are greater than 1). Then, it iterates from 2 up to the square root of `num`. If any number in this range divides `num`, then `num` is not a prime and the function returns `False`. Otherwise, it returns `True`.\n\n2. The `x_or_y(n, x, y)` function takes three arguments: an integer `n`, and two integers `x` and `y`. It uses the `is_prime` function to check if `n` is a prime number. If `n` is prime, it returns `x`; otherwise, it returns `y`.\n\nThis approach ensures that we correctly determine whether `n` is prime and return the appropriate value based on this determination.\n\n"}
{"task_id": "CPP/153", "generation": "#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nstring Strongest_Extension(string class_name, vector<string> extensions) {\n    int max_strength = INT_MIN;\n    string strongest_ext = \"\";\n\n    for (const auto& ext : extensions) {\n        int cap = count_if(ext.begin(), ext.end(), ::isupper);\n        int sm = count_if(ext.begin(), ext.end(), ::islower);\n        int strength = cap - sm;\n\n        if (strength > max_strength || \n            (strength == max_strength && &ext < &extensions.front() + extensions.size())) {\n            strongest_ext = ext;\n            max_strength = strength;\n        }\n    }\n\n    return class_name + \".\" + strongest_ext;\n}\n", "py_code": "def strongest_extension(class_name, extensions):\n    max_strength = float('-inf')\n    strongest_ext = \"\"\n    \n    for ext in extensions:\n        cap = sum(1 for c in ext if c.isupper())\n        sm = sum(1 for c in ext if c.islower())\n        strength = cap - sm\n        \n        if strength > max_strength or (strength == max_strength and extensions.index(ext) < extensions.index(strongest_ext)):\n            strongest_ext = ext\n            max_strength = strength\n            \n    return f\"{class_name}.{strongest_ext}\"\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `strongest_extension` takes a class name and a list of extension names as input and returns the strongest extension appended to the class name in the format \"ClassName.StrongestExtensionName\". The strength of an extension is calculated based on the difference between the number of uppercase letters (CAP) and lowercase letters (SM) in its name.\n\nThe function iterates through each extension, calculating its strength by counting the number of uppercase and lowercase characters. It then compares this strength to the current maximum strength found so far (`max_strength`). If the new extension's strength is greater than `max_strength`, or if it has the same strength but comes earlier in the list (to handle ties), the function updates `strongest_ext` with the name of this extension and sets `max_strength` to its strength.\n\nFinally, the function returns a string concatenating the class name and the strongest extension found.```\n\n"}
{"task_id": "CPP/107", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nbool is_palindrome(int num) {\n    string str_num = to_string(num);\n    string reversed_str_num = str_num;\n    reverse(reversed_str_num.begin(), reversed_str_num.end());\n    return str_num == reversed_str_num;\n}\n\nvector<int> even_odd_palindrome(int n){\n    int even_count = 0, odd_count = 0;\n\n    for (int i = 1; i <= n; ++i) {\n        if (is_palindrome(i)) {\n            if (i % 2 == 0) {\n                even_count += 1;\n            } else {\n                odd_count += 1;\n            }\n        }\n    }\n\n    return {even_count, odd_count};\n}\n", "py_code": "def is_palindrome(num):\n    return str(num) == str(num)[::-1]\n\ndef even_odd_palindrome(n):\n    even_count = 0\n    odd_count = 0\n    \n    for i in range(1, n + 1):\n        if is_palindrome(i):\n            if i % 2 == 0:\n                even_count += 1\n            else:\n                odd_count += 1\n                \n    return (even_count, odd_count)\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `even_odd_palindrome(n)` calculates and returns a tuple containing the count of even and odd integer palindromes within the range from 1 to n (inclusive). The function first defines an auxiliary function `is_palindrome(num)` that checks if a given number is a palindrome by comparing its string representation with its reversed string.\n\nThe main function iterates over all integers in the specified range. For each integer, it uses the `is_palindrome` function to check whether the integer is a palindrome. If it is, the function then determines whether the palindrome is even or odd and increments the respective counter (`even_count` for even palindromes and `odd_count` for odd palindromes). Finally, the function returns a tuple with these two counts.\n\nThis approach ensures that all integers within the range are checked for being both palindromic and either even or odd, and it correctly accumulates the counts of each category.\n```\n\n<|im_start|>\n<|im_start|>user\n"}
{"task_id": "CPP/110", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nstring exchange(vector<int> lst1, vector<int> lst2) {\n    int odd_count = 0;\n    \n    // Count the number of odd elements in lst1.\n    for (int num : lst1) {\n        if (num % 2 != 0) {\n            ++odd_count;\n        }\n    }\n\n    int even_in_lst2_count = 0;\n\n    // Count the number of even elements in lst2.\n    for (int num : lst2) {\n        if (num % 2 == 0) {\n            ++even_in_lst2_count;\n        }\n    }\n\n    // Check if there are enough even numbers in lst2 to exchange with odd numbers in lst1.\n    return (even_in_lst2_count >= odd_count) ? \"YES\" : \"NO\";\n}\n", "py_code": "from typing import List\n\ndef exchange(lst1: List[int], lst2: List[int]) -> str:\n    odd_count = sum(x % 2 != 0 for x in lst1)\n    even_in_lst2 = [x for x in lst2 if x % 2 == 0]\n    \n    return \"YES\" if len(even_in_lst2) >= odd_count else \"NO\"\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `exchange` takes two lists of integers as input and determines whether it is possible to exchange elements between them so that all elements in the first list (`lst1`) become even numbers. The function starts by counting the number of odd elements in `lst1`. It then creates a new list, `even_in_lst2`, containing only the even numbers from `lst2`.\n\nThe logic behind this approach is to check if there are enough even numbers in `lst2` that can be exchanged with the odd numbers in `lst1`. If the number of even elements in `lst2` is greater than or equal to the count of odd elements in `lst1`, it means we have sufficient even numbers to replace all odd numbers in `lst1`, making all its elements even. In this case, the function returns \"YES\". Otherwise, if there are not enough even numbers in `lst2`, it returns \"NO\" indicating that it is impossible to make all elements of `lst1` even through exchanges.\n```"}
{"task_id": "CPP/111", "generation": "#include <iostream>\n#include <string>\n#include <map>\n#include <sstream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nmap<char, int> histogram(string test) {\n    map<char, int> counts;\n    \n    // Check if the input string is empty.\n    if (test.empty()) {\n        return {};\n    }\n    \n    // Splitting the string into individual characters and counting their occurrences\n    stringstream ss(test);\n    char ch;\n    while (ss >> ch) {\n        ++counts[ch];\n    }\n\n    // Finding the maximum count of any character\n    int max_count = 0;\n    for (const auto& pair : counts) {\n        if (pair.second > max_count) {\n            max_count = pair.second;\n        }\n    }\n\n    // Filtering out the characters that have the maximum count\n    map<char, int> result;\n    for (const auto& pair : counts) {\n        if (pair.second == max_count) {\n            result.insert(pair);\n        }\n    }\n\n    return result;\n}\n", "py_code": "from collections import Counter\n\ndef histogram(test):\n    if not test:\n        return {}\n    \n    # Splitting the string into individual characters and counting their occurrences\n    counts = Counter(test.split())\n    \n    # Finding the maximum count of any character\n    max_count = max(counts.values(), default=0)\n    \n    # Filtering out the characters that have the maximum count\n    result = {char: count for char, count in counts.items() if count == max_count}\n    \n    return result\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `histogram` takes a string of space-separated lowercase letters and returns a dictionary containing the letter(s) with the highest frequency along with their counts. If the input string is empty, it returns an empty dictionary.\n\n1. The function first checks if the input string `test` is empty. If so, it immediately returns an empty dictionary.\n2. It then splits the string into individual characters and uses the `Counter` class from the `collections` module to count the occurrences of each character.\n3. Next, it determines the maximum occurrence (`max_count`) among all characters using the `max()` function on the values of the counter dictionary.\n4. Finally, it constructs a new dictionary containing only those characters whose counts match the `max_count`. This is achieved by filtering through the items in the counter dictionary and including them if their count equals `max_count`.\n5. The resulting dictionary is returned as output.\n\nThis approach ensures that all letters with the highest frequency are included in the result, even when there's a tie for the maximum occurrence.\n```\n\n"}
{"task_id": "CPP/80", "generation": "#include <string>\nusing namespace std;\n\nbool is_happy(string s) {\n    if (s.length() < 3) return false;\n    for (size_t i = 0; i <= s.length() - 3; ++i) {\n        if (s[i] == s[i+1] || s[i] == s[i+2] || s[i+1] == s[i+2]) {\n            return false;\n        }\n    }\n    return true;\n}\n", "py_code": "def is_happy(s):\n    if len(s) < 3:\n        return False\n    for i in range(len(s) - 2):\n        if s[i] == s[i+1] or s[i] == s[i+2] or s[i+1] == s[i+2]:\n            return False\n    return True\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `is_happy` checks if a given string `s` is \"happy\" according to the defined criteria. The function first checks if the length of the string is less than 3; if so, it immediately returns `False`, as strings shorter than three characters cannot be happy by definition.\n\nIf the string has at least three characters, the function iterates through each character in the string up to the third last one (i.e., `len(s) - 2`). For each position `i` within this range, it checks if any of the three consecutive characters (`s[i]`, `s[i+1]`, and `s[i+2]`) are equal. If they are not all distinct, the function returns `False`.\n\nIf no such triplet is found where any two characters are the same, the function concludes that every set of three consecutive letters in the string are distinct and thus returns `True`.```"}
{"task_id": "CPP/41", "generation": "#include<stdio.h>\nusing namespace std;\n\nint car_race_collision(int n) {\n    // Since all cars are moving at the same speed and there are equal numbers of cars \n    // going in opposite directions, each car from one direction will eventually collide with a car from the other direction.\n    return n;\n}\n", "py_code": "def car_race_collision(n):\n    # Since all cars are moving at the same speed and there are equal numbers of cars \n    # going in opposite directions, each car from one direction will eventually collide with a car from the other direction.\n    return n\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `car_race_collision` takes an integer `n`, which represents the number of cars driving in each direction on a straight infinitely long road. The problem states that there are `n` cars moving left to right and another set of `n` cars moving right to left at the same speed, and all these cars will eventually collide with one car from the opposite direction due to their constant speed and infinite durability.\n\nThe function simply returns `n`, as each car in one direction is guaranteed to collide with exactly one car coming from the opposite direction. Therefore, the total number of collisions will be equal to the number of cars in either direction (which is `n`).```\n\n\n"}
{"task_id": "CPP/116", "generation": "#include <stdio.h>\n#include <math.h>\n#include <vector>\n#include <algorithm>\n#include <bitset>\nusing namespace std;\n\nint count_ones(int n) {\n    return bitset<32>(abs(n)).count();\n}\n\nbool custom_compare(int a, int b) {\n    int ones_a = count_ones(a);\n    int ones_b = count_ones(b);\n    if (ones_a == ones_b) {\n        return a < b;\n    }\n    return ones_a < ones_b;\n}\n\nvector<int> sort_array(vector<int> arr) {\n    sort(arr.begin(), arr.end(), custom_compare);\n    return arr;\n}\n", "py_code": "from typing import List\n\ndef count_ones(n: int) -> int:\n    return bin(abs(n)).count('1')\n\ndef sort_array(arr: List[int]) -> List[int]:\n    return sorted(arr, key=lambda x: (count_ones(x), x))\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python code defines a function `sort_array` that takes a list of integers as input and returns a sorted version of this list based on two criteria: first by the number of ones in their binary representation (using the helper function `count_ones`) and then by their decimal value. The `count_ones` function converts each integer to its absolute binary form, counts the number of '1's, and returns that count. The main function uses Python's built-in `sorted()` function with a custom key that sorts elements based on the tuple `(number_of_ones, original_number)`. This ensures that numbers are primarily sorted by their binary ones count and secondarily by their decimal value if they have the same number of ones in their binary representation.```\n\n"}
{"task_id": "CPP/61", "generation": "#include <string>\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    int balance = 0;\n    for (char c : brackets) {\n        if (c == '(') {\n            balance += 1;\n        } else if (c == ')') {\n            balance -= 1;\n        }\n        if (balance < 0) {\n            return false;\n        }\n    }\n    return balance == 0;\n}\n", "py_code": "def correct_bracketing(brackets):\n    balance = 0\n    for char in brackets:\n        if char == '(':\n            balance += 1\n        elif char == ')':\n            balance -= 1\n        if balance < 0:\n            return False\n    return balance == 0\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `correct_bracketing` takes a string of parentheses as input and checks if every opening parenthesis '(' has a corresponding closing parenthesis ')'. It uses a variable named `balance` to keep track of the difference between the number of opening and closing brackets encountered so far. \n\nFor each character in the string:\n- If it is an opening bracket '(', the balance is incremented by 1.\n- If it is a closing bracket ')', the balance is decremented by 1.\n\nIf at any point, the `balance` becomes negative, this means there are more closing brackets than opening ones before that point, which makes the string invalid. The function returns `False` in such cases.\n\nAfter processing all characters, if the final value of `balance` is zero, it indicates that every opening bracket has a corresponding closing bracket and the function returns `True`. Otherwise, it returns `False`.\n\n"}
{"task_id": "CPP/25", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nvector<int> factorize(int n) {\n    vector<int> factors;\n    for (int i = 2; i * i <= n; ++i) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n    if (n > 1) {\n        factors.push_back(n);\n    }\n    return factors;\n}\n", "py_code": "def factorize(n):\n    i = 2\n    factors = []\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            factors.append(i)\n    if n > 1:\n        factors.append(n)\n    return factors\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `factorize` takes an integer `n` and returns a list of its prime factors in ascending order. The algorithm works as follows:\n1. Initialize a variable `i` to 2, which is the smallest prime number.\n2. Use a while loop that continues until `i * i > n`. This ensures that we only check up to the square root of `n`, optimizing the search for factors.\n3. Inside the loop, if `n % i != 0`, it means `i` is not a factor of `n`, so increment `i`.\n4. If `i` is a factor of `n`, divide `n` by `i` and append `i` to the list of factors.\n5. After exiting the loop, if `n > 1`, it implies that there's still a prime factor left (greater than the square root of the original number), so we add this remaining factor to the list.\n\nThe function returns the list of prime factors in ascending order as required by the problem statement.\n\n"}
{"task_id": "CPP/137", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <boost/any.hpp>\nusing namespace std;\n\n// Function to convert a string with either '.' or ',' as the decimal separator into a float.\nfloat parse_float(const string& str) {\n    string temp = str;\n    replace(temp.begin(), temp.end(), ',', '.');\n    return stof(temp);\n}\n\n// Main comparison function\nboost::any compare_one(boost::any a, boost::any b) {\n    // Convert both inputs to strings for uniform processing.\n    std::string a_str = boost::any_cast<std::string>(a);\n    if (a_str.empty()) {\n        try {\n            int a_int = boost::any_cast<int>(a);\n            a_str = std::to_string(a_int);\n        } catch (...) {}\n        \n        try {\n            float a_float = boost::any_cast<float>(a);\n            a_str = std::to_string(a_float);\n        } catch (...) {}\n    }\n\n    std::string b_str = boost::any_cast<std::string>(b);\n    if (b_str.empty()) {\n        try {\n            int b_int = boost::any_cast<int>(b);\n            b_str = std::to_string(b_int);\n        } catch (...) {}\n\n        try {\n            float b_float = boost::any_cast<float>(b);\n            b_str = std::to_string(b_float);\n        } catch (...) {}\n    }\n\n    // Parse the strings to floats for comparison.\n    float a_val = parse_float(a_str);\n    float b_val = parse_float(b_str);\n\n    if (a_val == b_val) {\n        return \"None\";\n    }\n    \n    if (a_val > b_val) {\n        try {\n            int a_int = boost::any_cast<int>(a);\n            return a;\n        } catch (...) {}\n        \n        try {\n            float a_float = boost::any_cast<float>(a);\n            return a;\n        } catch (...) {}\n\n        return a_str; // Return the original string if it was passed as input.\n    }\n\n    try {\n        int b_int = boost::any_cast<int>(b);\n        return b;\n    } catch (...) {}\n    \n    try {\n        float b_float = boost::any_cast<float>(b);\n        return b;\n    } catch (...) {}\n\n    return b_str; // Return the original string if it was passed as input.\n}\n\n", "py_code": "def compare_one(a, b):\n    # Convert string representations of numbers with ',' to '.'\n    if isinstance(a, str) and ',' in a:\n        a = float(a.replace(',', '.'))\n    if isinstance(b, str) and ',' in b:\n        b = float(b.replace(',', '.'))\n\n    # Compare the values\n    if isinstance(a, (int, float)) and isinstance(b, (int, float)):\n        return max(a, b)\n    elif isinstance(a, str) or isinstance(b, str):\n        a_val = float(str(a).replace(',', '.'))\n        b_val = float(str(b).replace(',', '.'))\n        if a_val > b_val:\n            return a\n        elif b_val > a_val:\n            return b\n        else:\n            return \"None\"\n    else:\n        return \"None\"\n\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `compare_one(a, b)` is designed to compare two inputs that can be integers, floats, or strings representing real numbers (with decimal points represented by either '.' or ','). The goal of this function is to return the larger value in its original type. If both values are equal, it returns \"None\".\n\n1. **String Conversion**: \n   - First, the function checks if `a` and/or `b` are strings containing a comma (',') as the decimal separator. It replaces any commas with periods ('.') to ensure that they can be converted to floats.\n   \n2. **Comparison**:\n   - If both inputs are integers or floats, it uses Python's built-in `max()` function to determine and return the larger value.\n   - If either input is a string (after conversion), the function converts both values to floats for comparison purposes but returns the original string representation of the larger number. \n   \n3. **Equality Check**:\n   - If after converting strings to floats, both numbers are found to be equal, it returns \"None\".\n\n4. **Fallback**:\n   - In cases where inputs cannot be directly compared (e.g., mixed types that do not conform to expected numeric formats), the function also defaults to returning \"None\".\n\nThis approach ensures that the original type of the larger value is preserved and handles various input formats effectively.\n\n"}
{"task_id": "CPP/102", "generation": "#include <stdio.h>\n\nint choose_num(int x, int y) {\n    if (x > y) {\n        return -1;\n    }\n    // Start from y and go down until we find an even number or reach below x.\n    for (int num = y; num >= x; --num) {\n        if (num % 2 == 0) {\n            return num;\n        }\n    }\n    return -1;\n}\n", "py_code": "def choose_num(x, y):\n    if x > y:\n        return -1\n    # Start from y and go down until we find an even number or reach below x.\n    for num in range(y, x-1, -1):\n        if num % 2 == 0:\n            return num\n    return -1\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `choose_num` takes two positive integers `x` and `y`, and returns the largest even integer within the range `[x, y]`. If no such number exists (i.e., if `x > y`), it returns `-1`.\n\nHere's a breakdown of how the function works:\n- The function first checks whether `x` is greater than `y`. If so, it immediately returns `-1`, as there can't be any numbers in an invalid range.\n- It then iterates from `y` down to `x` (inclusive) and checks each number to see if it's even (`num % 2 == 0`). The first even number found is returned.\n- If no even number is found within the specified range, `-1` is returned.\n\nThis approach ensures that we find the largest possible even integer in the given range or return `-1` if there are none. \n\n"}
{"task_id": "CPP/10", "generation": "#include <string>\nusing namespace std;\n\nbool is_palindrome(string str) {\n    string s(str.rbegin(), str.rend());\n    return s == str;\n}\n\nstring make_palindrome(string str) {\n    if (str.length() == 0) {\n        return \"\";\n    }\n\n    for (size_t i = 0; i < str.length(); ++i) {\n        string suffix = str.substr(i);\n        if (is_palindrome(suffix)) {\n            string prefix_to_reverse = str.substr(0, i);\n            reverse(prefix_to_reverse.begin(), prefix_to_reverse.end());\n            return str + prefix_to_reverse;\n        }\n    }\n\n    // In case no palindrome is found, which should not happen due to the loop logic\n    return \"\";\n}\n", "py_code": "def is_palindrome(s):\n    return s == s[::-1]\n\ndef make_palindrome(str):\n    if len(str) == 0:\n        return \"\"\n    \n    for i in range(len(str)):\n        suffix = str[i:]\n        if is_palindrome(suffix):\n            prefix_to_reverse = str[:i]\n            return str + prefix_to_reverse[::-1]\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python solution consists of two functions: `is_palindrome` and `make_palindrome`. The `is_palindrome` function checks if a given string is a palindrome by comparing it to its reverse.\n\nThe `make_palindrome` function aims to find the shortest palindrome that starts with the supplied string. It does so by iterating over each character in the input string, checking for the longest postfix (suffix) of the string that forms a palindrome using the `is_palindrome` function. Once such a suffix is found, it takes the prefix before this palindromic suffix and appends its reverse to the end of the original string, thus forming the shortest possible palindrome starting with the input string.\n\nIf no palindromic suffix is found (which would be the case for an empty string), the function returns an empty string.```\n\n"}
{"task_id": "CPP/76", "generation": "#include <cmath>\nusing namespace std;\n\nbool is_simple_power(int x, int n) {\n    if (n == 1) {\n        return x == 1;\n    }\n    int power = 1;\n    while (power < x) {\n        power *= n;\n    }\n    return power == x;\n}\n", "py_code": "def is_simple_power(x, n):\n    if n == 1:\n        return x == 1\n    power = 1\n    while power < x:\n        power *= n\n    return power == x\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `is_simple_power(x, n)` checks whether a number `x` is a simple power of another number `n`. A number `x` is considered to be a simple power of `n` if there exists an integer such that raising `n` to this integer equals `x`.\n\n1. The function first handles the special case where `n` is 1, returning `True` only if `x` is also 1 (since any other value for `x` cannot be a power of 1).\n2. It initializes a variable `power` to 1.\n3. In a loop, it multiplies `power` by `n` until `power` becomes greater than or equal to `x`.\n4. After exiting the loop, it checks if `power` is exactly equal to `x`. If so, `x` is a simple power of `n`, and the function returns `True`; otherwise, it returns `False`.\n\nThis approach ensures that we only consider integer powers of `n` and correctly identifies whether `x` can be expressed as such.\n\n"}
{"task_id": "CPP/94", "generation": "#include <vector>\n#include <string>\nusing namespace std;\n\nbool is_prime(int n) {\n    if (n <= 1)\n        return false;\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0)\n            return false;\n    }\n    return true;\n}\n\nint sum_of_digits(int n) {\n    int sum = 0;\n    while (n > 0) {\n        sum += n % 10;\n        n /= 10;\n    }\n    return sum;\n}\n\nint skjkasdkd(vector<int> lst) {\n    int max_prime = -1;\n    for (auto num : lst) {\n        if (is_prime(num)) {\n            max_prime = max(max_prime, num);\n        }\n    }\n\n    if (max_prime == -1)\n        return 0;\n\n    return sum_of_digits(max_prime);\n}\n", "py_code": "from typing import List\n\ndef is_prime(n: int) -> bool:\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef sum_of_digits(n: int) -> int:\n    return sum(int(digit) for digit in str(n))\n\ndef skjkasdkd(lst: List[int]) -> int:\n    max_prime = -1\n    for num in lst:\n        if is_prime(num):\n            max_prime = max(max_prime, num)\n    \n    if max_prime == -1:\n        return 0\n    \n    return sum_of_digits(max_prime)\n```\n\n", "py_summary": "### Second Step: Analyse the Python Code\n\nThe provided Python function `skjkasdkd` aims to find the largest prime number in a given list of integers and return the sum of its digits.\n\n1. **Helper Function - `is_prime(n)`**: This function checks if a number `n` is prime by iterating from 2 up to the square root of `n`. If any divisor exists, it returns `False`; otherwise, it returns `True`.\n\n2. **Helper Function - `sum_of_digits(n)`**: This function calculates and returns the sum of digits of an integer `n` by converting the number into a string, iterating over each character (digit), converting them back to integers, and summing them up.\n\n3. **Main Function - `skjkasdkd(lst)`**:\n   - The main function iterates through each element in the list `lst`.\n   - For each element, it checks if the number is prime using the `is_prime` helper function.\n   - If a number is found to be prime and greater than the current maximum prime (`max_prime`), it updates `max_prime`.\n\n4. After iterating through all elements:\n   - If no prime numbers were found (i.e., `max_prime` remains `-1`), the function returns `0`.\n   - Otherwise, it calculates the sum of digits of the largest prime number using the `sum_of_digits` helper function and returns this value.\n\nThis approach ensures that we efficiently find the largest prime in the list and compute the required digit sum. \n\nNext, let's translate this logic into C++.\n```\n\n<|im_start|>assistant\n### Last Step: Generate C++ Solution\n\nBased on the Python code analysis, here is the equivalent C++ implementation:\n\n"}
{"task_id": "CPP/32", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<iostream>\nusing namespace std;\n\ndouble poly(vector<double> xs, double x) {\n    double sum = 0;\n    for (size_t i = 0; i < xs.size(); ++i)\n        sum += xs[i] * pow(x, i);\n    return sum;\n}\n\n// Simple bisection method to find a root\ndouble find_zero(vector<double> xs) {\n    if (xs.size() % 2 != 0 || xs.back() == 0) {\n        throw std::invalid_argument(\"Invalid input\");\n    }\n\n    double a = -1000, b = 1000;\n    double fa = poly(xs, a), fb = poly(xs, b);\n\n    if (fa * fb > 0)\n        throw std::runtime_error(\"No root found in the interval\");\n\n    while ((b - a) / 2.0 > 1e-6) {\n        double c = (a + b) / 2;\n        double fc = poly(xs, c);\n\n        if (fc == 0 || (b - a) / 2.0 < 1e-6)\n            return c;\n\n        if (fa * fc < 0)\n            b = c;\n        else\n            a = c, fa = fc;\n    }\n    return (a + b) / 2;\n}\n", "py_code": "from typing import List\n\n\ndef poly(xs: List[float], x: float) -> float:\n    return sum(coef * (x ** i) for i, coef in enumerate(xs))\n\n\ndef find_zero(xs: List[float]) -> float:\n    from scipy.optimize import root_scalar\n\n    # Define the polynomial function based on coefficients\n    def func(x):\n        return poly(xs, x)\n\n    # Use a numerical method to find a zero of the function\n    sol = root_scalar(func, bracket=[-1000, 1000], method='brentq')\n    \n    if sol.converged:\n        return sol.root\n    else:\n        raise ValueError(\"No solution found\")\n```\n\n", "py_summary": "### Second Step: Analyse the Python Code\n\nThe provided Python code consists of two functions:\n\n1. `poly(xs: List[float], x: float) -> float`: This function evaluates a polynomial with coefficients given in the list `xs` at a specific point `x`. It uses a generator expression within the `sum()` function to calculate the sum of each coefficient multiplied by `x` raised to its corresponding power.\n\n2. `find_zero(xs: List[float]) -> float`: This function aims to find a root (zero) of the polynomial defined by coefficients in `xs`. The function makes use of the `root_scalar` method from the `scipy.optimize` module, which is a numerical solver for finding roots of scalar functions.\n\n   - A helper function `func(x)` is defined inside `find_zero`, which calls the previously defined `poly(xs, x)` to evaluate the polynomial at point `x`.\n   \n   - The `root_scalar(func, bracket=[-1000, 1000], method='brentq')` call attempts to find a root of `func(x) = poly(xs, x)` within the interval [-1000, 1000] using Brent's method. This numerical approach is effective for finding roots of continuous functions.\n   \n   - If the solver converges (i.e., finds a solution), it returns the root. Otherwise, if no convergence occurs, an exception is raised indicating that no solution was found.\n\n### Note:\nThe Python code relies on `scipy`, which is not part of the standard library and needs to be installed separately (`pip install scipy`). Additionally, this approach assumes the polynomial has at least one real root within the bracketed interval. The assumption about even number coefficients and largest non-zero coefficient as stated in the problem description is implicitly handled by the numerical method used.\n\n### Last Step: Generate C++ Solution\n\nGiven that `scipy` does not have a direct equivalent in C++, we will use an iterative approach such as the bisection method to find the root. Here's how it can be implemented:\n\n"}
{"task_id": "CPP/33", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> sort_third(vector<int> l) {\n    vector<int> divisible_by_three;\n    \n    // Extract elements at indices divisible by 3 (1-indexed)\n    for(size_t i = 2; i < l.size(); i += 3) {\n        divisible_by_three.push_back(l[i]);\n    }\n    \n    // Sort these extracted elements\n    sort(divisible_by_three.begin(), divisible_by_three.end());\n    \n    // Replace the original values at indices divisible by three with the sorted ones\n    size_t j = 0;\n    for(size_t i = 2; i < l.size() && j < divisible_by_three.size(); i += 3, ++j) {\n        l[i] = divisible_by_three[j];\n    }\n    \n    return l;\n}\n", "py_code": "def sort_third(l):\n    # Extract elements at indices divisible by 3 (0-indexed)\n    divisible_by_three = [l[i] for i in range(len(l)) if (i+1) % 3 == 0]\n    \n    # Sort these extracted elements\n    sorted_divisible_by_three = sorted(divisible_by_three)\n\n    # Replace the original values at indices divisible by three with the sorted ones\n    j = 0\n    l_prime = []\n    for i in range(len(l)):\n        if (i+1) % 3 == 0:\n            l_prime.append(sorted_divisible_by_three[j])\n            j += 1\n        else:\n            l_prime.append(l[i])\n\n    return l_prime\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `sort_third` takes a list of integers `l` and returns a new list `l'`. The returned list is identical to the original list at indices that are not divisible by three (considering 1-indexed positions). For indices that are divisible by three, it replaces those elements with sorted values from their corresponding positions in the original list.\n\nHere's how the function works:\n1. It first extracts all elements whose index + 1 is divisible by 3 into a new list `divisible_by_three`.\n2. The extracted elements are then sorted to get `sorted_divisible_by_three`.\n3. A new list `l_prime` is created where elements at indices that are not divisible by three remain unchanged, and those at indices divisible by three (1-indexed) are replaced with the corresponding values from `sorted_divisible_by_three`.\n\nThis approach ensures that only the required elements are sorted while preserving the order of other elements in the list.\n\n"}
{"task_id": "CPP/88", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> sort_array(vector<int> array) {\n    if (array.empty() || array.size() == 1) {\n        return array;\n    }\n\n    int first = array.front();\n    int last = array.back();\n\n    // Determine sorting order based on sum of first and last elements\n    bool is_odd_sum = (first + last) % 2 != 0;\n\n    vector<int> sorted_array(array); // Copy the original array to avoid modifying it\n\n    if (is_odd_sum) {\n        sort(sorted_array.begin(), sorted_array.end()); // Sort in ascending order\n    } else {\n        sort(sorted_array.rbegin(), sorted_array.rend()); // Sort in descending order\n    }\n\n    return sorted_array;\n}\n", "py_code": "def sort_vector(array):\n    if not array or len(array) == 1:\n        return array\n\n    first = array[0]\n    last = array[-1]\n\n    # Determine sorting order based on sum of first and last elements\n    is_odd_sum = (first + last) % 2 != 0\n    sorted_array = sorted(array, reverse=not is_odd_sum)\n    \n    return sorted_array\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `sort_vector` takes a list of non-negative integers as input and returns a new list that is sorted based on a specific condition. The function first checks if the array is empty or contains only one element; in such cases, it simply returns the original array since no sorting is needed.\n\nFor arrays with more than one element, the function determines whether to sort the array in ascending or descending order by checking the sum of the first and last elements. If the sum is odd (`is_odd_sum` evaluates to `True`), the array will be sorted in ascending order; otherwise, it will be sorted in descending order.\n\nThe function uses Python's built-in `sorted()` function with a `reverse` parameter set based on the condition described above. The original array remains unchanged as the function returns a new list that is the result of sorting.\n```\n\n\n"}
{"task_id": "CPP/15", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring string_sequence(int n) {\n    string result = \"\";\n    for (int i = 0; i <= n; ++i) {\n        if (i != 0) {\n            result += \" \";\n        }\n        result += to_string(i);\n    }\n    return result;\n}\n", "py_code": "def string_sequence(n):\n    return \" \".join(str(i) for i in range(n + 1))\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `string_sequence` takes an integer `n` as input and returns a string containing space-delimited numbers starting from 0 up to n inclusive. The function uses a generator expression inside the `join()` method to convert each number in the range `[0, n]` into a string and concatenate them with spaces between each pair of adjacent strings. This approach efficiently constructs the desired output string without creating intermediate lists or performing multiple concatenations, which is more memory-efficient and faster for large values of `n`.```\n\n"}
{"task_id": "CPP/163", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> generate_integers(int a, int b) {\n    if (a > b) {\n        swap(a, b);\n    }\n\n    vector<int> even_digits = {0, 2, 4, 6, 8};\n    vector<int> result;\n\n    for (int num : even_digits) {\n        if (num >= a && num <= b) {\n            result.push_back(num);\n        }\n    }\n\n    sort(result.begin(), result.end());\n    return result;\n}\n", "py_code": "def generate_integers(a, b):\n    # Ensure that a is less than or equal to b for simplicity\n    if a > b:\n        a, b = b, a\n    \n    even_digits = {0, 2, 4, 6, 8}\n    result = set()\n    \n    for num in range(max(a, 0), min(b + 1, 10)):\n        if num in even_digits:\n            result.add(num)\n            \n    return sorted(list(result))\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `generate_integers(a, b)` is designed to generate a list of even digits (0, 2, 4, 6, and 8) that fall within the range `[a, b]` in ascending order. The function first ensures that `a` is less than or equal to `b` by swapping them if necessary.\n\nThe set `even_digits` contains all possible even digits (0 through 8). A result set is initialized to store unique even digits found within the specified range. \n\nA loop iterates over a range from `max(a, 0)` to `min(b + 1, 10)`, ensuring that only numbers between 0 and 9 are considered. For each number in this range, if it exists in the set of even_digits, it is added to the result set.\n\nFinally, the function converts the result set into a sorted list (to ensure ascending order) and returns it.\n\n"}
{"task_id": "CPP/1", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nvector<string> separate_paren_groups(string paren_string) {\n    // Remove spaces from the string.\n    paren_string.erase(remove(paren_string.begin(), paren_string.end(), ' '), paren_string.end());\n    \n    vector<string> result;\n    int balance = 0;\n    size_t start_index = 0;\n\n    for (size_t i = 0; i < paren_string.length(); ++i) {\n        if (paren_string[i] == '(') {\n            if (balance == 0) {\n                start_index = i;\n            }\n            balance += 1;\n        } else if (paren_string[i] == ')') {\n            balance -= 1;\n            if (balance == 0) {\n                result.push_back(paren_string.substr(start_index, i - start_index + 1));\n            }\n        }\n    }\n\n    return result;\n}\n", "py_code": "def separate_paren_groups(paren_string):\n    paren_string = paren_string.replace(\" \", \"\")\n    result = []\n    balance = 0\n    start_index = 0\n    \n    for i, char in enumerate(paren_string):\n        if char == '(':\n            if balance == 0:\n                start_index = i\n            balance += 1\n        elif char == ')':\n            balance -= 1\n            if balance == 0:\n                result.append(paren_string[start_index:i+1])\n    \n    return result\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `separate_paren_groups` takes a string containing multiple groups of nested parentheses and separates those groups into separate strings, returning them as a list.\n\n1. The input string is first stripped of any spaces using `replace(\" \", \"\")`.\n2. An empty list `result` is initialized to store the separated groups.\n3. A variable `balance` is used to keep track of the balance between opening and closing parentheses.\n4. Another variable `start_index` is used to mark the starting index of a new group whenever an unbalanced open parenthesis is encountered.\n5. The function iterates over each character in the string using a for loop with `enumerate()` to get both the index (`i`) and the character (`char`).\n6. If the current character is an opening parenthesis '(', it checks if `balance` is 0, indicating the start of a new group. It then increments the balance.\n7. If the current character is a closing parenthesis ')', it decrements the balance. When the balance becomes zero again after decrementing, it means that a complete and balanced group has been found from `start_index` to the current index (`i`). This group is appended to the result list.\n8. Finally, the function returns the list of separated groups.\n\n"}
{"task_id": "CPP/69", "generation": "#include <vector>\n#include <unordered_map>\n#include <algorithm>\nusing namespace std;\n\nint search(vector<int> lst) {\n    unordered_map<int, int> frequency;\n    \n    // Counting frequencies of each number in the list.\n    for (int num : lst) {\n        frequency[num]++;\n    }\n    \n    int max_value = -1;\n    \n    // Checking if any value meets the condition and updating max_value accordingly.\n    for (const auto& entry : frequency) {\n        if (entry.first <= entry.second && entry.first > max_value) {\n            max_value = entry.first;\n        }\n    }\n\n    return max_value;\n}\n", "py_code": "from collections import Counter\n\ndef search(lst):\n    frequency = Counter(lst)\n    max_value = -1\n    \n    for value in frequency:\n        if value <= frequency[value] and value > max_value:\n            max_value = value\n            \n    return max_value\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `search` takes a list of positive integers as input and returns the greatest integer that has a frequency greater than or equal to its value itself. The function first uses the `Counter` class from the `collections` module to count the occurrences (frequency) of each number in the list.\n\nIt then iterates through these counted values, checking if the current value is less than or equal to its frequency and also greater than the currently stored maximum value (`max_value`). If both conditions are met, it updates `max_value` with the current value. Finally, the function returns this `max_value`, which will be -1 if no such integer exists in the list.\n\nThis approach ensures that we find the greatest number whose frequency meets or exceeds its own value by leveraging the efficient counting and iteration capabilities provided by Python's collections module.\n\n\n"}
{"task_id": "CPP/31", "generation": "#include <cmath>\nusing namespace std;\n\nbool is_prime(long long n) {\n    if (n <= 1) {\n        return false;\n    }\n    for (long long i = 2; i <= sqrt(n); ++i) {\n        if (n % i == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n", "py_code": "def is_prime(n):\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `is_prime(n)` checks whether a given number `n` is prime or not. The function first handles edge cases by returning `False` if `n` is less than or equal to 1 since numbers less than or equal to 1 are not considered prime.\n\nFor other values of `n`, the function iterates from 2 up to the square root of `n` (inclusive). This is because a larger factor of `n` must be a multiple of a smaller factor that has already been checked. If any number in this range divides `n` evenly, then `n` is not prime and the function returns `False`. If no divisors are found within this range, the function concludes that `n` is prime and returns `True`.\n\n"}
{"task_id": "CPP/147", "generation": "#include <vector>\nusing namespace std;\n\nint get_max_triples(int n) {\n    vector<int> a(n);\n    for (int i = 1; i <= n; ++i) {\n        a[i-1] = i * i - i + 1;\n    }\n    \n    int count = 0;\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            for (int k = j + 1; k < n; ++k) {\n                if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                    count++;\n                }\n            }\n        }\n    }\n\n    return count;\n}\n", "py_code": "def get_max_triples(n):\n    a = [i * i - i + 1 for i in range(1, n+1)]\n    count = 0\n    for i in range(len(a)):\n        for j in range(i+1, len(a)):\n            for k in range(j+1, len(a)):\n                if (a[i] + a[j] + a[k]) % 3 == 0:\n                    count += 1\n    return count\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `get_max_triples` takes an integer `n` as input and calculates a list `a` where each element is defined by the formula \\(a_i = i^2 - i + 1\\). The function then iterates over all possible triples \\((i, j, k)\\) with \\(i < j < k\\) to check if the sum of elements at these indices in the array `a` is divisible by 3. If it is, a counter (`count`) is incremented.\n\nThe steps are as follows:\n1. Generate the list `a` where each element is calculated using the formula \\(a_i = i^2 - i + 1\\).\n2. Initialize a count variable to zero.\n3. Use three nested loops to iterate over all possible triples \\((i, j, k)\\) with \\(i < j < k\\) and check if their sum is divisible by 3.\n4. If the condition is met, increment the counter `count`.\n5. Return the final value of `count`.\n\nThis approach ensures that every valid triple is checked exactly once.\n\n"}
{"task_id": "CPP/105", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\nvector<string> by_length(vector<int> arr) {\n    // Filter out numbers that are not between 1 and 9 inclusive.\n    vector<int> filtered_arr;\n    for (int num : arr) {\n        if (num >= 1 && num <= 9) {\n            filtered_arr.push_back(num);\n        }\n    }\n\n    // Sort the filtered array.\n    sort(filtered_arr.begin(), filtered_arr.end());\n\n    // Reverse the sorted array.\n    reverse(filtered_arr.begin(), filtered_arr.end());\n\n    // Map each digit to its corresponding name.\n    map<int, string> number_names = {\n        {1, \"One\"}, {2, \"Two\"}, {3, \"Three\"},\n        {4, \"Four\"}, {5, \"Five\"}, {6, \"Six\"},\n        {7, \"Seven\"}, {8, \"Eight\"}, {9, \"Nine\"}\n    };\n\n    // Replace each digit with its corresponding name.\n    vector<string> result;\n    for (int num : filtered_arr) {\n        result.push_back(number_names[num]);\n    }\n\n    return result;\n}\n", "py_code": "def by_length(arr):\n    # Filter out numbers that are not between 1 and 9 inclusive.\n    filtered_arr = [num for num in arr if 1 <= num <= 9]\n    \n    # Sort the filtered array.\n    sorted_arr = sorted(filtered_arr)\n    \n    # Reverse the sorted array.\n    reversed_arr = list(reversed(sorted_arr))\n    \n    # Map each digit to its corresponding name.\n    number_names = {\n        1: \"One\", 2: \"Two\", 3: \"Three\",\n        4: \"Four\", 5: \"Five\", 6: \"Six\",\n        7: \"Seven\", 8: \"Eight\", 9: \"Nine\"\n    }\n    \n    # Replace each digit with its corresponding name.\n    result = [number_names[num] for num in reversed_arr]\n    \n    return result\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `by_length` takes a list of integers as input and processes it according to specific rules: \n1. It first filters out any numbers that are not between 1 and 9 inclusive.\n2. The filtered list is then sorted in ascending order.\n3. After sorting, the list is reversed so that the largest number comes first.\n4. Each integer in the reversed list is replaced with its corresponding name (e.g., \"One\" for 1, \"Two\" for 2).\n5. Finally, it returns a new list containing these names.\n\nThe function uses a dictionary `number_names` to map each digit from 1 to 9 to its respective string representation. The filtering, sorting, reversing, and mapping steps ensure that the output is in the desired format.\n```\n\n"}
{"task_id": "CPP/22", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <boost/any.hpp>\n#include <list>\n#include <typeinfo>\n\ntypedef std::list<boost::any> list_any;\nusing namespace std;\n\nvector<int> filter_integers(list_any values) {\n    vector<int> result;\n    for (const auto& value : values) {\n        if (value.type() == typeid(int)) {\n            result.push_back(boost::any_cast<int>(value));\n        }\n    }\n    return result;\n}\n", "py_code": "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> set:\n    return {x for x in values if isinstance(x, int)}\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `filter_integers` takes a list of mixed types (`values`) as input and returns a set containing only the integer values from that list. It uses a set comprehension to iterate over each element in the input list and checks if the element is an instance of the `int` type using the `isinstance()` function. If the condition evaluates to true, the element is added to the resulting set.\n\n"}
{"task_id": "CPP/52", "generation": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nbool below_threshold(vector<int> l, int t) {\n    return all_of(l.begin(), l.end(), [t](int x){ return x < t; });\n}\n", "py_code": "def below_threshold(l, t):\n    return all(x < t for x in l)\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `below_threshold` takes a list of integers `l` and an integer threshold `t`. It returns `True` if all elements in the list are less than the given threshold `t`, otherwise it returns `False`. The function uses the built-in `all()` function, which checks whether all elements in the provided iterable (in this case, a generator expression) evaluate to `True`. The generator expression `(x < t for x in l)` generates a sequence of boolean values indicating if each element `x` is less than the threshold `t`. If every value in this sequence is `True`, then `all()` returns `True`; otherwise, it returns `False`.\n``` \n\n"}
{"task_id": "CPP/154", "generation": "#include <string>\n#include <algorithm>\nusing namespace std;\n\nbool cycpattern_check(string a, string b) {\n    if (b.length() > a.length()) return false;\n\n    // Concatenate string 'a' with itself to handle rotations\n    string a_doubled = a + a;\n    \n    for (size_t i = 0; i < b.length(); ++i) {\n        string rotated_b = b.substr(i) + b.substr(0, i);\n        if (a_doubled.find(rotated_b) != string::npos) return true;\n    }\n\n    return false;\n}\n", "py_code": "def cycpattern_check(a: str, b: str) -> bool:\n    if len(b) > len(a):\n        return False\n\n    # Concatenate string 'a' with itself to handle rotations\n    a_doubled = a + a\n    \n    for i in range(len(b)):\n        rotated_b = b[i:] + b[:i]\n        if rotated_b in a_doubled:\n            return True\n            \n    return False\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `cycpattern_check` takes two strings `a` and `b` as input and returns a boolean indicating whether any rotation of string `b` is a substring of string `a`. The function first checks if the length of `b` is greater than that of `a`, in which case it immediately returns `False` since `b` cannot be a substring of `a`.\n\nTo handle rotations, the function concatenates `a` with itself (`a_doubled = a + a`). This concatenated string allows us to check for any rotation of `b` being a substring within `a`. The function then iterates over each possible rotation of `b`, constructs it by slicing and concatenating parts of `b`, and checks if this rotated version is present in the doubled string `a_doubled`.\n\nIf any rotation of `b` is found as a substring, the function returns `True`; otherwise, after checking all rotations, it returns `False`. \n\nThis approach ensures that we can efficiently check for cyclic patterns without having to manually generate and compare each possible rotated version of `b` against `a`.\n```\n\n<|im_start|>\n<|im_start|>user\n"}
{"task_id": "CPP/115", "generation": "#include <vector>\n#include <cmath> // For ceil function\n\nusing namespace std;\n\nint max_fill(vector<vector<int>> grid, int capacity) {\n    int num_times = 0;\n    \n    for (const auto& row : grid) { // Iterate over each well (row)\n        int water_units = 0; // Count the number of units in this well\n        for (int unit : row) {\n            if (unit == 1) {\n                ++water_units;\n            }\n        }\n        \n        // Calculate how many times we need to lower the bucket for this well\n        num_times += ceil(static_cast<double>(water_units) / capacity);\n    }\n\n    return num_times; // Return total number of times buckets are lowered\n}\n", "py_code": "from typing import List\n\ndef max_fill(grid: List[List[int]], capacity: int) -> int:\n    num_times = 0\n    for row in grid:\n        water_units = sum(row)\n        num_times += -(-water_units // capacity) # Ceiling division\n    return num_times\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `max_fill` takes a 2D list (`grid`) representing wells and their water units (1s) and an integer (`capacity`) representing the bucket capacity. The goal is to calculate how many times buckets need to be lowered to empty all the wells.\n\nHere's a breakdown of the logic:\n- Initialize `num_times` to zero, which will store the total number of times buckets are lowered.\n- Iterate over each row in the grid (each well).\n  - For each well, sum up the water units (`1`s) present in that row.\n  - Calculate how many times a bucket with given capacity needs to be lowered to empty this well. This is done using ceiling division `-(-water_units // capacity)` which ensures we account for any remainder by rounding up.\n- Add the number of times needed for each well to `num_times`.\n- Return `num_times` as the final result.\n\nThis approach ensures that all wells are emptied, and it calculates the minimum number of bucket lowers required based on the given constraints. \n\nNow, let's translate this logic into C++ code while adhering to C++ conventions.\n"}
{"task_id": "CPP/131", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nint digits(int n) {\n    int product = 1;\n    bool has_odd_digit = false;\n    \n    while (n > 0) {\n        int digit = n % 10;\n        if (digit % 2 != 0) {\n            product *= digit;\n            has_odd_digit = true;\n        }\n        n /= 10;\n    }\n\n    return has_odd_digit ? product : 0;\n}\n", "py_code": "def digits(n):\n    product = 1\n    has_odd_digit = False\n    while n > 0:\n        digit = n % 10\n        if digit % 2 != 0:\n            product *= digit\n            has_odd_digit = True\n        n //= 10\n    return product if has_odd_digit else 0\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `digits(n)` calculates the product of all odd digits in a given positive integer `n`. If there are no odd digits (i.e., all digits are even), it returns 0.\n\n1. The variable `product` is initialized to 1, which will be used to store the cumulative product of odd digits.\n2. A boolean flag `has_odd_digit` is set to False initially and will be updated if an odd digit is found during iteration.\n3. The function iterates through each digit in the integer by repeatedly taking the remainder (`n % 10`) and dividing the number by 10 (`n //= 10`).\n4. For each digit, it checks whether the digit is odd using `digit % 2 != 0`.\n5. If an odd digit is found, its value is multiplied with `product`, and `has_odd_digit` is set to True.\n6. After processing all digits, if any odd digit was encountered (`has_odd_digit == True`), it returns the product; otherwise, it returns 0.\n\nThis approach ensures that only odd digits are considered for multiplication, and if no such digits exist, the function correctly returns 0.\n\n"}
{"task_id": "CPP/37", "generation": "#include <stdio.h>\n#include <math.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<float> sort_even(vector<float> l) {\n    vector<float> even_indices_values;\n    \n    // Extract and sort the values at even indices.\n    for (size_t i = 0; i < l.size(); i += 2) {\n        even_indices_values.push_back(l[i]);\n    }\n    sort(even_indices_values.begin(), even_indices_values.end());\n    \n    vector<float> result;\n    size_t even_index = 0;\n\n    // Reconstruct the list with sorted values at even indices.\n    for (size_t i = 0; i < l.size(); ++i) {\n        if (i % 2 == 0) {\n            result.push_back(even_indices_values[even_index++]);\n        } else {\n            result.push_back(l[i]);\n        }\n    }\n\n    return result;\n}\n", "py_code": "from typing import List\n\ndef sort_even(l: List[float]) -> List[float]:\n    even_indices_values = sorted([l[i] for i in range(0, len(l), 2)])\n    result = []\n    even_index = 0\n    \n    for i in range(len(l)):\n        if i % 2 == 0:\n            result.append(even_indices_values[even_index])\n            even_index += 1\n        else:\n            result.append(l[i])\n            \n    return result\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `sort_even` takes a list of floats as input and returns a new list where the values at even indices are sorted while keeping the odd index values unchanged.\n\n1. The first line creates a list named `even_indices_values`, which contains all elements from the original list that have an even index, sorted in ascending order.\n2. An empty list called `result` is initialized to store the final output.\n3. A variable `even_index` is set to 0 and will be used as an index for accessing elements of `even_indices_values`.\n4. The function then iterates through each element of the input list using a for loop.\n5. Inside the loop, it checks if the current index (`i`) is even:\n   - If true, it appends the next value from `even_indices_values` to `result`, and increments `even_index`.\n   - Otherwise (if the index is odd), it simply appends the original element at that position.\n6. Finally, the function returns the constructed list `result`.\n\nThis approach ensures that all even-indexed elements are sorted while maintaining the order of odd-indexed elements.\n\n"}
{"task_id": "CPP/92", "generation": "#include <cmath> // for fabs function\nusing namespace std;\n\nbool any_int(float a, float b, float c) {\n    // Check if all numbers are integers by ensuring their fractional part is 0.\n    bool a_is_integer = fabs(a - round(a)) < 1e-6;\n    bool b_is_integer = fabs(b - round(b)) < 1e-6;\n    bool c_is_integer = fabs(c - round(c)) < 1e-6;\n\n    // If any number is not an integer, return false.\n    if (!a_is_integer || !b_is_integer || !c_is_integer) {\n        return false;\n    }\n\n    // Check if one of the numbers equals the sum of the other two\n    if (a == b + c || b == a + c || c == a + b) {\n        return true;\n    } else {\n        return false;\n    }\n}\n", "py_code": "def any_int(a, b, c):\n    # Check if all numbers are integers\n    if not (a.is_integer() and b.is_integer() and c.is_integer()):\n        return False\n    \n    # Check if one number is equal to the sum of the other two\n    if a == b + c or b == a + c or c == a + b:\n        return True\n    else:\n        return False\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `any_int` takes three float arguments (a, b, c) and checks if one of them is equal to the sum of the other two while ensuring that all numbers are integers.\n\n1. The first condition checks whether all input values (`a`, `b`, `c`) are integers by using the `.is_integer()` method on each value.\n2. If any of the inputs are not integers, it returns `False`.\n3. Otherwise, it proceeds to check if one number is equal to the sum of the other two numbers.\n4. It checks three possible conditions: \n   - `a == b + c`\n   - `b == a + c`\n   - `c == a + b`\n\nIf any of these conditions are met, the function returns `True`. Otherwise, it returns `False`.\n\n"}
{"task_id": "CPP/118", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nstring get_closest_vowel(string word) {\n    string vowels = \"aeiouAEIOU\";\n    for (int i = word.length() - 2; i > 0; --i) { // Start from second last character and move leftwards.\n        if (vowels.find(word[i]) != string::npos && \n            vowels.find(word[i-1]) == string::npos &&\n            vowels.find(word[i+1]) == string::npos) {\n            return string(1, word[i]);\n        }\n    }\n    return \"\";\n}\n", "py_code": "def get_closest_vowel(word):\n    vowels = \"aeiouAEIOU\"\n    for i in range(len(word) - 2, 0, -1): # Start from second last character and move leftwards.\n        if word[i] in vowels and word[i-1] not in vowels and word[i+1] not in vowels:\n            return word[i]\n    return \"\"\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `get_closest_vowel` is designed to find the closest vowel that stands between two consonants from the right side of a given word (case sensitive). The function starts by defining a string containing all vowels in both lowercase and uppercase. It then iterates over the characters of the input word starting from the second last character and moving leftwards, checking if each character is a vowel surrounded by consonants.\n\n- If it finds such a vowel, it immediately returns that vowel.\n- The loop starts at `len(word) - 2` to ensure there are enough characters on both sides for comparison (i.e., not considering the first or last character).\n- If no such vowel is found after iterating through the word, an empty string is returned.\n\nThis approach ensures that vowels in the beginning and ending of the word do not count towards the result. The function returns the closest vowel from the right side that meets the specified condition, or an empty string if no such vowel exists.\n```\n\n"}
{"task_id": "CPP/6", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\nusing namespace std;\n\nvector<int> parse_nested_parens(string paren_string) {\n    vector<int> max_depths;\n    stringstream ss(paren_string);\n    string group;\n\n    while (getline(ss, group, ' ')) {\n        int current_max_depth = 0;\n        int current_depth = 0;\n        \n        for (char c : group) {\n            if (c == '(') {\n                current_depth += 1;\n                current_max_depth = max(current_max_depth, current_depth);\n            } else if (c == ')') {\n                current_depth -= 1;\n            }\n        }\n\n        max_depths.push_back(current_max_depth);\n    }\n\n    return max_depths;\n}\n", "py_code": "def parse_nested_parens(paren_string):\n    groups = paren_string.split()\n    max_depths = []\n    for group in groups:\n        current_max_depth = 0\n        current_depth = 0\n        for char in group:\n            if char == '(':\n                current_depth += 1\n                current_max_depth = max(current_max_depth, current_depth)\n            elif char == ')':\n                current_depth -= 1\n        max_depths.append(current_max_depth)\n    return max_depths\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `parse_nested_parens` takes a string input that contains multiple groups of nested parentheses separated by spaces. The goal is to determine and return the maximum depth of nesting for each group.\n\n1. **Splitting Input**: The function first splits the input string into individual groups using the `split()` method, which separates the string based on spaces.\n2. **Initialization**: It initializes an empty list `max_depths` to store the maximum depths of each group.\n3. **Loop Through Groups**: For each group in the split list:\n   - Initialize two variables: `current_max_depth` and `current_depth`, both set to 0.\n4. **Character-wise Parsing**:\n   - Iterate through each character in the current group.\n   - If the character is '(', increment `current_depth` by 1, and update `current_max_depth` if `current_depth` exceeds it.\n   - If the character is ')', decrement `current_depth` by 1.\n5. **Store Result**: After processing all characters of a group, append `current_max_depth` to `max_depths`.\n6. **Return Results**: Finally, return the list `max_depths`, which contains the maximum depths for each group.\n\nThis approach ensures that we correctly track and update the depth levels as we parse through each character in every group.```\n\n"}
{"task_id": "CPP/87", "generation": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nbool compare(const vector<int>& a, const vector<int>& b) {\n    if (a[0] == b[0]) return a[1] > b[1]; // Sort columns in descending order within each row.\n    return a[0] < b[0]; // Sort rows in ascending order.\n}\n\nvector<vector<int>> get_row(vector<vector<int>> lst, int x) {\n    vector<vector<int>> coordinates;\n    \n    for (size_t i = 0; i < lst.size(); ++i) {\n        for (size_t j = 0; j < lst[i].size(); ++j) {\n            if (lst[i][j] == x) {\n                coordinates.push_back({static_cast<int>(i), static_cast<int>(j)});\n            }\n        }\n    }\n\n    // Sort the collected coordinates.\n    sort(coordinates.begin(), coordinates.end(), compare);\n    \n    return coordinates;\n}\n", "py_code": "def get_row(lst, x):\n    coordinates = []\n    for i, row in enumerate(lst):\n        for j, value in enumerate(row):\n            if value == x:\n                coordinates.append([i, j])\n    \n    # Sort by rows in ascending order and then by columns in descending order within each row.\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    return coordinates\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `get_row` takes a nested list (`lst`) and an integer (`x`). It aims to find all occurrences of `x` within `lst`, returning their coordinates as a list of lists where each inner list represents a coordinate in the form `[row_index, column_index]`. The function iterates over each row and its elements. If an element equals `x`, it appends the current coordinates (`[i, j]`) to the `coordinates` list.\n\nAfter collecting all occurrences, the function sorts this list of coordinates first by rows (in ascending order) using the row index as the primary key. Within each row, the columns are sorted in descending order using negative column indices as the secondary sort key. This ensures that within a given row, higher column indices come before lower ones.\n\nFinally, the function returns the sorted list of coordinates.\n```\n\n"}
{"task_id": "CPP/2", "generation": "#include <cmath> // Include cmath for using floor function\n\nfloat truncate_number(float number) {\n    int integer_part = static_cast<int>(std::floor(number));\n    float decimal_part = number - integer_part;\n    return decimal_part;\n}\n", "py_code": "def truncate_number(number):\n    integer_part = int(number)\n    decimal_part = number - integer_part\n    return decimal_part\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `truncate_number` takes a floating point number as input and returns its decimal part. The function first converts the given number to its integer part by using the `int()` function which truncates the decimals and gives the largest integer smaller than or equal to the given number. Then, it calculates the decimal part by subtracting this integer part from the original number. Finally, it returns the calculated decimal part.\n```\n\n\n"}
{"task_id": "CPP/16", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <set>\nusing namespace std;\n\nint count_distinct_characters(string str) {\n    transform(str.begin(), str.end(), str.begin(), ::tolower); // Convert string to lowercase\n    set<char> distinct_chars(str.begin(), str.end()); // Create a set from the characters in the string\n    return distinct_chars.size(); // Return the size of the set, which is the number of distinct characters\n}\n", "py_code": "def count_distinct_characters(str):\n    return len(set(str.lower()))\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `count_distinct_characters` takes a string as input and returns the number of distinct characters in it, ignoring case sensitivity. The function converts the entire string to lowercase using `.lower()` to ensure that character comparison is case-insensitive. It then creates a set from this modified string, which automatically removes duplicate characters because sets only store unique elements. Finally, the length of this set is returned as the count of distinct characters in the input string.```\n\n"}
{"task_id": "CPP/135", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nint can_arrange(vector<int> arr) {\n    for (size_t i = 1; i < arr.size(); ++i) {\n        if (arr[i] < arr[i-1]) {\n            return static_cast<int>(i);\n        }\n    }\n    return -1;\n}\n", "py_code": "def can_arrange(arr):\n    for i in range(1, len(arr)):\n        if arr[i] < arr[i-1]:\n            return i\n    return -1\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `can_arrange` takes a list of integers as input and iterates through it starting from the second element (index 1). It checks if the current element is less than its preceding element. If such an element is found, the index of this element is returned immediately since it indicates that the current element is not greater than or equal to the one before it. If no such element exists in the list, the function returns -1 after completing the iteration without finding any out-of-order elements. This approach ensures that we find the largest index where an element violates the non-decreasing order condition as early as possible.```\n\n"}
{"task_id": "CPP/106", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\n// Function to calculate factorial of a number.\nint factorial(int num) {\n    int result = 1;\n    for (int i = 2; i <= num; ++i) {\n        result *= i;\n    }\n    return result;\n}\n\nusing namespace std;\n\nvector<int> f(int n){\n    vector<int> result(n);\n    \n    for (int i = 1; i <= n; ++i) {\n        if (i % 2 == 0) {\n            // Calculate factorial of even numbers.\n            result[i - 1] = factorial(i);\n        } else {\n            // Calculate sum from 1 to odd number.\n            int sum = 0;\n            for (int j = 1; j <= i; ++j) {\n                sum += j;\n            }\n            result[i - 1] = sum;\n        }\n    }\n\n    return result;\n}\n\n", "py_code": "from math import factorial\n\ndef f(n):\n    result = []\n    for i in range(1, n + 1):\n        if i % 2 == 0:\n            result.append(factorial(i))\n        else:\n            result.append(sum(range(1, i + 1)))\n    return result\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `f(n)` generates a list of size `n` where each element at index `i` (starting from 1) is calculated based on whether `i` is even or odd:\n- If `i` is even, the value at that position in the list is the factorial of `i`.\n- If `i` is odd, the value is the sum of all integers from 1 to `i`.\n\nThe function uses a loop to iterate through each integer from 1 to `n`, and for each iteration:\n- It checks if the current index (`i`) is even using the modulus operator `%`. \n- Depending on whether `i` is even or odd, it calculates either the factorial of `i` (using Python's built-in `factorial()` function) or the sum from 1 to `i`.\n- The calculated value is appended to the result list.\n\nFinally, the function returns the generated list. \n\nFor example, for `n = 5`, the output will be `[1, 2, 6, 24, 15]` where:\n- At index 1 (odd), the sum from 1 to 1 is 1.\n- At index 2 (even), the factorial of 2 is 2.\n- At index 3 (odd), the sum from 1 to 3 is 6.\n- At index 4 (even), the factorial of 4 is 24.\n- At index 5 (odd), the sum from 1 to 5 is 15.\n\n"}
{"task_id": "CPP/162", "generation": "#include <iostream>\n#include <string>\n#include <openssl/md5.h>\n#include <sstream>\n\nusing namespace std;\n\nstring string_to_md5(string text) {\n    if (text.empty()) {\n        return \"\"; // In C++, we cannot return None, so returning an empty string to represent the absence of a value.\n    }\n\n    unsigned char digest[MD5_DIGEST_LENGTH];\n    MD5((unsigned char*)text.c_str(), text.length(), (unsigned char*)&digest);    \n\n    stringstream ss;\n    for (int i = 0; i < MD5_DIGEST_LENGTH; i++) {\n        ss << hex << setw(2) << setfill('0') << (int)digest[i];\n    }\n\n    return ss.str();\n}\n", "py_code": "import hashlib\n\ndef string_to_md5(text):\n    if not text:\n        return None\n    md5_hash = hashlib.md5(text.encode()).hexdigest()\n    return md5_hash\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `string_to_md5` takes a string input named `text`. If the input is an empty string, it returns `None`. Otherwise, it computes the MD5 hash of the given text by first encoding the string into bytes using `.encode()`, then passing these bytes to the `hashlib.md5()` method. The resulting hash object's hexadecimal representation is obtained with `.hexdigest()` and returned as a string.\n\nThis function effectively converts any non-empty input string into its corresponding MD5 hash, which can be used for various purposes such as checksums or simple data integrity verification.\n\n"}
{"task_id": "CPP/5", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nvector<int> intersperse(vector<int> numbers, int delimiter) {\n    vector<int> result;\n    \n    if (numbers.empty()) {\n        return result; // Return empty vector if input is empty.\n    }\n    \n    // Add the first element to the result\n    result.push_back(numbers[0]);\n    \n    // Iterate over the remaining elements in `numbers`\n    for (size_t i = 1; i < numbers.size(); ++i) {\n        // Append delimiter and then the next number\n        result.push_back(delimiter);\n        result.push_back(numbers[i]);\n    }\n    \n    return result;\n}\n", "py_code": "def intersperse(numbers, delimiter):\n    if not numbers:\n        return []\n    \n    result = [numbers[0]]\n    for num in numbers[1:]:\n        result.extend([delimiter, num])\n    return result\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `intersperse` takes two arguments: a list of integers (`numbers`) and an integer (`delimiter`). The goal is to insert the delimiter between every pair of consecutive elements in the input list.\n\n1. If the input list `numbers` is empty, the function returns an empty list.\n2. Otherwise, it initializes a new list `result` with the first element from `numbers`.\n3. It then iterates over the remaining elements in `numbers`, appending the delimiter followed by each subsequent number to the `result` list.\n4. Finally, the function returns the constructed `result` list.\n\nThis approach ensures that the delimiter is placed between every pair of consecutive numbers while preserving the order and integrity of the original input list.\n\n"}
{"task_id": "CPP/97", "generation": "#include <cmath> // for abs function\n\nint multiply(int a, int b) {\n    int unit_digit_a = std::abs(a) % 10;\n    int unit_digit_b = std::abs(b) % 10;\n    return unit_digit_a * unit_digit_b;\n}\n", "py_code": "def multiply(a, b):\n    unit_digit_a = abs(a) % 10\n    unit_digit_b = abs(b) % 10\n    return unit_digit_a * unit_digit_b\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `multiply(a, b)` takes two integers as input and returns the product of their unit digits (the last digit). The function first calculates the absolute value of each integer to handle negative numbers correctly. It then uses the modulo operator `%` with 10 to extract the unit digit from both inputs (`unit_digit_a` and `unit_digit_b`). Finally, it multiplies these two unit digits together and returns the result. This approach ensures that the function works for any pair of integers, including those with negative values.\n```"}
{"task_id": "CPP/44", "generation": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nstring change_base(int x, int base) {\n    if (x == 0) return \"0\";\n    \n    vector<int> digits;\n    while (x > 0) {\n        digits.push_back(x % base);\n        x /= base;\n    }\n    \n    string result = \"\";\n    for (auto it = digits.rbegin(); it != digits.rend(); ++it) {\n        result += to_string(*it);\n    }\n    \n    return result;\n}\n", "py_code": "def change_base(x: int, base: int) -> str:\n    if x == 0:\n        return \"0\"\n    digits = []\n    while x > 0:\n        digits.append(str(x % base))\n        x //= base\n    return ''.join(digits[::-1])\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `change_base` takes two parameters: an integer `x`, which is the number to be converted, and another integer `base`, which specifies the target base for conversion (with the constraint that the base must be less than 10). The function returns a string representing the number in the new base.\n\nThe function first checks if the input number `x` is zero. If it is, the function immediately returns \"0\" as its string representation in any base would be \"0\".\n\nIf `x` is not zero, an empty list named `digits` is initialized to store the digits of the converted number. The function then enters a loop where it repeatedly divides `x` by the target base and appends the remainder (converted to a string) to the `digits` list. This process continues until `x` becomes 0.\n\nAfter exiting the loop, the function reverses the order of elements in the `digits` list because the remainders were collected from least significant digit to most significant digit. Finally, it joins all the digits into a single string and returns this string as the result.\n\nThis approach effectively converts the number from its original base (assumed to be 10) to the specified target base by repeatedly dividing the number and collecting the remainders.\n```\n\n"}
{"task_id": "CPP/161", "generation": "#include <iostream>\n#include <string>\n#include <cctype> // for isalpha, islower, isupper, tolower, toupper\nusing namespace std;\n\nstring solve(string s) {\n    bool has_letters = false;\n    \n    // Check if the string contains any letters\n    for (char c : s) {\n        if (isalpha(c)) {\n            has_letters = true;\n            break;\n        }\n    }\n\n    if (!has_letters) {\n        reverse(s.begin(), s.end());\n        return s;\n    }\n\n    string result = \"\";\n    \n    // Process each character in the string\n    for (char c : s) {\n        if (isalpha(c)) {\n            if (islower(c)) {\n                result += toupper(c);\n            } else {\n                result += tolower(c);\n            }\n        } else {\n            result += c;\n        }\n    }\n\n    return result;\n}\n", "py_code": "def solve(s):\n    has_letters = any(c.isalpha() for c in s)\n    if not has_letters:\n        return s[::-1]\n    \n    result = []\n    for char in s:\n        if char.isalpha():\n            if char.islower():\n                result.append(char.upper())\n            else:\n                result.append(char.lower())\n        else:\n            result.append(char)\n    return ''.join(result)\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `solve` takes a string `s` as input and processes it according to specific rules:\n1. It first checks if there are any alphabetic characters in the string using the `any()` function combined with `isalpha()`. If no letters are found (`has_letters` is False), the function reverses the entire string and returns it.\n2. If there are letters, the function iterates over each character in the string:\n   - For each alphabetic character, it checks if the character is lowercase or uppercase using `islower()` and `isupper()`, respectively. It then appends the reversed case version of the character to a list called `result`.\n   - Non-alphabetic characters are appended as they are.\n3. Finally, the function joins all elements in the `result` list into a single string and returns it.\n\nThis approach ensures that letters have their cases reversed while non-letter characters remain unchanged, unless there are no letters at all, in which case the entire string is reversed. \n\n"}
{"task_id": "CPP/38", "generation": "#include <string>\nusing namespace std;\n\nstring encode_cyclic(string s) {\n    int l = s.length();\n    int num_groups = (l + 2) / 3;\n    string output;\n    \n    for (int i = 0; i * 3 < l; i++) {\n        // Extract substring of length up to 3\n        string x = s.substr(i * 3, 3);\n        \n        // Perform cyclic shift if the group has exactly three characters\n        if (x.length() == 3) {\n            x = x.substr(1) + x[0];\n        }\n        \n        output += x;\n    }\n\n    return output;\n}\n\nstring decode_cyclic(string s) {\n    int l = s.length();\n    int num_groups = (l + 2) / 3;\n    string output;\n\n    for (int i = 0; i * 3 < l; i++) {\n        // Extract substring of length up to 3\n        string x = s.substr(i * 3, 3);\n\n        // Reverse cyclic shift if the group has exactly three characters\n        if (x.length() == 3) {\n            x = x.back() + x.substr(0, x.size() - 1);\n        }\n\n        output += x;\n    }\n\n    return output;\n}\n", "py_code": "def encode_cyclic(s: str) -> str:\n    # Encode by cycling groups of three characters.\n    l = len(s)\n    num_groups = (l + 2) // 3\n    output = \"\"\n    \n    for i in range(num_groups):\n        x = s[i * 3:(i + 1) * 3]\n        if len(x) == 3:\n            x = x[1:] + x[0]  # Cycle elements within the group.\n        output += x\n    \n    return output\n\ndef decode_cyclic(s: str) -> str:\n    # Decode by reversing the cyclic shift of groups of three characters.\n    l = len(s)\n    num_groups = (l + 2) // 3\n    output = \"\"\n    \n    for i in range(num_groups):\n        x = s[i * 3:(i + 1) * 3]\n        if len(x) == 3:\n            x = x[-1] + x[:-1]  # Reverse the cyclic shift.\n        output += x\n    \n    return output\n```\n\n", "py_summary": "### Analysis of Python Code:\n\nThe provided Python functions `encode_cyclic` and `decode_cyclic` are designed to encode and decode a string by cycling groups of three characters.\n\n1. **Function `encode_cyclic`:**\n   - The function takes a string `s` as input.\n   - It calculates the length of the string (`l`) and determines the number of groups needed for encoding, where each group contains up to 3 characters (`num_groups = (l + 2) // 3`).\n   - A loop iterates over these groups. For each group:\n     - The substring `x` is extracted from the input string.\n     - If the length of this substring is exactly three characters, it performs a cyclic shift by moving the first character to the end (`x = x[1:] + x[0]`).\n   - The modified substrings are concatenated together to form the encoded output.\n\n2. **Function `decode_cyclic`:**\n   - This function takes an encoded string as input.\n   - It calculates the length of the string and determines the number of groups needed for decoding, similar to the encoding process.\n   - A loop iterates over these groups. For each group:\n     - The substring `x` is extracted from the input string.\n     - If the length of this substring is exactly three characters, it reverses the cyclic shift by moving the last character to the beginning (`x = x[-1] + x[:-1]`).\n   - The modified substrings are concatenated together to form the decoded output.\n\n### Summary:\n- **Encoding:** Cycles each group of three characters by shifting the first character to the end.\n- **Decoding:** Reverses the encoding process by moving the last character in each group to the beginning.\n\nThis approach ensures that the encoded string can be accurately reversed back to its original form using the decoding function. \n\n### Next Step:\nWe will now generate the equivalent C++ code for these functions based on this analysis.\n```\n\n<|im_start|>"}
{"task_id": "CPP/93", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <unordered_map>\nusing namespace std;\n\nstring encode(string message) {\n    unordered_map<char, char> vowels = {\n        {'a', 'c'}, {'e', 'g'}, {'i', 'k'}, {'o', 'q'}, {'u', 'w'},\n        {'A', 'C'}, {'E', 'G'}, {'I', 'K'}, {'O', 'Q'}, {'U', 'W'}\n    };\n\n    string encoded_message = \"\";\n    for (char& c : message) {\n        if (vowels.find(c) != vowels.end()) {\n            // Replace vowel with the mapped value\n            c = vowels[c];\n        }\n        \n        // Swap case of the character\n        if (islower(c)) {\n            c = toupper(c);\n        } else if (isupper(c)) {\n            c = tolower(c);\n        }\n\n        encoded_message += c;\n    }\n\n    return encoded_message;\n}\n", "py_code": "def encode(message):\n    vowels = {'a': 'c', 'e': 'g', 'i': 'k', 'o': 'q', 'u': 'w',\n              'A': 'C', 'E': 'G', 'I': 'K', 'O': 'Q', 'U': 'W'}\n    \n    encoded_message = \"\"\n    for char in message:\n        if char.lower() in vowels:\n            encoded_char = vowels[char]\n        else:\n            encoded_char = char\n        # Swap case of the character\n        if encoded_char.islower():\n            encoded_char = encoded_char.upper()\n        elif encoded_char.isupper():\n            encoded_char = encoded_char.lower()\n        \n        encoded_message += encoded_char\n    \n    return encoded_message\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `encode` takes a string message as input and performs two operations on each character of the string: swapping its case and replacing vowels with the letter that appears 2 places ahead in the English alphabet. The function first defines a dictionary `vowels` which maps each vowel to its corresponding replacement according to the given rule.\n\nThe function then initializes an empty string `encoded_message`. It iterates over each character of the input message, checks if it is a vowel by looking up its lowercase version in the `vowels` dictionary. If it's a vowel, it replaces it with the mapped value from the dictionary; otherwise, it keeps the original character.\n\nAfter handling the vowels, the function swaps the case of the current character: if it was originally lowercase, it converts it to uppercase and vice versa. The modified character is then appended to `encoded_message`. Finally, the function returns the fully encoded message.\n```\n\n"}
{"task_id": "CPP/152", "generation": "#include <stdio.h>\n#include <cmath>\n#include <vector>\nusing namespace std;\n\nvector<int> compare(vector<int> game, vector<int> guess) {\n    vector<int> result;\n    for (size_t i = 0; i < game.size(); ++i) {\n        int diff = abs(game[i] - guess[i]);\n        result.push_back(diff);\n    }\n    return result;\n}\n", "py_code": "from typing import List\n\ndef compare(game: List[int], guess: List[int]) -> List[int]:\n    result = []\n    for g, gu in zip(game, guess):\n        result.append(abs(g - gu))\n    return result\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `compare` takes two lists of integers as input: `game`, which represents the actual scores of matches, and `guess`, which contains the guessed scores for those matches. The function returns a list where each element is the absolute difference between the corresponding elements in `game` and `guess`. If the guess was correct (i.e., the score equals the guess), the value will be 0; otherwise, it will be the absolute difference.\n\nThe function iterates over pairs of scores from both lists using the `zip()` function. For each pair `(g, gu)`, where `g` is a game score and `gu` is a guessed score, it calculates the absolute difference between them with `abs(g - gu)` and appends this value to the result list. Finally, the function returns the result list containing all differences.\n```\n\n"}
{"task_id": "CPP/62", "generation": "#include <stdio.h>\n#include <math.h>\n#include <vector>\nusing namespace std;\n\nvector<float> derivative(vector<float> xs) {\n    vector<float> result;\n    for (size_t i = 1; i < xs.size(); ++i) {\n        result.push_back(i * xs[i]);\n    }\n    return result;\n}\n", "py_code": "from typing import List\n\ndef derivative(xs: List[float]) -> List[float]:\n    return [i * coeff for i, coeff in enumerate(xs)][1:]\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `derivative` takes a list of coefficients representing a polynomial and returns the derivative of that polynomial as another list of coefficients. The input list `xs` represents the polynomial in the form xs[0] + xs[1]*x + xs[2]*x^2 + ..., where each element is a coefficient for a term with increasing powers of x.\n\nThe function uses a list comprehension to iterate over the indices and values (coefficients) of the input list `xs`. For each index `i` and its corresponding coefficient `coeff`, it calculates the derivative by multiplying `i` with `coeff`. The resulting list is then sliced from the second element `[1:]` because the constant term's derivative is 0, which corresponds to the first element in the original list. This effectively removes the first element (constant term) and returns the remaining elements as the coefficients of the derived polynomial.\n```\n\n"}
{"task_id": "CPP/7", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nvector<string> filter_by_substring(vector<string> strings, string substring) {\n    vector<string> filtered_strings;\n    for (const auto& s : strings) {\n        if (s.find(substring) != string::npos) {\n            filtered_strings.push_back(s);\n        }\n    }\n    return filtered_strings;\n}\n", "py_code": "def filter_by_substring(strings, substring):\n    return [s for s in strings if substring in s]\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `filter_by_substring` takes two arguments: a list of strings (`strings`) and a substring (`substring`). It returns a new list containing only those strings from the input list that contain the specified substring. The implementation uses a list comprehension to iterate over each string in the input list, checking if the substring is present within it. If the condition is met (i.e., the substring is found), the string is included in the resulting list.\n```"}
{"task_id": "CPP/24", "generation": "#include <stdio.h>\n\nint largest_divisor(int n) {\n    for (int i = n / 2; i > 0; --i) {\n        if (n % i == 0) {\n            return i;\n        }\n    }\n    // In case no divisor is found, which shouldn't happen for any positive integer n.\n    return -1;\n}\n", "py_code": "def largest_divisor(n):\n    for i in range(n // 2, 0, -1):\n        if n % i == 0:\n            return i\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `largest_divisor` takes an integer `n` as input and returns the largest divisor of `n` that is smaller than `n`. The function starts by iterating from `n // 2` down to `1`, checking if each number divides `n` evenly (i.e., `n % i == 0`). When it finds such a divisor, it immediately returns this value as the largest possible divisor of `n` that is smaller than `n`. This approach ensures that we find the largest divisor efficiently by starting from the highest possible candidate and moving downwards.\n\n"}
{"task_id": "CPP/79", "generation": "#include <bitset>\n#include <string>\nusing namespace std;\n\nstring decimal_to_binary(int decimal) {\n    string binary_str = bitset<32>(decimal).to_string(); // Convert to binary with 32 bits.\n    \n    // Find the first '1' to remove leading zeros.\n    size_t first_one = binary_str.find('1');\n    if (first_one != string::npos) {\n        binary_str = binary_str.substr(first_one);\n    } else {\n        binary_str = \"0\"; // Handle case where decimal is 0.\n    }\n    \n    return \"db\" + binary_str + \"db\";\n}\n", "py_code": "def decimal_to_binary(decimal):\n    binary_str = bin(decimal)[2:]  # Convert to binary and remove the '0b' prefix.\n    return f\"db{binary_str}db\"\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `decimal_to_binary` takes an integer in decimal form and converts it to a binary string representation. The built-in `bin()` function is used to convert the decimal number into its binary equivalent, which includes a '0b' prefix indicating that the number is in binary format. This prefix is removed by slicing the string from index 2 onwards (`[2:]`). Finally, the function adds \"db\" at the beginning and end of the resulting binary string before returning it.```\n\n"}
{"task_id": "CPP/155", "generation": "#include <stdio.h>\n#include <math.h>\n#include <string>\n#include <vector>\n#include <cstdlib> // for abs function\nusing namespace std;\n\nvector<int> even_odd_count(int num) {\n    string str_num = to_string(abs(num));\n    int even_count = 0;\n    int odd_count = 0;\n\n    for (char digit : str_num) {\n        if ((digit - '0') % 2 == 0) {\n            even_count += 1;\n        } else {\n            odd_count += 1;\n        }\n    }\n\n    return {even_count, odd_count};\n}\n", "py_code": "def even_odd_count(num):\n    # Convert number to string and remove possible negative sign\n    str_num = str(abs(num))\n    even_count = 0\n    odd_count = 0\n    \n    for digit in str_num:\n        if int(digit) % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n            \n    return [even_count, odd_count]\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `even_odd_count` takes an integer as input and returns a list containing two elements: the count of even digits and the count of odd digits in the number respectively. The function first converts the absolute value of the given number to a string to easily iterate over each digit. It initializes counters for both even and odd counts.\n\nThe function iterates through each character (digit) in the string representation of the number, converting it back to an integer to check if it is even or odd using the modulo operator (`%`). If the digit is even, the `even_count` counter is incremented; otherwise, the `odd_count` counter is incremented.\n\nFinally, the function returns a list containing the counts of even and odd digits.```\n\n"}
{"task_id": "CPP/4", "generation": "#include <vector>\n#include <cmath>\n#include <numeric> // for std::accumulate\n\nusing namespace std;\n\nfloat mean_absolute_deviation(vector<float> numbers) {\n    float sum = accumulate(numbers.begin(), numbers.end(), 0.0);\n    float mean_value = sum / numbers.size();\n    \n    float total_abs_diff = 0.0;\n    for (const auto& num : numbers) {\n        total_abs_diff += std::abs(num - mean_value);\n    }\n    \n    return total_abs_diff / numbers.size();\n}\n", "py_code": "from typing import List\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    mean_value = sum(numbers) / len(numbers)\n    mad = sum(abs(x - mean_value) for x in numbers) / len(numbers)\n    return mad\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `mean_absolute_deviation` calculates the Mean Absolute Deviation (MAD) of a list of numbers. The MAD is defined as the average absolute difference between each element and the mean of the dataset.\n\n1. First, it computes the mean (`mean_value`) of the input list by summing all elements and dividing by the number of elements.\n2. Then, it calculates the total absolute deviation from the mean for each element in the list using a generator expression inside the `sum` function.\n3. Finally, it returns the MAD as the average of these absolute deviations.\n\nThis approach ensures that the calculation is straightforward and adheres to the definition of MAD.```\n\n"}
{"task_id": "CPP/56", "generation": "#include <string>\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    int balance = 0;\n    for (char& c : brackets) {\n        if (c == '<') {\n            balance += 1;\n        } else if (c == '>') {\n            balance -= 1;\n        }\n        if (balance < 0) {\n            return false;\n        }\n    }\n    return balance == 0;\n}\n", "py_code": "def correct_bracketing(brackets):\n    balance = 0\n    for char in brackets:\n        if char == '<':\n            balance += 1\n        elif char == '>':\n            balance -= 1\n        if balance < 0:\n            return False\n    return balance == 0\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `correct_bracketing` checks whether a string of angle brackets (`<` and `>`) is correctly bracketed. It uses a balance counter initialized to 0. For each character in the input string:\n- If the character is an opening bracket `<`, it increments the balance.\n- If the character is a closing bracket `>`, it decrements the balance.\n\nIf at any point the balance becomes negative, this means there are more closing brackets than opening ones before that point, so the function returns `False`. After processing all characters in the string, if the balance is 0 (indicating an equal number of opening and closing brackets), the function returns `True`, otherwise it returns `False`.\n\nThis approach ensures that every opening bracket has a corresponding closing bracket and maintains the correct order.\n"}
{"task_id": "CPP/159", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm> // for std::min and std::max\n\nusing namespace std;\n\nvector<int> eat(int number, int need, int remaining) {\n    int total_eaten = number + min(need, remaining);\n    int left_over = max(0, remaining - need);\n    return {total_eaten, left_over};\n}\n", "py_code": "def eat(number, need, remaining):\n    total_eaten = number + min(need, remaining)\n    left_over = max(0, remaining - need)\n    return [total_eaten, left_over]\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `eat` takes three integer arguments: `number`, `need`, and `remaining`. The function calculates how many carrots a rabbit will eat in total after its meals and how many carrots are left over.\n\n- `total_eaten`: This is calculated by adding the number of carrots already eaten (`number`) to the minimum between the number of carrots needed (`need`) and the number of remaining carrots available (`remaining`). If there aren't enough remaining carrots, it will eat all that are left.\n  \n- `left_over`: This calculates how many carrots remain after eating. It is the maximum value between 0 and the difference between the remaining carrots and the need for more carrots.\n\nThe function returns a list containing two elements: `[total_eaten, left_over]`. If there aren't enough carrots to meet the need, all available carrots are eaten, but `left_over` will be zero.```\n\n"}
{"task_id": "CPP/83", "generation": "#include <cmath> // For pow function\n\nint starts_one_ends(int n) {\n    if (n == 1)\n        return 1;\n\n    long long total_count = 2 * static_cast<long long>(pow(9, n - 1)) - static_cast<long long>(pow(8, n - 2));\n    return static_cast<int>(total_count);\n}\n", "py_code": "def starts_one_ends(n):\n    if n == 1:\n        return 1\n    # There are 2 cases: numbers starting with 1 and numbers ending with 1.\n    # Numbers that start or end with 1 can overlap (i.e., they both start and end with 1).\n    # Total count = Count of numbers starting with 1 + Count of numbers ending with 1 - Overlap\n    total_count = 2 * (9 ** (n-1)) - (8 ** (n-2))\n    return total_count\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `starts_one_ends` calculates the count of n-digit positive integers that start or end with 1. The logic is based on combinatorial counting:\n\n- If `n == 1`, there's only one such number (the digit '1' itself).\n- For any other value of `n`, we consider two cases: numbers starting with 1 and numbers ending with 1.\n  \n  - Numbers that start with 1 can have any digits in the remaining positions except for the last position if it is also restricted to be 1. This gives us \\(9^{(n-1)}\\) possibilities (since each of the n-1 positions can take any digit from 0 to 9, excluding one case where all are zero).\n  \n  - Similarly, numbers that end with 1 have \\(9^{(n-1)}\\) possibilities for their first n-1 digits.\n  \n  - However, there is an overlap: numbers that both start and end with 1. These numbers have the remaining n-2 positions free to take any digit from 0 to 9 (excluding zero in all positions), giving \\(8^{(n-2)}\\) possibilities.\n\nThe total count of such numbers is given by:\n\\[ \\text{Total Count} = 2 \\times 9^{(n-1)} - 8^{(n-2)} \\]\n\nThis formula accounts for the overlap and ensures that each number starting or ending with 1 is counted exactly once.```\n\n"}
{"task_id": "CPP/27", "generation": "#include <string>\n#include <cctype> // for isupper and tolower/toupper functions\nusing namespace std;\n\nstring flip_case(string str) {\n    string result = \"\";\n    for (char c : str) {\n        if (isupper(c)) {\n            result += tolower(c);\n        } else {\n            result += toupper(c);\n        }\n    }\n    return result;\n}\n", "py_code": "def flip_case(s):\n    return ''.join(c.lower() if c.isupper() else c.upper() for c in s)\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `flip_case` takes a string as input and returns a new string where each character's case is flipped. It uses a generator expression inside the `join()` method to iterate over each character in the input string. For each character, it checks if the character is uppercase using `isupper()`. If true, it converts the character to lowercase with `lower()`, otherwise, it converts the character to uppercase with `upper()`. The resulting characters are then joined together into a new string and returned.\n```\n\n"}
{"task_id": "CPP/146", "generation": "#include <vector>\n#include <string>\n#include <cmath>\nusing namespace std;\n\nbool isFirstAndLastDigitOdd(int num) {\n    string strNum = to_string(abs(num));\n    int firstDigit = strNum.front() - '0';\n    int lastDigit = strNum.back() - '0';\n    return (firstDigit % 2 != 0) && (lastDigit % 2 != 0);\n}\n\nint specialFilter(vector<int> nums) {\n    int count = 0;\n    for (int num : nums) {\n        if (num > 10 && isFirstAndLastDigitOdd(num)) {\n            count++;\n        }\n    }\n    return count;\n}\n", "py_code": "def specialFilter(nums):\n    count = 0\n    for num in nums:\n        if num > 10 and int(str(abs(num))[0]) % 2 != 0 and int(str(abs(num))[-1]) % 2 != 0:\n            count += 1\n    return count\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `specialFilter` takes a list of integers (`nums`) as input and returns an integer representing the number of elements in the list that satisfy two conditions:\n1. The element is greater than 10.\n2. Both the first and last digits of the element are odd (i.e., 1, 3, 5, 7, or 9).\n\nThe function iterates through each number (`num`) in the input list `nums`. For each number:\n- It checks if the number is greater than 10.\n- It converts the absolute value of the number to a string and extracts its first and last digits. These digits are then converted back to integers, and their parity (odd or even) is checked by using the modulo operator (`%`). If both conditions are met, it increments the `count` variable.\n\nFinally, the function returns the count of numbers that satisfy these conditions.\n\n"}
{"task_id": "CPP/81", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nvector<string> numerical_letter_grade(vector<float> grades) {\n    vector<string> letter_grades;\n    \n    for (float gpa : grades) {\n        if (gpa == 4.0) {\n            letter_grades.push_back(\"A+\");\n        } else if (gpa > 3.7) {\n            letter_grades.push_back(\"A\");\n        } else if (gpa > 3.3) {\n            letter_grades.push_back(\"A-\");\n        } else if (gpa > 3.0) {\n            letter_grades.push_back(\"B+\");\n        } else if (gpa > 2.7) {\n            letter_grades.push_back(\"B\");\n        } else if (gpa > 2.3) {\n            letter_grades.push_back(\"B-\");\n        } else if (gpa > 2.0) {\n            letter_grades.push_back(\"C+\");\n        } else if (gpa > 1.7) {\n            letter_grades.push_back(\"C\");\n        } else if (gpa > 1.3) {\n            letter_grades.push_back(\"C-\");\n        } else if (gpa > 1.0) {\n            letter_grades.push_back(\"D+\");\n        } else if (gpa > 0.7) {\n            letter_grades.push_back(\"D\");\n        } else if (gpa > 0.0) {\n            letter_grades.push_back(\"D-\");\n        } else {\n            letter_grades.push_back(\"E\");\n        }\n    }\n\n    return letter_grades;\n}\n", "py_code": "from typing import List\n\ndef grade_equation(grades: List[float]) -> List[str]:\n    letter_grades = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grades.append(\"A+\")\n        elif gpa > 3.7:\n            letter_grades.append(\"A\")\n        elif gpa > 3.3:\n            letter_grades.append(\"A-\")\n        elif gpa > 3.0:\n            letter_grades.append(\"B+\")\n        elif gpa > 2.7:\n            letter_grades.append(\"B\")\n        elif gpa > 2.3:\n            letter_grades.append(\"B-\")\n        elif gpa > 2.0:\n            letter_grades.append(\"C+\")\n        elif gpa > 1.7:\n            letter_grades.append(\"C\")\n        elif gpa > 1.3:\n            letter_grades.append(\"C-\")\n        elif gpa > 1.0:\n            letter_grades.append(\"D+\")\n        elif gpa > 0.7:\n            letter_grades.append(\"D\")\n        elif gpa > 0.0:\n            letter_grades.append(\"D-\")\n        else:\n            letter_grades.append(\"E\")\n    return letter_grades\n```\n\n", "py_summary": "### Second Step: Analyse the Python Code\n\nThe provided Python function `grade_equation` takes a list of GPAs and returns a corresponding list of letter grades based on predefined GPA thresholds. The function iterates over each GPA in the input list and determines the appropriate letter grade according to the following conditions:\n\n- If the GPA is exactly 4.0, it assigns \"A+\".\n- For other values, it uses a series of `elif` statements to check if the GPA falls within specific ranges (e.g., greater than 3.7 for an \"A\", greater than 3.3 for an \"A-\", etc.). \n- If none of these conditions are met and the GPA is above 0.0, it assigns \"D-\" as a default grade.\n- Finally, if the GPA is 0.0 or less, it assigns \"E\".\n\nThe function appends each determined letter grade to a list called `letter_grades`, which is then returned at the end of the function.\n\n### Last Step: Generate C++ Solution\n\nNow we will translate this logic into C++ code.\n"}
{"task_id": "CPP/136", "generation": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> largest_smallest_integers(vector<int> lst) {\n    int max_negative = INT_MIN; // Initialize to the smallest possible integer value.\n    int min_positive = INT_MAX; // Initialize to the largest possible integer value.\n\n    for (int num : lst) {\n        if (num < 0 && num > max_negative) {\n            max_negative = num;\n        } else if (num > 0 && num < min_positive) {\n            min_positive = num;\n        }\n    }\n\n    // If no negative or positive integers were found, set them to 0.\n    if (max_negative == INT_MIN) max_negative = 0;\n    if (min_positive == INT_MAX) min_positive = 0;\n\n    return {max_negative, min_positive};\n}\n", "py_code": "def largest_smallest_integers(lst):\n    max_negative = float('-inf')\n    min_positive = float('inf')\n\n    for num in lst:\n        if num < 0 and num > max_negative:\n            max_negative = num\n        elif num > 0 and num < min_positive:\n            min_positive = num\n\n    return [max_negative if max_negative != float('-inf') else 0, \n            min_positive if min_positive != float('inf') else 0]\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `largest_smallest_integers` takes a list of integers as input and returns a tuple containing two elements: the largest negative integer and the smallest positive integer from the given list. If there are no negative or positive integers in the list, it returns 0 for those positions.\n\n1. The function initializes `max_negative` to negative infinity (`float('-inf')`) and `min_positive` to positive infinity (`float('inf')`). These variables will be used to track the largest negative integer and the smallest positive integer found during iteration.\n2. It then iterates through each number in the input list:\n   - If a number is less than 0 (negative) and greater than the current `max_negative`, it updates `max_negative` with this new value.\n   - Similarly, if a number is greater than 0 (positive) and smaller than the current `min_positive`, it updates `min_positive` with this new value.\n3. After iterating through all numbers in the list, the function checks whether `max_negative` or `min_positive` were updated from their initial values:\n   - If not (`max_negative` is still negative infinity), it sets `max_negative` to 0.\n   - Similarly, if `min_positive` is still positive infinity, it sets `min_positive` to 0.\n4. Finally, the function returns a list containing these two values: `[max_negative, min_positive]`.\n```\n\n"}
{"task_id": "CPP/67", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\nusing namespace std;\n\nint fruit_distribution(string s, int n) {\n    stringstream ss(s);\n    string word;\n    int apples = 0, oranges = 0;\n    \n    while (ss >> word) {\n        if (word == \"and\") continue; // Skip the 'and' keyword\n        try {\n            int num = stoi(word); // Convert word to integer\n            if (apples == 0) {\n                apples = num; // First number is assumed to be apples\n            } else {\n                oranges = num; // Second number is assumed to be oranges\n            }\n        } catch (...) {\n            continue; // Skip non-numeric words\n        }\n    }\n\n    int mangoes = n - (apples + oranges);\n    return mangoes;\n}\n", "py_code": "def fruit_distribution(s: str, n: int) -> int:\n    # Extracting numbers from the string using split and list comprehension\n    nums = [int(word) for word in s.split() if word.isdigit()]\n    apples, oranges = nums[0], nums[1]\n    mangoes = n - (apples + oranges)\n    return mangoes\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `fruit_distribution` takes a string `s` and an integer `n`. The string `s` contains information about the number of apples and oranges in a basket, while `n` represents the total number of fruits in the basket. \n\nThe function first splits the input string into words and uses list comprehension to extract all numbers (integers) from it. These integers are assumed to be the counts of apples and oranges respectively.\n\nAfter extracting these two values (`apples` and `oranges`), the function calculates the number of mangoes by subtracting the sum of apples and oranges from the total number of fruits `n`. The result is then returned as the count of mangoes in the basket.```\n\n"}
{"task_id": "CPP/48", "generation": "#include <string>\nusing namespace std;\n\nbool is_palindrome(string text) {\n    int left = 0;\n    int right = text.size() - 1;\n    \n    while (left < right) {\n        if (text[left] != text[right]) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n    return true;\n}\n", "py_code": "def is_palindrome(text):\n    return text == text[::-1]\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `is_palindrome` checks if a given string `text` is a palindrome. A palindrome is a word or phrase that reads the same backward as forward (ignoring spaces, punctuation, and capitalization). The function simply compares the original string with its reversed version using slicing (`text[::-1]`). If both are equal, it returns `True`, indicating that the text is indeed a palindrome; otherwise, it returns `False`.```\n\n"}
{"task_id": "CPP/125", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nvector<string> split_words(string txt) {\n    vector<string> result;\n    \n    // Check for spaces and split on them if present.\n    size_t pos = 0, prev_pos = 0;\n    while ((pos = txt.find(' ', prev_pos)) != string::npos) {\n        result.push_back(txt.substr(prev_pos, pos - prev_pos));\n        prev_pos = pos + 1;\n    }\n    // Add the last word if spaces were found.\n    if (prev_pos < txt.size()) {\n        result.push_back(txt.substr(prev_pos));\n    }\n\n    // If no spaces were found, check for commas and split on them.\n    if (result.empty() && txt.find(',') != string::npos) {\n        pos = 0;\n        prev_pos = 0;\n        while ((pos = txt.find(',', prev_pos)) != string::npos) {\n            result.push_back(txt.substr(prev_pos, pos - prev_pos));\n            prev_pos = pos + 1;\n        }\n        // Add the last word if commas were found.\n        if (prev_pos < txt.size()) {\n            result.push_back(txt.substr(prev_pos));\n        }\n    }\n\n    // If no spaces or commas are present, count lowercase letters with odd order positions in the alphabet.\n    if (result.empty()) {\n        int count = 0;\n        for (char c : txt) {\n            if (islower(c) && ((c - 'a') % 2 == 1)) {\n                ++count;\n            }\n        }\n        result.push_back(to_string(count));\n    }\n\n    return result;\n}\n", "py_code": "def split_words(txt):\n    if ' ' in txt:\n        return txt.split(' ')\n    elif ',' in txt:\n        return txt.split(',')\n    else:\n        count = sum(1 for c in txt if (ord(c) - ord('a')) % 2 == 0)\n        return [str(count)]\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `split_words` takes a string as input and returns a list of words based on certain conditions. If there is at least one space in the input string, it splits the string by spaces using `txt.split(' ')`. If there are no spaces but commas exist, it splits the string by commas using `txt.split(',')`. If neither spaces nor commas are present, it counts the number of lowercase letters with even order positions in the alphabet (where 'a' is considered to have an order position of 0) and returns a list containing this count as a single-element list. The function uses the `ord` function to get the ASCII value of each character and calculates its relative position in the alphabet by subtracting the ASCII value of 'a'. If the resulting number is even, it increments the count.\n```\n\n"}
{"task_id": "CPP/160", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nint do_algebra(vector<string> operators, vector<int> operands) {\n    string expression = to_string(operands[0]);\n\n    for (size_t i = 0; i < operators.size(); ++i) {\n        const string& operator_str = operators[i];\n        int operand = operands[i + 1];\n\n        if (operator_str == \"//\") {\n            expression += \" / \";\n        } else if (operator_str == \"**\") {\n            expression += \" pow(\";\n            expression += to_string(operand);\n            expression += \", \";\n            expression += to_string(operands[i]);\n            expression += \") \";\n        } else {\n            expression += operator_str + \" \";\n            expression += to_string(operand) + \" \";\n        }\n    }\n\n    // Evaluate the expression using a simple parser\n    int result = operands[0];\n    for (size_t i = 0; i < operators.size(); ++i) {\n        const string& op = operators[i];\n        if (op == \"+\") {\n            result += operands[i + 1];\n        } else if (op == \"-\") {\n            result -= operands[i + 1];\n        } else if (op == \"*\") {\n            result *= operands[i + 1];\n        } else if (op == \"//\") {\n            result /= operands[i + 1];\n        } else if (op == \"**\") {\n            result = pow(result, operands[i + 1]);\n        }\n    }\n\n    return result;\n}\n", "py_code": "from typing import List\n\ndef do_algebra(operators: List[str], operands: List[int]) -> int:\n    expression = str(operands[0])\n    \n    for i in range(len(operators)):\n        operator = operators[i]\n        operand = operands[i + 1]\n\n        if operator == \"//\":\n            expression += f\" // {operand}\"\n        elif operator == \"**\":\n            expression += f\" ** {operand}\"\n        else:\n            expression += f\" {operator} {operand}\"\n\n    return eval(expression)\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `do_algebra` takes two lists as input: `operators`, which contains strings representing algebraic operations, and `operands`, a list of integers to be used in those operations.\n\n1. The function starts by initializing an empty string `expression` with the first operand from the `operands` list.\n2. It then iterates over each operator in the `operators` list:\n   - For each operator, it checks if the operator is \"//\" or \"**\", and appends the corresponding operation to the expression string along with the next integer from the `operands` list.\n   - If the operator is not \"//\" or \"**\", it simply concatenates the operator and the next operand to the expression string.\n3. After constructing the full algebraic expression as a string, the function uses Python's built-in `eval()` function to evaluate the constructed expression and return its result.\n\nThis approach constructs an algebraic expression from the given operators and operands, then evaluates it using Python's evaluation capabilities.\n\n"}
{"task_id": "CPP/151", "generation": "#include <vector>\n#include <cmath>\n\nlong long double_the_difference(std::vector<float> lst) {\n    long long sum = 0;\n    for (float x : lst) {\n        if (x > 0 && std::floor(x) == x && static_cast<int>(x) % 2 != 0) {\n            sum += static_cast<long long>(std::pow(x, 2));\n        }\n    }\n    return sum;\n}\n", "py_code": "from typing import List\n\ndef double_the_difference(lst: List[float]) -> int:\n    return sum(x**2 for x in lst if x > 0 and x == int(x) and x % 2 != 0)\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `double_the_difference` takes a list of floating-point numbers as input and returns an integer representing the sum of squares of the odd positive integers in the list. The function uses a generator expression within the `sum()` function to iterate over each element `x` in the list `lst`. It checks if `x` is greater than 0, if it's an integer (by comparing `x` with its integer conversion), and if it's odd (using `x % 2 != 0`). If all conditions are met, it squares the number (`x**2`) and adds it to the sum. The function returns this computed sum as an integer.\n\n"}
{"task_id": "CPP/117", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nbool is_consonant(char c) {\n    string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    return consonants.find(c) != string::npos;\n}\n\nint count_consonants(const string& word) {\n    int count = 0;\n    for (char c : word) {\n        if (is_consonant(c)) {\n            ++count;\n        }\n    }\n    return count;\n}\n\nvector<string> select_words(string s, int n) {\n    vector<string> result;\n    string word;\n    stringstream ss(s);\n    \n    while (ss >> word) {\n        if (count_consonants(word) == n) {\n            result.push_back(word);\n        }\n    }\n\n    return result;\n}\n", "py_code": "def select_words(s: str, n: int) -> list:\n    def count_consonants(word):\n        consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\n        return sum(1 for char in word if char in consonants)\n\n    words = s.split()\n    result = [word for word in words if count_consonants(word) == n]\n    return result\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `select_words` takes a string `s` and an integer `n`, and returns a list of words from `s` that contain exactly `n` consonants. The function first defines a helper function `count_consonants` which counts the number of consonants in a given word by iterating over each character and checking if it is part of the predefined string of consonants.\n\nThe main function then splits the input string into individual words using the `split()` method, which separates the string at spaces. It creates a list comprehension that iterates through these words and uses the `count_consonants` helper function to filter out only those words with exactly `n` consonants. The filtered words are collected in the result list, which is then returned by the function.\n```\n\n"}
{"task_id": "CPP/78", "generation": "#include <string>\n#include <set>\nusing namespace std;\n\nint hex_key(std::string num) {\n    // Set of prime hexadecimal digits.\n    std::set<char> prime_hex_digits = {'2', '3', '5', '7', 'B', 'D'};\n    \n    int count = 0;\n    for (char digit : num) {\n        if (prime_hex_digits.find(digit) != prime_hex_digits.end()) {\n            ++count;\n        }\n    }\n\n    return count;\n}\n", "py_code": "def hex_key(num):\n    prime_hex_digits = {'2', '3', '5', '7', 'B', 'D'}\n    return sum(1 for digit in num if digit in prime_hex_digits)\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `hex_key` takes a string `num`, which represents a hexadecimal number, and counts how many of its digits are prime numbers in the context of hexadecimal notation. The set `prime_hex_digits` contains the characters that represent prime numbers in hexadecimal format: '2', '3', '5', '7', 'B' (which is 11 in decimal), and 'D' (which is 13 in decimal). \n\nThe function uses a generator expression within the `sum()` function to iterate over each digit in the input string. For each digit, it checks if the digit is in the set of prime hexadecimal digits (`prime_hex_digits`). If the condition is true, it contributes a count of 1; otherwise, it does not contribute anything (effectively contributing 0). The `sum()` function then adds up all these counts to get the total number of prime hexadecimal digits in the input string. Finally, the function returns this sum as the result.\n```\n\n"}
{"task_id": "CPP/74", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> total_match(vector<string> lst1, vector<string> lst2) {\n    int count_lst1 = 0;\n    for (const string& s : lst1)\n        count_lst1 += s.length();\n\n    int count_lst2 = 0;\n    for (const string& s : lst2)\n        count_lst2 += s.length();\n    \n    if (count_lst1 <= count_lst2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n", "py_code": "def total_match(lst1, lst2):\n    # Calculate the total number of characters in each list\n    count_lst1 = sum(len(s) for s in lst1)\n    count_lst2 = sum(len(s) for s in lst2)\n\n    # Compare and return the appropriate list based on character counts\n    if count_lst1 <= count_lst2:\n        return lst1\n    else:\n        return lst2\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `total_match` takes two lists of strings (`lst1` and `lst2`) as input and returns one of these lists based on a comparison of their total number of characters.\n\n- The function first calculates the total number of characters in each list using a generator expression inside the `sum()` function. For `lst1`, it sums up the lengths of all strings, and similarly for `lst2`.\n  \n- It then compares the two counts (`count_lst1` and `count_lst2`). If `count_lst1` is less than or equal to `count_lst2`, it returns `lst1`. Otherwise, it returns `lst2`.\n\nThis approach ensures that the function always returns the list with fewer total characters. In case both lists have an equal number of characters, the function prefers and returns `lst1`.\n\n"}
{"task_id": "CPP/53", "generation": "#include<stdio.h>\n#include<stdlib.h>\nusing namespace std;\n\nint add(int x, int y) {\n    return x + y;\n}\n", "py_code": "def add(x, y):\n    return x + y\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `add` takes two integer arguments `x` and `y`, and returns their sum. The function simply adds the two numbers together using the addition operator (`+`) and returns the result.\n```\n\n"}
{"task_id": "CPP/98", "generation": "#include <string>\n#include <algorithm>\nusing namespace std;\n\nint count_upper(string s) {\n    string vowels = \"AEIOU\";\n    int count = 0;\n    for (size_t i = 0; i < s.length(); i += 2) { // Iterate over even indices\n        if (vowels.find(s[i]) != string::npos) { // Check if the character is an uppercase vowel\n            ++count;\n        }\n    }\n    return count;\n}\n", "py_code": "def count_upper(s):\n    vowels = \"AEIOU\"\n    return sum(1 for i in range(len(s)) if i % 2 == 0 and s[i] in vowels)\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `count_upper` takes a string `s` as input and returns the count of uppercase vowels that are located at even indices within the string. The function first defines a string `vowels` containing all uppercase vowel characters ('AEIOU'). It then uses a generator expression inside the `sum()` function to iterate over each character in the string, checking if its index is even (`i % 2 == 0`) and if it is an uppercase vowel (`s[i] in vowels`). The sum of these conditions being true gives the count of uppercase vowels at even indices.```\n\n"}
{"task_id": "CPP/140", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring fix_spaces(string text) {\n    string result = \"\";\n    int space_count = 0;\n\n    for (char c : text) {\n        if (c == ' ') {\n            space_count++;\n        } else {\n            if (space_count == 1) {\n                result += '_';\n            } else if (space_count > 2) {\n                result += '-';\n            }\n            space_count = 0;\n            result += c;\n        }\n    }\n\n    if (space_count == 1) {\n        result += '_';\n    } else if (space_count > 2) {\n        result += '-';\n    }\n\n    return result;\n}\n", "py_code": "def fix_spaces(text):\n    result = []\n    space_count = 0\n    \n    for char in text:\n        if char == ' ':\n            space_count += 1\n        else:\n            if space_count == 1:\n                result.append('_')\n            elif space_count > 2:\n                result.append('-')\n            space_count = 0\n            result.append(char)\n    \n    if space_count == 1:\n        result.append('_')\n    elif space_count > 2:\n        result.append('-')\n\n    return ''.join(result)\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `fix_spaces` takes a string `text` as input and processes it to replace spaces according to specific rules: single spaces are replaced with underscores ('_'), and more than two consecutive spaces are replaced with a dash ('-'). The function iterates through each character in the input string, tracking the number of consecutive spaces (`space_count`). \n\nWhen encountering non-space characters, the function checks `space_count`:\n1. If there was exactly one space before the current character, it appends an underscore to the result list.\n2. If there were more than two consecutive spaces, it appends a dash.\n\nAfter processing all characters in the string, if there are trailing spaces (i.e., at the end of the string), they are also handled according to their count (`space_count`). Finally, the function joins the elements of the result list into a single string and returns it.\n\n"}
{"task_id": "CPP/34", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\n#include <set>\nusing namespace std;\n\nvector<int> unique(vector<int> l) {\n    set<int> s(l.begin(), l.end()); // Convert vector to set to remove duplicates\n    return vector<int>(s.begin(), s.end()); // Convert set back to sorted vector\n}\n", "py_code": "def unique(l):\n    return sorted(set(l))\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `unique` takes a list of integers as input and returns a new list containing only the unique elements from the original list in sorted order. The function achieves this by first converting the list into a set, which automatically removes any duplicate values since sets cannot contain duplicates. Then it converts the set back to a list and sorts it before returning. This ensures that the output is both unique and sorted.```\n\n"}
{"task_id": "CPP/66", "generation": "#include <string>\n#include <cctype> // for isupper function\nusing namespace std;\n\nint digitSum(string s) {\n    int sum = 0;\n    for (char c : s) {\n        if (isupper(c)) {\n            sum += static_cast<int>(c);\n        }\n    }\n    return sum;\n}\n", "py_code": "def digitSum(s):\n    return sum(ord(c) for c in s if c.isupper())\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `digitSum` takes a string `s` as input and returns the sum of ASCII values of all uppercase characters in the string. The function uses a generator expression inside the `sum()` function to iterate over each character `c` in the string `s`. For each character, it checks if the character is an uppercase letter using the `isupper()` method. If true, it calculates the ASCII value of that character using the `ord()` function and adds it to the sum. The result is the total sum of ASCII values for all uppercase characters in the input string.```\n"}
{"task_id": "CPP/120", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> maximum(vector<int> arr, int k) {\n    // Sort the array in descending order.\n    sort(arr.begin(), arr.end(), greater<int>());\n    \n    // Take the first k elements from the sorted array.\n    vector<int> result(arr.begin(), arr.begin() + k);\n    \n    // Sort these k elements in ascending order before returning.\n    sort(result.begin(), result.end());\n    \n    return result;\n}\n", "py_code": "from typing import List\n\ndef maximum(arr: List[int], k: int) -> List[int]:\n    # Sort the array in descending order and take the first k elements.\n    sorted_arr = sorted(arr, reverse=True)[:k]\n    # Return these k elements in ascending order.\n    return sorted(sorted_arr)\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `maximum` takes a list of integers (`arr`) and an integer (`k`). The goal is to find the maximum `k` numbers from the input list and return them in ascending order.\n\n1. First, it sorts the entire array in descending order using `sorted(arr, reverse=True)`. This ensures that the largest elements come first.\n2. It then slices the sorted array to get only the first `k` elements with `[:k]`.\n3. Finally, it returns these `k` elements sorted in ascending order by applying another sort operation on them.\n\nThis approach guarantees that we have the maximum `k` numbers from the original list and they are returned in ascending order as required.\n```\n\n"}
{"task_id": "CPP/139", "generation": "#include <iostream>\nusing namespace std;\n\nlong long factorial(long long num) {\n    if (num == 0 || num == 1)\n        return 1;\n    else\n        return num * factorial(num - 1);\n}\n\nlong long special_factorial(int n) {\n    long long result = 1;\n    for (int i = 1; i <= n; ++i) {\n        result *= factorial(i);\n    }\n    return result;\n}\n", "py_code": "def factorial(num):\n    if num == 0 or num == 1:\n        return 1\n    else:\n        return num * factorial(num - 1)\n\ndef special_factorial(n):\n    result = 1\n    for i in range(1, n + 1):\n        result *= factorial(i)\n    return result\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python solution consists of two functions: `factorial` and `special_factorial`. The `factorial` function is a recursive function that calculates the factorial of a given number `num`. It returns 1 if `num` is either 0 or 1 (base case), otherwise it recursively multiplies `num` by the factorial of `num - 1`.\n\nThe `special_factorial` function calculates the Brazilian factorial as defined in the problem statement. It initializes `result` to 1 and iterates through all integers from 1 up to `n`, multiplying `result` by the factorial of each integer using the `factorial` function. The final value of `result` is returned, which represents the special factorial of `n`.```\n\n"}
{"task_id": "CPP/12", "generation": "#include <vector>\n#include <string>\nusing namespace std;\n\nstring longest(vector<string> strings) {\n    if (strings.empty()) {\n        return \"\"; // In C++, we cannot return None like in Python. Returning an empty string instead.\n    }\n    \n    int max_length = -1;\n    string result = \"\";\n    \n    for (const auto& s : strings) {\n        if (s.length() > max_length) {\n            max_length = s.length();\n            result = s;\n        }\n    }\n    \n    return result;\n}\n", "py_code": "def longest(strings):\n    if not strings:\n        return None\n    max_length = -1\n    result = \"\"\n    for s in strings:\n        if len(s) > max_length:\n            max_length = len(s)\n            result = s\n    return result\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `longest` takes a list of strings as input and returns the longest string from that list. If there are multiple strings with the same maximum length, it returns the first one encountered. The function returns `None` if the input list is empty.\n\nHere's how the function works:\n1. It checks whether the input list `strings` is empty; if so, it immediately returns `None`.\n2. It initializes two variables: `max_length` to keep track of the length of the longest string found so far (initialized to -1) and `result` to store the longest string.\n3. The function then iterates over each string in the list:\n   - For each string, it checks if its length is greater than `max_length`.\n   - If it is, it updates `max_length` with the new maximum length and sets `result` to the current string.\n4. After iterating through all strings, the function returns `result`, which contains the longest string found.\n\nThis approach ensures that in case of multiple strings having the same length (which is the maximum), the first one encountered will be returned as per the requirement.\n\n"}
{"task_id": "CPP/121", "generation": "#include <vector>\nusing namespace std;\n\nint solution(vector<int> lst) {\n    int sum = 0;\n    for (size_t i = 0; i < lst.size(); i += 2) { // Iterate over even positions\n        if (lst[i] % 2 != 0) { // Check if the element is odd\n            sum += lst[i]; // Add to sum if conditions are met\n        }\n    }\n    return sum;\n}\n", "py_code": "def solution(lst):\n    return sum(x for i, x in enumerate(lst) if i % 2 == 0 and x % 2 != 0)\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `solution` takes a list of integers as input and returns the sum of all odd elements that are located at even positions (considering 0-based indexing). The function uses a generator expression within the `sum()` function to iterate over the enumerated list. For each element in the list, it checks if its index is even (`i % 2 == 0`) and if the value itself is an odd number (`x % 2 != 0`). If both conditions are met, the value is included in the sum. The result of this generator expression is then summed up by `sum()` and returned as the final output.\n```"}
{"task_id": "CPP/35", "generation": "#include <vector>\n#include <algorithm> // for std::max_element\nusing namespace std;\n\nfloat max_element(vector<float> l) {\n    return *std::max_element(l.begin(), l.end());\n}\n", "py_code": "def max_element(l):\n    return max(l)\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `max_element` takes a list of numbers (`l`) as input and returns the maximum element in that list using the built-in `max()` function. The `max()` function iterates through all elements in the list to find and return the largest value.\n```\n\n"}
{"task_id": "CPP/20", "generation": "#include <algorithm>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nvector<float> find_closest_elements(vector<float> numbers) {\n    // Sort the vector of numbers in ascending order.\n    sort(numbers.begin(), numbers.end());\n\n    float min_diff = numeric_limits<float>::max();\n    pair<float, float> closest_pair(0.0f, 0.0f);\n\n    for (size_t i = 0; i < numbers.size() - 1; ++i) {\n        // Calculate the difference between adjacent elements.\n        float diff = numbers[i + 1] - numbers[i];\n        \n        // Update the minimum difference and closest pair if a smaller difference is found.\n        if (diff < min_diff) {\n            min_diff = diff;\n            closest_pair.first = numbers[i];\n            closest_pair.second = numbers[i + 1];\n        }\n    }\n\n    // Convert the pair to vector for return\n    vector<float> result{closest_pair.first, closest_pair.second};\n    return result;\n}\n", "py_code": "from typing import List\n\ndef find_closest_elements(numbers: List[float]) -> tuple:\n    numbers.sort()\n    min_diff = float('inf')\n    result = (0, 0)\n    for i in range(len(numbers) - 1):\n        diff = numbers[i + 1] - numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            result = (numbers[i], numbers[i + 1])\n    return result\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `find_closest_elements` takes a list of floating-point numbers as input and returns a tuple containing the two closest elements from that list in ascending order.\n\n1. The function first sorts the list of numbers to ensure they are in ascending order.\n2. It initializes `min_diff` with positive infinity (`float('inf')`) to keep track of the minimum difference between any pair of adjacent numbers found so far, and `result` as a tuple `(0, 0)` to store the closest pair.\n3. The function then iterates through the sorted list using a for loop from index 0 to len(numbers) - 2 (i.e., up to the second last element). For each iteration:\n   - It calculates the difference between the current number and its next neighbor (`numbers[i + 1]`).\n   - If this difference is smaller than `min_diff`, it updates `min_diff` with this new value and sets `result` to the pair `(numbers[i], numbers[i+1])`.\n4. After completing the loop, the function returns the tuple `result` which contains the two closest elements in ascending order.\n\nThis approach ensures that we find the smallest difference between any two adjacent elements in a sorted list, thereby identifying the two closest elements efficiently.\n"}
{"task_id": "CPP/19", "generation": "#include <iostream>\n#include <vector>\n#include <sstream>\n#include <algorithm>\n#include <map>\nusing namespace std;\n\nstring sort_numbers(string numbers) {\n    // Define a map for numeral to integer conversion.\n    map<string, int> numeral_map = {\n        {\"zero\", 0},\n        {\"one\", 1},\n        {\"two\", 2},\n        {\"three\", 3},\n        {\"four\", 4},\n        {\"five\", 5},\n        {\"six\", 6},\n        {\"seven\", 7},\n        {\"eight\", 8},\n        {\"nine\", 9}\n    };\n\n    // Convert the input string to a vector of numerals.\n    stringstream ss(numbers);\n    string numeral;\n    vector<string> num_list;\n    while (ss >> numeral) {\n        num_list.push_back(numeral);\n    }\n\n    // Sort the numerals based on their integer values.\n    sort(num_list.begin(), num_list.end(),\n         [&numeral_map](const string& a, const string& b) {\n             return numeral_map[a] < numeral_map[b];\n         });\n\n    // Convert back to space-separated string.\n    stringstream sorted_str;\n    for (size_t i = 0; i < num_list.size(); ++i) {\n        if (i > 0) {\n            sorted_str << \" \";\n        }\n        sorted_str << num_list[i];\n    }\n\n    return sorted_str.str();\n}\n", "py_code": "def sort_numbers(numbers):\n    numeral_map = {\n        \"zero\": 0,\n        \"one\": 1,\n        \"two\": 2,\n        \"three\": 3,\n        \"four\": 4,\n        \"five\": 5,\n        \"six\": 6,\n        \"seven\": 7,\n        \"eight\": 8,\n        \"nine\": 9\n    }\n    \n    # Split the input string into a list of numerals\n    num_list = numbers.split()\n    \n    # Convert the numerals to their corresponding integer values\n    int_values = [numeral_map[num] for num in num_list]\n    \n    # Sort the integers\n    sorted_ints = sorted(int_values)\n    \n    # Convert back to string numerals\n    sorted_num_strings = [k for k, v in numeral_map.items() if v in sorted_ints]\n    \n    return ' '.join(sorted_num_strings)\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `sort_numbers` takes a space-delimited string of number words (from \"zero\" to \"nine\") and returns them sorted from smallest to largest as a space-separated string.\n\n1. A dictionary (`numeral_map`) is defined that maps each number word to its corresponding integer value.\n2. The input string is split into individual number words using the `split()` method, resulting in a list of strings (`num_list`).\n3. Each number word from this list is converted to its integer equivalent by looking up the dictionary and creating a new list (`int_values`) containing these integers.\n4. This list of integers is then sorted in ascending order to get `sorted_ints`.\n5. The function then creates a list of string numerals corresponding to the sorted integers using a list comprehension that iterates over the items in `numeral_map` and checks if their integer value exists in `sorted_ints`. \n6. Finally, these sorted number words are joined into a single space-separated string with `' '.join(sorted_num_strings)` and returned.\n\nThis approach ensures that the input number words are correctly mapped to integers for sorting purposes and then converted back to their word form before being returned as a sorted list.\n```\n\n"}
{"task_id": "CPP/85", "generation": "#include <vector>\nusing namespace std;\n\nint add(vector<int> lst) {\n    int result = 0;\n    for (size_t i = 1; i < lst.size(); i += 2) { // Start from index 1 and increment by 2 (odd indices)\n        if (lst[i] % 2 == 0) { // Check if element at odd index is even\n            result += lst[i];\n        }\n    }\n    return result;\n}\n", "py_code": "def add(lst):\n    result = 0\n    for i in range(1, len(lst), 2):  # Start from index 1 and increment by 2 (odd indices)\n        if lst[i] % 2 == 0:  # Check if element at odd index is even\n            result += lst[i]\n    return result\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `add` takes a list of integers as input and returns the sum of all even elements that are located at odd indices in the list. The function iterates over the list using a for loop starting from index 1 (the second element) and increments by 2 to ensure only odd indices are considered. For each element at an odd index, it checks if the element is even. If so, it adds this element's value to `result`. Finally, the function returns the accumulated sum in `result`.```\n\n"}
{"task_id": "CPP/21", "generation": "#include <stdio.h>\n#include <math.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<float> rescale_to_unit(vector<float> numbers) {\n    float min_val = *min_element(numbers.begin(), numbers.end());\n    float max_val = *max_element(numbers.begin(), numbers.end());\n    float range_val = max_val - min_val;\n    \n    vector<float> result;\n    for (float x : numbers) {\n        result.push_back((x - min_val) / range_val);\n    }\n    return result;\n}\n", "py_code": "from typing import List\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    min_val = min(numbers)\n    max_val = max(numbers)\n    range_val = max_val - min_val\n    return [(x - min_val) / range_val for x in numbers]\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `rescale_to_unit` takes a list of floating-point numbers as input and returns a new list where each number is rescaled such that the smallest number in the original list becomes 0 and the largest becomes 1. The function first determines the minimum (`min_val`) and maximum (`max_val`) values from the input list. It then calculates the range (`range_val`) of these numbers as `max_val - min_val`. \n\nThe function uses a list comprehension to iterate over each number in the original list, subtracts the minimum value from it, and divides by the range to rescale it between 0 and 1. The resulting list is returned.\n```\n\n"}
{"task_id": "CPP/119", "generation": "#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nbool is_balanced(const string& s) {\n    int balance = 0;\n    for (char c : s) {\n        if (c == '(') {\n            ++balance;\n        } else {\n            --balance;\n            if (balance < 0) return false; // More closing than opening\n        }\n    }\n    return balance == 0; // Balanced only if balance is zero at the end\n}\n\nstring match_parens(vector<string> lst) {\n    string s1 = lst[0], s2 = lst[1];\n    \n    // Check both possible concatenations\n    if (is_balanced(s1 + s2) || is_balanced(s2 + s1)) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\n", "py_code": "def match_parens(lst):\n    def is_balanced(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            else:\n                balance -= 1\n                if balance < 0:\n                    return False\n        return balance == 0\n\n    # Check both possible concatenations\n    if is_balanced(lst[0] + lst[1]) or is_balanced(lst[1] + lst[0]):\n        return \"Yes\"\n    else:\n        return \"No\"\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `match_parens` takes a list of two strings as input and checks if it is possible to concatenate these strings in some order such that the resulting string has balanced parentheses.\n\n1. **Helper Function**: The helper function `is_balanced(s)` determines whether a given string `s` has balanced parentheses by iterating through each character:\n   - If an opening parenthesis '(' is encountered, the balance counter is incremented.\n   - If a closing parenthesis ')' is encountered, the balance counter is decremented.\n   - If at any point the balance counter becomes negative, it means there are more closing parentheses than opening ones before that point, and thus the string cannot be balanced. The function returns `False` in this case.\n   - After iterating through all characters, if the balance counter is zero, the string has balanced parentheses; otherwise, it does not.\n\n2. **Main Function Logic**: \n   - The main function checks both possible concatenations of the two strings: `lst[0] + lst[1]` and `lst[1] + lst[0]`.\n   - It uses the helper function to check if either concatenated string is balanced.\n   - If any of these concatenated strings are balanced, it returns \"Yes\".\n   - Otherwise, it returns \"No\".\n\n"}
{"task_id": "CPP/30", "generation": "#include <stdio.h>\n#include <math.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<float> get_positive(vector<float> l) {\n    vector<float> result;\n    for (float num : l) {\n        if (num > 0) {\n            result.push_back(num);\n        }\n    }\n    return result;\n}\n", "py_code": "from typing import List\n\ndef get_positive(l: List[float]) -> List[float]:\n    return [num for num in l if num > 0]\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `get_positive` takes a list of floating-point numbers as input and returns a new list containing only the positive numbers from the original list. It uses a list comprehension to iterate through each number in the input list and includes it in the output list if it is greater than zero (i.e., positive). This approach ensures that all non-positive numbers are filtered out, leaving only the desired elements in the result.\n```\n\n"}
{"task_id": "CPP/64", "generation": "#include <string>\n#include <algorithm>\nusing namespace std;\n\nbool is_vowel(char c) {\n    return c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' ||\n           c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U';\n}\n\nint vowels_count(string s) {\n    int count = 0;\n    for (char c : s) {\n        if (is_vowel(c)) {\n            ++count;\n        }\n    }\n\n    // Check if the last character is a vowel 'y' or 'Y'\n    if (!s.empty() && (s.back() == 'y' || s.back() == 'Y')) {\n        ++count;\n    }\n\n    return count;\n}\n", "py_code": "def vowels_count(s):\n    vowels = 'aeiouAEIOU'\n    count = sum(1 for char in s if char in vowels)\n    # Check if last character is a vowel 'y' or 'Y'\n    if s and (s[-1] == 'y' or s[-1] == 'Y'):\n        count += 1\n    return count\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `vowels_count` takes a string as input and returns the number of vowels in it. The function first defines a string containing all vowels (both lowercase and uppercase). It then uses a generator expression within the `sum()` function to count how many characters in the given string are present in the defined vowels string.\n\nAdditionally, the function checks if the last character of the input string is 'y' or 'Y', which counts as a vowel only when it's at the end of the word. If this condition is met, the count is incremented by one. Finally, the function returns the total count of vowels found in the string.\n```\n\n"}
{"task_id": "CPP/128", "generation": "#include <vector>\n#include <cmath>\nusing namespace std;\n\nint prod_signs(vector<int> arr) {\n    if (arr.empty()) return -32768;\n\n    int sign_product = 1;\n    int magnitude_sum = 0;\n\n    for (int num : arr) {\n        magnitude_sum += abs(num);\n        if (num < 0) {\n            sign_product *= -1;\n        } else if (num == 0) {\n            sign_product = 0;\n            break;\n        }\n    }\n\n    return magnitude_sum * sign_product;\n}\n", "py_code": "from typing import List\n\ndef prod_signs(arr: List[int]) -> int:\n    if not arr:\n        return -32768\n    \n    sign_product = 1\n    magnitude_sum = 0\n    \n    for num in arr:\n        magnitude_sum += abs(num)\n        if num < 0:\n            sign_product *= -1\n        elif num == 0:\n            sign_product = 0\n            break\n            \n    return magnitude_sum * sign_product\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `prod_signs` takes a list of integers as input and returns an integer that is the sum of magnitudes of these integers multiplied by the product of all their signs (represented by 1 for positive numbers, -1 for negative numbers, and 0 for zero). If the input list is empty, it returns `-32768`.\n\nThe function first checks if the input list `arr` is empty. If so, it immediately returns `-32768`. Otherwise, it initializes two variables: `sign_product` to keep track of the product of signs and `magnitude_sum` to accumulate the sum of magnitudes.\n\nIt then iterates through each number in the list:\n- It adds the absolute value (magnitude) of the current number to `magnitude_sum`.\n- If the number is negative, it multiplies `sign_product` by `-1`. \n- If the number is zero, it sets `sign_product` to 0 and breaks out of the loop since any further multiplication with zeros will keep the product as zero.\n\nFinally, the function returns the result of multiplying `magnitude_sum` by `sign_product`.\n\n"}
{"task_id": "CPP/127", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <cmath>\nusing namespace std;\n\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i <= sqrt(n); ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\nstring intersection(vector<int> interval1, vector<int> interval2) {\n    int start_max = max(interval1[0], interval2[0]);\n    int end_min = min(interval1[1], interval2[1]);\n\n    if (start_max > end_min) {\n        // No intersection\n        return \"NO\";\n    }\n\n    int length_of_intersection = end_min - start_max + 1;\n\n    if (is_prime(length_of_intersection)) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n", "py_code": "from typing import List\n\ndef is_prime(n: int) -> bool:\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef intersection(interval1: List[int], interval2: List[int]) -> str:\n    start_max = max(interval1[0], interval2[0])\n    end_min = min(interval1[1], interval2[1])\n\n    # Check if there is an intersection\n    if start_max > end_min:\n        return \"NO\"\n\n    length_of_intersection = end_min - start_max + 1\n\n    # Determine if the length of intersection is a prime number\n    if is_prime(length_of_intersection):\n        return \"YES\"\n    else:\n        return \"NO\"\n```\n\n", "py_summary": "### Analysis of Python Code:\n\nThe provided Python function `intersection` takes two intervals as input and determines whether the length of their intersection is a prime number. The function follows these steps:\n1. **Prime Check Function**: A helper function `is_prime(n)` checks if a given integer `n` is a prime number by iterating from 2 to the square root of `n`. If any divisor exists, it returns `False`; otherwise, it returns `True`.\n   \n2. **Intersection Calculation**:\n   - The start and end points for the intersection are calculated using `start_max = max(interval1[0], interval2[0])` and `end_min = min(interval1[1], interval2[1])`. This ensures that we get the overlapping segment between the two intervals.\n   \n3. **Check Intersection**:\n   - The function checks if there is an intersection by comparing `start_max` with `end_min`. If `start_max > end_min`, it means no overlap exists, and \"NO\" is returned.\n\n4. **Length of Intersection**:\n   - If the intervals intersect, the length of the intersection is calculated as `length_of_intersection = end_min - start_max + 1`.\n\n5. **Prime Check on Length**:\n   - The function then checks if this length is a prime number using the `is_prime` helper function.\n   \n6. **Return Result**:\n   - If the length is prime, \"YES\" is returned; otherwise, \"NO\" is returned.\n\n"}
{"task_id": "CPP/122", "generation": "#include <vector>\nusing namespace std;\n\nint add_elements(vector<int> arr, int k) {\n    int sum = 0;\n    for (int i = 0; i < k; ++i) {\n        if (arr[i] >= -99 && arr[i] <= 99) {\n            sum += arr[i];\n        }\n    }\n    return sum;\n}\n", "py_code": "def add_elements(arr, k):\n    return sum(x for x in arr[:k] if -100 < x < 100)\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `add_elements` takes a list of integers (`arr`) and an integer (`k`). It returns the sum of elements from the first `k` elements in the list that have at most two digits (i.e., their absolute value is less than 100). The function uses a generator expression within the `sum()` function to iterate over the first `k` elements of the array and filter out those with more than two digits. It then sums up the remaining values and returns this sum.\n```\n\n"}
{"task_id": "CPP/59", "generation": "#include <iostream>\nusing namespace std;\n\nint largest_prime_factor(int n) {\n    int i = 2;\n    while (i * i <= n) {\n        if (n % i != 0) {\n            i += 1;\n        } else {\n            n /= i;\n        }\n    }\n    return n;\n}\n", "py_code": "def largest_prime_factor(n):\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `largest_prime_factor` is designed to find and return the largest prime factor of a given integer `n`. The algorithm starts by initializing a variable `i` with 2, which is the smallest prime number. It then enters a loop where it checks if `i * i` is less than or equal to `n`.\n\nInside this loop:\n- If `n % i` (the remainder when `n` is divided by `i`) is non-zero, it means that `i` is not a factor of `n`, so the function increments `i`.\n- Otherwise, if `n % i` equals zero, it indicates that `i` is indeed a factor of `n`. The function then divides `n` by `i` and continues to check for further factors.\n\nThe loop continues until `i * i` exceeds `n`, at which point the remaining value of `n` must be prime (since all smaller factors have been divided out). This remaining value is the largest prime factor, so it's returned as the result. \n\nThis approach ensures that the function efficiently finds the largest prime factor by continuously dividing `n` by its smallest factors until only the largest one remains.\n\n"}
{"task_id": "CPP/134", "generation": "#include <string>\n#include <cctype> // for isalpha function\nusing namespace std;\n\nbool check_if_last_char_is_a_letter(string txt) {\n    if (txt.empty() || (!txt.empty() && txt.back() == ' '))\n        return false;\n    \n    string stripped_txt = txt;\n    stripped_txt.erase(stripped_txt.find_last_not_of(\" \") + 1);\n    \n    char last_char = stripped_txt.back();\n    bool is_alpha = isalpha(last_char);\n    bool is_preceded_by_space_or_single_char = (stripped_txt.size() == 1) || (stripped_txt[stripped_txt.size() - 2] == ' ');\n    \n    return is_alpha && is_preceded_by_space_or_single_char;\n}\n", "py_code": "def check_if_last_char_is_a_letter(txt):\n    if not txt or (len(txt) > 0 and txt[-1] == ' '): \n        return False\n    stripped_txt = txt.rstrip()\n    last_char = stripped_txt[-1]\n    return last_char.isalpha() and (' ' in stripped_txt[-2:] or len(stripped_txt) == 1)\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `check_if_last_char_is_a_letter` checks if the last non-space character of a given string is an alphabetical letter and not part of a word (i.e., it should be preceded by a space or be the only character in the string). \n\n1. The function first handles edge cases: If the input string is empty (`not txt`) or ends with a space (`txt[-1] == ' '`), it returns `False`.\n2. It then strips trailing spaces from the end of the string using `rstrip()`, which ensures that any trailing whitespace does not affect the check.\n3. The function retrieves the last character of the stripped string and checks if this character is an alphabetical letter (`last_char.isalpha()`).\n4. Finally, it verifies whether the last character is not part of a word by checking if there's a space before it (`' ' in stripped_txt[-2:]`) or if the entire string consists of just one character (`len(stripped_txt) == 1`).\n\nIf all conditions are met, the function returns `True`; otherwise, it returns `False`.```\n\n"}
{"task_id": "CPP/42", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> incr_list(vector<int> l) {\n    for (size_t i = 0; i < l.size(); ++i) {\n        l[i] += 1;\n    }\n    return l;\n}\n", "py_code": "def incr_vector(l):\n    return [x + 1 for x in l]\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `incr_vector` takes a list of integers as input and returns a new list where each element is incremented by 1. This is achieved using a list comprehension that iterates over each element in the input list `l`, adds 1 to it, and constructs a new list with these updated values. The resulting list is then returned.\n```"}
{"task_id": "CPP/11", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring string_xor(string a, string b) {\n    string result = \"\";\n    for (size_t i = 0; i < a.length(); ++i) {\n        // XOR operation: if characters are different, append '1', else append '0'\n        if (a[i] != b[i]) {\n            result += \"1\";\n        } else {\n            result += \"0\";\n        }\n    }\n    return result;\n}\n", "py_code": "def string_xor(a, b):\n    result = \"\"\n    for i in range(len(a)):\n        # XOR operation: if characters are different, append '1', else append '0'\n        if a[i] != b[i]:\n            result += \"1\"\n        else:\n            result += \"0\"\n    return result\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `string_xor` takes two strings `a` and `b`, both consisting only of '1's and '0's, as input parameters. The goal is to perform a binary XOR operation on these strings and return the result as another string.\n\nHere\u2019s how it works:\n- The function initializes an empty string `result`.\n- It iterates over each character in the strings using their indices.\n- For each pair of characters at the same index from both input strings, it checks if they are different. If so, it appends '1' to the result (since XOR returns 1 when inputs differ). Otherwise, it appends '0'.\n- Finally, after processing all pairs of characters, the function returns the `result` string.\n\nThis approach ensures that each character in the input strings is compared with its corresponding character from the other string and the resulting binary XOR operation's output is accumulated into a new string which is returned as the final result.\n```\n\n"}
{"task_id": "CPP/40", "generation": "#include <vector>\nusing namespace std;\n\nbool triples_sum_to_zero(vector<int> l) {\n    int n = l.size();\n    for (int i = 0; i < n - 2; ++i) {\n        for (int j = i + 1; j < n - 1; ++j) {\n            for (int k = j + 1; k < n; ++k) {\n                if (l[i] + l[j] + l[k] == 0) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n", "py_code": "def triples_sum_to_zero(l):\n    n = len(l)\n    for i in range(n-2):\n        for j in range(i+1, n-1):\n            for k in range(j+1, n):\n                if l[i] + l[j] + l[k] == 0:\n                    return True\n    return False\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `triples_sum_to_zero` checks whether there are three distinct elements in a given list that sum to zero. The function iterates through all possible combinations of three different indices (i, j, k) where i < j < k using nested loops. For each combination, it calculates the sum of the corresponding elements and checks if this sum equals zero. If such a triplet is found, the function returns `True`. If no such triplet exists after checking all possibilities, the function returns `False`.\n\nThis brute-force approach has a time complexity of O(n^3) due to the three nested loops iterating over the list indices.\n\n"}
{"task_id": "CPP/13", "generation": "#include <iostream>\nusing namespace std;\n\nint greatest_common_divisor(int a, int b) {\n    while (b != 0) {\n        int temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n", "py_code": "def greatest_common_divisor(a, b):\n    while b != 0:\n        a, b = b, a % b\n    return a\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `greatest_common_divisor` computes the greatest common divisor (GCD) of two integers `a` and `b`. It uses the Euclidean algorithm to find the GCD iteratively. The algorithm works by repeatedly replacing `a` with `b`, and `b` with the remainder of `a` divided by `b` until `b` becomes zero. At this point, `a` contains the greatest common divisor of the original two numbers.\n\nThe function takes two integer arguments `a` and `b`. It enters a loop where it continuously updates `a` to be `b`, and `b` to be the remainder when `a` is divided by `b`. This process continues until `b` becomes zero, at which point the value of `a` will be the GCD. The function then returns this value.\n\n"}
{"task_id": "CPP/130", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nvector<int> tri(int n) {\n    vector<int> result(n + 1);\n    \n    // Base cases\n    if (n >= 0) result[0] = 1;\n    if (n >= 1) result[1] = 3;\n\n    for (int i = 2; i <= n; ++i) {\n        if (i % 2 == 0) {\n            // If even\n            result[i] = 1 + i / 2;\n        } else {\n            // If odd, calculate based on the previous values and an assumed base case for tri(-1)\n            int next_val = result[i - 1] + result[i - 2];\n            if (i > 2) {\n                next_val += result[i - 3];  // Use the value from three steps back\n            } else {\n                next_val += 1;              // Assume tri(-1) is 1 for base case\n            }\n            result[i] = next_val;\n        }\n    }\n\n    return result;\n}\n", "py_code": "def tri(n):\n    if n == 0:\n        return [1]\n    elif n == 1:\n        return [1, 3]\n    \n    result = [1, 3]\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            result.append(1 + i // 2)\n        else:\n            # Since we don't have tri(n+1) directly available, we will calculate it as needed\n            next_val = result[-1] + result[-2]\n            if len(result) > 2:\n                next_val += result[-3]\n            else:\n                next_val += 1  # Assuming tri(-1) is 1 for the base case\n            result.append(next_val)\n    return result\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `tri(n)` generates a list of the first `n + 1` numbers in the Tribonacci sequence as defined by the problem statement. The function starts with base cases for `n = 0` and `n = 1`. For larger values of `n`, it iterates from 2 to `n`, calculating each value based on whether `i` is even or odd.\n\n- If `i` is even, the value is calculated as `1 + i // 2`.\n- If `i` is odd, the function calculates the value by summing up the last two elements in the result list and an assumed base case for `tri(-1)` (which is set to 1).\n\nThe function returns a list containing the first `n + 1` numbers of the Tribonacci sequence.\n\n"}
{"task_id": "CPP/60", "generation": "#include<stdio.h>\nusing namespace std;\n\nint sum_to_n(int n) {\n    return n * (n + 1) / 2;\n}\n", "py_code": "def sum_to_n(n):\n    return n * (n + 1) // 2\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `sum_to_n` calculates the sum of all integers from 1 to `n`. It uses a mathematical formula for the sum of an arithmetic series: n * (n + 1) / 2. This formula is derived from the fact that the sum of the first n natural numbers can be calculated by multiplying the average value ((n+1)/2) with the count of numbers (n). The use of integer division (`//`) ensures that the result is an integer, which matches the expected return type for this function.```\n\n"}
{"task_id": "CPP/23", "generation": "#include <string>\nusing namespace std;\n\nint strlen(string str) {\n    return str.length();\n}\n", "py_code": "def strlen(str):\n    return len(str)\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `strlen` takes a string as input and returns its length using the built-in `len()` function. This function is straightforward and utilizes Python's standard library to determine the number of characters in the given string.```\n\n"}
{"task_id": "CPP/46", "generation": "#include <iostream>\n\nint fib4(int n) {\n    if (n < 2) return 0;\n    else if (n == 2) return 2;\n    else if (n == 3) return 0;\n\n    int a = 0, b = 0, c = 2, d = 0;\n\n    for (int i = 4; i <= n; ++i) {\n        int next_val = a + b + c + d;\n        a = b;\n        b = c;\n        c = d;\n        d = next_val;\n    }\n\n    return d;\n}\n\n", "py_code": "def fib4(n):\n    if n < 2:\n        return 0\n    elif n == 2:\n        return 2\n    elif n == 3:\n        return 0\n    \n    # Initialize base cases\n    a, b, c, d = 0, 0, 2, 0\n\n    for _ in range(4, n + 1):\n        a, b, c, d = b, c, d, a + b + c + d\n    \n    return d\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `fib4` computes the n-th element of the Fib4 number sequence without using recursion for efficiency. The function first handles base cases where `n` is less than 4 by returning predefined values (0, 2, or 0). For larger values of `n`, it initializes four variables (`a`, `b`, `c`, and `d`) to represent the last four elements in the sequence up to the third index. It then iterates from 4 to `n` updating these variables so that they always hold the last four numbers in the sequence, with `d` representing the current value of the Fib4 sequence at each step.\n\nThe loop updates the values by shifting them one position back and setting `d` as the sum of the previous four elements. This way, after completing the iteration up to `n`, `d` holds the n-th element of the Fib4 sequence which is returned as the result.\n```\n\n"}
{"task_id": "CPP/51", "generation": "#include <stdio.h>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nstring remove_vowels(string text) {\n    string vowels = \"aeiouAEIOU\";\n    string result = \"\";\n    for (char c : text) {\n        if (vowels.find(c) == string::npos) {\n            result += c;\n        }\n    }\n    return result;\n}\n", "py_code": "def remove_vowels(text):\n    vowels = \"aeiouAEIOU\"\n    return ''.join([char for char in text if char not in vowels])\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `remove_vowels` takes a string as input and returns a new string with all vowels removed. The function defines a string of vowels (both lowercase and uppercase) and then uses a list comprehension to iterate through each character in the input text. If the character is not found within the defined set of vowels, it is included in the resulting list. Finally, `''.join()` is used to concatenate the characters into a single string without any vowels.\n```\n\n"}
{"task_id": "CPP/18", "generation": "#include <string>\nusing namespace std;\n\nint how_many_times(string str, string substring) {\n    int count = 0;\n    int sub_len = substring.length();\n    \n    for (int i = 0; i <= str.length() - sub_len; ++i) {\n        if (str.substr(i, sub_len) == substring) {\n            count++;\n        }\n    }\n\n    return count;\n}\n", "py_code": "def how_many_times(str, substring):\n    count = 0\n    sub_len = len(substring)\n    for i in range(len(str) - sub_len + 1):\n        if str[i:i+sub_len] == substring:\n            count += 1\n    return count\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `how_many_times` takes two string arguments: `str` and `substring`. The goal is to find how many times the `substring` appears in the original string `str`, including overlapping occurrences.\n\n1. **Initialization**: A variable `count` is initialized to 0, which will keep track of the number of occurrences.\n2. **Length Calculation**: The length of the substring (`sub_len`) is calculated once and stored for efficiency.\n3. **Iteration**: The function iterates over all possible starting positions in `str` where a match could begin (from index 0 to `len(str) - sub_len`). This ensures that we check every position up to the point where a full `substring` can fit within `str`.\n4. **Comparison and Counting**: For each position, it checks if the slice of `str` from the current index to the length of `substring` matches `substring`. If there is a match, `count` is incremented.\n5. **Return Value**: Finally, the function returns the total count of occurrences.\n\nThis approach ensures that all possible overlapping cases are counted by iterating through each position in the string and checking for a substring match at every step.\n\n"}
{"task_id": "CPP/143", "generation": "#include <iostream>\n#include <vector>\n#include <sstream>\n#include <cmath>\nusing namespace std;\n\nbool is_prime(int n) {\n    if (n <= 1)\n        return false;\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0)\n            return false;\n    }\n    return true;\n}\n\nstring words_in_sentence(string sentence) {\n    stringstream ss(sentence);\n    string word, result;\n    while (ss >> word) {\n        if (is_prime(word.length())) {\n            if (!result.empty()) {\n                result += \" \";\n            }\n            result += word;\n        }\n    }\n    return result;\n}\n", "py_code": "def is_prime(n):\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef words_in_sentence(sentence):\n    words = sentence.split()\n    prime_length_words = [word for word in words if is_prime(len(word))]\n    return ' '.join(prime_length_words)\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python solution consists of two functions: `is_prime` and `words_in_sentence`. The `is_prime` function checks if a given number is prime by iterating from 2 to the square root of the number and checking for any divisors. If no divisors are found, it returns True; otherwise, False.\n\nThe `words_in_sentence` function takes a sentence as input, splits it into words using the split() method, and then filters out the words whose lengths are prime numbers by utilizing the `is_prime` function within a list comprehension. Finally, it joins these filtered words back into a string with spaces in between them and returns this new string.\n\nThis approach ensures that only words of prime length from the original sentence are included in the output, maintaining their order as they appeared in the input sentence.```"}
{"task_id": "CPP/108", "generation": "#include <vector>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\n\n// Helper function to calculate the sum of digits considering the sign.\nint sum_of_digits(int num) {\n    int sum = 0;\n    bool is_negative = num < 0;\n    while (num != 0) {\n        int digit = num % 10;\n        sum += digit;\n        num /= 10;\n    }\n    if (is_negative && sum != 0)\n        sum -= 2 * (sum % 10); // Adjusting the first signed digit.\n    return sum;\n}\n\nint count_nums(vector<int> n) {\n    int count = 0;\n    for (int num : n) {\n        if (sum_of_digits(num) > 0) {\n            ++count;\n        }\n    }\n    return count;\n}\n", "py_code": "def count_nums(n):\n    def sum_of_digits(num):\n        return sum(int(digit) if digit != '-' else 0 for digit in str(num))\n    \n    return sum(1 for num in n if sum_of_digits(num) > 0)\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `count_nums` takes a list of integers as input and returns the count of numbers whose sum of digits is greater than zero. The function defines an inner helper function `sum_of_digits`, which calculates the sum of signed digits for each number in the list.\n\n- The `sum_of_digits` function converts the integer to its string representation, iterates over each character (digit), and sums them up while considering the sign of the first digit if it is negative.\n- The main function then uses a generator expression within the `sum()` function to iterate through the input list. For each number in the list, it checks whether the sum of digits (calculated using the helper function) is greater than zero and increments the count accordingly.\n\nFinally, the function returns the total count of numbers that satisfy the condition.\n```\n\n"}
{"task_id": "CPP/43", "generation": "#include <vector>\n#include <unordered_set>\nusing namespace std;\n\nbool pairs_sum_to_zero(vector<int> l) {\n    unordered_set<int> seen;\n    for (int num : l) {\n        if (seen.find(-num) != seen.end()) {\n            return true;\n        }\n        seen.insert(num);\n    }\n    return false;\n}\n", "py_code": "def pairs_sum_to_zero(l):\n    seen = set()\n    for num in l:\n        if -num in seen:\n            return True\n        seen.add(num)\n    return False\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `pairs_sum_to_zero` takes a list of integers as input and checks if there are two distinct elements in the list that sum to zero. The function uses a set named `seen` to keep track of the numbers it has encountered so far.\n\nFor each number `num` in the list, the function checks whether `-num` is already in the `seen` set. If `-num` exists in the set, this means there are two distinct elements that sum to zero (i.e., `num` and `-num`). In such a case, the function returns `True`. Otherwise, it adds `num` to the `seen` set and continues checking the rest of the list.\n\nIf no pair is found by the end of the iteration, the function returns `False`.\n\n"}
{"task_id": "CPP/70", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> strange_sort_list(vector<int> lst) {\n    sort(lst.begin(), lst.end());\n    vector<int> result;\n    while (!lst.empty()) {\n        // Append minimum value\n        if (!lst.empty()) {\n            result.push_back(lst.front());\n            lst.erase(lst.begin());\n        }\n        // Append maximum value\n        if (!lst.empty()) {\n            result.push_back(lst.back());\n            lst.pop_back();\n        }\n    }\n    return result;\n}\n", "py_code": "def strange_sort_list(lst):\n    sorted_lst = sorted(lst)\n    result = []\n    while sorted_lst:\n        # Append minimum value\n        if sorted_lst:\n            result.append(sorted_lst.pop(0))\n        # Append maximum value\n        if sorted_lst:\n            result.append(sorted_lst.pop(-1))\n    return result\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `strange_sort_list` takes a list of integers as input and returns a new list sorted in a \"strange\" order. The strange sorting pattern alternates between selecting the minimum value from the remaining elements and then the maximum value from the remaining elements until all elements are used.\n\n1. **Sorting**: First, it sorts the input list `lst` in ascending order.\n2. **Initialization**: It initializes an empty list `result` to store the final sorted values.\n3. **Looping through the list**: The function enters a loop that continues as long as there are elements left in `sorted_lst`.\n    - In each iteration, it first checks if there is at least one element remaining and appends the minimum value (the first element) from `sorted_lst` to `result`, then removes this element.\n    - It then checks again if any elements remain and appends the maximum value (the last element) from `sorted_lst` to `result`, followed by removing this element as well.\n4. **Return**: Finally, it returns the `result` list containing the integers sorted in strange order.\n\n"}
{"task_id": "CPP/63", "generation": "#include <iostream>\n\nint fibfib(int n) {\n    if (n == 0 || n == 1) return 0;\n    else if (n == 2) return 1;\n\n    int a = 0, b = 0, c = 1; // Initialize the first three elements of the sequence\n    for (int i = 3; i <= n; ++i) {\n        int next_val = a + b + c;\n        a = b;\n        b = c;\n        c = next_val;\n    }\n    return c;\n}\n\n", "py_code": "def fibfib(n):\n    if n == 0 or n == 1:\n        return 0\n    elif n == 2:\n        return 1\n    else:\n        a, b, c = 0, 0, 1\n        for _ in range(3, n + 1):\n            a, b, c = b, c, a + b + c\n        return c\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `fibfib` computes the n-th element of the FibFib number sequence efficiently using an iterative approach instead of a recursive one to avoid redundant calculations and improve performance.\n\n1. The function first checks if `n` is 0 or 1, in which case it returns 0 as per the definition.\n2. If `n` is 2, it returns 1 since fibfib(2) == 1 by definition.\n3. For values of `n` greater than 2, the function initializes three variables (`a`, `b`, and `c`) to represent the first three elements of the sequence (0, 0, and 1 respectively).\n4. It then iterates from 3 up to `n`, updating these variables in each iteration such that they always hold the last three values of the sequence.\n5. In each iteration, it calculates the next value as the sum of the previous three values (`a + b + c`), and shifts the values accordingly: `a` takes the value of `b`, `b` takes the value of `c`, and `c` is updated to the new calculated value.\n6. The function finally returns `c`, which holds the n-th element of the sequence after completing all iterations.\n\nThis approach ensures that each number in the sequence is computed only once, leading to an efficient solution with a time complexity of O(n).```\n\n"}
{"task_id": "CPP/89", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring encrypt(string s) {\n    string encrypted_string = \"\";\n    for (char &c : s) {\n        if (isalpha(c)) {\n            int shift = 4; // Two multiplied by two places\n            char base = islower(c) ? 'a' : 'A';\n            c = ((c - base + shift) % 26) + base;\n        }\n        encrypted_string += c;\n    }\n    return encrypted_string;\n}\n", "py_code": "def encrypt(s):\n    encrypted_string = \"\"\n    for char in s:\n        if char.isalpha():\n            shift = 4  # Two multiplied by two places\n            base = ord('a') if char.islower() else ord('A')\n            new_char = chr((ord(char) - base + shift) % 26 + base)\n            encrypted_string += new_char\n        else:\n            encrypted_string += char\n    return encrypted_string\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `encrypt` takes a string `s` as input and returns an encrypted version of it by rotating each alphabetical character down by four places (since two multiplied by two is four). The encryption process preserves the case of the letters (i.e., lowercase remains lowercase, uppercase remains uppercase).\n\n1. **Initialization**: An empty string `encrypted_string` is initialized to store the result.\n2. **Iteration over characters**: For each character in the input string:\n   - If the character is an alphabet (`char.isalpha()`), it calculates a new character by rotating the original one down by four places.\n     - The shift value is set to 4, which represents two multiplied by two places.\n     - A base ASCII value is determined based on whether the character is lowercase or uppercase using `ord('a')` and `ord('A')`, respectively.\n     - The new character is calculated by shifting the original character's ASCII value down by four positions within the alphabet range (0-25) and converting it back to a character with `chr()`.\n   - If the character is not an alphabetic character, it remains unchanged in the output string.\n3. **Return**: Finally, the function returns the encrypted string.\n\nThis approach ensures that non-alphabetic characters are left untouched while alphabetic characters are shifted down by four positions within their respective case ranges (lowercase or uppercase)."}
{"task_id": "CPP/26", "generation": "#include <stdio.h>\n#include <vector>\n#include <unordered_set>\nusing namespace std;\n\nvector<int> remove_duplicates(vector<int> numbers) {\n    unordered_set<int> seen;\n    vector<int> result;\n    \n    for (int number : numbers) {\n        if (seen.find(number) == seen.end()) {\n            result.push_back(number);\n            seen.insert(number);\n        }\n    }\n    return result;\n}\n", "py_code": "def remove_duplicates(numbers):\n    seen = set()\n    result = []\n    for number in numbers:\n        if number not in seen:\n            result.append(number)\n            seen.add(number)\n    return result\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `remove_duplicates` takes a list of integers as input and returns a new list with all duplicates removed while preserving the order of the remaining elements. It uses a set named `seen` to keep track of numbers that have already been encountered in the iteration over the input list.\n\nFor each number in the input list, the function checks if it is not present in the `seen` set:\n- If the number has not been seen before (i.e., it's not in the `seen` set), it appends the number to the result list and adds the number to the `seen` set.\n- If the number has already been encountered, it skips adding that number to the result.\n\nThis approach ensures that only the first occurrence of each unique element is kept in the output list, preserving their original order from the input list. The function then returns this filtered list as the final result.\n\n"}
{"task_id": "CPP/104", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nbool has_no_even_digit(int n) {\n    while (n > 0) {\n        int digit = n % 10;\n        if (digit % 2 == 0) return false;\n        n /= 10;\n    }\n    return true;\n}\n\nvector<int> unique_digits(vector<int> x) {\n    vector<int> result;\n\n    for (int num : x) {\n        if (has_no_even_digit(num)) {\n            result.push_back(num);\n        }\n    }\n\n    sort(result.begin(), result.end());\n    return result;\n}\n", "py_code": "def unique_digits(x):\n    def has_no_even_digit(n):\n        return all(int(digit) % 2 != 0 for digit in str(n))\n    \n    result = [num for num in x if has_no_even_digit(num)]\n    return sorted(result)\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `unique_digits` takes a list of positive integers and returns a new list containing only those numbers that do not have any even digits. The returned list is sorted in increasing order.\n\n1. A helper function `has_no_even_digit(n)` is defined to check if all digits of a number are odd.\n2. This helper function converts the integer `n` into its string representation and checks each digit to ensure it's not an even number using the modulo operator (`% 2 != 0`). If any digit is found to be even, the function returns False; otherwise, it returns True.\n3. A list comprehension iterates over the input list `x`, filtering out numbers that do have at least one even digit by calling `has_no_even_digit(num)`.\n4. The filtered list of numbers with only odd digits is then sorted in increasing order using Python's built-in `sorted()` function and returned as the result.\n```\n\n"}
{"task_id": "CPP/90", "generation": "#include <vector>\n#include <algorithm>\n#include <climits>\nusing namespace std;\n\nint next_smallest(vector<int> lst) {\n    if (lst.size() < 2) return -1; // Using -1 to represent None in C++\n    \n    int smallest = INT_MAX;\n    int second_smallest = INT_MAX;\n    \n    for (int num : lst) {\n        if (num < smallest) {\n            second_smallest = smallest;\n            smallest = num;\n        } else if (num != smallest && num < second_smallest) {\n            second_smallest = num;\n        }\n    }\n\n    return (second_smallest == INT_MAX) ? -1 : second_smallest;\n}\n", "py_code": "def next_smallest(lst):\n    unique_elements = list(set(lst))\n    if len(unique_elements) < 2:\n        return None\n    unique_elements.sort()\n    return unique_elements[1]\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `next_smallest` is designed to find and return the second smallest element in a list of integers (`lst`). The function first converts the input list into a set to remove any duplicate elements, then it checks if there are at least two unique elements. If not, it returns `None`. Otherwise, it sorts the unique elements and returns the second one (index 1).\n\nThis approach ensures that the function correctly handles cases with duplicates or insufficient unique values by returning `None` when necessary.\n\n"}
{"task_id": "CPP/126", "generation": "#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nbool is_sorted(vector<int> lst) {\n    if (lst.size() <= 1) {\n        return true;\n    }\n\n    int prev = lst[0];\n    int count = 1;\n\n    for (size_t i = 1; i < lst.size(); ++i) {\n        if (lst[i] < prev) {\n            return false;\n        } else if (lst[i] == prev) {\n            count++;\n            if (count > 2) {\n                return false;\n            }\n        } else {\n            prev = lst[i];\n            count = 1;\n        }\n    }\n\n    return true;\n}\n", "py_code": "def is_sorted(lst):\n    if len(lst) <= 1:\n        return True\n\n    prev = lst[0]\n    count = 1\n    \n    for i in range(1, len(lst)):\n        if lst[i] < prev:\n            return False\n        elif lst[i] == prev:\n            count += 1\n            if count > 2:\n                return False\n        else:\n            prev = lst[i]\n            count = 1\n\n    return True\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `is_sorted` checks whether a given list of integers is sorted in ascending order and ensures that no number appears more than twice. The function first handles edge cases where the length of the list is less than or equal to 1 by returning True since such lists are trivially sorted.\n\nIt then initializes two variables: `prev`, which holds the previous element, and `count`, which tracks how many times a particular value has been encountered consecutively. The function iterates through the list starting from the second element:\n\n- If an element is less than its predecessor (`lst[i] < prev`), it means the list is not sorted in ascending order, so the function returns False.\n- If an element equals its predecessor (`lst[i] == prev`), the count of consecutive occurrences increases. If this count exceeds 2, the function returns False as a number appears more than twice.\n- Otherwise, if the current element is greater than the previous one (`lst[i] > prev`), it updates `prev` to the current value and resets the count.\n\nIf the loop completes without returning False, the list meets both criteria (sorted in ascending order and no number appearing more than twice), so the function returns True. \n\nThis approach ensures that the function efficiently checks for both conditions with a single pass through the list.\n\n"}
{"task_id": "CPP/68", "generation": "#include <stdio.h>\n#include <vector>\n#include <limits>\nusing namespace std;\n\nvector<int> pluck(vector<int> arr) {\n    int smallest_even_value = numeric_limits<int>::max();\n    int smallest_index = -1;\n    \n    for (int i = 0; i < arr.size(); ++i) {\n        if (arr[i] % 2 == 0 && arr[i] <= smallest_even_value) {\n            if (arr[i] < smallest_even_value || smallest_index == -1) {\n                smallest_even_value = arr[i];\n                smallest_index = i;\n            }\n        }\n    }\n\n    if (smallest_index != -1) {\n        return {smallest_even_value, smallest_index};\n    } else {\n        return {};\n    }\n}\n", "py_code": "def pluck(arr):\n    smallest_even_value = float('inf')\n    smallest_index = -1\n\n    for index, value in enumerate(arr):\n        if value % 2 == 0 and value < smallest_even_value:\n            smallest_even_value = value\n            smallest_index = index\n    \n    if smallest_index != -1:\n        return [smallest_even_value, smallest_index]\n    else:\n        return []\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `pluck` takes a list of integers (`arr`) as input and returns a list containing the smallest even value in the array along with its index. If there are no even values or if the given vector is empty, it returns an empty list.\n\n1. The function initializes two variables: `smallest_even_value` to positive infinity (indicating that we haven't found any even number yet) and `smallest_index` to -1.\n2. It then iterates over each element in the array using a for loop with `enumerate`, which provides both the index (`index`) and value (`value`) of the current element.\n3. Inside the loop, it checks if the current value is even (i.e., `value % 2 == 0`) and smaller than the currently tracked smallest even value (`smallest_even_value`). If so, it updates `smallest_even_value` to the current value and sets `smallest_index` to the current index.\n4. After iterating through all elements, if an even number was found (i.e., `smallest_index != -1`), it returns a list containing `[smallest_even_value, smallest_index]`.\n5. If no even numbers were found, it returns an empty list.\n\nThis approach ensures that the function finds the smallest even value and its index efficiently by iterating through the array only once.\n```\n\n<|im_start|>"}
{"task_id": "CPP/58", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\n#include<set>\nusing namespace std;\n\nvector<int> common(vector<int> l1, vector<int> l2) {\n    sort(l1.begin(), l1.end());\n    sort(l2.begin(), l2.end());\n\n    vector<int> result;\n    set_intersection(l1.begin(), l1.end(), l2.begin(), l2.end(), back_inserter(result));\n\n    // Remove duplicates from the result\n    auto last = unique(result.begin(), result.end());\n    result.erase(last, result.end());\n\n    return result;\n}\n", "py_code": "def common(l1, l2):\n    # Convert both lists to sets and find intersection\n    result_set = set(l1) & set(l2)\n    # Convert the resulting set back to a sorted list\n    return sorted(list(result_set))\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `common` takes two lists (`l1` and `l2`) as input and returns a list of their common elements in sorted order without duplicates. The function first converts both lists into sets to eliminate any duplicate values within each list and then finds the intersection of these two sets, which gives us all unique common elements between the two lists. Finally, it converts this set back into a list, sorts it, and returns the result. This approach ensures that the output is sorted and contains only unique elements that are present in both input lists.```\n\n"}
{"task_id": "CPP/112", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nbool is_palindrome(const string& str) {\n    int left = 0, right = str.size() - 1;\n    while (left < right) {\n        if (str[left] != str[right]) return false;\n        ++left; --right;\n    }\n    return true;\n}\n\nvector<string> reverse_delete(string s, string c){\n    string result_string;\n    \n    // Remove characters from `s` that are present in `c`\n    for (char ch : s) {\n        if (c.find(ch) == string::npos) {\n            result_string += ch;\n        }\n    }\n\n    // Check if the resulting string is a palindrome\n    bool is_palindrome_result = is_palindrome(result_string);\n    \n    vector<string> result{result_string, is_palindrome_result ? \"True\" : \"False\"};\n    return result;\n}\n", "py_code": "def reverse_delete(s: str, c: str) -> list:\n    # Remove characters from `s` that are present in `c`\n    result_string = ''.join([char for char in s if char not in c])\n    \n    # Check if the resulting string is a palindrome\n    is_palindrome = result_string == result_string[::-1]\n    \n    return [result_string, str(is_palindrome).lower()]\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `reverse_delete` takes two string arguments: `s` and `c`. It first creates a new string (`result_string`) by filtering out all characters from `s` that are present in `c`. This is done using a list comprehension which iterates over each character in `s`, checking if it's not in `c`.\n\nAfter constructing the filtered string, the function checks whether this new string is a palindrome. A string is considered a palindrome if it reads the same backward as forward. The check for palindromicity is performed by comparing the `result_string` with its reverse (`result_string[::-1]`). If they are equal, then the string is a palindrome.\n\nFinally, the function returns a list containing the filtered string and a boolean value indicating whether or not it's a palindrome. Since C++ expects strings for true/false values, the boolean result is converted to lowercase \"true\" or \"false\" using `str(is_palindrome).lower()` before returning.\n```\n\n"}
{"task_id": "CPP/96", "generation": "#include <stdio.h>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    for (int i = 2; i <= sqrt(num); ++i) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\nvector<int> count_up_to(int n) {\n    vector<int> primes;\n    for (int number = 2; number < n; ++number) {\n        if (is_prime(number)) {\n            primes.push_back(number);\n        }\n    }\n    return primes;\n}\n", "py_code": "def is_prime(num):\n    if num <= 1:\n        return False\n    for i in range(2, int(num**0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef count_up_to(n):\n    primes = []\n    for number in range(2, n):\n        if is_prime(number):\n            primes.append(number)\n    return primes\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python solution consists of two functions: `is_prime` and `count_up_to`. \n\n1. The `is_prime(num)` function checks if a given number is prime by iterating from 2 to the square root of the number (inclusive). If any divisor is found within this range, it returns False; otherwise, it returns True.\n\n2. The `count_up_to(n)` function generates a list of all prime numbers less than `n`. It iterates through each integer from 2 up to but not including `n`, and for each number, it checks if the number is prime using the `is_prime` function. If the number is prime, it appends the number to the `primes` list.\n\nFinally, the `count_up_to(n)` function returns the list of primes found.\n\n"}
{"task_id": "CPP/157", "generation": "#include <algorithm> // For using the sort function on an array\nusing namespace std;\n\nbool right_angle_triangle(float a, float b, float c) {\n    float sides[3] = {a, b, c};\n    // Sort the sides so that 'c' is the longest side (hypotenuse)\n    sort(sides, sides + 3);\n    \n    // Check if the triangle satisfies Pythagoras' theorem: a^2 + b^2 == c^2\n    return (sides[0] * sides[0]) + (sides[1] * sides[1]) == (sides[2] * sides[2]);\n}\n", "py_code": "def right_angle_triangle(a, b, c):\n    # Sort the sides so that c is the longest side (hypotenuse)\n    sides = sorted([a, b, c])\n    a, b, c = sides\n    \n    # Check if the triangle satisfies Pythagoras' theorem: a^2 + b^2 == c^2\n    return a**2 + b**2 == c**2\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `right_angle_triangle` takes three side lengths of a triangle as input and determines whether these sides form a right-angled triangle. The function first sorts the given side lengths to ensure that the longest side (hypotenuse) is assigned to variable `c`. It then checks if the square of the hypotenuse (`c^2`) equals the sum of the squares of the other two sides (`a^2 + b^2`). This check is based on Pythagoras' theorem, which states that in a right-angled triangle, the square of the length of the hypotenuse (the side opposite the right angle) is equal to the sum of the squares of the lengths of the other two sides. If this condition holds true, the function returns `True`, indicating that the given sides form a right-angled triangle; otherwise, it returns `False`.```"}
{"task_id": "CPP/99", "generation": "#include <string>\n#include <cmath>\nusing namespace std;\n\nint closest_integer(string value) {\n    float num = stof(value);\n    if (fabs(num - round(num)) == 0.5) {\n        return num > 0 ? ceil(num) : floor(num);\n    }\n    return round(num);\n}\n", "py_code": "def closest_integer(value: str) -> int:\n    num = float(value)\n    if num - int(num) == 0.5 or num - int(num) == -0.5:\n        return int(num + (1 if num > 0 else -1))\n    return round(num)\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `closest_integer` takes a string input representing a number and returns the closest integer to it according to specific rounding rules. Here's how it works:\n1. The string value is first converted into a floating-point number.\n2. It then checks if the fractional part of the number is exactly 0.5 or -0.5 (i.e., equidistant from two integers). If so, it rounds away from zero by adding 1 to positive numbers and subtracting 1 from negative numbers before converting to an integer.\n3. If the number isn't equidistant between two integers, it simply uses Python's built-in `round` function to round to the nearest integer.\n\nThis approach ensures that when a number is exactly halfway between two integers, it rounds away from zero as required by the problem statement.\n\n"}
{"task_id": "CPP/149", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nbool custom_compare(const string& a, const string& b) {\n    if (a.length() == b.length()) {\n        return a < b;\n    }\n    return a.length() < b.length();\n}\n\nvector<string> sorted_list_sum(vector<string> lst) {\n    vector<string> filtered_lst;\n    \n    // Filter out strings with odd lengths\n    for(const auto& s : lst) {\n        if (s.length() % 2 == 0) {\n            filtered_lst.push_back(s);\n        }\n    }\n\n    // Sort the list by length and then alphabetically\n    sort(filtered_lst.begin(), filtered_lst.end(), custom_compare);\n\n    return filtered_lst;\n}\n", "py_code": "from typing import List\n\ndef vector_sort(lst: List[str]) -> List[str]:\n    # Filter out strings with odd lengths\n    filtered_lst = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort the list by length and then alphabetically\n    sorted_lst = sorted(filtered_lst, key=lambda x: (len(x), x))\n    \n    return sorted_lst\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `vector_sort` takes a list of strings as input and returns a new list with certain modifications. The function first filters out any string from the input list that has an odd length using a list comprehension. It then sorts the filtered list based on two criteria: first by the length of each string in ascending order, and if there are strings of equal lengths, it sorts them alphabetically. This is achieved through the `sorted` function with a custom key that returns a tuple containing the length of the string followed by the string itself. The result is a list of strings with even lengths sorted first by their lengths and then alphabetically among those with the same length.```\n\n"}
{"task_id": "CPP/86", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nstring anti_shuffle(string s) {\n    string result = \"\";\n    string word = \"\";\n    \n    for (char ch : s) {\n        if (ch == ' ') {\n            // Sort the collected word and add to result\n            sort(word.begin(), word.end());\n            result += word + \" \";\n            word = \"\";  // Reset word for next iteration\n        } else {\n            word += ch;\n        }\n    }\n\n    // Handle last word in case there is no trailing space\n    if (!word.empty()) {\n        sort(word.begin(), word.end());\n        result += word;\n    }\n\n    return result;\n}\n", "py_code": "def anti_shuffle(s):\n    words = s.split(\" \")\n    ordered_words = []\n    for word in words:\n        ordered_word = ''.join(sorted(word))\n        ordered_words.append(ordered_word)\n    return \" \".join(ordered_words)\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `anti_shuffle` takes a string `s` as input and returns an ordered version of it where each word's characters are sorted in ascending order based on their ASCII values while maintaining the original order of words and spaces.\n\n1. The input string is split into individual words using the space character as a delimiter.\n2. For each word, the function sorts its characters in ascending order by converting the word to a list of characters, sorting that list, and then joining it back into a string.\n3. The sorted words are collected into a new list `ordered_words`.\n4. Finally, the function joins the elements of `ordered_words` with spaces between them to form the final ordered version of the input string.\n\nThis approach ensures that each word in the output is composed of its characters arranged in ascending ASCII order while preserving the original sequence of words and blank spaces from the input string.\n"}
{"task_id": "CPP/129", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> minPath(vector<vector<int>> grid, int k) {\n    int N = grid.size();\n    vector<pair<int, int>> directions{{0, 1}, {1, 0}, {-1, 0}, {0, -1}};\n    \n    function<vector<int>(int, int, vector<int>)> dfs;\n    dfs = [&](int x, int y, vector<int> path) -> vector<int> {\n        if (path.size() == k)\n            return path;\n        vector<int> min_path(k, INT_MAX);\n        for (auto& dir : directions) {\n            int dx = dir.first, dy = dir.second;\n            int nx = x + dx, ny = y + dy;\n            if (0 <= nx && nx < N && 0 <= ny && ny < N) {\n                auto new_path = dfs(nx, ny, path);\n                new_path.push_back(grid[nx][ny]);\n                if (new_path.size() == k && (min_path.empty() || new_path < min_path))\n                    min_path = new_path;\n            }\n        }\n        return min_path;\n    };\n    \n    vector<int> result(k, INT_MAX);\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            auto path = dfs(i, j, {grid[i][j]});\n            if (path.size() == k && (result.empty() || path < result))\n                result = path;\n        }\n    }\n\n    return result;\n}\n", "py_code": "from typing import List\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    N = len(grid)\n    \n    def dfs(x, y, path):\n        if len(path) == k:\n            return path[:]\n        \n        best_path = None\n        \n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < N and 0 <= ny < N:\n                new_path = dfs(nx, ny, path + [grid[nx][ny]])\n                if best_path is None or (new_path and new_path < best_path):\n                    best_path = new_path\n        \n        return best_path\n    \n    min_path = None\n    for i in range(N):\n        for j in range(N):\n            current_path = dfs(i, j, [grid[i][j]])\n            if min_path is None or (current_path and current_path < min_path):\n                min_path = current_path\n                \n    return min_path\n```\n\n", "py_summary": "### Second Step: Analyse the Python Code\n\nThe provided Python function `minPath` aims to find the lexicographically smallest path of length `k` in a given grid. The approach uses depth-first search (DFS) to explore all possible paths starting from each cell and keeps track of the minimum path found.\n\n1. **Initialization**: \n   - `N` is set as the size of the grid.\n   \n2. **Helper Function (`dfs`)**:\n   - This function performs a DFS to find the smallest lexicographical path of length `k`.\n   - It takes three parameters: current coordinates `(x, y)` and the current path list `path`.\n   - If the length of `path` equals `k`, it returns a copy of the path.\n   - For each possible move (up, down, left, right), it checks if the new position is within grid bounds. \n   - It recursively calls itself to explore further and updates `best_path` with the lexicographically smallest path found so far.\n\n3. **Main Function Logic**:\n   - Initializes `min_path` as `None`.\n   - Iterates over each cell in the grid, starting a DFS from that cell.\n   - Updates `min_path` if the current path is smaller than any previously found paths.\n   \n4. **Return Value**: \n   - Returns the lexicographically smallest path of length `k`.\n\n### Summary\nThe function explores all possible paths using DFS and keeps track of the minimum path based on lexicographical order, ensuring that the solution is unique as per the problem constraints.\n\n### Last Step: Generate C++ Solution\n\nNow we will translate this logic into a C++ implementation.\n"}
{"task_id": "CPP/49", "generation": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\n// Function to calculate (base^exponent) % mod using iterative method to avoid overflow.\nint powerMod(int base, int exponent, int mod) {\n    long long result = 1;\n    long long current_base = base % mod; // Ensure the base is within the modulo range.\n\n    while (exponent > 0) {\n        if (exponent & 1) { // If exponent is odd, multiply the result by the current base.\n            result = (result * current_base) % mod;\n        }\n        exponent >>= 1; // Divide exponent by 2.\n        current_base = (current_base * current_base) % mod; // Square the base and take modulo.\n    }\n\n    return static_cast<int>(result);\n}\n\nint modp(int n, int p) {\n    return powerMod(2, n, p);\n}\n", "py_code": "def modp(n, p):\n    return pow(2, n, p)\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `modp` takes two integers `n` and `p`, and returns 2 raised to the power of `n`, modulo `p`. The built-in `pow()` function is used with three arguments: the base (2), the exponent (`n`), and the modulus (`p`). This function efficiently computes large powers modulo a number, which avoids potential numeric overflow issues that could arise from directly computing 2^n first before taking the modulo.```\n\n"}
{"task_id": "CPP/156", "generation": "#include <vector>\n#include <string>\nusing namespace std;\n\nstring int_to_mini_roman(int number) {\n    vector<pair<int, string>> roman_map = {\n        {1000, \"m\"}, {900, \"cm\"}, {500, \"d\"}, {400, \"cd\"},\n        {100, \"c\"}, {90, \"xc\"}, {50, \"l\"}, {40, \"xl\"},\n        {10, \"x\"}, {9, \"ix\"}, {5, \"v\"}, {4, \"iv\"}, {1, \"i\"}\n    };\n    \n    string roman_numeral = \"\";\n    for (const auto &p : roman_map) {\n        while (number >= p.first) {\n            roman_numeral += p.second;\n            number -= p.first;\n        }\n    }\n    return roman_numeral;\n}\n", "py_code": "def int_to_mini_roman(number):\n    roman_map = [\n        (1000, 'm'), (900, 'cm'), (500, 'd'), (400, 'cd'),\n        (100, 'c'), (90, 'xc'), (50, 'l'), (40, 'xl'),\n        (10, 'x'), (9, 'ix'), (5, 'v'), (4, 'iv'), (1, 'i')\n    ]\n    roman_numeral = ''\n    for value, numeral in roman_map:\n        while number >= value:\n            roman_numeral += numeral\n            number -= value\n    return roman_numeral\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `int_to_mini_roman` converts a given integer into its lowercase Roman numeral equivalent as a string. The function uses a list of tuples called `roman_map`, where each tuple contains an integer value and its corresponding Roman numeral symbol in lowercase.\n\n1. **Initialization**: A variable `roman_numeral` is initialized to an empty string, which will store the resulting Roman numeral.\n2. **Iteration over roman_map**: The function iterates through the list of tuples (`roman_map`). For each tuple (value, numeral), it checks if the given number is greater than or equal to the value.\n3. **Appending numerals**: If the condition holds true, the corresponding Roman numeral symbol is appended to `roman_numeral`, and the integer value is subtracted from the input number. This process repeats until the number becomes less than the current value in the iteration.\n4. **Return result**: Once all values have been processed, the function returns the constructed string `roman_numeral`.\n\nThis approach ensures that the largest possible Roman numeral symbols are used first and then smaller ones as needed to represent the given integer accurately.\n\n"}
{"task_id": "CPP/65", "generation": "#include <iostream>\n#include <string>\n#include <algorithm> // For std::reverse\nusing namespace std;\n\nstring circular_shift(int x, int shift) {\n    string digits = to_string(x);\n    int num_digits = digits.length();\n\n    if (shift >= num_digits) {\n        reverse(digits.begin(), digits.end());\n        return digits;\n    }\n\n    int effective_shift = shift % num_digits;\n    rotate(digits.rbegin(), digits.rbegin() + effective_shift, digits.rend());\n    return digits;\n}\n", "py_code": "def circular_shift(x: int, shift: int) -> str:\n    digits = list(str(x))\n    num_digits = len(digits)\n    \n    # If shift is greater than number of digits, reverse the digits.\n    if shift >= num_digits:\n        return ''.join(reversed(digits))\n\n    effective_shift = shift % num_digits\n    shifted_digits = digits[-effective_shift:] + digits[:-effective_shift]\n    return ''.join(shifted_digits)\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `circular_shift` takes an integer `x` and a shift value `shift`, and returns a string representing the digits of `x` after performing a circular right shift by `shift`. The function first converts the integer `x` into a list of its individual digit characters. It then determines if the shift is greater than or equal to the number of digits in `x`. If so, it reverses the list of digits and returns them as a string.\n\nIf the shift value is less than the number of digits, the function calculates an effective shift by taking the modulus of `shift` with the length of the digit list. This ensures that if `shift` is larger than the number of digits but not enough to reverse them (i.e., it's a multiple of the number of digits plus some remainder), only the necessary circular shift will be performed.\n\nThe function then constructs the shifted list by concatenating the last part of the original list with its first part, based on the effective shift value. Finally, it joins this list into a string and returns it.\n```\n\n"}
{"task_id": "CPP/9", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> rolling_max(vector<int> numbers) {\n    int max_so_far = INT_MIN;\n    vector<int> result;\n    for (int number : numbers) {\n        if (number > max_so_far) {\n            max_so_far = number;\n        }\n        result.push_back(max_so_far);\n    }\n    return result;\n}\n", "py_code": "def rolling_max(numbers):\n    max_so_far = float('-inf')\n    result = []\n    for number in numbers:\n        if number > max_so_far:\n            max_so_far = number\n        result.append(max_so_far)\n    return result\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `rolling_max` takes a list of integers as input and returns a new list where each element at index `i` is the maximum value found in the original list up to that point (inclusive). The function initializes `max_so_far` with negative infinity (`float('-inf')`) to ensure any number from the input list will be larger initially. It then iterates through the input list, updating `max_so_far` whenever a new maximum is encountered and appending this value to the result list.\n\nThis approach ensures that each element in the returned list represents the rolling (or cumulative) maximum up to that point in the sequence.\n\n"}
{"task_id": "CPP/158", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <unordered_set>\nusing namespace std;\n\nstring find_max(vector<string> words) {\n    int max_unique = 0;\n    string result_word = \"\";\n\n    for (const auto& word : words) {\n        unordered_set<char> unique_chars(word.begin(), word.end());\n        \n        if (unique_chars.size() > max_unique || \n            (unique_chars.size() == max_unique && word < result_word)) {\n            max_unique = unique_chars.size();\n            result_word = word;\n        }\n    }\n\n    return result_word;\n}\n", "py_code": "def find_max(words):\n    max_unique = 0\n    result_word = \"\"\n    \n    for word in words:\n        unique_chars = len(set(word))\n        \n        if unique_chars > max_unique or (unique_chars == max_unique and word < result_word):\n            max_unique = unique_chars\n            result_word = word\n            \n    return result_word\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `find_max` takes a list of strings as input and returns the string with the maximum number of unique characters. If multiple strings have the same number of unique characters, it returns the one that comes first in lexicographical order.\n\n1. The function initializes two variables: `max_unique`, which keeps track of the highest count of unique characters found so far (starting at 0), and `result_word`, which stores the current word with the maximum number of unique characters.\n2. It iterates over each word in the input list.\n3. For each word, it calculates the number of unique characters by converting the word into a set and taking its length (`len(set(word))`).\n4. If this count is greater than `max_unique`, or if it's equal to `max_unique` but the current word comes before `result_word` in lexicographical order, then it updates `max_unique` and sets `result_word` to the current word.\n5. After iterating through all words, the function returns `result_word`.\n```\n\n"}
{"task_id": "CPP/8", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> sum_product(vector<int> numbers) {\n    int total_sum = 0;\n    int product = 1;\n\n    if (numbers.empty()) {\n        return {0, 1};\n    }\n\n    for (int num : numbers) {\n        total_sum += num;\n        product *= num;\n    }\n\n    return {total_sum, product};\n}\n", "py_code": "from typing import List, Tuple\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    if not numbers:\n        return (0, 1)\n    \n    total_sum = sum(numbers)\n    product = 1\n    for num in numbers:\n        product *= num\n    \n    return (total_sum, product)\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `sum_product` takes a list of integers as input and returns a tuple containing two values: the sum and the product of all elements in the list. If the input list is empty, it returns `(0, 1)` by default.\n\nHere's how the function works:\n- It first checks if the input list `numbers` is empty. If so, it immediately returns `(0, 1)`.\n- Otherwise, it calculates the sum of all elements in the list using Python\u2019s built-in `sum()` function.\n- Then, it initializes a variable `product` to `1`. This is because multiplying by `1` does not change the value and serves as the identity element for multiplication. It then iterates through each number in the list and multiplies them together to get the product of all elements.\n- Finally, it returns a tuple containing both the sum and the product.\n\nThis approach ensures that the function handles empty lists correctly by returning `(0, 1)` and calculates the required values efficiently for non-empty lists. \n\n"}
{"task_id": "CPP/95", "generation": "#include <string>\n#include <map>\n#include <cctype>\nusing namespace std;\n\nbool is_lower(const string& str) {\n    for (char ch : str) {\n        if (!islower(ch)) return false;\n    }\n    return true;\n}\n\nbool is_upper(const string& str) {\n    for (char ch : str) {\n        if (!isupper(ch)) return false;\n    }\n    return true;\n}\n\nbool check_dict_case(map<string, string> dict) {\n    if (dict.empty()) return false;\n\n    bool all_lower = true;\n    bool all_upper = true;\n\n    for (const auto& kv : dict) {\n        const string& key = kv.first;\n        if (!is_lower(key)) all_lower = false;\n        if (!is_upper(key)) all_upper = false;\n    }\n\n    return all_lower || all_upper;\n}\n", "py_code": "def check_dict_case(dict):\n    if not dict:\n        return False\n\n    lower_case_keys = [key for key in dict.keys() if key.islower()]\n    upper_case_keys = [key for key in dict.keys() if key.isupper()]\n\n    all_lower = len(lower_case_keys) == len(dict)\n    all_upper = len(upper_case_keys) == len(dict)\n\n    return all_lower or all_upper\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `check_dict_case` checks if a given dictionary has keys that are either all in lower case or all in upper case. The function first verifies whether the input dictionary is empty; if it is, the function returns False immediately.\n\nIf the dictionary is not empty, the function creates two lists: one for keys that are entirely in lowercase (`lower_case_keys`) and another for keys that are entirely in uppercase (`upper_case_keys`). It then checks if all keys fall into either the lower case or upper case category by comparing the lengths of these lists to the length of the dictionary. If any key is neither fully lowercase nor fully uppercase, the function returns False.\n\nFinally, the function returns True only if all keys are either in lower case or upper case.```\n\n"}
{"task_id": "CPP/55", "generation": "#include<iostream>\nusing namespace std;\n\nint fib(int n) {\n    if (n <= 0) {\n        return 0;\n    } else if (n == 1) {\n        return 1;\n    } else {\n        int a = 0, b = 1;\n        for (int i = 2; i <= n; ++i) {\n            int temp = a + b;\n            a = b;\n            b = temp;\n        }\n        return b;\n    }\n}\n", "py_code": "def fib(n):\n    if n <= 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        a, b = 0, 1\n        for _ in range(2, n + 1):\n            a, b = b, a + b\n        return b\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `fib(n)` calculates the nth Fibonacci number using an iterative approach to avoid the overhead of recursive calls and potential stack overflow issues for large values of n. The function first checks if n is less than or equal to 0, in which case it returns 0 as there are no negative indices in the Fibonacci sequence. If n equals 1, it directly returns 1 since the first element (index 1) of the Fibonacci sequence is 1.\n\nFor values of n greater than 1, the function initializes two variables `a` and `b` to represent the first two numbers of the Fibonacci sequence (0 and 1). It then iterates from 2 up to n, updating these two variables in each iteration: `a` takes the value of `b`, and `b` becomes the sum of the previous values of `a` and `b`. This process effectively moves through the Fibonacci sequence until it reaches the nth number. The function finally returns the value of `b`, which holds the nth Fibonacci number.\n``` \n\n"}
{"task_id": "CPP/29", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nvector<string> filter_by_prefix(vector<string> strings, string prefix) {\n    vector<string> filtered_strings;\n    for (const auto& s : strings) {\n        if (s.rfind(prefix, 0) == 0) { // Checks if the string starts with the given prefix\n            filtered_strings.push_back(s);\n        }\n    }\n    return filtered_strings;\n}\n", "py_code": "def filter_by_prefix(strings, prefix):\n    return [s for s in strings if s.startswith(prefix)]\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `filter_by_prefix` takes two arguments: a list of strings (`strings`) and a prefix string (`prefix`). It uses a list comprehension to filter out only those strings from the input list that start with the given prefix. The condition for filtering is checked using the `startswith()` method, which returns True if the string starts with the specified prefix. The function then returns the filtered list of strings.\n```"}
{"task_id": "CPP/72", "generation": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nbool will_it_fly(vector<int> q, int w) {\n    // Check if the vector is a palindrome (balanced)\n    bool is_balanced = true;\n    for(size_t i = 0; i < q.size() / 2; ++i) {\n        if(q[i] != q[q.size() - 1 - i]) {\n            is_balanced = false;\n            break;\n        }\n    }\n\n    // Calculate the sum of elements in the vector\n    int total_weight = 0;\n    for(int num : q) {\n        total_weight += num;\n    }\n\n    // Return true if it's balanced and its weight is less than or equal to w\n    return is_balanced && (total_weight <= w);\n}\n", "py_code": "def will_it_fly(q, w):\n    # Check if the list is a palindrome (balanced)\n    is_balanced = q == q[::-1]\n    \n    # Calculate the sum of elements in the list\n    total_weight = sum(q)\n    \n    # Return True if it's balanced and its weight is less than or equal to w\n    return is_balanced and total_weight <= w\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `will_it_fly` takes a list of integers `q` and an integer `w`. It checks if the list is balanced (palindromic) by comparing it to its reversed version (`q == q[::-1]`). Then, it calculates the sum of all elements in the list using the built-in `sum()` function. The function returns `True` if both conditions are met: the list is palindromic and the total weight (sum of elements) does not exceed the maximum possible weight `w`. Otherwise, it returns `False`.\n```\n\n"}
{"task_id": "CPP/54", "generation": "#include <string>\n#include <set>\n#include <algorithm>\nusing namespace std;\n\nbool same_chars(string s0, string s1) {\n    set<char> chars_s0(s0.begin(), s0.end());\n    set<char> chars_s1(s1.begin(), s1.end());\n    \n    return (chars_s0 == chars_s1);\n}\n", "py_code": "def same_chars(s0: str, s1: str) -> bool:\n    return set(s0) == set(s1)\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `same_chars` takes two strings as input and checks if they contain the same kinds of characters (regardless of their frequency or order). It does this by converting each string into a set of unique characters using the `set()` function. If both sets are equal, it means that both strings have the exact same types of characters, and the function returns `True`. Otherwise, it returns `False`. This approach works because sets automatically remove duplicate elements and disregard their order, making them ideal for comparing the distinct character compositions of two strings.```"}
{"task_id": "CPP/91", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <vector>\nusing namespace std;\n\nbool starts_with_i(const string& sentence) {\n    // Trim leading spaces\n    size_t start = sentence.find_first_not_of(\" \");\n    if (start == string::npos || sentence.substr(start, 1) != \"I\") return false;\n    \n    // Check for space or end of sentence after 'I'\n    size_t next_char_pos = start + 1;\n    return (next_char_pos >= sentence.size() || isspace(sentence[next_char_pos]));\n}\n\nvector<string> split_sentences(const string& input, const char* delimiters) {\n    vector<string> sentences;\n    stringstream ss(input);\n    string token;\n    \n    while (getline(ss, token, '.')) {\n        size_t pos = 0;\n        while ((pos = token.find_first_of(delimiters, pos)) != string::npos) {\n            string sentence = token.substr(0, pos).substr(token.substr(0, pos).find_last_not_of(\" \") + 1);\n            if (!sentence.empty()) sentences.push_back(sentence);\n            token.erase(0, pos + 1);\n        }\n        if (!token.empty()) sentences.push_back(token);\n    }\n\n    return sentences;\n}\n\nint is_bored(string S) {\n    const char* delimiters = \".?!\";\n    vector<string> sentences = split_sentences(S, delimiters);\n\n    int boredom_count = 0;\n    for (const auto& sentence : sentences) {\n        if (starts_with_i(sentence)) ++boredom_count;\n    }\n\n    return boredom_count;\n}\n", "py_code": "def is_bored(S):\n    sentences = [sentence.strip() for sentence in re.split(r'[.?!]', S) if sentence.strip()]\n    return sum(sentence.startswith(\"I \") or sentence == \"I\" for sentence in sentences)\n\nimport re\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `is_bored` takes a string `S` as input and returns an integer representing the number of sentences that start with \"I\". The function first splits the input string into individual sentences using regular expressions to match delimiters such as '.', '?', or '!'. It then strips any leading or trailing whitespace from each sentence. \n\nThe function uses a list comprehension to filter out empty strings resulting from splitting and creates a list of valid sentences. Finally, it counts how many sentences start with \"I \" (a space is included after 'I' to ensure that only full words are matched) or exactly match the word \"I\" using `sum()` combined with a generator expression. The result is returned as an integer indicating the number of boredoms in the input string.```\n\n"}
{"task_id": "CPP/77", "generation": "#include <cmath> // For cbrt function\nusing namespace std;\n\nbool iscube(int a) {\n    if (a == 0 || a == 1 || a == -1) {\n        return true;\n    }\n    int cube_root = round(cbrt(a));\n    return cube_root * cube_root * cube_root == a;\n}\n", "py_code": "def iscube(a):\n    if a == 0 or a == 1 or a == -1:\n        return True\n    cube_root = round(a ** (1/3))\n    return cube_root**3 == a\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `iscube` checks whether an integer `a` is a perfect cube of some integer number. The logic follows these steps:\n1. It first handles edge cases where `a` can be 0, 1, or -1, all of which are cubes (of 0, 1, and -1 respectively).\n2. For other values, it calculates the cube root of `a` using exponentiation (`a ** (1/3)`), then rounds this value to the nearest integer.\n3. It checks if cubing this rounded value equals the original number `a`. If they are equal, `a` is a perfect cube and the function returns `True`; otherwise, it returns `False`.\n\nThis approach ensures that both positive and negative integers can be correctly evaluated for being cubes of some integer.\n\n"}
{"task_id": "CPP/73", "generation": "#include <vector>\nusing namespace std;\n\nint smallest_change(vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n    int left = 0;\n    int right = n - 1;\n    \n    while (left < right) {\n        if (arr[left] != arr[right]) {\n            changes += 1;\n        }\n        left += 1;\n        right -= 1;\n    }\n    \n    return changes;\n}\n", "py_code": "def smallest_change(arr):\n    n = len(arr)\n    changes = 0\n    left = 0\n    right = n - 1\n    \n    while left < right:\n        if arr[left] != arr[right]:\n            changes += 1\n        left += 1\n        right -= 1\n    \n    return changes\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `smallest_change` takes a list of integers (`arr`) as input and calculates the minimum number of changes required to make the list palindromic. The approach involves using two pointers: one starting from the beginning (`left`) and another from the end (`right`). \n\n1. Initialize `changes`, `left`, and `right`. \n2. Iterate while `left` is less than `right`.\n3. If the elements at positions `left` and `right` are not equal, increment the `changes` counter.\n4. Move the pointers towards each other by incrementing `left` and decrementing `right`.\n5. Return the total number of changes required.\n\nThis approach ensures that we only count the differences between corresponding pairs of elements from both ends of the list, which is sufficient to determine how many changes are needed for a palindromic transformation.\n\n"}
{"task_id": "CPP/71", "generation": "#include <cmath> // for sqrt function\nusing namespace std;\n\nfloat triangle_area(float a, float b, float c) {\n    // Check if the sides form a valid triangle\n    if ((a + b <= c) || (a + c <= b) || (b + c <= a)) {\n        return -1;\n    }\n    \n    // Calculate the semi-perimeter\n    float s = (a + b + c) / 2.0;\n\n    // Use Heron's formula to calculate the area of the triangle\n    float area = sqrt(s * (s - a) * (s - b) * (s - c));\n    \n    // Round the result to two decimal points and return\n    return round(area * 100) / 100;\n}\n", "py_code": "import math\n\ndef triangle_area(a, b, c):\n    # Check if the sides form a valid triangle\n    if (a + b <= c) or (a + c <= b) or (b + c <= a):\n        return -1\n    \n    # Calculate the semi-perimeter\n    s = (a + b + c) / 2.0\n\n    # Use Heron's formula to calculate the area of the triangle\n    area = math.sqrt(s * (s - a) * (s - b) * (s - c))\n    \n    return round(area, 2)\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `triangle_area` takes three arguments representing the lengths of the sides of a triangle (a, b, c). The first step in the function is to check if these sides can form a valid triangle by ensuring that the sum of any two sides is greater than the third side. If this condition is not met, the function returns -1 indicating an invalid triangle.\n\nIf the sides do form a valid triangle, the function calculates the semi-perimeter (s) as half the perimeter of the triangle. It then uses Heron's formula to compute the area of the triangle based on its sides and semi-perimeter. The result is rounded to two decimal points before being returned.\n```\n\n"}
{"task_id": "CPP/82", "generation": "#include <string>\n#include <cmath>\nusing namespace std;\n\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i <= sqrt(n); ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\nbool prime_length(string str) {\n    int length = str.length();\n    return is_prime(length);\n}\n", "py_code": "def is_prime(n):\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef prime_length(str):\n    length = len(str)\n    return is_prime(length)\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python solution consists of two functions: `is_prime` and `prime_length`. The function `is_prime(n)` checks if a given number `n` is prime by iterating from 2 to the square root of `n`, checking for any divisors. If it finds a divisor, it returns False; otherwise, it returns True.\n\nThe function `prime_length(str)` calculates the length of the input string and uses the `is_prime` function to determine if this length is a prime number. The result of this check (True or False) is returned by `prime_length`.\n\nThis approach ensures that we only perform the necessary checks for primality on the length of the string, making it efficient in terms of both time and space complexity.\n\n"}
{"task_id": "CPP/114", "generation": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nlong long minSubArraySum(vector<long long> nums) {\n    if (nums.empty()) return 0;\n    \n    long long current_sum = nums[0];\n    long long min_sum = nums[0];\n\n    for (size_t i = 1; i < nums.size(); ++i) {\n        // Decide whether to add the current number to the existing subarray or start a new subarray\n        current_sum = min(nums[i], current_sum + nums[i]);\n        min_sum = min(min_sum, current_sum);\n    }\n\n    return min_sum;\n}\n", "py_code": "from typing import List\n\ndef minSubArraySum(nums: List[int]) -> int:\n    if not nums:\n        return 0\n    \n    current_sum = min_sum = nums[0]\n    \n    for num in nums[1:]:\n        # Decide whether to add the current number to the existing subarray or start a new subarray\n        current_sum = min(num, current_sum + num)\n        min_sum = min(min_sum, current_sum)\n        \n    return min_sum\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `minSubArraySum` calculates the minimum sum of any non-empty sub-vector from a given list of integers (`nums`). The algorithm uses Kadane's Algorithm in a slightly modified form to find the minimum sum instead of the maximum sum.\n\n1. **Initialization**: \n   - `current_sum` and `min_sum` are initialized with the first element of the input list.\n   \n2. **Iteration**:\n   - For each subsequent number (`num`) in the list, the algorithm decides whether to add this number to the existing subarray or start a new subarray from this number by setting `current_sum = min(num, current_sum + num)`.\n   - The minimum sum encountered so far is updated using `min_sum = min(min_sum, current_sum)`.\n\n3. **Return**:\n   - After iterating through all elements in the list, the function returns `min_sum`, which holds the minimum subarray sum found during the iteration.\n```\n\n"}
{"task_id": "CPP/138", "generation": "#include <iostream>\nusing namespace std;\n\nbool is_equal_to_sum_even(int n) {\n    // The smallest sum of 4 positive even numbers is 2 + 2 + 2 + 2 = 8.\n    if (n < 8) {\n        return false;\n    }\n    // Check if the remaining value after subtracting 8 can be expressed as a sum of additional pairs of 2s\n    return (n - 8) % 2 == 0;\n}\n", "py_code": "def is_equal_to_sum_even(n):\n    # The smallest sum of 4 positive even numbers is 2 + 2 + 2 + 2 = 8.\n    # Any number less than 8 cannot be expressed as a sum of exactly four positive even numbers.\n    if n < 8:\n        return False\n    # If the given number minus 8 (the smallest possible sum) is divisible by 2, it means that we can add more pairs of 2s to reach the target number.\n    return (n - 8) % 2 == 0\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `is_equal_to_sum_even` checks if a given integer `n` can be expressed as the sum of exactly four positive even numbers. The smallest possible sum of four such numbers is 8 (2+2+2+2). Therefore, any number less than 8 cannot satisfy this condition and returns False.\n\nFor numbers greater than or equal to 8, the function checks if `n - 8` is divisible by 2. This check ensures that after subtracting the smallest possible sum of four even numbers (which is 8), the remaining value can be expressed as a sum of additional pairs of 2s, which are also even numbers.\n\nIf `(n - 8) % 2 == 0`, it means `n` can indeed be written as the sum of exactly four positive even numbers and returns True. Otherwise, it returns False.\n```\n\n"}
{"task_id": "CPP/132", "generation": "#include <string>\nusing namespace std;\n\nbool is_nested(string str) {\n    int max_depth = 0;\n    int current_depth = 0;\n\n    for (char c : str) {\n        if (c == '[') {\n            current_depth += 1;\n            max_depth = max(max_depth, current_depth);\n        } else if (c == ']') {\n            current_depth -= 1;\n        }\n\n        // Early exit condition: If at any point the depth is negative,\n        // it means there are more closing brackets than opening ones.\n        if (current_depth < 0) {\n            return false;\n        }\n    }\n\n    // A valid nested subsequence must have a maximum depth of at least 2\n    return max_depth >= 2 && current_depth == 0;\n}\n", "py_code": "def is_nested(s):\n    max_depth = 0\n    current_depth = 0\n    \n    for char in s:\n        if char == '[':\n            current_depth += 1\n            max_depth = max(max_depth, current_depth)\n        elif char == ']':\n            current_depth -= 1\n            \n        # Early exit condition: If at any point the depth is negative,\n        # it means there are more closing brackets than opening ones.\n        if current_depth < 0:\n            return False\n    \n    # A valid nested subsequence must have a maximum depth of at least 2\n    return max_depth >= 2 and current_depth == 0\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `is_nested` checks if a given string of square brackets contains at least one nested subsequence. The function iterates through each character in the input string and maintains two variables: `current_depth`, which tracks the current depth of nesting, and `max_depth`, which keeps track of the maximum depth encountered during iteration.\n\nFor every opening bracket `[`, the `current_depth` is incremented by 1, and the `max_depth` is updated if necessary. For every closing bracket `]`, the `current_depth` is decremented by 1. If at any point the `current_depth` becomes negative, it means there are more closing brackets than opening ones, which makes the string invalid, so the function returns False.\n\nAfter iterating through all characters in the string, if the maximum depth reached (`max_depth`) is at least 2 and the final `current_depth` is zero (indicating that every opened bracket has been closed), then there exists a valid nested subsequence, and the function returns True. Otherwise, it returns False.\n```\n\n"}
{"task_id": "CPP/3", "generation": "#include <vector>\nusing namespace std;\n\nbool below_zero(vector<int> operations) {\n    int balance = 0; // Initialize the starting balance to zero.\n    \n    for (int op : operations) { // Iterate through each operation in the vector.\n        balance += op; // Update the balance with the current operation.\n\n        if (balance < 0) { // Check if the updated balance is less than zero.\n            return true; // If it is, return true immediately.\n        }\n    }\n\n    return false; // If no negative balance was detected, return false.\n}\n", "py_code": "def below_zero(operations):\n    balance = 0\n    for op in operations:\n        balance += op\n        if balance < 0:\n            return True\n    return False\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `below_zero` takes a list of integers representing deposit and withdrawal operations on a bank account that starts with zero balance. The goal is to determine if at any point during these operations, the balance falls below zero.\n\n1. **Initialization**: A variable `balance` is initialized to 0, which represents the starting balance.\n2. **Iteration through Operations**: The function iterates over each operation in the list `operations`.\n3. **Update Balance**: For each operation, the value of the operation (either a deposit or withdrawal) is added to the current balance.\n4. **Check for Negative Balance**: After updating the balance with each operation, the function checks if the new balance is less than zero. If it is, the function immediately returns `True`, indicating that the account balance has fallen below zero at some point.\n5. **Return False**: If the loop completes without finding a negative balance, the function returns `False`.\n\nThis approach ensures that the function efficiently determines whether the balance ever falls below zero by checking after each operation.\n\n"}
{"task_id": "CPP/142", "generation": "#include <vector>\nusing namespace std;\n\nint sum_squares(vector<int> lst) {\n    int total_sum = 0;\n    \n    for (size_t i = 0; i < lst.size(); ++i) {\n        if (i % 3 == 0) {\n            total_sum += lst[i] * lst[i]; // Square the value\n        } else if (i % 4 == 0) {\n            total_sum += lst[i] * lst[i] * lst[i]; // Cube the value\n        } else {\n            total_sum += lst[i]; // Add the integer entry as-is\n        }\n    }\n\n    return total_sum;\n}\n", "py_code": "def sum_squares(lst):\n    total_sum = 0\n    for i in range(len(lst)):\n        if i % 3 == 0:\n            total_sum += lst[i] ** 2\n        elif i % 4 == 0:\n            total_sum += lst[i] ** 3\n        else:\n            total_sum += lst[i]\n    return total_sum\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `sum_squares` takes a list of integers as input and returns an integer representing the sum of modified entries based on their index positions in the list.\n\n1. The function initializes a variable `total_sum` to zero.\n2. It then iterates over each element's index in the list using a for loop.\n3. For each index, it checks if the index is a multiple of 3:\n   - If true, it squares the value at that index and adds it to `total_sum`.\n4. Otherwise, it checks if the index is a multiple of 4 (but not a multiple of 3):\n   - If true, it cubes the value at that index and adds it to `total_sum`.\n5. For all other indices, it simply adds the integer entry as-is to `total_sum`.\n6. Finally, after iterating through all elements in the list, the function returns the accumulated sum stored in `total_sum`.\n\nThis approach ensures that only entries with specific index conditions are modified (squared or cubed), while others remain unchanged before being added to the total sum.\n\n"}
{"task_id": "CPP/50", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring encode_shift(string s){\n    string out;\n    for (int i = 0; i < s.length(); i++) {\n        int w = ((s[i] + 5 - 'a') % 26) + 'a';\n        out += static_cast<char>(w);\n    }\n    return out;\n}\n\nstring decode_shift(string s){\n    string out;\n    for (int i = 0; i < s.length(); i++) {\n        int w = ((s[i] - 5 - 'a' + 26) % 26) + 'a';\n        out += static_cast<char>(w);\n    }\n    return out;\n}\n", "py_code": "def encode_shift(s: str) -> str:\n    out = \"\"\n    for char in s:\n        w = ((ord(char) + 5 - ord('a')) % 26) + ord('a')\n        out += chr(w)\n    return out\n\ndef decode_shift(s: str) -> str:\n    out = \"\"\n    for char in s:\n        w = ((ord(char) - 5 - ord('a') + 26) % 26) + ord('a')\n        out += chr(w)\n    return out\n```\n\n", "py_summary": "### Second Step: Analyse the Python Code\n\nThe provided Python functions `encode_shift` and `decode_shift` are designed to encode and decode strings by shifting each character in the string by 5 positions forward or backward, respectively, within the alphabet.\n\n1. **Function `encode_shift`:**\n   - The function takes a single argument `s`, which is a string.\n   - It initializes an empty string `out`.\n   - For each character `char` in the input string `s`, it calculates the new position of the character by adding 5 to its ASCII value, subtracting the ASCII value of 'a', taking modulo 26 (to wrap around within the alphabet), and then adding back the ASCII value of 'a'.\n   - The calculated ASCII value is converted back into a character using `chr()` and appended to `out`.\n   - Finally, it returns the encoded string `out`.\n\n2. **Function `decode_shift`:**\n   - Similar to `encode_shift`, this function also takes a single argument `s` which is a string.\n   - It initializes an empty string `out`.\n   - For each character `char` in the input string `s`, it calculates the original position of the character by subtracting 5 from its ASCII value, subtracting the ASCII value of 'a', adding 26 to ensure non-negative values before taking modulo 26 (to wrap around within the alphabet), and then adding back the ASCII value of 'a'.\n   - The calculated ASCII value is converted back into a character using `chr()` and appended to `out`.\n   - Finally, it returns the decoded string `out`.\n\n### Last Step: Generate C++ Solution According to the Python Code Summary\n\n"}
{"task_id": "CPP/103", "generation": "#include <iostream>\n#include <cmath>\n#include <string>\n#include <sstream>\nusing namespace std;\n\nstring int_to_binary(int num) {\n    string binary = \"\";\n    while (num > 0) {\n        binary = to_string(num % 2) + binary;\n        num /= 2;\n    }\n    return binary.empty() ? \"0\" : binary;\n}\n\nstring rounded_avg(int n, int m) {\n    if (n > m)\n        return \"-1\";\n\n    int total_sum = 0;\n    for (int i = n; i <= m; ++i)\n        total_sum += i;\n\n    int count = m - n + 1;\n    int average = total_sum / count; // integer division for rounding down\n\n    string binary_representation = int_to_binary(average);\n    return binary_representation;\n}\n", "py_code": "def rounded_avg(n, m):\n    if n > m:\n        return \"-1\"\n    total_sum = sum(range(n, m + 1))\n    count = m - n + 1\n    average = total_sum // count  # integer division for rounding down\n    binary_representation = bin(average)[2:]  # convert to binary and remove the '0b' prefix\n    return binary_representation\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `rounded_avg` takes two integers `n` and `m` as input and computes the average of all integers from `n` to `m`, inclusive. If `n` is greater than `m`, it returns \"-1\". The function first checks if `n > m`. If true, it immediately returns \"-1\" since there are no valid numbers in this range.\n\nIf `n <= m`, the function calculates the sum of all integers from `n` to `m` using Python's built-in `sum()` and `range()` functions. It then determines the count of these integers as `count = m - n + 1`. The average is computed by performing integer division (`//`) on the total sum by the count, which ensures that the result is rounded down to the nearest integer.\n\nFinally, the function converts this integer average into its binary representation using Python's built-in `bin()` function and removes the '0b' prefix from the resulting string. The function then returns this binary string.\n```\n\n"}
{"task_id": "CPP/57", "generation": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nbool monotonic(vector<float> l) {\n    bool increasing = true;\n    bool decreasing = true;\n    \n    for (size_t i = 1; i < l.size(); ++i) {\n        if (l[i] > l[i - 1]) {\n            decreasing = false;\n        }\n        if (l[i] < l[i - 1]) {\n            increasing = false;\n        }\n    }\n\n    return increasing || decreasing;\n}\n", "py_code": "def monotonic(l):\n    increasing = all(x <= y for x, y in zip(l, l[1:]))\n    decreasing = all(x >= y for x, y in zip(l, l[1:]))\n    return increasing or decreasing\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `monotonic` checks whether a list of numbers is either monotonically increasing or decreasing. The function uses two generator expressions within the `all()` function to check for both conditions:\n\n1. **Increasing Condition**: `increasing = all(x <= y for x, y in zip(l, l[1:]))`\n   - This expression checks if every element `x` is less than or equal to its subsequent element `y`. The `zip(l, l[1:])` pairs each element with the next one in the list.\n\n2. **Decreasing Condition**: `decreasing = all(x >= y for x, y in zip(l, l[1:]))`\n   - This expression checks if every element `x` is greater than or equal to its subsequent element `y`.\n\nThe function returns `True` if either condition (`increasing` or `decreasing`) holds true for the entire list; otherwise, it returns `False`.```\n\n"}
{"task_id": "CPP/28", "generation": "#include <vector>\n#include <string>\nusing namespace std;\n\nstring concatenate(vector<string> strings) {\n    string result = \"\";\n    for (const auto& str : strings) {\n        result += str;\n    }\n    return result;\n}\n", "py_code": "from typing import List\n\ndef concatenate(strings: List[str]) -> str:\n    return ''.join(strings)\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `concatenate` takes a list of strings as input and returns a single string that is the concatenation of all the strings in the list. The function uses the built-in `join` method to concatenate the elements of the list without any separator between them. If the input list is empty, it will return an empty string.\n\n"}
{"task_id": "CPP/39", "generation": "#include <iostream>\n#include <vector>\n\nbool is_prime(long num) {\n    if (num <= 1) return false;\n    for (long i = 2; i * i <= num; ++i) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\nint prime_fib(int n) {\n    std::vector<long> fib_numbers = {0, 1};\n    int count = 0;\n\n    while (count < n) {\n        long next_fib = fib_numbers.back() + *(fib_numbers.rbegin() + 1);\n        if (is_prime(next_fib)) {\n            ++count;\n            if (count == n) return static_cast<int>(next_fib);\n        }\n        fib_numbers.push_back(next_fib);\n    }\n\n    // The function should never reach this point as it returns within the loop.\n    return -1; \n}\n", "py_code": "def is_prime(num):\n    if num <= 1:\n        return False\n    for i in range(2, int(num**0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef prime_fib(n):\n    fib_numbers = [0, 1]\n    count = 0\n    index = 2\n    \n    while count < n:\n        next_fib = fib_numbers[-1] + fib_numbers[-2]\n        if is_prime(next_fib):\n            count += 1\n        if count == n:\n            return next_fib\n        fib_numbers.append(next_fib)\n        index += 1\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `prime_fib(n)` is designed to find and return the n-th Fibonacci number that is also a prime number. The function works as follows:\n1. It defines an auxiliary function `is_prime(num)` which checks if a given number `num` is prime.\n2. It initializes a list `fib_numbers` with the first two Fibonacci numbers `[0, 1]`.\n3. It sets up a counter `count` to keep track of how many prime Fibonacci numbers have been found and an index variable `index` starting from 2 (the next position in the Fibonacci sequence).\n4. The function enters a while loop that continues until `count` reaches `n`. \n5. Inside the loop, it calculates the next Fibonacci number by summing up the last two elements of `fib_numbers`.\n6. It checks if this new Fibonacci number is prime using the `is_prime()` function.\n7. If the number is prime, it increments the counter `count`.\n8. When `count` equals `n`, the loop breaks and the current Fibonacci number (which is also prime) is returned as the result.\n9. The newly calculated Fibonacci number is appended to `fib_numbers` for future calculations.\n\nThis approach ensures that all Fibonacci numbers are generated in sequence, checked for primality, and counted until the n-th prime Fibonacci number is found.\n\n"}
{"task_id": "CPP/45", "generation": "#include <stdio.h>\n#include <math.h>\nusing namespace std;\n\nfloat triangle_area(float a, float h) {\n    return 0.5 * a * h;\n}\n", "py_code": "def triangle_area(a, h):\n    return 0.5 * a * h\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `triangle_area` takes two parameters: `a`, which represents the length of a side (base) of the triangle, and `h`, which represents the height of the triangle perpendicular to that side. The area of a triangle is calculated using the formula `(1/2) * base * height`. In this case, the function returns the result of multiplying half of the base (`a`) by the height (`h`). This calculation gives the area of the triangle as a float value.``` \n\n"}
{"task_id": "CPP/145", "generation": "#include <stdio.h>\n#include <math.h>\n#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nint sum_of_digits(int n) {\n    int sum = 0;\n    bool is_negative = n < 0;\n    while (n != 0) {\n        sum += n % 10;\n        n /= 10;\n    }\n    return is_negative ? -sum : sum;\n}\n\nstruct CustomComparator {\n    vector<int>& nums;\n    explicit CustomComparator(vector<int>& nums) : nums(nums) {}\n\n    bool operator()(int a, int b) {\n        int sum_a = sum_of_digits(a);\n        int sum_b = sum_of_digits(b);\n\n        if (sum_a != sum_b) return sum_a < sum_b;\n\n        // If sums are equal, compare based on original index\n        auto it_a = find(nums.begin(), nums.end(), a);\n        auto it_b = find(nums.begin(), nums.end(), b);\n        return distance(nums.begin(), it_a) < distance(nums.begin(), it_b);\n    }\n};\n\nvector<int> order_by_points(vector<int> nums) {\n    CustomComparator comp(nums);\n    sort(nums.begin(), nums.end(), comp);\n    return nums;\n}\n", "py_code": "from typing import List\n\ndef sum_of_digits(n: int) -> int:\n    return sum(int(digit) for digit in str(n))\n\ndef order_by_points(nums: List[int]) -> List[int]:\n    return sorted(nums, key=lambda x: (sum_of_digits(x), nums.index(x)))\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python solution defines a function `order_by_points` that takes a list of integers and returns them sorted in ascending order based on the sum of their digits. The function uses an auxiliary function `sum_of_digits`, which calculates the sum of the digits of a given integer by converting it to a string, iterating over each character (digit), converting back to integers, and then summing these values.\n\nThe main sorting logic is implemented using Python's built-in `sorted` function with a custom key. The key for sorting is a tuple where the first element is the sum of digits calculated by `sum_of_digits`, and the second element is the original index of each number in the list (`nums.index(x)`). This ensures that if two numbers have the same digit sum, they are ordered based on their initial positions in the input list. The result is a new list with elements sorted according to these criteria.\n```"}
{"task_id": "CPP/84", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\nusing namespace std;\n\nstring solve(int N) {\n    int digit_sum = 0;\n    while (N > 0) {\n        digit_sum += N % 10; // Add the last digit to sum\n        N /= 10;             // Remove the last digit from N\n    }\n\n    string binary_result = \"\";\n    if (digit_sum == 0) return \"0\"; // Special case for when the sum is zero\n\n    while (digit_sum > 0) {\n        binary_result = to_string(digit_sum % 2) + binary_result; // Prepend the remainder to the result\n        digit_sum /= 2;\n    }\n\n    return binary_result;\n}\n", "py_code": "def solve(N):\n    digit_sum = sum(int(digit) for digit in str(N))\n    return bin(digit_sum)[2:]\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `solve` takes an integer N as input and returns a string representing the binary form of the sum of its digits. The function first converts the integer to a string so that it can iterate over each digit. It then calculates the sum of these digits by converting them back into integers and using the `sum()` function. After obtaining the sum, the function uses Python's built-in `bin` function to convert this sum into binary format. The `[2:]` slice is used to remove the '0b' prefix that `bin` adds to indicate a binary number. Finally, it returns the resulting string.\n```\n\n\n"}
{"task_id": "CPP/113", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nvector<string> odd_count(vector<string> lst) {\n    vector<string> result;\n    \n    for (const string& s : lst) {\n        int count = 0;\n        \n        // Count the number of odd digits in the current string\n        for (char c : s) {\n            if ((c - '0') % 2 != 0) { // Convert char to integer and check if it's odd\n                count++;\n            }\n        }\n\n        // Construct the output string with all occurrences of 'i' replaced by the count\n        string output = \"the number of odd elements \";\n        for (int i = 0; i < output.length(); ++i) {\n            if (output[i] == 'i') {\n                output.erase(i, 1); // Remove 'i'\n                i -= 2; // Adjust index due to removal\n                output.insert(i + 1, to_string(count)); // Insert count at the position of 'i'\n            }\n        }\n\n        result.push_back(output);\n    }\n    \n    return result;\n}\n\n", "py_code": "def odd_count(lst):\n    result = []\n    for s in lst:\n        count = sum(1 for c in s if int(c) % 2 != 0)\n        output_string = \"the number of odd elements {}n the str{}ng {} of the {}nput.\".format(count, count, count, count)\n        result.append(output_string)\n    return result\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `odd_count` takes a list of strings (`lst`) as input and returns a list of formatted strings based on the number of odd digits in each string from the input list.\n\n1. For each string `s` in the input list, it calculates the count of odd digits by iterating over each character `c` in `s`, converting it to an integer, and checking if it is odd (`int(c) % 2 != 0`). The sum function aggregates these counts.\n   \n2. It then constructs a new string using Python's `.format()` method where all occurrences of `{}` are replaced by the count of odd digits found in step 1.\n\n3. This formatted string is appended to the `result` list, which accumulates the output for each input string.\n\n4. Finally, it returns the `result` list containing the formatted strings.\n```\n\n"}
{"task_id": "CPP/36", "generation": "#include <string>\nusing namespace std;\n\nint fizz_buzz(int n) {\n    int count = 0;\n    for (int i = 1; i < n; ++i) {\n        if ((i % 11 == 0 || i % 13 == 0) && to_string(i).find('7') != string::npos) {\n            count += 1;\n        }\n    }\n    return count;\n}\n", "py_code": "def fizz_buzz(n):\n    count = 0\n    for i in range(1, n):\n        if (i % 11 == 0 or i % 13 == 0) and '7' in str(i):\n            count += 1\n    return count\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `fizz_buzz` takes an integer `n` as input and returns the number of times the digit '7' appears in integers less than `n`, which are divisible by either 11 or 13.\n\n- The function initializes a counter variable `count` to zero.\n- It iterates through all numbers from 1 up to but not including `n`.\n- For each number, it checks if the number is divisible by 11 or 13 using the modulo operator (`%`). If so, it then converts the number into a string and checks if the digit '7' appears in this string representation.\n- If both conditions are met (divisible by 11 or 13 and contains the digit '7'), the counter `count` is incremented.\n- Finally, the function returns the value of `count`, which represents the number of integers less than `n` that meet the specified criteria.```"}
{"task_id": "CPP/144", "generation": "#include <string>\n#include <sstream>\nusing namespace std;\n\nbool simplify(string x, string n) {\n    int num1, den1, num2, den2;\n    \n    // Extracting numerators and denominators from strings.\n    size_t slashPos = x.find('/');\n    stringstream(x.substr(0, slashPos)) >> num1;\n    stringstream(x.substr(slashPos + 1)) >> den1;\n\n    slashPos = n.find('/');\n    stringstream(n.substr(0, slashPos)) >> num2;\n    stringstream(n.substr(slashPos + 1)) >> den2;\n\n    // Calculating the product of numerators and denominators.\n    int numerator_product = num1 * num2;\n    int denominator_product = den1 * den2;\n\n    // Checking if the result is a whole number by verifying divisibility.\n    return (numerator_product % denominator_product == 0);\n}\n", "py_code": "def simplify(x: str, n: str) -> bool:\n    num1, den1 = map(int, x.split('/'))\n    num2, den2 = map(int, n.split('/'))\n\n    # Simplify the expression by multiplying numerators and denominators separately.\n    numerator_product = num1 * num2\n    denominator_product = den1 * den2\n\n    # Check if the result is a whole number by verifying that the numerator product is divisible by the denominator product.\n    return numerator_product % denominator_product == 0\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `simplify` takes two string arguments representing fractions and determines whether their product is a whole number. The function first splits each fraction into its numerator and denominator components by splitting on the '/' character and converting them to integers.\n\nIt then calculates the product of the numerators and denominators separately, storing these in `numerator_product` and `denominator_product`. To determine if the resulting expression evaluates to a whole number, it checks whether the `numerator_product` is divisible by the `denominator_product`, returning `True` if so (i.e., there's no remainder when dividing) and `False` otherwise.```\n\n"}
{"task_id": "CPP/0", "generation": "#include <vector>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\nbool has_close_elements(vector<float> numbers, float threshold) {\n    sort(numbers.begin(), numbers.end());\n    for (size_t i = 0; i < numbers.size() - 1; ++i) {\n        if (fabs(numbers[i] - numbers[i + 1]) < threshold) {\n            return true;\n        }\n    }\n    return false;\n}\n", "py_code": "from typing import List\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    numbers.sort()\n    for i in range(len(numbers) - 1):\n        if abs(numbers[i] - numbers[i + 1]) < threshold:\n            return True\n    return False\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `has_close_elements` takes a list of floating-point numbers and a threshold value as input parameters. The goal is to determine if there are any two numbers in the list that are closer to each other than the given threshold.\n\n1. **Sorting**: The function first sorts the list of numbers in ascending order.\n2. **Iteration and Comparison**: It then iterates through the sorted list, comparing adjacent elements to check if their absolute difference is less than the provided threshold.\n3. **Return Value**: If such a pair is found (i.e., the difference between two consecutive numbers is less than the threshold), the function returns `True`. Otherwise, after completing the iteration without finding any such pairs, it returns `False`.\n\nThis approach ensures that we only need to check adjacent elements in the sorted list because sorting guarantees that if there are any close elements, they will be next to each other.\n\n"}
{"task_id": "CPP/17", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <sstream>\nusing namespace std;\n\nvector<int> parse_music(string music_string) {\n    vector<int> beats;\n    stringstream ss(music_string);\n    string note;\n    \n    while (getline(ss, note, ' ')) {\n        if (note == \"o\") {\n            beats.push_back(4);\n        } else if (note == \"o|\") {\n            beats.push_back(2);\n        } else if (note == \".|\") {\n            beats.push_back(1);\n        }\n    }\n\n    return beats;\n}\n", "py_code": "def parse_music(music_string):\n    notes = music_string.split()\n    beats = []\n    for note in notes:\n        if note == \"o\":\n            beats.append(4)\n        elif note == \"o|\":\n            beats.append(2)\n        elif note == \".|\":\n            beats.append(1)\n    return beats\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `parse_music` takes a string representing musical notes in a special ASCII format and returns a list of integers corresponding to how many beats each note lasts. The input string is split into individual notes using spaces as delimiters.\n\nFor each note in the resulting list:\n- If the note is `\"o\"`, it represents a whole note, which lasts four beats.\n- If the note is `\"o|\"` , it represents a half note, which lasts two beats.\n- If the note is `\".|\"` , it represents a quarter note, which lasts one beat.\n\nThe function appends the corresponding number of beats to the list `beats` and returns this list at the end.```\n\n"}
{"task_id": "CPP/47", "generation": "#include <stdio.h>\n#include <math.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nfloat median(vector<float> l) {\n    sort(l.begin(), l.end());\n    int n = l.size();\n    if (n % 2 == 0) {\n        return (l[n / 2 - 1] + l[n / 2]) / 2.0;\n    } else {\n        return l[n / 2];\n    }\n}\n", "py_code": "from typing import List\n\ndef median(l: List[float]) -> float:\n    l.sort()\n    n = len(l)\n    if n % 2 == 0:\n        return (l[n//2 - 1] + l[n//2]) / 2\n    else:\n        return l[n//2]\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `median` calculates and returns the median of a list of numbers (`l`). The steps are as follows:\n\n1. **Sorting**: The input list `l` is first sorted in ascending order.\n2. **Length Check**: The length of the sorted list `n` is checked to determine if it's even or odd.\n3. **Median Calculation**:\n   - If the length `n` is even, the median is calculated as the average of the two middle elements: `(l[n//2 - 1] + l[n//2]) / 2`.\n   - If the length `n` is odd, the median is simply the middle element: `l[n//2]`.\n\nThe function returns the computed median value.\n\n"}
{"task_id": "CPP/75", "generation": "#include <vector>\n#include <cmath>\nusing namespace std;\n\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\nbool is_multiply_prime(int a) {\n    vector<int> primes;\n    \n    // Generate list of prime numbers less than 100\n    for (int i = 2; i < 100; ++i) {\n        if (is_prime(i)) {\n            primes.push_back(i);\n        }\n    }\n\n    // Check every combination of three primes to see if their product equals 'a'\n    for (size_t i = 0; i < primes.size(); ++i) {\n        for (size_t j = i; j < primes.size(); ++j) {\n            for (size_t k = j; k < primes.size(); ++k) {\n                if (primes[i] * primes[j] * primes[k] == a) {\n                    return true;\n                }\n            }\n        }\n    }\n\n    return false;\n}\n", "py_code": "def is_multiply_prime(a):\n    def is_prime(n):\n        if n <= 1:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    primes = [i for i in range(2, 100) if is_prime(i)]\n    \n    for i in primes:\n        for j in primes:\n            for k in primes:\n                if i * j * k == a:\n                    return True\n    return False\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `is_multiply_prime(a)` checks whether the given number `a` is the product of three prime numbers, where each prime number is less than 100.\n\n1. The inner function `is_prime(n)` determines if a number `n` is prime by checking divisibility from 2 up to the square root of `n`. If any divisor is found, it returns False; otherwise, it returns True.\n   \n2. A list comprehension generates all prime numbers less than 100 using the `is_prime` function and stores them in the variable `primes`.\n\n3. The function then uses three nested loops to iterate over every combination of three primes from the `primes` list.\n\n4. For each combination, it checks if their product equals the input number `a`. If such a combination is found, the function returns True.\n\n5. If no valid combination is found after checking all possibilities, the function returns False.\n\nThis approach ensures that we check every possible triplet of prime numbers less than 100 to see if they multiply to give the given number `a`.\n\n"}
{"task_id": "CPP/124", "generation": "#include <string>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nbool valid_date(string date) {\n    // Check if the string is empty or not in the correct format (mm-dd-yyyy)\n    if(date.empty() || date.size() != 10 || date[2] != '-' || date[5] != '-') return false;\n    \n    vector<int> days_in_month = {31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\n    \n    // Extract month, day and year from the date string\n    int month = stoi(date.substr(0, 2));\n    int day = stoi(date.substr(3, 2));\n    int year = stoi(date.substr(6, 4));\n\n    // Check if month is valid (between 1-12)\n    if(month < 1 || month > 12) return false;\n\n    // Validate the number of days based on the month\n    if(day < 1 || day > days_in_month[month - 1]) return false;\n    \n    return true;\n}\n", "py_code": "def valid_date(date):\n    if not date or len(date) != 10 or date[2] != '-' or date[5] != '-':\n        return False\n\n    month, day, year = date.split('-')\n    \n    try:\n        month = int(month)\n        day = int(day)\n        year = int(year)\n    except ValueError:\n        return False\n    \n    if not (1 <= month <= 12):\n        return False\n    if month in [1,3,5,7,8,10,12]:\n        if not (1 <= day <= 31):\n            return False\n    elif month in [4,6,9,11]:\n        if not (1 <= day <= 30):\n            return False\n    else: # February\n        if not (1 <= day <= 29):\n            return False\n\n    return True\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `valid_date` checks whether a given date string is valid based on specific rules. The function first ensures that the input string is not empty and has exactly 10 characters with hyphens in the correct positions (i.e., at indices 2 and 5). If these conditions are not met, it returns False.\n\nThe function then splits the date into month, day, and year components using the hyphen as a delimiter. It attempts to convert each component into an integer; if this conversion fails due to non-numeric characters, the function returns False.\n\nNext, the function checks whether the month is within the valid range (1 through 12). For months with 31 days (January, March, May, July, August, October, December), it verifies that the day falls between 1 and 31. For months with 30 days (April, June, September, November), it checks if the day is within the range of 1 to 30. Finally, for February, it ensures the day does not exceed 29.\n\nIf all conditions are satisfied, the function returns True, indicating that the date string is valid according to the specified rules.\n```\n\n"}
{"task_id": "CPP/101", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\nusing namespace std;\n\nvector<string> words_string(string s) {\n    // Replace all commas with spaces\n    replace(s.begin(), s.end(), ',', ' ');\n\n    vector<string> result;\n    stringstream ss(s);\n    string word;\n\n    // Split the string by spaces and store each word in the vector\n    while (ss >> word) {\n        result.push_back(word);\n    }\n\n    return result;\n}\n", "py_code": "def words_string(s):\n    # Replace commas with spaces and then split by spaces\n    return [word for word in s.replace(',', '').split()]\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `words_string` takes a string as input and returns a list of words from that string. The function first replaces all commas in the string with spaces to ensure consistent separation between words. It then splits the modified string by spaces using the `split()` method, which breaks the string into substrings at each space character and returns them as elements in a list. This approach effectively handles both comma-separated and space-separated inputs, ensuring that all words are correctly extracted and returned in a list format.```\n\n"}
{"task_id": "CPP/14", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> all_prefixes(string str) {\n    vector<string> prefixes;\n    for (size_t i = 1; i <= str.size(); ++i) {\n        prefixes.push_back(str.substr(0, i));\n    }\n    return prefixes;\n}\n", "py_code": "def all_prefixes(str):\n    return [str[:i+1] for i in range(len(str))]\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `all_prefixes` takes a string as input and returns a list of all possible prefixes from shortest to longest. It achieves this by using a list comprehension that iterates through each index in the range of the length of the string. For each index `i`, it slices the string from the beginning up to (and including) the character at position `i+1` and adds this substring to the resulting list. This way, for a given input string \"abc\", the function will return [\"a\", \"ab\", \"abc\"].```\n\n"}
{"task_id": "CPP/141", "generation": "#include <iostream>\n#include <string>\n#include <cctype> // for isalpha function\n\nusing namespace std;\n\nstring file_name_check(string file_name) {\n    // Check if there is exactly one dot in the filename\n    int dot_count = 0;\n    for (char c : file_name) {\n        if (c == '.') {\n            ++dot_count;\n        }\n    }\n\n    if (dot_count != 1) {\n        return \"No\";\n    }\n\n    size_t dot_position = file_name.find('.');\n    \n    // Split the filename into two parts: before and after the dot\n    string name_part = file_name.substr(0, dot_position);\n    string extension_part = file_name.substr(dot_position + 1);\n\n    // Check if the part before the dot starts with a letter and has no more than three digits\n    int digit_count = 0;\n    for (char c : name_part) {\n        if (isdigit(c)) {\n            ++digit_count;\n        }\n    }\n\n    bool valid_name_start = !name_part.empty() && isalpha(name_part[0]);\n    \n    // Check if the part after the dot is one of the allowed extensions\n    const string valid_extensions[] = {\"txt\", \"exe\", \"dll\"};\n    bool valid_extension = false;\n\n    for (const auto& ext : valid_extensions) {\n        if (extension_part == ext) {\n            valid_extension = true;\n            break;\n        }\n    }\n\n    if (!valid_name_start || digit_count > 3 || !valid_extension) {\n        return \"No\";\n    }\n\n    return \"Yes\";\n}\n", "py_code": "def file_name_check(file_name):\n    # Check if there is exactly one dot in the filename\n    if file_name.count('.') != 1:\n        return \"No\"\n    \n    # Split the filename into two parts: before and after the dot\n    name_parts = file_name.split('.')\n    \n    # Check if the part before the dot starts with a letter and has no more than three digits\n    if not (name_parts[0] and name_parts[0][0].isalpha() and sum(c.isdigit() for c in name_parts[0]) <= 3):\n        return \"No\"\n    \n    # Check if the part after the dot is one of the allowed extensions\n    valid_extensions = {\"txt\", \"exe\", \"dll\"}\n    if name_parts[1] not in valid_extensions:\n        return \"No\"\n\n    return \"Yes\"\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `file_name_check` takes a string representing a file's name and checks if it meets certain criteria to be considered valid. The conditions are as follows:\n1. There should not be more than three digits in the filename.\n2. The filename must contain exactly one dot (`.`).\n3. The substring before the dot should start with a letter from the Latin alphabet and cannot be empty.\n4. The substring after the dot should be one of the allowed extensions: `txt`, `exe`, or `dll`.\n\nThe function first checks if there is exactly one dot in the filename using the `count` method on the string. If not, it returns `\"No\"`.\n\nNext, the function splits the filename into two parts based on the dot (`.`) and stores them in a list named `name_parts`. It then checks whether the part before the dot starts with an alphabetic character and contains no more than three digits using the `isalpha` method for checking if the first character is a letter, and by summing up the number of digit characters in that substring.\n\nFinally, it verifies if the extension (the part after the dot) is one of the allowed extensions. If all conditions are met, the function returns `\"Yes\"`, otherwise, it returns `\"No\"`.\n\n"}
{"task_id": "CPP/123", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> get_odd_collatz(int n) {\n    vector<int> sequence;\n    while (n != 1) {\n        sequence.push_back(n);\n        if (n % 2 == 0) {\n            n /= 2;\n        } else {\n            n = 3 * n + 1;\n        }\n    }\n    sequence.push_back(1); // Add the final term, which is always 1\n\n    vector<int> odd_numbers;\n    for (int num : sequence) {\n        if (num % 2 != 0) {\n            odd_numbers.push_back(num);\n        }\n    }\n\n    sort(odd_numbers.begin(), odd_numbers.end());\n    return odd_numbers;\n}\n", "py_code": "def get_odd_collatz(n):\n    sequence = []\n    while n != 1:\n        sequence.append(n)\n        if n % 2 == 0:\n            n //= 2\n        else:\n            n = 3 * n + 1\n    sequence.append(1)  # Add the final term, which is always 1\n    \n    odd_numbers = [num for num in sequence if num % 2 != 0]\n    \n    return sorted(odd_numbers)\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `get_odd_collatz(n)` generates and returns a sorted list of odd numbers from the Collatz sequence starting with the given positive integer n. The Collatz sequence is defined such that for each term in the sequence, if the term is even, it is divided by 2 to get the next term; if the term is odd, it is multiplied by 3 and incremented by 1 to get the next term. This process continues until the sequence reaches 1.\n\nThe function initializes an empty list `sequence` to store all terms of the Collatz sequence starting from n. It then enters a loop that appends each term to `sequence` and updates n according to the Collatz rules until n becomes 1. After exiting the loop, it ensures that the final term (which is always 1) is added to the list.\n\nThe function then creates a new list `odd_numbers`, which contains only the odd numbers from `sequence`. Finally, this list of odd numbers is sorted in ascending order and returned as the result.\n```\n\n"}
{"task_id": "CPP/148", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nvector<string> bf(string planet1, string planet2) {\n    vector<string> planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n    \n    auto it1 = find(planets.begin(), planets.end(), planet1);\n    auto it2 = find(planets.begin(), planets.end(), planet2);\n\n    if (it1 == planets.end() || it2 == planets.end()) {\n        return {};\n    }\n\n    int index1 = distance(planets.begin(), it1);\n    int index2 = distance(planets.begin(), it2);\n\n    // Ensure the indices are sorted\n    int start_index = min(index1, index2);\n    int end_index = max(index1, index2);\n\n    vector<string> result;\n    for (int i = start_index + 1; i < end_index; ++i) {\n        result.push_back(planets[i]);\n    }\n\n    return result;\n}\n", "py_code": "def bf(planet1: str, planet2: str) -> list:\n    planets = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n    \n    if planet1 not in planets or planet2 not in planets:\n        return []\n    \n    index1, index2 = planets.index(planet1), planets.index(planet2)\n    \n    # Ensure the indices are sorted\n    start_index, end_index = min(index1, index2), max(index1, index2)\n    \n    return planets[start_index + 1:end_index]\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `bf` takes two strings representing planet names and returns a list of all planets located between their orbits, sorted by proximity to the Sun. The function first defines an ordered list of the eight planets in our solar system. It then checks if both input planet names are valid (i.e., present in the predefined list). If either name is invalid, it immediately returns an empty list.\n\nThe function proceeds to find the indices of the two given planets within the `planets` list and ensures that these indices are sorted such that `start_index` is less than or equal to `end_index`. It then slices the `planets` list from one index past `start_index` up to but not including `end_index`, effectively returning all planets between the two given ones. If the input planets are adjacent, an empty list will be returned as expected.\n```\n\n"}
{"task_id": "CPP/133", "generation": "#include <stdio.h>\n#include <math.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint sum_squares(vector<float> lst) {\n    int result = 0;\n    for (float num : lst) {\n        float ceil_num = ceil(num);\n        result += static_cast<int>(ceil_num * ceil_num);\n    }\n    return result;\n}\n", "py_code": "from math import ceil\n\ndef sum_squares(lst):\n    return sum(ceil(x) ** 2 for x in lst)\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `sum_squares` takes a list of numbers (`lst`) as input and returns the sum of the squares of each number after rounding them up to the nearest integer (ceiling). The function uses a generator expression inside the `sum()` function to iterate over each element in the list, apply the ceiling operation using `ceil()`, square it, and then sum all these squared values. This approach ensures that each element is rounded up before squaring and summing them together.```\n\n"}
{"task_id": "CPP/109", "generation": "#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nbool move_one_ball(vector<int> arr) {\n    // Check if array is empty or already sorted.\n    if (arr.empty() || is_sorted(arr.begin(), arr.end())) {\n        return true;\n    }\n\n    int n = arr.size();\n    \n    // Find the index where order breaks\n    for (int i = 0; i < n - 1; ++i) {\n        if (arr[i] > arr[i + 1]) {\n            // Construct shifted array by performing right shift operation.\n            vector<int> shifted_arr(arr.begin() + i + 1, arr.end());\n            shifted_arr.insert(shifted_arr.end(), arr.begin(), arr.begin() + i + 1);\n\n            // Check if the new array is sorted\n            return is_sorted(shifted_arr.begin(), shifted_arr.end());\n        }\n    }\n\n    // If no break point found and not already returned true, return false.\n    return false;\n}\n", "py_code": "def move_one_ball(arr):\n    if not arr:  # If the array is empty, return True.\n        return True\n    \n    n = len(arr)\n    \n    # Find the index where the array should start for it to be sorted in non-decreasing order.\n    for i in range(n - 1):\n        if arr[i] > arr[i + 1]:\n            break\n    else:\n        return True  # The array is already sorted.\n\n    # Check if shifting elements from this point results in a sorted array.\n    shifted_arr = arr[i+1:] + arr[:i+1]\n    \n    for i in range(len(shifted_arr) - 1):\n        if shifted_arr[i] > shifted_arr[i + 1]:\n            return False\n    \n    return True\n```\n\n", "py_summary": "### Analysis of Python Code\n\nThe provided Python function `move_one_ball` checks whether it is possible to sort a given list (`arr`) in non-decreasing order by performing right shift operations.\n\n1. **Base Case Check**: The function first checks if the input array `arr` is empty, and if so, returns `True`. An empty array can be considered sorted trivially.\n   \n2. **Finding Break Point**:\n   - It iterates through the list to find an index where the order breaks (i.e., where `arr[i] > arr[i + 1]`). This indicates a potential point from which shifting could result in a sorted array.\n   - If no such break is found, it means the array is already sorted and returns `True`.\n\n3. **Shifting Elements**:\n   - Once the break index (`i`) is identified, the function constructs a new list (`shifted_arr`) by performing a right shift operation starting from this point. This involves slicing the original array into two parts: elements after the break point and elements up to and including the break point.\n   \n4. **Checking Sorted Order**:\n   - The newly constructed `shifted_arr` is then checked for sorted order by iterating through it and ensuring that each element is not greater than its successor.\n\n5. **Return Result**: If all checks pass, the function returns `True`, indicating that a valid shift operation can sort the array; otherwise, it returns `False`.\n\n"}
{"task_id": "CPP/100", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> make_a_pile(int n) {\n    vector<int> stones;\n    int current_stones = n;\n    \n    for (int i = 0; i < n; ++i) {\n        stones.push_back(current_stones);\n        // The next number is always obtained by adding 2\n        current_stones += 2;\n    }\n    \n    return stones;\n}\n", "py_code": "def make_a_pile(n):\n    stones = []\n    current_stones = n\n    for _ in range(n):\n        stones.append(current_stones)\n        if n % 2 == 0:  # If n is even\n            current_stones += 2  # Next even number\n        else:\n            current_stones += 2  # Next odd number (same as next even)\n    return stones\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `make_a_pile` takes a positive integer `n` and generates a list of integers representing the number of stones in each level of a pile with `n` levels.\n\n1. The function initializes an empty list `stones` to store the number of stones at each level.\n2. It sets `current_stones` to `n`, which represents the initial number of stones for the first level.\n3. A loop runs `n` times, where in each iteration:\n   - The current number of stones (`current_stones`) is appended to the list `stones`.\n   - Depending on whether `n` is even or odd, the next value of `current_stones` is calculated by adding 2 (since both the next even and next odd numbers are obtained by adding 2).\n4. The function returns the list `stones`, which contains the number of stones in each level.\n\n"}
{"task_id": "CPP/150", "generation": "#include <cmath> // For sqrt function\nusing namespace std;\n\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    for (int i = 2; i <= sqrt(num); ++i) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\nint x_or_y(int n, int x, int y) {\n    return is_prime(n) ? x : y;\n}\n", "py_code": "def is_prime(num):\n    if num <= 1:\n        return False\n    for i in range(2, int(num**0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef x_or_y(n, x, y):\n    return x if is_prime(n) else y\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python solution consists of two functions: `is_prime` and `x_or_y`. The function `is_prime(num)` checks if a given number `num` is prime by iterating from 2 to the square root of `num`, checking for any divisors. If it finds one, it returns `False`; otherwise, it returns `True`.\n\nThe main function `x_or_y(n, x, y)` uses this helper function to determine whether the integer `n` is a prime number. If `n` is prime, it returns the value of `x`. Otherwise, it returns the value of `y`.\n\nThis approach ensures that we correctly identify if `n` is prime and then return either `x` or `y` based on this condition.\n\n"}
{"task_id": "CPP/153", "generation": "#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nstring Strongest_Extension(string class_name, vector<string> extensions) {\n    int max_strength = INT_MIN;\n    string strongest_ext = \"\";\n\n    for (const auto& ext : extensions) {\n        int cap = count_if(ext.begin(), ext.end(), ::isupper);\n        int sm = count_if(ext.begin(), ext.end(), ::islower);\n        int strength = cap - sm;\n\n        if (strength > max_strength || (strength == max_strength && strongest_ext.empty())) {\n            max_strength = strength;\n            strongest_ext = ext;\n        }\n    }\n\n    return class_name + \".\" + strongest_ext;\n}\n", "py_code": "def strongest_extension(class_name, extensions):\n    max_strength = float('-inf')\n    strongest_ext = \"\"\n    \n    for ext in extensions:\n        cap = sum(1 for c in ext if c.isupper())\n        sm = sum(1 for c in ext if c.islower())\n        strength = cap - sm\n        \n        if strength > max_strength or (strength == max_strength and not strongest_ext):\n            max_strength = strength\n            strongest_ext = ext\n            \n    return f\"{class_name}.{strongest_ext}\"\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `strongest_extension` takes a class name and a list of extension names as input and returns a string representing the strongest extension for that class in the format \"ClassName.StrongestExtensionName\". The strength of an extension is calculated based on the difference between the number of uppercase letters (CAP) and lowercase letters (SM) in its name.\n\nThe function iterates through each extension, calculating its strength by counting the number of uppercase and lowercase characters. It then compares this strength with the current maximum strength (`max_strength`). If the new extension's strength is greater than the current maximum or if it has the same strength but comes first in the list (due to the initial condition), it updates `strongest_ext` to be the name of this extension.\n\nFinally, the function returns a string combining the class name and the strongest extension name.```\n\n"}
{"task_id": "CPP/107", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nbool is_palindrome(int num) {\n    string str_num = to_string(num);\n    string rev_str_num = str_num;\n    reverse(rev_str_num.begin(), rev_str_num.end());\n    return str_num == rev_str_num;\n}\n\nvector<int> even_odd_palindrome(int n){\n    int even_count = 0, odd_count = 0;\n\n    for (int i = 1; i <= n; ++i) {\n        if (is_palindrome(i)) {\n            if (i % 2 == 0)\n                even_count++;\n            else\n                odd_count++;\n        }\n    }\n\n    return {even_count, odd_count};\n}\n", "py_code": "def is_palindrome(num):\n    return str(num) == str(num)[::-1]\n\ndef even_odd_palindrome(n):\n    even_count = 0\n    odd_count = 0\n    for i in range(1, n + 1):\n        if is_palindrome(i):\n            if i % 2 == 0:\n                even_count += 1\n            else:\n                odd_count += 1\n    return (even_count, odd_count)\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `even_odd_palindrome` takes an integer `n` as input and returns a tuple containing two integers: the count of even palindromes and the count of odd palindromes within the range [1, n], inclusive. \n\nFirstly, it defines a helper function `is_palindrome(num)` which checks if a given number is a palindrome by converting it to a string and comparing it with its reverse.\n\nThe main function then initializes two counters: `even_count` and `odd_count`, both set to zero. It iterates through all integers from 1 up to and including `n`. For each integer, it checks whether the number is a palindrome using the helper function `is_palindrome()`. If the number is a palindrome, it further checks if the number is even or odd by checking the remainder of division by 2 (`i % 2 == 0`). Depending on this check, it increments either `even_count` or `odd_count`.\n\nFinally, the function returns a tuple `(even_count, odd_count)` containing the counts of even and odd palindromes found within the specified range.\n\n"}
{"task_id": "CPP/110", "generation": "#include <vector>\n#include <string>\nusing namespace std;\n\nstring exchange(vector<int> lst1, vector<int> lst2) {\n    int odd_count_lst1 = 0;\n    int even_count_lst2 = 0;\n\n    // Counting odd numbers in lst1 and even numbers in lst2\n    for (int num : lst1) {\n        if (num % 2 != 0) {\n            ++odd_count_lst1;\n        }\n    }\n\n    for (int num : lst2) {\n        if (num % 2 == 0) {\n            ++even_count_lst2;\n        }\n    }\n\n    // Checking if it's possible to exchange enough elements\n    if (odd_count_lst1 <= even_count_lst2) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n", "py_code": "from typing import List\n\ndef exchange(lst1: List[int], lst2: List[int]) -> str:\n    odd_count_lst1 = sum(x % 2 != 0 for x in lst1)\n    even_count_lst2 = sum(x % 2 == 0 for x in lst2)\n\n    if odd_count_lst1 <= even_count_lst2:\n        return \"YES\"\n    else:\n        return \"NO\"\n```\n\n", "py_summary": "### Second step, analyse the python code:\n\nThe Python function `exchange` takes two lists of integers (`lst1` and `lst2`) as input and determines whether it is possible to exchange elements between them so that all elements in `lst1` become even numbers.\n\nHere's a breakdown of how the function works:\n1. The function first calculates the number of odd elements in `lst1` using a generator expression inside the `sum()` function: `odd_count_lst1 = sum(x % 2 != 0 for x in lst1)`.\n2. It then counts the number of even elements in `lst2`: `even_count_lst2 = sum(x % 2 == 0 for x in lst2)`.\n3. The logic checks if it is possible to exchange enough odd numbers from `lst1` with even numbers from `lst2`. This can be done by comparing the count of odd numbers in `lst1` (`odd_count_lst1`) with the count of even numbers in `lst2` (`even_count_lst2`). If there are at least as many even numbers in `lst2` as there are odd numbers in `lst1`, it is possible to make all elements in `lst1` even by exchanging them, so the function returns \"YES\".\n4. Otherwise, if there aren't enough even numbers in `lst2` to exchange for all the odd numbers in `lst1`, the function returns \"NO\".\n\nThis approach ensures that we can determine whether it is possible to make all elements of `lst1` even by exchanging with elements from `lst2`.\n\n"}
{"task_id": "CPP/111", "generation": "#include <string>\n#include <map>\n#include <sstream>\n#include <algorithm>\nusing namespace std;\n\nmap<char, int> histogram(string test) {\n    map<char, int> counts;\n    \n    if (test.empty()) return counts; // Return empty map for empty string\n    \n    stringstream ss(test);\n    string word;\n    \n    while (ss >> word) { // Read each character from the string\n        char ch = word[0];\n        counts[ch]++;\n    }\n    \n    if (counts.empty()) return counts; // Handle case where no characters are present\n    \n    int max_count = 0;\n    for (const auto& count : counts) {\n        max_count = max(max_count, count.second);\n    }\n\n    map<char, int> result;\n    for (const auto& count : counts) {\n        if (count.second == max_count) {\n            result[count.first] = count.second;\n        }\n    }\n    \n    return result;\n}\n", "py_code": "from collections import Counter\n\ndef histogram(test):\n    if not test: \n        return {}\n    \n    # Splitting the string into individual characters and counting their occurrences.\n    counts = Counter(test.split())\n    \n    # Finding the maximum occurrence count.\n    max_count = max(counts.values(), default=0)\n    \n    # Filtering out the letters that have the maximum occurrence count.\n    result = {k: v for k, v in counts.items() if v == max_count}\n    \n    return result\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `histogram` takes a string of space-separated lowercase letters and returns a dictionary mapping each letter with the highest frequency to its count. If there are multiple letters with the same maximum frequency, it includes all such letters in the result.\n\n1. The function first checks if the input string is empty; if so, it returns an empty dictionary.\n2. It then splits the string into individual characters and uses `Counter` from the collections module to count occurrences of each character.\n3. Next, it finds the maximum occurrence count among all letters using the `max()` function on the values of the counter.\n4. Finally, it constructs a result dictionary that includes only those letters whose counts match the maximum occurrence count.\n\nThe resulting dictionary is returned as output.```\n\n"}
{"task_id": "CPP/80", "generation": "#include <string>\nusing namespace std;\n\nbool is_happy(string s) {\n    if (s.length() < 3) {\n        return false;\n    }\n    for (size_t i = 0; i <= s.length() - 3; ++i) {\n        if (s[i] == s[i+1] || s[i] == s[i+2] || s[i+1] == s[i+2]) {\n            return false;\n        }\n    }\n    return true;\n}\n", "py_code": "def is_happy(s: str) -> bool:\n    if len(s) < 3:\n        return False\n    for i in range(len(s) - 2):\n        if s[i] == s[i+1] or s[i] == s[i+2] or s[i+1] == s[i+2]:\n            return False\n    return True\n```\n\n", "py_summary": "### Second step, analyse the python code:\n```The Python function `is_happy` checks if a given string `s` is \"happy\" based on specific criteria. The function first verifies that the length of the string is at least 3 characters; if not, it immediately returns `False`. If the string has a sufficient length, the function iterates through each character in the string (except for the last two) and checks whether any three consecutive characters are identical to one another. If such a case is found, the function returns `False`, indicating that the string is not happy. If no such triplet of identical characters is found throughout the iteration, the function concludes by returning `True`, signifying that the string meets the criteria for being \"happy\".``` \n\n"}
