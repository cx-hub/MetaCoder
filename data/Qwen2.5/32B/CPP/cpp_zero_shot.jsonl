{"task_id": "CPP/0", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // For std::sort\n\nusing namespace std;\n\nbool has_close_elements(vector<float> numbers, float threshold) {\n    // Sort the vector to bring close elements next to each other.\n    sort(numbers.begin(), numbers.end());\n    \n    // Iterate through the sorted list and check for closeness\n    for (size_t i = 0; i < numbers.size() - 1; ++i) {\n        if (numbers[i + 1] - numbers[i] < threshold) {\n            return true;\n        }\n    }\n    return false;\n}\n\n// Function to test the solution with provided data points.\nvoid check_solution() {\n    cout << boolalpha; // Print boolean values as 'true' or 'false'\n    \n    vector<float> test_case_1 = {1.0, 2.0, 3.0};\n    float threshold_1 = 0.5;\n    cout << \"Test Case 1: \" << has_close_elements(test_case_1, threshold_1) << endl; // Expected output: false\n    \n    vector<float> test_case_2 = {1.0, 2.8, 3.0, 4.0, 5.0, 2.0};\n    float threshold_2 = 0.3;\n    cout << \"Test Case 2: \" << has_close_elements(test_case_2, threshold_2) << endl; // Expected output: true\n}\n\n"}
{"task_id": "CPP/1", "generation": "#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> separate_paren_groups(string paren_string) {\n    vector<string> result;\n    int balance = 0; // To keep track of open parentheses\n    string current_group; // Current group being processed\n\n    for (char c : paren_string) {\n        if (c == '(' || c == ')') { // Ignore spaces and only process parentheses\n            current_group += c; // Add the character to the current group\n            balance += (c == '(' ? 1 : -1); // Update balance based on the type of parenthesis\n\n            if (balance == 0) { // A complete group is found when balance returns to zero\n                result.push_back(current_group);\n                current_group.clear(); // Reset for the next group\n            }\n        }\n    }\n\n    return result;\n}\n\n// Example usage:\n"}
{"task_id": "CPP/2", "generation": "#include<stdio.h>\n#include<math.h>\n\nfloat truncate_number(float number){\n    int integerPart = (int)number; // Convert the float to an integer to get the integer part.\n    float decimalPart = number - integerPart; // Subtract the integer part from the original number to get the decimal part.\n    return decimalPart;\n}\n\n// Function to test the correctness of truncate_number\nvoid check() {\n    printf(\"Testing with 3.5: Expected 0.5, Got %.1f\\n\", truncate_number(3.5));\n    printf(\"Testing with 4.75: Expected 0.75, Got %.2f\\n\", truncate_number(4.75));\n}\n\n"}
{"task_id": "CPP/3", "generation": "#include <vector>\nusing namespace std;\n\nbool below_zero(vector<int> operations) {\n    int balance = 0; // Start with a zero balance\n\n    for (int op : operations) { // Iterate through each operation\n        balance += op; // Update the balance based on the current operation\n        \n        if (balance < 0) { // Check if balance falls below zero\n            return true;\n        }\n    }\n\n    return false; // If we never went below zero, return false\n}\n"}
{"task_id": "CPP/4", "generation": "#include <stdio.h>\n#include <math.h>\n#include <vector>\n#include <numeric> // For std::accumulate\n\nusing namespace std;\n\nfloat mean_absolute_deviation(vector<float> numbers) {\n    if(numbers.empty()) return 0.0f; // Handle empty vector case\n    \n    float sum = accumulate(numbers.begin(), numbers.end(), 0.0f);\n    float mean = sum / numbers.size();\n    \n    float mad_sum = 0.0f;\n    for(float num : numbers) {\n        mad_sum += fabs(num - mean); // Calculate the absolute difference and add to the sum\n    }\n    \n    return mad_sum / numbers.size(); // Average of all absolute differences\n}\n\n// Example usage:\n"}
{"task_id": "CPP/5", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvector<int> intersperse(vector<int> numbers, int delimeter) {\n    // If the input vector is empty or has only one element, return it as is.\n    if (numbers.size() <= 1) {\n        return numbers;\n    }\n\n    vector<int> result;\n    \n    // Iterate through each element in the vector\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        // Add the current number to the result vector\n        result.push_back(numbers[i]);\n        \n        // If it's not the last element, add the delimiter after it.\n        if (i != numbers.size() - 1) {\n            result.push_back(delimeter);\n        }\n    }\n\n    return result;\n}\n\n// Function to print a vector for testing purposes\nvoid printVector(const vector<int>& vec) {\n    cout << \"{\";\n    for (size_t i = 0; i < vec.size(); ++i) {\n        cout << vec[i];\n        if (i != vec.size() - 1) {\n            cout << \", \";\n        }\n    }\n    cout << \"}\" << endl;\n}\n\n"}
{"task_id": "CPP/6", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<int> parse_nested_parens(string paren_string) {\n    vector<int> depths;\n    int current_depth = 0, max_depth = 0;\n    \n    for (char c : paren_string) {\n        if (c == '(') {\n            // Increase depth when encountering an opening parenthesis\n            ++current_depth;\n            // Update the maximum depth found so far in this group\n            if (current_depth > max_depth) {\n                max_depth = current_depth;\n            }\n        } else if (c == ')') {\n            // Decrease depth when encountering a closing parenthesis\n            --current_depth;\n        } else if (c == ' ') {\n            // When we encounter a space, it means the end of one group and start of another.\n            // Add the max depth found for this group to the result vector.\n            depths.push_back(max_depth);\n            // Reset counters for the next group\n            current_depth = 0;\n            max_depth = 0;\n        }\n    }\n\n    // Handle the last group which doesn't end with a space\n    if (current_depth != 0) {\n        depths.push_back(max_depth);\n    }\n\n    return depths;\n}\n\n"}
{"task_id": "CPP/7", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<string> filter_by_substring(vector<string> strings, string substring) {\n    vector<string> filteredStrings;\n    \n    for (const auto& str : strings) {\n        // Check if the current string contains the substring\n        if (str.find(substring) != string::npos) {\n            filteredStrings.push_back(str);\n        }\n    }\n\n    return filteredStrings;\n}\n\n// Function to print a vector of strings\nvoid printVector(const vector<string>& vec) {\n    cout << \"{\";\n    for (size_t i = 0; i < vec.size(); ++i) {\n        cout << \"\\\"\" << vec[i] << \"\\\"\";\n        if (i != vec.size() - 1) cout << \", \";\n    }\n    cout << \"}\" << endl;\n}\n\n"}
{"task_id": "CPP/8", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\npair<int, int> sum_product(vector<int> numbers) {\n    // Initialize sum to 0 and product to 1.\n    int sum = 0;\n    int product = 1;\n\n    // Iterate through the vector to calculate sum and product.\n    for (int num : numbers) {\n        sum += num;       // Add each number to sum\n        product *= num;   // Multiply each number with product\n    }\n\n    return make_pair(sum, product);\n}\n\n// Function to test the correctness of the solution\nvoid check() {\n    auto result = sum_product({});\n    cout << \"(\" << result.first << \", \" << result.second << \")\" << endl;\n    \n    result = sum_product({1, 2, 3, 4});\n    cout << \"(\" << result.first << \", \" << result.second << \")\" << endl;\n}\n\n"}
{"task_id": "CPP/9", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> rolling_max(vector<int> numbers) {\n    if (numbers.empty()) return {}; // Handle empty input\n\n    vector<int> max_values;\n    int current_max = numbers[0];  // Initialize with the first element of the sequence\n    \n    for (int num : numbers) {\n        if (num > current_max) {   // Update current_max when a new maximum is found\n            current_max = num;\n        }\n        max_values.push_back(current_max); // Add current_max to the result vector\n    }\n\n    return max_values;\n}\n\n// Function to test the rolling_max function with provided data points.\nvoid check_rolling_max() {\n    vector<int> input = {1, 2, 3, 2, 3, 4, 2};\n    vector<int> expected_output = {1, 2, 3, 3, 3, 4, 4};\n    vector<int> output = rolling_max(input);\n\n    if (output == expected_output) {\n        cout << \"Test passed.\" << endl;\n    } else {\n        cout << \"Test failed.\" << endl;\n    }\n}\n\n"}
{"task_id": "CPP/10", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_palindrome(string str) {\n    // Test if given string is a palindrome \n    string s(str.rbegin(), str.rend());\n    return s == str;\n}\n\nstring make_palindrome(string str) {\n    /*\n    Find the shortest palindrome that begins with a supplied string. \n    Algorithm idea is simple: - Find the longest postfix of supplied string that is a palindrome. \n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome(\"\") \n    \"\" \n    >>> make_palindrome(\"cat\") \n    \"catac\" \n    >>> make_palindrome(\"cata\") \n    \"catac\" \n    */\n    \n    if (str.empty()) return str; // If the string is empty, return it as is.\n    \n    int n = str.length();\n    for (int i = 0; i < n; ++i) {\n        // Check if the suffix starting from position 'i' to end of the string is a palindrome\n        if (is_palindrome(str.substr(i))) {\n            // If found, append the reverse of the prefix before this palindromic part.\n            return str + string(str.rbegin(), str.rbegin() + i);\n        }\n    }\n\n    // In case no suffix is found to be a palindrome, which should not happen given our logic\n    return str;\n}\n\n"}
{"task_id": "CPP/11", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring string_xor(string a, string b) {\n    // Ensure both strings are of the same length.\n    if (a.length() != b.length()) {\n        cout << \"Error: Strings must be of equal length.\" << endl;\n        return \"\";  // Return an empty string in case of error\n    }\n\n    string result = \"\";\n    \n    for(size_t i = 0; i < a.length(); ++i) {\n        if (a[i] == b[i]) { \n            // If both characters are the same, XOR is '0'\n            result += \"0\";\n        } else {\n            // If they differ, XOR is '1'\n            result += \"1\";\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/12", "generation": "#include <vector>\n#include <string>\nusing namespace std;\n\nstring longest(vector<string> strings) {\n    if (strings.empty()) return \"\"; // Return an empty string to represent None in C++\n\n    string longestString = strings[0]; // Initialize with the first element\n\n    for (const auto& str : strings) {\n        if (str.length() > longestString.length()) {\n            longestString = str;\n        }\n    }\n\n    return longestString;\n}\n"}
{"task_id": "CPP/13", "generation": "#include<stdio.h>\n\nint greatest_common_divisor(int a, int b){\n    while(b != 0){\n        int temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n\n// Function to test the GCD function with given data points.\nvoid check_gcd(){\n    printf(\"GCD of 3 and 5 is: %d\\n\", greatest_common_divisor(3, 5)); // Expected output: 1\n    printf(\"GCD of 25 and 15 is: %d\\n\", greatest_common_divisor(25, 15)); // Expected output: 5\n}\n\n"}
{"task_id": "CPP/14", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> all_prefixes(string str) {\n    vector<string> prefixes;\n    for (size_t i = 1; i <= str.size(); ++i) {\n        // Create a substring from the start of the string up to position `i`\n        prefixes.push_back(str.substr(0, i));\n    }\n    return prefixes;\n}\n\n// Example usage\n"}
{"task_id": "CPP/15", "generation": "#include <iostream> // For input and output operations.\n#include <string>   // To work with strings.\n\nusing namespace std;\n\nstring string_sequence(int n) {\n    string result = \"\";  // Initialize an empty string to store the sequence.\n    \n    for (int i = 0; i <= n; ++i) {  // Loop from 0 to n inclusive.\n        if (i > 0) {  // Add a space before each number except the first one.\n            result += \" \";\n        }\n        result += to_string(i);  // Convert integer to string and append it to 'result'.\n    }\n\n    return result;  // Return the final sequence as a string.\n}\n\n// Example usage:\n"}
{"task_id": "CPP/16", "generation": "#include <iostream>\n#include <string>\n#include <set>\nusing namespace std;\n\nint count_distinct_characters(string str) {\n    // Convert the string to lower case to ignore case differences.\n    transform(str.begin(), str.end(), str.begin(), ::tolower);\n    \n    // Use a set to store unique characters.\n    set<char> charSet;\n    \n    // Insert each character into the set.\n    for (char c : str) {\n        charSet.insert(c);\n    }\n    \n    // The size of the set is the number of distinct characters.\n    return charSet.size();\n}\n\n"}
{"task_id": "CPP/17", "generation": "#include <vector>\n#include <string>\nusing namespace std;\n\nvector<int> parse_music(string music_string) {\n    vector<int> beats;\n    for (size_t i = 0; i < music_string.length(); ++i) {\n        if (music_string[i] == 'o') { // Check for whole note\n            if (i + 1 < music_string.length() && music_string[i+1] == '|') {\n                beats.push_back(2); // Half note\n                i++; // Skip the next character as it's part of the half note\n            } else {\n                beats.push_back(4); // Whole note\n            }\n        } else if (music_string[i] == '.') { // Check for quarter note\n            if (i + 1 < music_string.length() && music_string[i+1] == '|') {\n                beats.push_back(1); // Quarter note\n                i++; // Skip the next character as it's part of the quarter note\n            }\n        }\n    }\n    return beats;\n}\n\n// Example usage:\n"}
{"task_id": "CPP/18", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint how_many_times(string str, string substring) {\n    int count = 0;\n    // Length of the main string and the substring\n    size_t len_str = str.length(), len_sub = substring.length();\n    \n    // Iterate through the string to find occurrences of the substring\n    for (size_t i = 0; i <= len_str - len_sub; ++i) {\n        if (str.substr(i, len_sub) == substring)\n            count++;\n    }\n    \n    return count;\n}\n\n"}
{"task_id": "CPP/19", "generation": "#include <iostream>\n#include <string>\n#include <vector>\n#include <map>\n#include <sstream>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to sort the numbers represented as words from \"zero\" to \"nine\"\nstring sort_numbers(string numbers) {\n    // Mapping of number words to their numeric values\n    map<string, int> word_to_num = {\n        {\"zero\", 0}, {\"one\", 1}, {\"two\", 2}, {\"three\", 3},\n        {\"four\", 4}, {\"five\", 5}, {\"six\", 6}, {\"seven\", 7},\n        {\"eight\", 8}, {\"nine\", 9}\n    };\n\n    // Mapping of numeric values back to number words\n    map<int, string> num_to_word;\n    for (const auto &pair : word_to_num) {\n        num_to_word[pair.second] = pair.first;\n    }\n\n    // Split the input string into individual words\n    vector<string> words;\n    stringstream ss(numbers);\n    string token;\n    while (getline(ss, token, ' ')) {\n        if (!token.empty()) {  // Ensure no empty strings are added to the list\n            words.push_back(token);\n        }\n    }\n\n    // Sort the words based on their numeric values\n    sort(words.begin(), words.end(),\n         [&word_to_num](const string &a, const string &b) {\n             return word_to_num[a] < word_to_num[b];\n         });\n\n    // Convert back to a space-delimited string of sorted number words\n    stringstream result;\n    for (size_t i = 0; i < words.size(); ++i) {\n        if (i > 0) {\n            result << \" \";\n        }\n        result << num_to_word[word_to_num[words[i]]];\n    }\n\n    return result.str();\n}\n\n"}
{"task_id": "CPP/20", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // for std::sort\n\nusing namespace std;\n\npair<float, float> find_closest_elements(vector<float> numbers) {\n    // Sort the vector to make it easier to find adjacent pairs.\n    sort(numbers.begin(), numbers.end());\n\n    float min_diff = numeric_limits<float>::max();\n    pair<float, float> closest_pair;\n    \n    // Iterate through the sorted list and find the minimum difference between consecutive elements\n    for (size_t i = 0; i < numbers.size() - 1; ++i) {\n        float diff = numbers[i + 1] - numbers[i];\n        if (diff < min_diff) {\n            min_diff = diff;\n            closest_pair = {numbers[i], numbers[i + 1]};\n        }\n    }\n\n    return closest_pair;\n}\n\n// Function to test the solution\nvoid check() {\n    auto result = find_closest_elements({1.0, 2.0, 3.0, 4.0, 5.0, 2.2});\n    cout << \"(\" << result.first << \", \" << result.second << \")\" << endl; // Expected: (2.0, 2.2)\n    \n    result = find_closest_elements({1.0, 2.0, 3.0, 4.0, 5.0, 2.0});\n    cout << \"(\" << result.first << \", \" << result.second << \")\" << endl; // Expected: (2.0, 2.0)\n}\n\n"}
{"task_id": "CPP/21", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // For std::min_element and std::max_element\n\nusing namespace std;\n\nvector<float> rescale_to_unit(vector<float> numbers) {\n    float min_val = *min_element(numbers.begin(), numbers.end());\n    float max_val = *max_element(numbers.begin(), numbers.end());\n\n    vector<float> scaled_numbers;\n    for (float num : numbers) {\n        // Apply the linear transformation\n        float scaled_num = (num - min_val) / (max_val - min_val);\n        scaled_numbers.push_back(scaled_num);\n    }\n\n    return scaled_numbers;\n}\n\n"}
{"task_id": "CPP/22", "generation": "#include <iostream>\n#include <vector>\n#include <list>\n#include <boost/any.hpp>\n\ntypedef std::list<boost::any> list_any;\n\nstd::vector<int> filter_integers(list_any values) {\n    std::vector<int> integers;\n    \n    for (const auto& value : values) {\n        if (value.type() == typeid(int)) { // Check if the type is int\n            integers.push_back(boost::any_cast<int>(value)); // Cast and add to vector\n        }\n    }\n\n    return integers;\n}\n\n"}
{"task_id": "CPP/23", "generation": "#include <iostream>\n#include <string>\n\nint stringLength(const std::string& str) {\n    return str.length();\n}\n\n"}
{"task_id": "CPP/24", "generation": "#include<stdio.h>\n\nint largest_divisor(int n) {\n    // Start checking from n/2 and go downwards to find the largest divisor.\n    for (int i = n / 2; i >= 1; --i) {\n        if (n % i == 0) {\n            return i;\n        }\n    }\n    // If no divisor is found, which theoretically shouldn't happen for any n > 1\n    return -1;\n}\n\n"}
{"task_id": "CPP/25", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvector<int> factorize(int n) {\n    vector<int> factors;\n    \n    // Divide by 2 to get rid of all even factors\n    while (n % 2 == 0) {\n        factors.push_back(2);\n        n /= 2;\n    }\n    \n    // Now we only have odd factors left, so we can skip even numbers in the loop\n    for (int i = 3; i * i <= n; i += 2) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n\n    // If n is a prime number greater than 2, it will remain after the above loop\n    if (n > 2) {\n        factors.push_back(n);\n    }\n\n    return factors;\n}\n\n// Function to test the factorize function with given examples\nvoid check() {\n    vector<int> result;\n\n    // Test case 1: factorize(8)\n    result = factorize(8);\n    cout << \"factorize(8): \";\n    for (int f : result) cout << f << \" \";\n    cout << endl;\n\n    // Test case 2: factorize(25)\n    result = factorize(25);\n    cout << \"factorize(25): \";\n    for (int f : result) cout << f << \" \";\n    cout << endl;\n\n    // Test case 3: factorize(70)\n    result = factorize(70);\n    cout << \"factorize(70): \";\n    for (int f : result) cout << f << \" \";\n    cout << endl;\n}\n\n// Main function to run the check\n"}
{"task_id": "CPP/26", "generation": "#include <iostream>\n#include <vector>\n#include <unordered_map> // For keeping track of element counts\n\nusing namespace std;\n\nvector<int> remove_duplicates(vector<int> numbers){\n    unordered_map<int, int> countMap; // To keep track of occurrences of each number\n    vector<int> result;               // Resultant vector with duplicates removed\n    \n    for (int num : numbers) {\n        if(countMap[num] == 0) {      // If the element has not been seen before\n            result.push_back(num);    // Add it to the result\n        }\n        countMap[num]++;              // Increment its count in the map\n    }\n\n    return result;\n}\n\n// Function to print vector elements for testing purposes\nvoid printVector(const vector<int>& vec) {\n    for (int num : vec) {\n        cout << num << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/27", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring flip_case(string str) {\n    for (size_t i = 0; i < str.length(); ++i) {\n        if (isupper(str[i])) {\n            // Convert uppercase to lowercase\n            str[i] = tolower(str[i]);\n        } else if (islower(str[i])) {\n            // Convert lowercase to uppercase\n            str[i] = toupper(str[i]);\n        }\n    }\n    return str;\n}\n\n"}
{"task_id": "CPP/28", "generation": "#include <vector>\n#include <string>\n#include <iostream>\n\nusing namespace std;\n\nstring concatenate(vector<string> strings) {\n    // Initialize an empty string to hold the concatenated result.\n    string result = \"\";\n    \n    // Iterate through each element in the vector and append it to the result string.\n    for (const auto& str : strings) {\n        result += str;\n    }\n    \n    return result;\n}\n\n// Function to test the concatenate function\nvoid test_concatenate() {\n    cout << \"Testing with empty vector: \\\"\" << concatenate({}) << \"\\\" (Expected: \\\"\\\")\" << endl;\n    cout << \"Testing with {\\\"a\\\", \\\"b\\\", \\\"c\\\"}: \\\"\" << concatenate({\"a\", \"b\", \"c\"}) << \"\\\" (Expected: \\\"abc\\\")\" << endl;\n}\n\n"}
{"task_id": "CPP/29", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> filter_by_prefix(vector<string> strings, string prefix) {\n    vector<string> filteredStrings;\n    \n    // Iterate through each string in the input vector.\n    for (const auto& str : strings) {\n        // Check if the current string starts with the given prefix.\n        if (str.find(prefix) == 0) { // find returns 0 if prefix is at the start\n            filteredStrings.push_back(str);\n        }\n    }\n\n    return filteredStrings;\n}\n\n// Function to test the filter_by_prefix function.\nvoid check() {\n    vector<string> test1 = {\"abc\", \"bcd\", \"cde\", \"vector\"};\n    string prefix1 = \"a\";\n    auto result1 = filter_by_prefix(test1, prefix1);\n    cout << \"Filtered strings: \";\n    for (const auto& str : result1) {\n        cout << str << \" \";\n    }\n    cout << endl;\n\n    vector<string> test2 = {};\n    string prefix2 = \"a\";\n    auto result2 = filter_by_prefix(test2, prefix2);\n    cout << \"Filtered strings: \";\n    if(result2.empty()) {\n        cout << \"{}\" << endl;\n    } else {\n        for (const auto& str : result2) {\n            cout << str << \" \";\n        }\n        cout << endl;\n    }\n}\n\n"}
{"task_id": "CPP/30", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvector<float> get_positive(vector<float> l) {\n    vector<float> result; // Initialize an empty vector for storing positive numbers\n    \n    // Iterate through each element in the input vector\n    for (float num : l) {\n        if (num > 0) { // Check if the number is positive\n            result.push_back(num); // Add it to the result vector\n        }\n    }\n    \n    return result; // Return the vector containing only positive numbers\n}\n\n// Function to print a vector of floats for demonstration purposes\nvoid print_vector(const vector<float>& v) {\n    cout << \"{\";\n    for (size_t i = 0; i < v.size(); ++i) {\n        if (i != 0) cout << \", \";\n        cout << v[i];\n    }\n    cout << \"}\" << endl;\n}\n\n"}
{"task_id": "CPP/31", "generation": "#include <iostream>\n#include <cmath> // For sqrt() function\n\nbool is_prime(long long n) {\n    if (n <= 1) return false; // 0 and 1 are not prime numbers\n    if (n == 2 || n == 3) return true; // 2 and 3 are prime numbers\n    \n    // Check for divisibility by 2 or 3\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    \n    // Only check up to the square root of n, checking only odd numbers\n    for(long long i = 5; i * i <= n; i += 6) {\n        if(n % i == 0 || n % (i + 2) == 0)\n            return false;\n    }\n    \n    return true;\n}\n\n"}
{"task_id": "CPP/32", "generation": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\ndouble poly(vector<double> xs, double x) {\n    /* \n    Evaluates polynomial with coefficients xs at point x. return xs[0] + xs[1] * x + xs[2] * x^2 + .... xs[n] * x^n \n    */\n    double sum = 0;\n    for (int i = 0; i < xs.size(); ++i) {\n        sum += xs[i] * pow(x, i);\n    }\n    return sum;\n}\n\ndouble find_zero(vector<double> xs) {\n    /*\n    xs are coefficients of a polynomial. find_zero finds x such that poly(x) = 0.\n    find_zero returns only one zero point, even if there are many.\n    Moreover, find_zero only takes list xs having an even number of coefficients and the largest non-zero coefficient as it guarantees a solution.\n    */\n    \n    // Initial interval for bisection method\n    double a = -100.0;  // Start with a large negative value\n    double b = 100.0;   // End with a large positive value\n    \n    // Evaluate the polynomial at the boundaries of the initial interval\n    double fa = poly(xs, a);\n    double fb = poly(xs, b);\n\n    // If both are non-negative or non-positive, adjust the interval to ensure opposite signs\n    while (fa * fb > 0) {\n        if (fabs(fa) < fabs(fb)) {\n            a *= 2;\n            fa = poly(xs, a);\n        } else {\n            b *= 2;\n            fb = poly(xs, b);\n        }\n    }\n\n    // Bisection method\n    double tol = 1e-6;  // Tolerance level for the root approximation\n    while (fabs(b - a) > tol) {\n        double c = (a + b) / 2.0;\n        double fc = poly(xs, c);\n\n        if (fc == 0 || fabs(b - a) < tol)\n            return c;\n\n        if (fa * fc < 0) {\n            b = c;\n            fb = fc;\n        } else {\n            a = c;\n            fa = fc;\n        }\n    }\n\n    // Return the midpoint of the final interval\n    return (a + b) / 2.0;\n}\n\n"}
{"task_id": "CPP/33", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm> // For std::sort\n\nusing namespace std;\n\nvector<int> sort_third(vector<int> l) {\n    vector<int> to_sort;\n    \n    // Extract elements at indices divisible by three (0-based index)\n    for(size_t i = 2; i < l.size(); i += 3) { \n        to_sort.push_back(l[i]);\n    }\n    \n    // Sort the extracted elements\n    sort(to_sort.begin(), to_sort.end());\n    \n    // Replace original values with sorted ones\n    size_t j = 0;\n    for(size_t i = 2; i < l.size() && j < to_sort.size(); i += 3) {\n        l[i] = to_sort[j++];\n    }\n    \n    return l;\n}\n\n// Function to print vector elements (for testing purposes)\nvoid print_vector(const vector<int>& v) {\n    for(int num : v) {\n        printf(\"%d \", num);\n    }\n    printf(\"\\n\");\n}\n\n"}
{"task_id": "CPP/34", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // for std::sort and std::unique\n\nusing namespace std;\n\nvector<int> unique(vector<int> l) {\n    // First, sort the vector so that duplicate elements are adjacent.\n    sort(l.begin(), l.end());\n    \n    // Use std::unique to remove consecutive duplicates. It returns a past-the-end iterator\n    // for the new range of unique elements in the sorted vector.\n    auto last = unique(l.begin(), l.end());\n    \n    // Erase the non-unique part of the vector.\n    l.erase(last, l.end());\n    \n    return l;\n}\n\n// Example usage:\n"}
{"task_id": "CPP/35", "generation": "#include <vector>\n#include <algorithm> // For std::max\nusing namespace std;\n\nfloat max_element(vector<float> l) {\n    if (l.empty()) {  // Check if the vector is empty to avoid undefined behavior.\n        throw runtime_error(\"The vector is empty\"); // Throw an exception for empty vectors.\n    }\n\n    float max_val = l[0];  // Initialize max_val with the first element of the vector.\n\n    for (size_t i = 1; i < l.size(); ++i) {  // Start from the second element and iterate through the rest.\n        if (l[i] > max_val) {\n            max_val = l[i];  // Update max_val if a larger value is found.\n        }\n    }\n\n    return max_val;\n}\n\n// Example usage:\n/*\n"}
{"task_id": "CPP/36", "generation": "#include <iostream>\nusing namespace std;\n\nint fizz_buzz(int n) {\n    int count = 0;\n    \n    for (int i = 1; i < n; ++i) {\n        if ((i % 11 == 0 || i % 13 == 0)) { // Check divisibility by 11 or 13\n            int temp = i;\n            while (temp > 0) {\n                if (temp % 10 == 7) count++; // Count digit '7'\n                temp /= 10; // Move to the next digit\n            }\n        }\n    }\n\n    return count;\n}\n\n"}
{"task_id": "CPP/37", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // for std::sort\n\nusing namespace std;\n\nvector<float> sort_even(vector<float> l) {\n    if (l.size() <= 1) return l; // If the vector is too small, just return it as-is.\n\n    vector<float> even_elements;\n    \n    // Extract elements at even indices.\n    for(size_t i = 0; i < l.size(); i += 2) {\n        even_elements.push_back(l[i]);\n    }\n\n    // Sort the extracted elements.\n    sort(even_elements.begin(), even_elements.end());\n\n    // Place sorted elements back into their original positions.\n    for(size_t i = 0, j = 0; i < l.size() && j < even_elements.size(); i += 2, ++j) {\n        l[i] = even_elements[j];\n    }\n\n    return l;\n}\n\n// Function to test the sort_even function with given examples\nvoid check_function() {\n    vector<float> result;\n\n    // Test case 1\n    result = sort_even({1, 2, 3});\n    for (float num : result) cout << num << \" \";\n    cout << endl; // Expected output: 1 2 3\n\n    // Test case 2\n    result = sort_even({5, 6, 3, 4});\n    for (float num : result) cout << num << \" \";\n    cout << endl; // Expected output: 3 6 5 4\n}\n\n"}
{"task_id": "CPP/38", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\n// Function to encode a string by cycling groups of three characters.\nstring encode_cyclic(string s) { \n    // split string into groups. Each of length 3.\n    int l = s.length();\n    int num = (l + 2) / 3;\n    string x, output;\n    for (int i = 0; i * 3 < l; i++) {\n        // cycle elements in each group unless the group has fewer than 3 characters\n        x = s.substr(i * 3, 3);\n        if (x.length() == 3) x = x.substr(1) + x[0];\n        output += x;\n    }\n    return output;\n}\n\n// Function to decode a string encoded with encode_cyclic function.\nstring decode_cyclic(string s) { \n    // split string into groups. Each of length 3.\n    int l = s.length();\n    string x, output;\n    for (int i = 0; i * 3 < l; i++) {\n        // cycle elements in each group unless the group has fewer than 3 characters\n        x = s.substr(i * 3, 3);\n        if (x.length() == 3) x = x.back() + x.substr(0, 2); // Move last character to front.\n        output += x;\n    }\n    return output;\n}\n\n"}
{"task_id": "CPP/39", "generation": "#include <iostream>\nusing namespace std;\n\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    for (int i = 2; i * i <= num; ++i) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\nint prime_fib(int n) {\n    int count = 0, fib1 = 0, fib2 = 1, fib3 = 1;\n\n    while (true) {\n        // Generate next Fibonacci number\n        fib3 = fib1 + fib2;\n        fib1 = fib2;\n        fib2 = fib3;\n\n        if (is_prime(fib3)) {\n            count++;\n            if (count == n)\n                return fib3;\n        }\n    }\n\n    return -1;  // This line should never be reached\n}\n\n"}
{"task_id": "CPP/40", "generation": "#include <vector>\n#include <algorithm> // For std::sort\n\nbool triples_sum_to_zero(std::vector<int> l) {\n    if (l.size() < 3) return false; // Early exit for vectors with less than 3 elements\n    \n    std::sort(l.begin(), l.end()); // Sort the vector to apply two-pointer technique\n    \n    for (size_t i = 0; i < l.size() - 2; ++i) { // Iterate through each element\n        int left = i + 1, right = l.size() - 1;\n        \n        while (left < right) {\n            int sum = l[i] + l[left] + l[right];\n            \n            if (sum == 0) return true; // Found a triplet that sums to zero\n            \n            if (sum < 0) ++left; // Move left pointer to the right\n            else --right;        // Move right pointer to the left\n        }\n    }\n    \n    return false; // No such triplet found\n}\n"}
{"task_id": "CPP/41", "generation": "#include<iostream>\nusing namespace std;\n\nint car_race_collision(int n) {\n    // Since each car moving left-to-right collides exactly once with a car moving right-to-left,\n    // the total number of collisions is simply equal to the number of cars in one direction.\n    return n;\n}\n\n"}
{"task_id": "CPP/42", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvector<int> incr_list(vector<int> l) {\n    for (size_t i = 0; i < l.size(); ++i) {\n        l[i] += 1;\n    }\n    return l;\n}\n\n// Function to test the correctness of incr_list\nvoid check() {\n    vector<int> test1 = {1, 2, 3};\n    vector<int> expected1 = {2, 3, 4};\n    assert(incr_list(test1) == expected1);\n\n    vector<int> test2 = {5, 3, 5, 2, 3, 3, 9, 0, 123};\n    vector<int> expected2 = {6, 4, 6, 3, 4, 4, 10, 1, 124};\n    assert(incr_list(test2) == expected2);\n\n    cout << \"All tests passed successfully.\" << endl;\n}\n\n"}
{"task_id": "CPP/43", "generation": "#include <iostream>\n#include <vector>\n#include <unordered_set> // For using std::unordered_set\n\nusing namespace std;\n\nbool pairs_sum_to_zero(vector<int> l) {\n    unordered_set<int> seen; // To store the elements we've seen so far\n    \n    for (int num : l) {\n        if (seen.find(-num) != seen.end()) { // Check if the complement exists\n            return true;\n        }\n        seen.insert(num); // Add current number to the set\n    }\n\n    return false; // No pairs found that sum to zero\n}\n\n// Function to test the implementation with given examples\nvoid check() {\n    cout << boolalpha; // Print boolean values as 'true' or 'false'\n    cout << \"Test 1: \" << pairs_sum_to_zero({1, 3, 5, 0}) << endl;\n    cout << \"Test 2: \" << pairs_sum_to_zero({1, 3, -2, 1}) << endl;\n    cout << \"Test 3: \" << pairs_sum_to_zero({1, 2, 3, 7}) << endl;\n    cout << \"Test 4: \" << pairs_sum_to_zero({2, 4, -5, 3, 5, 7}) << endl;\n    cout << \"Test 5: \" << pairs_sum_to_zero({1}) << endl;\n}\n\n"}
{"task_id": "CPP/44", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring change_base(int x, int base) {\n    if(base <= 1 || base >= 10) return \"Invalid base\"; // Ensure the base is valid as per problem statement.\n    \n    string result = \"\";\n    while (x > 0) {\n        int remainder = x % base;\n        result = to_string(remainder) + result; // Prepend the remainder to the result\n        x /= base;\n    }\n    return result.empty() ? \"0\" : result; // Handle case where x is 0 initially.\n}\n\n"}
{"task_id": "CPP/45", "generation": "#include <iostream> // Use iostream for input/output operations\n\nfloat triangle_area(float a, float h) {\n    return 0.5 * a * h; // Area formula: (base * height) / 2\n}\n\n"}
{"task_id": "CPP/46", "generation": "#include <iostream>\nusing namespace std;\n\nint fib4(int n) {\n    // Base cases for the first 4 elements.\n    if (n == 0 || n == 1) return 0;\n    if (n == 2) return 2;\n    if (n == 3) return 0;\n\n    // Initialize variables to hold the last four numbers of the sequence\n    int a = 0, b = 0, c = 2, d = 0; // fib4(0), fib4(1), fib4(2), fib4(3)\n    \n    for (int i = 4; i <= n; ++i) {\n        int next = a + b + c + d;\n        a = b;\n        b = c;\n        c = d;\n        d = next;\n    }\n\n    return d; // The last computed value is the nth element\n}\n\n// Function to test the fib4 function with given data points.\nvoid check() {\n    cout << \"fib4(5) -> Expected: 4, Actual: \" << fib4(5) << endl;\n    cout << \"fib4(6) -> Expected: 8, Actual: \" << fib4(6) << endl;\n    cout << \"fib4(7) -> Expected: 14, Actual: \" << fib4(7) << endl;\n}\n\n"}
{"task_id": "CPP/47", "generation": "#include <stdio.h>\n#include <math.h>\n#include <vector>\n#include <algorithm> // For std::sort\n\nusing namespace std;\n\nfloat median(vector<float> l) {\n    size_t n = l.size();\n    \n    if (n == 0) return NAN; // Return NaN for empty vector\n    \n    sort(l.begin(), l.end()); // Sort the vector\n    \n    if (n % 2 == 1) { // If odd number of elements\n        return l[n / 2]; // Median is the middle element\n    } else { // If even number of elements\n        float mid1 = l[(n - 1) / 2];\n        float mid2 = l[n / 2];\n        return (mid1 + mid2) / 2; // Average of two middle elements\n    }\n}\n\n// Example usage:\n"}
{"task_id": "CPP/48", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_palindrome(string text) {\n    int left = 0;\n    int right = text.length() - 1;\n    \n    while (left < right) {\n        if (text[left] != text[right]) {\n            return false; // Characters do not match\n        }\n        left++;\n        right--;\n    }\n    return true; // All characters matched, it's a palindrome\n}\n\n// Function to test the is_palindrome function with given examples\nvoid check() {\n    cout << boolalpha; // Print 'true' or 'false' instead of 1 or 0\n    cout << \"is_palindrome(\"\"): \" << is_palindrome(\"\") << endl;\n    cout << \"is_palindrome(aba): \" << is_palindrome(\"aba\") << endl;\n    cout << \"is_palindrome(aaaaa): \" << is_palindrome(\"aaaaa\") << endl;\n    cout << \"is_palindrome(zbcd): \" << is_palindrome(\"zbcd\") << endl;\n}\n\n"}
{"task_id": "CPP/49", "generation": "#include<stdio.h>\n\nint modp(int n, int p) {\n    long long result = 1; // Use long long to avoid overflow during calculations\n    long long base = 2;\n\n    while (n > 0) {\n        if (n % 2 == 1) { // If n is odd, multiply the result by the current base value\n            result = (result * base) % p;\n        }\n        base = (base * base) % p; // Square the base for the next iteration\n        n /= 2; // Halve n to move towards the end of the loop\n    }\n\n    return (int)result;\n}\n\n// Function to test the modp function with given data points.\nvoid check() {\n    printf(\"modp(3, 5) = %d\\n\", modp(3, 5)); // Expected output: 3\n    printf(\"modp(1101, 101) = %d\\n\", modp(1101, 101)); // Expected output: 2\n    printf(\"modp(0, 101) = %d\\n\", modp(0, 101)); // Expected output: 1\n    printf(\"modp(3, 11) = %d\\n\", modp(3, 11)); // Expected output: 8\n    printf(\"modp(100, 101) = %d\\n\", modp(100, 101)); // Expected output: 1\n}\n\n"}
{"task_id": "CPP/50", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\n// Function to encode a string by shifting every character by 5 in the alphabet.\nstring encode_shift(string s) {\n    string out;\n    for (int i = 0; i < s.length(); i++) {\n        int w = ((s[i] - 'a' + 26 - 5) % 26) + 'a'; // Adjusting to handle negative shifts\n        out += char(w);\n    }\n    return out;\n}\n\n// Function to decode a string that was encoded with the encode_shift function.\nstring decode_shift(string s) {\n    string out;\n    for (int i = 0; i < s.length(); i++) {\n        int w = ((s[i] - 'a' + 26 - 5) % 26) + 'a'; // Adjusting to handle negative shifts\n        out += char(w);\n    }\n    return out;\n}\n\n// Example usage:\n"}
{"task_id": "CPP/51", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nbool isVowel(char c) {\n    // Convert to lowercase for simplicity and check if the character is a vowel.\n    char lower_c = tolower(c);\n    return (lower_c == 'a' || lower_c == 'e' || lower_c == 'i' || lower_c == 'o' || lower_c == 'u');\n}\n\nstring remove_vowels(string text) {\n    string result;\n    for(char c : text) {\n        if(!isVowel(c)) { // If the character is not a vowel, add it to the result.\n            result += c;\n        }\n    }\n    return result;\n}\n\n"}
{"task_id": "CPP/52", "generation": "#include <vector>\nusing namespace std;\n\nbool below_threshold(vector<int> l, int t) {\n    // Iterate through each element in the vector\n    for (int num : l) {\n        // If any number is greater than or equal to the threshold, return false\n        if (num >= t) {\n            return false;\n        }\n    }\n    // If all numbers are below the threshold, return true\n    return true;\n}\n\n// Example usage:\n/*\nbool result1 = below_threshold({1, 2, 4, 10}, 100); // Should be true\nbool result2 = below_threshold({1, 20, 4, 10}, 5);   // Should be false\n*/\n"}
{"task_id": "CPP/53", "generation": "#include <stdio.h>\n\nint add(int x, int y) {\n    return x + y;\n}\n\n"}
{"task_id": "CPP/54", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nbool same_chars(string s0, string s1) {\n    // Sort both strings to bring identical characters together.\n    sort(s0.begin(), s0.end());\n    sort(s1.begin(), s1.end());\n\n    // Remove duplicate characters from each sorted string.\n    auto last_unique_s0 = unique(s0.begin(), s0.end());\n    auto last_unique_s1 = unique(s1.begin(), s1.end());\n\n    // Erase the duplicates in place, so we only keep one instance of each character.\n    s0.erase(last_unique_s0, s0.end());\n    s1.erase(last_unique_s1, s1.end());\n\n    // Compare the two strings to check if they have the same set of characters.\n    return s0 == s1;\n}\n\n"}
{"task_id": "CPP/55", "generation": "#include<stdio.h>\n\nint fib(int n){\n    if (n <= 0) {\n        return 0;\n    }\n    else if(n == 1 || n == 2){\n        return 1;\n    }\n\n    int a = 1, b = 1, c;\n    for(int i = 3; i <= n; ++i){\n        c = a + b;\n        a = b;\n        b = c;\n    }\n    return b;\n}\n\n"}
{"task_id": "CPP/56", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    int balance = 0; // This will help us keep track of the number of unmatched '<'s\n\n    for (char c : brackets) { \n        if (c == '<') {\n            ++balance;\n        } else if (c == '>') {\n            --balance;\n            if (balance < 0) return false; // If balance is negative, it means there's a '>' without a matching '<'\n        }\n    }\n\n    return balance == 0; // All brackets are correctly matched if balance is zero\n}\n\n"}
{"task_id": "CPP/57", "generation": "#include <vector>\nusing namespace std;\n\nbool monotonic(vector<float> l) {\n    // Check for empty vector or single-element vector, which are trivially monotonic.\n    if (l.size() <= 1) return true;\n    \n    bool increasing = false; // Flag to check if the sequence is monotonically increasing\n    bool decreasing = false; // Flag to check if the sequence is monotonically decreasing\n    \n    for(size_t i = 1; i < l.size(); ++i) {\n        if (l[i] > l[i-1]) {\n            // If we find an element greater than its predecessor, it must be increasing.\n            increasing = true;\n        } else if (l[i] < l[i-1]) {\n            // If we find an element less than its predecessor, it must be decreasing.\n            decreasing = true;\n        }\n        \n        // If both flags are set to true at any point, the sequence is neither strictly increasing nor decreasing.\n        if (increasing && decreasing) return false;\n    }\n\n    // The sequence can be either monotonically increasing or decreasing\n    return true;\n}\n"}
{"task_id": "CPP/58", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\n\nusing namespace std;\n\nvector<int> common(vector<int> l1, vector<int> l2) {\n    // Sort the input vectors.\n    sort(l1.begin(), l1.end());\n    sort(l2.begin(), l2.end());\n\n    // Use a set to store unique common elements.\n    set<int> commonElements;\n    \n    auto it1 = l1.begin();\n    auto it2 = l2.begin();\n\n    // Iterate through both vectors to find common elements.\n    while (it1 != l1.end() && it2 != l2.end()) {\n        if (*it1 == *it2) {\n            commonElements.insert(*it1);\n            ++it1;\n            ++it2;\n        } else if (*it1 < *it2) {\n            ++it1;\n        } else {\n            ++it2;\n        }\n    }\n\n    // Convert the set to a vector and return.\n    return vector<int>(commonElements.begin(), commonElements.end());\n}\n\n// Function to print the elements of a vector\nvoid printVector(const vector<int>& vec) {\n    for (int num : vec) {\n        cout << num << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/59", "generation": "#include <iostream>\n#include <cmath>\n\nint largest_prime_factor(int n) {\n    int maxPrime = -1;\n    \n    // Divide n by 2 to remove all even factors\n    while (n % 2 == 0) {\n        maxPrime = 2;\n        n /= 2;\n    }\n    \n    // Now we only have odd factors left, so we can skip even numbers\n    for (int i = 3; i <= sqrt(n); i += 2) {\n        while (n % i == 0) {\n            maxPrime = i;\n            n = n / i;\n        }\n    }\n\n    // If n is a prime number greater than 2, then it's the largest prime factor\n    if (n > 2)\n        maxPrime = n;\n\n    return maxPrime;\n}\n\n"}
{"task_id": "CPP/60", "generation": "#include<stdio.h>\n\nint sum_to_n(int n){\n    int sum = 0;\n    for(int i = 1; i <= n; i++){\n        sum += i;\n    }\n    return sum;\n}\n\n// Function to test the correctness of sum_to_n.\nvoid check_function(){\n    printf(\"sum_to_n(30) should be 465: %d\\n\", sum_to_n(30));\n    printf(\"sum_to_n(100) should be 5050: %d\\n\", sum_to_n(100));\n    printf(\"sum_to_n(5) should be 15: %d\\n\", sum_to_n(5));\n    printf(\"sum_to_n(10) should be 55: %d\\n\", sum_to_n(10));\n    printf(\"sum_to_n(1) should be 1: %d\\n\", sum_to_n(1));\n}\n\n"}
{"task_id": "CPP/61", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    int balance = 0; // Initialize a counter for open brackets\n\n    for (char c : brackets) { // Iterate through each character in the string\n        if (c == '(') {\n            ++balance; // Increment count for an opening bracket\n        } else if (c == ')') {\n            --balance; // Decrement count for a closing bracket\n            if (balance < 0) return false; // If balance goes negative, brackets are not balanced\n        }\n    }\n\n    return balance == 0; // Return true only if all open brackets have been closed\n}\n\n"}
{"task_id": "CPP/62", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvector<float> derivative(vector<float> xs) {\n    vector<float> result;\n    \n    // Iterate through each coefficient except the first one (constant term)\n    for(size_t i = 1; i < xs.size(); ++i) {\n        // Multiply by its power and add to the result\n        result.push_back(xs[i] * i);\n    }\n    \n    return result;\n}\n\n// Function to print vector for testing purposes\nvoid printVector(const vector<float>& v) {\n    cout << \"{\";\n    for(size_t i = 0; i < v.size(); ++i) {\n        if(i > 0) cout << \", \";\n        cout << v[i];\n    }\n    cout << \"}\" << endl;\n}\n\n"}
{"task_id": "CPP/63", "generation": "#include <vector>\nusing namespace std;\n\nint fibfib(int n) {\n    // Base cases\n    if (n == 0 || n == 1) return 0;\n    if (n == 2) return 1;\n\n    // Initialize a vector to store the computed values of FibFib sequence.\n    vector<int> dp(n + 1, 0);\n    \n    // Set base cases\n    dp[0] = 0;\n    dp[1] = 0;\n    dp[2] = 1;\n\n    // Compute each value from 3 to n using the recurrence relation\n    for (int i = 3; i <= n; ++i) {\n        dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3];\n    }\n\n    return dp[n];\n}\n\n// Example usage:\n/*\n"}
{"task_id": "CPP/64", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint vowels_count(string s) {\n    int count = 0;\n    // Convert string to lowercase for simplicity\n    transform(s.begin(), s.end(), s.begin(), ::tolower);\n\n    // Check each character in the string\n    for (size_t i = 0; i < s.length(); ++i) {\n        char c = s[i];\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n            count++;\n        }\n        // Check for 'y' at the end of the string\n        else if (c == 'y' && i == s.length() - 1) {\n            count++;\n        }\n    }\n\n    return count;\n}\n\n"}
{"task_id": "CPP/65", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring circular_shift(int x, int shift) {\n    // Convert integer to string for easy manipulation\n    string str = to_string(x);\n    \n    // Calculate the effective shift needed\n    int len = str.length();\n    shift %= len;  // Effective shifts\n    \n    if (shift >= len) {  // If shift is greater than or equal to length, reverse the digits\n        reverse(str.begin(), str.end());\n    } else {\n        // Perform circular right shift by 'shift' positions\n        rotate(str.rbegin(), str.rbegin() + shift, str.rend());\n    }\n    \n    return str;\n}\n\n"}
{"task_id": "CPP/66", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint digitSum(string s) {\n    int sum = 0;\n    \n    // Iterate over each character in the string.\n    for (char c : s) {\n        // Check if the character is an uppercase letter.\n        if (c >= 'A' && c <= 'Z') {\n            // Add its ASCII value to the sum.\n            sum += static_cast<int>(c);\n        }\n    }\n\n    return sum;\n}\n\n// Function to test the digitSum function with given examples\nvoid check() {\n    cout << \"digitSum(\\\"\\\") => \" << digitSum(\"\") << endl;       // Expected output: 0\n    cout << \"digitSum(\\\"abAB\\\") => \" << digitSum(\"abAB\") << endl;   // Expected output: 131\n    cout << \"digitSum(\\\"abcCd\\\") => \" << digitSum(\"abcCd\") << endl; // Expected output: 67\n    cout << \"digitSum(\\\"helloE\\\") => \" << digitSum(\"helloE\") << endl;// Expected output: 69\n    cout << \"digitSum(\\\"woArBld\\\") => \" << digitSum(\"woArBld\") << endl; // Expected output: 131\n    cout << \"digitSum(\\\"aAaaaXa\\\") => \" << digitSum(\"aAaaaXa\") << endl;// Expected output: 153\n}\n\n"}
{"task_id": "CPP/67", "generation": "#include <iostream>\n#include <string>\n#include <sstream> // For std::istringstream\n\nusing namespace std;\n\nint fruit_distribution(string s, int n) {\n    istringstream iss(s);\n    string word;\n    \n    int apples = 0, oranges = 0;\n    \n    while (iss >> word) { // Read words from the stream\n        if (word == \"apples\") {\n            iss >> word; // Skip 'and'\n            iss >> oranges; // The number following 'and' is the count of oranges\n        } else if (isdigit(word[0])) {\n            apples = stoi(word); // Convert string to integer for apples\n        }\n    }\n\n    return n - apples - oranges;\n}\n\n"}
{"task_id": "CPP/68", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> pluck(vector<int> arr) {\n    int minEvenValue = INT_MAX; // Initialize with a large number to find the minimum even value.\n    int minIndex = -1;          // To store the index of the smallest even value.\n\n    for (int i = 0; i < arr.size(); ++i) {\n        if (arr[i] % 2 == 0 && arr[i] <= minEvenValue) { // Check if it's an even number and less than or equal to current minimum.\n            minEvenValue = arr[i];\n            minIndex = i;\n        }\n    }\n\n    // If no even value was found, return an empty vector.\n    if (minIndex == -1)\n        return {};\n\n    return {minEvenValue, minIndex}; // Return the smallest even value and its index.\n}\n"}
{"task_id": "CPP/69", "generation": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint search(vector<int> lst) {\n    // Create a frequency map to count occurrences of each number\n    unordered_map<int, int> freqMap;\n    \n    for (int num : lst) {\n        freqMap[num]++;\n    }\n    \n    // Initialize the result as -1 assuming no such value exists initially\n    int result = -1;\n\n    // Iterate through the frequency map and check if any integer's frequency is >= its value\n    for (const auto& pair : freqMap) {\n        if (pair.first <= pair.second && pair.first > result) {\n            result = pair.first;\n        }\n    }\n\n    return result;\n}\n\n// Function to test the solution with given examples\nvoid test() {\n    vector<int> test1 = {4, 1, 2, 2, 3, 1};\n    vector<int> test2 = {1, 2, 2, 3, 3, 3, 4, 4, 4};\n    vector<int> test3 = {5, 5, 4, 4, 4};\n\n    cout << \"Test 1: Expected 2, Got \" << search(test1) << endl;\n    cout << \"Test 2: Expected 3, Got \" << search(test2) << endl;\n    cout << \"Test 3: Expected -1, Got \" << search(test3) << endl;\n}\n\n"}
{"task_id": "CPP/70", "generation": "#include <vector>\n#include <algorithm> // For std::sort\n\nstd::vector<int> strange_sort_list(std::vector<int> lst) {\n    if (lst.empty()) return {};  // Return an empty vector for an empty input list\n    \n    std::sort(lst.begin(), lst.end());  // Sort the list in ascending order\n    std::vector<int> result;\n    \n    int left = 0;  // Start of the sorted list\n    int right = lst.size() - 1;  // End of the sorted list\n    \n    while (left <= right) {\n        if (left == right) {  // If there's only one element left, add it to the result\n            result.push_back(lst[left]);\n            break;\n        }\n        \n        // Add minimum value from the remaining elements\n        result.push_back(lst[left++]);\n        // Add maximum value from the remaining elements\n        if (left <= right) {  // Check to avoid adding an element twice\n            result.push_back(lst[right--]);\n        }\n    }\n    \n    return result;\n}\n\n// Example usage:\n"}
{"task_id": "CPP/71", "generation": "#include <iostream>\n#include <cmath> // For sqrt function\n\n// Function to calculate the area of a triangle given its sides.\nfloat triangle_area(float a, float b, float c) {\n    // Check if the sides form a valid triangle\n    if (a + b <= c || a + c <= b || b + c <= a) {\n        return -1;\n    }\n\n    // Calculate the semi-perimeter\n    float s = (a + b + c) / 2;\n\n    // Use Heron's formula to calculate the area\n    float area = sqrt(s * (s - a) * (s - b) * (s - c));\n\n    // Round the result to two decimal points and return it\n    return std::round(area * 100) / 100;\n}\n\n"}
{"task_id": "CPP/72", "generation": "#include <vector>\nusing namespace std;\n\nbool will_it_fly(vector<int> q, int w) {\n    // Check if the vector is palindromic (balanced)\n    for(int i = 0; i < q.size() / 2; ++i){\n        if(q[i] != q[q.size() - 1 - i]){\n            return false;\n        }\n    }\n\n    // Calculate the sum of elements in the vector\n    int sum = 0;\n    for(int num : q) {\n        sum += num;\n    }\n\n    // Check if the sum is less than or equal to w\n    return sum <= w;\n}\n"}
{"task_id": "CPP/73", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint smallest_change(vector<int> arr) {\n    int changes = 0;\n    int left = 0, right = arr.size() - 1;\n\n    while (left < right) {\n        if (arr[left] != arr[right]) {\n            ++changes; // Increment the change count\n        }\n        ++left;\n        --right;\n    }\n\n    return changes;\n}\n\n"}
{"task_id": "CPP/74", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to calculate total number of chars in a list of strings.\nint countChars(const vector<string>& lst) {\n    int count = 0;\n    for (const string& str : lst) {\n        count += str.size();\n    }\n    return count;\n}\n\nvector<string> total_match(vector<string> lst1, vector<string> lst2) {\n    // Calculate the number of characters in each list\n    int charsInLst1 = countChars(lst1);\n    int charsInLst2 = countChars(lst2);\n\n    // Compare and return the appropriate list based on character counts.\n    if (charsInLst1 <= charsInLst2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n\n// Function to test the total_match function with given examples\nvoid check() {\n    vector<string> empty = {};\n    vector<string> result;\n\n    // Test cases\n    result = total_match(empty, empty);\n    for (const string& str : result) cout << str << \" \";\n    cout << endl;\n\n    result = total_match({\"hi\", \"admin\"}, {\"hI\", \"Hi\"});\n    for (const string& str : result) cout << str << \" \";\n    cout << endl;\n\n    result = total_match({\"hi\", \"admin\"}, {\"hi\", \"hi\", \"admin\", \"project\"});\n    for (const string& str : result) cout << str << \" \";\n    cout << endl;\n\n    result = total_match({\"hi\", \"admin\"}, {\"hI\", \"hi\", \"hi\"});\n    for (const string& str : result) cout << str << \" \";\n    cout << endl;\n\n    result = total_match({\"4\"}, {\"1\", \"2\", \"3\", \"4\", \"5\"});\n    for (const string& str : result) cout << str << \" \";\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/75", "generation": "#include <iostream>\nusing namespace std;\n\n// Helper function to check if a number is prime.\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\n// Main function to check if the number can be expressed as a product of three primes.\nbool is_multiply_prime(int a) {\n    // Iterate through all possible prime factors less than 100\n    for (int i = 2; i < 100 && i * i <= a; ++i) {\n        if (!is_prime(i)) continue;\n        \n        int count = 0;\n        while (a % i == 0) {\n            a /= i;\n            count++;\n        }\n        \n        // If we have more than one prime factor, break early\n        if (count > 1) return false;\n\n        // Check the remaining part of 'a' to see if it can be expressed as product of two primes.\n        for (int j = i + 1; j < 100 && a >= j * j; ++j) {\n            if (!is_prime(j)) continue;\n            \n            int count2 = 0;\n            while (a % j == 0) {\n                a /= j;\n                count2++;\n            }\n            \n            // If we have more than one prime factor, break early\n            if (count2 > 1) return false;\n\n            // Check the remaining part of 'a' to see if it is prime.\n            if (is_prime(a)) return true;\n        }\n\n        // Reset 'a' for next iteration\n        a = a * i;\n    }\n    \n    return false;\n}\n\n"}
{"task_id": "CPP/76", "generation": "#include <cmath> // For log and pow functions\n\nbool is_simple_power(int x, int n) {\n    if (x == 1) return true; // Any number to the power of 0 is 1.\n    if (n <= 1 && x != n) return false; // If n is less than or equal to 1 and not equal to x, it's false.\n\n    double k = log(x) / log(n); // Calculate the potential exponent\n    int k_int = round(k); // Round to nearest integer\n\n    if (pow(n, k_int) == x) return true; // Check if n raised to this power equals x\n    else return false;\n}\n\n"}
{"task_id": "CPP/77", "generation": "#include <iostream>\n#include <cmath> // For cbrt and round functions\n\nbool iscube(int a) {\n    double cubeRoot = cbrt(a); // Calculate the cube root\n    int roundedCubeRoot = round(cubeRoot); // Round to the nearest integer\n    \n    // Check if the cube of the rounded value equals the original number.\n    return (roundedCubeRoot * roundedCubeRoot * roundedCubeRoot == a);\n}\n\n"}
{"task_id": "CPP/78", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint hex_key(string num) {\n    // Define a set of prime hexadecimal digits.\n    string primes = \"2357BD\";\n    \n    int count = 0;\n    for (char c : num) {\n        if (primes.find(c) != string::npos) {\n            ++count; // Increment count if the digit is in our list of primes\n        }\n    }\n    return count;\n}\n\n// Function to test the hex_key function with given examples.\nvoid check() {\n    cout << \"Testing 'AB': Expected 1, Got: \" << hex_key(\"AB\") << endl;\n    cout << \"Testing '1077E': Expected 2, Got: \" << hex_key(\"1077E\") << endl;\n    cout << \"Testing 'ABED1A33': Expected 4, Got: \" << hex_key(\"ABED1A33\") << endl;\n    cout << \"Testing '123456789ABCDEF0': Expected 6, Got: \" << hex_key(\"123456789ABCDEF0\") << endl;\n    cout << \"Testing '2020': Expected 2, Got: \" << hex_key(\"2020\") << endl;\n}\n\n"}
{"task_id": "CPP/79", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring decimal_to_binary(int decimal) {\n    // Initialize an empty string to store the binary digits.\n    string binary = \"\";\n\n    // Convert the decimal number to binary.\n    while (decimal > 0) {\n        int remainder = decimal % 2;\n        binary = char('0' + remainder) + binary; // Prepend the remainder to the binary string\n        decimal /= 2;\n    }\n\n    // Add \"db\" at both ends of the binary string.\n    return \"db\" + binary + \"db\";\n}\n\n"}
{"task_id": "CPP/80", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_happy(string s) {\n    // Check if the length of the string is less than 3, return false immediately.\n    if (s.length() < 3) {\n        return false;\n    }\n\n    // Iterate through the string to check every set of three consecutive characters\n    for (int i = 0; i <= s.length() - 3; ++i) {\n        // Check if any two out of three consecutive characters are the same.\n        if (s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]) {\n            return false;\n        }\n    }\n\n    // If all checks pass, the string is happy\n    return true;\n}\n\n"}
{"task_id": "CPP/81", "generation": "#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<string> numerical_letter_grade(vector<float> grades) {\n    vector<string> result;\n    \n    for (float gpa : grades) {\n        if (gpa >= 4.0) result.push_back(\"A+\");\n        else if (gpa > 3.7) result.push_back(\"A\");\n        else if (gpa > 3.3) result.push_back(\"A-\");\n        else if (gpa > 3.0) result.push_back(\"B+\");\n        else if (gpa > 2.7) result.push_back(\"B\");\n        else if (gpa > 2.3) result.push_back(\"B-\");\n        else if (gpa > 2.0) result.push_back(\"C+\");\n        else if (gpa > 1.7) result.push_back(\"C\");\n        else if (gpa > 1.3) result.push_back(\"C-\");\n        else if (gpa > 1.0) result.push_back(\"D+\");\n        else if (gpa > 0.7) result.push_back(\"D\");\n        else if (gpa > 0.0) result.push_back(\"D-\");\n        else result.push_back(\"E\"); // For GPA <= 0\n    }\n    \n    return result;\n}\n\n// Example usage:\n"}
{"task_id": "CPP/82", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\n// Helper function to check if a number is prime\nbool is_prime(int n) {\n    // Handle edge cases for 0, 1 and negative numbers\n    if (n <= 1) return false;\n    \n    // Check divisibility from 2 up to the square root of n\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0)\n            return false;\n    }\n    return true;\n}\n\n// Main function that checks if the length of a string is prime\nbool prime_length(string str){\n    // Get the length of the string\n    int len = str.length();\n    \n    // Use the helper function to check if the length is prime\n    return is_prime(len);\n}\n\n"}
{"task_id": "CPP/83", "generation": "#include <iostream>\n#include <cmath> // For pow function\n\nint starts_one_ends(int n) {\n    if (n == 1) return 1; // Special case for single-digit numbers\n    \n    int count_start_with_1 = static_cast<int>(pow(9, n-1));\n    int count_end_with_1 = static_cast<int>(pow(9, n-1));\n    int overlap_count = static_cast<int>(pow(9, n-2));\n\n    return count_start_with_1 + count_end_with_1 - overlap_count;\n}\n\n"}
{"task_id": "CPP/84", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\n// Function to calculate the sum of digits of N\nint sumOfDigits(int N) {\n    int sum = 0;\n    while (N > 0) {\n        sum += N % 10; // Add the last digit to sum\n        N /= 10;       // Remove the last digit from N\n    }\n    return sum;\n}\n\n// Function to convert a decimal number to binary and return as string\nstring decimalToBinary(int num) {\n    if (num == 0)\n        return \"0\";\n    \n    string binary = \"\";\n    while (num > 0) {\n        binary = to_string(num % 2) + binary; // Prepend the remainder to the result\n        num /= 2;\n    }\n    return binary;\n}\n\nstring solve(int N){\n    int sum = sumOfDigits(N); // Calculate the sum of digits\n    string binarySum = decimalToBinary(sum); // Convert the sum to binary\n    return binarySum; // Return the binary representation as a string\n}\n\n// Function to test the solution with given examples\nvoid check() {\n    cout << solve(1000) << endl;  // Expected output: \"1\"\n    cout << solve(150) << endl;   // Expected output: \"110\"\n    cout << solve(147) << endl;   // Expected output: \"1100\"\n}\n\n"}
{"task_id": "CPP/85", "generation": "#include <vector>\nusing namespace std;\n\nint add(vector<int> lst) {\n    int sum = 0;\n    // Iterate through the list with index i starting from 1 (the first odd index)\n    for(int i = 1; i < lst.size(); i += 2) { // Increment by 2 to only check odd indices\n        if(lst[i] % 2 == 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n\n// Example usage:\n"}
{"task_id": "CPP/86", "generation": "#include <iostream>\n#include <string>\n#include <vector>\n#include <sstream>\n\nusing namespace std;\n\n// Function to sort a single word based on ASCII values.\nstring sortWord(const string& word) {\n    string sorted_word = word;\n    sort(sorted_word.begin(), sorted_word.end());\n    return sorted_word;\n}\n\n// Main function that processes the entire sentence.\nstring anti_shuffle(string s) {\n    stringstream ss(s);\n    string word, result;\n    \n    // Process each word in the sentence\n    while (ss >> word) {\n        if (!result.empty()) {\n            result += \" \";  // Add a space before appending the next word\n        }\n        result += sortWord(word);  // Append sorted word to the result\n    }\n\n    return result;\n}\n\n// Function to test the anti_shuffle function with given examples.\nvoid check() {\n    cout << (anti_shuffle(\"Hi\") == \"Hi\" ? \"Pass\\n\" : \"Fail\\n\");\n    cout << (anti_shuffle(\"hello\") == \"ehllo\" ? \"Pass\\n\" : \"Fail\\n\");\n    cout << (anti_shuffle(\"Hello World!!!\") == \"Hello !!!Wdlor\" ? \"Pass\\n\" : \"Fail\\n\");\n}\n\n"}
{"task_id": "CPP/87", "generation": "#include <vector>\n#include <algorithm> // for std::sort\n\nusing namespace std;\n\n// Comparator function for sorting.\nbool compare(const vector<int>& a, const vector<int>& b) {\n    if (a[0] != b[0]) return a[0] < b[0]; // Sort by row in ascending order\n    else return a[1] > b[1];              // Then sort by column in descending order within the same row\n}\n\nvector<vector<int>> get_row(vector<vector<int>> lst, int x) {\n    vector<vector<int>> result;\n\n    // Iterate through each row and find occurrences of x.\n    for (int i = 0; i < lst.size(); ++i) {\n        for (int j = 0; j < lst[i].size(); ++j) {\n            if (lst[i][j] == x) {\n                result.push_back({i, j});\n            }\n        }\n    }\n\n    // Sort the coordinates according to the specified criteria.\n    sort(result.begin(), result.end(), compare);\n\n    return result;\n}\n\n// Example usage\n"}
{"task_id": "CPP/88", "generation": "#include <vector>\n#include <algorithm> // for std::sort and std::greater\n\nusing namespace std;\n\nvector<int> sort_array(vector<int> array) {\n    if(array.empty() || array.size() == 1) return array; // Handle edge cases\n    \n    vector<int> sortedArray = array; // Copy the original array to avoid modifying it directly\n    int sumOfFirstAndLast = array.front() + array.back();\n    \n    if(sumOfFirstAndLast % 2 == 0) { // If the sum is even, sort in descending order\n        sort(sortedArray.begin(), sortedArray.end(), greater<int>());\n    } else { // Otherwise, sort in ascending order\n        sort(sortedArray.begin(), sortedArray.end());\n    }\n    \n    return sortedArray;\n}\n\n// Example usage:\n// vector<int> result = sort_array({2, 4, 3, 0, 1, 5});\n// for(int i : result) {\n//     printf(\"%d \", i);\n// }\n"}
{"task_id": "CPP/89", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nchar rotate_char(char c, int shift) {\n    // Check if character is lowercase.\n    bool is_lower = islower(c);\n    \n    // Calculate the new position with wrapping around using modulo operation.\n    char base = is_lower ? 'a' : 'A';\n    return (c - base + shift) % 26 + base;\n}\n\nstring encrypt(string s){\n    int shift = 4; // Two multiplied by two\n    string encrypted_string;\n\n    for(char c: s) {\n        if(isalpha(c)) { // Check if the character is an alphabet letter.\n            encrypted_string += rotate_char(c, shift);\n        } else {\n            // If it's not a letter, just append it as-is.\n            encrypted_string += c;\n        }\n    }\n\n    return encrypted_string;\n}\n\n"}
{"task_id": "CPP/90", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits> // For INT_MAX\n\nusing namespace std;\n\nint next_smallest(vector<int> lst) {\n    if (lst.size() < 2) return INT_MAX; // Return a special value indicating no second smallest element exists\n    \n    sort(lst.begin(), lst.end()); // Sort the vector to arrange elements in ascending order\n    int first = lst[0]; // The smallest element is now at index 0\n\n    for (size_t i = 1; i < lst.size(); ++i) {\n        if (lst[i] != first) { // Find the next unique element which will be the second smallest\n            return lst[i];\n        }\n    }\n\n    return INT_MAX; // If all elements are the same, there is no second smallest element\n}\n\n"}
{"task_id": "CPP/91", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint is_bored(string S) {\n    int boredom_count = 0;\n    string word;\n    bool isNewSentence = true; // Flag to check if we are at the start of a new sentence\n\n    for (char c : S) {\n        if (isNewSentence && c == 'I') { // Check if the current character is 'I' and it's the start of a sentence\n            boredom_count++;\n            isNewSentence = false; // Reset flag since we've found an \"I\" at the beginning\n        } else if (c == '.' || c == '?' || c == '!') {\n            isNewSentence = true; // New sentence starts after a delimiter\n        } else if (isNewSentence && c != ' ') { // If it's not 'I' and we're still in the start of a new sentence, reset flag\n            isNewSentence = false;\n        }\n    }\n\n    return boredom_count;\n}\n\n"}
{"task_id": "CPP/92", "generation": "#include <iostream>\n#include <cmath>\n\nbool is_integer(float num) {\n    return std::floor(num) == num;\n}\n\nbool any_int(float a, float b, float c) {\n    // Check if all numbers are integers\n    if (!is_integer(a) || !is_integer(b) || !is_integer(c)) {\n        return false;\n    }\n\n    // Convert to int for comparison\n    int ia = static_cast<int>(a);\n    int ib = static_cast<int>(b);\n    int ic = static_cast<int>(c);\n\n    // Check if any number is the sum of the other two\n    return (ia == ib + ic) || (ib == ia + ic) || (ic == ia + ib);\n}\n\n"}
{"task_id": "CPP/93", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\n// Function to encode a message according to the given rules\nstring encode(string message) {\n    // Iterate through each character of the string\n    for (int i = 0; i < message.length(); ++i) {\n        char c = message[i];\n        \n        // Swap case: if lowercase, convert to uppercase and vice versa\n        if (islower(c)) {\n            message[i] = toupper(c);\n        } else if (isupper(c)) {\n            message[i] = tolower(c);\n        }\n        \n        // Replace vowels with the letter 2 places ahead in the alphabet\n        switch(message[i]) {\n            case 'A': case 'a':\n                message[i] = 'C';\n                break;\n            case 'E': case 'e':\n                message[i] = 'G';\n                break;\n            case 'I': case 'i':\n                message[i] = 'K';\n                break;\n            case 'O': case 'o':\n                message[i] = 'Q';\n                break;\n            case 'U': case 'u':\n                message[i] = 'W';\n                break;\n        }\n    }\n    \n    return message;\n}\n\n// Function to test the encode function\nvoid check() {\n    cout << \"Encoded 'test': \" << encode(\"test\") << endl; // Expected: TGST\n    cout << \"Encoded 'This is a message': \" << encode(\"This is a message\") << endl; // Expected: tHKS KS C MGSSCGG\n}\n\n"}
{"task_id": "CPP/94", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Helper function to check if a number is prime\nbool isPrime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\n// Function to sum the digits of a number\nint sumDigits(int num) {\n    int sum = 0;\n    while (num > 0) {\n        sum += num % 10;\n        num /= 10;\n    }\n    return sum;\n}\n\n// Main function to find and process the largest prime in the list\nint skjkasdkd(vector<int> lst) {\n    int maxPrime = -1; // Initialize with a non-prime value\n\n    // Find the largest prime number in the list\n    for (int num : lst) {\n        if (isPrime(num)) {\n            if (num > maxPrime) {\n                maxPrime = num;\n            }\n        }\n    }\n\n    // If no prime was found, return 0 or handle as needed\n    if (maxPrime == -1) return 0;\n\n    // Sum the digits of the largest prime number\n    return sumDigits(maxPrime);\n}\n\n// Example usage and testing\n"}
{"task_id": "CPP/95", "generation": "#include <iostream>\n#include <string>\n#include <map>\nusing namespace std;\n\nbool check_dict_case(map<string, string> dict) {\n    // Check for empty map\n    if(dict.empty()) return false;\n    \n    bool allLower = true, allUpper = true;\n    \n    for(auto& pair : dict) {\n        const string& key = pair.first;\n        \n        // Check if the key contains non-alphabetic characters\n        for(char c : key) {\n            if(!isalpha(c)) return false;  // If any character is not alphabetic, return false\n        }\n        \n        // Determine case of keys\n        allLower &= islower(key[0]);\n        allUpper &= isupper(key[0]);\n    }\n\n    // Return true only if all keys are either in lower or upper case\n    return allLower || allUpper;\n}\n\n"}
{"task_id": "CPP/96", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Helper function to check if a number is prime.\nbool is_prime(int num) {\n    if (num <= 1) return false; // 0 and 1 are not primes\n    for (int i = 2; i * i <= num; ++i) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\nvector<int> count_up_to(int n){\n    vector<int> primes;\n    \n    // Iterate through all numbers from 2 up to but not including n\n    for (int i = 2; i < n; ++i) {\n        if (is_prime(i)) {\n            primes.push_back(i);\n        }\n    }\n    \n    return primes;\n}\n\n// Function to test the count_up_to function with given examples.\nvoid test() {\n    vector<int> result;\n\n    result = count_up_to(5); // Expected: {2, 3}\n    for (int prime : result) cout << prime << \" \";\n    cout << endl;\n\n    result = count_up_to(11); // Expected: {2, 3, 5, 7}\n    for (int prime : result) cout << prime << \" \";\n    cout << endl;\n\n    result = count_up_to(0); // Expected: {}\n    if(result.empty()) cout << \"{}\" << endl;\n    \n    result = count_up_to(20); // Expected: {2, 3, 5, 7, 11, 13, 17, 19}\n    for (int prime : result) cout << prime << \" \";\n    cout << endl;\n\n    result = count_up_to(1); // Expected: {}\n    if(result.empty()) cout << \"{}\" << endl;\n    \n    result = count_up_to(18); // Expected: {2, 3, 5, 7, 11, 13, 17}\n    for (int prime : result) cout << prime << \" \";\n    cout << endl;\n}\n\n// Main function to run the tests.\n"}
{"task_id": "CPP/97", "generation": "#include <iostream> // Corrected the include directive for standard input/output\n\nint multiply(int a, int b) {\n    // Extracting the unit digit of both numbers using modulo 10\n    int unitDigitA = abs(a % 10); \n    int unitDigitB = abs(b % 10);\n    \n    // Multiplying the unit digits and returning the result\n    return unitDigitA * unitDigitB;\n}\n\n"}
{"task_id": "CPP/98", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint count_upper(string s) {\n    int count = 0;\n    // Iterate through the string with a step of 2 to check even indices only.\n    for (size_t i = 0; i < s.length(); i += 2) {\n        char c = s[i];\n        // Check if the character is an uppercase vowel\n        if (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n            count++;\n        }\n    }\n    return count;\n}\n\n"}
{"task_id": "CPP/99", "generation": "#include <iostream>\n#include <cmath>\n#include <string>\n\nusing namespace std;\n\nint closest_integer(string value) {\n    // Convert string to float\n    float num = stof(value);\n    \n    // Get the integer part of the number\n    int intPart = static_cast<int>(num);\n\n    // Calculate the fractional part\n    float fracPart = fabs(num - intPart);\n\n    // Check if it's equidistant from two integers and round away from zero\n    if (fracPart == 0.5) {\n        return num > 0 ? ceil(num) : floor(num);\n    } else {\n        // Use standard rounding for other cases\n        return static_cast<int>(round(num));\n    }\n}\n\n"}
{"task_id": "CPP/100", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> make_a_pile(int n) {\n    // Initialize a vector to store the number of stones at each level.\n    vector<int> pile;\n    \n    // Loop through from 0 to n-1, adding the current value and then incrementing by 2\n    for (int i = 0; i < n; ++i) {\n        pile.push_back(n);\n        n += 2; // Move to the next odd or even number.\n    }\n    \n    return pile;\n}\n\n// Example usage:\n// vector<int> result = make_a_pile(3); // result should be {3, 5, 7}\n"}
{"task_id": "CPP/101", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> words_string(string s) {\n    vector<string> result;\n    string word = \"\";\n    \n    for (char c : s) {\n        if (c == ' ' || c == ',') { // Check for space or comma\n            if (!word.empty()) { // Add the collected word to the result, only if it's not empty\n                result.push_back(word);\n                word = \"\"; // Reset word after adding to the vector\n            }\n        } else {\n            word += c; // Collect characters into a word\n        }\n    }\n\n    if (!word.empty()) { // Add any remaining word in case there is no delimiter at the end of the string\n        result.push_back(word);\n    }\n\n    return result;\n}\n\n// Function to test the implementation with given examples\nvoid check() {\n    vector<string> res1 = words_string(\"Hi, my name is John\");\n    for (const auto& str : res1) cout << str << \" \";\n    cout << endl;\n\n    vector<string> res2 = words_string(\"One, two, three, four, five, six\");\n    for (const auto& str : res2) cout << str << \" \";\n}\n\n"}
{"task_id": "CPP/102", "generation": "#include <iostream>\nusing namespace std;\n\nint choose_num(int x, int y) {\n    // Check if the range is valid.\n    if (x > y)\n        return -1;\n    \n    // Start from y and move backwards to find the largest even number in the range [x, y].\n    for (int i = y; i >= x; --i) {\n        if (i % 2 == 0)\n            return i;\n    }\n    \n    // If no even number is found, which shouldn't happen given valid input,\n    // but as a fallback, we return -1.\n    return -1;\n}\n\n"}
{"task_id": "CPP/103", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring int_to_binary(int num){\n    string binary = \"\";\n    while (num > 0) {\n        binary = to_string(num % 2) + binary;\n        num /= 2;\n    }\n    return binary.empty() ? \"0\" : binary; // Handle the case when num is 0\n}\n\nstring rounded_avg(int n, int m){\n    if(n > m)\n        return \"-1\";\n    \n    long sum = 0;\n    for (int i = n; i <= m; ++i) {\n        sum += i;\n    }\n    \n    int count = m - n + 1;\n    int average = sum / count; // Integer division automatically rounds down\n    \n    return int_to_binary(average);\n}\n\n// Example usage\n"}
{"task_id": "CPP/104", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to check if a number contains only odd digits.\nbool hasOnlyOddDigits(int num) {\n    while (num > 0) {\n        int digit = num % 10;\n        if (digit % 2 == 0) return false; // If any digit is even, return false\n        num /= 10;\n    }\n    return true;\n}\n\nvector<int> unique_digits(vector<int> x) {\n    vector<int> result;\n\n    // Filter out numbers that contain only odd digits.\n    for (int num : x) {\n        if (hasOnlyOddDigits(num)) {\n            result.push_back(num);\n        }\n    }\n\n    // Sort the resulting vector in increasing order\n    sort(result.begin(), result.end());\n\n    return result;\n}\n\n// Function to test the unique_digits function with given examples.\nvoid check() {\n    vector<int> test1 = {15, 33, 1422, 1};\n    vector<int> expected1 = {1, 15, 33};\n    assert(unique_digits(test1) == expected1);\n\n    vector<int> test2 = {152, 323, 1422, 10};\n    vector<int> expected2 = {};\n    assert(unique_digits(test2) == expected2);\n\n    cout << \"All tests passed successfully.\" << endl;\n}\n\n"}
{"task_id": "CPP/105", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nvector<string> by_length(vector<int> arr) {\n    // Map to store number to string mapping\n    map<int, string> num_to_str = {\n        {1, \"One\"}, {2, \"Two\"}, {3, \"Three\"},\n        {4, \"Four\"}, {5, \"Five\"}, {6, \"Six\"},\n        {7, \"Seven\"}, {8, \"Eight\"}, {9, \"Nine\"}\n    };\n\n    // Filter and sort\n    vector<int> filtered_sorted;\n    for (int num : arr) {\n        if (num >= 1 && num <= 9) {\n            filtered_sorted.push_back(num);\n        }\n    }\n    sort(filtered_sorted.begin(), filtered_sorted.end());\n\n    // Reverse the sorted array\n    reverse(filtered_sorted.begin(), filtered_sorted.end());\n\n    // Convert numbers to their corresponding names\n    vector<string> result;\n    for (int num : filtered_sorted) {\n        result.push_back(num_to_str[num]);\n    }\n\n    return result;\n}\n\n// Function to check if the solution is correct\nvoid check() {\n    vector<int> test1 = {2, 1, 1, 4, 5, 8, 2, 3};\n    vector<string> expected1 = {\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"};\n    assert(by_length(test1) == expected1);\n\n    vector<int> test2 = {};\n    vector<string> expected2 = {};\n    assert(by_length(test2) == expected2);\n\n    vector<int> test3 = {1, -1, 55};\n    vector<string> expected3 = {\"One\"};\n    assert(by_length(test3) == expected3);\n    \n    cout << \"All tests passed successfully.\" << endl;\n}\n\n"}
{"task_id": "CPP/106", "generation": "#include <vector>\nusing namespace std;\n\n// Function to calculate factorial\nint factorial(int num) {\n    int result = 1;\n    for (int i = 2; i <= num; ++i) {\n        result *= i;\n    }\n    return result;\n}\n\n// Function to calculate the sum of numbers from 1 to num\nint sumToN(int num) {\n    return (num * (num + 1)) / 2; // Using the formula for the sum of first n natural numbers\n}\n\nvector<int> f(int n){\n    vector<int> result(n);\n    for (int i = 0; i < n; ++i) {\n        int indexValue = i + 1;\n        if (indexValue % 2 == 0) { // If the value is even, calculate factorial\n            result[i] = factorial(indexValue);\n        } else { // Otherwise, calculate sum from 1 to that number\n            result[i] = sumToN(indexValue);\n        }\n    }\n    return result;\n}\n\n// Example usage:\n// vector<int> res = f(5); // Should give {1, 2, 6, 24, 15}\n"}
{"task_id": "CPP/107", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\n// Function to check if a number is a palindrome.\nbool is_palindrome(int num) {\n    string str_num = to_string(num);\n    int len = str_num.length();\n    for (int i = 0; i < len / 2; ++i) {\n        if (str_num[i] != str_num[len - i - 1]) return false;\n    }\n    return true;\n}\n\nvector<int> even_odd_palindrome(int n) {\n    int even_count = 0, odd_count = 0;\n\n    for (int i = 1; i <= n; ++i) {\n        if (is_palindrome(i)) { // Check if the number is a palindrome.\n            if (i % 2 == 0) {\n                even_count++; // Increment count of even palindromes.\n            } else {\n                odd_count++; // Increment count of odd palindromes.\n            }\n        }\n    }\n\n    return vector<int>{even_count, odd_count};\n}\n\n"}
{"task_id": "CPP/108", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint count_nums(vector<int> n) {\n    int count = 0;\n    \n    for (auto num : n) {\n        int sum_of_digits = 0;\n        \n        // Handle negative numbers by converting them to positive and adjusting the first digit.\n        if (num < 0) {\n            num = -num; // Make it positive\n            sum_of_digits -= num % 10; // Subtract the last digit as it was originally negative\n            num /= 10;\n        }\n        \n        while (num > 0) {\n            sum_of_digits += num % 10; // Add each digit to the sum\n            num /= 10;\n        }\n\n        if (sum_of_digits > 0) count++; // Increment count if sum of digits is greater than 0\n    }\n    \n    return count;\n}\n\n"}
{"task_id": "CPP/109", "generation": "#include <vector>\nusing namespace std;\n\nbool move_one_ball(vector<int> arr) {\n    if (arr.empty()) return true; // An empty array is considered sorted.\n    \n    int n = arr.size();\n    bool foundBreakPoint = false;\n    \n    for(int i = 1; i < n; ++i) {\n        // Check if the current element is smaller than the previous one\n        if(arr[i] < arr[i-1]) {\n            if(foundBreakPoint) return false; // More than one break point, cannot be sorted by shifting.\n            \n            foundBreakPoint = true;\n        }\n    }\n\n    // If there was a break point, check if it can be resolved by shifting.\n    if (foundBreakPoint && arr[n-1] > arr[0]) {\n        return false; // The last element is greater than the first one after the shift, cannot sort.\n    }\n\n    return true;\n}\n"}
{"task_id": "CPP/110", "generation": "#include <vector>\n#include <string>\nusing namespace std;\n\nstring exchange(vector<int> lst1, vector<int> lst2) {\n    int oddCountInLst1 = 0;\n    int evenCountInLst2 = 0;\n\n    // Count the number of odd numbers in lst1 and even numbers in lst2\n    for (int num : lst1) {\n        if (num % 2 != 0) {\n            ++oddCountInLst1;\n        }\n    }\n\n    for (int num : lst2) {\n        if (num % 2 == 0) {\n            ++evenCountInLst2;\n        }\n    }\n\n    // If there are enough even numbers in lst2 to replace all odd numbers in lst1\n    if (oddCountInLst1 <= evenCountInLst2) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n"}
{"task_id": "CPP/111", "generation": "#include <iostream>\n#include <string>\n#include <map>\n#include <sstream>\nusing namespace std;\n\nmap<char,int> histogram(string test) {\n    // Map to store character frequencies\n    map<char, int> freq;\n    \n    // Temporary string to hold each word (character in this case)\n    stringstream ss(test);\n    string token;\n    \n    // Read each character from the input string and update frequency\n    while (getline(ss, token, ' ')) {\n        if (!token.empty()) {  // Ensure we don't count empty tokens\n            freq[token[0]]++;\n        }\n    }\n\n    // Find the maximum frequency\n    int maxFreq = 0;\n    for (auto& pair : freq) {\n        if (pair.second > maxFreq) {\n            maxFreq = pair.second;\n        }\n    }\n\n    // Create a new map with only characters that have the maximum frequency\n    map<char, int> result;\n    for (auto& pair : freq) {\n        if (pair.second == maxFreq) {\n            result.insert(pair);\n        }\n    }\n\n    return result;\n}\n\n// Function to test the histogram function\nvoid check() {\n    auto res = histogram(\"a b c\");\n    assert(res == map<char, int>{{'a', 1}, {'b', 1}, {'c', 1}});\n\n    res = histogram(\"a b b a\");\n    assert(res == map<char, int>{{'a', 2}, {'b', 2}});\n\n    res = histogram(\"a b c a b\");\n    assert(res == map<char, int>{{'a', 2}, {'b', 2}});\n\n    res = histogram(\"b b b b a\");\n    assert(res == map<char, int>{{'b', 4}});\n\n    res = histogram(\"\");\n    assert(res.empty());\n\n    cout << \"All tests passed successfully.\" << endl;\n}\n\n"}
{"task_id": "CPP/112", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to check if a string is a palindrome.\nbool isPalindrome(const string& str) {\n    int left = 0;\n    int right = str.size() - 1;\n    \n    while (left < right) {\n        if (str[left] != str[right]) return false;\n        ++left;\n        --right;\n    }\n    return true;\n}\n\nvector<string> reverse_delete(string s, string c) {\n    // Remove all characters from 's' that are present in 'c'.\n    for (char ch : c) {\n        s.erase(remove(s.begin(), s.end(), ch), s.end());\n    }\n\n    // Check if the resulting string is a palindrome.\n    bool result = isPalindrome(s);\n\n    // Prepare and return the result as required.\n    vector<string> res;\n    res.push_back(s);\n    res.push_back(result ? \"True\" : \"False\");\n    \n    return res;\n}\n\n"}
{"task_id": "CPP/113", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to replace all occurrences of 'i' with count in the template string.\nstring replaceIWithCount(const string& templateStr, int count) {\n    string result = \"\";\n    for (char c : templateStr) {\n        if (c == 'i') {\n            result += to_string(count);\n        } else {\n            result += c;\n        }\n    }\n    return result;\n}\n\nvector<string> odd_count(vector<string> lst){\n    vector<string> output;\n    string templateStr = \"the number of odd elements in the strin of the input.\";\n    \n    for (const auto& s : lst) {\n        int oddCount = 0;\n        // Counting odd digits\n        for (char c : s) {\n            if ((c - '0') % 2 != 0) { // Convert char to digit and check if it's odd\n                ++oddCount;\n            }\n        }\n        \n        // Replace all 'i' with the count of odd numbers in the template string.\n        output.push_back(replaceIWithCount(templateStr, oddCount));\n    }\n    \n    return output;\n}\n\n// Function to test the solution\nvoid check() {\n    vector<string> input1 = {\"1234567\"};\n    auto result1 = odd_count(input1);\n    for (const auto& s : result1) cout << s << endl;\n\n    vector<string> input2 = {\"3\", \"11111111\"};\n    auto result2 = odd_count(input2);\n    for (const auto& s : result2) cout << s << endl;\n}\n\n"}
{"task_id": "CPP/114", "generation": "#include <iostream>\n#include <vector>\n#include <climits> // For INT_MAX\n\nusing namespace std;\n\nlong long minSubArraySum(vector<long long> nums) {\n    if (nums.empty()) return 0; // Handle empty vector case\n    \n    long long currentMin = nums[0];\n    long long globalMin = nums[0];\n\n    for (size_t i = 1; i < nums.size(); ++i) {\n        currentMin = min(nums[i], currentMin + nums[i]);\n        if (currentMin < globalMin) {\n            globalMin = currentMin;\n        }\n    }\n\n    return globalMin;\n}\n\n"}
{"task_id": "CPP/115", "generation": "#include <vector>\n#include <algorithm> // for std::max\n\nint max_fill(std::vector<std::vector<int>> grid, int capacity) {\n    int total_drops = 0;\n    \n    // Iterate over each well (each row in the grid)\n    for(const auto& well : grid) {\n        int water_units = 0; // Count of units of water in this well\n        \n        // Sum up the number of '1's in the current well\n        for(int unit : well) {\n            if(unit == 1) {\n                ++water_units;\n            }\n        }\n\n        // Calculate how many times we need to lower the bucket into this well\n        int drops_for_well = (water_units + capacity - 1) / capacity; // Equivalent to ceil(water_units/capacity)\n        \n        total_drops += drops_for_well;\n    }\n    \n    return total_drops;\n}\n\n// Example usage:\n"}
{"task_id": "CPP/116", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to count the number of 1s in the binary representation of a number\nint countOnes(int n) {\n    int count = 0;\n    while (n != 0) {\n        if ((n & 1) == 1)\n            ++count;\n        n >>= 1; // Right shift to check the next bit\n    }\n    return count;\n}\n\n// Custom comparator function for sorting based on number of ones and then by value\nbool customComparator(int a, int b) {\n    int countA = countOnes(abs(a));\n    int countB = countOnes(abs(b));\n\n    if (countA == countB)\n        return a < b; // If the number of ones is equal, sort based on decimal value\n\n    return countA < countB; // Otherwise, sort based on the number of ones\n}\n\nvector<int> sort_array(vector<int> arr) {\n    sort(arr.begin(), arr.end(), customComparator);\n    return arr;\n}\n\n"}
{"task_id": "CPP/117", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to check if a character is a consonant\nbool is_consonant(char c) {\n    string vowels = \"aeiouAEIOU\";\n    return !vowels.find(c) && (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z');\n}\n\n// Function to count the number of consonants in a word\nint count_consonants(const string& word) {\n    int count = 0;\n    for (char c : word) {\n        if (is_consonant(c)) {\n            ++count;\n        }\n    }\n    return count;\n}\n\nvector<string> select_words(string s, int n) {\n    vector<string> result;\n    string word;\n    stringstream ss(s);\n\n    // Read each word from the input stream\n    while (ss >> word) {\n        if (count_consonants(word) == n) {\n            result.push_back(word);\n        }\n    }\n\n    return result;\n}\n\n// Function to test the select_words function with given examples\nvoid test_select_words() {\n    vector<string> res;\n\n    res = select_words(\"Mary had a little lamb\", 4);\n    for (const auto& word : res) cout << word << \" \"; // Should print: little\n\n    cout << endl;\n    \n    res = select_words(\"Mary had a little lamb\", 3);\n    for (const auto& word : res) cout << word << \" \"; // Should print: Mary lamb\n    \n    cout << endl;\n\n    res = select_words(\"simple white space\", 2);\n    if(res.empty()) cout << \"{}\"; // Should print: {}\n\n    cout << endl;\n    \n    res = select_words(\"Hello world\", 4);\n    for (const auto& word : res) cout << word << \" \"; // Should print: world\n    \n    cout << endl;\n\n    res = select_words(\"Uncle sam\", 3);\n    for (const auto& word : res) cout << word << \" \"; // Should print: Uncle\n}\n\n"}
{"task_id": "CPP/118", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool isVowel(char c) {\n    return (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' ||\n            c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U');\n}\n\nstring get_closest_vowel(string word) {\n    if (word.length() < 3) return \"\"; // If the length is less than 3, it's impossible to have a vowel between two consonants.\n\n    for (int i = word.length() - 2; i > 0; --i) { // Start from second last character and move left.\n        if (!isVowel(word[i]) && isVowel(word[i-1]) && !isVowel(word[i+1])) {\n            return string(1, word[i-1]); // Return the vowel found between two consonants.\n        }\n    }\n\n    return \"\"; // If no such vowel is found, return an empty string.\n}\n\n"}
{"task_id": "CPP/119", "generation": "#include <vector>\n#include <string>\nusing namespace std;\n\nstring match_parens(vector<string> lst) {\n    int balance1 = 0, balance2 = 0;\n    for (char c : lst[0]) {\n        if (c == '(') ++balance1;\n        else --balance1;\n    }\n    for (char c : lst[1]) {\n        if (c == '(') ++balance2;\n        else --balance2;\n    }\n\n    // Check both concatenation orders\n    bool canConcatenate = false;\n\n    // Concatenate in order 1,2 and check balance\n    int tempBalance = 0;\n    for (char c : lst[0]) {\n        if (c == '(') ++tempBalance;\n        else --tempBalance;\n        if (tempBalance < 0) break; // Early exit if unbalanced\n    }\n    for (char c : lst[1]) {\n        if (c == '(') ++tempBalance;\n        else --tempBalance;\n        if (tempBalance < 0) break; // Early exit if unbalanced\n    }\n    canConcatenate |= tempBalance == 0;\n\n    // Concatenate in order 2,1 and check balance\n    tempBalance = 0;\n    for (char c : lst[1]) {\n        if (c == '(') ++tempBalance;\n        else --tempBalance;\n        if (tempBalance < 0) break; // Early exit if unbalanced\n    }\n    for (char c : lst[0]) {\n        if (c == '(') ++tempBalance;\n        else --tempBalance;\n        if (tempBalance < 0) break; // Early exit if unbalanced\n    }\n    canConcatenate |= tempBalance == 0;\n\n    return canConcatenate ? \"Yes\" : \"No\";\n}\n"}
{"task_id": "CPP/120", "generation": "#include <vector>\n#include <algorithm> // for std::sort\n\nusing namespace std;\n\nvector<int> maximum(vector<int> arr, int k) {\n    // Step 1: Sort the array in ascending order.\n    sort(arr.begin(), arr.end());\n    \n    // Step 2: Extract the last k elements from the sorted vector.\n    vector<int> result;\n    for (int i = arr.size() - k; i < arr.size(); ++i) {\n        result.push_back(arr[i]);\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/121", "generation": "#include <vector>\nusing namespace std;\n\nint solution(vector<int> lst) {\n    int sum = 0;\n    \n    // Iterate through the vector, starting from index 0 and incrementing by 2 to get even positions.\n    for (size_t i = 0; i < lst.size(); i += 2) {\n        if (lst[i] % 2 != 0) { // Check if the element at position i is odd\n            sum += lst[i];\n        }\n    }\n\n    return sum;\n}\n"}
{"task_id": "CPP/122", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint add_elements(vector<int> arr, int k) {\n    // Initialize the sum to zero.\n    int sum = 0;\n    \n    // Iterate through the first k elements of the array.\n    for (int i = 0; i < k; ++i) {\n        // Check if the current element has at most two digits.\n        if (arr[i] >= 0 && arr[i] <= 99) {\n            sum += arr[i];  // Add it to the sum if it does.\n        }\n    }\n\n    return sum;\n}\n\n"}
{"task_id": "CPP/123", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // For std::sort\n\nusing namespace std;\n\nvector<int> get_odd_collatz(int n) {\n    vector<int> oddNumbers;\n    \n    while (n != 1) {\n        if (n % 2 == 1) { // Check if the number is odd\n            oddNumbers.push_back(n);\n        }\n        // Apply Collatz rules\n        if (n % 2 == 0) {\n            n = n / 2;\n        } else {\n            n = 3 * n + 1;\n        }\n    }\n    \n    // Add the last number in the sequence, which is always 1 and odd.\n    oddNumbers.push_back(1);\n    \n    // Sort the vector of odd numbers\n    sort(oddNumbers.begin(), oddNumbers.end());\n    \n    return oddNumbers;\n}\n\n// Function to test the solution with given examples\nvoid check() {\n    vector<int> result = get_odd_collatz(5);\n    cout << \"Odd Collatz sequence for 5: \";\n    for (int num : result) {\n        cout << num << \" \";\n    }\n    cout << endl;\n    \n    // Add more checks if necessary\n}\n\n"}
{"task_id": "CPP/124", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool valid_date(string date) {\n    // Check that the string length is correct and format matches mm-dd-yyyy\n    if(date.length() != 10 || date[2] != '-' || date[5] != '-') return false;\n    \n    // Extract month, day, year from the string\n    int month = stoi(date.substr(0, 2));\n    int day = stoi(date.substr(3, 2));\n    int year = stoi(date.substr(6, 4));\n\n    // Validate month and day according to rules\n    if(month < 1 || month > 12) return false;\n    \n    if(day < 1 || (month == 2 && day > 29)) return false; // February special case\n    \n    if((month == 4 || month == 6 || month == 9 || month == 11) && day > 30) return false; // Months with 30 days\n    else if(day > 31) return false; // Other months have up to 31 days\n    \n    // If all checks pass, the date is valid\n    return true;\n}\n\n"}
{"task_id": "CPP/125", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> split_words(string txt){\n    vector<string> result;\n    \n    // Check for spaces and split on them if they exist.\n    size_t start = 0, end = 0;\n    while ((end = txt.find(' ', start)) != string::npos) {\n        result.push_back(txt.substr(start, end - start));\n        start = end + 1;\n    }\n    // Add the last word (or entire text if no spaces were found)\n    result.push_back(txt.substr(start));\n\n    // If only one element in vector and it's not empty, check for commas.\n    if(result.size() == 1 && !result[0].empty()) {\n        start = 0;\n        end = 0;\n        while ((end = txt.find(',', start)) != string::npos) {\n            result.push_back(txt.substr(start, end - start));\n            start = end + 1;\n        }\n        // Add the last word (or entire text if no commas were found)\n        result.back() = txt.substr(start);\n    }\n\n    // If only one element in vector and it's not empty, count odd order letters.\n    if(result.size() == 1 && !result[0].empty()) {\n        int oddCount = 0;\n        for(char c : result[0]) {\n            if(islower(c) && ((c - 'a') % 2 != 0)) {\n                ++oddCount;\n            }\n        }\n        // Convert the count to string and return as a vector with one element.\n        result.clear();\n        result.push_back(to_string(oddCount));\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/126", "generation": "#include <vector>\n#include <algorithm>\n\nbool is_sorted(std::vector<int> lst) {\n    // Check if the list is empty or has only one element, which is trivially sorted.\n    if (lst.size() <= 1) return true;\n\n    int count = 1; // Initialize a counter for consecutive duplicates.\n\n    for(size_t i = 1; i < lst.size(); ++i) {\n        // Check if the current number appears more than twice\n        if(lst[i] == lst[i-1]) {\n            count++;\n            if(count > 2) return false;\n        } else {\n            count = 1; // Reset counter for a new number.\n        }\n\n        // Check if the list is not sorted in ascending order.\n        if (lst[i] < lst[i - 1]) return false;\n    }\n    \n    return true;\n}\n"}
{"task_id": "CPP/127", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\n// Function to check if a number is prime\nbool isPrime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\n// Function to find the intersection of two intervals\nvector<int> findIntersection(vector<int>& interval1, vector<int>& interval2) {\n    int start = max(interval1[0], interval2[0]);\n    int end = min(interval1[1], interval2[1]);\n    \n    if (start > end) return {}; // No intersection\n    \n    return {start, end};\n}\n\n// Main function to determine if the length of intersection is prime\nstring intersection(vector<int> interval1, vector<int> interval2) {\n    auto intersect = findIntersection(interval1, interval2);\n    if (intersect.empty()) return \"NO\"; // No intersection\n    \n    int len = intersect[1] - intersect[0];\n    \n    return isPrime(len + 1) ? \"YES\" : \"NO\";\n}\n\n"}
{"task_id": "CPP/128", "generation": "#include <vector>\n#include <cmath> // For std::abs\n\nint prod_signs(std::vector<int> arr) {\n    if (arr.empty()) return -32768; // Return special value for empty vector\n    \n    int signProduct = 1;\n    int magnitudeSum = 0;\n\n    for (auto num : arr) {\n        magnitudeSum += std::abs(num); // Sum of magnitudes\n        if (num == 0) { \n            signProduct = 0; // If any number is zero, the product of signs becomes 0\n            break;\n        } else if (num < 0) {\n            signProduct *= -1; // Multiply by -1 for negative numbers\n        }\n    }\n\n    return magnitudeSum * signProduct; // Return the final result\n}\n"}
{"task_id": "CPP/129", "generation": "#include <vector>\n#include <queue>\nusing namespace std;\n\n// Directions for moving up, down, left, and right.\nconst vector<pair<int, int>> directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n\nvector<int> minPath(vector<vector<int>>& grid, int k) {\n    int n = grid.size();\n    \n    // Priority queue to keep track of the minimum path values.\n    priority_queue<vector<int>, vector<vector<int>>, greater<>> pq;\n    \n    // Lambda function for DFS\n    auto dfs = [&](auto&& self, int x, int y, vector<int> path) {\n        if (path.size() == k) {\n            pq.push(path);\n            return;\n        }\n        \n        for (const auto& dir : directions) {\n            int nx = x + dir.first, ny = y + dir.second;\n            if (nx >= 0 && nx < n && ny >= 0 && ny < n) {\n                path.push_back(grid[nx][ny]);\n                self(self, nx, ny, path);\n                path.pop_back(); // Backtrack\n            }\n        }\n    };\n    \n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            dfs(dfs, i, j, {grid[i][j]});\n        }\n    }\n    \n    return pq.top();\n}\n"}
{"task_id": "CPP/130", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> tri(int n) {\n    vector<int> result(n + 1);\n    \n    // Base cases as per the problem statement.\n    if (n >= 0) result[0] = 1; // Assuming tri(0) should be defined for completeness\n    if (n >= 1) result[1] = 3;\n    if (n >= 2) result[2] = 2;\n\n    // Compute the sequence up to n.\n    for(int i = 3; i <= n; ++i){\n        if(i % 2 == 0)\n            result[i] = 1 + i / 2;\n        else\n            result[i] = result[i - 1] + result[i - 2] + result[i - 3];\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/131", "generation": "#include <iostream>\n#include <string>\n\nint digits(int n) {\n    std::string numStr = std::to_string(n); // Convert the number to string for easy iteration over each digit.\n    int product = 1; // Initialize product with 1, as multiplying by 1 doesn't change the value.\n    bool hasOddDigit = false; // Flag to check if there is at least one odd digit.\n\n    for (char c : numStr) {\n        int digit = c - '0'; // Convert char to integer\n        if (digit % 2 != 0) { // Check if the digit is odd.\n            product *= digit;\n            hasOddDigit = true; // Set flag as true since we found an odd digit.\n        }\n    }\n\n    return hasOddDigit ? product : 0; // Return product if there's at least one odd digit, otherwise return 0.\n}\n\n"}
{"task_id": "CPP/132", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_nested(string str) {\n    int depth = 0;\n    bool hasNestedPair = false;\n\n    for (char ch : str) {\n        if (ch == '[') {\n            depth++;\n            // If we have more than one level of nesting, set the flag to true\n            if (depth > 1) {\n                hasNestedPair = true;\n            }\n        } else if (ch == ']') {\n            depth--;\n            // Ensure that depth doesn't go below zero which would indicate an invalid sequence\n            if (depth < 0) return false;\n        }\n    }\n\n    // Return true only if we found a nested pair and the final depth is zero (valid sequence)\n    return hasNestedPair && depth == 0;\n}\n\n"}
{"task_id": "CPP/133", "generation": "#include <stdio.h>\n#include <math.h>\n#include <vector>\n\nusing namespace std;\n\nint sum_squares(vector<float> lst){\n    int sum = 0;\n    \n    for (float num : lst) {\n        // Round each number up to the nearest integer using ceil()\n        int rounded_num = ceil(num);\n        \n        // Square the rounded number and add it to the sum\n        sum += rounded_num * rounded_num;\n    }\n    \n    return sum;\n}\n\n// Function to test the solution with given examples\nvoid check() {\n    printf(\"%d\\n\", sum_squares({1, 2, 3}));   // Expected output: 14\n    printf(\"%d\\n\", sum_squares({1, 4, 9}));   // Expected output: 98\n    printf(\"%d\\n\", sum_squares({1, 3, 5, 7}));// Expected output: 84\n    printf(\"%d\\n\", sum_squares({1.4, 4.2, 0})); // Expected output: 29\n    printf(\"%d\\n\", sum_squares({-2.4, 1, 1})); // Expected output: 6\n}\n\n"}
{"task_id": "CPP/134", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool check_if_last_char_is_a_letter(string txt) {\n    // Check if string is empty or ends with space.\n    if (txt.empty() || txt.back() == ' ') return false;\n    \n    // Get the last character of the string.\n    char lastChar = txt.back();\n    \n    // Check if it's an alphabetical character and not part of a word.\n    bool isAlphabetical = isalpha(lastChar);\n    bool isNotPartOfWord = (txt.size() == 1 || txt[txt.size()-2] == ' ');\n    \n    return isAlphabetical && isNotPartOfWord;\n}\n\n"}
{"task_id": "CPP/135", "generation": "#include <vector>\nusing namespace std;\n\nint can_arrange(vector<int> arr) {\n    int result = -1;\n    \n    // Iterate through the array starting from the second element.\n    for (size_t i = 1; i < arr.size(); ++i) {\n        if (arr[i] < arr[i-1]) { // Check if current element is less than its predecessor\n            result = i; // Update the largest index found so far\n        }\n    }\n\n    return result;\n}\n\n// Example usage:\n"}
{"task_id": "CPP/136", "generation": "#include <vector>\n#include <climits> // For INT_MIN and INT_MAX\n\nusing namespace std;\n\nvector<int> largest_smallest_integers(vector<int> lst) {\n    int largestNegative = INT_MIN; // Initialize to smallest possible integer value\n    int smallestPositive = INT_MAX; // Initialize to largest possible integer value\n    \n    for (int num : lst) {\n        if (num < 0 && num > largestNegative) {\n            largestNegative = num;\n        } else if (num > 0 && num < smallestPositive) {\n            smallestPositive = num;\n        }\n    }\n\n    // If no negative numbers were found, set largestNegative to 0\n    if (largestNegative == INT_MIN) {\n        largestNegative = 0;\n    }\n    \n    // If no positive numbers were found, set smallestPositive to 0\n    if (smallestPositive == INT_MAX) {\n        smallestPositive = 0;\n    }\n\n    return {largestNegative, smallestPositive};\n}\n\n// Example usage:\n"}
{"task_id": "CPP/137", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <boost/any.hpp>\n\nusing namespace std;\n\n// Helper function to convert string representation of numbers into float.\nfloat parseNumber(const string& str) {\n    string temp = str;\n    // Replace comma with dot if it exists\n    size_t found = temp.find(',');\n    if (found != string::npos)\n        temp.replace(found, 1, \".\");\n    \n    return stof(temp);\n}\n\n// Main function to compare two values of mixed types.\nboost::any compare_one(boost::any a, boost::any b) {\n    float fa, fb;\n    \n    // Convert both inputs to floats for comparison\n    if (a.type() == typeid(int)) {\n        fa = boost::any_cast<int>(a);\n    } else if (a.type() == typeid(float)) {\n        fa = boost::any_cast<float>(a);\n    } else if (a.type() == typeid(string)) {\n        fa = parseNumber(boost::any_cast<string>(a));\n    }\n    \n    if (b.type() == typeid(int)) {\n        fb = boost::any_cast<int>(b);\n    } else if (b.type() == typeid(float)) {\n        fb = boost::any_cast<float>(b);\n    } else if (b.type() == typeid(string)) {\n        fb = parseNumber(boost::any_cast<string>(b));\n    }\n    \n    // Compare the values\n    if (fa > fb) return a;\n    else if (fb > fa) return b;\n    else return string(\"None\");\n}\n\n"}
{"task_id": "CPP/138", "generation": "#include<iostream>\nusing namespace std;\n\nbool is_equal_to_sum_even(int n) {\n    // Check if n is at least 8 and if (n - 8) is divisible by 2.\n    return n >= 8 && (n % 2 == 0);\n}\n\n"}
{"task_id": "CPP/139", "generation": "#include <iostream>\nusing namespace std;\n\n// Function to calculate factorial of a number\nlong long factorial(int num) {\n    if (num == 0 || num == 1)\n        return 1;\n    else\n        return num * factorial(num - 1);\n}\n\n// Function to calculate the Brazilian factorial as defined\nlong long special_factorial(int n){\n    long long result = 1;\n    for (int i = n; i > 0; --i) {\n        result *= factorial(i);\n    }\n    return result;\n}\n\n"}
{"task_id": "CPP/140", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring fix_spaces(string text) {\n    string result;\n    int spaceCount = 0; // To count consecutive spaces\n\n    for (char c : text) {\n        if (c == ' ') {\n            ++spaceCount;\n        } else {\n            if (spaceCount > 2) { // More than two consecutive spaces\n                result += '-';\n            } else if (spaceCount > 0) { // One or two consecutive spaces\n                for (int i = 0; i < spaceCount; ++i) {\n                    result += '_';\n                }\n            }\n            spaceCount = 0;\n            result += c;\n        }\n    }\n\n    // Handle trailing spaces\n    if (spaceCount > 2) {\n        result += '-';\n    } else if (spaceCount > 0) {\n        for (int i = 0; i < spaceCount; ++i) {\n            result += '_';\n        }\n    }\n\n    return result;\n}\n\n// Function to test the fix_spaces function\nvoid check() {\n    assert(fix_spaces(\"Example\") == \"Example\");\n    assert(fix_spaces(\"Example 1\") == \"Example_1\");\n    assert(fix_spaces(\" Example 2\") == \"_Example_2\");\n    assert(fix_spaces(\" Example   3\") == \"_Example-3\");\n\n    cout << \"All tests passed successfully.\" << endl;\n}\n\n"}
{"task_id": "CPP/141", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool isValidExtension(const string& ext) {\n    return (ext == \"txt\" || ext == \"exe\" || ext == \"dll\");\n}\n\nint countDigitsBeforeDot(const string& name, size_t dotPos) {\n    int digitCount = 0;\n    for(size_t i = 0; i < dotPos; ++i) {\n        if(isdigit(name[i])) {\n            ++digitCount;\n        }\n    }\n    return digitCount;\n}\n\nstring file_name_check(string file_name){\n    // Check for exactly one dot\n    size_t dotPosition = file_name.find('.');\n    if(dotPosition == string::npos || file_name.find('.', dotPosition + 1) != string::npos) {\n        return \"No\";\n    }\n\n    // Validate the substring before the dot\n    if(dotPosition == 0 || !isalpha(file_name[0])) { \n        return \"No\"; // The name should start with a letter and not be empty.\n    }\n    \n    // Count digits in the part before the dot\n    int digitCount = countDigitsBeforeDot(file_name, dotPosition);\n    if(digitCount > 3) {\n        return \"No\";\n    }\n\n    // Validate the extension after the dot\n    string ext = file_name.substr(dotPosition + 1);\n    if(!isValidExtension(ext)) {\n        return \"No\";\n    }\n    \n    return \"Yes\";\n}\n\n"}
{"task_id": "CPP/142", "generation": "#include <vector>\nusing namespace std;\n\nint sum_squares(vector<int> lst) {\n    int sum = 0;\n    \n    for (size_t i = 0; i < lst.size(); ++i) {\n        if (i % 3 == 0 && i % 4 != 0) { // Index is a multiple of 3 but not 4\n            sum += lst[i] * lst[i]; // Square the element and add to sum\n        } else if (i % 4 == 0) { // Index is a multiple of 4\n            sum += lst[i] * lst[i] * lst[i]; // Cube the element and add to sum\n        } else {\n            sum += lst[i]; // Add the element as it is\n        }\n    }\n\n    return sum;\n}\n"}
{"task_id": "CPP/143", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\n// Function to extract words with prime length from the sentence\nstring words_in_sentence(string sentence) {\n    stringstream ss(sentence);\n    string word, result;\n    \n    while (ss >> word) { // Extract each word\n        if (is_prime(word.length())) { // Check if its length is a prime number\n            if (!result.empty()) result += \" \"; // Add space before the next word if it's not the first one\n            result += word; // Append the word to the result string\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/144", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\nusing namespace std;\n\n// Function to parse fractions from strings and return numerator and denominator.\npair<int, int> parseFraction(const string& fraction) {\n    stringstream ss(fraction);\n    string part;\n    getline(ss, part, '/');\n    int numerator = stoi(part);\n    getline(ss, part, '/');\n    int denominator = stoi(part);\n    return {numerator, denominator};\n}\n\n// Function to simplify the multiplication of two fractions and check if it's a whole number.\nbool simplify(string x, string n) {\n    // Parse both fractions\n    auto [x_numerator, x_denominator] = parseFraction(x);\n    auto [n_numerator, n_denominator] = parseFraction(n);\n\n    // Multiply numerators and denominators separately\n    int result_numerator = x_numerator * n_numerator;\n    int result_denominator = x_denominator * n_denominator;\n\n    // Check if the resulting fraction is a whole number (denominator should be 1 after simplification)\n    return result_numerator % result_denominator == 0;\n}\n\n"}
{"task_id": "CPP/145", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\n// Helper function to calculate the sum of digits of an integer\nint sum_of_digits(int num) {\n    int sum = 0;\n    while (num != 0) {\n        sum += num % 10;\n        num /= 10;\n    }\n    return sum;\n}\n\nvector<int> order_by_points(vector<int> nums) {\n    // Create a vector of pairs to store the original index and value\n    std::vector<std::pair<int, int>> indexed_nums(nums.size());\n    \n    for (size_t i = 0; i < nums.size(); ++i) {\n        indexed_nums[i] = {sum_of_digits(nums[i]), static_cast<int>(i)};\n    }\n    \n    // Sort the vector of pairs by sum of digits and then by original index\n    std::stable_sort(indexed_nums.begin(), indexed_nums.end(),\n                     [](const std::pair<int, int>& a, const std::pair<int, int>& b) {\n                         if (a.first == b.first) return a.second < b.second;\n                         else return a.first < b.first;\n                     });\n    \n    // Reconstruct the sorted vector of integers\n    std::vector<int> result(nums.size());\n    for (size_t i = 0; i < indexed_nums.size(); ++i) {\n        result[i] = nums[indexed_nums[i].second];\n    }\n    \n    return result;\n}\n\n// Function to check if the function works as expected\nvoid check() {\n    std::vector<int> test1 = {1, 11, -1, -11, -12};\n    std::vector<int> expected1 = {-1, -11, 1, -12, 11};\n    assert(order_by_points(test1) == expected1);\n\n    std::vector<int> test2 = {};\n    std::vector<int> expected2 = {};\n    assert(order_by_points(test2) == expected2);\n    \n    std::cout << \"All tests passed successfully.\" << std::endl;\n}\n\n"}
{"task_id": "CPP/146", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nint specialFilter(vector<int> nums) {\n    int count = 0;\n    \n    for (auto num : nums) {\n        if (num > 10) { // Check if the number is greater than 10\n            string strNum = to_string(abs(num)); // Convert number to string and take absolute value\n            \n            char firstDigit = strNum[0]; // First digit of the number\n            char lastDigit = strNum[strNum.length() - 1]; // Last digit of the number\n            \n            if ((firstDigit == '1' || firstDigit == '3' || firstDigit == '5' || \n                 firstDigit == '7' || firstDigit == '9') &&\n                (lastDigit == '1' || lastDigit == '3' || lastDigit == '5' ||\n                 lastDigit == '7' || lastDigit == '9')) {\n                count++; // Increment count if both conditions are met\n            }\n        }\n    }\n    \n    return count;\n}\n\n"}
{"task_id": "CPP/147", "generation": "#include<iostream>\n#include<vector>\nusing namespace std;\n\nint get_max_triples(int n) {\n    vector<int> a(n);\n    \n    // Generate the array based on the formula i * i - i + 1\n    for (int i = 0; i < n; ++i) {\n        a[i] = (i+1)*(i+1) - (i+1) + 1;\n    }\n    \n    int count = 0;\n    \n    // Count the number of valid triples\n    for (int i = 0; i < n-2; ++i) {\n        for (int j = i+1; j < n-1; ++j) {\n            for (int k = j+1; k < n; ++k) {\n                if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                    count++;\n                }\n            }\n        }\n    }\n    \n    return count;\n}\n\n// Function to test the solution\nvoid check_solution() {\n    int n = 5;\n    cout << \"Input: n = \" << n << endl;\n    cout << \"Output: \" << get_max_triples(n) << endl; // Expected output is 1\n    \n    n = 6;\n    cout << \"Input: n = \" << n << endl;\n    cout << \"Output: \" << get_max_triples(n) << endl; // Expected output based on the formula\n}\n\n"}
{"task_id": "CPP/148", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> bf(string planet1, string planet2) {\n    // List of planets in order from closest to farthest from the Sun.\n    vector<string> planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n    \n    int index1 = -1, index2 = -1;\n    \n    // Find indices of planet1 and planet2\n    for (int i = 0; i < planets.size(); ++i) {\n        if (planets[i] == planet1)\n            index1 = i;\n        else if (planets[i] == planet2)\n            index2 = i;\n        \n        // If both indices are found, break the loop\n        if (index1 != -1 && index2 != -1)\n            break;\n    }\n    \n    // Check if either of the planets was not found in the list.\n    if (index1 == -1 || index2 == -1) {\n        return {};  // Return an empty vector if any planet is invalid\n    }\n\n    // Ensure index1 < index2 for simplicity\n    if (index1 > index2)\n        swap(index1, index2);\n    \n    // Collect and return the planets between them.\n    vector<string> result;\n    for (int i = index1 + 1; i < index2; ++i) {\n        result.push_back(planets[i]);\n    }\n    \n    return result;\n}\n\n// Function to test the bf function\nvoid check() {\n    auto res1 = bf(\"Jupiter\", \"Neptune\");\n    cout << \"{\";\n    for (const auto& planet : res1)\n        cout << \"\\\"\" << planet << \"\\\", \";\n    cout << \"}\\n\";\n\n    auto res2 = bf(\"Earth\", \"Mercury\");\n    cout << \"{\";\n    for (const auto& planet : res2)\n        cout << \"\\\"\" << planet << \"\\\", \";\n    cout << \"}\\n\";\n\n    auto res3 = bf(\"Mercury\", \"Uranus\");\n    cout << \"{\";\n    for (const auto& planet : res3)\n        cout << \"\\\"\" << planet << \"\\\", \";\n    cout << \"}\\n\";\n}\n\n"}
{"task_id": "CPP/149", "generation": "#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to filter out strings of odd length and sort the rest.\nvector<string> vector_sort(vector<string> lst) {\n    // Remove elements with odd lengths.\n    lst.erase(remove_if(lst.begin(), lst.end(), [](const string& s){ return s.size() % 2 != 0; }), lst.end());\n    \n    // Sort by length, then alphabetically if lengths are equal.\n    sort(lst.begin(), lst.end(), [](const string& a, const string& b) {\n        if (a.length() == b.length()) {\n            return a < b;\n        }\n        return a.length() < b.length();\n    });\n    \n    return lst;\n}\n\n// Example usage and check function\nvoid assert_vector_sort(vector<string> input, vector<string> expected_output) {\n    auto result = vector_sort(input);\n    if (result == expected_output) {\n        printf(\"Test passed.\\n\");\n    } else {\n        printf(\"Test failed.\\n\");\n    }\n}\n\n"}
{"task_id": "CPP/150", "generation": "#include <iostream>\nusing namespace std;\n\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\nint x_or_y(int n, int x, int y){\n    if(is_prime(n)) {\n        return x;\n    } else {\n        return y;\n    }\n}\n\n// Function to test the correctness of the solution\nvoid check() {\n    cout << \"x_or_y(7, 34, 12) == \" << x_or_y(7, 34, 12) << endl; // Should output: 34\n    cout << \"x_or_y(15, 8, 5) == \" << x_or_y(15, 8, 5) << endl;   // Should output: 5\n}\n\n"}
{"task_id": "CPP/151", "generation": "#include <vector>\nusing namespace std;\n\nlong long double_the_difference(vector<float> lst) {\n    long long sum = 0;\n    \n    for (float num : lst) {\n        // Check if number is positive, an integer and odd.\n        if (num > 0 && floor(num) == num && static_cast<int>(num) % 2 != 0) {\n            sum += pow(static_cast<long long>(num), 2);\n        }\n    }\n\n    return sum;\n}\n"}
{"task_id": "CPP/152", "generation": "#include <iostream>\n#include <vector>\n#include <cmath> // For std::abs\n\nusing namespace std;\n\n// Function to compare scores and guesses, returning a vector of differences.\nvector<int> compare(vector<int> game, vector<int> guess) {\n    vector<int> result;\n    \n    for (size_t i = 0; i < game.size(); ++i) {\n        // Calculate the absolute difference between each score and its corresponding guess\n        int diff = abs(game[i] - guess[i]);\n        result.push_back(diff);\n    }\n    \n    return result;\n}\n\n// Function to test the compare function with given data points.\nvoid check() {\n    vector<int> game1 = {1, 2, 3, 4, 5, 1};\n    vector<int> guess1 = {1, 2, 3, 4, 2, -2};\n    vector<int> expected1 = {0, 0, 0, 0, 3, 3};\n    \n    vector<int> game2 = {0, 5, 0, 0, 0, 4};\n    vector<int> guess2 = {4, 1, 1, 0, 0, -2};\n    vector<int> expected2 = {4, 4, 1, 0, 0, 6};\n\n    assert(compare(game1, guess1) == expected1);\n    assert(compare(game2, guess2) == expected2);\n\n    cout << \"All tests passed successfully.\" << endl;\n}\n\n"}
{"task_id": "CPP/153", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to calculate the strength of an extension.\nint CalculateStrength(const string& extension) {\n    int cap = 0, sm = 0;\n    for (char c : extension) {\n        if (isupper(c)) ++cap; // Count uppercase letters\n        else if (islower(c)) ++sm; // Count lowercase letters\n    }\n    return cap - sm; // Calculate strength as per the given formula.\n}\n\nstring Strongest_Extension(string class_name, vector<string> extensions) {\n    string strongest_extension = \"\";\n    int max_strength = INT_MIN;\n\n    for (const auto& ext : extensions) {\n        int strength = CalculateStrength(ext);\n        if (strength > max_strength || (strength == max_strength && strongest_extension.empty())) {\n            max_strength = strength;\n            strongest_extension = ext;\n        }\n    }\n\n    return class_name + \".\" + strongest_extension;\n}\n\n"}
{"task_id": "CPP/154", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool cycpattern_check(string a, string b) {\n    // Concatenate the first string with itself.\n    string aa = a + a;\n    \n    // Check if b is a substring of aa.\n    return aa.find(b) != string::npos && b.length() <= a.length();\n}\n\n"}
{"task_id": "CPP/155", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<int> even_odd_count(int num) {\n    // Convert the number to its absolute value to handle negative numbers.\n    int abs_num = abs(num);\n    \n    // Convert the integer to a string for easy digit access.\n    string str_num = to_string(abs_num);\n\n    // Initialize counters for even and odd digits.\n    int even_count = 0;\n    int odd_count = 0;\n\n    // Iterate over each character in the string representation of the number.\n    for (char &c : str_num) {\n        // Convert char digit back to integer and check if it's even or odd.\n        int digit = c - '0';\n        if (digit % 2 == 0) {\n            ++even_count;\n        } else {\n            ++odd_count;\n        }\n    }\n\n    // Return a vector containing the counts of even and odd digits respectively.\n    return {even_count, odd_count};\n}\n\n// Function to test the solution with given examples\nvoid check() {\n    auto result = even_odd_count(-12);\n    cout << \"Even: \" << result[0] << \", Odd: \" << result[1] << endl; // Expected: Even: 1, Odd: 1\n\n    result = even_odd_count(123);\n    cout << \"Even: \" << result[0] << \", Odd: \" << result[1] << endl; // Expected: Even: 1, Odd: 2\n}\n\n"}
{"task_id": "CPP/156", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring int_to_mini_roman(int number) {\n    // Define Roman numeral symbols and their corresponding values.\n    vector<pair<int, string>> roman = {\n        {1000, \"m\"}, {900, \"cm\"}, {500, \"d\"}, {400, \"cd\"},\n        {100, \"c\"}, {90, \"xc\"}, {50, \"l\"}, {40, \"xl\"},\n        {10, \"x\"}, {9, \"ix\"}, {5, \"v\"}, {4, \"iv\"}, {1, \"i\"}\n    };\n    \n    string result = \"\";\n    \n    // Iterate through each Roman numeral symbol and its value.\n    for (auto& item : roman) {\n        while (number >= item.first) {\n            number -= item.first;\n            result += item.second;\n        }\n    }\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/157", "generation": "#include <iostream>\n#include <cmath> // For std::pow and std::sqrt\n\nbool right_angle_triangle(float a, float b, float c) {\n    // First, sort the sides to ensure that 'c' is the longest side.\n    if (a > c) std::swap(a, c);\n    if (b > c) std::swap(b, c);\n\n    // Check the Pythagorean theorem: a^2 + b^2 = c^2\n    return std::abs(std::pow(a, 2) + std::pow(b, 2) - std::pow(c, 2)) < 1e-6;\n}\n\n"}
{"task_id": "CPP/158", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <set>\n#include <algorithm>\n\nusing namespace std;\n\nstring find_max(vector<string> words) {\n    string maxWord = \"\";\n    size_t maxUniqueChars = 0;\n    \n    for (const auto& word : words) {\n        set<char> uniqueChars(word.begin(), word.end());\n        \n        // If this word has more unique characters than the current maximum,\n        // or if it has the same number but comes first lexicographically\n        if (uniqueChars.size() > maxUniqueChars ||\n            (uniqueChars.size() == maxUniqueChars && word < maxWord)) {\n            maxUniqueChars = uniqueChars.size();\n            maxWord = word;\n        }\n    }\n    \n    return maxWord;\n}\n\n"}
{"task_id": "CPP/159", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> eat(int number, int need, int remaining) {\n    // Total number of carrots needed including those already eaten\n    int totalNeeded = number + need;\n    \n    // If there are enough carrots in stock to satisfy the need\n    if (remaining >= need) {\n        return {totalNeeded, remaining - need};\n    } else {\n        // Eat all remaining carrots and adjust the total eaten accordingly\n        return {number + remaining, 0};\n    }\n}\n"}
{"task_id": "CPP/160", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nint do_algebra(vector<string> operato, vector<int> operand) {\n    // Initialize result with the first operand.\n    int result = operand[0];\n    \n    // Iterate through each operator and apply it to the next operand.\n    for (size_t i = 0; i < operato.size(); ++i) {\n        if (operato[i] == \"+\") {\n            result += operand[i + 1];\n        } else if (operato[i] == \"-\") {\n            result -= operand[i + 1];\n        } else if (operato[i] == \"*\") {\n            result *= operand[i + 1];\n        } else if (operato[i] == \"//\") {\n            result /= operand[i + 1]; // Floor division\n        } else if (operato[i] == \"**\") {\n            result = pow(result, operand[i + 1]);\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/161", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool containsLetters(const string& s) {\n    for(char c : s) {\n        if(isalpha(c)) return true;\n    }\n    return false;\n}\n\nstring solve(string s){\n    // Check if the string contains any letters.\n    bool hasLetters = containsLetters(s);\n    \n    if (!hasLetters) {\n        // If no letters are found, reverse the entire string.\n        reverse(s.begin(), s.end());\n        return s;\n    }\n\n    for (char &c : s) {\n        if(isalpha(c)) {  // Check if c is a letter\n            if(islower(c))\n                c = toupper(c);  // Convert to upper case\n            else\n                c = tolower(c);  // Convert to lower case\n        }\n    }\n\n    return s;\n}\n\n"}
{"task_id": "CPP/162", "generation": "#include <iostream>\n#include <string>\n#include <openssl/md5.h>\n\nusing namespace std;\n\nstring string_to_md5(string text) {\n    if (text.empty()) return \"None\"; // Return \"None\" for empty strings\n\n    unsigned char digest[MD5_DIGEST_LENGTH];\n    MD5((unsigned char*)text.c_str(), text.length(), (unsigned char*)&digest); // Calculate the hash\n\n    char mdString[33]; // Buffer to hold the hexadecimal representation\n    for(int i = 0; i < 16; ++i)\n        sprintf(&mdString[i*2], \"%02x\", (unsigned int)digest[i]); // Convert each byte to hex format\n\n    return string(mdString); // Return the hash as a string\n}\n\n"}
{"task_id": "CPP/163", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> generate_integers(int a, int b) {\n    // Ensure that start <= end for iteration purposes.\n    int start = min(a, b);\n    int end = max(a, b);\n\n    vector<int> result;\n    \n    // Iterate through all even digits and check if they are within the range\n    for (int digit : {2, 4, 6, 8}) {\n        if (digit >= start && digit <= end) {\n            result.push_back(digit);\n        }\n    }\n\n    return result;\n}\n\n// Function to print vector elements\nvoid print_vector(const vector<int>& vec) {\n    cout << \"{\";\n    for (size_t i = 0; i < vec.size(); ++i) {\n        if (i > 0) cout << \", \";\n        cout << vec[i];\n    }\n    cout << \"}\" << endl;\n}\n\n"}
{"task_id": "CPP/0", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // For std::sort\n\nusing namespace std;\n\nbool has_close_elements(vector<float> numbers, float threshold) {\n    // Sort the vector to make it easier to find close elements.\n    sort(numbers.begin(), numbers.end());\n    \n    // Iterate through the sorted list and check if any two consecutive\n    // elements are closer than the given threshold.\n    for (size_t i = 0; i < numbers.size() - 1; ++i) {\n        if (numbers[i + 1] - numbers[i] < threshold) {\n            return true;\n        }\n    }\n    \n    return false;\n}\n\n"}
{"task_id": "CPP/1", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> separate_paren_groups(string paren_string) {\n    vector<string> result;\n    string current_group = \"\";\n    int balance = 0;\n\n    // Remove spaces from the input string.\n    paren_string.erase(remove(paren_string.begin(), paren_string.end(), ' '), paren_string.end());\n\n    for (char c : paren_string) {\n        if (c == '(') {\n            ++balance;  // Increase balance when an open parenthesis is found\n        } else if (c == ')') {\n            --balance;  // Decrease balance when a close parenthesis is found\n        }\n        \n        current_group += c;\n\n        // When the balance returns to zero, we've completed a group.\n        if (balance == 0 && !current_group.empty()) {\n            result.push_back(current_group);\n            current_group = \"\";  // Reset for the next group\n        }\n    }\n\n    return result;\n}\n\n// Function to test the solution with given examples\nvoid check() {\n    vector<string> res1 = separate_paren_groups(\"( ) (( )) (( )( ))\");\n    assert((res1 == vector<string>{\"()\", \"(())\", \"(()())\"}));\n\n    // Additional checks can be added here\n\n    cout << \"All tests passed successfully.\" << endl;\n}\n\n"}
{"task_id": "CPP/2", "generation": "#include<stdio.h>\n#include<math.h>\n\nfloat truncate_number(float number){\n    float intPart;\n    // Use modf function which splits the number into an integral and a fractional part.\n    // The integral part is stored in intPart, and the function returns the fractional part.\n    return modf(number, &intPart);\n}\n\n// Function to test the correctness of truncate_number\nvoid check() {\n    printf(\"Testing with 3.5: Expected 0.5, Got %.1f\\n\", truncate_number(3.5));\n    printf(\"Testing with 4.75: Expected 0.75, Got %.2f\\n\", truncate_number(4.75));\n}\n\n"}
{"task_id": "CPP/3", "generation": "#include <vector>\nusing namespace std;\n\nbool below_zero(vector<int> operations) {\n    int balance = 0; // Start with a zero balance\n\n    for (int op : operations) { // Iterate through each operation\n        balance += op; // Update the balance by adding or subtracting the current operation value\n        if (balance < 0) { // Check if balance falls below zero\n            return true;\n        }\n    }\n\n    return false; // Return false if no point in time the balance was below zero\n}\n\n// Example usage:\n"}
{"task_id": "CPP/4", "generation": "#include <iostream>\n#include <vector>\n#include <numeric> // for std::accumulate\n#include <cmath>   // for std::abs\n\nusing namespace std;\n\nfloat mean_absolute_deviation(vector<float> numbers) {\n    if (numbers.empty()) return 0.0f; // Handle empty vector case\n    \n    float sum = accumulate(numbers.begin(), numbers.end(), 0.0f);\n    float mean = sum / numbers.size();\n    \n    float mad_sum = 0.0f;\n    for (float num : numbers) {\n        mad_sum += abs(num - mean); // Calculate the absolute difference and add to sum\n    }\n    \n    return mad_sum / numbers.size(); // Average of all absolute differences\n}\n\n"}
{"task_id": "CPP/5", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvector<int> intersperse(vector<int> numbers, int delimeter) {\n    // If the input vector is empty or has only one element, return it as is.\n    if (numbers.size() <= 1) {\n        return numbers;\n    }\n\n    vector<int> result;\n    \n    // Iterate through all but the last element of `numbers`.\n    for(size_t i = 0; i < numbers.size() - 1; ++i) {\n        result.push_back(numbers[i]);\n        result.push_back(delimeter);\n    }\n    \n    // Add the last element without a delimiter after it.\n    result.push_back(numbers.back());\n    \n    return result;\n}\n\n// Function to print vector for testing purposes\nvoid printVector(const vector<int>& v) {\n    cout << \"{\";\n    for(size_t i = 0; i < v.size(); ++i) {\n        if (i != 0) cout << \", \";\n        cout << v[i];\n    }\n    cout << \"}\" << endl;\n}\n\n"}
{"task_id": "CPP/6", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<int> parse_nested_parens(string paren_string) {\n    vector<int> max_depths;\n    int current_depth = 0, max_depth = 0;\n\n    for (char c : paren_string) {\n        if (c == '(') { // Increase depth\n            current_depth++;\n            max_depth = max(max_depth, current_depth);\n        } else if (c == ')') { // Decrease depth\n            current_depth--;\n        } else if (c == ' ') { // Space indicates the end of a group\n            if (max_depth > 0) {\n                max_depths.push_back(max_depth);\n                max_depth = 0; // Reset for next group\n            }\n            current_depth = 0;\n        }\n    }\n\n    // Add last group's depth if it exists and is not already added due to trailing space\n    if (max_depth > 0) {\n        max_depths.push_back(max_depth);\n    }\n\n    return max_depths;\n}\n\n"}
{"task_id": "CPP/7", "generation": "#include <vector>\n#include <string>\nusing namespace std;\n\nbool containsSubstring(const string& str, const string& substr) {\n    return str.find(substr) != string::npos;\n}\n\nvector<string> filter_by_substring(vector<string> strings, string substring){\n    vector<string> result;\n    \n    for (const auto& s : strings) {\n        if (containsSubstring(s, substring)) {\n            result.push_back(s);\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/8", "generation": "#include <iostream>\n#include <vector>\n#include <utility> // for std::pair\n\nusing namespace std;\n\n// Function to calculate sum and product of all elements in the vector.\nstd::pair<int, int> sum_product(const vector<int>& numbers) {\n    int sum = 0;\n    int product = 1; // Start with 1 because multiplying by 0 would result in 0.\n\n    for (int num : numbers) {\n        sum += num;\n        product *= num;\n    }\n\n    return std::make_pair(sum, product);\n}\n\n// Function to test the correctness of the sum_product function.\nvoid check() {\n    auto result = sum_product({});\n    cout << \"(\" << result.first << \", \" << result.second << \")\" << endl; // Expected: (0, 1)\n\n    result = sum_product({1, 2, 3, 4});\n    cout << \"(\" << result.first << \", \" << result.second << \")\" << endl; // Expected: (10, 24)\n}\n\n"}
{"task_id": "CPP/9", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> rolling_max(vector<int> numbers) {\n    if (numbers.empty()) return {}; // Handle empty input\n\n    vector<int> max_values;\n    int current_max = numbers[0]; // Initialize with the first element\n    \n    for (int num : numbers) {\n        if (num > current_max) {\n            current_max = num; // Update maximum\n        }\n        max_values.push_back(current_max); // Add current maximum to result vector\n    }\n\n    return max_values;\n}\n\n// Function to test the rolling_max function with a given input and expected output.\nvoid check_rolling_max() {\n    vector<int> input = {1, 2, 3, 2, 3, 4, 2};\n    vector<int> expected_output = {1, 2, 3, 3, 3, 4, 4};\n    vector<int> output = rolling_max(input);\n\n    if (output == expected_output) {\n        cout << \"Test passed.\" << endl;\n    } else {\n        cout << \"Test failed.\" << endl;\n    }\n}\n\n"}
{"task_id": "CPP/10", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_palindrome(string str) {\n    // Test if given string is a palindrome \n    string s(str.rbegin(), str.rend());\n    return s == str;\n}\n\nstring make_palindrome(string str) {\n    /*\n    Find the shortest palindrome that begins with a supplied string. \n    Algorithm idea is simple: - Find the longest postfix of supplied string that is a palindrome. \n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome(\"\") \n    \"\" \n    >>> make_palindrome(\"cat\") \n    \"catac\" \n    >>> make_palindrome(\"cata\") \n    \"catac\" \n    */\n    \n    if (str.empty()) return str; // If string is empty, return it as is.\n    \n    int n = str.length();\n    for (int i = 0; i < n; ++i) {\n        string suffix = str.substr(i);\n        if (is_palindrome(suffix)) {\n            // Found the longest palindromic suffix\n            string prefix_to_reverse = str.substr(0, i); \n            reverse(prefix_to_reverse.begin(), prefix_to_reverse.end());\n            return str + prefix_to_reverse;\n        }\n    }\n\n    // If no palindrome is found in a substring (which shouldn't happen), just append the whole reversed string.\n    string reversed_str(str.rbegin(), str.rend());\n    return str + reversed_str;\n}\n\n"}
{"task_id": "CPP/11", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring string_xor(string a, string b) {\n    // Ensure both strings are of equal length by padding with leading zeros if necessary.\n    while (a.length() > b.length()) b = '0' + b;\n    while (b.length() > a.length()) a = '0' + a;\n\n    string result = \"\";  // Initialize the result string\n\n    // Iterate through each character of both strings\n    for(size_t i = 0; i < a.length(); ++i) {\n        // Perform XOR operation on corresponding characters and append to result.\n        if (a[i] == b[i]) {\n            result += '0';  // If the same, XOR is 0\n        } else {\n            result += '1';  // If different, XOR is 1\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/12", "generation": "#include <vector>\n#include <string>\nusing namespace std;\n\nstring longest(vector<string> strings) {\n    // Check if the input vector is empty\n    if (strings.empty()) return \"\";  // or you can throw an exception, depending on your preference\n\n    string longestString = \"\";\n    \n    for (const auto& str : strings) {\n        // Update longestString if a longer string is found\n        if (str.length() > longestString.length()) {\n            longestString = str;\n        }\n    }\n\n    return longestString;\n}\n"}
{"task_id": "CPP/13", "generation": "#include<stdio.h>\n\nint greatest_common_divisor(int a, int b){\n    while(b != 0){\n        int temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n\n// Function to test the GCD function with given data points.\nvoid check_gcd(){\n    printf(\"GCD of 3 and 5 is: %d\\n\", greatest_common_divisor(3, 5)); // Expected output: 1\n    printf(\"GCD of 25 and 15 is: %d\\n\", greatest_common_divisor(25, 15)); // Expected output: 5\n}\n\n"}
{"task_id": "CPP/14", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> all_prefixes(string str) {\n    vector<string> prefixes;\n    for (size_t i = 1; i <= str.size(); ++i) {\n        // Construct the prefix from the beginning of the string up to index `i`\n        prefixes.push_back(str.substr(0, i));\n    }\n    return prefixes;\n}\n\n// Example usage\n"}
{"task_id": "CPP/15", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nstring string_sequence(int n) {\n    string result = \"\";\n    \n    for (int i = 0; i <= n; ++i) {\n        // Convert the number to a string and append it.\n        result += to_string(i);\n        \n        // Add space after each number except the last one\n        if (i < n) {\n            result += \" \";\n        }\n    }\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/16", "generation": "#include <iostream>\n#include <string>\n#include <set>\n#include <algorithm> // for std::transform\n\nusing namespace std;\n\nint count_distinct_characters(string str) {\n    transform(str.begin(), str.end(), str.begin(), ::tolower); // Convert all characters to lowercase\n    \n    set<char> uniqueChars;\n    \n    for (char c : str) {\n        uniqueChars.insert(c);\n    }\n    \n    return uniqueChars.size();\n}\n\n// Example usage\n"}
{"task_id": "CPP/17", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<int> parse_music(string music_string) {\n    vector<int> beats;\n    for (size_t i = 0; i < music_string.length(); ) {\n        if (music_string.substr(i, 2) == \"o|\") { // Check for half note\n            beats.push_back(2);\n            i += 2;\n        } else if (music_string[i] == 'o') { // Check for whole note\n            beats.push_back(4);\n            ++i; // Move past the 'o'\n        } else if (music_string.substr(i, 2) == \".|\") { // Check for quarter note\n            beats.push_back(1);\n            i += 2;\n        } else {\n            ++i; // Skip unrecognized characters or spaces\n        }\n    }\n    return beats;\n}\n\n"}
{"task_id": "CPP/18", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint how_many_times(string str, string substring) {\n    int count = 0;\n    size_t pos = 0; // Position to start searching for the substring\n\n    while ((pos = str.find(substring, pos)) != string::npos) { // Find the substring starting from 'pos'\n        ++count; // Increment count if found\n        ++pos;   // Move to the next position to allow overlapping matches\n    }\n\n    return count;\n}\n\n"}
{"task_id": "CPP/19", "generation": "#include <iostream>\n#include <string>\n#include <vector>\n#include <map>\n#include <sstream>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to map numeral words to numeric values.\nint getNumericValue(const string& numWord) {\n    static const map<string, int> numberMap = {\n        {\"zero\", 0}, {\"one\", 1}, {\"two\", 2}, {\"three\", 3},\n        {\"four\", 4}, {\"five\", 5}, {\"six\", 6}, {\"seven\", 7},\n        {\"eight\", 8}, {\"nine\", 9}\n    };\n    \n    return numberMap.at(numWord);\n}\n\n// Function to map numeric values back to numeral words.\nstring getNumeralWord(int num) {\n    static const map<int, string> reverseNumberMap = {\n        {0, \"zero\"}, {1, \"one\"}, {2, \"two\"}, {3, \"three\"},\n        {4, \"four\"}, {5, \"five\"}, {6, \"six\"}, {7, \"seven\"},\n        {8, \"eight\"}, {9, \"nine\"}\n    };\n    \n    return reverseNumberMap.at(num);\n}\n\nstring sort_numbers(string numbers) {\n    // Split the input string into individual words.\n    istringstream iss(numbers);\n    vector<string> numWords;\n    string word;\n    while (iss >> word) {\n        numWords.push_back(word);\n    }\n    \n    // Convert each numeral word to its numeric value and store in a new vector.\n    vector<int> nums;\n    for (const auto& w : numWords) {\n        nums.push_back(getNumericValue(w));\n    }\n\n    // Sort the numbers.\n    sort(nums.begin(), nums.end());\n\n    // Convert back to numeral words and join them into a single string.\n    ostringstream oss;\n    for (size_t i = 0; i < nums.size(); ++i) {\n        if (i != 0) {\n            oss << \" \";\n        }\n        oss << getNumeralWord(nums[i]);\n    }\n\n    return oss.str();\n}\n\n"}
{"task_id": "CPP/20", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // For std::sort\n\nusing namespace std;\n\npair<float, float> find_closest_elements(vector<float> numbers) {\n    if (numbers.size() < 2) {\n        throw invalid_argument(\"Vector must contain at least two elements.\");\n    }\n\n    sort(numbers.begin(), numbers.end()); // Sort the vector to make comparisons easier.\n\n    pair<float, float> closest_pair = {numbers[0], numbers[1]};\n    float min_diff = abs(closest_pair.second - closest_pair.first);\n\n    for (size_t i = 1; i < numbers.size() - 1; ++i) {\n        float diff = abs(numbers[i + 1] - numbers[i]);\n        if (diff < min_diff) {\n            min_diff = diff;\n            closest_pair = {numbers[i], numbers[i + 1]};\n        }\n    }\n\n    return closest_pair;\n}\n\n"}
{"task_id": "CPP/21", "generation": "#include <vector>\n#include <algorithm> // For std::min_element and std::max_element\n\nusing namespace std;\n\nvector<float> rescale_to_unit(vector<float> numbers) {\n    float min_val = *min_element(numbers.begin(), numbers.end());\n    float max_val = *max_element(numbers.begin(), numbers.end());\n\n    vector<float> scaled_numbers;\n    for (float num : numbers) {\n        // Apply the linear transformation\n        float scaled_num = (num - min_val) / (max_val - min_val);\n        scaled_numbers.push_back(scaled_num);\n    }\n\n    return scaled_numbers;\n}\n\n// Example usage:\n"}
{"task_id": "CPP/22", "generation": "#include <iostream>\n#include <vector>\n#include <list>\n#include <boost/any.hpp>\n\ntypedef std::list<boost::any> list_any;\n\nstd::vector<int> filter_integers(list_any values) {\n    std::vector<int> integers;\n    \n    for (auto& value : values) {\n        if (value.type() == typeid(int)) { // Check if the type is int\n            integers.push_back(boost::any_cast<int>(value)); // Cast and add to vector\n        }\n    }\n\n    return integers;\n}\n\n"}
{"task_id": "CPP/23", "generation": "#include <iostream>\n#include <string>\n\nint myStrlen(const std::string& str) {\n    return str.length();\n}\n\n"}
{"task_id": "CPP/24", "generation": "#include <iostream> // Corrected the include directive for standard input/output\n\nint largest_divisor(int n) {\n    for (int i = n - 1; i > 0; --i) { // Start from n-1 and go down to 1\n        if (n % i == 0) { // Check divisibility\n            return i; // Return the first divisor found\n        }\n    }\n    return 1; // If no divisor is found, return 1 (this case happens when n = 1)\n}\n\n"}
{"task_id": "CPP/25", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> factorize(int n) {\n    vector<int> factors;\n    \n    // Divide by 2 until odd\n    while (n % 2 == 0) {\n        factors.push_back(2);\n        n /= 2;\n    }\n    \n    // Check for odd factors from 3 onwards\n    for (int i = 3; i * i <= n; i += 2) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n    \n    // If n is a prime number greater than 2\n    if (n > 2) {\n        factors.push_back(n);\n    }\n\n    return factors;\n}\n\n// Function to test the factorize function with given data points.\nvoid check() {\n    vector<int> result;\n\n    result = factorize(8);\n    for(int i : result)\n        cout << i << \" \";\n    cout << endl; // Expected: 2 2 2\n\n    result = factorize(25);\n    for(int i : result)\n        cout << i << \" \";\n    cout << endl; // Expected: 5 5\n\n    result = factorize(70);\n    for(int i : result)\n        cout << i << \" \";\n    cout << endl; // Expected: 2 5 7\n}\n\n"}
{"task_id": "CPP/26", "generation": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nvector<int> remove_duplicates(vector<int> numbers){\n    // Create an unordered map to keep track of element counts.\n    unordered_map<int, int> countMap;\n    \n    // First pass: Count occurrences of each number.\n    for(int num : numbers) {\n        countMap[num]++;\n    }\n    \n    // Second pass: Collect elements that occur exactly once in the original order.\n    vector<int> result;\n    for(int num : numbers) {\n        if(countMap[num] == 1) {\n            result.push_back(num);\n        }\n    }\n    \n    return result;\n}\n\n// Function to print a vector\nvoid printVector(const vector<int>& vec){\n    cout << \"{\";\n    for(size_t i = 0; i < vec.size(); ++i){\n        if(i != 0) cout << \", \";\n        cout << vec[i];\n    }\n    cout << \"}\" << endl;\n}\n\n"}
{"task_id": "CPP/27", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring flip_case(string str) {\n    for (size_t i = 0; i < str.length(); ++i) {\n        if (islower(str[i])) {\n            // If the character is lowercase, convert it to uppercase.\n            str[i] = toupper(str[i]);\n        } else if (isupper(str[i])) {\n            // If the character is uppercase, convert it to lowercase.\n            str[i] = tolower(str[i]);\n        }\n    }\n    return str;\n}\n\n"}
{"task_id": "CPP/28", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring concatenate(vector<string> strings) {\n    // Initialize an empty string to hold the concatenated result.\n    string result = \"\";\n    \n    // Iterate through each element in the vector and append it to the result string.\n    for (const auto& str : strings) {\n        result += str;\n    }\n    \n    return result;\n}\n\n// Example usage\n"}
{"task_id": "CPP/29", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> filter_by_prefix(vector<string> strings, string prefix) {\n    vector<string> filteredStrings;\n    \n    for (const auto& str : strings) {\n        // Check if the current string starts with the given prefix.\n        if (str.find(prefix) == 0) { // find returns 0 if it starts with the prefix\n            filteredStrings.push_back(str);\n        }\n    }\n\n    return filteredStrings;\n}\n\n// Function to test the filter_by_prefix function\nvoid check() {\n    vector<string> result;\n\n    result = filter_by_prefix({}, \"a\");\n    cout << \"{\";\n    for (const auto& str : result) {\n        cout << \"\\\"\" << str << \"\\\", \";\n    }\n    cout << \"}\\n\";\n\n    result = filter_by_prefix({\"abc\", \"bcd\", \"cde\", \"vector\"}, \"a\");\n    cout << \"{\";\n    for (const auto& str : result) {\n        cout << \"\\\"\" << str << \"\\\", \";\n    }\n    cout << \"}\\n\";\n}\n\n"}
{"task_id": "CPP/30", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvector<float> get_positive(vector<float> l) {\n    vector<float> positiveNumbers; // Create an empty vector to store positive numbers\n    \n    for (float num : l) { // Iterate through each element in the input vector\n        if (num > 0) { // Check if the number is greater than zero\n            positiveNumbers.push_back(num); // Add it to the result vector\n        }\n    }\n    \n    return positiveNumbers; // Return the vector containing only positive numbers\n}\n\n// Function to test the get_positive function with some data points\nvoid check() {\n    vector<float> test1 = {-1, 2, -4, 5, 6};\n    vector<float> expected1 = {2, 5, 6};\n    \n    vector<float> result1 = get_positive(test1);\n    cout << \"Test 1: \";\n    if (result1 == expected1) {\n        cout << \"Passed\" << endl;\n    } else {\n        cout << \"Failed\" << endl;\n    }\n    \n    vector<float> test2 = {5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10};\n    vector<float> expected2 = {5, 3, 2, 3, 9, 123, 1};\n    \n    vector<float> result2 = get_positive(test2);\n    cout << \"Test 2: \";\n    if (result2 == expected2) {\n        cout << \"Passed\" << endl;\n    } else {\n        cout << \"Failed\" << endl;\n    }\n}\n\n"}
{"task_id": "CPP/31", "generation": "#include <cmath>\n\nbool is_prime(long long n) {\n    // Handle edge cases for numbers less than 2.\n    if (n <= 1) return false;\n    \n    // Check divisibility up to the square root of n.\n    for (long long i = 2; i <= std::sqrt(n); ++i) {\n        if (n % i == 0) return false;\n    }\n    \n    return true;\n}\n\n// Example usage\n"}
{"task_id": "CPP/32", "generation": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\ndouble poly(vector<double> xs, double x) {\n    /* \n    Evaluates polynomial with coefficients xs at point x. return xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n \n    */\n    double sum = 0;\n    int i;\n    for (i = 0; i < xs.size(); i++) {\n        sum += xs[i] * pow(x, i);\n    }\n    return sum;\n}\n\ndouble find_zero(vector<double> xs) {\n    /*\n    xs are coefficients of a polynomial. find_zero finds x such that poly(x) = 0.\n    It returns only one zero point, even if there are many.\n    Moreover, find_zero only takes list xs having an even number of coefficients and the largest non-zero coefficient as it guarantees a solution.\n\n    >>> round(find_zero({1, 2}), 2) // f(x) = 1 + 2x \n    -0.5\n    >>> round(find_zero({-6, 11, -6, 1}), 2) // (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3 \n    1.0\n    */\n\n    double a = -100; // Initial guess for the lower bound\n    double b = 100;  // Initial guess for the upper bound\n\n    if (poly(xs, a) * poly(xs, b) > 0) {\n        cout << \"The initial interval does not bracket a root.\" << endl;\n        return -1.0; // Return an error value\n    }\n\n    double c = a;\n\n    while ((b - a) >= 0.001) { // Tolerance for the bisection method\n        c = (a + b) / 2;\n\n        if (poly(xs, c) == 0.0)\n            break;\n        else if (poly(xs, c) * poly(xs, a) < 0)\n            b = c;\n        else\n            a = c;\n    }\n\n    return c; // Return the root found by the bisection method\n}\n\n"}
{"task_id": "CPP/33", "generation": "#include <vector>\n#include <algorithm> // for std::sort\n\nstd::vector<int> sort_third(std::vector<int> l) {\n    if (l.size() <= 2) return l; // If there are less than three elements, no index is divisible by 3.\n\n    std::vector<int> to_sort;\n    \n    // Collect all elements at indices divisible by three.\n    for(size_t i = 0; i < l.size(); i += 3) {\n        to_sort.push_back(l[i]);\n    }\n    \n    // Sort the collected elements.\n    std::sort(to_sort.begin(), to_sort.end());\n    \n    // Replace original elements with sorted ones.\n    for(size_t i = 0, j = 0; i < l.size() && j < to_sort.size(); i += 3, ++j) {\n        l[i] = to_sort[j];\n    }\n    \n    return l;\n}\n\n// Example usage\n#include <iostream>\n"}
{"task_id": "CPP/34", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> unique(vector<int> l) {\n    // Step 1: Sort the input vector\n    sort(l.begin(), l.end());\n    \n    // Step 2: Remove consecutive duplicates\n    auto last = unique(l.begin(), l.end());\n    \n    // Step 3: Resize to remove undefined trailing elements\n    l.erase(last, l.end());\n    \n    return l;\n}\n\n// Function to test the unique function\nvoid check() {\n    vector<int> input = {5, 3, 5, 2, 3, 3, 9, 0, 123};\n    vector<int> expected_output = {0, 2, 3, 5, 9, 123};\n    vector<int> output = unique(input);\n    \n    if (output == expected_output) {\n        cout << \"Test passed.\" << endl;\n    } else {\n        cout << \"Test failed.\" << endl;\n    }\n}\n\n"}
{"task_id": "CPP/35", "generation": "#include <vector>\n#include <algorithm> // for std::numeric_limits\n\nusing namespace std;\n\nfloat max_element(vector<float> l) {\n    if (l.empty()) {  // Check if the vector is empty to avoid undefined behavior.\n        throw runtime_error(\"The input vector cannot be empty.\");\n    }\n\n    float max_val = l[0];  // Initialize max_val with the first element of the vector.\n\n    for(size_t i = 1; i < l.size(); ++i) {  // Start loop from second element\n        if (l[i] > max_val) {\n            max_val = l[i];\n        }\n    }\n\n    return max_val;\n}\n\n// Example usage:\n"}
{"task_id": "CPP/36", "generation": "#include <iostream>\nusing namespace std;\n\nint fizz_buzz(int n) {\n    int count = 0;\n    \n    for (int i = 1; i < n; ++i) {\n        if ((i % 11 == 0 || i % 13 == 0)) { // Check divisibility by 11 or 13\n            int temp = i;\n            while (temp > 0) {\n                if (temp % 10 == 7) { // Check for digit '7'\n                    ++count;\n                }\n                temp /= 10; // Move to the next digit\n            }\n        }\n    }\n\n    return count;\n}\n\n"}
{"task_id": "CPP/37", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // for std::sort\n\nusing namespace std;\n\nvector<float> sort_even(vector<float> l) {\n    if (l.size() <= 1) return l; // If the vector is too small, just return it as-is.\n\n    vector<float> even_elements;\n    \n    // Extract elements at even indices.\n    for(size_t i = 0; i < l.size(); i += 2) {\n        even_elements.push_back(l[i]);\n    }\n    \n    // Sort the extracted elements.\n    sort(even_elements.begin(), even_elements.end());\n    \n    // Place sorted elements back into their original positions.\n    for(size_t i = 0, j = 0; i < l.size(); i += 2) {\n        l[i] = even_elements[j++];\n    }\n    \n    return l;\n}\n\n// Function to test the sort_even function\nvoid check() {\n    vector<float> v1 = {1, 2, 3};\n    vector<float> expected1 = {1, 2, 3};\n    assert(sort_even(v1) == expected1);\n\n    vector<float> v2 = {5, 6, 3, 4};\n    vector<float> expected2 = {3, 6, 5, 4};\n    assert(sort_even(v2) == expected2);\n    \n    cout << \"All tests passed successfully.\" << endl;\n}\n\n"}
{"task_id": "CPP/38", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\n// Function to encode a string by cycling groups of three characters.\nstring encode_cyclic(string s){ \n    // returns encoded string by cycling groups of three characters.  \n    int l = s.length();\n    string output;\n    for (int i = 0; i * 3 < l; i++) {\n        string x = s.substr(i * 3, 3);\n        if (x.length() == 3) x = x.substr(1) + x[0];\n        output += x;\n    }\n    return output;\n}\n\n// Function to decode a string encoded with encode_cyclic function.\nstring decode_cyclic(string s){ \n    int l = s.length();\n    string output;\n    for (int i = 0; i * 3 < l; i++) {\n        string x = s.substr(i * 3, 3);\n        if (x.length() == 3) x = x[2] + x.substr(0, 2); // Move the last character to the beginning\n        output += x;\n    }\n    return output;\n}\n\n"}
{"task_id": "CPP/39", "generation": "#include <iostream>\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    if (num == 2 || num == 3) return true;\n    if (num % 2 == 0 || num % 3 == 0) return false;\n\n    for (int i = 5; i * i <= num; i += 6) {\n        if (num % i == 0 || num % (i + 2) == 0)\n            return false;\n    }\n    return true;\n}\n\n// Function to generate the nth prime Fibonacci number\nint prime_fib(int n) {\n    int count = 0, fib1 = 0, fib2 = 1, fib_next;\n\n    while (true) {\n        // Generate next Fibonacci number\n        fib_next = fib1 + fib2;\n        fib1 = fib2;\n        fib2 = fib_next;\n\n        // Check if the generated Fibonacci number is prime\n        if (is_prime(fib_next)) {\n            count++;\n            if (count == n)\n                return fib_next;\n        }\n    }\n\n    return -1;  // This line should never be reached.\n}\n\n"}
{"task_id": "CPP/40", "generation": "#include <vector>\n#include <algorithm> // For std::sort\n\nbool triples_sum_to_zero(std::vector<int> l) {\n    int n = l.size();\n    \n    if (n < 3) return false; // If there are less than 3 elements, we can't find a triple.\n    \n    std::sort(l.begin(), l.end()); // Sort the vector to use two-pointer technique\n    \n    for(int i = 0; i < n-2; ++i) {\n        int left = i + 1;\n        int right = n - 1;\n        \n        while(left < right) {\n            int sum = l[i] + l[left] + l[right];\n            \n            if(sum == 0) return true; // Found a triple that sums to zero\n            \n            else if(sum < 0) ++left; // If the sum is less than zero, move left pointer to the right\n            else --right; // If the sum is greater than zero, move right pointer to the left\n        }\n    }\n    \n    return false; // No triple found that sums to zero\n}\n"}
{"task_id": "CPP/41", "generation": "#include <iostream> // Corrected the include statement for standard input/output\n\nint car_race_collision(int n) {\n    return n; // Since each of the n cars going left to right collides with one of the n cars going right to left.\n}\n\n// Example usage:\n"}
{"task_id": "CPP/42", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> incr_vector(vector<int> l) {\n    // Iterate over all elements of the vector.\n    for (size_t i = 0; i < l.size(); ++i) {\n        // Increment each element by 1.\n        l[i] += 1;\n    }\n    return l;\n}\n\n// Function to test the correctness of incr_vector function\nvoid check() {\n    vector<int> test1 = {1, 2, 3};\n    vector<int> expected1 = {2, 3, 4};\n    assert(incr_vector(test1) == expected1);\n\n    vector<int> test2 = {5, 3, 5, 2, 3, 3, 9, 0, 123};\n    vector<int> expected2 = {6, 4, 6, 3, 4, 4, 10, 1, 124};\n    assert(incr_vector(test2) == expected2);\n\n    cout << \"All tests passed successfully.\" << endl;\n}\n\n"}
{"task_id": "CPP/43", "generation": "#include <iostream>\n#include <vector>\n#include <unordered_set> // For using hash set\n\nusing namespace std;\n\nbool pairs_sum_to_zero(vector<int> l) {\n    unordered_set<int> seen;\n    \n    for (int num : l) {\n        if (seen.find(-num) != seen.end()) { // Check if the negation of current number exists in the set\n            return true; // Found a pair that sums to zero\n        }\n        seen.insert(num); // Add the current number to the set\n    }\n\n    return false; // No such pairs found\n}\n\n"}
{"task_id": "CPP/44", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring change_base(int x, int base){\n    if(base <= 1 || base >= 10)\n        throw invalid_argument(\"Base must be between 2 and 9.\");\n\n    string result = \"\";\n    \n    while (x > 0) {\n        int remainder = x % base;\n        // Convert the digit to its corresponding character\n        char digit_char = '0' + remainder;\n        result = digit_char + result; // Prepend the new digit to the result string\n        x /= base;\n    }\n    \n    return result.empty() ? \"0\" : result;\n}\n\n"}
{"task_id": "CPP/45", "generation": "#include<stdio.h>\n\nfloat triangle_area(float base, float height) {\n    return 0.5 * base * height;\n}\n\n"}
{"task_id": "CPP/46", "generation": "#include <iostream>\nusing namespace std;\n\nint fib4(int n) {\n    if (n == 0 || n == 1) return 0;\n    if (n == 2) return 2;\n    if (n == 3) return 0;\n\n    // Initialize the first four numbers of the sequence\n    int a = 0, b = 0, c = 2, d = 0;\n\n    for(int i = 4; i <= n; ++i) {\n        int next = a + b + c + d;\n        a = b;\n        b = c;\n        c = d;\n        d = next;\n    }\n\n    return d;\n}\n\n"}
{"task_id": "CPP/47", "generation": "#include <stdio.h>\n#include <math.h>\n#include <vector>\n#include <algorithm> // For std::sort\n\nusing namespace std;\n\nfloat median(vector<float> l) {\n    size_t n = l.size();\n    \n    // Sort the vector\n    sort(l.begin(), l.end());\n    \n    if (n % 2 == 0) { // Even number of elements\n        return (l[n/2 - 1] + l[n/2]) / 2.0;\n    } else { // Odd number of elements\n        return l[n/2];\n    }\n}\n\n// Example usage:\n"}
{"task_id": "CPP/48", "generation": "#include <iostream> // Corrected from #include<stdio.h>\n#include<string>\nusing namespace std;\n\nbool is_palindrome(string text) {\n    int left = 0;\n    int right = text.length() - 1;\n\n    while (left < right) {\n        if (text[left] != text[right]) {\n            return false; // Characters do not match, so it's not a palindrome\n        }\n        left++; \n        right--;\n    }\n\n    return true; // All characters matched, hence it is a palindrome\n}\n\n"}
{"task_id": "CPP/49", "generation": "#include <iostream>\nusing namespace std;\n\nint modp(int n, int p) {\n    // Base case: 2^0 % p = 1\n    if (n == 0)\n        return 1;\n    \n    long long result = 1; // Use long long to avoid overflow issues.\n    long long base = 2;   // The number we're raising to the power of n\n    \n    while (n > 0) {\n        // If n is odd, multiply the current result by the base\n        if (n % 2 == 1)\n            result = (result * base) % p;\n        \n        // Square the base and reduce modulo p for the next iteration\n        base = (base * base) % p;\n        \n        // Divide n by 2 for the next iteration\n        n /= 2;\n    }\n    \n    return static_cast<int>(result);\n}\n\n"}
{"task_id": "CPP/50", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\n// Function to encode a string by shifting every character by 5 positions.\nstring encode_shift(string s){\n    // returns encoded string by shifting every character by 5 in the alphabet.\n    string out;\n    for (int i = 0; i < s.length(); i++)\n    {\n        int w = ((int)s[i] - 'a' + 26 - 5) % 26 + 'a'; // Adjusting to handle negative values\n        out += (char)w;\n    }\n    return out;\n}\n\n// Function to decode a string encoded with encode_shift function.\nstring decode_shift(string s){\n    string out;\n    for (int i = 0; i < s.length(); i++)\n    {\n        int w = ((int)s[i] - 'a' + 26 - 5) % 26 + 'a'; // Adjusting to handle negative values\n        out += (char)w;\n    }\n    return out;\n}\n\n// Example usage:\n"}
{"task_id": "CPP/51", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nbool isVowel(char c) {\n    // Convert character to lowercase for simplicity.\n    char lower_c = tolower(c);\n    return (lower_c == 'a' || lower_c == 'e' || lower_c == 'i' || lower_c == 'o' || lower_c == 'u');\n}\n\nstring remove_vowels(string text) {\n    string result;\n    // Iterate through each character in the input string.\n    for(char c : text) {\n        if(!isVowel(c)) {  // If it's not a vowel, add to result.\n            result += c;\n        }\n    }\n    return result;\n}\n\n"}
{"task_id": "CPP/52", "generation": "#include <vector>\nusing namespace std;\n\nbool below_threshold(vector<int> l, int t) {\n    // Iterate through each element in the vector.\n    for (int num : l) {\n        // If any number is greater than or equal to the threshold, return false.\n        if (num >= t) {\n            return false;\n        }\n    }\n    // If all numbers are below the threshold, return true.\n    return true;\n}\n\n// Example usage:\n/*\nbool result1 = below_threshold({1, 2, 4, 10}, 100); // Should be true\nbool result2 = below_threshold({1, 20, 4, 10}, 5);   // Should be false\n*/\n"}
{"task_id": "CPP/53", "generation": "#include <iostream> // Correct header for input/output operations in C++\n\nint add(int x, int y) {\n    return x + y; // Simply adds two integers and returns the result\n}\n\n// Example usage:\n"}
{"task_id": "CPP/54", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool same_chars(string s0, string s1) {\n    // Boolean arrays to keep track of character presence.\n    bool chars_in_s0[256] = {false};  // Assuming ASCII characters\n    bool chars_in_s1[256] = {false};\n\n    // Mark the presence of each character in both strings.\n    for (char c : s0) {\n        chars_in_s0[c] = true;\n    }\n    for (char c : s1) {\n        chars_in_s1[c] = true;\n    }\n\n    // Compare the two boolean arrays to check if they have the same set of characters.\n    for (int i = 0; i < 256; ++i) {\n        if (chars_in_s0[i] != chars_in_s1[i]) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n\n// Function to test the solution with given examples\nvoid check() {\n    cout << boolalpha; // Print 'true' or 'false'\n    cout << same_chars(\"eabcdzzzz\", \"dddzzzzzzzddeddabc\") << endl;  // Expected: true\n    cout << same_chars(\"abcd\", \"dddddddabc\") << endl;               // Expected: true\n    cout << same_chars(\"dddddddabc\", \"abcd\") << endl;               // Expected: true\n    cout << same_chars(\"eabcd\", \"dddddddabc\") << endl;              // Expected: false\n    cout << same_chars(\"abcd\", \"dddddddabce\") << endl;              // Expected: false\n    cout << same_chars(\"eabcdzzzz\", \"dddzzzzzzzddddabc\") << endl;   // Expected: false\n}\n\n"}
{"task_id": "CPP/55", "generation": "#include<iostream>\nusing namespace std;\n\nint fib(int n) {\n    if (n <= 1)\n        return n;\n    else\n        return fib(n-1) + fib(n-2);\n}\n\n"}
{"task_id": "CPP/56", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    int balance = 0; // Initialize balance\n\n    for (char c : brackets) { // Iterate through each character in the string\n        if (c == '<') {\n            ++balance; // Increment balance for an opening bracket\n        } else if (c == '>') {\n            --balance; // Decrement balance for a closing bracket\n            if (balance < 0) return false; // If balance goes negative, brackets are not balanced\n        }\n    }\n\n    return balance == 0; // Return true only if all opening brackets have corresponding closing ones\n}\n\n"}
{"task_id": "CPP/57", "generation": "#include <vector>\nusing namespace std;\n\nbool monotonic(vector<float> l) {\n    // If there are less than 2 elements, it's trivially monotonic.\n    if (l.size() <= 1) return true;\n    \n    bool increasing = false; // Flag to check for increasing order\n    bool decreasing = false; // Flag to check for decreasing order\n    \n    // Determine the direction based on the first two elements\n    if (l[0] < l[1]) {\n        increasing = true;\n    } else if (l[0] > l[1]) {\n        decreasing = true;\n    }\n    \n    // Check the rest of the vector for consistency with the determined order.\n    for(size_t i = 2; i < l.size(); ++i) {\n        if(increasing && l[i-1] >= l[i])\n            return false;\n        else if(decreasing && l[i-1] <= l[i])\n            return false;\n    }\n    \n    // If the loop completes without returning false, it's monotonic.\n    return true;\n}\n"}
{"task_id": "CPP/58", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\n\nusing namespace std;\n\nvector<int> common(vector<int> l1, vector<int> l2) {\n    // Sort the input vectors.\n    sort(l1.begin(), l1.end());\n    sort(l2.begin(), l2.end());\n\n    set<int> result;\n    \n    auto it1 = l1.begin();\n    auto it2 = l2.begin();\n\n    while (it1 != l1.end() && it2 != l2.end()) {\n        if (*it1 == *it2) {\n            // If elements are equal, add to the set and move both iterators.\n            result.insert(*it1);\n            ++it1;\n            ++it2;\n        } else if (*it1 < *it2) {\n            // Move iterator of l1 forward if its element is smaller.\n            ++it1;\n        } else {\n            // Otherwise, move iterator of l2 forward.\n            ++it2;\n        }\n    }\n\n    // Convert set to vector and return.\n    return vector<int>(result.begin(), result.end());\n}\n\n// Function to print the elements of a vector\nvoid printVector(const vector<int>& vec) {\n    for (int num : vec) {\n        cout << num << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/59", "generation": "#include <iostream>\nusing namespace std;\n\nint largest_prime_factor(int n) {\n    int maxPrime = -1;\n    \n    // Divide n by 2 until it's odd, so we only have to check odd numbers later.\n    while (n % 2 == 0) {\n        maxPrime = 2;\n        n /= 2;\n    }\n    \n    // Now n is odd. Start checking from 3\n    for (int i = 3; i * i <= n; i += 2) {\n        while (n % i == 0) {\n            maxPrime = i;\n            n = n / i;\n        }\n    }\n    \n    // If n became a prime number greater than 2, then it's the largest prime factor.\n    if (n > 2)\n        maxPrime = n;\n\n    return maxPrime;\n}\n\n"}
{"task_id": "CPP/60", "generation": "#include <stdio.h>\n\nint sum_to_n(int n) {\n    int sum = 0;\n    for (int i = 1; i <= n; ++i) {\n        sum += i;\n    }\n    return sum;\n}\n\n// Function to test the correctness of sum_to_n function.\nvoid check_function() {\n    printf(\"sum_to_n(30): %d\\n\", sum_to_n(30)); // Expected: 465\n    printf(\"sum_to_n(100): %d\\n\", sum_to_n(100)); // Expected: 5050\n    printf(\"sum_to_n(5): %d\\n\", sum_to_n(5)); // Expected: 15\n    printf(\"sum_to_n(10): %d\\n\", sum_to_n(10)); // Expected: 55\n    printf(\"sum_to_n(1): %d\\n\", sum_to_n(1)); // Expected: 1\n}\n\n"}
{"task_id": "CPP/61", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    int count = 0;\n    \n    for (char c : brackets) {\n        if (c == '(') {\n            ++count; // Increment count for every opening parenthesis\n        } else if (c == ')') {\n            --count; // Decrement count for every closing parenthesis\n            \n            // If at any point the count goes below zero, return false\n            if (count < 0) {\n                return false;\n            }\n        }\n    }\n    \n    // After processing all characters, check if count is back to zero\n    return count == 0;\n}\n\n"}
{"task_id": "CPP/62", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvector<float> derivative(vector<float> xs) {\n    // Create an empty vector to store the coefficients of the derivative.\n    vector<float> result;\n    \n    // Iterate through each coefficient starting from the first non-constant term (index 1).\n    for(size_t i = 1; i < xs.size(); ++i) {\n        // Multiply the current coefficient by its power and add it to the result vector.\n        result.push_back(xs[i] * static_cast<float>(i));\n    }\n    \n    return result;\n}\n\n// Function to test the derivative function with given data points\nvoid check_derivative() {\n    vector<float> test1 = {3, 1, 2, 4, 5};\n    vector<float> expected1 = {1, 4, 12, 20};\n    \n    vector<float> result1 = derivative(test1);\n    assert(result1 == expected1);\n\n    vector<float> test2 = {1, 2, 3};\n    vector<float> expected2 = {2, 6};\n\n    vector<float> result2 = derivative(test2);\n    assert(result2 == expected2);\n\n    cout << \"All tests passed successfully.\" << endl;\n}\n\n"}
{"task_id": "CPP/63", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint fibfib(int n) {\n    // Base cases\n    if (n == 0 || n == 1)\n        return 0;\n    else if (n == 2)\n        return 1;\n\n    // Initialize a vector to store the computed values of fibfib sequence.\n    vector<int> dp(n + 1, 0);\n    dp[0] = 0; // fibfib(0) is 0\n    dp[1] = 0; // fibfib(1) is 0\n    dp[2] = 1; // fibfib(2) is 1\n\n    // Compute the values from 3 to n using the recurrence relation.\n    for (int i = 3; i <= n; ++i) {\n        dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3];\n    }\n\n    return dp[n]; // Return the nth element of fibfib sequence\n}\n\n// Function to test the correctness of the solution.\nvoid check() {\n    cout << \"fibfib(1): \" << fibfib(1) << endl; // Expected output: 0\n    cout << \"fibfib(5): \" << fibfib(5) << endl; // Expected output: 4\n    cout << \"fibfib(8): \" << fibfib(8) << endl; // Expected output: 24\n}\n\n"}
{"task_id": "CPP/64", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint vowels_count(string s) {\n    int count = 0;\n    // Define the set of vowels\n    string vowels = \"aeiouAEIOU\";\n    \n    for (char c : s) {\n        if (vowels.find(c) != string::npos) {\n            ++count; // Increment count if character is a vowel\n        }\n    }\n\n    // Check if last character is 'y' or 'Y'\n    if (!s.empty() && (s.back() == 'y' || s.back() == 'Y')) {\n        ++count;\n    }\n\n    return count;\n}\n\n"}
{"task_id": "CPP/65", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring circular_shift(int x, int shift) {\n    // Convert integer to string for easier manipulation\n    string str_x = to_string(x);\n    \n    // Calculate the effective number of shifts needed\n    int len = str_x.length();\n    shift %= len;  // Effective shift after considering full rotations\n    \n    if (shift >= len) {  // If shift is greater than or equal to length, reverse digits\n        reverse(str_x.begin(), str_x.end());\n    } else {\n        // Perform circular right shift by 'shift' positions\n        string shifted = str_x.substr(len - shift) + str_x.substr(0, len - shift);\n        return shifted;\n    }\n    \n    return str_x;  // Return the reversed or shifted string\n}\n\n// Function to test the circular_shift function with given examples\nvoid check() {\n    cout << (circular_shift(12, 1) == \"21\" ? \"Test 1 Passed\\n\" : \"Test 1 Failed\\n\");\n    cout << (circular_shift(12, 2) == \"12\" ? \"Test 2 Passed\\n\" : \"Test 2 Failed\\n\");\n}\n\n"}
{"task_id": "CPP/66", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint digitSum(string s) {\n    int sum = 0;\n    \n    // Iterate over each character in the string.\n    for (char c : s) {\n        // Check if the character is an uppercase letter.\n        if (isupper(c)) {\n            // Add its ASCII value to the sum.\n            sum += static_cast<int>(c);\n        }\n    }\n\n    return sum;\n}\n\n// Function to test the digitSum function with given examples\nvoid check() {\n    cout << \"digitSum(\\\"\\\") => \" << digitSum(\"\") << endl;       // Expected: 0\n    cout << \"digitSum(\\\"abAB\\\") => \" << digitSum(\"abAB\") << endl;   // Expected: 131\n    cout << \"digitSum(\\\"abcCd\\\") => \" << digitSum(\"abcCd\") << endl; // Expected: 67\n    cout << \"digitSum(\\\"helloE\\\") => \" << digitSum(\"helloE\") << endl; // Expected: 69\n    cout << \"digitSum(\\\"woArBld\\\") => \" << digitSum(\"woArBld\") << endl; // Expected: 131\n    cout << \"digitSum(\\\"aAaaaXa\\\") => \" << digitSum(\"aAaaaXa\") << endl; // Expected: 153\n}\n\n"}
{"task_id": "CPP/67", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nint fruit_distribution(string s, int n) {\n    // Extracting numbers from the string using stringstream\n    stringstream ss(s);\n    int apples = 0;\n    int oranges = 0;\n    \n    // Parsing the string to get the number of apples and oranges\n    ss >> apples; // Read the first integer (number of apples)\n    string temp; // Temporary variable for reading \"apples\" and \"and\"\n    getline(ss, temp, ' '); // Skip \"apples\", \"and\", and spaces\n    getline(ss, temp, ' ');\n    ss >> oranges; // Read the second integer (number of oranges)\n\n    // Calculate the number of mangoes by subtracting apples and oranges from total fruits\n    int mangoes = n - (apples + oranges);\n    \n    return mangoes;\n}\n\n"}
{"task_id": "CPP/68", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> pluck(vector<int> arr) {\n    int minEvenValue = INT_MAX; // Initialize to maximum possible integer value\n    int minIndex = -1;          // Initialize to an invalid index\n\n    for (int i = 0; i < arr.size(); ++i) {\n        if (arr[i] % 2 == 0 && arr[i] <= minEvenValue) { // Check if the current element is even and smaller or equal to the current minimum\n            if (arr[i] < minEvenValue || (arr[i] == minEvenValue && i < minIndex)) {\n                minEvenValue = arr[i];\n                minIndex = i;\n            }\n        }\n    }\n\n    if (minIndex != -1) { // If a valid even number was found\n        return {minEvenValue, minIndex};\n    } else {\n        return {}; // Return an empty vector if no even numbers were found\n    }\n}\n"}
{"task_id": "CPP/69", "generation": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint search(vector<int> lst) {\n    // Create a map to store the frequency of each number in the list.\n    unordered_map<int, int> freqMap;\n    \n    // Populate the frequency map with counts from the vector.\n    for (int num : lst) {\n        freqMap[num]++;\n    }\n    \n    // Initialize the result as -1. This will be returned if no valid integer is found.\n    int result = -1;\n\n    // Iterate through each entry in the frequency map to find the greatest number\n    // that meets the criteria.\n    for (auto& entry : freqMap) {\n        int num = entry.first;\n        int count = entry.second;\n        \n        // Check if the current number's frequency is greater than or equal to its value.\n        if (count >= num && num > result) {\n            result = num;\n        }\n    }\n\n    return result;\n}\n\n// Function to test the search function with given examples\nvoid test() {\n    vector<int> test1 = {4, 1, 2, 2, 3, 1};\n    vector<int> test2 = {1, 2, 2, 3, 3, 3, 4, 4, 4};\n    vector<int> test3 = {5, 5, 4, 4, 4};\n\n    cout << \"Test 1: Expected 2, Got \" << search(test1) << endl;\n    cout << \"Test 2: Expected 3, Got \" << search(test2) << endl;\n    cout << \"Test 3: Expected -1, Got \" << search(test3) << endl;\n}\n\n"}
{"task_id": "CPP/70", "generation": "#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> strange_sort_list(vector<int> lst) {\n    vector<int> result;\n    sort(lst.begin(), lst.end()); // First, sort the list in ascending order.\n    \n    int left = 0; // Start index for picking minimum values.\n    int right = lst.size() - 1; // End index for picking maximum values.\n\n    while (left <= right) {\n        if (left == right) { // If only one element is left, add it to the result.\n            result.push_back(lst[left]);\n            break;\n        }\n        // Add minimum value\n        result.push_back(lst[left++]);\n        // Add maximum value\n        if (left <= right)\n            result.push_back(lst[right--]);\n    }\n\n    return result;\n}\n\n// Example usage:\n// vector<int> sortedList = strange_sort_list({1, 2, 3, 4});\n// This will give you {1, 4, 2, 3}\n"}
{"task_id": "CPP/71", "generation": "#include <iostream>\n#include <cmath> // For sqrt function\n\nfloat triangle_area(float a, float b, float c) {\n    if (a + b <= c || a + c <= b || b + c <= a) { // Check for valid triangle\n        return -1;\n    }\n    \n    float s = (a + b + c) / 2; // Semi-perimeter\n    float area = sqrt(s * (s - a) * (s - b) * (s - c)); // Heron's formula\n    \n    return round(area * 100) / 100; // Round to 2 decimal places\n}\n\n"}
{"task_id": "CPP/72", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nbool will_it_fly(vector<int> q, int w) {\n    // Check if the vector is palindromic (balanced)\n    for(int i = 0; i < q.size() / 2; ++i) {\n        if(q[i] != q[q.size() - 1 - i]) return false;\n    }\n    \n    // Calculate the sum of elements in the vector\n    int sum = 0;\n    for(int num : q) {\n        sum += num;\n    }\n\n    // Check if the sum is less than or equal to w\n    return sum <= w;\n}\n\n"}
{"task_id": "CPP/73", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint smallest_change(vector<int> arr) {\n    int n = arr.size();\n    int changes_needed = 0;\n    \n    for (int i = 0; i < n / 2; ++i) {\n        if (arr[i] != arr[n - 1 - i]) {\n            ++changes_needed;\n        }\n    }\n\n    return changes_needed;\n}\n\n// Function to test the solution\nvoid check() {\n    assert(smallest_change({1, 2, 3, 5, 4, 7, 9, 6}) == 4);\n    assert(smallest_change({1, 2, 3, 4, 3, 2, 2}) == 1);\n    assert(smallest_change({1, 2, 3, 2, 1}) == 0);\n\n    cout << \"All test cases passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/74", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to calculate the total number of characters in a vector of strings.\nint countChars(const vector<string>& lst) {\n    int total = 0;\n    for (const string& str : lst) {\n        total += str.size();\n    }\n    return total;\n}\n\nvector<string> total_match(vector<string> lst1, vector<string> lst2) {\n    // Calculate the number of characters in each list\n    int count1 = countChars(lst1);\n    int count2 = countChars(lst2);\n\n    // Compare and return the appropriate list based on character counts.\n    if (count1 <= count2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n\n// Function to test the total_match function with given examples\nvoid check() {\n    vector<string> empty = {};\n    vector<string> result;\n\n    // Test case 1: Both vectors are empty\n    result = total_match(empty, empty);\n    cout << \"Test Case 1: \";\n    for (const string& s : result) cout << s << \" \";\n    cout << endl;\n\n    // Test case 2: First vector has fewer characters\n    result = total_match({\"hi\", \"admin\"}, {\"hI\", \"Hi\"});\n    cout << \"Test Case 2: \";\n    for (const string& s : result) cout << s << \" \";\n    cout << endl;\n\n    // Test case 3: Second vector has more characters\n    result = total_match({\"hi\", \"admin\"}, {\"hi\", \"hi\", \"admin\", \"project\"});\n    cout << \"Test Case 3: \";\n    for (const string& s : result) cout << s << \" \";\n    cout << endl;\n\n    // Test case 4: Second vector has fewer characters\n    result = total_match({\"hi\", \"admin\"}, {\"hI\", \"hi\", \"hi\"});\n    cout << \"Test Case 4: \";\n    for (const string& s : result) cout << s << \" \";\n    cout << endl;\n\n    // Test case 5: First vector has fewer characters\n    result = total_match({\"4\"}, {\"1\", \"2\", \"3\", \"4\", \"5\"});\n    cout << \"Test Case 5: \";\n    for (const string& s : result) cout << s << \" \";\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/75", "generation": "#include <iostream>\nusing namespace std;\n\n// Function to check if a number is prime.\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\n// Function to check if the given number can be expressed as a product of exactly three prime numbers.\nbool is_multiply_prime(int a) {\n    // If 'a' itself is less than or equal to 1, it cannot be a product of primes.\n    if (a <= 1) return false;\n\n    int count = 0; // To keep track of the number of prime factors.\n\n    for (int i = 2; i < 100 && i * i <= a; ++i) {\n        while (a % i == 0) { // Check if 'i' is a factor.\n            if (!is_prime(i)) return false; // If the factor is not prime, return false.\n            count++;\n            a /= i;\n        }\n    }\n\n    // If there's any remaining number greater than 1 and less than 100, check if it's prime.\n    if (a > 1 && a < 100) {\n        if (!is_prime(a)) return false; // If the factor is not prime, return false.\n        count++;\n    }\n\n    // The number should have exactly three prime factors to be true.\n    return count == 3;\n}\n\n"}
{"task_id": "CPP/76", "generation": "#include <cmath> // For log and pow functions\n\nbool is_simple_power(int x, int n) {\n    if (x == 1) return true; // Any number to the power of 0 is 1.\n    if (n <= 1 && x != n) return false; // If n is less than or equal to 1 and not equal to x, it's impossible for x to be a simple power of n.\n\n    double log_result = std::log(x) / std::log(n); // Calculate the logarithm base n of x\n    int k = static_cast<int>(std::round(log_result)); // Round the result to check if it's an integer\n\n    return std::pow(n, k) == x; // Check if raising n to this power equals x\n}\n\n"}
{"task_id": "CPP/77", "generation": "#include <iostream>\n#include <cmath> // Use cmath for C++ programs\n\nbool iscube(int a) {\n    double cubeRoot = cbrt(a); // Compute the cube root\n    int roundedCubeRoot = round(cubeRoot); // Round to nearest integer\n    \n    // Check if the cube of the rounded value equals the original number\n    return (roundedCubeRoot * roundedCubeRoot * roundedCubeRoot == a);\n}\n\n"}
{"task_id": "CPP/78", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint hex_key(string num) {\n    // Define a set of prime hexadecimal digits.\n    string primes = \"2357BD\";\n    \n    int count = 0;\n    \n    // Iterate through each character in the input string.\n    for (char c : num) {\n        // Check if the current character is one of the prime hex digits.\n        if (primes.find(c) != string::npos) {\n            ++count; // Increment the count if it's a prime digit.\n        }\n    }\n\n    return count;\n}\n\n// Function to test the solution with given examples\nvoid check() {\n    cout << \"Test Case 1: \" << hex_key(\"AB\") << endl; // Expected output: 1\n    cout << \"Test Case 2: \" << hex_key(\"1077E\") << endl; // Expected output: 2\n    cout << \"Test Case 3: \" << hex_key(\"ABED1A33\") << endl; // Expected output: 4\n    cout << \"Test Case 4: \" << hex_key(\"123456789ABCDEF0\") << endl; // Expected output: 6\n    cout << \"Test Case 5: \" << hex_key(\"2020\") << endl; // Expected output: 2\n}\n\n"}
{"task_id": "CPP/79", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring decimal_to_binary(int decimal) {\n    // Handling the special case for 0 as it should return \"db0db\"\n    if (decimal == 0) {\n        return \"db0db\";\n    }\n\n    string binary = \"\";\n    \n    // Convert to binary\n    while (decimal > 0) {\n        int remainder = decimal % 2;\n        binary = char('0' + remainder) + binary; // Prepend the character to the left of the existing string.\n        decimal /= 2;\n    }\n    \n    // Add \"db\" at both ends and return\n    return \"db\" + binary + \"db\";\n}\n\n"}
{"task_id": "CPP/80", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_happy(string s) {\n    // Check if the length of the string is less than 3.\n    if (s.length() < 3) return false;\n    \n    // Iterate through the string and check every set of three consecutive characters.\n    for (int i = 0; i < s.length() - 2; ++i) {\n        // If any three consecutive characters are not distinct, return false.\n        if (s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]) {\n            return false;\n        }\n    }\n\n    // If all sets of three consecutive characters are distinct, the string is happy.\n    return true;\n}\n\n"}
{"task_id": "CPP/81", "generation": "#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<string> numerical_letter_grade(vector<float> grades) {\n    vector<string> letter_grades;\n    \n    for (float gpa : grades) {\n        if (gpa >= 4.0) letter_grades.push_back(\"A+\");\n        else if (gpa > 3.7) letter_grades.push_back(\"A\");\n        else if (gpa > 3.3) letter_grades.push_back(\"A-\");\n        else if (gpa > 3.0) letter_grades.push_back(\"B+\");\n        else if (gpa > 2.7) letter_grades.push_back(\"B\");\n        else if (gpa > 2.3) letter_grades.push_back(\"B-\");\n        else if (gpa > 2.0) letter_grades.push_back(\"C+\");\n        else if (gpa > 1.7) letter_grades.push_back(\"C\");\n        else if (gpa > 1.3) letter_grades.push_back(\"C-\");\n        else if (gpa > 1.0) letter_grades.push_back(\"D+\");\n        else if (gpa > 0.7) letter_grades.push_back(\"D\");\n        else if (gpa > 0.0) letter_grades.push_back(\"D-\");\n        else letter_grades.push_back(\"E\"); // This covers the case where GPA is exactly 0.0\n    }\n    \n    return letter_grades;\n}\n\n// Example usage:\n"}
{"task_id": "CPP/82", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\n// Function to check if a number is prime.\nbool is_prime(int n) {\n    if (n <= 1) return false; // Numbers less than or equal to 1 are not prime.\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\n// Function that takes a string and returns true if the length of the string is a prime number\nbool prime_length(string str){\n    int len = str.length();\n    return is_prime(len);\n}\n\n"}
{"task_id": "CPP/83", "generation": "#include<iostream>\nusing namespace std;\n\nint starts_one_ends(int n){\n    if(n == 1) return 1; // Special case for single-digit numbers\n\n    int total_n_digit_numbers = 9 * pow(10, n-1); // Total count of n-digit numbers\n    int start_with_1 = pow(10, n-1);              // Count of numbers starting with 1\n    int end_with_1   = pow(10, n-1);              // Count of numbers ending with 1\n    int both_start_end_with_1 = pow(10, n-2);     // Overlap: count of numbers that start and end with 1\n\n    return total_n_digit_numbers - (total_n_digit_numbers - start_with_1) -\n           (total_n_digit_numbers - end_with_1) + both_start_end_with_1;\n}\n\n"}
{"task_id": "CPP/84", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\n// Function to calculate the sum of digits of N\nint sumOfDigits(int n) {\n    int sum = 0;\n    while (n > 0) {\n        sum += n % 10; // Add the last digit to sum\n        n /= 10;       // Remove the last digit from n\n    }\n    return sum;\n}\n\n// Function to convert an integer to its binary string representation\nstring intToBinary(int num) {\n    if (num == 0) return \"0\"; // Special case for zero\n\n    string binary = \"\";\n    while (num > 0) {\n        binary = (num % 2 == 0 ? \"0\" : \"1\") + binary; // Prepend the remainder\n        num /= 2;\n    }\n    return binary;\n}\n\nstring solve(int N){\n    int sumDigits = sumOfDigits(N); // Calculate the sum of digits\n    string result = intToBinary(sumDigits); // Convert to binary and store as a string\n    return result; // Return the binary representation as a string\n}\n\n// Example usage:\n"}
{"task_id": "CPP/85", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint add(vector<int> lst) {\n    int sum = 0;\n    \n    // Iterate through the vector starting from index 1 and increment by 2 to only check odd indices.\n    for (size_t i = 1; i < lst.size(); i += 2) {\n        if (lst[i] % 2 == 0) { // Check if the element at the current index is even\n            sum += lst[i]; // Add it to the sum if it's even\n        }\n    }\n\n    return sum;\n}\n\n"}
{"task_id": "CPP/86", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nstring anti_shuffle(string s) {\n    int n = s.length();\n    string result;\n    \n    for (int i = 0; i < n; ++i) {\n        // Collect characters of the current word.\n        string word;\n        \n        while (i < n && isalpha(s[i])) {\n            word += s[i];\n            ++i;\n        }\n        \n        // Sort the collected word and append it to result\n        sort(word.begin(), word.end());\n        for (char c : word) {\n            result += c;\n        }\n\n        // Append non-alphabetic characters as they are.\n        while (i < n && !isalpha(s[i])) {\n            result += s[i];\n            ++i;\n        }\n    }\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/87", "generation": "#include <vector>\n#include <algorithm> // for std::sort\n\nusing namespace std;\n\n// Comparator function for sorting the coordinates.\nbool compare(const vector<int>& a, const vector<int>& b) {\n    if (a[0] == b[0]) { // If rows are equal, sort columns in descending order\n        return a[1] > b[1];\n    }\n    return a[0] < b[0]; // Otherwise, sort by row in ascending order\n}\n\nvector<vector<int>> get_row(vector<vector<int>> lst, int x) {\n    vector<vector<int>> coordinates;\n    \n    for (int i = 0; i < lst.size(); ++i) { // Iterate through each row\n        for (int j = 0; j < lst[i].size(); ++j) { // Iterate through each element in the row\n            if (lst[i][j] == x) {\n                coordinates.push_back({i, j}); // Record the coordinate of found integer\n            }\n        }\n    }\n\n    sort(coordinates.begin(), coordinates.end(), compare); // Sort according to specified rules\n    \n    return coordinates;\n}\n\n// Example usage:\n/*\nvector<vector<int>> result = get_row({\n  {1,2,3,4,5,6},\n  {1,2,3,4,1,6},\n  {1,2,3,4,5,1}\n}, 1);\nfor (const auto& coord : result) {\n    printf(\"{%d, %d}\\n\", coord[0], coord[1]);\n}\n*/\n"}
{"task_id": "CPP/88", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> sort_array(vector<int> array) {\n    // Check for empty or single element vector\n    if (array.size() <= 1) return array;\n    \n    // Determine sorting order based on the sum of first and last elements\n    bool ascending = ((array.front() + array.back()) % 2 != 0);\n    \n    // Create a copy to sort without modifying the original vector\n    vector<int> sorted_array(array);\n    \n    if (ascending) {\n        // Sort in ascending order\n        sort(sorted_array.begin(), sorted_array.end());\n    } else {\n        // Sort in descending order\n        sort(sorted_array.rbegin(), sorted_array.rend());\n    }\n    \n    return sorted_array;\n}\n\n// Function to test the implementation with given examples\nvoid test() {\n    vector<int> empty = {};\n    vector<int> single = {5};\n    vector<int> example1 = {2, 4, 3, 0, 1, 5};\n    vector<int> example2 = {2, 4, 3, 0, 1, 5, 6};\n\n    auto result_empty = sort_array(empty);\n    auto result_single = sort_array(single);\n    auto result_example1 = sort_array(example1);\n    auto result_example2 = sort_array(example2);\n\n    // Output the results\n    for (int num : result_empty) cout << num << \" \";\n    cout << endl;\n\n    for (int num : result_single) cout << num << \" \";\n    cout << endl;\n\n    for (int num : result_example1) cout << num << \" \";\n    cout << endl;\n\n    for (int num : result_example2) cout << num << \" \";\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/89", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nstring encrypt(string s) {\n    for (size_t i = 0; i < s.length(); ++i) {\n        if (isalpha(s[i])) { // Check if the character is an alphabet letter.\n            char base = islower(s[i]) ? 'a' : 'A'; // Determine the base ('a' or 'A') for wrapping around the alphabet.\n            int shift = 4; // The specified shift amount.\n            \n            s[i] = (s[i] - base + shift) % 26 + base; // Perform the rotation and wrap around if necessary.\n        }\n    }\n    return s;\n}\n\n"}
{"task_id": "CPP/90", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint next_smallest(vector<int> lst) {\n    if (lst.size() < 2) return -1; // If there are less than two elements, we can't have a second smallest.\n\n    sort(lst.begin(), lst.end()); // Sort the vector to easily find the second smallest element.\n    \n    int first = lst[0]; // The smallest element is now at index 0 after sorting.\n    for (size_t i = 1; i < lst.size(); ++i) {\n        if (lst[i] != first) { // Find the next different element, which will be the second smallest.\n            return lst[i];\n        }\n    }\n\n    return -1; // If all elements are the same or there's no distinct second smallest element, return -1.\n}\n\n"}
{"task_id": "CPP/91", "generation": "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nint is_bored(string S) {\n    int boredomCount = 0;\n    string delimiterChars = \".?!\";\n    \n    // Temporary buffer to hold each sentence\n    string sentenceBuffer;\n    bool isNewSentence = true; // Flag to indicate the start of a new sentence\n    \n    for (char ch : S) {\n        if (isNewSentence && ch == 'I') {\n            // Check next character is space, indicating \"I \"\n            char nextChar = *(S.c_str() + 1);\n            if (nextChar == ' ') {\n                boredomCount++;\n            }\n        }\n\n        isNewSentence = delimiterChars.find(ch) != string::npos;\n        \n        if (!isNewSentence) {\n            sentenceBuffer += ch; // Build the current sentence\n        } else {\n            sentenceBuffer.clear(); // Reset buffer for next sentence\n        }\n    }\n    \n    return boredomCount;\n}\n\n"}
{"task_id": "CPP/92", "generation": "#include <cmath> // For std::floor and std::ceil\n\nbool is_integer(float num) {\n    return std::floor(num) == std::ceil(num);\n}\n\nbool any_int(float a, float b, float c) {\n    if (!is_integer(a) || !is_integer(b) || !is_integer(c)) {\n        return false;\n    }\n    \n    // Check if one number is the sum of the other two\n    return (a == b + c) || (b == a + c) || (c == a + b);\n}\n\n"}
{"task_id": "CPP/93", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\n// Function to encode a message according to given rules\nstring encode(string message) {\n    // Iterate through each character of the string\n    for (int i = 0; i < message.length(); ++i) {\n        char ch = message[i];\n        \n        // Swap case: convert lowercase to uppercase and vice versa\n        if (islower(ch)) {\n            ch = toupper(ch);\n        } else if (isupper(ch)) {\n            ch = tolower(ch);\n        }\n        \n        // Replace vowels with the letter that appears 2 places ahead in the alphabet\n        switch (tolower(ch)) { // Use lowercase for simplicity when checking vowels\n            case 'a': ch = 'C'; break;\n            case 'e': ch = 'G'; break;\n            case 'i': ch = 'K'; break;\n            case 'o': ch = 'Q'; break;\n            case 'u': ch = 'W'; break;\n        }\n        \n        // Update the character in the string\n        message[i] = ch;\n    }\n\n    return message;\n}\n\n"}
{"task_id": "CPP/94", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Helper function to check if a number is prime\nbool isPrime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\n// Function to sum the digits of a number\nint sumDigits(int num) {\n    int sum = 0;\n    while (num > 0) {\n        sum += num % 10;\n        num /= 10;\n    }\n    return sum;\n}\n\n// Main function to find and process the largest prime in the list\nint skjkasdkd(vector<int> lst){\n    int maxPrime = -1; // Initialize with an invalid value\n\n    for (auto &num : lst) {\n        if (isPrime(num)) { // Check if the number is prime\n            if (num > maxPrime) {\n                maxPrime = num;\n            }\n        }\n    }\n\n    return sumDigits(maxPrime); // Return the sum of digits of the largest prime found\n}\n\n// Example usage and testing\n"}
{"task_id": "CPP/95", "generation": "#include <iostream>\n#include <map>\n#include <cctype> // for std::islower and std::isupper\n\nusing namespace std;\n\nbool check_dict_case(map<string, string> dict) {\n    if (dict.empty()) return false; // Return false if the map is empty\n    \n    bool allLower = true;\n    bool allUpper = true;\n    \n    for (const auto& kv : dict) {\n        const string& key = kv.first;\n        \n        // Check each character in the key\n        for (char ch : key) {\n            if (!islower(ch)) allLower = false; // If any char is not lowercase, set allLower to false\n            if (!isupper(ch)) allUpper = false; // If any char is not uppercase, set allUpper to false\n        }\n        \n        // Early exit if neither condition holds true for the current key\n        if (!allLower && !allUpper) return false;\n    }\n\n    // Return true if either all keys are lowercase or all keys are uppercase\n    return allLower || allUpper;\n}\n\n"}
{"task_id": "CPP/96", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\n// Helper function to check if a number is prime.\nbool is_prime(int num) {\n    if (num <= 1) return false; // 0 and 1 are not primes\n    for (int i = 2; i * i <= num; ++i) { // Only need to check up to sqrt(num)\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\nvector<int> count_up_to(int n){\n    vector<int> primes;\n    for (int i = 2; i < n; ++i) {\n        if (is_prime(i)) {\n            primes.push_back(i);\n        }\n    }\n    return primes;\n}\n\n// Function to test the implementation\nvoid check() {\n    printf(\"count_up_to(5): \");\n    vector<int> result = count_up_to(5);\n    for(int num : result) printf(\"%d \", num); // Expected: 2 3\n    printf(\"\\n\");\n\n    printf(\"count_up_to(11): \");\n    result = count_up_to(11);\n    for(int num : result) printf(\"%d \", num); // Expected: 2 3 5 7\n    printf(\"\\n\");\n\n    printf(\"count_up_to(0): \");\n    result = count_up_to(0);\n    if(result.empty()) printf(\"{}\\n\"); // Expected: {}\n\n    printf(\"count_up_to(20): \");\n    result = count_up_to(20);\n    for(int num : result) printf(\"%d \", num); // Expected: 2 3 5 7 11 13 17 19\n    printf(\"\\n\");\n\n    printf(\"count_up_to(18): \");\n    result = count_up_to(18);\n    for(int num : result) printf(\"%d \", num); // Expected: 2 3 5 7 11 13 17\n    printf(\"\\n\");\n}\n\n"}
{"task_id": "CPP/97", "generation": "#include <iostream> // Corrected header for input/output operations\n\nint multiply(int a, int b) {\n    // Extracting the unit digit from both numbers\n    int unitDigitA = abs(a % 10);\n    int unitDigitB = abs(b % 10);\n\n    // Multiplying the unit digits and returning the result\n    return unitDigitA * unitDigitB;\n}\n\n"}
{"task_id": "CPP/98", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint count_upper(string s){\n    int count = 0;\n    // Iterate through the string with a step of 2 to check even indices.\n    for (size_t i = 0; i < s.length(); i += 2) {\n        char c = s[i];\n        if (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n            count++;\n        }\n    }\n    return count;\n}\n\n"}
{"task_id": "CPP/99", "generation": "#include <iostream>\n#include <cmath>\n#include <string>\n\nusing namespace std;\n\nint closest_integer(string value) {\n    // Convert string to float\n    float num = stof(value);\n    \n    // Get the integer part and the fractional part of the number\n    int intPart = static_cast<int>(num);\n    double fracPart = fabs(num - intPart);\n\n    // Check if the number is equidistant from two integers\n    if (fracPart == 0.5) {\n        // Round away from zero\n        return num > 0 ? intPart + 1 : intPart - 1;\n    } else {\n        // Use standard rounding rules\n        return round(num);\n    }\n}\n\n"}
{"task_id": "CPP/100", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> make_a_pile(int n) {\n    vector<int> pile;\n    int current_stones = n; // Start with the number of stones in the first level\n    \n    for (int i = 0; i < n; ++i) {\n        pile.push_back(current_stones); // Add the current number of stones to the pile\n        if (n % 2 == 0) { // If n is even, add 2 to get the next even number\n            current_stones += 2;\n        } else { // If n is odd, add 2 to get the next odd number\n            current_stones += 2;\n        }\n    }\n\n    return pile; // Return the vector containing stones in each level\n}\n\n// Function to test the make_a_pile function with a given input and expected output.\nvoid check(int n, const vector<int>& expected) {\n    vector<int> result = make_a_pile(n);\n    if (result == expected) {\n        cout << \"Test passed for n=\" << n << endl;\n    } else {\n        cout << \"Test failed for n=\" << n << \". Expected: {\";\n        for (int i : expected) cout << i << \", \";\n        cout << \"} but got: {\";\n        for (int i : result) cout << i << \", \";\n        cout << \"}\" << endl;\n    }\n}\n\n"}
{"task_id": "CPP/101", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> words_string(string s) {\n    vector<string> result;\n    string word = \"\";\n    \n    for (char c : s) {\n        if (c == ',' || c == ' ') { // Check for delimiters\n            if (!word.empty()) { // Add the current word to the result and reset it\n                result.push_back(word);\n                word = \"\";\n            }\n        } else {\n            word += c; // Build up the current word\n        }\n    }\n\n    if (!word.empty()) { // Don't forget to add the last word if there's any left\n        result.push_back(word);\n    }\n\n    return result;\n}\n\n// Example usage:\n"}
{"task_id": "CPP/102", "generation": "#include<iostream>\nusing namespace std;\n\nint choose_num(int x, int y) {\n    // If x is greater than y, there's no valid range.\n    if (x > y) return -1;\n    \n    // Start from the smaller number and move towards the larger one.\n    for (int i = min(x, y); i <= max(x, y); ++i) {\n        // Check if the current number is even\n        if (i % 2 == 0) {\n            // Since we are iterating in ascending order,\n            // the last even number found will be the largest.\n            return i;\n        }\n    }\n    \n    // If no even number was found, return -1.\n    return -1;\n}\n\n"}
{"task_id": "CPP/103", "generation": "#include <iostream>\n#include <cmath>\n#include <bitset>\n\nusing namespace std;\n\nstring rounded_avg(int n, int m){\n    if(n > m)\n        return \"-1\";\n    \n    // Calculate the sum of all integers from n to m.\n    long long totalSum = 0;\n    for (int i = n; i <= m; ++i) {\n        totalSum += i;\n    }\n    \n    // Calculate the average and round it down\n    int count = m - n + 1;\n    int avg = totalSum / count;\n\n    // Convert to binary string\n    bitset<32> binary(avg); // Assuming the maximum number of bits needed is 32.\n    string binaryStr = binary.to_string();\n\n    // Remove leading zeros\n    size_t firstOne = binaryStr.find('1');\n    if (firstOne != string::npos) {\n        return binaryStr.substr(firstOne);\n    } else {\n        return \"0\"; // In case the average is 0, which doesn't have a '1' in its binary representation.\n    }\n}\n\n"}
{"task_id": "CPP/104", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to check if a number contains any even digit.\nbool has_even_digit(int num) {\n    while (num > 0) {\n        int digit = num % 10;\n        if (digit % 2 == 0) return true; // If an even digit is found, return true\n        num /= 10;\n    }\n    return false; // No even digits were found\n}\n\nvector<int> unique_digits(vector<int> x) {\n    vector<int> result;\n\n    // Filter out numbers with any even digit and store the rest in 'result'.\n    for (int num : x) {\n        if (!has_even_digit(num)) {\n            result.push_back(num);\n        }\n    }\n\n    // Sort the resulting vector.\n    sort(result.begin(), result.end());\n\n    return result;\n}\n\n// Function to test the unique_digits function\nvoid check() {\n    vector<int> test1 = {15, 33, 1422, 1};\n    vector<int> expected1 = {1, 15, 33};\n    assert(unique_digits(test1) == expected1);\n\n    vector<int> test2 = {152, 323, 1422, 10};\n    vector<int> expected2 = {};\n    assert(unique_digits(test2) == expected2);\n    \n    cout << \"All tests passed successfully.\" << endl;\n}\n\n"}
{"task_id": "CPP/105", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nvector<string> by_length(vector<int> arr) {\n    // Map to hold digit names\n    map<int, string> digitNames = {\n        {1, \"One\"}, {2, \"Two\"}, {3, \"Three\"},\n        {4, \"Four\"}, {5, \"Five\"}, {6, \"Six\"},\n        {7, \"Seven\"}, {8, \"Eight\"}, {9, \"Nine\"}\n    };\n\n    vector<int> filteredArr;\n    \n    // Filter out integers that are not between 1 and 9\n    for (int num : arr) {\n        if (num >= 1 && num <= 9) {\n            filteredArr.push_back(num);\n        }\n    }\n\n    // Sort the filtered array\n    sort(filteredArr.begin(), filteredArr.end());\n\n    // Reverse the sorted array\n    reverse(filteredArr.begin(), filteredArr.end());\n\n    vector<string> result;\n    \n    // Replace each digit with its corresponding name\n    for (int num : filteredArr) {\n        result.push_back(digitNames[num]);\n    }\n\n    return result;\n}\n\n// Function to test the solution\nvoid check() {\n    vector<int> arr1 = {2, 1, 1, 4, 5, 8, 2, 3};\n    vector<string> expected1 = {\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"};\n    assert(by_length(arr1) == expected1);\n\n    vector<int> arr2 = {};\n    vector<string> expected2 = {};\n    assert(by_length(arr2) == expected2);\n\n    vector<int> arr3 = {1, -1, 55};\n    vector<string> expected3 = {\"One\"};\n    assert(by_length(arr3) == expected3);\n\n    cout << \"All tests passed successfully.\" << endl;\n}\n\n"}
{"task_id": "CPP/106", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// Function to calculate factorial\nint factorial(int num) {\n    int result = 1;\n    for (int i = 2; i <= num; ++i) {\n        result *= i;\n    }\n    return result;\n}\n\n// Function to calculate sum from 1 to num\nint sumToN(int num) {\n    return (num * (num + 1)) / 2; // Using the formula for the sum of first n natural numbers\n}\n\nvector<int> f(int n){\n    vector<int> result(n);\n    \n    for (int i = 0; i < n; ++i) {\n        int val = i + 1;\n        if (val % 2 == 0) { // If val is even\n            result[i] = factorial(val);\n        } else { // If val is odd\n            result[i] = sumToN(val);\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/107", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to check if a number is a palindrome\nbool isPalindrome(int num) {\n    string str = to_string(num);\n    int len = str.length();\n    for (int i = 0; i < len / 2; ++i) {\n        if (str[i] != str[len - i - 1]) return false;\n    }\n    return true;\n}\n\nvector<int> even_odd_palindrome(int n){\n    vector<int> result(2, 0); // Initialize a vector to store counts of even and odd palindromes\n    for (int i = 1; i <= n; ++i) {\n        if (isPalindrome(i)) { // Check if the number is a palindrome\n            if (i % 2 == 0) result[0]++; // Increment count of even palindromes\n            else result[1]++; // Increment count of odd palindromes\n        }\n    }\n    return result;\n}\n\n"}
{"task_id": "CPP/108", "generation": "#include <vector>\n#include <cmath> // for std::abs\n\nint count_nums(std::vector<int> n) {\n    int count = 0;\n    \n    for (auto num : n) {\n        int sum_of_digits = 0;\n        bool is_negative = num < 0; // Check if the number is negative\n        \n        while (num != 0) {\n            int digit = num % 10; // Get the last digit\n            sum_of_digits += digit;\n            num /= 10; // Remove the last digit\n            \n            // If it's the first iteration and the number was negative, adjust the first digit\n            if (is_negative && num == 0) {\n                sum_of_digits -= 2 * digit; // Subtract twice because we added once already\n            }\n        }\n\n        if (sum_of_digits > 0) {\n            count++;\n        }\n    }\n    \n    return count;\n}\n\n// Example usage:\n"}
{"task_id": "CPP/109", "generation": "#include <vector>\nusing namespace std;\n\nbool move_one_ball(vector<int> arr) {\n    if (arr.empty()) return true; // An empty array is trivially sorted.\n    \n    int n = arr.size();\n    bool foundBreakPoint = false;\n    \n    for (int i = 0; i < n - 1; ++i) {\n        if (arr[i] > arr[i + 1]) { // Found a break point\n            if (foundBreakPoint) return false; // More than one break point exists.\n            foundBreakPoint = true;\n            \n            // Check if the elements after the break point and before it form non-decreasing sequences.\n            // Also, check if the last element is less than or equal to the first element.\n            if ((i < n - 2 && arr[i + 1] > arr[i + 2]) || (arr[n-1] > arr[0])) {\n                return false;\n            }\n        }\n    }\n\n    // If there was no break point, the array is already sorted.\n    return true;\n}\n"}
{"task_id": "CPP/110", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring exchange(vector<int> lst1, vector<int> lst2) {\n    int oddCountLst1 = 0;\n    int evenCountLst2 = 0;\n\n    // Count the number of odd numbers in lst1\n    for (int num : lst1) {\n        if (num % 2 != 0) {\n            ++oddCountLst1;\n        }\n    }\n\n    // Count the number of even numbers in lst2\n    for (int num : lst2) {\n        if (num % 2 == 0) {\n            ++evenCountLst2;\n        }\n    }\n\n    // If there are enough even numbers in lst2 to replace all odd numbers in lst1, return \"YES\"\n    if (oddCountLst1 <= evenCountLst2) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n\n// Function to test the exchange function\nvoid test() {\n    cout << exchange({1, 2, 3, 4}, {1, 2, 3, 4}) << endl; // Expected output: YES\n    cout << exchange({1, 2, 3, 4}, {1, 5, 3, 4}) << endl; // Expected output: NO\n}\n\n"}
{"task_id": "CPP/111", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <map>\nusing namespace std;\n\nmap<char, int> histogram(string test) {\n    map<char, int> freqMap;\n    \n    // Parse the input string to count frequencies of each character\n    stringstream ss(test);\n    char ch;\n    while (ss >> ch) {\n        ++freqMap[ch];\n    }\n    \n    // Find the maximum frequency\n    int maxFreq = 0;\n    for (auto &p : freqMap) {\n        if (p.second > maxFreq) {\n            maxFreq = p.second;\n        }\n    }\n\n    // Create a map with only characters that have the maximum frequency\n    map<char, int> result;\n    for (auto &p : freqMap) {\n        if (p.second == maxFreq) {\n            result[p.first] = p.second;\n        }\n    }\n    \n    return result;\n}\n\n// Function to print the map for testing purposes\nvoid printHistogram(const map<char, int>& m) {\n    for (const auto& p : m) {\n        cout << \"{\" << p.first << \", \" << p.second << \"} \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/112", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to check if a string is a palindrome.\nbool isPalindrome(const string& str) {\n    int left = 0;\n    int right = str.size() - 1;\n    \n    while (left < right) {\n        if (str[left] != str[right]) return false;\n        ++left;\n        --right;\n    }\n    return true;\n}\n\nvector<string> reverse_delete(string s, string c) {\n    // Remove all characters in 's' that are present in 'c'\n    for(char ch : c) {\n        s.erase(remove(s.begin(), s.end(), ch), s.end());\n    }\n\n    // Check if the resulting string is a palindrome\n    bool result = isPalindrome(s);\n\n    vector<string> output;\n    output.push_back(s);\n    output.push_back(result ? \"True\" : \"False\");\n\n    return output;\n}\n\n"}
{"task_id": "CPP/113", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to replace all occurrences of 'i' in the template string with the given number.\nstring replace_i_with_count(const string& template_str, int count) {\n    string result;\n    for (char c : template_str) {\n        if (c == 'i') {\n            // Convert count to string and append it\n            result += to_string(count);\n        } else {\n            result += c;\n        }\n    }\n    return result;\n}\n\nvector<string> odd_count(vector<string> lst){\n    vector<string> output;\n    const string template_str = \"the number of odd elements in the strin of the input.\";\n    \n    for (const auto& s : lst) {\n        int count_odd = 0;\n        \n        // Counting odd digits\n        for (char c : s) {\n            if ((c - '0') % 2 != 0) { // Convert char to int and check if it's odd\n                ++count_odd;\n            }\n        }\n\n        // Replace all occurrences of 'i' in the template string with count_odd\n        output.push_back(replace_i_with_count(template_str, count_odd));\n    }\n    \n    return output;\n}\n\n// Function to test the solution.\nvoid test() {\n    vector<string> input1 = {\"1234567\"};\n    auto result1 = odd_count(input1);\n    for (const auto& s : result1) {\n        cout << s << endl;\n    }\n\n    vector<string> input2 = {\"3\", \"11111111\"};\n    auto result2 = odd_count(input2);\n    for (const auto& s : result2) {\n        cout << s << endl;\n    }\n}\n\n"}
{"task_id": "CPP/114", "generation": "#include <vector>\n#include <algorithm> // For std::min\n\nusing namespace std;\n\nlong long minSubArraySum(vector<long long> nums) {\n    if (nums.empty()) return 0; // Handle empty vector case\n    \n    long long currentMin = nums[0];\n    long long globalMin = nums[0];\n\n    for(size_t i = 1; i < nums.size(); ++i) {\n        currentMin = min(nums[i], currentMin + nums[i]);\n        if (currentMin < globalMin) {\n            globalMin = currentMin;\n        }\n    }\n\n    return globalMin;\n}\n\n// Example usage\n"}
{"task_id": "CPP/115", "generation": "#include <vector>\nusing namespace std;\n\nint max_fill(vector<vector<int>> grid, int bucket_capacity) {\n    int total_operations = 0;\n    \n    // Iterate over each row (well)\n    for(auto& well : grid) {\n        int water_units = 0;\n        \n        // Count the number of units of water in this well\n        for(int unit : well) {\n            if(unit == 1) {\n                ++water_units;\n            }\n        }\n        \n        // Calculate how many times we need to lower the bucket into this well\n        total_operations += (water_units + bucket_capacity - 1) / bucket_capacity;\n    }\n\n    return total_operations;\n}\n\n// Example usage:\n"}
{"task_id": "CPP/116", "generation": "#include <vector>\n#include <algorithm>\n\n// Function to count the number of 1s in the binary representation of an integer.\nint countOnes(int n) {\n    int count = 0;\n    while (n != 0) {\n        if (n & 1)\n            ++count;\n        n >>= 1; // Right shift by one bit\n    }\n    return count;\n}\n\n// Custom comparator function for sorting based on the problem's criteria.\nbool customComparator(int a, int b) {\n    int onesA = countOnes(a);\n    int onesB = countOnes(b);\n\n    if (onesA == onesB)\n        return a < b; // If number of 1s is the same, sort by decimal value\n    else\n        return onesA < onesB; // Otherwise, sort based on number of 1s\n}\n\nvector<int> sort_array(vector<int> arr) {\n    std::sort(arr.begin(), arr.end(), customComparator);\n    return arr;\n}\n"}
{"task_id": "CPP/117", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Helper function to check if a character is a consonant\nbool isConsonant(char c) {\n    string vowels = \"aeiouAEIOU\";\n    return !vowels.find(c) && (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z');\n}\n\n// Main function to select words with exactly n consonants\nvector<string> select_words(string s, int n) {\n    vector<string> result;\n    string word = \"\";\n    \n    // Iterate through the string and split it into words\n    for (char ch : s) {\n        if (ch == ' ') {  // If space is encountered, process the current word\n            if (!word.empty()) {\n                int consonantCount = count_if(word.begin(), word.end(), isConsonant);\n                if (consonantCount == n)\n                    result.push_back(word);\n                word.clear();  // Reset for next word\n            }\n        } else {  // Build the current word\n            word += ch;\n        }\n    }\n\n    // Process the last word in case there's no trailing space\n    if (!word.empty()) {\n        int consonantCount = count_if(word.begin(), word.end(), isConsonant);\n        if (consonantCount == n)\n            result.push_back(word);\n    }\n\n    return result;\n}\n\n// Function to test the solution with given examples\nvoid check() {\n    vector<string> res;\n\n    res = select_words(\"Mary had a little lamb\", 4);\n    for (string s : res) cout << s << \" \";\n    cout << endl; // Expected: {\"little\"}\n\n    res = select_words(\"Mary had a little lamb\", 3);\n    for (string s : res) cout << s << \" \";\n    cout << endl; // Expected: {\"Mary\", \"lamb\"}\n\n    res = select_words(\"simple white space\", 2);\n    for (string s : res) cout << s << \" \";\n    cout << endl; // Expected: {}\n\n    res = select_words(\"Hello world\", 4);\n    for (string s : res) cout << s << \" \";\n    cout << endl; // Expected: {\"world\"}\n\n    res = select_words(\"Uncle sam\", 3);\n    for (string s : res) cout << s << \" \";\n    cout << endl; // Expected: {\"Uncle\"}\n}\n\n"}
{"task_id": "CPP/118", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_vowel(char c) {\n    return c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' ||\n           c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U';\n}\n\nstring get_closest_vowel(string word) {\n    int n = word.length();\n    \n    for (int i = n - 2; i > 0; --i) { // Start from the second last character and move left\n        if (is_vowel(word[i]) && !is_vowel(word[i-1]) && !is_vowel(word[i+1])) {\n            return string(1, word[i]); // Return the vowel as a single-character string\n        }\n    }\n\n    return \"\"; // No such vowel found\n}\n\n"}
{"task_id": "CPP/119", "generation": "#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to check if parentheses are balanced.\nbool isBalanced(const string& s) {\n    int balance = 0;\n    for (char c : s) {\n        if (c == '(') ++balance;\n        else --balance;\n        \n        // If at any point the balance goes negative, it means there's an unmatched ')'\n        if (balance < 0) return false;\n    }\n    \n    // The string is balanced only if the final balance is zero.\n    return balance == 0;\n}\n\nstring match_parens(vector<string> lst){\n    int open1 = 0, close1 = 0, open2 = 0, close2 = 0;\n\n    // Counting open and close parentheses in both strings\n    for (char c : lst[0]) {\n        if (c == '(') ++open1;\n        else ++close1;\n    }\n    \n    for (char c : lst[1]) {\n        if (c == '(') ++open2;\n        else ++close2;\n    }\n\n    // Check both possible concatenations\n    if ((open1 - close1 + open2 >= close2) && (open2 - close2 + open1 >= close1)) return \"Yes\";\n    \n    return \"No\";\n}\n"}
{"task_id": "CPP/120", "generation": "#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> maximum(vector<int> arr, int k) {\n    // First, sort the array in ascending order\n    sort(arr.begin(), arr.end());\n    \n    // Create a result vector to store the largest k elements\n    vector<int> result;\n    \n    // Extract the last k elements from the sorted vector\n    for (int i = 0; i < k; ++i) {\n        result.push_back(arr[arr.size() - 1 - i]);\n    }\n    \n    // Since we want the output in ascending order, sort it again before returning\n    sort(result.begin(), result.end());\n    \n    return result;\n}\n"}
{"task_id": "CPP/121", "generation": "#include <vector>\nusing namespace std;\n\nint solution(vector<int> lst) {\n    int sum = 0;\n    \n    // Iterate through the vector, starting from index 0 and incrementing by 2 to get even positions.\n    for (size_t i = 0; i < lst.size(); i += 2) { \n        if (lst[i] % 2 != 0) { // Check if the element at position i is odd\n            sum += lst[i];     // Add it to the sum if it's odd.\n        }\n    }\n\n    return sum;\n}\n"}
{"task_id": "CPP/122", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint add_elements(vector<int> arr, int k) {\n    // Initialize the sum to zero.\n    int sum = 0;\n    \n    // Iterate through the first 'k' elements of the vector.\n    for (int i = 0; i < k; ++i) {\n        // Check if the current element has at most two digits.\n        if (arr[i] >= 0 && arr[i] <= 99) {\n            sum += arr[i];  // Add it to the sum if it does.\n        }\n    }\n    \n    return sum;\n}\n\n"}
{"task_id": "CPP/123", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // For std::sort\n\nusing namespace std;\n\nvector<int> get_odd_collatz(int n) {\n    vector<int> oddNumbers;\n    \n    while (n != 1) { // Continue until we reach 1\n        if (n % 2 == 1) { // If the number is odd, add it to our list of odd numbers\n            oddNumbers.push_back(n);\n        }\n        n = (n % 2 == 0) ? n / 2 : 3 * n + 1; // Apply Collatz rules\n    }\n    \n    if (n % 2 == 1) { // Add the last number, which is always 1 and odd.\n        oddNumbers.push_back(n);\n    }\n\n    sort(oddNumbers.begin(), oddNumbers.end()); // Sort the vector in increasing order\n    \n    return oddNumbers;\n}\n\n// Function to test the solution\nvoid check() {\n    vector<int> result = get_odd_collatz(5);\n    for (int num : result) {\n        cout << num << \" \";\n    }\n    cout << endl; // Expected output: 1 5\n}\n\n"}
{"task_id": "CPP/124", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool valid_date(string date) {\n    // Check if the string is empty or not of length 10 (mm-dd-yyyy)\n    if(date.empty() || date.length() != 10) return false;\n    \n    // Validate format mm-dd-yyyy\n    if(date[2] != '-' || date[5] != '-') return false;\n\n    // Extract month, day and year from the string\n    int month = stoi(date.substr(0, 2));\n    int day = stoi(date.substr(3, 2));\n    int year = stoi(date.substr(6, 4));\n\n    // Validate month range (1-12)\n    if(month < 1 || month > 12) return false;\n\n    // Validate day based on the month\n    if((month == 4 || month == 6 || month == 9 || month == 11) && (day < 1 || day > 30)) return false;\n    else if(month != 2 && (day < 1 || day > 31)) return false;\n\n    // For February, we assume non-leap years for simplicity\n    if(month == 2 && (day < 1 || day > 29)) return false;\n\n    return true;\n}\n\n"}
{"task_id": "CPP/125", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nvector<string> split_words(string txt){\n    // Check for whitespace\n    if (txt.find(' ') != string::npos) {\n        return split_on_whitespace(txt);\n    }\n    \n    // Check for comma\n    else if (txt.find(',') != string::npos) {\n        return split_on_comma(txt);\n    }\n\n    // No whitespaces or commas, count odd order lowercase letters\n    int oddCount = 0;\n    for(char c : txt){\n        if(islower(c) && ((c - 'a') % 2 == 1)){\n            ++oddCount;\n        }\n    }\n    \n    return {to_string(oddCount)};\n}\n\nvector<string> split_on_whitespace(string str){\n    vector<string> result;\n    string word = \"\";\n    for(char c : str){\n        if(c == ' ' && !word.empty()){\n            result.push_back(word);\n            word = \"\";\n        } else {\n            word += c;\n        }\n    }\n    if(!word.empty()) result.push_back(word); // Add the last word\n    return result;\n}\n\nvector<string> split_on_comma(string str){\n    vector<string> result;\n    string word = \"\";\n    for(char c : str){\n        if(c == ',' && !word.empty()){\n            result.push_back(word);\n            word = \"\";\n        } else {\n            word += c;\n        }\n    }\n    if(!word.empty()) result.push_back(word); // Add the last word\n    return result;\n}\n\n// Function to test the solution with given examples\nvoid check(){\n    vector<string> res1 = split_words(\"Hello world!\");\n    for(auto s : res1) cout << s << \" \";\n    cout << endl;\n\n    vector<string> res2 = split_words(\"Hello,world!\");\n    for(auto s : res2) cout << s << \" \";\n    cout << endl;\n    \n    vector<string> res3 = split_words(\"abcdef\");\n    for(auto s : res3) cout << s << \" \";\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/126", "generation": "#include <vector>\n#include <algorithm>\n\nbool is_sorted(std::vector<int> lst) {\n    // Check if the vector is empty or has only one element, which means it's sorted.\n    if (lst.size() <= 1) return true;\n\n    int count = 1; // Initialize a counter for consecutive elements\n    for (size_t i = 1; i < lst.size(); ++i) {\n        // If the current number is less than the previous one, the list isn't sorted.\n        if (lst[i] < lst[i - 1]) return false;\n        \n        // Check how many times a number appears consecutively\n        if (lst[i] == lst[i - 1]) {\n            count++;\n            // If any number appears more than twice, return false.\n            if (count > 2) return false;\n        } else {\n            count = 1; // Reset the counter for new numbers\n        }\n    }\n\n    return true;\n}\n"}
{"task_id": "CPP/127", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\n// Function to check if a number is prime.\nbool isPrime(int n) {\n    if (n <= 1)\n        return false;\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0)\n            return false;\n    }\n    return true;\n}\n\nstring intersection(vector<int> interval1, vector<int> interval2) {\n    // Determine the start and end of the intersection.\n    int startMax = max(interval1[0], interval2[0]);\n    int endMin = min(interval1[1], interval2[1]);\n\n    // Check if there is an intersection.\n    if (startMax > endMin)\n        return \"NO\";  // No intersection.\n\n    // Calculate the length of the intersection.\n    int length = endMin - startMax + 1;\n\n    // Check if the length is a prime number.\n    if (isPrime(length))\n        return \"YES\";\n    else\n        return \"NO\";\n}\n\n"}
{"task_id": "CPP/128", "generation": "#include <vector>\n#include <cmath> // For std::abs\n\nint prod_signs(std::vector<int> arr) {\n    if (arr.empty()) {  // Check for an empty array\n        return -32768;\n    }\n\n    int sum_of_magnitudes = 0;  // To store the sum of absolute values\n    int product_of_signs = 1;   // Initialize to 1, as it's a multiplicative identity\n\n    for (int num : arr) {\n        if (num == 0) {  // If any number is zero, the whole product becomes zero.\n            return 0;\n        }\n        sum_of_magnitudes += std::abs(num);  // Add absolute value to the sum\n        product_of_signs *= (num > 0 ? 1 : -1);  // Multiply by sign of num\n    }\n\n    return sum_of_magnitudes * product_of_signs;  // Return the final result\n}\n"}
{"task_id": "CPP/129", "generation": "#include <vector>\n#include <queue>\nusing namespace std;\n\n// Define a structure to hold the path and its current state.\nstruct Path {\n    vector<int> values; // The sequence of cell values visited so far.\n    int row, col;       // Current position on the grid.\n    int length;         // Length of the path so far.\n\n    bool operator<(const Path& other) const {\n        return values > other.values;\n    }\n};\n\nvector<int> minPath(vector<vector<int>>& grid, int k) {\n    int N = grid.size();\n    vector<int> directions = {-1, 0, 1, 0, -1}; // For moving in four possible directions.\n\n    // Priority queue to store paths. The smallest path comes first.\n    priority_queue<Path> pq;\n\n    // Initialize the priority queue with all possible starting points.\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            pq.push({{grid[i][j]}, i, j, 1});\n        }\n    }\n\n    // Process the paths until we find one of length k.\n    while (!pq.empty()) {\n        Path currentPath = pq.top();\n        pq.pop();\n\n        if (currentPath.length == k) return currentPath.values;\n\n        for (int d = 0; d < 4; ++d) { // Explore all four possible directions.\n            int newRow = currentPath.row + directions[d];\n            int newCol = currentPath.col + directions[d+1];\n\n            // Check if the new position is within bounds and not out of grid.\n            if (newRow >= 0 && newRow < N && newCol >= 0 && newCol < N) {\n                vector<int> newPathValues(currentPath.values);\n                newPathValues.push_back(grid[newRow][newCol]);\n                pq.push({newPathValues, newRow, newCol, currentPath.length + 1});\n            }\n        }\n    }\n\n    // If no path of length k is found (which shouldn't happen given the problem constraints), return an empty vector.\n    return {};\n}\n"}
{"task_id": "CPP/130", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> tri(int n){\n    vector<int> result(n+1);\n    \n    // Base cases\n    if (n >= 1) {\n        result[1] = 3;\n    }\n    if (n >= 2) {\n        result[2] = 1 + 2 / 2; // Simplifies to 2 as per the given rule for even n.\n    }\n\n    // Fill in the rest of the sequence\n    for(int i = 3; i <= n; ++i){\n        if(i % 2 == 0) {\n            result[i] = 1 + i / 2;\n        } else {\n            result[i] = result[i-1] + result[i-2] + (i >= 4 ? result[i-3] : 0);\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/131", "generation": "#include <iostream> // Corrected header for input/output operations\n\nint digits(int n) {\n    int product = 1; // Initialize product to 1 (multiplicative identity)\n    bool hasOddDigit = false; // Flag to check if there's at least one odd digit\n    \n    while (n > 0) {\n        int digit = n % 10; // Extract the last digit\n        if (digit % 2 != 0) { // Check if the digit is odd\n            product *= digit;\n            hasOddDigit = true;\n        }\n        n /= 10; // Remove the last digit from n\n    }\n\n    return hasOddDigit ? product : 0; // Return 0 if no odd digits were found, else return the product\n}\n\n"}
{"task_id": "CPP/132", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_nested(string str) {\n    int depth = 0;\n    bool hasNested = false; // Flag to check if there was any nesting\n\n    for (char c : str) {\n        if (c == '[') {\n            depth++;\n            if (depth > 1) {\n                hasNested = true; // Found a nested pair\n            }\n        } else if (c == ']') {\n            if (depth > 0) {\n                depth--;\n            } else {\n                return false; // Invalid sequence, closing bracket without matching opening\n            }\n        }\n    }\n\n    return hasNested && depth == 0;\n}\n\n"}
{"task_id": "CPP/133", "generation": "#include <stdio.h>\n#include <math.h>\n#include <vector>\nusing namespace std;\n\nint sum_squares(vector<float> lst) {\n    int sum = 0;\n    \n    // Iterate through each element in the vector\n    for (float num : lst) {\n        // Round up to the nearest integer and square it\n        float rounded_num = ceil(num);\n        int squared_value = static_cast<int>(rounded_num * rounded_num);\n        \n        // Add the squared value to the sum\n        sum += squared_value;\n    }\n    \n    return sum;\n}\n\n// Example usage:\n"}
{"task_id": "CPP/134", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool check_if_last_char_is_a_letter(string txt) {\n    // Check for empty string or a string that ends with space.\n    if (txt.empty() || txt.back() == ' ') return false;\n    \n    // Get the last character of the string\n    char lastChar = txt.back();\n    \n    // Check if it's an alphabetical character and not part of any word\n    bool isAlphabetical = isalpha(lastChar);\n    bool isNotPartOfWord = (txt.size() == 1 || txt[txt.size()-2] == ' ');\n    \n    return isAlphabetical && isNotPartOfWord;\n}\n\n"}
{"task_id": "CPP/135", "generation": "#include <vector>\nusing namespace std;\n\nint can_arrange(vector<int> arr) {\n    // Iterate through the vector starting from the second element.\n    for (size_t i = 1; i < arr.size(); ++i) {\n        // Check if current element is not greater than or equal to its predecessor.\n        if (arr[i] < arr[i - 1]) {\n            return static_cast<int>(i); // Return the index of this element.\n        }\n    }\n    // If no such element found, return -1.\n    return -1;\n}\n"}
{"task_id": "CPP/136", "generation": "#include <vector>\n#include <climits> // For INT_MIN and INT_MAX\n\nusing namespace std;\n\nvector<int> largest_smallest_integers(vector<int> lst) {\n    int largestNegative = INT_MIN; // Initialize with the smallest possible integer value.\n    int smallestPositive = INT_MAX; // Initialize with the largest possible integer value.\n\n    for (int num : lst) {\n        if (num < 0 && num > largestNegative) {\n            largestNegative = num;\n        } else if (num > 0 && num < smallestPositive) {\n            smallestPositive = num;\n        }\n    }\n\n    // If no negative numbers were found, set largestNegative to 0.\n    if (largestNegative == INT_MIN) {\n        largestNegative = 0;\n    }\n\n    // If no positive numbers were found, set smallestPositive to 0.\n    if (smallestPositive == INT_MAX) {\n        smallestPositive = 0;\n    }\n\n    return {largestNegative, smallestPositive};\n}\n\n// Example usage\n"}
{"task_id": "CPP/137", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <locale>\n#include <sstream>\n#include <boost/any.hpp>\n\nusing namespace std;\n\n// Function to convert a string with either '.' or ',' as decimal separator to float.\nfloat parse_float(const string& str) {\n    string temp = str;\n    // Replace comma with dot if it exists\n    replace(temp.begin(), temp.end(), ',', '.');\n    stringstream ss(temp);\n    float result;\n    ss >> result;\n    return result;\n}\n\n// Function to compare two values of any type and return the larger one.\nboost::any compare_one(boost::any a, boost::any b) {\n    // Convert both inputs to strings for uniform processing\n    string str_a = boost::any_cast<string>(a);\n    string str_b = boost::any_cast<string>(b);\n\n    try {\n        // Attempt to parse the values as floats.\n        float num_a = parse_float(str_a);\n        float num_b = parse_float(str_b);\n\n        if (num_a > num_b) return a;\n        else if (num_a < num_b) return b;\n        else return \"None\";  // If they are equal\n    } catch (...) {\n        // In case of conversion failure, compare the strings directly.\n        if (str_a > str_b) return a;\n        else if (str_a < str_b) return b;\n        else return \"None\";\n    }\n}\n\n"}
{"task_id": "CPP/138", "generation": "#include<stdio.h>\nusing namespace std;\n\nbool is_equal_to_sum_even(int n) {\n    // Check if n is even and greater than or equal to 8.\n    return (n >= 8 && n % 2 == 0);\n}\n\n"}
{"task_id": "CPP/139", "generation": "#include <iostream>\nusing namespace std;\n\n// Function to calculate factorial of a given number.\nlong long factorial(int num) {\n    if (num == 0 || num == 1)\n        return 1;\n    else\n        return num * factorial(num - 1);\n}\n\n// Function to calculate the Brazilian factorial as defined.\nlong long special_factorial(int n){\n    long long result = 1; // Initialize result with 1 because we are multiplying.\n    \n    for (int i = 1; i <= n; ++i) {\n        result *= factorial(i); // Multiply each factorial from 1 to n\n    }\n    \n    return result;\n}\n\n// Example usage:\n"}
{"task_id": "CPP/140", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring fix_spaces(string text) {\n    string result;\n    int space_count = 0; // Counter for consecutive spaces\n\n    for (char c : text) {\n        if (c == ' ') {\n            ++space_count;\n        } else {\n            if (space_count > 0) {\n                if (space_count <= 2) {\n                    while (space_count-- > 0)\n                        result += '_';\n                } else {\n                    result += '-';\n                }\n                space_count = 0; // Reset the counter\n            }\n            result += c;\n        }\n    }\n\n    // Handle trailing spaces\n    if (space_count > 0) {\n        if (space_count <= 2) {\n            while (space_count-- > 0)\n                result += '_';\n        } else {\n            result += '-';\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/141", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool hasMoreThanThreeDigits(const string& str) {\n    int digitCount = 0;\n    for (char ch : str) {\n        if (isdigit(ch)) {\n            ++digitCount;\n            if (digitCount > 3) return true;\n        }\n    }\n    return false;\n}\n\nstring file_name_check(string file_name){\n    // Check the number of digits\n    if(hasMoreThanThreeDigits(file_name)) return \"No\";\n    \n    size_t dotPos = file_name.find('.');\n    // Ensure there is exactly one dot and it's not at the beginning or end\n    if(dotPos == string::npos || dotPos == 0 || dotPos == file_name.length() - 1) {\n        return \"No\";\n    }\n    \n    string prefix = file_name.substr(0, dotPos);\n    string extension = file_name.substr(dotPos + 1);\n\n    // Check the prefix\n    if(prefix.empty() || !isalpha(prefix[0])) return \"No\";\n\n    // Validate the extension\n    const string validExtensions[] = {\"txt\", \"exe\", \"dll\"};\n    for(const auto& ext : validExtensions) {\n        if(extension == ext) return \"Yes\";\n    }\n    \n    return \"No\";\n}\n\n"}
{"task_id": "CPP/142", "generation": "#include <vector>\nusing namespace std;\n\nint sum_squares(vector<int> lst) {\n    int sum = 0;\n    \n    for (size_t i = 0; i < lst.size(); ++i) {\n        if (i % 3 == 0 && i != 0) { // Check if index is a multiple of 3 and not zero\n            sum += lst[i] * lst[i]; // Square the element\n        } else if (i % 4 == 0 && i != 0) { // Check if index is a multiple of 4 but not multiples of 3\n            sum += lst[i] * lst[i] * lst[i]; // Cube the element\n        } else {\n            sum += lst[i]; // Add the element as it is\n        }\n    }\n\n    return sum;\n}\n\n// Example usage:\n"}
{"task_id": "CPP/143", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\n// Helper function to check if a number is prime.\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\n// Main function to filter words based on prime length.\nstring words_in_sentence(string sentence) {\n    stringstream ss(sentence);\n    string word, result;\n    \n    while (ss >> word) { // Extract each word from the sentence\n        if (is_prime(word.length())) {\n            if (!result.empty()) result += \" \"; // Add space before appending new word\n            result += word;\n        }\n    }\n\n    return result;\n}\n\n// Function to test our solution with given examples.\nvoid check() {\n    cout << words_in_sentence(\"This is a test\") << endl;  // Expected: \"is\"\n    cout << words_in_sentence(\"lets go for swimming\") << endl;  // Expected: \"go for\"\n}\n\n"}
{"task_id": "CPP/144", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nbool simplify(string x, string n) {\n    // Parse fractions from strings\n    size_t slashPosX = x.find('/');\n    int num1 = stoi(x.substr(0, slashPosX));\n    int den1 = stoi(x.substr(slashPosX + 1));\n\n    size_t slashPosN = n.find('/');\n    int num2 = stoi(n.substr(0, slashPosN));\n    int den2 = stoi(n.substr(slashPosN + 1));\n\n    // Multiply the fractions\n    int numeratorResult = num1 * num2;\n    int denominatorResult = den1 * den2;\n\n    // Check if the result is a whole number\n    return (numeratorResult % denominatorResult == 0);\n}\n\n"}
{"task_id": "CPP/145", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\n// Helper function to calculate the sum of digits of an integer.\nint sum_of_digits(int n) {\n    int sum = 0;\n    while (n != 0) {\n        sum += n % 10;\n        n /= 10;\n    }\n    return sum;\n}\n\nvector<int> order_by_points(vector<int> nums) {\n    // Create a vector of pairs to store the original index and digit sum\n    std::vector<std::pair<int, int>> indexed_nums(nums.size());\n    \n    for (size_t i = 0; i < nums.size(); ++i) {\n        indexed_nums[i] = {sum_of_digits(nums[i]), static_cast<int>(i)};\n    }\n    \n    // Sort the vector of pairs by digit sum and then by original index\n    std::stable_sort(indexed_nums.begin(), indexed_nums.end(),\n                     [](const auto& a, const auto& b) {\n                         if (a.first == b.first)\n                             return a.second < b.second;\n                         else\n                             return a.first < b.first;\n                     });\n    \n    // Reconstruct the sorted vector of integers based on the original indices\n    std::vector<int> result(nums.size());\n    for (size_t i = 0; i < indexed_nums.size(); ++i) {\n        result[i] = nums[indexed_nums[i].second];\n    }\n    \n    return result;\n}\n\n// Function to test and print the results.\nvoid check(const std::vector<int>& input, const std::vector<int>& expected_output) {\n    auto output = order_by_points(input);\n    if (output == expected_output) {\n        std::cout << \"Test passed.\" << std::endl;\n    } else {\n        std::cout << \"Test failed. Expected: \";\n        for (int num : expected_output)\n            std::cout << num << ' ';\n        std::cout << \"\\nGot: \";\n        for (int num : output)\n            std::cout << num << ' ';\n        std::cout << std::endl;\n    }\n}\n\n"}
{"task_id": "CPP/146", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nbool isFirstAndLastDigitOdd(int num) {\n    // Convert number to string to easily access digits\n    string strNum = to_string(abs(num));  // Use abs to handle negative numbers\n\n    char firstDigit = strNum[0];\n    char lastDigit = strNum[strNum.length() - 1];\n\n    // Check if both the first and last digit are odd\n    return (firstDigit == '1' || firstDigit == '3' || firstDigit == '5' || \n            firstDigit == '7' || firstDigit == '9') &&\n           (lastDigit == '1' || lastDigit == '3' || lastDigit == '5' ||\n            lastDigit == '7' || lastDigit == '9');\n}\n\nint specialFilter(vector<int> nums) {\n    int count = 0;\n    for(int num : nums) {\n        if(num > 10 && isFirstAndLastDigitOdd(num)) {\n            ++count;\n        }\n    }\n    return count;\n}\n\n// Function to test the solution\nvoid check() {\n    cout << (specialFilter({15, -73, 14, -15}) == 1 ? \"Test 1 Passed\" : \"Test 1 Failed\") << endl;\n    cout << (specialFilter({33, -2, -3, 45, 21, 109}) == 2 ? \"Test 2 Passed\" : \"Test 2 Failed\") << endl;\n}\n\n"}
{"task_id": "CPP/147", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint get_max_triples(int n) {\n    vector<int> a(n);\n    // Generate the array a\n    for (int i = 1; i <= n; ++i) {\n        a[i-1] = i * i - i + 1;\n    }\n\n    int count[3] = {0}; // To store counts of remainders when divided by 3\n\n    // Count the number of elements with each remainder\n    for (int num : a) {\n        ++count[num % 3];\n    }\n\n    // Calculate the number of valid triples\n    long long result = 0;\n\n    // Case 1: All three numbers have a remainder of 0 when divided by 3.\n    result += count[0] * (count[0] - 1) * (count[0] - 2) / 6;\n    \n    // Case 2: All three numbers have a remainder of 1 or all have a remainder of 2\n    result += count[1] * (count[1] - 1) * (count[1] - 2) / 6;\n    result += count[2] * (count[2] - 1) * (count[2] - 2) / 6;\n\n    // Case 3: One number has a remainder of 0, one has a remainder of 1, and one has a remainder of 2\n    result += count[0] * count[1] * count[2];\n\n    return result;\n}\n\n"}
{"task_id": "CPP/148", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> bf(string planet1, string planet2) {\n    // List of planets in order from closest to farthest from the Sun.\n    vector<string> planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n    \n    int index1 = -1, index2 = -1;\n    \n    // Find indices of planet1 and planet2 in the list.\n    for (int i = 0; i < planets.size(); ++i) {\n        if (planets[i] == planet1)\n            index1 = i;\n        else if (planets[i] == planet2)\n            index2 = i;\n        \n        // If both indices are found, break the loop.\n        if (index1 != -1 && index2 != -1)\n            break;\n    }\n    \n    // Check if either of the planets was not found in the list.\n    if (index1 == -1 || index2 == -1) {\n        return {};  // Return an empty vector.\n    }\n\n    // Ensure index1 is less than index2 for simplicity.\n    if (index1 > index2)\n        swap(index1, index2);\n\n    // Collect planets between the two indices.\n    vector<string> result;\n    for (int i = index1 + 1; i < index2; ++i) {\n        result.push_back(planets[i]);\n    }\n    \n    return result;\n}\n\n// Function to test the bf function with given examples\nvoid check() {\n    auto res1 = bf(\"Jupiter\", \"Neptune\");\n    for (auto& planet : res1)\n        cout << planet << \" \";\n    cout << endl;\n\n    auto res2 = bf(\"Earth\", \"Mercury\");\n    for (auto& planet : res2)\n        cout << planet << \" \";\n    cout << endl;\n\n    auto res3 = bf(\"Mercury\", \"Uranus\");\n    for (auto& planet : res3)\n        cout << planet << \" \";\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/149", "generation": "#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to sort and filter the vector of strings as per requirements.\nvector<string> sorted_list_sum(vector<string> lst) {\n    // Remove elements with odd lengths\n    lst.erase(remove_if(lst.begin(), lst.end(), [](const string& s){ return s.size() % 2 != 0; }), lst.end());\n    \n    // Sort by length, then alphabetically if lengths are equal.\n    sort(lst.begin(), lst.end(), [](const string& a, const string& b){\n        if (a.length() == b.length()) {\n            return a < b;\n        }\n        return a.length() < b.length();\n    });\n    \n    return lst;\n}\n\n// Example usage and check function\nvoid assert_vector_sort(vector<string> input, vector<string> expected) {\n    auto result = sorted_list_sum(input);\n    if (result == expected) {\n        printf(\"Test passed.\\n\");\n    } else {\n        printf(\"Test failed. Expected: \");\n        for (const auto& str : expected) printf(\"%s \", str.c_str());\n        printf(\"\\nGot: \");\n        for (const auto& str : result) printf(\"%s \", str.c_str());\n        printf(\"\\n\");\n    }\n}\n\n"}
{"task_id": "CPP/150", "generation": "#include<iostream>\nbool is_prime(int n){\n    if(n <= 1) return false;\n    for(int i = 2; i * i <= n; ++i){\n        if(n % i == 0) return false;\n    }\n    return true;\n}\n\nint x_or_y(int n, int x, int y){\n    // Check if n is a prime number\n    if(is_prime(n)){\n        return x; // Return x if n is prime\n    } else {\n        return y; // Otherwise return y\n    }\n}\n\n// Function to test the correctness of the solution\nvoid check(){\n    std::cout << (x_or_y(7, 34, 12) == 34 ? \"Pass\" : \"Fail\") << std::endl;\n    std::cout << (x_or_y(15, 8, 5) == 5 ? \"Pass\" : \"Fail\") << std::endl;\n}\n\n"}
{"task_id": "CPP/151", "generation": "#include <vector>\nusing namespace std;\n\nlong long double_the_difference(vector<float> lst) {\n    long long sum = 0;\n    \n    for (float num : lst) {\n        // Check if number is positive, an integer and odd.\n        if (num > 0 && floor(num) == num && static_cast<int>(num) % 2 != 0) {\n            sum += pow(static_cast<long long>(num), 2);\n        }\n    }\n\n    return sum;\n}\n"}
{"task_id": "CPP/152", "generation": "#include <iostream>\n#include <vector>\n#include <cmath> // For std::abs\n\nusing namespace std;\n\nvector<int> compare(vector<int> game, vector<int> guess) {\n    vector<int> result;\n    \n    // Ensure both vectors have the same size.\n    if (game.size() != guess.size()) {\n        throw invalid_argument(\"Vectors must be of equal length.\");\n    }\n    \n    for(size_t i = 0; i < game.size(); ++i) {\n        int difference = std::abs(game[i] - guess[i]);\n        result.push_back(difference);\n    }\n\n    return result;\n}\n\n// Function to test the compare function\nvoid test() {\n    vector<int> scores1 = {1,2,3,4,5,1};\n    vector<int> guesses1 = {1,2,3,4,2,-2};\n    vector<int> expected1 = {0,0,0,0,3,3};\n    \n    assert(compare(scores1, guesses1) == expected1);\n    \n    vector<int> scores2 = {0,5,0,0,0,4};\n    vector<int> guesses2 = {4,1,1,0,0,-2};\n    vector<int> expected2 = {4,4,1,0,0,6};\n    \n    assert(compare(scores2, guesses2) == expected2);\n    \n    cout << \"All tests passed successfully.\" << endl;\n}\n\n"}
{"task_id": "CPP/153", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nint calculateStrength(const string& extension) {\n    int uppercase = 0;\n    int lowercase = 0;\n    for (char c : extension) {\n        if (isupper(c)) uppercase++;\n        else if (islower(c)) lowercase++;\n    }\n    return uppercase - lowercase;\n}\n\nstring Strongest_Extension(string class_name, vector<string> extensions){\n    string strongest_extension = \"\";\n    int max_strength = INT_MIN; // Initialize with the smallest possible integer\n\n    for (const auto& extension : extensions) {\n        int strength = calculateStrength(extension);\n        if (strength > max_strength || (strength == max_strength && strongest_extension.empty())) {\n            max_strength = strength;\n            strongest_extension = extension;\n        }\n    }\n\n    return class_name + \".\" + strongest_extension;\n}\n\n// Example usage\n"}
{"task_id": "CPP/154", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nbool cycpattern_check(string a, string b) {\n    // Concatenate the first string with itself.\n    string double_a = a + a;\n    \n    // Check if b is a substring of this concatenated version.\n    return (double_a.find(b) != string::npos);\n}\n\n"}
{"task_id": "CPP/155", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<int> even_odd_count(int num){\n    // Convert number to its absolute value to handle negative numbers\n    int abs_num = abs(num);\n    \n    // Convert integer to string for easy digit extraction\n    string str_num = to_string(abs_num);\n\n    // Initialize counters for even and odd digits\n    int even_count = 0;\n    int odd_count = 0;\n\n    // Iterate through each character in the string\n    for (char &c : str_num) {\n        // Convert char to integer digit\n        int digit = c - '0';\n        \n        // Check if the digit is even or odd and increment respective counter\n        if (digit % 2 == 0) {\n            even_count++;\n        } else {\n            odd_count++;\n        }\n    }\n\n    // Return a vector with counts of even and odd digits\n    return {even_count, odd_count};\n}\n\n// Function to test the solution\nvoid check() {\n    vector<int> result = even_odd_count(-12);\n    cout << \"even_odd_count(-12) -> {\" << result[0] << \", \" << result[1] << \"}\" << endl;\n    \n    result = even_odd_count(123);\n    cout << \"even_odd_count(123) -> {\" << result[0] << \", \" << result[1] << \"}\" << endl;\n}\n\n"}
{"task_id": "CPP/156", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring int_to_mini_roman(int number) {\n    // Define arrays for Roman numeral symbols and their corresponding values.\n    string thousands[] = {\"\", \"m\", \"mm\", \"mmm\"};\n    string hundreds[]  = {\"\", \"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"};\n    string tens[]      = {\"\", \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\"};\n    string ones[]      = {\"\", \"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\", \"ix\"};\n\n    // Extract the thousands, hundreds, tens and ones digits from the number.\n    int t = number / 1000;\n    int h = (number % 1000) / 100;\n    int te = (number % 100) / 10;\n    int o = number % 10;\n\n    // Concatenate the Roman numeral representations of each digit.\n    string romanNumeral = thousands[t] + hundreds[h] + tens[te] + ones[o];\n\n    return romanNumeral;\n}\n\n"}
{"task_id": "CPP/157", "generation": "#include <iostream>\n#include <cmath>\n\nbool right_angle_triangle(float a, float b, float c){\n    // First, sort the sides so that c is always the longest side.\n    if (a > c) std::swap(a, c);\n    if (b > c) std::swap(b, c);\n\n    // Check if the triangle satisfies the Pythagorean theorem\n    return fabs(a*a + b*b - c*c) < 1e-6; // Using a small threshold to account for floating point precision errors.\n}\n\n"}
{"task_id": "CPP/158", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nbool compare(const string& a, const string& b) {\n    // First, check for unique character count.\n    int uniqueA = set<char>(a.begin(), a.end()).size();\n    int uniqueB = set<char>(b.begin(), b.end()).size();\n\n    if (uniqueA != uniqueB)\n        return uniqueA > uniqueB;  // More unique characters come first.\n\n    // If the number of unique characters is equal, compare lexicographically.\n    return a < b;\n}\n\nstring find_max(vector<string> words) {\n    sort(words.begin(), words.end(), compare);\n    return words.front();  // The first element after sorting will be our answer.\n}\n\n"}
{"task_id": "CPP/159", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> eat(int number, int need, int remaining) {\n    // Calculate the total number of carrots eaten after trying to eat 'need' more.\n    int totalEaten = number + min(need, remaining);\n    \n    // Calculate the number of carrots left after eating as many as possible.\n    int carrotsLeft = max(remaining - need, 0);\n    \n    return {totalEaten, carrotsLeft};\n}\n"}
{"task_id": "CPP/160", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nint do_algebra(vector<string> operators, vector<int> operands) {\n    if (operands.size() <= 1 || operators.empty()) return operands[0]; // Base case: no operations to perform\n\n    int result = operands[0];\n    \n    for(size_t i = 0; i < operators.size(); ++i){\n        string op = operators[i];\n        int nextOperand = operands[i + 1];\n\n        if (op == \"+\") {\n            result += nextOperand;\n        } else if (op == \"-\") {\n            result -= nextOperand;\n        } else if (op == \"*\") {\n            result *= nextOperand;\n        } else if (op == \"//\") {\n            result /= nextOperand; // Floor division\n        } else if (op == \"**\") {\n            result = pow(result, nextOperand); // Exponentiation using std::pow\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/161", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool containsLetter(const string& s) {\n    for(char c : s) {\n        if(isalpha(c)) return true;\n    }\n    return false;\n}\n\nchar reverseCase(char c) {\n    if(islower(c)) return toupper(c);\n    else if(isupper(c)) return tolower(c);\n    else return c;\n}\n\nstring solve(string s){\n    // Check if the string contains any letters\n    bool hasLetters = containsLetter(s);\n\n    if(!hasLetters) {\n        // If no letters, reverse the entire string\n        reverse(s.begin(), s.end());\n        return s;\n    } else {\n        // Reverse case for each letter in the string\n        for(char &c : s) {\n            c = reverseCase(c);\n        }\n        return s;\n    }\n}\n\n"}
{"task_id": "CPP/162", "generation": "#include <iostream>\n#include <string>\n#include <openssl/md5.h>\n\nusing namespace std;\n\nstring string_to_md5(string text) {\n    if (text.empty()) return \"None\";\n\n    unsigned char digest[MD5_DIGEST_LENGTH];\n    MD5((unsigned char*)text.c_str(), text.length(), (unsigned char*)&digest);    \n\n    char mdString[33];\n    for(int i = 0; i < 16; ++i)\n        sprintf(&mdString[i*2], \"%02x\", (unsigned int)digest[i]);\n\n    return string(mdString);\n}\n\n"}
{"task_id": "CPP/163", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> generate_integers(int a, int b) {\n    vector<int> evenDigits = {2, 4, 6, 8}; // Possible even digits less than 10.\n    vector<int> result;\n    \n    // Ensure the range is from min to max for simplicity\n    if (a > b) swap(a, b);\n    \n    // Iterate through possible even digits and check if they are in the given range\n    for(int digit : evenDigits) {\n        if(digit >= a && digit <= b) {\n            result.push_back(digit);\n        }\n    }\n\n    return result;\n}\n\n// Function to print vector elements (for testing purposes)\nvoid printVector(const vector<int>& vec) {\n    cout << \"{\";\n    for(size_t i = 0; i < vec.size(); ++i) {\n        if(i != 0) cout << \", \";\n        cout << vec[i];\n    }\n    cout << \"}\" << endl;\n}\n\n"}
{"task_id": "CPP/0", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // For std::sort\n\nusing namespace std;\n\nbool has_close_elements(vector<float> numbers, float threshold) {\n    // Sort the vector to bring close elements next to each other if they exist.\n    sort(numbers.begin(), numbers.end());\n    \n    // Iterate through the sorted list and check for any two consecutive elements\n    // that are closer than the given threshold.\n    for (size_t i = 0; i < numbers.size() - 1; ++i) {\n        if (numbers[i + 1] - numbers[i] < threshold) {\n            return true;\n        }\n    }\n    \n    // If no such pair is found, return false.\n    return false;\n}\n\n// Function to test the solution with given data points\nvoid check() {\n    cout << boolalpha; // Print bools as true/false instead of 1/0\n    cout << has_close_elements({1.0, 2.0, 3.0}, 0.5) << endl; // Expected: false\n    cout << has_close_elements({1.0, 2.8, 3.0, 4.0, 5.0, 2.0}, 0.3) << endl; // Expected: true\n}\n\n"}
{"task_id": "CPP/1", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> separate_paren_groups(string paren_string) {\n    vector<string> result;\n    int balance = 0;\n    string current_group = \"\";\n    \n    // Remove spaces from the input string\n    paren_string.erase(remove(paren_string.begin(), paren_string.end(), ' '), paren_string.end());\n    \n    for (char c : paren_string) {\n        if (c == '(') {\n            balance++;\n        } else if (c == ')') {\n            balance--;\n        }\n        \n        current_group += c;\n        \n        // When balance is 0, we have a complete group\n        if (balance == 0 && !current_group.empty()) {\n            result.push_back(current_group);\n            current_group = \"\"; // Reset for the next group\n        }\n    }\n\n    return result;\n}\n\n// Function to test the implementation with some data points\nvoid check() {\n    vector<string> expected1 = {\"()\", \"(())\", \"(()())\"};\n    assert(separate_paren_groups(\"( ) (( )) (( )( ))\") == expected1);\n    \n    vector<string> expected2 = {\"(())\", \"()\"};\n    assert(separate_paren_groups(\" (()) () \") == expected2);\n\n    cout << \"All tests passed successfully.\" << endl;\n}\n\n"}
{"task_id": "CPP/2", "generation": "#include <iostream>\n#include <cmath> // For std::floor\n\nfloat truncate_number(float number){\n    float integerPart = std::floor(number); // Get the largest integer smaller than or equal to 'number'\n    return number - integerPart;            // Subtract the integer part from the original number to get the decimal part\n}\n\n"}
{"task_id": "CPP/3", "generation": "#include <vector>\nusing namespace std;\n\nbool below_zero(vector<int> operations) {\n    int balance = 0; // Start with a zero balance\n    \n    for (int op : operations) { // Iterate through each operation\n        balance += op; // Update the balance based on the current operation\n        \n        if (balance < 0) { // Check if the balance falls below zero\n            return true;\n        }\n    }\n    \n    return false; // Return false if no point in time the balance was below zero\n}\n\n// Example usage:\n/*\n"}
{"task_id": "CPP/4", "generation": "#include <iostream>\n#include <vector>\n#include <numeric> // For std::accumulate\n#include <cmath>   // For std::abs\n\nusing namespace std;\n\nfloat mean_absolute_deviation(vector<float> numbers) {\n    if (numbers.empty()) return 0.0f; // Handle empty vector case\n    \n    float sum = accumulate(numbers.begin(), numbers.end(), 0.0f);\n    float mean = sum / numbers.size();\n    \n    float mad_sum = 0.0f;\n    for (float num : numbers) {\n        mad_sum += abs(num - mean); // Sum of absolute differences\n    }\n    \n    return mad_sum / numbers.size(); // Average the absolute differences\n}\n\n"}
{"task_id": "CPP/5", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> intersperse(vector<int> numbers, int delimeter) {\n    // If the input vector is empty, return it as is.\n    if (numbers.empty()) {\n        return {};\n    }\n\n    vector<int> result;\n    \n    // Add elements and delimiters to the result vector\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        result.push_back(numbers[i]);\n        \n        // Do not add a delimiter after the last element.\n        if (i != numbers.size() - 1) {\n            result.push_back(delimeter);\n        }\n    }\n\n    return result;\n}\n\n// Function to print vector for testing\nvoid printVector(const vector<int>& vec) {\n    cout << \"{\";\n    for (size_t i = 0; i < vec.size(); ++i) {\n        if (i != 0) cout << \", \";\n        cout << vec[i];\n    }\n    cout << \"}\" << endl;\n}\n\n"}
{"task_id": "CPP/6", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<int> parse_nested_parens(string paren_string) {\n    vector<int> depths;\n    int depth = 0, max_depth = 0;\n    \n    for (char c : paren_string) {\n        if (c == '(') {\n            // Increase the current depth and update max_depth\n            ++depth;\n            max_depth = max(max_depth, depth);\n        } else if (c == ')') {\n            // Decrease the current depth as we encounter a closing parenthesis\n            --depth;\n        } else if (c == ' ') {\n            // When encountering space, store the max_depth of the previous group and reset for next group\n            depths.push_back(max_depth);\n            depth = 0;\n            max_depth = 0;\n        }\n    }\n\n    // Add the last group's max_depth to the vector as there won't be a trailing space\n    if (max_depth > 0) {\n        depths.push_back(max_depth);\n    }\n\n    return depths;\n}\n\n"}
{"task_id": "CPP/7", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\n// Function to filter strings that contain a given substring.\nvector<string> filter_by_substring(vector<string> strings, string substring) {\n    vector<string> result;  // Vector to store the filtered results.\n\n    for (const auto& str : strings) {  // Iterate through each string in the input vector.\n        if (str.find(substring) != string::npos) {  // Check if the current string contains the substring.\n            result.push_back(str);  // If it does, add it to the result vector.\n        }\n    }\n\n    return result;  // Return the filtered results.\n}\n\n// Function to test the filter_by_substring function with given data points.\nvoid check() {\n    auto res1 = filter_by_substring({}, \"a\");\n    cout << \"{\";\n    for (const auto& str : res1) {\n        cout << \"\\\"\" << str << \"\\\", \";\n    }\n    cout << \"}\\n\";\n\n    auto res2 = filter_by_substring({\"abc\", \"bacd\", \"cde\", \"vector\"}, \"a\");\n    cout << \"{\";\n    for (const auto& str : res2) {\n        cout << \"\\\"\" << str << \"\\\", \";\n    }\n    cout << \"}\\n\";\n}\n\n"}
{"task_id": "CPP/8", "generation": "#include <iostream>\n#include <vector>\n#include <utility> // For std::pair\n\nusing namespace std;\n\n// Function to calculate sum and product of all elements in a vector.\nstd::pair<int, int> sum_product(vector<int> numbers) {\n    if (numbers.empty()) {  // Check for empty vector\n        return make_pair(0, 1);\n    }\n\n    int sum = 0;\n    int product = 1;\n\n    for (int num : numbers) {\n        sum += num;         // Accumulate the sum of elements.\n        product *= num;     // Multiply each element to accumulate the product.\n    }\n\n    return make_pair(sum, product);  // Return a pair containing sum and product.\n}\n\n// Function to test the correctness of the solution\nvoid check() {\n    auto result = sum_product({});\n    cout << \"(\" << result.first << \", \" << result.second << \")\" << endl; // Expected: (0, 1)\n\n    result = sum_product({1, 2, 3, 4});\n    cout << \"(\" << result.first << \", \" << result.second << \")\" << endl; // Expected: (10, 24)\n}\n\n"}
{"task_id": "CPP/9", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> rolling_max(vector<int> numbers) {\n    if (numbers.empty()) return {}; // Handle empty input case\n\n    vector<int> result;\n    int currentMax = numbers[0]; // Initialize with the first element of the list\n    \n    for (int num : numbers) {\n        if (num > currentMax) {\n            currentMax = num; // Update max when a new maximum is found\n        }\n        result.push_back(currentMax); // Add the current max to the result vector\n    }\n\n    return result;\n}\n\n// Function to test the rolling_max function with provided data points.\nvoid check() {\n    vector<int> input = {1, 2, 3, 2, 3, 4, 2};\n    vector<int> expectedOutput = {1, 2, 3, 3, 3, 4, 4};\n    vector<int> output = rolling_max(input);\n\n    if (output == expectedOutput) {\n        cout << \"Test passed.\" << endl;\n    } else {\n        cout << \"Test failed.\" << endl;\n    }\n}\n\n"}
{"task_id": "CPP/10", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nbool is_palindrome(string str) {\n    // Test if given string is a palindrome \n    string s(str.rbegin(), str.rend());\n    return s == str;\n}\n\nstring make_palindrome(string str) {\n    int n = str.length();\n    \n    // Find the longest palindromic suffix\n    for (int i = 0; i < n; ++i) {\n        if (is_palindrome(str.substr(i))) {\n            // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n            return str + string(str.rbegin(), str.rend() - i);\n        }\n    }\n\n    // If no palindromic suffix is found, it means the whole string needs to be reversed and appended\n    return str + string(str.rbegin(), str.rend());\n}\n\n"}
{"task_id": "CPP/11", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring string_xor(string a, string b) {\n    // Ensure both strings are of equal length.\n    if (a.length() != b.length()) {\n        cout << \"Error: Strings must be of the same length.\" << endl;\n        return \"\";  // Return an empty string in case of error\n    }\n\n    string result = \"\";\n    \n    for(size_t i = 0; i < a.length(); ++i) {\n        // Perform XOR on each bit and append to the result.\n        if (a[i] == b[i]) {\n            result += '0';  // If both bits are same, XOR is 0\n        } else {\n            result += '1';  // If bits are different, XOR is 1\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/12", "generation": "#include <vector>\n#include <string>\nusing namespace std;\n\nstring longest(vector<string> strings) {\n    if (strings.empty()) return \"\"; // Return an empty string for an empty vector\n\n    string longestString = strings[0]; // Assume the first string is the longest initially\n    \n    for (const auto& str : strings) {\n        if (str.length() > longestString.length()) {\n            longestString = str; // Update longestString if a longer string is found\n        }\n    }\n\n    return longestString;\n}\n"}
{"task_id": "CPP/13", "generation": "#include <iostream>\nusing namespace std;\n\nint greatest_common_divisor(int a, int b) {\n    // Ensure that both a and b are positive.\n    a = abs(a);\n    b = abs(b);\n\n    while (b != 0) {\n        int temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a; // At this point, 'a' holds the GCD\n}\n\n"}
{"task_id": "CPP/14", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> all_prefixes(string str) {\n    vector<string> prefixes;\n    for (size_t i = 1; i <= str.size(); ++i) {\n        // Create a substring from the beginning to the current position\n        string prefix = str.substr(0, i);\n        // Add this prefix to the vector\n        prefixes.push_back(prefix);\n    }\n    return prefixes;\n}\n\n// Example usage:\n"}
{"task_id": "CPP/15", "generation": "#include <iostream>\n#include <sstream> // For std::ostringstream\nusing namespace std;\n\nstring string_sequence(int n) {\n    ostringstream oss; // Create an output string stream object\n    for (int i = 0; i <= n; ++i) { // Loop from 0 to n inclusive\n        if (i != 0) { // Add a space before each number except the first one\n            oss << \" \";\n        }\n        oss << i; // Insert the current number into the stream\n    }\n    return oss.str(); // Convert the content of ostringstream to string and return it\n}\n\n// Example usage:\n"}
{"task_id": "CPP/16", "generation": "#include <iostream>\n#include <string>\n#include <set>\n#include <cctype> // for std::tolower\n\nusing namespace std;\n\nint count_distinct_characters(string str) {\n    set<char> distinctChars;\n    \n    // Convert each character to lowercase and insert into the set\n    for (char c : str) {\n        distinctChars.insert(tolower(c)); // tolower converts uppercase to lowercase\n    }\n    \n    return distinctChars.size();\n}\n\n"}
{"task_id": "CPP/17", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<int> parse_music(string music_string){\n    vector<int> beats;\n    for (size_t i = 0; i < music_string.length(); ) {\n        if (music_string[i] == 'o') { // Check for whole note\n            if (i + 1 < music_string.length() && music_string[i+1] == '|') {\n                beats.push_back(2); // Half note\n                i += 2; // Skip the next character as well since it's part of the half note\n            } else {\n                beats.push_back(4); // Whole note\n                ++i;\n            }\n        } else if (music_string[i] == '.' && music_string[i+1] == '|') { // Check for quarter note\n            beats.push_back(1);\n            i += 2; // Skip the next character as well since it's part of the quarter note\n        } else {\n            ++i;\n        }\n    }\n    return beats;\n}\n\n// Function to test the parse_music function with given input and expected output.\nvoid check() {\n    vector<int> result = parse_music(\"o o| .| o| o| .| .| .| .| o o\");\n    vector<int> expected{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4};\n    \n    if (result == expected) {\n        cout << \"Test passed.\" << endl;\n    } else {\n        cout << \"Test failed.\" << endl;\n    }\n}\n\n"}
{"task_id": "CPP/18", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint how_many_times(string str, string substring) {\n    int count = 0;\n    size_t pos = 0; // Position of the found substring\n\n    if (substring.empty() || str.size() < substring.size()) return 0;\n\n    while ((pos = str.find(substring, pos)) != string::npos) {\n        ++count;\n        ++pos; // Move to the next character after the current match\n               // This ensures overlapping matches are counted\n    }\n\n    return count;\n}\n\n// Function to test the solution with given data points\nvoid check() {\n    cout << how_many_times(\"\", \"a\") << endl;       // Expected output: 0\n    cout << how_many_times(\"aaa\", \"a\") << endl;    // Expected output: 3\n    cout << how_many_times(\"aaaa\", \"aa\") << endl;  // Expected output: 3\n}\n\n"}
{"task_id": "CPP/19", "generation": "#include <iostream>\n#include <string>\n#include <vector>\n#include <map>\n#include <sstream>\nusing namespace std;\n\n// Function to split a string by spaces.\nvector<string> split(const string &s) {\n    vector<string> result;\n    stringstream ss(s);\n    string item;\n    while (getline(ss, item, ' ')) {\n        if (!item.empty()) {\n            result.push_back(item);\n        }\n    }\n    return result;\n}\n\nstring sort_numbers(string numbers) {\n    // Map to associate number words with their numeric values.\n    map<string, int> num_map = {\n        {\"zero\", 0}, {\"one\", 1}, {\"two\", 2}, {\"three\", 3},\n        {\"four\", 4}, {\"five\", 5}, {\"six\", 6}, {\"seven\", 7},\n        {\"eight\", 8}, {\"nine\", 9}\n    };\n\n    // Split the input string into words.\n    vector<string> words = split(numbers);\n\n    // Sort the words based on their numeric values.\n    sort(words.begin(), words.end(),\n         [&num_map](const string &a, const string &b) {\n             return num_map[a] < num_map[b];\n         });\n\n    // Concatenate sorted words back into a single string.\n    stringstream ss;\n    for (size_t i = 0; i < words.size(); ++i) {\n        if (i != 0) ss << \" \";\n        ss << words[i];\n    }\n\n    return ss.str();\n}\n\n"}
{"task_id": "CPP/20", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // for std::sort\n\nusing namespace std;\n\npair<float, float> find_closest_elements(vector<float> numbers) {\n    // Sort the vector in ascending order.\n    sort(numbers.begin(), numbers.end());\n\n    float min_diff = numeric_limits<float>::max();\n    pair<float, float> closest_pair;\n    \n    // Iterate through the sorted list to find the smallest difference\n    for (size_t i = 0; i < numbers.size() - 1; ++i) {\n        float diff = numbers[i + 1] - numbers[i];\n        \n        if (diff < min_diff) {\n            min_diff = diff;\n            closest_pair = {numbers[i], numbers[i + 1]};\n        }\n    }\n\n    return closest_pair;\n}\n\n"}
{"task_id": "CPP/21", "generation": "#include <vector>\n#include <algorithm> // for std::min_element and std::max_element\n\nusing namespace std;\n\nvector<float> rescale_to_unit(vector<float> numbers){\n    float min_val = *std::min_element(numbers.begin(), numbers.end());\n    float max_val = *std::max_element(numbers.begin(), numbers.end());\n\n    vector<float> result;\n    for (float num : numbers) {\n        // Apply the linear transformation\n        float scaled_num = (num - min_val) / (max_val - min_val);\n        result.push_back(scaled_num);\n    }\n\n    return result;\n}\n\n// Example usage:\n"}
{"task_id": "CPP/22", "generation": "#include <iostream>\n#include <vector>\n#include <list>\n#include <boost/any.hpp>\n\ntypedef std::list<boost::any> list_any;\n\nstd::vector<int> filter_integers(list_any values) {\n    std::vector<int> integers;\n    \n    for (const auto& value : values) {\n        if (value.type() == typeid(int)) {  // Check if the type is int\n            integers.push_back(boost::any_cast<int>(value));  // Cast and add to vector\n        }\n    }\n\n    return integers;\n}\n\n"}
{"task_id": "CPP/23", "generation": "#include <iostream>\n\n// Function to calculate length of string\nint strlen(const char* str) {\n    int count = 0;\n    while (str[count] != '\\0') { // Loop until null character is found\n        ++count;\n    }\n    return count;\n}\n\n"}
{"task_id": "CPP/24", "generation": "#include <stdio.h>\n\nint largest_divisor(int n) {\n    // Start from n/2 and go downwards until we find a divisor.\n    for (int i = n / 2; i >= 1; --i) {\n        if (n % i == 0) {\n            return i;\n        }\n    }\n    // If no divisor is found, which shouldn't happen since every number is divisible by itself,\n    // we return -1 to indicate an error or special case.\n    return -1;\n}\n\n"}
{"task_id": "CPP/25", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvector<int> factorize(int n) {\n    vector<int> factors;\n    \n    // Divide by 2 until odd\n    while (n % 2 == 0) {\n        factors.push_back(2);\n        n /= 2;\n    }\n    \n    // Check for odd factors from 3 onwards\n    for (int i = 3; i * i <= n; i += 2) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n    \n    // If n is a prime number greater than 2\n    if (n > 2) {\n        factors.push_back(n);\n    }\n\n    return factors;\n}\n\n"}
{"task_id": "CPP/26", "generation": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nvector<int> remove_duplicates(vector<int> numbers) {\n    unordered_map<int, int> countMap; // To keep track of counts of each number\n    vector<int> result;               // Resultant vector with duplicates removed\n\n    for (int num : numbers) {\n        if (countMap[num] == 0) {     // If the element has not been seen before\n            result.push_back(num);    // Add it to the result\n        }\n        countMap[num]++;              // Increment its count in the map\n    }\n\n    vector<int> finalResult;\n    for (int num : numbers) {\n        if (countMap[num] == 1) {     // If an element occurs only once, add it to the final result\n            finalResult.push_back(num);\n        }\n    }\n\n    return finalResult;               // Return the final result vector\n}\n\n// Function to print a vector\nvoid printVector(const vector<int>& vec) {\n    for (int num : vec) {\n        cout << num << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/27", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring flip_case(string str) {\n    for (size_t i = 0; i < str.length(); ++i) {\n        if (islower(str[i])) { // If the character is lowercase, convert to uppercase.\n            str[i] = toupper(str[i]);\n        } else if (isupper(str[i])) { // If the character is uppercase, convert to lowercase.\n            str[i] = tolower(str[i]);\n        }\n    }\n    return str;\n}\n\n"}
{"task_id": "CPP/28", "generation": "#include <vector>\n#include <string>\nusing namespace std;\n\nstring concatenate(vector<string> strings) {\n    // Initialize an empty string to hold the concatenated result.\n    string result = \"\";\n\n    // Iterate through each element in the vector and append it to the result string.\n    for (const auto& str : strings) {\n        result += str;\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/29", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> filter_by_prefix(vector<string> strings, string prefix) {\n    vector<string> filteredStrings;\n    \n    for (const auto& str : strings) {\n        // Check if the current string starts with the given prefix.\n        if (str.find(prefix) == 0) { // find returns 0 if prefix is found at the beginning\n            filteredStrings.push_back(str);\n        }\n    }\n\n    return filteredStrings;\n}\n\n// Function to print vector of strings for testing purposes\nvoid printVector(const vector<string>& vec) {\n    cout << \"{\";\n    for (size_t i = 0; i < vec.size(); ++i) {\n        if (i > 0) cout << \", \";\n        cout << \"\\\"\" << vec[i] << \"\\\"\";\n    }\n    cout << \"}\" << endl;\n}\n\n"}
{"task_id": "CPP/30", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvector<float> get_positive(vector<float> l) {\n    vector<float> result; // Initialize an empty vector for storing positive numbers\n\n    // Iterate through each element in the input vector\n    for (float num : l) {\n        if (num > 0) { // Check if the number is greater than zero\n            result.push_back(num); // Add it to the result vector if it's positive\n        }\n    }\n\n    return result; // Return the vector containing only positive numbers\n}\n\n// Function to test the get_positive function with sample data\nvoid check() {\n    vector<float> test1 = {-1, 2, -4, 5, 6};\n    vector<float> expected1 = {2, 5, 6};\n    \n    vector<float> result1 = get_positive(test1);\n    cout << \"Test 1: \";\n    if (result1 == expected1) {\n        cout << \"Passed\" << endl;\n    } else {\n        cout << \"Failed\" << endl;\n    }\n\n    vector<float> test2 = {5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10};\n    vector<float> expected2 = {5, 3, 2, 3, 9, 123, 1};\n\n    vector<float> result2 = get_positive(test2);\n    cout << \"Test 2: \";\n    if (result2 == expected2) {\n        cout << \"Passed\" << endl;\n    } else {\n        cout << \"Failed\" << endl;\n    }\n}\n\n"}
{"task_id": "CPP/31", "generation": "#include <iostream>\nusing namespace std;\n\nbool is_prime(long long n) {\n    // Handle edge cases: 0, 1 and negative numbers are not prime.\n    if (n <= 1) return false;\n    \n    // Check for divisibility by any number from 2 to the square root of n\n    for (long long i = 2; i * i <= n; ++i) {\n        if (n % i == 0)\n            return false;\n    }\n    return true;\n}\n\n"}
{"task_id": "CPP/32", "generation": "#include <iostream>\n#include <vector>\n#include <cmath>\n\ndouble poly(std::vector<double> xs, double x) {\n    /* \n    Evaluates polynomial with coefficients xs at point x.\n    Returns xs[0] + xs[1] * x + xs[2] * x^2 + .... xs[n] * x^n\n    */\n    double sum = 0;\n    for (size_t i = 0; i < xs.size(); ++i) {\n        sum += xs[i] * std::pow(x, i);\n    }\n    return sum;\n}\n\ndouble find_zero(std::vector<double> xs) {\n    /*\n    Finds a zero of the polynomial with coefficients in xs.\n    Assumes that there is at least one real root and xs has an even number of coefficients.\n    */\n    \n    // Initial interval for bisection method\n    double left = -100.0;  // Start from a large negative value\n    double right = 100.0;  // End with a large positive value\n    \n    // Evaluate the polynomial at both ends to ensure there's a sign change\n    double f_left = poly(xs, left);\n    double f_right = poly(xs, right);\n\n    // If no sign change is found in [-100, 100], adjust the interval.\n    while (f_left * f_right > 0) {\n        if (std::abs(f_left) < std::abs(f_right)) {\n            left *= 2;\n            f_left = poly(xs, left);\n        } else {\n            right *= 2;\n            f_right = poly(xs, right);\n        }\n    }\n\n    // Bisection method\n    double mid;\n    while (right - left > 1e-6) {  // Tolerance for the root\n        mid = (left + right) / 2.0;\n        if (poly(xs, mid) * f_left < 0) {\n            right = mid;\n            f_right = poly(xs, mid);\n        } else {\n            left = mid;\n            f_left = poly(xs, mid);\n        }\n    }\n\n    return (left + right) / 2.0; // Return the midpoint as the root\n}\n\n"}
{"task_id": "CPP/33", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // For std::sort\n\nusing namespace std;\n\nvector<int> sort_third(vector<int> l) {\n    vector<int> to_sort;  // This will hold elements at indices divisible by three.\n    \n    // Extract the values from indices that are divisible by three\n    for (size_t i = 2; i < l.size(); i += 3) { // Start from index 2 as it's the first index divisible by 3 in a zero-indexed array\n        to_sort.push_back(l[i]);\n    }\n    \n    // Sort these extracted values\n    sort(to_sort.begin(), to_sort.end());\n    \n    // Replace the original values at indices divisible by three with sorted ones\n    for (size_t i = 2, j = 0; i < l.size() && j < to_sort.size(); i += 3, ++j) {\n        l[i] = to_sort[j];\n    }\n    \n    return l;\n}\n\n// Function to test the correctness of sort_third function\nvoid check_function() {\n    vector<int> test1 = {1, 2, 3};\n    vector<int> expected1 = {1, 2, 3};\n    assert(sort_third(test1) == expected1);\n\n    vector<int> test2 = {5, 6, 3, 4, 8, 9, 2};\n    vector<int> expected2 = {2, 6, 3, 4, 8, 9, 5};\n    assert(sort_third(test2) == expected2);\n\n    cout << \"All tests passed successfully.\" << endl;\n}\n\n"}
{"task_id": "CPP/34", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // For std::sort and std::unique\n\nusing namespace std;\n\nvector<int> unique(vector<int> l) {\n    // First, sort the vector so that duplicate elements are adjacent.\n    sort(l.begin(), l.end());\n    \n    // Use std::unique to remove consecutive duplicates. It returns a past-the-end iterator for the new range of unique elements.\n    auto last = unique(l.begin(), l.end());\n    \n    // Erase the non-unique part of the vector.\n    l.erase(last, l.end());\n    \n    return l;\n}\n\n// Example usage\n"}
{"task_id": "CPP/35", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // For std::max\n\nusing namespace std;\n\nfloat max_element(vector<float> l) {\n    if (l.empty()) {  // Check if vector is empty to avoid errors.\n        throw runtime_error(\"Vector is empty\"); // Or handle in another way as needed\n    }\n\n    float max_val = l[0]; // Initialize max_val with the first element of the vector\n\n    for (float num : l) {\n        max_val = std::max(max_val, num); // Update max_val if a larger number is found\n    }\n    \n    return max_val;\n}\n\n// Function to test the correctness of the max_element function.\nvoid check() {\n    vector<float> vec1 = {1.0f, 2.0f, 3.0f};\n    vector<float> vec2 = {5.0f, 3.0f, -5.0f, 2.0f, -3.0f, 3.0f, 9.0f, 0.0f, 123.0f, 1.0f, -10.0f};\n\n    cout << \"Max element in vec1: \" << max_element(vec1) << endl; // Should output 3\n    cout << \"Max element in vec2: \" << max_element(vec2) << endl; // Should output 123\n}\n\n"}
{"task_id": "CPP/36", "generation": "#include <iostream>\nusing namespace std;\n\nint fizz_buzz(int n) {\n    int count = 0;\n    \n    for (int i = 1; i < n; ++i) {\n        if ((i % 11 == 0 || i % 13 == 0)) { // Check divisibility by 11 or 13\n            int temp = i;\n            while (temp > 0) {\n                if (temp % 10 == 7) count++; // Count digit '7'\n                temp /= 10; // Move to the next digit\n            }\n        }\n    }\n\n    return count;\n}\n\n"}
{"task_id": "CPP/37", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // For std::sort\n\nusing namespace std;\n\nvector<float> sort_even(vector<float> l) {\n    if (l.empty()) return l; // Return the empty vector as is.\n\n    vector<float> evenIndicesValues;\n    \n    // Extract elements at even indices.\n    for(size_t i = 0; i < l.size(); i += 2) {\n        evenIndicesValues.push_back(l[i]);\n    }\n\n    // Sort the extracted values.\n    sort(evenIndicesValues.begin(), evenIndicesValues.end());\n\n    // Place sorted values back into their original positions.\n    size_t j = 0;\n    for(size_t i = 0; i < l.size(); i += 2) {\n        l[i] = evenIndicesValues[j++];\n    }\n\n    return l;\n}\n\n"}
{"task_id": "CPP/38", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\n// The encode_cyclic function as provided.\nstring encode_cyclic(string s){ \n    int l = s.length();\n    string output;\n    for (int i = 0; i * 3 < l; i++) {\n        string x = s.substr(i * 3, 3);\n        if (x.length() == 3) x = x.substr(1) + x[0];\n        output += x;\n    }\n    return output;\n}\n\n// The decode_cyclic function to reverse the encoding.\nstring decode_cyclic(string s){ \n    int l = s.length();\n    string output;\n    for (int i = 0; i * 3 < l; i++) {\n        string x = s.substr(i * 3, 3);\n        if (x.length() == 3) x = x[2] + x.substr(0, 2); // Shift right\n        output += x;\n    }\n    return output;\n}\n\n"}
{"task_id": "CPP/39", "generation": "#include <iostream>\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    for (int i = 2; i * i <= num; ++i) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\n// Function to generate the nth Fibonacci number that is also prime\nint prime_fib(int n) {\n    int count = 0, fib1 = 0, fib2 = 1, fib3;\n\n    while (true) {\n        // Generate next Fibonacci number\n        fib3 = fib1 + fib2;\n        fib1 = fib2;\n        fib2 = fib3;\n\n        // Check if the generated Fibonacci number is prime\n        if (is_prime(fib3)) {\n            count++;\n            if (count == n) return fib3;  // Return when nth prime Fibonacci found\n        }\n    }\n\n    return -1; // This line should theoretically never be reached.\n}\n\n"}
{"task_id": "CPP/40", "generation": "#include <vector>\n#include <algorithm> // for std::sort\n\nusing namespace std;\n\nbool triples_sum_to_zero(vector<int> l) {\n    int n = l.size();\n    \n    if (n < 3) return false; // If there are less than 3 elements, it's impossible to find a triplet\n    \n    sort(l.begin(), l.end()); // Sort the array first\n\n    for (int i = 0; i < n - 2; ++i) { // Iterate through each element as the first number\n        int left = i + 1;\n        int right = n - 1;\n\n        while (left < right) {\n            int sum = l[i] + l[left] + l[right];\n            \n            if (sum == 0) {\n                return true; // Found a triplet that sums to zero\n            } else if (sum < 0) {\n                ++left; // Need a larger number, move left pointer rightward\n            } else {\n                --right; // Need a smaller number, move right pointer leftward\n            }\n        }\n    }\n\n    return false; // No triplet found that sums to zero\n}\n\n// Example usage:\n/*\n"}
{"task_id": "CPP/41", "generation": "#include <iostream>\nusing namespace std;\n\nint car_race_collision(int n) {\n    // Since every car going left to right collides with a unique car going right to left,\n    // and there are `n` cars in each direction, the total number of collisions is `n`.\n    return n;\n}\n\n"}
{"task_id": "CPP/42", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Function to increment each element of the vector by 1.\nvector<int> incr_vector(vector<int> l) {\n    // Iterate through each element in the vector and increment it by 1.\n    for (size_t i = 0; i < l.size(); ++i) {\n        l[i] += 1;\n    }\n    return l;\n}\n\n// Function to test the correctness of incr_vector function\nvoid check() {\n    vector<int> test1 = {1, 2, 3};\n    vector<int> expected1 = {2, 3, 4};\n    assert(incr_vector(test1) == expected1);\n\n    vector<int> test2 = {5, 3, 5, 2, 3, 3, 9, 0, 123};\n    vector<int> expected2 = {6, 4, 6, 3, 4, 4, 10, 1, 124};\n    assert(incr_vector(test2) == expected2);\n\n    cout << \"All tests passed successfully.\" << endl;\n}\n\n"}
{"task_id": "CPP/43", "generation": "#include <iostream>\n#include <vector>\n#include <unordered_set> // For using hash set\n\nusing namespace std;\n\nbool pairs_sum_to_zero(vector<int> l) {\n    unordered_set<int> seen;\n    \n    for (int num : l) {\n        if (seen.find(-num) != seen.end()) { // Check if the negation of current number is in the set\n            return true; // Found a pair that sums to zero\n        }\n        seen.insert(num); // Add current number to the set\n    }\n\n    return false; // No pairs found that sum to zero\n}\n\n// Function to test the solution with given examples\nvoid check() {\n    assert(pairs_sum_to_zero({1, 3, 5, 0}) == false);\n    assert(pairs_sum_to_zero({1, 3, -2, 1}) == false);\n    assert(pairs_sum_to_zero({1, 2, 3, 7}) == false);\n    assert(pairs_sum_to_zero({2, 4, -5, 3, 5, 7}) == true);\n    assert(pairs_sum_to_zero({1}) == false);\n\n    cout << \"All tests passed successfully.\" << endl;\n}\n\n"}
{"task_id": "CPP/44", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring change_base(int x, int base){\n    if(base <= 1 || base >= 10)\n        throw invalid_argument(\"Base must be between 2 and 9\");\n\n    string result = \"\";\n    \n    while(x > 0) {\n        int remainder = x % base;\n        result = to_string(remainder) + result; // prepend the digit\n        x /= base;\n    }\n    \n    return result.empty() ? \"0\" : result;\n}\n\n"}
{"task_id": "CPP/45", "generation": "#include <stdio.h>\n\nfloat triangle_area(float base, float height) {\n    return 0.5 * base * height;\n}\n\n"}
{"task_id": "CPP/46", "generation": "#include <iostream>\nusing namespace std;\n\nint fib4(int n) {\n    // Base cases for the first 4 elements of the Fib4 sequence.\n    if (n == 0 || n == 1) return 0;\n    if (n == 2) return 2;\n    if (n == 3) return 0;\n\n    // Initialize the first four numbers in the sequence\n    int a = 0, b = 0, c = 2, d = 0;\n\n    // Compute the n-th element iteratively.\n    for(int i = 4; i <= n; ++i) {\n        int next = a + b + c + d;\n        // Update the values of a, b, c, and d\n        a = b;\n        b = c;\n        c = d;\n        d = next;\n    }\n\n    return d;\n}\n\n"}
{"task_id": "CPP/47", "generation": "#include <stdio.h>\n#include <math.h>\n#include <vector>\n#include <algorithm> // for std::sort\n\nusing namespace std;\n\nfloat median(vector<float> l) {\n    size_t n = l.size();\n    \n    if (n == 0) return NAN; // Return NaN for empty vector\n    \n    sort(l.begin(), l.end()); // Sort the vector\n    \n    if (n % 2 == 1) { // If odd number of elements\n        return l[n / 2]; // Median is the middle element\n    } else { // If even number of elements\n        size_t mid = n / 2;\n        return (l[mid - 1] + l[mid]) / 2.0; // Average of two middle elements\n    }\n}\n\n// Example usage:\n"}
{"task_id": "CPP/48", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_palindrome(string text) {\n    int left = 0;\n    int right = text.length() - 1;\n    \n    while (left < right) {\n        if (text[left] != text[right]) {\n            return false; // Characters do not match, so it's not a palindrome\n        }\n        left++;\n        right--;\n    }\n    return true; // All characters matched, hence it is a palindrome\n}\n\n"}
{"task_id": "CPP/49", "generation": "#include <iostream>\nusing namespace std;\n\nint modp(int n, int p) {\n    long long result = 1;\n    long long base = 2; // Start with the base value of 2\n\n    while (n > 0) {\n        if (n % 2 == 1) { // If n is odd\n            result = (result * base) % p;\n        }\n        base = (base * base) % p; // Square the base and take modulo to avoid overflow\n        n /= 2; // Halve n for the next iteration\n    }\n\n    return static_cast<int>(result);\n}\n\n"}
{"task_id": "CPP/50", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nstring encode_shift(string s) {\n    // returns encoded string by shifting every character by 5 in the alphabet.\n    string out;\n    int i;\n    for (i = 0; i < s.length(); i++) {\n        int w = ((int)s[i] + 5 - (int)'a') % 26 + (int)'a';\n        out += (char)w;\n    }\n    return out;\n}\n\nstring decode_shift(string s) {\n    // takes as input string encoded with encode_shift function. Returns decoded string.\n    string out;\n    int i;\n    for (i = 0; i < s.length(); i++) {\n        int w = ((int)s[i] - 5 + 26 - (int)'a') % 26 + (int)'a';\n        out += (char)w;\n    }\n    return out;\n}\n\n// Example usage\n"}
{"task_id": "CPP/51", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nbool isVowel(char ch) {\n    // Convert character to lowercase for simplicity and check if it's a vowel.\n    char lowerCh = tolower(ch);\n    return (lowerCh == 'a' || lowerCh == 'e' || lowerCh == 'i' || lowerCh == 'o' || lowerCh == 'u');\n}\n\nstring remove_vowels(string text) {\n    string result;\n    \n    // Iterate through each character in the input string.\n    for(char ch : text) {\n        if(!isVowel(ch)) {  // If it's not a vowel, add to result.\n            result += ch;\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/52", "generation": "#include <vector>\nusing namespace std;\n\nbool below_threshold(vector<int> l, int t) {\n    // Iterate through each element in the vector\n    for (int num : l) {\n        // If any number is greater than or equal to the threshold, return false\n        if (num >= t) {\n            return false;\n        }\n    }\n    // If all numbers are below the threshold, return true\n    return true;\n}\n\n// Example usage:\n/*\nbool result1 = below_threshold({1, 2, 4, 10}, 100); // Should be true\nbool result2 = below_threshold({1, 20, 4, 10}, 5);   // Should be false\n*/\n"}
{"task_id": "CPP/53", "generation": "#include<iostream>\nusing namespace std;\n\nint add(int x, int y) {\n    return x + y;\n}\n\n"}
{"task_id": "CPP/54", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nbool same_chars(string s0, string s1) {\n    // Sort both strings to bring identical characters together.\n    sort(s0.begin(), s0.end());\n    sort(s1.begin(), s1.end());\n\n    // Remove duplicate characters from each sorted string.\n    auto last0 = unique(s0.begin(), s0.end());\n    auto last1 = unique(s1.begin(), s1.end());\n\n    // Resize strings to remove the duplicates.\n    s0.resize(distance(s0.begin(), last0));\n    s1.resize(distance(s1.begin(), last1));\n\n    // Compare the two processed strings for equality.\n    return s0 == s1;\n}\n\n"}
{"task_id": "CPP/55", "generation": "#include <iostream> // Correct header for C++ standard input/output\n\nint fib(int n) {\n    if (n <= 0) return 0; // Base case: F(0) = 0\n    if (n == 1) return 1; // Base case: F(1) = 1\n    \n    int a = 0, b = 1, c;\n    for(int i = 2; i <= n; ++i){\n        c = a + b;\n        a = b;\n        b = c;\n    }\n    return b;\n}\n\n"}
{"task_id": "CPP/56", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    int openCount = 0;\n    \n    for (char c : brackets) {\n        if (c == '<') {\n            ++openCount; // Increment count for an opening bracket\n        } else if (c == '>') {\n            --openCount; // Decrement count for a closing bracket\n            \n            // If at any point the openCount is negative, return false\n            if (openCount < 0) {\n                return false;\n            }\n        }\n    }\n\n    // At the end of iteration, all brackets should be matched\n    return openCount == 0;\n}\n\n"}
{"task_id": "CPP/57", "generation": "#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nbool monotonic(vector<float> l) {\n    // Check for empty or single-element vectors, which are considered monotonic.\n    if (l.size() <= 1) return true;\n    \n    bool increasing = true;\n    bool decreasing = true;\n    \n    // Iterate through the vector to check the trend\n    for(size_t i = 0; i < l.size() - 1; ++i) {\n        if(l[i] > l[i + 1]) increasing = false;\n        if(l[i] < l[i + 1]) decreasing = false;\n        \n        // If neither condition holds, we can return false immediately\n        if (!increasing && !decreasing) return false;\n    }\n    \n    // The vector is monotonic if it's either increasing or decreasing.\n    return increasing || decreasing;\n}\n\n// Example usage:\n"}
{"task_id": "CPP/58", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\n\nusing namespace std;\n\nvector<int> common(vector<int> l1, vector<int> l2) {\n    // Sort the input vectors.\n    sort(l1.begin(), l1.end());\n    sort(l2.begin(), l2.end());\n\n    // Use a set to store unique common elements.\n    set<int> commonElements;\n    \n    auto it1 = l1.begin();\n    auto it2 = l2.begin();\n\n    // Iterate through both vectors to find common elements.\n    while (it1 != l1.end() && it2 != l2.end()) {\n        if (*it1 == *it2) {\n            commonElements.insert(*it1);\n            ++it1;\n            ++it2;\n        } else if (*it1 < *it2) {\n            ++it1;\n        } else {\n            ++it2;\n        }\n    }\n\n    // Convert the set to a vector and return.\n    return vector<int>(commonElements.begin(), commonElements.end());\n}\n\n// Function to print the elements of a vector\nvoid printVector(const vector<int>& vec) {\n    for (int num : vec) {\n        cout << num << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/59", "generation": "#include<stdio.h>\n#include<math.h>\n\nint largest_prime_factor(int n) {\n    int maxPrime = -1;\n    \n    // Divide n by 2 to remove all even factors\n    while (n % 2 == 0) {\n        maxPrime = 2;\n        n /= 2;\n    }\n    \n    // Now n must be odd, start from 3 and check for prime factors.\n    for (int i = 3; i <= sqrt(n); i += 2) {\n        while (n % i == 0) {\n            maxPrime = i;\n            n = n / i;\n        }\n    }\n\n    // If n is a prime number greater than 2\n    if (n > 2)\n        maxPrime = n;\n\n    return maxPrime;\n}\n\n"}
{"task_id": "CPP/60", "generation": "#include <iostream>\n\nint sum_to_n(int n) {\n    return (n * (n + 1)) / 2;\n}\n\n"}
{"task_id": "CPP/61", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    int balance = 0; // This will keep track of open parentheses\n\n    for (char c : brackets) {\n        if (c == '(') {\n            ++balance;\n        } else if (c == ')') {\n            --balance;\n            if (balance < 0) { // If balance goes negative, there are more closing than opening\n                return false;\n            }\n        }\n    }\n\n    return balance == 0; // True only if all parentheses are matched correctly\n}\n\n"}
{"task_id": "CPP/62", "generation": "#include <vector>\nusing namespace std;\n\nvector<float> derivative(vector<float> xs){\n    // Create a new vector for storing the result.\n    vector<float> result;\n    \n    // Iterate through the coefficients starting from index 1 (the first term with x).\n    for(size_t i = 1; i < xs.size(); ++i) {\n        // Multiply each coefficient by its power and add to the result vector.\n        result.push_back(i * xs[i]);\n    }\n    \n    return result;\n}\n\n// Example usage\n"}
{"task_id": "CPP/63", "generation": "#include <vector>\nusing namespace std;\n\nint fibfib(int n) {\n    // Base cases as defined by the problem statement.\n    if (n == 0 || n == 1) return 0;\n    if (n == 2) return 1;\n\n    // Initialize a vector to store computed values of FibFib sequence\n    vector<int> fibfib_values(n + 1);\n    \n    // Set base cases in the vector.\n    fibfib_values[0] = 0;\n    fibfib_values[1] = 0;\n    fibfib_values[2] = 1;\n\n    // Compute values from 3 to n using previously computed values\n    for (int i = 3; i <= n; ++i) {\n        fibfib_values[i] = fibfib_values[i - 1] + fibfib_values[i - 2] + fibfib_values[i - 3];\n    }\n\n    // Return the nth value of the FibFib sequence\n    return fibfib_values[n];\n}\n\n// Example usage:\n"}
{"task_id": "CPP/64", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint vowels_count(string s) {\n    int count = 0;\n    // Define a set of vowels for easy lookup.\n    string vowels = \"aeiouAEIOU\";\n    \n    // Iterate through each character in the string.\n    for (size_t i = 0; i < s.length(); ++i) {\n        if (vowels.find(s[i]) != string::npos)\n            count++;\n        \n        // Check if 'y' or 'Y' is at the end of the word and it's not already counted as a vowel.\n        if ((s[i] == 'y' || s[i] == 'Y') && i == s.length() - 1) {\n            count++;\n        }\n    }\n\n    return count;\n}\n\n// Function to test the implementation\nvoid check_function() {\n    cout << \"Testing vowels_count function:\" << endl;\n    cout << \"vowels_count(\\\"abcde\\\") = \" << vowels_count(\"abcde\") << \", Expected: 2\" << endl;\n    cout << \"vowels_count(\\\"ACEDY\\\") = \" << vowels_count(\"ACEDY\") << \", Expected: 3\" << endl;\n}\n\n"}
{"task_id": "CPP/65", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring circular_shift(int x, int shift){\n    string num = to_string(x); // Convert integer to string for easy manipulation\n    int len = num.length();\n    \n    if (shift >= len) {\n        reverse(num.begin(), num.end()); // Reverse the digits if shift is greater than or equal to length of number\n    } else {\n        shift %= len; // Normalize shift value in case it's larger than the length but not enough to trigger a reversal\n        string shifted = num.substr(len - shift) + num.substr(0, len - shift); // Perform circular right shift\n        return shifted;\n    }\n    \n    return num;\n}\n\n"}
{"task_id": "CPP/66", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint digitSum(string s) {\n    int sum = 0;\n    for (char c : s) { // Iterate through each character in the string.\n        if (isupper(c)) { // Check if the character is uppercase.\n            sum += static_cast<int>(c); // Add its ASCII value to the sum.\n        }\n    }\n    return sum; // Return the final sum of ASCII values of uppercase characters.\n}\n\n"}
{"task_id": "CPP/67", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\nusing namespace std;\n\nint fruit_distribution(string s, int n) {\n    // Variables to hold the count of apples and oranges.\n    int apples = 0;\n    int oranges = 0;\n    \n    // Parsing the string to extract numbers.\n    stringstream ss(s);\n    string temp;\n    while (getline(ss, temp, ' ')) { \n        if(temp == \"apples\") {\n            getline(ss, temp, ' '); // Skip \"and\"\n            getline(ss, temp, ' ');\n            oranges = stoi(temp); // The number after \"oranges\" is the count of oranges.\n        } else if (temp == \"and\") {\n            continue; // Skip \"and\".\n        } else {\n            apples = stoi(temp); // The first number in the string is the count of apples.\n        }\n    }\n\n    // Calculate the number of mangoes by subtracting apples and oranges from total fruits.\n    int mangoes = n - (apples + oranges);\n    \n    return mangoes;\n}\n\n"}
{"task_id": "CPP/68", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> pluck(vector<int> arr) {\n    int minEvenValue = INT_MAX;\n    int minIndex = -1;\n\n    // Iterate through the vector to find the smallest even value and its index.\n    for (int i = 0; i < arr.size(); ++i) {\n        if (arr[i] % 2 == 0 && arr[i] <= minEvenValue) {\n            if (arr[i] < minEvenValue || minIndex == -1) {\n                minEvenValue = arr[i];\n                minIndex = i;\n            }\n        }\n    }\n\n    // If no even value was found, return an empty vector.\n    if (minIndex == -1) {\n        return {};\n    } else {\n        return {minEvenValue, minIndex};\n    }\n}\n"}
{"task_id": "CPP/69", "generation": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint search(vector<int> lst) {\n    unordered_map<int, int> freqMap;\n    \n    // Count frequencies of each number\n    for (int num : lst) {\n        freqMap[num]++;\n    }\n    \n    int result = -1;  // Default to -1 if no such value exists\n    \n    // Check which numbers meet the criteria and find the largest one\n    for (const auto& pair : freqMap) {\n        if (pair.first <= pair.second && pair.first > result) {\n            result = pair.first;\n        }\n    }\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/70", "generation": "#include <vector>\n#include <algorithm> // for std::sort\n\nstd::vector<int> strange_sort_list(std::vector<int> lst) {\n    if (lst.empty()) return {};  // Return an empty list if the input list is empty\n    \n    std::sort(lst.begin(), lst.end());  // Sort the vector in ascending order\n    std::vector<int> result;\n    \n    int left = 0;  // Start pointer\n    int right = lst.size() - 1;  // End pointer\n    \n    while (left <= right) {\n        if (left == right) {  // If there's only one element left, add it to the result.\n            result.push_back(lst[left]);\n            break;\n        }\n        \n        // Add from start and end alternately\n        result.push_back(lst[left++]);  // Minimum value\n        result.push_back(lst[right--]); // Maximum value\n    }\n    \n    return result;\n}\n\n// Example usage:\n"}
{"task_id": "CPP/71", "generation": "#include<stdio.h>\n#include<math.h>\n\nfloat triangle_area(float a, float b, float c) {\n    // Check if sides form a valid triangle\n    if (a + b <= c || a + c <= b || b + c <= a)\n        return -1;\n\n    // Calculate the semi-perimeter\n    float s = (a + b + c) / 2.0f;\n    \n    // Use Heron's formula to calculate area\n    float area = sqrt(s * (s - a) * (s - b) * (s - c));\n    \n    // Round the result to 2 decimal points and return\n    return round(area * 100) / 100;\n}\n\n"}
{"task_id": "CPP/72", "generation": "#include <vector>\n#include <numeric> // For std::accumulate\n\nbool will_it_fly(std::vector<int> q, int w) {\n    // Check if the vector is a palindrome.\n    bool is_balanced = true;\n    for (size_t i = 0; i < q.size() / 2; ++i) {\n        if (q[i] != q[q.size() - 1 - i]) {\n            is_balanced = false;\n            break;\n        }\n    }\n\n    // Calculate the sum of elements in the vector.\n    int total_weight = std::accumulate(q.begin(), q.end(), 0);\n\n    // Check both conditions: balanced and weight condition.\n    return is_balanced && (total_weight <= w);\n}\n\n// Example usage:\n"}
{"task_id": "CPP/73", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint smallest_change(vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n    \n    for (int i = 0; i < n / 2; ++i) {\n        if (arr[i] != arr[n - 1 - i]) {\n            ++changes;\n        }\n    }\n\n    return changes;\n}\n\n// Function to test the solution with given examples\nvoid check() {\n    vector<int> test1 = {1, 2, 3, 5, 4, 7, 9, 6};\n    cout << \"Test 1: Expected 4, Got \" << smallest_change(test1) << endl;\n\n    vector<int> test2 = {1, 2, 3, 4, 3, 2, 2};\n    cout << \"Test 2: Expected 1, Got \" << smallest_change(test2) << endl;\n\n    vector<int> test3 = {1, 2, 3, 2, 1};\n    cout << \"Test 3: Expected 0, Got \" << smallest_change(test3) << endl;\n}\n\n"}
{"task_id": "CPP/74", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to calculate the total number of chars in a list of strings.\nint countTotalChars(const vector<string>& lst) {\n    int total = 0;\n    for (const string& str : lst) {\n        total += str.size();\n    }\n    return total;\n}\n\nvector<string> total_match(vector<string> lst1, vector<string> lst2) {\n    // Calculate the total number of characters in each list.\n    int count1 = countTotalChars(lst1);\n    int count2 = countTotalChars(lst2);\n\n    // Compare and return the appropriate list based on the counts.\n    if (count1 <= count2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n\n// Function to test the solution with given examples\nvoid check() {\n    vector<string> empty = {};\n    auto result1 = total_match(empty, empty);\n    assert(result1 == empty);\n\n    vector<string> list1 = {\"hi\", \"admin\"};\n    vector<string> list2 = {\"hI\", \"Hi\"};\n    auto result2 = total_match(list1, list2);\n    assert((result2 == list2));\n\n    vector<string> list3 = {\"hi\", \"admin\"};\n    vector<string> list4 = {\"hi\", \"hi\", \"admin\", \"project\"};\n    auto result3 = total_match(list3, list4);\n    assert((result3 == list3));\n\n    vector<string> list5 = {\"hi\", \"admin\"};\n    vector<string> list6 = {\"hI\", \"hi\", \"hi\"};\n    auto result4 = total_match(list5, list6);\n    assert((result4 == list6));\n\n    vector<string> list7 = {\"4\"};\n    vector<string> list8 = {\"1\", \"2\", \"3\", \"4\", \"5\"};\n    auto result5 = total_match(list7, list8);\n    assert((result5 == list7));\n    \n    cout << \"All tests passed successfully.\" << endl;\n}\n\n"}
{"task_id": "CPP/75", "generation": "#include <iostream>\nusing namespace std;\n\nbool isPrime(int n) {\n    if (n <= 1)\n        return false;\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0)\n            return false;\n    }\n    return true;\n}\n\nbool is_multiply_prime(int a) {\n    int primeCount = 0;\n\n    // Check all primes less than 100\n    for (int p = 2; p < 100 && a > 1; ++p) {\n        if (isPrime(p)) {\n            while (a % p == 0) {\n                a /= p;\n                primeCount++;\n            }\n        }\n    }\n\n    // Check if exactly three primes were found\n    return primeCount == 3 && a == 1;\n}\n\n"}
{"task_id": "CPP/76", "generation": "#include <iostream>\n#include <cmath>\n\nbool is_simple_power(int x, int n) {\n    // Handle special cases:\n    if (n == 1) return x == 1; // Only 1^k = 1 for any k.\n    if (x <= 0 || n <= 0) return false; // Negative numbers and zero cannot be simple powers in this context.\n\n    double log_result = std::log(x) / std::log(n);\n    \n    // Check if the result is an integer by comparing it to its rounded value\n    return std::abs(log_result - round(log_result)) < 1e-10;\n}\n\n"}
{"task_id": "CPP/77", "generation": "#include <iostream>\n#include <cmath> // For cbrt function\n\nbool iscube(int a) {\n    double cubeRoot = cbrt(a);\n    int roundedCubeRoot = round(cubeRoot); // Round the cube root to the nearest integer\n    \n    // Check if the cube of the rounded value equals the original number\n    return (roundedCubeRoot * roundedCubeRoot * roundedCubeRoot == a);\n}\n\n"}
{"task_id": "CPP/78", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint hex_key(string num) {\n    // Define a set of prime hexadecimal digits.\n    string primes = \"2357BD\";\n    \n    int count = 0;\n    \n    // Iterate through each character in the input string.\n    for (char c : num) {\n        // If the current character is found in the primes string, increment the count.\n        if (primes.find(c) != string::npos)\n            ++count;\n    }\n    \n    return count;\n}\n\n"}
{"task_id": "CPP/79", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring decimal_to_binary(int decimal) {\n    // Handle the special case where the number is 0.\n    if (decimal == 0) return \"db0db\";\n\n    string binary = \"\";\n    \n    // Convert the decimal to binary by repeatedly dividing by 2 and storing remainders\n    while (decimal > 0) {\n        int remainder = decimal % 2;\n        binary = char('0' + remainder) + binary;  // Prepend the remainder as a character\n        decimal /= 2;\n    }\n    \n    // Add \"db\" at the beginning and end of the binary string.\n    return \"db\" + binary + \"db\";\n}\n\n// Function to test the correctness of the solution with given examples.\nvoid check() {\n    cout << (decimal_to_binary(15) == \"db1111db\") << endl; // Should output 1 for true\n    cout << (decimal_to_binary(32) == \"db100000db\") << endl; // Should output 1 for true\n}\n\n"}
{"task_id": "CPP/80", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_happy(string s) {\n    // Check if the length of the string is less than 3, return false immediately.\n    if (s.length() < 3) {\n        return false;\n    }\n\n    // Iterate through the string to check every set of three consecutive characters\n    for (size_t i = 0; i <= s.length() - 3; ++i) {\n        // Check if any two out of three consecutive characters are the same.\n        if (s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]) {\n            return false;\n        }\n    }\n\n    // If all checks pass, the string is happy\n    return true;\n}\n\n"}
{"task_id": "CPP/81", "generation": "#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<string> numerical_letter_grade(vector<float> grades) {\n    vector<string> result;\n    \n    for (float gpa : grades) {\n        if (gpa >= 4.0) result.push_back(\"A+\");\n        else if (gpa > 3.7) result.push_back(\"A\");\n        else if (gpa > 3.3) result.push_back(\"A-\");\n        else if (gpa > 3.0) result.push_back(\"B+\");\n        else if (gpa > 2.7) result.push_back(\"B\");\n        else if (gpa > 2.3) result.push_back(\"B-\");\n        else if (gpa > 2.0) result.push_back(\"C+\");\n        else if (gpa > 1.7) result.push_back(\"C\");\n        else if (gpa > 1.3) result.push_back(\"C-\");\n        else if (gpa > 1.0) result.push_back(\"D+\");\n        else if (gpa > 0.7) result.push_back(\"D\");\n        else if (gpa > 0.0) result.push_back(\"D-\");\n        else result.push_back(\"E\"); // This covers the case where GPA is exactly 0.0\n    }\n    \n    return result;\n}\n\n// Example usage:\n// vector<string> grades = numerical_letter_grade({4.0, 3, 1.7, 2, 3.5});\n// for (const auto& grade : grades) {\n//     cout << grade << \" \";\n// }\n"}
{"task_id": "CPP/82", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nbool is_prime(int n) {\n    if (n <= 1) return false; // 0 and 1 are not prime numbers\n    for (int i = 2; i * i <= n; ++i) { // Check divisibility up to the square root of n\n        if (n % i == 0)\n            return false;\n    }\n    return true;\n}\n\nbool prime_length(string str){\n    int length = str.length();\n    return is_prime(length);\n}\n\n"}
{"task_id": "CPP/83", "generation": "#include<iostream>\nusing namespace std;\n\nint starts_one_ends(int n){\n    if(n == 1)\n        return 1; // Only one number, which is '1', satisfies the condition.\n    \n    int total_n_digit_numbers = 9 * pow(10, n-1); // Total count of n-digit numbers\n    int start_with_1 = pow(10, n-1);              // Count of numbers starting with 1\n    int end_with_1 = pow(10, n-1);                // Count of numbers ending with 1\n    int both_start_end_with_1 = pow(10, n-2);     // Overlap: count of numbers that start and end with 1\n    \n    return total_n_digit_numbers - (total_n_digit_numbers - start_with_1) -\n           (total_n_digit_numbers - end_with_1) + both_start_end_with_1;\n}\n\n"}
{"task_id": "CPP/84", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\n// Function to calculate and return the sum of digits as a binary string.\nstring solve(int N) {\n    int sum = 0;\n    \n    // Calculate the sum of digits of N\n    while (N > 0) {\n        sum += N % 10; // Add the last digit of N to sum\n        N /= 10;       // Remove the last digit from N\n    }\n    \n    // Convert the sum into a binary string.\n    if (sum == 0) return \"0\"; // Special case for when sum is zero\n    \n    string binary = \"\";\n    while (sum > 0) {\n        binary = to_string(sum % 2) + binary; // Prepend the remainder of division by 2\n        sum /= 2;                             // Divide sum by 2\n    }\n    \n    return binary;\n}\n\n// Function to test the solve function with given examples.\nvoid test() {\n    cout << \"Testing N = 1000: Expected '1', Got '\" << solve(1000) << \"'\" << endl;\n    cout << \"Testing N = 150: Expected '110', Got '\" << solve(150) << \"'\" << endl;\n    cout << \"Testing N = 147: Expected '1100', Got '\" << solve(147) << \"'\" << endl;\n}\n\n"}
{"task_id": "CPP/85", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint add(vector<int> lst) {\n    int sum = 0;\n    \n    // Iterate through the vector starting from index 1 (second element)\n    for(int i = 1; i < lst.size(); i += 2) { // Increment by 2 to only check odd indices\n        if(lst[i] % 2 == 0) {\n            sum += lst[i];\n        }\n    }\n    \n    return sum;\n}\n\n"}
{"task_id": "CPP/86", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <algorithm>\n\nusing namespace std;\n\nstring anti_shuffle(string s) {\n    stringstream ss(s);\n    string word, result;\n    \n    // Process each word in the input string\n    while (ss >> word) {\n        // Sort characters of the current word\n        sort(word.begin(), word.end());\n        \n        // Append sorted word to the result string with a space\n        if (!result.empty()) {\n            result += \" \";\n        }\n        result += word;\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/87", "generation": "#include <vector>\n#include <algorithm> // For std::sort\n\nusing namespace std;\n\n// Comparator function for sorting the coordinates.\nbool compare(const vector<int>& a, const vector<int>& b) {\n    if (a[0] == b[0]) { // If they are in the same row,\n        return a[1] > b[1]; // sort by column index in descending order\n    }\n    return a[0] < b[0]; // Otherwise, sort by row index in ascending order\n}\n\nvector<vector<int>> get_row(vector<vector<int>> lst, int x) {\n    vector<vector<int>> coordinates;\n\n    // Iterate through each row and find occurrences of 'x'\n    for (int i = 0; i < lst.size(); ++i) {\n        for (int j = 0; j < lst[i].size(); ++j) {\n            if (lst[i][j] == x) {\n                coordinates.push_back({i, j});\n            }\n        }\n    }\n\n    // Sort the collected coordinates\n    sort(coordinates.begin(), coordinates.end(), compare);\n\n    return coordinates;\n}\n\n// Example usage:\n"}
{"task_id": "CPP/88", "generation": "#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> sort_array(vector<int> array) {\n    // Check if the array is empty or has only one element\n    if (array.size() <= 1) return array;\n    \n    // Calculate the sum of the first and last elements\n    int sum = array.front() + array.back();\n    \n    // Create a copy of the input vector to avoid modifying the original\n    vector<int> sortedArray(array);\n    \n    // Sort based on whether the sum is odd or even\n    if (sum % 2 == 0) {\n        sort(sortedArray.begin(), sortedArray.end(), greater<int>());\n    } else {\n        sort(sortedArray.begin(), sortedArray.end());\n    }\n    \n    return sortedArray;\n}\n\n// Example usage:\n"}
{"task_id": "CPP/89", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring encrypt(string s) {\n    string encrypted = \"\"; // Initialize an empty string to store the result.\n    \n    for (char c : s) { // Iterate over each character in the input string.\n        if (isalpha(c)) { // Check if the character is a letter.\n            char base = islower(c) ? 'a' : 'A'; // Determine the base ('a' or 'A') based on case.\n            int shift = 4; // Define the shift amount as per problem statement.\n            \n            // Calculate the new position with wrap-around for the alphabet.\n            char encryptedChar = ((c - base + shift) % 26) + base;\n            encrypted += encryptedChar; // Append the shifted character to the result string.\n        } else {\n            // If it's not a letter, append as is (though this case isn't covered in examples).\n            encrypted += c;\n        }\n    }\n\n    return encrypted; // Return the encrypted string.\n}\n\n"}
{"task_id": "CPP/90", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint* next_smallest(vector<int> lst){\n    // Check for empty list or single-element list.\n    if(lst.size() <= 1)\n        return nullptr; // Equivalent to None in C++.\n\n    // Sort the vector.\n    sort(lst.begin(), lst.end());\n\n    // Find the second smallest element by skipping duplicates of the smallest element.\n    int first = lst[0];\n    for(size_t i = 1; i < lst.size(); ++i){\n        if(lst[i] != first)\n            return new int(lst[i]); // Return a pointer to the second smallest element.\n    }\n\n    // If all elements are the same, there is no second smallest element.\n    return nullptr;\n}\n\n// Function to check the correctness of the solution\nvoid check() {\n    vector<int> test1 = {1, 2, 3, 4, 5};\n    vector<int> test2 = {5, 1, 4, 3, 2};\n    vector<int> test3 = {};\n    vector<int> test4 = {1, 1};\n\n    int* result;\n\n    result = next_smallest(test1);\n    cout << (result ? *result : -1) << endl; // Should print 2\n\n    result = next_smallest(test2);\n    cout << (result ? *result : -1) << endl; // Should print 2\n\n    result = next_smallest(test3);\n    cout << (result ? *result : -1) << endl; // Should print -1, indicating None\n\n    result = next_smallest(test4);\n    cout << (result ? *result : -1) << endl; // Should print -1, indicating None\n}\n\n"}
{"task_id": "CPP/91", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint is_bored(string S) {\n    int boredom_count = 0;\n    bool isNewSentence = true; // Flag to check if we are at the start of a new sentence\n\n    for (size_t i = 0; i <= S.length(); ++i) { // Loop through each character\n        char currentChar = (i < S.length()) ? S[i] : '\\0'; // Handle end of string gracefully\n        \n        // Check if we are at the start of a new sentence and it starts with \"I \"\n        if ((isNewSentence && i + 1 < S.length() && S.substr(i, 2) == \"I \")) {\n            boredom_count++;\n        }\n\n        // Update isNewSentence flag based on punctuation marks\n        if (currentChar == '.' || currentChar == '?' || currentChar == '!') {\n            isNewSentence = true;\n        } else {\n            isNewSentence = false;\n        }\n    }\n\n    return boredom_count;\n}\n\n// Function to test the is_bored function with provided data points\nvoid check() {\n    cout << \"Test 1: \" << (is_bored(\"Hello world\") == 0 ? \"Passed\" : \"Failed\") << endl;\n    cout << \"Test 2: \" << (is_bored(\"The sky is blue. The sun is shining. I love this weather.\") == 1 ? \"Passed\" : \"Failed\") << endl;\n}\n\n"}
{"task_id": "CPP/92", "generation": "#include <iostream>\n#include <cmath>\n\nbool isInteger(float num) {\n    return std::floor(num) == num;\n}\n\nbool any_int(float a, float b, float c) {\n    // Check if all numbers are integers\n    if (!isInteger(a) || !isInteger(b) || !isInteger(c)) {\n        return false;\n    }\n\n    // Convert to int for comparison\n    int ia = static_cast<int>(a);\n    int ib = static_cast<int>(b);\n    int ic = static_cast<int>(c);\n\n    // Check if any number is equal to the sum of the other two\n    return (ia == ib + ic) || (ib == ia + ic) || (ic == ia + ib);\n}\n\n"}
{"task_id": "CPP/93", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\n// Function to encode the message as per given rules.\nstring encode(string message) {\n    string encodedMessage = \"\";\n    \n    // Iterate through each character in the input message.\n    for (char &c : message) {\n        if (islower(c)) {  // If lowercase, convert to uppercase\n            c = toupper(c);\n        } else if (isupper(c)) {  // If uppercase, convert to lowercase\n            c = tolower(c);\n        }\n        \n        // Replace vowels with the letter that appears two places ahead.\n        switch (c) {\n            case 'a': c = 'c'; break;\n            case 'e': c = 'g'; break;\n            case 'i': c = 'k'; break;\n            case 'o': c = 'q'; break;\n            case 'u': c = 'w'; break;\n            case 'A': c = 'C'; break;\n            case 'E': c = 'G'; break;\n            case 'I': c = 'K'; break;\n            case 'O': c = 'Q'; break;\n            case 'U': c = 'W'; break;\n        }\n        \n        // Append the modified character to the encoded message.\n        encodedMessage += c;\n    }\n    \n    return encodedMessage;\n}\n\n"}
{"task_id": "CPP/94", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Helper function to check if a number is prime\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\n// Function to calculate the sum of digits of a number\nint sum_of_digits(int num) {\n    int sum = 0;\n    while (num > 0) {\n        sum += num % 10;\n        num /= 10;\n    }\n    return sum;\n}\n\n// Main function that finds the largest prime and returns the sum of its digits\nint skjkasdkd(vector<int> lst) {\n    int max_prime = -1; // Initialize with a non-prime value\n    \n    for (auto &num : lst) {\n        if (is_prime(num)) {\n            max_prime = max(max_prime, num);\n        }\n    }\n\n    return sum_of_digits(max_prime); // Return the sum of digits of the largest prime\n}\n\n// Example usage\n"}
{"task_id": "CPP/95", "generation": "#include <iostream>\n#include <map>\n#include <string>\nusing namespace std;\n\nbool check_dict_case(map<string, string> dict) {\n    // If the dictionary is empty, return false.\n    if (dict.empty()) return false;\n    \n    bool allLower = true;  // Flag to track if all keys are lowercase\n    bool allUpper = true;  // Flag to track if all keys are uppercase\n    \n    for (const auto& pair : dict) {\n        const string& key = pair.first;\n        \n        // Check each character in the key.\n        for (char ch : key) {\n            if (!isalpha(ch)) {  // If any non-alphabetic character is found, return false\n                return false;\n            }\n            \n            if (islower(ch)) allUpper = false;  // If a lowercase letter is found, set allUpper to false.\n            else if (isupper(ch)) allLower = false;  // If an uppercase letter is found, set allLower to false.\n        }\n    }\n\n    // Return true only if all keys are either all lower or all upper case.\n    return allLower || allUpper;\n}\n\n"}
{"task_id": "CPP/96", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int num) {\n    if (num <= 1) return false; // 0 and 1 are not primes\n    for (int i = 2; i * i <= num; ++i) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\nvector<int> count_up_to(int n){\n    vector<int> primes;\n\n    // Iterate through numbers from 2 to n-1\n    for (int i = 2; i < n; ++i) {\n        if (is_prime(i)) {\n            primes.push_back(i);\n        }\n    }\n\n    return primes;\n}\n\n// Function to test the count_up_to function with given examples\nvoid test() {\n    vector<int> result;\n\n    result = count_up_to(5); // Expected: {2, 3}\n    for(int num : result) cout << num << \" \";\n    cout << endl;\n\n    result = count_up_to(11); // Expected: {2, 3, 5, 7}\n    for(int num : result) cout << num << \" \";\n    cout << endl;\n\n    result = count_up_to(0); // Expected: {}\n    if(result.empty()) cout << \"{}\" << endl;\n    \n    result = count_up_to(20); // Expected: {2, 3, 5, 7, 11, 13, 17, 19}\n    for(int num : result) cout << num << \" \";\n    cout << endl;\n\n    result = count_up_to(1); // Expected: {}\n    if(result.empty()) cout << \"{}\" << endl;\n    \n    result = count_up_to(18); // Expected: {2, 3, 5, 7, 11, 13, 17}\n    for(int num : result) cout << num << \" \";\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/97", "generation": "#include <iostream> // Corrected from #include<stdio.h>\nusing namespace std;\n\nint multiply(int a, int b) {\n    // Extract unit digits of both numbers.\n    int unitDigitA = abs(a % 10); // Use abs to handle negative numbers properly.\n    int unitDigitB = abs(b % 10);\n    \n    // Return the product of these unit digits.\n    return unitDigitA * unitDigitB;\n}\n\n"}
{"task_id": "CPP/98", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint count_upper(string s) {\n    int count = 0;\n    // Iterate through the string, checking only even indices.\n    for (size_t i = 0; i < s.length(); i += 2) { \n        char c = toupper(s[i]); // Convert to uppercase to simplify comparison\n        if(c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n            count++;\n        }\n    }\n    return count;\n}\n\n"}
{"task_id": "CPP/99", "generation": "#include <iostream>\n#include <cmath>\n#include <string>\n\nusing namespace std;\n\nint closest_integer(string value) {\n    // Convert string to double for precision\n    double num = stod(value);\n    \n    // Check if the number is positive or negative\n    bool isPositive = num > 0;\n    \n    // Get the fractional part of the number\n    double fractionPart = fabs(num - floor(num));\n    \n    // If the fractional part is exactly .5, round away from zero\n    if (fractionPart == 0.5) {\n        return isPositive ? ceil(num) : floor(num);\n    } else {\n        // Otherwise, use standard rounding\n        return static_cast<int>(round(num));\n    }\n}\n\n// Function to test the closest_integer function with some examples\nvoid check() {\n    cout << \"Testing closest_integer:\" << endl;\n    cout << \"closest_integer(\\\"10\\\") = \" << closest_integer(\"10\") << \", Expected: 10\" << endl;\n    cout << \"closest_integer(\\\"15.3\\\") = \" << closest_integer(\"15.3\") << \", Expected: 15\" << endl;\n    cout << \"closest_integer(\\\"14.5\\\") = \" << closest_integer(\"14.5\") << \", Expected: 15\" << endl;\n    cout << \"closest_integer(\\\"-14.5\\\") = \" << closest_integer(\"-14.5\") << \", Expected: -15\" << endl;\n}\n\n"}
{"task_id": "CPP/100", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvector<int> make_a_pile(int n) {\n    vector<int> pile;\n    int current_stones = n; // Start with n stones\n\n    for (int i = 0; i < n; ++i) {\n        pile.push_back(current_stones); // Add the number of stones to the pile\n        if (current_stones % 2 == 0) { // If even, next is current + 1\n            current_stones += 1;\n        } else { // If odd, next is current + 2\n            current_stones += 2;\n        }\n    }\n\n    return pile;\n}\n\n// Function to check the correctness of the solution\nvoid check_solution() {\n    vector<int> result = make_a_pile(3);\n    assert((result == vector<int>{3, 5, 7}) && \"Test case for n=3 failed\");\n\n    // Add more test cases if necessary\n    cout << \"All tests passed successfully.\" << endl;\n}\n\n"}
{"task_id": "CPP/101", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> words_string(string s) {\n    vector<string> result;\n    string word = \"\";\n    \n    for (char c : s) {\n        if (c == ' ' || c == ',') { // Check for space or comma\n            if (!word.empty()) { // Add the collected word to the result vector only if it's not empty\n                result.push_back(word);\n                word = \"\"; // Reset the word string after adding to the result\n            }\n        } else {\n            word += c; // Collect characters into a word until we find a delimiter\n        }\n    }\n\n    if (!word.empty()) { // Add any remaining collected word (last one) to the vector\n        result.push_back(word);\n    }\n\n    return result;\n}\n\n// Example usage:\n"}
{"task_id": "CPP/102", "generation": "#include <iostream>\nusing namespace std;\n\nint choose_num(int x, int y) {\n    // Ensure x <= y. If not, there's no valid range.\n    if (x > y) return -1;\n    \n    // Start from the larger number and move backwards to find the largest even number.\n    for (int i = max(x, y); i >= min(x, y); --i) {\n        if (i % 2 == 0) return i; // If it's even, return it.\n    }\n    \n    // If no even numbers are found in the range, return -1.\n    return -1;\n}\n\n"}
{"task_id": "CPP/103", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\n// Function to convert an integer to a binary string.\nstring int_to_binary(int num) {\n    if (num == 0) return \"0\";\n    string result = \"\";\n    while (num > 0) {\n        // Prepend the remainder of num divided by 2\n        result = to_string(num % 2) + result;\n        num /= 2;\n    }\n    return result;\n}\n\nstring rounded_avg(int n, int m) {\n    if (n > m) return \"-1\";\n    \n    // Calculate the sum from n through m.\n    long long total_sum = 0;\n    for (int i = n; i <= m; ++i) {\n        total_sum += i;\n    }\n    \n    // Calculate the average and floor it.\n    int count = m - n + 1;\n    int avg = static_cast<int>(total_sum / count);\n    \n    // Convert the rounded-down average to binary.\n    return int_to_binary(avg);\n}\n\n"}
{"task_id": "CPP/104", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// Helper function to check if a number contains only odd digits.\nbool hasOnlyOddDigits(int num) {\n    while (num > 0) {\n        int digit = num % 10;\n        if (digit % 2 == 0) return false; // If any digit is even, return false\n        num /= 10;\n    }\n    return true;\n}\n\nvector<int> unique_digits(vector<int> x) {\n    vector<int> result;\n\n    // Filter out numbers that have only odd digits.\n    for (int num : x) {\n        if (hasOnlyOddDigits(num)) {\n            result.push_back(num);\n        }\n    }\n\n    // Sort the resulting vector in increasing order\n    sort(result.begin(), result.end());\n\n    return result;\n}\n\n// Example usage:\n/*\nvector<int> test1 = {15, 33, 1422, 1};\nvector<int> res1 = unique_digits(test1);\nfor (int num : res1) {\n    printf(\"%d \", num); // Output: 1 15 33\n}\nprintf(\"\\n\");\n\nvector<int> test2 = {152, 323, 1422, 10};\nvector<int> res2 = unique_digits(test2);\nfor (int num : res2) {\n    printf(\"%d \", num); // Output: (empty)\n}\n*/\n"}
{"task_id": "CPP/105", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nvector<string> by_length(vector<int> arr) {\n    // Mapping from digits to their names\n    map<int, string> digitNames = {\n        {1, \"One\"}, {2, \"Two\"}, {3, \"Three\"},\n        {4, \"Four\"}, {5, \"Five\"}, {6, \"Six\"},\n        {7, \"Seven\"}, {8, \"Eight\"}, {9, \"Nine\"}\n    };\n\n    vector<int> filteredArr;\n    \n    // Filter out integers not between 1 and 9\n    for (int num : arr) {\n        if (num >= 1 && num <= 9) {\n            filteredArr.push_back(num);\n        }\n    }\n\n    // Sort the array\n    sort(filteredArr.begin(), filteredArr.end());\n\n    // Reverse the sorted array\n    reverse(filteredArr.begin(), filteredArr.end());\n\n    vector<string> result;\n    \n    // Replace each digit with its name\n    for (int num : filteredArr) {\n        result.push_back(digitNames[num]);\n    }\n\n    return result;\n}\n\n// Function to check the correctness of the solution\nvoid check() {\n    vector<int> test1 = {2, 1, 1, 4, 5, 8, 2, 3};\n    vector<string> expected1 = {\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"};\n    assert(by_length(test1) == expected1);\n\n    vector<int> test2 = {};\n    vector<string> expected2 = {};\n    assert(by_length(test2) == expected2);\n\n    vector<int> test3 = {1, -1, 55};\n    vector<string> expected3 = {\"One\"};\n    assert(by_length(test3) == expected3);\n    \n    cout << \"All tests passed successfully.\" << endl;\n}\n\n"}
{"task_id": "CPP/106", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// Function to calculate factorial\nint factorial(int num) {\n    int result = 1;\n    for (int i = 2; i <= num; ++i) {\n        result *= i;\n    }\n    return result;\n}\n\n// Function to calculate the sum of numbers from 1 to num\nint sumToN(int num) {\n    return (num * (num + 1)) / 2;\n}\n\nvector<int> f(int n){\n    vector<int> result(n);\n    \n    for (int i = 0; i < n; ++i) {\n        if ((i+1) % 2 == 0) { // Check if the index plus one is even\n            result[i] = factorial(i + 1); // Calculate factorial\n        } else {\n            result[i] = sumToN(i + 1); // Calculate sum from 1 to i+1\n        }\n    }\n\n    return result;\n}\n\n// Function to test the correctness of f function\nvoid check() {\n    vector<int> expected = {1, 2, 6, 24, 15};\n    vector<int> actual = f(5);\n    \n    if (actual == expected) {\n        cout << \"Test passed.\" << endl;\n    } else {\n        cout << \"Test failed.\" << endl;\n    }\n}\n\n"}
{"task_id": "CPP/107", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to check if a number is palindrome\nbool isPalindrome(int num) {\n    string str = to_string(num);\n    int len = str.length();\n    for (int i = 0; i < len / 2; ++i) {\n        if (str[i] != str[len - i - 1]) return false;\n    }\n    return true;\n}\n\nvector<int> even_odd_palindrome(int n){\n    vector<int> result(2, 0); // Initialize a vector with two elements set to zero\n    for (int i = 1; i <= n; ++i) {\n        if (isPalindrome(i)) { // Check if the number is palindrome\n            if (i % 2 == 0)\n                result[0]++; // Increment even count\n            else\n                result[1]++; // Increment odd count\n        }\n    }\n    return result;\n}\n\n// Example usage:\n"}
{"task_id": "CPP/108", "generation": "#include <vector>\nusing namespace std;\n\nint count_nums(vector<int> n) {\n    int count = 0;\n    \n    for (auto num : n) {\n        int sum_of_digits = 0, temp_num = abs(num);\n        \n        // Calculate the sum of digits.\n        while (temp_num > 0) {\n            sum_of_digits += temp_num % 10; \n            temp_num /= 10;\n        }\n        \n        // If the number is negative and its absolute value's digit sum is greater than 0,\n        // we need to adjust the first digit as negative.\n        if (num < 0) {\n            sum_of_digits -= 2 * (abs(num) % 10);\n        }\n\n        // Check if the sum of digits is greater than 0\n        if (sum_of_digits > 0) {\n            count++;\n        }\n    }\n    \n    return count;\n}\n\n// Example usage:\n/*\n"}
{"task_id": "CPP/109", "generation": "#include <vector>\n#include <algorithm> // for std::is_sorted_until\n\nusing namespace std;\n\nbool move_one_ball(vector<int>& arr) {\n    if (arr.empty()) return true;  // An empty vector is considered sorted.\n    \n    auto it = is_sorted_until(arr.begin(), arr.end());  // Find the first unsorted element.\n\n    // If the array is already sorted, return true.\n    if (it == arr.end()) return true;\n\n    // Check if we can split the array into two non-decreasing sequences\n    // and the last element of the first part <= the first element of the second part.\n    auto end_of_first_part = it - 1;\n    auto start_of_second_part = it;\n    \n    // If there's no valid split, return false.\n    if (end_of_first_part == arr.begin() || *arr.rbegin() > *start_of_second_part) {\n        return false;\n    }\n\n    // Check the second part is sorted\n    if (!is_sorted(start_of_second_part, arr.end())) {\n        return false;\n    }\n    \n    // If we reach here, it means the array can be split into two non-decreasing sequences.\n    return true;\n}\n"}
{"task_id": "CPP/110", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring exchange(vector<int> lst1, vector<int> lst2) {\n    // Count the odd numbers in lst1 and even numbers in lst2.\n    int oddCountInLst1 = 0;\n    for (int num : lst1) {\n        if (num % 2 != 0) {\n            ++oddCountInLst1;\n        }\n    }\n\n    int evenCountInLst2 = 0;\n    for (int num : lst2) {\n        if (num % 2 == 0) {\n            ++evenCountInLst2;\n        }\n    }\n\n    // If there are enough even numbers in lst2 to replace all odd numbers in lst1, return \"YES\".\n    if (oddCountInLst1 <= evenCountInLst2) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n\n"}
{"task_id": "CPP/111", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <map>\n\nusing namespace std;\n\nmap<char, int> histogram(string test) {\n    // Map to store character frequencies\n    map<char, int> freqMap;\n    \n    // Parse the input string and count occurrences of each character\n    stringstream ss(test);\n    char ch;\n    while (ss >> ch) {\n        ++freqMap[ch];\n    }\n    \n    // Determine the maximum frequency\n    int maxFreq = 0;\n    for (auto& pair : freqMap) {\n        if (pair.second > maxFreq) {\n            maxFreq = pair.second;\n        }\n    }\n\n    // Create a map with only characters that have the maximum frequency\n    map<char, int> result;\n    for (auto& pair : freqMap) {\n        if (pair.second == maxFreq) {\n            result.insert(pair);\n        }\n    }\n\n    return result;\n}\n\n// Function to print the histogram results for testing purposes\nvoid printHistogram(const map<char, int>& hist) {\n    for (const auto& pair : hist) {\n        cout << \"{\" << pair.first << \", \" << pair.second << \"} \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/112", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to check if a string is a palindrome.\nbool isPalindrome(const string& str) {\n    int n = str.length();\n    for (int i = 0; i < n / 2; ++i) {\n        if (str[i] != str[n - i - 1]) return false;\n    }\n    return true;\n}\n\nvector<string> reverse_delete(string s, string c) {\n    // Remove characters from 's' that are present in 'c'\n    for (char ch : c) {\n        s.erase(remove(s.begin(), s.end(), ch), s.end());\n    }\n\n    // Check if the resulting string is a palindrome\n    bool result = isPalindrome(s);\n\n    vector<string> res;\n    res.push_back(s);\n    res.push_back(result ? \"True\" : \"False\");\n\n    return res;\n}\n\n"}
{"task_id": "CPP/113", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to count odd digits in a given string.\nint countOddDigits(const string& str) {\n    int count = 0;\n    for (char c : str) {\n        if ((c - '0') % 2 != 0) { // Check if the digit is odd\n            ++count;\n        }\n    }\n    return count;\n}\n\nvector<string> odd_count(vector<string> lst){\n    vector<string> result;\n    string templateSentence = \"the number of odd elements in the strin of the input.\";\n\n    for (const auto& s : lst) {\n        int oddCount = countOddDigits(s);\n        string modifiedSentence = templateSentence;\n\n        // Replace all occurrences of 'i' with the odd digit count.\n        for (size_t pos = 0; ; pos += 1 + to_string(oddCount).length()) {\n            pos = modifiedSentence.find('i', pos);\n            if (pos == string::npos) break;\n            modifiedSentence.replace(pos, 1, to_string(oddCount));\n        }\n\n        result.push_back(modifiedSentence);\n    }\n    \n    return result;\n}\n\n// Function to test the odd_count function.\nvoid check() {\n    vector<string> input = {\"1234567\", \"3\", \"11111111\"};\n    vector<string> expectedOutput = {\n        \"the number of odd elements 4n the str4ng 4 of the 4nput.\",\n        \"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n        \"the number of odd elements 8n the str8ng 8 of the 8nput.\"\n    };\n    \n    vector<string> output = odd_count(input);\n    \n    for (size_t i = 0; i < expectedOutput.size(); ++i) {\n        cout << \"Test case \" << i + 1 << \": \";\n        if (output[i] == expectedOutput[i]) {\n            cout << \"PASS\" << endl;\n        } else {\n            cout << \"FAIL: Expected '\" << expectedOutput[i] << \"' but got '\" << output[i] << \"'\" << endl;\n        }\n    }\n}\n\n"}
{"task_id": "CPP/114", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // For std::min\n\nusing namespace std;\n\nlong long minSubArraySum(vector<long long> nums) {\n    if (nums.empty()) return 0; // Handle empty vector case\n    \n    long long currentMin = nums[0];\n    long long globalMin = nums[0];\n\n    for (size_t i = 1; i < nums.size(); ++i) {\n        currentMin = min(nums[i], currentMin + nums[i]);\n        globalMin = min(globalMin, currentMin);\n    }\n\n    return globalMin;\n}\n\n"}
{"task_id": "CPP/115", "generation": "#include <vector>\nusing namespace std;\n\nint max_fill(vector<vector<int>> grid, int capacity) {\n    int total_lowerings = 0;\n    \n    // Iterate through each well (row)\n    for(auto& row : grid) {\n        int water_units = 0;\n        \n        // Count the number of units of water in this well\n        for(int unit : row) {\n            if(unit == 1) {\n                ++water_units;\n            }\n        }\n        \n        // Calculate how many times we need to lower the bucket\n        total_lowerings += (water_units + capacity - 1) / capacity; \n    }\n    \n    return total_lowerings;\n}\n\n// Example usage:\n"}
{"task_id": "CPP/116", "generation": "#include <vector>\n#include <algorithm>\n\n// Function to count the number of 1s in the binary representation of an integer.\nint countOnes(int n) {\n    int ones = 0;\n    while (n != 0) {\n        if ((n & 1) == 1) // Check if the least significant bit is 1\n            ++ones;\n        n >>= 1; // Right shift to check the next bit\n    }\n    return ones;\n}\n\n// Comparator function for sorting.\nbool compare(int a, int b) {\n    int countA = countOnes(a);\n    int countB = countOnes(b);\n\n    if (countA == countB)\n        return a < b; // If number of 1s is the same, sort by decimal value\n    else\n        return countA < countB; // Otherwise, sort by number of 1s\n}\n\nvector<int> sort_array(vector<int> arr) {\n    std::sort(arr.begin(), arr.end(), compare);\n    return arr;\n}\n"}
{"task_id": "CPP/117", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to check if a character is a consonant\nbool isConsonant(char c) {\n    string vowels = \"aeiouAEIOU\";\n    return !vowels.find(c) && (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z');\n}\n\nvector<string> select_words(string s, int n) {\n    vector<string> result;\n    string word = \"\";\n    \n    // Iterate through the input string to split it into words\n    for(char ch : s) {\n        if(ch == ' ') {  // If a space is encountered, process the current word\n            if(!word.empty()) {\n                int consonantCount = count_if(word.begin(), word.end(), isConsonant);\n                if(consonantCount == n)\n                    result.push_back(word);\n                word.clear();  // Reset the word for the next iteration\n            }\n        } else {  // If not a space, add character to current word\n            word += ch;\n        }\n    }\n\n    // Process the last word in case there's no trailing space\n    if(!word.empty()) {\n        int consonantCount = count_if(word.begin(), word.end(), isConsonant);\n        if(consonantCount == n)\n            result.push_back(word);\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/118", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool isVowel(char c) {\n    string vowels = \"aeiouAEIOU\";\n    return vowels.find(c) != string::npos;\n}\n\nstring get_closest_vowel(string word) {\n    int n = word.length();\n    \n    // Iterate from the end of the string towards the beginning\n    for (int i = n - 2; i > 0; --i) { // Start from second last character to avoid edge cases\n        if (isVowel(word[i])) { // Check if current char is a vowel\n            // Check if both neighbors are consonants\n            if (!isVowel(word[i-1]) && !isVowel(word[i+1])) {\n                return string(1, word[i]); // Return the found vowel as a string\n            }\n        }\n    }\n\n    return \"\"; // No such vowel found\n}\n\n"}
{"task_id": "CPP/119", "generation": "#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to check if the given string is balanced.\nbool isBalanced(const string& s) {\n    int balance = 0;\n    for (char c : s) {\n        if (c == '(') ++balance;\n        else --balance;\n        // If at any point, balance goes negative, it means there are more closing parentheses than opening ones before this point.\n        if (balance < 0) return false;\n    }\n    return balance == 0; // The string is balanced only if the final count of open and close parentheses is equal.\n}\n\nstring match_parens(vector<string> lst){\n    int open1 = 0, close1 = 0, open2 = 0, close2 = 0;\n\n    for (char c : lst[0]) {\n        if (c == '(') ++open1;\n        else ++close1;\n    }\n    \n    for (char c : lst[1]) {\n        if (c == '(') ++open2;\n        else ++close2;\n    }\n\n    // Check individual balance\n    bool balanced1 = isBalanced(lst[0]);\n    bool balanced2 = isBalanced(lst[1]);\n\n    // If both are already balanced, concatenation in any order will be balanced.\n    if (balanced1 && balanced2) return \"Yes\";\n\n    // If one string has more closing parentheses and the other has enough opening ones to balance it out\n    if ((open1 >= close2 && open2 + close1 - close2 == 0) || \n        (open2 >= close1 && open1 + close2 - close1 == 0)) {\n        return \"Yes\";\n    }\n\n    // If none of the above conditions are met, it's not possible to form a balanced string.\n    return \"No\";\n}\n"}
{"task_id": "CPP/120", "generation": "#include <vector>\n#include <algorithm> // For std::sort\n\nusing namespace std;\n\nvector<int> maximum(vector<int> arr, int k) {\n    // Step 1: Sort the array in ascending order.\n    sort(arr.begin(), arr.end());\n    \n    // Step 2: Create a new vector to store the largest k elements.\n    vector<int> result;\n    for (int i = arr.size() - k; i < arr.size(); ++i) {\n        result.push_back(arr[i]);\n    }\n    \n    return result;\n}\n\n// Example usage\n#include <iostream>\nusing namespace std;\n\nvoid printVector(const vector<int>& vec) {\n    for (int num : vec) {\n        cout << num << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/121", "generation": "#include <vector>\nusing namespace std;\n\nint solution(vector<int> lst) {\n    int sum = 0;\n    \n    // Iterate through the vector with index i.\n    for (size_t i = 0; i < lst.size(); ++i) {\n        // Check if the position is even and the element at that position is odd\n        if ((i % 2 == 0) && (lst[i] % 2 != 0)) {\n            sum += lst[i];\n        }\n    }\n\n    return sum;\n}\n"}
{"task_id": "CPP/122", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint add_elements(vector<int> arr, int k) {\n    // Initialize sum to zero.\n    int sum = 0;\n    \n    // Iterate through the first k elements of the array.\n    for (int i = 0; i < k; ++i) {\n        // Check if the current element has at most two digits.\n        if (arr[i] >= 0 && arr[i] <= 99) {\n            sum += arr[i];  // Add it to the sum if it does.\n        }\n    }\n\n    return sum;\n}\n\n// Function to test the solution with given data points\nvoid check() {\n    vector<int> arr = {111,21,3,4000,5,6,7,8,9};\n    int k = 4;\n    cout << \"Output: \" << add_elements(arr, k) << endl; // Expected output: 24\n}\n\n"}
{"task_id": "CPP/123", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // For std::sort\n\nusing namespace std;\n\nvector<int> get_odd_collatz(int n) {\n    vector<int> oddNumbers;\n    \n    while (n != 1) {\n        if (n % 2 == 1) { // If n is odd\n            oddNumbers.push_back(n);\n        }\n        if (n % 2 == 0) { // If n is even\n            n /= 2;       // Divide by 2\n        } else {\n            n = 3 * n + 1; // Multiply by 3 and add 1\n        }\n    }\n    \n    oddNumbers.push_back(1); // Add the final number, which is always 1\n    \n    sort(oddNumbers.begin(), oddNumbers.end()); // Sort in increasing order\n    \n    return oddNumbers;\n}\n\n"}
{"task_id": "CPP/124", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool valid_date(string date) {\n    // Check for empty string\n    if (date.empty()) return false;\n    \n    // Validate format mm-dd-yyyy and extract parts\n    if (date.size() != 10 || date[2] != '-' || date[5] != '-') return false;\n    \n    int month, day, year;\n    sscanf(date.c_str(), \"%d-%d-%d\", &month, &day, &year);\n    \n    // Check for valid month\n    if (month < 1 || month > 12) return false;\n\n    // Check for valid day based on the month\n    if ((month == 4 || month == 6 || month == 9 || month == 11 && day < 1 || day > 30)) return false;\n    else if (day < 1 || day > 31) return false;\n\n    // Special case for February\n    if (month == 2) {\n        if (day < 1 || day > 29) return false; // Considering only non-leap years here.\n    }\n\n    return true;\n}\n\n"}
{"task_id": "CPP/125", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to check if character is a lowercase letter with an odd order in the alphabet.\nbool has_odd_order(char c) {\n    return (c >= 'a' && c <= 'z') && ((c - 'a') % 2 == 1);\n}\n\nvector<string> split_words(string txt){\n    vector<string> result;\n    \n    // Check for whitespace\n    if(txt.find(' ') != string::npos) {\n        size_t start = 0;\n        size_t end = txt.find(' ');\n        while(end != string::npos) {\n            result.push_back(txt.substr(start, end - start));\n            start = end + 1;\n            end = txt.find(' ', start);\n        }\n        // Add the last word\n        result.push_back(txt.substr(start, txt.length() - start));\n    } else if (txt.find(',') != string::npos) { // Check for comma\n        size_t start = 0;\n        size_t end = txt.find(',');\n        while(end != string::npos) {\n            result.push_back(txt.substr(start, end - start));\n            start = end + 1;\n            end = txt.find(',', start);\n        }\n        // Add the last word\n        result.push_back(txt.substr(start, txt.length() - start));\n    } else { // No whitespace or comma found\n        int count_odd_order_letters = count_if(txt.begin(), txt.end(), has_odd_order);\n        string odd_count_str = to_string(count_odd_order_letters);\n        result.push_back(odd_count_str);\n    }\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/126", "generation": "#include <vector>\n#include <algorithm>\n\nbool is_sorted(std::vector<int> lst) {\n    // Check if the list is empty or has only one element, which means it's sorted.\n    if (lst.size() <= 1) return true;\n\n    // Initialize a counter for consecutive duplicates and previous number.\n    int count = 1;\n    int prev = lst[0];\n\n    // Iterate through the vector starting from the second element.\n    for(size_t i = 1; i < lst.size(); ++i) {\n        if (lst[i] < prev) return false; // If current is less than previous, not sorted.\n\n        if (lst[i] == prev) { // Count duplicates\n            count++;\n            if(count > 2) return false; // More than two duplicates found.\n        } else {\n            count = 1; // Reset counter for the next number.\n        }\n        \n        prev = lst[i]; // Update previous to current element.\n    }\n\n    return true;\n}\n"}
{"task_id": "CPP/127", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to check if a number is prime\nbool isPrime(int n) {\n    if (n <= 1)\n        return false;\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0)\n            return false;\n    }\n    return true;\n}\n\nstring intersection(vector<int> interval1, vector<int> interval2) {\n    // Determine the start and end of the intersection\n    int startMax = max(interval1[0], interval2[0]);\n    int endMin = min(interval1[1], interval2[1]);\n\n    // Check if there is an intersection\n    if (startMax > endMin)\n        return \"NO\";  // No intersection\n\n    // Calculate the length of the intersection\n    int length = endMin - startMax + 1;\n\n    // Check if the length is a prime number\n    if (isPrime(length))\n        return \"YES\";\n    else\n        return \"NO\";\n}\n\n"}
{"task_id": "CPP/128", "generation": "#include <vector>\n#include <cmath> // For std::abs\n\nint prod_signs(std::vector<int> arr) {\n    if (arr.empty()) return -32768; // Return special value for empty vector\n    \n    int sum_of_magnitudes = 0;\n    int product_of_signs = 1;\n\n    for (auto num : arr) {\n        sum_of_magnitudes += std::abs(num); // Sum of magnitudes\n        if (num == 0) {\n            product_of_signs = 0; // If any number is zero, the product becomes zero\n            break;\n        } else if (num < 0) {\n            product_of_signs *= -1; // Negative numbers contribute a -1 to the sign product\n        }\n    }\n\n    return sum_of_magnitudes * product_of_signs; // Final result\n}\n\n// Example usage:\n"}
{"task_id": "CPP/129", "generation": "#include <vector>\n#include <queue>\nusing namespace std;\n\n// Directions for moving to adjacent cells (up, down, left, right)\nconst vector<pair<int, int>> directions = {{0, 1}, {1, 0}, {-1, 0}, {0, -1}};\n\nvector<int> minPath(vector<vector<int>>& grid, int k) {\n    int N = grid.size();\n    \n    // Min-heap to store paths based on lexicographical order\n    auto cmp = [](const pair<vector<int>, pair<int, int>>& a,\n                  const pair<vector<int>, pair<int, int>>& b) { \n        return a.first > b.first; \n    };\n    priority_queue<pair<vector<int>, pair<int, int>>, vector<pair<vector<int>, pair<int, int>>>, decltype(cmp)> pq(cmp);\n    \n    // Initialize the heap with all possible starting points\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            pq.push({{grid[i][j]}, {i, j}});\n        }\n    }\n\n    while (!pq.empty()) {\n        auto [path, pos] = pq.top(); // Get the current path and position\n        pq.pop();\n        \n        if (path.size() == k) return path; // If we have a complete path of length k\n        \n        int x = pos.first;\n        int y = pos.second;\n\n        for (auto& dir : directions) {\n            int nx = x + dir.first, ny = y + dir.second;\n            \n            // Check if the new position is within bounds\n            if (nx >= 0 && nx < N && ny >= 0 && ny < N) {\n                vector<int> newPath(path);\n                newPath.push_back(grid[nx][ny]);\n                \n                pq.push({newPath, {nx, ny}});\n            }\n        }\n    }\n\n    return {}; // Should never reach here if input is valid\n}\n"}
{"task_id": "CPP/130", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> tri(int n) {\n    vector<int> result(n + 1, 0); // Initialize a vector of size n+1 with all elements set to 0.\n    \n    if (n >= 1)\n        result[1] = 3; // Base case for odd numbers\n    \n    for (int i = 2; i <= n; ++i) {\n        if (i % 2 == 0) { // If even\n            result[i] = 1 + i / 2;\n        } else { // If odd and greater than 1\n            if (i >= 3)\n                result[i] = result[i - 1] + result[i - 2] + result[i - 3];\n            else\n                result[i] = 3; // For the case of i == 1, which is already set.\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/131", "generation": "#include <iostream>\nusing namespace std;\n\nint digits(int n) {\n    int product = 1;\n    bool hasOddDigit = false; // Flag to check if any odd digit is found\n\n    while (n > 0) {\n        int digit = n % 10; // Extract the last digit\n        if (digit % 2 != 0) { // Check if the digit is odd\n            product *= digit;\n            hasOddDigit = true;\n        }\n        n /= 10; // Remove the last digit from n\n    }\n\n    return hasOddDigit ? product : 0; // Return product or 0 based on whether an odd digit was found\n}\n\n"}
{"task_id": "CPP/132", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_nested(string str) {\n    int depth = 0;\n    bool hasNested = false;\n\n    for (char c : str) {\n        if (c == '[') {\n            depth++;\n        } else if (c == ']') {\n            if (depth > 1) {\n                hasNested = true;\n            }\n            depth--;\n        }\n\n        // Early exit if we've already found a nested pair\n        if (hasNested) return true;\n\n        // If depth is negative, it means there are more closing brackets than opening ones.\n        if (depth < 0) break;\n    }\n\n    return hasNested;\n}\n\n"}
{"task_id": "CPP/133", "generation": "#include <iostream>\n#include <vector>\n#include <cmath> // For ceil() and pow()\n\nusing namespace std;\n\nint sum_squares(vector<float> lst) {\n    int sum = 0;\n    \n    for (float num : lst) {\n        float ceilingValue = ceil(num); // Round up to the nearest integer\n        sum += pow(ceilingValue, 2); // Square it and add to sum\n    }\n    \n    return sum;\n}\n\n// Example usage:\n"}
{"task_id": "CPP/134", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool check_if_last_char_is_a_letter(string txt) {\n    // If the string is empty, return false.\n    if (txt.empty()) return false;\n    \n    // Get the last character of the string.\n    char lastChar = txt.back();\n    \n    // Check if the last character is an alphabetical letter and not part of a word.\n    bool isLastCharAlphabetical = isalpha(lastChar);\n    bool isNotPartOfWord = (txt.size() == 1) || (txt[txt.size()-2] == ' ');\n    \n    return isLastCharAlphabetical && isNotPartOfWord;\n}\n\n"}
{"task_id": "CPP/135", "generation": "#include <vector>\nusing namespace std;\n\nint can_arrange(vector<int> arr) {\n    // Iterate through the vector starting from the second element.\n    for (size_t i = 1; i < arr.size(); ++i) {\n        // Check if current element is not greater than or equal to its predecessor\n        if (arr[i] < arr[i - 1]) {\n            return static_cast<int>(i); // Return the index of this element.\n        }\n    }\n    // If no such element found, return -1\n    return -1;\n}\n"}
{"task_id": "CPP/136", "generation": "#include <vector>\n#include <climits> // For INT_MIN and INT_MAX\n\nusing namespace std;\n\nvector<int> largest_smallest_integers(vector<int> lst) {\n    int largestNegative = INT_MIN; // Initialize to smallest possible integer value.\n    int smallestPositive = INT_MAX; // Initialize to largest possible integer value.\n\n    for (int num : lst) {\n        if (num < 0 && num > largestNegative) {\n            largestNegative = num;\n        } else if (num > 0 && num < smallestPositive) {\n            smallestPositive = num;\n        }\n    }\n\n    // If no negative numbers were found, set largestNegative to 0.\n    if (largestNegative == INT_MIN) {\n        largestNegative = 0;\n    }\n\n    // If no positive numbers were found, set smallestPositive to 0.\n    if (smallestPositive == INT_MAX) {\n        smallestPositive = 0;\n    }\n\n    return {largestNegative, smallestPositive};\n}\n\n// Example usage:\n"}
{"task_id": "CPP/137", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <boost/any.hpp>\n\nusing namespace std;\n\ndouble parseNumber(const string& str) {\n    // Replace comma with dot if present for proper conversion to double.\n    string temp = str;\n    size_t found = temp.find(',');\n    if (found != string::npos)\n        temp.replace(found, 1, \".\");\n    \n    return stod(temp);\n}\n\nboost::any compare_one(boost::any a, boost::any b) {\n    // Convert both inputs into doubles for comparison.\n    double numA;\n    double numB;\n\n    try {\n        if (a.type() == typeid(int)) {\n            numA = boost::any_cast<int>(a);\n        } else if (a.type() == typeid(double)) {\n            numA = boost::any_cast<double>(a);\n        } else if (a.type() == typeid(string)) {\n            numA = parseNumber(boost::any_cast<string>(a));\n        }\n\n        if (b.type() == typeid(int)) {\n            numB = boost::any_cast<int>(b);\n        } else if (b.type() == typeid(double)) {\n            numB = boost::any_cast<double>(b);\n        } else if (b.type() == typeid(string)) {\n            numB = parseNumber(boost::any_cast<string>(b));\n        }\n    } catch (...) {\n        return \"None\"; // In case of any conversion error, return \"None\".\n    }\n\n    // Compare the numbers.\n    if (numA > numB) {\n        return a;  // Return original type of 'a'.\n    } else if (numB > numA) {\n        return b;  // Return original type of 'b'.\n    } else {\n        return \"None\";  // If equal, return \"None\".\n    }\n}\n\n"}
{"task_id": "CPP/138", "generation": "#include<stdio.h>\n\nbool is_equal_to_sum_even(int n) {\n    // Check if n is less than 8 or odd\n    if (n < 8 || n % 2 != 0) {\n        return false;\n    }\n    // If n >= 8 and even, it can be expressed as the sum of four even numbers\n    return true;\n}\n\n"}
{"task_id": "CPP/139", "generation": "#include <iostream>\nusing namespace std;\n\n// Function to calculate factorial of a number\nlong long factorial(int n) {\n    if (n == 0 || n == 1)\n        return 1;\n    else\n        return n * factorial(n - 1);\n}\n\n// Function to calculate the special factorial as defined\nlong long special_factorial(int n){\n    long long result = 1;\n    for(int i = n; i > 0; --i) {\n        result *= factorial(i); // Multiply by each factorial from n down to 1\n    }\n    return result;\n}\n\n"}
{"task_id": "CPP/140", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring fix_spaces(string text) {\n    string result = \"\";\n    int space_count = 0; // To count the number of consecutive spaces\n\n    for (size_t i = 0; i < text.length(); ++i) {\n        if (text[i] == ' ') {\n            space_count++;\n            continue;\n        }\n\n        if (space_count > 2 && result.back() != '-') {\n            result += '-';\n        } else if (space_count >= 1) {\n            for (int j = 0; j < space_count; ++j) {\n                result += '_';\n            }\n        }\n\n        space_count = 0;\n        result += text[i];\n    }\n\n    // Handle trailing spaces\n    if (space_count > 2 && result.back() != '-') {\n        result += '-';\n    } else if (space_count >= 1) {\n        for (int j = 0; j < space_count; ++j) {\n            result += '_';\n        }\n    }\n\n    return result;\n}\n\n// Function to test the fix_spaces function\nvoid check(string input, string expected_output) {\n    string output = fix_spaces(input);\n    if(output == expected_output) {\n        cout << \"PASS: \" << input << \" -> \" << output << endl;\n    } else {\n        cout << \"FAIL: Expected \" << expected_output << \", but got \" << output << endl;\n    }\n}\n\n"}
{"task_id": "CPP/141", "generation": "#include <iostream>\n#include <string>\n#include <cctype> // for std::isalpha\n\nusing namespace std;\n\nstring file_name_check(string file_name) {\n    int digit_count = 0;\n    size_t dot_position = file_name.find('.');\n    \n    // Check if there is exactly one dot in the filename\n    if (dot_position == string::npos || file_name.find('.', dot_position + 1) != string::npos) {\n        return \"No\";\n    }\n    \n    // Validate the part before the dot\n    if (dot_position == 0 || !isalpha(file_name[0])) { // starts with a letter and not empty\n        return \"No\";\n    }\n    \n    for (size_t i = 0; i < file_name.size(); ++i) {\n        if (isdigit(file_name[i])) {\n            digit_count++;\n            if (digit_count > 3) {\n                return \"No\"; // more than three digits\n            }\n        }\n    }\n\n    string extension = file_name.substr(dot_position + 1);\n    \n    // Validate the part after the dot (extension)\n    if (extension != \"txt\" && extension != \"exe\" && extension != \"dll\") {\n        return \"No\";\n    }\n    \n    return \"Yes\"; // All checks passed\n}\n\n"}
{"task_id": "CPP/142", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint sum_squares(vector<int> lst) {\n    int sum = 0;\n    \n    for (size_t i = 0; i < lst.size(); ++i) {\n        if (i % 3 == 0 && i != 0) { // Check if index is a multiple of 3\n            sum += lst[i] * lst[i]; // Square the element and add to sum\n        } else if (i % 4 == 0) { // Check if index is a multiple of 4 but not 3\n            sum += lst[i] * lst[i] * lst[i]; // Cube the element and add to sum\n        } else {\n            sum += lst[i]; // Add the element as it is\n        }\n    }\n\n    return sum;\n}\n\n"}
{"task_id": "CPP/143", "generation": "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\n// Function to extract words with prime lengths from the sentence\nstring words_in_sentence(string sentence) {\n    string result;\n    int len = sentence.length();\n    \n    // Splitting the sentence into words and checking their length\n    for (int i = 0; i < len;) {\n        if (sentence[i] == ' ') { \n            ++i; // Skip spaces\n            continue;\n        }\n        \n        int start = i;\n        while (i < len && sentence[i] != ' ') ++i; // Find the end of the word\n        \n        string word = sentence.substr(start, i - start);\n        if (is_prime(word.length())) {\n            result += word + \" \";\n        }\n    }\n\n    // Remove trailing space\n    if (!result.empty()) result.pop_back();\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/144", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nbool simplify(string x, string n) {\n    // Parse fractions from strings\n    int numX, denX, numN, denN;\n    \n    size_t slashPos = x.find('/');\n    stringstream ssX(x.substr(0, slashPos));\n    ssX >> numX;\n    stringstream ssDx(x.substr(slashPos + 1));\n    ssDx >> denX;\n\n    slashPos = n.find('/');\n    stringstream ssN(n.substr(0, slashPos));\n    ssN >> numN;\n    stringstream ssDn(n.substr(slashPos + 1));\n    ssDn >> denN;\n\n    // Calculate the product of fractions\n    int numeratorProduct = numX * numN;\n    int denominatorProduct = denX * denN;\n\n    // Simplify the fraction by finding the greatest common divisor (GCD)\n    auto gcd = [](int a, int b) {\n        while (b != 0) {\n            int temp = b;\n            b = a % b;\n            a = temp;\n        }\n        return a;\n    };\n\n    int gcdValue = gcd(numeratorProduct, denominatorProduct);\n\n    // Simplify the fraction\n    numeratorProduct /= gcdValue;\n    denominatorProduct /= gcdValue;\n\n    // Check if it's a whole number (denominator should be 1)\n    return denominatorProduct == 1;\n}\n\n"}
{"task_id": "CPP/145", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // For std::stable_sort\n\nusing namespace std;\n\n// Function to calculate the sum of digits of an integer.\nint sum_of_digits(int num) {\n    int sum = 0;\n    bool negative = num < 0;\n    while (num != 0) {\n        sum += num % 10;\n        num /= 10;\n    }\n    return negative ? -sum : sum; // If the number is negative, make the sum negative.\n}\n\n// Comparator function for std::stable_sort\nbool compare_by_points(const pair<int, int>& a, const pair<int, int>& b) {\n    if (a.first != b.first) {\n        return a.first < b.first;\n    }\n    return a.second < b.second; // Maintain original order when sums are equal.\n}\n\nvector<int> order_by_points(vector<int> nums) {\n    vector<pair<int, int>> indexed_nums;\n\n    // Pair each number with its index and sum of digits\n    for (int i = 0; i < nums.size(); ++i) {\n        indexed_nums.push_back({sum_of_digits(nums[i]), i});\n    }\n\n    // Sort by the sum of digits using a stable sort to maintain original order when sums are equal.\n    stable_sort(indexed_nums.begin(), indexed_nums.end(), compare_by_points);\n\n    vector<int> sorted_nums;\n    for (const auto& p : indexed_nums) {\n        sorted_nums.push_back(nums[p.second]);\n    }\n\n    return sorted_nums;\n}\n\n// Function to check the correctness of the solution\nvoid test() {\n    vector<int> result = order_by_points({1, 11, -1, -11, -12});\n    for (int num : result) cout << num << \" \";\n    cout << endl;\n\n    result = order_by_points({});\n    for (int num : result) cout << num << \" \";\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/146", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nint specialFilter(vector<int> nums) {\n    int count = 0;\n    \n    for (auto num : nums) {\n        // Skip numbers less than or equal to 10\n        if (num <= 10)\n            continue;\n        \n        string strNum = to_string(abs(num)); // Convert number to string and take absolute value to handle negative numbers\n        \n        char firstDigit = strNum[0];\n        char lastDigit = strNum[strNum.length() - 1];\n        \n        int firstInt = firstDigit - '0'; // Convert char digit back to integer\n        int lastInt = lastDigit - '0';\n        \n        // Check if both digits are odd\n        if (firstInt % 2 != 0 && lastInt % 2 != 0) {\n            count++;\n        }\n    }\n    \n    return count;\n}\n\n// Function to test the specialFilter function with given examples\nvoid check() {\n    cout << \"Test Case 1: \" << (specialFilter({15, -73, 14, -15}) == 1 ? \"Passed\" : \"Failed\") << endl;\n    cout << \"Test Case 2: \" << (specialFilter({33, -2, -3, 45, 21, 109}) == 2 ? \"Passed\" : \"Failed\") << endl;\n}\n\n"}
{"task_id": "CPP/147", "generation": "#include<iostream>\n#include<vector>\nusing namespace std;\n\nint get_max_triples(int n){\n    vector<int> a(n);\n    \n    // Generate the array based on the formula a_i = i^2 - i + 1\n    for (int i = 0; i < n; ++i) {\n        a[i] = (i+1)*(i+1) - (i+1) + 1;\n    }\n    \n    int count = 0;\n    \n    // Iterate over all possible triples (i, j, k)\n    for (int i = 0; i < n-2; ++i) {\n        for (int j = i+1; j < n-1; ++j) {\n            for (int k = j+1; k < n; ++k) {\n                if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                    count++;\n                }\n            }\n        }\n    }\n    \n    return count;\n}\n\n// Function to test the solution\nvoid check_solution() {\n    cout << \"Input: n = 5, Output: \" << get_max_triples(5) << endl; // Expected output: 1\n    // Add more tests if necessary\n}\n\n"}
{"task_id": "CPP/148", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> bf(string planet1, string planet2) {\n    // Define an array with the order of the planets from closest to farthest from the Sun.\n    vector<string> planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n    \n    // Find the indices of planet1 and planet2 in the array\n    int index1 = -1, index2 = -1;\n    for (int i = 0; i < planets.size(); ++i) {\n        if (planets[i] == planet1)\n            index1 = i;\n        else if (planets[i] == planet2)\n            index2 = i;\n        \n        // Break the loop once both indices are found\n        if (index1 != -1 && index2 != -1)\n            break;\n    }\n    \n    // If either of the planets is not found, return an empty vector.\n    if (index1 == -1 || index2 == -1) {\n        return {};\n    }\n\n    // Ensure index1 < index2 for simplicity\n    if (index1 > index2) swap(index1, index2);\n\n    // Collect all planets between the two indices and return them in order.\n    vector<string> result;\n    for (int i = index1 + 1; i < index2; ++i) {\n        result.push_back(planets[i]);\n    }\n    \n    return result;\n}\n\n// Function to test the bf function with given examples\nvoid check() {\n    auto res1 = bf(\"Jupiter\", \"Neptune\");\n    for (const auto& planet : res1)\n        cout << planet << \" \";\n    cout << endl;\n\n    auto res2 = bf(\"Earth\", \"Mercury\");\n    for (const auto& planet : res2)\n        cout << planet << \" \";\n    cout << endl;\n\n    auto res3 = bf(\"Mercury\", \"Uranus\");\n    for (const auto& planet : res3)\n        cout << planet << \" \";\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/149", "generation": "#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to sort and filter a vector of strings based on given conditions.\nvector<string> sorted_list_sum(vector<string> lst) {\n    // Remove elements with odd lengths\n    lst.erase(remove_if(lst.begin(), lst.end(), [](const string& s){ return s.size() % 2 != 0; }), lst.end());\n    \n    // Sort the vector by length, then alphabetically for strings of equal length.\n    sort(lst.begin(), lst.end(), [](const string& a, const string& b) {\n        if (a.length() == b.length()) {\n            return a < b;\n        }\n        return a.length() < b.length();\n    });\n\n    return lst;\n}\n\n// Example usage\n"}
{"task_id": "CPP/150", "generation": "#include <iostream>\nusing namespace std;\n\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    if (n == 2 || n == 3) return true; // 2 and 3 are prime numbers.\n    if (n % 2 == 0 || n % 3 == 0) return false; // Eliminate multiples of 2 and 3.\n\n    for(int i = 5; i * i <= n; i += 6) {\n        if(n % i == 0 || n % (i + 2) == 0)\n            return false;\n    }\n    return true;\n}\n\nint x_or_y(int n, int x, int y){\n    if(is_prime(n)) {\n        return x;\n    } else {\n        return y;\n    }\n}\n\n// Function to test the correctness of the solution\nvoid check() {\n    cout << \"x_or_y(7, 34, 12) == \" << x_or_y(7, 34, 12) << endl; // Should output 34\n    cout << \"x_or_y(15, 8, 5) == \" << x_or_y(15, 8, 5) << endl;   // Should output 5\n}\n\n"}
{"task_id": "CPP/151", "generation": "#include <vector>\nusing namespace std;\n\nlong long double_the_difference(vector<float> lst) {\n    long long sum = 0;\n    \n    for (float num : lst) {\n        // Check if number is positive, an integer and odd.\n        if (num > 0 && floor(num) == num && static_cast<int>(num) % 2 != 0) {\n            int n = static_cast<int>(num);\n            sum += n * n; // Add the square of the number to the sum\n        }\n    }\n\n    return sum;\n}\n"}
{"task_id": "CPP/152", "generation": "#include <iostream>\n#include <vector>\n#include <cmath> // For std::abs\n\nusing namespace std;\n\nvector<int> compare(vector<int> game, vector<int> guess){\n    vector<int> result;\n    \n    // Iterate through the vectors and calculate differences.\n    for(size_t i = 0; i < game.size(); ++i) {\n        int diff = abs(game[i] - guess[i]); // Calculate absolute difference\n        result.push_back(diff);             // Add to result vector\n    }\n    \n    return result;\n}\n\n// Function to test the compare function with given data points.\nvoid check() {\n    vector<int> game1 = {1,2,3,4,5,1};\n    vector<int> guess1 = {1,2,3,4,2,-2};\n    vector<int> expected1 = {0,0,0,0,3,3};\n    \n    vector<int> game2 = {0,5,0,0,0,4};\n    vector<int> guess2 = {4,1,1,0,0,-2};\n    vector<int> expected2 = {4,4,1,0,0,6};\n\n    assert(compare(game1, guess1) == expected1);\n    assert(compare(game2, guess2) == expected2);\n\n    cout << \"All tests passed successfully.\" << endl;\n}\n\n"}
{"task_id": "CPP/153", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to calculate the strength of an extension.\nint CalculateStrength(const string& extension) {\n    int uppercase = 0;\n    int lowercase = 0;\n    \n    for (char c : extension) {\n        if (isupper(c)) uppercase++;\n        else if (islower(c)) lowercase++;\n    }\n    \n    return uppercase - lowercase;\n}\n\nstring Strongest_Extension(string class_name, vector<string> extensions){\n    string strongest_extension = \"\";\n    int max_strength = INT_MIN; // Initialize with the smallest possible integer value.\n    \n    for (const auto& extension : extensions) {\n        int strength = CalculateStrength(extension);\n        \n        if (strength > max_strength || (strength == max_strength && strongest_extension.empty())) {\n            max_strength = strength;\n            strongest_extension = extension;\n        }\n    }\n    \n    return class_name + \".\" + strongest_extension;\n}\n\n"}
{"task_id": "CPP/154", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool cycpattern_check(string a, string b) {\n    // Concatenate 'a' with itself to handle rotations.\n    string doubled_a = a + a;\n    \n    // Check if 'b' is a substring of the concatenated string.\n    return doubled_a.find(b) != string::npos;\n}\n\n"}
{"task_id": "CPP/155", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<int> even_odd_count(int num) {\n    // Convert number to its absolute value and then to string for easy iteration over digits\n    string str_num = to_string(abs(num));\n    \n    int even_count = 0;\n    int odd_count = 0;\n    \n    // Iterate through each character in the string\n    for (char& c : str_num) {\n        int digit = c - '0'; // Convert char to integer\n        \n        if (digit % 2 == 0) {\n            even_count++;\n        } else {\n            odd_count++;\n        }\n    }\n    \n    return {even_count, odd_count};\n}\n\n// Function to test the solution\nvoid check() {\n    vector<int> result1 = even_odd_count(-12);\n    cout << \"even_odd_count(-12): {\" << result1[0] << \", \" << result1[1] << \"}\" << endl;\n    \n    vector<int> result2 = even_odd_count(123);\n    cout << \"even_odd_count(123): {\" << result2[0] << \", \" << result2[1] << \"}\" << endl;\n}\n\n"}
{"task_id": "CPP/156", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring int_to_mini_roman(int number) {\n    // Define vectors for Roman numeral symbols and their values.\n    vector<string> thousands[] = {\"\", \"m\", \"mm\", \"mmm\"};\n    vector<string> hundreds[]  = {\"\", \"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"};\n    vector<string> tens[]      = {\"\", \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\"};\n    vector<string> ones[]      = {\"\", \"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\", \"ix\"};\n\n    // Construct the Roman numeral by combining parts for thousands, hundreds, tens, and ones.\n    string roman;\n    roman += thousands[number / 1000][number % 1000 >= 1000 ? 3 : number / 1000];\n    roman += hundreds[(number % 1000) / 100][(number % 100) >= 100 ? 9 : (number % 1000) / 100];\n    roman += tens[(number % 100) / 10][(number % 10) >= 10 ? 9 : (number % 100) / 10];\n    roman += ones[number % 10][number % 10];\n\n    return roman;\n}\n\n"}
{"task_id": "CPP/157", "generation": "#include<stdio.h>\n#include<math.h>\n\nbool right_angle_triangle(float a, float b, float c){\n    // First, sort the sides so that c is the longest side.\n    if (a > c) std::swap(a, c);\n    if (b > c) std::swap(b, c);\n\n    // Check the Pythagorean theorem: a^2 + b^2 should equal c^2\n    return fabs((a*a + b*b) - (c*c)) < 1e-6; // Using a small threshold to account for floating point precision errors.\n}\n\n"}
{"task_id": "CPP/158", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <set> // For storing unique characters\n\nusing namespace std;\n\n// Function to find the string with maximum number of unique characters.\nstring find_max(vector<string> words) {\n    string maxUniqueWord = \"\";\n    size_t maxUniqueCount = 0;\n    \n    for (const auto& word : words) {\n        set<char> uniqueChars(word.begin(), word.end()); // Using a set to store unique characters\n        if (uniqueChars.size() > maxUniqueCount || \n            (uniqueChars.size() == maxUniqueCount && word < maxUniqueWord)) {\n            maxUniqueCount = uniqueChars.size();\n            maxUniqueWord = word;\n        }\n    }\n    \n    return maxUniqueWord;\n}\n\n// Function to check the correctness of the solution\nvoid check() {\n    assert(find_max({\"name\", \"of\", \"string\"}) == \"string\");\n    assert(find_max({\"name\", \"enam\", \"game\"}) == \"enam\");\n    assert(find_max({\"aaaaaaa\", \"bb\" ,\"cc\"}) == \"aaaaaaa\");\n    \n    cout << \"All test cases passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/159", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> eat(int number, int need, int remaining) {\n    // Calculate the total number of carrots eaten after trying to eat 'need' more.\n    int totalEaten = number + min(need, remaining);\n    \n    // Calculate the number of remaining carrots after eating as many as possible.\n    int leftOver = max(0, remaining - need);\n\n    return {totalEaten, leftOver};\n}\n"}
{"task_id": "CPP/160", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nint do_algebra(vector<string> operato, vector<int> operand) {\n    int result = operand[0]; // Start with the first operand\n\n    for (size_t i = 0; i < operato.size(); ++i) {\n        if (operato[i] == \"+\") {\n            result += operand[i + 1];\n        } else if (operato[i] == \"-\") {\n            result -= operand[i + 1];\n        } else if (operato[i] == \"*\") {\n            result *= operand[i + 1];\n        } else if (operato[i] == \"//\") {\n            result /= operand[i + 1]; // Integer division\n        } else if (operato[i] == \"**\") {\n            result = pow(result, operand[i + 1]); // Exponentiation using std::pow\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/161", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool containsLetter(const string& s) {\n    for(char c : s) {\n        if(isalpha(c)) return true;\n    }\n    return false;\n}\n\nchar reverseCase(char c) {\n    if(islower(c)) return toupper(c);\n    else if(isupper(c)) return tolower(c);\n    return c;\n}\n\nstring solve(string s){\n    // Check if the string contains any letters\n    bool hasLetters = containsLetter(s);\n\n    if(!hasLetters) {\n        // If no letters, reverse the entire string and return it\n        reverse(s.begin(), s.end());\n        return s;\n    }\n\n    // If there are letters, change their case accordingly\n    for(char& c : s) {\n        if(isalpha(c)) c = reverseCase(c);\n    }\n    \n    return s;\n}\n\n"}
{"task_id": "CPP/162", "generation": "#include <iostream>\n#include <string>\n#include <openssl/md5.h>\n\nusing namespace std;\n\nstring string_to_md5(string text) {\n    if (text.empty()) return \"None\";\n\n    unsigned char digest[MD5_DIGEST_LENGTH];\n    MD5((unsigned char*)text.c_str(), text.length(), (unsigned char*)&digest);    \n\n    char mdString[33];\n    for(int i = 0; i < 16; ++i)\n        sprintf(&mdString[i*2], \"%02x\", (unsigned int)digest[i]);\n\n    return string(mdString);\n}\n\n"}
{"task_id": "CPP/163", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // For std::min and std::max\n\nusing namespace std;\n\nvector<int> generate_integers(int a, int b) {\n    vector<int> evenDigits = {0, 2, 4, 6, 8}; // All possible even digits\n    vector<int> result;\n    \n    // Ensure the range is from min to max\n    int start = std::min(a, b);\n    int end = std::max(a, b);\n\n    for (int digit : evenDigits) {\n        if (digit >= start && digit <= end) {\n            result.push_back(digit);\n        }\n    }\n\n    return result;\n}\n\n// Function to print the vector\nvoid printVector(const vector<int>& vec) {\n    cout << \"{\";\n    for(size_t i = 0; i < vec.size(); ++i) {\n        if (i != 0) cout << \", \";\n        cout << vec[i];\n    }\n    cout << \"}\" << endl;\n}\n\n"}
{"task_id": "CPP/0", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // For std::sort\n\nusing namespace std;\n\nbool has_close_elements(vector<float> numbers, float threshold) {\n    // First, sort the vector to make sure elements are in ascending order.\n    sort(numbers.begin(), numbers.end());\n    \n    // Iterate through the sorted list and check for any two consecutive elements\n    // that have a difference less than the given threshold.\n    for (size_t i = 0; i < numbers.size() - 1; ++i) {\n        if (numbers[i + 1] - numbers[i] < threshold) {\n            return true;\n        }\n    }\n    \n    // If no such pair is found, return false\n    return false;\n}\n\n// Function to test the has_close_elements function with given data points.\nvoid check() {\n    cout << boolalpha; // Print boolean values as 'true' or 'false'\n    cout << \"Test 1: \" << has_close_elements({1.0, 2.0, 3.0}, 0.5) << endl;\n    cout << \"Expected: false\" << endl;\n    \n    cout << \"Test 2: \" << has_close_elements({1.0, 2.8, 3.0, 4.0, 5.0, 2.0}, 0.3) << endl;\n    cout << \"Expected: true\" << endl;\n}\n\n"}
{"task_id": "CPP/1", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> separate_paren_groups(string paren_string){\n    vector<string> result;\n    int balance = 0; // To keep track of open parentheses\n    string current_group = \"\"; // Current group being processed\n\n    for (char c : paren_string) {\n        if (c == '(' || c == ')') { // Ignore spaces and only process parentheses\n            current_group += c; // Add the character to the current group\n            balance += (c == '(' ? 1 : -1); // Update balance based on the type of parenthesis\n\n            if (balance == 0) { // When balance is zero, a complete group has been found\n                result.push_back(current_group);\n                current_group = \"\"; // Reset for next group\n            }\n        }\n    }\n\n    return result;\n}\n\n// Function to test the solution with given examples\nvoid check() {\n    vector<string> res1 = separate_paren_groups(\"( ) (( )) (( )( ))\");\n    assert((res1 == vector<string>{\"()\", \"(())\", \"(()())\"}));\n\n    cout << \"All tests passed successfully.\" << endl;\n}\n\n"}
{"task_id": "CPP/2", "generation": "#include<stdio.h>\n#include<math.h>\n\nfloat truncate_number(float number){\n    float intPart;\n    // Extracting the integer part using modf function which also returns the decimal part.\n    float decPart = modf(number, &intPart);\n    \n    return decPart;\n}\n\n// Function to test the correctness of the truncate_number function\nvoid check() {\n    printf(\"Testing with 3.5: Expected 0.5, Got %.1f\\n\", truncate_number(3.5));\n    printf(\"Testing with 4.75: Expected 0.75, Got %.2f\\n\", truncate_number(4.75));\n    printf(\"Testing with 8.0: Expected 0.0, Got %.1f\\n\", truncate_number(8.0));\n}\n\n"}
{"task_id": "CPP/3", "generation": "#include <vector>\nusing namespace std;\n\nbool below_zero(vector<int> operations) {\n    int balance = 0; // Start with a zero balance\n\n    for (int op : operations) { // Iterate through each operation\n        balance += op; // Update the balance based on the current operation\n        \n        if (balance < 0) { // Check if balance falls below zero\n            return true;\n        }\n    }\n\n    return false; // If no point in time the balance was negative, return false\n}\n"}
{"task_id": "CPP/4", "generation": "#include <iostream>\n#include <vector>\n#include <numeric> // for std::accumulate\n#include <cmath>   // for std::abs\n\nusing namespace std;\n\nfloat mean_absolute_deviation(vector<float> numbers) {\n    if (numbers.empty()) return 0.0f; // Handle empty vector case\n    \n    float sum = accumulate(numbers.begin(), numbers.end(), 0.0f);\n    float mean = sum / numbers.size();\n    \n    float mad_sum = 0.0f;\n    for (float num : numbers) {\n        mad_sum += abs(num - mean); // Calculate the absolute difference and add it to the total\n    }\n    \n    return mad_sum / numbers.size(); // Average of all absolute differences\n}\n\n"}
{"task_id": "CPP/5", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvector<int> intersperse(vector<int> numbers, int delimiter) {\n    vector<int> result;\n    \n    // If the input vector is empty or has only one element, return it as is.\n    if (numbers.size() <= 1) {\n        return numbers;\n    }\n    \n    for(size_t i = 0; i < numbers.size(); ++i) {\n        // Add current number to the result\n        result.push_back(numbers[i]);\n        \n        // If this isn't the last element, add delimiter after it.\n        if (i != numbers.size() - 1) {\n            result.push_back(delimiter);\n        }\n    }\n\n    return result;\n}\n\n// Function to print vector for demonstration purposes\nvoid printVector(const vector<int>& vec) {\n    cout << \"{\";\n    for(size_t i = 0; i < vec.size(); ++i) {\n        if (i != 0) cout << \", \";\n        cout << vec[i];\n    }\n    cout << \"}\" << endl;\n}\n\n"}
{"task_id": "CPP/6", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<int> parse_nested_parens(string paren_string) {\n    vector<int> max_depths;\n    int current_depth = 0, max_depth = 0;\n    \n    for (char c : paren_string) {\n        if (c == '(') {\n            // Increase depth when an opening parenthesis is found\n            ++current_depth;\n            // Update the maximum depth encountered so far in this group\n            if (current_depth > max_depth) {\n                max_depth = current_depth;\n            }\n        } else if (c == ')') {\n            // Decrease depth when a closing parenthesis is found\n            --current_depth;\n        } else if (c == ' ') {\n            // When we encounter a space, it means the end of one group and start of another.\n            // Add the max depth of this group to our result vector and reset counters for next group.\n            if (max_depth > 0) { // Only add non-empty groups\n                max_depths.push_back(max_depth);\n            }\n            current_depth = 0;\n            max_depth = 0;\n        }\n    }\n\n    // Add the last group's depth if it exists\n    if (current_depth != 0) {\n        max_depths.push_back(current_depth); // In this case, current_depth is also the max_depth for the last group.\n    }\n\n    return max_depths;\n}\n\n"}
{"task_id": "CPP/7", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> filter_by_substring(vector<string> strings, string substring) {\n    vector<string> filteredStrings; // This will hold our result\n\n    for (const auto& str : strings) { // Iterate through each string in the input vector\n        if (str.find(substring) != string::npos) { // Check if the substring is found in the current string\n            filteredStrings.push_back(str); // If yes, add it to the result vector\n        }\n    }\n\n    return filteredStrings; // Return the result vector containing only strings that have the substring\n}\n\n// Function to test our filter_by_substring function with given examples\nvoid check() {\n    auto result1 = filter_by_substring({}, \"a\");\n    cout << \"{\";\n    for (const auto& str : result1) {\n        cout << \"\\\"\" << str << \"\\\", \";\n    }\n    cout << \"}\\n\";\n\n    auto result2 = filter_by_substring({\"abc\", \"bacd\", \"cde\", \"vector\"}, \"a\");\n    cout << \"{\";\n    for (const auto& str : result2) {\n        cout << \"\\\"\" << str << \"\\\", \";\n    }\n    cout << \"}\\n\";\n}\n\n"}
{"task_id": "CPP/8", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// Function to calculate sum and product of elements in a vector.\npair<int, int> sum_product(vector<int> numbers) {\n    // Initialize sum and product with default values for empty vectors.\n    int sum = 0;\n    int product = 1; // Product starts at 1 because multiplying by 1 doesn't change the value.\n\n    // Loop through each number in the vector to calculate sum and product.\n    for (int num : numbers) {\n        sum += num;\n        product *= num;\n    }\n\n    return make_pair(sum, product);\n}\n\n// Function to test the correctness of the solution with given data points.\nvoid check() {\n    auto result = sum_product({});\n    cout << \"(\" << result.first << \", \" << result.second << \")\" << endl; // Expected: (0, 1)\n\n    result = sum_product({1, 2, 3, 4});\n    cout << \"(\" << result.first << \", \" << result.second << \")\" << endl; // Expected: (10, 24)\n}\n\n"}
{"task_id": "CPP/9", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> rolling_max(vector<int> numbers) {\n    // Check if the input vector is empty to avoid undefined behavior.\n    if (numbers.empty()) return {};\n\n    vector<int> result;\n    int currentMax = numbers[0];  // Initialize with the first element of the sequence.\n\n    for (int num : numbers) {\n        if (num > currentMax) {\n            currentMax = num;  // Update currentMax when a new maximum is found.\n        }\n        result.push_back(currentMax);  // Add the current maximum to the result vector.\n    }\n\n    return result;\n}\n\n// Function to test the rolling_max function\nvoid test_rolling_max() {\n    vector<int> input = {1, 2, 3, 2, 3, 4, 2};\n    vector<int> expected_output = {1, 2, 3, 3, 3, 4, 4};\n    vector<int> output = rolling_max(input);\n\n    if (output == expected_output) {\n        cout << \"Test passed.\" << endl;\n    } else {\n        cout << \"Test failed.\" << endl;\n    }\n}\n\n"}
{"task_id": "CPP/10", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_palindrome(string str) {\n    // Test if given string is a palindrome \n    string s(str.rbegin(), str.rend());\n    return s == str;\n}\n\nstring make_palindrome(string str) {\n    /*\n    Find the shortest palindrome that begins with a supplied string. \n    Algorithm idea is simple: - Find the longest postfix of supplied string that is a palindrome. \n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome(\"\") \n    \"\" \n    >>> make_palindrome(\"cat\") \n    \"catac\" \n    >>> make_palindrome(\"cata\") \n    \"catac\" \n    */\n    \n    if (str.empty()) return str; // If string is empty, return it as is\n    \n    int n = str.length();\n    for(int i = 0; i < n; ++i) {\n        if(is_palindrome(str.substr(i))) { // Check from each position to the end\n            // Append reverse of prefix before palindromic suffix\n            string prefix = str.substr(0, i);\n            return str + string(prefix.rbegin(), prefix.rend());\n        }\n    }\n    \n    // If no palindrome is found (which shouldn't happen), just append the whole reversed string\n    return str + string(str.rbegin(), str.rend());\n}\n\n"}
{"task_id": "CPP/11", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring string_xor(string a, string b){\n    // Ensure both strings are of equal length.\n    if(a.length() != b.length()){\n        return \"\";  // Return an empty string or handle error as needed.\n    }\n\n    string result = \"\";\n    \n    for(size_t i = 0; i < a.length(); ++i) {\n        // Perform XOR on each pair of characters and append to the result\n        if(a[i] == b[i]) {\n            result += '0';  // If both are same, XOR is 0.\n        } else {\n            result += '1';  // If different, XOR is 1.\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/12", "generation": "#include <vector>\n#include <string>\nusing namespace std;\n\nstring longest(vector<string> strings) {\n    if (strings.empty()) { // Check if the vector is empty\n        return \"\"; // Return an empty string to represent None as C++ does not have a direct equivalent of Python's None.\n    }\n\n    string longestString = strings[0]; // Initialize with the first element\n\n    for (const auto& str : strings) {\n        if (str.length() > longestString.length()) {\n            longestString = str;\n        }\n    }\n\n    return longestString;\n}\n"}
{"task_id": "CPP/13", "generation": "#include <stdio.h>\n\nint greatest_common_divisor(int a, int b){\n    // Ensure that both a and b are positive for simplicity.\n    a = (a > 0) ? a : -a;\n    b = (b > 0) ? b : -b;\n\n    while(b != 0){\n        int temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a; // The GCD is now in 'a'\n}\n\n"}
{"task_id": "CPP/14", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> all_prefixes(string str) {\n    vector<string> prefixes;\n    for (size_t i = 1; i <= str.size(); ++i) {\n        // Add substring from the beginning to current position as a prefix\n        prefixes.push_back(str.substr(0, i));\n    }\n    return prefixes;\n}\n\n// Example usage\n"}
{"task_id": "CPP/15", "generation": "#include <iostream>\n#include <sstream> // For std::ostringstream\n\nusing namespace std;\n\nstring string_sequence(int n) {\n    ostringstream oss;  // Create an output string stream\n    for (int i = 0; i <= n; ++i) {\n        if (i != 0) {   // Avoid adding space before the first number\n            oss << \" \";\n        }\n        oss << i;\n    }\n    return oss.str();   // Convert the ostringstream to a string and return it\n}\n\n// Example usage:\n"}
{"task_id": "CPP/16", "generation": "#include <iostream>\n#include <set>\n#include <string>\n#include <cctype> // for std::tolower\n\nusing namespace std;\n\nint count_distinct_characters(string str) {\n    set<char> distinctChars;\n    \n    // Convert each character to lowercase and insert into the set.\n    for (char c : str) {\n        distinctChars.insert(tolower(c));\n    }\n    \n    // The size of the set is the number of distinct characters\n    return distinctChars.size();\n}\n\n// Function to test the solution with given examples\nvoid check() {\n    cout << \"Test 1: \" << count_distinct_characters(\"xyzXYZ\") << endl; // Expected output: 3\n    cout << \"Test 2: \" << count_distinct_characters(\"Jerry\") << endl;   // Expected output: 4\n}\n\n"}
{"task_id": "CPP/17", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<int> parse_music(string music_string) {\n    vector<int> beats;\n    for (size_t i = 0; i < music_string.length(); ) {\n        if (music_string.substr(i, 2) == \"o|\") { // Check for half note\n            beats.push_back(2);\n            i += 2; // Skip the next character as it's part of this note\n        } else if (music_string[i] == 'o') { // Check for whole note\n            beats.push_back(4);\n            ++i;\n        } else if (music_string.substr(i, 2) == \".|\") { // Check for quarter note\n            beats.push_back(1);\n            i += 2; // Skip the next character as it's part of this note\n        } else {\n            ++i; // Move to the next character in case of unexpected input or spaces\n        }\n    }\n    return beats;\n}\n\n"}
{"task_id": "CPP/18", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint how_many_times(string str, string substring) {\n    int count = 0;\n    // Lengths of strings\n    size_t len_str = str.length();\n    size_t len_sub = substring.length();\n\n    // Iterate through the main string\n    for (size_t i = 0; i <= len_str - len_sub; ++i) {\n        // Check if the current segment matches the substring\n        if (str.substr(i, len_sub) == substring)\n            count++;\n    }\n\n    return count;\n}\n\n"}
{"task_id": "CPP/19", "generation": "#include <iostream>\n#include <string>\n#include <vector>\n#include <map>\n#include <sstream>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to sort numbers from \"zero\" to \"nine\"\nstring sort_numbers(string numbers) {\n    // Mapping of number words to their integer values\n    map<string, int> num_map = {\n        {\"zero\", 0}, {\"one\", 1}, {\"two\", 2}, {\"three\", 3},\n        {\"four\", 4}, {\"five\", 5}, {\"six\", 6}, {\"seven\", 7},\n        {\"eight\", 8}, {\"nine\", 9}\n    };\n\n    // Mapping of integer values back to number words\n    map<int, string> reverse_map = {\n        {0, \"zero\"}, {1, \"one\"}, {2, \"two\"}, {3, \"three\"},\n        {4, \"four\"}, {5, \"five\"}, {6, \"six\"}, {7, \"seven\"},\n        {8, \"eight\"}, {9, \"nine\"}\n    };\n\n    // Split the input string into words\n    istringstream iss(numbers);\n    vector<string> num_words;\n    string word;\n    while (iss >> word) {\n        num_words.push_back(word);\n    }\n\n    // Sort based on their integer values\n    sort(num_words.begin(), num_words.end(),\n         [&num_map](const string& a, const string& b) { return num_map[a] < num_map[b]; });\n\n    // Convert back to words and form the output string\n    ostringstream oss;\n    for (size_t i = 0; i < num_words.size(); ++i) {\n        if (i > 0) {\n            oss << \" \";\n        }\n        int value = num_map[num_words[i]];\n        oss << reverse_map[value];\n    }\n\n    return oss.str();\n}\n\n"}
{"task_id": "CPP/20", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // for sort function\n\nusing namespace std;\n\npair<float, float> find_closest_elements(vector<float> numbers) {\n    // Sort the vector to make it easier to compare adjacent elements.\n    sort(numbers.begin(), numbers.end());\n\n    pair<float, float> closest_pair;\n    float min_diff = numeric_limits<float>::max();  // Initialize with maximum possible value\n\n    // Iterate through the sorted list comparing each element with its next neighbor\n    for (size_t i = 0; i < numbers.size() - 1; ++i) {\n        float diff = numbers[i + 1] - numbers[i];\n        if (diff < min_diff) {\n            min_diff = diff;\n            closest_pair = make_pair(numbers[i], numbers[i + 1]);\n        }\n    }\n\n    return closest_pair;\n}\n\n"}
{"task_id": "CPP/21", "generation": "#include <vector>\n#include <algorithm> // For std::min_element and std::max_element\n\nusing namespace std;\n\nvector<float> rescale_to_unit(vector<float> numbers) {\n    float min_val = *std::min_element(numbers.begin(), numbers.end());\n    float max_val = *std::max_element(numbers.begin(), numbers.end());\n\n    vector<float> result;\n    for (float num : numbers) {\n        // Apply the linear transformation\n        float scaled_value = (num - min_val) / (max_val - min_val);\n        result.push_back(scaled_value);\n    }\n\n    return result;\n}\n\n// Example usage:\n"}
{"task_id": "CPP/22", "generation": "#include <iostream>\n#include <vector>\n#include <list>\n#include <boost/any.hpp>\n\ntypedef std::list<boost::any> list_any;\n\nstd::vector<int> filter_integers(list_any values) {\n    std::vector<int> integers;\n    \n    for (const auto& value : values) {\n        if (value.type() == typeid(int)) { // Check if the type is int\n            integers.push_back(boost::any_cast<int>(value)); // Cast and add to vector\n        }\n    }\n\n    return integers;\n}\n\n"}
{"task_id": "CPP/23", "generation": "#include <string>\nusing namespace std;\n\nint strlen(string str) {\n    // Use size() method to get the length of the string.\n    return str.size();\n}\n\n// Example usage:\n/*\n"}
{"task_id": "CPP/24", "generation": "#include<stdio.h>\n\nint largest_divisor(int n) {\n    // Start from n/2 because that would be the largest possible divisor smaller than n.\n    for (int i = n / 2; i >= 1; --i) {\n        if (n % i == 0) {\n            return i;\n        }\n    }\n    // If no divisor is found, which shouldn't happen as every number is divisible by itself and 1,\n    // we return -1 to indicate an error or special case.\n    return -1;\n}\n\n"}
{"task_id": "CPP/25", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> factorize(int n) {\n    vector<int> factors;\n    \n    // Divide by 2 until odd\n    while (n % 2 == 0) {\n        factors.push_back(2);\n        n /= 2;\n    }\n    \n    // Check for odd factors from 3 onwards\n    for (int i = 3; i * i <= n; i += 2) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n    \n    // If n is a prime number greater than 2\n    if (n > 2) {\n        factors.push_back(n);\n    }\n\n    return factors;\n}\n\n// Function to test the factorize function with given examples\nvoid check() {\n    vector<int> result;\n\n    result = factorize(8);\n    cout << \"Factorization of 8: \";\n    for(int i : result)\n        cout << i << \" \";\n    cout << endl;\n\n    result = factorize(25);\n    cout << \"Factorization of 25: \";\n    for(int i : result)\n        cout << i << \" \";\n    cout << endl;\n\n    result = factorize(70);\n    cout << \"Factorization of 70: \";\n    for(int i : result)\n        cout << i << \" \";\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/26", "generation": "#include <iostream>\n#include <vector>\n#include <unordered_set>\n\nusing namespace std;\n\nvector<int> remove_duplicates(vector<int> numbers) {\n    unordered_set<int> seen;\n    vector<int> result;\n\n    for (int num : numbers) {\n        // If it's the first time we see this number, add it to both sets\n        if (seen.find(num) == seen.end()) {\n            seen.insert(num);\n            result.push_back(num);\n        }\n    }\n\n    return result;\n}\n\n// Function to print vector elements for testing purposes\nvoid print_vector(const vector<int>& vec) {\n    cout << \"{\";\n    for(size_t i = 0; i < vec.size(); ++i) {\n        cout << vec[i];\n        if (i != vec.size() - 1) cout << \", \";\n    }\n    cout << \"}\" << endl;\n}\n\n"}
{"task_id": "CPP/27", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring flip_case(string str) {\n    for (size_t i = 0; i < str.length(); ++i) { // Iterate through each character of the string.\n        if (isupper(str[i])) { // Check if the current character is uppercase.\n            str[i] = tolower(str[i]); // Convert it to lowercase.\n        } else if (islower(str[i])) { // Check if the current character is lowercase.\n            str[i] = toupper(str[i]); // Convert it to uppercase.\n        }\n    }\n    return str; // Return the modified string.\n}\n\n"}
{"task_id": "CPP/28", "generation": "#include <vector>\n#include <string>\nusing namespace std;\n\nstring concatenate(vector<string> strings) {\n    // Initialize an empty string to hold the concatenated result.\n    string result = \"\";\n    \n    // Iterate through each string in the vector and append it to the result.\n    for (const auto& str : strings) {\n        result += str;\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/29", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> filter_by_prefix(vector<string> strings, string prefix) {\n    vector<string> filtered_strings;\n    \n    for (const auto& str : strings) {\n        if (str.find(prefix) == 0) { // Check if the string starts with the given prefix\n            filtered_strings.push_back(str);\n        }\n    }\n\n    return filtered_strings;\n}\n\n// Function to print the contents of a vector<string>\nvoid print_vector(const vector<string>& vec) {\n    for (const auto& str : vec) {\n        cout << \"\\\"\" << str << \"\\\" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/30", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvector<float> get_positive(vector<float> l) {\n    // Create an empty vector to store positive numbers.\n    vector<float> result;\n    \n    // Iterate through each element in the input vector.\n    for (float num : l) {\n        // If the number is greater than zero, add it to the result vector.\n        if (num > 0.0f) {\n            result.push_back(num);\n        }\n    }\n    \n    return result;\n}\n\n// Function to test the get_positive function with sample data\nvoid check() {\n    vector<float> test1 = {-1.0f, 2.0f, -4.0f, 5.0f, 6.0f};\n    vector<float> expected1 = {2.0f, 5.0f, 6.0f};\n    \n    vector<float> result1 = get_positive(test1);\n    assert(result1 == expected1);\n\n    vector<float> test2 = {5.0f, 3.0f, -5.0f, 2.0f, -3.0f, 3.0f, 9.0f, 0.0f, 123.0f, 1.0f, -10.0f};\n    vector<float> expected2 = {5.0f, 3.0f, 2.0f, 3.0f, 9.0f, 123.0f, 1.0f};\n\n    vector<float> result2 = get_positive(test2);\n    assert(result2 == expected2);\n\n    cout << \"All tests passed successfully.\" << endl;\n}\n\n"}
{"task_id": "CPP/31", "generation": "#include <iostream>\nusing namespace std;\n\nbool is_prime(long long n) {\n    // Handle edge cases\n    if (n <= 1) return false;\n    if (n == 2 || n == 3) return true;\n    \n    // Check divisibility by 2 and 3\n    if (n % 2 == 0 || n % 3 == 0) return false;\n\n    // Only check up to the square root of n for efficiency.\n    for(long long i = 5; i * i <= n; i += 6) {\n        if(n % i == 0 || n % (i + 2) == 0)\n            return false;\n    }\n    \n    return true;\n}\n\n"}
{"task_id": "CPP/32", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\ndouble poly(vector<double> xs, double x){\n    /* \n    Evaluates polynomial with coefficients xs at point x. return xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n \n    */\n    double sum=0;\n    int i;\n    for (i=0;i<xs.size();i++)\n    {\n        sum+=xs[i]*pow(x,i);\n    }\n    return sum;\n}\n\ndouble find_zero(vector<double> xs){\n    /*\n    xs are coefficients of a polynomial. find_zero finds x such that poly(x) = 0. \n    It returns only one zero point, even if there are many.\n    Moreover, find_zero only takes list xs having an even number of coefficients and the largest non-zero coefficient as it guarantees a solution.\n    */\n    \n    // Define initial interval\n    double left = -1000; // arbitrary large negative value\n    double right = 1000; // arbitrary large positive value\n    \n    // Check for sign change in the interval, adjust if necessary\n    while (poly(xs, left) * poly(xs, right) > 0){\n        left *= 2;\n        right *= 2;\n    }\n    \n    double mid;\n    const int max_iter = 100; // Maximum number of iterations to prevent infinite loop\n    for(int i=0; i<max_iter; ++i)\n    {\n        mid = (left + right) / 2.0;\n        \n        if(poly(xs, mid) == 0 || (right - left)/2 < 1e-7){\n            return mid;\n        }\n        \n        // Narrow down the interval\n        if(poly(xs, left) * poly(xs, mid) < 0)\n            right = mid;\n        else\n            left = mid;\n    }\n\n    return mid; // Return midpoint of last interval as best approximation\n}\n\n"}
{"task_id": "CPP/33", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // For std::sort\n\nusing namespace std;\n\nvector<int> sort_third(vector<int> l) {\n    vector<int> to_sort;\n    \n    // Extract elements from indices divisible by three (0-based index)\n    for(size_t i = 2; i < l.size(); i += 3) {\n        to_sort.push_back(l[i]);\n    }\n    \n    // Sort the extracted elements\n    sort(to_sort.begin(), to_sort.end());\n    \n    // Replace original elements with sorted ones\n    size_t j = 0;\n    for(size_t i = 2; i < l.size() && j < to_sort.size(); i += 3, ++j) {\n        l[i] = to_sort[j];\n    }\n    \n    return l;\n}\n\n// Function to test the sort_third function with given examples\nvoid check_function() {\n    vector<int> result1 = sort_third({1, 2, 3});\n    for(int num : result1) cout << num << \" \";\n    cout << endl;\n\n    vector<int> result2 = sort_third({5, 6, 3, 4, 8, 9, 2});\n    for(int num : result2) cout << num << \" \";\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/34", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // for std::sort and std::unique\n\nusing namespace std;\n\nvector<int> unique(vector<int> l) {\n    // First, sort the vector to bring duplicates together.\n    sort(l.begin(), l.end());\n    \n    // Use std::unique to remove consecutive duplicates. It returns an iterator\n    // pointing past the last element of the new range without duplicates.\n    auto it = unique(l.begin(), l.end());\n    \n    // Erase the elements from the vector that are beyond the new end.\n    l.erase(it, l.end());\n\n    return l;\n}\n\n// Example usage and check function\nvoid check() {\n    vector<int> testVec = {5, 3, 5, 2, 3, 3, 9, 0, 123};\n    vector<int> result = unique(testVec);\n    \n    // Expected output: 0 2 3 5 9 123\n    for (int num : result) {\n        cout << num << \" \";\n    }\n}\n\n"}
{"task_id": "CPP/35", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // For std::max\n\nusing namespace std;\n\nfloat max_element(vector<float> l) {\n    if (l.empty()) {  // Check if vector is empty to avoid errors.\n        throw runtime_error(\"Vector is empty\"); // Or handle it as needed\n    }\n\n    float max_val = l[0]; // Initialize with the first element\n\n    for (size_t i = 1; i < l.size(); ++i) {\n        if (l[i] > max_val) {\n            max_val = l[i];\n        }\n    }\n\n    return max_val;\n}\n\n"}
{"task_id": "CPP/36", "generation": "#include <iostream>\nusing namespace std;\n\nint fizz_buzz(int n) {\n    int count = 0;\n    \n    for (int i = 1; i < n; ++i) {\n        if ((i % 11 == 0 || i % 13 == 0)) { // Check divisibility by 11 or 13\n            int temp = i;\n            while (temp > 0) {\n                if (temp % 10 == 7) count++; // Count digit '7'\n                temp /= 10; // Move to the next digit\n            }\n        }\n    }\n\n    return count;\n}\n\n"}
{"task_id": "CPP/37", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // For std::sort\n\nusing namespace std;\n\nvector<float> sort_even(vector<float> l) {\n    if (l.size() <= 1) return l; // If the vector is empty or has only one element, just return it as is.\n\n    vector<float> evenIndicesElements;\n    \n    // Extract elements at even indices.\n    for(size_t i = 0; i < l.size(); i += 2) {\n        evenIndicesElements.push_back(l[i]);\n    }\n    \n    // Sort the extracted elements.\n    sort(evenIndicesElements.begin(), evenIndicesElements.end());\n    \n    // Place sorted elements back into their original positions.\n    for(size_t i = 0, j = 0; i < l.size(); i += 2, ++j) {\n        l[i] = evenIndicesElements[j];\n    }\n    \n    return l;\n}\n\n"}
{"task_id": "CPP/38", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\n// Function to encode a string by cycling groups of three characters.\nstring encode_cyclic(string s) { \n    // split string into groups. Each of length 3.\n    int l = s.length();\n    int num = (l + 2) / 3;\n    string x, output;\n    for (int i = 0; i * 3 < l; i++) {\n        // cycle elements in each group unless the group has fewer than three characters\n        x = s.substr(i * 3, 3);\n        if (x.length() == 3) \n            x = x.back() + x.substr(0, 2); // Move last character to front.\n        output += x;\n    }\n    return output;\n}\n\n// Function to decode a string that was encoded with the encode_cyclic function\nstring decode_cyclic(string s) { \n    int l = s.length();\n    string x, output;\n    for (int i = 0; i * 3 < l; i++) {\n        // cycle elements in each group unless the group has fewer than three characters\n        x = s.substr(i * 3, 3);\n        if (x.length() == 3) \n            x = x.substr(1) + x[0]; // Move first character to end.\n        output += x;\n    }\n    return output;\n}\n\n"}
{"task_id": "CPP/39", "generation": "#include <iostream>\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    for (int i = 2; i * i <= num; ++i) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\n// Function to generate the n-th prime Fibonacci number\nint prime_fib(int n) {\n    int count = 0, a = 0, b = 1, fib;\n\n    while (true) {\n        // Generate next Fibonacci number\n        fib = a + b;\n        a = b;\n        b = fib;\n\n        // Check if the generated Fibonacci number is prime\n        if (is_prime(fib)) {\n            count++;\n            if (count == n) return fib;  // Return when we find the nth prime Fibonacci\n        }\n    }\n\n    return -1;  // This line should never be reached, but added for completeness.\n}\n\n"}
{"task_id": "CPP/40", "generation": "#include <vector>\n#include <algorithm> // For std::sort\n\nbool triples_sum_to_zero(std::vector<int> l) {\n    int n = l.size();\n    \n    // If the vector has less than 3 elements, it can't have a triple sum to zero.\n    if (n < 3)\n        return false;\n\n    // Sort the array\n    std::sort(l.begin(), l.end());\n\n    for (int i = 0; i < n - 2; ++i) {\n        int left = i + 1;\n        int right = n - 1;\n\n        while (left < right) {\n            int sum = l[i] + l[left] + l[right];\n            \n            if (sum == 0)\n                return true;\n            else if (sum < 0)\n                ++left; // We need a larger number\n            else\n                --right; // We need a smaller number\n        }\n    }\n\n    return false;\n}\n"}
{"task_id": "CPP/41", "generation": "#include <iostream>\nusing namespace std;\n\nint car_race_collision(int n) {\n    return n;\n}\n\n"}
{"task_id": "CPP/42", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> incr_vector(vector<int> l) {\n    // Iterate over all elements in the vector.\n    for (size_t i = 0; i < l.size(); ++i) {\n        // Increment each element by 1.\n        l[i] += 1;\n    }\n    return l;\n}\n\n// Function to test the correctness of incr_vector function\nvoid check() {\n    assert((incr_vector({1, 2, 3}) == vector<int>{2, 3, 4}));\n    assert((incr_vector({5, 3, 5, 2, 3, 3, 9, 0, 123}) == vector<int>{6, 4, 6, 3, 4, 4, 10, 1, 124}));\n    cout << \"All tests passed successfully.\" << endl;\n}\n\n"}
{"task_id": "CPP/43", "generation": "#include <iostream>\n#include <vector>\n#include <unordered_set> // Using unordered_set for efficient lookups\n\nusing namespace std;\n\nbool pairs_sum_to_zero(vector<int> l) {\n    unordered_set<int> seen; // To store elements we've seen so far\n    \n    for (int num : l) {\n        if (seen.find(-num) != seen.end()) { // Check if the negation of current number exists\n            return true;\n        }\n        seen.insert(num); // Add current number to set\n    }\n\n    return false; // No pair found that sums to zero\n}\n\n// Function to test the pairs_sum_to_zero function with given data points\nvoid check() {\n    cout << boolalpha; // Print 'true' or 'false' instead of 1 or 0\n    cout << \"Test Case 1: \" << pairs_sum_to_zero({1, 3, 5, 0}) << endl;\n    cout << \"Test Case 2: \" << pairs_sum_to_zero({1, 3, -2, 1}) << endl;\n    cout << \"Test Case 3: \" << pairs_sum_to_zero({1, 2, 3, 7}) << endl;\n    cout << \"Test Case 4: \" << pairs_sum_to_zero({2, 4, -5, 3, 5, 7}) << endl;\n    cout << \"Test Case 5: \" << pairs_sum_to_zero({1}) << endl;\n}\n\n"}
{"task_id": "CPP/44", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring change_base(int x, int base){\n    if(base <= 1 || base >= 10) return \"\"; // Ensure base is within the allowed range (2-9)\n    \n    string result = \"\";\n    while(x > 0){\n        int remainder = x % base;\n        result = to_string(remainder) + result; // Prepend the digit\n        x /= base;\n    }\n    \n    if(result == \"\") return \"0\"; // Handle case where x is 0\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/45", "generation": "#include <iostream> // Use for input/output\n\nfloat triangle_area(float base, float height) {\n    return 0.5 * base * height;\n}\n\n"}
{"task_id": "CPP/46", "generation": "#include <iostream>\nusing namespace std;\n\nint fib4(int n) {\n    // Base cases for the first 4 numbers of the sequence.\n    if (n == 0 || n == 1) return 0;\n    if (n == 2) return 2;\n    if (n == 3) return 0;\n\n    // Initialize the first four elements\n    int a = 0, b = 0, c = 2, d = 0;\n\n    for(int i = 4; i <= n; ++i) {\n        // Compute the next element in the sequence.\n        int next = a + b + c + d;\n        \n        // Shift the values to prepare for the next iteration\n        a = b;\n        b = c;\n        c = d;\n        d = next;\n    }\n\n    return d;  // The last computed value is fib4(n)\n}\n\n"}
{"task_id": "CPP/47", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // For std::sort\n\nusing namespace std;\n\nfloat median(vector<float> l) {\n    size_t n = l.size();\n    \n    if (n == 0) return NAN; // Return NaN for empty vector\n    \n    sort(l.begin(), l.end()); // Sort the vector\n    \n    if (n % 2 == 1) { // If odd number of elements\n        return l[n / 2]; // Median is the middle element\n    } else { // If even number of elements\n        size_t mid = n / 2;\n        return (l[mid - 1] + l[mid]) / 2.0; // Average of two middle elements\n    }\n}\n\n// Example usage:\n"}
{"task_id": "CPP/48", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_palindrome(string text) {\n    int left = 0;\n    int right = text.length() - 1;\n    \n    while (left < right) {\n        if (text[left] != text[right]) {\n            return false; // Characters do not match\n        }\n        left++;\n        right--;\n    }\n    return true; // All characters matched, it's a palindrome\n}\n\n"}
{"task_id": "CPP/49", "generation": "#include <iostream>\nusing namespace std;\n\nint modp(int n, int p) {\n    long long result = 1; // Use long long to avoid overflow during calculations.\n    long long base = 2;\n    \n    while (n > 0) {\n        if (n % 2 == 1) { // If n is odd\n            result = (result * base) % p;\n        }\n        base = (base * base) % p; // Square the base and take modulo to avoid overflow.\n        n /= 2; // Divide n by 2 for the next iteration.\n    }\n\n    return static_cast<int>(result);\n}\n\n"}
{"task_id": "CPP/50", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\n// Function to encode a string by shifting every character by 5 in the alphabet.\nstring encode_shift(string s) {\n    string out;\n    for (int i = 0; i < s.length(); i++) {\n        int w = ((int)s[i] + 5 - (int)'a') % 26 + (int)'a';\n        out += (char)w;\n    }\n    return out;\n}\n\n// Function to decode a string that was encoded with encode_shift function.\nstring decode_shift(string s) {\n    string out;\n    for (int i = 0; i < s.length(); i++) {\n        int w = ((int)s[i] - 5 - (int)'a' + 26) % 26 + (int)'a'; // Adding 26 to ensure non-negative result\n        out += (char)w;\n    }\n    return out;\n}\n\n// Example usage:\n"}
{"task_id": "CPP/51", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nbool isVowel(char c) {\n    // Check for both uppercase and lowercase vowels.\n    return (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' ||\n            c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U');\n}\n\nstring remove_vowels(string text) {\n    string result = \"\"; // Initialize an empty string to store the result.\n    \n    for (char c : text) { // Iterate through each character in the input string.\n        if (!isVowel(c)) { // If it's not a vowel, add it to the result string.\n            result += c;\n        }\n    }\n\n    return result; // Return the resulting string without vowels.\n}\n\n"}
{"task_id": "CPP/52", "generation": "#include <vector>\nusing namespace std;\n\nbool below_threshold(vector<int> l, int t) {\n    // Iterate through each element in the vector.\n    for (int num : l) {\n        // If any number is greater than or equal to the threshold, return false.\n        if (num >= t) {\n            return false;\n        }\n    }\n    // If all numbers are below the threshold, return true.\n    return true;\n}\n\n// Example usage:\n/*\nbool result1 = below_threshold({1, 2, 4, 10}, 100); // Should be true\nbool result2 = below_threshold({1, 20, 4, 10}, 5);   // Should be false\n*/\n"}
{"task_id": "CPP/53", "generation": "#include<iostream>\nusing namespace std;\n\nint add(int x, int y) {\n    return x + y;\n}\n\n"}
{"task_id": "CPP/54", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nbool same_chars(string s0, string s1) {\n    // Sort both strings\n    sort(s0.begin(), s0.end());\n    sort(s1.begin(), s1.end());\n\n    // Remove duplicates from the first string\n    auto last = unique(s0.begin(), s0.end());\n    s0.erase(last, s0.end());\n\n    // Remove duplicates from the second string\n    last = unique(s1.begin(), s1.end());\n    s1.erase(last, s1.end());\n\n    // Compare the two strings after removing duplicates\n    return s0 == s1;\n}\n\n"}
{"task_id": "CPP/55", "generation": "#include <iostream>\nusing namespace std;\n\nint fib(int n) {\n    if (n <= 1)\n        return n;\n    else\n        return fib(n-1) + fib(n-2);\n}\n\n"}
{"task_id": "CPP/56", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    int balance = 0; // Initialize balance to 0\n\n    for (char c : brackets) { // Iterate through each character in the string\n        if (c == '<') {\n            ++balance; // Increment balance for an opening bracket\n        } else if (c == '>') {\n            --balance; // Decrement balance for a closing bracket\n            if (balance < 0) return false; // If balance goes negative, it means there's no matching opening bracket\n        }\n    }\n\n    return balance == 0; // True if all brackets are correctly matched and balanced\n}\n\n"}
{"task_id": "CPP/57", "generation": "#include <vector>\nusing namespace std;\n\nbool monotonic(vector<float> l) {\n    // Check for empty or single-element vectors.\n    if (l.size() <= 1) return true;\n    \n    // Determine the direction of monotonicity based on the first two elements.\n    bool increasing = l[0] <= l[1];\n    bool decreasing = l[0] >= l[1];\n\n    // If both are false, it means all elements are equal (edge case).\n    if (!increasing && !decreasing) return true;\n\n    for(size_t i = 2; i < l.size(); ++i) {\n        if ((increasing && l[i-1] > l[i]) || (decreasing && l[i-1] < l[i])) {\n            // If the current element breaks the monotonicity, return false.\n            return false;\n        }\n    }\n\n    // If no break in monotonicity was found, return true.\n    return true;\n}\n"}
{"task_id": "CPP/58", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\n\nusing namespace std;\n\nvector<int> common(vector<int> l1, vector<int> l2) {\n    // Sort the input vectors.\n    sort(l1.begin(), l1.end());\n    sort(l2.begin(), l2.end());\n\n    // Use a set to store unique common elements.\n    set<int> commonElements;\n    \n    auto it1 = l1.begin();\n    auto it2 = l2.begin();\n\n    // Iterate through both vectors to find common elements.\n    while (it1 != l1.end() && it2 != l2.end()) {\n        if (*it1 == *it2) {\n            commonElements.insert(*it1);\n            ++it1;\n            ++it2;\n        } else if (*it1 < *it2) {\n            ++it1;\n        } else {\n            ++it2;\n        }\n    }\n\n    // Convert the set to a vector and return.\n    return vector<int>(commonElements.begin(), commonElements.end());\n}\n\n// Function to print the elements of a vector\nvoid printVector(const vector<int>& vec) {\n    for (int num : vec) {\n        cout << num << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/59", "generation": "#include<stdio.h>\n\nint largest_prime_factor(int n) {\n    int factor = 2; // Start with the smallest prime number.\n    \n    while (n != 1) { \n        if (n % factor == 0) {\n            n /= factor;\n        } else {\n            factor++;\n        }\n    }\n\n    return factor;\n}\n\n"}
{"task_id": "CPP/60", "generation": "#include <stdio.h>\n\nint sum_to_n(int n) {\n    int sum = 0;\n    for (int i = 1; i <= n; ++i) {\n        sum += i;\n    }\n    return sum;\n}\n\n// Function to test the correctness of sum_to_n\nvoid check_function() {\n    printf(\"sum_to_n(30): %d\\n\", sum_to_n(30)); // Expected: 465\n    printf(\"sum_to_n(100): %d\\n\", sum_to_n(100)); // Expected: 5050\n    printf(\"sum_to_n(5): %d\\n\", sum_to_n(5)); // Expected: 15\n    printf(\"sum_to_n(10): %d\\n\", sum_to_n(10)); // Expected: 55\n    printf(\"sum_to_n(1): %d\\n\", sum_to_n(1)); // Expected: 1\n}\n\n"}
{"task_id": "CPP/61", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    int balance = 0; // Counter for open brackets\n\n    for (char c : brackets) { // Iterate through each character in the string\n        if (c == '(') {\n            ++balance; // Increment counter for an opening bracket\n        } else if (c == ')') {\n            --balance; // Decrement counter for a closing bracket\n            if (balance < 0) {\n                return false; // If balance goes below zero, there are more closing brackets than open ones at some point\n            }\n        }\n    }\n\n    return balance == 0; // True if all opening brackets have corresponding closing brackets\n}\n\n"}
{"task_id": "CPP/62", "generation": "#include <iostream>\n#include <vector>\n\nstd::vector<float> derivative(const std::vector<float>& xs) {\n    // Check if the input vector has less than 2 elements, which means there's no derivative to compute.\n    if (xs.size() <= 1) return {};\n\n    std::vector<float> result;\n    \n    // Start from index 1 because we skip the constant term\n    for (size_t i = 1; i < xs.size(); ++i) {\n        // Multiply each coefficient by its power of x, which is represented by the index.\n        float coeff = xs[i] * static_cast<float>(i);\n        result.push_back(coeff);\n    }\n    \n    return result;\n}\n\n// Function to test the derivative function\nvoid check_derivative() {\n    std::vector<float> test1 = {3, 1, 2, 4, 5};\n    std::vector<float> expected1 = {1, 4, 12, 20};\n    \n    std::vector<float> result1 = derivative(test1);\n    assert(result1 == expected1);\n\n    std::vector<float> test2 = {1, 2, 3};\n    std::vector<float> expected2 = {2, 6};\n\n    std::vector<float> result2 = derivative(test2);\n    assert(result2 == expected2);\n\n    std::cout << \"All tests passed successfully.\" << std::endl;\n}\n\n"}
{"task_id": "CPP/63", "generation": "#include <iostream>\n#include <vector>\n\nint fibfib(int n) {\n    // Base cases as defined in the problem statement.\n    if(n == 0 || n == 1)\n        return 0;\n    else if(n == 2)\n        return 1;\n\n    // Initialize a vector to store computed values of FibFib sequence\n    std::vector<int> fibfib_values(n + 1, 0);\n    \n    // Set the base cases.\n    fibfib_values[0] = 0;\n    fibfib_values[1] = 0;\n    fibfib_values[2] = 1;\n\n    // Compute values from 3 to n using the given formula\n    for(int i = 3; i <= n; ++i) {\n        fibfib_values[i] = fibfib_values[i-1] + fibfib_values[i-2] + fibfib_values[i-3];\n    }\n\n    return fibfib_values[n];\n}\n\n"}
{"task_id": "CPP/64", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint vowels_count(string s) {\n    int count = 0;\n    // Convert string to lowercase for simplicity\n    transform(s.begin(), s.end(), s.begin(), ::tolower);\n    \n    // Check each character in the string\n    for (size_t i = 0; i < s.length(); ++i) {\n        char c = s[i];\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n            count++;\n        }\n        // Check for 'y' at the end of the string\n        else if (c == 'y' && i == s.length() - 1) {\n            count++;\n        }\n    }\n\n    return count;\n}\n\n"}
{"task_id": "CPP/65", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring circular_shift(int x, int shift) {\n    // Convert integer to string for easier manipulation\n    string str = to_string(x);\n    int len = str.length();\n    \n    // If shift is greater than the number of digits, reverse the string\n    if (shift > len) {\n        reverse(str.begin(), str.end());\n        return str;\n    }\n    \n    // Calculate effective shift\n    shift %= len;  // Adjust shift to be within the length of the string\n    \n    // Perform circular shift\n    string result = str.substr(len - shift, shift) + str.substr(0, len - shift);\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/66", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint digitSum(string s) {\n    int sum = 0;\n    \n    // Iterate through each character in the string\n    for (char c : s) {\n        // Check if the character is an uppercase letter\n        if (c >= 'A' && c <= 'Z') {\n            // Add its ASCII value to the sum\n            sum += static_cast<int>(c);\n        }\n    }\n\n    return sum;\n}\n\n"}
{"task_id": "CPP/67", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nint fruit_distribution(string s, int n) {\n    // Variables to store the count of apples and oranges.\n    int apples = 0;\n    int oranges = 0;\n\n    // Use a string stream to parse the input string.\n    stringstream ss(s);\n    string word;\n\n    while (ss >> word) {\n        if (word == \"apples\") {\n            ss >> word; // Skip 'and'\n            ss >> oranges; // The next number is for oranges\n        } else if (isdigit(word[0])) { // Check if the first character of the word is a digit.\n            apples = stoi(word); // Convert string to integer and store it in apples.\n        }\n    }\n\n    // Calculate the number of mangoes by subtracting the count of apples and oranges from n.\n    int mangoes = n - (apples + oranges);\n    \n    return mangoes;\n}\n\n"}
{"task_id": "CPP/68", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> pluck(vector<int> arr) {\n    int minEvenValue = INT_MAX; // Initialize to a large number\n    int minIndex = -1;          // Initialize to an invalid index\n\n    for (int i = 0; i < arr.size(); ++i) {\n        if (arr[i] % 2 == 0 && arr[i] <= minEvenValue) { // Check if the value is even and smaller or equal to current minimum\n            if (arr[i] < minEvenValue || (arr[i] == minEvenValue && i < minIndex)) {\n                minEvenValue = arr[i];\n                minIndex = i;\n            }\n        }\n    }\n\n    if (minIndex != -1) { // If a valid even number was found\n        return vector<int>{minEvenValue, minIndex};\n    } else {\n        return {}; // Return an empty vector if no even value is found or the input vector is empty\n    }\n}\n"}
{"task_id": "CPP/69", "generation": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint search(vector<int> lst) {\n    unordered_map<int, int> freqMap;\n    \n    // Step 1: Count the frequency of each integer.\n    for (int num : lst) {\n        freqMap[num]++;\n    }\n    \n    int result = -1; // Initialize with -1 to handle cases where no such number exists\n    \n    // Step 2 and 3: Check frequencies against their values\n    for (auto& pair : freqMap) {\n        if (pair.first <= pair.second && pair.first > result) {\n            result = pair.first;\n        }\n    }\n    \n    return result; // Step 4: Return the highest number that meets the criteria, or -1.\n}\n\n"}
{"task_id": "CPP/70", "generation": "#include <vector>\n#include <algorithm>\n\nstd::vector<int> strange_sort_list(std::vector<int> lst) {\n    std::sort(lst.begin(), lst.end()); // Step 1: Sort the list\n\n    std::vector<int> result;\n    int left = 0; // Start pointer\n    int right = lst.size() - 1; // End pointer\n\n    while (left <= right) { // Continue until all elements are added to result\n        if (left == right) {\n            result.push_back(lst[left]); // If only one element is left, add it directly\n        } else {\n            result.push_back(lst[left++]); // Add the minimum value and move the start pointer\n            result.push_back(lst[right--]); // Add the maximum value and move the end pointer\n        }\n    }\n\n    return result;\n}\n\n// Example usage:\n// std::vector<int> sorted = strange_sort_list({1, 2, 3, 4});\n// This will give you {1, 4, 2, 3}\n"}
{"task_id": "CPP/71", "generation": "#include <iostream>\n#include <cmath> // For sqrt function\n\nfloat triangle_area(float a, float b, float c) {\n    // Check if the sides form a valid triangle\n    if (a + b <= c || a + c <= b || b + c <= a)\n        return -1;\n\n    // Calculate semi-perimeter\n    float s = (a + b + c) / 2.0f;\n    \n    // Calculate area using Heron's formula\n    float area = sqrt(s * (s - a) * (s - b) * (s - c));\n    \n    // Return the area rounded to two decimal points\n    return round(area * 100) / 100.0f;\n}\n\n"}
{"task_id": "CPP/72", "generation": "#include <vector>\nusing namespace std;\n\nbool is_palindromic(const vector<int>& q) {\n    int n = q.size();\n    for (int i = 0; i < n / 2; ++i) {\n        if (q[i] != q[n - 1 - i]) return false;\n    }\n    return true;\n}\n\nbool will_it_fly(vector<int> q, int w) {\n    // Check if the vector is palindromic\n    if (!is_palindromic(q)) return false;\n\n    // Calculate the sum of elements in the vector\n    int sum = 0;\n    for (int num : q) {\n        sum += num;\n    }\n\n    // Check if the sum is less than or equal to w\n    return sum <= w;\n}\n\n// Example usage:\n/*\nbool result1 = will_it_fly({1, 2}, 5); // \u279e false \nbool result2 = will_it_fly({3, 2, 3}, 1); // \u279e false\nbool result3 = will_it_fly({3, 2, 3}, 9); // \u279e true\nbool result4 = will_it_fly({3}, 5); // \u279e true\n*/\n"}
{"task_id": "CPP/73", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint smallest_change(vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n    \n    for (int i = 0; i < n / 2; ++i) {\n        if (arr[i] != arr[n - i - 1]) {\n            ++changes;\n        }\n    }\n\n    return changes;\n}\n\n// Function to test the solution with given data points\nvoid check() {\n    vector<int> test1 = {1, 2, 3, 5, 4, 7, 9, 6};\n    vector<int> test2 = {1, 2, 3, 4, 3, 2, 2};\n    vector<int> test3 = {1, 2, 3, 2, 1};\n\n    cout << \"Test 1: Expected 4, Got \" << smallest_change(test1) << endl;\n    cout << \"Test 2: Expected 1, Got \" << smallest_change(test2) << endl;\n    cout << \"Test 3: Expected 0, Got \" << smallest_change(test3) << endl;\n}\n\n"}
{"task_id": "CPP/74", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to calculate the total number of characters in a vector of strings.\nint countChars(const vector<string>& lst) {\n    int count = 0;\n    for (const string& str : lst) {\n        count += str.size();\n    }\n    return count;\n}\n\nvector<string> total_match(vector<string> lst1, vector<string> lst2) {\n    // Calculate the number of characters in each list.\n    int charsInLst1 = countChars(lst1);\n    int charsInLst2 = countChars(lst2);\n\n    // Compare and return the appropriate list based on character counts.\n    if (charsInLst1 <= charsInLst2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n\n// Function to test the total_match function with given examples\nvoid check() {\n    vector<string> empty = {};\n    vector<string> result;\n\n    // Example 1: Both lists are empty.\n    result = total_match(empty, empty);\n    cout << \"Example 1: \";\n    for (const string& str : result) {\n        cout << str << \" \";\n    }\n    cout << endl;\n\n    // Example 2\n    vector<string> lst1_2 = {\"hi\", \"admin\"};\n    vector<string> lst2_2 = {\"hI\", \"Hi\"};\n    result = total_match(lst1_2, lst2_2);\n    cout << \"Example 2: \";\n    for (const string& str : result) {\n        cout << str << \" \";\n    }\n    cout << endl;\n\n    // Example 3\n    vector<string> lst1_3 = {\"hi\", \"admin\"};\n    vector<string> lst2_3 = {\"hi\", \"hi\", \"admin\", \"project\"};\n    result = total_match(lst1_3, lst2_3);\n    cout << \"Example 3: \";\n    for (const string& str : result) {\n        cout << str << \" \";\n    }\n    cout << endl;\n\n    // Example 4\n    vector<string> lst1_4 = {\"hi\", \"admin\"};\n    vector<string> lst2_4 = {\"hI\", \"hi\", \"hi\"};\n    result = total_match(lst1_4, lst2_4);\n    cout << \"Example 4: \";\n    for (const string& str : result) {\n        cout << str << \" \";\n    }\n    cout << endl;\n\n    // Example 5\n    vector<string> lst1_5 = {\"4\"};\n    vector<string> lst2_5 = {\"1\", \"2\", \"3\", \"4\", \"5\"};\n    result = total_match(lst1_5, lst2_5);\n    cout << \"Example 5: \";\n    for (const string& str : result) {\n        cout << str << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/75", "generation": "#include <iostream>\nusing namespace std;\n\n// Function to check if a number is prime.\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\n// Function to check if a number can be expressed as the product of exactly three prime numbers.\nbool is_multiply_prime(int a) {\n    // Iterate through all possible combinations of three primes less than 100\n    for (int i = 2; i < 100 && i * i * i <= a; ++i) {\n        if (!is_prime(i)) continue;\n        \n        for (int j = i; j < 100 && i * j * j <= a; ++j) {\n            if (!is_prime(j)) continue;\n\n            for (int k = j; k < 100 && i * j * k <= a; ++k) {\n                if (!is_prime(k)) continue;\n                \n                // Check if the product of these three primes equals 'a'\n                if (i * j * k == a) return true;\n            }\n        }\n    }\n\n    return false;\n}\n\n"}
{"task_id": "CPP/76", "generation": "#include <cmath>\n#include <iostream>\n\nbool is_simple_power(int x, int n) {\n    // Special case: any number to the power 0 is 1 (except for 0^0 which is undefined)\n    if (x == 1) return true;\n    \n    // If n is 1 and x is not 1, it's impossible for x to be a simple power of n\n    if (n == 1) return false;\n\n    // Calculate the logarithm of x with base n\n    double log_result = std::log(x) / std::log(n);\n\n    // Check if the result is an integer by comparing it to its rounded value\n    return std::abs(log_result - std::round(log_result)) < 1e-10;\n}\n\n"}
{"task_id": "CPP/77", "generation": "#include<stdio.h>\n#include<math.h>\n\nbool iscube(int a){\n    // Calculate the cube root of 'a' using cbrt() from math.h.\n    double cubeRoot = cbrt(a);\n    \n    // Round the cube root to the nearest integer and then cube it again.\n    int roundedCubeRoot = round(cubeRoot);\n    int cubedValue = roundedCubeRoot * roundedCubeRoot * roundedCubeRoot;\n    \n    // Check if the cubed value matches 'a'.\n    return cubedValue == a;\n}\n\n"}
{"task_id": "CPP/78", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint hex_key(string num) {\n    // Define a set of prime hexadecimal digits.\n    string primes = \"2357BD\";\n    \n    int count = 0;\n    \n    // Iterate through each character in the input string.\n    for (char c : num) {\n        // Check if the current character is one of the prime hex digits.\n        if (primes.find(c) != string::npos)\n            ++count; // Increment count if it's a prime digit.\n    }\n    \n    return count;\n}\n\n"}
{"task_id": "CPP/79", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring decimal_to_binary(int decimal) {\n    string binary = \"\";\n    \n    // Convert decimal to binary\n    while (decimal > 0) {\n        int remainder = decimal % 2;\n        binary = char('0' + remainder) + binary; // Prepend the character\n        decimal /= 2;\n    }\n    \n    // Add \"db\" at the beginning and end of the string\n    return \"db\" + binary + \"db\";\n}\n\n"}
{"task_id": "CPP/80", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_happy(const string& s) {\n    // Check if the length of the string is less than 3.\n    if (s.length() < 3) return false;\n    \n    // Iterate through the string to check every set of three consecutive characters.\n    for (size_t i = 0; i < s.length() - 2; ++i) {\n        // Check if any two out of three consecutive characters are the same.\n        if (s[i] == s[i+1] || s[i] == s[i+2] || s[i+1] == s[i+2]) {\n            return false;\n        }\n    }\n\n    // If all sets of three consecutive characters are distinct, the string is happy.\n    return true;\n}\n\n"}
{"task_id": "CPP/81", "generation": "#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<string> numerical_letter_grade(vector<float> grades) {\n    vector<string> result;\n    \n    for (float gpa : grades) {\n        if (gpa >= 4.0) result.push_back(\"A+\");\n        else if (gpa > 3.7) result.push_back(\"A\");\n        else if (gpa > 3.3) result.push_back(\"A-\");\n        else if (gpa > 3.0) result.push_back(\"B+\");\n        else if (gpa > 2.7) result.push_back(\"B\");\n        else if (gpa > 2.3) result.push_back(\"B-\");\n        else if (gpa > 2.0) result.push_back(\"C+\");\n        else if (gpa > 1.7) result.push_back(\"C\");\n        else if (gpa > 1.3) result.push_back(\"C-\");\n        else if (gpa > 1.0) result.push_back(\"D+\");\n        else if (gpa > 0.7) result.push_back(\"D\");\n        else if (gpa > 0.0) result.push_back(\"D-\");\n        else result.push_back(\"E\"); // For gpa <= 0\n    }\n    \n    return result;\n}\n\n// Example usage:\n"}
{"task_id": "CPP/82", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\n// Helper function to check if a number is prime.\nbool is_prime(int n) {\n    if (n <= 1) return false; // 0 and 1 are not primes\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\n// Main function to check if the length of a string is prime.\nbool prime_length(string str) {\n    int len = str.length();\n    return is_prime(len);\n}\n\n"}
{"task_id": "CPP/83", "generation": "#include<iostream>\nusing namespace std;\n\nint starts_one_ends(int n) {\n    if(n == 1) return 1; // Special case for single-digit numbers\n\n    int total_n_digit_numbers = 9 * pow(10, n-1); // Total n-digit numbers\n    int start_with_1 = pow(10, n-1);              // Numbers starting with '1'\n    int end_with_1 = pow(10, n-1);                // Numbers ending with '1'\n    int both_start_and_end_with_1 = pow(10, n-2); // Overlap: numbers that start and end with '1'\n\n    return total_n_digit_numbers - (total_n_digit_numbers - start_with_1) -\n           (total_n_digit_numbers - end_with_1) + both_start_and_end_with_1;\n}\n\n"}
{"task_id": "CPP/84", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\n// Function to calculate the sum of digits of N\nint sumOfDigits(int N) {\n    int sum = 0;\n    while (N > 0) {\n        sum += N % 10; // Add the last digit to sum\n        N /= 10;       // Remove the last digit from N\n    }\n    return sum;\n}\n\n// Function to convert an integer to its binary representation as a string\nstring intToBinary(int num) {\n    if (num == 0) return \"0\"; // Special case for zero\n\n    string binary = \"\";\n    while (num > 0) {\n        binary = (num % 2 == 0 ? \"0\" : \"1\") + binary; // Prepend the remainder\n        num /= 2;\n    }\n    return binary;\n}\n\nstring solve(int N){\n    int sumDigits = sumOfDigits(N); // Calculate the sum of digits\n    string resultBinary = intToBinary(sumDigits); // Convert to binary\n    return resultBinary;\n}\n\n// Example usage:\n"}
{"task_id": "CPP/85", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint add(vector<int> lst) {\n    int sum = 0;\n    // Iterate through the vector with a for loop.\n    for (size_t i = 1; i < lst.size(); i += 2) { // Start from index 1 and increment by 2 to get odd indices\n        if (lst[i] % 2 == 0) { // Check if the element at the current index is even\n            sum += lst[i]; // Add it to the sum if it's even.\n        }\n    }\n    return sum;\n}\n\n// Example usage:\n"}
{"task_id": "CPP/86", "generation": "#include <iostream>\n#include <string>\n#include <algorithm> // for std::sort\n\nusing namespace std;\n\nstring anti_shuffle(string s) {\n    string result = \"\";\n    string tempWord = \"\";  // Temporary word to hold characters of each word before sorting\n    \n    for (char c : s) {  // Iterate through each character in the input string\n        if (c == ' ') {  // If a space is encountered, sort and append the current word to result\n            sort(tempWord.begin(), tempWord.end());  // Sort characters of the temporary word\n            result += tempWord + \" \";  // Append sorted word followed by a space\n            tempWord = \"\";  // Reset temporary word for next word in string\n        } else {\n            tempWord += c;  // Add character to current word being processed\n        }\n    }\n\n    if (!tempWord.empty()) {  // Sort and append the last word (if any) after loop ends\n        sort(tempWord.begin(), tempWord.end());\n        result += tempWord;\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/87", "generation": "#include <vector>\n#include <algorithm> // for std::sort\n\nusing namespace std;\n\n// Comparator function to sort coordinates as required.\nbool compare(const vector<int>& a, const vector<int>& b) {\n    if (a[0] != b[0]) return a[0] < b[0]; // Sort by row in ascending order\n    else return a[1] > b[1];              // Then sort by column in descending order within the same row\n}\n\nvector<vector<int>> get_row(vector<vector<int>> lst, int x) {\n    vector<vector<int>> coordinates;\n    \n    for (int i = 0; i < lst.size(); ++i) { // Iterate through each row\n        for (int j = 0; j < lst[i].size(); ++j) { // Iterate through each element in the row\n            if (lst[i][j] == x) {\n                coordinates.push_back({i, j}); // Record the coordinate of found integer\n            }\n        }\n    }\n\n    sort(coordinates.begin(), coordinates.end(), compare); // Sort according to specified rules\n    \n    return coordinates;\n}\n\n// Example usage:\n"}
{"task_id": "CPP/88", "generation": "#include <vector>\n#include <algorithm> // for std::sort\n\nusing namespace std;\n\nvector<int> sort_array(vector<int> array) {\n    if (array.size() <= 1) return array; // If the vector is empty or has only one element, return it as is.\n\n    int first = array.front(); // Get the first element\n    int last = array.back();   // Get the last element\n\n    bool shouldSortAscending = (first + last) % 2 != 0; // Determine sorting order based on sum of first and last elements\n\n    vector<int> sortedArray(array); // Create a copy to avoid modifying the original vector\n\n    if (shouldSortAscending) {\n        sort(sortedArray.begin(), sortedArray.end()); // Sort in ascending order\n    } else {\n        sort(sortedArray.rbegin(), sortedArray.rend()); // Sort in descending order using reverse iterators\n    }\n\n    return sortedArray;\n}\n\n// Example usage:\n/*\nvector<int> result = sort_array({});\nfor (int num : result) {\n    printf(\"%d \", num);\n}\n*/\n"}
{"task_id": "CPP/89", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nstring encrypt(string s){\n    string result = \"\";\n    \n    for(char c : s) {\n        if(isalpha(c)) { // Check if character is an alphabet letter.\n            char base = islower(c) ? 'a' : 'A'; // Determine the base ('a' or 'A') based on case\n            int shift = (c - base + 4) % 26; // Calculate new position with wrap-around\n            result += base + shift;\n        } else {\n            result += c; // Non-alphabet characters are not encrypted.\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/90", "generation": "#include <vector>\n#include <algorithm> // for std::sort and std::unique\n#include <optional>  // for returning None (std::nullopt)\n\nint next_smallest(const std::vector<int>& lst) {\n    if(lst.size() < 2) return std::nullopt; // If there are less than two elements, we can't have a second smallest.\n    \n    std::vector<int> sorted_unique_lst = lst;\n    sort(sorted_unique_lst.begin(), sorted_unique_lst.end()); // Sort the vector\n    auto last = unique(sorted_unique_lst.begin(), sorted_unique_lst.end()); // Remove duplicates\n    \n    if(last == sorted_unique_lst.begin() || next(sorted_unique_lst.begin()) == last) {\n        return std::nullopt; // If there's only one unique element, we can't have a second smallest.\n    }\n    \n    auto it = next(sorted_unique_lst.begin());\n    return *it;\n}\n\n// Example usage\n"}
{"task_id": "CPP/91", "generation": "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nint is_bored(string S) {\n    vector<string> sentences;\n    string delimiter = \"\";\n    int boredomCount = 0;\n\n    // Split the input string into sentences based on '.', '?' or '!'\n    for (char c : S) {\n        if (c == '.' || c == '?' || c == '!') {\n            sentences.push_back(delimiter);\n            delimiter = \"\"; // Reset delimiter after finding a sentence\n        } else {\n            delimiter += c;\n        }\n    }\n\n    // Add the last part of the string as a sentence if it's not empty\n    if (!delimiter.empty()) {\n        sentences.push_back(delimiter);\n    }\n\n    // Check each sentence to see if it starts with \"I\"\n    for (string &sentence : sentences) {\n        // Trim leading spaces\n        size_t start = sentence.find_first_not_of(\" \");\n        if (start != string::npos) {\n            sentence = sentence.substr(start);\n        }\n        \n        // Check if the sentence starts with \"I\"\n        if (!sentence.empty() && sentence[0] == 'I' && (sentence.size() < 2 || !isalpha(sentence[1]))) {\n            boredomCount++;\n        }\n    }\n\n    return boredomCount;\n}\n\n"}
{"task_id": "CPP/92", "generation": "#include <iostream>\n#include <cmath>\n\nbool is_integer(float num) {\n    return std::floor(num) == num;\n}\n\nbool any_int(float a, float b, float c) {\n    // Check if all numbers are integers\n    if (!is_integer(a) || !is_integer(b) || !is_integer(c)) {\n        return false;\n    }\n\n    int ia = static_cast<int>(a);\n    int ib = static_cast<int>(b);\n    int ic = static_cast<int>(c);\n\n    // Check if any number is the sum of the other two\n    return (ia == ib + ic) || (ib == ia + ic) || (ic == ia + ib);\n}\n\n"}
{"task_id": "CPP/93", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\n// Function to encode the message according to the given rules.\nstring encode(string message) {\n    // Define a mapping for vowel replacements.\n    string vowels = \"aeiouAEIOU\";\n    string replacementVowels = \"cdefgCDEFG\";  // Each character is two places ahead in the alphabet.\n\n    for (int i = 0; i < message.length(); ++i) {\n        char ch = message[i];\n        \n        // Swap case\n        if(islower(ch)) \n            ch = toupper(ch);\n        else if(isupper(ch))\n            ch = tolower(ch);\n\n        // Replace vowels with the character that is two places ahead in the alphabet.\n        size_t pos = vowels.find(ch);\n        if (pos != string::npos) {\n            message[i] = replacementVowels[pos];\n        } else {\n            message[i] = ch;\n        }\n    }\n\n    return message;\n}\n\n// Function to test the encode function with given examples.\nvoid check() {\n    cout << \"encode('test'): \" << encode(\"test\") << endl;  // Expected: TGST\n    cout << \"encode('This is a message'): \" << encode(\"This is a message\") << endl;  // Expected: tHKS KS C MGSSCGG\n}\n\n"}
{"task_id": "CPP/94", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Helper function to check if a number is prime\nbool isPrime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\n// Function to sum the digits of a number\nint sumDigits(int n) {\n    int sum = 0;\n    while (n > 0) {\n        sum += n % 10;\n        n /= 10;\n    }\n    return sum;\n}\n\n// Main function to find and process the largest prime in the list\nint skjkasdkd(vector<int> lst) {\n    int maxPrime = -1; // Initialize with a non-prime value\n\n    // Find the largest prime number in the vector\n    for (auto num : lst) {\n        if (isPrime(num)) {\n            maxPrime = max(maxPrime, num);\n        }\n    }\n\n    // If no prime was found, return 0 or handle as needed\n    if (maxPrime == -1) return 0;\n\n    // Sum the digits of the largest prime number\n    return sumDigits(maxPrime);\n}\n\n"}
{"task_id": "CPP/95", "generation": "#include <iostream>\n#include <string>\n#include <map>\n\nusing namespace std;\n\nbool check_dict_case(map<string, string> dict) {\n    if (dict.empty()) return false; // Return false for an empty map\n\n    bool allLower = true;\n    bool allUpper = true;\n\n    for (const auto& pair : dict) {\n        const string& key = pair.first;\n        \n        // Check if the key contains any non-alphabetic characters\n        for (char ch : key) {\n            if (!isalpha(ch)) return false; // Return false if there's a non-alphabetic character\n        }\n\n        // Determine if all keys are lowercase or uppercase\n        for (char ch : key) {\n            if (!islower(ch)) allLower = false;\n            if (!isupper(ch)) allUpper = false;\n        }\n    }\n\n    return allLower || allUpper; // Return true if all keys are either in lower case or upper case\n}\n\n"}
{"task_id": "CPP/96", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    for (int i = 2; i * i <= num; ++i) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\nvector<int> count_up_to(int n){\n    vector<int> primes;\n    \n    // Iterate through all numbers from 2 to n-1\n    for (int i = 2; i < n; ++i) {\n        if (is_prime(i)) {\n            primes.push_back(i);\n        }\n    }\n    \n    return primes;\n}\n\n// Function to test the count_up_to function with some examples\nvoid test_count_up_to() {\n    vector<int> result;\n\n    result = count_up_to(5);\n    for(int prime : result) cout << prime << \" \";\n    cout << endl; // Expected: 2 3\n\n    result = count_up_to(11);\n    for(int prime : result) cout << prime << \" \";\n    cout << endl; // Expected: 2 3 5 7\n\n    result = count_up_to(0);\n    if (result.empty()) cout << \"{}\" << endl; // Expected: {}\n\n    result = count_up_to(20);\n    for(int prime : result) cout << prime << \" \";\n    cout << endl; // Expected: 2 3 5 7 11 13 17 19\n\n    result = count_up_to(1);\n    if (result.empty()) cout << \"{}\" << endl; // Expected: {}\n\n    result = count_up_to(18);\n    for(int prime : result) cout << prime << \" \";\n    cout << endl; // Expected: 2 3 5 7 11 13 17\n}\n\n"}
{"task_id": "CPP/97", "generation": "#include <iostream> // Corrected header for standard input/output operations\n\nint multiply(int a, int b) {\n    // Extract unit digits of both numbers\n    int unitDigitA = abs(a % 10); // Use abs to ensure the result is positive even if 'a' or 'b' are negative\n    int unitDigitB = abs(b % 10);\n\n    // Multiply the unit digits and return the product\n    return unitDigitA * unitDigitB;\n}\n\n"}
{"task_id": "CPP/98", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint count_upper(string s) {\n    int count = 0;\n    // Iterate over even indices only.\n    for (size_t i = 0; i < s.length(); i += 2) { // Start from index 0 and increment by 2\n        char c = s[i];\n        if (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n            count++;\n        }\n    }\n    return count;\n}\n\n"}
{"task_id": "CPP/99", "generation": "#include <iostream>\n#include <cmath>\n#include <string>\n\nusing namespace std;\n\nint closest_integer(string value) {\n    // Convert string to float\n    float num = stof(value);\n    \n    // Get the integer part of the number\n    int intPart = static_cast<int>(num);\n    \n    // Calculate the fractional part\n    float fracPart = fabs(num - intPart);\n    \n    // Check if it's equidistant from two integers and round away from zero\n    if (fracPart == 0.5) {\n        return num > 0 ? ceil(num) : floor(num);\n    } else {\n        // Use standard rounding for other cases\n        return static_cast<int>(round(num));\n    }\n}\n\n// Function to test the closest_integer function with given examples\nvoid check() {\n    cout << \"Testing closest_integer(\\\"10\\\"): \" << closest_integer(\"10\") << endl;\n    cout << \"Testing closest_integer(\\\"15.3\\\"): \" << closest_integer(\"15.3\") << endl;\n    cout << \"Testing closest_integer(\\\"14.5\\\"): \" << closest_integer(\"14.5\") << endl;\n    cout << \"Testing closest_integer(\\\"-14.5\\\"): \" << closest_integer(\"-14.5\") << endl;\n}\n\n"}
{"task_id": "CPP/100", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> make_a_pile(int n) {\n    vector<int> pile;\n    int current_stones = n; // Start with the number of stones in the first level\n    \n    for (int i = 0; i < n; ++i) { // Loop to create each level\n        pile.push_back(current_stones); // Add the current number of stones to the vector\n        \n        if (n % 2 == 1) { // If n is odd, add 2 to get the next odd number\n            current_stones += 2;\n        } else { // If n is even, add 2 to get the next even number\n            current_stones += 2;\n        }\n    }\n    \n    return pile; // Return the vector containing stones in each level\n}\n\n// Function to test the make_a_pile function with a given input and expected output.\nvoid check(int n, const vector<int>& expected) {\n    vector<int> result = make_a_pile(n);\n    if (result == expected) {\n        cout << \"Test passed for n=\" << n << endl;\n    } else {\n        cout << \"Test failed for n=\" << n << \". Expected: \";\n        for (int num : expected) {\n            cout << num << \" \";\n        }\n        cout << \", Got: \";\n        for (int num : result) {\n            cout << num << \" \";\n        }\n        cout << endl;\n    }\n}\n\n"}
{"task_id": "CPP/101", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> words_string(string s) {\n    vector<string> result;\n    string currentWord = \"\";\n\n    for (char c : s) {\n        if (c == ' ' || c == ',') { // If we encounter a space or comma\n            if (!currentWord.empty()) { // Only add to the result if the word is not empty\n                result.push_back(currentWord);\n                currentWord = \"\"; // Reset for next word\n            }\n        } else {\n            currentWord += c; // Add character to current word\n        }\n    }\n\n    if (!currentWord.empty()) { // Don't forget to add the last word after loop ends\n        result.push_back(currentWord);\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/102", "generation": "#include<iostream>\nusing namespace std;\n\nint choose_num(int x, int y) {\n    // If y is less than x, return -1 because the range is invalid.\n    if (y < x)\n        return -1;\n    \n    // Start from y and move downwards to find the largest even number in the range\n    for (int i = y; i >= x; --i) {\n        if (i % 2 == 0)\n            return i;\n    }\n    \n    // If no even number is found, return -1.\n    return -1;\n}\n\n// Function to test the solution with given examples\nvoid check() {\n    cout << \"choose_num(12, 15) = \" << choose_num(12, 15) << endl; // Expected output: 14\n    cout << \"choose_num(13, 12) = \" << choose_num(13, 12) << endl; // Expected output: -1\n}\n\n"}
{"task_id": "CPP/103", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring rounded_avg(int n, int m) {\n    if (n > m) return \"-1\"; // Step 1\n    \n    long sum = 0;\n    for (int i = n; i <= m; ++i) {\n        sum += i; // Summing up all numbers from n to m\n    }\n    \n    int count = m - n + 1; // Number of terms\n    int avg = sum / count; // Step 3: Compute average\n    \n    string binary;\n    while (avg > 0) { // Convert the integer to binary\n        binary = to_string(avg % 2) + binary;\n        avg /= 2;\n    }\n    \n    return binary.empty() ? \"0\" : binary; // Return \"0\" if binary is empty, else binary string\n}\n\n"}
{"task_id": "CPP/104", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to check if a number contains an even digit.\nbool has_even_digit(int num) {\n    while (num > 0) {\n        int digit = num % 10;\n        if (digit % 2 == 0) return true; // If any digit is even, return true\n        num /= 10;\n    }\n    return false;\n}\n\nvector<int> unique_digits(vector<int> x) {\n    vector<int> result;\n\n    // Filter out numbers that contain an even digit.\n    for (int num : x) {\n        if (!has_even_digit(num)) {\n            result.push_back(num);\n        }\n    }\n\n    // Sort the resulting vector in increasing order.\n    sort(result.begin(), result.end());\n\n    return result;\n}\n\n// Function to test the unique_digits function\nvoid check() {\n    vector<int> test1 = {15, 33, 1422, 1};\n    vector<int> expected1 = {1, 15, 33};\n    assert(unique_digits(test1) == expected1);\n\n    vector<int> test2 = {152, 323, 1422, 10};\n    vector<int> expected2 = {};\n    assert(unique_digits(test2) == expected2);\n    \n    cout << \"All tests passed successfully.\" << endl;\n}\n\n"}
{"task_id": "CPP/105", "generation": "#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\n\nusing namespace std;\n\nvector<string> by_length(vector<int> arr) {\n    // Map to store numbers and their names.\n    map<int, string> numberNames = {\n        {1, \"One\"}, {2, \"Two\"}, {3, \"Three\"},\n        {4, \"Four\"}, {5, \"Five\"}, {6, \"Six\"},\n        {7, \"Seven\"}, {8, \"Eight\"}, {9, \"Nine\"}\n    };\n\n    // Filter and sort the numbers between 1 and 9.\n    vector<int> filteredSorted;\n    for (int num : arr) {\n        if (num >= 1 && num <= 9) {\n            filteredSorted.push_back(num);\n        }\n    }\n    sort(filteredSorted.begin(), filteredSorted.end());\n\n    // Reverse the sorted list.\n    reverse(filteredSorted.begin(), filteredSorted.end());\n\n    // Replace each number with its name.\n    vector<string> result;\n    for (int num : filteredSorted) {\n        result.push_back(numberNames[num]);\n    }\n\n    return result;\n}\n\n// Example usage\n#include <iostream>\nusing namespace std;\n\n"}
{"task_id": "CPP/106", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// Function to calculate factorial\nint factorial(int num) {\n    int result = 1;\n    for (int i = 2; i <= num; ++i) {\n        result *= i;\n    }\n    return result;\n}\n\n// Function to calculate sum from 1 to num\nint sumToN(int num) {\n    return (num * (num + 1)) / 2; // Using the formula for the sum of first n natural numbers\n}\n\nvector<int> f(int n){\n    vector<int> result(n);\n    for (int i = 0; i < n; ++i) {\n        int value = i + 1;\n        if (value % 2 == 0) { // Check if the number is even\n            result[i] = factorial(value); // Calculate factorial\n        } else {\n            result[i] = sumToN(value); // Calculate sum from 1 to value\n        }\n    }\n    return result;\n}\n\n// Function to check the correctness of the function f\nvoid check() {\n    vector<int> expected = {1, 2, 6, 24, 15};\n    vector<int> result = f(5);\n    \n    cout << \"Expected: \";\n    for (int num : expected) {\n        cout << num << \" \";\n    }\n    cout << endl;\n    \n    cout << \"Result: \";\n    for (int num : result) {\n        cout << num << \" \";\n    }\n    cout << endl;\n\n    // Check if the results match\n    bool isCorrect = true;\n    for (size_t i = 0; i < expected.size(); ++i) {\n        if (expected[i] != result[i]) {\n            isCorrect = false;\n            break;\n        }\n    }\n\n    if (isCorrect) {\n        cout << \"The function works correctly.\" << endl;\n    } else {\n        cout << \"There's an error in the function.\" << endl;\n    }\n}\n\n"}
{"task_id": "CPP/107", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to check if a number is a palindrome\nbool is_palindrome(int num) {\n    string str = to_string(num);\n    int len = str.length();\n    for (int i = 0; i < len / 2; ++i) {\n        if (str[i] != str[len - i - 1]) return false;\n    }\n    return true;\n}\n\nvector<int> even_odd_palindrome(int n){\n    vector<int> result(2, 0); // Initialize a vector to hold counts of even and odd palindromes\n    for (int i = 1; i <= n; ++i) {\n        if (is_palindrome(i)) { // Check if the number is a palindrome\n            if (i % 2 == 0) result[0]++; // Increment count for even palindromes\n            else result[1]++; // Increment count for odd palindromes\n        }\n    }\n    return result;\n}\n\n// Example usage:\n"}
{"task_id": "CPP/108", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint count_nums(vector<int> n) {\n    int count = 0;\n    \n    for (auto num : n) {\n        int sum_of_digits = 0;\n        \n        // Handle the case where number is negative.\n        bool is_negative = num < 0;\n        if (is_negative)\n            num = -num; // Make it positive to simplify digit extraction\n        \n        while (num > 0) {\n            int digit = num % 10;\n            sum_of_digits += is_negative ? -digit : digit;\n            num /= 10;\n        }\n        \n        // If the number was negative, we've already adjusted the first digit.\n        if (!is_negative && n.size() > 0)\n            sum_of_digits += (n[0] < 0) ? -(abs(n[0]) % 10) : (n[0] % 10);\n        \n        // Check if the sum of digits is greater than 0\n        if (sum_of_digits > 0) {\n            count++;\n        }\n    }\n\n    return count;\n}\n\n"}
{"task_id": "CPP/109", "generation": "#include <vector>\nusing namespace std;\n\nbool move_one_ball(vector<int> arr){\n    int n = arr.size();\n    \n    // If array is empty or has only one element, it is trivially sorted.\n    if (n <= 1) return true;\n    \n    // Find the split point where the sequence breaks\n    int breakPoint = -1;\n    for(int i = 0; i < n-1; ++i){\n        if(arr[i] > arr[i+1]){\n            if(breakPoint != -1) return false; // More than one break point found, cannot be sorted by shifting.\n            breakPoint = i;\n        }\n    }\n\n    // If no break point is found, the array is already sorted\n    if (breakPoint == -1) return true;\n\n    // Check if elements after the break point are in order and smaller than the first element of the original array\n    for(int i = breakPoint + 1; i < n-1; ++i){\n        if(arr[i] > arr[i+1]) return false;\n    }\n\n    // Finally, check if the last element is less than or equal to the first element.\n    return (arr[n-1] <= arr[0]);\n}\n"}
{"task_id": "CPP/110", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring exchange(vector<int> lst1, vector<int> lst2) {\n    int oddCountInLst1 = 0;\n    int evenCountInLst2 = 0;\n\n    // Count the number of odd numbers in lst1\n    for (int num : lst1) {\n        if (num % 2 != 0) {\n            ++oddCountInLst1;\n        }\n    }\n\n    // Count the number of even numbers in lst2\n    for (int num : lst2) {\n        if (num % 2 == 0) {\n            ++evenCountInLst2;\n        }\n    }\n\n    // If there are enough even numbers in lst2 to replace all odd numbers in lst1, return \"YES\"\n    if (oddCountInLst1 <= evenCountInLst2) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n\n// Function to test the solution\nvoid test() {\n    cout << exchange({1, 2, 3, 4}, {1, 2, 3, 4}) << endl; // Expected: YES\n    cout << exchange({1, 2, 3, 4}, {1, 5, 3, 4}) << endl; // Expected: NO\n}\n\n"}
{"task_id": "CPP/111", "generation": "#include <iostream>\n#include <string>\n#include <map>\n#include <sstream>\nusing namespace std;\n\nmap<char,int> histogram(string test) {\n    map<char, int> letterCount;\n    map<char, int> maxLetters;\n    \n    // If the input string is empty, return an empty map.\n    if (test.empty()) {\n        return maxLetters;\n    }\n    \n    stringstream ss(test);\n    char ch;\n    \n    // Count occurrences of each character\n    while (ss >> ch) {\n        letterCount[ch]++;\n    }\n\n    int maxFrequency = 0;\n\n    // Find the maximum frequency among all characters.\n    for (const auto& pair : letterCount) {\n        if (pair.second > maxFrequency) {\n            maxFrequency = pair.second;\n        }\n    }\n\n    // Collect all characters that have the maximum frequency\n    for (const auto& pair : letterCount) {\n        if (pair.second == maxFrequency) {\n            maxLetters[pair.first] = pair.second;\n        }\n    }\n\n    return maxLetters;\n}\n\n// Function to print the map for testing purposes.\nvoid printMap(const map<char, int>& m) {\n    for (const auto& pair : m) {\n        cout << \"{\" << pair.first << \", \" << pair.second << \"} \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/112", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to check if a string is palindrome\nbool isPalindrome(const string& str) {\n    int n = str.length();\n    for (int i = 0; i < n / 2; ++i) {\n        if (str[i] != str[n - i - 1]) return false;\n    }\n    return true;\n}\n\nvector<string> reverse_delete(string s, string c) {\n    // Remove characters from s that are present in c\n    for (char ch : c) {\n        s.erase(remove(s.begin(), s.end(), ch), s.end());\n    }\n\n    // Check if the resulting string is a palindrome\n    bool result = isPalindrome(s);\n\n    vector<string> res;\n    res.push_back(s);\n    res.push_back(result ? \"True\" : \"False\");\n\n    return res;\n}\n\n"}
{"task_id": "CPP/113", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to replace all instances of 'i' in a template string with the given number.\nstring replace_i_with_count(const string& template_str, int count) {\n    string result;\n    for (char c : template_str) {\n        if (c == 'i') {\n            // Convert count to string and append it\n            result += to_string(count);\n        } else {\n            result += c;\n        }\n    }\n    return result;\n}\n\nvector<string> odd_count(vector<string> lst){\n    vector<string> output;\n    const string template_str = \"the number of odd elements in the strin of the input.\";\n    \n    for (const auto& s : lst) {\n        int count_odd_digits = 0;\n        \n        // Counting odd digits\n        for (char c : s) {\n            if ((c - '0') % 2 != 0) { // Convert char to digit and check if it's odd\n                ++count_odd_digits;\n            }\n        }\n\n        // Replace all 'i' in the template string with count_odd_digits\n        output.push_back(replace_i_with_count(template_str, count_odd_digits));\n    }\n    \n    return output;\n}\n\n// Function to test the solution\nvoid test() {\n    vector<string> input1 = {\"1234567\"};\n    auto result1 = odd_count(input1);\n    for (const auto& s : result1) cout << s << endl;\n\n    vector<string> input2 = {\"3\", \"11111111\"};\n    auto result2 = odd_count(input2);\n    for (const auto& s : result2) cout << s << endl;\n}\n\n"}
{"task_id": "CPP/114", "generation": "#include <iostream>\n#include <vector>\n#include <climits> // For INT_MAX\n\nusing namespace std;\n\nlong long minSubArraySum(vector<long long>& nums) {\n    if (nums.empty()) return 0; // Handle empty vector case\n    \n    long long currentMin = nums[0];\n    long long globalMin = nums[0];\n\n    for (size_t i = 1; i < nums.size(); ++i) {\n        currentMin = min(nums[i], currentMin + nums[i]);\n        if (currentMin < globalMin)\n            globalMin = currentMin;\n    }\n\n    return globalMin;\n}\n\n"}
{"task_id": "CPP/115", "generation": "#include <vector>\nusing namespace std;\n\nint max_fill(vector<vector<int>> grid, int capacity) {\n    int total_drops = 0;\n    \n    // Iterate through each well (row in the grid)\n    for(auto& row : grid) {\n        int water_units = 0;\n        \n        // Count units of water in this well\n        for(int unit : row) {\n            if(unit == 1) {\n                ++water_units;\n            }\n        }\n        \n        // Calculate number of drops needed to empty the current well\n        total_drops += (water_units + capacity - 1) / capacity; \n    }\n\n    return total_drops;\n}\n"}
{"task_id": "CPP/116", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// Helper function to count the number of 1s in binary representation\nint countOnes(int n) {\n    int count = 0;\n    while (n != 0) {\n        if ((n & 1) == 1)\n            ++count;\n        n >>= 1; // Right shift by one position\n    }\n    return count;\n}\n\n// Comparator function for sorting based on the number of ones and then value\nbool compare(int a, int b) {\n    int countA = countOnes(a);\n    int countB = countOnes(b);\n\n    if (countA == countB)\n        return a < b; // If same number of 1s, sort by decimal value\n\n    return countA < countB;\n}\n\nvector<int> sort_array(vector<int> arr) {\n    sort(arr.begin(), arr.end(), compare);\n    return arr;\n}\n\n"}
{"task_id": "CPP/117", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to count consonants in a given string.\nint count_consonants(const string& str) {\n    int count = 0;\n    for (char ch : str) {\n        // Convert character to lowercase and check if it's a consonant\n        char lower_ch = tolower(ch);\n        if ((lower_ch >= 'a' && lower_ch <= 'z') && !strchr(\"aeiou\", lower_ch)) {\n            count++;\n        }\n    }\n    return count;\n}\n\n// Function to split the string into words.\nvector<string> split_string(const string& str) {\n    vector<string> words;\n    string word = \"\";\n    for (char ch : str) {\n        if (ch == ' ') {\n            if (!word.empty()) {\n                words.push_back(word);\n                word = \"\";\n            }\n        } else {\n            word += ch;\n        }\n    }\n    // Add the last word\n    if (!word.empty()) {\n        words.push_back(word);\n    }\n    return words;\n}\n\nvector<string> select_words(string s, int n) {\n    vector<string> result;\n    vector<string> words = split_string(s);\n\n    for (const string& word : words) {\n        // Count consonants in the current word\n        if (count_consonants(word) == n) {\n            result.push_back(word);\n        }\n    }\n\n    return result;\n}\n\n// Function to test the select_words function.\nvoid test() {\n    vector<string> res;\n\n    res = select_words(\"Mary had a little lamb\", 4);\n    for (const string& str : res) cout << str << \" \";\n    cout << endl; // Expected: {\"little\"}\n\n    res = select_words(\"Mary had a little lamb\", 3);\n    for (const string& str : res) cout << str << \" \";\n    cout << endl; // Expected: {\"Mary\", \"lamb\"}\n\n    res = select_words(\"simple white space\", 2);\n    for (const string& str : res) cout << str << \" \";\n    cout << endl; // Expected: {}\n\n    res = select_words(\"Hello world\", 4);\n    for (const string& str : res) cout << str << \" \";\n    cout << endl; // Expected: {\"world\"}\n\n    res = select_words(\"Uncle sam\", 3);\n    for (const string& str : res) cout << str << \" \";\n    cout << endl; // Expected: {\"Uncle\"}\n}\n\n"}
{"task_id": "CPP/118", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool isVowel(char c) {\n    string vowels = \"aeiouAEIOU\";\n    return vowels.find(c) != string::npos;\n}\n\nstring get_closest_vowel(string word) {\n    int n = word.length();\n    \n    // Iterate from the second last character to the first\n    for (int i = n - 2; i > 0; --i) {\n        char currentChar = word[i];\n        \n        // Check if the current character is a vowel and surrounded by consonants\n        if (isVowel(currentChar)) {\n            char prevChar = word[i-1], nextChar = word[i+1];\n            \n            // Check if both neighbors are consonants\n            if (!isVowel(prevChar) && !isVowel(nextChar))\n                return string(1, currentChar);\n        }\n    }\n\n    // Return an empty string if no vowel is found that meets the condition\n    return \"\";\n}\n\n"}
{"task_id": "CPP/119", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to check if a given string has balanced parentheses.\nbool is_balanced(const string& s) {\n    int balance = 0;\n    for (char c : s) {\n        if (c == '(') ++balance;\n        else --balance;\n        \n        // If at any point the balance goes negative, it means there are more closing\n        // parentheses than opening ones up to this point.\n        if (balance < 0) return false;\n    }\n    \n    // The string is balanced only if the final count of open and close parentheses match.\n    return balance == 0;\n}\n\nstring match_parens(vector<string> lst){\n    // Check each possible concatenation\n    if(is_balanced(lst[0] + lst[1])) return \"Yes\";\n    if(is_balanced(lst[1] + lst[0])) return \"Yes\";\n    \n    // Also check individual strings for balance, though this is redundant given the problem constraints.\n    if(is_balanced(lst[0])) return \"Yes\";\n    if(is_balanced(lst[1])) return \"Yes\";\n\n    return \"No\";\n}\n\n"}
{"task_id": "CPP/120", "generation": "#include <vector>\n#include <algorithm> // For sort function\n\nusing namespace std;\n\nvector<int> maximum(vector<int> arr, int k) {\n    // Step 1: Sort the array in ascending order.\n    sort(arr.begin(), arr.end());\n    \n    // Step 2: Create a new vector with the last k elements of the sorted array.\n    vector<int> result;\n    for (int i = arr.size() - k; i < arr.size(); ++i) {\n        result.push_back(arr[i]);\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/121", "generation": "#include <vector>\nusing namespace std;\n\nint solution(vector<int> lst) {\n    int sum = 0;\n    \n    // Iterate through the vector with index i.\n    for (size_t i = 0; i < lst.size(); i++) {\n        // Check if the position is even and the element at that position is odd\n        if (i % 2 == 0 && lst[i] % 2 != 0) {\n            sum += lst[i];\n        }\n    }\n    \n    return sum;\n}\n"}
{"task_id": "CPP/122", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint add_elements(vector<int> arr, int k) {\n    // Initialize sum to 0\n    int sum = 0;\n    \n    // Iterate through the first k elements of the array\n    for (int i = 0; i < k; ++i) {\n        // Check if the current element has at most two digits\n        if (arr[i] >= -99 && arr[i] <= 99) { // Considering negative numbers as well\n            sum += arr[i];\n        }\n    }\n\n    return sum;\n}\n\n"}
{"task_id": "CPP/123", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // For std::sort\n\nusing namespace std;\n\nvector<int> get_odd_collatz(int n) {\n    vector<int> odd_numbers;\n    \n    while (n != 1) { // Continue until we reach 1\n        if (n % 2 == 1) { // If the number is odd, add it to our list of odd numbers\n            odd_numbers.push_back(n);\n        }\n        // Apply Collatz rules: n/2 if even, 3*n + 1 if odd\n        n = (n % 2 == 0) ? n / 2 : 3 * n + 1;\n    }\n    \n    // Add the last number in the sequence which is always 1 and is odd.\n    odd_numbers.push_back(1);\n    \n    // Sort the vector of odd numbers\n    sort(odd_numbers.begin(), odd_numbers.end());\n    \n    return odd_numbers;\n}\n\n// Example usage:\n"}
{"task_id": "CPP/124", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool valid_date(string date) {\n    // Check for empty string\n    if (date.empty()) return false;\n    \n    // Check format mm-dd-yyyy\n    if(date.length() != 10 || date[2] != '-' || date[5] != '-') return false;\n    \n    // Extract month, day and year from the string\n    int month = stoi(date.substr(0, 2));\n    int day = stoi(date.substr(3, 2));\n    int year = stoi(date.substr(6, 4));\n\n    // Validate month\n    if (month < 1 || month > 12) return false;\n\n    // Validate day based on the month\n    if ((month == 4 || month == 6 || month == 9 || month == 11) && (day < 1 || day > 30)) {\n        return false;\n    } else if (month != 2 && (day < 1 || day > 31)) {\n        return false;\n    }\n\n    // Validate February\n    if (month == 2) {\n        if (year % 400 == 0 || (year % 4 == 0 && year % 100 != 0)) { // Leap year\n            if(day < 1 || day > 29) return false;\n        } else { // Not a leap year\n            if(day < 1 || day > 28) return false;\n        }\n    }\n\n    return true; // All checks passed, date is valid\n}\n\n"}
{"task_id": "CPP/125", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> split_words(string txt) {\n    vector<string> result;\n    \n    // Check for spaces and commas to split the string.\n    if (txt.find(' ') != string::npos) {\n        size_t start = 0;\n        size_t end = txt.find(' ');\n        while (end != string::npos) {\n            result.push_back(txt.substr(start, end - start));\n            start = end + 1;\n            end = txt.find(' ', start);\n        }\n        // Add the last word\n        result.push_back(txt.substr(start, txt.length() - start));\n    } else if (txt.find(',') != string::npos) {\n        size_t start = 0;\n        size_t end = txt.find(',');\n        while (end != string::npos) {\n            result.push_back(txt.substr(start, end - start));\n            start = end + 1;\n            end = txt.find(',', start);\n        }\n        // Add the last word\n        result.push_back(txt.substr(start, txt.length() - start));\n    } else {\n        // Count lowercase letters with odd order positions in the alphabet.\n        int count = 0;\n        for (char c : txt) {\n            if (islower(c)) {\n                if ((c - 'a') % 2 == 1) {\n                    count++;\n                }\n            }\n        }\n        result.push_back(to_string(count));\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/126", "generation": "#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nbool is_sorted(vector<int> lst) {\n    // Check if the list is empty or has only one element, which means it's sorted.\n    if (lst.size() <= 1) return true;\n    \n    // Initialize a counter for consecutive duplicates and previous number\n    int prev = lst[0];\n    int count = 1;\n\n    for (size_t i = 1; i < lst.size(); ++i) {\n        // Check the ascending order condition\n        if (lst[i] < prev) return false;\n        \n        // Counting consecutive duplicates\n        if (lst[i] == prev) {\n            count++;\n            // If any number appears more than twice, return false.\n            if (count > 2) return false;\n        } else {\n            // Reset the counter for a new number\n            count = 1;\n        }\n        \n        // Update previous number to current one\n        prev = lst[i];\n    }\n\n    // If all checks pass, return true\n    return true;\n}\n"}
{"task_id": "CPP/127", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\n// Function to check if a number is prime.\nbool isPrime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\nstring intersection(vector<int> interval1, vector<int> interval2) {\n    int startMax = max(interval1[0], interval2[0]);\n    int endMin = min(interval1[1], interval2[1]);\n\n    // Check if there is an intersection\n    if (startMax > endMin) return \"NO\";\n\n    // Calculate the length of the intersection\n    int intersectionLength = endMin - startMax + 1;\n\n    // Check if the length is a prime number\n    if (isPrime(intersectionLength)) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n\n"}
{"task_id": "CPP/128", "generation": "#include <vector>\n#include <cmath> // For std::abs\n\nint prod_signs(std::vector<int> arr) {\n    if (arr.empty()) return -32768; // Return special value for empty vector\n    \n    int sign_product = 1;\n    int magnitude_sum = 0;\n\n    for (auto num : arr) {\n        if (num == 0) {\n            sign_product = 0; // If any number is zero, the product of signs will be zero\n            break;\n        }\n        magnitude_sum += std::abs(num); // Sum up the absolute values\n        \n        // Calculate the product of signs\n        if (num < 0) {\n            sign_product *= -1;\n        } else {\n            sign_product *= 1; // This is redundant but for clarity\n        }\n    }\n\n    return sign_product * magnitude_sum;\n}\n\n// Example usage:\n"}
{"task_id": "CPP/129", "generation": "#include <vector>\n#include <queue>\nusing namespace std;\n\n// Directions for moving to adjacent cells (up, down, left, right)\nconst vector<pair<int, int>> directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n\nvector<int> minPath(vector<vector<int>>& grid, int k) {\n    int N = grid.size();\n    \n    // Priority queue to store paths in lexicographical order\n    priority_queue<vector<int>, vector<vector<int>>, greater<>> pq;\n    \n    // Helper function for DFS\n    auto dfs = [&](auto&& self, int x, int y, vector<int> path) {\n        if (path.size() == k) {\n            pq.push(path);\n            return;\n        }\n        \n        for (const auto& [dx, dy] : directions) {\n            int nx = x + dx, ny = y + dy;\n            if (nx >= 0 && nx < N && ny >= 0 && ny < N) {\n                path.push_back(grid[nx][ny]);\n                self(self, nx, ny, path);\n                path.pop_back();\n            }\n        }\n    };\n    \n    // Start DFS from every cell\n    for (int i = 0; i < N; ++i)\n        for (int j = 0; j < N; ++j) {\n            vector<int> initialPath{grid[i][j]};\n            dfs(dfs, i, j, initialPath);\n        }\n    \n    // The top of the priority queue contains the lexicographically smallest path\n    return pq.top();\n}\n\n// Example usage:\n"}
{"task_id": "CPP/130", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvector<int> tri(int n){\n    vector<int> result(n+1);\n    \n    // Base cases as per the problem statement.\n    if (n >= 0) result[0] = 1; // Assuming tri(0) is defined to be 1 for consistency with Fibonacci-like sequences\n    if (n >= 1) result[1] = 3;\n    if (n >= 2) result[2] = 2;\n\n    // Fill the rest of the sequence based on the corrected definition.\n    for(int i = 3; i <= n; ++i){\n        if(i % 2 == 0)\n            result[i] = 1 + i / 2;\n        else\n            result[i] = result[i-1] + result[i-2] + result[i-3];\n    }\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/131", "generation": "#include <iostream>\nusing namespace std;\n\nint digits(int n) {\n    int product = 1;\n    bool hasOddDigit = false; // Flag to check if any odd digit exists\n\n    while (n > 0) {\n        int digit = n % 10; // Extract the last digit\n        if (digit % 2 != 0) { // Check if it's an odd digit\n            product *= digit;\n            hasOddDigit = true;\n        }\n        n /= 10; // Remove the last digit from n\n    }\n\n    return hasOddDigit ? product : 0; // Return 0 if no odd digits were found, else return the product\n}\n\n"}
{"task_id": "CPP/132", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_nested(string str) {\n    int maxDepth = 0;\n    int currentDepth = 0;\n    \n    for (char c : str) {\n        if (c == '[') {\n            currentDepth++;\n            maxDepth = max(maxDepth, currentDepth);\n        } else if (c == ']') {\n            currentDepth--;\n        }\n        \n        // If we find a nested pair, return true\n        if (currentDepth > 0 && c == ']')\n            return true;\n    }\n\n    // No nested pairs found\n    return false;\n}\n\n"}
{"task_id": "CPP/133", "generation": "#include <vector>\n#include <cmath> // for ceil and pow functions\n\nusing namespace std;\n\nint sum_squares(vector<float> lst) {\n    int sum = 0;\n    \n    for (float num : lst) {\n        float rounded_num = ceil(num); // Round up to the nearest integer\n        sum += pow(rounded_num, 2); // Square it and add to sum\n    }\n    \n    return sum;\n}\n"}
{"task_id": "CPP/134", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool check_if_last_char_is_a_letter(string txt) {\n    // Trim trailing spaces from the end of the string\n    while (!txt.empty() && isspace(txt.back())) {\n        txt.pop_back();\n    }\n\n    if (txt.empty()) return false;  // If the string is empty after trimming, return false\n\n    char last_char = txt.back();  // Get the last character\n\n    // Check if it's an alphabetical character\n    if (!isalpha(last_char)) return false;\n\n    // Ensure that this character is not part of any word by checking the previous character\n    if (txt.size() > 1 && isalpha(txt[txt.size() - 2])) {\n        return false;\n    }\n\n    return true;  // The last character is an alphabet and not part of a word\n}\n\n"}
{"task_id": "CPP/135", "generation": "#include <vector>\nusing namespace std;\n\nint can_arrange(vector<int> arr) {\n    int largestIndex = -1;\n    \n    // Iterate through the vector starting from the second element.\n    for (size_t i = 1; i < arr.size(); ++i) {\n        if (arr[i] < arr[i-1]) { // Check if current element is less than its predecessor\n            largestIndex = i; // Update the largest index found so far\n        }\n    }\n\n    return largestIndex;\n}\n\n// Example usage:\n"}
{"task_id": "CPP/136", "generation": "#include <vector>\n#include <climits> // For INT_MIN and INT_MAX\n\nusing namespace std;\n\nvector<int> largest_smallest_integers(vector<int> lst) {\n    int largestNegative = INT_MIN; // Initialize with smallest possible integer value\n    int smallestPositive = INT_MAX; // Initialize with largest possible integer value\n    \n    for (int num : lst) {\n        if (num < 0 && num > largestNegative) {\n            largestNegative = num;\n        } else if (num > 0 && num < smallestPositive) {\n            smallestPositive = num;\n        }\n    }\n\n    // If no negative number was found, set largestNegative to 0\n    if (largestNegative == INT_MIN) {\n        largestNegative = 0;\n    }\n    \n    // If no positive number was found, set smallestPositive to 0\n    if (smallestPositive == INT_MAX) {\n        smallestPositive = 0;\n    }\n\n    return {largestNegative, smallestPositive};\n}\n\n// Example usage:\n"}
{"task_id": "CPP/137", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <boost/any.hpp>\n#include <locale> // For locale support to handle different decimal separators\n\nusing namespace std;\n\n// Function to convert string to float, handling both '.' and ',' as decimal points.\nfloat strToFloat(const string& s) {\n    string temp = s;\n    replace(temp.begin(), temp.end(), ',', '.'); // Replace comma with dot if present\n    return stof(temp);\n}\n\nboost::any compare_one(boost::any a, boost::any b) {\n    float fa, fb;\n\n    try {\n        // Convert both inputs to floats for comparison.\n        if (a.type() == typeid(int)) {\n            fa = any_cast<int>(a);\n        } else if (a.type() == typeid(float)) {\n            fa = any_cast<float>(a);\n        } else if (a.type() == typeid(string)) {\n            fa = strToFloat(any_cast<string>(a));\n        }\n\n        if (b.type() == typeid(int)) {\n            fb = any_cast<int>(b);\n        } else if (b.type() == typeid(float)) {\n            fb = any_cast<float>(b);\n        } else if (b.type() == typeid(string)) {\n            fb = strToFloat(any_cast<string>(b));\n        }\n\n    } catch (...) {\n        return \"None\"; // In case of type conversion failure\n    }\n\n    // Compare the float values and determine which original value to return.\n    if (fa > fb) {\n        return a;\n    } else if (fb > fa) {\n        return b;\n    } else {\n        return string(\"None\"); // Return \"None\" as a string when equal\n    }\n}\n\n"}
{"task_id": "CPP/138", "generation": "#include<iostream>\nusing namespace std;\n\nbool is_equal_to_sum_even(int n) {\n    // Check if n is less than 8 or odd.\n    if (n < 8 || n % 2 != 0) {\n        return false;\n    }\n    // If n >= 8 and even, it can be expressed as the sum of four positive even numbers\n    return true;\n}\n\n"}
{"task_id": "CPP/139", "generation": "#include <iostream>\nusing namespace std;\n\n// Function to calculate factorial of a given number.\nlong long factorial(int num) {\n    if (num == 0 || num == 1)\n        return 1;\n    else\n        return num * factorial(num - 1);\n}\n\n// Function to calculate the Brazilian factorial as defined.\nlong long special_factorial(int n){\n    long long result = 1;\n    for (int i = 1; i <= n; ++i) {\n        result *= factorial(i); // Multiply by each factorial from 1! up to n!\n    }\n    return result;\n}\n\n// Example usage\n"}
{"task_id": "CPP/140", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring fix_spaces(string text) {\n    ostringstream result;\n    int spaceCount = 0; // To count consecutive spaces\n\n    for (char c : text) {\n        if (c == ' ') {\n            ++spaceCount;\n        } else {\n            if (spaceCount > 2) { // More than two consecutive spaces\n                result << '-';\n            } else {\n                while (spaceCount > 0) {\n                    result << '_';\n                    --spaceCount;\n                }\n            }\n            spaceCount = 0; // Reset the count after processing non-space character\n            result << c;\n        }\n    }\n\n    // Handle trailing spaces if any\n    if (spaceCount > 2) {\n        result << '-';\n    } else {\n        while (spaceCount > 0) {\n            result << '_';\n            --spaceCount;\n        }\n    }\n\n    return result.str();\n}\n\n"}
{"task_id": "CPP/141", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool isValidChar(char c) {\n    // Check if the character is a letter (a-z or A-Z)\n    return ('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z');\n}\n\nint countDigits(const string& s) {\n    int count = 0;\n    for (char c : s) {\n        if ('0' <= c && c <= '9') {\n            ++count;\n        }\n    }\n    return count;\n}\n\nstring file_name_check(string file_name){\n    size_t dotPos = file_name.find('.');\n    \n    // Check if there is exactly one dot and it's not at the start or end\n    if (dotPos == string::npos || dotPos == 0 || dotPos == file_name.size() - 1) {\n        return \"No\";\n    }\n    \n    // Extract parts before and after the dot\n    string namePart = file_name.substr(0, dotPos);\n    string extensionPart = file_name.substr(dotPos + 1);\n\n    // Check if the first character of the name part is a letter\n    if (!isValidChar(namePart[0])) {\n        return \"No\";\n    }\n\n    // Count digits in the name part and ensure it's not more than three\n    int digitCount = countDigits(namePart);\n    if (digitCount > 3) {\n        return \"No\";\n    }\n    \n    // Check for valid extension\n    string validExtensions[] = {\"txt\", \"exe\", \"dll\"};\n    bool isValidExtension = false;\n    for (const auto& ext : validExtensions) {\n        if (extensionPart == ext) {\n            isValidExtension = true;\n            break;\n        }\n    }\n\n    return isValidExtension ? \"Yes\" : \"No\";\n}\n\n"}
{"task_id": "CPP/142", "generation": "#include <vector>\nusing namespace std;\n\nint sum_squares(vector<int> lst) {\n    int sum = 0;\n    \n    for (size_t i = 0; i < lst.size(); ++i) {\n        if (i % 3 == 0 && i != 0) { // Check if index is a multiple of 3 and not zero\n            sum += lst[i] * lst[i]; // Square the element\n        } else if (i % 4 == 0) {    // Check if index is a multiple of 4\n            sum += lst[i] * lst[i] * lst[i]; // Cube the element\n        } else {\n            sum += lst[i]; // Add the element as it is\n        }\n    }\n\n    return sum;\n}\n\n// Example usage:\n"}
{"task_id": "CPP/143", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\nstring words_in_sentence(string sentence) {\n    stringstream ss(sentence);\n    string word, result;\n    \n    while (ss >> word) { // Extract each word from the sentence\n        if (is_prime(word.length())) { // Check if length is prime\n            if (!result.empty()) result += \" \"; // Add space before appending new word\n            result += word; // Append the word to the result string\n        }\n    }\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/144", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nbool simplify(string x, string n) {\n    // Parse fractions\n    size_t slashPos;\n    \n    int numX = stoi(x.substr(0, (slashPos = x.find('/'))));\n    int denX = stoi(x.substr(slashPos + 1));\n\n    int numN = stoi(n.substr(0, (slashPos = n.find('/'))));\n    int denN = stoi(n.substr(slashPos + 1));\n\n    // Calculate the product of the fractions\n    int numeratorProduct = numX * numN;\n    int denominatorProduct = denX * denN;\n\n    // Check if the result is a whole number\n    return (numeratorProduct % denominatorProduct == 0);\n}\n\n"}
{"task_id": "CPP/145", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // For std::stable_sort\n\nint sum_of_digits(int num) {\n    int sum = 0;\n    while (num != 0) {\n        sum += num % 10;\n        num /= 10;\n    }\n    return sum;\n}\n\nbool compare_by_digit_sum(const int& a, const int& b, const std::vector<int>& original) {\n    // Calculate the digit sums\n    int sum_a = sum_of_digits(a);\n    int sum_b = sum_of_digits(b);\n\n    if (sum_a == sum_b) {\n        // If sums are equal, compare their positions in the original vector\n        return &a < &b;\n    }\n    return sum_a < sum_b;\n}\n\nvector<int> order_by_points(vector<int> nums) {\n    std::stable_sort(nums.begin(), nums.end(), [&](const int& a, const int& b){\n        // Use lambda to capture the compare function and original vector\n        return compare_by_digit_sum(a, b, nums);\n    });\n    return nums;\n}\n\n// Example usage:\n"}
{"task_id": "CPP/146", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nbool isFirstAndLastDigitOdd(int num) {\n    // Convert number to string for easy digit extraction\n    string strNum = to_string(abs(num));  // Use abs to handle negative numbers\n\n    char firstDigit = strNum[0];\n    char lastDigit = strNum[strNum.length() - 1];\n\n    int firstDigitInt = firstDigit - '0';\n    int lastDigitInt = lastDigit - '0';\n\n    return (firstDigitInt % 2 != 0) && (lastDigitInt % 2 != 0);\n}\n\nint specialFilter(vector<int> nums){\n    int count = 0;\n    for(int num : nums) {\n        if(num > 10 && isFirstAndLastDigitOdd(num)) {\n            ++count;\n        }\n    }\n    return count;\n}\n\n// Function to test the solution\nvoid test() {\n    cout << specialFilter({15, -73, 14, -15}) << endl; // Expected output: 1\n    cout << specialFilter({33, -2, -3, 45, 21, 109}) << endl; // Expected output: 2\n}\n\n"}
{"task_id": "CPP/147", "generation": "#include<iostream>\n#include<vector>\nusing namespace std;\n\nint get_max_triples(int n) {\n    vector<int> a(n);\n    \n    // Generate the array based on the given formula.\n    for (int i = 0; i < n; ++i) {\n        a[i] = (i + 1) * (i + 1) - (i + 1) + 1;\n    }\n    \n    int count = 0;\n\n    // Iterate through all possible triples\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            for (int k = j + 1; k < n; ++k) {\n                if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                    count++;\n                }\n            }\n        }\n    }\n\n    return count;\n}\n\n// Function to check the correctness of the solution\nvoid check_solution() {\n    int test_cases[] = {5, 6};\n    int expected_results[] = {1, 4};\n\n    for (int i = 0; i < sizeof(test_cases) / sizeof(int); ++i) {\n        int result = get_max_triples(test_cases[i]);\n        if (result == expected_results[i]) {\n            cout << \"Test case \" << test_cases[i] << \": Passed\" << endl;\n        } else {\n            cout << \"Test case \" << test_cases[i] << \": Failed. Expected \" << expected_results[i] << \", got \" << result << endl;\n        }\n    }\n}\n\n"}
{"task_id": "CPP/148", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> bf(string planet1, string planet2) {\n    // List of planets in order from closest to farthest from the Sun.\n    vector<string> planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n    \n    int index1 = -1, index2 = -1;\n    \n    // Find indices of planet1 and planet2 in the list.\n    for (int i = 0; i < planets.size(); ++i) {\n        if (planets[i] == planet1)\n            index1 = i;\n        else if (planets[i] == planet2)\n            index2 = i;\n        \n        // If both indices are found, break the loop.\n        if (index1 != -1 && index2 != -1)\n            break;\n    }\n    \n    // Check if either of the planets was not found in the list.\n    if (index1 == -1 || index2 == -1) {\n        return {};  // Return an empty vector if any planet is invalid.\n    }\n\n    // Ensure index1 < index2 for simplicity.\n    if (index1 > index2)\n        swap(index1, index2);\n    \n    // Collect planets between the two indices.\n    vector<string> result;\n    for (int i = index1 + 1; i < index2; ++i) {\n        result.push_back(planets[i]);\n    }\n    \n    return result;\n}\n\n// Function to test the bf function with given examples\nvoid check() {\n    auto res1 = bf(\"Jupiter\", \"Neptune\");\n    for (const auto& planet : res1)\n        cout << planet << \" \";\n    cout << endl;\n\n    auto res2 = bf(\"Earth\", \"Mercury\");\n    for (const auto& planet : res2)\n        cout << planet << \" \";\n    cout << endl;\n\n    auto res3 = bf(\"Mercury\", \"Uranus\");\n    for (const auto& planet : res3)\n        cout << planet << \" \";\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/149", "generation": "#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to sort and filter a vector of strings based on given criteria.\nvector<string> sorted_list_sum(vector<string> lst) {\n    // Remove elements with odd lengths from the list.\n    auto end = remove_if(lst.begin(), lst.end(), [](const string& s){ return s.size() % 2 != 0; });\n    lst.erase(end, lst.end());\n\n    // Sort the vector by length and then alphabetically if lengths are equal\n    sort(lst.begin(), lst.end(), [](const string& a, const string& b) {\n        if (a.length() == b.length()) return a < b;\n        else return a.length() < b.length();\n    });\n\n    return lst;\n}\n\n// Example usage:\n"}
{"task_id": "CPP/150", "generation": "#include <iostream>\nusing namespace std;\n\n// Helper function to check if n is a prime number\nbool is_prime(int n) {\n    // Handle edge cases: 0, 1 and negative numbers are not primes.\n    if (n <= 1) return false;\n    \n    // Check divisibility from 2 up to the square root of n.\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0)\n            return false;\n    }\n    return true;\n}\n\n// Main function as described\nint x_or_y(int n, int x, int y){\n    // Use the is_prime helper to decide which value to return.\n    return is_prime(n) ? x : y;\n}\n\n// Function to test the correctness of the solution\nvoid check() {\n    cout << \"x_or_y(7, 34, 12): Expected: 34, Actual: \" << x_or_y(7, 34, 12) << endl;\n    cout << \"x_or_y(15, 8, 5): Expected: 5, Actual: \" << x_or_y(15, 8, 5) << endl;\n}\n\n"}
{"task_id": "CPP/151", "generation": "#include <vector>\nusing namespace std;\n\nlong long double_the_difference(vector<float> lst) {\n    long long sum = 0;\n    \n    for (float num : lst) {\n        // Check if the number is positive, an integer, and odd.\n        if (num > 0 && floor(num) == num && static_cast<int>(num) % 2 != 0) {\n            int n = static_cast<int>(num);\n            sum += n * n; // Add square of the number to sum\n        }\n    }\n\n    return sum;\n}\n"}
{"task_id": "CPP/152", "generation": "#include <iostream>\n#include <vector>\n#include <cmath> // For std::abs\n\nusing namespace std;\n\nvector<int> compare(vector<int> game, vector<int> guess) {\n    vector<int> result;\n    \n    // Iterate through each element of the vectors.\n    for (size_t i = 0; i < game.size(); ++i) {\n        int diff = abs(game[i] - guess[i]); // Calculate absolute difference\n        result.push_back(diff);             // Add to result vector\n    }\n    \n    return result;\n}\n\n// Function to test the compare function with given data points.\nvoid check() {\n    vector<int> game1 = {1, 2, 3, 4, 5, 1};\n    vector<int> guess1 = {1, 2, 3, 4, 2, -2};\n    vector<int> expected1 = {0, 0, 0, 0, 3, 3};\n    \n    vector<int> game2 = {0, 5, 0, 0, 0, 4};\n    vector<int> guess2 = {4, 1, 1, 0, 0, -2};\n    vector<int> expected2 = {4, 4, 1, 0, 0, 6};\n\n    assert(compare(game1, guess1) == expected1);\n    assert(compare(game2, guess2) == expected2);\n\n    cout << \"All tests passed successfully.\" << endl;\n}\n\n"}
{"task_id": "CPP/153", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nint calculateStrength(const string& ext) {\n    int CAP = 0, SM = 0;\n    for (char c : ext) {\n        if (isupper(c)) CAP++;\n        else if (islower(c)) SM++;\n    }\n    return CAP - SM;\n}\n\nstring Strongest_Extension(string class_name, vector<string> extensions){\n    string strongest_ext = \"\";\n    int max_strength = INT_MIN;\n\n    for (const auto& ext : extensions) {\n        int strength = calculateStrength(ext);\n        if (strength > max_strength || (strength == max_strength && strongest_ext.empty())) {\n            max_strength = strength;\n            strongest_ext = ext;\n        }\n    }\n\n    return class_name + \".\" + strongest_ext;\n}\n\n"}
{"task_id": "CPP/154", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool cycpattern_check(string a, string b) {\n    // Concatenate 'a' with itself.\n    string doubled_a = a + a;\n    \n    // Check if 'b' is a substring of the concatenated string.\n    return doubled_a.find(b) != string::npos;\n}\n\n"}
{"task_id": "CPP/155", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> even_odd_count(int num) {\n    // Initialize counters for even and odd digits.\n    int evenCount = 0;\n    int oddCount = 0;\n\n    // Handle negative numbers by converting to positive.\n    if (num < 0) {\n        num = -num;\n    }\n\n    // Iterate through each digit of the number.\n    while (num > 0) {\n        int digit = num % 10; // Get the last digit\n        if (digit % 2 == 0) { // Check if it's even\n            evenCount++;\n        } else {              // Otherwise, it's odd\n            oddCount++;\n        }\n        num /= 10; // Remove the last digit from num\n    }\n\n    // Return a vector containing counts of even and odd digits.\n    return {evenCount, oddCount};\n}\n\n// Function to test the solution with given examples.\nvoid check() {\n    vector<int> result = even_odd_count(-12);\n    cout << \"even_odd_count(-12) -> {\" << result[0] << \", \" << result[1] << \"}\\n\";\n    \n    result = even_odd_count(123);\n    cout << \"even_odd_count(123) -> {\" << result[0] << \", \" << result[1] << \"}\\n\";\n}\n\n"}
{"task_id": "CPP/156", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring int_to_mini_roman(int number) {\n    // Define arrays for Roman numerals in descending order.\n    const string thousands[] = {\"\", \"m\", \"mm\", \"mmm\"};\n    const string hundreds[]  = {\"\", \"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"};\n    const string tens[]      = {\"\", \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\"};\n    const string ones[]      = {\"\", \"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\", \"ix\"};\n\n    // Construct the Roman numeral by combining parts for thousands, hundreds, tens, and ones.\n    return thousands[number / 1000] + \n           hundreds[(number % 1000) / 100] +\n           tens[(number % 100) / 10] +\n           ones[number % 10];\n}\n\n"}
{"task_id": "CPP/157", "generation": "#include <iostream>\n#include <cmath>\n\nbool right_angle_triangle(float a, float b, float c) {\n    // First, sort the sides so that c is the longest side (hypotenuse)\n    if (a > c) std::swap(a, c);\n    if (b > c) std::swap(b, c);\n\n    // Check the Pythagorean theorem: a^2 + b^2 = c^2\n    return fabs(a*a + b*b - c*c) < 1e-6; // Using a small threshold for floating point comparison\n}\n\n"}
{"task_id": "CPP/158", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <set>\nusing namespace std;\n\nstring find_max(vector<string> words) {\n    string max_word = \"\";\n    int max_unique_count = 0;\n    \n    for (const auto& word : words) {\n        set<char> unique_chars(word.begin(), word.end());\n        \n        // Count of unique characters in the current word\n        int unique_count = unique_chars.size();\n        \n        if (unique_count > max_unique_count || \n            (unique_count == max_unique_count && word < max_word)) {\n            max_unique_count = unique_count;\n            max_word = word;\n        }\n    }\n\n    return max_word;\n}\n\n"}
{"task_id": "CPP/159", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> eat(int number, int need, int remaining) {\n    // Calculate how many more carrots can be eaten based on what is needed and available.\n    int actualEaten = min(need, remaining);\n    \n    // Update the total number of carrots eaten.\n    int totalEaten = number + actualEaten;\n    \n    // Subtract the eaten carrots from the stock to get the new count of remaining carrots.\n    int newRemaining = remaining - actualEaten;\n\n    return {totalEaten, newRemaining};\n}\n"}
{"task_id": "CPP/160", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nint do_algebra(vector<string> operato, vector<int> operand) {\n    // Start with the first operand as the initial value of result.\n    int result = operand[0];\n    \n    // Iterate through each operator and apply it to the current result and next operand.\n    for (size_t i = 0; i < operato.size(); ++i) {\n        if (operato[i] == \"+\") {\n            result += operand[i + 1];\n        } else if (operato[i] == \"-\") {\n            result -= operand[i + 1];\n        } else if (operato[i] == \"*\") {\n            result *= operand[i + 1];\n        } else if (operato[i] == \"//\") {\n            // Floor division\n            result = floor(static_cast<double>(result) / operand[i + 1]);\n        } else if (operato[i] == \"**\") {\n            result = pow(result, operand[i + 1]);\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/161", "generation": "#include <iostream>\n#include <string>\n#include <cctype> // For isalpha and toupper/tolower functions\n\nusing namespace std;\n\nstring solve(string s) {\n    bool hasLetters = false;\n    \n    // Check if there are any letters in the string.\n    for (char c : s) {\n        if (isalpha(c)) {\n            hasLetters = true;\n            break;\n        }\n    }\n\n    // If no letters, reverse the entire string\n    if (!hasLetters) {\n        reverse(s.begin(), s.end());\n        return s;\n    }\n\n    // Otherwise, change the case of each letter.\n    for (char &c : s) {\n        if (isalpha(c)) {\n            if (islower(c))\n                c = toupper(c);\n            else\n                c = tolower(c);\n        }\n    }\n\n    return s;\n}\n\n"}
{"task_id": "CPP/162", "generation": "#include <iostream>\n#include <string>\n#include <openssl/md5.h>\n\nusing namespace std;\n\nstring string_to_md5(string text) {\n    if (text.empty()) return \"None\"; // Return \"None\" for empty strings\n\n    unsigned char digest[MD5_DIGEST_LENGTH];\n    MD5((unsigned char*)text.c_str(), text.length(), (unsigned char*)&digest);    \n\n    char mdString[33];\n    for(int i = 0; i < 16; ++i)\n        sprintf(&mdString[i*2], \"%02x\", (unsigned int)digest[i]);\n\n    return string(mdString);\n}\n\n"}
{"task_id": "CPP/163", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> generate_integers(int a, int b) {\n    vector<int> result;\n    \n    // Ensure that start <= end for the loop\n    if (a > b) swap(a, b);\n    \n    // Loop through all numbers from a to b and check each digit\n    for (int num = a; num <= b; ++num) {\n        int temp = num;\n        \n        while(temp != 0) {\n            int digit = temp % 10; // Get the last digit of the number\n            \n            if(digit % 2 == 0 && find(result.begin(), result.end(), digit) == result.end()) {\n                // If it's an even digit and not already in the vector, add it\n                result.push_back(digit);\n            }\n            \n            temp /= 10; // Remove the last digit from the number\n        }\n    }\n\n    // Sort the result to ensure ascending order\n    sort(result.begin(), result.end());\n    \n    return result;\n}\n\n// Function to test the solution with given examples\nvoid check() {\n    vector<int> res;\n\n    res = generate_integers(2, 8);\n    for(int num : res) cout << num << \" \";\n    cout << endl;\n\n    res = generate_integers(8, 2);\n    for(int num : res) cout << num << \" \";\n    cout << endl;\n\n    res = generate_integers(10, 14);\n    for(int num : res) cout << num << \" \";\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/0", "generation": "#include <algorithm> // For std::sort\n\nbool has_close_elements(std::vector<float> numbers, float threshold) {\n    if (numbers.size() < 2) return false; // If there are less than two elements, we can't have any pairs.\n\n    // Sort the vector to bring closer elements next to each other.\n    std::sort(numbers.begin(), numbers.end());\n\n    for(size_t i = 0; i < numbers.size() - 1; ++i) {\n        if (std::abs(numbers[i] - numbers[i + 1]) < threshold) {\n            return true;\n        }\n    }\n\n    return false;\n}\n"}
{"task_id": "CPP/1", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> separate_paren_groups(string paren_string){\n    vector<string> result;\n    int balance = 0; // Keeps track of open parentheses\n    string current_group = \"\"; // Current group being processed\n\n    for (char c : paren_string) {\n        if (c == '(' || c == ')') { // Ignore spaces and only consider parentheses\n            current_group += c; // Add the character to the current group\n            balance += (c == '(' ? 1 : -1); // Update balance based on the character\n\n            if (balance == 0) { // When balance is zero, a complete group has been found\n                result.push_back(current_group);\n                current_group = \"\"; // Reset for the next group\n            }\n        }\n    }\n\n    return result;\n}\n\n// Function to test the solution with provided data points\nvoid check() {\n    vector<string> expected1 = {\"()\", \"(())\", \"(()())\"};\n    assert(separate_paren_groups(\"( ) (( )) (( )( ))\") == expected1);\n\n    // Additional checks can be added here as needed\n\n    cout << \"All tests passed successfully.\" << endl;\n}\n\n"}
{"task_id": "CPP/2", "generation": "#include<stdio.h>\n#include<math.h>\n\nfloat truncate_number(float number){\n    float integerPart = floor(number);\n    return number - integerPart;\n}\n\n"}
{"task_id": "CPP/3", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nbool below_zero(vector<int> operations) {\n    int balance = 0; // Start with a zero balance\n\n    for (int op : operations) { // Iterate through each operation\n        balance += op; // Update the balance according to the current operation\n        \n        if (balance < 0) { // Check if balance falls below zero\n            return true;\n        }\n    }\n\n    return false; // Return false if no point in time the balance was below zero\n}\n\n"}
{"task_id": "CPP/4", "generation": "#include <iostream>\n#include <vector>\n#include <numeric> // for std::accumulate\n#include <cmath>   // for std::abs\n\nusing namespace std;\n\nfloat mean_absolute_deviation(vector<float> numbers) {\n    if (numbers.empty()) return 0.0f; // Handle empty vector case\n    \n    float sum = accumulate(numbers.begin(), numbers.end(), 0.0f);\n    float mean = sum / numbers.size();\n    \n    float mad_sum = 0.0f;\n    for (float num : numbers) {\n        mad_sum += std::abs(num - mean); // Calculate the absolute difference and add it to the sum\n    }\n    \n    return mad_sum / numbers.size(); // Average of all absolute differences\n}\n\n"}
{"task_id": "CPP/5", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> intersperse(vector<int> numbers, int delimeter) {\n    vector<int> result;\n    \n    // If the input vector is empty, return it as is.\n    if (numbers.empty()) {\n        return result;\n    }\n    \n    // Iterate through each element in the input vector\n    for(size_t i = 0; i < numbers.size(); ++i) {\n        // Add the current number to the result vector\n        result.push_back(numbers[i]);\n        \n        // If it's not the last element, add the delimiter after it.\n        if (i != numbers.size() - 1) {\n            result.push_back(delimeter);\n        }\n    }\n\n    return result;\n}\n\n// Example usage:\n"}
{"task_id": "CPP/6", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<int> parse_nested_parens(string paren_string) {\n    vector<int> max_depths;\n    int current_depth = 0, max_depth = 0;\n    \n    for (char c : paren_string) {\n        if (c == '(') {\n            // Increase depth when encountering an opening parenthesis\n            ++current_depth;\n            // Update the maximum depth found so far in this group\n            if (current_depth > max_depth)\n                max_depth = current_depth;\n        } else if (c == ')') {\n            // Decrease depth when encountering a closing parenthesis\n            --current_depth;\n        } else if (c == ' ') {\n            // When we encounter a space, it means the end of one group.\n            // Add the maximum depth found for this group to our result vector,\n            // and reset max_depth and current_depth for the next group.\n            max_depths.push_back(max_depth);\n            max_depth = 0;\n            current_depth = 0;\n        }\n    }\n\n    // Handle the last group if there is no trailing space\n    if (max_depth > 0) {\n        max_depths.push_back(max_depth);\n    }\n\n    return max_depths;\n}\n\n"}
{"task_id": "CPP/7", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\n// Function to filter strings containing a specific substring.\nvector<string> filter_by_substring(vector<string> strings, string substring) {\n    vector<string> filteredStrings; // Vector to store the result.\n\n    for (const auto& str : strings) { // Iterate through each string in the input vector.\n        if (str.find(substring) != string::npos) { // Check if the current string contains the substring.\n            filteredStrings.push_back(str); // If it does, add it to the result vector.\n        }\n    }\n\n    return filteredStrings; // Return the filtered list of strings.\n}\n\n// Function to test the filter_by_substring function with given data points.\nvoid check() {\n    vector<string> empty;\n    auto res1 = filter_by_substring(empty, \"a\");\n    assert(res1.empty()); // Should be an empty vector.\n\n    vector<string> input2{\"abc\", \"bacd\", \"cde\", \"vector\"};\n    auto res2 = filter_by_substring(input2, \"a\");\n    vector<string> expected2{\"abc\", \"bacd\", \"vector\"};\n    assert(res2 == expected2); // Should match the expected result.\n\n    cout << \"All tests passed successfully.\" << endl;\n}\n\n"}
{"task_id": "CPP/8", "generation": "#include <iostream>\n#include <vector>\n#include <utility> // For std::pair\n\nusing namespace std;\n\n// Function to calculate sum and product of elements in a vector.\nstd::pair<int, int> sum_product(vector<int> numbers) {\n    int sum = 0;\n    int product = 1; // Product starts at 1 because multiplying by 1 doesn't change the value.\n\n    for (int num : numbers) {\n        sum += num;\n        product *= num;\n    }\n\n    return std::make_pair(sum, product);\n}\n\n// Function to test the correctness of the solution.\nvoid check() {\n    auto result = sum_product({});\n    cout << \"Sum: \" << result.first << \", Product: \" << result.second << endl; // Expected (0, 1)\n\n    result = sum_product({1, 2, 3, 4});\n    cout << \"Sum: \" << result.first << \", Product: \" << result.second << endl; // Expected (10, 24)\n}\n\n"}
{"task_id": "CPP/9", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> rolling_max(vector<int> numbers) {\n    // Check if the input vector is empty to avoid undefined behavior.\n    if (numbers.empty()) return {};\n\n    vector<int> result;\n    int currentMax = numbers[0];  // Initialize with the first element of the sequence.\n\n    for (int num : numbers) {\n        // Update the current maximum value if the current number is greater than it.\n        if (num > currentMax) {\n            currentMax = num;\n        }\n        // Append the current maximum to the result vector.\n        result.push_back(currentMax);\n    }\n\n    return result;\n}\n\n// Example usage\n"}
{"task_id": "CPP/10", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_palindrome(string str){\n    // Test if given string is a palindrome \n    string s(str.rbegin(),str.rend());\n    return s==str;\n}\n\nstring make_palindrome(string str){\n    /*\n    Find the shortest palindrome that begins with a supplied string. \n    Algorithm idea is simple: - Find the longest postfix of supplied string that is a palindrome. \n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    */\n    \n    int n = str.length();\n    for (int i = 0; i < n; ++i) {\n        if (is_palindrome(str.substr(i))) { // Check from each position if it forms a palindrome\n            return str + string(str.rbegin(), str.rbegin() + i); // Append the reverse of the prefix before palindromic suffix\n        }\n    }\n    return \"\";  // This line should theoretically never be reached.\n}\n\n"}
{"task_id": "CPP/11", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring string_xor(string a, string b) {\n    // Ensure both strings are of equal length by padding with zeros if necessary.\n    int len_a = a.length();\n    int len_b = b.length();\n\n    // Pad the shorter string with leading '0's to match lengths\n    while (len_a < len_b) { a = \"0\" + a; ++len_a; }\n    while (len_b < len_a) { b = \"0\" + b; ++len_b; }\n\n    string result;\n    \n    // Perform XOR on each pair of characters and append to the result\n    for(int i = 0; i < len_a; ++i){\n        if(a[i] == b[i]) {\n            result += '0'; // If both are same, XOR is 0\n        } else {\n            result += '1'; // If different, XOR is 1\n        }\n    }\n\n    return result;\n}\n\n// Function to test the string_xor function\nvoid check() {\n    cout << (string_xor(\"010\", \"110\") == \"100\" ? \"Test Passed\\n\" : \"Test Failed\\n\");\n}\n\n"}
{"task_id": "CPP/12", "generation": "#include <vector>\n#include <string>\nusing namespace std;\n\nstring longest(vector<string> strings) {\n    if (strings.empty()) return \"\"; // Return an empty string to represent None\n\n    string maxString = strings[0]; // Assume the first string is the longest initially\n    size_t maxLength = maxString.length();\n\n    for (size_t i = 1; i < strings.size(); ++i) { // Start from the second element\n        if (strings[i].length() > maxLength) {\n            maxString = strings[i];\n            maxLength = strings[i].length();\n        }\n    }\n\n    return maxString;\n}\n"}
{"task_id": "CPP/13", "generation": "#include <stdio.h>\n\nint greatest_common_divisor(int a, int b) {\n    while (b != 0) {\n        int temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n\n// Example usage:\n/*\n"}
{"task_id": "CPP/14", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> all_prefixes(string str){\n    vector<string> prefixes;\n    for(size_t i = 0; i < str.length(); ++i) {\n        // Create a substring from the start to the current position (inclusive)\n        string prefix = str.substr(0, i + 1);\n        // Add this prefix to the vector\n        prefixes.push_back(prefix);\n    }\n    return prefixes;\n}\n\n// Example usage:\n"}
{"task_id": "CPP/15", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nstring string_sequence(int n) {\n    string result = \"\";\n    \n    for (int i = 0; i <= n; ++i) {\n        // Convert integer to string and append it to the result string.\n        result += to_string(i);\n        \n        // Add a space after each number except the last one\n        if (i < n) {\n            result += \" \";\n        }\n    }\n\n    return result;\n}\n\n// Function to test the correctness of the solution\nvoid check() {\n    cout << (string_sequence(0) == \"0\" ? \"Test 1 Passed\\n\" : \"Test 1 Failed\\n\");\n    cout << (string_sequence(5) == \"0 1 2 3 4 5\" ? \"Test 2 Passed\\n\" : \"Test 2 Failed\\n\");\n}\n\n"}
{"task_id": "CPP/16", "generation": "#include <iostream>\n#include <set>\n#include <string>\nusing namespace std;\n\nint count_distinct_characters(string str) {\n    // Convert string to lower case for case-insensitive comparison\n    transform(str.begin(), str.end(), str.begin(), ::tolower);\n    \n    // Use a set to store unique characters\n    set<char> distinctChars;\n    \n    // Iterate through each character and add it to the set\n    for (char c : str) {\n        distinctChars.insert(c);\n    }\n    \n    // The size of the set is the number of distinct characters\n    return distinctChars.size();\n}\n\n"}
{"task_id": "CPP/17", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<int> parse_music(string music_string){\n    vector<int> beats;\n    int i = 0;\n    \n    while (i < music_string.length()) {\n        if(music_string[i] == 'o') { // Check for whole note\n            if(i + 1 < music_string.length() && music_string[i+1] == '|') {\n                beats.push_back(2); // Half note\n                i += 2; // Skip the next character as well since it's part of the half note\n            } else {\n                beats.push_back(4); // Whole note\n                i++;\n            }\n        } else if(music_string[i] == '.') { // Check for quarter note\n            if(i + 1 < music_string.length() && music_string[i+1] == '|') {\n                beats.push_back(1); // Quarter note\n                i += 2; // Skip the next character as well since it's part of the quarter note\n            } else {\n                cout << \"Invalid input: Expected '|' after '.'\" << endl;\n                return vector<int>(); // Return an empty vector in case of invalid input\n            }\n        } else if(music_string[i] == ' ') { // Skip spaces\n            i++;\n        } else {\n            cout << \"Invalid character encountered: \" << music_string[i] << endl;\n            return vector<int>(); // Return an empty vector in case of invalid input\n        }\n    }\n\n    return beats;\n}\n\n"}
{"task_id": "CPP/18", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint how_many_times(string str, string substring) {\n    if (substring.empty() || str.empty()) return 0; // If either string is empty, no matches are possible.\n    \n    int count = 0;\n    size_t pos = 0;\n    \n    while ((pos = str.find(substring, pos)) != string::npos) { // Find the substring starting from 'pos'.\n        ++count; // Increment count for each match found.\n        ++pos;   // Move to the next character after the current match to find overlapping occurrences.\n    }\n    \n    return count;\n}\n\n"}
{"task_id": "CPP/19", "generation": "#include <iostream>\n#include <string>\n#include <vector>\n#include <map>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to sort numbers given as words from \"zero\" to \"nine\"\nstring sort_numbers(string numbers) {\n    // Mapping of number words to their numeric values\n    map<string, int> num_map = {\n        {\"zero\", 0}, {\"one\", 1}, {\"two\", 2}, {\"three\", 3},\n        {\"four\", 4}, {\"five\", 5}, {\"six\", 6}, {\"seven\", 7},\n        {\"eight\", 8}, {\"nine\", 9}\n    };\n\n    // Reverse mapping for converting numeric values back to words\n    map<int, string> reverse_map;\n    for (auto &p : num_map) {\n        reverse_map[p.second] = p.first;\n    }\n\n    // Split the input string into individual number words\n    vector<string> num_words;\n    string word;\n    for (char c : numbers) {\n        if (c == ' ') {\n            if (!word.empty()) {\n                num_words.push_back(word);\n                word.clear();\n            }\n        } else {\n            word += c;\n        }\n    }\n    if (!word.empty()) {\n        num_words.push_back(word);\n    }\n\n    // Sort the number words based on their numeric values\n    sort(num_words.begin(), num_words.end(),\n         [&num_map](const string &a, const string &b) { return num_map[a] < num_map[b]; });\n\n    // Convert back to a space-delimited string of sorted number words\n    string result;\n    for (size_t i = 0; i < num_words.size(); ++i) {\n        if (i > 0) result += \" \";\n        result += reverse_map[num_map[num_words[i]]];\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/20", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // For std::sort\n\nusing namespace std;\n\npair<float, float> find_closest_elements(vector<float> numbers) {\n    // Sort the vector to make it easier to find the closest elements.\n    sort(numbers.begin(), numbers.end());\n\n    float min_diff = numeric_limits<float>::max();\n    pair<float, float> closest_pair;\n\n    // Iterate through the sorted list and find the minimum difference between consecutive elements\n    for (size_t i = 0; i < numbers.size() - 1; ++i) {\n        float diff = numbers[i + 1] - numbers[i];\n        if (diff < min_diff) {\n            min_diff = diff;\n            closest_pair = {numbers[i], numbers[i + 1]};\n        }\n    }\n\n    return closest_pair;\n}\n\n"}
{"task_id": "CPP/21", "generation": "#include <vector>\n#include <algorithm> // for std::min_element and std::max_element\n\nusing namespace std;\n\nvector<float> rescale_to_unit(vector<float> numbers){\n    float min_val = *std::min_element(numbers.begin(), numbers.end());\n    float max_val = *std::max_element(numbers.begin(), numbers.end());\n\n    vector<float> scaled_numbers;\n    for (float num : numbers) {\n        // Apply the linear transformation\n        float scaled_num = (num - min_val) / (max_val - min_val);\n        scaled_numbers.push_back(scaled_num);\n    }\n\n    return scaled_numbers;\n}\n\n// Example usage:\n"}
{"task_id": "CPP/22", "generation": "#include <iostream>\n#include <vector>\n#include <list>\n#include <boost/any.hpp>\n\ntypedef std::list<boost::any> list_any;\n\nstd::vector<int> filter_integers(list_any values) {\n    std::vector<int> integers;\n    \n    for (auto it = values.begin(); it != values.end(); ++it) {\n        if (it->type() == typeid(int)) { // Check if the type is int\n            integers.push_back(boost::any_cast<int>(*it)); // Cast and add to vector\n        }\n    }\n\n    return integers;\n}\n\n"}
{"task_id": "CPP/23", "generation": "#include <iostream>\n#include <string>\n\nint stringLength(const std::string& str) {\n    return str.length();\n}\n\n"}
{"task_id": "CPP/24", "generation": "#include<stdio.h>\n\nint largest_divisor(int n) {\n    // Start from half of n because no number greater than n/2 can be a divisor of n (except n itself)\n    for (int i = n / 2; i >= 1; --i) {\n        if (n % i == 0) {\n            return i;\n        }\n    }\n    // If no divisor is found, which theoretically shouldn't happen unless n <= 1\n    return -1;\n}\n\n"}
{"task_id": "CPP/25", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvector<int> factorize(int n) {\n    vector<int> factors;\n    \n    // Divide by 2 until odd\n    while (n % 2 == 0) {\n        factors.push_back(2);\n        n /= 2;\n    }\n    \n    // Check for odd factors from 3 onwards\n    for (int i = 3; i * i <= n; i += 2) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n    \n    // If n is a prime number greater than 2\n    if (n > 2) {\n        factors.push_back(n);\n    }\n\n    return factors;\n}\n\n"}
{"task_id": "CPP/26", "generation": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nvector<int> remove_duplicates(vector<int> numbers) {\n    unordered_map<int, int> occurrences;\n    \n    // Count the occurrences of each number.\n    for (int num : numbers) {\n        occurrences[num]++;\n    }\n    \n    vector<int> result;\n    \n    // Add to result only those elements that occur once.\n    for (int num : numbers) {\n        if (occurrences[num] == 1) {\n            result.push_back(num);\n        }\n    }\n    \n    return result;\n}\n\n// Function to print the vector\nvoid print_vector(const vector<int>& v) {\n    cout << \"{\";\n    for(size_t i = 0; i < v.size(); ++i) {\n        cout << v[i];\n        if (i != v.size() - 1) cout << \", \";\n    }\n    cout << \"}\" << endl;\n}\n\n"}
{"task_id": "CPP/27", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring flip_case(string str) {\n    for (size_t i = 0; i < str.length(); ++i) {\n        if (isupper(str[i])) {\n            // Convert uppercase to lowercase\n            str[i] = tolower(str[i]);\n        } else if (islower(str[i])) {\n            // Convert lowercase to uppercase\n            str[i] = toupper(str[i]);\n        }\n    }\n    return str;\n}\n\n"}
{"task_id": "CPP/28", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring concatenate(vector<string> strings) {\n    // Initialize an empty string for storing the concatenated result.\n    string result = \"\";\n    \n    // Iterate through each element in the vector and append it to the result.\n    for (const auto& str : strings) {\n        result += str;\n    }\n    \n    return result;\n}\n\n// Function to test the concatenate function with some test cases\nvoid test_concatenate() {\n    cout << \"Test Case 1: Empty Vector -> Expected: \\\"\\\", Actual: \\\"\" << concatenate({}) << \"\\\"\" << endl;\n    cout << \"Test Case 2: {\\\"a\\\", \\\"b\\\", \\\"c\\\"} -> Expected: \\\"abc\\\", Actual: \\\"\" << concatenate({\"a\", \"b\", \"c\"}) << \"\\\"\" << endl;\n}\n\n"}
{"task_id": "CPP/29", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> filter_by_prefix(vector<string> strings, string prefix) {\n    vector<string> filteredStrings; // This will store the results\n\n    for (const auto& str : strings) { // Iterate through each string in the input\n        if (!str.empty() && str.substr(0, prefix.size()) == prefix) {\n            // Check if the current string starts with the given prefix\n            filteredStrings.push_back(str); // Add to result vector if condition is met\n        }\n    }\n\n    return filteredStrings; // Return the filtered list of strings\n}\n\n// Function to test the filter_by_prefix function\nvoid check() {\n    auto result1 = filter_by_prefix({}, \"a\");\n    cout << \"Test 1: \";\n    for (const auto& str : result1) {\n        cout << str << \" \";\n    }\n    cout << endl;\n\n    auto result2 = filter_by_prefix({\"abc\", \"bcd\", \"cde\", \"vector\"}, \"a\");\n    cout << \"Test 2: \";\n    for (const auto& str : result2) {\n        cout << str << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/30", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // For std::copy_if\n\nusing namespace std;\n\nvector<float> get_positive(vector<float> l) {\n    vector<float> result;  // This will store the positive numbers.\n    \n    // Use copy_if to filter only positive numbers into 'result'.\n    copy_if(l.begin(), l.end(), back_inserter(result), [](float x){ return x > 0; });\n    \n    return result;\n}\n\n// Function to print a vector\nvoid print_vector(const vector<float>& v) {\n    for (auto num : v) {\n        cout << num << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/31", "generation": "#include <iostream>\nusing namespace std;\n\nbool is_prime(long long n) {\n    // Handle edge cases for 0, 1 and negative numbers.\n    if (n <= 1) return false;\n    \n    // Check divisibility from 2 up to the square root of n.\n    for (long long i = 2; i * i <= n; ++i) {\n        if (n % i == 0)\n            return false;\n    }\n    return true;\n}\n\n"}
{"task_id": "CPP/32", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\ndouble poly(vector<double> xs, double x){\n    /* \n    Evaluates polynomial with coefficients xs at point x. return xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n \n    */\n    double sum=0;\n    int i;\n    for (i=0;i<xs.size();i++)\n    {\n        sum+=xs[i]*pow(x,i);\n    }\n    return sum;\n}\n\ndouble find_zero(vector<double> xs){\n    /*\n    xs are coefficients of a polynomial. find_zero finds x such that poly(x) = 0.\n    find_zero returns only one zero point, even if there are many.\n    Moreover, find_zero only takes list xs having an even number of coefficients and the largest non-zero coefficient as it guarantees a solution.\n    */\n    \n    // Initial guesses for bisection method\n    double a = -100.0;\n    double b = 100.0;\n\n    // Evaluate polynomial at initial points\n    double fa = poly(xs, a);\n    double fb = poly(xs, b);\n\n    // Ensure that the function changes sign in the interval [a, b]\n    while (fa * fb > 0) {\n        if (fabs(fa) < fabs(fb)) {\n            a *= 2;\n        } else {\n            b *= 2;\n        }\n        fa = poly(xs, a);\n        fb = poly(xs, b);\n    }\n\n    // Bisection method\n    double tol = 1e-6; // Tolerance for the root\n    while ((b - a) / 2 > tol) {\n        double c = (a + b) / 2;\n        double fc = poly(xs, c);\n\n        if (fc == 0 || fabs(b - a) / 2 < tol) {\n            return c;\n        } else if (fa * fc < 0) {\n            b = c;\n            fb = fc;\n        } else {\n            a = c;\n            fa = fc;\n        }\n    }\n\n    // Return the midpoint of the final interval\n    return (a + b) / 2;\n}\n\n"}
{"task_id": "CPP/33", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // for std::sort\n\nusing namespace std;\n\nvector<int> sort_third(vector<int> l) {\n    vector<int> to_sort;\n    \n    // Extract values from indices divisible by 3 (0-based indexing)\n    for(size_t i = 0; i < l.size(); i += 3) {\n        to_sort.push_back(l[i]);\n    }\n    \n    // Sort the extracted values\n    sort(to_sort.begin(), to_sort.end());\n    \n    // Replace original elements with sorted ones\n    for(size_t i = 0, j = 0; i < l.size() && j < to_sort.size(); i += 3, ++j) {\n        l[i] = to_sort[j];\n    }\n    \n    return l;\n}\n\n// Function to test the correctness of sort_third function\nvoid check_function() {\n    vector<int> test1 = {1, 2, 3};\n    vector<int> expected1 = {1, 2, 3};\n    assert(sort_third(test1) == expected1);\n\n    vector<int> test2 = {5, 6, 3, 4, 8, 9, 2};\n    vector<int> expected2 = {2, 6, 3, 4, 8, 9, 5};\n    assert(sort_third(test2) == expected2);\n\n    cout << \"All tests passed successfully.\" << endl;\n}\n\n"}
{"task_id": "CPP/34", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // for std::sort and std::unique\n\nusing namespace std;\n\nvector<int> unique(vector<int> l) {\n    // First, sort the vector so that duplicate elements are adjacent.\n    sort(l.begin(), l.end());\n    \n    // Use std::unique to remove consecutive duplicates. It returns a past-the-end iterator for the new range of unique elements.\n    auto last = unique(l.begin(), l.end());\n    \n    // Erase the non-unique part of the vector\n    l.erase(last, l.end());\n    \n    return l;\n}\n\n// Function to print the contents of a vector\nvoid printVector(const vector<int>& v) {\n    for (int i : v) {\n        cout << i << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/35", "generation": "#include <vector>\n#include <algorithm> // For std::numeric_limits\n\nusing namespace std;\n\nfloat max_element(vector<float> l) {\n    if (l.empty()) {  // Check if the vector is empty to avoid undefined behavior.\n        return numeric_limits<float>::lowest(); // Return the lowest possible float value if the vector is empty\n    }\n\n    float max_val = l[0];  // Initialize max_val with the first element of the vector\n\n    for (size_t i = 1; i < l.size(); ++i) {  // Start from the second element and iterate through the rest\n        if (l[i] > max_val) {\n            max_val = l[i];  // Update max_val if a larger value is found\n        }\n    }\n\n    return max_val;\n}\n"}
{"task_id": "CPP/36", "generation": "#include <iostream>\nusing namespace std;\n\nint fizz_buzz(int n) {\n    int count = 0;\n    \n    for (int i = 1; i < n; ++i) {\n        if ((i % 11 == 0 || i % 13 == 0)) { // Check divisibility by 11 or 13\n            int temp = i;\n            while (temp > 0) {\n                if (temp % 10 == 7) count++; // Count digit '7'\n                temp /= 10; // Move to the next digit\n            }\n        }\n    }\n    \n    return count;\n}\n\n"}
{"task_id": "CPP/37", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // for std::sort\n\nusing namespace std;\n\nvector<float> sort_even(vector<float> l) {\n    vector<float> even_elements;\n    \n    // Extract elements at even indices and store them in a separate vector.\n    for (size_t i = 0; i < l.size(); i += 2) {\n        even_elements.push_back(l[i]);\n    }\n    \n    // Sort the extracted even-indexed elements.\n    sort(even_elements.begin(), even_elements.end());\n    \n    // Place sorted elements back into their original positions in vector `l`.\n    for (size_t i = 0, j = 0; i < l.size(); i += 2) {\n        l[i] = even_elements[j++];\n    }\n    \n    return l;\n}\n\n// Function to test the sort_even function with provided data points.\nvoid check() {\n    vector<float> result;\n\n    // Test case 1\n    result = sort_even({1, 2, 3});\n    for (float num : result) cout << num << \" \";\n    cout << endl; // Expected: 1 2 3\n\n    // Test case 2\n    result = sort_even({5, 6, 3, 4});\n    for (float num : result) cout << num << \" \";\n    cout << endl; // Expected: 3 6 5 4\n}\n\n"}
{"task_id": "CPP/38", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\n// Function to encode a string by cycling groups of three characters.\nstring encode_cyclic(string s) { \n    int l = s.length();\n    string output;\n    for (int i = 0; i * 3 < l; i++) {\n        string x = s.substr(i * 3, 3);\n        if (x.length() == 3) x = x.substr(1) + x[0];\n        output += x;\n    }\n    return output;\n}\n\n// Function to decode a string that was encoded with encode_cyclic.\nstring decode_cyclic(string s) { \n    int l = s.length();\n    string output;\n    for (int i = 0; i * 3 < l; i++) {\n        string x = s.substr(i * 3, 3);\n        if (x.length() == 3) x = x[2] + x.substr(0, 2); // Rotate right\n        output += x;\n    }\n    return output;\n}\n\n"}
{"task_id": "CPP/39", "generation": "#include <stdio.h>\n#include <math.h>\n\n// Function to check if a number is prime\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    if (num == 2 || num == 3) return true;\n    if (num % 2 == 0 || num % 3 == 0) return false;\n\n    for (int i = 5; i * i <= num; i += 6) {\n        if (num % i == 0 || num % (i + 2) == 0)\n            return false;\n    }\n    return true;\n}\n\n// Function to find the n-th Fibonacci number that is also prime\nint prime_fib(int n) {\n    int fib1 = 0, fib2 = 1; // First two Fibonacci numbers\n    int count = 0;\n\n    while (true) {\n        int nextFib = fib1 + fib2;\n        if (is_prime(nextFib)) {\n            count++;\n            if (count == n)\n                return nextFib;\n        }\n        fib1 = fib2;\n        fib2 = nextFib;\n    }\n\n    // This line should never be reached\n    return -1;\n}\n\n"}
{"task_id": "CPP/40", "generation": "#include <vector>\n#include <algorithm> // For std::sort\n\nusing namespace std;\n\nbool triples_sum_to_zero(vector<int> l) {\n    int n = l.size();\n    \n    if (n < 3) return false; // Early exit for vectors with less than 3 elements\n    \n    sort(l.begin(), l.end()); // Sort the vector to use two-pointer technique\n    \n    for(int i = 0; i < n-2; ++i) {\n        int left = i + 1, right = n - 1;\n        \n        while(left < right) {\n            int sum = l[i] + l[left] + l[right];\n            \n            if(sum == 0) return true; // Found three numbers that sum to zero\n            else if(sum < 0) ++left; // Need a larger number, move left pointer to the right\n            else --right; // Need a smaller number, move right pointer to the left\n        }\n    }\n    \n    return false; // No triplet found that sums up to zero\n}\n\n// Example usage:\n"}
{"task_id": "CPP/41", "generation": "#include<iostream>\nusing namespace std;\n\nint car_race_collision(int n) {\n    // Since every car from one side will collide with exactly one car from the other side,\n    // the total number of collisions is equal to the number of cars on either side.\n    return n;\n}\n\n"}
{"task_id": "CPP/42", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> incr_list(vector<int> l) {\n    // Iterate over all elements of the vector.\n    for (size_t i = 0; i < l.size(); ++i) {\n        // Increment each element by 1.\n        l[i] += 1;\n    }\n    return l;\n}\n\n// Function to test the correctness of incr_list function\nvoid check() {\n    vector<int> test1 = {1, 2, 3};\n    vector<int> expected1 = {2, 3, 4};\n    assert(incr_list(test1) == expected1);\n\n    vector<int> test2 = {5, 3, 5, 2, 3, 3, 9, 0, 123};\n    vector<int> expected2 = {6, 4, 6, 3, 4, 4, 10, 1, 124};\n    assert(incr_list(test2) == expected2);\n\n    cout << \"All tests passed successfully.\" << endl;\n}\n\n"}
{"task_id": "CPP/43", "generation": "#include <iostream>\n#include <vector>\n#include <unordered_set> // Use unordered_set for efficient lookup\n\nusing namespace std;\n\nbool pairs_sum_to_zero(vector<int> l) {\n    unordered_set<int> seenNumbers; // Set to keep track of numbers we've seen\n    \n    for (int num : l) { // Iterate through each number in the vector\n        if (seenNumbers.find(-num) != seenNumbers.end()) { // Check if -num is already in the set\n            return true; // Found two numbers that sum to zero\n        }\n        seenNumbers.insert(num); // Add current number to the set\n    }\n    \n    return false; // No pair found that sums to zero\n}\n\n// Function to test the pairs_sum_to_zero function with given data points\nvoid check() {\n    cout << boolalpha; // Print true/false instead of 1/0 for boolean values\n    cout << \"Test Case 1: \" << pairs_sum_to_zero({1, 3, 5, 0}) << endl;\n    cout << \"Test Case 2: \" << pairs_sum_to_zero({1, 3, -2, 1}) << endl;\n    cout << \"Test Case 3: \" << pairs_sum_to_zero({1, 2, 3, 7}) << endl;\n    cout << \"Test Case 4: \" << pairs_sum_to_zero({2, 4, -5, 3, 5, 7}) << endl;\n    cout << \"Test Case 5: \" << pairs_sum_to_zero({1}) << endl;\n}\n\n"}
{"task_id": "CPP/44", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring change_base(int x, int base) {\n    if (base <= 1 || base >= 10) return \"Invalid base\"; // Ensure base is valid\n\n    string result = \"\";\n    while (x > 0) {\n        int remainder = x % base;\n        result = to_string(remainder) + result; // Prepend the remainder\n        x /= base;\n    }\n\n    if(result == \"\") result = \"0\"; // Handle case where x was 0 initially\n\n    return result;\n}\n\n"}
{"task_id": "CPP/45", "generation": "#include<stdio.h>\n\nfloat triangle_area(float a, float h) {\n    // Area of a triangle is 0.5 * base * height\n    return 0.5 * a * h;\n}\n\n"}
{"task_id": "CPP/46", "generation": "#include <iostream>\n#include <vector>\n\nint fib4(int n) {\n    // Base cases for the first four elements of the sequence.\n    if (n == 0 || n == 1)\n        return 0;\n    else if (n == 2)\n        return 2;\n    else if (n == 3)\n        return 0;\n\n    // Initialize an array to store the computed values up to n\n    std::vector<int> fib4_values(n + 1);\n    \n    // Set the base cases.\n    fib4_values[0] = 0;\n    fib4_values[1] = 0;\n    fib4_values[2] = 2;\n    fib4_values[3] = 0;\n\n    // Compute each value from 4 to n using the formula\n    for (int i = 4; i <= n; ++i) {\n        fib4_values[i] = fib4_values[i - 1] + fib4_values[i - 2] + fib4_values[i - 3] + fib4_values[i - 4];\n    }\n\n    // Return the nth value\n    return fib4_values[n];\n}\n\n"}
{"task_id": "CPP/47", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // for std::sort\n\nusing namespace std;\n\nfloat median(vector<float> l){\n    size_t n = l.size();\n    \n    if (n == 0) {\n        throw invalid_argument(\"Vector is empty\");\n    }\n    \n    sort(l.begin(), l.end()); // Sort the vector\n    \n    if (n % 2 != 0) { // If odd number of elements\n        return l[n / 2];\n    } else { // If even number of elements\n        return (l[(n - 1) / 2] + l[n / 2]) / 2.0;\n    }\n}\n\n"}
{"task_id": "CPP/48", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_palindrome(string text) {\n    int left = 0;\n    int right = text.length() - 1;\n\n    while (left < right) {\n        if (text[left] != text[right]) {\n            return false; // Characters do not match\n        }\n        left++;\n        right--;\n    }\n\n    return true; // All characters matched, it's a palindrome\n}\n\n"}
{"task_id": "CPP/49", "generation": "#include <iostream>\nusing namespace std;\n\nint modp(int n, int p) {\n    // Initialize result\n    long long res = 1;\n    \n    // Update base if it is more than or equal to p\n    long long base = (n >= p ? n % p : n);\n    \n    while (base > 0) {\n        // If base is odd, multiply the result with base modulo p\n        if (base & 1)\n            res = (res * base) % p;\n        \n        // Square the base and reduce it modulo p\n        base = (base * base) % p;\n        \n        // Divide the exponent by 2\n        n >>= 1; \n    }\n    \n    return res;\n}\n\n"}
{"task_id": "CPP/50", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nstring encode_shift(string s) {\n    // returns encoded string by shifting every character by 5 in the alphabet.\n    string out;\n    int i;\n    for (i = 0; i < s.length(); i++) {\n        int w = ((int)s[i] + 5 - (int)'a') % 26 + (int)'a';\n        out += (char)w;\n    }\n    return out;\n}\n\nstring decode_shift(string s) {\n    // takes as input string encoded with encode_shift function. Returns decoded string.\n    string out;\n    int i;\n    for (i = 0; i < s.length(); i++) {\n        int w = ((int)s[i] - 5 - (int)'a' + 26) % 26 + (int)'a'; // Adding 26 to ensure positive result\n        out += (char)w;\n    }\n    return out;\n}\n\n// Example usage:\n"}
{"task_id": "CPP/51", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool isVowel(char c) {\n    // Convert character to lowercase for simplicity and check if it's a vowel.\n    char lower_c = tolower(c);\n    return (lower_c == 'a' || lower_c == 'e' || lower_c == 'i' || lower_c == 'o' || lower_c == 'u');\n}\n\nstring remove_vowels(string text) {\n    string result;\n    for(char c : text) {\n        if(!isVowel(c)) { // If the character is not a vowel, add it to the result.\n            result += c;\n        }\n    }\n    return result;\n}\n\n"}
{"task_id": "CPP/52", "generation": "#include <vector>\nusing namespace std;\n\nbool below_threshold(vector<int> l, int t) {\n    // Iterate through each element in the vector\n    for (int num : l) {\n        // If any number is greater than or equal to the threshold, return false\n        if (num >= t) {\n            return false;\n        }\n    }\n    // If all numbers are below the threshold, return true\n    return true;\n}\n\n// Example usage:\n/*\nbool result1 = below_threshold({1, 2, 4, 10}, 100); // Should be true\nbool result2 = below_threshold({1, 20, 4, 10}, 5);   // Should be false\n*/\n"}
{"task_id": "CPP/53", "generation": "#include<iostream>\nusing namespace std;\n\nint add(int x, int y) {\n    return x + y;\n}\n\n// Example usage\n"}
{"task_id": "CPP/54", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nbool same_chars(string s0, string s1) {\n    // Sort both strings to bring identical characters together.\n    sort(s0.begin(), s0.end());\n    sort(s1.begin(), s1.end());\n\n    // Remove duplicate characters from each sorted string.\n    auto last_unique_s0 = unique(s0.begin(), s0.end());\n    auto last_unique_s1 = unique(s1.begin(), s1.end());\n\n    // Erase the duplicates in place to get only unique characters.\n    s0.erase(last_unique_s0, s0.end());\n    s1.erase(last_unique_s1, s1.end());\n\n    // Compare the two strings for equality after processing.\n    return s0 == s1;\n}\n\n"}
{"task_id": "CPP/55", "generation": "#include<stdio.h>\n\nint fib(int n) {\n    if (n <= 1)\n        return n;\n    else\n        return fib(n-1) + fib(n-2);\n}\n\n"}
{"task_id": "CPP/56", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    int balance = 0;\n    \n    for (char c : brackets) {\n        if (c == '<') {\n            ++balance; // Increment for an opening bracket\n        } else if (c == '>') {\n            --balance; // Decrement for a closing bracket\n            \n            // If balance goes below zero, there's an unmatched closing bracket\n            if (balance < 0) return false;\n        }\n    }\n    \n    // Return true only if the balance is back to zero at the end\n    return balance == 0;\n}\n\n"}
{"task_id": "CPP/57", "generation": "#include <vector>\nusing namespace std;\n\nbool monotonic(vector<float> l) {\n    // If the list is empty or has only one element, it's considered monotonic.\n    if (l.size() <= 1) return true;\n    \n    bool increasing = false; // Flag to check for increasing trend\n    bool decreasing = false; // Flag to check for decreasing trend\n    \n    // Determine the initial trend based on the first two elements\n    if (l[0] < l[1]) {\n        increasing = true;\n    } else if (l[0] > l[1]) {\n        decreasing = true;\n    }\n    \n    // Iterate through the list to check consistency with the determined trend.\n    for(size_t i = 1; i < l.size(); ++i) {\n        if(increasing && l[i-1] >= l[i]) return false; // Violates increasing\n        if(decreasing && l[i-1] <= l[i]) return false; // Violates decreasing\n    }\n    \n    // If the loop completes without returning false, it's monotonic.\n    return true;\n}\n"}
{"task_id": "CPP/58", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // For sort function\n#include <set>       // To store unique elements\n\nusing namespace std;\n\nvector<int> common(vector<int> l1, vector<int> l2) {\n    // Sort both vectors to make it easier to find common elements.\n    sort(l1.begin(), l1.end());\n    sort(l2.begin(), l2.end());\n\n    set<int> result;  // Use a set to store unique and sorted results\n    auto it1 = l1.begin();\n    auto it2 = l2.begin();\n\n    // Traverse both vectors to find common elements\n    while (it1 != l1.end() && it2 != l2.end()) {\n        if (*it1 == *it2) {\n            result.insert(*it1);\n            ++it1;\n            ++it2;\n        } else if (*it1 < *it2) {\n            ++it1;\n        } else {\n            ++it2;\n        }\n    }\n\n    // Convert set to vector\n    return vector<int>(result.begin(), result.end());\n}\n\n// Function to print the elements of a vector\nvoid printVector(const vector<int>& vec) {\n    for (int num : vec) {\n        cout << num << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/59", "generation": "#include <stdio.h>\n#include <stdbool.h>\n\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    for (int i = 2; i * i <= num; ++i) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\nint largest_prime_factor(int n){\n    int largestFactor = -1;\n\n    // Divide n by 2 to remove all even factors\n    while (n % 2 == 0) {\n        largestFactor = 2;\n        n /= 2;\n    }\n\n    // Now we only have odd factors left, start from 3 and check each odd number.\n    for (int i = 3; i * i <= n; i += 2) {\n        while (n % i == 0) {\n            largestFactor = i;\n            n /= i;\n        }\n    }\n\n    // If n is a prime number greater than 2\n    if (n > 2)\n        largestFactor = n;\n\n    return largestFactor;\n}\n\n"}
{"task_id": "CPP/60", "generation": "#include<iostream>\nusing namespace std;\n\nint sum_to_n(int n){\n    int sum = 0;\n    for (int i = 1; i <= n; ++i) {\n        sum += i;\n    }\n    return sum;\n}\n\n// Function to test the correctness of sum_to_n\nvoid check_function() {\n    cout << \"sum_to_n(30): \" << sum_to_n(30) << endl; // Expected output: 465\n    cout << \"sum_to_n(100): \" << sum_to_n(100) << endl; // Expected output: 5050\n    cout << \"sum_to_n(5): \" << sum_to_n(5) << endl; // Expected output: 15\n    cout << \"sum_to_n(10): \" << sum_to_n(10) << endl; // Expected output: 55\n    cout << \"sum_to_n(1): \" << sum_to_n(1) << endl; // Expected output: 1\n}\n\n"}
{"task_id": "CPP/61", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    int balance = 0; // Initialize balance counter\n\n    for (char c : brackets) { // Iterate through each character in the string\n        if (c == '(') {\n            ++balance; // Increment balance for an opening bracket\n        } else if (c == ')') {\n            --balance; // Decrement balance for a closing bracket\n            if (balance < 0) return false; // If balance is negative, there's a closing bracket without a matching opening one\n        }\n    }\n\n    return balance == 0; // True if all brackets are correctly matched and balanced\n}\n\n"}
{"task_id": "CPP/62", "generation": "#include <iostream>\n#include <vector>\n\nstd::vector<float> derivative(const std::vector<float>& xs) {\n    // Create an empty vector to store the coefficients of the derivative polynomial\n    std::vector<float> result;\n\n    // Iterate through each coefficient starting from the first non-constant term (index 1)\n    for(size_t i = 1; i < xs.size(); ++i) {\n        // Multiply the current coefficient by its index and add it to the result vector\n        result.push_back(xs[i] * static_cast<float>(i));\n    }\n\n    return result;\n}\n\n// Function to test the derivative function with given examples\nvoid check_derivative() {\n    std::vector<float> example1 = {3, 1, 2, 4, 5};\n    std::vector<float> expected1 = {1, 4, 12, 20};\n    \n    std::vector<float> result1 = derivative(example1);\n    assert(result1 == expected1);\n\n    std::vector<float> example2 = {1, 2, 3};\n    std::vector<float> expected2 = {2, 6};\n\n    std::vector<float> result2 = derivative(example2);\n    assert(result2 == expected2);\n\n    std::cout << \"All tests passed successfully.\" << std::endl;\n}\n\n"}
{"task_id": "CPP/63", "generation": "#include <iostream>\n#include <vector>\n\nint fibfib(int n) {\n    // Base cases\n    if (n == 0 || n == 1)\n        return 0;\n    else if (n == 2)\n        return 1;\n\n    // Initialize a vector to store the computed values of fibfib sequence.\n    std::vector<int> dp(n + 1);\n    dp[0] = 0;   // fibfib(0) is 0\n    dp[1] = 0;   // fibfib(1) is 0\n    dp[2] = 1;   // fibfib(2) is 1\n\n    // Compute the values from 3 to n using the recurrence relation.\n    for (int i = 3; i <= n; ++i)\n        dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3];\n\n    return dp[n];\n}\n\n// Function to test the fibfib function with given data points\nvoid check() {\n    std::cout << \"fibfib(1) should be 0: \" << (fibfib(1) == 0 ? \"Passed\" : \"Failed\") << std::endl;\n    std::cout << \"fibfib(5) should be 4: \" << (fibfib(5) == 4 ? \"Passed\" : \"Failed\") << std::endl;\n    std::cout << \"fibfib(8) should be 24: \" << (fibfib(8) == 24 ? \"Passed\" : \"Failed\") << std::endl;\n}\n\n"}
{"task_id": "CPP/64", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint vowels_count(string s) {\n    int count = 0;\n    // Convert string to lowercase for simplicity\n    transform(s.begin(), s.end(), s.begin(), ::tolower);\n\n    // Check each character in the string\n    for (size_t i = 0; i < s.length(); ++i) {\n        char c = s[i];\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n            count++;\n        }\n        // Check for 'y' at the end of the string\n        else if (c == 'y' && i == s.length() - 1) {\n            count++;\n        }\n    }\n\n    return count;\n}\n\n"}
{"task_id": "CPP/65", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring circular_shift(int x, int shift) {\n    // Convert integer to string for easy manipulation\n    string str_x = to_string(x);\n    \n    // Calculate effective shift\n    int len = str_x.length();\n    shift %= len;  // Effective shift\n    \n    if (shift == 0 || shift == len) {  // No actual circular shift needed or full circle\n        return str_x;\n    } else if (shift > len) {\n        reverse(str_x.begin(), str_x.end());  // Reverse the string\n        return str_x;\n    }\n    \n    // Perform circular shift\n    string result = str_x.substr(len - shift, shift);  // Last 'shift' characters\n    result += str_x.substr(0, len - shift);            // First (len-shift) characters\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/66", "generation": "#include <iostream>\n#include <string>\n#include <cctype> // For isupper() function\n\nusing namespace std;\n\nint digitSum(string s) {\n    int sum = 0;\n    for (char c : s) { // Iterate through each character in the string\n        if (isupper(c)) { // Check if the character is an uppercase letter\n            sum += static_cast<int>(c); // Add its ASCII value to sum\n        }\n    }\n    return sum; // Return the total sum of ASCII values of uppercase letters\n}\n\n"}
{"task_id": "CPP/67", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nint fruit_distribution(string s, int n) {\n    // Variables to hold the count of apples and oranges.\n    int apples = 0;\n    int oranges = 0;\n    \n    // Use a string stream for parsing the input string.\n    stringstream ss(s);\n    string word;\n    \n    while (ss >> word) {\n        if (word == \"apples\") {\n            ss >> word; // Skip 'and'\n            ss >> oranges; // The number after 'and' is the count of oranges\n        } else if (word == \"oranges\") {\n            ss >> apples; // The number before 'apples' is the count of apples\n        }\n    }\n\n    // Calculate and return the number of mangoes.\n    int mangoes = n - apples - oranges;\n    return mangoes;\n}\n\n"}
{"task_id": "CPP/68", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> pluck(vector<int> arr) {\n    int minValue = INT_MAX; // Initialize to a very large number.\n    int minIndex = -1;      // No valid index found initially.\n\n    for (int i = 0; i < arr.size(); ++i) {\n        if (arr[i] % 2 == 0 && arr[i] <= minValue) { // Check if the value is even and smaller or equal to current min.\n            if (arr[i] < minValue || (arr[i] == minValue && i < minIndex)) {\n                minValue = arr[i];\n                minIndex = i;\n            }\n        }\n    }\n\n    if (minIndex != -1) { // If a valid index was found, return the value and its index.\n        return {minValue, minIndex};\n    } else { // No even number found or vector is empty.\n        return {};\n    }\n}\n"}
{"task_id": "CPP/69", "generation": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint search(vector<int> lst) {\n    unordered_map<int, int> freqMap;\n    \n    // Count frequencies of each element in the list\n    for (int num : lst) {\n        freqMap[num]++;\n    }\n    \n    int result = -1;  // Initialize result as -1\n    \n    // Check each frequency against its value\n    for (auto &entry : freqMap) {\n        if (entry.first <= entry.second && entry.first > result) {\n            result = entry.first;\n        }\n    }\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/70", "generation": "#include <vector>\n#include <algorithm>\n\nstd::vector<int> strange_sort_list(std::vector<int> lst) {\n    // Sort the vector initially.\n    std::sort(lst.begin(), lst.end());\n    \n    std::vector<int> result;\n    int left = 0; // Start index for minimum value\n    int right = lst.size() - 1; // End index for maximum value\n    \n    while (left <= right) {\n        if (left == right) {\n            // If there's only one element left, add it to the result.\n            result.push_back(lst[left]);\n            break;\n        }\n        \n        // Add the minimum value\n        result.push_back(lst[left++]);\n        // Add the maximum value\n        result.push_back(lst[right--]);\n    }\n\n    return result;\n}\n\n// Example usage:\n"}
{"task_id": "CPP/71", "generation": "#include<stdio.h>\n#include<math.h>\n\nfloat triangle_area(float a, float b, float c){\n    // Check if sides form a valid triangle\n    if (a + b <= c || a + c <= b || b + c <= a) {\n        return -1;\n    }\n\n    // Calculate the semi-perimeter\n    float s = (a + b + c) / 2;\n\n    // Use Heron's formula to calculate area\n    float area = sqrt(s * (s - a) * (s - b) * (s - c));\n\n    // Round the result to two decimal points and return\n    return round(area * 100) / 100;\n}\n\n"}
{"task_id": "CPP/72", "generation": "#include <vector>\nusing namespace std;\n\nbool will_it_fly(vector<int> q, int w) {\n    // Check if the vector is balanced (palindromic)\n    for(int i = 0; i < q.size() / 2; ++i) {\n        if(q[i] != q[q.size() - 1 - i]) return false;\n    }\n\n    // Calculate the sum of elements in the vector\n    int sum = 0;\n    for(int num : q) {\n        sum += num;\n    }\n\n    // Check if the sum is less than or equal to the maximum possible weight w\n    return sum <= w;\n}\n"}
{"task_id": "CPP/73", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint smallest_change(vector<int> arr) {\n    int changes = 0;\n    int left = 0;\n    int right = arr.size() - 1;\n\n    while (left < right) {\n        if (arr[left] != arr[right]) {\n            ++changes; // Increment the change count when elements don't match\n        }\n        ++left;\n        --right;\n    }\n\n    return changes;\n}\n\n"}
{"task_id": "CPP/74", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to calculate the total number of characters in a vector of strings.\nint countChars(const vector<string>& lst) {\n    int count = 0;\n    for (const string& str : lst) {\n        count += str.length();\n    }\n    return count;\n}\n\nvector<string> total_match(vector<string> lst1, vector<string> lst2) {\n    // Calculate the number of characters in each list\n    int charsInLst1 = countChars(lst1);\n    int charsInLst2 = countChars(lst2);\n\n    // Compare and return the appropriate list\n    if (charsInLst1 <= charsInLst2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n\n// Function to test the solution with given examples.\nvoid check() {\n    vector<string> empty = {};\n    vector<string> result;\n\n    // Example 1\n    result = total_match(empty, empty);\n    cout << \"Example 1: \";\n    for (const string& str : result) cout << str << \" \";\n    cout << endl;\n\n    // Example 2\n    result = total_match({\"hi\", \"admin\"}, {\"hI\", \"Hi\"});\n    cout << \"Example 2: \";\n    for (const string& str : result) cout << str << \" \";\n    cout << endl;\n\n    // Example 3\n    result = total_match({\"hi\", \"admin\"}, {\"hi\", \"hi\", \"admin\", \"project\"});\n    cout << \"Example 3: \";\n    for (const string& str : result) cout << str << \" \";\n    cout << endl;\n\n    // Example 4\n    result = total_match({\"hi\", \"admin\"}, {\"hI\", \"hi\", \"hi\"});\n    cout << \"Example 4: \";\n    for (const string& str : result) cout << str << \" \";\n    cout << endl;\n\n    // Example 5\n    result = total_match({\"4\"}, {\"1\", \"2\", \"3\", \"4\", \"5\"});\n    cout << \"Example 5: \";\n    for (const string& str : result) cout << str << \" \";\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/75", "generation": "#include <iostream>\nusing namespace std;\n\n// Function to check if a number is prime.\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0)\n            return false;\n    }\n    return true;\n}\n\n// Function to check if a number can be expressed as the product of exactly three prime numbers.\nbool is_multiply_prime(int a) {\n    // Iterate through all possible combinations of primes less than 100\n    for (int i = 2; i < 100 && i * i * i <= a; ++i) {\n        if (!is_prime(i)) continue;\n        \n        for (int j = i; j < 100 && i * j * j <= a; ++j) {\n            if (!is_prime(j)) continue;\n\n            for (int k = j; k < 100; ++k) {\n                if (!is_prime(k)) continue;\n                \n                // Check if the product of these three primes equals 'a'\n                if (i * j * k == a)\n                    return true;\n            }\n        }\n    }\n\n    return false;\n}\n\n"}
{"task_id": "CPP/76", "generation": "#include <cmath> // For log and pow functions\n\nbool is_simple_power(int x, int n) {\n    if (n == 1) return x == 1; // Special case: only 1^k = 1 for any k.\n    \n    double log_result = std::log(x) / std::log(n); // Calculate the logarithm of x with base n\n    \n    // Check if the result is an integer by comparing it to its rounded value\n    return std::abs(log_result - std::round(log_result)) < 1e-9; \n}\n\n"}
{"task_id": "CPP/77", "generation": "#include <cmath> // For std::cbrt and std::round\n\nbool iscube(int a) {\n    double cubeRoot = std::cbrt(a); // Calculate the cube root of 'a'\n    int nearestInt = std::round(cubeRoot); // Round to the nearest integer\n    \n    // Check if the cube of the rounded value equals 'a'\n    return (nearestInt * nearestInt * nearestInt == a);\n}\n\n"}
{"task_id": "CPP/78", "generation": "#include <iostream>\n#include <string>\n#include <set>\n\nusing namespace std;\n\nint hex_key(string num) {\n    // Set of prime hexadecimal digits\n    set<char> primes = {'2', '3', '5', '7', 'B', 'D'};\n    \n    int count = 0;\n    for (char c : num) {\n        if (primes.find(c) != primes.end()) {\n            ++count;\n        }\n    }\n    \n    return count;\n}\n\n"}
{"task_id": "CPP/79", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring decimal_to_binary(int decimal) {\n    // Convert the number to binary using bit manipulation.\n    string binary = \"\";\n    \n    if (decimal == 0) {\n        return \"db0db\"; // Special case for zero\n    }\n    \n    while (decimal > 0) {\n        int remainder = decimal % 2;\n        binary = char('0' + remainder) + binary; // Convert the remainder to a character and prepend it.\n        decimal /= 2;\n    }\n\n    return \"db\" + binary + \"db\"; // Add 'db' at both ends\n}\n\n"}
{"task_id": "CPP/80", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_happy(string s) {\n    // Check if the length of the string is less than 3, return false immediately.\n    if (s.length() < 3) {\n        return false;\n    }\n\n    // Iterate through the string to check every set of three consecutive characters\n    for (int i = 0; i <= s.length() - 3; ++i) {\n        // Check if any two out of three consecutive characters are the same.\n        if (s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]) {\n            return false;\n        }\n    }\n\n    // If all checks pass, the string is happy\n    return true;\n}\n\n"}
{"task_id": "CPP/81", "generation": "#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> numerical_letter_grade(vector<float> grades) {\n    vector<string> result;\n    \n    for (float gpa : grades) {\n        if (gpa >= 4.0) result.push_back(\"A+\");\n        else if (gpa > 3.7) result.push_back(\"A\");\n        else if (gpa > 3.3) result.push_back(\"A-\");\n        else if (gpa > 3.0) result.push_back(\"B+\");\n        else if (gpa > 2.7) result.push_back(\"B\");\n        else if (gpa > 2.3) result.push_back(\"B-\");\n        else if (gpa > 2.0) result.push_back(\"C+\");\n        else if (gpa > 1.7) result.push_back(\"C\");\n        else if (gpa > 1.3) result.push_back(\"C-\");\n        else if (gpa > 1.0) result.push_back(\"D+\");\n        else if (gpa > 0.7) result.push_back(\"D\");\n        else if (gpa > 0.0) result.push_back(\"D-\");\n        else result.push_back(\"E\"); // This will cover the case where GPA is exactly 0.0\n    }\n    \n    return result;\n}\n\n// Example usage:\n/*\nvector<float> sample_grades = {4.0, 3, 1.7, 2, 3.5};\nvector<string> letter_grades = numerical_letter_grade(sample_grades);\nfor (const auto& grade : letter_grades) {\n    printf(\"%s \", grade.c_str());\n}\n// Output: A+ B C- C A-\n*/\n"}
{"task_id": "CPP/82", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\n// Helper function to check if a number is prime.\nbool is_prime(int n) {\n    if (n <= 1) return false; // 0 and 1 are not primes\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\n// Main function to check if the length of a string is prime.\nbool prime_length(string str){\n    int len = str.length();\n    return is_prime(len);\n}\n\n"}
{"task_id": "CPP/83", "generation": "#include <cmath> // For pow function\n\nint starts_one_ends(int n) {\n    if (n == 1) return 1; // Special case for single-digit numbers\n    \n    long long countStartsWithOne = pow(9, n-1);\n    long long countEndsWithOne = pow(9, n-1);\n    long long countBothStartAndEndWithOne = pow(9, n-2);\n\n    // Total count using inclusion-exclusion principle\n    return (int)(countStartsWithOne + countEndsWithOne - countBothStartAndEndWithOne);\n}\n\n// Example usage:\n"}
{"task_id": "CPP/84", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\n// Function to calculate the sum of digits of N\nint sumOfDigits(int N) {\n    int sum = 0;\n    while (N > 0) {\n        sum += N % 10; // Add the last digit to sum\n        N /= 10;       // Remove the last digit from N\n    }\n    return sum;\n}\n\n// Function to convert an integer to its binary string representation\nstring intToBinary(int num) {\n    if (num == 0) return \"0\"; // Special case for zero\n\n    string binary = \"\";\n    while (num > 0) {\n        binary = to_string(num % 2) + binary; // Prepend the remainder of division by 2\n        num /= 2;\n    }\n    return binary;\n}\n\nstring solve(int N){\n    int sumDigits = sumOfDigits(N); // Calculate the sum of digits\n    string resultBinary = intToBinary(sumDigits); // Convert the sum to binary string\n    return resultBinary; // Return the binary representation as a string\n}\n\n// Example usage:\n"}
{"task_id": "CPP/85", "generation": "#include <vector>\nusing namespace std;\n\nint add(vector<int> lst) {\n    int sum = 0;\n    \n    // Iterate through the list with an index starting from 1 (the first odd index)\n    for(int i = 1; i < lst.size(); i += 2) { // Increment by 2 to stay at odd indices\n        if(lst[i] % 2 == 0) { // Check if the element is even\n            sum += lst[i]; // Add it to the sum\n        }\n    }\n\n    return sum;\n}\n"}
{"task_id": "CPP/86", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nstring anti_shuffle(string s) {\n    // Temporary variables to hold the current word and its sorted version.\n    string tempWord = \"\";\n    string result = \"\";\n\n    for (char c : s) {\n        if (c == ' ') {  // If we encounter a space, process the collected word\n            sort(tempWord.begin(), tempWord.end());  // Sort characters in ascending order based on ASCII value\n            result += tempWord + \" \";  // Append sorted word and space to the result\n            tempWord = \"\";  // Reset for next word\n        } else {\n            tempWord += c;  // Collect characters of current word\n        }\n    }\n\n    if (!tempWord.empty()) {  // Process any remaining word after last space or at end of string\n        sort(tempWord.begin(), tempWord.end());\n        result += tempWord;\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/87", "generation": "#include <vector>\n#include <algorithm> // for std::sort\n\nusing namespace std;\n\nbool compare(const vector<int>& a, const vector<int>& b) {\n    if (a[0] != b[0]) return a[0] < b[0]; // sort by row in ascending order\n    else return a[1] > b[1];              // then by column in descending order within the same row\n}\n\nvector<vector<int>> get_row(vector<vector<int>> lst, int x) {\n    vector<vector<int>> coordinates;\n    \n    for (int i = 0; i < lst.size(); ++i) { // iterate through each row\n        for (int j = 0; j < lst[i].size(); ++j) { // iterate through each element in the current row\n            if (lst[i][j] == x) {\n                coordinates.push_back({i, j}); // store the coordinate of found integer\n            }\n        }\n    }\n\n    sort(coordinates.begin(), coordinates.end(), compare); // sort according to specified rules\n\n    return coordinates;\n}\n\n// Example usage:\n"}
{"task_id": "CPP/88", "generation": "#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> sort_array(vector<int> array) {\n    // Check if the vector is empty or contains only one element\n    if (array.size() <= 1) return array;\n    \n    // Calculate the sum of the first and last elements\n    int sum = array.front() + array.back();\n    \n    // Create a copy to avoid modifying the original vector\n    vector<int> sortedArray(array);\n    \n    // Sort based on whether the sum is odd or even\n    if (sum % 2 == 0) {\n        sort(sortedArray.begin(), sortedArray.end(), greater<int>());\n    } else {\n        sort(sortedArray.begin(), sortedArray.end());\n    }\n    \n    return sortedArray;\n}\n\n// Example usage:\n"}
{"task_id": "CPP/89", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring encrypt(string s){\n    for (int i = 0; i < s.length(); ++i) {\n        char c = s[i];\n        \n        // Check if the character is a lowercase letter.\n        if ('a' <= c && c <= 'z') {\n            // Shift by 4 positions and wrap around using modulo operation\n            s[i] = ((c - 'a' + 4) % 26) + 'a';\n        }\n        \n        // Check if the character is an uppercase letter.\n        else if ('A' <= c && c <= 'Z') {\n            // Shift by 4 positions and wrap around using modulo operation\n            s[i] = ((c - 'A' + 4) % 26) + 'A';\n        }\n    }\n    \n    return s;\n}\n\n"}
{"task_id": "CPP/90", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint next_smallest(vector<int> lst) {\n    if (lst.size() < 2) { // If the list has less than two elements, return -1.\n        return -1;\n    }\n\n    sort(lst.begin(), lst.end()); // Sort the vector to find the smallest and second smallest elements easily.\n\n    int first = lst[0]; // The smallest element is now at index 0 after sorting.\n    \n    for (int i = 1; i < lst.size(); ++i) {\n        if (lst[i] != first) { // Find the next unique element which will be the second smallest.\n            return lst[i];\n        }\n    }\n\n    // If all elements are the same, there is no second smallest element.\n    return -1;\n}\n\n"}
{"task_id": "CPP/91", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nint is_bored(string S) {\n    int boredom_count = 0;\n    \n    // Use a stringstream to split the string into sentences.\n    stringstream ss(S);\n    string sentence;\n    char delimiters[] = {'.', '?', '!'};\n\n    while (getline(ss, sentence)) {\n        bool found_delimiter = false;\n\n        for(char delimiter : delimiters) {\n            size_t pos = 0;\n            while ((pos = sentence.find(delimiter, pos)) != string::npos) {\n                // Extract the substring up to the current delimiter.\n                string sub_sentence = sentence.substr(0, pos);\n                \n                // Trim leading spaces from the extracted substring.\n                sub_sentence.erase(0, sub_sentence.find_first_not_of(\" \"));\n                \n                if (!sub_sentence.empty() && sub_sentence[0] == 'I' && (sub_sentence.size() > 1 ? isspace(sub_sentence[1]) : true)) {\n                    boredom_count++;\n                }\n                \n                // Move past the delimiter for next iteration.\n                pos += 1;\n            }\n\n            found_delimiter = true;\n        }\n\n        if (!found_delimiter) {\n            sentence.erase(0, sentence.find_first_not_of(\" \"));\n            \n            if (!sentence.empty() && sentence[0] == 'I' && (sentence.size() > 1 ? isspace(sentence[1]) : true)) {\n                boredom_count++;\n            }\n        }\n    }\n\n    return boredom_count;\n}\n\n"}
{"task_id": "CPP/92", "generation": "#include <iostream>\n#include <cmath>\n\nbool any_int(float a, float b, float c) {\n    // Check if all numbers are integers by comparing them with their floor values.\n    bool is_a_integer = (a == std::floor(a));\n    bool is_b_integer = (b == std::floor(b));\n    bool is_c_integer = (c == std::floor(c));\n\n    // If any of the numbers are not integers, return false\n    if (!is_a_integer || !is_b_integer || !is_c_integer) {\n        return false;\n    }\n\n    // Check if one number equals the sum of the other two.\n    if ((a + b == c) || (b + c == a) || (c + a == b)) {\n        return true;\n    } else {\n        return false;\n    }\n}\n\n"}
{"task_id": "CPP/93", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\n// Function to encode a message according to the given rules.\nstring encode(string message) {\n    // Iterate through each character of the string.\n    for (char &c : message) {\n        // Swap case: if lowercase, convert to uppercase and vice versa.\n        if (islower(c)) c = toupper(c);\n        else if (isupper(c)) c = tolower(c);\n\n        // Replace vowels with the letter that appears 2 places ahead in the alphabet.\n        switch (tolower(c)) {\n            case 'a': c = islower(c) ? 'c' : 'C'; break;\n            case 'e': c = islower(c) ? 'g' : 'G'; break;\n            case 'i': c = islower(c) ? 'k' : 'K'; break;\n            case 'o': c = islower(c) ? 'q' : 'Q'; break;\n            case 'u': c = islower(c) ? 'w' : 'W'; break;\n        }\n    }\n\n    return message;\n}\n\n"}
{"task_id": "CPP/94", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to check if a number is prime\nbool isPrime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\n// Function to calculate the sum of digits of a number\nint sumOfDigits(int num) {\n    int sum = 0;\n    while (num > 0) {\n        sum += num % 10;\n        num /= 10;\n    }\n    return sum;\n}\n\n// Main function to find the largest prime and sum its digits\nint skjkasdkd(vector<int> lst){\n    int maxPrime = -1; // Initialize with a non-prime value\n    \n    // Iterate through the list to find the largest prime number\n    for (int num : lst) {\n        if (isPrime(num)) {\n            maxPrime = max(maxPrime, num);\n        }\n    }\n\n    // If no prime was found, return 0 or handle as needed\n    if (maxPrime == -1) return 0;\n\n    // Calculate and return the sum of digits of the largest prime number\n    return sumOfDigits(maxPrime);\n}\n\n// Function to test the solution with given examples\nvoid check() {\n    cout << skjkasdkd({0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3}) << endl; // 10\n    cout << skjkasdkd({1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1}) << endl; // 25\n    cout << skjkasdkd({1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3}) << endl; // 13\n    cout << skjkasdkd({0,724,32,71,99,32,6,0,5,91,83,0,5,6}) << endl; // 11\n    cout << skjkasdkd({0,81,12,3,1,21}) << endl; // 3\n    cout << skjkasdkd({0,8,1,2,1,7}) << endl; // 7\n}\n\n"}
{"task_id": "CPP/95", "generation": "#include <iostream>\n#include <string>\n#include <map>\n\nusing namespace std;\n\nbool check_dict_case(map<string, string> dict) {\n    if (dict.empty()) return false; // Return false if the dictionary is empty\n\n    bool allLower = true;\n    bool allUpper = true;\n\n    for (const auto& pair : dict) {\n        const string& key = pair.first;\n        \n        // Check each character of the key\n        for (char ch : key) {\n            if (!isalpha(ch)) { // If any non-alphabetic character is found, return false\n                return false;\n            }\n            \n            allLower &= islower(ch);\n            allUpper &= isupper(ch);\n        }\n\n        // Early exit if it's neither all lower nor all upper\n        if (!allLower && !allUpper) {\n            return false;\n        }\n    }\n\n    // If we reach here, the keys are either all lowercase or all uppercase\n    return true;\n}\n\n"}
{"task_id": "CPP/96", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// Helper function to check if a number is prime\nbool is_prime(int num) {\n    if (num <= 1) return false; // 0 and 1 are not primes\n    for (int i = 2; i * i <= num; ++i) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\nvector<int> count_up_to(int n){\n    vector<int> primes;\n    \n    // Iterate through all numbers from 2 up to but not including n\n    for (int i = 2; i < n; ++i) {\n        if (is_prime(i)) {\n            primes.push_back(i);\n        }\n    }\n\n    return primes;\n}\n\n// Function to test the implementation with given examples\nvoid check() {\n    vector<int> result;\n\n    result = count_up_to(5); // Expected: {2, 3}\n    for(int num : result) cout << num << \" \";\n    cout << endl;\n\n    result = count_up_to(11); // Expected: {2, 3, 5, 7}\n    for(int num : result) cout << num << \" \";\n    cout << endl;\n\n    result = count_up_to(0); // Expected: {}\n    if(result.empty()) cout << \"{}\" << endl;\n    \n    result = count_up_to(20); // Expected: {2, 3, 5, 7, 11, 13, 17, 19}\n    for(int num : result) cout << num << \" \";\n    cout << endl;\n\n    result = count_up_to(1); // Expected: {}\n    if(result.empty()) cout << \"{}\" << endl;\n    \n    result = count_up_to(18); // Expected: {2, 3, 5, 7, 11, 13, 17}\n    for(int num : result) cout << num << \" \";\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/97", "generation": "#include<stdio.h>\n\nint multiply(int a, int b) {\n    // Extracting the unit digits\n    int unitDigitA = abs(a) % 10;\n    int unitDigitB = abs(b) % 10;\n\n    // Calculating and returning the product of the unit digits\n    return unitDigitA * unitDigitB;\n}\n\n"}
{"task_id": "CPP/98", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint count_upper(string s) {\n    int count = 0;\n    \n    // Iterate through the string with even indices only.\n    for (size_t i = 0; i < s.length(); i += 2) { // Start from index 0 and increment by 2\n        char c = s[i];\n        \n        // Check if it's an uppercase vowel\n        if (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n            count++;\n        }\n    }\n\n    return count;\n}\n\n"}
{"task_id": "CPP/99", "generation": "#include <iostream>\n#include <cmath>\n#include <string>\n\nusing namespace std;\n\nint closest_integer(string value) {\n    // Convert string to double for precision handling\n    double num = stod(value);\n    \n    // Check if the number is positive or negative\n    bool isPositive = num > 0;\n    \n    // Calculate the floor and ceil values of the number\n    int floorValue = static_cast<int>(floor(num));\n    int ceilValue = static_cast<int>(ceil(num));\n    \n    // Determine which integer to round towards based on the distance from the decimal part\n    double fractionalPart = num - floorValue;\n    \n    if (fractionalPart == 0.5) {\n        // If equidistant, round away from zero\n        return isPositive ? ceilValue : floorValue;\n    } else {\n        // Otherwise, use standard rounding rules\n        return static_cast<int>(round(num));\n    }\n}\n\n// Function to test the closest_integer function with given examples\nvoid check() {\n    cout << \"Testing '10': Expected 10, Got: \" << closest_integer(\"10\") << endl;\n    cout << \"Testing '15.3': Expected 15, Got: \" << closest_integer(\"15.3\") << endl;\n    cout << \"Testing '14.5': Expected 15, Got: \" << closest_integer(\"14.5\") << endl;\n    cout << \"Testing '-14.5': Expected -15, Got: \" << closest_integer(\"-14.5\") << endl;\n}\n\n"}
{"task_id": "CPP/100", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> make_a_pile(int n) {\n    vector<int> pile;\n    \n    // Start with the first level having 'n' stones.\n    int current_stones = n;\n    \n    for (int i = 0; i < n; ++i) {\n        pile.push_back(current_stones);\n        \n        // Determine the next number of stones based on whether current is odd or even\n        if (current_stones % 2 == 0) { // If current_stones is even, add 2 to get the next even number.\n            current_stones += 2;\n        } else { // If current_stones is odd, add 2 to get the next odd number.\n            current_stones += 2;\n        }\n    }\n\n    return pile;\n}\n\n// Example usage\n"}
{"task_id": "CPP/101", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> words_string(string s) {\n    vector<string> result;\n    string word = \"\";\n    \n    for (char c : s) {\n        if (c == ' ' || c == ',') {  // Check if the character is a space or comma\n            if (!word.empty()) {      // If there's a word, add it to the result vector\n                result.push_back(word);\n                word = \"\";            // Reset the word for the next iteration\n            }\n        } else {\n            word += c;  // Append the current character to the word\n        }\n    }\n\n    if (!word.empty()) {  // Add any remaining word after the loop ends\n        result.push_back(word);\n    }\n\n    return result;\n}\n\n// Function to test the implementation with example inputs\nvoid check() {\n    vector<string> res1 = words_string(\"Hi, my name is John\");\n    for (string s : res1) cout << s << \" \";\n    cout << endl;\n\n    vector<string> res2 = words_string(\"One, two, three, four, five, six\");\n    for (string s : res2) cout << s << \" \";\n}\n\n"}
{"task_id": "CPP/102", "generation": "#include<iostream>\nusing namespace std;\n\nint choose_num(int x, int y) {\n    // Check if the range is valid.\n    if (y < x)\n        return -1;\n    \n    // If 'y' itself is even and within the range, return it.\n    if (y % 2 == 0 && y >= x)\n        return y;\n\n    // Otherwise, check for the next lower number that could be even.\n    int candidate = y - 1;\n    while(candidate >= x) {\n        if (candidate % 2 == 0)\n            return candidate;\n        --candidate; // Move to the next lower number\n    }\n\n    // If no even number is found in the range, return -1.\n    return -1;\n}\n\n"}
{"task_id": "CPP/103", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\n// Function to convert an integer to a binary string\nstring int_to_binary(int num) {\n    if (num == 0) return \"0\";\n    string binary = \"\";\n    while (num > 0) {\n        binary = (num % 2 == 0 ? \"0\" : \"1\") + binary;\n        num /= 2;\n    }\n    return binary;\n}\n\nstring rounded_avg(int n, int m) {\n    if (n > m) return \"-1\";\n    \n    // Calculate the sum of integers from n to m\n    long long sum = ((long long)m * (m + 1) - (n * (n - 1))) / 2;\n    int count = m - n + 1; // Number of terms\n    \n    // Compute average and round down\n    int avg = sum / count;\n    \n    // Convert to binary string\n    return int_to_binary(avg);\n}\n\n"}
{"task_id": "CPP/104", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to check if a number contains only odd digits.\nbool hasOnlyOddDigits(int num) {\n    while (num > 0) {\n        int digit = num % 10;\n        if (digit % 2 == 0) return false; // If any digit is even, return false\n        num /= 10;\n    }\n    return true;\n}\n\nvector<int> unique_digits(vector<int> x) {\n    vector<int> result;\n\n    // Filter numbers that have only odd digits.\n    for (int num : x) {\n        if (hasOnlyOddDigits(num)) {\n            result.push_back(num);\n        }\n    }\n\n    // Sort the filtered numbers in increasing order\n    sort(result.begin(), result.end());\n\n    return result;\n}\n\n// Function to test the solution with given examples\nvoid check() {\n    vector<int> test1 = {15, 33, 1422, 1};\n    vector<int> expected1 = {1, 15, 33};\n    assert(unique_digits(test1) == expected1);\n\n    vector<int> test2 = {152, 323, 1422, 10};\n    vector<int> expected2 = {};\n    assert(unique_digits(test2) == expected2);\n    \n    cout << \"All tests passed successfully.\" << endl;\n}\n\n"}
{"task_id": "CPP/105", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\n\nusing namespace std;\n\nvector<string> by_length(vector<int> arr) {\n    // Map to store the digit-to-name mapping.\n    map<int, string> numberNames = {\n        {1, \"One\"}, {2, \"Two\"}, {3, \"Three\"},\n        {4, \"Four\"}, {5, \"Five\"}, {6, \"Six\"},\n        {7, \"Seven\"}, {8, \"Eight\"}, {9, \"Nine\"}\n    };\n\n    // Filter out numbers not between 1 and 9.\n    vector<int> filteredArr;\n    for (int num : arr) {\n        if (num >= 1 && num <= 9) {\n            filteredArr.push_back(num);\n        }\n    }\n\n    // Sort the filtered array.\n    sort(filteredArr.begin(), filteredArr.end());\n\n    // Reverse the sorted array.\n    reverse(filteredArr.begin(), filteredArr.end());\n\n    // Replace each digit with its corresponding name.\n    vector<string> result;\n    for (int num : filteredArr) {\n        result.push_back(numberNames[num]);\n    }\n\n    return result;\n}\n\n// Function to test the solution\nvoid check() {\n    vector<int> arr1 = {2, 1, 1, 4, 5, 8, 2, 3};\n    vector<string> expected1 = {\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"};\n    assert(by_length(arr1) == expected1);\n\n    vector<int> arr2 = {};\n    vector<string> expected2 = {};\n    assert(by_length(arr2) == expected2);\n\n    vector<int> arr3 = {1, -1, 55};\n    vector<string> expected3 = {\"One\"};\n    assert(by_length(arr3) == expected3);\n\n    cout << \"All tests passed successfully.\" << endl;\n}\n\n"}
{"task_id": "CPP/106", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// Function to calculate factorial\nint factorial(int num) {\n    int result = 1;\n    for (int i = 2; i <= num; ++i) {\n        result *= i;\n    }\n    return result;\n}\n\n// Function to calculate the sum of numbers from 1 to num\nint sumToN(int num) {\n    return (num * (num + 1)) / 2;\n}\n\nvector<int> f(int n) {\n    vector<int> result(n);\n    \n    for (int i = 0; i < n; ++i) {\n        if ((i + 1) % 2 == 0) { // Check if the index+1 is even\n            result[i] = factorial(i + 1); // Calculate factorial\n        } else {\n            result[i] = sumToN(i + 1); // Calculate sum from 1 to i+1\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/107", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\n// Function to check if a number is a palindrome\nbool isPalindrome(int num) {\n    string str = to_string(num);\n    int len = str.length();\n    for (int i = 0; i < len / 2; ++i) {\n        if (str[i] != str[len - i - 1]) return false;\n    }\n    return true;\n}\n\nvector<int> even_odd_palindrome(int n){\n    vector<int> result(2, 0); // Initialize a vector with two elements set to zero\n    for (int i = 1; i <= n; ++i) {\n        if (isPalindrome(i)) { // Check if the number is a palindrome\n            if (i % 2 == 0) {\n                result[0]++; // Increment even count\n            } else {\n                result[1]++; // Increment odd count\n            }\n        }\n    }\n    return result;\n}\n\n"}
{"task_id": "CPP/108", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint sum_of_digits(int num) {\n    int sum = 0;\n    bool is_negative = num < 0;\n    \n    while (num != 0) {\n        int digit = num % 10; // Get the last digit.\n        sum += digit;\n        num /= 10; // Remove the last digit from num.\n    }\n    \n    if (is_negative && sum == 0)\n        return -9; // Special case to handle numbers like -9, where the sum of digits is zero but should be considered negative.\n    \n    return sum;\n}\n\nint count_nums(vector<int> n) {\n    int count = 0;\n    \n    for (auto num : n) {\n        if (sum_of_digits(num) > 0)\n            ++count;\n    }\n    \n    return count;\n}\n\n// Function to test the solution\nvoid check() {\n    assert(count_nums({}) == 0);\n    assert(count_nums({-1, 11, -11}) == 1); // Only 11 has a sum of digits > 0.\n    assert(count_nums({1, 1, 2}) == 3);     // All numbers have a sum of digits > 0.\n    \n    cout << \"All tests passed successfully.\" << endl;\n}\n\n"}
{"task_id": "CPP/109", "generation": "#include <vector>\nusing namespace std;\n\nbool move_one_ball(vector<int> arr) {\n    if (arr.empty()) return true;\n    \n    int n = arr.size();\n    int disorder_count = 0;\n    \n    // Check for disorder points\n    for (int i = 1; i < n; ++i) {\n        if (arr[i] < arr[i - 1]) {\n            disorder_count++;\n        }\n    }\n\n    // Special case: check the wrap-around condition between last and first element\n    if (disorder_count == 0 || (disorder_count == 1 && arr[n-1] <= arr[0])) {\n        return true;\n    } else {\n        return false;\n    }\n}\n"}
{"task_id": "CPP/110", "generation": "#include <vector>\n#include <string>\nusing namespace std;\n\nstring exchange(vector<int> lst1, vector<int> lst2) {\n    // Count odd numbers in lst1 and even numbers in lst2.\n    int oddCountInLst1 = 0;\n    for (int num : lst1) {\n        if (num % 2 != 0) {\n            ++oddCountInLst1;\n        }\n    }\n\n    int evenCountInLst2 = 0;\n    for (int num : lst2) {\n        if (num % 2 == 0) {\n            ++evenCountInLst2;\n        }\n    }\n\n    // If there are enough even numbers in lst2 to replace all odd numbers in lst1, return \"YES\".\n    if (oddCountInLst1 <= evenCountInLst2) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n"}
{"task_id": "CPP/111", "generation": "#include <iostream>\n#include <string>\n#include <map>\n#include <sstream> // For std::istringstream\n\nusing namespace std;\n\nmap<char, int> histogram(string test) {\n    map<char, int> charCount;\n    map<char, int> result;\n    \n    if (test.empty()) return result; // Return empty map for empty input\n    \n    istringstream iss(test);\n    string word;\n    \n    // Count occurrences of each character\n    while (iss >> word && !word.empty()) {\n        ++charCount[word[0]];\n    }\n    \n    int maxCount = 0;\n    \n    // Find the maximum count\n    for (const auto& pair : charCount) {\n        if (pair.second > maxCount) {\n            maxCount = pair.second;\n        }\n    }\n    \n    // Collect characters with the maximum count into result map\n    for (const auto& pair : charCount) {\n        if (pair.second == maxCount) {\n            result.insert(pair);\n        }\n    }\n    \n    return result;\n}\n\n// Function to print the map for testing purposes\nvoid printMap(const map<char, int>& m) {\n    for (const auto& pair : m) {\n        cout << \"{\" << pair.first << \", \" << pair.second << \"} \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/112", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to check if a string is a palindrome.\nbool isPalindrome(const string& str) {\n    int left = 0;\n    int right = str.size() - 1;\n    while (left < right) {\n        if (str[left] != str[right]) return false;\n        ++left;\n        --right;\n    }\n    return true;\n}\n\nvector<string> reverse_delete(string s, string c) {\n    // Remove all characters in 's' that are present in 'c'.\n    for (char ch : c) {\n        s.erase(remove(s.begin(), s.end(), ch), s.end());\n    }\n\n    // Check if the resulting string is a palindrome.\n    bool result = isPalindrome(s);\n\n    vector<string> res;\n    res.push_back(s);\n    res.push_back(result ? \"True\" : \"False\");\n\n    return res;\n}\n\n// Function to test the solution with given examples.\nvoid check() {\n    auto res1 = reverse_delete(\"abcde\", \"ae\");\n    assert(res1 == vector<string>{\"bcd\", \"False\"});\n    \n    auto res2 = reverse_delete(\"abcdef\", \"b\");\n    assert(res2 == vector<string>{\"acdef\", \"False\"});\n\n    auto res3 = reverse_delete(\"abcdedcba\", \"ab\");\n    assert(res3 == vector<string>{\"cdedc\", \"True\"});\n}\n\n"}
{"task_id": "CPP/113", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to replace all occurrences of 'i' in a string with a given number.\nstring replace_i_with_number(string str, int num) {\n    for (size_t pos = 0; ; pos += num_str.length()) {\n        size_t found_pos = str.find(\"i\", pos);\n        if (found_pos == string::npos)\n            break;\n        str.replace(found_pos, 1, to_string(num));\n    }\n    return str;\n}\n\nvector<string> odd_count(vector<string> lst) {\n    vector<string> result;\n    for (const auto& s : lst) {\n        int count = 0;\n        // Count the number of odd digits in the string.\n        for (char c : s) {\n            if ((c - '0') % 2 != 0)\n                ++count;\n        }\n        // Construct the output string with replacements.\n        string output = \"the number of odd elements i\" + to_string(count) + \"n the stri\" + to_string(count) + \"ng i\" + to_string(count) + \" of the i\" + to_string(count) + \"nput.\";\n        result.push_back(replace_i_with_number(output, count));\n    }\n    return result;\n}\n\n"}
{"task_id": "CPP/114", "generation": "#include <iostream>\n#include <vector>\n#include <climits> // For INT_MAX\n\nusing namespace std;\n\nlong long minSubArraySum(vector<long long> nums) {\n    if (nums.empty()) return 0; // Handle empty vector case\n    \n    long long currentSum = 0;\n    long long minSum = LLONG_MAX; // Initialize to the largest possible value\n    \n    for (auto num : nums) {\n        currentSum += num;\n        \n        // Update minSum if currentSum is smaller\n        if (currentSum < minSum)\n            minSum = currentSum;\n            \n        // Reset currentSum to 0 if it becomes non-negative\n        if (currentSum >= 0)\n            currentSum = 0;\n    }\n    \n    return minSum;\n}\n\n"}
{"task_id": "CPP/115", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint max_fill(vector<vector<int>> grid, int capacity) {\n    int total_drops = 0;\n    \n    // Iterate over each well (row)\n    for (auto& row : grid) {\n        int water_units = 0;\n        \n        // Count the number of units of water in this well\n        for (int unit : row) {\n            if (unit == 1) {\n                ++water_units;\n            }\n        }\n        \n        // Calculate how many times we need to lower the bucket for this well\n        int drops_for_well = (water_units + capacity - 1) / capacity; // Equivalent to ceil(water_units / capacity)\n        \n        total_drops += drops_for_well;\n    }\n    \n    return total_drops;\n}\n\n"}
{"task_id": "CPP/116", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to count the number of 1s in binary representation of a number.\nint countOnes(int n) {\n    int ones = 0;\n    while (n != 0) {\n        if (n % 2 == 1)\n            ++ones;\n        n /= 2;\n    }\n    return ones;\n}\n\n// Comparator function for sorting based on the number of ones and then by value.\nbool compare(int a, int b) {\n    int countA = countOnes(abs(a));\n    int countB = countOnes(abs(b));\n\n    if (countA == countB)\n        return a < b; // If same number of 1s, sort by decimal value\n    else\n        return countA < countB; // Otherwise, sort by the number of 1s\n}\n\nvector<int> sort_array(vector<int> arr) {\n    sort(arr.begin(), arr.end(), compare);\n    return arr;\n}\n\n"}
{"task_id": "CPP/117", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Helper function to count consonants in a word\nint count_consonants(const string& word) {\n    int count = 0;\n    for (char ch : word) {\n        // Convert character to lowercase and check if it's a consonant\n        char lower_ch = tolower(ch);\n        if ((lower_ch >= 'a' && lower_ch <= 'z') && !(lower_ch == 'a' || lower_ch == 'e' || lower_ch == 'i' || lower_ch == 'o' || lower_ch == 'u')) {\n            count++;\n        }\n    }\n    return count;\n}\n\nvector<string> select_words(string s, int n) {\n    vector<string> result;\n    string word = \"\";\n    \n    // Split the string into words and check consonant count\n    for (char ch : s) {\n        if (ch == ' ') {\n            if (!word.empty()) {\n                if (count_consonants(word) == n) {\n                    result.push_back(word);\n                }\n                word = \"\";  // Reset word after processing it\n            }\n        } else {\n            word += ch;\n        }\n    }\n\n    // Check the last word in case there's no trailing space\n    if (!word.empty()) {\n        if (count_consonants(word) == n) {\n            result.push_back(word);\n        }\n    }\n\n    return result;\n}\n\n// Function to test the implementation with given examples\nvoid check() {\n    vector<string> res;\n\n    res = select_words(\"Mary had a little lamb\", 4);\n    for (const auto& word : res) cout << word << \" \";\n    cout << endl; // Expected: {\"little\"}\n\n    res = select_words(\"Mary had a little lamb\", 3);\n    for (const auto& word : res) cout << word << \" \";\n    cout << endl; // Expected: {\"Mary\", \"lamb\"}\n\n    res = select_words(\"simple white space\", 2);\n    for (const auto& word : res) cout << word << \" \";\n    cout << endl; // Expected: {}\n\n    res = select_words(\"Hello world\", 4);\n    for (const auto& word : res) cout << word << \" \";\n    cout << endl; // Expected: {\"world\"}\n\n    res = select_words(\"Uncle sam\", 3);\n    for (const auto& word : res) cout << word << \" \";\n    cout << endl; // Expected: {\"Uncle\"}\n}\n\n"}
{"task_id": "CPP/118", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_vowel(char c) {\n    string vowels = \"aeiouAEIOU\";\n    return vowels.find(c) != string::npos;\n}\n\nstring get_closest_vowel(string word){\n    int len = word.length();\n    \n    // Iterate from the end of the string to the beginning\n    for (int i = len - 2; i > 0; --i) {\n        // Check if current character is a vowel and surrounded by consonants\n        if (is_vowel(word[i]) && !is_vowel(word[i-1]) && !is_vowel(word[i+1])) {\n            return string(1, word[i]);\n        }\n    }\n    \n    // Return empty string if no such vowel found\n    return \"\";\n}\n\n"}
{"task_id": "CPP/119", "generation": "#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to calculate balance (open - close) for a given string.\nint get_balance(const string& s) {\n    int open = 0, close = 0;\n    for(char c : s) {\n        if(c == '(') open++;\n        else close++;\n    }\n    return open - close; // Returns positive if more opens, negative if more closes\n}\n\nstring match_parens(vector<string> lst){\n    int balance1 = get_balance(lst[0]);\n    int balance2 = get_balance(lst[1]);\n\n    // Check both concatenation orders:\n    // 1. lst[0] + lst[1]\n    // 2. lst[1] + lst[0]\n\n    // For the first order, the imbalance of the second string must not exceed\n    // the positive balance (open parentheses) of the first string.\n    bool canConcatenateFirstOrder = balance1 >= 0 && balance2 <= balance1;\n\n    // For the second order, the imbalance of the first string must not exceed\n    // the negative balance (close parentheses) of the second string.\n    bool canConcatenateSecondOrder = balance2 >= 0 && balance1 <= balance2;\n\n    if(canConcatenateFirstOrder || canConcatenateSecondOrder)\n        return \"Yes\";\n    else\n        return \"No\";\n}\n\n// Example usage:\n"}
{"task_id": "CPP/120", "generation": "#include <vector>\n#include <algorithm> // for std::sort\n\nusing namespace std;\n\nvector<int> maximum(vector<int> arr, int k) {\n    // Step 1: Sort the array in ascending order.\n    sort(arr.begin(), arr.end());\n    \n    // Step 2: Extract the last k elements from the sorted vector.\n    vector<int> result;\n    for (int i = arr.size() - k; i < arr.size(); ++i) {\n        result.push_back(arr[i]);\n    }\n    \n    return result;\n}\n\n// Example usage:\n/*\nvector<int> example1 = {-3, -4, 5};\nvector<int> output1 = maximum(example1, 3); // Output: {-4, -3, 5}\n\nvector<int> example2 = {4, -4, 4};\nvector<int> output2 = maximum(example2, 2); // Output: {4, 4}\n\nvector<int> example3 = {-3, 2, 1, 2, -1, -2, 1};\nvector<int> output3 = maximum(example3, 1); // Output: {2}\n*/\n"}
{"task_id": "CPP/121", "generation": "#include <vector>\nusing namespace std;\n\nint solution(vector<int> lst) {\n    int sum = 0;\n    \n    // Iterate through the vector with a step of 2 to check even positions (0-indexed)\n    for(int i = 0; i < lst.size(); i += 2) {\n        if(lst[i] % 2 != 0) { // Check if the element is odd\n            sum += lst[i];\n        }\n    }\n    \n    return sum;\n}\n"}
{"task_id": "CPP/122", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint add_elements(vector<int> arr, int k) {\n    // Initialize the sum to zero.\n    int sum = 0;\n    \n    // Iterate through the first k elements of the array.\n    for(int i = 0; i < k; ++i) {\n        // Check if the current element has at most two digits.\n        if(arr[i] >= 0 && arr[i] <= 99) {\n            sum += arr[i]; // Add it to the sum if it does.\n        }\n    }\n\n    return sum;\n}\n\n// Function to test the solution with given data points\nvoid check() {\n    vector<int> arr = {111,21,3,4000,5,6,7,8,9};\n    int k = 4;\n    cout << \"The sum is: \" << add_elements(arr, k) << endl; // Expected output: 24\n}\n\n"}
{"task_id": "CPP/123", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // For std::sort\n\nusing namespace std;\n\nvector<int> get_odd_collatz(int n) {\n    vector<int> oddNumbers;\n    \n    while (n != 1) {\n        if (n % 2 == 1) { // Check if the number is odd\n            oddNumbers.push_back(n);\n        }\n        if (n % 2 == 0) { // If even, divide by 2\n            n /= 2;\n        } else { // If odd, apply the Collatz formula\n            n = 3 * n + 1;\n        }\n    }\n    \n    // Add the last number in the sequence which is always 1 and is odd.\n    oddNumbers.push_back(1);\n    \n    // Sort the vector of odd numbers before returning it.\n    sort(oddNumbers.begin(), oddNumbers.end());\n    \n    return oddNumbers;\n}\n\n// Function to test the get_odd_collatz function\nvoid check() {\n    vector<int> result = get_odd_collatz(5);\n    for (int num : result) {\n        cout << num << \" \";\n    }\n    // Expected output: 1 5\n    cout << endl;\n    \n    result = get_odd_collatz(7); \n    for (int num : result) {\n        cout << num << \" \";\n    }\n    // Expected output: 1 7 11 22\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/124", "generation": "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nbool valid_date(const string& date) {\n    // Check if the date string is empty or not in mm-dd-yyyy format.\n    if (date.length() != 10 || date[2] != '-' || date[5] != '-') return false;\n    \n    vector<int> days_in_month = {31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\n    \n    // Extract month, day and year from the date string.\n    int month = stoi(date.substr(0, 2));\n    int day = stoi(date.substr(3, 2));\n    int year = stoi(date.substr(6, 4));\n\n    // Validate month\n    if (month < 1 || month > 12) return false;\n\n    // Validate day based on the month and leap year for February.\n    if (day < 1 || day > days_in_month[month - 1]) return false;\n    \n    // Special case for February in a non-leap year\n    if (month == 2 && day == 29) {\n        bool is_leap_year = ((year % 4 == 0 && year % 100 != 0) || (year % 400 == 0));\n        if (!is_leap_year) return false;\n    }\n\n    // If all checks pass, the date is valid.\n    return true;\n}\n\n"}
{"task_id": "CPP/125", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nvector<string> split_words(string txt) {\n    // Check for spaces\n    if (txt.find(' ') != string::npos) {\n        return vector<string>(begin(txt), end(txt));\n    }\n    \n    // Check for commas\n    if (txt.find(',') != string::npos) {\n        size_t start = 0;\n        size_t end = txt.find(',');\n        vector<string> result;\n        \n        while (end != string::npos) {\n            result.push_back(txt.substr(start, end - start));\n            start = end + 1;\n            end = txt.find(',', start);\n        }\n        \n        // Add the last segment\n        result.push_back(txt.substr(start));\n        return result;\n    }\n\n    // Count lowercase letters with odd order positions in the alphabet\n    int countOddLetters = 0;\n    for (char c : txt) {\n        if (islower(c)) {\n            int position = c - 'a';\n            if (position % 2 == 1) { // Odd position, ord(\"b\") = 1, ord(\"d\") = 3, etc.\n                countOddLetters++;\n            }\n        }\n    }\n\n    return vector<string>{to_string(countOddLetters)};\n}\n\n"}
{"task_id": "CPP/126", "generation": "#include <vector>\n#include <algorithm>\n\nbool is_sorted(std::vector<int> lst) {\n    // Check if the list is empty or has only one element, which is always sorted.\n    if (lst.size() <= 1) return true;\n\n    int count = 1; // To keep track of how many times a number appears consecutively.\n\n    for (size_t i = 1; i < lst.size(); ++i) {\n        // If the current element is less than the previous one, it's not sorted.\n        if (lst[i] < lst[i - 1]) return false;\n\n        // Check how many times a number appears consecutively.\n        if (lst[i] == lst[i - 1]) {\n            count++;\n            // If any number appears more than twice, return false.\n            if (count > 2) return false;\n        } else {\n            count = 1; // Reset the counter for different numbers.\n        }\n    }\n\n    return true;\n}\n"}
{"task_id": "CPP/127", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nbool isPrime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\nstring intersection(vector<int> interval1, vector<int> interval2) {\n    int startMax = max(interval1[0], interval2[0]);\n    int endMin = min(interval1[1], interval2[1]);\n\n    if (startMax > endMin) {\n        // No intersection\n        return \"NO\";\n    }\n\n    int lengthOfIntersection = endMin - startMax + 1;\n\n    if (isPrime(lengthOfIntersection)) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n\n"}
{"task_id": "CPP/128", "generation": "#include <vector>\n#include <cmath> // For std::abs\n\nint prod_signs(std::vector<int> arr) {\n    if (arr.empty()) return -32768; // Return special value for empty vector\n    \n    int signProduct = 1;\n    int magnitudeSum = 0;\n\n    for (auto num : arr) {\n        magnitudeSum += std::abs(num); // Sum of magnitudes\n        if (num == 0) { \n            signProduct = 0; // If any number is zero, the product of signs will be zero.\n            break;\n        } else if (num < 0) {\n            signProduct *= -1; // Multiply by -1 for negative numbers\n        }\n    }\n\n    return magnitudeSum * signProduct;\n}\n\n// Example usage:\n"}
{"task_id": "CPP/129", "generation": "#include <vector>\n#include <queue>\nusing namespace std;\n\n// Directions for moving in the grid (up, down, left, right)\nconst vector<pair<int, int>> directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n\nvector<int> minPath(vector<vector<int>>& grid, int k) {\n    int N = grid.size();\n    \n    // Priority queue to store the paths. The path with the smallest lexicographical order will be at the top.\n    auto comp = [](const vector<int>& a, const vector<int>& b) { return a > b; };\n    priority_queue<vector<int>, vector<vector<int>>, decltype(comp)> pq(comp);\n    \n    // Start from every cell\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            pq.push({grid[i][j]});\n        }\n    }\n\n    while (!pq.empty()) {\n        vector<int> path = pq.top();\n        pq.pop();\n\n        // If the current path length is k, return it\n        if (path.size() == k) return path;\n\n        int lastRow = path.back() / N;\n        int lastCol = path.back() % N;\n\n        // Explore all possible moves from the last cell in the current path\n        for (const auto& dir : directions) {\n            int newRow = lastRow + dir.first;\n            int newCol = lastCol + dir.second;\n\n            if (newRow >= 0 && newRow < N && newCol >= 0 && newCol < N) {\n                vector<int> newPath(path);\n                newPath.push_back(grid[newRow][N * newRow + newCol]);\n                pq.push(newPath);\n            }\n        }\n    }\n\n    // If no path of length k is found, return an empty vector (though the problem guarantees a unique answer)\n    return {};\n}\n"}
{"task_id": "CPP/130", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvector<int> tri(int n) {\n    vector<int> result(n + 1);\n    \n    // Initial conditions\n    if (n >= 0) result[0] = 0;\n    if (n >= 1) result[1] = 1;\n    if (n >= 2) result[2] = 1;\n\n    for(int i = 3; i <= n; ++i){\n        if(i % 2 == 0)\n            result[i] = 1 + i / 2;\n        else\n            result[i] = result[i - 1] + result[i - 2] + result[i - 3];\n    }\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/131", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint digits(int n) {\n    string numStr = to_string(n); // Convert integer to string for easy digit access\n    int product = 1; // Initialize product with 1\n    \n    bool hasOddDigit = false;\n    \n    for (char c : numStr) { // Iterate through each character in the string\n        int digit = c - '0'; // Convert char to int\n        \n        if (digit % 2 != 0) { // Check if the digit is odd\n            product *= digit; // Multiply it into the product\n            hasOddDigit = true;\n        }\n    }\n    \n    return hasOddDigit ? product : 0; // Return product or 0 based on whether there was an odd digit\n}\n\n"}
{"task_id": "CPP/132", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_nested(string str) {\n    int depth = 0;\n    bool hasNested = false; // This will be true if we find at least one nested pair\n\n    for (char c : str) {\n        if (c == '[') {\n            depth++;\n            if (depth > 1) { // If the depth is greater than 1, it means there's a nested bracket\n                hasNested = true;\n            }\n        } else if (c == ']') {\n            depth--;\n            if (depth < 0) return false; // This ensures that brackets are properly closed\n        }\n    }\n\n    // The string must be balanced and have at least one nested pair to return true.\n    return hasNested && depth == 0;\n}\n\n"}
{"task_id": "CPP/133", "generation": "#include <iostream>\n#include <vector>\n#include <cmath> // for ceil and pow functions\n\nusing namespace std;\n\nint sum_squares(vector<float> lst){\n    int sum = 0;\n    for (float num : lst) {\n        float ceilingValue = ceil(num); // Round up to the nearest integer\n        sum += pow(ceilingValue, 2); // Square it and add to sum\n    }\n    return sum;\n}\n\n"}
{"task_id": "CPP/134", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool check_if_last_char_is_a_letter(string txt) {\n    // Check if string is empty or ends with a space.\n    if (txt.empty() || txt.back() == ' ') return false;\n    \n    // Get the last character of the string.\n    char lastChar = txt.back();\n    \n    // Check if it's an alphabetical character and not part of a word.\n    bool isAlphabetical = isalpha(lastChar);\n    bool isNotPartOfWord = (txt.size() == 1 || txt[txt.size()-2] == ' ');\n    \n    return isAlphabetical && isNotPartOfWord;\n}\n\n"}
{"task_id": "CPP/135", "generation": "#include <vector>\nusing namespace std;\n\nint can_arrange(vector<int> arr) {\n    // Iterate through the vector starting from the second element.\n    for (size_t i = 1; i < arr.size(); ++i) {\n        // Check if the current element is not greater than or equal to its preceding element.\n        if (arr[i] < arr[i - 1]) {\n            return static_cast<int>(i); // Return the index of this element.\n        }\n    }\n    // If no such element exists, return -1.\n    return -1;\n}\n"}
{"task_id": "CPP/136", "generation": "#include <vector>\n#include <algorithm> // For std::min and std::max\n\nusing namespace std;\n\nvector<int> largest_smallest_integers(vector<int> lst){\n    int largestNegative = 0;\n    int smallestPositive = 0;\n    \n    bool foundNegative = false;\n    bool foundPositive = false;\n    \n    for(int num : lst) {\n        if(num < 0) {\n            // Update the largest negative number\n            if(!foundNegative || num > largestNegative) {\n                largestNegative = num;\n                foundNegative = true;\n            }\n        } else if (num > 0) {\n            // Update the smallest positive number\n            if(!foundPositive || num < smallestPositive) {\n                smallestPositive = num;\n                foundPositive = true;\n            }\n        }\n    }\n\n    return {largestNegative, smallestPositive};\n}\n\n// Example usage:\n"}
{"task_id": "CPP/137", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <locale>\n#include <sstream>\n#include <boost/any.hpp>\n\nusing namespace std;\n\n// Function to convert string representation of a number into float.\nfloat parseNumber(const string& str) {\n    // Replace comma with dot if present for correct parsing.\n    string temp = str;\n    replace(temp.begin(), temp.end(), ',', '.');\n    \n    stringstream ss(temp);\n    float num;\n    ss >> num;\n    return num;\n}\n\n// Function to compare two values of any type and return the larger one or \"None\" if equal.\nboost::any compare_one(boost::any a, boost::any b) {\n    // Convert both inputs into floats for comparison\n    float fa = 0.0f, fb = 0.0f;\n    \n    try {\n        // Try to convert any type of input to float\n        if (a.type() == typeid(int)) {\n            fa = boost::any_cast<int>(a);\n        } else if (a.type() == typeid(float)) {\n            fa = boost::any_cast<float>(a);\n        } else if (a.type() == typeid(string)) {\n            fa = parseNumber(boost::any_cast<string>(a));\n        }\n\n        if (b.type() == typeid(int)) {\n            fb = boost::any_cast<int>(b);\n        } else if (b.type() == typeid(float)) {\n            fb = boost::any_cast<float>(b);\n        } else if (b.type() == typeid(string)) {\n            fb = parseNumber(boost::any_cast<string>(b));\n        }\n    } catch (...) {\n        // In case of any error in conversion, return \"None\"\n        return string(\"None\");\n    }\n\n    // Compare the numbers\n    if (fa > fb) {\n        return a;\n    } else if (fb > fa) {\n        return b;\n    } else {\n        return string(\"None\");  // Return \"None\" if equal\n    }\n}\n\n"}
{"task_id": "CPP/138", "generation": "#include <iostream>\nusing namespace std;\n\nbool is_equal_to_sum_even(int n) {\n    // Check if n is at least 8 and an even number.\n    return (n >= 8 && n % 2 == 0);\n}\n\n"}
{"task_id": "CPP/139", "generation": "#include <iostream>\nusing namespace std;\n\n// Function to calculate factorial of a given number\nlong long factorial(int num) {\n    if (num == 0 || num == 1)\n        return 1;\n    else\n        return num * factorial(num - 1);\n}\n\n// Function to calculate the Brazilian factorial as defined\nlong long special_factorial(int n){\n    long long result = 1;\n    for(int i = 1; i <= n; ++i) {\n        result *= factorial(i);\n    }\n    return result;\n}\n\n"}
{"task_id": "CPP/140", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring fix_spaces(string text) {\n    string result;\n    int spaceCount = 0; // Counter for consecutive spaces\n\n    for (char c : text) {\n        if (c == ' ') {\n            ++spaceCount;\n        } else {\n            if (spaceCount > 2) {\n                result += '-';\n            } else {\n                while (spaceCount > 0) {\n                    result += '_';\n                    --spaceCount;\n                }\n            }\n            spaceCount = 0; // Reset the counter\n            result += c;\n        }\n    }\n\n    // Handle trailing spaces if any\n    if (spaceCount > 2) {\n        result += '-';\n    } else {\n        while (spaceCount > 0) {\n            result += '_';\n            --spaceCount;\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/141", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring file_name_check(string file_name) {\n    // Check for exactly one dot in the name.\n    size_t dotPos = file_name.find('.');\n    if (dotPos == string::npos || file_name.find('.', dotPos + 1) != string::npos)\n        return \"No\";\n\n    // Split the filename into two parts: before and after the dot\n    string prefix = file_name.substr(0, dotPos);\n    string suffix = file_name.substr(dotPos + 1);\n\n    // Check if there are more than three digits in the prefix.\n    int digitCount = 0;\n    for (char c : prefix) {\n        if (isdigit(c)) digitCount++;\n        if (digitCount > 3) return \"No\";\n    }\n\n    // Validate that the prefix starts with a letter and is not empty\n    if (prefix.empty() || !isalpha(prefix[0])) \n        return \"No\";\n\n    // Check valid extensions.\n    string validExtensions[] = {\"txt\", \"exe\", \"dll\"};\n    bool isValidExtension = false;\n    for (string ext : validExtensions) {\n        if (ext == suffix) {\n            isValidExtension = true;\n            break;\n        }\n    }\n\n    if (!isValidExtension)\n        return \"No\";\n\n    // If all checks pass, the filename is valid.\n    return \"Yes\";\n}\n\n"}
{"task_id": "CPP/142", "generation": "#include <vector>\nusing namespace std;\n\nint sum_squares(vector<int> lst) {\n    int sum = 0;\n    \n    for (size_t i = 0; i < lst.size(); ++i) {\n        if (i % 3 == 0) { // If index is a multiple of 3\n            sum += lst[i] * lst[i]; // Square the element and add to sum\n        } else if (i % 4 == 0 && i % 3 != 0) { // If index is a multiple of 4 but not 3\n            sum += lst[i] * lst[i] * lst[i]; // Cube the element and add to sum\n        } else {\n            sum += lst[i]; // Add the element as it is if no condition matches\n        }\n    }\n\n    return sum;\n}\n\n// Example usage:\n"}
{"task_id": "CPP/143", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\n// Helper function to check if a number is prime\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    for (int i = 2; i * i <= num; ++i) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\n// Main function to filter words based on prime length\nstring words_in_sentence(string sentence) {\n    stringstream ss(sentence);\n    string word, result;\n    \n    while (ss >> word) { // Extract each word from the sentence\n        if (is_prime(word.length())) {\n            if (!result.empty()) result += \" \"; // Add space before appending new word\n            result += word; // Append prime length words to result\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/144", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool simplify(string x, string n) {\n    // Parsing fractions\n    size_t slashPos;\n    \n    int numX = stoi(x.substr(0, (slashPos = x.find('/'))));\n    int denX = stoi(x.substr(slashPos + 1));\n\n    int numN = stoi(n.substr(0, (slashPos = n.find('/'))));\n    int denN = stoi(n.substr(slashPos + 1));\n\n    // Multiplying the fractions\n    int numeratorResult = numX * numN;\n    int denominatorResult = denX * denN;\n\n    // Simplifying to check if it's a whole number\n    return (numeratorResult % denominatorResult == 0);\n}\n\n"}
{"task_id": "CPP/145", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // for std::sort\n\n// Helper function to calculate sum of digits.\nint digit_sum(int n) {\n    int sum = 0;\n    while (n != 0) {\n        sum += n % 10;\n        n /= 10;\n    }\n    return sum;\n}\n\nvector<int> order_by_points(vector<int> nums){\n    // Create a vector of pairs to store the original index and value\n    std::vector<std::pair<int, int>> indexed_nums(nums.size());\n    \n    for (size_t i = 0; i < nums.size(); ++i) {\n        indexed_nums[i] = {digit_sum(nums[i]), static_cast<int>(i)};\n    }\n    \n    // Sort the vector of pairs based on digit sum and then by original index\n    std::sort(indexed_nums.begin(), indexed_nums.end(),\n              [](const auto& a, const auto& b) {\n                  return (a.first == b.first) ? a.second < b.second : a.first < b.first;\n              });\n    \n    // Reconstruct the sorted vector based on the sorted indices\n    std::vector<int> result(nums.size());\n    for (size_t i = 0; i < indexed_nums.size(); ++i) {\n        result[i] = nums[indexed_nums[i].second];\n    }\n    \n    return result;\n}\n\n// Function to check if two vectors are equal\nbool vector_equal(const std::vector<int>& a, const std::vector<int>& b) {\n    return a == b;\n}\n\n"}
{"task_id": "CPP/146", "generation": "#include <vector>\n#include <string>\nusing namespace std;\n\nbool isFirstAndLastDigitOdd(int num) {\n    // Convert to string to easily access first and last digit\n    string strNum = to_string(abs(num));  // Use abs to handle negative numbers\n    char firstDigit = strNum[0];\n    char lastDigit = strNum[strNum.length() - 1];\n\n    // Check if both digits are odd\n    return (firstDigit == '1' || firstDigit == '3' || firstDigit == '5' || \n            firstDigit == '7' || firstDigit == '9') &&\n           (lastDigit == '1' || lastDigit == '3' || lastDigit == '5' ||\n            lastDigit == '7' || lastDigit == '9');\n}\n\nint specialFilter(vector<int> nums) {\n    int count = 0;\n    for(int num : nums) {\n        if(num > 10 && isFirstAndLastDigitOdd(num)) {\n            ++count;\n        }\n    }\n    return count;\n}\n"}
{"task_id": "CPP/147", "generation": "#include<iostream>\n#include<vector>\n\nusing namespace std;\n\nint get_max_triples(int n) {\n    vector<int> a(n);\n    \n    // Fill the array with values according to the given formula.\n    for (int i = 0; i < n; ++i) {\n        a[i] = (i + 1) * (i + 1) - (i + 1) + 1;\n    }\n    \n    int count = 0;\n\n    // Iterate through all possible triples and check the condition.\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            for (int k = j + 1; k < n; ++k) {\n                if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                    count++;\n                }\n            }\n        }\n    }\n\n    return count;\n}\n\n// Function to test the solution with given data points.\nvoid check_solution() {\n    cout << \"For n = 5, Expected: 1, Got: \" << get_max_triples(5) << endl;\n    // You can add more tests here as needed\n}\n\n"}
{"task_id": "CPP/148", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to find planets between two given planets.\nvector<string> bf(string planet1, string planet2) {\n    // Mapping of each planet name to its position relative to the Sun.\n    vector<pair<string, int>> solarSystem = {\n        {\"Mercury\", 1}, {\"Venus\", 2}, {\"Earth\", 3},\n        {\"Mars\", 4}, {\"Jupiter\", 5}, {\"Saturn\", 6},\n        {\"Uranus\", 7}, {\"Neptune\", 8}\n    };\n\n    // Find the positions of planet1 and planet2.\n    int pos1 = -1, pos2 = -1;\n    for (const auto& planet : solarSystem) {\n        if (planet.first == planet1)\n            pos1 = planet.second;\n        else if (planet.first == planet2)\n            pos2 = planet.second;\n\n        // If both positions are found, break the loop.\n        if (pos1 != -1 && pos2 != -1)\n            break;\n    }\n\n    // Check if either of the planets was not found.\n    if (pos1 == -1 || pos2 == -1) {\n        return {};  // Return an empty vector if any planet is invalid.\n    }\n\n    // Ensure pos1 < pos2 for simplicity in the loop below.\n    if (pos1 > pos2)\n        swap(pos1, pos2);\n\n    // Collect all planets between pos1 and pos2.\n    vector<string> result;\n    for (const auto& planet : solarSystem) {\n        int position = planet.second;\n        if (position > pos1 && position < pos2) {\n            result.push_back(planet.first);\n        }\n    }\n\n    return result;\n}\n\n// Function to test the bf function with examples.\nvoid check() {\n    vector<string> res;\n\n    // Example 1\n    res = bf(\"Jupiter\", \"Neptune\");\n    for (const auto& planet : res)\n        cout << planet << \" \";\n    cout << endl;  // Expected: Saturn Uranus\n\n    // Example 2\n    res = bf(\"Earth\", \"Mercury\");\n    for (const auto& planet : res)\n        cout << planet << \" \";\n    cout << endl;  // Expected: Venus\n\n    // Example 3\n    res = bf(\"Mercury\", \"Uranus\");\n    for (const auto& planet : res)\n        cout << planet << \" \";\n    cout << endl;  // Expected: Venus Earth Mars Jupiter Saturn\n}\n\n"}
{"task_id": "CPP/149", "generation": "#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to filter out strings with odd lengths and sort the rest.\nvector<string> filter_and_sort(vector<string> lst) {\n    // Remove strings of odd length\n    vector<string>::iterator it = lst.begin();\n    while (it != lst.end()) {\n        if ((*it).size() % 2 != 0) { // Check for odd length\n            it = lst.erase(it); // Erase and get the new iterator position\n        } else {\n            ++it; // Move to next element\n        }\n    }\n\n    // Sort by length, then alphabetically if lengths are equal\n    sort(lst.begin(), lst.end(), [](const string& a, const string& b) {\n        return make_pair(a.size(), a) < make_pair(b.size(), b);\n    });\n\n    return lst;\n}\n\n// Function to test the correctness of our solution.\nvoid assert_vector_sort() {\n    vector<string> result = filter_and_sort({\"aa\", \"a\", \"aaa\"});\n    assert((result == vector<string>{\"aa\"}));\n\n    result = filter_and_sort({\"ab\", \"a\", \"aaa\", \"cd\"});\n    assert((result == vector<string>{\"ab\", \"cd\"}));\n}\n\n"}
{"task_id": "CPP/150", "generation": "#include <iostream>\nusing namespace std;\n\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    if (n == 2 || n == 3) return true; // 2 and 3 are prime numbers\n    if (n % 2 == 0 || n % 3 == 0) return false; // Eliminate multiples of 2 and 3\n\n    for (int i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0)\n            return false;\n    }\n    return true;\n}\n\nint x_or_y(int n, int x, int y){\n    if(is_prime(n)) \n        return x;\n    else\n        return y;\n}\n\n// Example usage:\n/*\n"}
{"task_id": "CPP/151", "generation": "#include <vector>\n#include <cmath> // For std::pow\n\nusing namespace std;\n\nlong long double_the_difference(vector<float> lst) {\n    long long sum = 0;\n    \n    for (float num : lst) {\n        if (num > 0 && floor(num) == num && static_cast<int>(num) % 2 != 0) { // Check if positive, integer and odd\n            int n = static_cast<int>(num);\n            sum += pow(n, 2); // Square the number and add to sum\n        }\n    }\n\n    return sum;\n}\n\n// Test cases\n"}
{"task_id": "CPP/152", "generation": "#include <iostream>\n#include <vector>\n#include <cmath> // For std::abs\n\nusing namespace std;\n\nvector<int> compare(vector<int>& game, vector<int>& guess) {\n    vector<int> result;\n    \n    for (size_t i = 0; i < game.size(); ++i) {\n        int diff = abs(game[i] - guess[i]);\n        result.push_back(diff);\n    }\n    \n    return result;\n}\n\n// Function to print the vector\nvoid printVector(const vector<int>& vec) {\n    cout << \"{\";\n    for (size_t i = 0; i < vec.size(); ++i) {\n        if (i != 0) cout << \",\";\n        cout << vec[i];\n    }\n    cout << \"}\" << endl;\n}\n\n"}
{"task_id": "CPP/153", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to calculate the strength of an extension.\nint CalculateStrength(const string& extension) {\n    int uppercase = 0;\n    int lowercase = 0;\n    \n    for (char c : extension) {\n        if (isupper(c)) uppercase++;\n        else if (islower(c)) lowercase++;\n    }\n    \n    return uppercase - lowercase;\n}\n\nstring Strongest_Extension(string class_name, vector<string> extensions) {\n    string strongest_extension = \"\";\n    int max_strength = INT_MIN; // Initialize with the smallest possible integer.\n    \n    for (const auto& extension : extensions) {\n        int strength = CalculateStrength(extension);\n        \n        if (strength > max_strength || (strength == max_strength && strongest_extension.empty())) {\n            max_strength = strength;\n            strongest_extension = extension;\n        }\n    }\n    \n    return class_name + \".\" + strongest_extension;\n}\n\n"}
{"task_id": "CPP/154", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool cycpattern_check(string a, string b) {\n    // Concatenate the first string with itself.\n    string aa = a + a;\n    \n    // Check if the second string is a substring of the concatenated string.\n    return aa.find(b) != string::npos && b.length() <= a.length();\n}\n\n"}
{"task_id": "CPP/155", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<int> even_odd_count(int num){\n    // Convert number to its absolute value to handle negative numbers\n    int absNum = abs(num);\n    \n    // Convert integer to string for easy digit extraction\n    string strNum = to_string(absNum);\n\n    // Initialize counters for even and odd digits\n    int evenCount = 0;\n    int oddCount = 0;\n\n    // Iterate through each character in the string\n    for (char c : strNum) {\n        // Convert char to integer digit\n        int digit = c - '0';\n        \n        // Check if the digit is even or odd and increment respective counter\n        if (digit % 2 == 0) {\n            evenCount++;\n        } else {\n            oddCount++;\n        }\n    }\n\n    // Return a vector containing counts of even and odd digits respectively\n    return {evenCount, oddCount};\n}\n\n// Function to test the solution with given examples\nvoid check() {\n    vector<int> result = even_odd_count(-12);\n    cout << \"even_odd_count(-12) -> {\" << result[0] << \", \" << result[1] << \"}\\n\";\n    \n    result = even_odd_count(123);\n    cout << \"even_odd_count(123) -> {\" << result[0] << \", \" << result[1] << \"}\\n\";\n}\n\n"}
{"task_id": "CPP/156", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring int_to_mini_roman(int number) {\n    // Define the values and corresponding symbols\n    vector<int> values = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    vector<string> symbols = {\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n\n    string roman = \"\";\n    \n    // Iterate over the values and construct the Roman numeral\n    for (int i = 0; number > 0; ++i) {\n        while (number >= values[i]) {\n            roman += symbols[i];\n            number -= values[i];\n        }\n    }\n\n    return roman;\n}\n\n// Example usage:\n"}
{"task_id": "CPP/157", "generation": "#include <iostream>\n#include <cmath>\n\nbool right_angle_triangle(float a, float b, float c){\n    // First, sort the sides so that c is the longest side (hypotenuse)\n    if(a > c) std::swap(a, c);\n    if(b > c) std::swap(b, c);\n\n    // Check the Pythagorean theorem\n    return fabs(a*a + b*b - c*c) < 1e-6; // Using a small threshold to account for floating point precision issues.\n}\n\n"}
{"task_id": "CPP/158", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <set>\nusing namespace std;\n\nstring find_max(vector<string> words) {\n    string result;\n    int max_unique = 0; // To keep track of maximum unique characters\n\n    for (const auto& word : words) {\n        set<char> unique_chars(word.begin(), word.end()); // Use a set to get unique characters\n        int count_unique = unique_chars.size();\n\n        if (count_unique > max_unique || \n            (count_unique == max_unique && word < result)) { // Check lexicographical order as well\n            max_unique = count_unique;\n            result = word;\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/159", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> eat(int number, int need, int remaining) {\n    // Calculate the total number of carrots eaten after trying to eat 'need' more.\n    int totalEaten = number + min(need, remaining);\n    \n    // Calculate how many carrots are left after eating as much as possible.\n    int carrotsLeft = max(0, remaining - need);\n\n    return {totalEaten, carrotsLeft};\n}\n"}
{"task_id": "CPP/160", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nint do_algebra(vector<string> operato, vector<int> operand) {\n    // Initialize result with the first operand.\n    int result = operand[0];\n    \n    for (size_t i = 0; i < operato.size(); ++i) {\n        if (operato[i] == \"+\") {\n            result += operand[i + 1];\n        } else if (operato[i] == \"-\") {\n            result -= operand[i + 1];\n        } else if (operato[i] == \"*\") {\n            result *= operand[i + 1];\n        } else if (operato[i] == \"//\") {\n            // Floor division\n            result = floor((double)result / operand[i + 1]);\n        } else if (operato[i] == \"**\") {\n            // Exponentiation\n            result = pow(result, operand[i + 1]);\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/161", "generation": "#include <iostream>\n#include <string>\n#include <cctype> // For std::isalpha and std::islower\n\nusing namespace std;\n\nstring solve(string s) {\n    bool hasLetters = false;\n    \n    // Check if the string contains any letters.\n    for (char c : s) {\n        if (std::isalpha(c)) {\n            hasLetters = true;\n            break;\n        }\n    }\n\n    // If no letters are present, reverse the entire string.\n    if (!hasLetters) {\n        std::reverse(s.begin(), s.end());\n        return s;\n    }\n\n    // Otherwise, change the case of each letter and keep other characters as they are.\n    for (char &c : s) {\n        if (std::isalpha(c)) {\n            c = std::islower(c) ? toupper(c) : tolower(c);\n        }\n    }\n\n    return s;\n}\n\n"}
{"task_id": "CPP/162", "generation": "#include <iostream>\n#include <string>\n#include <openssl/md5.h>\n\nusing namespace std;\n\nstring string_to_md5(string text) {\n    if (text.empty()) return \"None\"; // Return \"None\" for empty strings\n\n    unsigned char digest[MD5_DIGEST_LENGTH];\n    MD5((unsigned char*)text.c_str(), text.length(), (unsigned char*)&digest);    \n\n    char mdString[33];\n    for(int i = 0; i < 16; ++i)\n        sprintf(&mdString[i*2], \"%02x\", (unsigned int)digest[i]);\n\n    return string(mdString);\n}\n\n"}
{"task_id": "CPP/163", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // For std::min and std::max\n\nusing namespace std;\n\nvector<int> generate_integers(int a, int b) {\n    vector<int> evenDigits = {2, 4, 6, 8}; // All possible even digits less than 10\n    vector<int> result;\n    \n    // Ensure a is the smaller number and b is the larger one\n    int start = min(a, b);\n    int end = max(a, b);\n\n    for (int digit : evenDigits) {\n        if (digit >= start && digit <= end) {\n            result.push_back(digit);\n        }\n    }\n\n    return result;\n}\n\n// Function to print vector elements\nvoid printVector(const vector<int>& vec) {\n    cout << \"{\";\n    for(size_t i = 0; i < vec.size(); ++i) {\n        if (i != 0) cout << \", \";\n        cout << vec[i];\n    }\n    cout << \"}\" << endl;\n}\n\n"}
