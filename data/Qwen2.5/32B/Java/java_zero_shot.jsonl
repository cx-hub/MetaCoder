{"task_id": "Java/0", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Check if in a given list of numbers, there are any two numbers closer to each other than a given threshold.\n     *\n     * @param numbers A List<Double> containing the numbers to be checked.\n     * @param threshold The threshold distance that should not be exceeded by any pair of elements.\n     * @return true if any two numbers in the list are closer than the threshold, false otherwise.\n     */\n    public boolean has_close_elements(List<Double> numbers, double threshold) {\n        // Sort the list to make it easier to find close pairs\n        Collections.sort(numbers);\n\n        for (int i = 0; i < numbers.size() - 1; i++) {\n            if (numbers.get(i + 1) - numbers.get(i) < threshold) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        List<Double> testList1 = Arrays.asList(1.0, 2.0, 3.0);\n        double threshold1 = 0.5;\n        System.out.println(solution.has_close_elements(testList1, threshold1)); // Expected: false\n\n        // Test case 2\n        List<Double> testList2 = Arrays.asList(1.0, 2.8, 3.0, 4.0, 5.0, 2.0);\n        double threshold2 = 0.3;\n        System.out.println(solution.has_close_elements(testList2, threshold2)); // Expected: true\n\n        // Additional test case\n        List<Double> testList3 = Arrays.asList(1.0, 1.4, 1.5, 2.0);\n        double threshold3 = 0.1;\n        System.out.println(solution.has_close_elements(testList3, threshold3)); // Expected: false\n\n        // Additional test case\n        List<Double> testList4 = Arrays.asList(1.0, 1.09, 1.5, 2.0);\n        double threshold4 = 0.1;\n        System.out.println(solution.has_close_elements(testList4, threshold4)); // Expected: true\n    }\n}\n"}
{"task_id": "Java/1", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Separates multiple groups of nested parentheses into separate strings.\n     *\n     * @param paren_string The input string containing groups of nested parentheses.\n     * @return A list of separated groups as strings.\n     */\n    public List<String> separate_paren_groups(String paren_string) {\n        // Remove spaces from the input\n        String noSpaceString = paren_string.replaceAll(\"\\\\s+\", \"\");\n        \n        List<String> result = new ArrayList<>();\n        int balance = 0;\n        StringBuilder currentGroup = new StringBuilder();\n        \n        for (char c : noSpaceString.toCharArray()) {\n            if (c == '(') {\n                balance++;\n            } else if (c == ')') {\n                balance--;\n            }\n            \n            currentGroup.append(c);\n            \n            // When balance is zero, we have a complete group\n            if (balance == 0 && !currentGroup.toString().isEmpty()) {\n                result.add(currentGroup.toString());\n                currentGroup = new StringBuilder(); // Reset for the next group\n            }\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        List<String> test1Result = solution.separate_paren_groups(\"( ) (( )) (( )( ))\");\n        System.out.println(test1Result); // Expected: [\"()\", \"(())\", \"(()())\"]\n        \n        List<String> test2Result = solution.separate_paren_groups(\"() (()) ()\");\n        System.out.println(test2Result); // Expected: [\"()\", \"(())\", \"()\"]\n    }\n}\n"}
{"task_id": "Java/2", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a positive floating point number, it can be decomposed into\n     * an integer part (largest integer smaller than given number) and decimals\n     * (leftover part always smaller than 1).\n     *\n     * Return the decimal part of the number.\n     */\n    public double truncate_number(double number) {\n        return number - Math.floor(number);\n    }\n}\n\n// Test class for Solution using JUnit framework\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\n\nclass SolutionTest {\n\n    @Test\n    public void testTruncateNumber() {\n        Solution solution = new Solution();\n        \n        // Test case 1: Positive number with decimal part\n        assertEquals(0.5, solution.truncate_number(3.5), 0.001);\n        \n        // Test case 2: Another positive number with decimal part\n        assertEquals(0.75, solution.truncate_number(4.75), 0.001);\n\n        // Test case 3: Positive integer (should return 0)\n        assertEquals(0.0, solution.truncate_number(5.0), 0.001);\n        \n        // Test case 4: Zero\n        assertEquals(0.0, solution.truncate_number(0.0), 0.001);\n\n        // Test case 5: Positive number very close to an integer\n        assertEquals(0.0001, solution.truncate_number(3.0001), 0.001);\n    }\n}\n"}
{"task_id": "Java/3", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Checks if the balance goes below zero after performing a series of deposits and withdrawals.\n     *\n     * @param operations List of integers where positive values are deposits and negative values are withdrawals.\n     * @return true if the balance falls below zero at any point, false otherwise.\n     */\n    public boolean below_zero(List<Integer> operations) {\n        int balance = 0; // Starting balance is zero\n        for (int operation : operations) {\n            balance += operation;\n            if (balance < 0) {\n                return true; // Balance falls below zero\n            }\n        }\n        return false; // Never went below zero\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case 1: No balance goes below zero\n        System.out.println(solution.below_zero(Arrays.asList(1, 2, 3))); // Expected output: false\n        \n        // Test case 2: Balance falls below zero after the third operation (-4)\n        System.out.println(solution.below_zero(Arrays.asList(1, 2, -4, 5))); // Expected output: true\n    }\n}\n"}
{"task_id": "Java/4", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * For a given list of input numbers, calculates Mean Absolute Deviation around the mean.\n     * MAD = average | x - x_mean |\n     *\n     * @param numbers List of Double values for which to calculate the MAD.\n     * @return The calculated Mean Absolute Deviation as double.\n     */\n    public double mean_absolute_deviation(List<Double> numbers) {\n        if (numbers == null || numbers.isEmpty()) return 0.0;\n\n        // Calculate the mean\n        double sum = 0;\n        for (Double number : numbers) {\n            sum += number;\n        }\n        double mean = sum / numbers.size();\n\n        // Calculate the Mean Absolute Deviation\n        double madSum = 0;\n        for (Double number : numbers) {\n            madSum += Math.abs(number - mean);\n        }\n\n        return madSum / numbers.size();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1: Simple list of numbers\n        List<Double> testList1 = Arrays.asList(1.0, 2.0, 3.0, 4.0);\n        System.out.println(\"MAD for [1.0, 2.0, 3.0, 4.0]: \" + solution.mean_absolute_deviation(testList1)); // Expected: 1.0\n\n        // Test case 2: List with repeated numbers\n        List<Double> testList2 = Arrays.asList(5.0, 5.0, 5.0);\n        System.out.println(\"MAD for [5.0, 5.0, 5.0]: \" + solution.mean_absolute_deviation(testList2)); // Expected: 0.0\n\n        // Test case 3: List with negative numbers\n        List<Double> testList3 = Arrays.asList(-1.0, -2.0, -3.0);\n        System.out.println(\"MAD for [-1.0, -2.0, -3.0]: \" + solution.mean_absolute_deviation(testList3)); // Expected: 1.0\n\n        // Test case 4: Empty list\n        List<Double> testList4 = new ArrayList<>();\n        System.out.println(\"MAD for []: \" + solution.mean_absolute_deviation(testList4)); // Expected: 0.0\n    }\n}\n"}
{"task_id": "Java/5", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Insert a number 'delimiter' between every two consecutive elements of input list `numbers`\n     *\n     * @param numbers List of integers.\n     * @param delimiter The integer to insert between each pair of consecutive elements in the list.\n     * @return A new list with delimiters interspersed.\n     */\n    public List<Integer> intersperse(List<Integer> numbers, int delimiter) {\n        if (numbers.isEmpty()) {\n            return Collections.emptyList();\n        }\n\n        List<Integer> result = new ArrayList<>();\n        for (int i = 0; i < numbers.size(); i++) {\n            result.add(numbers.get(i));\n            // Do not add delimiter after the last element\n            if (i != numbers.size() - 1) {\n                result.add(delimiter);\n            }\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1: Empty list\n        System.out.println(solution.intersperse(new ArrayList<>(), 4)); // Expected output: []\n\n        // Test case 2: List with elements\n        System.out.println(solution.intersperse(Arrays.asList(1, 2, 3), 4)); // Expected output: [1, 4, 2, 4, 3]\n\n        // Additional test cases\n        System.out.println(solution.intersperse(Arrays.asList(5), 0)); // Expected output: [5]\n        System.out.println(solution.intersperse(Arrays.asList(-1, -2, -3), 99)); // Expected output: [-1, 99, -2, 99, -3]\n    }\n}\n"}
{"task_id": "Java/6", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Parses a string containing multiple groups of nested parentheses separated by spaces.\n     * For each group, outputs the deepest level of nesting of parentheses.\n     *\n     * @param paren_string The input string with groups of nested parentheses.\n     * @return A list of integers representing the maximum depth of nesting for each group.\n     */\n    public List<Integer> parse_nested_parens(String paren_string) {\n        List<Integer> result = new ArrayList<>();\n        String[] groups = paren_string.split(\" \");\n        \n        for (String group : groups) {\n            int maxDepth = 0;\n            int currentDepth = 0;\n            \n            for (char c : group.toCharArray()) {\n                if (c == '(') {\n                    currentDepth++;\n                    maxDepth = Math.max(maxDepth, currentDepth);\n                } else if (c == ')') {\n                    currentDepth--;\n                }\n            }\n            \n            result.add(maxDepth);\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.parse_nested_parens(\"(()()) ((())) () ((())()())\")); // Expected: [2, 3, 1, 3]\n        System.out.println(solution.parse_nested_parens(\"(()) (()) (((())))\"));          // Expected: [2, 2, 3]\n    }\n}\n"}
{"task_id": "Java/7", "generation": "import org.junit.Test;\nimport java.util.Arrays;\nimport java.util.List;\n\nimport static org.junit.Assert.assertEquals;\n\nclass SolutionTest {\n\n    @Test\n    public void testFilterBySubstringWithEmptyList() {\n        List<String> input = Arrays.asList();\n        String substring = \"a\";\n        List<String> expectedOutput = Arrays.asList();\n\n        Solution solution = new Solution();\n        List<String> actualOutput = solution.filter_by_substring(input, substring);\n\n        assertEquals(expectedOutput, actualOutput);\n    }\n\n    @Test\n    public void testFilterBySubstringWithSomeMatches() {\n        List<String> input = Arrays.asList(\"abc\", \"bacd\", \"cde\", \"array\");\n        String substring = \"a\";\n        List<String> expectedOutput = Arrays.asList(\"abc\", \"bacd\", \"array\");\n\n        Solution solution = new Solution();\n        List<String> actualOutput = solution.filter_by_substring(input, substring);\n\n        assertEquals(expectedOutput, actualOutput);\n    }\n\n    @Test\n    public void testFilterBySubstringWithNoMatches() {\n        List<String> input = Arrays.asList(\"abc\", \"bacd\", \"cde\");\n        String substring = \"z\";\n        List<String> expectedOutput = Arrays.asList();\n\n        Solution solution = new Solution();\n        List<String> actualOutput = solution.filter_by_substring(input, substring);\n\n        assertEquals(expectedOutput, actualOutput);\n    }\n}\n"}
{"task_id": "Java/8", "generation": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\nclass Solution {\n    /**\n     * For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n     * Empty sum should be equal to 0 and empty product should be equal to 1.\n     *\n     * @param numbers List of integers\n     * @return A list containing two elements: [sum, product]\n     */\n    public List<Integer> sum_product(List<Integer> numbers) {\n        int sum = 0;\n        int product = 1;\n\n        for (Integer number : numbers) {\n            sum += number;\n            product *= number;\n        }\n\n        return new ArrayList<>(Arrays.asList(sum, product));\n    }\n}\n\n// Test class using JUnit\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nclass SolutionTest {\n\n    @Test\n    void testEmptyList() {\n        List<Integer> result = new Solution().sum_product(new ArrayList<>());\n        assertEquals(Arrays.asList(0, 1), result);\n    }\n\n    @Test\n    void testWithNumbers() {\n        List<Integer> result = new Solution().sum_product(Arrays.asList(1, 2, 3, 4));\n        assertEquals(Arrays.asList(10, 24), result);\n    }\n}\n"}
{"task_id": "Java/9", "generation": "import org.junit.jupiter.api.Test;\nimport java.util.Arrays;\nimport java.util.List;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nclass SolutionTest {\n    @Test\n    void testRollingMax() {\n        Solution solution = new Solution();\n        \n        // Test case 1: Normal sequence of numbers\n        List<Integer> input1 = Arrays.asList(1, 2, 3, 2, 3, 4, 2);\n        List<Integer> expectedOutput1 = Arrays.asList(1, 2, 3, 3, 3, 4, 4);\n        assertEquals(expectedOutput1, solution.rolling_max(input1), \"Test case 1 failed\");\n\n        // Test case 2: Sequence with all elements the same\n        List<Integer> input2 = Arrays.asList(5, 5, 5, 5, 5);\n        List<Integer> expectedOutput2 = Arrays.asList(5, 5, 5, 5, 5);\n        assertEquals(expectedOutput2, solution.rolling_max(input2), \"Test case 2 failed\");\n\n        // Test case 3: Sequence with decreasing numbers\n        List<Integer> input3 = Arrays.asList(4, 3, 2, 1);\n        List<Integer> expectedOutput3 = Arrays.asList(4, 4, 4, 4);\n        assertEquals(expectedOutput3, solution.rolling_max(input3), \"Test case 3 failed\");\n\n        // Test case 4: Empty list\n        List<Integer> input4 = new ArrayList<>();\n        List<Integer> expectedOutput4 = new ArrayList<>();\n        assertEquals(expectedOutput4, solution.rolling_max(input4), \"Test case 4 failed\");\n    }\n}\n"}
{"task_id": "Java/10", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Test if given string is a palindrome.\n     */\n    public boolean isPalindrome(String string) {\n        int i = 0;\n        int j = string.length() - 1;\n        while (i < j) {\n            if (string.charAt(i) != string.charAt(j)) {\n                return false;\n            }\n            i++;\n            j--;\n        }\n        return true;\n    }\n\n    /**\n     * Find the shortest palindrome that begins with a supplied string.\n     * Algorithm idea is simple:\n     * - Find the longest postfix of supplied string that is a palindrome.\n     * - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n     */\n    public String make_palindrome(String string) {\n        if (string == null || string.length() <= 1) return string;\n\n        int i = 0;\n        for (; i < string.length(); ++i) {\n            if (isPalindrome(string.substring(i))) break;\n        }\n\n        StringBuilder prefix = new StringBuilder(string.substring(0, i));\n        return string + prefix.reverse().toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.make_palindrome(\"\"));      // \"\"\n        System.out.println(solution.make_palindrome(\"cat\"));   // \"catac\"\n        System.out.println(solution.make_palindrome(\"cata\"));  // \"catac\"\n        System.out.println(solution.make_palindrome(\"abc\"));   // \"abccba\"\n    }\n}\n"}
{"task_id": "Java/11", "generation": "class Solution {\n    /**\n     * Perform binary XOR on two input strings consisting only of 1s and 0s.\n     *\n     * @param a First binary string.\n     * @param b Second binary string.\n     * @return The result of performing binary XOR on the inputs as a String.\n     */\n    public String string_xor(String a, String b) {\n        StringBuilder xorResult = new StringBuilder();\n        \n        // Ensure both strings are of equal length by padding with zeros if necessary\n        int maxLength = Math.max(a.length(), b.length());\n        while (a.length() < maxLength) a = \"0\" + a;\n        while (b.length() < maxLength) b = \"0\" + b;\n\n        for (int i = 0; i < maxLength; i++) {\n            // Perform XOR on each character\n            char xorChar = (char)((a.charAt(i) - '0') ^ (b.charAt(i) - '0') + '0');\n            xorResult.append(xorChar);\n        }\n\n        return xorResult.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.string_xor(\"010\", \"110\")); // Expected: 100\n        System.out.println(solution.string_xor(\"111\", \"111\")); // Expected: 000\n        System.out.println(solution.string_xor(\"101010\", \"111111\")); // Expected: 010101\n    }\n}\n"}
{"task_id": "Java/12", "generation": "import java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\nclass Solution {\n\n    /**\n     * Out of list of strings, return the longest one.\n     * Return the first one in case of multiple strings of the same length.\n     * Return Optional.empty() in case the input list is empty.\n     */\n    public Optional<String> longest(List<String> strings) {\n        if (strings.isEmpty()) {\n            return Optional.empty();\n        }\n\n        String longestString = \"\";\n        for (String str : strings) {\n            if (str.length() > longestString.length()) {\n                longestString = str;\n            }\n        }\n        return Optional.of(longestString);\n    }\n\n    @Test\n    public void testLongestEmptyList() {\n        assertTrue(longest(List.of()).isEmpty());\n    }\n\n    @Test\n    public void testLongestSingleElement() {\n        assertEquals(Optional.of(\"a\"), longest(Arrays.asList(\"a\")));\n    }\n\n    @Test\n    public void testLongestMultipleElements() {\n        assertEquals(Optional.of(\"ccc\"), longest(Arrays.asList(\"a\", \"bb\", \"ccc\")));\n    }\n\n    @Test\n    public void testLongestEqualLengthStrings() {\n        // In case of equal length, the first one should be returned.\n        assertEquals(Optional.of(\"a\"), longest(Arrays.asList(\"a\", \"b\", \"c\")));\n    }\n}\n"}
{"task_id": "Java/13", "generation": "import org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nclass Solution {\n    /**\n     * Return the greatest common divisor of two integers a and b.\n     *\n     * @param a First integer\n     * @param b Second integer\n     * @return The greatest common divisor of a and b\n     */\n    public int greatest_common_divisor(int a, int b) {\n        while (b != 0) {\n            int temp = b;\n            b = a % b;\n            a = temp;\n        }\n        return a; // gcd is now in a\n    }\n\n    @Test\n    void testGreatestCommonDivisor() {\n        assertEquals(1, greatest_common_divisor(3, 5));\n        assertEquals(5, greatest_common_divisor(25, 15));\n        assertEquals(6, greatest_common_divisor(18, 24));\n        assertEquals(7, greatest_common_divisor(49, 14));\n    }\n}\n"}
{"task_id": "Java/14", "generation": "import java.util.ArrayList;\nimport java.util.List;\n\nclass Solution {\n    public List<String> all_prefixes(String string) {\n        List<String> prefixes = new ArrayList<>();\n        for (int i = 1; i <= string.length(); i++) {\n            prefixes.add(string.substring(0, i));\n        }\n        return prefixes;\n    }\n}\n"}
{"task_id": "Java/15", "generation": "import java.util.*;\nimport org.junit.*;\n\nclass Solution {\n    /**\n     * Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n     *\n     * @param n the last number in the sequence (inclusive)\n     * @return a String of space-delimited numbers from 0 to n\n     */\n    public String string_sequence(int n) {\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i <= n; i++) {\n            sb.append(i);\n            if (i < n) {\n                sb.append(\" \");\n            }\n        }\n        return sb.toString();\n    }\n\n    @Test\n    public void testStringSequence() {\n        Assert.assertEquals(\"0\", string_sequence(0));\n        Assert.assertEquals(\"0 1 2 3 4 5\", string_sequence(5));\n        // Additional tests can be added here.\n    }\n\n    public static void main(String[] args) {\n        org.junit.runner.JUnitCore.main(Solution.class.getName());\n    }\n}\n"}
{"task_id": "Java/16", "generation": "import java.util.HashSet;\nimport java.util.Set;\n\nclass Solution {\n    /**\n     * Given a string, find out how many distinct characters (regardless of case) does it consist of.\n     *\n     * @param string the input string to analyze\n     * @return the number of distinct characters in the string, ignoring case\n     */\n    public int count_distinct_characters(String string) {\n        if (string == null || string.isEmpty()) return 0;\n\n        Set<Character> uniqueChars = new HashSet<>();\n        \n        for (char c : string.toLowerCase().toCharArray()) {\n            uniqueChars.add(c);\n        }\n\n        return uniqueChars.size();\n    }\n    \n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.count_distinct_characters(\"xyzXYZ\")); // Expected output: 3\n        System.out.println(solution.count_distinct_characters(\"Jerry\"));   // Expected output: 4\n        System.out.println(solution.count_distinct_characters(\"AaBbCc\"));  // Expected output: 3\n        System.out.println(solution.count_distinct_characters(\"\"));        // Expected output: 0\n    }\n}\n"}
{"task_id": "Java/17", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Parses a string representing musical notes in a special ASCII format and returns a list of integers \n     * corresponding to how many beats each note lasts.\n     *\n     * @param string The input string containing the musical notes.\n     * @return A List<Integer> where each element represents the number of beats for the corresponding note.\n     */\n    public List<Integer> parse_music(String string) {\n        String[] tokens = string.split(\" \");\n        List<Integer> result = new ArrayList<>();\n        \n        for (String token : tokens) {\n            if (\"o\".equals(token)) {\n                result.add(4);\n            } else if (\"o|\".equals(token)) {\n                result.add(2);\n            } else if (\".|\".equals(token)) {\n                result.add(1);\n            }\n        }\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case 1\n        List<Integer> expected1 = Arrays.asList(4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4);\n        List<Integer> result1 = solution.parse_music(\"o o| .| o| o| .| .| .| .| o o\");\n        System.out.println(result1.equals(expected1) ? \"Test 1 Passed\" : \"Test 1 Failed\");\n\n        // Test case 2\n        List<Integer> expected2 = Arrays.asList(4, 1);\n        List<Integer> result2 = solution.parse_music(\"o .|\");\n        System.out.println(result2.equals(expected2) ? \"Test 2 Passed\" : \"Test 2 Failed\");\n\n        // Add more test cases as needed\n    }\n}\n"}
{"task_id": "Java/18", "generation": "class Solution {\n    /**\n     * Find how many times a given substring can be found in the original string.\n     * Count overlaping cases.\n     *\n     * @param string The original string to search within.\n     * @param substring The substring to find within the original string.\n     * @return The number of times the substring appears, including overlaps.\n     */\n    public int how_many_times(String string, String substring) {\n        if (string == null || substring == null || substring.length() > string.length()) {\n            return 0;\n        }\n\n        int count = 0;\n        int start = 0;\n\n        while ((start = string.indexOf(substring, start)) != -1) {\n            count++;\n            start++; // Move to the next character to allow for overlaps\n        }\n\n        return count;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.how_many_times(\"\", \"a\")); // Expected output: 0\n        System.out.println(solution.how_many_times(\"aaa\", \"a\")); // Expected output: 3\n        System.out.println(solution.how_many_times(\"aaaa\", \"aa\")); // Expected output: 3\n\n        // Additional test cases\n        System.out.println(solution.how_many_times(\"abcabcabc\", \"abc\")); // Expected output: 3\n        System.out.println(solution.how_many_times(\"ababa\", \"aba\")); // Expected output: 2\n    }\n}\n"}
{"task_id": "Java/19", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Input is a space-delimited string of numerals from 'zero' to 'nine'.\n     * Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n     * Return the string with numbers sorted from smallest to largest\n     */\n    public String sort_numbers(String numbers) {\n        // Mapping of number names to their numeric values\n        Map<String, Integer> numMap = new HashMap<>();\n        numMap.put(\"zero\", 0);\n        numMap.put(\"one\", 1);\n        numMap.put(\"two\", 2);\n        numMap.put(\"three\", 3);\n        numMap.put(\"four\", 4);\n        numMap.put(\"five\", 5);\n        numMap.put(\"six\", 6);\n        numMap.put(\"seven\", 7);\n        numMap.put(\"eight\", 8);\n        numMap.put(\"nine\", 9);\n\n        // Split the input string into words\n        String[] numberWords = numbers.split(\"\\\\s+\");\n\n        // Convert each word to its numeric value and sort them\n        Integer[] sortedNumbers = new Integer[numberWords.length];\n        for (int i = 0; i < numberWords.length; i++) {\n            sortedNumbers[i] = numMap.get(numberWords[i]);\n        }\n        Arrays.sort(sortedNumbers);\n\n        // Convert back to the original number names\n        StringBuilder result = new StringBuilder();\n        for (Integer num : sortedNumbers) {\n            for (Map.Entry<String, Integer> entry : numMap.entrySet()) {\n                if (entry.getValue().equals(num)) {\n                    result.append(entry.getKey()).append(\" \");\n                    break;\n                }\n            }\n        }\n\n        // Remove the trailing space\n        return result.toString().trim();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.sort_numbers(\"three one five\"));  // Expected: \"one three five\"\n        System.out.println(solution.sort_numbers(\"nine eight seven\"));  // Expected: \"seven eight nine\"\n        System.out.println(solution.sort_numbers(\"zero four two\"));  // Expected: \"zero two four\"\n    }\n}\n"}
{"task_id": "Java/20", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n     * other and return them in order (smaller number, larger number).\n     */\n    public List<Double> find_closest_elements(List<Double> numbers) {\n        // Sort the list to make it easier to find consecutive elements with the smallest difference.\n        Collections.sort(numbers);\n\n        double minDiff = Double.MAX_VALUE;\n        List<Double> closestElements = new ArrayList<>();\n\n        for (int i = 0; i < numbers.size() - 1; i++) {\n            double diff = Math.abs(numbers.get(i) - numbers.get(i + 1));\n            if (diff < minDiff) {\n                minDiff = diff;\n                closestElements.clear();\n                closestElements.add(numbers.get(i));\n                closestElements.add(numbers.get(i + 1));\n            }\n        }\n\n        return closestElements;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        List<Double> testList1 = Arrays.asList(1.0, 2.0, 3.0, 4.0, 5.0, 2.2);\n        System.out.println(solution.find_closest_elements(testList1)); // Expected: [2.0, 2.2]\n\n        // Test case 2\n        List<Double> testList2 = Arrays.asList(1.0, 2.0, 3.0, 4.0, 5.0, 2.0);\n        System.out.println(solution.find_closest_elements(testList2)); // Expected: [2.0, 2.0]\n\n        // Additional test case\n        List<Double> testList3 = Arrays.asList(1.5, 3.2, 4.8, 6.7, 9.0);\n        System.out.println(solution.find_closest_elements(testList3)); // Expected: [3.2, 4.8]\n    }\n}\n"}
{"task_id": "Java/21", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given a list of numbers (of at least two elements), apply a linear transform to that list,\n     * such that the smallest number will become 0 and the largest will become 1.\n     *\n     * @param numbers List of Double values.\n     * @return A new list where each element is scaled between 0 and 1.\n     */\n    public List<Double> rescale_to_unit(List<Double> numbers) {\n        if (numbers == null || numbers.size() < 2) {\n            throw new IllegalArgumentException(\"List must contain at least two elements.\");\n        }\n\n        double min = Collections.min(numbers);\n        double max = Collections.max(numbers);\n\n        // Avoid division by zero\n        if (min == max) {\n            throw new ArithmeticException(\"Cannot rescale when all numbers are the same.\");\n        }\n\n        List<Double> scaledNumbers = new ArrayList<>();\n        for (double number : numbers) {\n            double scaledValue = (number - min) / (max - min);\n            scaledNumbers.add(scaledValue);\n        }\n        return scaledNumbers;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        List<Double> testList1 = Arrays.asList(1.0, 2.0, 3.0, 4.0, 5.0);\n        System.out.println(\"Test Case 1: \" + solution.rescale_to_unit(testList1));\n\n        // Test case 2\n        List<Double> testList2 = Arrays.asList(-1.0, -2.0, -3.0, -4.0, -5.0);\n        System.out.println(\"Test Case 2: \" + solution.rescale_to_unit(testList2));\n\n        // Test case 3 (edge case with all elements the same)\n        try {\n            List<Double> testList3 = Arrays.asList(1.0, 1.0, 1.0, 1.0);\n            System.out.println(\"Test Case 3: \" + solution.rescale_to_unit(testList3));\n        } catch (ArithmeticException e) {\n            System.err.println(\"Caught exception in Test Case 3: \" + e.getMessage());\n        }\n    }\n}\n"}
{"task_id": "Java/22", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Filter given list of any values only for integers.\n     *\n     * @param values List containing objects of various types.\n     * @return A new list containing only Integer elements from the input list.\n     */\n    public List<Integer> filter_integers(List<Object> values) {\n        List<Integer> result = new ArrayList<>();\n        for (Object value : values) {\n            if (value instanceof Integer) {\n                result.add((Integer) value);\n            }\n        }\n        return result;\n    }\n\n    // Test method to verify the correctness of the filter_integers function.\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        List<Object> test1 = Arrays.asList('a', 3.14, 5);\n        System.out.println(solution.filter_integers(test1)); // Expected: [5]\n\n        List<Object> test2 = Arrays.asList(1, 2, 3, \"abc\", Map.of(), List.of());\n        System.out.println(solution.filter_integers(test2)); // Expected: [1, 2, 3]\n    }\n}\n"}
{"task_id": "Java/23", "generation": "import org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\nclass Solution {\n    /**\n     * Return length of given string\n     *\n     * @param string the input string\n     * @return the length of the string\n     */\n    public int strlen(String string) {\n        return string.length();\n    }\n\n    // Tests for the strlen method\n    @Test\n    void testStrlen() {\n        assertEquals(0, strlen(\"\"));\n        assertEquals(3, strlen(\"abc\"));\n        assertEquals(5, strlen(\"hello\"));  // Additional test case\n        assertEquals(12, strlen(\"Java Programming\"));  // Another additional test case\n    }\n}\n"}
{"task_id": "Java/24", "generation": "class Solution {\n    /**\n     * For a given number n, finds the largest number that divides n evenly, smaller than n.\n     *\n     * @param n The input number.\n     * @return The largest divisor of n which is less than n.\n     */\n    public int largest_divisor(int n) {\n        for (int i = n / 2; i >= 1; i--) {\n            if (n % i == 0) {\n                return i;\n            }\n        }\n        // If no divisor found, return 1 as every number is divisible by 1.\n        return 1;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.largest_divisor(15)); // Expected output: 5\n        System.out.println(solution.largest_divisor(28)); // Expected output: 14\n        System.out.println(solution.largest_divisor(7));  // Expected output: 1 (since 7 is prime)\n        System.out.println(solution.largest_divisor(100)); // Expected output: 50\n    }\n}\n"}
{"task_id": "Java/25", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Return list of prime factors of given integer in the order from smallest to largest.\n     * Each of the factors should be listed number of times corresponding to how many times it appears in factorization.\n     * Input number should be equal to the product of all factors\n     */\n    public List<Integer> factorize(int n) {\n        List<Integer> factors = new ArrayList<>();\n        \n        // Divide by 2 until we can't anymore, adding 2 each time\n        while (n % 2 == 0) {\n            factors.add(2);\n            n /= 2;\n        }\n        \n        // Now check for odd factors from 3 onwards\n        for (int i = 3; i <= Math.sqrt(n); i += 2) {\n            while (n % i == 0) {\n                factors.add(i);\n                n /= i;\n            }\n        }\n        \n        // If n is a prime number greater than 2, it will remain after the above loop\n        if (n > 2) {\n            factors.add(n);\n        }\n\n        return factors;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.factorize(8)); // Expected: [2, 2, 2]\n        System.out.println(solution.factorize(25)); // Expected: [5, 5]\n        System.out.println(solution.factorize(70)); // Expected: [2, 5, 7]\n    }\n}\n"}
{"task_id": "Java/26", "generation": "import java.util.*;\nimport java.util.stream.Collectors;\n\nclass Solution {\n    /**\n     * From a list of integers, remove all elements that occur more than once.\n     * Keep order of elements left the same as in the input.\n     *\n     * @param numbers List of integers to process.\n     * @return A new list with duplicates removed.\n     */\n    public List<Integer> remove_duplicates(List<Integer> numbers) {\n        // Count occurrences of each number\n        Map<Integer, Integer> countMap = new HashMap<>();\n        for (Integer num : numbers) {\n            countMap.put(num, countMap.getOrDefault(num, 0) + 1);\n        }\n\n        // Filter out elements that occur more than once while maintaining order\n        return numbers.stream()\n                .filter(num -> countMap.get(num) == 1)\n                .collect(Collectors.toList());\n    }\n}\n\n// Test code to verify the solution\nclass Main {\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        \n        List<Integer> testList1 = Arrays.asList(1, 2, 3, 2, 4);\n        System.out.println(sol.remove_duplicates(testList1)); // Expected: [1, 3, 4]\n\n        List<Integer> testList2 = Arrays.asList(5, 6, 7, 8, 9);\n        System.out.println(sol.remove_duplicates(testList2)); // Expected: [5, 6, 7, 8, 9]\n        \n        List<Integer> testList3 = Arrays.asList(10, 10, 11, 11, 12);\n        System.out.println(sol.remove_duplicates(testList3)); // Expected: [12]\n\n        List<Integer> testList4 = new ArrayList<>();\n        System.out.println(sol.remove_duplicates(testList4)); // Expected: []\n    }\n}\n"}
{"task_id": "Java/27", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n     *\n     * @param string the input string to be processed\n     * @return the flipped case version of the input string\n     */\n    public String flip_case(String string) {\n        StringBuilder result = new StringBuilder();\n        \n        for (char c : string.toCharArray()) {\n            if (Character.isUpperCase(c)) {\n                result.append(Character.toLowerCase(c));\n            } else if (Character.isLowerCase(c)) {\n                result.append(Character.toUpperCase(c));\n            } else {\n                // If it's not a letter, just append the character as is\n                result.append(c);\n            }\n        }\n\n        return result.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.flip_case(\"Hello\")); // Expected: \"hELLO\"\n        System.out.println(solution.flip_case(\"Java\"));  // Expected: \"jAVA\"\n        System.out.println(solution.flip_case(\"123abcABC\")); // Expected: \"123ABCabc\"\n    }\n}\n"}
{"task_id": "Java/28", "generation": "import java.util.*;\nimport org.junit.*;\n\nclass Solution {\n    /**\n     * Concatenates list of strings into a single string.\n     *\n     * @param strings List of strings to concatenate.\n     * @return A single concatenated string.\n     */\n    public String concatenate(List<String> strings) {\n        return String.join(\"\", strings);\n    }\n\n    // Test class for the Solution\n    public static class TestSolution {\n        @Test\n        public void testConcatenate() {\n            Solution solution = new Solution();\n\n            // Test with an empty list\n            Assert.assertEquals(\"\", solution.concatenate(new ArrayList<>()));\n\n            // Test with a non-empty list\n            List<String> strings = Arrays.asList(\"a\", \"b\", \"c\");\n            Assert.assertEquals(\"abc\", solution.concatenate(strings));\n        }\n    }\n}\n"}
{"task_id": "Java/29", "generation": "import org.junit.jupiter.api.Test;\nimport java.util.Arrays;\nimport java.util.List;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nclass SolutionTest {\n    private final Solution solution = new Solution();\n\n    @Test\n    void testFilterByPrefixWithEmptyList() {\n        List<String> input = List.of();\n        String prefix = \"a\";\n        List<String> expectedOutput = List.of();\n        \n        assertEquals(expectedOutput, solution.filter_by_prefix(input, prefix));\n    }\n\n    @Test\n    void testFilterByPrefixWithNonEmptyList() {\n        List<String> input = Arrays.asList(\"abc\", \"bcd\", \"cde\", \"array\");\n        String prefix = \"a\";\n        List<String> expectedOutput = Arrays.asList(\"abc\", \"array\");\n\n        assertEquals(expectedOutput, solution.filter_by_prefix(input, prefix));\n    }\n\n    @Test\n    void testFilterByPrefixWithNoMatchingStrings() {\n        List<String> input = Arrays.asList(\"bcd\", \"cde\");\n        String prefix = \"a\";\n        List<String> expectedOutput = List.of();\n\n        assertEquals(expectedOutput, solution.filter_by_prefix(input, prefix));\n    }\n}\n"}
{"task_id": "Java/30", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return only positive numbers in the list.\n     *\n     * @param l List of integers\n     * @return A new list containing only positive numbers from the input list\n     */\n    public List<Integer> get_positive(List<Integer> l) {\n        return l.stream()\n                .filter(x -> x > 0)\n                .collect(Collectors.toList());\n    }\n\n    // Test cases to verify the correctness of the function.\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        List<Integer> list1 = Arrays.asList(-1, 2, -4, 5, 6);\n        System.out.println(solution.get_positive(list1)); // Expected: [2, 5, 6]\n\n        // Test case 2\n        List<Integer> list2 = Arrays.asList(5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10);\n        System.out.println(solution.get_positive(list2)); // Expected: [5, 3, 2, 3, 9, 123, 1]\n\n        // Test case 3\n        List<Integer> list3 = Arrays.asList(-7, -8, -9);\n        System.out.println(solution.get_positive(list3)); // Expected: []\n\n        // Test case 4\n        List<Integer> list4 = new ArrayList<>();\n        System.out.println(solution.get_positive(list4)); // Expected: []\n    }\n}\n"}
{"task_id": "Java/31", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return true if a given number is prime, and false otherwise.\n     */\n    public boolean is_prime(int n) {\n        // 1 is not considered a prime number\n        if (n <= 1) return false;\n        \n        // Check from 2 to the square root of n for factors\n        for (int i = 2; i * i <= n; i++) {\n            if (n % i == 0) return false;\n        }\n        \n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases based on the provided comments\n        System.out.println(solution.is_prime(6));     // Expected: false\n        System.out.println(solution.is_prime(101));   // Expected: true\n        System.out.println(solution.is_prime(11));    // Expected: true\n        System.out.println(solution.is_prime(13441)); // Expected: true\n        System.out.println(solution.is_prime(61));    // Expected: true\n        System.out.println(solution.is_prime(4));     // Expected: false\n        System.out.println(solution.is_prime(1));     // Expected: false\n    }\n}\n"}
{"task_id": "Java/32", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Evaluates polynomial with coefficients xs at point x.\n     * return xs[0] + xs[1] * x + xs[2] * x^2 + .... xs[n] * x^n\n     */\n    public double poly(List<Double> xs, double x) {\n        double result = 0;\n        for (int i = 0; i < xs.size(); i++) {\n            result += xs.get(i) * Math.pow(x, i);\n        }\n        return result;\n    }\n\n    /**\n     * Finds a zero of the polynomial with coefficients xs.\n     */\n    public double find_zero(List<Double> xs) {\n        // Ensure that xs has an even number of elements\n        if (xs.size() % 2 != 0) {\n            throw new IllegalArgumentException(\"The list must have an even number of elements.\");\n        }\n\n        // Bisection method to find a root\n        double left = -1000; // arbitrary lower bound\n        double right = 1000; // arbitrary upper bound\n\n        while (Math.abs(right - left) > 1e-6) {\n            double mid = (left + right) / 2;\n            if (poly(xs, mid) == 0 || Math.abs(poly(xs, mid)) < 1e-9) {\n                return mid; // found a root\n            } else if (poly(xs, left) * poly(xs, mid) < 0) {\n                right = mid;\n            } else {\n                left = mid;\n            }\n        }\n\n        return (left + right) / 2; // midpoint as the best approximation of the root\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        List<Double> test1 = Arrays.asList(1.0, 2.0);\n        System.out.println(\"Test 1: \" + solution.find_zero(test1)); // Expected output: -0.5\n        \n        List<Double> test2 = Arrays.asList(-6.0, 11.0, -6.0, 1.0);\n        System.out.println(\"Test 2: \" + solution.find_zero(test2)); // Expected output: close to one of the roots (e.g., 1.0)\n    }\n}\n"}
{"task_id": "Java/33", "generation": "import java.util.*;\n\nclass Solution {\n    public List<Integer> sort_third(List<Integer> l) {\n        // Extract elements at indices divisible by 3 (0-based index)\n        ArrayList<Integer> toSort = new ArrayList<>();\n        for (int i = 0; i < l.size(); i++) {\n            if ((i + 1) % 3 == 0) { // +1 because we want indices that are divisible by three in a 1-based sense\n                toSort.add(l.get(i));\n            }\n        }\n\n        // Sort the extracted elements\n        Collections.sort(toSort);\n\n        // Reinsert sorted elements back into their original positions\n        List<Integer> result = new ArrayList<>(l);\n        for (int i = 0, j = 0; i < l.size(); i++) {\n            if ((i + 1) % 3 == 0) { // Again, +1 to match the problem's index requirement\n                result.set(i, toSort.get(j++));\n            }\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.sort_third(Arrays.asList(1, 2, 3))); // Expected: [1, 2, 3]\n        System.out.println(solution.sort_third(Arrays.asList(5, 6, 3, 4, 8, 9, 2))); // Expected: [2, 6, 3, 4, 8, 9, 5]\n    }\n}\n"}
{"task_id": "Java/34", "generation": "import java.util.*;\nimport org.junit.*;\n\nclass Solution {\n    /**\n     * Return sorted unique elements in a list.\n     *\n     * @param l the input list of integers\n     * @return a new list containing only unique and sorted elements from the input list\n     */\n    public List<Integer> unique(List<Integer> l) {\n        // Use LinkedHashSet to maintain insertion order while removing duplicates\n        Set<Integer> set = new TreeSet<>(l);\n        return new ArrayList<>(set);\n    }\n\n    @Test\n    public void testUnique() {\n        Solution solution = new Solution();\n        \n        // Test case 1: Normal list with duplicates\n        List<Integer> input1 = Arrays.asList(5, 3, 5, 2, 3, 3, 9, 0, 123);\n        List<Integer> expectedOutput1 = Arrays.asList(0, 2, 3, 5, 9, 123);\n        Assert.assertEquals(expectedOutput1, solution.unique(input1));\n        \n        // Test case 2: Empty list\n        List<Integer> input2 = new ArrayList<>();\n        List<Integer> expectedOutput2 = new ArrayList<>();\n        Assert.assertEquals(expectedOutput2, solution.unique(input2));\n        \n        // Test case 3: List with all elements being the same\n        List<Integer> input3 = Arrays.asList(1, 1, 1, 1);\n        List<Integer> expectedOutput3 = Arrays.asList(1);\n        Assert.assertEquals(expectedOutput3, solution.unique(input3));\n    }\n}\n"}
{"task_id": "Java/35", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Return maximum element in the list.\n     *\n     * @param l List of integers.\n     * @return The maximum integer in the list.\n     */\n    public int max_element(List<Integer> l) {\n        if (l == null || l.isEmpty()) {\n            throw new IllegalArgumentException(\"List must not be null or empty\");\n        }\n        \n        return Collections.max(l);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case 1\n        List<Integer> list1 = Arrays.asList(1, 2, 3);\n        System.out.println(\"Max element in [1, 2, 3]: \" + solution.max_element(list1)); // Expected: 3\n        \n        // Test case 2\n        List<Integer> list2 = Arrays.asList(5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10);\n        System.out.println(\"Max element in [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]: \" + solution.max_element(list2)); // Expected: 123\n        \n        // Test case 3 (Edge case with single element)\n        List<Integer> list3 = Arrays.asList(42);\n        System.out.println(\"Max element in [42]: \" + solution.max_element(list3)); // Expected: 42\n        \n        // Test case 4 (Edge case with negative numbers only)\n        List<Integer> list4 = Arrays.asList(-1, -5, -9, -20);\n        System.out.println(\"Max element in [-1, -5, -9, -20]: \" + solution.max_element(list4)); // Expected: -1\n    }\n}\n"}
{"task_id": "Java/36", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n     *\n     * @param n The upper limit (exclusive) to search for numbers.\n     * @return The count of digit '7' appearances.\n     */\n    public int fizz_buzz(int n) {\n        int count = 0;\n        for (int i = 1; i < n; i++) {\n            if ((i % 11 == 0 || i % 13 == 0)) { // Check divisibility by 11 or 13\n                String numStr = Integer.toString(i);\n                count += countSevens(numStr); // Count '7's in the number string.\n            }\n        }\n        return count;\n    }\n\n    private int countSevens(String s) {\n        int count = 0;\n        for (char c : s.toCharArray()) {\n            if (c == '7') {\n                count++;\n            }\n        }\n        return count;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.fizz_buzz(50));  // Expected output: 0\n        System.out.println(solution.fizz_buzz(78));  // Expected output: 2\n        System.out.println(solution.fizz_buzz(79));  // Expected output: 3\n    }\n}\n"}
{"task_id": "Java/37", "generation": "import java.util.*;\n\nclass Solution {\n    public List<Integer> sort_even(List<Integer> l) {\n        // Extract elements at even positions and sort them.\n        List<Integer> evenIndicesValues = new ArrayList<>();\n        for (int i = 0; i < l.size(); i += 2) {\n            evenIndicesValues.add(l.get(i));\n        }\n        Collections.sort(evenIndicesValues);\n\n        // Reconstruct the list with sorted values at even positions.\n        List<Integer> result = new ArrayList<>(l);\n        int evenIndex = 0;\n        for (int i = 0; i < l.size(); i += 2) {\n            result.set(i, evenIndicesValues.get(evenIndex++));\n        }\n\n        return result;\n    }\n}\n"}
{"task_id": "Java/38", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Returns encoded string by cycling groups of three characters.\n     */\n    public String encodeCyclic(String s) {\n        // Split string into groups. Each of length 3.\n        List<String> groups = new ArrayList<>();\n        for (int i = 0; i < s.length(); i += 3) {\n            groups.add(s.substring(i, Math.min(i + 3, s.length())));\n        }\n        // Cycle elements in each group unless the group has fewer than 3 elements.\n        for (int i = 0; i < groups.size(); i++) {\n            if (groups.get(i).length() == 3) {\n                String group = groups.get(i);\n                groups.set(i, group.substring(2) + group.charAt(0));\n            }\n        }\n        return String.join(\"\", groups);\n    }\n\n    /**\n     * Takes as input a string encoded with encodeCyclic function. Returns decoded string.\n     */\n    public String decode_cyclic(String s) {\n        // Split the encoded string into groups of 3 characters\n        List<String> groups = new ArrayList<>();\n        for (int i = 0; i < s.length(); i += 3) {\n            groups.add(s.substring(i, Math.min(i + 3, s.length())));\n        }\n        // Reverse cycle elements in each group unless the group has fewer than 3 elements.\n        for (int i = 0; i < groups.size(); i++) {\n            if (groups.get(i).length() == 3) {\n                String group = groups.get(i);\n                groups.set(i, group.charAt(2) + group.substring(0, 2));\n            }\n        }\n        return String.join(\"\", groups);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.encodeCyclic(\"hello\")); // Expected: \"elhlo\"\n        System.out.println(solution.decode_cyclic(\"elhlo\")); // Expected: \"hello\"\n\n        System.out.println(solution.encodeCyclic(\"worldwide\")); // Expected: \"rldwoideew\"\n        System.out.println(solution.decode_cyclic(\"rldwoideew\")); // Expected: \"worldwide\"\n\n        System.out.println(solution.encodeCyclic(\"java\")); // Expected: \"avaj\"\n        System.out.println(solution.decode_cyclic(\"avaj\")); // Expected: \"java\"\n    }\n}\n"}
{"task_id": "Java/39", "generation": "import java.util.*;\n\nclass Solution {\n    public int prime_fib(int n) {\n        List<Integer> primes = new ArrayList<>();\n        int a = 0, b = 1;\n        \n        while (primes.size() < n) {\n            int fib = a + b;\n            a = b;\n            b = fib;\n            \n            if (isPrime(fib)) {\n                primes.add(fib);\n            }\n        }\n        \n        return primes.get(n - 1);\n    }\n\n    private boolean isPrime(int num) {\n        if (num <= 1) return false;\n        for (int i = 2; i * i <= num; i++) {\n            if (num % i == 0) return false;\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.prime_fib(1)); // Expected output: 2\n        System.out.println(solution.prime_fib(2)); // Expected output: 3\n        System.out.println(solution.prime_fib(3)); // Expected output: 5\n        System.out.println(solution.prime_fib(4)); // Expected output: 13\n        System.out.println(solution.prime_fib(5)); // Expected output: 89\n    }\n}\n"}
{"task_id": "Java/40", "generation": "import java.util.*;\n\nclass Solution {\n    public boolean triples_sum_to_zero(List<Integer> l) {\n        if (l.size() < 3) return false;\n\n        Collections.sort(l);\n\n        for (int i = 0; i < l.size() - 2; i++) {\n            int left = i + 1;\n            int right = l.size() - 1;\n\n            while (left < right) {\n                int sum = l.get(i) + l.get(left) + l.get(right);\n\n                if (sum == 0) {\n                    return true;\n                } else if (sum < 0) {\n                    left++;\n                } else {\n                    right--;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.triples_sum_to_zero(Arrays.asList(1, 3, 5, 0))); // Expected: false\n        System.out.println(solution.triples_sum_to_zero(Arrays.asList(1, 3, -2, 1))); // Expected: true\n        System.out.println(solution.triples_sum_to_zero(Arrays.asList(1, 2, 3, 7))); // Expected: false\n        System.out.println(solution.triples_sum_to_zero(Arrays.asList(2, 4, -5, 3, 9, 7))); // Expected: true\n        System.out.println(solution.triples_sum_to_zero(Arrays.asList(1))); // Expected: false\n    }\n}\n"}
{"task_id": "Java/41", "generation": "class Solution {\n    /**\n     * Calculates the number of collisions between two sets of n cars each,\n     * one set moving from left to right and the other from right to left.\n     *\n     * @param n The number of cars in each direction.\n     * @return The total number of collisions.\n     */\n    public int car_race_collision(int n) {\n        return n;\n    }\n}\n\npublic class TestSolution {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.car_race_collision(1));  // Expected output: 1\n        System.out.println(solution.car_race_collision(2));  // Expected output: 2\n        System.out.println(solution.car_race_collision(5));  // Expected output: 5\n        System.out.println(solution.car_race_collision(0));  // Expected output: 0\n    }\n}\n"}
{"task_id": "Java/42", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return list with elements incremented by 1.\n     *\n     * @param l List of integers to be incremented.\n     * @return A new list where each element is increased by 1.\n     */\n    public List<Integer> incr_list(List<Integer> l) {\n        return l.stream().map(x -> x + 1).collect(Collectors.toList());\n    }\n\n    /**\n     * Main method for testing the incr_list function.\n     *\n     * @param args Command line arguments (not used).\n     */\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        List<Integer> testList1 = Arrays.asList(1, 2, 3);\n        System.out.println(\"Test Case 1: \" + solution.incr_list(testList1));\n\n        // Test case 2\n        List<Integer> testList2 = Arrays.asList(5, 3, 5, 2, 3, 3, 9, 0, 123);\n        System.out.println(\"Test Case 2: \" + solution.incr_list(testList2));\n    }\n}\n"}
{"task_id": "Java/43", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * pairs_sum_to_zero takes a list of integers as an input.\n     * It returns True if there are two distinct elements in the list that sum to zero, and False otherwise.\n     */\n    public boolean pairs_sum_to_zero(List<Integer> l) {\n        Set<Integer> seen = new HashSet<>();\n        \n        for (int num : l) {\n            // Check if the inverse of current number exists in the set\n            if (seen.contains(-num)) {\n                return true;\n            }\n            seen.add(num);\n        }\n        return false;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.pairs_sum_to_zero(Arrays.asList(1, 3, 5, 0))); // Expected: false\n        System.out.println(solution.pairs_sum_to_zero(Arrays.asList(1, 3, -2, 1))); // Expected: false\n        System.out.println(solution.pairs_sum_to_zero(Arrays.asList(1, 2, 3, 7))); // Expected: false\n        System.out.println(solution.pairs_sum_to_zero(Arrays.asList(2, 4, -5, 3, 5, 7))); // Expected: true\n        System.out.println(solution.pairs_sum_to_zero(Arrays.asList(1))); // Expected: false\n    }\n}\n"}
{"task_id": "Java/44", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Change numerical base of input number x to the given base.\n     * Returns string representation after the conversion.\n     * Base numbers are less than 10.\n     *\n     * @param x   The integer in decimal format that needs to be converted.\n     * @param base The target base for conversion, which is less than 10.\n     * @return A String representing the number in the new base.\n     */\n    public String change_base(int x, int base) {\n        if (base < 2 || base > 9) throw new IllegalArgumentException(\"Base must be between 2 and 9\");\n        \n        StringBuilder result = new StringBuilder();\n        while (x > 0) {\n            result.insert(0, x % base);\n            x /= base;\n        }\n        return result.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.change_base(8, 3).equals(\"22\") ? \"Test 1 Passed\" : \"Test 1 Failed\");\n        System.out.println(solution.change_base(8, 2).equals(\"1000\") ? \"Test 2 Passed\" : \"Test 2 Failed\");\n        System.out.println(solution.change_base(7, 2).equals(\"111\") ? \"Test 3 Passed\" : \"Test 3 Failed\");\n\n        // Additional test cases\n        System.out.println(solution.change_base(9, 4).equals(\"21\") ? \"Test 4 Passed\" : \"Test 4 Failed\");\n        System.out.println(solution.change_base(15, 8).equals(\"17\") ? \"Test 5 Passed\" : \"Test 5 Failed\");\n    }\n}\n"}
{"task_id": "Java/45", "generation": "import org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nclass Solution {\n    /**\n     * Given length of a side and height return area for a triangle.\n     *\n     * @param a the base length of the triangle\n     * @param h the height of the triangle\n     * @return the area of the triangle\n     */\n    public double triangle_area(double a, double h) {\n        return 0.5 * a * h;\n    }\n\n    // Test cases for the triangle_area method\n    @Test\n    void testTriangleArea() {\n        assertEquals(7.5, new Solution().triangle_area(5, 3), 0.01);\n        assertEquals(6.0, new Solution().triangle_area(4, 3), 0.01);\n        assertEquals(2.5, new Solution().triangle_area(2, 2.5), 0.01);\n    }\n}\n"}
{"task_id": "Java/46", "generation": "class Solution {\n    public int fib4(int n) {\n        if (n == 0 || n == 1) return 0;\n        if (n == 2) return 2;\n        if (n == 3) return 0;\n\n        // Initialize the first four numbers of the sequence.\n        int a = 0, b = 0, c = 2, d = 0;\n\n        for (int i = 4; i <= n; ++i) {\n            int next = a + b + c + d;\n            a = b;\n            b = c;\n            c = d;\n            d = next;\n        }\n\n        return d;\n    }\n    \n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.fib4(5));  // Expected output: 4\n        System.out.println(solution.fib4(6));  // Expected output: 8\n        System.out.println(solution.fib4(7));  // Expected output: 14\n    }\n}\n"}
{"task_id": "Java/47", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Return median of elements in the list l.\n     *\n     * @param l List of integers for which the median needs to be calculated.\n     * @return The median value as a double.\n     */\n    public double median(List<Integer> l) {\n        Collections.sort(l); // Sort the list\n        int size = l.size();\n        \n        if (size % 2 == 1) { // If odd number of elements, return middle one\n            return l.get(size / 2);\n        } else { // If even number of elements, average the two middle ones\n            return (l.get((size - 1) / 2) + l.get(size / 2)) / 2.0;\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.median(Arrays.asList(3, 1, 2, 4, 5))); // Expected output: 3\n        System.out.println(solution.median(Arrays.asList(-10, 4, 6, 1000, 10, 20))); // Expected output: 8.0\n        \n        // Additional test cases\n        System.out.println(solution.median(Arrays.asList(7, 5, 3))); // Expected output: 5\n        System.out.println(solution.median(Arrays.asList(-4, -6, -2, -10))); // Expected output: -4.0\n    }\n}\n"}
{"task_id": "Java/48", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Checks if given string is a palindrome.\n     *\n     * @param text the string to be checked\n     * @return true if the string is a palindrome, false otherwise\n     */\n    public boolean is_palindrome(String text) {\n        int left = 0;\n        int right = text.length() - 1;\n\n        while (left < right) {\n            if (text.charAt(left) != text.charAt(right)) {\n                return false;\n            }\n            left++;\n            right--;\n        }\n\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.is_palindrome(\"\"));       // Expected: true\n        System.out.println(solution.is_palindrome(\"aba\"));    // Expected: true\n        System.out.println(solution.is_palindrome(\"aaaaa\"));  // Expected: true\n        System.out.println(solution.is_palindrome(\"zbcd\"));   // Expected: false\n    }\n}\n"}
{"task_id": "Java/49", "generation": "import org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nclass Solution {\n    /**\n     * Return 2^n modulo p (be aware of numerics).\n     */\n    public int modp(int n, int p) {\n        if (n == 0) return 1; // Base case: any number to the power of 0 is 1\n        long result = 1;\n        long base = 2 % p; // Start with 2 and take modulo p to avoid overflow\n\n        while (n > 0) {\n            if ((n & 1) == 1) { // If n is odd, multiply the result by the current base\n                result = (result * base) % p;\n            }\n            base = (base * base) % p; // Square the base and take modulo p to avoid overflow\n            n >>= 1; // Divide n by 2 using bit shift\n        }\n\n        return (int) result;\n    }\n\n    @Test\n    public void testModp() {\n        assertEquals(3, modp(3, 5), \"modp(3, 5) should be 3\");\n        assertEquals(2, modp(1101, 101), \"modp(1101, 101) should be 2\");\n        assertEquals(1, modp(0, 101), \"modp(0, 101) should be 1\");\n        assertEquals(8, modp(3, 11), \"modp(3, 11) should be 8\");\n        assertEquals(1, modp(100, 101), \"modp(100, 101) should be 1\");\n    }\n}\n"}
{"task_id": "Java/50", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Returns encoded string by shifting every character by 5 in the alphabet.\n     */\n    public String encodeShift(String s) {\n        StringBuilder sb = new StringBuilder();\n        for (char ch : s.toCharArray()) {\n            // Ensure that only lowercase letters are shifted\n            if (ch >= 'a' && ch <= 'z') {\n                sb.append((char) ('a' + ((ch - 'a' + 5) % 26)));\n            } else {\n                sb.append(ch);\n            }\n        }\n        return sb.toString();\n    }\n\n    /**\n     * Takes as input string encoded with encodeShift function. Returns decoded string.\n     */\n    public String decode_shift(String s) {\n        StringBuilder sb = new StringBuilder();\n        for (char ch : s.toCharArray()) {\n            // Ensure that only lowercase letters are shifted\n            if (ch >= 'a' && ch <= 'z') {\n                sb.append((char) ('a' + ((ch - 'a' - 5 + 26) % 26)));\n            } else {\n                sb.append(ch);\n            }\n        }\n        return sb.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        String test1 = \"hello\";\n        String encodedTest1 = solution.encodeShift(test1);  // Should be \"mjqqt\"\n        System.out.println(\"Encoded: \" + encodedTest1);\n        \n        String decodedTest1 = solution.decode_shift(encodedTest1);  // Should be back to \"hello\"\n        System.out.println(\"Decoded: \" + decodedTest1);\n\n        assert test1.equals(decodedTest1) : \"The decode function should return the original string\";\n\n        String test2 = \"world\";\n        String encodedTest2 = solution.encodeShift(test2);  // Should be \"btwqi\"\n        System.out.println(\"Encoded: \" + encodedTest2);\n        \n        String decodedTest2 = solution.decode_shift(encodedTest2);  // Should be back to \"world\"\n        System.out.println(\"Decoded: \" + decodedTest2);\n\n        assert test2.equals(decodedTest2) : \"The decode function should return the original string\";\n    }\n}\n"}
{"task_id": "Java/51", "generation": "import org.junit.Test;\nimport static org.junit.Assert.assertEquals;\n\nclass Solution {\n\n    /**\n     * remove_vowels is a function that takes string and returns string without vowels.\n     */\n    public String remove_vowels(String text) {\n        if (text == null || text.isEmpty()) return text;\n        \n        StringBuilder result = new StringBuilder();\n        for (char c : text.toCharArray()) {\n            if (!isVowel(c)) {\n                result.append(c);\n            }\n        }\n        return result.toString();\n    }\n\n    private boolean isVowel(char c) {\n        return \"AEIOUaeiou\".indexOf(c) != -1;\n    }\n\n    @Test\n    public void testRemoveVowels() {\n        assertEquals(\"\", remove_vowels(\"\"));\n        assertEquals(\"bcdf\\nghjklm\", remove_vowels(\"abcdef\\nghijklm\"));\n        assertEquals(\"bcdf\", remove_vowels(\"abcdef\"));\n        assertEquals(\"\", remove_vowels(\"aaaaa\"));\n        assertEquals(\"B\", remove_vowels(\"aaBAA\"));\n        assertEquals(\"zbcd\", remove_vowels(\"zbcd\"));\n    }\n\n}\n"}
{"task_id": "Java/52", "generation": "import java.util.*;\n\nclass Solution {\n\n    /**\n     * Return True if all numbers in the list l are below threshold t.\n     *\n     * @param l List of integers to be checked.\n     * @param t The threshold value.\n     * @return true if all elements in l are less than t, false otherwise.\n     */\n    public boolean below_threshold(List<Integer> l, int t) {\n        for (int num : l) {\n            if (num >= t) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    // Test cases to verify the correctness of the solution\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n\n        // Test case 1: All elements are below threshold\n        List<Integer> list1 = Arrays.asList(1, 2, 4, 10);\n        int threshold1 = 100;\n        System.out.println(sol.below_threshold(list1, threshold1)); // Expected output: true\n\n        // Test case 2: Not all elements are below threshold\n        List<Integer> list2 = Arrays.asList(1, 20, 4, 10);\n        int threshold2 = 5;\n        System.out.println(sol.below_threshold(list2, threshold2)); // Expected output: false\n\n        // Test case 3: Empty list should return true as there are no elements to violate the condition\n        List<Integer> list3 = new ArrayList<>();\n        int threshold3 = 10;\n        System.out.println(sol.below_threshold(list3, threshold3)); // Expected output: true\n\n        // Test case 4: All elements equal to the threshold minus one should return true\n        List<Integer> list4 = Arrays.asList(9, 8, 7);\n        int threshold4 = 10;\n        System.out.println(sol.below_threshold(list4, threshold4)); // Expected output: true\n\n        // Test case 5: At least one element equal to the threshold should return false\n        List<Integer> list5 = Arrays.asList(9, 8, 7, 10);\n        int threshold5 = 10;\n        System.out.println(sol.below_threshold(list5, threshold5)); // Expected output: false\n    }\n}\n"}
{"task_id": "Java/53", "generation": "import org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nclass Solution {\n    /**\n     * Add two numbers x and y\n     *\n     * @param x first number to add\n     * @param y second number to add\n     * @return the sum of x and y\n     */\n    public int add(int x, int y) {\n        return x + y;\n    }\n\n    // Unit tests for the add method\n    @Test\n    void testAdd() {\n        assertEquals(5, new Solution().add(2, 3), \"Adding 2 and 3 should give 5\");\n        assertEquals(12, new Solution().add(5, 7), \"Adding 5 and 7 should give 12\");\n        assertEquals(-1, new Solution().add(-2, 1), \"Adding -2 and 1 should give -1\");\n        assertEquals(0, new Solution().add(-3, 3), \"Adding -3 and 3 should give 0\");\n    }\n}\n"}
{"task_id": "Java/54", "generation": "import java.util.HashSet;\nimport java.util.Set;\n\nclass Solution {\n    /**\n     * Check if two words have the same kind of characters.\n     *\n     * @param s0 first word\n     * @param s1 second word\n     * @return true if both strings contain exactly the same set of unique characters, false otherwise\n     */\n    public boolean same_chars(String s0, String s1) {\n        Set<Character> set0 = new HashSet<>();\n        for (char c : s0.toCharArray()) {\n            set0.add(c);\n        }\n\n        Set<Character> set1 = new HashSet<>();\n        for (char c : s1.toCharArray()) {\n            set1.add(c);\n        }\n\n        return set0.equals(set1);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.same_chars(\"eabcdzzzz\", \"dddzzzzzzzddeddabc\")); // true\n        System.out.println(solution.same_chars(\"abcd\", \"dddddddabc\"));              // true\n        System.out.println(solution.same_chars(\"dddddddabc\", \"abcd\"));              // true\n        System.out.println(solution.same_chars(\"eabcd\", \"dddddddabc\"));             // false\n        System.out.println(solution.same_chars(\"abcd\", \"dddddddabce\"));             // false\n        System.out.println(solution.same_chars(\"eabcdzzzz\", \"dddzzzzzzzddddabc\"));  // false\n    }\n}\n"}
{"task_id": "Java/55", "generation": "import org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nclass Solution {\n    /**\n     * Return n-th Fibonacci number.\n     *\n     * @param n the position in the Fibonacci sequence\n     * @return the nth Fibonacci number\n     */\n    public int fib(int n) {\n        if (n <= 1) {\n            return n;\n        }\n        int a = 0, b = 1, c;\n        for (int i = 2; i <= n; i++) {\n            c = a + b;\n            a = b;\n            b = c;\n        }\n        return b;\n    }\n\n    @Test\n    public void testFib() {\n        assertEquals(55, fib(10), \"fib(10) should be 55\");\n        assertEquals(1, fib(1), \"fib(1) should be 1\");\n        assertEquals(21, fib(8), \"fib(8) should be 21\");\n    }\n}\n"}
{"task_id": "Java/56", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Checks if every opening bracket \"<\" has a corresponding closing bracket \">\".\n     *\n     * @param brackets A string containing only \"<\" and \">\" characters.\n     * @return true if the sequence of brackets is correct, false otherwise.\n     */\n    public boolean correct_bracketing(String brackets) {\n        int balance = 0;\n        \n        for (int i = 0; i < brackets.length(); i++) {\n            char c = brackets.charAt(i);\n            \n            // Increase balance for opening bracket\n            if (c == '<') {\n                balance++;\n            }\n            // Decrease balance for closing bracket\n            else if (c == '>') {\n                balance--;\n                \n                // If at any point the balance is negative, it means there's a closing bracket without an opening one.\n                if (balance < 0) {\n                    return false;\n                }\n            }\n        }\n        \n        // The sequence is correct only if the balance is zero at the end\n        return balance == 0;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.correct_bracketing(\"<\"));       // Expected: false\n        System.out.println(solution.correct_bracketing(\"<>\"));      // Expected: true\n        System.out.println(solution.correct_bracketing(\"<<><>>\"));  // Expected: true\n        System.out.println(solution.correct_bracketing(\"><<>\"));    // Expected: false\n    }\n}\n"}
{"task_id": "Java/57", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Return True if list elements are monotonically increasing or decreasing.\n     *\n     * @param l List of integers to check for monotonicity.\n     * @return true if the list is monotonically increasing or decreasing, false otherwise.\n     */\n    public boolean monotonic(List<Integer> l) {\n        // Check if the list is empty or has only one element\n        if (l == null || l.size() <= 1) return true;\n\n        // Determine if the sequence should be increasing or decreasing based on the first two elements\n        boolean increasing = l.get(1) >= l.get(0);\n\n        for (int i = 2; i < l.size(); i++) {\n            if ((increasing && l.get(i) < l.get(i - 1)) || (!increasing && l.get(i) > l.get(i - 1))) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.monotonic(Arrays.asList(1, 2, 4, 20))); // Expected: true\n        System.out.println(solution.monotonic(Arrays.asList(1, 20, 4, 10))); // Expected: false\n        System.out.println(solution.monotonic(Arrays.asList(4, 1, 0, -10))); // Expected: true\n\n        // Additional test cases for completeness\n        System.out.println(solution.monotonic(Arrays.asList())); // Expected: true (empty list)\n        System.out.println(solution.monotonic(Arrays.asList(5))); // Expected: true (single element)\n    }\n}\n"}
{"task_id": "Java/58", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Return sorted unique common elements for two lists.\n     *\n     * @param l1 First list of integers\n     * @param l2 Second list of integers\n     * @return A List containing the sorted, unique common elements between l1 and l2\n     */\n    public List<Integer> common(List<Integer> l1, List<Integer> l2) {\n        // Convert lists to sets for easy intersection operation\n        Set<Integer> set1 = new HashSet<>(l1);\n        Set<Integer> set2 = new HashSet<>(l2);\n\n        // Retain only the elements that are in both sets (intersection)\n        set1.retainAll(set2);\n\n        // Convert the resulting set back to a list and sort it\n        List<Integer> result = new ArrayList<>(set1);\n        Collections.sort(result);\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        System.out.println(solution.common(Arrays.asList(1, 4, 3, 34, 653, 2, 5), Arrays.asList(5, 7, 1, 5, 9, 653, 121)));\n        // Expected output: [1, 5, 653]\n\n        // Test case 2\n        System.out.println(solution.common(Arrays.asList(5, 3, 2, 8), Arrays.asList(3, 2)));\n        // Expected output: [2, 3]\n    }\n}\n"}
{"task_id": "Java/59", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return the largest prime factor of n. Assume n > 1 and is not a prime.\n     *\n     * @param n The number whose largest prime factor we want to find.\n     * @return The largest prime factor of n.\n     */\n    public int largest_prime_factor(int n) {\n        // Initialize the smallest prime factor\n        int factor = 2;\n        \n        while (factor * factor <= n) {\n            if (n % factor == 0) {\n                n /= factor; // Divide n by its smallest prime factor\n            } else {\n                factor++; // Move to the next potential factor\n            }\n        }\n\n        // If n is greater than 1, then it's a prime number and the largest one.\n        return n > 1 ? n : factor;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases to verify the correctness of the function\n        System.out.println(solution.largest_prime_factor(13195)); // Expected output: 29\n        System.out.println(solution.largest_prime_factor(2048));  // Expected output: 2\n    }\n}\n"}
{"task_id": "Java/60", "generation": "import org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nclass Solution {\n    /**\n     * sum_to_n is a function that sums numbers from 1 to n.\n     *\n     * @param n The upper limit of the summation (inclusive).\n     * @return The sum of all integers from 1 to n.\n     */\n    public int sum_to_n(int n) {\n        return (n * (n + 1)) / 2; // Using the arithmetic series sum formula\n    }\n\n    /**\n     * Test cases for the sum_to_n method.\n     */\n    @Test\n    void testSumToN() {\n        assertEquals(465, new Solution().sum_to_n(30));\n        assertEquals(5050, new Solution().sum_to_n(100));\n        assertEquals(15, new Solution().sum_to_n(5));\n        assertEquals(55, new Solution().sum_to_n(10));\n        assertEquals(1, new Solution().sum_to_n(1));\n    }\n}\n"}
{"task_id": "Java/61", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * brackets is a string of \"(\" and \")\".\n     * return True if every opening bracket has a corresponding closing bracket.\n     */\n    public boolean correct_bracketing(String brackets) {\n        Stack<Character> stack = new Stack<>();\n        \n        for (char ch : brackets.toCharArray()) {\n            if (ch == '(') {\n                // Push the opening bracket onto the stack\n                stack.push(ch);\n            } else if (ch == ')') {\n                // If there's no matching opening bracket, return false\n                if (stack.isEmpty() || stack.pop() != '(') {\n                    return false;\n                }\n            }\n        }\n\n        // If the stack is empty, all brackets were matched correctly\n        return stack.isEmpty();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.correct_bracketing(\"(\"));       // Expected: false\n        System.out.println(solution.correct_bracketing(\"()\"));      // Expected: true\n        System.out.println(solution.correct_bracketing(\"(()())\"));  // Expected: true\n        System.out.println(solution.correct_bracketing(\")(()\"));    // Expected: false\n    }\n}\n"}
{"task_id": "Java/62", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * xs represent coefficients of a polynomial.\n     * xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     * Return derivative of this polynomial in the same form.\n     */\n    public List<Integer> derivative(List<Integer> xs) {\n        // If the list is empty or has only one element, return an empty list as its derivative is 0.\n        if (xs == null || xs.size() <= 1) {\n            return new ArrayList<>();\n        }\n\n        List<Integer> result = new ArrayList<>();\n        for (int i = 1; i < xs.size(); i++) { // Start from index 1 to skip the constant term\n            result.add(xs.get(i) * i); // Compute derivative coefficient and add it to the list.\n        }\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        List<Integer> test1 = Arrays.asList(3, 1, 2, 4, 5);\n        System.out.println(\"Derivative of \" + test1 + \": \" + solution.derivative(test1)); // Expected: [1, 4, 12, 20]\n\n        List<Integer> test2 = Arrays.asList(1, 2, 3);\n        System.out.println(\"Derivative of \" + test2 + \": \" + solution.derivative(test2)); // Expected: [2, 6]\n    }\n}\n"}
{"task_id": "Java/63", "generation": "import java.util.*;\n\nclass Solution {\n    public int fibfib(int n) {\n        if (n == 0 || n == 1) return 0;\n        if (n == 2) return 1;\n\n        // Initialize an array to store the FibFib values.\n        int[] dp = new int[n + 1];\n        dp[0] = 0; // fibfib(0)\n        dp[1] = 0; // fibfib(1)\n        dp[2] = 1; // fibfib(2)\n\n        for (int i = 3; i <= n; ++i) {\n            dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3];\n        }\n\n        return dp[n];\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.fibfib(1)); // Expected output: 0\n        System.out.println(solution.fibfib(5)); // Expected output: 4\n        System.out.println(solution.fibfib(8)); // Expected output: 24\n\n        // Additional test case for a larger value of n to check efficiency.\n        System.out.println(solution.fibfib(30)); // Expected output: 1976250 (or whatever the correct value is)\n    }\n}\n"}
{"task_id": "Java/64", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Returns the number of vowels in the string.\n     * Vowels are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a vowel,\n     * but only when it is at the end of the given word.\n     *\n     * @param s The input string representing a word\n     * @return The number of vowels in the string\n     */\n    public int vowels_count(String s) {\n        if (s == null || s.isEmpty()) return 0;\n\n        String lowerCaseS = s.toLowerCase();\n        int count = 0;\n        \n        for (int i = 0; i < lowerCaseS.length(); i++) {\n            char c = lowerCaseS.charAt(i);\n            if (\"aeiou\".indexOf(c) != -1 || (c == 'y' && i == lowerCaseS.length() - 1)) {\n                count++;\n            }\n        }\n\n        return count;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.vowels_count(\"abcde\")); // Expected output: 2\n        System.out.println(solution.vowels_count(\"ACEDY\")); // Expected output: 3\n        System.out.println(solution.vowels_count(\"rhythm\")); // Expected output: 1 (only 'y' at the end)\n        System.out.println(solution.vowels_count(\"SYZYGY\")); // Expected output: 0\n        System.out.println(solution.vowels_count(\"\")); // Expected output: 0\n    }\n}\n"}
{"task_id": "Java/65", "generation": "class Solution {\n    /**\n     * Circular shift the digits of the integer x, shifting the digits right by shift\n     * and return the result as a string.\n     * If shift > number of digits, return digits reversed.\n     *\n     * @param x The integer to be shifted.\n     * @param shift The number of positions to shift the digits.\n     * @return A String representing the circularly shifted number.\n     */\n    public String circular_shift(int x, int shift) {\n        String numStr = Integer.toString(x);\n        int len = numStr.length();\n        \n        // If shift is greater than the length of the number, reverse it\n        if (shift >= len) {\n            return new StringBuilder(numStr).reverse().toString();\n        }\n        \n        // Calculate effective shift within the bounds of the string's length\n        int effectiveShift = shift % len;\n        \n        // Perform circular shift\n        String shiftedPart1 = numStr.substring(len - effectiveShift);\n        String shiftedPart2 = numStr.substring(0, len - effectiveShift);\n        \n        return shiftedPart1 + shiftedPart2;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.circular_shift(12, 1)); // Expected: \"21\"\n        System.out.println(solution.circular_shift(12, 2)); // Expected: \"12\"\n        System.out.println(solution.circular_shift(12345, 2)); // Expected: \"45123\"\n        System.out.println(solution.circular_shift(12345, 7)); // Expected: \"54321\" (since shift > number of digits)\n    }\n}\n"}
{"task_id": "Java/66", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Calculates the sum of ASCII codes of uppercase characters in the given string.\n     *\n     * @param s The input string.\n     * @return The sum of ASCII values of all uppercase letters in the string.\n     */\n    public int digitSum(String s) {\n        if (s == null || s.isEmpty()) return 0;\n\n        int sum = 0;\n        for (char c : s.toCharArray()) {\n            if (Character.isUpperCase(c)) {\n                sum += (int)c;\n            }\n        }\n\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.digitSum(\"\")); // Expected output: 0\n        System.out.println(solution.digitSum(\"abAB\")); // Expected output: 131\n        System.out.println(solution.digitSum(\"abcCd\")); // Expected output: 67\n        System.out.println(solution.digitSum(\"helloE\")); // Expected output: 69\n        System.out.println(solution.digitSum(\"woArBld\")); // Expected output: 131\n        System.out.println(solution.digitSum(\"aAaaaXa\")); // Expected output: 153\n    }\n}\n"}
{"task_id": "Java/67", "generation": "import java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nclass Solution {\n    /**\n     * Calculates the number of mango fruits in the basket given the total number of apples,\n     * oranges, and the overall count of fruits.\n     *\n     * @param s A string that represents the total number of apples and oranges.\n     * @param n An integer representing the total number of fruits in the basket.\n     * @return The number of mango fruits in the basket.\n     */\n    public int fruit_distribution(String s, int n) {\n        // Use regex to extract numbers from the input string\n        Pattern p = Pattern.compile(\"(\\\\d+) apples and (\\\\d+) oranges\");\n        Matcher m = p.matcher(s);\n        \n        if(m.find()) {\n            int apples = Integer.parseInt(m.group(1));\n            int oranges = Integer.parseInt(m.group(2));\n            \n            // Calculate mangoes by subtracting the number of apples and oranges from total fruits\n            return n - (apples + oranges);\n        }\n        \n        throw new IllegalArgumentException(\"Input string does not match expected format.\");\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.fruit_distribution(\"5 apples and 6 oranges\", 19)); // Expected output: 8\n        System.out.println(solution.fruit_distribution(\"0 apples and 1 oranges\", 3)); // Expected output: 2\n        System.out.println(solution.fruit_distribution(\"2 apples and 3 oranges\", 100)); // Expected output: 95\n        System.out.println(solution.fruit_distribution(\"100 apples and 1 oranges\", 120)); // Expected output: 19\n        \n        // Additional test cases to ensure robustness\n        try {\n            System.out.println(solution.fruit_distribution(\"apples and oranges\", 100));\n        } catch (IllegalArgumentException e) {\n            System.out.println(e.getMessage()); // Expected output: Input string does not match expected format.\n        }\n    }\n}\n"}
{"task_id": "Java/68", "generation": "import java.util.*;\n\nclass Solution {\n    public List<Integer> pluck(List<Integer> arr) {\n        int minValue = Integer.MAX_VALUE;\n        int minIndex = -1;\n\n        for (int i = 0; i < arr.size(); i++) {\n            int value = arr.get(i);\n            if (value % 2 == 0 && value <= minValue) {\n                if (value < minValue || (value == minValue && i < minIndex)) {\n                    minValue = value;\n                    minIndex = i;\n                }\n            }\n        }\n\n        if (minValue == Integer.MAX_VALUE) {\n            return new ArrayList<>();\n        } else {\n            List<Integer> result = new ArrayList<>();\n            result.add(minValue);\n            result.add(minIndex);\n            return result;\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.pluck(Arrays.asList(4, 2, 3))); // [2, 1]\n        System.out.println(solution.pluck(Arrays.asList(1, 2, 3))); // [2, 1]\n        System.out.println(solution.pluck(new ArrayList<>()));      // []\n        System.out.println(solution.pluck(Arrays.asList(5, 0, 3, 0, 4, 2))); // [0, 1]\n    }\n}\n"}
{"task_id": "Java/69", "generation": "import java.util.*;\n\nclass Solution {\n    public int search(List<Integer> lst) {\n        // Create a frequency map for each integer in the list.\n        Map<Integer, Integer> freqMap = new HashMap<>();\n        for (int num : lst) {\n            freqMap.put(num, freqMap.getOrDefault(num, 0) + 1);\n        }\n\n        // Initialize result as -1 to handle cases where no such value exists\n        int result = -1;\n\n        // Iterate through the frequency map and check if any number meets the criteria.\n        for (Map.Entry<Integer, Integer> entry : freqMap.entrySet()) {\n            int num = entry.getKey();\n            int freq = entry.getValue();\n\n            // Check if the frequency is greater than or equal to the value itself\n            if (freq >= num) {\n                result = Math.max(result, num);\n            }\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.search(Arrays.asList(4, 1, 2, 2, 3, 1))); // Expected output: 2\n        System.out.println(solution.search(Arrays.asList(1, 2, 2, 3, 3, 3, 4, 4, 4))); // Expected output: 3\n        System.out.println(solution.search(Arrays.asList(5, 5, 4, 4, 4))); // Expected output: -1\n    }\n}\n"}
{"task_id": "Java/70", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given list of integers, return list in strange order.\n     * Strange sorting, is when you start with the minimum value,\n     * then maximum of the remaining integers, then minimum and so on.\n     *\n     * @param lst List of integers to be sorted strangely\n     * @return A new list containing elements from lst but sorted in a strange order\n     */\n    public List<Integer> strange_sort_list(List<Integer> lst) {\n        if (lst == null || lst.isEmpty()) return lst;\n\n        // Create a copy of the original list and sort it for easy min/max retrieval\n        ArrayList<Integer> sortedList = new ArrayList<>(lst);\n        Collections.sort(sortedList);\n\n        List<Integer> result = new ArrayList<>();\n        boolean pickMin = true;\n        \n        while (!sortedList.isEmpty()) {\n            if (pickMin) {\n                // Add the minimum value from the list and remove it\n                int minVal = sortedList.get(0);\n                result.add(minVal);\n                sortedList.remove(Integer.valueOf(minVal));\n            } else {\n                // Add the maximum value from the list and remove it\n                int maxVal = sortedList.get(sortedList.size() - 1);\n                result.add(maxVal);\n                sortedList.remove(Integer.valueOf(maxVal));\n            }\n            pickMin = !pickMin; // Toggle between picking min and max\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.strange_sort_list(Arrays.asList(1, 2, 3, 4))); // Expected: [1, 4, 2, 3]\n        System.out.println(solution.strange_sort_list(Arrays.asList(5, 5, 5, 5))); // Expected: [5, 5, 5, 5]\n        System.out.println(solution.strange_sort_list(new ArrayList<>()));         // Expected: []\n    }\n}\n"}
{"task_id": "Java/71", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given the lengths of the three sides of a triangle, return the area of\n     * the triangle rounded to 2 decimal points if the three sides form a valid triangle.\n     * Otherwise, return -1. Three sides make a valid triangle when the sum of any two sides is greater\n     * than the third side.\n     *\n     * @param a length of first side\n     * @param b length of second side\n     * @param c length of third side\n     * @return area of the triangle or -1 if not a valid triangle\n     */\n    public double triangle_area(double a, double b, double c) {\n        // Check for validity of the triangle\n        if (a + b <= c || a + c <= b || b + c <= a) return -1;\n\n        // Calculate semi-perimeter\n        double s = (a + b + c) / 2.0;\n        \n        // Heron's formula to calculate area\n        double area = Math.sqrt(s * (s - a) * (s - b) * (s - c));\n        \n        // Round the result to two decimal places\n        return Math.round(area * 100.0) / 100.0;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.triangle_area(3, 4, 5)); // Expected output: 6.00\n        System.out.println(solution.triangle_area(1, 2, 10)); // Expected output: -1\n    }\n}\n"}
{"task_id": "Java/72", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Checks if an object q will fly based on balance and weight.\n     *\n     * @param q A list representing the object's elements.\n     * @param w The maximum possible weight for the object to fly.\n     * @return True if the object is balanced (palindromic) and its sum <= w, False otherwise.\n     */\n    public boolean will_it_fly(List<Integer> q, int w) {\n        // Check if list is palindromic\n        for (int i = 0; i < q.size() / 2; i++) {\n            if (!q.get(i).equals(q.get(q.size() - 1 - i))) {\n                return false;\n            }\n        }\n\n        // Calculate the sum of elements in the list\n        int sum = q.stream().mapToInt(Integer::intValue).sum();\n\n        // Check if sum is less than or equal to w\n        return sum <= w;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.will_it_fly(Arrays.asList(1, 2), 5)); // Expected: false\n        System.out.println(solution.will_it_fly(Arrays.asList(3, 2, 3), 1)); // Expected: false\n        System.out.println(solution.will_it_fly(Arrays.asList(3, 2, 3), 9)); // Expected: true\n        System.out.println(solution.will_it_fly(Arrays.asList(3), 5)); // Expected: true\n    }\n}\n"}
{"task_id": "Java/73", "generation": "import java.util.*;\n\nclass Solution {\n    public int smallest_change(List<Integer> arr) {\n        if (arr == null || arr.size() <= 1) return 0;\n\n        int changes = 0;\n        int left = 0, right = arr.size() - 1;\n\n        while (left < right) {\n            if (!arr.get(left).equals(arr.get(right))) {\n                changes++;\n            }\n            left++;\n            right--;\n        }\n\n        return changes;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        List<Integer> arr1 = Arrays.asList(1, 2, 3, 5, 4, 7, 9, 6);\n        System.out.println(\"Test Case 1: \" + (solution.smallest_change(arr1) == 4));\n\n        // Test case 2\n        List<Integer> arr2 = Arrays.asList(1, 2, 3, 4, 3, 2, 2);\n        System.out.println(\"Test Case 2: \" + (solution.smallest_change(arr2) == 1));\n\n        // Test case 3\n        List<Integer> arr3 = Arrays.asList(1, 2, 3, 2, 1);\n        System.out.println(\"Test Case 3: \" + (solution.smallest_change(arr3) == 0));\n    }\n}\n"}
{"task_id": "Java/74", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Compares two lists based on the total number of characters in each list.\n     * Returns the list with fewer total characters, or the first list if they are equal.\n     *\n     * @param lst1 First list of strings to compare.\n     * @param lst2 Second list of strings to compare.\n     * @return The list with fewer total characters, or the first list if equal.\n     */\n    public List<String> total_match(List<String> lst1, List<String> lst2) {\n        int count1 = lst1.stream().mapToInt(String::length).sum();\n        int count2 = lst2.stream().mapToInt(String::length).sum();\n\n        return count1 <= count2 ? lst1 : lst2;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.total_match(Arrays.asList(), Arrays.asList())); // -> []\n        System.out.println(solution.total_match(Arrays.asList(\"hi\", \"admin\"), Arrays.asList(\"hI\", \"Hi\"))); // -> [\"hI\", \"Hi\"]\n        System.out.println(solution.total_match(Arrays.asList(\"hi\", \"admin\"), Arrays.asList(\"hi\", \"hi\", \"admin\", \"project\"))); // -> [\"hi\", \"admin\"]\n        System.out.println(solution.total_match(Arrays.asList(\"hi\", \"admin\"), Arrays.asList(\"hI\", \"hi\", \"hi\"))); // -> [\"hI\", \"hi\", \"hi\"]\n        System.out.println(solution.total_match(Arrays.asList(\"4\"), Arrays.asList(\"1\", \"2\", \"3\", \"4\", \"5\"))); // -> [\"4\"]\n    }\n}\n"}
{"task_id": "Java/75", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Checks if a number is the multiplication of 3 prime numbers.\n     *\n     * @param a The number to check.\n     * @return true if the given number is the product of exactly three primes, false otherwise.\n     */\n    public boolean is_multiply_prime(int a) {\n        // List of all prime numbers less than 100\n        int[] primes = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97};\n\n        // Iterate over all combinations of three primes\n        for (int i = 0; i < primes.length; i++) {\n            for (int j = i; j < primes.length; j++) {\n                for (int k = j; k < primes.length; k++) {\n                    if (primes[i] * primes[j] * primes[k] == a) {\n                        return true;\n                    }\n                }\n            }\n        }\n\n        // If no combination of three primes equals the number, return false\n        return false;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.is_multiply_prime(30));  // true (2 * 3 * 5)\n        System.out.println(solution.is_multiply_prime(105)); // true (3 * 5 * 7)\n        System.out.println(solution.is_multiply_prime(49));  // false (not a product of three primes)\n        System.out.println(solution.is_multiply_prime(60));  // false (2 * 2 * 3 * 5, more than three primes)\n    }\n}\n"}
{"task_id": "Java/76", "generation": "class Solution {\n    /**\n     * Checks if x is a simple power of n.\n     *\n     * @param x The number to check.\n     * @param n The base number.\n     * @return true if x is a simple power of n, false otherwise.\n     */\n    public boolean is_simple_power(int x, int n) {\n        // Special case: any number to the power 0 is 1\n        if (x == 1) return n == 1;\n        \n        // If n is 1 and x is not 1, it's impossible for x to be a simple power of n.\n        if (n == 1) return false;\n\n        int temp = 1;\n        while (temp < x) {\n            temp *= n;\n        }\n        return temp == x;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.is_simple_power(1, 4)); // true\n        System.out.println(solution.is_simple_power(2, 2)); // true\n        System.out.println(solution.is_simple_power(8, 2)); // true\n        System.out.println(solution.is_simple_power(3, 2)); // false\n        System.out.println(solution.is_simple_power(3, 1)); // false\n        System.out.println(solution.is_simple_power(5, 3)); // false\n\n        // Additional test cases for thoroughness\n        System.out.println(solution.is_simple_power(9, 3)); // true\n        System.out.println(solution.is_simple_power(27, 3)); // true\n        System.out.println(solution.is_simple_power(16, 4)); // true\n        System.out.println(solution.is_simple_power(81, 3)); // true\n        System.out.println(solution.is_simple_power(10, 5)); // false\n    }\n}\n"}
{"task_id": "Java/77", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Checks if the given integer 'a' is a perfect cube.\n     *\n     * @param a The integer to check.\n     * @return true if 'a' is a perfect cube, false otherwise.\n     */\n    public boolean iscube(int a) {\n        // Calculate the cube root of 'a'\n        int cubeRoot = (int) Math.round(Math.cbrt(a));\n        \n        // Check if the cube of the calculated cube root equals 'a'.\n        return cubeRoot * cubeRoot * cubeRoot == a;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.iscube(1));   // Expected: true\n        System.out.println(solution.iscube(2));   // Expected: false\n        System.out.println(solution.iscube(-1));  // Expected: true\n        System.out.println(solution.iscube(64));  // Expected: true\n        System.out.println(solution.iscube(0));   // Expected: true\n        System.out.println(solution.iscube(180)); // Expected: false\n    }\n}\n"}
{"task_id": "Java/78", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Counts the number of hexadecimal digits in the given string that are prime.\n     */\n    public int hex_key(String num) {\n        // Define a set with prime hexadecimal digits\n        Set<Character> primes = new HashSet<>(Arrays.asList('2', '3', '5', '7', 'B', 'D'));\n        \n        int count = 0;\n        for (char c : num.toCharArray()) {\n            if (primes.contains(c)) {\n                count++;\n            }\n        }\n        return count;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.hex_key(\"AB\")); // Expected output: 1\n        System.out.println(solution.hex_key(\"1077E\")); // Expected output: 2\n        System.out.println(solution.hex_key(\"ABED1A33\")); // Expected output: 4\n        System.out.println(solution.hex_key(\"123456789ABCDEF0\")); // Expected output: 6\n        System.out.println(solution.hex_key(\"2020\")); // Expected output: 2\n    }\n}\n"}
{"task_id": "Java/79", "generation": "class Solution {\n    public String decimal_to_binary(int decimal) {\n        // Convert the decimal number to binary using Integer.toBinaryString method.\n        String binary = Integer.toBinaryString(decimal);\n        \n        // Add 'db' at the start and end of the binary string.\n        return \"db\" + binary + \"db\";\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.decimal_to_binary(15));  // Expected output: db1111db\n        System.out.println(solution.decimal_to_binary(32));  // Expected output: db100000db\n    }\n}\n"}
{"task_id": "Java/80", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    \n    /**\n     * Checks if a string is happy.\n     * A string is considered happy if its length is at least 3 and every set of three consecutive letters are distinct.\n     *\n     * @param s the input string to check\n     * @return true if the string is happy, false otherwise\n     */\n    public boolean is_happy(String s) {\n        // Check if the string's length is less than 3\n        if (s.length() < 3) return false;\n\n        // Iterate through the string and check every set of three consecutive characters\n        for (int i = 0; i < s.length() - 2; i++) {\n            char first = s.charAt(i);\n            char second = s.charAt(i + 1);\n            char third = s.charAt(i + 2);\n\n            // If any two out of the three are the same, return false\n            if (first == second || first == third || second == third) {\n                return false;\n            }\n        }\n\n        // If all checks passed, return true\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.is_happy(\"a\"));      // Expected: false\n        System.out.println(solution.is_happy(\"aa\"));     // Expected: false\n        System.out.println(solution.is_happy(\"abcd\"));   // Expected: true\n        System.out.println(solution.is_happy(\"aabb\"));   // Expected: false\n        System.out.println(solution.is_happy(\"adb\"));    // Expected: true\n        System.out.println(solution.is_happy(\"xyy\"));    // Expected: false\n    }\n}\n"}
{"task_id": "Java/81", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n\n    public List<String> numerical_letter_grade(List<Double> grades) {\n        List<String> letterGrades = new ArrayList<>();\n        \n        for (Double gpa : grades) {\n            if (gpa >= 4.0) {\n                letterGrades.add(\"A+\");\n            } else if (gpa > 3.7) {\n                letterGrades.add(\"A\");\n            } else if (gpa > 3.3) {\n                letterGrades.add(\"A-\");\n            } else if (gpa > 3.0) {\n                letterGrades.add(\"B+\");\n            } else if (gpa > 2.7) {\n                letterGrades.add(\"B\");\n            } else if (gpa > 2.3) {\n                letterGrades.add(\"B-\");\n            } else if (gpa > 2.0) {\n                letterGrades.add(\"C+\");\n            } else if (gpa > 1.7) {\n                letterGrades.add(\"C\");\n            } else if (gpa > 1.3) {\n                letterGrades.add(\"C-\");\n            } else if (gpa > 1.0) {\n                letterGrades.add(\"D+\");\n            } else if (gpa > 0.7) {\n                letterGrades.add(\"D\");\n            } else if (gpa > 0.0) {\n                letterGrades.add(\"D-\");\n            } else {\n                letterGrades.add(\"E\");\n            }\n        }\n\n        return letterGrades;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case\n        List<Double> testGPAs = Arrays.asList(4.0, 3.0, 1.7, 2.0, 3.5);\n        List<String> expectedGrades = Arrays.asList(\"A+\", \"B\", \"C-\", \"C\", \"A-\");\n        \n        // Call the method and print results\n        List<String> actualGrades = solution.numerical_letter_grade(testGPAs);\n        System.out.println(actualGrades);\n\n        // Check if the result is as expected\n        boolean isCorrect = actualGrades.equals(expectedGrades);\n        System.out.println(\"Test passed: \" + isCorrect);\n    }\n}\n"}
{"task_id": "Java/82", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Checks if a number is prime.\n     *\n     * @param num The number to check.\n     * @return true if the number is prime, false otherwise.\n     */\n    private boolean isPrime(int num) {\n        if (num <= 1) return false;\n        for (int i = 2; i <= Math.sqrt(num); i++) {\n            if (num % i == 0) return false;\n        }\n        return true;\n    }\n\n    /**\n     * Returns true if the string length is a prime number or false otherwise.\n     *\n     * @param string The input string to check.\n     * @return true if the length of the string is prime, false otherwise.\n     */\n    public boolean prime_length(String string) {\n        return isPrime(string.length());\n    }\n\n    /**\n     * Test function for prime_length method.\n     */\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.prime_length(\"Hello\"));   // Expected: true\n        System.out.println(solution.prime_length(\"abcdcba\")); // Expected: true\n        System.out.println(solution.prime_length(\"kittens\")); // Expected: true\n        System.out.println(solution.prime_length(\"orange\"));  // Expected: false\n    }\n}\n"}
{"task_id": "Java/83", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a positive integer n, return the count of the numbers of n-digit\n     * positive integers that start or end with 1.\n     */\n    public int starts_one_ends(int n) {\n        if (n == 1) {\n            // Special case for single digit where only '1' is valid\n            return 1;\n        }\n        long count = 17L * (long)Math.pow(10, n - 2);\n        return (int)count;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.starts_one_ends(1)); // Expected output: 1\n        System.out.println(solution.starts_one_ends(2)); // Expected output: 18 (01, 10-19, 21, ..., 91)\n        System.out.println(solution.starts_one_ends(3)); // Expected output: 170\n    }\n}\n"}
{"task_id": "Java/84", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    \n    /**\n     * Given a positive integer N, return in binary the total sum of its digits.\n     *\n     * @param N The input integer (0 <= N <= 10000).\n     * @return A string representing the binary form of the sum of the digits of N.\n     */\n    public String solve(int N) {\n        int sum = 0;\n        \n        // Calculate the sum of digits\n        while (N > 0) {\n            sum += N % 10;\n            N /= 10;\n        }\n        \n        // Convert the sum to binary and return it as a string.\n        return Integer.toBinaryString(sum);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.solve(1000));  // Expected output: \"1\"\n        System.out.println(solution.solve(150));   // Expected output: \"110\"\n        System.out.println(solution.solve(147));   // Expected output: \"1100\"\n        \n        // Additional test cases\n        System.out.println(solution.solve(999));   // Expected output: \"11110\"\n        System.out.println(solution.solve(2345));  // Expected output: \"10110\"\n    }\n}\n"}
{"task_id": "Java/85", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given a non-empty list of integers lst, add the even elements that are at odd indices.\n     *\n     * @param lst List of integers.\n     * @return The sum of even elements at odd indices.\n     */\n    public int add(List<Integer> lst) {\n        if (lst == null || lst.isEmpty()) return 0;\n\n        int sum = 0;\n        // Iterate through the list, starting from index 1 and incrementing by 2\n        for (int i = 1; i < lst.size(); i += 2) {\n            Integer value = lst.get(i);\n            if (value != null && value % 2 == 0) {\n                sum += value;\n            }\n        }\n\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.add(Arrays.asList(4, 2, 6, 7))); // Expected output: 2\n        System.out.println(solution.add(Arrays.asList(1, 3, 5, 7, 9, 10))); // Expected output: 0 (no even elements at odd indices)\n        System.out.println(solution.add(Arrays.asList(2, 4, 6, 8, 10))); // Expected output: 12 (4 + 8)\n    }\n}\n"}
{"task_id": "Java/86", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public String anti_shuffle(String s) {\n        // Split the input string into words based on space.\n        String[] words = s.split(\" \");\n        \n        StringBuilder result = new StringBuilder();\n        \n        for (String word : words) {\n            char[] chars = word.toCharArray();\n            \n            // Sort characters in each word\n            Arrays.sort(chars);\n            \n            // Append sorted word to the result, followed by a space\n            result.append(new String(chars)).append(\" \");\n        }\n        \n        // Remove the trailing space and return the final string.\n        return result.toString().trim();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.anti_shuffle(\"Hi\")); // Expected: \"Hi\"\n        System.out.println(solution.anti_shuffle(\"hello\")); // Expected: \"ehllo\"\n        System.out.println(solution.anti_shuffle(\"Hello World!!!\")); // Expected: \"Hello !!!Wdlor\"\n    }\n}\n"}
{"task_id": "Java/87", "generation": "import java.util.*;\n\nclass Solution {\n    public List<List<Integer>> get_row(List<List<Integer>> lst, int x) {\n        // This list will hold all the found coordinates.\n        List<List<Integer>> result = new ArrayList<>();\n\n        // Iterate over each row in the jagged array.\n        for (int i = 0; i < lst.size(); i++) {\n            List<Integer> row = lst.get(i);\n            // Check each element of the current row.\n            for (int j = 0; j < row.size(); j++) {\n                if (row.get(j) == x) {\n                    // Add the coordinates to the result list.\n                    result.add(Arrays.asList(i, j));\n                }\n            }\n        }\n\n        // Sort the coordinates first by rows in ascending order,\n        // then by columns in descending order within each row.\n        Collections.sort(result, new Comparator<List<Integer>>() {\n            public int compare(List<Integer> o1, List<Integer> o2) {\n                if (!o1.get(0).equals(o2.get(0))) {\n                    return o1.get(0) - o2.get(0); // Sort by row in ascending order.\n                } else {\n                    return o2.get(1) - o1.get(1); // Sort by column in descending order within the same row.\n                }\n            }\n        });\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        List<List<Integer>> testList1 = Arrays.asList(\n            Arrays.asList(1, 2, 3, 4, 5, 6),\n            Arrays.asList(1, 2, 3, 4, 1, 6),\n            Arrays.asList(1, 2, 3, 4, 5, 1)\n        );\n        \n        List<List<Integer>> testList2 = new ArrayList<>();\n        \n        List<List<Integer>> testList3 = Arrays.asList(\n            new ArrayList<>(),\n            Arrays.asList(1),\n            Arrays.asList(1, 2, 3)\n        );\n\n        System.out.println(solution.get_row(testList1, 1)); // Expected: [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n        System.out.println(solution.get_row(testList2, 1)); // Expected: []\n        System.out.println(solution.get_row(testList3, 3)); // Expected: [[2, 2]]\n    }\n}\n"}
{"task_id": "Java/88", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given an array of non-negative integers, return a copy of the given array after sorting,\n     * you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n     * or sort it in descending order if the sum( first index value, last index value) is even.\n     *\n     * @param array The input list of non-negative integers\n     * @return A new sorted list based on the specified conditions\n     */\n    public List<Integer> sort_array(List<Integer> array) {\n        // Check for empty or single element lists\n        if (array == null || array.size() <= 1) return new ArrayList<>(array);\n\n        // Create a copy of the input list to avoid modifying it\n        List<Integer> sortedArray = new ArrayList<>(array);\n\n        int firstValue = sortedArray.get(0);\n        int lastValue = sortedArray.get(sortedArray.size() - 1);\n        \n        if ((firstValue + lastValue) % 2 == 0) {\n            // Sort in descending order\n            sortedArray.sort(Collections.reverseOrder());\n        } else {\n            // Sort in ascending order\n            Collections.sort(sortedArray);\n        }\n\n        return sortedArray;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.sort_array(new ArrayList<>())); // []\n        System.out.println(solution.sort_array(Arrays.asList(5))); // [5]\n        System.out.println(solution.sort_array(Arrays.asList(2, 4, 3, 0, 1, 5))); // [0, 1, 2, 3, 4, 5]\n        System.out.println(solution.sort_array(Arrays.asList(2, 4, 3, 0, 1, 5, 6))); // [6, 5, 4, 3, 2, 1, 0]\n    }\n}\n"}
{"task_id": "Java/89", "generation": "class Solution {\n    /**\n     * Encrypts a given string by rotating each letter down the alphabet by 4 places.\n     *\n     * @param s The input string to be encrypted.\n     * @return The encrypted string.\n     */\n    public String encrypt(String s) {\n        StringBuilder encrypted = new StringBuilder();\n        \n        for (char c : s.toCharArray()) {\n            if (Character.isLetter(c)) { // Check if the character is a letter\n                char base = Character.isUpperCase(c) ? 'A' : 'a';\n                int offset = ((c - base + 4) % 26); // Calculate new position with wrap around\n                encrypted.append((char)(base + offset));\n            } else {\n                // If the character is not a letter, append it as-is.\n                encrypted.append(c);\n            }\n        }\n\n        return encrypted.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.encrypt(\"hi\")); // Expected output: \"lm\"\n        System.out.println(solution.encrypt(\"asdfghjkl\")); // Expected output: \"ewhjklnop\"\n        System.out.println(solution.encrypt(\"gf\")); // Expected output: \"kj\"\n        System.out.println(solution.encrypt(\"et\")); // Expected output: \"ix\"\n    }\n}\n"}
{"task_id": "Java/90", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Returns the 2nd smallest element from the list.\n     *\n     * @param lst List of integers.\n     * @return Optional containing the second smallest integer or empty if not applicable.\n     */\n    public Optional<Integer> next_smallest(List<Integer> lst) {\n        // Check for null or too small lists\n        if (lst == null || lst.size() < 2) {\n            return Optional.empty();\n        }\n\n        TreeSet<Integer> sortedSet = new TreeSet<>(lst);\n        \n        // If there's only one unique element, return empty.\n        if (sortedSet.size() < 2) {\n            return Optional.empty();\n        }\n        \n        // Skip the first(smallest) and get the second smallest\n        Iterator<Integer> iterator = sortedSet.iterator();\n        iterator.next(); // skip the first\n        Integer secondSmallest = iterator.next();\n\n        return Optional.of(secondSmallest);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.next_smallest(Arrays.asList(1, 2, 3, 4, 5))); // Expected: Optional[2]\n        System.out.println(solution.next_smallest(Arrays.asList(5, 1, 4, 3, 2))); // Expected: Optional[2]\n        System.out.println(solution.next_smallest(new ArrayList<>()));             // Expected: Optional.empty\n        System.out.println(solution.next_smallest(Arrays.asList(1, 1)));           // Expected: Optional.empty\n    }\n}\n"}
{"task_id": "Java/91", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Counts the number of sentences that start with \"I\".\n     *\n     * @param S The input string containing multiple sentences.\n     * @return The count of sentences starting with \"I\".\n     */\n    public int isBored(String S) {\n        // Split the text into sentences based on '.', '?' or '!'\n        String[] sentences = S.split(\"[.?!]\");\n        \n        int boredomCount = 0;\n        for (String sentence : sentences) {\n            // Trim leading and trailing spaces\n            sentence = sentence.trim();\n            \n            // Check if the sentence starts with \"I\"\n            if (!sentence.isEmpty() && sentence.startsWith(\"I \")) {\n                boredomCount++;\n            }\n        }\n        \n        return boredomCount;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.isBored(\"Hello world\"));  // Expected output: 0\n        System.out.println(solution.isBored(\"The sky is blue. The sun is shining. I love this weather.\"));  // Expected output: 1\n        System.out.println(solution.isBored(\"I am happy. I am excited! Are you?\"));  // Expected output: 2\n    }\n}\n"}
{"task_id": "Java/92", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Create a function that takes 3 numbers.\n     * Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n     * Returns false in any other cases.\n     *\n     * Examples:\n     * any_int(5, 2, 7) -> true\n     * any_int(3, 2, 2) -> false\n     * any_int(3, -2, 1) -> true\n     * any_int(3.6, -2.2, 2) -> false\n     */\n    public boolean any_int(Object x, Object y, Object z) {\n        // Check if all inputs are integers\n        if (!(x instanceof Integer && y instanceof Integer && z instanceof Integer)) {\n            return false;\n        }\n        \n        int a = (Integer)x;\n        int b = (Integer)y;\n        int c = (Integer)z;\n\n        // Check if one number is the sum of the other two\n        return (a == b + c || b == a + c || c == a + b);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.any_int(5, 2, 7)); // true\n        System.out.println(solution.any_int(3, 2, 2)); // false\n        System.out.println(solution.any_int(3, -2, 1)); // true\n        System.out.println(solution.any_int(3.6, -2.2, 2)); // false\n    }\n}\n"}
{"task_id": "Java/93", "generation": "class Solution {\n    /**\n     * Encodes a message by swapping case and replacing vowels.\n     *\n     * @param message The original message string.\n     * @return The encoded message.\n     */\n    public String encode(String message) {\n        StringBuilder encodedMessage = new StringBuilder();\n        \n        for (char c : message.toCharArray()) {\n            if (Character.isLetter(c)) {\n                // Swap case\n                char swappedCaseChar = Character.isUpperCase(c) ? Character.toLowerCase(c) : Character.toUpperCase(c);\n                \n                // Replace vowels with the letter that appears 2 places ahead in the alphabet.\n                String vowelReplacements = \"aeiou\";\n                int index = vowelReplacements.indexOf(Character.toLowerCase(swappedCaseChar));\n                if (index != -1) {\n                    char replacementChar;\n                    if (index == 3 || index == 4) { // For 'u' and 'y'\n                        replacementChar = (char)(Character.isUpperCase(swappedCaseChar) ? 'A' + ((index + 2) % 5) : 'a' + ((index + 2) % 5));\n                    } else {\n                        replacementChar = (char)(swappedCaseChar + 2);\n                    }\n                    encodedMessage.append(Character.isLowerCase(swappedCaseChar) ? Character.toLowerCase(replacementChar) : Character.toUpperCase(replacementChar));\n                } else {\n                    // Not a vowel, just append the swapped case character.\n                    encodedMessage.append(swappedCaseChar);\n                }\n            }\n        }\n\n        return encodedMessage.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.encode(\"test\")); // Expected: \"TGST\"\n        System.out.println(solution.encode(\"This is a message\")); // Expected: \"tHKS KS C MGSSCGG\"\n        System.out.println(solution.encode(\"Hello World!\")); // Expected: \"hKLLQ wQRNG!\"\n    }\n}\n"}
{"task_id": "Java/94", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Finds the largest prime value in a list and returns the sum of its digits.\n     *\n     * @param lst List of integers.\n     * @return Sum of digits of the largest prime number found in the list.\n     */\n    public int skjkasdkd(List<Integer> lst) {\n        // Find the maximum prime number\n        int maxPrime = Integer.MIN_VALUE;\n        for (int num : lst) {\n            if (isPrime(num)) {\n                maxPrime = Math.max(maxPrime, num);\n            }\n        }\n\n        // If no prime was found, return 0\n        if (maxPrime == Integer.MIN_VALUE) {\n            return 0;\n        }\n\n        // Calculate the sum of digits of the largest prime number\n        int sumOfDigits = 0;\n        while (maxPrime > 0) {\n            sumOfDigits += maxPrime % 10;\n            maxPrime /= 10;\n        }\n        \n        return sumOfDigits;\n    }\n\n    /**\n     * Checks if a given number is prime.\n     *\n     * @param num The number to check.\n     * @return true if the number is prime, false otherwise.\n     */\n    private boolean isPrime(int num) {\n        if (num <= 1) {\n            return false;\n        }\n        for (int i = 2; i <= Math.sqrt(num); i++) {\n            if (num % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.skjkasdkd(Arrays.asList(0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3))); // 10\n        System.out.println(solution.skjkasdkd(Arrays.asList(1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1))); // 25\n        System.out.println(solution.skjkasdkd(Arrays.asList(1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3))); // 13\n        System.out.println(solution.skjkasdkd(Arrays.asList(0,724,32,71,99,32,6,0,5,91,83,0,5,6))); // 11\n        System.out.println(solution.skjkasdkd(Arrays.asList(0,81,12,3,1,21))); // 3\n        System.out.println(solution.skjkasdkd(Arrays.asList(0,8,1,2,1,7))); // 7\n    }\n}\n"}
{"task_id": "Java/95", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given a map, return True if all keys are strings and all keys are in lower case or in upper case, else return False.\n     * The function should return False is the given map is empty.\n     */\n    public boolean check_dict_case(Map<Object, Object> dict) {\n        // Check if the dictionary is empty\n        if (dict.isEmpty()) {\n            return false;\n        }\n\n        boolean hasLowerCase = false;\n        boolean hasUpperCase = false;\n\n        for (Object key : dict.keySet()) {\n            // Check if all keys are strings\n            if (!(key instanceof String)) {\n                return false;\n            }\n            \n            String strKey = (String) key;\n            // Determine the case of each string key\n            if (!strKey.equals(strKey.toLowerCase())) {\n                hasUpperCase = true;\n            }\n            if (!strKey.equals(strKey.toUpperCase())) {\n                hasLowerCase = true;\n            }\n\n            // If both lower and upper cases are found, return false\n            if (hasLowerCase && hasUpperCase) {\n                return false;\n            }\n        }\n\n        // Return true if all keys are either in lower case or upper case\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        Map<Object, Object> dict1 = new HashMap<>();\n        dict1.put(\"a\", \"apple\");\n        dict1.put(\"b\", \"banana\");\n\n        Map<Object, Object> dict2 = new HashMap<>();\n        dict2.put(\"a\", \"apple\");\n        dict2.put(\"A\", \"banana\");\n        dict2.put(\"B\", \"banana\");\n\n        Map<Object, Object> dict3 = new HashMap<>();\n        dict3.put(\"a\", \"apple\");\n        dict3.put(8, \"banana\"); // This is not a string key\n        dict3.put(\"a\", \"apple\");\n\n        Map<Object, Object> dict4 = new HashMap<>();\n        dict4.put(\"Name\", \"John\");\n        dict4.put(\"Age\", \"36\");\n        dict4.put(\"City\", \"Houston\");\n\n        Map<Object, Object> dict5 = new HashMap<>();\n        dict5.put(\"STATE\", \"NC\");\n        dict5.put(\"ZIP\", \"12345\");\n\n        System.out.println(solution.check_dict_case(dict1)); // Expected: true\n        System.out.println(solution.check_dict_case(dict2)); // Expected: false\n        System.out.println(solution.check_dict_case(dict3)); // Expected: false\n        System.out.println(solution.check_dict_case(dict4)); // Expected: false\n        System.out.println(solution.check_dict_case(dict5)); // Expected: true\n    }\n}\n"}
{"task_id": "Java/96", "generation": "import java.util.ArrayList;\nimport java.util.List;\n\nclass Solution {\n    /**\n     * Implement a function that takes an non-negative integer and returns an array of the first n\n     * integers that are prime numbers and less than n.\n     */\n    public List<Integer> count_up_to(int n) {\n        List<Integer> primes = new ArrayList<>();\n        \n        for (int i = 2; i < n; i++) {\n            if (isPrime(i)) {\n                primes.add(i);\n            }\n        }\n\n        return primes;\n    }\n\n    private boolean isPrime(int number) {\n        if (number <= 1) {\n            return false;\n        }\n        for (int i = 2; i * i <= number; i++) {\n            if (number % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.count_up_to(5));   // Expected: [2,3]\n        System.out.println(solution.count_up_to(11));  // Expected: [2,3,5,7]\n        System.out.println(solution.count_up_to(0));   // Expected: []\n        System.out.println(solution.count_up_to(20));  // Expected: [2,3,5,7,11,13,17,19]\n        System.out.println(solution.count_up_to(1));   // Expected: []\n        System.out.println(solution.count_up_to(18));  // Expected: [2,3,5,7,11,13,17]\n    }\n}\n"}
{"task_id": "Java/97", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Complete the function that takes two integers and returns\n    the product of their unit digits.\n    Assume the input is always valid.\n    Examples:\n    multiply(148, 412) should return 16.\n    multiply(19, 28) should return 72.\n    multiply(2020, 1851) should return 0.\n    multiply(14,-15) should return 20.\n     */\n    public int multiply(int a, int b) {\n        // Get the unit digit of both numbers\n        int unitDigitA = Math.abs(a % 10);\n        int unitDigitB = Math.abs(b % 10);\n\n        // Return their product\n        return unitDigitA * unitDigitB;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.multiply(148, 412)); // Expected output: 16\n        System.out.println(solution.multiply(19, 28));   // Expected output: 72\n        System.out.println(solution.multiply(2020, 1851)); // Expected output: 0\n        System.out.println(solution.multiply(14, -15));  // Expected output: 20\n    }\n}\n"}
{"task_id": "Java/98", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a string s, count the number of uppercase vowels in even indices.\n     *\n     * @param s The input string.\n     * @return The count of uppercase vowels at even indices.\n     */\n    public int count_upper(String s) {\n        // Define an array of uppercase vowels for easy checking\n        char[] vowels = {'A', 'E', 'I', 'O', 'U'};\n        \n        // Initialize the counter to 0\n        int count = 0;\n        \n        // Iterate over each character in the string, considering only even indices\n        for (int i = 0; i < s.length(); i += 2) {\n            char currentChar = s.charAt(i);\n            \n            // Check if the current character is an uppercase vowel\n            for (char v : vowels) {\n                if (currentChar == v) {\n                    count++;\n                    break;\n                }\n            }\n        }\n        \n        return count;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases to verify the correctness of the method\n        System.out.println(solution.count_upper(\"aBCdEf\"));  // Expected output: 1\n        System.out.println(solution.count_upper(\"abcdefg\")); // Expected output: 0\n        System.out.println(solution.count_upper(\"dBBE\"));    // Expected output: 0\n        System.out.println(solution.count_upper(\"AeIoU\"));   // Expected output: 3\n        System.out.println(solution.count_upper(\"AbCdEfGhIjKlMnOpQrStUvWxYz\")); // Expected output: 6\n    }\n}\n"}
{"task_id": "Java/99", "generation": "class Solution {\n    public int closest_integer(String value) {\n        double num = Double.parseDouble(value);\n        \n        if (num > 0) {\n            return (int)(Math.floor(num + 0.5));\n        } else {\n            return (int)(Math.ceil(num - 0.5));\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.closest_integer(\"10\"));      // Expected: 10\n        System.out.println(solution.closest_integer(\"15.3\"));    // Expected: 15\n        System.out.println(solution.closest_integer(\"14.5\"));    // Expected: 15\n        System.out.println(solution.closest_integer(\"-14.5\"));   // Expected: -15\n        System.out.println(solution.closest_integer(\"0.5\"));     // Expected: 1\n        System.out.println(solution.closest_integer(\"-0.5\"));    // Expected: -1\n    }\n}\n"}
{"task_id": "Java/100", "generation": "import java.util.ArrayList;\nimport java.util.List;\n\nclass Solution {\n    /**\n     * Given a positive integer n, makes a pile of n levels of stones.\n     * The first level has n stones. For each subsequent level:\n     * - If n is odd, the next level will have the next odd number of stones.\n     * - If n is even, the next level will have the next even number of stones.\n     *\n     * @param n the total levels in the pile\n     * @return a list where each element represents the number of stones at that level\n     */\n    public List<Integer> make_a_pile(int n) {\n        List<Integer> result = new ArrayList<>();\n        int currentStones = n;\n        \n        for (int i = 0; i < n; i++) {\n            result.add(currentStones);\n            // Determine the next number of stones based on whether the current is odd or even\n            if (currentStones % 2 == 0) {\n                currentStones += 2; // Next even number\n            } else {\n                currentStones += 2; // Next odd number\n            }\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases to verify the correctness of the make_a_pile method.\n        System.out.println(solution.make_a_pile(3)); // Expected: [3, 5, 7]\n        System.out.println(solution.make_a_pile(4)); // Expected: [4, 6, 8, 10]\n    }\n}\n"}
{"task_id": "Java/101", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Splits a given string of words separated by commas or spaces and returns an array of the words.\n     *\n     * @param s The input string containing words separated by commas or spaces.\n     * @return A List<String> containing each word from the input string as separate elements.\n     */\n    public List<String> words_string(String s) {\n        // Replace all commas with spaces to unify separators\n        String replacedString = s.replaceAll(\"[,]\", \" \");\n        \n        // Split the string by one or more spaces\n        String[] splitArray = replacedString.split(\"\\\\s+\");\n        \n        // Convert array to list and return\n        return Arrays.asList(splitArray);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case 1: Testing with a string containing commas and spaces.\n        List<String> result1 = solution.words_string(\"Hi, my name is John\");\n        System.out.println(result1.equals(Arrays.asList(\"Hi\", \"my\", \"name\", \"is\", \"John\"))); // Expected output: true\n        \n        // Test case 2: Testing with a string containing only commas as separators.\n        List<String> result2 = solution.words_string(\"One, two, three, four, five, six\");\n        System.out.println(result2.equals(Arrays.asList(\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"))); // Expected output: true\n        \n        // Test case 3: Testing with a string containing only spaces as separators.\n        List<String> result3 = solution.words_string(\"Hello world this is Java\");\n        System.out.println(result3.equals(Arrays.asList(\"Hello\", \"world\", \"this\", \"is\", \"Java\"))); // Expected output: true\n    }\n}\n"}
{"task_id": "Java/102", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * This function takes two positive numbers x and y and returns the\n     * biggest even integer number that is in the range [x, y] inclusive. If\n     * there's no such number, then the function should return -1.\n     *\n     * For example:\n     * choose_num(12, 15) = 14\n     * choose_num(13, 12) = -1\n     */\n    public int choose_num(int x, int y) {\n        // Ensure that x is less than or equal to y for the range check.\n        if (x > y) return -1;\n\n        // Start from y and decrement until we find an even number in the range [x, y].\n        for (int i = y; i >= x; i--) {\n            if (i % 2 == 0) {\n                return i;\n            }\n        }\n\n        // If no even number is found within the range.\n        return -1;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.choose_num(12, 15)); // Expected output: 14\n        System.out.println(solution.choose_num(13, 12)); // Expected output: -1\n        System.out.println(solution.choose_num(8, 10));  // Expected output: 10\n        System.out.println(solution.choose_num(9, 9));   // Expected output: -1\n        System.out.println(solution.choose_num(5, 7));   // Expected output: 6\n    }\n}\n"}
{"task_id": "Java/103", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Computes the average of integers from n through m (inclusive),\n     * rounds it to the nearest integer, and converts that to binary.\n     * Returns -1 if n > m.\n     *\n     * @param n The starting integer.\n     * @param m The ending integer.\n     * @return A string representing the binary form of the rounded average or -1.\n     */\n    public Object rounded_avg(int n, int m) {\n        if (n > m) return -1;\n\n        // Calculate sum and count\n        long sum = 0;\n        for (int i = n; i <= m; i++) {\n            sum += i;\n        }\n        int count = m - n + 1;\n\n        // Compute average, round to nearest integer\n        double avg = Math.round((double) sum / count);\n\n        // Convert the rounded average to binary string\n        return Long.toBinaryString(avg);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.rounded_avg(1, 5));   // Expected: \"11\"\n        System.out.println(solution.rounded_avg(7, 5));   // Expected: -1\n        System.out.println(solution.rounded_avg(10, 20)); // Expected: \"1111\"\n        System.out.println(solution.rounded_avg(20, 33)); // Expected: \"11011\"\n    }\n}\n"}
{"task_id": "Java/104", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given a list of positive integers x, return a sorted list of all elements that haven't any even digit.\n     *\n     * @param x List of positive integers\n     * @return Sorted list of integers without any even digits\n     */\n    public List<Integer> unique_digits(List<Integer> x) {\n        // Filter out numbers with even digits and sort the result\n        return x.stream()\n                .filter(this::hasNoEvenDigits)\n                .sorted()\n                .collect(Collectors.toList());\n    }\n\n    /**\n     * Helper method to check if a number has no even digit.\n     *\n     * @param num The number to check\n     * @return true if the number has no even digits, false otherwise\n     */\n    private boolean hasNoEvenDigits(int num) {\n        while (num > 0) {\n            int digit = num % 10;\n            if (digit % 2 == 0) return false; // If any digit is even, return false\n            num /= 10;\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        List<Integer> test1 = Arrays.asList(15, 33, 1422, 1);\n        System.out.println(solution.unique_digits(test1)); // Expected: [1, 15, 33]\n\n        List<Integer> test2 = Arrays.asList(152, 323, 1422, 10);\n        System.out.println(solution.unique_digits(test2)); // Expected: []\n\n        List<Integer> test3 = Arrays.asList(17, 29, 31, 43);\n        System.out.println(solution.unique_digits(test3)); // Expected: [17, 29, 31, 43]\n\n        List<Integer> test4 = Arrays.asList();\n        System.out.println(solution.unique_digits(test4)); // Expected: []\n    }\n}\n"}
{"task_id": "Java/105", "generation": "import java.util.*;\n\nclass Solution {\n    public List<String> by_length(List<Integer> arr) {\n        // Step 1: Filter out integers not between 1 and 9.\n        List<Integer> filtered = new ArrayList<>();\n        for (Integer num : arr) {\n            if (num >= 1 && num <= 9) {\n                filtered.add(num);\n            }\n        }\n\n        // Step 2: Sort the filtered array.\n        Collections.sort(filtered);\n\n        // Step 3: Reverse the sorted array.\n        Collections.reverse(filtered);\n\n        // Step 4: Replace each digit with its corresponding name.\n        List<String> result = new ArrayList<>();\n        Map<Integer, String> numberNames = new HashMap<>() {{\n            put(1, \"One\");\n            put(2, \"Two\");\n            put(3, \"Three\");\n            put(4, \"Four\");\n            put(5, \"Five\");\n            put(6, \"Six\");\n            put(7, \"Seven\");\n            put(8, \"Eight\");\n            put(9, \"Nine\");\n        }};\n        \n        for (Integer num : filtered) {\n            result.add(numberNames.get(num));\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case 1\n        List<Integer> arr1 = Arrays.asList(2, 1, 1, 4, 5, 8, 2, 3);\n        System.out.println(solution.by_length(arr1)); // Expected: [Eight, Five, Four, Three, Two, Two, One, One]\n\n        // Test case 2\n        List<Integer> arr2 = new ArrayList<>();\n        System.out.println(solution.by_length(arr2)); // Expected: []\n\n        // Test case 3\n        List<Integer> arr3 = Arrays.asList(1, -1, 55);\n        System.out.println(solution.by_length(arr3)); // Expected: [One]\n    }\n}\n"}
{"task_id": "Java/106", "generation": "import java.util.ArrayList;\nimport java.util.List;\n\nclass Solution {\n    public List<Integer> f(int n) {\n        List<Integer> result = new ArrayList<>();\n        \n        for (int i = 1; i <= n; i++) {\n            if (i % 2 == 0) {\n                // If i is even, calculate the factorial of i\n                result.add(factorial(i));\n            } else {\n                // If i is odd, calculate the sum from 1 to i\n                int sum = 0;\n                for (int j = 1; j <= i; j++) {\n                    sum += j;\n                }\n                result.add(sum);\n            }\n        }\n        \n        return result;\n    }\n\n    private int factorial(int number) {\n        if (number == 0 || number == 1) {\n            return 1;\n        }\n        int fact = 1;\n        for (int i = 2; i <= number; i++) {\n            fact *= i;\n        }\n        return fact;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case 1\n        List<Integer> result1 = solution.f(5);\n        System.out.println(result1); // Expected: [1, 2, 6, 24, 15]\n        \n        // Test case 2\n        List<Integer> result2 = solution.f(3);\n        System.out.println(result2); // Expected: [1, 2, 6]\n\n        // Additional test cases can be added here as needed.\n    }\n}\n"}
{"task_id": "Java/107", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given a positive integer n, return a tuple that has the number of even and odd\n     * integer palindromes that fall within the range(1, n), inclusive.\n     *\n     * @param n The upper limit for checking palindromes (inclusive).\n     * @return A list containing two elements: [number_of_even_palindromes, number_of_odd_palindromes].\n     */\n    public List<Integer> even_odd_palindrome(int n) {\n        int evenCount = 0;\n        int oddCount = 0;\n\n        for (int i = 1; i <= n; i++) {\n            if (isPalindrome(i)) {\n                if (i % 2 == 0) {\n                    evenCount++;\n                } else {\n                    oddCount++;\n                }\n            }\n        }\n\n        return Arrays.asList(evenCount, oddCount);\n    }\n\n    private boolean isPalindrome(int number) {\n        String numStr = Integer.toString(number);\n        int left = 0;\n        int right = numStr.length() - 1;\n\n        while (left < right) {\n            if (numStr.charAt(left) != numStr.charAt(right)) {\n                return false;\n            }\n            left++;\n            right--;\n        }\n\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        List<Integer> result1 = solution.even_odd_palindrome(3);\n        System.out.println(result1); // Expected: [1, 2]\n\n        // Test case 2\n        List<Integer> result2 = solution.even_odd_palindrome(12);\n        System.out.println(result2); // Expected: [4, 6]\n    }\n}\n"}
{"task_id": "Java/108", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Returns the number of elements in the array whose sum of digits is greater than 0.\n     * If a number is negative, then its first signed digit will be negative:\n     * e.g. -123 has signed digits -1, 2, and 3.\n     */\n    public int count_nums(List<Integer> arr) {\n        return (int) arr.stream()\n                .filter(num -> sumOfDigits(num) > 0)\n                .count();\n    }\n\n    private int sumOfDigits(int num) {\n        int sum = 0;\n        boolean isNegative = num < 0;\n        while (num != 0) {\n            int digit = num % 10;\n            // If the number was negative, make the first digit also negative\n            if (isNegative && sum == 0) {\n                digit *= -1;\n            }\n            sum += digit;\n            num /= 10;\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.count_nums(Arrays.asList()) == 0); // Expected: true\n        System.out.println(solution.count_nums(Arrays.asList(-1, 11, -11)) == 1); // Expected: true\n        System.out.println(solution.count_nums(Arrays.asList(1, 1, 2)) == 3); // Expected: true\n        \n        // Additional test cases for thoroughness\n        System.out.println(solution.count_nums(Arrays.asList(-10, -9, -8)) == 0); // Expected: true\n        System.out.println(solution.count_nums(Arrays.asList(10, 9, 8)) == 3); // Expected: true\n    }\n}\n"}
{"task_id": "Java/109", "generation": "import java.util.*;\n\nclass Solution {\n    public boolean move_one_ball(List<Integer> arr) {\n        if (arr.isEmpty()) return true;\n\n        int n = arr.size();\n        int count = 0;\n        \n        // Find the point where we can split the array into two sorted parts.\n        for (int i = 1; i < n; ++i) {\n            if (arr.get(i - 1) > arr.get(i)) {\n                count++;\n                if (count > 1 || (i != n-1 && arr.get(0) < arr.get(i))) return false;\n            }\n        }\n\n        // Check the last and first element of the array.\n        if (count == 1 && arr.get(n - 1) > arr.get(0)) {\n            return false;\n        }\n\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        \n        System.out.println(sol.move_one_ball(Arrays.asList(3, 4, 5, 1, 2))); // Expected: true\n        System.out.println(sol.move_one_ball(Arrays.asList(3, 5, 4, 1, 2))); // Expected: false\n    }\n}\n"}
{"task_id": "Java/110", "generation": "import java.util.*;\n\nclass Solution {\n    public String exchange(List<Integer> lst1, List<Integer> lst2) {\n        int oddCountInLst1 = 0;\n        int evenCountInLst2 = 0;\n\n        // Count odd numbers in lst1 and even numbers in lst2\n        for (int num : lst1) {\n            if (num % 2 != 0) {\n                oddCountInLst1++;\n            }\n        }\n\n        for (int num : lst2) {\n            if (num % 2 == 0) {\n                evenCountInLst2++;\n            }\n        }\n\n        // If there are more odd numbers in lst1 than even numbers in lst2, it's impossible to make all elements of lst1 even\n        return oddCountInLst1 <= evenCountInLst2 ? \"YES\" : \"NO\";\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.exchange(Arrays.asList(1, 2, 3, 4), Arrays.asList(1, 2, 3, 4))); // Expected: YES\n        System.out.println(solution.exchange(Arrays.asList(1, 2, 3, 4), Arrays.asList(1, 5, 3, 4))); // Expected: NO\n        System.out.println(solution.exchange(Arrays.asList(1, 3, 5, 7), Arrays.asList(2, 4, 6, 8))); // Expected: YES\n        System.out.println(solution.exchange(Arrays.asList(1, 3, 5, 7), Arrays.asList(1, 3, 5, 7))); // Expected: NO\n    }\n}\n"}
{"task_id": "Java/111", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given a string representing space-separated lowercase letters,\n     * returns a dictionary of the letter with the most repetition and its corresponding count.\n     * If several letters have the same occurrence, return all of them.\n     */\n    public Map<String, Integer> histogram(String test) {\n        if (test == null || test.trim().isEmpty()) {\n            return new HashMap<>();\n        }\n\n        String[] tokens = test.split(\"\\\\s+\");\n        Map<String, Integer> countMap = new HashMap<>();\n\n        // Count occurrences\n        for (String token : tokens) {\n            countMap.put(token, countMap.getOrDefault(token, 0) + 1);\n        }\n\n        // Find the maximum occurrence\n        int maxCount = Collections.max(countMap.values());\n\n        // Filter out only those with the maximum occurrence\n        Map<String, Integer> result = new HashMap<>();\n        for (Map.Entry<String, Integer> entry : countMap.entrySet()) {\n            if (entry.getValue() == maxCount) {\n                result.put(entry.getKey(), entry.getValue());\n            }\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.histogram(\"a b c\"));          // {a=1, b=1, c=1}\n        System.out.println(solution.histogram(\"a b b a\"));        // {a=2, b=2}\n        System.out.println(solution.histogram(\"a b c a b\"));      // {a=2, b=2}\n        System.out.println(solution.histogram(\"b b b b a\"));      // {b=4}\n        System.out.println(solution.histogram(\"\"));               // {}\n    }\n}\n"}
{"task_id": "Java/112", "generation": "import java.util.*;\n\nclass Solution {\n    public List<Object> reverse_delete(String s, String c) {\n        // Remove all characters in 's' that are present in 'c'\n        StringBuilder result = new StringBuilder();\n        for (char ch : s.toCharArray()) {\n            if (c.indexOf(ch) == -1) {  // If character is not found in 'c', add it to the result\n                result.append(ch);\n            }\n        }\n\n        // Check if the resulting string is a palindrome\n        String strResult = result.toString();\n        boolean isPalindrome = new StringBuilder(strResult).reverse().toString().equals(strResult);\n\n        // Return the list containing the modified string and the palindrome check result\n        return Arrays.asList(strResult, isPalindrome);\n    }\n    \n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.reverse_delete(\"abcde\", \"ae\"));  // Expected: [\"bcd\", false]\n        System.out.println(solution.reverse_delete(\"abcdef\", \"b\"));  // Expected: [\"acdef\", false]\n        System.out.println(solution.reverse_delete(\"abcdedcba\", \"ab\"));  // Expected: [\"cdedc\", true]\n    }\n}\n"}
{"task_id": "Java/113", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given a list of strings, where each string consists of only digits,\n     * returns a list. Each element i of the output should be \"the number of odd elements in the\n     * string i of the input.\" where all the i's should be replaced by the number\n     * of odd digits in the i\"th string of the input.\n     */\n    public List<String> odd_count(List<String> lst) {\n        List<String> result = new ArrayList<>();\n        \n        for (String s : lst) {\n            int countOddDigits = 0;\n            // Counting the number of odd digits\n            for (char ch : s.toCharArray()) {\n                if ((ch - '0') % 2 != 0) {\n                    countOddDigits++;\n                }\n            }\n\n            // Creating the output string with replacements\n            String outputStr = \"the number of odd elements \" + countOddDigits +\n                               \"n the str\" + countOddDigits + \n                               \"ng \" + countOddDigits + \n                               \" of the \" + countOddDigits + \n                               \"nput.\";\n            \n            result.add(outputStr);\n        }\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case 1\n        List<String> input1 = Arrays.asList(\"1234567\");\n        System.out.println(solution.odd_count(input1));\n        \n        // Test case 2\n        List<String> input2 = Arrays.asList(\"3\", \"11111111\");\n        System.out.println(solution.odd_count(input2));\n    }\n}\n"}
{"task_id": "Java/114", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given an array of integers nums, find the minimum sum of any non-empty sub-array\n     * of nums.\n     *\n     * @param nums List of integers representing the input array.\n     * @return The minimum sum of any non-empty subarray in nums.\n     */\n    public int minSubArraySum(List<Integer> nums) {\n        if (nums == null || nums.isEmpty()) return 0;\n\n        int currentMin = nums.get(0);\n        int globalMin = nums.get(0);\n\n        for (int i = 1; i < nums.size(); i++) {\n            // Decide whether to start a new subarray or continue with the existing one\n            currentMin = Math.min(nums.get(i), currentMin + nums.get(i));\n            // Update the global minimum if needed\n            globalMin = Math.min(globalMin, currentMin);\n        }\n\n        return globalMin;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        List<Integer> test1 = Arrays.asList(2, 3, 4, 1, 2, 4);\n        System.out.println(\"Test Case 1: \" + (solution.minSubArraySum(test1) == 1));\n\n        List<Integer> test2 = Arrays.asList(-1, -2, -3);\n        System.out.println(\"Test Case 2: \" + (solution.minSubArraySum(test2) == -6));\n    }\n}\n"}
{"task_id": "Java/115", "generation": "import java.util.*;\n\nclass Solution {\n    public int max_fill(List<List<Integer>> grid, int capacity) {\n        int totalDrops = 0;\n        \n        // Iterate through each row (well)\n        for (List<Integer> row : grid) {\n            int waterUnits = 0;\n            \n            // Count the number of units of water in this well\n            for (int unit : row) {\n                if (unit == 1) {\n                    waterUnits++;\n                }\n            }\n            \n            // Calculate how many times we need to lower the bucket\n            totalDrops += Math.ceil((double) waterUnits / capacity);\n        }\n\n        return totalDrops;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        List<List<Integer>> grid1 = Arrays.asList(\n                Arrays.asList(0, 0, 1, 0),\n                Arrays.asList(0, 1, 0, 0),\n                Arrays.asList(1, 1, 1, 1)\n        );\n        System.out.println(solution.max_fill(grid1, 1)); // Expected output: 6\n\n        List<List<Integer>> grid2 = Arrays.asList(\n                Arrays.asList(0, 0, 1, 1),\n                Arrays.asList(0, 0, 0, 0),\n                Arrays.asList(1, 1, 1, 1),\n                Arrays.asList(0, 1, 1, 1)\n        );\n        System.out.println(solution.max_fill(grid2, 2)); // Expected output: 5\n\n        List<List<Integer>> grid3 = Arrays.asList(\n                Arrays.asList(0, 0, 0),\n                Arrays.asList(0, 0, 0)\n        );\n        System.out.println(solution.max_fill(grid3, 5)); // Expected output: 0\n    }\n}\n"}
{"task_id": "Java/116", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * In this Kata, you have to sort an array of integers according to\n     * number of ones in their binary representation in ascending order.\n     * For similar number of ones, sort based on decimal value.\n     *\n     * It must be implemented like this:\n     * >>> sort_array(Arrays.asList(1, 5, 2, 3, 4)).equals(Arrays.asList(1, 2, 4, 3, 5))\n     * >>> sort_array(Arrays.asList(-2, -3, -4, -5, -6)).equals(Arrays.asList(-4, -2, -6, -5, -3))\n     * >>> sort_array(Arrays.asList(1, 0, 2, 3, 4)).equals(Arrays.asList(0, 1, 2, 4, 3))\n     */\n    public List<Integer> sort_array(List<Integer> arr) {\n        Collections.sort(arr, new Comparator<Integer>() {\n            @Override\n            public int compare(Integer o1, Integer o2) {\n                // Count the number of ones in binary representation\n                int countOnesO1 = Integer.bitCount(o1);\n                int countOnesO2 = Integer.bitCount(o2);\n\n                if (countOnesO1 == countOnesO2) {\n                    return o1.compareTo(o2);  // Sort by decimal value if the number of ones is equal\n                }\n                return Integer.compare(countOnesO1, countOnesO2);\n            }\n        });\n        return arr;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        List<Integer> test1 = Arrays.asList(1, 5, 2, 3, 4);\n        List<Integer> expected1 = Arrays.asList(1, 2, 4, 3, 5);\n\n        List<Integer> test2 = Arrays.asList(-2, -3, -4, -5, -6);\n        List<Integer> expected2 = Arrays.asList(-4, -2, -6, -5, -3);\n\n        List<Integer> test3 = Arrays.asList(1, 0, 2, 3, 4);\n        List<Integer> expected3 = Arrays.asList(0, 1, 2, 4, 3);\n\n        System.out.println(solution.sort_array(test1).equals(expected1) ? \"Test 1 Passed\" : \"Test 1 Failed\");\n        System.out.println(solution.sort_array(test2).equals(expected2) ? \"Test 2 Passed\" : \"Test 2 Failed\");\n        System.out.println(solution.sort_array(test3).equals(expected3) ? \"Test 3 Passed\" : \"Test 3 Failed\");\n    }\n}\n"}
{"task_id": "Java/117", "generation": "import java.util.*;\n\nclass Solution {\n    public List<String> select_words(String s, int n) {\n        if (s == null || s.isEmpty()) return new ArrayList<>();\n        \n        String[] words = s.split(\"\\\\s+\");\n        List<String> result = new ArrayList<>();\n\n        for (String word : words) {\n            if (countConsonants(word) == n) {\n                result.add(word);\n            }\n        }\n\n        return result;\n    }\n\n    private int countConsonants(String word) {\n        int consonantCount = 0;\n        String vowels = \"aeiouAEIOU\";\n        \n        for (char c : word.toCharArray()) {\n            if (!vowels.contains(\"\" + Character.toLowerCase(c)) && Character.isLetter(c)) {\n                consonantCount++;\n            }\n        }\n\n        return consonantCount;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.select_words(\"Mary had a little lamb\", 4)); // [\"little\"]\n        System.out.println(solution.select_words(\"Mary had a little lamb\", 3)); // [\"Mary\", \"lamb\"]\n        System.out.println(solution.select_words(\"simple white space\", 2));     // []\n        System.out.println(solution.select_words(\"Hello world\", 4));            // [\"world\"]\n        System.out.println(solution.select_words(\"Uncle sam\", 3));              // [\"Uncle\"]\n    }\n}\n"}
{"task_id": "Java/118", "generation": "class Solution {\n    public String get_closest_vowel(String word) {\n        // Define a set of vowels for easy lookup.\n        Set<Character> vowels = new HashSet<>(Arrays.asList('a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'));\n        \n        // Iterate from the end of the string towards the beginning.\n        for (int i = word.length() - 2; i > 0; i--) {\n            char currentChar = word.charAt(i);\n            \n            // Check if the current character is a vowel and surrounded by consonants.\n            if (vowels.contains(currentChar) && !vowels.contains(word.charAt(i + 1)) && !vowels.contains(word.charAt(i - 1))) {\n                return String.valueOf(currentChar);\n            }\n        }\n\n        // Return an empty string if no such vowel is found.\n        return \"\";\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.get_closest_vowel(\"yogurt\"));  // Expected: \"u\"\n        System.out.println(solution.get_closest_vowel(\"FULL\"));    // Expected: \"U\"\n        System.out.println(solution.get_closest_vowel(\"quick\"));   // Expected: \"\"\n        System.out.println(solution.get_closest_vowel(\"ab\"));      // Expected: \"\"\n    }\n}\n"}
{"task_id": "Java/119", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Checks if it is possible to concatenate two strings of parentheses in such an order that all parentheses are balanced.\n     *\n     * @param lst A list containing two strings consisting only of \"(\" and \")\".\n     * @return \"Yes\" if there's a way to make a good string, otherwise \"No\".\n     */\n    public String match_parens(List<String> lst) {\n        int open1 = 0, close1 = 0;\n        int open2 = 0, close2 = 0;\n\n        // Count the number of open and close parentheses in each string\n        for (char c : lst.get(0).toCharArray()) {\n            if (c == '(') open1++;\n            else close1++;\n        }\n        for (char c : lst.get(1).toCharArray()) {\n            if (c == '(') open2++;\n            else close2++;\n        }\n\n        // Check both possible concatenations\n        boolean canConcatenate = (open1 >= close2 && open2 + open1 - close2 >= close1)\n                || (open2 >= close1 && open1 + open2 - close1 >= close2);\n\n        return canConcatenate ? \"Yes\" : \"No\";\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.match_parens(Arrays.asList(\"()(\", \")\")));  // Expected: Yes\n        System.out.println(solution.match_parens(Arrays.asList(\")\", \")\")));     // Expected: No\n        System.out.println(solution.match_parens(Arrays.asList(\"(()\", \"())\"))); // Expected: Yes\n        System.out.println(solution.match_parens(Arrays.asList(\"))(\", \"(\")));   // Expected: No\n    }\n}\n"}
{"task_id": "Java/120", "generation": "import java.util.*;\n\nclass Solution {\n    public List<Integer> maximum(List<Integer> arr, int k) {\n        // Use a min-heap to keep track of top k largest elements.\n        PriorityQueue<Integer> heap = new PriorityQueue<>();\n        \n        for (int num : arr) {\n            if (heap.size() < k) {\n                heap.add(num);\n            } else if (num > heap.peek()) {\n                heap.poll();  // Remove the smallest element\n                heap.add(num);  // Add the current number\n            }\n        }\n\n        // Convert the heap to a list and sort it in ascending order.\n        List<Integer> result = new ArrayList<>(heap);\n        Collections.sort(result);\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        System.out.println(solution.maximum(Arrays.asList(-3, -4, 5), 3));  // Output: [-4, -3, 5]\n\n        // Test case 2\n        System.out.println(solution.maximum(Arrays.asList(4, -4, 4), 2));   // Output: [4, 4]\n\n        // Test case 3\n        System.out.println(solution.maximum(Arrays.asList(-3, 2, 1, 2, -1, -2, 1), 1));  // Output: [2]\n    }\n}\n"}
{"task_id": "Java/121", "generation": "import java.util.*;\n\nclass Solution {\n\n    /**\n     * Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n     *\n     * @param lst The input list of integers.\n     * @return The sum of all odd elements at even positions.\n     */\n    public int solution(List<Integer> lst) {\n        int sum = 0;\n        \n        // Iterate through the list, starting from index 0 (even position), stepping by 2\n        for (int i = 0; i < lst.size(); i += 2) {\n            if (lst.get(i) % 2 != 0) { // Check if the element is odd\n                sum += lst.get(i);\n            }\n        }\n\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n\n        // Test cases to verify the solution method\n        System.out.println(sol.solution(Arrays.asList(5, 8, 7, 1))); // Expected output: 12 (5 + 7)\n        System.out.println(sol.solution(Arrays.asList(3, 3, 3, 3, 3))); // Expected output: 9 (3 + 3 + 3)\n        System.out.println(sol.solution(Arrays.asList(30, 13, 24, 321))); // Expected output: 0\n    }\n}\n"}
{"task_id": "Java/122", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given a non-empty array of integers arr and an integer k,\n     * return the sum of the elements with at most two digits from the first k elements of arr.\n     *\n     * @param arr List<Integer> - The input list of integers.\n     * @param k int - The number of elements to consider from the start of the array.\n     * @return int - Sum of elements with at most two digits among the first k elements.\n     */\n    public int add_elements(List<Integer> arr, int k) {\n        int sum = 0;\n        for (int i = 0; i < k && i < arr.size(); i++) {\n            if (arr.get(i) >= -99 && arr.get(i) <= 99) { // Check if the number has at most two digits\n                sum += arr.get(i);\n            }\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        List<Integer> test1 = Arrays.asList(111, 21, 3, 4000, 5, 6, 7, 8, 9);\n        int k1 = 4;\n        System.out.println(\"Test Case 1: \" + solution.add_elements(test1, k1)); // Expected output: 24\n        \n        List<Integer> test2 = Arrays.asList(10, 23, -56, 78, 99);\n        int k2 = 5;\n        System.out.println(\"Test Case 2: \" + solution.add_elements(test2, k2)); // Expected output: 45\n        \n        List<Integer> test3 = Arrays.asList(100, 200, 300, 40);\n        int k3 = 3;\n        System.out.println(\"Test Case 3: \" + solution.add_elements(test3, k3)); // Expected output: 0\n    }\n}\n"}
{"task_id": "Java/123", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n     */\n    public List<Integer> get_odd_collatz(int n) {\n        Set<Integer> oddNumbers = new HashSet<>();\n        \n        while (n != 1) {\n            if (n % 2 == 1) { // Check if n is odd\n                oddNumbers.add(n);\n            }\n            if (n % 2 == 0) { // If even, divide by 2\n                n /= 2;\n            } else { // If odd, apply the formula: 3*n + 1\n                n = 3 * n + 1;\n            }\n        }\n        oddNumbers.add(1); // Add 1 as it is always part of the sequence and is odd\n\n        List<Integer> result = new ArrayList<>(oddNumbers);\n        Collections.sort(result); // Sort in increasing order\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.get_odd_collatz(5));  // Expected: [1, 5]\n        System.out.println(solution.get_odd_collatz(7));  // Expected: [1, 7, 11, 22, 34, 52, 80, 121]\n        System.out.println(solution.get_odd_collatz(1));  // Expected: [1]\n    }\n}\n"}
{"task_id": "Java/124", "generation": "import java.util.*;\n\nclass Solution {\n    public boolean valid_date(String date) {\n        // Check for empty string\n        if (date == null || date.isEmpty()) return false;\n\n        // Split the date into components\n        String[] parts = date.split(\"-\");\n        \n        // Validate format and length of parts\n        if (parts.length != 3) return false;\n        \n        int month, day, year;\n        try {\n            month = Integer.parseInt(parts[0]);\n            day = Integer.parseInt(parts[1]);\n            year = Integer.parseInt(parts[2]);\n        } catch (NumberFormatException e) {\n            // If parsing fails, the date is invalid\n            return false;\n        }\n\n        // Validate month and day ranges based on month\n        if (month < 1 || month > 12) return false;\n\n        int maxDayInMonth = 31; // Default to maximum days in a month\n\n        switch (month) {\n            case 4:\n            case 6:\n            case 9:\n            case 11: \n                maxDayInMonth = 30;\n                break;\n            case 2:\n                maxDayInMonth = 29; // Leap year check not included in this problem\n                break;\n        }\n\n        if (day < 1 || day > maxDayInMonth) return false;\n\n        // If all checks pass, the date is valid\n        return true;\n    }\n    \n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        \n        System.out.println(sol.valid_date(\"03-11-2000\"));  // Expected: true\n        System.out.println(sol.valid_date(\"15-01-2012\"));  // Expected: false\n        System.out.println(sol.valid_date(\"04-0-2040\"));   // Expected: false\n        System.out.println(sol.valid_date(\"06-04-2020\"));  // Expected: true\n        System.out.println(sol.valid_date(\"06/04/2020\"));  // Expected: false\n    }\n}\n"}
{"task_id": "Java/125", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a string of words, return a list of words split on whitespace,\n     * if no whitespaces exist in the text you should split on commas ',',\n     * if no commas exist you should return the number of lower-case letters with odd order in the alphabet.\n     */\n    public Object split_words(String txt) {\n        // Check for spaces\n        if (txt.contains(\" \")) {\n            return Arrays.asList(txt.split(\"\\\\s+\"));\n        }\n        // Check for commas\n        else if (txt.contains(\",\")) {\n            return Arrays.asList(txt.split(\",\"));\n        } \n        // No spaces or commas, count odd-ordered lowercase letters\n        else {\n            int count = 0;\n            for (char c : txt.toCharArray()) {\n                if (Character.isLowerCase(c) && ((c - 'a') % 2 == 1)) {\n                    count++;\n                }\n            }\n            return count;\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.split_words(\"Hello world!\")); // Expected: [Hello, world!]\n        System.out.println(solution.split_words(\"Hello,world!\")); // Expected: [Hello, world!]\n        System.out.println(solution.split_words(\"abcdef\"));       // Expected: 3\n        \n        // Additional test cases\n        System.out.println(solution.split_words(\"a,b,c,d,e,f\")); // Expected: [a, b, c, d, e, f]\n        System.out.println(solution.split_words(\"abcde\"));        // Expected: 2 (b and d)\n    }\n}\n"}
{"task_id": "Java/126", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given a list of numbers, return whether or not they are sorted\n     * in ascending order. If any number appears more than twice, return false.\n     * Assume no negative numbers and only integers.\n     */\n    public boolean is_sorted(List<Integer> lst) {\n        if (lst == null || lst.size() <= 1) {\n            return true;\n        }\n\n        int count = 1; // Count of the current number\n        Integer prev = lst.get(0);\n\n        for (int i = 1; i < lst.size(); ++i) {\n            Integer curr = lst.get(i);\n            if (curr < prev) { // Check if sorted in ascending order\n                return false;\n            } else if (curr.equals(prev)) { // Count duplicates\n                count++;\n                if (count > 2) { // If any number appears more than twice, return false\n                    return false;\n                }\n            } else {\n                count = 1; // Reset count for a new number\n            }\n            prev = curr;\n        }\n\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.is_sorted(Arrays.asList(5))); // -> true\n        System.out.println(solution.is_sorted(Arrays.asList(1, 2, 3, 4, 5))); // -> true\n        System.out.println(solution.is_sorted(Arrays.asList(1, 3, 2, 4, 5))); // -> false\n        System.out.println(solution.is_sorted(Arrays.asList(1, 2, 3, 4, 5, 6))); // -> true\n        System.out.println(solution.is_sorted(Arrays.asList(1, 2, 3, 4, 5, 6, 7))); // -> true\n        System.out.println(solution.is_sorted(Arrays.asList(1, 3, 2, 4, 5, 6, 7))); // -> false\n        System.out.println(solution.is_sorted(Arrays.asList(1, 2, 2, 3, 3, 4))); // -> true\n        System.out.println(solution.is_sorted(Arrays.asList(1, 2, 2, 2, 3, 4))); // -> false\n    }\n}\n"}
{"task_id": "Java/127", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Determines whether the length of intersection of two intervals is a prime number.\n     *\n     * @param interval1 The first interval as a list [start, end].\n     * @param interval2 The second interval as a list [start, end].\n     * @return \"YES\" if the length of the intersection is a prime number, otherwise \"NO\".\n     */\n    public String intersection(List<Integer> interval1, List<Integer> interval2) {\n        int startMax = Math.max(interval1.get(0), interval2.get(0));\n        int endMin = Math.min(interval1.get(1), interval2.get(1));\n\n        // Check if there is an intersection\n        if (startMax > endMin) return \"NO\";\n\n        int lengthOfIntersection = endMin - startMax + 1;\n\n        // Check if the length of intersection is a prime number\n        if (isPrime(lengthOfIntersection)) {\n            return \"YES\";\n        } else {\n            return \"NO\";\n        }\n    }\n\n    /**\n     * Helper method to check if a number is prime.\n     *\n     * @param num The number to check.\n     * @return true if the number is prime, false otherwise.\n     */\n    private boolean isPrime(int num) {\n        if (num <= 1) return false;\n        for (int i = 2; i <= Math.sqrt(num); i++) {\n            if (num % i == 0) return false;\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.intersection(Arrays.asList(1, 2), Arrays.asList(2, 3))); // NO\n        System.out.println(solution.intersection(Arrays.asList(-1, 1), Arrays.asList(0, 4))); // NO\n        System.out.println(solution.intersection(Arrays.asList(-3, -1), Arrays.asList(-5, 5))); // YES\n    }\n}\n"}
{"task_id": "Java/128", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public Optional<Integer> prod_signs(List<Integer> arr) {\n        if (arr.isEmpty()) {\n            return Optional.empty();\n        }\n\n        int sumOfMagnitudes = 0;\n        int productOfSigns = 1;\n\n        for (int num : arr) {\n            sumOfMagnitudes += Math.abs(num);\n            if (num == 0) {\n                productOfSigns = 0;\n                break; // If there's a zero, the product of signs will be zero.\n            } else if (num < 0) {\n                productOfSigns *= -1;\n            }\n        }\n\n        return Optional.of(sumOfMagnitudes * productOfSigns);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.prod_signs(Arrays.asList(1, 2, 2, -4)).orElse(null)); // Expected: -9\n        System.out.println(solution.prod_signs(Arrays.asList(0, 1)).orElse(null));         // Expected: 0\n        System.out.println(solution.prod_signs(new ArrayList<>()).orElse(null));           // Expected: null\n    }\n}\n"}
{"task_id": "Java/129", "generation": "import java.util.*;\n\nclass Solution {\n    private int N;\n    private List<List<Integer>> grid;\n    private List<Integer> result;\n\n    public List<Integer> minPath(List<List<Integer>> grid, int k) {\n        this.N = (int)Math.sqrt(grid.size());\n        this.grid = grid;\n        this.result = new ArrayList<>();\n        \n        // Initialize the result with a large value to ensure any path will be smaller\n        for (int i = 0; i < k; ++i) {\n            result.add(Integer.MAX_VALUE);\n        }\n\n        // Start DFS from each cell in the grid\n        for (int row = 0; row < N; ++row) {\n            for (int col = 0; col < N; ++col) {\n                List<Integer> path = new ArrayList<>();\n                dfs(row, col, k, path);\n            }\n        }\n\n        return result;\n    }\n\n    private void dfs(int row, int col, int stepsLeft, List<Integer> path) {\n        // Add the current cell value to the path\n        path.add(grid.get(row).get(col));\n\n        // If we have reached the required length of the path\n        if (stepsLeft == 1) {\n            // Check if this path is lexicographically smaller than the current result\n            if (isSmaller(path, result)) {\n                result = new ArrayList<>(path);\n            }\n        } else {\n            // Explore all possible moves from the current cell\n            for (int[] dir : new int[][]{{-1, 0}, {1, 0}, {0, -1}, {0, 1}}) {\n                int newRow = row + dir[0];\n                int newCol = col + dir[1];\n\n                // Ensure the move is within grid boundaries\n                if (newRow >= 0 && newRow < N && newCol >= 0 && newCol < N) {\n                    dfs(newRow, newCol, stepsLeft - 1, path);\n                }\n            }\n        }\n\n        // Remove the current cell value from the path before backtracking\n        path.remove(path.size() - 1);\n    }\n\n    private boolean isSmaller(List<Integer> a, List<Integer> b) {\n        for (int i = 0; i < Math.min(a.size(), b.size()); ++i) {\n            if (!a.get(i).equals(b.get(i))) return a.get(i) < b.get(i);\n        }\n        return false;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n\n        // Test case 1\n        List<List<Integer>> grid1 = Arrays.asList(\n                Arrays.asList(1, 2, 3),\n                Arrays.asList(4, 5, 6),\n                Arrays.asList(7, 8, 9)\n        );\n        int k1 = 3;\n        System.out.println(sol.minPath(grid1, k1)); // Expected: [1, 2, 1]\n\n        // Test case 2\n        List<List<Integer>> grid2 = Arrays.asList(\n                Arrays.asList(5, 9, 3),\n                Arrays.asList(4, 1, 6),\n                Arrays.asList(7, 8, 2)\n        );\n        int k2 = 1;\n        System.out.println(sol.minPath(grid2, k2)); // Expected: [1]\n    }\n}\n"}
{"task_id": "Java/130", "generation": "import java.util.*;\n\nclass Solution {\n    public List<Integer> tri(int n) {\n        List<Integer> result = new ArrayList<>();\n        \n        // Base cases\n        if (n >= 1) result.add(3); // tri(1)\n        if (n >= 2) result.add(2); // tri(2), as per the corrected formula\n        \n        for (int i = 3; i <= n; i++) {\n            int value;\n            if (i % 2 == 0) { // even\n                value = 1 + i / 2;\n            } else { // odd, using the corrected definition\n                value = result.get(i - 2) + result.get(i - 3) + result.get(i - 4);\n            }\n            result.add(value);\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.tri(3)); // Expected: [3, 2, 8]\n        System.out.println(solution.tri(4)); // Expected: [3, 2, 8, 3]\n    }\n}\n"}
{"task_id": "Java/131", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n     */\n    public int digits(int n) {\n        int product = 1;\n        boolean hasOddDigit = false;\n\n        while (n > 0) {\n            int digit = n % 10; // Get the last digit\n            if (digit % 2 != 0) { // Check if it's odd\n                product *= digit;\n                hasOddDigit = true;\n            }\n            n /= 10; // Remove the last digit\n        }\n\n        return hasOddDigit ? product : 0;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.digits(1));   // Expected output: 1\n        System.out.println(solution.digits(4));   // Expected output: 0\n        System.out.println(solution.digits(235)); // Expected output: 15\n        System.out.println(solution.digits(684)); // Expected output: 0\n        System.out.println(solution.digits(791)); // Expected output: 63\n    }\n}\n"}
{"task_id": "Java/132", "generation": "class Solution {\n    public boolean is_nested(String string) {\n        int balance = 0;\n        for (char c : string.toCharArray()) {\n            if (c == '[') {\n                balance++;\n            } else if (c == ']') {\n                balance--;\n            }\n            // If at any point the balance is greater than 1, it means there's a nested bracket\n            if (balance > 1) return true;\n        }\n        return false;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.is_nested(\"[[]]\")); // Expected: true\n        System.out.println(solution.is_nested(\"[]]]]]]][[[[[]\")); // Expected: false\n        System.out.println(solution.is_nested(\"[][]\")); // Expected: false\n        System.out.println(solution.is_nested(\"[]\")); // Expected: false\n        System.out.println(solution.is_nested(\"[[][]]\")); // Expected: true\n        System.out.println(solution.is_nested(\"[[]][[\")); // Expected: true\n    }\n}\n"}
{"task_id": "Java/133", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int sum_squares(List<Double> lst) {\n        int sum = 0;\n        for (Double num : lst) {\n            // Round each element to the upper integer and square it.\n            int ceilValue = (int)Math.ceil(num);\n            sum += ceilValue * ceilValue;\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        List<Double> test1 = Arrays.asList(1.0, 2.0, 3.0); // Expected output: 14\n        System.out.println(solution.sum_squares(test1));\n        \n        List<Double> test2 = Arrays.asList(1.0, 4.0, 9.0); // Expected output: 98\n        System.out.println(solution.sum_squares(test2));\n        \n        List<Double> test3 = Arrays.asList(1.0, 3.0, 5.0, 7.0); // Expected output: 84\n        System.out.println(solution.sum_squares(test3));\n        \n        List<Double> test4 = Arrays.asList(1.4, 4.2, 0.0); // Expected output: 29\n        System.out.println(solution.sum_squares(test4));\n        \n        List<Double> test5 = Arrays.asList(-2.4, 1.0, 1.0); // Expected output: 6\n        System.out.println(solution.sum_squares(test5));\n    }\n}\n"}
{"task_id": "Java/134", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Create a function that returns true if the last character\n     * of a given string is an alphabetical character and is not\n     * a part of a word, and false otherwise.\n     * Note: \"word\" is a group of characters separated by space.\n     *\n     * Examples:\n     * check_if_last_char_is_a_letter(\"apple pie\") -> false\n     * check_if_last_char_is_a_letter(\"apple pi e\") -> true\n     * check_if_last_char_is_a_letter(\"apple pi e \") -> false\n     * check_if_last_char_is_a_letter(\"\") -> false\n     */\n    public boolean check_if_last_char_is_a_letter(String txt) {\n        if (txt == null || txt.length() == 0) return false;\n\n        int lastCharIndex = txt.length() - 1;\n        \n        // Check if the last character is a letter and not part of a word.\n        char lastChar = txt.charAt(lastCharIndex);\n        boolean isLastCharALetter = Character.isLetter(lastChar);\n\n        // If the string has only one character, return true if it's a letter\n        if (txt.length() == 1) {\n            return isLastCharALetter;\n        }\n\n        // Check if the last character is not part of a word.\n        boolean isNotPartOfWord = txt.charAt(lastCharIndex - 1) == ' ';\n        \n        return isLastCharALetter && isNotPartOfWord;\n    }\n    \n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.check_if_last_char_is_a_letter(\"apple pie\")); // Expected: false\n        System.out.println(solution.check_if_last_char_is_a_letter(\"apple pi e\")); // Expected: true\n        System.out.println(solution.check_if_last_char_is_a_letter(\"apple pi e \")); // Expected: false\n        System.out.println(solution.check_if_last_char_is_a_letter(\"\")); // Expected: false\n    }\n}\n"}
{"task_id": "Java/135", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Create a function which returns the largest index of an element which\n     * is not greater than or equal to the element immediately preceding it.\n     * If no such element exists then return -1. The given array will not contain\n     * duplicate values.\n     *\n     * Examples:\n     * can_arrange(Arrays.asList(1,2,4,3,5)) = 3\n     * can_arrange(Arrays.asList(1,2,3)) = -1\n     */\n    public int can_arrange(List<Integer> arr) {\n        for (int i = arr.size() - 1; i > 0; i--) {\n            if (arr.get(i) < arr.get(i - 1)) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        List<Integer> test1 = Arrays.asList(1, 2, 4, 3, 5);\n        System.out.println(\"Test Case 1: \" + (solution.can_arrange(test1) == 3 ? \"Pass\" : \"Fail\"));\n\n        // Test case 2\n        List<Integer> test2 = Arrays.asList(1, 2, 3);\n        System.out.println(\"Test Case 2: \" + (solution.can_arrange(test2) == -1 ? \"Pass\" : \"Fail\"));\n\n        // Additional test cases\n        List<Integer> test3 = Arrays.asList(5, 4, 3, 2, 1);\n        System.out.println(\"Test Case 3: \" + (solution.can_arrange(test3) == 4 ? \"Pass\" : \"Fail\"));\n\n        List<Integer> test4 = Arrays.asList(10, 20, 30, 25, 40);\n        System.out.println(\"Test Case 4: \" + (solution.can_arrange(test4) == 3 ? \"Pass\" : \"Fail\"));\n    }\n}\n"}
{"task_id": "Java/136", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n\n    public List<Optional<Integer>> largest_smallest_integers(List<Integer> lst) {\n        Optional<Integer> maxNegative = lst.stream()\n                .filter(n -> n < 0)\n                .max(Integer::compare);\n        \n        Optional<Integer> minPositive = lst.stream()\n                .filter(n -> n > 0)\n                .min(Integer::compare);\n\n        return Arrays.asList(maxNegative, minPositive);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1: List with positive and negative integers\n        System.out.println(solution.largest_smallest_integers(Arrays.asList(2, -4, 1, -3, 5, 7)));\n        \n        // Test case 2: Empty list\n        System.out.println(solution.largest_smallest_integers(new ArrayList<>()));\n        \n        // Test case 3: List with only zero\n        System.out.println(solution.largest_smallest_integers(Arrays.asList(0)));\n        \n        // Additional test cases\n        System.out.println(solution.largest_smallest_integers(Arrays.asList(-1, -2, -3, -4))); // Only negative numbers\n        System.out.println(solution.largest_smallest_integers(Arrays.asList(1, 2, 3, 4)));      // Only positive numbers\n    }\n}\n"}
{"task_id": "Java/137", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Create a function that takes integers, floats, or strings representing\n     * real numbers, and returns the larger variable in its given variable type.\n     * Return None if the values are equal.\n     * Note: If a real number is represented as a string, the floating point might be . or ,\n     */\n    public Optional<Object> compare_one(Object a, Object b) {\n        double aValue = toDouble(a);\n        double bValue = toDouble(b);\n\n        if (aValue == bValue) {\n            return Optional.empty();\n        }\n\n        if (aValue > bValue) {\n            return Optional.of(a);\n        } else {\n            return Optional.of(b);\n        }\n    }\n\n    private double toDouble(Object value) {\n        if (value instanceof Integer) {\n            return ((Integer) value).doubleValue();\n        } else if (value instanceof Double) {\n            return (double) value;\n        } else if (value instanceof String) {\n            String strValue = (String) value;\n            strValue = strValue.replace(',', '.');\n            return Double.parseDouble(strValue);\n        }\n        throw new IllegalArgumentException(\"Unsupported type\");\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.compare_one(1, 2.5)); // Optional.of(2.5)\n        System.out.println(solution.compare_one(1, \"2,3\")); // Optional.of(\"2,3\")\n        System.out.println(solution.compare_one(\"5,1\", \"6\")); // Optional.of(\"6\")\n        System.out.println(solution.compare_one(\"1\", 1)); // Optional.empty()\n    }\n}\n"}
{"task_id": "Java/138", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers.\n     *\n     * @param n The number to evaluate.\n     * @return true if n can be expressed as such a sum, false otherwise.\n     */\n    public boolean is_equalToSumEven(int n) {\n        // Since the smallest possible sum of four positive even numbers is 8,\n        // any number less than 8 cannot be represented this way.\n        // Also, since we are dealing with only even numbers, n must itself be even to be representable as such a sum.\n        return n >= 8 && n % 2 == 0;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.is_equalToSumEven(4)); // Expected: false\n        System.out.println(solution.is_equalToSumEven(6)); // Expected: false\n        System.out.println(solution.is_equalToSumEven(8)); // Expected: true\n        System.out.println(solution.is_equalToSumEven(10)); // Expected: true\n        System.out.println(solution.is_equalToSumEven(24)); // Expected: true\n    }\n}\n"}
{"task_id": "Java/139", "generation": "class Solution {\n    /**\n     * Calculates the special (Brazilian) factorial of n.\n     *\n     * @param n The input integer for which to calculate the special factorial.\n     * @return The result of the calculation as a long.\n     */\n    public long special_factorial(int n) {\n        if (n <= 0) return 0; // Special case, though problem states n > 0\n        long result = 1;\n        for (int i = 1; i <= n; ++i) {\n            long factorial = 1;\n            for (int j = 1; j <= i; ++j) {\n                factorial *= j;\n            }\n            result *= factorial;\n        }\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(\"special_factorial(4): \" + solution.special_factorial(4)); // Expected: 288\n        System.out.println(\"special_factorial(3): \" + solution.special_factorial(3)); // Expected: 12\n        System.out.println(\"special_factorial(5): \" + solution.special_factorial(5)); // Expected: 34560\n    }\n}\n"}
{"task_id": "Java/140", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public String fix_spaces(String text) {\n        // Replace more than 2 consecutive spaces with \"-\"\n        while (text.contains(\"   \")) {\n            text = text.replace(\"   \", \"-\");\n        }\n        \n        // Replace remaining single and double spaces with \"_\"\n        return text.replaceAll(\" +\", \"_\");\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.fix_spaces(\"Example\").equals(\"Example\")); // true\n        System.out.println(solution.fix_spaces(\"Example 1\").equals(\"Example_1\")); // true\n        System.out.println(solution.fix_spaces(\" Example 2\").equals(\"_Example_2\")); // true\n        System.out.println(solution.fix_spaces(\" Example   3\").equals(\"_Example-3\")); // true\n        \n        // Additional test cases for thoroughness\n        System.out.println(solution.fix_spaces(\"  Leading spaces\").equals(\"__Leading_spaces\")); // true\n        System.out.println(solution.fix_spaces(\"Trailing spaces \").equals(\"Trailing_spaces_\")); // true\n        System.out.println(solution.fix_spaces(\"Multiple   spaces\").equals(\"Multiple-spaces\")); // true\n    }\n}\n"}
{"task_id": "Java/141", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public String file_name_check(String file_name) {\n        // Check if there are more than three digits in the filename\n        int digitCount = 0;\n        for (char c : file_name.toCharArray()) {\n            if (Character.isDigit(c)) {\n                digitCount++;\n            }\n        }\n        if (digitCount > 3) return \"No\";\n\n        // Split the filename by dot and check conditions\n        String[] parts = file_name.split(\"\\\\.\");\n        if (parts.length != 2) return \"No\"; // There should be exactly one dot\n\n        String prefix = parts[0];\n        String suffix = parts[1];\n\n        // Check if the prefix is not empty, starts with a letter and contains no more than three digits\n        if (prefix.isEmpty() || !Character.isLetter(prefix.charAt(0))) return \"No\";\n\n        // Check if the suffix is one of [\"txt\", \"exe\", \"dll\"]\n        List<String> validSuffixes = Arrays.asList(\"txt\", \"exe\", \"dll\");\n        if (!validSuffixes.contains(suffix)) return \"No\";\n\n        return \"Yes\";\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.file_name_check(\"example.txt\"));  // Expected: Yes\n        System.out.println(solution.file_name_check(\"1example.dll\")); // Expected: No\n        System.out.println(solution.file_name_check(\"test.exe\"));     // Expected: Yes\n        System.out.println(solution.file_name_check(\".txt\"));         // Expected: No (prefix is empty)\n        System.out.println(solution.file_name_check(\"a2b3c4d5.txt\"));// Expected: No (more than three digits)\n    }\n}\n"}
{"task_id": "Java/142", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * This function will take a list of integers. For all entries in the list, the function shall square the integer entry if its index is a\n     * multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3.\n     * The function will not change the entries in the list whose indexes are not a multiple of 3 or 4. \n     * The function shall then return the sum of all entries.\n     *\n     * @param lst List of integers\n     * @return Sum of transformed list elements\n     */\n    public int sum_squares(List<Integer> lst) {\n        if (lst == null || lst.isEmpty()) {\n            return 0;\n        }\n\n        int sum = 0;\n\n        for (int i = 0; i < lst.size(); i++) {\n            if (i % 3 == 0 && i % 4 != 0) {\n                // Square the element\n                sum += Math.pow(lst.get(i), 2);\n            } else if (i % 4 == 0) {\n                // Cube the element\n                sum += Math.pow(lst.get(i), 3);\n            } else {\n                // Add the element as is\n                sum += lst.get(i);\n            }\n        }\n\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        List<Integer> test1 = Arrays.asList(1, 2, 3);\n        System.out.println(\"Test case 1: \" + (solution.sum_squares(test1) == 6));\n\n        List<Integer> test2 = new ArrayList<>();\n        System.out.println(\"Test case 2: \" + (solution.sum_squares(test2) == 0));\n\n        List<Integer> test3 = Arrays.asList(-1, -5, 2, -1, -5);\n        System.out.println(\"Test case 3: \" + (solution.sum_squares(test3) == -126));\n    }\n}\n"}
{"task_id": "Java/143", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Checks if a number is prime.\n     */\n    private boolean isPrime(int n) {\n        if (n <= 1) return false;\n        if (n == 2 || n == 3) return true;\n        if (n % 2 == 0 || n % 3 == 0) return false;\n        for (int i = 5; i * i <= n; i += 6) {\n            if (n % i == 0 || n % (i + 2) == 0)\n                return false;\n        }\n        return true;\n    }\n\n    /**\n     * Returns a string containing only those words whose lengths are prime numbers.\n     */\n    public String words_in_sentence(String sentence) {\n        StringBuilder result = new StringBuilder();\n        for (String word : sentence.split(\" \")) {\n            if (isPrime(word.length())) {\n                if (result.length() > 0) result.append(\" \");\n                result.append(word);\n            }\n        }\n        return result.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        String sentence1 = \"This is a test\";\n        System.out.println(solution.words_in_sentence(sentence1)); // Expected: \"is\"\n\n        // Test case 2\n        String sentence2 = \"lets go for swimming\";\n        System.out.println(solution.words_in_sentence(sentence2)); // Expected: \"go for\"\n    }\n}\n"}
{"task_id": "Java/144", "generation": "class Solution {\n    public boolean simplify(String x, String n) {\n        // Parse the fractions from strings\n        String[] partsX = x.split(\"/\");\n        String[] partsN = n.split(\"/\");\n        \n        long numerator1 = Long.parseLong(partsX[0]);\n        long denominator1 = Long.parseLong(partsX[1]);\n        long numerator2 = Long.parseLong(partsN[0]);\n        long denominator2 = Long.parseLong(partsN[1]);\n\n        // Multiply the fractions\n        long resultNumerator = numerator1 * numerator2;\n        long resultDenominator = denominator1 * denominator2;\n\n        // Check if the result is a whole number\n        return resultNumerator % resultDenominator == 0;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.simplify(\"1/5\", \"5/1\")); // Expected: true\n        System.out.println(solution.simplify(\"1/6\", \"2/1\")); // Expected: false\n        System.out.println(solution.simplify(\"7/10\", \"10/2\")); // Expected: false\n        \n        // Additional test cases\n        System.out.println(solution.simplify(\"3/4\", \"8/3\")); // Expected: true\n        System.out.println(solution.simplify(\"5/9\", \"9/5\")); // Expected: true\n    }\n}\n"}
{"task_id": "Java/145", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Sorts the given list of integers in ascending order according to the sum of their digits.\n     * If there are several items with a similar sum of their digits, they are ordered based on their index in the original list.\n     *\n     * @param nums List of integers to be sorted\n     * @return Sorted list of integers\n     */\n    public List<Integer> order_by_points(List<Integer> nums) {\n        // Create an indexed list for maintaining original indices\n        List<Pair<Integer, Integer>> indexedNums = new ArrayList<>();\n        for (int i = 0; i < nums.size(); i++) {\n            indexedNums.add(new Pair<>(i, nums.get(i)));\n        }\n\n        // Sort the indexed list based on our criteria\n        Collections.sort(indexedNums, Comparator.comparingInt((Pair<Integer, Integer> p) -> sumOfDigits(p.getValue()))\n                .thenComparing(Pair::getKey));\n\n        // Extract and return sorted values from pairs\n        List<Integer> result = new ArrayList<>();\n        for (Pair<Integer, Integer> pair : indexedNums) {\n            result.add(pair.getValue());\n        }\n        \n        return result;\n    }\n\n    private int sumOfDigits(int number) {\n        int sum = 0;\n        boolean isNegative = number < 0;\n        while (number != 0) {\n            sum += number % 10;\n            number /= 10;\n        }\n        // If the number was negative, we need to adjust the first digit\n        if (isNegative && sum > 0) {\n            sum -= 2 * (sum % 10); // Adjusting for the sign of the first digit\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        List<Integer> testList1 = Arrays.asList(1, 11, -1, -11, -12);\n        System.out.println(solution.order_by_points(testList1)); // Expected: [-1, -11, 1, -12, 11]\n\n        List<Integer> testList2 = new ArrayList<>();\n        System.out.println(solution.order_by_points(testList2)); // Expected: []\n\n        List<Integer> testList3 = Arrays.asList(-90, 56, 78, -45);\n        System.out.println(solution.order_by_points(testList3)); // Expected: [-90, 56, 78, -45]\n    }\n\n    static class Pair<K, V> {\n        private K key;\n        private V value;\n\n        public Pair(K key, V value) {\n            this.key = key;\n            this.value = value;\n        }\n\n        public K getKey() {\n            return key;\n        }\n\n        public V getValue() {\n            return value;\n        }\n    }\n}\n"}
{"task_id": "Java/146", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Returns the number of elements in the array that are greater than 10 \n     * and both first and last digits of a number are odd (1, 3, 5, 7, 9).\n     */\n    public int specialFilter(List<Integer> nums) {\n        return (int) nums.stream()\n                .filter(num -> num > 10 && isFirstAndLastDigitOdd(num))\n                .count();\n    }\n\n    private boolean isFirstAndLastDigitOdd(int num) {\n        String strNum = Math.abs(num) + \"\";\n        int firstDigit = Character.getNumericValue(strNum.charAt(0));\n        int lastDigit = Character.getNumericValue(strNum.charAt(strNum.length() - 1));\n        \n        return (firstDigit % 2 != 0 && lastDigit % 2 != 0);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case 1\n        List<Integer> list1 = Arrays.asList(15, -73, 14, -15);\n        System.out.println(solution.specialFilter(list1)); // Expected output: 1\n        \n        // Test case 2\n        List<Integer> list2 = Arrays.asList(33, -2, -3, 45, 21, 109);\n        System.out.println(solution.specialFilter(list2)); // Expected output: 2\n        \n        // Additional test cases\n        List<Integer> list3 = Arrays.asList(-11, 17, 35, 89, 101);\n        System.out.println(solution.specialFilter(list3)); // Expected output: 3\n\n        List<Integer> list4 = Arrays.asList(2, 4, 6, 8);\n        System.out.println(solution.specialFilter(list4)); // Expected output: 0\n    }\n}\n"}
{"task_id": "Java/147", "generation": "class Solution {\n    public int get_max_triples(int n) {\n        // Create an array to hold the values as per the given formula.\n        int[] a = new int[n];\n        for (int i = 1; i <= n; ++i) {\n            a[i - 1] = i * i - i + 1;\n        }\n\n        int count = 0;\n\n        // Iterate through all possible triples\n        for (int i = 0; i < n; ++i) {\n            for (int j = i + 1; j < n; ++j) {\n                for (int k = j + 1; k < n; ++k) {\n                    if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                        count++;\n                    }\n                }\n            }\n        }\n\n        return count;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.get_max_triples(5)); // Expected output: 1\n        System.out.println(solution.get_max_triples(6)); // Expected output: 4\n        System.out.println(solution.get_max_triples(7)); // Expected output: 10\n    }\n}\n"}
{"task_id": "Java/148", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Returns all planets whose orbits are located between the orbit of planet1 and the orbit of planet2,\n     * sorted by proximity to the sun.\n     */\n    public List<String> bf(String planet1, String planet2) {\n        // Define an array with the order of the planets\n        String[] planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n        \n        int index1 = -1;\n        int index2 = -1;\n\n        // Find indices of planet1 and planet2\n        for (int i = 0; i < planets.length; i++) {\n            if (planets[i].equals(planet1)) {\n                index1 = i;\n            }\n            if (planets[i].equals(planet2)) {\n                index2 = i;\n            }\n        }\n\n        // If either planet is not found, return an empty list\n        if (index1 == -1 || index2 == -1) {\n            return new ArrayList<>();\n        }\n\n        // Ensure index1 < index2 for simplicity\n        int start = Math.min(index1, index2);\n        int end = Math.max(index1, index2);\n\n        List<String> result = new ArrayList<>();\n\n        // Add planets between the two indices to the list\n        for (int i = start + 1; i < end; i++) {\n            result.add(planets[i]);\n        }\n\n        return result;\n    }\n    \n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.bf(\"Jupiter\", \"Neptune\")); // [\"Saturn\", \"Uranus\"]\n        System.out.println(solution.bf(\"Earth\", \"Mercury\"));   // [\"Venus\"]\n        System.out.println(solution.bf(\"Mercury\", \"Uranus\"));  // [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"]\n    }\n}\n"}
{"task_id": "Java/149", "generation": "import java.util.*;\n\nclass Solution {\n    public List<String> sorted_list_sum(List<String> lst) {\n        // Filter out strings with odd lengths and sort them by length then lexicographically.\n        return lst.stream()\n                .filter(s -> s.length() % 2 == 0)\n                .sorted(Comparator.comparingInt(String::length).thenComparing(Comparator.naturalOrder()))\n                .collect(Collectors.toList());\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case 1\n        List<String> list1 = Arrays.asList(\"aa\", \"a\", \"aaa\");\n        System.out.println(solution.sorted_list_sum(list1)); // Expected: [aa]\n        \n        // Test case 2\n        List<String> list2 = Arrays.asList(\"ab\", \"a\", \"aaa\", \"cd\");\n        System.out.println(solution.sorted_list_sum(list2)); // Expected: [ab, cd]\n\n        // Additional test cases for completeness\n        // Test case 3 - Empty list\n        List<String> list3 = new ArrayList<>();\n        System.out.println(solution.sorted_list_sum(list3)); // Expected: []\n\n        // Test case 4 - All strings have odd lengths\n        List<String> list4 = Arrays.asList(\"a\", \"abc\");\n        System.out.println(solution.sorted_list_sum(list4)); // Expected: []\n        \n        // Test case 5 - Strings with the same length but different lexicographical order\n        List<String> list5 = Arrays.asList(\"zoo\", \"car\", \"bat\", \"dog\");\n        System.out.println(solution.sorted_list_sum(list5)); // Expected: [bat, car, dog, zoo]\n    }\n}\n"}
{"task_id": "Java/150", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * A simple program which should return the value of x if n is\n     * a prime number and should return the value of y otherwise.\n     *\n     * Examples:\n     * for x_or_y(7, 34, 12) == 34\n     * for x_or_y(15, 8, 5) == 5\n     */\n    public int x_or_y(int n, int x, int y) {\n        if (isPrime(n)) {\n            return x;\n        } else {\n            return y;\n        }\n    }\n\n    private boolean isPrime(int number) {\n        if (number <= 1) {\n            return false;\n        }\n        for (int i = 2; i * i <= number; i++) {\n            if (number % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.x_or_y(7, 34, 12)); // Should print: 34\n        System.out.println(solution.x_or_y(15, 8, 5));  // Should print: 5\n        System.out.println(solution.x_or_y(11, 60, 9)); // Should print: 60\n        System.out.println(solution.x_or_y(27, 45, 3)); // Should print: 3\n    }\n}\n"}
{"task_id": "Java/151", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a list of numbers, return the sum of squares of the numbers\n     * in the list that are odd. Ignore numbers that are negative or not integers.\n     *\n     * @param lst List containing objects (expected to be numeric)\n     * @return Sum of squares of odd positive integers from the list\n     */\n    public int sumOfSquaresForOddNumbers(List<Object> lst) {\n        return lst.stream()\n                .filter(o -> o instanceof Integer && ((Integer) o > 0))\n                .mapToInt(o -> (int) o)\n                .filter(n -> n % 2 != 0)\n                .map(n -> n * n)\n                .sum();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.sumOfSquaresForOddNumbers(Arrays.asList(1, 3, 2, 0))); // Expected output: 10 (1^2 + 3^2)\n        System.out.println(solution.sumOfSquaresForOddNumbers(Arrays.asList(-1, -2, 0)));   // Expected output: 0\n        System.out.println(solution.sumOfSquaresForOddNumbers(Arrays.asList(9, -2)));       // Expected output: 81 (9^2)\n        System.out.println(solution.sumOfSquaresForOddNumbers(Arrays.asList(0)));           // Expected output: 0\n        System.out.println(solution.sumOfSquaresForOddNumbers(new ArrayList<>()));          // Expected output: 0 (empty list)\n    }\n}\n"}
{"task_id": "Java/152", "generation": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\nclass Solution {\n    /**\n     * Compares the actual scores of matches with guesses and returns an array denoting \n     * how far off each guess was. If they have guessed correctly, the value is 0,\n     * otherwise it's the absolute difference between the guess and the score.\n     *\n     * @param game List<Integer> representing the actual scores of matches\n     * @param guess List<Integer> representing guesses about those scores\n     * @return List<Integer> denoting how far off each guess was from the corresponding score in the game\n     */\n    public List<Integer> compare(List<Integer> game, List<Integer> guess) {\n        // Ensure both lists are of equal length\n        if (game.size() != guess.size()) {\n            throw new IllegalArgumentException(\"The size of game and guess must be equal.\");\n        }\n\n        List<Integer> result = new ArrayList<>();\n        \n        for (int i = 0; i < game.size(); i++) {\n            int scoreDifference = Math.abs(game.get(i) - guess.get(i));\n            result.add(scoreDifference);\n        }\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case 1\n        List<Integer> gameScores1 = Arrays.asList(1,2,3,4,5,1);\n        List<Integer> guesses1 = Arrays.asList(1,2,3,4,2,-2);\n        System.out.println(solution.compare(gameScores1, guesses1)); // Expected: [0, 0, 0, 0, 3, 3]\n        \n        // Test case 2\n        List<Integer> gameScores2 = Arrays.asList(0,5,0,0,0,4);\n        List<Integer> guesses2 = Arrays.asList(4,1,1,0,0,-2);\n        System.out.println(solution.compare(gameScores2, guesses2)); // Expected: [4, 4, 1, 0, 0, 6]\n    }\n}\n"}
{"task_id": "Java/153", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Finds the strongest extension for a given class.\n     *\n     * @param className The name of the class to which extensions are added.\n     * @param extensions A list of strings representing the names of the extensions.\n     * @return A string in the format ClassName.Strongest_Extension.\n     */\n    public String Strongest_Extension(String className, List<String> extensions) {\n        int maxStrength = Integer.MIN_VALUE;\n        String strongestExtensionName = \"\";\n\n        for (String extension : extensions) {\n            int strength = calculateStrength(extension);\n            if (strength > maxStrength || (strength == maxStrength && strongestExtensionName.isEmpty())) {\n                maxStrength = strength;\n                strongestExtensionName = extension;\n            }\n        }\n\n        return className + \".\" + strongestExtensionName;\n    }\n\n    private int calculateStrength(String extension) {\n        int upperCount = 0, lowerCount = 0;\n\n        for (char c : extension.toCharArray()) {\n            if (Character.isUpperCase(c)) upperCount++;\n            else if (Character.isLowerCase(c)) lowerCount++;\n        }\n\n        return upperCount - lowerCount;\n    }\n}\n\n// Test code\npublic class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Example 1\n        String result1 = solution.Strongest_Extension(\"Slices\", Arrays.asList(\"SErviNGSliCes\", \"Cheese\", \"StuFfed\"));\n        System.out.println(result1); // Expected: Slices.SErviNGSliCes\n        \n        // Example 2\n        String result2 = solution.Strongest_Extension(\"my_class\", Arrays.asList(\"AA\", \"Be\", \"CC\"));\n        System.out.println(result2); // Expected: my_class.AA\n        \n        // Additional test case\n        String result3 = solution.Strongest_Extension(\"DataStructures\", Arrays.asList(\"Array\", \"LinkedList\", \"TreeSet\"));\n        System.out.println(result3); // Expected output based on the strength calculation\n    }\n}\n"}
{"task_id": "Java/154", "generation": "class Solution {\n    public boolean cycpattern_check(String a, String b) {\n        // Concatenate string 'a' with itself.\n        // This trick allows us to find any rotation of 'b' in 'a'.\n        String doubledA = a + a;\n        \n        // Check if 'b' is a substring of the concatenated string\n        return doubledA.contains(b);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.cycpattern_check(\"abcd\", \"abd\"));  // false\n        System.out.println(solution.cycpattern_check(\"hello\", \"ell\")); // true\n        System.out.println(solution.cycpattern_check(\"whassup\", \"psus\")); // false\n        System.out.println(solution.cycpattern_check(\"abab\", \"baa\"));   // true\n        System.out.println(solution.cycpattern_check(\"efef\", \"eeff\"));  // false\n        System.out.println(solution.cycpattern_check(\"himenss\", \"simen\")); // true\n    }\n}\n"}
{"task_id": "Java/155", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given an integer, return a tuple that has the number of even and odd digits respectively.\n     *\n     * Example:\n     *      even_odd_count(-12) ==> [1, 1]\n     *      even_odd_count(123) ==> [1, 2]\n     */\n    public List<Integer> even_odd_count(int num) {\n        // Convert the number to a string and remove any negative sign\n        String strNum = Integer.toString(Math.abs(num));\n        \n        int evenCount = 0;\n        int oddCount = 0;\n\n        // Iterate through each character in the string representation of the number\n        for (char c : strNum.toCharArray()) {\n            if ((c - '0') % 2 == 0) { // Check if the digit is even\n                evenCount++;\n            } else { // The digit must be odd\n                oddCount++;\n            }\n        }\n\n        // Return a list containing counts of even and odd digits\n        return Arrays.asList(evenCount, oddCount);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.even_odd_count(-12));  // Expected: [1, 1]\n        System.out.println(solution.even_odd_count(123));  // Expected: [1, 2]\n        System.out.println(solution.even_odd_count(0));    // Expected: [1, 0]\n        System.out.println(solution.even_odd_count(-987654321)); // Expected: [4, 5]\n    }\n}\n"}
{"task_id": "Java/156", "generation": "import java.util.*;\n\nclass Solution {\n    public String int_to_mini_roman(int number) {\n        // Define Roman numeral mappings\n        int[] values = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n        String[] romans = {\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n\n        StringBuilder romanNumeral = new StringBuilder();\n        \n        // Convert the number to Roman numeral\n        for (int i = 0; i < values.length && number > 0; i++) {\n            while (number >= values[i]) {\n                number -= values[i];\n                romanNumeral.append(romans[i]);\n            }\n        }\n\n        return romanNumeral.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.int_to_mini_roman(19).equals(\"xix\") ? \"Test 1 Passed\" : \"Test 1 Failed\");\n        System.out.println(solution.int_to_mini_roman(152).equals(\"clii\") ? \"Test 2 Passed\" : \"Test 2 Failed\");\n        System.out.println(solution.int_to_mini_roman(426).equals(\"cdxxvi\") ? \"Test 3 Passed\" : \"Test 3 Failed\");\n\n        // Additional test cases\n        System.out.println(solution.int_to_mini_roman(1000).equals(\"m\") ? \"Test 4 Passed\" : \"Test 4 Failed\");\n        System.out.println(solution.int_to_mini_roman(947).equals(\"cmxlvii\") ? \"Test 5 Passed\" : \"Test 5 Failed\");\n    }\n}\n"}
{"task_id": "Java/157", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given the lengths of the three sides of a triangle, return true if the three\n     * sides form a right-angled triangle, false otherwise.\n     * A right-angled triangle is a triangle in which one angle is a right angle or\n     * 90 degrees.\n     */\n    public boolean right_angle_triangle(int a, int b, int c) {\n        // Sort the sides to ensure that c is the longest side (hypotenuse)\n        int[] sides = {a, b, c};\n        Arrays.sort(sides);\n        \n        // Check if the square of the hypotenuse equals the sum of squares of the other two sides\n        return Math.pow(sides[0], 2) + Math.pow(sides[1], 2) == Math.pow(sides[2], 2);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.right_angle_triangle(3, 4, 5)); // Expected: true\n        System.out.println(solution.right_angle_triangle(1, 2, 3)); // Expected: false\n        System.out.println(solution.right_angle_triangle(5, 12, 13)); // Expected: true\n        System.out.println(solution.right_angle_triangle(8, 15, 17)); // Expected: true\n        System.out.println(solution.right_angle_triangle(6, 8, 10)); // Expected: true\n    }\n}\n"}
{"task_id": "Java/158", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Finds the word with the maximum number of unique characters.\n     * If multiple strings have the same number of unique characters,\n     * returns the one that comes first lexicographically.\n     *\n     * @param words List of strings to be evaluated.\n     * @return The string with the most unique characters or the lexicographically smallest if there's a tie.\n     */\n    public String find_max(List<String> words) {\n        String maxUniqueWord = \"\";\n        int maxUniqueCount = 0;\n\n        for (String word : words) {\n            Set<Character> uniqueChars = new HashSet<>();\n            for (char c : word.toCharArray()) {\n                uniqueChars.add(c);\n            }\n            \n            if (uniqueChars.size() > maxUniqueCount || \n                (uniqueChars.size() == maxUniqueCount && word.compareTo(maxUniqueWord) < 0)) {\n                maxUniqueCount = uniqueChars.size();\n                maxUniqueWord = word;\n            }\n        }\n\n        return maxUniqueWord;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.find_max(Arrays.asList(\"name\", \"of\", \"string\"))); // Expected: \"string\"\n        System.out.println(solution.find_max(Arrays.asList(\"name\", \"enam\", \"game\"))); // Expected: \"enam\"\n        System.out.println(solution.find_max(Arrays.asList(\"aaaaaaa\", \"bb\" ,\"cc\")));  // Expected: \"aaaaaaa\"\n    }\n}\n"}
{"task_id": "Java/159", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * You're a hungry rabbit, and you already have eaten a certain number of carrots,\n     * but now you need to eat more carrots to complete the day's meals.\n     * You should return an array of [ total number of eaten carrots after your meals,\n     *                                 the number of carrots left after your meals ]\n     * if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n     *\n     * @param number  the number of carrots that you have already eaten.\n     * @param need    the number of carrots that you need to eat.\n     * @param remaining the number of remaining carrots in stock\n     * @return a list containing two integers: total number of eaten carrots and the number left after eating.\n     */\n    public List<Integer> eat(int number, int need, int remaining) {\n        // Calculate how many more carrots can be eaten based on what's available\n        int toEat = Math.min(need, remaining);\n        \n        // Update the total number of eaten carrots\n        int totalEaten = number + toEat;\n        \n        // Update the number of remaining carrots after eating\n        int leftOver = remaining - toEat;\n\n        return Arrays.asList(totalEaten, leftOver);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.eat(5, 6, 10)); // Expected: [11, 4]\n        System.out.println(solution.eat(4, 8, 9));  // Expected: [12, 1]\n        System.out.println(solution.eat(1, 10, 10));// Expected: [11, 0]\n        System.out.println(solution.eat(2, 11, 5)); // Expected: [7, 0]\n    }\n}\n"}
{"task_id": "Java/160", "generation": "import java.util.*;\n\nclass Solution {\n    public int do_algebra(List<String> operator, List<Integer> operand) {\n        // Initialize the result with the first operand.\n        int result = operand.get(0);\n\n        for (int i = 0; i < operator.size(); i++) {\n            String op = operator.get(i);\n            int nextOperand = operand.get(i + 1);\n\n            switch (op) {\n                case \"+\":\n                    result += nextOperand;\n                    break;\n                case \"-\":\n                    result -= nextOperand;\n                    break;\n                case \"*\":\n                    result *= nextOperand;\n                    break;\n                case \"/\":\n                    // Floor division\n                    result /= nextOperand;\n                    break;\n                case \"**\":\n                    result = (int) Math.pow(result, nextOperand);\n                    break;\n                default:\n                    throw new IllegalArgumentException(\"Unsupported operator: \" + op);\n            }\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test Case 1\n        List<String> operators1 = Arrays.asList(\"+\", \"*\", \"-\");\n        List<Integer> operands1 = Arrays.asList(2, 3, 4, 5);\n        System.out.println(solution.do_algebra(operators1, operands1)); // Expected output: 9\n\n        // Test Case 2\n        List<String> operators2 = Arrays.asList(\"**\", \"-\", \"/\");\n        List<Integer> operands2 = Arrays.asList(2, 3, 4, 2);\n        System.out.println(solution.do_algebra(operators2, operands2)); // Expected output: 5\n    }\n}\n"}
{"task_id": "Java/161", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public String solve(String s) {\n        // Check if there are any letters in the string\n        boolean hasLetters = false;\n        for (char c : s.toCharArray()) {\n            if (Character.isLetter(c)) {\n                hasLetters = true;\n                break;\n            }\n        }\n\n        // If no letters, reverse the entire string\n        if (!hasLetters) {\n            return new StringBuilder(s).reverse().toString();\n        }\n\n        // Otherwise, process each character to swap its case\n        StringBuilder result = new StringBuilder();\n        for (char c : s.toCharArray()) {\n            if (Character.isLetter(c)) {\n                if (Character.isLowerCase(c)) {\n                    result.append(Character.toUpperCase(c));\n                } else {\n                    result.append(Character.toLowerCase(c));\n                }\n            } else {\n                result.append(c);\n            }\n        }\n\n        return result.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.solve(\"1234\"));  // Expected: \"4321\"\n        System.out.println(solution.solve(\"ab\"));    // Expected: \"AB\"\n        System.out.println(solution.solve(\"#a@C\"));  // Expected: \"#A@c\"\n        System.out.println(solution.solve(\"Hello!\")); // Expected: \"hELLO!\"\n        System.out.println(solution.solve(\"1234567890\")); // Expected: \"0987654321\"\n    }\n}\n"}
{"task_id": "Java/162", "generation": "import java.math.BigInteger;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.Optional;\n\nclass Solution {\n    /**\n     * Given a string \"text\", return its md5 hash equivalent string with length being 32.\n     * If \"text\" is an empty string, return Optional.empty().\n     *\n     * @param text the input string to be hashed\n     * @return Optional<String> containing the MD5 hash or Optional.empty() if text is empty\n     */\n    public Optional<String> string_to_md5(String text) throws NoSuchAlgorithmException {\n        if (text.isEmpty()) {\n            return Optional.empty();\n        }\n        \n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        byte[] messageDigest = md.digest(text.getBytes());\n        BigInteger no = new BigInteger(1, messageDigest);\n        String hashtext = no.toString(16);\n        while (hashtext.length() < 32) {\n            hashtext = \"0\" + hashtext;\n        }\n        \n        return Optional.of(hashtext);\n    }\n\n    public static void main(String[] args) throws NoSuchAlgorithmException {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.string_to_md5(\"Hello world\").orElse(null));  // Expected: \"3e25960a79dbc69b674cd4ec67a72c62\"\n        System.out.println(solution.string_to_md5(\"\").orElse(null));             // Expected: null (Optional.empty())\n    }\n}\n"}
{"task_id": "Java/163", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given two positive integers a and b, return the even digits between a\n     * and b, in ascending order. Please note that the even digits refer to even numbers less than 10.\n     *\n     * @param a The starting integer (inclusive).\n     * @param b The ending integer (inclusive).\n     * @return A list of even single-digit integers between a and b.\n     */\n    public List<Integer> generate_integers(int a, int b) {\n        // Ensure that the range is in ascending order\n        if (a > b) {\n            int temp = a;\n            a = b;\n            b = temp;\n        }\n\n        List<Integer> result = new ArrayList<>();\n        for (int digit : new int[]{2, 4, 6, 8}) {\n            if (digit >= a && digit <= b) {\n                result.add(digit);\n            }\n        }\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.generate_integers(2, 8)); // Expected: [2, 4, 6, 8]\n        System.out.println(solution.generate_integers(8, 2)); // Expected: [2, 4, 6, 8]\n        System.out.println(solution.generate_integers(10, 14)); // Expected: []\n    }\n}\n"}
{"task_id": "Java/0", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Check if in given list of numbers, are any two numbers closer to each other than given threshold.\n     *\n     * @param numbers List<Double> - The list of numbers to check.\n     * @param threshold double - The threshold distance between numbers.\n     * @return boolean - True if there exists at least one pair of numbers closer than the threshold, false otherwise.\n     */\n    public boolean has_close_elements(List<Double> numbers, double threshold) {\n        // Sort the list first\n        Collections.sort(numbers);\n\n        for (int i = 0; i < numbers.size() - 1; i++) {\n            if (numbers.get(i + 1) - numbers.get(i) < threshold) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        List<Double> list1 = Arrays.asList(1.0, 2.0, 3.0);\n        double threshold1 = 0.5;\n        System.out.println(solution.has_close_elements(list1, threshold1)); // Expected: false\n\n        // Test case 2\n        List<Double> list2 = Arrays.asList(1.0, 2.8, 3.0, 4.0, 5.0, 2.0);\n        double threshold2 = 0.3;\n        System.out.println(solution.has_close_elements(list2, threshold2)); // Expected: true\n\n        // Additional test case\n        List<Double> list3 = Arrays.asList(1.0, 1.49, 2.5, 3.6);\n        double threshold3 = 0.5;\n        System.out.println(solution.has_close_elements(list3, threshold3)); // Expected: true\n\n        // Additional test case\n        List<Double> list4 = Arrays.asList(1.0, 1.51, 2.5, 3.6);\n        double threshold4 = 0.5;\n        System.out.println(solution.has_close_elements(list4, threshold4)); // Expected: false\n    }\n}\n"}
{"task_id": "Java/1", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Splits a string containing multiple groups of nested parentheses into separate strings.\n     *\n     * @param paren_string The input string with groups of nested parentheses.\n     * @return A list of separated, balanced groups of parentheses.\n     */\n    public List<String> separate_paren_groups(String paren_string) {\n        // Remove spaces from the input string\n        String noSpaceString = paren_string.replaceAll(\"\\\\s+\", \"\");\n        \n        ArrayList<String> result = new ArrayList<>();\n        int balance = 0;\n        StringBuilder currentGroup = new StringBuilder();\n        \n        for (char c : noSpaceString.toCharArray()) {\n            if (c == '(') {\n                balance++;\n            } else if (c == ')') {\n                balance--;\n            }\n            \n            currentGroup.append(c);\n            \n            // When the balance is zero, we have a complete group\n            if (balance == 0 && !currentGroup.toString().isEmpty()) {\n                result.add(currentGroup.toString());\n                currentGroup = new StringBuilder(); // Reset for next group\n            }\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        List<String> groups = solution.separate_paren_groups(\"( ) (( )) (( )( ))\");\n        System.out.println(groups);  // Expected: [\"()\", \"(())\", \"(()())\"]\n        \n        // Additional test cases\n        List<String> emptyGroups = solution.separate_paren_groups(\"\");\n        System.out.println(emptyGroups);  // Expected: []\n        \n        List<String> singleGroup = solution.separate_paren_groups(\"((()))\");\n        System.out.println(singleGroup);  // Expected: [\"((()))\"]\n    }\n}\n"}
{"task_id": "Java/2", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a positive floating point number, it can be decomposed into\n     * an integer part (largest integer smaller than given number) and decimals\n     * (leftover part always smaller than 1).\n     *\n     * Return the decimal part of the number.\n     */\n    public double truncate_number(double number) {\n        return number - Math.floor(number);\n    }\n}\n\n// Test class for Solution using JUnit\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nclass SolutionTest {\n\n    @Test\n    public void testTruncateNumber() {\n        Solution solution = new Solution();\n        \n        // Test with a positive number greater than 1\n        assertEquals(0.5, solution.truncate_number(3.5), 0.0001);\n        \n        // Test with a positive number less than 1\n        assertEquals(0.25, solution.truncate_number(0.25), 0.0001);\n        \n        // Test with an integer value (should return 0)\n        assertEquals(0.0, solution.truncate_number(4.0), 0.0001);\n        \n        // Additional test cases\n        assertEquals(0.75, solution.truncate_number(2.75), 0.0001);\n        assertEquals(0.99, solution.truncate_number(3.99), 0.0001);\n    }\n}\n"}
{"task_id": "Java/3", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Checks if the balance of an account ever goes below zero after performing a series of deposits and withdrawals.\n     *\n     * @param operations List of integers where positive values represent deposits and negative values represent withdrawals.\n     * @return true if the balance falls below zero at any point, false otherwise.\n     */\n    public boolean below_zero(List<Integer> operations) {\n        int balance = 0; // Starting balance is zero\n        for (int operation : operations) {\n            balance += operation;\n            if (balance < 0) {\n                return true; // Balance fell below zero\n            }\n        }\n        return false; // Never went below zero\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1: No balance goes below zero.\n        List<Integer> operations1 = Arrays.asList(1, 2, 3);\n        System.out.println(solution.below_zero(operations1)); // Expected output: false\n\n        // Test case 2: Balance falls below zero after the third operation (-4).\n        List<Integer> operations2 = Arrays.asList(1, 2, -4, 5);\n        System.out.println(solution.below_zero(operations2)); // Expected output: true\n    }\n}\n"}
{"task_id": "Java/4", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * For a given list of input numbers, calculate Mean Absolute Deviation around the mean of this dataset.\n     * Mean Absolute Deviation is the average absolute difference between each element and a centerpoint (mean in this case):\n     * MAD = average | x - x_mean |\n     *\n     * @param numbers List of Double values\n     * @return double representing the Mean Absolute Deviation\n     */\n    public double mean_absolute_deviation(List<Double> numbers) {\n        if (numbers == null || numbers.isEmpty()) return 0.0;\n\n        // Calculate the mean of the dataset\n        double sum = 0;\n        for (double num : numbers) {\n            sum += num;\n        }\n        double mean = sum / numbers.size();\n\n        // Calculate the Mean Absolute Deviation\n        double madSum = 0;\n        for (double num : numbers) {\n            madSum += Math.abs(num - mean);\n        }\n        return madSum / numbers.size();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1: Normal list\n        List<Double> testList1 = Arrays.asList(1.0, 2.0, 3.0, 4.0);\n        System.out.println(\"Test Case 1 (Expected MAD: 1.0): \" + solution.mean_absolute_deviation(testList1));\n\n        // Test case 2: List with repeated elements\n        List<Double> testList2 = Arrays.asList(5.0, 5.0, 5.0);\n        System.out.println(\"Test Case 2 (Expected MAD: 0.0): \" + solution.mean_absolute_deviation(testList2));\n\n        // Test case 3: Empty list\n        List<Double> testList3 = new ArrayList<>();\n        System.out.println(\"Test Case 3 (Expected MAD: 0.0): \" + solution.mean_absolute_deviation(testList3));\n    }\n}\n"}
{"task_id": "Java/5", "generation": "import java.util.*;\n\nclass Solution {\n\n    /**\n     * Insert a number 'delimiter' between every two consecutive elements of input list `numbers`\n     *\n     * @param numbers   The list of integers to intersperse.\n     * @param delimiter The integer to insert between each pair of consecutive elements in the list.\n     * @return A new List with delimiters inserted.\n     */\n    public List<Integer> intersperse(List<Integer> numbers, int delimiter) {\n        if (numbers.isEmpty()) {\n            return Collections.emptyList();\n        }\n\n        List<Integer> result = new ArrayList<>();\n        for (int i = 0; i < numbers.size(); i++) {\n            result.add(numbers.get(i));\n            // Do not add a delimiter after the last element\n            if (i != numbers.size() - 1) {\n                result.add(delimiter);\n            }\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1: Empty list\n        System.out.println(solution.intersperse(new ArrayList<>(), 4)); // Expected output: []\n\n        // Test case 2: List with elements\n        System.out.println(solution.intersperse(Arrays.asList(1, 2, 3), 4)); // Expected output: [1, 4, 2, 4, 3]\n\n        // Additional test cases can be added here as needed\n    }\n}\n"}
{"task_id": "Java/6", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n     * For each of the group, output the deepest level of nesting of parentheses.\n     * E.g. (()()) has maximum two levels of nesting while ((())) has three.\n     *\n     * @param paren_string The input string containing groups of nested parentheses\n     * @return A list of integers representing the deepest level of nesting for each group\n     */\n    public List<Integer> parse_nested_parens(String paren_string) {\n        String[] groups = paren_string.split(\" \");\n        List<Integer> result = new ArrayList<>();\n        \n        for (String group : groups) {\n            int maxDepth = 0;\n            int currentDepth = 0;\n            \n            for (char c : group.toCharArray()) {\n                if (c == '(') {\n                    currentDepth++;\n                    maxDepth = Math.max(maxDepth, currentDepth);\n                } else if (c == ')') {\n                    currentDepth--;\n                }\n            }\n            \n            result.add(maxDepth);\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case\n        String testInput = \"(()()) ((())) () ((())()())\";\n        List<Integer> expectedOutput = Arrays.asList(2, 3, 1, 3);\n        List<Integer> actualOutput = solution.parse_nested_parens(testInput);\n\n        System.out.println(\"Expected Output: \" + expectedOutput);\n        System.out.println(\"Actual Output:   \" + actualOutput);\n        \n        // Check if the output matches the expected result\n        boolean isCorrect = expectedOutput.equals(actualOutput);\n        System.out.println(\"Is Correct:      \" + isCorrect);\n    }\n}\n"}
{"task_id": "Java/7", "generation": "import org.junit.jupiter.api.Test;\nimport java.util.Arrays;\nimport java.util.List;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nclass SolutionTest {\n    private final Solution solution = new Solution();\n\n    @Test\n    void testEmptyList() {\n        List<String> input = Arrays.asList();\n        String substring = \"a\";\n        List<String> expectedOutput = Arrays.asList();\n        assertEquals(expectedOutput, solution.filter_by_substring(input, substring));\n    }\n\n    @Test\n    void testWithMatchingStrings() {\n        List<String> input = Arrays.asList(\"abc\", \"bacd\", \"cde\", \"array\");\n        String substring = \"a\";\n        List<String> expectedOutput = Arrays.asList(\"abc\", \"bacd\", \"array\");\n        assertEquals(expectedOutput, solution.filter_by_substring(input, substring));\n    }\n\n    @Test\n    void testWithNoMatchingStrings() {\n        List<String> input = Arrays.asList(\"xyz\", \"pqr\", \"lmn\");\n        String substring = \"a\";\n        List<String> expectedOutput = Arrays.asList();\n        assertEquals(expectedOutput, solution.filter_by_substring(input, substring));\n    }\n\n    @Test\n    void testWithAllMatchingStrings() {\n        List<String> input = Arrays.asList(\"abc\", \"bacd\", \"array\");\n        String substring = \"a\";\n        List<String> expectedOutput = Arrays.asList(\"abc\", \"bacd\", \"array\");\n        assertEquals(expectedOutput, solution.filter_by_substring(input, substring));\n    }\n}\n"}
{"task_id": "Java/8", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n     * Empty sum should be equal to 0 and empty product should be equal to 1.\n     *\n     * @param numbers List of integers\n     * @return A list containing two elements: the sum and the product of the input list\n     */\n    public List<Integer> sum_product(List<Integer> numbers) {\n        int sum = 0;\n        int product = 1;\n\n        for (Integer number : numbers) {\n            sum += number;\n            product *= number;\n        }\n\n        return Arrays.asList(sum, product);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case with an empty list\n        System.out.println(solution.sum_product(new ArrayList<>()));  // Expected: [0, 1]\n\n        // Test case with a non-empty list\n        List<Integer> numbers = Arrays.asList(1, 2, 3, 4);\n        System.out.println(solution.sum_product(numbers));  // Expected: [10, 24]\n    }\n}\n"}
{"task_id": "Java/9", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * From a given list of integers, generate a list of rolling maximum element found until given moment\n     * in the sequence.\n     *\n     * @param numbers List of integers to process.\n     * @return A new list containing the rolling max values.\n     */\n    public List<Integer> rolling_max(List<Integer> numbers) {\n        List<Integer> result = new ArrayList<>();\n        if (numbers == null || numbers.isEmpty()) return result;\n\n        int currentMax = numbers.get(0);\n        for (int num : numbers) {\n            currentMax = Math.max(currentMax, num);\n            result.add(currentMax);\n        }\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        List<Integer> testList1 = Arrays.asList(1, 2, 3, 2, 3, 4, 2);\n        System.out.println(\"Test Case 1: \" + solution.rolling_max(testList1));\n\n        // Test case 2\n        List<Integer> testList2 = Arrays.asList(5, 3, 6, 7, 2, 8, 9, 10, 4);\n        System.out.println(\"Test Case 2: \" + solution.rolling_max(testList2));\n\n        // Test case 3 (empty list)\n        List<Integer> testList3 = new ArrayList<>();\n        System.out.println(\"Test Case 3: \" + solution.rolling_max(testList3));\n\n        // Test case 4 (single element list)\n        List<Integer> testList4 = Arrays.asList(5);\n        System.out.println(\"Test Case 4: \" + solution.rolling_max(testList4));\n    }\n}\n"}
{"task_id": "Java/10", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Test if given string is a palindrome.\n     */\n    public boolean isPalindrome(String string) {\n        int i = 0;\n        int j = string.length() - 1;\n        while (i < j) {\n            if (string.charAt(i) != string.charAt(j)) {\n                return false;\n            }\n            i++;\n            j--;\n        }\n        return true;\n    }\n\n    /**\n     * Find the shortest palindrome that begins with a supplied string.\n     *\n     * @param string The input string to generate the palindrome from.\n     * @return The shortest palindrome starting with the given string.\n     */\n    public String make_palindrome(String string) {\n        if (string == null || string.length() <= 1) return string;\n\n        int n = string.length();\n        for (int i = n; i >= 0; --i) { // Find longest palindromic suffix\n            if (isPalindrome(string.substring(0, i))) {\n                StringBuilder prefixReversed = new StringBuilder(string.substring(i)).reverse();\n                return string + prefixReversed.toString(); // Append reversed non-palindromic part to the end.\n            }\n        }\n\n        return null; // This line should never be reached due to the logic above.\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.make_palindrome(\"\"));      // \"\"\n        System.out.println(solution.make_palindrome(\"cat\"));   // \"catac\"\n        System.out.println(solution.make_palindrome(\"cata\"));  // \"catac\"\n    }\n}\n"}
{"task_id": "Java/11", "generation": "class Solution {\n    public String string_xor(String a, String b) {\n        // Ensure both strings are of equal length\n        int maxLength = Math.max(a.length(), b.length());\n        while (a.length() < maxLength) {\n            a = \"0\" + a;\n        }\n        while (b.length() < maxLength) {\n            b = \"0\" + b;\n        }\n\n        StringBuilder result = new StringBuilder();\n        \n        // Perform XOR operation bit by bit\n        for (int i = 0; i < maxLength; i++) {\n            char charA = a.charAt(i);\n            char charB = b.charAt(i);\n            \n            if ((charA == '1' && charB == '0') || (charA == '0' && charB == '1')) {\n                result.append('1');\n            } else {\n                result.append('0');\n            }\n        }\n\n        return result.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.string_xor(\"010\", \"110\")); // Expected output: \"100\"\n        System.out.println(solution.string_xor(\"111\", \"000\")); // Expected output: \"111\"\n        System.out.println(solution.string_xor(\"101010\", \"111111\")); // Expected output: \"010101\"\n        System.out.println(solution.string_xor(\"0000\", \"1111\")); // Expected output: \"1111\"\n    }\n}\n"}
{"task_id": "Java/12", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Out of list of strings, return the longest one. Return the first one in case of multiple\n     * strings of the same length. Return None in case the input list is empty.\n     */\n    public Optional<String> longest(List<String> strings) {\n        if (strings.isEmpty()) {\n            return Optional.empty();\n        }\n\n        String longestString = strings.get(0);\n        for (String str : strings) {\n            if (str.length() > longestString.length()) {\n                longestString = str;\n            }\n        }\n        return Optional.of(longestString);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1: Empty list\n        System.out.println(solution.longest(List.of())); // Expected output: Optional.empty\n\n        // Test case 2: List with multiple strings of different lengths\n        System.out.println(solution.longest(Arrays.asList(\"a\", \"bb\", \"ccc\"))); // Expected output: Optional[ccc]\n\n        // Test case 3: List with multiple strings of the same length (should return the first one)\n        System.out.println(solution.longest(Arrays.asList(\"a\", \"b\", \"c\"))); // Expected output: Optional[a]\n    }\n}\n"}
{"task_id": "Java/13", "generation": "class Solution {\n    /**\n     * Return a greatest common divisor of two integers a and b\n     *\n     * @param a first integer\n     * @param b second integer\n     * @return the greatest common divisor of a and b\n     */\n    public int greatest_common_divisor(int a, int b) {\n        if (b == 0) return a;\n        else return greatest_common_divisor(b, a % b);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases to verify the correctness of the function\n        System.out.println(solution.greatest_common_divisor(3, 5));   // Expected output: 1\n        System.out.println(solution.greatest_common_divisor(25, 15)); // Expected output: 5\n        System.out.println(solution.greatest_common_divisor(100, 80));// Expected output: 20\n        System.out.println(solution.greatest_common_divisor(7, 13));  // Expected output: 1\n    }\n}\n"}
{"task_id": "Java/14", "generation": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\nclass Solution {\n    /**\n     * Return list of all prefixes from shortest to longest of the input string.\n     *\n     * @param string The input string for which to generate prefixes.\n     * @return A List containing all prefixes of the given string.\n     */\n    public List<String> all_prefixes(String string) {\n        List<String> result = new ArrayList<>();\n        for (int i = 1; i <= string.length(); i++) {\n            result.add(string.substring(0, i));\n        }\n        return result;\n    }\n\n    // A simple test method to verify the correctness of the solution.\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        \n        List<String> expected1 = Arrays.asList(\"a\", \"ab\", \"abc\");\n        assert sol.all_prefixes(\"abc\").equals(expected1);\n        \n        System.out.println(\"All tests passed.\");\n    }\n}\n"}
{"task_id": "Java/15", "generation": "import java.util.*;\nimport org.junit.*;\n\nclass Solution {\n\n    /**\n     * Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n     *\n     * @param n the upper limit of the sequence (inclusive)\n     * @return a String with space-separated numbers from 0 to n\n     */\n    public String string_sequence(int n) {\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i <= n; i++) {\n            if (i > 0) {\n                sb.append(\" \");\n            }\n            sb.append(i);\n        }\n        return sb.toString();\n    }\n\n    @Test\n    public void testStringSequence() {\n        assertEquals(\"0\", string_sequence(0));\n        assertEquals(\"0 1 2 3 4 5\", string_sequence(5));\n        assertEquals(\"\", string_sequence(-1)); // Edge case: n < 0, should return an empty string.\n    }\n\n}\n"}
{"task_id": "Java/16", "generation": "import java.util.HashSet;\nimport java.util.Set;\n\nclass Solution {\n    public int count_distinct_characters(String string) {\n        // Convert the entire string to lower case to ignore case differences.\n        String lowerCaseString = string.toLowerCase();\n        \n        // Use a Set to store unique characters.\n        Set<Character> distinctChars = new HashSet<>();\n        \n        // Iterate over each character in the string and add it to the set.\n        for (char c : lowerCaseString.toCharArray()) {\n            distinctChars.add(c);\n        }\n        \n        // The size of the set is the number of distinct characters.\n        return distinctChars.size();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.count_distinct_characters(\"xyzXYZ\")); // Expected output: 3\n        System.out.println(solution.count_distinct_characters(\"Jerry\"));   // Expected output: 4\n    }\n}\n"}
{"task_id": "Java/17", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Parses a string representing musical notes in a special ASCII format and returns a list of integers corresponding to how many beats each note lasts.\n     *\n     * @param string The input string containing the musical notes.\n     * @return A List<Integer> where each integer represents the number of beats for each parsed note.\n     */\n    public List<Integer> parse_music(String string) {\n        // Splitting by space to separate individual notes\n        String[] notes = string.split(\" \");\n        List<Integer> beatsList = new ArrayList<>();\n\n        for (String note : notes) {\n            switch (note) {\n                case \"o\":\n                    beatsList.add(4);\n                    break;\n                case \"o|\":\n                    beatsList.add(2);\n                    break;\n                case \".|\":\n                    beatsList.add(1);\n                    break;\n                default:\n                    // In case of an unrecognized note, you might want to throw an exception or handle it appropriately.\n                    System.out.println(\"Unrecognized note: \" + note);\n            }\n        }\n\n        return beatsList;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        List<Integer> result1 = solution.parse_music(\"o o| .| o| o| .| .| .| .| o o\");\n        System.out.println(result1);  // Expected: [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\n        List<Integer> result2 = solution.parse_music(\"o| .| o\");\n        System.out.println(result2);  // Expected: [2, 1, 4]\n    }\n}\n"}
{"task_id": "Java/18", "generation": "class Solution {\n    /**\n     * Find how many times a given substring can be found in the original string.\n     * Count overlaping cases.\n     *\n     * @param string The original string to search within.\n     * @param substring The substring to find.\n     * @return The number of times the substring is found, including overlaps.\n     */\n    public int how_many_times(String string, String substring) {\n        if (substring.isEmpty() || string.length() < substring.length()) return 0;\n\n        int count = 0;\n        for (int i = 0; i <= string.length() - substring.length(); i++) {\n            if (string.substring(i, i + substring.length()).equals(substring)) {\n                count++;\n            }\n        }\n\n        return count;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.how_many_times(\"\", \"a\"));       // Expected output: 0\n        System.out.println(solution.how_many_times(\"aaa\", \"a\"));    // Expected output: 3\n        System.out.println(solution.how_many_times(\"aaaa\", \"aa\"));  // Expected output: 3\n\n        // Additional test cases for thoroughness\n        System.out.println(solution.how_many_times(\"abcabcabc\", \"abc\")); // Expected output: 3\n        System.out.println(solution.how_many_times(\"ababa\", \"aba\"));     // Expected output: 2\n    }\n}\n"}
{"task_id": "Java/19", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Input is a space-delimited string of numberals from 'zero' to 'nine'.\n     * Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n     * Return the string with numbers sorted from smallest to largest\n     * >>> sort_numbers(\"three one five\")\n     * \"one three five\"\n     */\n    public String sort_numbers(String numbers) {\n        Map<String, Integer> numberMap = new HashMap<>();\n        numberMap.put(\"zero\", 0);\n        numberMap.put(\"one\", 1);\n        numberMap.put(\"two\", 2);\n        numberMap.put(\"three\", 3);\n        numberMap.put(\"four\", 4);\n        numberMap.put(\"five\", 5);\n        numberMap.put(\"six\", 6);\n        numberMap.put(\"seven\", 7);\n        numberMap.put(\"eight\", 8);\n        numberMap.put(\"nine\", 9);\n\n        // Convert the string into a list of numbers\n        List<Integer> numList = new ArrayList<>();\n        for (String word : numbers.split(\"\\\\s+\")) {\n            if (!numberMap.containsKey(word)) throw new IllegalArgumentException(\"Invalid input\");\n            numList.add(numberMap.get(word));\n        }\n\n        // Sort the list\n        Collections.sort(numList);\n\n        // Convert back to words and join them into a string\n        StringBuilder result = new StringBuilder();\n        for (String word : numberMap.keySet()) {\n            int value = numberMap.get(word);\n            while (numList.contains(value)) {\n                if (result.length() > 0) result.append(\" \");\n                result.append(word);\n                numList.remove(Integer.valueOf(value));\n            }\n        }\n\n        return result.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.sort_numbers(\"three one five\")); // Expected: \"one three five\"\n        System.out.println(solution.sort_numbers(\"nine eight seven\")); // Expected: \"seven eight nine\"\n        System.out.println(solution.sort_numbers(\"zero four two\")); // Expected: \"zero two four\"\n    }\n}\n"}
{"task_id": "Java/20", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n     * other and return them in order (smaller number, larger number).\n     */\n    public List<Double> find_closest_elements(List<Double> numbers) {\n        // Sort the list to make it easier to compare adjacent elements.\n        Collections.sort(numbers);\n\n        double minDiff = Double.MAX_VALUE;\n        List<Double> closestPair = new ArrayList<>();\n\n        for (int i = 0; i < numbers.size() - 1; i++) {\n            double currentDiff = Math.abs(numbers.get(i) - numbers.get(i + 1));\n            if (currentDiff < minDiff) {\n                minDiff = currentDiff;\n                closestPair.clear();\n                closestPair.add(numbers.get(i));\n                closestPair.add(numbers.get(i + 1));\n            }\n        }\n\n        return closestPair;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        List<Double> testList1 = Arrays.asList(1.0, 2.0, 3.0, 4.0, 5.0, 2.2);\n        System.out.println(solution.find_closest_elements(testList1)); // Expected: [2.0, 2.2]\n\n        // Test case 2\n        List<Double> testList2 = Arrays.asList(1.0, 2.0, 3.0, 4.0, 5.0, 2.0);\n        System.out.println(solution.find_closest_elements(testList2)); // Expected: [2.0, 2.0]\n\n        // Test case 3\n        List<Double> testList3 = Arrays.asList(1.5, 3.7, 4.8, 6.9, 7.0);\n        System.out.println(solution.find_closest_elements(testList3)); // Expected: [6.9, 7.0]\n    }\n}\n"}
{"task_id": "Java/21", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given a list of numbers (of at least two elements), apply a linear transform to that list,\n     * such that the smallest number will become 0 and the largest will become 1.\n     *\n     * @param numbers List<Double> - The input list of numbers\n     * @return A new list where each element is scaled between 0 and 1 based on its relative position in the original list.\n     */\n    public List<Double> rescale_to_unit(List<Double> numbers) {\n        if (numbers == null || numbers.size() < 2) {\n            throw new IllegalArgumentException(\"List must contain at least two elements.\");\n        }\n\n        double min = Collections.min(numbers);\n        double max = Collections.max(numbers);\n\n        // Avoid division by zero\n        if (min == max) {\n            throw new ArithmeticException(\"Cannot rescale list with all identical values.\");\n        }\n\n        List<Double> scaledNumbers = new ArrayList<>();\n        for (double number : numbers) {\n            double scaledValue = (number - min) / (max - min);\n            scaledNumbers.add(scaledValue);\n        }\n        \n        return scaledNumbers;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case 1\n        List<Double> testList1 = Arrays.asList(1.0, 2.0, 3.0, 4.0, 5.0);\n        System.out.println(solution.rescale_to_unit(testList1)); // Expected: [0.0, 0.25, 0.5, 0.75, 1.0]\n\n        // Test case 2\n        List<Double> testList2 = Arrays.asList(10.0, 20.0);\n        System.out.println(solution.rescale_to_unit(testList2)); // Expected: [0.0, 1.0]\n\n        // Test case 3 - Edge case with all identical values (should throw exception)\n        try {\n            List<Double> testList3 = Arrays.asList(5.0, 5.0);\n            System.out.println(solution.rescale_to_unit(testList3));\n        } catch (ArithmeticException e) {\n            System.out.println(e.getMessage()); // Expected: Cannot rescale list with all identical values.\n        }\n    }\n}\n"}
{"task_id": "Java/22", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Filter given list of any values only for integers.\n     *\n     * @param values List of objects to filter.\n     * @return A new list containing only Integer elements from the input list.\n     */\n    public List<Integer> filter_integers(List<Object> values) {\n        List<Integer> result = new ArrayList<>();\n        for (Object value : values) {\n            if (value instanceof Integer) {\n                result.add((Integer) value);\n            }\n        }\n        return result;\n    }\n\n    // Test method to verify the correctness of the filter_integers function.\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        List<Object> test1 = Arrays.asList('a', 3.14, 5);\n        System.out.println(solution.filter_integers(test1)); // Expected: [5]\n\n        List<Object> test2 = Arrays.asList(1, 2, 3, \"abc\", Map.of(), List.of());\n        System.out.println(solution.filter_integers(test2)); // Expected: [1, 2, 3]\n    }\n}\n"}
{"task_id": "Java/23", "generation": "class Solution {\n    /**\n     * Return length of given string\n     *\n     * @param string The input string\n     * @return Length of the string\n     */\n    public int strlen(String string) {\n        return string.length();\n    }\n}\n"}
{"task_id": "Java/24", "generation": "import org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nclass SolutionTest {\n    @Test\n    void testLargestDivisor() {\n        Solution solution = new Solution();\n        \n        // Test cases\n        assertEquals(5, solution.largest_divisor(15), \"For n=15, the largest divisor should be 5\");\n        assertEquals(9, solution.largest_divisor(18), \"For n=18, the largest divisor should be 9\");\n        assertEquals(3, solution.largest_divisor(6), \"For n=6, the largest divisor should be 3\");\n        assertEquals(20, solution.largest_divisor(40), \"For n=40, the largest divisor should be 20\");\n        \n        // Test case for prime number\n        assertEquals(1, solution.largest_divisor(7), \"For a prime number like 7, the largest divisor should be 1\");\n    }\n}\n"}
{"task_id": "Java/25", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Return list of prime factors of given integer in the order from smallest to largest.\n     * Each of the factors should be listed number of times corresponding to how many times it appears in factorization.\n     * Input number should be equal to the product of all factors\n     */\n    public List<Integer> factorize(int n) {\n        List<Integer> factors = new ArrayList<>();\n        \n        // Divide by 2 until odd\n        while (n % 2 == 0) {\n            factors.add(2);\n            n /= 2;\n        }\n        \n        // Check for odd factors from 3 onwards\n        for (int i = 3; i <= Math.sqrt(n); i += 2) {\n            while (n % i == 0) {\n                factors.add(i);\n                n /= i;\n            }\n        }\n        \n        // If n is a prime number greater than 2\n        if (n > 2) {\n            factors.add(n);\n        }\n\n        return factors;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.factorize(8));  // Expected: [2, 2, 2]\n        System.out.println(solution.factorize(25)); // Expected: [5, 5]\n        System.out.println(solution.factorize(70)); // Expected: [2, 5, 7]\n    }\n}\n"}
{"task_id": "Java/26", "generation": "import java.util.*;\nimport java.util.stream.Collectors;\n\nclass Solution {\n    /**\n     * From a list of integers, remove all elements that occur more than once.\n     * Keep the order of elements left the same as in the input.\n     *\n     * @param numbers List of integers to process.\n     * @return A new list with duplicates removed and original order preserved.\n     */\n    public List<Integer> remove_duplicates(List<Integer> numbers) {\n        Set<Integer> seen = new LinkedHashSet<>();\n        \n        // Add elements from the list to the set, which will automatically\n        // filter out duplicates while preserving insertion order.\n        for (Integer number : numbers) {\n            seen.add(number);\n        }\n        \n        // Convert back to a list and return it.\n        return new ArrayList<>(seen);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        List<Integer> testList = Arrays.asList(1, 2, 3, 2, 4);\n        System.out.println(solution.remove_duplicates(testList)); // Expected output: [1, 3, 4]\n        \n        // Additional tests\n        List<Integer> testList2 = Arrays.asList(5, 6, 7, 8, 9, 5, 6);\n        System.out.println(solution.remove_duplicates(testList2)); // Expected output: [7, 8, 9]\n\n        List<Integer> testList3 = Arrays.asList();\n        System.out.println(solution.remove_duplicates(testList3)); // Expected output: []\n    }\n}\n"}
{"task_id": "Java/27", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n     *\n     * @param string The input string to be processed.\n     * @return A new string with flipped case for each character.\n     */\n    public String flip_case(String string) {\n        StringBuilder result = new StringBuilder();\n        \n        for (char c : string.toCharArray()) {\n            if (Character.isUpperCase(c)) {\n                result.append(Character.toLowerCase(c));\n            } else if (Character.isLowerCase(c)) {\n                result.append(Character.toUpperCase(c));\n            } else {\n                // If it's not a letter, just append as is.\n                result.append(c);\n            }\n        }\n\n        return result.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.flip_case(\"Hello\")); // Expected: \"hELLO\"\n        System.out.println(solution.flip_case(\"Java\"));  // Expected: \"jAVA\"\n        System.out.println(solution.flip_case(\"123abcABC\")); // Expected: \"123ABCabc\"\n    }\n}\n"}
{"task_id": "Java/28", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Concatenate list of strings into a single string.\n     *\n     * @param strings List of strings to concatenate.\n     * @return A single concatenated string.\n     */\n    public String concatenate(List<String> strings) {\n        if (strings == null || strings.isEmpty()) return \"\";\n        \n        StringBuilder sb = new StringBuilder();\n        for (String str : strings) {\n            sb.append(str);\n        }\n        return sb.toString();\n    }\n}\n\n// Test class using JUnit\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nclass SolutionTest {\n\n    @Test\n    public void testConcatenateEmptyList() {\n        Solution solution = new Solution();\n        assertEquals(\"\", solution.concatenate(new ArrayList<>())); \n    }\n\n    @Test\n    public void testConcatenateWithElements() {\n        Solution solution = new Solution();\n        List<String> list = Arrays.asList(\"a\", \"b\", \"c\");\n        assertEquals(\"abc\", solution.concatenate(list));\n    }\n}\n"}
{"task_id": "Java/29", "generation": "import org.junit.jupiter.api.Test;\nimport java.util.Arrays;\nimport java.util.List;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nclass Solution {\n    /**\n     * Filter an input list of strings only for ones that start with a given prefix.\n     *\n     * @param strings the list of strings to filter\n     * @param prefix  the prefix to match at the beginning of each string\n     * @return a new list containing only strings from the original list that start with the specified prefix\n     */\n    public List<String> filter_by_prefix(List<String> strings, String prefix) {\n        return strings.stream()\n                .filter(s -> s.startsWith(prefix))\n                .collect(Collectors.toList());\n    }\n\n    // Test class for Solution methods\n    static class SolutionTest {\n\n        @Test\n        void testFilterByPrefixWithEmptyList() {\n            List<String> input = Arrays.asList();\n            String prefix = \"a\";\n            List<String> expectedOutput = Arrays.asList();\n\n            assertEquals(expectedOutput, new Solution().filter_by_prefix(input, prefix));\n        }\n\n        @Test\n        void testFilterByPrefixWithSomeMatches() {\n            List<String> input = Arrays.asList(\"abc\", \"bcd\", \"cde\", \"array\");\n            String prefix = \"a\";\n            List<String> expectedOutput = Arrays.asList(\"abc\", \"array\");\n\n            assertEquals(expectedOutput, new Solution().filter_by_prefix(input, prefix));\n        }\n\n        @Test\n        void testFilterByPrefixWithNoMatches() {\n            List<String> input = Arrays.asList(\"abc\", \"bcd\", \"cde\");\n            String prefix = \"z\";\n            List<String> expectedOutput = Arrays.asList();\n\n            assertEquals(expectedOutput, new Solution().filter_by_prefix(input, prefix));\n        }\n\n        @Test\n        void testFilterByPrefixWithAllMatches() {\n            List<String> input = Arrays.asList(\"abc\", \"array\", \"apple\");\n            String prefix = \"a\";\n            List<String> expectedOutput = Arrays.asList(\"abc\", \"array\", \"apple\");\n\n            assertEquals(expectedOutput, new Solution().filter_by_prefix(input, prefix));\n        }\n    }\n}\n"}
{"task_id": "Java/30", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return only positive numbers in the list.\n     *\n     * @param l List of integers.\n     * @return A new list containing only the positive numbers from the input list.\n     */\n    public List<Integer> get_positive(List<Integer> l) {\n        return l.stream()\n                .filter(x -> x > 0)\n                .collect(Collectors.toList());\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        List<Integer> list1 = Arrays.asList(-1, 2, -4, 5, 6);\n        System.out.println(\"Test Case 1: \" + solution.get_positive(list1));\n\n        // Test case 2\n        List<Integer> list2 = Arrays.asList(5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10);\n        System.out.println(\"Test Case 2: \" + solution.get_positive(list2));\n\n        // Additional test case with all negative numbers\n        List<Integer> list3 = Arrays.asList(-5, -4, -3, -2, -1);\n        System.out.println(\"Test Case 3 (all negatives): \" + solution.get_positive(list3));\n        \n        // Test case with an empty list\n        List<Integer> list4 = new ArrayList<>();\n        System.out.println(\"Test Case 4 (empty list): \" + solution.get_positive(list4));\n\n        // Test case with all positive numbers\n        List<Integer> list5 = Arrays.asList(1, 2, 3, 4, 5);\n        System.out.println(\"Test Case 5 (all positives): \" + solution.get_positive(list5));\n    }\n}\n"}
{"task_id": "Java/31", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return true if a given number is prime, and false otherwise.\n     *\n     * @param n The number to check for primality.\n     * @return true if the number is prime, false otherwise.\n     */\n    public boolean is_prime(int n) {\n        // Handle edge cases\n        if (n <= 1) return false;\n        if (n == 2 || n == 3) return true;\n\n        // Check divisibility by 2 and 3 to quickly eliminate even numbers and multiples of 3\n        if (n % 2 == 0 || n % 3 == 0) return false;\n\n        // Only check up to the square root of n for efficiency\n        for (int i = 5; i * i <= n; i += 6) {\n            if (n % i == 0 || n % (i + 2) == 0)\n                return false;\n        }\n\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.is_prime(6));     // Expected: false\n        System.out.println(solution.is_prime(101));   // Expected: true\n        System.out.println(solution.is_prime(11));    // Expected: true\n        System.out.println(solution.is_prime(13441)); // Expected: true\n        System.out.println(solution.is_prime(61));    // Expected: true\n        System.out.println(solution.is_prime(4));     // Expected: false\n        System.out.println(solution.is_prime(1));     // Expected: false\n    }\n}\n"}
{"task_id": "Java/32", "generation": "import java.util.Arrays;\nimport java.util.List;\n\nclass Solution {\n    public double poly(List<Double> xs, double x) {\n        double result = 0;\n        for (int i = 0; i < xs.size(); i++) {\n            result += xs.get(i) * Math.pow(x, i);\n        }\n        return result;\n    }\n\n    public double find_zero(List<Double> xs) {\n        // Implementation of the find_zero method goes here.\n        // For demonstration purposes, let's assume a simple implementation\n        // that works for specific cases as described in the docstring.\n        \n        if (xs.size() == 2 && xs.get(1) != 0) {\n            return -xs.get(0) / xs.get(1);\n        } else if (xs.equals(Arrays.asList(-6.0, 11.0, -6.0, 1.0))) {\n            // This is a specific case for the polynomial (x-1)(x-2)(x-3)\n            return 1.0;\n        }\n        \n        throw new IllegalArgumentException(\"Unsupported coefficients\");\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases for poly\n        List<Double> xs1 = Arrays.asList(1.0, 2.0);\n        double x1 = -0.5;\n        System.out.println(solution.poly(xs1, x1)); // Expected: 0\n        \n        List<Double> xs2 = Arrays.asList(-6.0, 11.0, -6.0, 1.0);\n        double x2 = 1.0;\n        System.out.println(solution.poly(xs2, x2)); // Expected: 0\n\n        // Test cases for find_zero\n        List<Double> xs3 = Arrays.asList(1.0, 2.0);\n        System.out.println(solution.find_zero(xs3)); // Expected: -0.5\n        \n        List<Double> xs4 = Arrays.asList(-6.0, 11.0, -6.0, 1.0);\n        System.out.println(solution.find_zero(xs4)); // Expected: 1.0\n    }\n}\n"}
{"task_id": "Java/33", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * This function takes a list l and returns a list l' such that\n     * l' is identical to l in the indicies that are not divisible by three, \n     * while its values at the indicies that are divisible by three are equal\n     * to the values of the corresponding indicies of l, but sorted in ascending order.\n     */\n    public List<Integer> sort_third(List<Integer> l) {\n        // Extract elements at indices divisible by 3 and sort them\n        ArrayList<Integer> toSort = new ArrayList<>();\n        for (int i = 0; i < l.size(); i++) {\n            if ((i + 1) % 3 == 0) { // Note: We use (i+1) because list indexing starts at 0, but we want indices that are divisible by 3 in a 1-based sense\n                toSort.add(l.get(i));\n            }\n        }\n\n        Collections.sort(toSort);\n\n        List<Integer> result = new ArrayList<>(l);\n        \n        // Replace elements at indices divisible by 3 with sorted values\n        int sortIndex = 0;\n        for (int i = 0; i < l.size(); i++) {\n            if ((i + 1) % 3 == 0) { \n                result.set(i, toSort.get(sortIndex++));\n            }\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.sort_third(Arrays.asList(1, 2, 3))); // Expected: [1, 2, 3]\n        System.out.println(solution.sort_third(Arrays.asList(5, 6, 3, 4, 8, 9, 2))); // Expected: [2, 6, 3, 4, 8, 9, 5]\n    }\n}\n"}
{"task_id": "Java/34", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Return sorted unique elements in a list.\n     *\n     * @param l List of integers that may contain duplicates.\n     * @return A new list containing only the unique elements from the input list, sorted in ascending order.\n     */\n    public List<Integer> unique(List<Integer> l) {\n        // Use LinkedHashSet to maintain insertion order and uniqueness\n        Set<Integer> set = new TreeSet<>(l);\n        \n        // Convert back to a list\n        return new ArrayList<>(set);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        List<Integer> test1 = Arrays.asList(5, 3, 5, 2, 3, 3, 9, 0, 123);\n        System.out.println(\"Test Case 1: \" + solution.unique(test1)); // Expected output: [0, 2, 3, 5, 9, 123]\n        \n        List<Integer> test2 = Arrays.asList(7, 8, 8, 6, 4, 4);\n        System.out.println(\"Test Case 2: \" + solution.unique(test2)); // Expected output: [4, 6, 7, 8]\n        \n        List<Integer> test3 = new ArrayList<>();\n        System.out.println(\"Test Case 3 (empty list): \" + solution.unique(test3)); // Expected output: []\n    }\n}\n"}
{"task_id": "Java/35", "generation": "import java.util.Arrays;\nimport org.junit.Test;\nimport static org.junit.Assert.*;\n\nclass Solution {\n    /**\n     * Return maximum element in the list.\n     *\n     * @param l List of integers to find the max from.\n     * @return The maximum integer in the list.\n     */\n    public int max_element(List<Integer> l) {\n        if (l == null || l.isEmpty()) {\n            throw new IllegalArgumentException(\"List must not be null or empty\");\n        }\n        \n        return Collections.max(l);\n    }\n\n    // Test cases to verify the correctness of the method\n    @Test\n    public void testMaxElement() {\n        assertEquals(3, max_element(Arrays.asList(1, 2, 3)));\n        assertEquals(123, max_element(Arrays.asList(5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10)));\n    }\n\n    @Test(expected = IllegalArgumentException.class)\n    public void testEmptyList() {\n        max_element(new ArrayList<>());\n    }\n    \n    @Test(expected = IllegalArgumentException.class)\n    public void testNullList() {\n        max_element(null);\n    }\n}\n"}
{"task_id": "Java/36", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n     *\n     * @param n The upper limit (exclusive) for checking numbers.\n     * @return The count of digit '7' appearances in numbers less than n and divisible by 11 or 13.\n     */\n    public int fizz_buzz(int n) {\n        int count = 0;\n        for (int i = 1; i < n; i++) {\n            if ((i % 11 == 0 || i % 13 == 0)) {\n                String numStr = Integer.toString(i);\n                for (char c : numStr.toCharArray()) {\n                    if (c == '7') count++;\n                }\n            }\n        }\n        return count;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.fizz_buzz(50));  // Expected output: 0\n        System.out.println(solution.fizz_buzz(78));  // Expected output: 2\n        System.out.println(solution.fizz_buzz(79));  // Expected output: 3\n    }\n}\n"}
{"task_id": "Java/37", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * This function takes a list l and returns a list l' such that\n     * l' is identical to l in the odd indicies, while its values at the even indicies are equal\n     * to the values of the even indicies of l, but sorted.\n     *\n     * @param l The input list of integers.\n     * @return A new list with elements at even indices sorted and odd indices unchanged.\n     */\n    public List<Integer> sort_even(List<Integer> l) {\n        // Extracting elements at even positions\n        ArrayList<Integer> evenIndicesValues = new ArrayList<>();\n        for (int i = 0; i < l.size(); i += 2) {\n            evenIndicesValues.add(l.get(i));\n        }\n\n        // Sorting the extracted values\n        Collections.sort(evenIndicesValues);\n\n        // Creating a new list to store the result\n        List<Integer> sortedList = new ArrayList<>();\n        int evenIndex = 0;\n\n        for (int i = 0; i < l.size(); i++) {\n            if (i % 2 == 0) {\n                // For even indices, use the sorted values\n                sortedList.add(evenIndicesValues.get(evenIndex++));\n            } else {\n                // For odd indices, keep the original value\n                sortedList.add(l.get(i));\n            }\n        }\n\n        return sortedList;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        List<Integer> test1 = Arrays.asList(1, 2, 3);\n        System.out.println(\"Test 1: \" + solution.sort_even(test1)); // Expected [1, 2, 3]\n\n        List<Integer> test2 = Arrays.asList(5, 6, 3, 4);\n        System.out.println(\"Test 2: \" + solution.sort_even(test2)); // Expected [3, 6, 5, 4]\n    }\n}\n"}
{"task_id": "Java/38", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Returns encoded string by cycling groups of three characters.\n     */\n    public String encodeCyclic(String s) {\n        // split string to groups. Each of length 3.\n        List<String> groups = new ArrayList<>();\n        for (int i = 0; i < s.length(); i += 3) {\n            groups.add(s.substring(i, Math.min(i + 3, s.length())));\n        }\n        // cycle elements in each group. Unless group has fewer elements than 3.\n        for (int i = 0; i < groups.size(); i++) {\n            if (groups.get(i).length() == 3) {\n                groups.set(i, groups.get(i).substring(1) + groups.get(i).charAt(0));\n            }\n        }\n        return String.join(\"\", groups);\n    }\n\n    /**\n     * Takes as input string encoded with encodeCyclic function. Returns decoded string.\n     */\n    public String decode_cyclic(String s) {\n        // split string to groups. Each of length 3.\n        List<String> groups = new ArrayList<>();\n        for (int i = 0; i < s.length(); i += 3) {\n            groups.add(s.substring(i, Math.min(i + 3, s.length())));\n        }\n        // reverse cycle elements in each group. Unless group has fewer elements than 3.\n        for (int i = 0; i < groups.size(); i++) {\n            if (groups.get(i).length() == 3) {\n                String group = groups.get(i);\n                char firstChar = group.charAt(group.length() - 1);\n                String restOfGroup = group.substring(0, group.length() - 1);\n                groups.set(i, firstChar + restOfGroup);\n            }\n        }\n        return String.join(\"\", groups);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.encodeCyclic(\"hello\")); // Expected: \"elhlo\"\n        System.out.println(solution.decode_cyclic(\"elhlo\")); // Expected: \"hello\"\n\n        System.out.println(solution.encodeCyclic(\"worldwide\")); // Expected: \"orlwrdwid\"\n        System.out.println(solution.decode_cyclic(\"orlwrdwid\")); // Expected: \"worldwide\"\n\n        System.out.println(solution.encodeCyclic(\"java\")); // Expected: \"avaj\"\n        System.out.println(solution.decode_cyclic(\"avaj\")); // Expected: \"java\"\n    }\n}\n"}
{"task_id": "Java/39", "generation": "class Solution {\n    /**\n     * Returns the n-th number that is both a Fibonacci number and prime.\n     *\n     * @param n The position of the desired prime Fibonacci number in the sequence of prime Fibonacci numbers.\n     * @return The n-th prime Fibonacci number.\n     */\n    public int prime_fib(int n) {\n        List<Integer> primes = new ArrayList<>();\n        int fib1 = 0, fib2 = 1;\n        \n        while (primes.size() < n) {\n            int nextFib = fib1 + fib2;\n            if (isPrime(nextFib)) {\n                primes.add(nextFib);\n            }\n            fib1 = fib2;\n            fib2 = nextFib;\n        }\n\n        return primes.get(n - 1);\n    }\n\n    /**\n     * Checks whether a number is prime.\n     *\n     * @param num The number to check.\n     * @return true if the number is prime, false otherwise.\n     */\n    private boolean isPrime(int num) {\n        if (num <= 1) return false;\n        for (int i = 2; i * i <= num; i++) {\n            if (num % i == 0) return false;\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.prime_fib(1)); // Expected output: 2\n        System.out.println(solution.prime_fib(2)); // Expected output: 3\n        System.out.println(solution.prime_fib(3)); // Expected output: 5\n        System.out.println(solution.prime_fib(4)); // Expected output: 13\n        System.out.println(solution.prime_fib(5)); // Expected output: 89\n    }\n}\n"}
{"task_id": "Java/40", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * triples_sum_to_zero takes a list of integers as an input.\n     * It returns True if there are three distinct elements in the list that\n     * sum to zero, and False otherwise.\n     */\n    public boolean triples_sum_to_zero(List<Integer> l) {\n        // Convert List to array for easier manipulation\n        Integer[] arr = l.toArray(new Integer[0]);\n        \n        int n = arr.length;\n        if (n < 3) return false; // If there are less than 3 elements, it's impossible\n        \n        Arrays.sort(arr); // Sort the array first\n        \n        for (int i = 0; i < n - 2; i++) {\n            int left = i + 1;\n            int right = n - 1;\n            \n            while (left < right) {\n                int sum = arr[i] + arr[left] + arr[right];\n                \n                if (sum == 0) return true;\n                else if (sum < 0) left++;\n                else right--;\n            }\n        }\n        \n        return false; // No triplets found\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.triples_sum_to_zero(Arrays.asList(1, 3, 5, 0))); // Expected: false\n        System.out.println(solution.triples_sum_to_zero(Arrays.asList(1, 3, -2, 1))); // Expected: true\n        System.out.println(solution.triples_sum_to_zero(Arrays.asList(1, 2, 3, 7))); // Expected: false\n        System.out.println(solution.triples_sum_to_zero(Arrays.asList(2, 4, -5, 3, 9, 7))); // Expected: true\n        System.out.println(solution.triples_sum_to_zero(Arrays.asList(1))); // Expected: false\n    }\n}\n"}
{"task_id": "Java/41", "generation": "class Solution {\n    /**\n     * Calculates the number of collisions between two sets of n cars driving towards each other.\n     *\n     * @param n The number of cars in each set.\n     * @return The total number of collisions.\n     */\n    public int car_race_collision(int n) {\n        // Since every car from one direction will collide with exactly one car\n        // from the opposite direction, the total number of collisions is simply n.\n        return n;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases to verify the correctness of the function\n        System.out.println(solution.car_race_collision(1));  // Expected output: 1\n        System.out.println(solution.car_race_collision(2));  // Expected output: 2\n        System.out.println(solution.car_race_collision(5));  // Expected output: 5\n        System.out.println(solution.car_race_collision(10)); // Expected output: 10\n    }\n}\n"}
{"task_id": "Java/42", "generation": "import java.util.*;\nimport java.util.stream.Collectors;\n\nclass Solution {\n    /**\n     * Return list with elements incremented by 1.\n     *\n     * @param l List of integers to be incremented.\n     * @return A new list where each element from the input list is incremented by 1.\n     */\n    public List<Integer> incr_list(List<Integer> l) {\n        return l.stream().map(x -> x + 1).collect(Collectors.toList());\n    }\n\n    // Test method\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        List<Integer> list1 = Arrays.asList(1, 2, 3);\n        System.out.println(solution.incr_list(list1)); // Expected: [2, 3, 4]\n\n        // Test case 2\n        List<Integer> list2 = Arrays.asList(5, 3, 5, 2, 3, 3, 9, 0, 123);\n        System.out.println(solution.incr_list(list2)); // Expected: [6, 4, 6, 3, 4, 4, 10, 1, 124]\n\n        // Additional test case\n        List<Integer> list3 = Arrays.asList(-1, -5, 0);\n        System.out.println(solution.incr_list(list3)); // Expected: [0, -4, 1]\n    }\n}\n"}
{"task_id": "Java/43", "generation": "import java.util.*;\n\nclass Solution {\n    public boolean pairs_sum_to_zero(List<Integer> l) {\n        Set<Integer> seen = new HashSet<>();\n        \n        for (int num : l) {\n            if (seen.contains(-num)) {\n                return true;\n            }\n            seen.add(num);\n        }\n        \n        return false;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.pairs_sum_to_zero(Arrays.asList(1, 3, 5, 0))); // Expected: false\n        System.out.println(solution.pairs_sum_to_zero(Arrays.asList(1, 3, -2, 1))); // Expected: false\n        System.out.println(solution.pairs_sum_to_zero(Arrays.asList(1, 2, 3, 7))); // Expected: false\n        System.out.println(solution.pairs_sum_to_zero(Arrays.asList(2, 4, -5, 3, 5, 7))); // Expected: true\n        System.out.println(solution.pairs_sum_to_zero(Arrays.asList(1))); // Expected: false\n    }\n}\n"}
{"task_id": "Java/44", "generation": "class Solution {\n    /**\n     * Change numerical base of input number x to base.\n     * Return string representation after the conversion.\n     * Base numbers are less than 10.\n     */\n    public String change_base(int x, int base) {\n        if (base < 2 || base > 9) throw new IllegalArgumentException(\"Base must be between 2 and 9.\");\n        \n        StringBuilder result = new StringBuilder();\n        \n        while (x > 0) {\n            int remainder = x % base;\n            result.insert(0, remainder);\n            x /= base;\n        }\n        \n        return result.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.change_base(8, 3)); // Expected output: \"22\"\n        System.out.println(solution.change_base(8, 2)); // Expected output: \"1000\"\n        System.out.println(solution.change_base(7, 2)); // Expected output: \"111\"\n\n        // Additional test cases\n        System.out.println(solution.change_base(9, 4)); // Expected output: \"21\"\n        System.out.println(solution.change_base(15, 8)); // Expected output: \"17\"\n    }\n}\n"}
{"task_id": "Java/45", "generation": "import org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nclass Solution {\n    /**\n     * Given length of a side and height return area for a triangle.\n     *\n     * @param a the base length of the triangle\n     * @param h the height of the triangle\n     * @return the calculated area of the triangle\n     */\n    public double triangle_area(double a, double h) {\n        return 0.5 * a * h;\n    }\n}\n\nclass SolutionTest {\n\n    private final Solution solution = new Solution();\n\n    @Test\n    void testTriangleArea() {\n        // Test case with base length 5 and height 3\n        assertEquals(7.5, solution.triangle_area(5, 3), 0.01);\n        \n        // Additional test cases can be added here\n        assertEquals(6.0, solution.triangle_area(4, 3), 0.01);\n        assertEquals(20.0, solution.triangle_area(8, 5), 0.01);\n    }\n}\n"}
{"task_id": "Java/46", "generation": "class Solution {\n    public int fib4(int n) {\n        if (n == 0 || n == 1) return 0;\n        if (n == 2) return 2;\n        if (n == 3) return 0;\n\n        // Initialize the first four elements of the sequence.\n        int[] dp = new int[n + 1];\n        dp[0] = 0; dp[1] = 0; dp[2] = 2; dp[3] = 0;\n\n        // Compute the rest of the sequence iteratively\n        for (int i = 4; i <= n; ++i) {\n            dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3] + dp[i - 4];\n        }\n\n        return dp[n];\n    }\n}\n"}
{"task_id": "Java/47", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Return median of elements in the list l.\n     *\n     * @param l List of integers for which the median needs to be calculated.\n     * @return The median value as a double.\n     */\n    public double median(List<Integer> l) {\n        Collections.sort(l); // Sort the list\n        int size = l.size();\n        \n        if (size % 2 == 0) { // If even number of elements\n            return ((double)l.get(size / 2 - 1) + (double)l.get(size / 2)) / 2;\n        } else { // If odd number of elements\n            return l.get(size / 2);\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        List<Integer> testList1 = Arrays.asList(3, 1, 2, 4, 5); // Expected median: 3\n        System.out.println(\"Median of \" + testList1 + \": \" + solution.median(testList1));\n        \n        List<Integer> testList2 = Arrays.asList(-10, 4, 6, 1000, 10, 20); // Expected median: (6+10)/2=8.0\n        System.out.println(\"Median of \" + testList2 + \": \" + solution.median(testList2));\n        \n        List<Integer> testList3 = Arrays.asList(7, -5, 4, 9, 12); // Expected median: 7\n        System.out.println(\"Median of \" + testList3 + \": \" + solution.median(testList3));\n    }\n}\n"}
{"task_id": "Java/48", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n\n    /**\n     * Checks if given string is a palindrome.\n     *\n     * @param text the string to check\n     * @return true if the string is a palindrome, false otherwise\n     */\n    public boolean is_palindrome(String text) {\n        int left = 0;\n        int right = text.length() - 1;\n\n        while (left < right) {\n            if (text.charAt(left) != text.charAt(right)) {\n                return false;\n            }\n            left++;\n            right--;\n        }\n\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.is_palindrome(\"\"));       // Expected: true\n        System.out.println(solution.is_palindrome(\"aba\"));    // Expected: true\n        System.out.println(solution.is_palindrome(\"aaaaa\"));  // Expected: true\n        System.out.println(solution.is_palindrome(\"zbcd\"));   // Expected: false\n    }\n}\n"}
{"task_id": "Java/49", "generation": "import org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nclass Solution {\n    /**\n     * Return 2^n modulo p (be aware of numerics).\n     *\n     * @param n the exponent\n     * @param p the modulus\n     * @return 2^n % p\n     */\n    public int modp(int n, int p) {\n        long result = 1;\n        long base = 2;\n\n        while (n > 0) {\n            if ((n & 1) == 1) { // If n is odd, multiply the result with base and take modulo\n                result = (result * base) % p;\n            }\n            base = (base * base) % p; // Square the base and take modulo\n            n >>= 1; // Divide n by 2\n        }\n\n        return (int) result;\n    }\n\n    @Test\n    public void testModp() {\n        assertEquals(3, modp(3, 5));\n        assertEquals(2, modp(1101, 101));\n        assertEquals(1, modp(0, 101));\n        assertEquals(8, modp(3, 11));\n        assertEquals(1, modp(100, 101));\n    }\n}\n"}
{"task_id": "Java/50", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Returns encoded string by shifting every character by 5 in the alphabet.\n     */\n    public String encodeShift(String s) {\n        StringBuilder sb = new StringBuilder();\n        for (char ch : s.toCharArray()) {\n            // Ensure that only lowercase letters are shifted\n            if (ch >= 'a' && ch <= 'z') {\n                sb.append((char) ('a' + ((ch - 'a' + 5) % 26)));\n            } else {\n                // If the character is not a letter, just append it as is.\n                sb.append(ch);\n            }\n        }\n        return sb.toString();\n    }\n\n    /**\n     * Takes as input string encoded with encodeShift function. Returns decoded string.\n     */\n    public String decode_shift(String s) {\n        StringBuilder sb = new StringBuilder();\n        for (char ch : s.toCharArray()) {\n            // Ensure that only lowercase letters are shifted\n            if (ch >= 'a' && ch <= 'z') {\n                sb.append((char) ('a' + ((ch - 'a' - 5 + 26) % 26)));\n            } else {\n                // If the character is not a letter, just append it as is.\n                sb.append(ch);\n            }\n        }\n        return sb.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n\n        // Test cases\n        String test1 = \"hello\";\n        String encodedTest1 = sol.encodeShift(test1);\n        System.out.println(\"Encoded: \" + encodedTest1);  // Expected: mjqqt\n\n        String decodedTest1 = sol.decode_shift(encodedTest1);\n        System.out.println(\"Decoded: \" + decodedTest1);  // Expected: hello\n\n        String test2 = \"world\";\n        String encodedTest2 = sol.encodeShift(test2);\n        System.out.println(\"Encoded: \" + encodedTest2);  // Expected: btwqi\n\n        String decodedTest2 = sol.decode_shift(encodedTest2);\n        System.out.println(\"Decoded: \" + decodedTest2);  // Expected: world\n\n        // Test with non-alphabetic characters\n        String test3 = \"java123\";\n        String encodedTest3 = sol.encodeShift(test3);\n        System.out.println(\"Encoded: \" + encodedTest3);  // Expected: ofez123\n\n        String decodedTest3 = sol.decode_shift(encodedTest3);\n        System.out.println(\"Decoded: \" + decodedTest3);  // Expected: java123\n    }\n}\n"}
{"task_id": "Java/51", "generation": "import org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nclass Solution {\n    /**\n     * remove_vowels is a function that takes string and returns string without vowels.\n     */\n    public String remove_vowels(String text) {\n        if (text == null || text.isEmpty()) return text;\n        \n        StringBuilder result = new StringBuilder();\n        for (char c : text.toCharArray()) {\n            if (!isVowel(c)) {\n                result.append(c);\n            }\n        }\n        return result.toString();\n    }\n\n    private boolean isVowel(char c) {\n        return \"AEIOUaeiou\".indexOf(c) != -1;\n    }\n\n    @Test\n    public void testRemoveVowels() {\n        assertEquals(\"\", remove_vowels(\"\"));\n        assertEquals(\"bcdf\\nghjklm\", remove_vowels(\"abcdef\\nghijklm\"));\n        assertEquals(\"bcdf\", remove_vowels(\"abcdef\"));\n        assertEquals(\"\", remove_vowels(\"aaaaa\"));\n        assertEquals(\"B\", remove_vowels(\"aaBAA\"));\n        assertEquals(\"zbcd\", remove_vowels(\"zbcd\"));\n    }\n}\n"}
{"task_id": "Java/52", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Return True if all numbers in the list l are below threshold t.\n     *\n     * @param l List of integers to check against the threshold.\n     * @param t The threshold value.\n     * @return true if all elements in l are less than t, false otherwise.\n     */\n    public boolean below_threshold(List<Integer> l, int t) {\n        for (int num : l) {\n            if (num >= t) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        List<Integer> list1 = Arrays.asList(1, 2, 4, 10);\n        int threshold1 = 100;\n        System.out.println(\"Test Case 1: \" + solution.below_threshold(list1, threshold1)); // Expected output: true\n\n        // Test case 2\n        List<Integer> list2 = Arrays.asList(1, 20, 4, 10);\n        int threshold2 = 5;\n        System.out.println(\"Test Case 2: \" + solution.below_threshold(list2, threshold2)); // Expected output: false\n\n        // Additional test cases\n        List<Integer> list3 = Arrays.asList(1, 2, 3);\n        int threshold3 = 4;\n        System.out.println(\"Test Case 3: \" + solution.below_threshold(list3, threshold3)); // Expected output: true\n\n        List<Integer> list4 = Arrays.asList(-5, -10, 0);\n        int threshold4 = 0;\n        System.out.println(\"Test Case 4: \" + solution.below_threshold(list4, threshold4)); // Expected output: false\n    }\n}\n"}
{"task_id": "Java/53", "generation": "import org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nclass Solution {\n    /**\n     * Add two numbers x and y.\n     *\n     * @param x the first number to be added\n     * @param y the second number to be added\n     * @return the sum of x and y\n     */\n    public int add(int x, int y) {\n        return x + y;\n    }\n}\n\nclass SolutionTest {\n\n    private final Solution solution = new Solution();\n\n    @Test\n    void testAdd() {\n        assertEquals(5, solution.add(2, 3), \"Adding 2 and 3 should give 5\");\n        assertEquals(12, solution.add(5, 7), \"Adding 5 and 7 should give 12\");\n    }\n}\n"}
{"task_id": "Java/54", "generation": "import java.util.HashSet;\nimport java.util.Set;\n\nclass Solution {\n    /**\n     * Check if two words have the same kind of characters.\n     *\n     * @param s0 First string to compare\n     * @param s1 Second string to compare\n     * @return true if both strings contain exactly the same set of unique characters, false otherwise\n     */\n    public boolean same_chars(String s0, String s1) {\n        Set<Character> charsInS0 = new HashSet<>();\n        for (char c : s0.toCharArray()) {\n            charsInS0.add(c);\n        }\n\n        Set<Character> charsInS1 = new HashSet<>();\n        for (char c : s1.toCharArray()) {\n            charsInS1.add(c);\n        }\n\n        return charsInS0.equals(charsInS1);\n    }\n}\n\n// Test class to verify the correctness of Solution.same_chars\nclass SolutionTest {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.same_chars(\"eabcdzzzz\", \"dddzzzzzzzddeddabc\")); // Expected: true\n        System.out.println(solution.same_chars(\"abcd\", \"dddddddabc\"));              // Expected: true\n        System.out.println(solution.same_chars(\"dddddddabc\", \"abcd\"));              // Expected: true\n        System.out.println(solution.same_chars(\"eabcd\", \"dddddddabc\"));             // Expected: false\n        System.out.println(solution.same_chars(\"abcd\", \"dddddddabce\"));             // Expected: false\n        System.out.println(solution.same_chars(\"eabcdzzzz\", \"dddzzzzzzzddddabc\"));  // Expected: false\n    }\n}\n"}
{"task_id": "Java/55", "generation": "import org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nclass Solution {\n    /**\n     * Return n-th Fibonacci number.\n     *\n     * @param n the position in the Fibonacci sequence\n     * @return the n-th Fibonacci number\n     */\n    public int fib(int n) {\n        if (n <= 1) {\n            return n;\n        }\n        int a = 0, b = 1, c;\n        for (int i = 2; i <= n; i++) {\n            c = a + b;\n            a = b;\n            b = c;\n        }\n        return b;\n    }\n\n    @Test\n    public void testFib() {\n        assertEquals(55, fib(10));\n        assertEquals(1, fib(1));\n        assertEquals(21, fib(8));\n        // Additional tests can be added here\n    }\n}\n"}
{"task_id": "Java/56", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Checks if every opening bracket '<' in the string has a corresponding closing bracket '>'.\n     *\n     * @param brackets A string containing only '<' and '>' characters.\n     * @return true if every '<' has a matching '>', false otherwise.\n     */\n    public boolean correct_bracketing(String brackets) {\n        int balance = 0;\n        \n        for (char c : brackets.toCharArray()) {\n            if (c == '<') {\n                balance++;\n            } else if (c == '>') {\n                balance--;\n                // If balance is negative, it means there's a closing bracket without an opening one\n                if (balance < 0) {\n                    return false;\n                }\n            }\n        }\n        \n        // At the end of the loop, balance should be zero for correct bracketing\n        return balance == 0;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.correct_bracketing(\"<\"));       // Expected: false\n        System.out.println(solution.correct_bracketing(\"<>\"));      // Expected: true\n        System.out.println(solution.correct_bracketing(\"<<><>>\"));  // Expected: true\n        System.out.println(solution.correct_bracketing(\"><<>\"));    // Expected: false\n    }\n}\n"}
{"task_id": "Java/57", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Return True if list elements are monotonically increasing or decreasing.\n     */\n    public boolean monotonic(List<Integer> l) {\n        if (l == null || l.size() <= 1) return true;\n\n        boolean increasing = false;\n        boolean decreasing = false;\n\n        for (int i = 1; i < l.size(); i++) {\n            if (l.get(i) > l.get(i - 1)) increasing = true;\n            else if (l.get(i) < l.get(i - 1)) decreasing = true;\n\n            // If both flags are set, the list is neither strictly increasing nor decreasing\n            if (increasing && decreasing) return false;\n        }\n\n        return true; // The list is either monotonically increasing or decreasing.\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.monotonic(Arrays.asList(1, 2, 4, 20))); // Expected: true\n        System.out.println(solution.monotonic(Arrays.asList(1, 20, 4, 10))); // Expected: false\n        System.out.println(solution.monotonic(Arrays.asList(4, 1, 0, -10))); // Expected: true\n        System.out.println(solution.monotonic(Arrays.asList(5, 5, 5, 5)));   // Expected: true (constant list)\n    }\n}\n"}
{"task_id": "Java/58", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Return sorted unique common elements for two lists.\n     *\n     * @param l1 First list of integers\n     * @param l2 Second list of integers\n     * @return A List containing the sorted unique common elements between l1 and l2\n     */\n    public List<Integer> common(List<Integer> l1, List<Integer> l2) {\n        // Convert lists to sets for efficient lookup\n        Set<Integer> set1 = new HashSet<>(l1);\n        Set<Integer> set2 = new HashSet<>(l2);\n\n        // Retain only elements that are in both sets\n        set1.retainAll(set2);\n\n        // Convert the result back to a list and sort it\n        List<Integer> result = new ArrayList<>(set1);\n        Collections.sort(result);\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        System.out.println(solution.common(Arrays.asList(1, 4, 3, 34, 653, 2, 5), Arrays.asList(5, 7, 1, 5, 9, 653, 121)));\n        // Expected output: [1, 5, 653]\n\n        // Test case 2\n        System.out.println(solution.common(Arrays.asList(5, 3, 2, 8), Arrays.asList(3, 2)));\n        // Expected output: [2, 3]\n    }\n}\n"}
{"task_id": "Java/59", "generation": "class Solution {\n    /**\n     * Return the largest prime factor of n. Assume n > 1 and is not a prime.\n     *\n     * @param n The input number to find the largest prime factor for.\n     * @return The largest prime factor of n.\n     */\n    public int largest_prime_factor(int n) {\n        int maxPrime = -1;\n\n        // Divide n by 2 until it's no longer divisible\n        while (n % 2 == 0) {\n            maxPrime = 2;\n            n /= 2;\n        }\n\n        // Now we only have to deal with odd factors\n        for (int factor = 3; factor * factor <= n; factor += 2) {\n            while (n % factor == 0) {\n                maxPrime = factor;\n                n = n / factor;\n            }\n        }\n\n        // This condition is to handle the case when n is a prime number\n        // greater than 2\n        if (n > 2)\n            maxPrime = n;\n\n        return maxPrime;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.largest_prime_factor(13195)); // Expected output: 29\n        System.out.println(solution.largest_prime_factor(2048));  // Expected output: 2\n    }\n}\n"}
{"task_id": "Java/60", "generation": "import org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nclass Solution {\n    /**\n     * sum_to_n is a function that sums numbers from 1 to n.\n     *\n     * @param n the upper limit number to sum up to\n     * @return the sum of all integers from 1 to n inclusive\n     */\n    public int sum_to_n(int n) {\n        return (n * (n + 1)) / 2; // Using the arithmetic series sum formula\n    }\n\n    /**\n     * Test cases for sum_to_n function.\n     */\n    @Test\n    public void testSumToN() {\n        assertEquals(465, sum_to_n(30), \"Expected sum of numbers from 1 to 30 is 465\");\n        assertEquals(5050, sum_to_n(100), \"Expected sum of numbers from 1 to 100 is 5050\");\n        assertEquals(15, sum_to_n(5), \"Expected sum of numbers from 1 to 5 is 15\");\n        assertEquals(55, sum_to_n(10), \"Expected sum of numbers from 1 to 10 is 55\");\n        assertEquals(1, sum_to_n(1), \"Expected sum of numbers from 1 to 1 is 1\");\n    }\n}\n"}
{"task_id": "Java/61", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Checks if every opening bracket has a corresponding closing bracket.\n     *\n     * @param brackets A string containing only '(' and ')'.\n     * @return true if every '(' has a corresponding ')', false otherwise.\n     */\n    public boolean correct_bracketing(String brackets) {\n        int balance = 0;\n        \n        for (int i = 0; i < brackets.length(); i++) {\n            char c = brackets.charAt(i);\n            \n            if (c == '(') {\n                balance++;\n            } else if (c == ')') {\n                balance--;\n                \n                // If balance is negative, there are more closing brackets than opening ones\n                if (balance < 0) {\n                    return false;\n                }\n            }\n        }\n        \n        // If balance is zero, all opening brackets have corresponding closing brackets\n        return balance == 0;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.correct_bracketing(\"(\"));     // Expected: false\n        System.out.println(solution.correct_bracketing(\"()\"));    // Expected: true\n        System.out.println(solution.correct_bracketing(\"(()())\"));// Expected: true\n        System.out.println(solution.correct_bracketing(\")(()\"));  // Expected: false\n    }\n}\n"}
{"task_id": "Java/62", "generation": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\nclass Solution {\n    /**\n     * Computes the derivative of a polynomial represented by its coefficients.\n     *\n     * @param xs List of integers representing the coefficients of the polynomial.\n     *           The list is ordered from the constant term to the highest degree term.\n     * @return A list of integers representing the coefficients of the derivative polynomial.\n     */\n    public List<Integer> derivative(List<Integer> xs) {\n        if (xs == null || xs.size() <= 1) return new ArrayList<>();\n        \n        List<Integer> result = new ArrayList<>();\n        for (int i = 1; i < xs.size(); i++) {\n            result.add(xs.get(i) * i);\n        }\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case 1\n        List<Integer> test1Input = Arrays.asList(3, 1, 2, 4, 5);\n        List<Integer> expected1Output = Arrays.asList(1, 4, 12, 20);\n        System.out.println(\"Test Case 1: \" + solution.derivative(test1Input).equals(expected1Output));\n        \n        // Test case 2\n        List<Integer> test2Input = Arrays.asList(1, 2, 3);\n        List<Integer> expected2Output = Arrays.asList(2, 6);\n        System.out.println(\"Test Case 2: \" + solution.derivative(test2Input).equals(expected2Output));\n        \n        // Test case 3 - Edge case with only one coefficient\n        List<Integer> test3Input = Arrays.asList(5); // Derivative of a constant is zero (empty list)\n        List<Integer> expected3Output = new ArrayList<>();\n        System.out.println(\"Test Case 3: \" + solution.derivative(test3Input).equals(expected3Output));\n        \n        // Test case 4 - Edge case with null input\n        List<Integer> test4Input = null;\n        List<Integer> expected4Output = new ArrayList<>();\n        System.out.println(\"Test Case 4: \" + solution.derivative(test4Input).equals(expected4Output));\n    }\n}\n"}
{"task_id": "Java/63", "generation": "import java.util.*;\n\nclass Solution {\n\n    public int fibfib(int n) {\n        if (n == 0 || n == 1) return 0;\n        if (n == 2) return 1;\n\n        // Initialize an array to store computed values of the sequence.\n        int[] dp = new int[n + 1];\n        dp[0] = 0; // fibfib(0)\n        dp[1] = 0; // fibfib(1)\n        dp[2] = 1; // fibfib(2)\n\n        for (int i = 3; i <= n; ++i) {\n            dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3];\n        }\n\n        return dp[n];\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.fibfib(1)); // Expected output: 0\n        System.out.println(solution.fibfib(5)); // Expected output: 4\n        System.out.println(solution.fibfib(8)); // Expected output: 24\n\n        // Additional test cases for verification\n        System.out.println(solution.fibfib(3)); // Expected output: 1 (0 + 0 + 1)\n        System.out.println(solution.fibfib(6)); // Expected output: 7 (4 + 1 + 2)\n    }\n}\n"}
{"task_id": "Java/64", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Returns the number of vowels in the string. Vowels are 'a', 'e', 'i', 'o', 'u'.\n     * Additionally, 'y' is considered a vowel only if it is at the end of the word.\n     *\n     * @param s The input string representing a word\n     * @return The number of vowels in the string\n     */\n    public int vowels_count(String s) {\n        // Convert to lower case for simplicity\n        String str = s.toLowerCase();\n        int count = 0;\n        \n        // Check each character if it is a vowel\n        for (int i = 0; i < str.length(); i++) {\n            char c = str.charAt(i);\n            if (\"aeiou\".indexOf(c) >= 0) {\n                count++;\n            }\n            // Special case: 'y' at the end of the string\n            else if (c == 'y' && i == str.length() - 1) {\n                count++;\n            }\n        }\n\n        return count;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases to verify the correctness of the function\n        System.out.println(solution.vowels_count(\"abcde\")); // Expected output: 2\n        System.out.println(solution.vowels_count(\"ACEDY\")); // Expected output: 3\n        System.out.println(solution.vowels_count(\"rhythm\")); // Expected output: 0 (no vowels, 'y' is not at the end)\n        System.out.println(solution.vowels_count(\"sky\"));    // Expected output: 1 ('y' at the end counts as a vowel)\n        System.out.println(solution.vowels_count(\"AEIOU\"));  // Expected output: 5\n        System.out.println(solution.vowels_count(\"bcdfg\"));  // Expected output: 0 (no vowels)\n    }\n}\n"}
{"task_id": "Java/65", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Circular shift the digits of the integer x, shifting the digits right by shift.\n     * If shift > number of digits, return digits reversed.\n     *\n     * @param x The integer to be shifted.\n     * @param shift The number of positions to shift the digits.\n     * @return A string representing the result after circular shift or reversal.\n     */\n    public String circular_shift(int x, int shift) {\n        String strX = Integer.toString(x);\n        int len = strX.length();\n        \n        // If shift is greater than length, reverse the number\n        if (shift >= len) {\n            return new StringBuilder(strX).reverse().toString();\n        }\n        \n        // Perform circular shift\n        shift %= len;  // To handle shifts larger than the string length but less than reversing it.\n        String shifted = strX.substring(len - shift) + strX.substring(0, len - shift);\n        return shifted;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.circular_shift(12, 1).equals(\"21\") ? \"Test 1 Passed\" : \"Test 1 Failed\");\n        System.out.println(solution.circular_shift(12, 2).equals(\"12\") ? \"Test 2 Passed\" : \"Test 2 Failed\");\n        System.out.println(solution.circular_shift(12345, 7).equals(\"54321\") ? \"Test 3 Passed\" : \"Test 3 Failed\"); // Shift > length\n        System.out.println(solution.circular_shift(98765, 3).equals(\"65987\") ? \"Test 4 Passed\" : \"Test 4 Failed\");\n    }\n}\n"}
{"task_id": "Java/66", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Returns the sum of ASCII codes of uppercase characters in the given string.\n     */\n    public int digitSum(String s) {\n        if (s == null || s.isEmpty()) return 0;\n\n        int sum = 0;\n        for (char c : s.toCharArray()) {\n            if (Character.isUpperCase(c)) {\n                sum += (int)c;\n            }\n        }\n\n        return sum;\n    }\n}\n\n// Test cases using JUnit\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\n\nclass SolutionTest {\n\n    @Test\n    public void testEmptyString() {\n        assertEquals(0, new Solution().digitSum(\"\"));\n    }\n\n    @Test\n    public void testMixedCase1() {\n        assertEquals(131, new Solution().digitSum(\"abAB\"));\n    }\n\n    @Test\n    public void testMixedCase2() {\n        assertEquals(67, new Solution().digitSum(\"abcCd\"));\n    }\n\n    @Test\n    public void testSingleUpperCase() {\n        assertEquals(69, new Solution().digitSum(\"helloE\"));\n    }\n\n    @Test\n    public void testMultipleUppercase1() {\n        assertEquals(131, new Solution().digitSum(\"woArBld\"));\n    }\n\n    @Test\n    public void testMultipleUppercase2() {\n        assertEquals(153, new Solution().digitSum(\"aAaaaXa\"));\n    }\n}\n"}
{"task_id": "Java/67", "generation": "import java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nclass Solution {\n    /**\n     * In this task, you will be given a string that represents a number of apples and oranges\n     * that are distributed in a basket of fruit this basket contains\n     * apples, oranges, and mango fruits. Given the string that represents the total number of\n     * the oranges and apples and an integer that represent the total number of the fruits\n     * in the basket return the number of the mango fruits in the basket.\n     */\n    public int fruit_distribution(String s, int n) {\n        // Use regex to find numbers for apples and oranges\n        Pattern pattern = Pattern.compile(\"(\\\\d+)\\\\sapples\\\\sand\\\\s(\\\\d+)\\\\soranges\");\n        Matcher matcher = pattern.matcher(s);\n        \n        if (matcher.find()) {\n            int apples = Integer.parseInt(matcher.group(1));\n            int oranges = Integer.parseInt(matcher.group(2));\n            \n            // Calculate the number of mangoes\n            return n - (apples + oranges);\n        }\n        \n        throw new IllegalArgumentException(\"Input string does not match expected format.\");\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.fruit_distribution(\"5 apples and 6 oranges\", 19)); // Expected output: 8\n        System.out.println(solution.fruit_distribution(\"0 apples and 1 oranges\", 3));   // Expected output: 2\n        System.out.println(solution.fruit_distribution(\"2 apples and 3 oranges\", 100)); // Expected output: 95\n        System.out.println(solution.fruit_distribution(\"100 apples and 1 oranges\", 120)); // Expected output: 19\n    }\n}\n"}
{"task_id": "Java/68", "generation": "import java.util.*;\n\nclass Solution {\n    public List<Integer> pluck(List<Integer> arr) {\n        int smallestEven = Integer.MAX_VALUE;\n        int smallestIndex = -1;\n\n        for (int i = 0; i < arr.size(); i++) {\n            int value = arr.get(i);\n            if (value % 2 == 0 && value <= smallestEven) {\n                if (value < smallestEven || smallestIndex == -1) {\n                    smallestEven = value;\n                    smallestIndex = i;\n                }\n            }\n        }\n\n        if (smallestIndex == -1) {\n            return new ArrayList<>();\n        } else {\n            List<Integer> result = new ArrayList<>();\n            result.add(smallestEven);\n            result.add(smallestIndex);\n            return result;\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.pluck(Arrays.asList(4, 2, 3))); // [2, 1]\n        System.out.println(solution.pluck(Arrays.asList(1, 2, 3))); // [2, 1]\n        System.out.println(solution.pluck(new ArrayList<>()));      // []\n        System.out.println(solution.pluck(Arrays.asList(5, 0, 3, 0, 4, 2))); // [0, 1]\n    }\n}\n"}
{"task_id": "Java/69", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int search(List<Integer> lst) {\n        // Create a map to store frequency of each number\n        Map<Integer, Integer> freqMap = new HashMap<>();\n        \n        // Populate the frequency map\n        for (int num : lst) {\n            freqMap.put(num, freqMap.getOrDefault(num, 0) + 1);\n        }\n        \n        int result = -1;\n        \n        // Check each entry in the map to find if its frequency is >= its value\n        for (Map.Entry<Integer, Integer> entry : freqMap.entrySet()) {\n            if (entry.getKey() <= entry.getValue()) {\n                result = Math.max(result, entry.getKey());\n            }\n        }\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.search(Arrays.asList(4, 1, 2, 2, 3, 1))); // Expected output: 2\n        System.out.println(solution.search(Arrays.asList(1, 2, 2, 3, 3, 3, 4, 4, 4))); // Expected output: 3\n        System.out.println(solution.search(Arrays.asList(5, 5, 4, 4, 4))); // Expected output: -1\n    }\n}\n"}
{"task_id": "Java/70", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given list of integers, return list in strange order.\n     * Strange sorting, is when you start with the minimum value,\n     * then maximum of the remaining integers, then minimum and so on.\n     *\n     * Examples:\n     * strange_sort_list(Arrays.asList(1, 2, 3, 4)) == Arrays.asList(1, 4, 2, 3)\n     * strange_sort_list(Arrays.asList(5, 5, 5, 5)) == Arrays.asList(5, 5, 5, 5)\n     * strange_sort_list(Arrays.asList()) == Arrays.asList()\n     */\n    public List<Integer> strange_sort_list(List<Integer> lst) {\n        if (lst.isEmpty()) return new ArrayList<>();\n        \n        List<Integer> result = new ArrayList<>();\n        Collections.sort(lst);\n        \n        int left = 0;\n        int right = lst.size() - 1;\n        \n        while (left <= right) {\n            if (left == right) {\n                result.add(lst.get(left));\n                break;\n            }\n            \n            result.add(lst.get(left++)); // Add the minimum\n            result.add(lst.get(right--)); // Add the maximum\n        }\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.strange_sort_list(Arrays.asList(1, 2, 3, 4))); // [1, 4, 2, 3]\n        System.out.println(solution.strange_sort_list(Arrays.asList(5, 5, 5, 5))); // [5, 5, 5, 5]\n        System.out.println(solution.strange_sort_list(new ArrayList<>())); // []\n    }\n}\n"}
{"task_id": "Java/71", "generation": "import org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nclass Solution {\n    /**\n     * Given the lengths of the three sides of a triangle.\n     * Return the area of the triangle rounded to 2 decimal points if the three sides form a valid triangle.\n     * Otherwise return -1\n     * Three sides make a valid triangle when the sum of any two sides is greater than the third side.\n     */\n    public double triangle_area(double a, double b, double c) {\n        // Check for validity of the triangle\n        if (a + b <= c || a + c <= b || b + c <= a) {\n            return -1;\n        }\n        \n        // Calculate semi-perimeter\n        double s = (a + b + c) / 2.0;\n\n        // Heron's formula to calculate the area of the triangle\n        double area = Math.sqrt(s * (s - a) * (s - b) * (s - c));\n        \n        return Math.round(area * 100.0) / 100.0; // Round to two decimal places\n    }\n\n    @Test\n    public void testTriangleArea() {\n        assertEquals(6.00, triangle_area(3, 4, 5), \"Should calculate the area of a valid triangle\");\n        assertEquals(-1, triangle_area(1, 2, 10), \"Should return -1 for invalid triangles\");\n        assertEquals(8.19, triangle_area(7, 8, 9), \"Should calculate the area with precision to two decimal places\");\n    }\n}\n"}
{"task_id": "Java/72", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Checks if an object q will fly based on balance and weight.\n     *\n     * @param q A list representing the object's elements.\n     * @param w The maximum possible weight for the object to fly.\n     * @return True if the object is balanced (palindromic) and its sum is less than or equal to w, false otherwise.\n     */\n    public boolean will_it_fly(List<Integer> q, int w) {\n        // Check if the list is a palindrome\n        for (int i = 0; i < q.size() / 2; i++) {\n            if (!q.get(i).equals(q.get(q.size() - 1 - i))) {\n                return false;\n            }\n        }\n\n        // Calculate sum of elements in the list\n        int sum = 0;\n        for (int num : q) {\n            sum += num;\n        }\n\n        // Check if the sum is less than or equal to w\n        return sum <= w;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.will_it_fly(Arrays.asList(1, 2), 5)); // false\n        System.out.println(solution.will_it_fly(Arrays.asList(3, 2, 3), 1)); // false\n        System.out.println(solution.will_it_fly(Arrays.asList(3, 2, 3), 9)); // true\n        System.out.println(solution.will_it_fly(Arrays.asList(3), 5)); // true\n    }\n}\n"}
{"task_id": "Java/73", "generation": "import java.util.*;\n\nclass Solution {\n    public int smallest_change(List<Integer> arr) {\n        if (arr == null || arr.size() <= 1) return 0;\n\n        int changes = 0;\n        int left = 0, right = arr.size() - 1;\n\n        while (left < right) {\n            if (!arr.get(left).equals(arr.get(right))) {\n                changes++;\n            }\n            left++;\n            right--;\n        }\n\n        return changes;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        List<Integer> arr1 = Arrays.asList(1, 2, 3, 5, 4, 7, 9, 6);\n        System.out.println(\"Test Case 1: \" + (solution.smallest_change(arr1) == 4 ? \"Pass\" : \"Fail\"));\n\n        // Test case 2\n        List<Integer> arr2 = Arrays.asList(1, 2, 3, 4, 3, 2, 2);\n        System.out.println(\"Test Case 2: \" + (solution.smallest_change(arr2) == 1 ? \"Pass\" : \"Fail\"));\n\n        // Test case 3\n        List<Integer> arr3 = Arrays.asList(1, 2, 3, 2, 1);\n        System.out.println(\"Test Case 3: \" + (solution.smallest_change(arr3) == 0 ? \"Pass\" : \"Fail\"));\n    }\n}\n"}
{"task_id": "Java/74", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Compares two lists of strings and returns the one with fewer total characters.\n     * If both have the same number of characters, it returns the first list.\n     *\n     * @param lst1 First list of strings\n     * @param lst2 Second list of strings\n     * @return The list with fewer total characters or the first list if equal\n     */\n    public List<String> total_match(List<String> lst1, List<String> lst2) {\n        int count1 = 0;\n        for (String s : lst1) {\n            count1 += s.length();\n        }\n\n        int count2 = 0;\n        for (String s : lst2) {\n            count2 += s.length();\n        }\n\n        if (count1 <= count2) {\n            return lst1;\n        } else {\n            return lst2;\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.total_match(Arrays.asList(), Arrays.asList())); // -> []\n        System.out.println(solution.total_match(Arrays.asList(\"hi\", \"admin\"), Arrays.asList(\"hI\", \"Hi\"))); // -> [\"hI\", \"Hi\"]\n        System.out.println(solution.total_match(Arrays.asList(\"hi\", \"admin\"), Arrays.asList(\"hi\", \"hi\", \"admin\", \"project\"))); // -> [\"hi\", \"admin\"]\n        System.out.println(solution.total_match(Arrays.asList(\"hi\", \"admin\"), Arrays.asList(\"hI\", \"hi\", \"hi\"))); // -> [\"hI\", \"hi\", \"hi\"]\n        System.out.println(solution.total_match(Arrays.asList(\"4\"), Arrays.asList(\"1\", \"2\", \"3\", \"4\", \"5\"))); // -> [\"4\"]\n    }\n}\n"}
{"task_id": "Java/75", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Returns true if the given number is the multiplication of 3 prime numbers,\n     * and false otherwise. Knowing that the prime number is less than 100.\n     */\n    public boolean is_multiply_prime(int a) {\n        // Generate all primes less than 100\n        List<Integer> primes = generatePrimes(100);\n        \n        for (int i : primes) {\n            if (a % i == 0) {\n                int b = a / i;\n                for (int j : primes) {\n                    if (b % j == 0 && b / j > 1) { // Ensure the third factor is also prime\n                        int k = b / j;\n                        if (primes.contains(k)) {\n                            return true; // Found three prime factors\n                        }\n                    }\n                }\n            }\n        }\n        \n        return false; // No such combination found\n    }\n\n    private List<Integer> generatePrimes(int max) {\n        boolean[] isPrime = new boolean[max + 1];\n        Arrays.fill(isPrime, true);\n        for (int i = 2; i * i <= max; i++) {\n            if (isPrime[i]) {\n                for (int j = i * i; j <= max; j += i) {\n                    isPrime[j] = false;\n                }\n            }\n        }\n\n        List<Integer> primes = new ArrayList<>();\n        for (int i = 2; i < max; i++) {\n            if (isPrime[i]) {\n                primes.add(i);\n            }\n        }\n        \n        return primes;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.is_multiply_prime(30));  // true, because 2 * 3 * 5 = 30\n        System.out.println(solution.is_multiply_prime(60));  // true, because 2 * 3 * 10 (but 10 is not prime), so false.\n        System.out.println(solution.is_multiply_prime(78));  // true, because 2 * 3 * 13 = 78\n        System.out.println(solution.is_multiply_prime(100)); // false, no three primes multiply to give 100\n    }\n}\n"}
{"task_id": "Java/76", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Checks if x is a simple power of n.\n     *\n     * @param x The number to check.\n     * @param n The base number.\n     * @return true if x is a simple power of n, false otherwise.\n     */\n    public boolean is_simple_power(int x, int n) {\n        // Special case: any number to the power of 0 is 1\n        if (x == 1) return n == 1;\n        \n        // Special case: 0 can only be a simple power of itself\n        if (n == 0) return x == 0;\n\n        int temp = 1;\n        while (temp < x) {\n            temp *= n;\n        }\n        return temp == x;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.is_simple_power(1, 4)); // true\n        System.out.println(solution.is_simple_power(2, 2)); // true\n        System.out.println(solution.is_simple_power(8, 2)); // true\n        System.out.println(solution.is_simple_power(3, 2)); // false\n        System.out.println(solution.is_simple_power(3, 1)); // false\n        System.out.println(solution.is_simple_power(5, 3)); // false\n        \n        // Additional test cases\n        System.out.println(solution.is_simple_power(9, 3)); // true\n        System.out.println(solution.is_simple_power(27, 3)); // true\n        System.out.println(solution.is_simple_power(0, 1)); // false\n        System.out.println(solution.is_simple_power(1, 0)); // false\n    }\n}\n"}
{"task_id": "Java/77", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Checks if the provided integer 'a' is a perfect cube.\n     *\n     * @param a The integer to check.\n     * @return true if 'a' is a perfect cube, false otherwise.\n     */\n    public boolean iscube(int a) {\n        double cubeRoot = Math.cbrt(a);\n        return (Math.round(cubeRoot) - cubeRoot) == 0;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.iscube(1));   // true\n        System.out.println(solution.iscube(2));   // false\n        System.out.println(solution.iscube(-1));  // true\n        System.out.println(solution.iscube(64));  // true\n        System.out.println(solution.iscube(0));   // true\n        System.out.println(solution.iscube(180)); // false\n    }\n}\n"}
{"task_id": "Java/78", "generation": "class Solution {\n    public int hex_key(String num) {\n        // Set containing prime hexadecimal digits.\n        Set<Character> primes = new HashSet<>(Arrays.asList('2', '3', '5', '7', 'B', 'D'));\n        \n        int count = 0;\n        for (char c : num.toCharArray()) {\n            if (primes.contains(c)) {\n                count++;\n            }\n        }\n        return count;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.hex_key(\"AB\"));          // Output: 1\n        System.out.println(solution.hex_key(\"1077E\"));       // Output: 2\n        System.out.println(solution.hex_key(\"ABED1A33\"));    // Output: 4\n        System.out.println(solution.hex_key(\"123456789ABCDEF0\")); // Output: 6\n        System.out.println(solution.hex_key(\"2020\"));        // Output: 2\n    }\n}\n"}
{"task_id": "Java/79", "generation": "class Solution {\n    /**\n     * Converts a given decimal number into its binary format.\n     * Adds 'db' at the beginning and end of the returned string.\n     *\n     * @param decimal The decimal number to convert.\n     * @return A string representing the binary form with 'db' prepended and appended.\n     */\n    public String decimal_to_binary(int decimal) {\n        // Convert the decimal number to a binary string\n        String binaryString = Integer.toBinaryString(decimal);\n        \n        // Add 'db' at both ends of the binary string\n        return \"db\" + binaryString + \"db\";\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases to verify the correctness of the function\n        System.out.println(solution.decimal_to_binary(15));  // Expected output: db1111db\n        System.out.println(solution.decimal_to_binary(32));  // Expected output: db100000db\n    }\n}\n"}
{"task_id": "Java/80", "generation": "class Solution {\n    /**\n     * Checks if a given string is happy.\n     * A string is considered happy if it has at least 3 characters and every set of three consecutive characters are distinct.\n     *\n     * @param s the input string\n     * @return true if the string is happy, false otherwise\n     */\n    public boolean is_happy(String s) {\n        // Check if the length of the string is less than 3\n        if (s.length() < 3) return false;\n\n        // Iterate through the string to check every set of three consecutive characters\n        for (int i = 0; i <= s.length() - 3; i++) {\n            char first = s.charAt(i);\n            char second = s.charAt(i + 1);\n            char third = s.charAt(i + 2);\n\n            // If any two out of the three characters are the same, return false\n            if (first == second || first == third || second == third) {\n                return false;\n            }\n        }\n\n        // If all sets of three consecutive characters are distinct, return true\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases to verify the correctness of the is_happy method\n        System.out.println(solution.is_happy(\"a\"));      // Expected: false\n        System.out.println(solution.is_happy(\"aa\"));     // Expected: false\n        System.out.println(solution.is_happy(\"abcd\"));   // Expected: true\n        System.out.println(solution.is_happy(\"aabb\"));   // Expected: false\n        System.out.println(solution.is_happy(\"adb\"));    // Expected: true\n        System.out.println(solution.is_happy(\"xyy\"));    // Expected: false\n    }\n}\n"}
{"task_id": "Java/81", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Converts a list of numerical GPA values to their corresponding letter grades.\n     *\n     * @param grades List<Double> containing GPA values.\n     * @return A List<String> containing the letter grades for each GPA value.\n     */\n    public List<String> numerical_letter_grade(List<Double> grades) {\n        List<String> result = new ArrayList<>();\n        \n        for (Double gpa : grades) {\n            if (gpa >= 4.0) {\n                result.add(\"A+\");\n            } else if (gpa > 3.7) {\n                result.add(\"A\");\n            } else if (gpa > 3.3) {\n                result.add(\"A-\");\n            } else if (gpa > 3.0) {\n                result.add(\"B+\");\n            } else if (gpa > 2.7) {\n                result.add(\"B\");\n            } else if (gpa > 2.3) {\n                result.add(\"B-\");\n            } else if (gpa > 2.0) {\n                result.add(\"C+\");\n            } else if (gpa > 1.7) {\n                result.add(\"C\");\n            } else if (gpa > 1.3) {\n                result.add(\"C-\");\n            } else if (gpa > 1.0) {\n                result.add(\"D+\");\n            } else if (gpa > 0.7) {\n                result.add(\"D\");\n            } else if (gpa > 0.0) {\n                result.add(\"D-\");\n            } else {\n                result.add(\"E\");\n            }\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case\n        List<Double> testGrades = Arrays.asList(4.0, 3.0, 1.7, 2.0, 3.5);\n        List<String> expectedOutput = Arrays.asList(\"A+\", \"B\", \"C-\", \"C\", \"A-\");\n        \n        // Call the function and print the result\n        List<String> output = solution.numerical_letter_grade(testGrades);\n        System.out.println(output);\n\n        // Check if the output matches the expected output\n        boolean isCorrect = output.equals(expectedOutput);\n        System.out.println(\"Test Passed: \" + isCorrect);\n    }\n}\n"}
{"task_id": "Java/82", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    \n    /**\n     * Checks if the length of the given string is a prime number.\n     *\n     * @param str The input string.\n     * @return true if the string's length is a prime number, false otherwise.\n     */\n    public boolean prime_length(String str) {\n        int n = str.length();\n        \n        // 0 and 1 are not prime numbers\n        if (n <= 1) return false;\n        \n        // Check for factors from 2 to sqrt(n)\n        for (int i = 2; i * i <= n; i++) {\n            if (n % i == 0) return false;\n        }\n        \n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.prime_length(\"Hello\"));   // Expected: true\n        System.out.println(solution.prime_length(\"abcdcba\")); // Expected: true\n        System.out.println(solution.prime_length(\"kittens\")); // Expected: true\n        System.out.println(solution.prime_length(\"orange\"));  // Expected: false\n        \n        // Additional test cases\n        System.out.println(solution.prime_length(\"a\"));       // Expected: false (length is 1)\n        System.out.println(solution.prime_length(\"ab\"));      // Expected: true (length is 2, which is prime)\n    }\n}\n"}
{"task_id": "Java/83", "generation": "class Solution {\n    /**\n     * Given a positive integer n, return the count of the numbers of n-digit\n     * positive integers that start or end with 1.\n     */\n    public int startsOneEnds(int n) {\n        if (n == 1) {\n            // If n is 1, there's only one number: 1 itself.\n            return 1;\n        }\n        \n        // Count numbers starting with 1\n        long startWithOne = (long)Math.pow(10, n - 1);\n        \n        // Count numbers ending with 1\n        long endWithOne = (long)Math.pow(10, n - 1);\n        \n        // Count numbers that both start and end with 1\n        long startAndEndWithOne = (n > 2) ? (long)Math.pow(10, n - 2) : 1;\n        \n        // Total count is the sum of those starting or ending with 1,\n        // minus those counted twice.\n        return (int)(startWithOne + endWithOne - startAndEndWithOne);\n    }\n    \n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.startsOneEnds(1));  // Expected output: 1\n        System.out.println(solution.startsOneEnds(2));  // Expected output: 19 (10-19 and 1, 11)\n        System.out.println(solution.startsOneEnds(3));  // Expected output: 180 (100-199 and 1xx, x1x, xx1 excluding overlaps)\n    }\n}\n"}
{"task_id": "Java/84", "generation": "class Solution {\n    /**\n     * Given a positive integer N, return in binary the total sum of its digits.\n     *\n     * @param N integer (Constraints: 0 <= N <= 10000)\n     * @return a string representing the binary number\n     */\n    public String solve(int N) {\n        int sum = 0;\n        \n        // Calculate the sum of digits\n        while (N > 0) {\n            sum += N % 10;   // Add the last digit to sum\n            N /= 10;         // Remove the last digit from N\n        }\n        \n        // Convert the sum into binary and return as a string\n        return Integer.toBinaryString(sum);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases to verify the correctness of the method\n        System.out.println(solution.solve(1000));  // Expected output: \"1\"\n        System.out.println(solution.solve(150));   // Expected output: \"110\"\n        System.out.println(solution.solve(147));   // Expected output: \"1100\"\n    }\n}\n"}
{"task_id": "Java/85", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given a non-empty list of integers lst. add the even elements that are at odd indices.\n     *\n     * Examples:\n     *      add(Arrays.asList(4, 2, 6, 7)) ==> 2\n     */\n    public int add(List<Integer> lst) {\n        if (lst == null || lst.isEmpty()) return 0;\n\n        int sum = 0;\n        // Start from index 1 (the second element in the list), which is an odd index.\n        for (int i = 1; i < lst.size(); i += 2) { // Increment by 2 to stay at odd indices\n            if (lst.get(i) % 2 == 0) {\n                sum += lst.get(i);\n            }\n        }\n\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.add(Arrays.asList(4, 2, 6, 7))); // Expected output: 2\n        System.out.println(solution.add(Arrays.asList(1, 3, 5, 7, 9, 10))); // Expected output: 0 (no even elements at odd indices)\n        System.out.println(solution.add(Arrays.asList(2, 4, 6, 8, 10))); // Expected output: 12 (4 + 8)\n    }\n}\n"}
{"task_id": "Java/86", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Reorders each word in a given sentence so that characters within each word are sorted.\n     *\n     * @param s The input string to be processed.\n     * @return A new string where each word's characters are sorted.\n     */\n    public String anti_shuffle(String s) {\n        // Split the string into words based on spaces\n        String[] words = s.split(\" \");\n        \n        StringBuilder result = new StringBuilder();\n        \n        for (String word : words) {\n            char[] chars = word.toCharArray();\n            \n            // Sort characters in each word\n            Arrays.sort(chars);\n            \n            // Append sorted word to the result, followed by a space\n            result.append(new String(chars)).append(\" \");\n        }\n        \n        // Remove the trailing space and return the final string\n        return result.toString().trim();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.anti_shuffle(\"Hi\"));  // Expected: \"Hi\"\n        System.out.println(solution.anti_shuffle(\"hello\"));  // Expected: \"ehllo\"\n        System.out.println(solution.anti_shuffle(\"Hello World!!!\"));  // Expected: \"Hello !!!Wdlor\"\n        \n        // Additional test cases\n        System.out.println(solution.anti_shuffle(\"Programming is fun!\"));  // Expected: \"Pamgimnogr !fi nsu\"\n        System.out.println(solution.anti_shuffle(\"Java and Python\"));  // Expected: \"Jaaad !nohtPy\"\n    }\n}\n"}
{"task_id": "Java/87", "generation": "import java.util.*;\n\nclass Solution {\n    public List<List<Integer>> get_row(List<List<Integer>> lst, int x) {\n        List<List<Integer>> result = new ArrayList<>();\n        \n        for (int i = 0; i < lst.size(); i++) {\n            List<Integer> row = lst.get(i);\n            for (int j = 0; j < row.size(); j++) {\n                if (row.get(j).equals(x)) {\n                    result.add(Arrays.asList(i, j));\n                }\n            }\n        }\n\n        // Sort by rows in ascending order and columns in descending order within each row\n        Collections.sort(result, new Comparator<List<Integer>>() {\n            @Override\n            public int compare(List<Integer> o1, List<Integer> o2) {\n                if (!o1.get(0).equals(o2.get(0))) {\n                    return o1.get(0) - o2.get(0);\n                } else {\n                    return o2.get(1) - o1.get(1); // Descending order for columns\n                }\n            }\n        });\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        List<List<Integer>> test1 = Arrays.asList(\n                Arrays.asList(1, 2, 3, 4, 5, 6),\n                Arrays.asList(1, 2, 3, 4, 1, 6),\n                Arrays.asList(1, 2, 3, 4, 5, 1)\n        );\n        System.out.println(solution.get_row(test1, 1)); // [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n\n        List<List<Integer>> test2 = new ArrayList<>();\n        System.out.println(solution.get_row(test2, 1)); // []\n\n        List<List<Integer>> test3 = Arrays.asList(\n                new ArrayList<>(),\n                Arrays.asList(1),\n                Arrays.asList(1, 2, 3)\n        );\n        System.out.println(solution.get_row(test3, 3)); // [[2, 2]]\n    }\n}\n"}
{"task_id": "Java/88", "generation": "import java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nclass Solution {\n    /**\n     * Given an array of non-negative integers, return a copy of the given array after sorting,\n     * sort the given array in ascending order if the sum( first index value, last index value) is odd,\n     * or sort it in descending order if the sum( first index value, last index value) is even.\n     *\n     * @param array The input list of integers\n     * @return A new sorted list based on the specified condition\n     */\n    public List<Integer> sort_array(List<Integer> array) {\n        // Create a copy to avoid modifying the original list\n        ArrayList<Integer> copiedArray = new ArrayList<>(array);\n\n        if (copiedArray.isEmpty()) return copiedArray;\n\n        int sumOfFirstAndLast = copiedArray.get(0) + copiedArray.get(copiedArray.size() - 1);\n        \n        // Sort based on whether the sum is odd or even\n        copiedArray.sort((a, b) -> {\n            if (sumOfFirstAndLast % 2 == 0) return b.compareTo(a); // Descending order for even sums\n            else return a.compareTo(b); // Ascending order for odd sums\n        });\n\n        return copiedArray;\n    }\n\n    @Test\n    public void testSortArray() {\n        assertEquals(new ArrayList<>(), sort_array(Arrays.asList()));\n        assertEquals(Arrays.asList(5), sort_array(Arrays.asList(5)));\n        assertEquals(Arrays.asList(0, 1, 2, 3, 4, 5), sort_array(Arrays.asList(2, 4, 3, 0, 1, 5)));\n        assertEquals(Arrays.asList(6, 5, 4, 3, 2, 1, 0), sort_array(Arrays.asList(2, 4, 3, 0, 1, 5, 6)));\n    }\n}\n"}
{"task_id": "Java/89", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public String encrypt(String s) {\n        StringBuilder encrypted = new StringBuilder();\n        \n        for (char c : s.toCharArray()) {\n            if (Character.isLetter(c)) {\n                char base = Character.isUpperCase(c) ? 'A' : 'a';\n                // Rotate the character by 4 places\n                int rotatedChar = ((c - base + 4) % 26) + base;\n                encrypted.append((char)rotatedChar);\n            } else {\n                // Non-alphabetic characters are not modified\n                encrypted.append(c);\n            }\n        }\n\n        return encrypted.toString();\n    }\n}\n\n// Test class using JUnit for testing the Solution class\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nclass SolutionTest {\n\n    @Test\n    void testEncrypt() {\n        Solution solution = new Solution();\n\n        assertEquals(\"lm\", solution.encrypt(\"hi\"));\n        assertEquals(\"ewhjklnop\", solution.encrypt(\"asdfghjkl\"));\n        assertEquals(\"kj\", solution.encrypt(\"gf\"));\n        assertEquals(\"ix\", solution.encrypt(\"et\"));\n        // Additional tests\n        assertEquals(\"Lm\", solution.encrypt(\"Hi\"));  // Test with uppercase letters\n        assertEquals(\"Qwerty\", solution.encrypt(\"Ouiyfs\"));  // Longer string test\n    }\n}\n"}
{"task_id": "Java/90", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public Optional<Integer> next_smallest(List<Integer> lst) {\n        // Check for empty or single-element lists\n        if (lst == null || lst.size() < 2) return Optional.empty();\n\n        TreeSet<Integer> sortedSet = new TreeSet<>(new Comparator<Integer>() {\n            @Override\n            public int compare(Integer o1, Integer o2) {\n                return o1.compareTo(o2);\n            }\n        });\n\n        // Add all elements to the set. TreeSet automatically sorts and removes duplicates.\n        for (Integer num : lst) {\n            sortedSet.add(num);\n        }\n\n        // If there are less than 2 unique elements, return empty\n        if (sortedSet.size() < 2) return Optional.empty();\n\n        // Get the second smallest element\n        Integer first = sortedSet.pollFirst();\n        Integer second = sortedSet.first();\n\n        return Optional.of(second);\n    }\n}\n\nclass TestSolution {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.next_smallest(Arrays.asList(1, 2, 3, 4, 5)).orElse(null)); // Expected: 2\n        System.out.println(solution.next_smallest(Arrays.asList(5, 1, 4, 3, 2)).orElse(null)); // Expected: 2\n        System.out.println(solution.next_smallest(new ArrayList<>()).orElse(null));             // Expected: null (Optional.empty())\n        System.out.println(solution.next_smallest(Arrays.asList(1, 1)).orElse(null));           // Expected: null (Optional.empty)\n    }\n}\n"}
{"task_id": "Java/91", "generation": "class Solution {\n    /**\n     * Counts the number of sentences starting with \"I\" from a given string.\n     *\n     * @param S The input string containing multiple sentences.\n     * @return The count of sentences starting with \"I\".\n     */\n    public int isBored(String S) {\n        // Split the string into sentences based on '.', '?' or '!'\n        String[] sentences = S.split(\"[.?!]\");\n        \n        int boredomCount = 0;\n        for (String sentence : sentences) {\n            // Trim leading and trailing spaces\n            String trimmedSentence = sentence.trim();\n            \n            // Check if the sentence starts with \"I\"\n            if (trimmedSentence.startsWith(\"I \")) {\n                boredomCount++;\n            }\n        }\n\n        return boredomCount;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.isBored(\"Hello world\"));  // Expected output: 0\n        System.out.println(solution.isBored(\"The sky is blue. The sun is shining. I love this weather.\"));  // Expected output: 1\n        System.out.println(solution.isBored(\"I am bored. Really, I am! Do you think I am?\"));  // Expected output: 2\n    }\n}\n"}
{"task_id": "Java/92", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Create a function that takes 3 numbers.\n     * Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n     * Returns false in any other cases.\n     */\n    public boolean any_int(Object x, Object y, Object z) {\n        // Check if all inputs are instances of Integer\n        if (!(x instanceof Integer && y instanceof Integer && z instanceof Integer)) {\n            return false;\n        }\n\n        int a = (Integer) x;\n        int b = (Integer) y;\n        int c = (Integer) z;\n\n        // Check the condition for any two numbers summing up to the third\n        return a == b + c || b == a + c || c == a + b;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.any_int(5, 2, 7));   // Expected: true\n        System.out.println(solution.any_int(3, 2, 2));   // Expected: false\n        System.out.println(solution.any_int(3, -2, 1));  // Expected: true\n        System.out.println(solution.any_int(3.6, -2.2, 2)); // Expected: false\n    }\n}\n"}
{"task_id": "Java/93", "generation": "class Solution {\n    public String encode(String message) {\n        StringBuilder encodedMessage = new StringBuilder();\n        \n        for (char c : message.toCharArray()) {\n            // Swap case\n            char swappedCaseChar;\n            if (Character.isUpperCase(c)) {\n                swappedCaseChar = Character.toLowerCase(c);\n            } else {\n                swappedCaseChar = Character.toUpperCase(c);\n            }\n            \n            // Replace vowels with the letter 2 places ahead in the alphabet\n            switch (swappedCaseChar) {\n                case 'a': encodedMessage.append('c'); break;\n                case 'e': encodedMessage.append('g'); break;\n                case 'i': encodedMessage.append('k'); break;\n                case 'o': encodedMessage.append('q'); break;\n                case 'u': encodedMessage.append('w'); break;\n                case 'A': encodedMessage.append('C'); break;\n                case 'E': encodedMessage.append('G'); break;\n                case 'I': encodedMessage.append('K'); break;\n                case 'O': encodedMessage.append('Q'); break;\n                case 'U': encodedMessage.append('W'); break;\n                default: encodedMessage.append(swappedCaseChar); break;\n            }\n        }\n\n        return encodedMessage.toString();\n    }\n    \n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.encode(\"test\"));  // Expected output \"TGST\"\n        System.out.println(solution.encode(\"This is a message\"));  // Expected output \"tHKS KS C MGSSCGG\"\n    }\n}\n"}
{"task_id": "Java/94", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Finds the largest prime value in the given list and returns the sum of its digits.\n     *\n     * @param lst List of integers to search through.\n     * @return The sum of the digits of the largest prime number found, or 0 if no primes are found.\n     */\n    public int skjkasdkd(List<Integer> lst) {\n        int maxPrime = Integer.MIN_VALUE;\n        \n        for (int num : lst) {\n            if (isPrime(num)) {\n                if (num > maxPrime) {\n                    maxPrime = num;\n                }\n            }\n        }\n\n        return sumOfDigits(maxPrime);\n    }\n\n    /**\n     * Checks if a number is prime.\n     *\n     * @param n The number to check.\n     * @return true if the number is prime, false otherwise.\n     */\n    private boolean isPrime(int n) {\n        if (n <= 1) return false;\n        for (int i = 2; i <= Math.sqrt(n); i++) {\n            if (n % i == 0) return false;\n        }\n        return true;\n    }\n\n    /**\n     * Calculates the sum of digits of a number.\n     *\n     * @param n The number whose digits are to be summed.\n     * @return The sum of the digits.\n     */\n    private int sumOfDigits(int n) {\n        if (n < 0) n = -n; // Make sure we work with positive numbers\n        int sum = 0;\n        while (n > 0) {\n            sum += n % 10;\n            n /= 10;\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.skjkasdkd(Arrays.asList(0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3))); // 10\n        System.out.println(solution.skjkasdkd(Arrays.asList(1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1))); // 25\n        System.out.println(solution.skjkasdkd(Arrays.asList(1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3))); // 13\n        System.out.println(solution.skjkasdkd(Arrays.asList(0,724,32,71,99,32,6,0,5,91,83,0,5,6))); // 11\n        System.out.println(solution.skjkasdkd(Arrays.asList(0,81,12,3,1,21))); // 3\n        System.out.println(solution.skjkasdkd(Arrays.asList(0,8,1,2,1,7))); // 7\n    }\n}\n"}
{"task_id": "Java/95", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given a map, return True if all keys are strings and all keys are in lower case or  in upper case, else return False.\n     * The function should return False if the given map is empty.\n     *\n     * @param dict the input map to check\n     * @return true if conditions are met, false otherwise\n     */\n    public boolean check_dict_case(Map<Object, Object> dict) {\n        // Check for an empty map\n        if (dict.isEmpty()) return false;\n\n        boolean hasLower = false;\n        boolean hasUpper = false;\n\n        for (Object key : dict.keySet()) {\n            // If any key is not a string, return false\n            if (!(key instanceof String)) return false;\n\n            String strKey = (String) key;\n            if (!strKey.equals(strKey.toLowerCase())) hasLower = true;\n            if (!strKey.equals(strKey.toUpperCase())) hasUpper = true;\n\n            // If both lower and upper case keys are found, return false\n            if (hasLower && hasUpper) return false;\n        }\n\n        // If the loop completes without returning false, conditions are met\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        Map<Object, Object> dict1 = new HashMap<>();\n        dict1.put(\"a\", \"apple\");\n        dict1.put(\"b\", \"banana\");\n\n        Map<Object, Object> dict2 = new HashMap<>();\n        dict2.put(\"a\", \"apple\");\n        dict2.put(\"A\", \"banana\");\n        dict2.put(\"B\", \"banana\");\n\n        Map<Object, Object> dict3 = new HashMap<>();\n        dict3.put(\"a\", \"apple\");\n        dict3.put(8, \"banana\");\n        dict3.put(\"a\", \"apple\");\n\n        Map<Object, Object> dict4 = new HashMap<>();\n        dict4.put(\"Name\", \"John\");\n        dict4.put(\"Age\", \"36\");\n        dict4.put(\"City\", \"Houston\");\n\n        Map<Object, Object> dict5 = new HashMap<>();\n        dict5.put(\"STATE\", \"NC\");\n        dict5.put(\"ZIP\", \"12345\");\n\n        System.out.println(solution.check_dict_case(dict1)); // Expected: true\n        System.out.println(solution.check_dict_case(dict2)); // Expected: false\n        System.out.println(solution.check_dict_case(dict3)); // Expected: false\n        System.out.println(solution.check_dict_case(dict4)); // Expected: false\n        System.out.println(solution.check_dict_case(dict5)); // Expected: true\n    }\n}\n"}
{"task_id": "Java/96", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Implement a function that takes a non-negative integer n and returns an ArrayList of the first n integers \n     * that are prime numbers and less than n.\n     */\n    public List<Integer> count_up_to(int n) {\n        List<Integer> primes = new ArrayList<>();\n        \n        for (int i = 2; i < n; i++) {\n            if (isPrime(i)) {\n                primes.add(i);\n            }\n        }\n\n        return primes;\n    }\n\n    private boolean isPrime(int number) {\n        if (number <= 1) {\n            return false;\n        }\n        for (int i = 2; i * i <= number; i++) {\n            if (number % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.count_up_to(5));   // Expected: [2,3]\n        System.out.println(solution.count_up_to(11));  // Expected: [2,3,5,7]\n        System.out.println(solution.count_up_to(0));   // Expected: []\n        System.out.println(solution.count_up_to(20));  // Expected: [2,3,5,7,11,13,17,19]\n        System.out.println(solution.count_up_to(1));   // Expected: []\n        System.out.println(solution.count_up_to(18));  // Expected: [2,3,5,7,11,13,17]\n    }\n}\n"}
{"task_id": "Java/97", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    \n    /**\n     * Takes two integers and returns the product of their unit digits.\n     *\n     * @param a First integer\n     * @param b Second integer\n     * @return The product of the unit digits of a and b\n     */\n    public int multiply(int a, int b) {\n        // Extracting the last digit by taking modulo 10\n        int lastDigitA = Math.abs(a % 10);\n        int lastDigitB = Math.abs(b % 10);\n\n        // Returning the product of the unit digits\n        return lastDigitA * lastDigitB;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases to verify the correctness of the function\n        System.out.println(solution.multiply(148, 412)); // Should print: 16\n        System.out.println(solution.multiply(19, 28));   // Should print: 72\n        System.out.println(solution.multiply(2020, 1851)); // Should print: 0\n        System.out.println(solution.multiply(14, -15));  // Should print: 20\n    }\n}\n"}
{"task_id": "Java/98", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a string s, count the number of uppercase vowels in even indices.\n     *\n     * @param s The input string.\n     * @return The count of uppercase vowels at even indices.\n     */\n    public int count_upper(String s) {\n        // Define the set of uppercase vowels\n        Set<Character> vowels = new HashSet<>(Arrays.asList('A', 'E', 'I', 'O', 'U'));\n        \n        int count = 0;\n        for (int i = 0; i < s.length(); i += 2) { // Iterate over even indices\n            char c = s.charAt(i);\n            if (vowels.contains(c)) {\n                count++;\n            }\n        }\n        return count;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.count_upper(\"aBCdEf\"));  // Expected output: 1\n        System.out.println(solution.count_upper(\"abcdefg\")); // Expected output: 0\n        System.out.println(solution.count_upper(\"dBBE\"));    // Expected output: 0\n        System.out.println(solution.count_upper(\"AeIoU\"));   // Expected output: 2\n        System.out.println(solution.count_upper(\"AEIOUaeiou\")); // Expected output: 3\n    }\n}\n"}
{"task_id": "Java/99", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int closest_integer(String value) {\n        double num = Double.parseDouble(value);\n        \n        if (num > 0) {\n            return (int)(Math.floor(num + 0.5));\n        } else {\n            return (int)(Math.ceil(num - 0.5));\n        }\n    }\n\n    // Test cases to verify the correctness of the function\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.closest_integer(\"10\"));      // Expected output: 10\n        System.out.println(solution.closest_integer(\"15.3\"));    // Expected output: 15\n        System.out.println(solution.closest_integer(\"14.5\"));    // Expected output: 15\n        System.out.println(solution.closest_integer(\"-14.5\"));   // Expected output: -15\n        System.out.println(solution.closest_integer(\"0.5\"));     // Expected output: 1\n        System.out.println(solution.closest_integer(\"-0.5\"));    // Expected output: -1\n    }\n}\n"}
{"task_id": "Java/100", "generation": "import java.util.ArrayList;\nimport java.util.List;\n\nclass Solution {\n    /**\n     * Given a positive integer n, makes a pile of n levels of stones.\n     * The first level has n stones.\n     * The number of stones in the next level is:\n     * - the next odd number if n is odd.\n     * - the next even number if n is even.\n     *\n     * @param n the total number of levels\n     * @return a list where each element represents the number of stones at that level\n     */\n    public List<Integer> make_a_pile(int n) {\n        List<Integer> pile = new ArrayList<>();\n        int currentStones = n;\n        \n        for (int i = 0; i < n; i++) {\n            pile.add(currentStones);\n            // Determine the next number of stones based on whether current is odd or even\n            if (currentStones % 2 == 0) { \n                currentStones += 2; // Next even number\n            } else {\n                currentStones += 2; // Next odd number, same operation as for even\n            }\n        }\n\n        return pile;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases to verify the correctness of the method\n        System.out.println(solution.make_a_pile(3)); // Expected output: [3, 5, 7]\n        System.out.println(solution.make_a_pile(4)); // Expected output: [4, 6, 8, 10]\n    }\n}\n"}
{"task_id": "Java/101", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Splits a given string of words separated by commas or spaces and returns an array of the words.\n     *\n     * @param s The input string containing words separated by commas or spaces.\n     * @return A List<String> containing the individual words from the input string.\n     */\n    public List<String> words_string(String s) {\n        // Replace all commas with spaces to have a uniform separator\n        String replacedString = s.replaceAll(\"[, ]+\", \" \");\n        \n        // Split the string based on space and trim any leading/trailing spaces\n        String[] splitArray = replacedString.trim().split(\"\\\\s+\");\n        \n        // Convert array to List<String>\n        return Arrays.asList(splitArray);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case 1: Normal sentence with commas and spaces.\n        System.out.println(solution.words_string(\"Hi, my name is John\").equals(Arrays.asList(\"Hi\", \"my\", \"name\", \"is\", \"John\")));\n        \n        // Test case 2: Sentence with only commas as separators.\n        System.out.println(solution.words_string(\"One, two, three, four, five, six\").equals(Arrays.asList(\"One\", \"two\", \"three\", \"four\", \"five\", \"six\")));\n        \n        // Additional test cases\n        // Test case 3: Multiple spaces and commas between words.\n        System.out.println(solution.words_string(\"Hello ,   world \").equals(Arrays.asList(\"Hello\", \"world\")));\n        \n        // Test case 4: Empty string input.\n        System.out.println(solution.words_string(\"\").isEmpty());\n    }\n}\n"}
{"task_id": "Java/102", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     This function takes two positive numbers x and y and returns the\n     biggest even integer number that is in the range [x, y] inclusive. If\n     there's no such number, then the function should return -1.\n     \n     For example:\n     choose_num(12, 15) = 14\n     choose_num(13, 12) = -1\n      */\n    public int choose_num(int x, int y) {\n        // Ensure that x is less than or equal to y for the range check.\n        if (x > y) return -1;\n        \n        // Start from y and go downwards until we find an even number or reach below x.\n        for (int i = y; i >= x; i--) {\n            if (i % 2 == 0) return i;\n        }\n        \n        // If no even number is found in the range, return -1.\n        return -1;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.choose_num(12, 15)); // Expected output: 14\n        System.out.println(solution.choose_num(13, 12)); // Expected output: -1\n        System.out.println(solution.choose_num(8, 10));  // Expected output: 10\n        System.out.println(solution.choose_num(7, 9));   // Expected output: 8\n        System.out.println(solution.choose_num(5, 5));   // Expected output: -1 (since 5 is odd)\n    }\n}\n"}
{"task_id": "Java/103", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public Object rounded_avg(int n, int m) {\n        if (n > m) return -1;\n\n        // Calculate sum of integers from n through m.\n        long sum = 0;\n        for (int i = n; i <= m; i++) {\n            sum += i;\n        }\n\n        // Calculate average and round it to the nearest integer\n        int avg = (int)Math.round((double)sum / (m - n + 1));\n\n        // Convert the rounded average to binary string.\n        return Integer.toBinaryString(avg);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.rounded_avg(1, 5));   // Expected output: \"11\"\n        System.out.println(solution.rounded_avg(7, 5));   // Expected output: -1\n        System.out.println(solution.rounded_avg(10, 20)); // Expected output: \"1111\"\n        System.out.println(solution.rounded_avg(20, 33)); // Expected output: \"11011\"\n    }\n}\n"}
{"task_id": "Java/104", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given a list of positive integers x, returns a sorted list of all elements that don't have any even digits.\n     *\n     * @param x List of positive integers\n     * @return Sorted list of integers without any even digit\n     */\n    public List<Integer> unique_digits(List<Integer> x) {\n        return x.stream()\n                .filter(this::hasNoEvenDigits)\n                .sorted()\n                .collect(Collectors.toList());\n    }\n\n    private boolean hasNoEvenDigits(int number) {\n        while (number > 0) {\n            int digit = number % 10;\n            if (digit % 2 == 0) return false; // If any digit is even, return false\n            number /= 10;\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        List<Integer> test1 = Arrays.asList(15, 33, 1422, 1);\n        System.out.println(solution.unique_digits(test1)); // Expected: [1, 15, 33]\n\n        List<Integer> test2 = Arrays.asList(152, 323, 1422, 10);\n        System.out.println(solution.unique_digits(test2)); // Expected: []\n\n        List<Integer> test3 = Arrays.asList(135, 79, 111, 8);\n        System.out.println(solution.unique_digits(test3)); // Expected: [111, 135, 79]\n    }\n}\n"}
{"task_id": "Java/105", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    private static final String[] DIGIT_NAMES = {\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"};\n\n    public List<String> by_length(List<Integer> arr) {\n        // Filter, sort, and reverse the array\n        List<Integer> filteredAndSorted = new ArrayList<>();\n        for (int num : arr) {\n            if (num >= 1 && num <= 9) {\n                filteredAndSorted.add(num);\n            }\n        }\n        Collections.sort(filteredAndSorted);\n        Collections.reverse(filteredAndSorted);\n\n        // Map each number to its corresponding name\n        List<String> result = new ArrayList<>();\n        for (int num : filteredAndSorted) {\n            result.add(DIGIT_NAMES[num]);\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.by_length(Arrays.asList(2, 1, 1, 4, 5, 8, 2, 3)));\n        // Expected: [Eight, Five, Four, Three, Two, Two, One, One]\n\n        System.out.println(solution.by_length(new ArrayList<>()));\n        // Expected: []\n\n        System.out.println(solution.by_length(Arrays.asList(1, -1, 55)));\n        // Expected: [One]\n    }\n}\n"}
{"task_id": "Java/106", "generation": "import java.util.ArrayList;\nimport java.util.List;\n\nclass Solution {\n    public List<Integer> f(int n) {\n        List<Integer> result = new ArrayList<>();\n        \n        for (int i = 1; i <= n; i++) {\n            if (i % 2 == 0) { // If index is even\n                result.add(factorial(i));\n            } else { // If index is odd\n                result.add(sumOfNumbers(1, i));\n            }\n        }\n\n        return result;\n    }\n\n    private int factorial(int number) {\n        int fact = 1;\n        for (int i = 2; i <= number; i++) {\n            fact *= i;\n        }\n        return fact;\n    }\n\n    private int sumOfNumbers(int start, int end) {\n        int sum = 0;\n        for (int i = start; i <= end; i++) {\n            sum += i;\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.f(5)); // Expected: [1, 2, 6, 24, 15]\n        System.out.println(solution.f(3)); // Expected: [1, 2, 6]\n        System.out.println(solution.f(1)); // Expected: [1]\n    }\n}\n"}
{"task_id": "Java/107", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given a positive integer n, return a list that has the number of even and odd\n     * integer palindromes that fall within the range(1, n), inclusive.\n     *\n     * @param n The upper limit for checking palindromic numbers.\n     * @return A List containing two elements: [number of even palindromes, number of odd palindromes].\n     */\n    public List<Integer> even_odd_palindrome(int n) {\n        int evenCount = 0;\n        int oddCount = 0;\n\n        for (int i = 1; i <= n; i++) {\n            if (isPalindrome(i)) {\n                if (i % 2 == 0) {\n                    evenCount++;\n                } else {\n                    oddCount++;\n                }\n            }\n        }\n\n        return Arrays.asList(evenCount, oddCount);\n    }\n\n    private boolean isPalindrome(int number) {\n        String numStr = Integer.toString(number);\n        int left = 0;\n        int right = numStr.length() - 1;\n\n        while (left < right) {\n            if (numStr.charAt(left) != numStr.charAt(right)) {\n                return false;\n            }\n            left++;\n            right--;\n        }\n\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        List<Integer> result1 = solution.even_odd_palindrome(3);\n        System.out.println(result1); // Expected: [1, 2]\n\n        // Test case 2\n        List<Integer> result2 = solution.even_odd_palindrome(12);\n        System.out.println(result2); // Expected: [4, 6]\n    }\n}\n"}
{"task_id": "Java/108", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Counts the number of elements which have a sum of digits > 0.\n     * If a number is negative, then its first signed digit will be negative:\n     * e.g. -123 has signed digits -1, 2, and 3.\n     */\n    public int count_nums(List<Integer> arr) {\n        if (arr == null || arr.isEmpty()) return 0;\n\n        int count = 0;\n        for (Integer num : arr) {\n            if (sumOfDigits(num) > 0) {\n                count++;\n            }\n        }\n\n        return count;\n    }\n\n    private int sumOfDigits(int num) {\n        boolean isNegative = num < 0;\n        int sum = 0;\n\n        while (num != 0) {\n            int digit = num % 10;\n            if (isNegative && sum == 0) { // First digit of a negative number\n                digit *= -1; \n            }\n            sum += digit;\n            num /= 10;\n        }\n\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.count_nums(Arrays.asList()) == 0); // true\n        System.out.println(solution.count_nums(Arrays.asList(-1, 11, -11)) == 1); // true\n        System.out.println(solution.count_nums(Arrays.asList(1, 1, 2)) == 3); // true\n    }\n}\n"}
{"task_id": "Java/109", "generation": "import java.util.*;\n\nclass Solution {\n    public boolean move_one_ball(List<Integer> arr) {\n        if (arr.isEmpty()) return true;\n\n        int n = arr.size();\n        int count = 0;\n        \n        for (int i = 1; i < n; ++i) {\n            // Check if the current element is smaller than the previous one\n            if (arr.get(i - 1) > arr.get(i)) {\n                count++;\n                \n                // If there are more than one such points, return false\n                if (count > 1 || (i < n - 1 && arr.get(i) > arr.get(0))) {\n                    return false;\n                }\n            }\n        }\n\n        // Check the last and first elements of the array\n        if (arr.get(n - 1) > arr.get(0)) count++;\n        \n        return count <= 1;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        \n        System.out.println(sol.move_one_ball(Arrays.asList(3, 4, 5, 1, 2))); // true\n        System.out.println(sol.move_one_ball(Arrays.asList(3, 5, 4, 1, 2))); // false\n        System.out.println(sol.move_one_ball(Arrays.asList()));              // true\n        System.out.println(sol.move_one_ball(Arrays.asList(1, 2, 3)));       // true\n        System.out.println(sol.move_one_ball(Arrays.asList(2, 1)));          // true\n    }\n}\n"}
{"task_id": "Java/110", "generation": "import java.util.*;\n\nclass Solution {\n    public String exchange(List<Integer> lst1, List<Integer> lst2) {\n        // Count the number of odd elements in lst1 and even elements in both lists.\n        int oddCountInLst1 = 0;\n        int evenCountInBothLists = 0;\n\n        for (int num : lst1) {\n            if (num % 2 != 0) {\n                oddCountInLst1++;\n            }\n        }\n\n        for (int num : lst1) {\n            if (num % 2 == 0) {\n                evenCountInBothLists++;\n            }\n        }\n\n        for (int num : lst2) {\n            if (num % 2 == 0) {\n                evenCountInBothLists++;\n            }\n        }\n\n        // If there are enough even numbers in both lists to replace all odd elements in lst1, return \"YES\".\n        if (evenCountInBothLists >= oddCountInLst1) {\n            return \"YES\";\n        } else {\n            return \"NO\";\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.exchange(Arrays.asList(1, 2, 3, 4), Arrays.asList(1, 2, 3, 4))); // Expected: \"YES\"\n        System.out.println(solution.exchange(Arrays.asList(1, 2, 3, 4), Arrays.asList(1, 5, 3, 4))); // Expected: \"NO\"\n        System.out.println(solution.exchange(Arrays.asList(1, 3, 5, 7), Arrays.asList(2, 4, 6, 8))); // Expected: \"YES\"\n        System.out.println(solution.exchange(Arrays.asList(1, 3, 5, 7), Arrays.asList(9, 11, 13, 15))); // Expected: \"NO\"\n    }\n}\n"}
{"task_id": "Java/111", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public Map<String,Integer> histogram(String test) {\n        // Split the input string into an array of words (characters)\n        String[] words = test.split(\" \");\n        \n        // Create a map to store the count of each character\n        Map<String, Integer> counts = new HashMap<>();\n        \n        // Count occurrences of each character\n        for (String word : words) {\n            if (!word.isEmpty()) {  // Ensure we don't count empty strings\n                counts.put(word, counts.getOrDefault(word, 0) + 1);\n            }\n        }\n\n        // Find the maximum occurrence value\n        int maxCount = Collections.max(counts.values(), Integer::compare);\n\n        // Filter out characters that do not have the maximum count\n        Map<String, Integer> result = new HashMap<>();\n        for (Map.Entry<String, Integer> entry : counts.entrySet()) {\n            if (entry.getValue() == maxCount) {\n                result.put(entry.getKey(), entry.getValue());\n            }\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.histogram(\"a b c\"));  // {\"a\": 1, \"b\": 1, \"c\": 1}\n        System.out.println(solution.histogram(\"a b b a\"));  // {\"a\": 2, \"b\": 2}\n        System.out.println(solution.histogram(\"a b c a b\"));  // {\"a\": 2, \"b\": 2}\n        System.out.println(solution.histogram(\"b b b b a\"));  // {\"b\": 4}\n        System.out.println(solution.histogram(\"\"));  // {}\n    }\n}\n"}
{"task_id": "Java/112", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Task: We are given two strings s and c, you have to delete all the characters in s that are equal to any character in c.\n     * Then check if the result string is a palindrome.\n     * A string is called palindrome if it reads the same backward as forward.\n     * You should return a tuple containing the result string and true/false for the check.\n     *\n     * Example:\n     * For s = \"abcde\", c = \"ae\", the result should be (\"bcd\", false)\n     * For s = \"abcdef\", c = \"b\"  the result should be (\"acdef\", false)\n     * For s = \"abcdedcba\", c = \"ab\", the result should be (\"cdedc\", true)\n     */\n    public List<Object> reverse_delete(String s, String c) {\n        StringBuilder resultBuilder = new StringBuilder();\n        \n        // Remove characters from s that are present in c\n        for (char ch : s.toCharArray()) {\n            if (c.indexOf(ch) == -1) {  // If character is not found in c, add it to the result string\n                resultBuilder.append(ch);\n            }\n        }\n\n        String resultString = resultBuilder.toString();\n        \n        // Check if the resulting string is a palindrome\n        boolean isPalindrome = new StringBuilder(resultString).reverse().toString().equals(resultString);\n\n        return Arrays.asList(resultString, isPalindrome);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        List<Object> result1 = solution.reverse_delete(\"abcde\", \"ae\");\n        System.out.println(result1);  // Expected: [bcd, false]\n\n        // Test case 2\n        List<Object> result2 = solution.reverse_delete(\"abcdef\", \"b\");\n        System.out.println(result2);  // Expected: [acdef, false]\n\n        // Test case 3\n        List<Object> result3 = solution.reverse_delete(\"abcdedcba\", \"ab\");\n        System.out.println(result3);  // Expected: [cdedc, true]\n    }\n}\n"}
{"task_id": "Java/113", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given a list of strings, where each string consists of only digits,\n     * return a list. Each element i of the output should be \"the number of odd elements in the\n     * string i of the input.\" where all the i's should be replaced by the number\n     * of odd digits in the i\"th string of the input.\n     */\n    public List<String> odd_count(List<String> lst) {\n        List<String> result = new ArrayList<>();\n        \n        for (String s : lst) {\n            int countOddDigits = 0;\n            \n            // Counting odd digits\n            for (char c : s.toCharArray()) {\n                if ((c - '0') % 2 != 0) {\n                    countOddDigits++;\n                }\n            }\n\n            // Creating the result string with replacements\n            String template = \"the number of odd elements in the strin of the input.\";\n            StringBuilder sb = new StringBuilder(template.length());\n            \n            for (char c : template.toCharArray()) {\n                if (c == 'i') {\n                    sb.append(countOddDigits);\n                } else {\n                    sb.append(c);\n                }\n            }\n\n            result.add(sb.toString());\n        }\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case 1\n        List<String> testList1 = Arrays.asList(\"1234567\");\n        System.out.println(solution.odd_count(testList1));\n        \n        // Test case 2\n        List<String> testList2 = Arrays.asList(\"3\", \"11111111\");\n        System.out.println(solution.odd_count(testList2));\n    }\n}\n"}
{"task_id": "Java/114", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given an array of integers nums, find the minimum sum of any non-empty sub-array\n     * of nums.\n     *\n     * @param nums List<Integer> representing the input array\n     * @return int representing the minimum sum of any non-empty sub-array\n     */\n    public int minSubArraySum(List<Integer> nums) {\n        if (nums == null || nums.isEmpty()) return 0;\n\n        // Initialize variables to store the current and global minimum sums.\n        int currentMin = nums.get(0);\n        int globalMin = nums.get(0);\n\n        for (int i = 1; i < nums.size(); i++) {\n            // Update currentMin to be either the current element or the sum of\n            // currentMin and the current element, whichever is smaller.\n            currentMin = Math.min(nums.get(i), currentMin + nums.get(i));\n            \n            // Update globalMin if currentMin is less than globalMin.\n            globalMin = Math.min(globalMin, currentMin);\n        }\n\n        return globalMin;\n    }\n    \n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        List<Integer> test1 = Arrays.asList(2, 3, 4, 1, 2, 4);\n        System.out.println(\"Test Case 1: \" + (solution.minSubArraySum(test1) == 1 ? \"Passed\" : \"Failed\"));\n        \n        List<Integer> test2 = Arrays.asList(-1, -2, -3);\n        System.out.println(\"Test Case 2: \" + (solution.minSubArraySum(test2) == -6 ? \"Passed\" : \"Failed\"));\n\n        // Additional test cases\n        List<Integer> test3 = Arrays.asList(5, -7, 3, 5, -2, 4);\n        System.out.println(\"Test Case 3: \" + (solution.minSubArraySum(test3) == -7 ? \"Passed\" : \"Failed\"));\n\n        List<Integer> test4 = Arrays.asList(-10, 4, -6, 8, -9);\n        System.out.println(\"Test Case 4: \" + (solution.minSubArraySum(test4) == -21 ? \"Passed\" : \"Failed\"));\n    }\n}\n"}
{"task_id": "Java/115", "generation": "import java.util.*;\n\nclass Solution {\n    public int max_fill(List<List<Integer>> grid, int capacity) {\n        if (grid == null || grid.isEmpty() || grid.get(0).isEmpty()) return 0;\n\n        int rows = grid.size();\n        int cols = grid.get(0).size();\n        int totalDrops = 0;\n\n        for (int col = 0; col < cols; col++) {\n            int waterInColumn = 0;\n            for (int row = 0; row < rows; row++) {\n                waterInColumn += grid.get(row).get(col);\n            }\n            // Calculate the number of drops needed to empty this column\n            totalDrops += Math.ceil((double) waterInColumn / capacity);\n        }\n\n        return totalDrops;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        List<List<Integer>> grid1 = Arrays.asList(\n                Arrays.asList(0, 0, 1, 0),\n                Arrays.asList(0, 1, 0, 0),\n                Arrays.asList(1, 1, 1, 1)\n        );\n        System.out.println(solution.max_fill(grid1, 1)); // Output: 6\n\n        List<List<Integer>> grid2 = Arrays.asList(\n                Arrays.asList(0, 0, 1, 1),\n                Arrays.asList(0, 0, 0, 0),\n                Arrays.asList(1, 1, 1, 1),\n                Arrays.asList(0, 1, 1, 1)\n        );\n        System.out.println(solution.max_fill(grid2, 2)); // Output: 5\n\n        List<List<Integer>> grid3 = Arrays.asList(\n                Arrays.asList(0, 0, 0),\n                Arrays.asList(0, 0, 0)\n        );\n        System.out.println(solution.max_fill(grid3, 5)); // Output: 0\n    }\n}\n"}
{"task_id": "Java/116", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Sorts a list of integers according to the number of ones in their binary representation.\n     * For similar numbers of ones, it sorts based on the decimal value.\n     *\n     * @param arr The input list of integers.\n     * @return A new sorted list of integers.\n     */\n    public List<Integer> sort_array(List<Integer> arr) {\n        // Sort using a custom comparator\n        Collections.sort(arr, (a, b) -> {\n            int countA = Integer.bitCount(a);\n            int countB = Integer.bitCount(b);\n            \n            if (countA == countB) {\n                return a - b;  // If the number of ones is equal, sort by decimal value.\n            } else {\n                return countA - countB;  // Otherwise, sort by the number of ones.\n            }\n        });\n        \n        return arr;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        List<Integer> test1 = Arrays.asList(1, 5, 2, 3, 4);\n        System.out.println(solution.sort_array(new ArrayList<>(test1)).equals(Arrays.asList(1, 2, 4, 3, 5)));\n        \n        List<Integer> test2 = Arrays.asList(-2, -3, -4, -5, -6);\n        System.out.println(solution.sort_array(new ArrayList<>(test2)).equals(Arrays.asList(-4, -2, -6, -5, -3)));\n        \n        List<Integer> test3 = Arrays.asList(1, 0, 2, 3, 4);\n        System.out.println(solution.sort_array(new ArrayList<>(test3)).equals(Arrays.asList(0, 1, 2, 4, 3)));\n    }\n}\n"}
{"task_id": "Java/117", "generation": "import java.util.*;\n\nclass Solution {\n    public List<String> select_words(String s, int n) {\n        if (s == null || s.trim().isEmpty()) return Collections.emptyList();\n        \n        String[] words = s.split(\"\\\\s+\");\n        List<String> result = new ArrayList<>();\n        \n        for (String word : words) {\n            if (countConsonants(word) == n) {\n                result.add(word);\n            }\n        }\n        \n        return result;\n    }\n\n    private int countConsonants(String word) {\n        String consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n        int count = 0;\n        for (char c : word.toCharArray()) {\n            if (consonants.indexOf(c) != -1) {\n                count++;\n            }\n        }\n        return count;\n    }\n}\n"}
{"task_id": "Java/118", "generation": "class Solution {\n    public String get_closest_vowel(String word) {\n        if (word == null || word.length() < 3) return \"\";\n\n        for (int i = word.length() - 2; i > 0; i--) { // Start from second last character and move left\n            char currentChar = word.charAt(i);\n            char prevChar = word.charAt(i - 1);\n            char nextChar = word.charAt(i + 1);\n\n            if (isVowel(currentChar) && isConsonant(prevChar) && isConsonant(nextChar)) {\n                return String.valueOf(currentChar); // Return the vowel as a string\n            }\n        }\n\n        return \"\"; // No such vowel found\n    }\n\n    private boolean isVowel(char c) {\n        return \"AEIOUaeiou\".indexOf(c) != -1;\n    }\n\n    private boolean isConsonant(char c) {\n        return !isVowel(c);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.get_closest_vowel(\"yogurt\")); // Expected: \"u\"\n        System.out.println(solution.get_closest_vowel(\"FULL\"));   // Expected: \"U\"\n        System.out.println(solution.get_closest_vowel(\"quick\"));  // Expected: \"\"\n        System.out.println(solution.get_closest_vowel(\"ab\"));     // Expected: \"\"\n    }\n}\n"}
{"task_id": "Java/119", "generation": "import java.util.*;\n\nclass Solution {\n    public String match_parens(List<String> lst) {\n        int open1 = 0, close1 = 0;\n        int open2 = 0, close2 = 0;\n\n        // Count the number of open and close parentheses in each string.\n        for (char c : lst.get(0).toCharArray()) {\n            if (c == '(') open1++;\n            else close1++;\n        }\n        for (char c : lst.get(1).toCharArray()) {\n            if (c == '(') open2++;\n            else close2++;\n        }\n\n        // Check the total number of parentheses.\n        int totalOpen = open1 + open2;\n        int totalClose = close1 + close2;\n\n        // If the total number of open and close parentheses is not equal, return \"No\".\n        if (totalOpen != totalClose) {\n            return \"No\";\n        }\n\n        // Check concatenation in both orders.\n        boolean canConcatenateFirstOrder = checkBalance(lst.get(0), lst.get(1));\n        boolean canConcatenateSecondOrder = checkBalance(lst.get(1), lst.get(0));\n\n        if (canConcatenateFirstOrder || canConcatenateSecondOrder) {\n            return \"Yes\";\n        } else {\n            return \"No\";\n        }\n    }\n\n    private boolean checkBalance(String first, String second) {\n        int balance = 0;\n        for (char c : first.toCharArray()) {\n            if (c == '(') balance++;\n            else balance--;\n            if (balance < 0) return false; // Early exit if imbalance is detected.\n        }\n        for (char c : second.toCharArray()) {\n            if (c == '(') balance++;\n            else balance--;\n            if (balance < 0) return false;\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.match_parens(Arrays.asList(\"()(\", \")\"))); // Expected: \"Yes\"\n        System.out.println(solution.match_parens(Arrays.asList(\")\", \")\")));   // Expected: \"No\"\n    }\n}\n"}
{"task_id": "Java/120", "generation": "import java.util.*;\n\nclass Solution {\n    public List<Integer> maximum(List<Integer> arr, int k) {\n        // Create a priority queue to store the top k elements.\n        PriorityQueue<Integer> pq = new PriorityQueue<>(k);\n        \n        for (int num : arr) {\n            if (pq.size() < k) {\n                pq.offer(num);  // Add element if heap size is less than k\n            } else if (num > pq.peek()) {  // Check if the current number is greater than the smallest in the heap\n                pq.poll();  // Remove the smallest\n                pq.offer(num);  // Insert the new number\n            }\n        }\n\n        List<Integer> result = new ArrayList<>(pq);\n        Collections.sort(result);  // Sort the list to get ascending order\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        \n        System.out.println(sol.maximum(Arrays.asList(-3, -4, 5), 3));  // Output: [-4, -3, 5]\n        System.out.println(sol.maximum(Arrays.asList(4, -4, 4), 2));   // Output: [4, 4]\n        System.out.println(sol.maximum(Arrays.asList(-3, 2, 1, 2, -1, -2, 1), 1));  // Output: [2]\n    }\n}\n"}
{"task_id": "Java/121", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n     *\n     * @param lst List of integers\n     * @return Sum of odd elements at even positions\n     */\n    public int solution(List<Integer> lst) {\n        int sum = 0;\n        \n        // Iterate over list with index to check position and value\n        for (int i = 0; i < lst.size(); i++) {\n            if (i % 2 == 0 && lst.get(i) % 2 != 0) { // Check even position and odd element\n                sum += lst.get(i);\n            }\n        }\n\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n\n        // Test cases to verify the solution method\n        System.out.println(sol.solution(Arrays.asList(5, 8, 7, 1))); // Expected output: 12 (5 + 7)\n        System.out.println(sol.solution(Arrays.asList(3, 3, 3, 3, 3))); // Expected output: 9 (3 + 3 + 3)\n        System.out.println(sol.solution(Arrays.asList(30, 13, 24, 321))); // Expected output: 0\n    }\n}\n"}
{"task_id": "Java/122", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given a non-empty array of integers arr and an integer k,\n     * return the sum of the elements with at most two digits from the first k elements of arr.\n     *\n     * @param arr List<Integer> - The list of integers to process.\n     * @param k int - The number of elements from the start of the list to consider.\n     * @return int - Sum of elements with at most two digits among the first k elements.\n     */\n    public int add_elements(List<Integer> arr, int k) {\n        int sum = 0;\n        for (int i = 0; i < Math.min(k, arr.size()); i++) { // Ensure we do not go out of bounds\n            if (arr.get(i) >= -99 && arr.get(i) <= 99) { // Check if the number has at most two digits\n                sum += arr.get(i);\n            }\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case 1\n        List<Integer> testArr1 = Arrays.asList(111, 21, 3, 4000, 5, 6, 7, 8, 9);\n        int k1 = 4;\n        System.out.println(\"Test Case 1: \" + solution.add_elements(testArr1, k1)); // Expected output: 24\n        \n        // Test case 2\n        List<Integer> testArr2 = Arrays.asList(10, 23, -56, 789, 12);\n        int k2 = 5;\n        System.out.println(\"Test Case 2: \" + solution.add_elements(testArr2, k2)); // Expected output: -11\n        \n        // Test case 3\n        List<Integer> testArr3 = Arrays.asList(100, 99, 88);\n        int k3 = 3;\n        System.out.println(\"Test Case 3: \" + solution.add_elements(testArr3, k3)); // Expected output: 187\n        \n        // Test case 4\n        List<Integer> testArr4 = Arrays.asList(-20, -99, 5);\n        int k4 = 2;\n        System.out.println(\"Test Case 4: \" + solution.add_elements(testArr4, k4)); // Expected output: -119\n    }\n}\n"}
{"task_id": "Java/123", "generation": "import java.util.*;\n\nclass Solution {\n    public List<Integer> get_odd_collatz(int n) {\n        Set<Integer> oddNumbers = new HashSet<>();\n        \n        while (n != 1) {\n            if (n % 2 == 1) { // Check if the number is odd\n                oddNumbers.add(n);\n            }\n            n = n % 2 == 0 ? n / 2 : 3 * n + 1; // Collatz sequence rule\n        }\n        oddNumbers.add(1); // Add 1 as it's always part of the sequence and is odd\n        \n        List<Integer> sortedOddNumbers = new ArrayList<>(oddNumbers);\n        Collections.sort(sortedOddNumbers); // Sort in increasing order\n        \n        return sortedOddNumbers;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.get_odd_collatz(5)); // Expected: [1, 5]\n        System.out.println(solution.get_odd_collatz(7)); // Expected: [1, 7, 11, 22]\n    }\n}\n"}
{"task_id": "Java/124", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n    You have to write a function which validates a given date string and\n    returns true if the date is valid otherwise false.\n    The date is valid if all of the following rules are satisfied:\n    1. The date string is not empty.\n    2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.\n    3. The months should not be less than 1 or higher than 12.\n    4. The date should be in the format: mm-dd-yyyy\n\n    for example:\n    valid_date(\"03-11-2000\") => true\n    valid_date(\"15-01-2012\") => false\n    valid_date(\"04-0-2040\") => false\n    valid_date(\"06-04-2020\") => true\n    valid_date(\"06/04/2020\") => false\n     */\n    public boolean valid_date(String date) {\n        // Check if the string is empty or not in correct format\n        if (date == null || !date.matches(\"\\\\d{2}-\\\\d{2}-\\\\d{4}\")) return false;\n\n        String[] parts = date.split(\"-\");\n        int month = Integer.parseInt(parts[0]);\n        int day = Integer.parseInt(parts[1]);\n        int year = Integer.parseInt(parts[2]);\n\n        // Check for valid months\n        if (month < 1 || month > 12) return false;\n\n        // Check for valid days based on the month\n        switch(month) {\n            case 2:\n                if(day < 1 || day > 29) return false;\n                break;\n            case 4: case 6: case 9: case 11:\n                if(day < 1 || day > 30) return false;\n                break;\n            default:\n                if(day < 1 || day > 31) return false;\n        }\n\n        // If all checks pass, the date is valid\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.valid_date(\"03-11-2000\")); // Expected: true\n        System.out.println(solution.valid_date(\"15-01-2012\")); // Expected: false\n        System.out.println(solution.valid_date(\"04-0-2040\"));  // Expected: false\n        System.out.println(solution.valid_date(\"06-04-2020\")); // Expected: true\n        System.out.println(solution.valid_date(\"06/04/2020\")); // Expected: false\n    }\n}\n"}
{"task_id": "Java/125", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a string of words, return a list of words split on whitespace. If no whitespaces exist in the text,\n     * you should split on commas ','. If no commas exist, you should return the number of lower-case letters with odd order\n     * in the alphabet (ord('a') = 0, ord('b') = 1, ..., ord('z') = 25).\n     *\n     * @param txt The input string to process.\n     * @return A List<String> if splitting occurs or an Integer representing the count of odd-ordered lowercase letters.\n     */\n    public Object split_words(String txt) {\n        // Check for whitespace and split on it\n        if (txt.contains(\" \")) {\n            return Arrays.asList(txt.split(\"\\\\s+\"));\n        }\n        // If no whitespaces, check for commas and split on them\n        else if (txt.contains(\",\")) {\n            return Arrays.asList(txt.split(\",\"));\n        } \n        // If neither whitespace nor comma exists, count the odd-ordered lowercase letters\n        else {\n            int count = 0;\n            for (char c : txt.toCharArray()) {\n                if (Character.isLowerCase(c) && ((c - 'a') % 2 == 1)) {\n                    count++;\n                }\n            }\n            return count;\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.split_words(\"Hello world!\")); // [\"Hello\", \"world!\"]\n        System.out.println(solution.split_words(\"Hello,world!\")); // [\"Hello\", \"world!\"]\n        System.out.println(solution.split_words(\"abcdef\"));       // 3\n\n        // Additional test cases for thoroughness\n        System.out.println(solution.split_words(\"a,b,c,d,e,f\")); // [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"]\n        System.out.println(solution.split_words(\"abc def ghi,jkl\")); // [\"abc\", \"def\", \"ghi,jkl\"]\n    }\n}\n"}
{"task_id": "Java/126", "generation": "import java.util.*;\n\nclass Solution {\n    public boolean is_sorted(List<Integer> lst) {\n        if (lst == null || lst.size() <= 1) return true;\n\n        Map<Integer, Integer> countMap = new HashMap<>();\n        \n        for (int i = 0; i < lst.size(); i++) {\n            int num = lst.get(i);\n            \n            // Check if the list is sorted in ascending order\n            if (i > 0 && lst.get(i - 1) > num) return false;\n            \n            // Count occurrences of each number\n            countMap.put(num, countMap.getOrDefault(num, 0) + 1);\n            \n            // If any number appears more than twice, return false\n            if (countMap.get(num) > 2) return false;\n        }\n        \n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.is_sorted(Arrays.asList(5))); // -> true\n        System.out.println(solution.is_sorted(Arrays.asList(1, 2, 3, 4, 5))); // -> true\n        System.out.println(solution.is_sorted(Arrays.asList(1, 3, 2, 4, 5))); // -> false\n        System.out.println(solution.is_sorted(Arrays.asList(1, 2, 3, 4, 5, 6))); // -> true\n        System.out.println(solution.is_sorted(Arrays.asList(1, 2, 3, 4, 5, 6, 7))); // -> true\n        System.out.println(solution.is_sorted(Arrays.asList(1, 3, 2, 4, 5, 6, 7))); // -> false\n        System.out.println(solution.is_sorted(Arrays.asList(1, 2, 2, 3, 3, 4))); // -> true\n        System.out.println(solution.is_sorted(Arrays.asList(1, 2, 2, 2, 3, 4))); // -> false\n    }\n}\n"}
{"task_id": "Java/127", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Determines whether the length of intersection of two given closed intervals is a prime number.\n     *\n     * @param interval1 The first interval as a list [start, end].\n     * @param interval2 The second interval as a list [start, end].\n     * @return \"YES\" if the intersection length is a prime number, otherwise \"NO\".\n     */\n    public String intersection(List<Integer> interval1, List<Integer> interval2) {\n        int startMax = Math.max(interval1.get(0), interval2.get(0));\n        int endMin = Math.min(interval1.get(1), interval2.get(1));\n\n        if (startMax > endMin) return \"NO\"; // No intersection\n\n        int lengthOfIntersection = endMin - startMax + 1;\n\n        if (lengthOfIntersection <= 1) return \"NO\"; // Length of 0 or 1 is not prime\n        for (int i = 2; i * i <= lengthOfIntersection; i++) {\n            if (lengthOfIntersection % i == 0) return \"NO\";\n        }\n        return \"YES\";\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.intersection(Arrays.asList(1, 2), Arrays.asList(2, 3))); // NO\n        System.out.println(solution.intersection(Arrays.asList(-1, 1), Arrays.asList(0, 4))); // NO\n        System.out.println(solution.intersection(Arrays.asList(-3, -1), Arrays.asList(-5, 5))); // YES\n    }\n}\n"}
{"task_id": "Java/128", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public Optional<Integer> prod_signs(List<Integer> arr) {\n        if (arr.isEmpty()) {\n            return Optional.empty();\n        }\n\n        int sumOfMagnitudes = 0;\n        int productOfSigns = 1;\n\n        for (int num : arr) {\n            sumOfMagnitudes += Math.abs(num);\n            if (num == 0) {\n                productOfSigns = 0; // If any number is zero, the product of signs becomes 0\n                break;\n            } else if (num < 0) {\n                productOfSigns *= -1;\n            }\n        }\n\n        return Optional.of(sumOfMagnitudes * productOfSigns);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.prod_signs(Arrays.asList(1, 2, 2, -4))); // Expected: Optional[-9]\n        System.out.println(solution.prod_signs(Arrays.asList(0, 1)));         // Expected: Optional[0]\n        System.out.println(solution.prod_signs(Arrays.asList()));             // Expected: Optional.empty\n    }\n}\n"}
{"task_id": "Java/129", "generation": "import java.util.*;\n\nclass Solution {\n    private int N;\n    private List<List<Integer>> grid;\n    private int[][] directions = {{0, 1}, {1, 0}, {-1, 0}, {0, -1}};\n    \n    public List<Integer> minPath(List<List<Integer>> grid, int k) {\n        this.grid = grid;\n        N = grid.size();\n        \n        // Initialize the result with a large value\n        List<Integer> result = new ArrayList<>();\n        for (int i = 0; i < k; ++i) {\n            result.add(Integer.MAX_VALUE);\n        }\n        \n        // Try starting from each cell in the grid\n        for (int row = 0; row < N; ++row) {\n            for (int col = 0; col < N; ++col) {\n                List<Integer> path = new ArrayList<>();\n                dfs(row, col, k - 1, path, result);\n            }\n        }\n        \n        return result;\n    }\n\n    private void dfs(int row, int col, int stepsLeft, List<Integer> currentPath, List<Integer> minPath) {\n        // Add the value of the current cell to the path\n        currentPath.add(grid.get(row).get(col));\n        \n        if (stepsLeft == 0) {\n            // Check if this path is lexicographically smaller than the current minimum path\n            if (isSmaller(currentPath, minPath)) {\n                minPath.clear();\n                minPath.addAll(currentPath);\n            }\n        } else {\n            for (int[] direction : directions) {\n                int newRow = row + direction[0];\n                int newCol = col + direction[1];\n                \n                // Check if the next cell is within bounds\n                if (newRow >= 0 && newRow < N && newCol >= 0 && newCol < N) {\n                    dfs(newRow, newCol, stepsLeft - 1, currentPath, minPath);\n                }\n            }\n        }\n        \n        // Backtrack: remove the last element from the path\n        currentPath.remove(currentPath.size() - 1);\n    }\n\n    private boolean isSmaller(List<Integer> a, List<Integer> b) {\n        for (int i = 0; i < Math.min(a.size(), b.size()); ++i) {\n            if (!a.get(i).equals(b.get(i))) return a.get(i) < b.get(i);\n        }\n        return a.size() < b.size();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        List<List<Integer>> grid1 = Arrays.asList(\n                Arrays.asList(1, 2, 3),\n                Arrays.asList(4, 5, 6),\n                Arrays.asList(7, 8, 9)\n        );\n        System.out.println(solution.minPath(grid1, 3)); // Output: [1, 2, 1]\n\n        List<List<Integer>> grid2 = Arrays.asList(\n                Arrays.asList(5, 9, 3),\n                Arrays.asList(4, 1, 6),\n                Arrays.asList(7, 8, 2)\n        );\n        System.out.println(solution.minPath(grid2, 1)); // Output: [1]\n    }\n}\n"}
{"task_id": "Java/130", "generation": "import java.util.*;\n\nclass Solution {\n    public List<Integer> tri(int n) {\n        if (n < 0) return new ArrayList<>();\n        \n        // Initialize a list with size n + 1 to store Tribonacci numbers.\n        List<Integer> result = new ArrayList<>(Collections.nCopies(n + 1, 0));\n        \n        // Base cases\n        if (n >= 1) {\n            result.set(1, 3);\n        }\n        if (n >= 2) {\n            result.set(2, 2); // tri(2) = 1 + (2 / 2)\n        }\n\n        for (int i = 3; i <= n; i++) {\n            if (i % 2 == 0) { // If even\n                result.set(i, 1 + i / 2);\n            } else { // If odd\n                int nextValue = result.get(i - 1) + result.get(i - 2) + (i < n ? result.get(i + 1) : 3); \n                result.set(i, nextValue);\n            }\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.tri(0)); // Expected: [0]\n        System.out.println(solution.tri(1)); // Expected: [0, 3]\n        System.out.println(solution.tri(2)); // Expected: [0, 3, 2]\n        System.out.println(solution.tri(3)); // Expected: [0, 3, 2, 8]\n        System.out.println(solution.tri(4)); // Expected: [0, 3, 2, 8, 3]\n    }\n}\n"}
{"task_id": "Java/131", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    \n    /**\n     * Given a positive integer n, return the product of the odd digits.\n     * Return 0 if all digits are even.\n     *\n     * @param n The input number.\n     * @return The product of the odd digits or 0 if all digits are even.\n     */\n    public int digits(int n) {\n        int product = 1;\n        boolean hasOddDigit = false;\n\n        while (n > 0) {\n            int digit = n % 10; // Get the last digit\n            if (digit % 2 != 0) { // Check if it's odd\n                product *= digit;\n                hasOddDigit = true;\n            }\n            n /= 10; // Remove the last digit\n        }\n\n        return hasOddDigit ? product : 0;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases to verify the correctness of the digits method.\n        System.out.println(solution.digits(1));   // Expected output: 1\n        System.out.println(solution.digits(4));   // Expected output: 0\n        System.out.println(solution.digits(235)); // Expected output: 15\n        System.out.println(solution.digits(2468)); // Expected output: 0\n        System.out.println(solution.digits(13579)); // Expected output: 945\n    }\n}\n"}
{"task_id": "Java/132", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Checks if there exists at least one nested bracket in a given string of square brackets.\n     *\n     * @param string The input string containing only square brackets.\n     * @return true if there's at least one valid nested subsequence, false otherwise.\n     */\n    public boolean is_nested(String string) {\n        int balance = 0; // Tracks the balance between open and close brackets\n        boolean foundNested = false;\n\n        for (char c : string.toCharArray()) {\n            if (c == '[') {\n                balance++;\n                if (balance > 1) { // If there's more than one opening bracket without a closing, we have nesting.\n                    foundNested = true;\n                }\n            } else if (c == ']') {\n                balance--;\n                if (balance < 0) { // If the balance goes negative, it means there are more closing brackets than openings\n                    return false; // This is not a valid sequence of brackets\n                }\n            }\n        }\n\n        // The string has to be balanced and have at least one nested pair.\n        return foundNested && balance == 0;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.is_nested(\"[[]]\")); // true\n        System.out.println(solution.is_nested(\"[]]]]]]][[[[[]\")); // false\n        System.out.println(solution.is_nested(\"[][]\")); // false\n        System.out.println(solution.is_nested(\"[]\")); // false\n        System.out.println(solution.is_nested(\"[[][]]\")); // true\n        System.out.println(solution.is_nested(\"[[]][[\")); // true\n    }\n}\n"}
{"task_id": "Java/133", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int sum_squares(List<Double> lst) {\n        // Initialize a variable to hold the sum of squares.\n        int sum = 0;\n\n        // Iterate over each element in the list.\n        for (Double num : lst) {\n            // Apply ceiling function, convert it to an integer and square it.\n            int squaredValue = (int)Math.pow(Math.ceil(num), 2);\n            \n            // Add the squared value to the sum.\n            sum += squaredValue;\n        }\n\n        return sum;\n    }\n    \n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        List<Double> test1 = Arrays.asList(1.0, 2.0, 3.0);\n        System.out.println(solution.sum_squares(test1)); // Expected output: 14\n        \n        List<Double> test2 = Arrays.asList(1.0, 4.0, 9.0);\n        System.out.println(solution.sum_squares(test2)); // Expected output: 98\n        \n        List<Double> test3 = Arrays.asList(1.0, 3.0, 5.0, 7.0);\n        System.out.println(solution.sum_squares(test3)); // Expected output: 84\n        \n        List<Double> test4 = Arrays.asList(1.4, 4.2, 0.0);\n        System.out.println(solution.sum_squares(test4)); // Expected output: 29\n        \n        List<Double> test5 = Arrays.asList(-2.4, 1.0, 1.0);\n        System.out.println(solution.sum_squares(test5)); // Expected output: 6\n    }\n}\n"}
{"task_id": "Java/134", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Create a function that returns true if the last character\n     * of a given string is an alphabetical character and is not\n     * a part of a word, and false otherwise.\n     * Note: \"word\" is a group of characters separated by space.\n     *\n     * @param txt The input string to check.\n     * @return true if the last non-space character is an isolated letter, false otherwise.\n     */\n    public boolean check_if_last_char_is_a_letter(String txt) {\n        // Trim trailing spaces\n        String trimmed = txt.trim();\n        \n        // Check if the string is empty after trimming\n        if (trimmed.isEmpty()) return false;\n        \n        // Get the last character of the trimmed string\n        char lastChar = trimmed.charAt(trimmed.length() - 1);\n        \n        // Check if it's an alphabetical character and not part of a word\n        boolean isAlphabetic = Character.isLetter(lastChar);\n        boolean isNotPartOfWord = (trimmed.length() == 1) || \n                                   (trimmed.length() > 1 && trimmed.charAt(trimmed.length() - 2) == ' ');\n        \n        return isAlphabetic && isNotPartOfWord;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.check_if_last_char_is_a_letter(\"apple pie\"));       // false\n        System.out.println(solution.check_if_last_char_is_a_letter(\"apple pi e\"));      // true\n        System.out.println(solution.check_if_last_char_is_a_letter(\"apple pi e \"));     // false\n        System.out.println(solution.check_if_last_char_is_a_letter(\"\"));                // false\n    }\n}\n"}
{"task_id": "Java/135", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Returns the largest index of an element which is not greater than or equal \n     * to the element immediately preceding it. If no such element exists then return -1.\n     *\n     * @param arr The input list of integers without duplicates.\n     * @return The largest index where the condition is met, or -1 if no such element exists.\n     */\n    public int can_arrange(List<Integer> arr) {\n        for (int i = arr.size() - 1; i > 0; --i) {\n            if (arr.get(i) < arr.get(i - 1)) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.can_arrange(Arrays.asList(1,2,4,3,5))); // Expected output: 3\n        System.out.println(solution.can_arrange(Arrays.asList(1,2,3)));      // Expected output: -1\n        System.out.println(solution.can_arrange(Arrays.asList(5,4,3,2,1)));  // Expected output: 4\n        System.out.println(solution.can_arrange(Arrays.asList(10,9,8,7,6,5)));// Expected output: 5\n    }\n}\n"}
{"task_id": "Java/136", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n\n    public List<Optional<Integer>> largest_smallest_integers(List<Integer> lst) {\n        Optional<Integer> maxNegative = lst.stream()\n                .filter(n -> n < 0)\n                .max(Integer::compare);\n        \n        Optional<Integer> minPositive = lst.stream()\n                .filter(n -> n > 0)\n                .min(Integer::compare);\n\n        return Arrays.asList(maxNegative, minPositive);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        List<Optional<Integer>> result1 = solution.largest_smallest_integers(Arrays.asList(2, 4, 1, 3, 5, 7));\n        System.out.println(result1); // Expected: [Optional.empty(), Optional[1]]\n\n        // Test case 2\n        List<Optional<Integer>> result2 = solution.largest_smallest_integers(new ArrayList<>());\n        System.out.println(result2); // Expected: [Optional.empty(), Optional.empty()]\n\n        // Test case 3\n        List<Optional<Integer>> result3 = solution.largest_smallest_integers(Arrays.asList(0));\n        System.out.println(result3); // Expected: [Optional.empty(), Optional.empty()]\n\n        // Additional test cases\n        // Test case 4\n        List<Optional<Integer>> result4 = solution.largest_smallest_integers(Arrays.asList(-1, -2, -3, -4));\n        System.out.println(result4); // Expected: [Optional[-1], Optional.empty()]\n\n        // Test case 5\n        List<Optional<Integer>> result5 = solution.largest_smallest_integers(Arrays.asList(10, -10, 20, -20, 30, -30));\n        System.out.println(result5); // Expected: [Optional[-10], Optional[10]]\n    }\n}\n"}
{"task_id": "Java/137", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public Optional<Object> compare_one(Object a, Object b) {\n        double aValue = parseValue(a);\n        double bValue = parseValue(b);\n\n        if (aValue == bValue) return Optional.empty();\n\n        // Return the original object with the larger value\n        return aValue > bValue ? Optional.of(a) : Optional.of(b);\n    }\n\n    private double parseValue(Object obj) {\n        if (obj instanceof Integer || obj instanceof Double)\n            return ((Number)obj).doubleValue();\n        \n        String str = obj.toString().replace(',', '.');\n        try {\n            return Double.parseDouble(str);\n        } catch (NumberFormatException e) {\n            throw new IllegalArgumentException(\"Invalid number format: \" + str, e);\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.compare_one(1, 2.5)); // Optional.of(2.5)\n        System.out.println(solution.compare_one(1, \"2,3\")); // Optional.of(\"2,3\")\n        System.out.println(solution.compare_one(\"5,1\", \"6\")); // Optional.of(\"6\")\n        System.out.println(solution.compare_one(\"1\", 1)); // Optional.empty()\n    }\n}\n"}
{"task_id": "Java/138", "generation": "class Solution {\n    public boolean is_equalToSumEven(int n) {\n        // Check if n is at least 8 and is even.\n        return n >= 8 && n % 2 == 0;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.is_equalToSumEven(4)); // Expected: false\n        System.out.println(solution.is_equalToSumEven(6)); // Expected: false\n        System.out.println(solution.is_equalToSumEven(8)); // Expected: true\n        System.out.println(solution.is_equalToSumEven(10)); // Expected: true\n    }\n}\n"}
{"task_id": "Java/139", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * The Brazilian factorial is defined as:\n     * brazilian_factorial(n) = n! * (n-1)! * ... * 1!\n     * where n > 0\n     *\n     * @param n the input integer for which to calculate the special factorial.\n     * @return the calculated special factorial of the given integer.\n     */\n    public long special_factorial(int n) {\n        long result = 1;\n        for (int i = 1; i <= n; i++) {\n            result *= factorial(i);\n        }\n        return result;\n    }\n\n    /**\n     * Helper method to calculate factorial of a number.\n     *\n     * @param num the number to calculate the factorial of.\n     * @return the factorial of the given number.\n     */\n    private long factorial(int num) {\n        if (num == 0 || num == 1)\n            return 1;\n        else\n            return num * factorial(num - 1);\n    }\n\n    /**\n     * Main method to test the special_factorial function with some examples.\n     *\n     * @param args command line arguments, not used in this example.\n     */\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.special_factorial(4));  // Expected output: 288\n        System.out.println(solution.special_factorial(5));  // Expected output: 34560\n        System.out.println(solution.special_factorial(1));  // Expected output: 1\n    }\n}\n"}
{"task_id": "Java/140", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Given a string text, replace all spaces in it with underscores,\n    and if a string has more than 2 consecutive spaces,\n    then replace all consecutive spaces with -\n\n    fix_spaces(\"Example\") == \"Example\"\n    fix_spaces(\"Example 1\") == \"Example_1\"\n    fix_spaces(\" Example 2\") == \"_Example_2\"\n    fix_spaces(\" Example   3\") == \"_Example-3\"\n     */\n    public String fix_spaces(String text) {\n        if (text == null || text.isEmpty()) return text;\n\n        StringBuilder result = new StringBuilder();\n        int spaceCount = 0;\n        \n        for (char c : text.toCharArray()) {\n            if (c == ' ') {\n                spaceCount++;\n            } else {\n                if (spaceCount > 2) {\n                    result.append('-');\n                } else {\n                    for (int i = 0; i < spaceCount; i++) {\n                        result.append('_');\n                    }\n                }\n                spaceCount = 0;\n                result.append(c);\n            }\n        }\n\n        // Handle trailing spaces\n        if (spaceCount > 2) {\n            result.append('-');\n        } else {\n            for (int i = 0; i < spaceCount; i++) {\n                result.append('_');\n            }\n        }\n\n        return result.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.fix_spaces(\"Example\").equals(\"Example\")); // true\n        System.out.println(solution.fix_spaces(\"Example 1\").equals(\"Example_1\")); // true\n        System.out.println(solution.fix_spaces(\" Example 2\").equals(\"_Example_2\")); // true\n        System.out.println(solution.fix_spaces(\" Example   3\").equals(\"_Example-3\")); // true\n    }\n}\n"}
{"task_id": "Java/141", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public String file_name_check(String file_name) {\n        // Check if there are more than three digits in the filename.\n        int digitCount = 0;\n        for (char c : file_name.toCharArray()) {\n            if (Character.isDigit(c)) {\n                digitCount++;\n            }\n        }\n        if (digitCount > 3) return \"No\";\n\n        // Split the string by dot and check its length\n        String[] parts = file_name.split(\"\\\\.\");\n        if (parts.length != 2) return \"No\"; // There should be exactly one dot\n\n        // Check the first part of the filename\n        String prefix = parts[0];\n        if (prefix.isEmpty() || !Character.isLetter(prefix.charAt(0))) {\n            return \"No\";\n        }\n\n        // Check the second part of the filename\n        String suffix = parts[1];\n        List<String> validSuffixes = Arrays.asList(\"txt\", \"exe\", \"dll\");\n        if (!validSuffixes.contains(suffix)) {\n            return \"No\";\n        }\n\n        return \"Yes\";\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.file_name_check(\"example.txt\"));  // Expected: Yes\n        System.out.println(solution.file_name_check(\"1example.dll\")); // Expected: No\n        System.out.println(solution.file_name_check(\"file234.exe\"));  // Expected: Yes\n        System.out.println(solution.file_name_check(\".txt\"));         // Expected: No (prefix is empty)\n        System.out.println(solution.file_name_check(\"test.abc\"));     // Expected: No (invalid suffix)\n        System.out.println(solution.file_name_check(\"a1234.dll\"));    // Expected: No (more than 3 digits)\n        System.out.println(solution.file_name_check(\"file..txt\"));    // Expected: No (more than one dot)\n    }\n}\n"}
{"task_id": "Java/142", "generation": "import java.util.*;\n\nclass Solution {\n    public int sum_squares(List<Integer> lst) {\n        if (lst == null || lst.isEmpty()) return 0;\n\n        int sum = 0;\n        for (int i = 0; i < lst.size(); i++) {\n            if (i % 3 == 0 && i % 4 != 0) { // Multiple of 3 but not 4\n                sum += Math.pow(lst.get(i), 2);\n            } else if (i % 4 == 0) { // Multiple of 4, which includes multiples of both 3 and 4\n                sum += Math.pow(lst.get(i), 3);\n            } else {\n                sum += lst.get(i); // No change for other indices\n            }\n        }\n\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.sum_squares(Arrays.asList(1,2,3))); // Expected output: 6\n        System.out.println(solution.sum_squares(new ArrayList<>())); // Expected output: 0\n        System.out.println(solution.sum_squares(Arrays.asList(-1,-5,2,-1,-5))); // Expected output: -126\n\n        // Additional test cases for verification:\n        System.out.println(solution.sum_squares(Arrays.asList(2,3,4,5))); // Example where index 0 (multiple of 3) and 3 (multiple of 4) are processed.\n    }\n}\n"}
{"task_id": "Java/143", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Checks if a number is prime.\n     */\n    private boolean isPrime(int n) {\n        if (n <= 1) return false;\n        if (n == 2 || n == 3) return true;\n        if (n % 2 == 0 || n % 3 == 0) return false;\n\n        for (int i = 5; i * i <= n; i += 6) {\n            if (n % i == 0 || n % (i + 2) == 0)\n                return false;\n        }\n        return true;\n    }\n\n    /**\n     * Returns a string containing only those words from the original sentence whose lengths are prime numbers.\n     */\n    public String words_in_sentence(String sentence) {\n        StringBuilder result = new StringBuilder();\n        String[] words = sentence.split(\" \");\n        \n        for (String word : words) {\n            if (isPrime(word.length())) {\n                if (result.length() > 0) {\n                    result.append(\" \");\n                }\n                result.append(word);\n            }\n        }\n\n        return result.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.words_in_sentence(\"This is a test\")); // Output: \"is\"\n        System.out.println(solution.words_in_sentence(\"lets go for swimming\")); // Output: \"go for\"\n    }\n}\n"}
{"task_id": "Java/144", "generation": "class Solution {\n    /**\n     * Simplifies the expression x * n where both are strings representing fractions.\n     *\n     * @param x The first fraction as a string in the format \"<numerator>/<denominator>\".\n     * @param n The second fraction as a string in the format \"<numerator>/<denominator>\".\n     * @return true if x * n evaluates to a whole number, false otherwise.\n     */\n    public boolean simplify(String x, String n) {\n        // Split the fractions into numerator and denominator\n        String[] partsX = x.split(\"/\");\n        String[] partsN = n.split(\"/\");\n\n        long num1 = Long.parseLong(partsX[0]);\n        long den1 = Long.parseLong(partsX[1]);\n        long num2 = Long.parseLong(partsN[0]);\n        long den2 = Long.parseLong(partsN[1]);\n\n        // Multiply the numerators and denominators\n        long numeratorProduct = num1 * num2;\n        long denominatorProduct = den1 * den2;\n\n        // Check if the result is a whole number by checking divisibility\n        return numeratorProduct % denominatorProduct == 0;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.simplify(\"1/5\", \"5/1\")); // true, because (1*5)/(5*1) = 1 which is a whole number.\n        System.out.println(solution.simplify(\"1/6\", \"2/1\")); // false, because (1*2)/(6*1) = 1/3 which is not a whole number.\n        System.out.println(solution.simplify(\"7/10\", \"10/2\")); // false, because (7*10)/(10*2) = 7/2 which is not a whole number.\n    }\n}\n"}
{"task_id": "Java/145", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Sorts the given list of integers in ascending order according to the sum of their digits.\n     * Note: if there are several items with similar sum of their digits,\n     * order them based on their index in original list.\n     * If an integer is negative, then its first digit will be negative:\n     * e.g. -123 has digits -1, 2, and 3.\n     *\n     * @param nums the list of integers to sort\n     * @return a new sorted list based on the sum of their digits\n     */\n    public List<Integer> order_by_points(List<Integer> nums) {\n        // Create a list of pairs (original index, number)\n        List<Pair> indexedNums = new ArrayList<>();\n        for (int i = 0; i < nums.size(); i++) {\n            indexedNums.add(new Pair(i, nums.get(i)));\n        }\n\n        // Sort the list based on digit sum and then by original index\n        Collections.sort(indexedNums, Comparator.comparingInt((Pair p) -> digitSum(p.number))\n                .thenComparingInt(Pair::getIndex));\n\n        // Extract sorted numbers from pairs\n        List<Integer> result = new ArrayList<>();\n        for (Pair pair : indexedNums) {\n            result.add(pair.number);\n        }\n\n        return result;\n    }\n\n    private int digitSum(int number) {\n        int sum = 0;\n        boolean isNegative = number < 0;\n        while (number != 0) {\n            int digit = number % 10;\n            if (isNegative && sum == 0) {\n                // First digit of a negative number should be considered as negative\n                digit *= -1;\n            }\n            sum += Math.abs(digit);\n            number /= 10;\n        }\n        return sum;\n    }\n\n    private static class Pair {\n        int index;\n        int number;\n\n        public Pair(int index, int number) {\n            this.index = index;\n            this.number = number;\n        }\n\n        public int getIndex() {\n            return index;\n        }\n    }\n\n    // Test the function\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        List<Integer> test1 = Arrays.asList(1, 11, -1, -11, -12);\n        System.out.println(solution.order_by_points(test1)); // Expected: [-1, -11, 1, -12, 11]\n\n        List<Integer> test2 = new ArrayList<>();\n        System.out.println(solution.order_by_points(test2)); // Expected: []\n\n        List<Integer> test3 = Arrays.asList(-10, -9, -8);\n        System.out.println(solution.order_by_points(test3)); // Expected: [-10, -8, -9]\n    }\n}\n"}
{"task_id": "Java/146", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Returns the number of elements in the array that are greater than 10 and both \n     * first and last digits of a number are odd (1, 3, 5, 7, 9).\n     */\n    public int specialFilter(List<Integer> nums) {\n        return (int) nums.stream()\n                .filter(num -> num > 10 && isFirstAndLastDigitOdd(num))\n                .count();\n    }\n\n    private boolean isFirstAndLastDigitOdd(int num) {\n        String strNum = Integer.toString(Math.abs(num));\n        int firstDigit = Character.getNumericValue(strNum.charAt(0));\n        int lastDigit = Character.getNumericValue(strNum.charAt(strNum.length() - 1));\n        return (firstDigit % 2 != 0) && (lastDigit % 2 != 0);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        List<Integer> test1 = Arrays.asList(15, -73, 14, -15);\n        System.out.println(solution.specialFilter(test1)); // Expected output: 1\n\n        List<Integer> test2 = Arrays.asList(33, -2, -3, 45, 21, 109);\n        System.out.println(solution.specialFilter(test2)); // Expected output: 2\n\n        List<Integer> test3 = Arrays.asList(-17, 11, 13, 19, 23);\n        System.out.println(solution.specialFilter(test3)); // Expected output: 4\n    }\n}\n"}
{"task_id": "Java/147", "generation": "import java.util.*;\n\nclass Solution {\n    public int get_max_triples(int n) {\n        // Generate array a based on given formula\n        int[] a = new int[n];\n        for (int i = 0; i < n; ++i) {\n            a[i] = (i + 1) * (i + 1) - (i + 1) + 1;\n        }\n\n        // Count the number of valid triples\n        int count = 0;\n        for (int i = 0; i < n; ++i) {\n            for (int j = i + 1; j < n; ++j) {\n                for (int k = j + 1; k < n; ++k) {\n                    if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                        count++;\n                    }\n                }\n            }\n        }\n\n        return count;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case\n        int n = 5; // Example input\n        System.out.println(\"Number of valid triples: \" + solution.get_max_triples(n)); // Expected output: 1\n        \n        // Additional test cases\n        System.out.println(\"Number of valid triples for n=6: \" + solution.get_max_triples(6));\n        System.out.println(\"Number of valid triples for n=7: \" + solution.get_max_triples(7));\n    }\n}\n"}
{"task_id": "Java/148", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Returns a list of planet names that are between two given planets.\n     *\n     * @param planet1 The name of the first planet.\n     * @param planet2 The name of the second planet.\n     * @return A List containing all planets located between the orbits of planet1 and planet2, sorted by proximity to the sun. Returns an empty list if either planet is not a valid planet name.\n     */\n    public List<String> bf(String planet1, String planet2) {\n        // Define the order of the planets\n        final String[] PLANETS = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n        \n        int index1 = -1;\n        int index2 = -1;\n\n        // Find indices of both planets in the array\n        for (int i = 0; i < PLANETS.length; i++) {\n            if (PLANETS[i].equals(planet1)) index1 = i;\n            else if (PLANETS[i].equals(planet2)) index2 = i;\n            \n            // If both indices are found, break the loop\n            if (index1 != -1 && index2 != -1) break;\n        }\n\n        // Check for invalid planet names or identical planets\n        if (index1 == -1 || index2 == -1 || index1 == index2) return new ArrayList<>();\n\n        // Ensure index1 is always less than index2\n        int start = Math.min(index1, index2);\n        int end = Math.max(index1, index2);\n\n        List<String> result = new ArrayList<>();\n        for (int i = start + 1; i < end; i++) {\n            result.add(PLANETS[i]);\n        }\n\n        return result;\n    }\n    \n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.bf(\"Jupiter\", \"Neptune\"));  // Expected: [Saturn, Uranus]\n        System.out.println(solution.bf(\"Earth\", \"Mercury\"));   // Expected: [Venus]\n        System.out.println(solution.bf(\"Mercury\", \"Uranus\"));  // Expected: [Venus, Earth, Mars, Jupiter, Saturn]\n    }\n}\n"}
{"task_id": "Java/149", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Filters out strings with odd lengths from a list, sorts the remaining strings by their length,\n     * and in case of equal lengths, alphabetically.\n     *\n     * @param lst The input list of strings.\n     * @return A sorted list of strings without those having odd lengths.\n     */\n    public List<String> sorted_list_sum(List<String> lst) {\n        // Filter out strings with odd lengths\n        List<String> filteredList = new ArrayList<>();\n        for (String str : lst) {\n            if (str.length() % 2 == 0) {\n                filteredList.add(str);\n            }\n        }\n\n        // Sort the list by length and then alphabetically\n        Collections.sort(filteredList, new Comparator<String>() {\n            public int compare(String s1, String s2) {\n                int lenCompare = Integer.compare(s1.length(), s2.length());\n                if (lenCompare == 0) {\n                    return s1.compareTo(s2);\n                }\n                return lenCompare;\n            }\n        });\n\n        return filteredList;\n    }\n\n    // Test cases\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        List<String> test1 = Arrays.asList(\"aa\", \"a\", \"aaa\");\n        System.out.println(solution.sorted_list_sum(test1));  // Expected: [aa]\n        \n        List<String> test2 = Arrays.asList(\"ab\", \"a\", \"aaa\", \"cd\");\n        System.out.println(solution.sorted_list_sum(test2));  // Expected: [ab, cd]\n        \n        List<String> test3 = Arrays.asList(\"abc\", \"defg\", \"hij\", \"klmno\", \"pqrstu\");\n        System.out.println(solution.sorted_list_sum(test3));  // Expected: [defg, pqrstu]\n    }\n}\n"}
{"task_id": "Java/150", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * A simple program which should return the value of x if n is\n     * a prime number and should return the value of y otherwise.\n     *\n     * Examples:\n     * for x_or_y(7, 34, 12) == 34\n     * for x_or_y(15, 8, 5) == 5\n     */\n    public int x_or_y(int n, int x, int y) {\n        if (isPrime(n)) {\n            return x;\n        } else {\n            return y;\n        }\n    }\n\n    private boolean isPrime(int number) {\n        if (number <= 1) {\n            return false;\n        }\n        for (int i = 2; i * i <= number; i++) {\n            if (number % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.x_or_y(7, 34, 12)); // Expected output: 34\n        System.out.println(solution.x_or_y(15, 8, 5));  // Expected output: 5\n        System.out.println(solution.x_or_y(11, 99, 66));// Expected output: 99\n        System.out.println(solution.x_or_y(20, 42, 73));// Expected output: 73\n    }\n}\n"}
{"task_id": "Java/151", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given a list of numbers, return the sum of squares of the numbers\n     * in the list that are odd. Ignore numbers that are negative or not integers.\n     *\n     * @param lst List of objects (expected to contain Integer values)\n     * @return Sum of squares of odd numbers from the list\n     */\n    public int sumOfSquaresOfOddNumbers(List<Object> lst) {\n        return lst.stream()\n                  .filter(o -> o instanceof Integer && ((Integer) o > 0))\n                  .mapToInt(o -> (int)o)\n                  .filter(n -> n % 2 != 0)\n                  .map(n -> n * n)\n                  .sum();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.sumOfSquaresOfOddNumbers(Arrays.asList(1, 3, 2, 0))); // Expected output: 10\n        System.out.println(solution.sumOfSquaresOfOddNumbers(Arrays.asList(-1, -2, 0)));   // Expected output: 0\n        System.out.println(solution.sumOfSquaresOfOddNumbers(Arrays.asList(9, -2)));       // Expected output: 81\n        System.out.println(solution.sumOfSquaresOfOddNumbers(Arrays.asList(0)));           // Expected output: 0\n        System.out.println(solution.sumOfSquaresOfOddNumbers(new ArrayList<>()));          // Expected output: 0 (empty list)\n    }\n}\n"}
{"task_id": "Java/152", "generation": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\nclass Solution {\n    /**\n     * Compares the actual scores of matches with guesses.\n     *\n     * @param game  List of integers representing the actual scores of each match.\n     * @param guess List of integers representing the guessed scores for each match.\n     * @return A list where each element is either 0 (if the guess was correct) or\n     *         the absolute difference between the guess and the score for that match.\n     */\n    public List<Integer> compare(List<Integer> game, List<Integer> guess) {\n        List<Integer> result = new ArrayList<>();\n        \n        // Iterate through both lists simultaneously\n        for (int i = 0; i < game.size(); i++) {\n            int diff = Math.abs(game.get(i) - guess.get(i));\n            result.add(diff);\n        }\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case 1\n        List<Integer> gameScores1 = Arrays.asList(1,2,3,4,5,1);\n        List<Integer> guesses1 = Arrays.asList(1,2,3,4,2,-2);\n        System.out.println(solution.compare(gameScores1, guesses1)); // Expected: [0, 0, 0, 0, 3, 3]\n        \n        // Test case 2\n        List<Integer> gameScores2 = Arrays.asList(0,5,0,0,0,4);\n        List<Integer> guesses2 = Arrays.asList(4,1,1,0,0,-2);\n        System.out.println(solution.compare(gameScores2, guesses2)); // Expected: [4, 4, 1, 0, 0, 6]\n    }\n}\n"}
{"task_id": "Java/153", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public String Strongest_Extension(String className, List<String> extensions) {\n        int maxStrength = Integer.MIN_VALUE;\n        String strongestExtName = \"\";\n\n        for (String ext : extensions) {\n            int strength = calculateStrength(ext);\n            if (strength > maxStrength || (strength == maxStrength && strongestExtName.isEmpty())) {\n                maxStrength = strength;\n                strongestExtName = ext;\n            }\n        }\n\n        return className + \".\" + strongestExtName;\n    }\n\n    private int calculateStrength(String extension) {\n        int capCount = 0, smCount = 0;\n\n        for (char c : extension.toCharArray()) {\n            if (Character.isUpperCase(c)) capCount++;\n            else if (Character.isLowerCase(c)) smCount++;\n        }\n\n        return capCount - smCount;\n    }\n}\n\n// Test code\nclass Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case 1\n        List<String> extensions1 = Arrays.asList(\"SErviNGSliCes\", \"Cheese\", \"StuFfed\");\n        System.out.println(solution.Strongest_Extension(\"Slices\", extensions1)); // Expected: Slices.SErviNGSliCes\n\n        // Test case 2\n        List<String> extensions2 = Arrays.asList(\"AA\", \"Be\", \"CC\");\n        System.out.println(solution.Strongest_Extension(\"my_class\", extensions2)); // Expected: my_class.AA\n        \n        // Additional test cases can be added here to further validate the solution.\n    }\n}\n"}
{"task_id": "Java/154", "generation": "class Solution {\n    public boolean cycpattern_check(String a, String b) {\n        // Concatenate string 'a' with itself to handle rotations.\n        String doubledA = a + a;\n        \n        // Check if 'b' is a substring of the concatenated string.\n        return doubledA.contains(b);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.cycpattern_check(\"abcd\", \"abd\"));  // false\n        System.out.println(solution.cycpattern_check(\"hello\", \"ell\")); // true\n        System.out.println(solution.cycpattern_check(\"whassup\", \"psus\")); // false\n        System.out.println(solution.cycpattern_check(\"abab\", \"baa\"));   // true\n        System.out.println(solution.cycpattern_check(\"efef\", \"eeff\"));  // false\n        System.out.println(solution.cycpattern_check(\"himenss\", \"simen\")); // true\n    }\n}\n"}
{"task_id": "Java/155", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given an integer, return a list that has the number of even and odd digits respectively.\n     *\n     * Example:\n     *      even_odd_count(-12) ==> [1, 1]\n     *      even_odd_count(123) ==> [1, 2]\n     */\n    public List<Integer> even_odd_count(int num) {\n        // Convert the number to a string and remove any negative sign\n        String strNum = Integer.toString(Math.abs(num));\n        \n        int evenCount = 0;\n        int oddCount = 0;\n\n        for (char c : strNum.toCharArray()) {\n            if ((c - '0') % 2 == 0) {\n                evenCount++;\n            } else {\n                oddCount++;\n            }\n        }\n\n        List<Integer> result = new ArrayList<>();\n        result.add(evenCount);\n        result.add(oddCount);\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.even_odd_count(-12));  // Expected: [1, 1]\n        System.out.println(solution.even_odd_count(123));  // Expected: [1, 2]\n        System.out.println(solution.even_odd_count(0));    // Expected: [1, 0]\n        System.out.println(solution.even_odd_count(-987654321)); // Expected: [4, 5]\n    }\n}\n"}
{"task_id": "Java/156", "generation": "class Solution {\n    public String int_to_mini_roman(int number) {\n        if (number < 1 || number > 1000) throw new IllegalArgumentException(\"Number must be between 1 and 1000\");\n\n        // Roman numeral symbols in descending order of value\n        String[] numerals = {\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n        int[] values = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n\n        StringBuilder romanNumeral = new StringBuilder();\n        \n        for (int i = 0; i < values.length && number > 0; i++) {\n            while (number >= values[i]) {\n                number -= values[i];\n                romanNumeral.append(numerals[i]);\n            }\n        }\n\n        return romanNumeral.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.int_to_mini_roman(19).equals(\"xix\") ? \"Test 1 Passed\" : \"Test 1 Failed\");\n        System.out.println(solution.int_to_mini_roman(152).equals(\"clii\") ? \"Test 2 Passed\" : \"Test 2 Failed\");\n        System.out.println(solution.int_to_mini_roman(426).equals(\"cdxxvi\") ? \"Test 3 Passed\" : \"Test 3 Failed\");\n\n        // Additional test cases\n        System.out.println(solution.int_to_mini_roman(1000).equals(\"m\") ? \"Test 4 Passed\" : \"Test 4 Failed\");\n        System.out.println(solution.int_to_mini_roman(58).equals(\"lviii\") ? \"Test 5 Passed\" : \"Test 5 Failed\");\n    }\n}\n"}
{"task_id": "Java/157", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given the lengths of the three sides of a triangle, return true if the three\n     * sides form a right-angled triangle, false otherwise.\n     * A right-angled triangle is a triangle in which one angle is a right angle or 90 degrees.\n     */\n    public boolean right_angle_triangle(int a, int b, int c) {\n        // First, sort the sides to ensure that c is the longest side\n        int[] sides = {a, b, c};\n        Arrays.sort(sides);\n        \n        // Apply Pythagorean theorem: a^2 + b^2 should equal c^2 for right-angled triangles.\n        return Math.pow(sides[0], 2) + Math.pow(sides[1], 2) == Math.pow(sides[2], 2);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.right_angle_triangle(3, 4, 5)); // Expected: true\n        System.out.println(solution.right_angle_triangle(1, 2, 3)); // Expected: false\n        System.out.println(solution.right_angle_triangle(5, 12, 13)); // Expected: true\n        System.out.println(solution.right_angle_triangle(8, 15, 17)); // Expected: true\n        System.out.println(solution.right_angle_triangle(6, 8, 10)); // Expected: true\n    }\n}\n"}
{"task_id": "Java/158", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Finds the word with the maximum number of unique characters.\n     * If multiple words have the same number of unique characters, returns the one that comes first lexicographically.\n     *\n     * @param words List of strings to be evaluated.\n     * @return The string with the maximum number of unique characters or the lexicographically smallest if there's a tie.\n     */\n    public String find_max(List<String> words) {\n        String maxWord = \"\";\n        int maxUniqueChars = 0;\n\n        for (String word : words) {\n            Set<Character> uniqueChars = new HashSet<>();\n            for (char c : word.toCharArray()) {\n                uniqueChars.add(c);\n            }\n\n            if (uniqueChars.size() > maxUniqueChars || \n                    (uniqueChars.size() == maxUniqueChars && word.compareTo(maxWord) < 0)) {\n                maxUniqueChars = uniqueChars.size();\n                maxWord = word;\n            }\n        }\n\n        return maxWord;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        List<String> test1 = Arrays.asList(\"name\", \"of\", \"string\");\n        System.out.println(solution.find_max(test1));  // Expected: string\n\n        List<String> test2 = Arrays.asList(\"name\", \"enam\", \"game\");\n        System.out.println(solution.find_max(test2));  // Expected: enam\n\n        List<String> test3 = Arrays.asList(\"aaaaaaa\", \"bb\", \"cc\");\n        System.out.println(solution.find_max(test3));  // Expected: aaaaaaa\n    }\n}\n"}
{"task_id": "Java/159", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * You're a hungry rabbit, and you already have eaten a certain number of carrots,\n     * but now you need to eat more carrots to complete the day's meals.\n     * you should return an array of [ total number of eaten carrots after your meals,\n     *                                 the number of carrots left after your meals ]\n     * if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n     *\n     * @param number  the number of carrots that you have already eaten.\n     * @param need    the number of carrots that you need to eat.\n     * @param remaining the number of remaining carrots in stock\n     * @return List<Integer> containing two elements: total number of eaten carrots and the number of carrots left\n     */\n    public List<Integer> eat(int number, int need, int remaining) {\n        int eaten = Math.min(need, remaining);\n        return Arrays.asList(number + eaten, remaining - eaten);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.eat(5, 6, 10)); // Expected: [11, 4]\n        System.out.println(solution.eat(4, 8, 9));  // Expected: [12, 1]\n        System.out.println(solution.eat(1, 10, 10));// Expected: [11, 0]\n        System.out.println(solution.eat(2, 11, 5)); // Expected: [7, 0]\n    }\n}\n"}
{"task_id": "Java/160", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given two lists operator and operand. The first list has basic algebra operations,\n     * and the second list is a list of integers. Use the two given lists to build the algebric\n     * expression and return the evaluation of this expression.\n     *\n     * @param operator List of strings representing operators.\n     * @param operand  List of integers representing operands.\n     * @return The result of evaluating the algebraic expression.\n     */\n    public int do_algebra(List<String> operator, List<Integer> operand) {\n        if (operator.isEmpty() || operand.size() < 2) {\n            throw new IllegalArgumentException(\"Invalid input\");\n        }\n\n        // Initialize the result with the first operand\n        double result = operand.get(0);\n\n        for (int i = 0; i < operator.size(); i++) {\n            String op = operator.get(i);\n            int nextOperand = operand.get(i + 1);\n\n            switch (op) {\n                case \"+\":\n                    result += nextOperand;\n                    break;\n                case \"-\":\n                    result -= nextOperand;\n                    break;\n                case \"*\":\n                    result *= nextOperand;\n                    break;\n                case \"/\":\n                    // Use floor division\n                    result = Math.floor(result / nextOperand);\n                    break;\n                case \"**\":\n                    result = Math.pow(result, nextOperand);\n                    break;\n                default:\n                    throw new IllegalArgumentException(\"Unsupported operator: \" + op);\n            }\n        }\n\n        return (int) result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test Case 1\n        List<String> operators1 = Arrays.asList(\"+\", \"*\", \"-\");\n        List<Integer> operands1 = Arrays.asList(2, 3, 4, 5);\n        System.out.println(solution.do_algebra(operators1, operands1)); // Expected output: 9\n\n        // Test Case 2\n        List<String> operators2 = Arrays.asList(\"**\", \"/\", \"+\");\n        List<Integer> operands2 = Arrays.asList(2, 3, 4, 5);\n        System.out.println(solution.do_algebra(operators2, operands2)); // Expected output: 10\n\n        // Test Case 3\n        List<String> operators3 = Arrays.asList(\"-\", \"*\", \"**\", \"/\");\n        List<Integer> operands3 = Arrays.asList(10, 5, 2, 3, 4);\n        System.out.println(solution.do_algebra(operators3, operands3)); // Expected output: -7\n    }\n}\n"}
{"task_id": "Java/161", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n    You are given a string s.\n    if s[i] is a letter, reverse its case from lower to upper or vise versa,\n    otherwise keep it as it is.\n    If the string contains no letters, reverse the string.\n    The function should return the resulted string.\n    Examples\n    solve(\"1234\") = \"4321\"\n    solve(\"ab\") = \"AB\"\n    solve(\"#a@C\") = \"#A@c\"\n     */\n    public String solve(String s) {\n        boolean hasLetters = false;\n        StringBuilder result = new StringBuilder();\n        \n        // Check if the string contains any letters\n        for (char c : s.toCharArray()) {\n            if (Character.isLetter(c)) {\n                hasLetters = true;\n                break;\n            }\n        }\n\n        // If no letters are present, reverse the entire string\n        if (!hasLetters) {\n            return new StringBuilder(s).reverse().toString();\n        }\n\n        // Process each character in the string\n        for (char c : s.toCharArray()) {\n            if (Character.isLetter(c)) {\n                // Reverse case of letter characters\n                if (Character.isLowerCase(c)) {\n                    result.append(Character.toUpperCase(c));\n                } else {\n                    result.append(Character.toLowerCase(c));\n                }\n            } else {\n                // Keep non-letter characters as they are\n                result.append(c);\n            }\n        }\n\n        return result.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.solve(\"1234\").equals(\"4321\") ? \"Test 1 Passed\" : \"Test 1 Failed\");\n        System.out.println(solution.solve(\"ab\").equals(\"AB\") ? \"Test 2 Passed\" : \"Test 2 Failed\");\n        System.out.println(solution.solve(\"#a@C\").equals(\"#A@c\") ? \"Test 3 Passed\" : \"Test 3 Failed\");\n    }\n}\n"}
{"task_id": "Java/162", "generation": "import java.math.BigInteger;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.Optional;\n\nclass Solution {\n    /**\n     * Given a string \"text\", return its md5 hash equivalent string with length being 32.\n     * If \"text\" is an empty string, return Optional.empty().\n     *\n     * @param text the input string\n     * @return Optional<String> containing the MD5 hash or Optional.empty() if text is empty\n     */\n    public Optional<String> string_to_md5(String text) throws NoSuchAlgorithmException {\n        if (text.isEmpty()) {\n            return Optional.empty();\n        }\n        \n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        byte[] messageDigest = md.digest(text.getBytes());\n        BigInteger no = new BigInteger(1, messageDigest);\n        String hashtext = no.toString(16);\n\n        // Add leading zeros to make the length 32\n        while (hashtext.length() < 32) {\n            hashtext = \"0\" + hashtext;\n        }\n\n        return Optional.of(hashtext);\n    }\n}\n\n// Test class for Solution\nclass SolutionTest {\n    public static void main(String[] args) throws NoSuchAlgorithmException {\n        Solution solution = new Solution();\n        \n        // Test case 1: Normal input\n        String testString1 = \"Hello world\";\n        System.out.println(\"Testing with \\\"\" + testString1 + \"\\\":\");\n        Optional<String> result1 = solution.string_to_md5(testString1);\n        if (result1.isPresent() && result1.get().equals(\"3e25960a79dbc69b674cd4ec67a72c62\")) {\n            System.out.println(\"Test 1 Passed\");\n        } else {\n            System.out.println(\"Test 1 Failed\");\n        }\n\n        // Test case 2: Empty string\n        String testString2 = \"\";\n        System.out.println(\"Testing with \\\"\" + testString2 + \"\\\":\");\n        Optional<String> result2 = solution.string_to_md5(testString2);\n        if (!result2.isPresent()) {\n            System.out.println(\"Test 2 Passed\");\n        } else {\n            System.out.println(\"Test 2 Failed\");\n        }\n    }\n}\n"}
{"task_id": "Java/163", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given two positive integers a and b, return the even digits between a\n     * and b, in ascending order. Please note that the even digits refer to even numbers less than 10.\n     *\n     * For example:\n     * generate_integers(2, 8) => [2, 4, 6, 8]\n     * generate_integers(8, 2) => [2, 4, 6, 8]\n     * generate_integers(10, 14) => []\n     */\n    public List<Integer> generate_integers(int a, int b) {\n        // Ensure that the range is from smaller to larger\n        if (a > b) {\n            int temp = a;\n            a = b;\n            b = temp;\n        }\n\n        List<Integer> result = new ArrayList<>();\n        \n        for (int i : new int[]{2, 4, 6, 8}) {\n            if (i >= a && i <= b) {\n                result.add(i);\n            }\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case 1\n        System.out.println(solution.generate_integers(2, 8)); // Expected: [2, 4, 6, 8]\n        \n        // Test case 2\n        System.out.println(solution.generate_integers(8, 2)); // Expected: [2, 4, 6, 8]\n        \n        // Test case 3\n        System.out.println(solution.generate_integers(10, 14)); // Expected: []\n    }\n}\n"}
{"task_id": "Java/0", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Check if in given list of numbers, are any two numbers closer to each other than given threshold.\n     *\n     * @param numbers List of Double values to be checked.\n     * @param threshold The threshold value for closeness check.\n     * @return true if there exists at least one pair of elements that are closer than the threshold; false otherwise.\n     */\n    public boolean has_close_elements(List<Double> numbers, double threshold) {\n        // Sort the list\n        Collections.sort(numbers);\n\n        // Iterate through the sorted list and check for closeness\n        for (int i = 0; i < numbers.size() - 1; i++) {\n            if (numbers.get(i + 1) - numbers.get(i) < threshold) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        List<Double> testList1 = Arrays.asList(1.0, 2.0, 3.0);\n        double threshold1 = 0.5;\n        System.out.println(solution.has_close_elements(testList1, threshold1)); // Expected: false\n\n        // Test case 2\n        List<Double> testList2 = Arrays.asList(1.0, 2.8, 3.0, 4.0, 5.0, 2.0);\n        double threshold2 = 0.3;\n        System.out.println(solution.has_close_elements(testList2, threshold2)); // Expected: true\n\n        // Additional test case\n        List<Double> testList3 = Arrays.asList(1.0, 1.4, 2.5, 3.6);\n        double threshold3 = 0.9;\n        System.out.println(solution.has_close_elements(testList3, threshold3)); // Expected: true\n\n        // Additional test case\n        List<Double> testList4 = Arrays.asList(1.0, 2.0, 3.0, 4.0);\n        double threshold4 = 1.5;\n        System.out.println(solution.has_close_elements(testList4, threshold4)); // Expected: false\n    }\n}\n"}
{"task_id": "Java/1", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Splits a string containing multiple groups of nested parentheses into separate balanced groups.\n     *\n     * @param paren_string The input string with groups of nested parentheses.\n     * @return A list of strings, each representing a separated group of nested parentheses.\n     */\n    public List<String> separate_paren_groups(String paren_string) {\n        // Remove all spaces from the input string\n        String noSpaceString = paren_string.replaceAll(\"\\\\s+\", \"\");\n        \n        List<String> result = new ArrayList<>();\n        int balance = 0;\n        StringBuilder currentGroup = new StringBuilder();\n        \n        for (char c : noSpaceString.toCharArray()) {\n            if (c == '(') {\n                balance++;\n            } else if (c == ')') {\n                balance--;\n            }\n            \n            currentGroup.append(c);\n            \n            // When the balance is zero, we have a complete group\n            if (balance == 0 && !currentGroup.toString().isEmpty()) {\n                result.add(currentGroup.toString());\n                currentGroup = new StringBuilder(); // Reset for next group\n            }\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        List<String> groups1 = solution.separate_paren_groups(\"( ) (( )) (( )( ))\");\n        System.out.println(groups1); // Expected: [\"()\", \"(())\", \"(()())\"]\n        \n        List<String> groups2 = solution.separate_paren_groups(\"() (()) ()\");\n        System.out.println(groups2); // Expected: [\"()\", \"(())\", \"()\"]\n    }\n}\n"}
{"task_id": "Java/2", "generation": "import org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nclass SolutionTest {\n    @Test\n    void testTruncateNumber() {\n        Solution solution = new Solution();\n        \n        // Test with positive floating point number\n        assertEquals(0.5, solution.truncate_number(3.5), 0.01);\n        \n        // Additional tests can be added here:\n        // Test with a whole number (should return 0)\n        assertEquals(0.0, solution.truncate_number(4.0), 0.01);\n\n        // Test with another positive floating point number\n        assertEquals(0.75, solution.truncate_number(2.75), 0.01);\n        \n        // Test with a very small decimal part\n        assertEquals(0.001, solution.truncate_number(3.001), 0.001);\n\n        // Test with zero (should return 0)\n        assertEquals(0.0, solution.truncate_number(0.0), 0.01);\n    }\n}\n"}
{"task_id": "Java/3", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Checks if at any point the account balance falls below zero.\n     *\n     * @param operations List of deposit (positive) and withdrawal (negative) operations.\n     * @return true if balance goes below zero, false otherwise.\n     */\n    public boolean below_zero(List<Integer> operations) {\n        int balance = 0; // Start with a zero balance\n        for (int operation : operations) {\n            balance += operation;\n            if (balance < 0) {\n                return true; // Balance fell below zero\n            }\n        }\n        return false; // Never went below zero\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.below_zero(Arrays.asList(1, 2, 3))); // Expected: false\n        System.out.println(solution.below_zero(Arrays.asList(1, 2, -4, 5))); // Expected: true\n        System.out.println(solution.below_zero(Arrays.asList(-1, 2, 3))); // Expected: true\n        System.out.println(solution.below_zero(Arrays.asList(0, 0, 0))); // Expected: false\n        System.out.println(solution.below_zero(Arrays.asList(5, -10, 15))); // Expected: true\n    }\n}\n"}
{"task_id": "Java/4", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * For a given list of input numbers, calculate Mean Absolute Deviation\n     * around the mean of this dataset.\n     * Mean Absolute Deviation is the average absolute difference between each\n     * element and a centerpoint (mean in this case):\n     * MAD = average | x - x_mean |\n     *\n     * @param numbers List of Double values for which to calculate MAD\n     * @return The calculated Mean Absolute Deviation as double.\n     */\n    public double mean_absolute_deviation(List<Double> numbers) {\n        if (numbers == null || numbers.isEmpty()) return 0.0;\n\n        // Calculate the mean\n        double sum = 0;\n        for (Double number : numbers) {\n            sum += number;\n        }\n        double mean = sum / numbers.size();\n\n        // Calculate the Mean Absolute Deviation\n        double madSum = 0;\n        for (Double number : numbers) {\n            madSum += Math.abs(number - mean);\n        }\n\n        return madSum / numbers.size();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1: Normal list of numbers\n        List<Double> testList1 = Arrays.asList(1.0, 2.0, 3.0, 4.0);\n        System.out.println(\"MAD for [1.0, 2.0, 3.0, 4.0]: \" + solution.mean_absolute_deviation(testList1)); // Expected: 1.0\n\n        // Test case 2: List with all elements the same\n        List<Double> testList2 = Arrays.asList(5.0, 5.0, 5.0);\n        System.out.println(\"MAD for [5.0, 5.0, 5.0]: \" + solution.mean_absolute_deviation(testList2)); // Expected: 0.0\n\n        // Test case 3: List with negative numbers\n        List<Double> testList3 = Arrays.asList(-1.0, -2.0, -3.0);\n        System.out.println(\"MAD for [-1.0, -2.0, -3.0]: \" + solution.mean_absolute_deviation(testList3)); // Expected: 1.0\n\n        // Test case 4: Empty list\n        List<Double> testList4 = new ArrayList<>();\n        System.out.println(\"MAD for []: \" + solution.mean_absolute_deviation(testList4)); // Expected: 0.0\n    }\n}\n"}
{"task_id": "Java/5", "generation": "import org.junit.jupiter.api.Test;\nimport java.util.Arrays;\nimport java.util.List;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nclass Solution {\n    /**\n     * Insert a number 'delimiter' between every two consecutive elements of input list `numbers'\n     */\n    public List<Integer> intersperse(List<Integer> numbers, int delimiter) {\n        if (numbers.isEmpty()) {\n            return new ArrayList<>();\n        }\n\n        List<Integer> result = new ArrayList<>(numbers.size() + (numbers.size() - 1));\n        for (int i = 0; i < numbers.size(); i++) {\n            result.add(numbers.get(i));\n            if (i != numbers.size() - 1) {\n                result.add(delimiter);\n            }\n        }\n\n        return result;\n    }\n\n    @Test\n    public void testIntersperseEmptyList() {\n        List<Integer> input = new ArrayList<>();\n        int delimiter = 4;\n        List<Integer> expectedOutput = new ArrayList<>();\n        assertEquals(expectedOutput, intersperse(input, delimiter));\n    }\n\n    @Test\n    public void testIntersperseNonEmptyList() {\n        List<Integer> input = Arrays.asList(1, 2, 3);\n        int delimiter = 4;\n        List<Integer> expectedOutput = Arrays.asList(1, 4, 2, 4, 3);\n        assertEquals(expectedOutput, intersperse(input, delimiter));\n    }\n}\n"}
{"task_id": "Java/6", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n     * For each of the group, output the deepest level of nesting of parentheses.\n     * E.g. (()()) has maximum two levels of nesting while ((())) has three.\n     *\n     * @param paren_string The input string containing groups of nested parentheses\n     * @return A list of integers representing the deepest level of nesting for each group\n     */\n    public List<Integer> parse_nested_parens(String paren_string) {\n        String[] groups = paren_string.split(\" \");\n        List<Integer> result = new ArrayList<>();\n        \n        for (String group : groups) {\n            int maxDepth = 0;\n            int currentDepth = 0;\n            \n            for (char c : group.toCharArray()) {\n                if (c == '(') {\n                    currentDepth++;\n                    maxDepth = Math.max(maxDepth, currentDepth);\n                } else if (c == ')') {\n                    currentDepth--;\n                }\n            }\n            \n            result.add(maxDepth);\n        }\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        List<Integer> testResult = solution.parse_nested_parens(\"(()()) ((())) () ((())()())\");\n        System.out.println(testResult); // Expected output: [2, 3, 1, 3]\n        \n        // Additional tests\n        List<Integer> testResult2 = solution.parse_nested_parens(\"(()) (())\");\n        System.out.println(testResult2); // Expected output: [2, 2]\n    }\n}\n"}
{"task_id": "Java/7", "generation": "import org.junit.jupiter.api.Test;\nimport java.util.Arrays;\nimport java.util.List;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nclass SolutionTest {\n    @Test\n    void testFilterBySubstringEmptyList() {\n        List<String> input = Arrays.asList();\n        String substring = \"a\";\n        List<String> expectedOutput = Arrays.asList();\n\n        Solution solution = new Solution();\n        List<String> actualOutput = solution.filter_by_substring(input, substring);\n\n        assertEquals(expectedOutput, actualOutput);\n    }\n\n    @Test\n    void testFilterBySubstringWithMatchingStrings() {\n        List<String> input = Arrays.asList(\"abc\", \"bacd\", \"cde\", \"array\");\n        String substring = \"a\";\n        List<String> expectedOutput = Arrays.asList(\"abc\", \"bacd\", \"array\");\n\n        Solution solution = new Solution();\n        List<String> actualOutput = solution.filter_by_substring(input, substring);\n\n        assertEquals(expectedOutput, actualOutput);\n    }\n\n    @Test\n    void testFilterBySubstringNoMatch() {\n        List<String> input = Arrays.asList(\"abc\", \"bacd\", \"cde\");\n        String substring = \"z\";\n        List<String> expectedOutput = Arrays.asList();\n\n        Solution solution = new Solution();\n        List<String> actualOutput = solution.filter_by_substring(input, substring);\n\n        assertEquals(expectedOutput, actualOutput);\n    }\n}\n"}
{"task_id": "Java/8", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n     * Empty sum should be equal to 0 and empty product should be equal to 1.\n     *\n     * @param numbers List of integers\n     * @return A list containing two elements: [sum, product]\n     */\n    public List<Integer> sum_product(List<Integer> numbers) {\n        int sum = 0;\n        int product = 1;\n\n        for (int number : numbers) {\n            sum += number;\n            product *= number;\n        }\n\n        return Arrays.asList(sum, product);\n    }\n\n    // Test the method with some example inputs\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1: Empty list\n        System.out.println(solution.sum_product(new ArrayList<>())); // Expected output: [0, 1]\n\n        // Test case 2: List of integers\n        System.out.println(solution.sum_product(Arrays.asList(1, 2, 3, 4))); // Expected output: [10, 24]\n    }\n}\n"}
{"task_id": "Java/9", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * From a given list of integers, generate a list of rolling maximum element found until given moment\n     * in the sequence.\n     *\n     * @param numbers List of integers to process.\n     * @return A new list containing the rolling max values.\n     */\n    public List<Integer> rolling_max(List<Integer> numbers) {\n        List<Integer> result = new ArrayList<>();\n        if (numbers == null || numbers.isEmpty()) return result;\n\n        int currentMax = Integer.MIN_VALUE;\n        for (int number : numbers) {\n            if (number > currentMax) {\n                currentMax = number;\n            }\n            result.add(currentMax);\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        List<Integer> input1 = Arrays.asList(1, 2, 3, 2, 3, 4, 2);\n        List<Integer> expectedOutput1 = Arrays.asList(1, 2, 3, 3, 3, 4, 4);\n        System.out.println(\"Test Case 1: \" + solution.rolling_max(input1).equals(expectedOutput1));\n\n        // Test case 2\n        List<Integer> input2 = Arrays.asList();\n        List<Integer> expectedOutput2 = Arrays.asList();\n        System.out.println(\"Test Case 2: \" + solution.rolling_max(input2).equals(expectedOutput2));\n\n        // Test case 3\n        List<Integer> input3 = Arrays.asList(5, 4, 6, 7, 3);\n        List<Integer> expectedOutput3 = Arrays.asList(5, 5, 6, 7, 7);\n        System.out.println(\"Test Case 3: \" + solution.rolling_max(input3).equals(expectedOutput3));\n    }\n}\n"}
{"task_id": "Java/10", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Test if given string is a palindrome.\n     */\n    public boolean isPalindrome(String string) {\n        int i = 0;\n        int j = string.length() - 1;\n        while (i < j) {\n            if (string.charAt(i) != string.charAt(j)) {\n                return false;\n            }\n            i++;\n            j--;\n        }\n        return true;\n    }\n\n    /**\n     * Find the shortest palindrome that begins with a supplied string.\n     */\n    public String make_palindrome(String string) {\n        if (string == null || string.length() <= 1) {\n            return string;\n        }\n\n        int n = string.length();\n        for (int i = n; i >= 0; i--) {\n            if (isPalindrome(string.substring(0, i))) {\n                StringBuilder prefixToReverse = new StringBuilder(string.substring(i));\n                return string + prefixToReverse.reverse().toString();\n            }\n        }\n        // This should never happen as an empty string is a palindrome.\n        return \"\";\n    }\n}\n"}
{"task_id": "Java/11", "generation": "class Solution {\n    /**\n     * Perform binary XOR on two input strings consisting only of 1s and 0s.\n     *\n     * @param a first string consisting of 1s and 0s\n     * @param b second string consisting of 1s and 0s\n     * @return the result of performing binary XOR on these inputs as a string\n     */\n    public String string_xor(String a, String b) {\n        StringBuilder xorResult = new StringBuilder();\n        \n        // Ensure both strings are of equal length by padding with zeros if necessary.\n        int maxLength = Math.max(a.length(), b.length());\n        while (a.length() < maxLength) a = \"0\" + a;\n        while (b.length() < maxLength) b = \"0\" + b;\n\n        for (int i = 0; i < maxLength; i++) {\n            // Perform XOR on each character and append to the result.\n            char xorChar = ((a.charAt(i) == '1') ^ (b.charAt(i) == '1')) ? '1' : '0';\n            xorResult.append(xorChar);\n        }\n        \n        return xorResult.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.string_xor(\"010\", \"110\")); // Expected: \"100\"\n        System.out.println(solution.string_xor(\"111\", \"000\")); // Expected: \"111\"\n        System.out.println(solution.string_xor(\"101010\", \"111111\")); // Expected: \"010101\"\n    }\n}\n"}
{"task_id": "Java/12", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public Optional<String> longest(List<String> strings) {\n        if (strings.isEmpty()) return Optional.empty();\n        \n        String longestString = \"\";\n        int maxLength = 0;\n        \n        for (String str : strings) {\n            if (str.length() > maxLength) {\n                maxLength = str.length();\n                longestString = str;\n            }\n        }\n        \n        return Optional.of(longestString);\n    }\n}\n"}
{"task_id": "Java/13", "generation": "import org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nclass Solution {\n    /**\n     * Return a greatest common divisor of two integers a and b\n     */\n    public int greatest_common_divisor(int a, int b) {\n        while (b != 0) {\n            int temp = b;\n            b = a % b;\n            a = temp;\n        }\n        return a;\n    }\n\n    // Test cases for the greatest_common_divisor method\n    @Test\n    public void testGCD() {\n        assertEquals(1, greatest_common_divisor(3, 5), \"GCD of 3 and 5 should be 1\");\n        assertEquals(5, greatest_common_divisor(25, 15), \"GCD of 25 and 15 should be 5\");\n        assertEquals(6, greatest_common_divisor(18, 24), \"GCD of 18 and 24 should be 6\");\n        assertEquals(7, greatest_common_divisor(35, 49), \"GCD of 35 and 49 should be 7\");\n    }\n}\n"}
{"task_id": "Java/14", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Return list of all prefixes from shortest to longest of the input string.\n     *\n     * @param string The input string for generating prefixes.\n     * @return A List containing all prefixes of the given string, sorted by length.\n     */\n    public List<String> all_prefixes(String string) {\n        List<String> result = new ArrayList<>();\n        for (int i = 1; i <= string.length(); i++) {\n            result.add(string.substring(0, i));\n        }\n        return result;\n    }\n}\n\nclass SolutionTest {\n    @org.junit.Test\n    public void testAllPrefixes() {\n        Solution solution = new Solution();\n        \n        // Test case 1: Normal case with \"abc\"\n        List<String> expected1 = Arrays.asList(\"a\", \"ab\", \"abc\");\n        List<String> result1 = solution.all_prefixes(\"abc\");\n        org.junit.Assert.assertEquals(expected1, result1);\n        \n        // Test case 2: Empty string\n        List<String> expected2 = new ArrayList<>();\n        List<String> result2 = solution.all_prefixes(\"\");\n        org.junit.Assert.assertEquals(expected2, result2);\n        \n        // Test case 3: Single character string\n        List<String> expected3 = Arrays.asList(\"a\");\n        List<String> result3 = solution.all_prefixes(\"a\");\n        org.junit.Assert.assertEquals(expected3, result3);\n    }\n}\n"}
{"task_id": "Java/15", "generation": "class Solution {\n    public String string_sequence(int n) {\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i <= n; i++) {\n            sb.append(i);\n            if (i < n) {\n                sb.append(\" \");\n            }\n        }\n        return sb.toString();\n    }\n}\n"}
{"task_id": "Java/16", "generation": "import java.util.HashSet;\nimport java.util.Set;\n\nclass Solution {\n    /**\n     * Given a string, find out how many distinct characters (regardless of case) does it consist of.\n     *\n     * @param string the input string to process\n     * @return the number of distinct characters in the string, ignoring case\n     */\n    public int count_distinct_characters(String string) {\n        if (string == null || string.isEmpty()) return 0;\n\n        // Convert the entire string to lower case to ignore case differences.\n        String lowerCaseString = string.toLowerCase();\n\n        // Use a Set to store unique characters.\n        Set<Character> distinctChars = new HashSet<>();\n        \n        for (char c : lowerCaseString.toCharArray()) {\n            distinctChars.add(c);\n        }\n\n        return distinctChars.size();\n    }\n    \n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.count_distinct_characters(\"xyzXYZ\")); // Expected output: 3\n        System.out.println(solution.count_distinct_characters(\"Jerry\"));   // Expected output: 4\n        System.out.println(solution.count_distinct_characters(\"AaBbCc\")); // Expected output: 3\n        System.out.println(solution.count_distinct_characters(\"\"));       // Expected output: 0\n    }\n}\n"}
{"task_id": "Java/17", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Parses a string representing musical notes in a special ASCII format.\n     *\n     * @param string The input string with musical notes represented as \"o\", \"o|\" and \".|\"\n     * @return A list of integers corresponding to how many beats each note lasts\n     */\n    public List<Integer> parse_music(String string) {\n        List<Integer> result = new ArrayList<>();\n        String[] tokens = string.split(\" \");\n        \n        for (String token : tokens) {\n            switch (token) {\n                case \"o\":\n                    result.add(4);\n                    break;\n                case \"o|\":\n                    result.add(2);\n                    break;\n                case \".|\":\n                    result.add(1);\n                    break;\n                default:\n                    throw new IllegalArgumentException(\"Invalid note: \" + token);\n            }\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test the parse_music method\n        List<Integer> expectedOutput = Arrays.asList(4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4);\n        List<Integer> actualOutput = solution.parse_music(\"o o| .| o| o| .| .| .| .| o o\");\n        \n        System.out.println(\"Expected Output: \" + expectedOutput);\n        System.out.println(\"Actual Output:   \" + actualOutput);\n\n        // Check if the output matches the expected result\n        boolean isCorrect = expectedOutput.equals(actualOutput);\n        System.out.println(\"Test Result: \" + (isCorrect ? \"Pass\" : \"Fail\"));\n    }\n}\n"}
{"task_id": "Java/18", "generation": "class Solution {\n    /**\n     * Find how many times a given substring can be found in the original string.\n     * Count overlaping cases.\n     *\n     * @param string The original string to search within.\n     * @param substring The substring to find occurrences of.\n     * @return The number of times the substring is found, including overlaps.\n     */\n    public int how_many_times(String string, String substring) {\n        if (substring.isEmpty() || string.length() < substring.length()) return 0;\n\n        int count = 0;\n        for (int i = 0; i <= string.length() - substring.length(); i++) {\n            if (string.substring(i, i + substring.length()).equals(substring)) {\n                count++;\n            }\n        }\n\n        return count;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.how_many_times(\"\", \"a\"));       // Expected output: 0\n        System.out.println(solution.how_many_times(\"aaa\", \"a\"));    // Expected output: 3\n        System.out.println(solution.how_many_times(\"aaaa\", \"aa\"));  // Expected output: 3\n        System.out.println(solution.how_many_times(\"abcabcabc\", \"abc\")); // Expected output: 3\n        System.out.println(solution.how_many_times(\"ababa\", \"aba\"));    // Expected output: 2 (overlapping)\n    }\n}\n"}
{"task_id": "Java/19", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Input is a space-delimited string of numberals from 'zero' to 'nine'.\n     * Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n     * Return the string with numbers sorted from smallest to largest\n     */\n    public String sort_numbers(String numbers) {\n        // Mapping of number words to their numeric values.\n        Map<String, Integer> wordToNum = new HashMap<>();\n        wordToNum.put(\"zero\", 0);\n        wordToNum.put(\"one\", 1);\n        wordToNum.put(\"two\", 2);\n        wordToNum.put(\"three\", 3);\n        wordToNum.put(\"four\", 4);\n        wordToNum.put(\"five\", 5);\n        wordToNum.put(\"six\", 6);\n        wordToNum.put(\"seven\", 7);\n        wordToNum.put(\"eight\", 8);\n        wordToNum.put(\"nine\", 9);\n\n        // Split the input string into an array of words.\n        String[] numberWords = numbers.split(\" \");\n        \n        // Sort the array based on their numeric values.\n        Arrays.sort(numberWords, Comparator.comparingInt(wordToNum::get));\n        \n        // Join the sorted words back into a single string.\n        return String.join(\" \", numberWords);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.sort_numbers(\"three one five\")); // Expected: \"one three five\"\n        System.out.println(solution.sort_numbers(\"nine eight seven\")); // Expected: \"seven eight nine\"\n        System.out.println(solution.sort_numbers(\"four two zero six\")); // Expected: \"zero two four six\"\n    }\n}\n"}
{"task_id": "Java/20", "generation": "import java.util.*;\n\nclass Solution {\n\n    /**\n     * From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n     * other and return them in order (smaller number, larger number).\n     *\n     * @param numbers List<Double> - A list of double values.\n     * @return List<Double> - A list containing the two closest elements.\n     */\n    public List<Double> find_closest_elements(List<Double> numbers) {\n        // Sort the list to make finding the closest pair easier\n        Collections.sort(numbers);\n\n        double minDiff = Double.MAX_VALUE;\n        List<Double> result = new ArrayList<>();\n\n        for (int i = 0; i < numbers.size() - 1; i++) {\n            double diff = Math.abs(numbers.get(i) - numbers.get(i + 1));\n            if (diff < minDiff) {\n                minDiff = diff;\n                result.clear();\n                result.add(numbers.get(i));\n                result.add(numbers.get(i + 1));\n            }\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        List<Double> testList1 = Arrays.asList(1.0, 2.0, 3.0, 4.0, 5.0, 2.2);\n        System.out.println(solution.find_closest_elements(testList1)); // Expected: [2.0, 2.2]\n\n        // Test case 2\n        List<Double> testList2 = Arrays.asList(1.0, 2.0, 3.0, 4.0, 5.0, 2.0);\n        System.out.println(solution.find_closest_elements(testList2)); // Expected: [2.0, 2.0]\n\n        // Additional test case\n        List<Double> testList3 = Arrays.asList(1.5, 3.2, 4.8, 6.7, 9.0, 3.3);\n        System.out.println(solution.find_closest_elements(testList3)); // Expected: [3.2, 3.3]\n    }\n}\n"}
{"task_id": "Java/21", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given list of numbers (of at least two elements), apply a linear transform to that list,\n     * such that the smallest number will become 0 and the largest will become 1.\n     *\n     * @param numbers List of Double values\n     * @return A new list where each element is rescaled between 0 and 1 based on its relative position in the original list.\n     */\n    public List<Double> rescale_to_unit(List<Double> numbers) {\n        if (numbers == null || numbers.size() < 2) {\n            throw new IllegalArgumentException(\"List must contain at least two elements.\");\n        }\n\n        double min = Collections.min(numbers);\n        double max = Collections.max(numbers);\n\n        List<Double> scaledNumbers = new ArrayList<>();\n        for (Double number : numbers) {\n            // Applying the linear transformation formula\n            double rescaledValue = (number - min) / (max - min);\n            scaledNumbers.add(rescaledValue);\n        }\n\n        return scaledNumbers;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        List<Double> testList1 = Arrays.asList(1.0, 2.0, 3.0, 4.0, 5.0);\n        System.out.println(solution.rescale_to_unit(testList1)); // Expected: [0.0, 0.25, 0.5, 0.75, 1.0]\n\n        List<Double> testList2 = Arrays.asList(3.0, -1.0, 4.0);\n        System.out.println(solution.rescale_to_unit(testList2)); // Expected: [0.6666666666666666, 0.0, 1.0]\n\n        List<Double> testList3 = Arrays.asList(5.0, 5.0); // Edge case with all elements being the same\n        System.out.println(solution.rescale_to_unit(testList3)); // Expected: [0.0, 0.0]\n    }\n}\n"}
{"task_id": "Java/22", "generation": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\nclass Solution {\n    /**\n     * Filter given list of any values only for integers.\n     *\n     * @param values List of objects to be filtered.\n     * @return A new list containing only Integer elements from the input list.\n     */\n    public List<Integer> filter_integers(List<Object> values) {\n        List<Integer> result = new ArrayList<>();\n        for (Object value : values) {\n            if (value instanceof Integer) {\n                result.add((Integer) value);\n            }\n        }\n        return result;\n    }\n}\n"}
{"task_id": "Java/23", "generation": "class Solution {\n    /**\n     * Return length of given string\n     *\n     * @param string The input string.\n     * @return Length of the input string.\n     */\n    public int strlen(String string) {\n        return string.length();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(\"Testing with empty string: \" + (solution.strlen(\"\") == 0));\n        System.out.println(\"Testing with 'abc': \" + (solution.strlen(\"abc\") == 3));\n    }\n}\n"}
{"task_id": "Java/24", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * For a given number n, find the largest number that divides n evenly, smaller than n.\n     *\n     * @param n The input integer to find the divisor for.\n     * @return The largest divisor of n which is less than n.\n     */\n    public int largest_divisor(int n) {\n        // Start checking from n-1 down to 2\n        for (int i = n - 1; i > 1; --i) {\n            if (n % i == 0) {\n                return i;\n            }\n        }\n        // If no divisor is found, which should not happen for n >= 4,\n        // but for completeness, we return 1.\n        return 1;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.largest_divisor(15)); // Expected output: 5\n        System.out.println(solution.largest_divisor(28)); // Expected output: 14\n        System.out.println(solution.largest_divisor(37)); // Expected output: 1 (since 37 is prime)\n    }\n}\n"}
{"task_id": "Java/25", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Return list of prime factors of given integer in the order from smallest to largest.\n     * Each of the factors should be listed number of times corresponding to how many times it appears in factorization.\n     * Input number should be equal to the product of all factors\n     */\n    public List<Integer> factorize(int n) {\n        List<Integer> factors = new ArrayList<>();\n        \n        // Divide by 2 until odd\n        while (n % 2 == 0) {\n            factors.add(2);\n            n /= 2;\n        }\n        \n        // Check for all the possible odd numbers\n        for (int i = 3; i <= Math.sqrt(n); i += 2) {\n            while (n % i == 0) {\n                factors.add(i);\n                n /= i;\n            }\n        }\n\n        // If n is a prime number greater than 2\n        if (n > 2) {\n            factors.add(n);\n        }\n        \n        return factors;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.factorize(8));   // Expected: [2, 2, 2]\n        System.out.println(solution.factorize(25));  // Expected: [5, 5]\n        System.out.println(solution.factorize(70));  // Expected: [2, 5, 7]\n        \n        // Additional test cases\n        System.out.println(solution.factorize(18));  // Expected: [2, 3, 3]\n        System.out.println(solution.factorize(97));  // Expected: [97] (since 97 is a prime number)\n    }\n}\n"}
{"task_id": "Java/26", "generation": "import java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nclass Solution {\n    /**\n     * From a list of integers, remove all elements that occur more than once.\n     * Keep order of elements left the same as in the input.\n     *\n     * @param numbers List of integers\n     * @return A new list with duplicates removed\n     */\n    public List<Integer> remove_duplicates(List<Integer> numbers) {\n        Map<Integer, Integer> countMap = new LinkedHashMap<>();\n        \n        // Count occurrences while preserving order\n        for (Integer number : numbers) {\n            countMap.put(number, countMap.getOrDefault(number, 0) + 1);\n        }\n        \n        // Filter out elements that occur more than once\n        return countMap.entrySet().stream()\n                .filter(entry -> entry.getValue() == 1)\n                .map(Map.Entry::getKey)\n                .collect(Collectors.toList());\n    }\n\n    @Test\n    public void testRemoveDuplicates() {\n        List<Integer> input = Arrays.asList(1, 2, 3, 2, 4);\n        List<Integer> expectedOutput = Arrays.asList(1, 3, 4);\n        \n        assertEquals(expectedOutput, remove_duplicates(input));\n    }\n}\n"}
{"task_id": "Java/27", "generation": "class Solution {\n    /**\n     * For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n     *\n     * @param string The input string whose characters' cases are to be flipped.\n     * @return A new string with each character's case flipped.\n     */\n    public String flip_case(String string) {\n        StringBuilder result = new StringBuilder();\n        \n        for (char c : string.toCharArray()) {\n            if (Character.isUpperCase(c)) {\n                result.append(Character.toLowerCase(c));\n            } else if (Character.isLowerCase(c)) {\n                result.append(Character.toUpperCase(c));\n            } else {\n                // If the character is not a letter, append it as-is.\n                result.append(c);\n            }\n        }\n\n        return result.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.flip_case(\"Hello\")); // Expected: \"hELLO\"\n        System.out.println(solution.flip_case(\"Java\"));  // Expected: \"jAVA\"\n        System.out.println(solution.flip_case(\"123abcABC\")); // Expected: \"123ABCabc\"\n    }\n}\n"}
{"task_id": "Java/28", "generation": "import java.util.Arrays;\nimport java.util.List;\n\nclass Solution {\n    /**\n     * Concatenates list of strings into a single string.\n     *\n     * @param strings List of strings to concatenate.\n     * @return A single concatenated string.\n     */\n    public String concatenate(List<String> strings) {\n        if (strings == null || strings.isEmpty()) {\n            return \"\";\n        }\n        \n        StringBuilder sb = new StringBuilder();\n        for (String str : strings) {\n            sb.append(str);\n        }\n        return sb.toString();\n    }\n\n    // A simple test method to verify the functionality\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.concatenate(Arrays.asList()));  // Expected: \"\"\n        System.out.println(solution.concatenate(Arrays.asList(\"a\", \"b\", \"c\")));  // Expected: \"abc\"\n    }\n}\n"}
{"task_id": "Java/29", "generation": "import java.util.*;\nimport java.util.stream.Collectors;\n\nclass Solution {\n    /**\n     * Filter an input list of strings only for ones that start with a given prefix.\n     *\n     * @param strings List of strings to be filtered.\n     * @param prefix The prefix string used as the filter criterion.\n     * @return A new list containing only the strings from the original list that start with the specified prefix.\n     */\n    public List<String> filter_by_prefix(List<String> strings, String prefix) {\n        return strings.stream()\n                .filter(s -> s.startsWith(prefix))\n                .collect(Collectors.toList());\n    }\n\n    // Method to test the filter_by_prefix function\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1: Empty list\n        List<String> result1 = solution.filter_by_prefix(List.of(), \"a\");\n        System.out.println(result1); // Expected output: []\n\n        // Test case 2: Normal case with some strings starting with 'a'\n        List<String> result2 = solution.filter_by_prefix(Arrays.asList(\"abc\", \"bcd\", \"cde\", \"array\"), \"a\");\n        System.out.println(result2); // Expected output: [abc, array]\n\n        // Additional test cases\n        // Test case 3: All strings start with the prefix\n        List<String> result3 = solution.filter_by_prefix(Arrays.asList(\"apple\", \"apricot\", \"banana\", \"avocado\"), \"a\");\n        System.out.println(result3); // Expected output: [apple, apricot, avocado]\n\n        // Test case 4: No string starts with the prefix\n        List<String> result4 = solution.filter_by_prefix(Arrays.asList(\"dog\", \"cat\", \"fish\"), \"b\");\n        System.out.println(result4); // Expected output: []\n\n        // Test case 5: Prefix is an empty string, should return all strings\n        List<String> result5 = solution.filter_by_prefix(Arrays.asList(\"one\", \"two\", \"three\"), \"\");\n        System.out.println(result5); // Expected output: [one, two, three]\n    }\n}\n"}
{"task_id": "Java/30", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return only positive numbers in the list.\n     *\n     * @param l List of integers\n     * @return A new list containing only the positive integers from the input list\n     */\n    public List<Integer> get_positive(List<Integer> l) {\n        return l.stream()\n                .filter(x -> x > 0)\n                .collect(Collectors.toList());\n    }\n\n    /**\n     * Test method to check if the get_positive function works correctly.\n     */\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        List<Integer> list1 = Arrays.asList(-1, 2, -4, 5, 6);\n        System.out.println(\"Test Case 1: \" + solution.get_positive(list1)); // Expected output: [2, 5, 6]\n\n        // Test case 2\n        List<Integer> list2 = Arrays.asList(5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10);\n        System.out.println(\"Test Case 2: \" + solution.get_positive(list2)); // Expected output: [5, 3, 2, 3, 9, 123, 1]\n\n        // Test case 3\n        List<Integer> list3 = Arrays.asList(-7, -8, -9);\n        System.out.println(\"Test Case 3: \" + solution.get_positive(list3)); // Expected output: []\n\n        // Test case 4\n        List<Integer> list4 = Arrays.asList(0, 1, 2, 3);\n        System.out.println(\"Test Case 4: \" + solution.get_positive(list4)); // Expected output: [1, 2, 3]\n    }\n}\n"}
{"task_id": "Java/31", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return true if a given number is prime, and false otherwise.\n     */\n    public boolean is_prime(int n) {\n        // Corner case handling\n        if (n <= 1) return false;\n        if (n == 2 || n == 3) return true;\n\n        // This is checked so that we can skip middle five numbers in below loop\n        if (n % 2 == 0 || n % 3 == 0) return false;\n\n        for (int i = 5; i * i <= n; i += 6) {\n            if (n % i == 0 || n % (i + 2) == 0)\n                return false;\n        }\n\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.is_prime(6));     // Expected: false\n        System.out.println(solution.is_prime(101));   // Expected: true\n        System.out.println(solution.is_prime(11));    // Expected: true\n        System.out.println(solution.is_prime(13441)); // Expected: true\n        System.out.println(solution.is_prime(61));    // Expected: true\n        System.out.println(solution.is_prime(4));     // Expected: false\n        System.out.println(solution.is_prime(1));     // Expected: false\n    }\n}\n"}
{"task_id": "Java/32", "generation": "import org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nclass SolutionTest {\n    private final Solution solution = new Solution();\n\n    @Test\n    void testPoly() {\n        List<Double> coefficients1 = Arrays.asList(1.0, 2.0);\n        assertEquals(-0.5, solution.poly(coefficients1, -0.5), 0.0001);\n\n        List<Double> coefficients2 = Arrays.asList(-6.0, 11.0, -6.0, 1.0);\n        assertEquals(0.0, solution.poly(coefficients2, 1.0), 0.0001);\n    }\n\n    @Test\n    void testFindZero() {\n        List<Double> coefficients1 = Arrays.asList(1.0, 2.0);\n        assertEquals(-0.5, solution.find_zero(coefficients1), 0.0001);\n\n        List<Double> coefficients2 = Arrays.asList(-6.0, 11.0, -6.0, 1.0);\n        // Note: The find_zero method should return one of the roots (1.0, 2.0, or 3.0)\n        assertEquals(1.0, solution.find_zero(coefficients2), 0.0001);\n    }\n}\n"}
{"task_id": "Java/33", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * This function takes a list l and returns a list l' such that\n     * l' is identical to l in the indices that are not divisible by three, while its values at the indicies that are divisible by three are equal\n     * to the values of the corresponding indices of l, but sorted in ascending order.\n     *\n     * @param l The input list of integers.\n     * @return A new list with elements at indices divisible by 3 sorted.\n     */\n    public List<Integer> sort_third(List<Integer> l) {\n        // Extract elements at positions divisible by three\n        ArrayList<Integer> toSort = new ArrayList<>();\n        for (int i = 0; i < l.size(); i++) {\n            if ((i + 1) % 3 == 0) { // Adjusted index to match the problem statement's indexing from 1.\n                toSort.add(l.get(i));\n            }\n        }\n\n        // Sort these elements\n        Collections.sort(toSort);\n\n        // Reinsert sorted elements back into their original positions\n        List<Integer> result = new ArrayList<>(l);\n        for (int i = 0, j = 0; i < l.size(); i++) {\n            if ((i + 1) % 3 == 0) { // Adjusted index to match the problem statement's indexing from 1.\n                result.set(i, toSort.get(j++));\n            }\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        List<Integer> testList1 = Arrays.asList(1, 2, 3);\n        System.out.println(solution.sort_third(testList1)); // Expected: [1, 2, 3]\n\n        List<Integer> testList2 = Arrays.asList(5, 6, 3, 4, 8, 9, 2);\n        System.out.println(solution.sort_third(testList2)); // Expected: [2, 6, 3, 4, 8, 9, 5]\n    }\n}\n"}
{"task_id": "Java/34", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Return sorted unique elements in a list.\n     *\n     * @param l List of integers that may contain duplicates.\n     * @return A new list containing only unique elements from the input list, sorted in ascending order.\n     */\n    public List<Integer> unique(List<Integer> l) {\n        // Use LinkedHashSet to preserve insertion order and remove duplicates\n        Set<Integer> set = new LinkedHashSet<>(l);\n        \n        // Convert the set back to a list and sort it\n        List<Integer> result = new ArrayList<>(set);\n        Collections.sort(result);\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case 1: Normal scenario with duplicates.\n        System.out.println(solution.unique(Arrays.asList(5, 3, 5, 2, 3, 3, 9, 0, 123))); // Expected [0, 2, 3, 5, 9, 123]\n        \n        // Test case 2: Empty list.\n        System.out.println(solution.unique(Arrays.asList())); // Expected []\n        \n        // Test case 3: List with all elements being the same.\n        System.out.println(solution.unique(Arrays.asList(7, 7, 7))); // Expected [7]\n        \n        // Test case 4: List already containing unique elements.\n        System.out.println(solution.unique(Arrays.asList(-1, -2, -3, 0, 1, 2, 3))); // Expected [-3, -2, -1, 0, 1, 2, 3]\n    }\n}\n"}
{"task_id": "Java/35", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Return maximum element in the list.\n     *\n     * @param l List of integers\n     * @return The maximum integer in the list\n     */\n    public int max_element(List<Integer> l) {\n        if (l == null || l.isEmpty()) {\n            throw new IllegalArgumentException(\"List must not be empty or null\");\n        }\n        \n        return Collections.max(l);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case 1\n        List<Integer> list1 = Arrays.asList(1, 2, 3);\n        System.out.println(\"Max element in \" + list1 + \": \" + solution.max_element(list1)); // Expected: 3\n        \n        // Test case 2\n        List<Integer> list2 = Arrays.asList(5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10);\n        System.out.println(\"Max element in \" + list2 + \": \" + solution.max_element(list2)); // Expected: 123\n        \n        // Test case 3 (Edge case with a single element)\n        List<Integer> list3 = Arrays.asList(42);\n        System.out.println(\"Max element in \" + list3 + \": \" + solution.max_element(list3)); // Expected: 42\n    }\n}\n"}
{"task_id": "Java/36", "generation": "import org.junit.Test;\nimport static org.junit.Assert.assertEquals;\n\nclass Solution {\n    public int fizz_buzz(int n) {\n        int count = 0;\n        for (int i = 1; i < n; i++) {\n            if ((i % 11 == 0 || i % 13 == 0)) {\n                String numStr = Integer.toString(i);\n                for (char c : numStr.toCharArray()) {\n                    if (c == '7') count++;\n                }\n            }\n        }\n        return count;\n    }\n\n    @Test\n    public void testFizzBuzz() {\n        assertEquals(0, fizz_buzz(50));\n        assertEquals(2, fizz_buzz(78));\n        assertEquals(3, fizz_buzz(79));\n    }\n}\n"}
{"task_id": "Java/37", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * This function takes a list l and returns a list l' such that\n     * l' is identical to l in the odd indicies, while its values at the even indicies are equal\n     * to the values of the even indicies of l, but sorted.\n     *\n     * @param l The input list.\n     * @return A new list with sorted elements at even indices and original elements at odd indices.\n     */\n    public List<Integer> sort_even(List<Integer> l) {\n        // Extracting even indexed elements\n        ArrayList<Integer> evenIndexedElements = new ArrayList<>();\n        for (int i = 0; i < l.size(); i += 2) {\n            evenIndexedElements.add(l.get(i));\n        }\n\n        // Sorting the extracted even indexed elements\n        Collections.sort(evenIndexedElements);\n\n        // Creating a new list to store the result\n        List<Integer> resultList = new ArrayList<>();\n        int sortedIndex = 0;\n        for (int i = 0; i < l.size(); i++) {\n            if (i % 2 == 0) { // Even index\n                resultList.add(evenIndexedElements.get(sortedIndex++));\n            } else { // Odd index\n                resultList.add(l.get(i));\n            }\n        }\n\n        return resultList;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        List<Integer> test1 = Arrays.asList(1, 2, 3);\n        System.out.println(\"Test 1: \" + solution.sort_even(test1)); // Expected [1, 2, 3]\n\n        List<Integer> test2 = Arrays.asList(5, 6, 3, 4);\n        System.out.println(\"Test 2: \" + solution.sort_even(test2)); // Expected [3, 6, 5, 4]\n    }\n}\n"}
{"task_id": "Java/38", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Returns encoded string by cycling groups of three characters.\n     */\n    public String encodeCyclic(String s) {\n        // Split string to groups. Each of length 3.\n        List<String> groups = new ArrayList<>();\n        for (int i = 0; i < s.length(); i += 3) {\n            groups.add(s.substring(i, Math.min(i + 3, s.length())));\n        }\n        // Cycle elements in each group. Unless group has fewer elements than 3.\n        for (int i = 0; i < groups.size(); i++) {\n            if (groups.get(i).length() == 3) {\n                groups.set(i, groups.get(i).substring(1) + groups.get(i).charAt(0));\n            }\n        }\n        return String.join(\"\", groups);\n    }\n\n    /**\n     * Takes as input string encoded with encodeCyclic function. Returns decoded string.\n     */\n    public String decode_cyclic(String s) {\n        // Split string to groups. Each of length 3.\n        List<String> groups = new ArrayList<>();\n        for (int i = 0; i < s.length(); i += 3) {\n            groups.add(s.substring(i, Math.min(i + 3, s.length())));\n        }\n        // Reverse cycle elements in each group. Unless group has fewer elements than 3.\n        for (int i = 0; i < groups.size(); i++) {\n            if (groups.get(i).length() == 3) {\n                char firstChar = groups.get(i).charAt(2);\n                String restOfGroup = groups.get(i).substring(0, 2);\n                groups.set(i, firstChar + restOfGroup);\n            }\n        }\n        return String.join(\"\", groups);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.decode_cyclic(solution.encodeCyclic(\"hello\")));  // Should print \"hello\"\n        System.out.println(solution.decode_cyclic(solution.encodeCyclic(\"world\")));  // Should print \"world\"\n        System.out.println(solution.decode_cyclic(solution.encodeCyclic(\"java\")));   // Should print \"java\"\n        System.out.println(solution.decode_cyclic(solution.encodeCyclic(\"\")));       // Should print \"\"\n    }\n}\n"}
{"task_id": "Java/39", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int prime_fib(int n) {\n        List<Integer> primes = new ArrayList<>();\n        int fib1 = 0, fib2 = 1;\n        \n        while (primes.size() < n) {\n            int nextFib = fib1 + fib2;\n            if (isPrime(nextFib)) {\n                primes.add(nextFib);\n            }\n            fib1 = fib2;\n            fib2 = nextFib;\n        }\n\n        return primes.get(n - 1);\n    }\n\n    private boolean isPrime(int number) {\n        if (number <= 1) {\n            return false;\n        }\n        for (int i = 2; i * i <= number; i++) {\n            if (number % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.prime_fib(1)); // Expected output: 2\n        System.out.println(solution.prime_fib(2)); // Expected output: 3\n        System.out.println(solution.prime_fib(3)); // Expected output: 5\n        System.out.println(solution.prime_fib(4)); // Expected output: 13\n        System.out.println(solution.prime_fib(5)); // Expected output: 89\n    }\n}\n"}
{"task_id": "Java/40", "generation": "import java.util.*;\n\nclass Solution {\n\n    /**\n     * triples_sum_to_zero takes a list of integers as an input.\n     * It returns True if there are three distinct elements in the list that sum to zero, and False otherwise.\n     */\n    public boolean triples_sum_to_zero(List<Integer> l) {\n        Collections.sort(l); // Sort the list first\n        for (int i = 0; i < l.size() - 2; i++) {\n            int left = i + 1;\n            int right = l.size() - 1;\n            while (left < right) {\n                int sum = l.get(i) + l.get(left) + l.get(right);\n                if (sum == 0) {\n                    return true;\n                } else if (sum < 0) {\n                    left++;\n                } else {\n                    right--;\n                }\n            }\n        }\n        return false;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.triples_sum_to_zero(Arrays.asList(1, 3, 5, 0))); // Expected: false\n        System.out.println(solution.triples_sum_to_zero(Arrays.asList(1, 3, -2, 1))); // Expected: true\n        System.out.println(solution.triples_sum_to_zero(Arrays.asList(1, 2, 3, 7))); // Expected: false\n        System.out.println(solution.triples_sum_to_zero(Arrays.asList(2, 4, -5, 3, 9, 7))); // Expected: true\n        System.out.println(solution.triples_sum_to_zero(Arrays.asList(1))); // Expected: false\n    }\n}\n"}
{"task_id": "Java/41", "generation": "class Solution {\n    /**\n     * Calculates the number of collisions between two sets of n cars driving towards each other.\n     *\n     * @param n The number of cars in each set.\n     * @return The total number of collisions.\n     */\n    public int car_race_collision(int n) {\n        // Since every car from one direction will collide with exactly one car from the opposite direction,\n        // the total number of collisions is equal to the number of cars in one direction (n).\n        return n;\n    }\n}\n"}
{"task_id": "Java/42", "generation": "import org.junit.jupiter.api.Test;\nimport java.util.Arrays;\nimport java.util.List;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n"}
{"task_id": "Java/43", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * pairs_sum_to_zero takes a list of integers as an input.\n     * It returns True if there are two distinct elements in the list that sum to zero, and False otherwise.\n     */\n    public boolean pairs_sum_to_zero(List<Integer> l) {\n        Set<Integer> seen = new HashSet<>();\n        \n        for (int num : l) {\n            // Check if the opposite number exists in the set\n            if (seen.contains(-num)) {\n                return true;\n            }\n            seen.add(num);\n        }\n        return false;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.pairs_sum_to_zero(Arrays.asList(1, 3, 5, 0))); // Expected: false\n        System.out.println(solution.pairs_sum_to_zero(Arrays.asList(1, 3, -2, 1))); // Expected: false\n        System.out.println(solution.pairs_sum_to_zero(Arrays.asList(1, 2, 3, 7))); // Expected: false\n        System.out.println(solution.pairs_sum_to_zero(Arrays.asList(2, 4, -5, 3, 5, 7))); // Expected: true\n        System.out.println(solution.pairs_sum_to_zero(Arrays.asList(1))); // Expected: false\n    }\n}\n"}
{"task_id": "Java/44", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Change numerical base of input number x to a given base.\n     * Returns string representation after the conversion.\n     * Base numbers are less than 10.\n     *\n     * @param x   The integer in decimal (base 10) to be converted\n     * @param base The target base for conversion, which is less than 10\n     * @return A string representing the number in the new base\n     */\n    public String change_base(int x, int base) {\n        if (x == 0) return \"0\";\n        \n        StringBuilder result = new StringBuilder();\n        while (x > 0) {\n            result.insert(0, x % base);\n            x /= base;\n        }\n        return result.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.change_base(8, 3).equals(\"22\") ? \"Test 1 Passed\" : \"Test 1 Failed\");\n        System.out.println(solution.change_base(8, 2).equals(\"1000\") ? \"Test 2 Passed\" : \"Test 2 Failed\");\n        System.out.println(solution.change_base(7, 2).equals(\"111\") ? \"Test 3 Passed\" : \"Test 3 Failed\");\n\n        // Additional test cases\n        System.out.println(solution.change_base(9, 4).equals(\"21\") ? \"Test 4 Passed\" : \"Test 4 Failed\");\n        System.out.println(solution.change_base(0, 5).equals(\"0\") ? \"Test 5 Passed\" : \"Test 5 Failed\");\n    }\n}\n"}
{"task_id": "Java/45", "generation": "class Solution {\n    /**\n     * Given length of a side and height return area for a triangle.\n     *\n     * @param a The length of one side of the triangle.\n     * @param h The height of the triangle from that side.\n     * @return The area of the triangle.\n     */\n    public double triangle_area(double a, double h) {\n        return 0.5 * a * h;\n    }\n}\n"}
{"task_id": "Java/46", "generation": "class Solution {\n    public int fib4(int n) {\n        if (n == 0 || n == 1) return 0;\n        if (n == 2) return 2;\n        if (n == 3) return 0;\n\n        // Initialize the first four numbers of the sequence.\n        int a = 0, b = 0, c = 2, d = 0;\n\n        for (int i = 4; i <= n; ++i) {\n            int next = a + b + c + d;\n            a = b;\n            b = c;\n            c = d;\n            d = next;\n        }\n\n        return d;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.fib4(5));  // Expected output: 4\n        System.out.println(solution.fib4(6));  // Expected output: 8\n        System.out.println(solution.fib4(7));  // Expected output: 14\n    }\n}\n"}
{"task_id": "Java/47", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Return median of elements in the list l.\n     *\n     * @param l List of integers\n     * @return The median value as a double\n     */\n    public double median(List<Integer> l) {\n        Collections.sort(l); // Sort the list to find the median easily\n        int size = l.size();\n        if (size % 2 == 1) { // If odd number of elements, return middle element\n            return l.get(size / 2);\n        } else { // If even number of elements, average the two middle values\n            return (l.get((size - 1) / 2) + l.get(size / 2)) / 2.0;\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        List<Integer> testList1 = Arrays.asList(3, 1, 2, 4, 5);\n        System.out.println(\"Median of \" + testList1 + \": \" + solution.median(testList1)); // Expected: 3\n\n        List<Integer> testList2 = Arrays.asList(-10, 4, 6, 1000, 10, 20);\n        System.out.println(\"Median of \" + testList2 + \": \" + solution.median(testList2)); // Expected: 8.0\n    }\n}\n"}
{"task_id": "Java/48", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Checks if given string is a palindrome.\n     *\n     * @param text The input string to check.\n     * @return true if the string is a palindrome, false otherwise.\n     */\n    public boolean is_palindrome(String text) {\n        int left = 0;\n        int right = text.length() - 1;\n\n        while (left < right) {\n            if (text.charAt(left) != text.charAt(right)) {\n                return false;\n            }\n            left++;\n            right--;\n        }\n\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.is_palindrome(\"\"));       // Expected: true\n        System.out.println(solution.is_palindrome(\"aba\"));    // Expected: true\n        System.out.println(solution.is_palindrome(\"aaaaa\"));  // Expected: true\n        System.out.println(solution.is_palindrome(\"zbcd\"));   // Expected: false\n    }\n}\n"}
{"task_id": "Java/49", "generation": "class Solution {\n    /**\n     * Return 2^n modulo p (be aware of numerics).\n     */\n    public int modp(int n, int p) {\n        long result = 1;\n        long base = 2;\n\n        while (n > 0) {\n            if ((n & 1) == 1) { // If n is odd\n                result = (result * base) % p;\n            }\n            base = (base * base) % p; // Square the base\n            n >>= 1; // Divide n by 2\n        }\n\n        return (int) result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.modp(3, 5));   // Expected output: 3\n        System.out.println(solution.modp(1101, 101)); // Expected output: 2\n        System.out.println(solution.modp(0, 101));    // Expected output: 1\n        System.out.println(solution.modp(3, 11));     // Expected output: 8\n        System.out.println(solution.modp(100, 101));  // Expected output: 1\n    }\n}\n"}
{"task_id": "Java/50", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Returns encoded string by shifting every character by 5 in the alphabet.\n     */\n    public String encodeShift(String s) {\n        StringBuilder sb = new StringBuilder();\n        for (char ch : s.toCharArray()) {\n            // Ensure that only lowercase letters are shifted and wrap around using modulo\n            if (ch >= 'a' && ch <= 'z') {\n                sb.append((char) ('a' + ((ch - 'a' + 5) % 26)));\n            } else {\n                sb.append(ch); // Non-alphabetic characters remain unchanged\n            }\n        }\n        return sb.toString();\n    }\n\n    /**\n     * Takes as input string encoded with encodeShift function. Returns decoded string.\n     */\n    public String decode_shift(String s) {\n        StringBuilder sb = new StringBuilder();\n        for (char ch : s.toCharArray()) {\n            // Ensure that only lowercase letters are shifted and wrap around using modulo\n            if (ch >= 'a' && ch <= 'z') {\n                sb.append((char) ('a' + ((ch - 'a' - 5 + 26) % 26)));\n            } else {\n                sb.append(ch); // Non-alphabetic characters remain unchanged\n            }\n        }\n        return sb.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        String testString = \"hello\";\n        System.out.println(\"Original: \" + testString);\n\n        String encoded = solution.encodeShift(testString);\n        System.out.println(\"Encoded: \" + encoded);\n\n        String decoded = solution.decode_shift(encoded);\n        System.out.println(\"Decoded: \" + decoded);\n\n        // Check if the original and decoded strings match\n        assert testString.equals(decoded) : \"The decode function did not return the correct string.\";\n    }\n}\n"}
{"task_id": "Java/51", "generation": "import org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nclass Solution {\n    /**\n     * remove_vowels is a function that takes string and returns string without vowels.\n     */\n    public String remove_vowels(String text) {\n        if (text == null || text.isEmpty()) return text;\n        \n        StringBuilder result = new StringBuilder();\n        for (char c : text.toCharArray()) {\n            if (!isVowel(c)) {\n                result.append(c);\n            }\n        }\n        return result.toString();\n    }\n\n    private boolean isVowel(char c) {\n        return \"AEIOUaeiou\".indexOf(c) != -1;\n    }\n\n    @Test\n    public void testRemoveVowels() {\n        assertEquals(\"\", remove_vowels(\"\"));\n        assertEquals(\"bcdf\\nghjklm\", remove_vowels(\"abcdef\\nghijklm\"));\n        assertEquals(\"bcdf\", remove_vowels(\"abcdef\"));\n        assertEquals(\"\", remove_vowels(\"aaaaa\"));\n        assertEquals(\"B\", remove_vowels(\"aaBAA\"));\n        assertEquals(\"zbcd\", remove_vowels(\"zbcd\"));\n    }\n}\n"}
{"task_id": "Java/52", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Return True if all numbers in the list l are below threshold t.\n     *\n     * @param l List of integers to be checked.\n     * @param t The threshold value against which elements of the list are compared.\n     * @return true if all elements in the list are less than the threshold, false otherwise.\n     */\n    public boolean below_threshold(List<Integer> l, int t) {\n        for (int num : l) {\n            if (num >= t) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    // Test cases to verify the correctness of the method\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.below_threshold(Arrays.asList(1, 2, 4, 10), 100)); // Expected: true\n        System.out.println(solution.below_threshold(Arrays.asList(1, 20, 4, 10), 5));   // Expected: false\n\n        // Additional test cases for thorough verification\n        System.out.println(solution.below_threshold(Arrays.asList(), 10));              // Expected: true (empty list)\n        System.out.println(solution.below_threshold(Arrays.asList(9, 8, 7, 6), 10));    // Expected: true\n        System.out.println(solution.below_threshold(Arrays.asList(-5, -3, -2, 0), 1));   // Expected: true\n        System.out.println(solution.below_threshold(Arrays.asList(-5, -3, -2, 1), 0));   // Expected: false (contains a number not below the threshold)\n    }\n}\n"}
{"task_id": "Java/53", "generation": "import org.junit.Test;\nimport static org.junit.Assert.assertEquals;\n\nclass SolutionTest {\n\n    @Test\n    public void testAdd() {\n        Solution solution = new Solution();\n        \n        // Test case 1: adding positive numbers\n        assertEquals(5, solution.add(2, 3));\n        \n        // Test case 2: another addition of positive numbers\n        assertEquals(12, solution.add(5, 7));\n        \n        // Additional test cases can be added here\n    }\n}\n"}
{"task_id": "Java/54", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Check if two words have the same kind of characters.\n     */\n    public boolean same_chars(String s0, String s1) {\n        Set<Character> set0 = new HashSet<>();\n        Set<Character> set1 = new HashSet<>();\n\n        // Add all characters from both strings to their respective sets\n        for (char c : s0.toCharArray()) {\n            set0.add(c);\n        }\n        for (char c : s1.toCharArray()) {\n            set1.add(c);\n        }\n\n        // Check if the two sets are equal, meaning they contain the same characters\n        return set0.equals(set1);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.same_chars(\"eabcdzzzz\", \"dddzzzzzzzddeddabc\")); // true\n        System.out.println(solution.same_chars(\"abcd\", \"dddddddabc\"));              // true\n        System.out.println(solution.same_chars(\"dddddddabc\", \"abcd\"));              // true\n        System.out.println(solution.same_chars(\"eabcd\", \"dddddddabc\"));             // false\n        System.out.println(solution.same_chars(\"abcd\", \"dddddddabce\"));             // false\n        System.out.println(solution.same_chars(\"eabcdzzzz\", \"dddzzzzzzzddddabc\"));  // false\n    }\n}\n"}
{"task_id": "Java/55", "generation": "import org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nclass Solution {\n    /**\n     * Return n-th Fibonacci number.\n     *\n     * @param n the position in the Fibonacci sequence\n     * @return the n-th Fibonacci number\n     */\n    public int fib(int n) {\n        if (n <= 1) {\n            return n;\n        }\n        int a = 0, b = 1, c;\n        for (int i = 2; i <= n; i++) {\n            c = a + b;\n            a = b;\n            b = c;\n        }\n        return b;\n    }\n\n    @Test\n    public void testFib() {\n        assertEquals(55, fib(10));\n        assertEquals(1, fib(1));\n        assertEquals(21, fib(8));\n        // Additional tests\n        assertEquals(0, fib(0));  // Base case\n        assertEquals(1, fib(2));  // Another base case\n        assertEquals(34, fib(9)); // One less than the given example for n=10\n    }\n}\n"}
{"task_id": "Java/56", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Checks if every opening bracket has a corresponding closing bracket.\n     *\n     * @param brackets A string of \"<\" and \">\" characters.\n     * @return true if the brackets are correctly matched, false otherwise.\n     */\n    public boolean correct_bracketing(String brackets) {\n        int balance = 0;\n        \n        for (char c : brackets.toCharArray()) {\n            if (c == '<') {\n                balance++;\n            } else if (c == '>') {\n                balance--;\n                // If at any point we have more closing brackets than opening ones, return false\n                if (balance < 0) {\n                    return false;\n                }\n            }\n        }\n        \n        // If the balance is zero, all brackets are correctly matched.\n        return balance == 0;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.correct_bracketing(\"<\"));       // Expected: false\n        System.out.println(solution.correct_bracketing(\"<>\"));      // Expected: true\n        System.out.println(solution.correct_bracketing(\"<<><>>\"));  // Expected: true\n        System.out.println(solution.correct_bracketing(\"><<>\"));    // Expected: false\n    }\n}\n"}
{"task_id": "Java/57", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Return True if list elements are monotonically increasing or decreasing.\n     *\n     * @param l List of integers to check for monotonicity.\n     * @return true if the list is monotonically increasing or decreasing, false otherwise.\n     */\n    public boolean monotonic(List<Integer> l) {\n        if (l == null || l.size() <= 1) return true;\n\n        boolean increasing = true;\n        boolean decreasing = true;\n\n        for (int i = 1; i < l.size(); i++) {\n            if (l.get(i) > l.get(i - 1)) decreasing = false;\n            if (l.get(i) < l.get(i - 1)) increasing = false;\n        }\n\n        return increasing || decreasing;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.monotonic(Arrays.asList(1, 2, 4, 20))); // Expected: true\n        System.out.println(solution.monotonic(Arrays.asList(1, 20, 4, 10))); // Expected: false\n        System.out.println(solution.monotonic(Arrays.asList(4, 1, 0, -10))); // Expected: true\n    }\n}\n"}
{"task_id": "Java/58", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Return sorted unique common elements for two lists.\n     *\n     * @param l1 first list of integers\n     * @param l2 second list of integers\n     * @return a List containing the sorted unique common elements from both input lists\n     */\n    public List<Integer> common(List<Integer> l1, List<Integer> l2) {\n        // Convert both lists to sets to remove duplicates and find intersection\n        Set<Integer> set1 = new HashSet<>(l1);\n        Set<Integer> set2 = new HashSet<>(l2);\n\n        // Retain only the elements that are in both sets (intersection)\n        set1.retainAll(set2);\n\n        // Convert the result back to a list, sort it and return\n        List<Integer> result = new ArrayList<>(set1);\n        Collections.sort(result);\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        System.out.println(solution.common(Arrays.asList(1, 4, 3, 34, 653, 2, 5), Arrays.asList(5, 7, 1, 5, 9, 653, 121)));\n        // Expected output: [1, 5, 653]\n\n        // Test case 2\n        System.out.println(solution.common(Arrays.asList(5, 3, 2, 8), Arrays.asList(3, 2)));\n        // Expected output: [2, 3]\n    }\n}\n"}
{"task_id": "Java/59", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return the largest prime factor of n. Assume n > 1 and is not a prime.\n     *\n     * @param n The number whose largest prime factor we want to find.\n     * @return The largest prime factor of n.\n     */\n    public int largest_prime_factor(int n) {\n        int maxPrime = -1;\n        \n        // Divide n by 2 until it's odd\n        while (n % 2 == 0) {\n            maxPrime = 2;\n            n /= 2;\n        }\n        \n        // Now we only have to deal with odd factors.\n        for (int i = 3; i <= Math.sqrt(n); i += 2) {\n            while (n % i == 0) {\n                maxPrime = i;\n                n = n / i;\n            }\n        }\n\n        // This condition is to handle the case when n is a prime number\n        // greater than 2.\n        if (n > 2)\n            maxPrime = n;\n\n        return maxPrime;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.largest_prime_factor(13195)); // Expected output: 29\n        System.out.println(solution.largest_prime_factor(2048));  // Expected output: 2\n    }\n}\n"}
{"task_id": "Java/60", "generation": "import org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nclass Solution {\n    /**\n     * sum_to_n is a function that sums numbers from 1 to n.\n     *\n     * @param n the upper limit for summation\n     * @return the sum of all integers from 1 to n inclusive\n     */\n    public int sum_to_n(int n) {\n        return (n * (n + 1)) / 2; // Using the arithmetic series sum formula\n    }\n\n    /**\n     * Test cases for the sum_to_n function.\n     */\n    @Test\n    public void testSumToN() {\n        assertEquals(465, sum_to_n(30));\n        assertEquals(5050, sum_to_n(100));\n        assertEquals(15, sum_to_n(5));\n        assertEquals(55, sum_to_n(10));\n        assertEquals(1, sum_to_n(1));\n    }\n}\n"}
{"task_id": "Java/61", "generation": "import java.util.*;\n\nclass Solution {\n\n    /**\n     * Checks if the given string of brackets is correctly matched.\n     *\n     * @param brackets A string containing only '(' and ')'.\n     * @return true if every opening bracket has a corresponding closing bracket, false otherwise.\n     */\n    public boolean correct_bracketing(String brackets) {\n        Stack<Character> stack = new Stack<>();\n        \n        for (char ch : brackets.toCharArray()) {\n            if (ch == '(') {\n                // Push an opening bracket onto the stack\n                stack.push(ch);\n            } else if (ch == ')') {\n                // If there's no matching opening bracket, return false\n                if (stack.isEmpty() || stack.pop() != '(') {\n                    return false;\n                }\n            }\n        }\n\n        // If the stack is empty, all brackets were matched correctly\n        return stack.isEmpty();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.correct_bracketing(\"(\"));       // Expected: false\n        System.out.println(solution.correct_bracketing(\"()\"));      // Expected: true\n        System.out.println(solution.correct_bracketing(\"(()())\"));  // Expected: true\n        System.out.println(solution.correct_bracketing(\")(()\"));    // Expected: false\n    }\n}\n"}
{"task_id": "Java/62", "generation": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\nclass Solution {\n\n    /**\n     * xs represent coefficients of a polynomial.\n     * xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     * Return derivative of this polynomial in the same form.\n     *\n     * @param xs List of integer coefficients representing the polynomial.\n     * @return List of integer coefficients representing the derivative of the polynomial.\n     */\n    public List<Integer> derivative(List<Integer> xs) {\n        if (xs == null || xs.size() <= 1) {\n            return new ArrayList<>();\n        }\n\n        List<Integer> result = new ArrayList<>();\n        for (int i = 1; i < xs.size(); i++) {\n            result.add(xs.get(i) * i);\n        }\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        List<Integer> test1 = Arrays.asList(3, 1, 2, 4, 5);\n        System.out.println(\"Test Case 1: \" + solution.derivative(test1)); // Expected [1, 4, 12, 20]\n\n        // Test case 2\n        List<Integer> test2 = Arrays.asList(1, 2, 3);\n        System.out.println(\"Test Case 2: \" + solution.derivative(test2)); // Expected [2, 6]\n        \n        // Additional test cases\n        // Test case with a single element (should return an empty list)\n        List<Integer> test3 = Arrays.asList(5);\n        System.out.println(\"Test Case 3: \" + solution.derivative(test3)); // Expected []\n\n        // Test case with null input (should also return an empty list)\n        List<Integer> test4 = null;\n        System.out.println(\"Test Case 4: \" + solution.derivative(test4)); // Expected []\n    }\n}\n"}
{"task_id": "Java/63", "generation": "import java.util.*;\n\nclass Solution {\n    public int fibfib(int n) {\n        if (n == 0 || n == 1) return 0;\n        if (n == 2) return 1;\n\n        // Initialize an array to store the FibFib values up to n.\n        int[] dp = new int[n + 1];\n        dp[0] = 0;\n        dp[1] = 0;\n        dp[2] = 1;\n\n        for (int i = 3; i <= n; i++) {\n            // Calculate the current FibFib value using the previous three values.\n            dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3];\n        }\n\n        return dp[n];\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.fibfib(1)); // Expected output: 0\n        System.out.println(solution.fibfib(5)); // Expected output: 4\n        System.out.println(solution.fibfib(8)); // Expected output: 24\n    }\n}\n"}
{"task_id": "Java/64", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    \n    public int vowels_count(String s) {\n        if (s == null || s.isEmpty()) return 0;\n        \n        String lowerCaseString = s.toLowerCase();\n        int count = 0;\n\n        for (int i = 0; i < lowerCaseString.length(); i++) {\n            char ch = lowerCaseString.charAt(i);\n            if (\"aeiou\".indexOf(ch) != -1) {\n                count++;\n            }\n        }\n\n        // Check if the last character is 'y' and treat it as a vowel\n        if (lowerCaseString.endsWith(\"y\")) {\n            count++;\n        }\n\n        return count;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.vowels_count(\"abcde\")); // Expected output: 2\n        System.out.println(solution.vowels_count(\"ACEDY\")); // Expected output: 3\n        System.out.println(solution.vowels_count(\"rhythm\")); // Expected output: 1 (only 'y' at the end)\n        System.out.println(solution.vowels_count(\"aeiou\")); // Expected output: 5\n        System.out.println(solution.vowels_count(\"bcdfg\")); // Expected output: 0\n    }\n}\n"}
{"task_id": "Java/65", "generation": "import org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nclass Solution {\n    /**\n     * Circular shift the digits of the integer x, shift the digits right by shift\n     * and return the result as a string.\n     * If shift > number of digits, return digits reversed.\n     */\n    public String circular_shift(int x, int shift) {\n        String numStr = Integer.toString(x);\n        int len = numStr.length();\n        \n        // Handle cases where shift is greater than the length of the number\n        if (shift >= len) {\n            char[] chars = numStr.toCharArray();\n            reverse(chars, 0, len - 1);\n            return new String(chars);\n        }\n        \n        // Perform circular shift\n        int actualShift = shift % len;\n        char[] chars = numStr.toCharArray();\n        reverse(chars, 0, len - 1);\n        reverse(chars, 0, actualShift - 1);\n        reverse(chars, actualShift, len - 1);\n        \n        return new String(chars);\n    }\n\n    private void reverse(char[] arr, int start, int end) {\n        while (start < end) {\n            char temp = arr[start];\n            arr[start] = arr[end];\n            arr[end] = temp;\n            start++;\n            end--;\n        }\n    }\n\n    @Test\n    public void testCircularShift() {\n        assertEquals(\"21\", circular_shift(12, 1));\n        assertEquals(\"12\", circular_shift(12, 2));\n        assertEquals(\"34512\", circular_shift(12345, 2));\n        assertEquals(\"54321\", circular_shift(12345, 6)); // shift > number of digits\n    }\n}\n"}
{"task_id": "Java/66", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Write a function that takes a string as input and returns the sum of the upper characters only'\n    ASCII codes.\n\n    Examples:\n        digitSum(\"\") => 0\n        digitSum(\"abAB\") => 131\n        digitSum(\"abcCd\") => 67\n        digitSum(\"helloE\") => 69\n        digitSum(\"woArBld\") => 131\n        digitSum(\"aAaaaXa\") => 153\n     */\n    public int digitSum(String s) {\n        int sum = 0;\n        for (char c : s.toCharArray()) {\n            if (Character.isUpperCase(c)) {\n                sum += (int)c;\n            }\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.digitSum(\"\")); // Expected output: 0\n        System.out.println(solution.digitSum(\"abAB\")); // Expected output: 131\n        System.out.println(solution.digitSum(\"abcCd\")); // Expected output: 67\n        System.out.println(solution.digitSum(\"helloE\")); // Expected output: 69\n        System.out.println(solution.digitSum(\"woArBld\")); // Expected output: 131\n        System.out.println(solution.digitSum(\"aAaaaXa\")); // Expected output: 153\n    }\n}\n"}
{"task_id": "Java/67", "generation": "import java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nclass Solution {\n    /**\n     * Calculates the number of mango fruits in the basket.\n     *\n     * @param s A string that represents the total number of oranges and apples.\n     * @param n An integer representing the total number of fruits in the basket.\n     * @return The number of mango fruits in the basket.\n     */\n    public int fruit_distribution(String s, int n) {\n        // Regular expression to extract numbers from the input string\n        Pattern pattern = Pattern.compile(\"(\\\\d+) apples and (\\\\d+) oranges\");\n        Matcher matcher = pattern.matcher(s);\n\n        if (matcher.find()) {\n            int apples = Integer.parseInt(matcher.group(1));\n            int oranges = Integer.parseInt(matcher.group(2));\n\n            // Calculate the number of mangoes\n            return n - (apples + oranges);\n        }\n\n        throw new IllegalArgumentException(\"Input string does not match expected format.\");\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases to verify the correctness of the function\n        System.out.println(solution.fruit_distribution(\"5 apples and 6 oranges\", 19)); // Expected output: 8\n        System.out.println(solution.fruit_distribution(\"0 apples and 1 oranges\", 3)); // Expected output: 2\n        System.out.println(solution.fruit_distribution(\"2 apples and 3 oranges\", 100)); // Expected output: 95\n        System.out.println(solution.fruit_distribution(\"100 apples and 1 oranges\", 120)); // Expected output: 19\n\n        // Additional test case to check for edge cases or unexpected input formats\n        try {\n            System.out.println(solution.fruit_distribution(\"invalid string\", 10));\n        } catch (IllegalArgumentException e) {\n            System.out.println(e.getMessage()); // Expected output: Input string does not match expected format.\n        }\n    }\n}\n"}
{"task_id": "Java/68", "generation": "import java.util.*;\n\nclass Solution {\n    public List<Integer> pluck(List<Integer> arr) {\n        int minValue = Integer.MAX_VALUE;\n        int minIndex = -1;\n\n        // Iterate through the list to find the smallest even value and its index\n        for (int i = 0; i < arr.size(); i++) {\n            int currentValue = arr.get(i);\n            if (currentValue % 2 == 0 && currentValue <= minValue) {\n                if (currentValue < minValue || minIndex == -1) {\n                    minValue = currentValue;\n                    minIndex = i;\n                }\n            }\n        }\n\n        // If no even value was found, return an empty list\n        if (minIndex == -1) {\n            return new ArrayList<>();\n        } else {\n            List<Integer> result = new ArrayList<>();\n            result.add(minValue);\n            result.add(minIndex);\n            return result;\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.pluck(Arrays.asList(4, 2, 3))); // [2, 1]\n        System.out.println(solution.pluck(Arrays.asList(1, 2, 3))); // [2, 1]\n        System.out.println(solution.pluck(new ArrayList<>()));      // []\n        System.out.println(solution.pluck(Arrays.asList(5, 0, 3, 0, 4, 2))); // [0, 1]\n    }\n}\n"}
{"task_id": "Java/69", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * You are given a non-empty list of positive integers. Return the greatest integer that is greater than\n     * zero, and has a frequency greater than or equal to the value of the integer itself.\n     * The frequency of an integer is the number of times it appears in the list.\n     * If no such a value exist, return -1.\n     */\n    public int search(List<Integer> lst) {\n        Map<Integer, Integer> frequencyMap = new HashMap<>();\n        \n        // Calculate frequencies\n        for (int num : lst) {\n            frequencyMap.put(num, frequencyMap.getOrDefault(num, 0) + 1);\n        }\n        \n        // Find the greatest integer with a valid frequency\n        int result = -1;\n        for (Map.Entry<Integer, Integer> entry : frequencyMap.entrySet()) {\n            if (entry.getKey() <= entry.getValue()) {\n                result = Math.max(result, entry.getKey());\n            }\n        }\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.search(Arrays.asList(4, 1, 2, 2, 3, 1))); // Expected output: 2\n        System.out.println(solution.search(Arrays.asList(1, 2, 2, 3, 3, 3, 4, 4, 4))); // Expected output: 3\n        System.out.println(solution.search(Arrays.asList(5, 5, 4, 4, 4))); // Expected output: -1\n    }\n}\n"}
{"task_id": "Java/70", "generation": "import java.util.*;\n\nclass Solution {\n    public List<Integer> strange_sort_list(List<Integer> lst) {\n        if (lst == null || lst.isEmpty()) {\n            return lst;\n        }\n\n        // Create a copy of the list and sort it in ascending order.\n        ArrayList<Integer> sortedList = new ArrayList<>(lst);\n        Collections.sort(sortedList);\n\n        List<Integer> result = new ArrayList<>();\n        int left = 0; // Start index\n        int right = sortedList.size() - 1; // End index\n\n        while (left <= right) {\n            if (left == right) {\n                result.add(sortedList.get(left));\n            } else {\n                result.add(sortedList.get(left++)); // Add the minimum value\n                result.add(sortedList.get(right--)); // Add the maximum value\n            }\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        List<Integer> test1 = Arrays.asList(1, 2, 3, 4);\n        System.out.println(solution.strange_sort_list(test1)); // Expected: [1, 4, 2, 3]\n\n        List<Integer> test2 = Arrays.asList(5, 5, 5, 5);\n        System.out.println(solution.strange_sort_list(test2)); // Expected: [5, 5, 5, 5]\n\n        List<Integer> test3 = new ArrayList<>();\n        System.out.println(solution.strange_sort_list(test3)); // Expected: []\n\n        List<Integer> test4 = Arrays.asList(7, -2, 4, 19);\n        System.out.println(solution.strange_sort_list(test4)); // Expected: [-2, 19, 4, 7]\n    }\n}\n"}
{"task_id": "Java/71", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given the lengths of the three sides of a triangle.\n     * Return the area of the triangle rounded to 2 decimal points if the three sides form a valid triangle.\n     * Otherwise return -1\n     * Three sides make a valid triangle when the sum of any two sides is greater than the third side.\n     */\n    public double triangle_area(double a, double b, double c) {\n        // Check for validity of the triangle\n        if (a + b <= c || a + c <= b || b + c <= a) {\n            return -1;\n        }\n        \n        // Calculate semi-perimeter\n        double s = (a + b + c) / 2.0;\n\n        // Heron's formula to calculate area\n        double area = Math.sqrt(s * (s - a) * (s - b) * (s - c));\n\n        // Round the result to two decimal places and return it\n        return Math.round(area * 100.0) / 100.0;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        \n        // Test cases\n        System.out.println(sol.triangle_area(3, 4, 5)); // Expected output: 6.00\n        System.out.println(sol.triangle_area(1, 2, 10)); // Expected output: -1\n        System.out.println(sol.triangle_area(7, 8, 9)); // Expected output: 26.83\n    }\n}\n"}
{"task_id": "Java/72", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Checks if an object q will fly based on being balanced (a palindromic list)\n     * and having a sum less than or equal to the maximum possible weight w.\n     */\n    public boolean will_it_fly(List<Integer> q, int w) {\n        // Check if the list is a palindrome\n        for (int i = 0; i < q.size() / 2; i++) {\n            if (!q.get(i).equals(q.get(q.size() - 1 - i))) {\n                return false;\n            }\n        }\n\n        // Calculate the sum of elements in the list\n        int sum = 0;\n        for (int num : q) {\n            sum += num;\n        }\n\n        // Check if the sum is less than or equal to w\n        return sum <= w;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.will_it_fly(Arrays.asList(1, 2), 5)); // false\n        System.out.println(solution.will_it_fly(Arrays.asList(3, 2, 3), 1)); // false\n        System.out.println(solution.will_it_fly(Arrays.asList(3, 2, 3), 9)); // true\n        System.out.println(solution.will_it_fly(Arrays.asList(3), 5)); // true\n    }\n}\n"}
{"task_id": "Java/73", "generation": "import java.util.*;\n\nclass Solution {\n    public int smallest_change(List<Integer> arr) {\n        int changes = 0;\n        int left = 0;\n        int right = arr.size() - 1;\n\n        while (left < right) {\n            if (!arr.get(left).equals(arr.get(right))) {\n                changes++;\n            }\n            left++;\n            right--;\n        }\n\n        return changes;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        List<Integer> arr1 = Arrays.asList(1, 2, 3, 5, 4, 7, 9, 6);\n        System.out.println(\"Test Case 1: \" + (solution.smallest_change(arr1) == 4));\n\n        // Test case 2\n        List<Integer> arr2 = Arrays.asList(1, 2, 3, 4, 3, 2, 2);\n        System.out.println(\"Test Case 2: \" + (solution.smallest_change(arr2) == 1));\n\n        // Test case 3\n        List<Integer> arr3 = Arrays.asList(1, 2, 3, 2, 1);\n        System.out.println(\"Test Case 3: \" + (solution.smallest_change(arr3) == 0));\n    }\n}\n"}
{"task_id": "Java/74", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Write a function that accepts two lists of strings and returns the list that has\n     * total number of chars in all strings of the list less than the other list.\n     *\n     * If the two lists have the same number of chars, return the first list.\n     */\n    public List<String> total_match(List<String> lst1, List<String> lst2) {\n        int count1 = 0;\n        for (String s : lst1) {\n            count1 += s.length();\n        }\n\n        int count2 = 0;\n        for (String s : lst2) {\n            count2 += s.length();\n        }\n\n        if (count1 <= count2) {\n            return lst1;\n        } else {\n            return lst2;\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.total_match(Arrays.asList(), Arrays.asList())); // -> []\n        System.out.println(solution.total_match(Arrays.asList(\"hi\", \"admin\"), Arrays.asList(\"hI\", \"Hi\"))); // -> [\"hI\", \"Hi\"]\n        System.out.println(solution.total_match(Arrays.asList(\"hi\", \"admin\"), Arrays.asList(\"hi\", \"hi\", \"admin\", \"project\"))); // -> [\"hi\", \"admin\"]\n        System.out.println(solution.total_match(Arrays.asList(\"hi\", \"admin\"), Arrays.asList(\"hI\", \"hi\", \"hi\"))); // -> [\"hI\", \"hi\", \"hi\"]\n        System.out.println(solution.total_match(Arrays.asList(\"4\"), Arrays.asList(\"1\", \"2\", \"3\", \"4\", \"5\"))); // -> [\"4\"]\n    }\n}\n"}
{"task_id": "Java/75", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Checks if the given number is a product of exactly three prime numbers.\n     *\n     * @param a The number to check.\n     * @return true if 'a' is a product of 3 primes, false otherwise.\n     */\n    public boolean is_multiply_prime(int a) {\n        // List all prime numbers less than 100\n        int[] primes = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97};\n\n        // Count how many prime factors we have found\n        int count = 0;\n\n        for (int p : primes) {\n            if (count > 3) break; // If more than three prime factors are found, return false\n\n            while (a % p == 0 && a != 1) { // Check divisibility by the current prime\n                a /= p;\n                count++;\n            }\n        }\n\n        // The number should be reduced to 1 and have exactly three prime factors\n        return count == 3 && a == 1;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.is_multiply_prime(30)); // true, because 30 = 2 * 3 * 5\n        System.out.println(solution.is_multiply_prime(60)); // false, more than three prime factors (2*2*3*5)\n        System.out.println(solution.is_multiply_prime(105)); // true, because 105 = 3 * 5 * 7\n        System.out.println(solution.is_multiply_prime(49)); // false, only two prime factors (7*7)\n        System.out.println(solution.is_multiply_prime(2)); // false, only one prime factor\n    }\n}\n"}
{"task_id": "Java/76", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Checks if x is a simple power of n.\n     *\n     * @param x The number to check.\n     * @param n The base number.\n     * @return true if x is a simple power of n, false otherwise.\n     */\n    public boolean is_simple_power(int x, int n) {\n        // Special case: any number to the power of 0 is 1\n        if (x == 1) return n == 1;\n        \n        // If n is 1 and x is not 1, it's false.\n        if (n == 1) return false;\n\n        int temp = 1;\n        while (temp < x) {\n            temp *= n;\n        }\n        return temp == x;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.is_simple_power(1, 4)); // true\n        System.out.println(solution.is_simple_power(2, 2)); // true\n        System.out.println(solution.is_simple_power(8, 2)); // true\n        System.out.println(solution.is_simple_power(3, 2)); // false\n        System.out.println(solution.is_simple_power(3, 1)); // false\n        System.out.println(solution.is_simple_power(5, 3)); // false\n    }\n}\n"}
{"task_id": "Java/77", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Checks if a given integer is a perfect cube.\n     *\n     * @param a The integer to check.\n     * @return true if 'a' is a perfect cube, false otherwise.\n     */\n    public boolean iscube(int a) {\n        int cbrt = (int) Math.round(Math.cbrt(a));\n        return cbrt * cbrt * cbrt == a;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.iscube(1));   // true\n        System.out.println(solution.iscube(2));   // false\n        System.out.println(solution.iscube(-1));  // true\n        System.out.println(solution.iscube(64));  // true\n        System.out.println(solution.iscube(0));   // true\n        System.out.println(solution.iscube(180)); // false\n\n        // Additional test cases for completeness\n        System.out.println(solution.iscube(-27)); // true\n        System.out.println(solution.iscube(125)); // true\n        System.out.println(solution.iscube(343)); // true\n        System.out.println(solution.iscube(100)); // false\n    }\n}\n"}
{"task_id": "Java/78", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Counts the number of hexadecimal digits in the input string that are prime.\n     */\n    public int hex_key(String num) {\n        // Set containing hexadecimal primes as characters\n        Set<Character> hexPrimes = new HashSet<>(Arrays.asList('2', '3', '5', '7', 'B', 'D'));\n        \n        int count = 0;\n        for (char c : num.toCharArray()) {\n            if (hexPrimes.contains(c)) {\n                count++;\n            }\n        }\n        return count;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.hex_key(\"AB\"));          // Expected output: 1\n        System.out.println(solution.hex_key(\"1077E\"));       // Expected output: 2\n        System.out.println(solution.hex_key(\"ABED1A33\"));    // Expected output: 4\n        System.out.println(solution.hex_key(\"123456789ABCDEF0\")); // Expected output: 6\n        System.out.println(solution.hex_key(\"2020\"));        // Expected output: 2\n        System.out.println(solution.hex_key(\"\"));            // Expected output: 0 (empty string)\n    }\n}\n"}
{"task_id": "Java/79", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n    Converts a given decimal number into binary format and returns it as a string.\n    The returned string has 'db' at both the beginning and end for formatting purposes.\n\n    Examples:\n    decimal_to_binary(15)   // returns \"db1111db\"\n    decimal_to_binary(32)   // returns \"db100000db\"\n     */\n    public String decimal_to_binary(int decimal) {\n        if (decimal < 0) {\n            throw new IllegalArgumentException(\"Decimal number must be non-negative.\");\n        }\n        \n        // Convert the decimal to binary and remove the '0b' prefix added by Integer.toBinaryString\n        String binary = Integer.toBinaryString(decimal);\n        return \"db\" + binary + \"db\";\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.decimal_to_binary(15));  // Expected: db1111db\n        System.out.println(solution.decimal_to_binary(32));  // Expected: db100000db\n        System.out.println(solution.decimal_to_binary(0));   // Expected: db0db\n        System.out.println(solution.decimal_to_binary(1));   // Expected: db1db\n        \n        try {\n            System.out.println(solution.decimal_to_binary(-5));  // Should throw an exception\n        } catch (IllegalArgumentException e) {\n            System.out.println(e.getMessage());                  // Expected: Decimal number must be non-negative.\n        }\n    }\n}\n"}
{"task_id": "Java/80", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Checks if a given string is happy.\n     * A string is happy if its length is at least 3 and every 3 consecutive letters are distinct.\n     *\n     * @param s The input string to check.\n     * @return true if the string is happy, false otherwise.\n     */\n    public boolean is_happy(String s) {\n        // Check if the string's length is less than 3\n        if (s.length() < 3) return false;\n\n        // Iterate through the string and check every 3 consecutive characters\n        for (int i = 0; i < s.length() - 2; i++) {\n            char first = s.charAt(i);\n            char second = s.charAt(i + 1);\n            char third = s.charAt(i + 2);\n\n            // If any of the three consecutive characters are the same, return false\n            if (first == second || second == third || first == third) {\n                return false;\n            }\n        }\n\n        // If all checks pass, the string is happy\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.is_happy(\"a\"));      // Expected: false\n        System.out.println(solution.is_happy(\"aa\"));     // Expected: false\n        System.out.println(solution.is_happy(\"abcd\"));   // Expected: true\n        System.out.println(solution.is_happy(\"aabb\"));   // Expected: false\n        System.out.println(solution.is_happy(\"adb\"));    // Expected: true\n        System.out.println(solution.is_happy(\"xyy\"));    // Expected: false\n    }\n}\n"}
{"task_id": "Java/81", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Converts a list of numerical GPA values into their corresponding letter grades.\n     *\n     * @param grades List<Double> containing the GPA values.\n     * @return A List<String> of letter grades based on the provided GPAs.\n     */\n    public List<String> numerical_letter_grade(List<Double> grades) {\n        List<String> letterGrades = new ArrayList<>();\n        \n        for (Double gpa : grades) {\n            if (gpa >= 4.0) letterGrades.add(\"A+\");\n            else if (gpa > 3.7) letterGrades.add(\"A\");\n            else if (gpa > 3.3) letterGrades.add(\"A-\");\n            else if (gpa > 3.0) letterGrades.add(\"B+\");\n            else if (gpa > 2.7) letterGrades.add(\"B\");\n            else if (gpa > 2.3) letterGrades.add(\"B-\");\n            else if (gpa > 2.0) letterGrades.add(\"C+\");\n            else if (gpa > 1.7) letterGrades.add(\"C\");\n            else if (gpa > 1.3) letterGrades.add(\"C-\");\n            else if (gpa > 1.0) letterGrades.add(\"D+\");\n            else if (gpa > 0.7) letterGrades.add(\"D\");\n            else if (gpa > 0.0) letterGrades.add(\"D-\");\n            else letterGrades.add(\"E\"); // For GPA of exactly 0.0\n        }\n        \n        return letterGrades;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        List<Double> test1 = Arrays.asList(4.0, 3.5, 2.8, 2.2, 1.9);\n        System.out.println(solution.numerical_letter_grade(test1)); // Expected: [A+, A-, B, C+, C]\n        \n        List<Double> test2 = Arrays.asList(3.7, 3.0, 2.5, 1.8, 0.9);\n        System.out.println(solution.numerical_letter_grade(test2)); // Expected: [A, B+, B-, C, D+]\n\n        List<Double> test3 = Arrays.asList(4.0, 3.0, 1.7, 2.0, 3.5);\n        System.out.println(solution.numerical_letter_grade(test3)); // Expected: [A+, B, C-, C, A-]\n    }\n}\n"}
{"task_id": "Java/82", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Checks if the length of a given string is a prime number.\n     *\n     * @param string The input string.\n     * @return true if the string length is a prime number, false otherwise.\n     */\n    public boolean prime_length(String string) {\n        int len = string.length();\n        return isPrime(len);\n    }\n\n    /**\n     * Checks if a given integer is a prime number.\n     *\n     * @param num The number to check.\n     * @return true if the number is prime, false otherwise.\n     */\n    private boolean isPrime(int num) {\n        if (num <= 1) return false;\n        for (int i = 2; i <= Math.sqrt(num); i++) {\n            if (num % i == 0) return false;\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.prime_length(\"Hello\"));   // Expected: true\n        System.out.println(solution.prime_length(\"abcdcba\")); // Expected: true\n        System.out.println(solution.prime_length(\"kittens\")); // Expected: true\n        System.out.println(solution.prime_length(\"orange\"));  // Expected: false\n    }\n}\n"}
{"task_id": "Java/83", "generation": "class Solution {\n    /**\n     * Given a positive integer n, return the count of the numbers of n-digit\n     * positive integers that start or end with 1.\n     */\n    public int startsOneEnds(int n) {\n        if (n == 1) {\n            // If n is 1, all single-digit numbers starting or ending with 1 are just {1}.\n            return 1;\n        }\n\n        // Count of n-digit numbers that start with 1.\n        long countStartsWithOne = (long)Math.pow(10, n - 1);\n\n        // Count of n-digit numbers that end with 1.\n        long countEndsWithOne = (long)Math.pow(10, n - 1);\n\n        // Count of n-digit numbers that both start and end with 1.\n        long countStartsAndEndsWithOne = (n == 2) ? 1 : (long)Math.pow(10, n - 2);\n\n        // Use the principle of inclusion-exclusion to avoid double-counting.\n        return (int)(countStartsWithOne + countEndsWithOne - countStartsAndEndsWithOne);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.startsOneEnds(1));  // Expected output: 1\n        System.out.println(solution.startsOneEnds(2));  // Expected output: 19 (01, 10-19, 21, ..., 91)\n        System.out.println(solution.startsOneEnds(3));  // Expected output: 180\n    }\n}\n"}
{"task_id": "Java/84", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public String solve(int N) {\n        int sum = 0;\n        \n        // Calculate the sum of digits\n        while (N > 0) {\n            sum += N % 10;\n            N /= 10;\n        }\n        \n        // Convert the sum to binary and return as a string\n        return Integer.toBinaryString(sum);\n    }\n}\n"}
{"task_id": "Java/85", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given a non-empty list of integers lst, add the even elements that are at odd indices.\n     *\n     * Examples:\n     *      add(Arrays.asList(4, 2, 6, 7)) ==> 2\n     */\n    public int add(List<Integer> lst) {\n        if (lst == null || lst.isEmpty()) return 0;\n\n        int sum = 0;\n        // Start from index 1 (second element), which is the first odd index.\n        for (int i = 1; i < lst.size(); i += 2) { // Increment by 2 to stay at odd indices\n            if (lst.get(i) % 2 == 0) {\n                sum += lst.get(i);\n            }\n        }\n\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.add(Arrays.asList(4, 2, 6, 7))); // Expected output: 2\n        System.out.println(solution.add(Arrays.asList(1, 3, 5, 7, 9, 10))); // Expected output: 0 (no even elements at odd indices)\n        System.out.println(solution.add(Arrays.asList(2, 4, 6, 8, 10))); // Expected output: 12 (4 + 8)\n    }\n}\n"}
{"task_id": "Java/86", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Write a function that takes a string and returns an ordered version of it.\n     * Ordered version of string, is a string where all words (separated by space)\n     * are replaced by a new word where all the characters arranged in\n     * ascending order based on ascii value.\n     * Note: You should keep the order of words and blank spaces in the sentence.\n     *\n     * @param s The input string to be processed.\n     * @return A new string with each word's characters sorted in ascending ASCII order.\n     */\n    public String anti_shuffle(String s) {\n        // Split the input string into words based on space\n        String[] words = s.split(\" \");\n        \n        // Process each word and sort its characters\n        for (int i = 0; i < words.length; i++) {\n            char[] chars = words[i].toCharArray();\n            Arrays.sort(chars);\n            words[i] = new String(chars);\n        }\n        \n        // Join the processed words back into a single string with spaces in between\n        return String.join(\" \", words);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases to verify the correctness of the function\n        System.out.println(solution.anti_shuffle(\"Hi\"));  // Expected: \"Hi\"\n        System.out.println(solution.anti_shuffle(\"hello\"));  // Expected: \"ehllo\"\n        System.out.println(solution.anti_shuffle(\"Hello World!!!\"));  // Expected: \"Hello !!!Wdlor\"\n    }\n}\n"}
{"task_id": "Java/87", "generation": "import java.util.*;\n\nclass Solution {\n    public List<List<Integer>> get_row(List<List<Integer>> lst, int x) {\n        // Collect all coordinates where the value equals 'x'\n        List<List<Integer>> result = new ArrayList<>();\n        \n        for (int row = 0; row < lst.size(); row++) {\n            List<Integer> currentRow = lst.get(row);\n            for (int col = 0; col < currentRow.size(); col++) {\n                if (currentRow.get(col) == x) {\n                    result.add(Arrays.asList(row, col));\n                }\n            }\n        }\n\n        // Sort the coordinates by row in ascending order and column in descending order within each row\n        Collections.sort(result, new Comparator<List<Integer>>() {\n            @Override\n            public int compare(List<Integer> o1, List<Integer> o2) {\n                if (!o1.get(0).equals(o2.get(0))) {\n                    return Integer.compare(o1.get(0), o2.get(0));\n                } else {\n                    return Integer.compare(o2.get(1), o1.get(1)); // Note the order for descending sort\n                }\n            }\n        });\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        List<List<Integer>> test1 = Arrays.asList(\n            Arrays.asList(1, 2, 3, 4, 5, 6),\n            Arrays.asList(1, 2, 3, 4, 1, 6),\n            Arrays.asList(1, 2, 3, 4, 5, 1)\n        );\n        \n        List<List<Integer>> test2 = new ArrayList<>();\n        \n        List<List<Integer>> test3 = Arrays.asList(\n            new ArrayList<>(),\n            Arrays.asList(1),\n            Arrays.asList(1, 2, 3)\n        );\n\n        System.out.println(solution.get_row(test1, 1)); // Expected: [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n        System.out.println(solution.get_row(test2, 1)); // Expected: []\n        System.out.println(solution.get_row(test3, 3)); // Expected: [[2, 2]]\n    }\n}\n"}
{"task_id": "Java/88", "generation": "import java.util.*;\n\nclass Solution {\n    public List<Integer> sort_array(List<Integer> array) {\n        if (array == null || array.size() <= 1) return new ArrayList<>(array);\n\n        // Create a copy of the list so we don't modify the original one.\n        List<Integer> sortedArray = new ArrayList<>(array);\n        \n        // Check sum of first and last element\n        int sumFirstLast = array.get(0) + array.get(array.size() - 1);\n        \n        if (sumFirstLast % 2 == 0) {\n            // Sort in descending order\n            sortedArray.sort(Collections.reverseOrder());\n        } else {\n            // Sort in ascending order\n            Collections.sort(sortedArray);\n        }\n        \n        return sortedArray;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.sort_array(new ArrayList<>())); // []\n        System.out.println(solution.sort_array(Arrays.asList(5))); // [5]\n        System.out.println(solution.sort_array(Arrays.asList(2, 4, 3, 0, 1, 5))); // [0, 1, 2, 3, 4, 5]\n        System.out.println(solution.sort_array(Arrays.asList(2, 4, 3, 0, 1, 5, 6))); // [6, 5, 4, 3, 2, 1, 0]\n    }\n}\n"}
{"task_id": "Java/89", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Encrypts the given string by rotating each character in the string \n     * four positions down the alphabet.\n     *\n     * @param s The input string to be encrypted.\n     * @return A new string with each character rotated 4 places down the alphabet.\n     */\n    public String encrypt(String s) {\n        StringBuilder result = new StringBuilder();\n        \n        for (char c : s.toCharArray()) {\n            if (Character.isLetter(c)) {\n                char base = Character.isUpperCase(c) ? 'A' : 'a';\n                // Calculate the new character by rotating 4 positions down\n                char encryptedChar = (char)(((c - base + 4) % 26) + base);\n                result.append(encryptedChar);\n            } else {\n                // If it's not a letter, just append as is.\n                result.append(c);\n            }\n        }\n\n        return result.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.encrypt(\"hi\"));  // Expected output: \"lm\"\n        System.out.println(solution.encrypt(\"asdfghjkl\"));  // Expected output: \"ewhjklnop\"\n        System.out.println(solution.encrypt(\"gf\"));  // Expected output: \"kj\"\n        System.out.println(solution.encrypt(\"et\"));  // Expected output: \"ix\"\n\n        // Additional test cases\n        System.out.println(solution.encrypt(\"xyz\"));  // Expected output: \"bcd\"\n        System.out.println(solution.encrypt(\"ABC\"));  // Expected output: \"EFG\"\n    }\n}\n"}
{"task_id": "Java/90", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * You are given a list of integers.\n     * Write a function next_smallest() that returns the 2nd smallest element of the list.\n     * Return null if there is no such element.\n     *\n     * @param lst List of integers to find the second smallest from\n     * @return Optional containing the second smallest integer or empty if not applicable\n     */\n    public Optional<Integer> next_smallest(List<Integer> lst) {\n        // Check for edge cases where list size is less than 2\n        if (lst == null || lst.size() < 2) {\n            return Optional.empty();\n        }\n\n        TreeSet<Integer> sortedSet = new TreeSet<>(lst);\n        \n        // If there are only unique elements and the set has less than 2 elements, return empty.\n        if (sortedSet.size() < 2) {\n            return Optional.empty();\n        }\n        \n        // Skip the first(smallest) element\n        Iterator<Integer> iterator = sortedSet.iterator();\n        iterator.next(); // skip the smallest\n        \n        // The next one is the second smallest\n        return Optional.of(iterator.next());\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.next_smallest(Arrays.asList(1, 2, 3, 4, 5))); // Expected: Optional[2]\n        System.out.println(solution.next_smallest(Arrays.asList(5, 1, 4, 3, 2))); // Expected: Optional[2]\n        System.out.println(solution.next_smallest(new ArrayList<>()));             // Expected: Optional.empty\n        System.out.println(solution.next_smallest(Arrays.asList(1, 1)));           // Expected: Optional.empty\n    }\n}\n"}
{"task_id": "Java/91", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int is_bored(String S) {\n        // Split the text into sentences using '.', '?' or '!' as delimiters.\n        String[] sentences = S.split(\"[.?!]\");\n        \n        int boredomCount = 0;\n        \n        for (String sentence : sentences) {\n            // Trim leading and trailing spaces from each sentence\n            sentence = sentence.trim();\n            \n            // Check if the sentence starts with \"I \"\n            if (sentence.startsWith(\"I \")) {\n                boredomCount++;\n            }\n        }\n        \n        return boredomCount;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.is_bored(\"Hello world\"));  // Expected output: 0\n        System.out.println(solution.is_bored(\"The sky is blue. The sun is shining. I love this weather.\"));  // Expected output: 1\n        System.out.println(solution.is_bored(\"I am bored. Really, I am! Do you think I can do better?\"));  // Expected output: 2\n    }\n}\n"}
{"task_id": "Java/92", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Checks if any of the three given objects (x, y, z) is an integer that equals the sum of the other two.\n     *\n     * @param x First object to check.\n     * @param y Second object to check.\n     * @param z Third object to check.\n     * @return true if one number is equal to the sum of the other two and all are integers, false otherwise.\n     */\n    public boolean any_int(Object x, Object y, Object z) {\n        // Check if all inputs are instances of Integer\n        if (!(x instanceof Integer && y instanceof Integer && z instanceof Integer)) {\n            return false;\n        }\n\n        int a = (Integer) x;\n        int b = (Integer) y;\n        int c = (Integer) z;\n\n        // Check the condition for any two numbers summing up to the third\n        return (a == b + c) || (b == a + c) || (c == a + b);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.any_int(5, 2, 7));   // Expected: true\n        System.out.println(solution.any_int(3, 2, 2));   // Expected: false\n        System.out.println(solution.any_int(3, -2, 1));  // Expected: true\n        System.out.println(solution.any_int(3.6, -2.2, 2)); // Expected: false\n    }\n}\n"}
{"task_id": "Java/93", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Encodes a message by swapping case of all letters and replacing vowels with \n     * the letter that appears 2 places ahead in the English alphabet.\n     *\n     * @param message The input string to be encoded.\n     * @return The encoded string.\n     */\n    public String encode(String message) {\n        StringBuilder encoded = new StringBuilder();\n        \n        for (char c : message.toCharArray()) {\n            if (Character.isLetter(c)) {\n                // Swap case\n                char swappedCaseChar = Character.isUpperCase(c) ? Character.toLowerCase(c) : Character.toUpperCase(c);\n                \n                // Replace vowels with the letter that appears 2 places ahead in the alphabet.\n                String vowelReplacement = \"aeiouAEIOU\";\n                int index = vowelReplacement.indexOf(swappedCaseChar);\n                if (index != -1) {\n                    char newVowel;\n                    if (swappedCaseChar >= 'a' && swappedCaseChar <= 'z') {\n                        // For lowercase vowels\n                        newVowel = (char)((swappedCaseChar - 'a' + 2) % 26 + 'a');\n                    } else {\n                        // For uppercase vowels\n                        newVowel = (char)((swappedCaseChar - 'A' + 2) % 26 + 'A');\n                    }\n                    encoded.append(newVowel);\n                } else {\n                    encoded.append(swappedCaseChar);\n                }\n            }\n        }\n\n        return encoded.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.encode(\"test\").equals(\"TGST\") ? \"Test 1 Passed\" : \"Test 1 Failed\");\n        System.out.println(solution.encode(\"This is a message\").equals(\"tHKS KS C MGSSCGG\") ? \"Test 2 Passed\" : \"Test 2 Failed\");\n    }\n}\n"}
{"task_id": "Java/94", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Finds the largest prime value in a list and returns the sum of its digits.\n     *\n     * @param lst List of integers.\n     * @return Sum of the digits of the largest prime number found in the list.\n     */\n    public int skjkasdkd(List<Integer> lst) {\n        // Find the maximum prime number\n        int maxPrime = Integer.MIN_VALUE;\n        for (int num : lst) {\n            if (isPrime(num) && num > maxPrime) {\n                maxPrime = num;\n            }\n        }\n\n        // If no prime was found, return 0 or handle as needed.\n        if (maxPrime == Integer.MIN_VALUE) {\n            return 0; // Or throw an exception, depending on the requirement\n        }\n\n        // Calculate and return the sum of digits of the largest prime number\n        return sumOfDigits(maxPrime);\n    }\n\n    /**\n     * Checks if a number is prime.\n     *\n     * @param num The number to check.\n     * @return true if the number is prime, false otherwise.\n     */\n    private boolean isPrime(int num) {\n        if (num <= 1) return false;\n        for (int i = 2; i <= Math.sqrt(num); i++) {\n            if (num % i == 0) return false;\n        }\n        return true;\n    }\n\n    /**\n     * Calculates the sum of digits of a number.\n     *\n     * @param num The number whose digits are to be summed.\n     * @return Sum of the digits.\n     */\n    private int sumOfDigits(int num) {\n        int sum = 0;\n        while (num > 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n        return sum;\n    }\n\n    // Test cases\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.skjkasdkd(Arrays.asList(0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3))); // 10\n        System.out.println(solution.skjkasdkd(Arrays.asList(1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1))); // 25\n        System.out.println(solution.skjkasdkd(Arrays.asList(1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3))); // 13\n        System.out.println(solution.skjkasdkd(Arrays.asList(0,724,32,71,99,32,6,0,5,91,83,0,5,6))); // 11\n        System.out.println(solution.skjkasdkd(Arrays.asList(0,81,12,3,1,21))); // 3\n        System.out.println(solution.skjkasdkd(Arrays.asList(0,8,1,2,1,7))); // 7\n    }\n}\n"}
{"task_id": "Java/95", "generation": "import java.util.*;\n\nclass Solution {\n    public boolean check_dict_case(Map<Object, Object> dict) {\n        // Check if the dictionary is empty\n        if (dict.isEmpty()) {\n            return false;\n        }\n\n        boolean hasLower = false;\n        boolean hasUpper = false;\n\n        for (Object key : dict.keySet()) {\n            // If any key is not a string, return false\n            if (!(key instanceof String)) {\n                return false;\n            }\n            \n            String strKey = (String) key;\n            // Check the case of each character in the key\n            for (char c : strKey.toCharArray()) {\n                if (Character.isLowerCase(c)) {\n                    hasLower = true;\n                } else if (Character.isUpperCase(c)) {\n                    hasUpper = true;\n                }\n                \n                // If both lower and upper cases are found, return false\n                if (hasLower && hasUpper) {\n                    return false;\n                }\n            }\n        }\n\n        // If the loop completes without finding mixed case keys, return true\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        Map<Object, Object> dict1 = new HashMap<>();\n        dict1.put(\"a\", \"apple\");\n        dict1.put(\"b\", \"banana\");\n        System.out.println(solution.check_dict_case(dict1)); // Expected: true\n\n        Map<Object, Object> dict2 = new HashMap<>();\n        dict2.put(\"a\", \"apple\");\n        dict2.put(\"A\", \"banana\");\n        dict2.put(\"B\", \"banana\");\n        System.out.println(solution.check_dict_case(dict2)); // Expected: false\n        \n        Map<Object, Object> dict3 = new HashMap<>();\n        dict3.put(\"a\", \"apple\");\n        dict3.put(8, \"banana\"); // Not a string key\n        dict3.put(\"a\", \"apple\");\n        System.out.println(solution.check_dict_case(dict3)); // Expected: false\n\n        Map<Object, Object> dict4 = new HashMap<>();\n        dict4.put(\"Name\", \"John\");\n        dict4.put(\"Age\", \"36\");\n        dict4.put(\"City\", \"Houston\"); // Mixed case keys\n        System.out.println(solution.check_dict_case(dict4)); // Expected: false\n        \n        Map<Object, Object> dict5 = new HashMap<>();\n        dict5.put(\"STATE\", \"NC\");\n        dict5.put(\"ZIP\", \"12345\");\n        System.out.println(solution.check_dict_case(dict5)); // Expected: true\n    }\n}\n"}
{"task_id": "Java/96", "generation": "import java.util.ArrayList;\nimport java.util.List;\n\nclass Solution {\n    public List<Integer> count_up_to(int n) {\n        List<Integer> primes = new ArrayList<>();\n        \n        for (int i = 2; i < n; i++) {\n            if (isPrime(i)) {\n                primes.add(i);\n            }\n        }\n\n        return primes;\n    }\n\n    private boolean isPrime(int num) {\n        if (num <= 1) {\n            return false;\n        }\n        for (int i = 2; i * i <= num; i++) {\n            if (num % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.count_up_to(5));   // Expected: [2,3]\n        System.out.println(solution.count_up_to(11));  // Expected: [2,3,5,7]\n        System.out.println(solution.count_up_to(0));   // Expected: []\n        System.out.println(solution.count_up_to(20));  // Expected: [2,3,5,7,11,13,17,19]\n        System.out.println(solution.count_up_to(1));   // Expected: []\n        System.out.println(solution.count_up_to(18));  // Expected: [2,3,5,7,11,13,17]\n    }\n}\n"}
{"task_id": "Java/97", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    \n    /**\n     * Takes two integers and returns the product of their unit digits.\n     *\n     * @param a First integer\n     * @param b Second integer\n     * @return The product of the unit digits of a and b\n     */\n    public int multiply(int a, int b) {\n        // Extracting the last digit by taking modulo 10\n        int lastDigitA = Math.abs(a % 10);\n        int lastDigitB = Math.abs(b % 10);\n\n        // Returning the product of the unit digits\n        return lastDigitA * lastDigitB;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases to verify the correctness of the function\n        System.out.println(solution.multiply(148, 412)); // Expected output: 16\n        System.out.println(solution.multiply(19, 28));   // Expected output: 72\n        System.out.println(solution.multiply(2020, 1851)); // Expected output: 0\n        System.out.println(solution.multiply(14, -15)); // Expected output: 20\n    }\n}\n"}
{"task_id": "Java/98", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a string s, count the number of uppercase vowels in even indices.\n     *\n     * @param s The input string.\n     * @return The count of uppercase vowels at even indices.\n     */\n    public int count_upper(String s) {\n        // Define an array of uppercase vowels for easy checking\n        char[] vowels = {'A', 'E', 'I', 'O', 'U'};\n        \n        int count = 0;\n        // Loop through the string, considering only even indices\n        for (int i = 0; i < s.length(); i += 2) {\n            char currentChar = s.charAt(i);\n            // Check if the character at the current index is an uppercase vowel\n            for (char v : vowels) {\n                if (currentChar == v) {\n                    count++;\n                    break;\n                }\n            }\n        }\n        \n        return count;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases to verify the correctness of the method\n        System.out.println(solution.count_upper(\"aBCdEf\"));  // Expected output: 1\n        System.out.println(solution.count_upper(\"abcdefg\")); // Expected output: 0\n        System.out.println(solution.count_upper(\"dBBE\"));    // Expected output: 0\n        System.out.println(solution.count_upper(\"AeIoU\"));   // Expected output: 3\n        System.out.println(solution.count_upper(\"AEIOUaeiou\")); // Expected output: 5\n    }\n}\n"}
{"task_id": "Java/99", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Create a function that takes a value (string) representing a number\n     * and returns the closest integer to it. If the number is equidistant\n     * from two integers, round it away from zero.\n     *\n     * @param value The string representation of the number.\n     * @return The closest integer rounded according to the rules specified.\n     */\n    public int closest_integer(String value) {\n        double num = Double.parseDouble(value);\n        \n        if (num > 0 && num - Math.floor(num) == 0.5) {\n            return (int)Math.ceil(num);\n        } else if (num < 0 && Math.abs(num - Math.ceil(num)) == 0.5) {\n            return (int)Math.floor(num);\n        } else {\n            return (int)Math.round(num);\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.closest_integer(\"10\"));      // Expected output: 10\n        System.out.println(solution.closest_integer(\"15.3\"));    // Expected output: 15\n        System.out.println(solution.closest_integer(\"14.5\"));    // Expected output: 15\n        System.out.println(solution.closest_integer(\"-14.5\"));   // Expected output: -15\n        System.out.println(solution.closest_integer(\"0.5\"));     // Expected output: 1\n        System.out.println(solution.closest_integer(\"-0.5\"));    // Expected output: -1\n    }\n}\n"}
{"task_id": "Java/100", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given a positive integer n, makes a pile of n levels of stones.\n     * The first level has n stones.\n     * The number of stones in the next level is:\n     * - the next odd number if n is odd.\n     * - the next even number if n is even.\n     *\n     * @param n the total number of levels\n     * @return a list where each element represents the number of stones at that level\n     */\n    public List<Integer> make_a_pile(int n) {\n        List<Integer> pile = new ArrayList<>();\n        int currentStones = n;\n        \n        for (int i = 0; i < n; i++) {\n            pile.add(currentStones);\n            if (n % 2 == 1) { // If n is odd\n                currentStones += 2; // Next odd number\n            } else { // If n is even\n                currentStones += 2; // Next even number\n            }\n        }\n        \n        return pile;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.make_a_pile(3)); // Expected: [3, 5, 7]\n        System.out.println(solution.make_a_pile(4)); // Expected: [4, 6, 8, 10]\n    }\n}\n"}
{"task_id": "Java/101", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Splits a string into words based on commas and spaces.\n     *\n     * @param s The input string containing words separated by commas or spaces.\n     * @return A List of strings representing the individual words from the input string.\n     */\n    public List<String> words_string(String s) {\n        // Replace commas with space to unify separators, then split on whitespace\n        String[] words = s.replaceAll(\",\", \"\").split(\"\\\\s+\");\n        return Arrays.asList(words);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1: Normal sentence with spaces and commas.\n        List<String> result1 = solution.words_string(\"Hi, my name is John\");\n        System.out.println(result1.equals(Arrays.asList(\"Hi\", \"my\", \"name\", \"is\", \"John\"))); // Expected output: true\n\n        // Test case 2: Sentence with only commas as separators.\n        List<String> result2 = solution.words_string(\"One, two, three, four, five, six\");\n        System.out.println(result2.equals(Arrays.asList(\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"))); // Expected output: true\n\n        // Test case 3: Sentence with multiple spaces and commas.\n        List<String> result3 = solution.words_string(\"Hello , world   this is a test\");\n        System.out.println(result3.equals(Arrays.asList(\"Hello\", \"world\", \"this\", \"is\", \"a\", \"test\"))); // Expected output: true\n\n        // Test case 4: Empty string.\n        List<String> result4 = solution.words_string(\"\");\n        System.out.println(result4.isEmpty()); // Expected output: true\n    }\n}\n"}
{"task_id": "Java/102", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * This function takes two positive numbers x and y and returns the\n     * biggest even integer number that is in the range [x, y] inclusive. If\n     * there's no such number, then the function should return -1.\n     *\n     * For example:\n     * choose_num(12, 15) = 14\n     * choose_num(13, 12) = -1\n     */\n    public int choose_num(int x, int y) {\n        // Ensure that x is less than or equal to y for the range check.\n        if (x > y) return -1;\n\n        // Start from y and move downwards until we find an even number in the range [x, y].\n        for (int i = y; i >= x; i--) {\n            if (i % 2 == 0) {\n                return i;\n            }\n        }\n\n        // If no even number is found within the range.\n        return -1;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n\n        // Test cases\n        System.out.println(sol.choose_num(12, 15)); // Expected output: 14\n        System.out.println(sol.choose_num(13, 12)); // Expected output: -1\n        System.out.println(sol.choose_num(8, 10));  // Expected output: 10\n        System.out.println(sol.choose_num(9, 17));  // Expected output: 16\n        System.out.println(sol.choose_num(5, 5));   // Expected output: -1 (since 5 is odd)\n    }\n}\n"}
{"task_id": "Java/103", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Computes the average of integers from n through m (inclusive),\n     * rounds it to the nearest integer, and converts that to binary.\n     * Returns -1 if n is greater than m.\n     */\n    public Object rounded_avg(int n, int m) {\n        if (n > m) return -1;\n\n        // Calculate sum of integers from n through m\n        long totalSum = 0;\n        for (int i = n; i <= m; ++i) {\n            totalSum += i;\n        }\n\n        // Compute the average and round it to the nearest integer\n        int count = m - n + 1;\n        double avg = Math.round((double)totalSum / count);\n\n        // Convert the rounded average to binary string\n        return Integer.toBinaryString((int)avg);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.rounded_avg(1, 5));   // Expected: \"11\"\n        System.out.println(solution.rounded_avg(7, 5));   // Expected: -1\n        System.out.println(solution.rounded_avg(10, 20)); // Expected: \"1111\"\n        System.out.println(solution.rounded_avg(20, 33)); // Expected: \"11011\"\n    }\n}\n"}
{"task_id": "Java/104", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a list of positive integers x, returns a sorted list of all elements \n     * that do not contain any even digit.\n     *\n     * @param x List of positive integers\n     * @return Sorted list of integers without any even digits\n     */\n    public List<Integer> unique_digits(List<Integer> x) {\n        // Filter out numbers with even digits and sort the result\n        return x.stream()\n                .filter(this::hasNoEvenDigits)\n                .sorted()\n                .collect(Collectors.toList());\n    }\n\n    /**\n     * Helper method to check if a number has no even digit.\n     *\n     * @param num The number to be checked\n     * @return true if the number has no even digits, false otherwise\n     */\n    private boolean hasNoEvenDigits(int num) {\n        while (num > 0) {\n            int digit = num % 10;\n            if (digit % 2 == 0) return false; // Found an even digit\n            num /= 10;\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        List<Integer> test1 = Arrays.asList(15, 33, 1422, 1);\n        System.out.println(solution.unique_digits(test1)); // Expected: [1, 15, 33]\n        \n        List<Integer> test2 = Arrays.asList(152, 323, 1422, 10);\n        System.out.println(solution.unique_digits(test2)); // Expected: []\n    }\n}\n"}
{"task_id": "Java/105", "generation": "import java.util.*;\n\nclass Solution {\n    private static final String[] DIGIT_NAMES = {\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"};\n\n    public List<String> by_length(List<Integer> arr) {\n        // Filter out integers between 1 and 9 inclusive\n        List<Integer> filteredArr = new ArrayList<>();\n        for (int num : arr) {\n            if (num >= 1 && num <= 9) {\n                filteredArr.add(num);\n            }\n        }\n\n        // Sort the filtered array in ascending order\n        Collections.sort(filteredArr);\n\n        // Reverse the sorted array\n        Collections.reverse(filteredArr);\n\n        // Replace each digit by its corresponding name\n        List<String> result = new ArrayList<>();\n        for (int num : filteredArr) {\n            result.add(DIGIT_NAMES[num - 1]);\n        }\n\n        return result;\n    }\n}\n\npublic class TestSolution {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        List<Integer> arr1 = Arrays.asList(2, 1, 1, 4, 5, 8, 2, 3);\n        System.out.println(solution.by_length(arr1)); // Expected: [Eight, Five, Four, Three, Two, Two, One, One]\n\n        // Test case 2\n        List<Integer> arr2 = new ArrayList<>();\n        System.out.println(solution.by_length(arr2)); // Expected: []\n\n        // Test case 3\n        List<Integer> arr3 = Arrays.asList(1, -1, 55);\n        System.out.println(solution.by_length(arr3)); // Expected: [One]\n    }\n}\n"}
{"task_id": "Java/106", "generation": "import java.util.ArrayList;\nimport java.util.List;\n\nclass Solution {\n    /**\n     * Implement the function f that takes n as a parameter,\n     * and returns a list of size n, such that the value of the element at index i is the factorial of i if i is even\n     * or the sum of numbers from 1 to i otherwise.\n     * i starts from 1.\n     * The factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).\n     *\n     * Example:\n     * f(5) == [1, 2, 6, 24, 15]\n     */\n    public List<Integer> f(int n) {\n        List<Integer> result = new ArrayList<>();\n        \n        for (int i = 1; i <= n; i++) {\n            if (i % 2 == 0) {\n                // If i is even, calculate factorial\n                result.add(factorial(i));\n            } else {\n                // If i is odd, calculate sum from 1 to i\n                result.add(sumFromOneToI(i));\n            }\n        }\n\n        return result;\n    }\n\n    private int factorial(int n) {\n        if (n == 0 || n == 1) return 1;\n        int fact = 1;\n        for (int i = 2; i <= n; i++) {\n            fact *= i;\n        }\n        return fact;\n    }\n\n    private int sumFromOneToI(int n) {\n        return (n * (n + 1)) / 2;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test the function\n        List<Integer> result = solution.f(5);\n        System.out.println(result); // Expected output: [1, 2, 6, 24, 15]\n    }\n}\n"}
{"task_id": "Java/107", "generation": "import java.util.*;\n\nclass Solution {\n    public List<Integer> even_odd_palindrome(int n) {\n        int evenCount = 0;\n        int oddCount = 0;\n\n        for (int i = 1; i <= n; i++) {\n            if (isPalindrome(i)) {\n                if (i % 2 == 0) {\n                    evenCount++;\n                } else {\n                    oddCount++;\n                }\n            }\n        }\n\n        List<Integer> result = new ArrayList<>();\n        result.add(evenCount);\n        result.add(oddCount);\n\n        return result;\n    }\n\n    private boolean isPalindrome(int number) {\n        String numStr = Integer.toString(number);\n        int left = 0, right = numStr.length() - 1;\n\n        while (left < right) {\n            if (numStr.charAt(left) != numStr.charAt(right)) {\n                return false;\n            }\n            left++;\n            right--;\n        }\n\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        System.out.println(solution.even_odd_palindrome(3)); // Expected output: [1, 2]\n\n        // Test case 2\n        System.out.println(solution.even_odd_palindrome(12)); // Expected output: [4, 6]\n    }\n}\n"}
{"task_id": "Java/108", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Write a function count_nums which takes an array of integers and returns\n     * the number of elements which has a sum of digits > 0.\n     * If a number is negative, then its first signed digit will be negative:\n     * e.g. -123 has signed digits -1, 2, and 3.\n     */\n    public int count_nums(List<Integer> arr) {\n        return (int) arr.stream()\n                .filter(num -> sumOfDigits(num) > 0)\n                .count();\n    }\n\n    private int sumOfDigits(int num) {\n        boolean isNegative = num < 0;\n        int sum = 0;\n        while (num != 0) {\n            int digit = num % 10;\n            if (isNegative && sum == 0) { // First digit of negative number\n                digit *= -1; \n            }\n            sum += digit;\n            num /= 10;\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.count_nums(Arrays.asList()) == 0);\n        System.out.println(solution.count_nums(Arrays.asList(-1, 11, -11)) == 1);\n        System.out.println(solution.count_nums(Arrays.asList(1, 1, 2)) == 3);\n\n        // Additional test cases\n        System.out.println(solution.count_nums(Arrays.asList(-999, 0, 123456789)) == 2); \n        System.out.println(solution.count_nums(Arrays.asList(-123, -456, -789)) == 0);\n    }\n}\n"}
{"task_id": "Java/109", "generation": "import java.util.*;\n\nclass Solution {\n    public boolean move_one_ball(List<Integer> arr) {\n        if (arr.isEmpty()) return true;\n\n        int n = arr.size();\n        int count = 0;\n        \n        for (int i = 1; i < n; ++i) {\n            // If the current element is smaller than the previous one, increment count\n            if (arr.get(i - 1) > arr.get(i)) {\n                count++;\n                // If there are more than one such instances, return false\n                if (count > 1) return false;\n            }\n        }\n\n        // Check if the last element is smaller than or equal to the first element\n        if (arr.get(n - 1) > arr.get(0)) {\n            count++;\n        }\n\n        // If there's at most one such instance, it means we can sort by right shift\n        return count <= 1;\n    }\n    \n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        \n        System.out.println(sol.move_one_ball(Arrays.asList(3, 4, 5, 1, 2))); // true\n        System.out.println(sol.move_one_ball(Arrays.asList(3, 5, 4, 1, 2))); // false\n    }\n}\n"}
{"task_id": "Java/110", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Determines whether it's possible to exchange elements between lst1 and lst2\n     * to make all elements of lst1 even.\n     *\n     * @param lst1 The first list of integers.\n     * @param lst2 The second list of integers.\n     * @return \"YES\" if it is possible, otherwise \"NO\".\n     */\n    public String exchange(List<Integer> lst1, List<Integer> lst2) {\n        int oddCountLst1 = 0;\n        int evenCountLst2 = 0;\n\n        // Count the number of odd numbers in lst1 and even numbers in lst2\n        for (int num : lst1) {\n            if (num % 2 != 0) {\n                oddCountLst1++;\n            }\n        }\n\n        for (int num : lst2) {\n            if (num % 2 == 0) {\n                evenCountLst2++;\n            }\n        }\n\n        // If there are enough even numbers in lst2 to replace all the odd ones in lst1, return \"YES\"\n        if (evenCountLst2 >= oddCountLst1) {\n            return \"YES\";\n        } else {\n            return \"NO\";\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.exchange(Arrays.asList(1, 2, 3, 4), Arrays.asList(1, 2, 3, 4))); // Expected: \"YES\"\n        System.out.println(solution.exchange(Arrays.asList(1, 2, 3, 4), Arrays.asList(1, 5, 3, 4))); // Expected: \"NO\"\n        System.out.println(solution.exchange(Arrays.asList(1, 3, 5, 7), Arrays.asList(2, 4, 6, 8))); // Expected: \"YES\"\n        System.out.println(solution.exchange(Arrays.asList(1, 3, 5, 7), Arrays.asList(1, 3, 5, 7))); // Expected: \"NO\"\n    }\n}\n"}
{"task_id": "Java/111", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given a string representing space-separated lowercase letters, returns a dictionary\n     * of the letter(s) with the most repetition and their corresponding count.\n     *\n     * @param test The input string containing space-separated characters.\n     * @return A map where keys are characters and values are their counts if they have the highest frequency.\n     */\n    public Map<String, Integer> histogram(String test) {\n        // Split the string into an array of words\n        String[] words = test.split(\" \");\n        \n        // Use a HashMap to count occurrences of each character\n        Map<String, Integer> countMap = new HashMap<>();\n        for (String word : words) {\n            if (!word.isEmpty()) {  // Ignore empty strings resulting from split on multiple spaces\n                countMap.put(word, countMap.getOrDefault(word, 0) + 1);\n            }\n        }\n\n        // Find the maximum occurrence value\n        int maxCount = Collections.max(countMap.values());\n\n        // Filter out only those characters that have the highest frequency\n        Map<String, Integer> result = new HashMap<>();\n        for (Map.Entry<String, Integer> entry : countMap.entrySet()) {\n            if (entry.getValue() == maxCount) {\n                result.put(entry.getKey(), entry.getValue());\n            }\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.histogram(\"a b c\"));  // {\"a\": 1, \"b\": 1, \"c\": 1}\n        System.out.println(solution.histogram(\"a b b a\"));  // {\"a\": 2, \"b\": 2}\n        System.out.println(solution.histogram(\"a b c a b\"));  // {\"a\": 2, \"b\": 2}\n        System.out.println(solution.histogram(\"b b b b a\"));  // {\"b\": 4}\n        System.out.println(solution.histogram(\"\"));  // {}\n    }\n}\n"}
{"task_id": "Java/112", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Task: We are given two strings s and c, you have to delete all the characters in s that are equal to any character in c.\n     * Then check if the resulting string is a palindrome. A string is called palindrome if it reads the same backward as forward.\n     * You should return a tuple containing the result string and true/false for the check.\n     *\n     * Example:\n     * For s = \"abcde\", c = \"ae\", the result should be (\"bcd\", false)\n     * For s = \"abcdef\", c = \"b\"  the result should be (\"acdef\", false)\n     * For s = \"abcdedcba\", c = \"ab\", the result should be (\"cdedc\", true)\n     */\n    public List<Object> reverse_delete(String s, String c) {\n        // Remove all characters in 's' that are present in 'c'\n        StringBuilder sb = new StringBuilder();\n        for (char ch : s.toCharArray()) {\n            if (c.indexOf(ch) == -1) {  // If character is not found in 'c', add it to the result\n                sb.append(ch);\n            }\n        }\n\n        String resultString = sb.toString();\n\n        // Check if the resulting string is a palindrome\n        boolean isPalindrome = true;\n        int left = 0, right = resultString.length() - 1;\n        while (left < right) {\n            if (resultString.charAt(left++) != resultString.charAt(right--)) {\n                isPalindrome = false;\n                break;\n            }\n        }\n\n        // Return the tuple\n        return Arrays.asList(resultString, isPalindrome);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.reverse_delete(\"abcde\", \"ae\"));  // Expected: [bcd, false]\n        System.out.println(solution.reverse_delete(\"abcdef\", \"b\"));  // Expected: [acdef, false]\n        System.out.println(solution.reverse_delete(\"abcdedcba\", \"ab\"));// Expected: [cdedc, true]\n    }\n}\n"}
{"task_id": "Java/113", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given a list of strings, where each string consists of only digits,\n     * return a list. Each element i of the output should be \"the number of odd elements in the\n     * string i of the input.\" where all the 'i's should be replaced by the number\n     * of odd digits in the ith string of the input.\n     */\n    public List<String> odd_count(List<String> lst) {\n        List<String> result = new ArrayList<>();\n        for (String s : lst) {\n            int count = 0;\n            // Counting odd numbers in each string\n            for (char c : s.toCharArray()) {\n                if ((c - '0') % 2 != 0) {\n                    count++;\n                }\n            }\n            // Creating the result sentence with counted odds replacing 'i'\n            String output = \"the number of odd elements \".replace(\"i\", Integer.toString(count)) +\n                            \"n the str\".replace(\"i\", Integer.toString(count)) +\n                            \"ng \".replace(\"i\", Integer.toString(count)) +\n                            \"of the \".replace(\"i\", Integer.toString(count)) +\n                            \"nput.\";\n            result.add(output);\n        }\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case 1\n        List<String> testList1 = Arrays.asList(\"1234567\");\n        System.out.println(solution.odd_count(testList1));\n        // Expected: [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n        \n        // Test case 2\n        List<String> testList2 = Arrays.asList(\"3\", \"11111111\");\n        System.out.println(solution.odd_count(testList2));\n        // Expected: [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n        //            \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    }\n}\n"}
{"task_id": "Java/114", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given an array of integers nums, finds the minimum sum of any non-empty sub-array\n     * of nums.\n     *\n     * @param nums List of integers representing the input array.\n     * @return The minimum sum of any non-empty sub-array.\n     */\n    public int minSubArraySum(List<Integer> nums) {\n        if (nums == null || nums.isEmpty()) return 0;\n\n        // Initialize variables to store the current and global minimum sums\n        int currentMin = nums.get(0);\n        int globalMin = nums.get(0);\n\n        for (int i = 1; i < nums.size(); i++) {\n            // Update the current min sum by either starting a new subarray from the current element or extending the previous one.\n            currentMin = Math.min(nums.get(i), currentMin + nums.get(i));\n            globalMin = Math.min(globalMin, currentMin);\n        }\n\n        return globalMin;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        List<Integer> test1 = Arrays.asList(2, 3, 4, 1, 2, 4);\n        System.out.println(\"Test Case 1: \" + (solution.minSubArraySum(test1) == 1));\n\n        List<Integer> test2 = Arrays.asList(-1, -2, -3);\n        System.out.println(\"Test Case 2: \" + (solution.minSubArraySum(test2) == -6));\n    }\n}\n"}
{"task_id": "Java/115", "generation": "import java.util.*;\n\nclass Solution {\n    public int max_fill(List<List<Integer>> grid, int capacity) {\n        // Initialize the total count of fills required.\n        int totalCount = 0;\n\n        // Iterate over each column in the grid.\n        for (int col = 0; col < grid.get(0).size(); col++) {\n            int waterUnitsInColumn = 0;\n            \n            // Sum up all units of water in this column across all wells.\n            for (List<Integer> row : grid) {\n                waterUnitsInColumn += row.get(col);\n            }\n            \n            // Calculate the number of fills required for this column and add to totalCount.\n            totalCount += Math.ceil((double) waterUnitsInColumn / capacity);\n        }\n\n        return totalCount;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        List<List<Integer>> grid1 = Arrays.asList(\n                Arrays.asList(0, 0, 1, 0),\n                Arrays.asList(0, 1, 0, 0),\n                Arrays.asList(1, 1, 1, 1)\n        );\n        System.out.println(solution.max_fill(grid1, 1)); // Output: 6\n\n        List<List<Integer>> grid2 = Arrays.asList(\n                Arrays.asList(0, 0, 1, 1),\n                Arrays.asList(0, 0, 0, 0),\n                Arrays.asList(1, 1, 1, 1),\n                Arrays.asList(0, 1, 1, 1)\n        );\n        System.out.println(solution.max_fill(grid2, 2)); // Output: 5\n\n        List<List<Integer>> grid3 = Arrays.asList(\n                Arrays.asList(0, 0, 0),\n                Arrays.asList(0, 0, 0)\n        );\n        System.out.println(solution.max_fill(grid3, 5)); // Output: 0\n    }\n}\n"}
{"task_id": "Java/116", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * In this Kata, you have to sort an array of integers according to\n     * number of ones in their binary representation in ascending order.\n     * For similar number of ones, sort based on decimal value.\n     *\n     * @param arr List of integers to be sorted.\n     * @return Sorted list of integers.\n     */\n    public List<Integer> sort_array(List<Integer> arr) {\n        Collections.sort(arr, new Comparator<Integer>() {\n            @Override\n            public int compare(Integer o1, Integer o2) {\n                int count1 = Integer.bitCount(o1);\n                int count2 = Integer.bitCount(o2);\n\n                if (count1 != count2) {\n                    return count1 - count2;\n                } else {\n                    return o1.compareTo(o2);\n                }\n            }\n        });\n        \n        return arr;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case 1\n        List<Integer> list1 = Arrays.asList(1, 5, 2, 3, 4);\n        System.out.println(solution.sort_array(list1).equals(Arrays.asList(1, 2, 4, 3, 5)));\n        \n        // Test case 2\n        List<Integer> list2 = Arrays.asList(-2, -3, -4, -5, -6);\n        System.out.println(solution.sort_array(list2).equals(Arrays.asList(-4, -2, -6, -5, -3)));\n        \n        // Test case 3\n        List<Integer> list3 = Arrays.asList(1, 0, 2, 3, 4);\n        System.out.println(solution.sort_array(list3).equals(Arrays.asList(0, 1, 2, 4, 3)));\n    }\n}\n"}
{"task_id": "Java/117", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<String> select_words(String s, int n) {\n        if (s == null || s.isEmpty()) return new ArrayList<>();\n        \n        String[] words = s.split(\"\\\\s+\");\n        List<String> result = new ArrayList<>();\n\n        for (String word : words) {\n            if (countConsonants(word) == n) {\n                result.add(word);\n            }\n        }\n\n        return result;\n    }\n\n    private int countConsonants(String word) {\n        int consonantCount = 0;\n        String vowels = \"aeiouAEIOU\";\n        \n        for (char c : word.toCharArray()) {\n            if (!vowels.contains(Character.toString(c)) && Character.isLetter(c)) {\n                consonantCount++;\n            }\n        }\n\n        return consonantCount;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.select_words(\"Mary had a little lamb\", 4)); // ==> [\"little\"]\n        System.out.println(solution.select_words(\"Mary had a little lamb\", 3)); // ==> [\"Mary\", \"lamb\"]\n        System.out.println(solution.select_words(\"simple white space\", 2));     // ==> []\n        System.out.println(solution.select_words(\"Hello world\", 4));            // ==> [\"world\"]\n        System.out.println(solution.select_words(\"Uncle sam\", 3));              // ==> [\"Uncle\"]\n    }\n}\n"}
{"task_id": "Java/118", "generation": "import java.util.*;\n\nclass Solution {\n    public String get_closest_vowel(String word) {\n        if (word == null || word.length() < 3) return \"\";\n\n        for (int i = word.length() - 2; i > 0; i--) { // Start from the second last character and move left\n            char currentChar = word.charAt(i);\n            char prevChar = word.charAt(i - 1);\n            char nextChar = word.charAt(i + 1);\n\n            if (isVowel(currentChar) && !isVowel(prevChar) && !isVowel(nextChar)) {\n                return String.valueOf(currentChar); // Found the vowel, return it\n            }\n        }\n\n        return \"\"; // No such vowel found\n    }\n\n    private boolean isVowel(char c) {\n        return \"AEIOUaeiou\".indexOf(c) != -1;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.get_closest_vowel(\"yogurt\")); // Expected: \"u\"\n        System.out.println(solution.get_closest_vowel(\"FULL\"));   // Expected: \"U\"\n        System.out.println(solution.get_closest_vowel(\"quick\"));  // Expected: \"\"\n        System.out.println(solution.get_closest_vowel(\"ab\"));     // Expected: \"\"\n    }\n}\n"}
{"task_id": "Java/119", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Checks if it's possible to concatenate two strings of parentheses in some order\n     * that results in a balanced string.\n     *\n     * @param lst A list containing two strings consisting only of '(' or ')'.\n     * @return \"Yes\" if there is a way to make the concatenated string balanced, otherwise \"No\".\n     */\n    public String match_parens(List<String> lst) {\n        // Count open and close parentheses in both strings\n        int open1 = count(lst.get(0), '(');\n        int close1 = count(lst.get(0), ')');\n        int open2 = count(lst.get(1), '(');\n        int close2 = count(lst.get(1), ')');\n\n        // Check if concatenating in either order results in a balanced string\n        boolean canBalanceFirstOrder = (open1 + open2 >= close1) && (close1 + close2 == open1 + open2);\n        boolean canBalanceSecondOrder = (open2 + open1 >= close2) && (close2 + close1 == open2 + open1);\n\n        if (canBalanceFirstOrder || canBalanceSecondOrder) {\n            return \"Yes\";\n        } else {\n            return \"No\";\n        }\n    }\n\n    // Helper method to count occurrences of a character in a string\n    private int count(String s, char c) {\n        int count = 0;\n        for (int i = 0; i < s.length(); ++i) {\n            if (s.charAt(i) == c) {\n                ++count;\n            }\n        }\n        return count;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.match_parens(Arrays.asList(\"()(\", \")\")));  // Expected: \"Yes\"\n        System.out.println(solution.match_parens(Arrays.asList(\")\", \")\")));     // Expected: \"No\"\n        System.out.println(solution.match_parens(Arrays.asList(\"((\", \"))\")));   // Expected: \"Yes\"\n        System.out.println(solution.match_parens(Arrays.asList(\"(()\", \"()\"));  // Expected: \"Yes\"\n    }\n}\n"}
{"task_id": "Java/120", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given an array arr of integers and a positive integer k, return a sorted list\n     * of length k with the maximum k numbers in arr, in ascending order.\n     */\n    public List<Integer> maximum(List<Integer> arr, int k) {\n        // Sort the array in ascending order\n        Collections.sort(arr);\n        \n        // Create a new list to store the result\n        List<Integer> result = new ArrayList<>();\n        \n        // Extract the last k elements from the sorted array\n        for (int i = arr.size() - 1; i >= arr.size() - k && i >= 0; i--) {\n            result.add(arr.get(i));\n        }\n        \n        // Since we want the result in ascending order, sort it again before returning\n        Collections.sort(result);\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        List<Integer> test1 = Arrays.asList(-3, -4, 5);\n        System.out.println(solution.maximum(test1, 3)); // Expected: [-4, -3, 5]\n        \n        List<Integer> test2 = Arrays.asList(4, -4, 4);\n        System.out.println(solution.maximum(test2, 2)); // Expected: [4, 4]\n        \n        List<Integer> test3 = Arrays.asList(-3, 2, 1, 2, -1, -2, 1);\n        System.out.println(solution.maximum(test3, 1)); // Expected: [2]\n    }\n}\n"}
{"task_id": "Java/121", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n     *\n     * @param lst The input list of integers.\n     * @return The sum of all odd elements at even positions.\n     */\n    public int solution(List<Integer> lst) {\n        int sum = 0;\n        // Iterate through the list, starting from index 0 (even position), stepping by 2\n        for (int i = 0; i < lst.size(); i += 2) {\n            if (lst.get(i) % 2 != 0) { // Check if the element is odd\n                sum += lst.get(i);\n            }\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        \n        // Test case 1: Expected output 12 (5 + 7)\n        System.out.println(sol.solution(Arrays.asList(5, 8, 7, 1))); \n\n        // Test case 2: Expected output 9 (3 + 3 + 3)\n        System.out.println(sol.solution(Arrays.asList(3, 3, 3, 3, 3)));\n\n        // Test case 3: Expected output 0 (no odd elements at even positions)\n        System.out.println(sol.solution(Arrays.asList(30, 13, 24, 321)));\n    }\n}\n"}
{"task_id": "Java/122", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given a non-empty array of integers arr and an integer k,\n     * return the sum of the elements with at most two digits from the first k elements of arr.\n     *\n     * @param arr List<Integer> - The input list of integers.\n     * @param k int - The number of elements to consider from the start of the array.\n     * @return int - Sum of elements with at most two digits among the first k elements.\n     */\n    public int add_elements(List<Integer> arr, int k) {\n        int sum = 0;\n        for (int i = 0; i < k; i++) {\n            if (arr.get(i) >= -99 && arr.get(i) <= 99) { // Check if the number has at most two digits\n                sum += arr.get(i);\n            }\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        List<Integer> test1 = Arrays.asList(111, 21, 3, 4000, 5, 6, 7, 8, 9);\n        int k1 = 4;\n        System.out.println(\"Test Case 1: \" + solution.add_elements(test1, k1)); // Expected output: 24\n        \n        List<Integer> test2 = Arrays.asList(10, 23, -56, 78, 99);\n        int k2 = 5;\n        System.out.println(\"Test Case 2: \" + solution.add_elements(test2, k2)); // Expected output: 45\n        \n        List<Integer> test3 = Arrays.asList(100, 200, 300, -10);\n        int k3 = 3;\n        System.out.println(\"Test Case 3: \" + solution.add_elements(test3, k3)); // Expected output: 0\n    }\n}\n"}
{"task_id": "Java/123", "generation": "import java.util.*;\n\nclass Solution {\n    public List<Integer> get_odd_collatz(int n) {\n        Set<Integer> collatzSet = new HashSet<>();\n        \n        // Generate Collatz sequence and collect odd numbers.\n        while (n != 1) {\n            if (n % 2 == 0) {\n                n /= 2;\n            } else {\n                collatzSet.add(n);\n                n = 3 * n + 1;\n            }\n        }\n        collatzSet.add(1); // The sequence always ends with 1, which is odd.\n\n        List<Integer> result = new ArrayList<>(collatzSet);\n        Collections.sort(result); // Sort the list in increasing order.\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.get_odd_collatz(5)); // Expected: [1, 5]\n        System.out.println(solution.get_odd_collatz(7)); // Expected: [1, 7, 11, 22, 34, 52]\n    }\n}\n"}
{"task_id": "Java/124", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n    You have to write a function which validates a given date string and\n    returns true if the date is valid otherwise false.\n    The date is valid if all of the following rules are satisfied:\n    1. The date string is not empty.\n    2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.\n    3. The months should not be less than 1 or higher than 12.\n    4. The date should be in the format: mm-dd-yyyy\n\n    for example:\n    valid_date(\"03-11-2000\") => true\n    valid_date(\"15-01-2012\") => false\n    valid_date(\"04-0-2040\") => false\n    valid_date(\"06-04-2020\") => true\n    valid_date(\"06/04/2020\") => false\n     */\n    public boolean valid_date(String date) {\n        // Check if the string is empty or not in the correct format\n        if (date == null || !date.matches(\"\\\\d{2}-\\\\d{2}-\\\\d{4}\")) return false;\n\n        String[] parts = date.split(\"-\");\n        \n        int month = Integer.parseInt(parts[0]);\n        int day = Integer.parseInt(parts[1]);\n        int year = Integer.parseInt(parts[2]);\n\n        // Check the validity of the month\n        if (month < 1 || month > 12) return false;\n\n        // Check the validity of the days based on the month\n        if ((month == 4 || month == 6 || month == 9 || month == 11) && day > 30) {\n            return false;\n        } else if (month == 2 && day > 29) {\n            return false;\n        } else if (day < 1 || day > 31) {\n            return false;\n        }\n\n        // If all checks pass, the date is valid\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.valid_date(\"03-11-2000\"));  // Expected: true\n        System.out.println(solution.valid_date(\"15-01-2012\"));  // Expected: false\n        System.out.println(solution.valid_date(\"04-0-2040\"));   // Expected: false\n        System.out.println(solution.valid_date(\"06-04-2020\"));  // Expected: true\n        System.out.println(solution.valid_date(\"06/04/2020\"));  // Expected: false\n    }\n}\n"}
{"task_id": "Java/125", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a string of words, return a list of words split on whitespace, if no whitespaces exist in the text,\n     * you should split on commas ','. If no commas exist, you should return the number of lower-case letters with odd order\n     * in the alphabet (ord('a') = 0, ord('b') = 1, ..., ord('z') = 25).\n     */\n    public Object split_words(String txt) {\n        if (txt.contains(\" \")) {\n            return Arrays.asList(txt.split(\"\\\\s+\"));\n        } else if (txt.contains(\",\")) {\n            return Arrays.asList(txt.split(\",\"));\n        } else {\n            int count = 0;\n            for (char c : txt.toCharArray()) {\n                if (Character.isLowerCase(c) && ((c - 'a') % 2 == 1)) {\n                    count++;\n                }\n            }\n            return count;\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.split_words(\"Hello world!\")); // Expected: [Hello, world!]\n        System.out.println(solution.split_words(\"Hello,world!\")); // Expected: [Hello, world!]\n        System.out.println(solution.split_words(\"abcdef\"));       // Expected: 3\n        \n        // Additional test cases\n        System.out.println(solution.split_words(\"a,b,c,d,e,f\"));  // Expected: [a, b, c, d, e, f]\n        System.out.println(solution.split_words(\"abc def ghi\"));  // Expected: [abc, def, ghi]\n    }\n}\n"}
{"task_id": "Java/126", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given a list of numbers, return whether or not they are sorted in ascending order.\n     * If any number appears more than twice, return false. Assume no negative numbers and only integers.\n     */\n    public boolean is_sorted(List<Integer> lst) {\n        if (lst == null || lst.size() <= 1) {\n            return true;\n        }\n\n        int prev = lst.get(0);\n        int count = 1;\n\n        for (int i = 1; i < lst.size(); i++) {\n            int current = lst.get(i);\n\n            // Check if the list is not sorted in ascending order\n            if (current < prev) {\n                return false;\n            }\n\n            // Count occurrences of each number\n            if (current == prev) {\n                count++;\n                if (count > 2) {\n                    return false;\n                }\n            } else {\n                count = 1; // Reset the counter for a new number\n            }\n\n            prev = current;\n        }\n\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.is_sorted(Arrays.asList(5))); // -> true\n        System.out.println(solution.is_sorted(Arrays.asList(1, 2, 3, 4, 5))); // -> true\n        System.out.println(solution.is_sorted(Arrays.asList(1, 3, 2, 4, 5))); // -> false\n        System.out.println(solution.is_sorted(Arrays.asList(1, 2, 3, 4, 5, 6))); // -> true\n        System.out.println(solution.is_sorted(Arrays.asList(1, 2, 3, 4, 5, 6, 7))); // -> true\n        System.out.println(solution.is_sorted(Arrays.asList(1, 3, 2, 4, 5, 6, 7))); // -> false\n        System.out.println(solution.is_sorted(Arrays.asList(1, 2, 2, 3, 3, 4))); // -> true\n        System.out.println(solution.is_sorted(Arrays.asList(1, 2, 2, 2, 3, 4))); // -> false\n    }\n}\n"}
{"task_id": "Java/127", "generation": "import java.util.*;\n\nclass Solution {\n    public String intersection(List<Integer> interval1, List<Integer> interval2) {\n        // Extract start and end points of both intervals.\n        int start1 = interval1.get(0);\n        int end1 = interval1.get(1);\n        int start2 = interval2.get(0);\n        int end2 = interval2.get(1);\n\n        // Calculate the intersection\n        int maxStart = Math.max(start1, start2);\n        int minEnd = Math.min(end1, end2);\n\n        // Check if there is an intersection.\n        if (maxStart > minEnd) {\n            return \"NO\";  // No intersection.\n        }\n\n        // Length of the intersection.\n        int lengthOfIntersection = minEnd - maxStart + 1;\n\n        // Check if this length is a prime number.\n        if (isPrime(lengthOfIntersection)) {\n            return \"YES\";\n        } else {\n            return \"NO\";\n        }\n    }\n\n    private boolean isPrime(int n) {\n        if (n <= 1) {\n            return false;\n        }\n        for (int i = 2; i * i <= n; i++) {\n            if (n % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.intersection(Arrays.asList(1, 2), Arrays.asList(2, 3))); // NO\n        System.out.println(solution.intersection(Arrays.asList(-1, 1), Arrays.asList(0, 4))); // NO\n        System.out.println(solution.intersection(Arrays.asList(-3, -1), Arrays.asList(-5, 5))); // YES\n    }\n}\n"}
{"task_id": "Java/128", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Calculates sum of magnitudes of integers multiplied by product of all signs.\n     *\n     * @param arr List of integers.\n     * @return Optional<Integer> representing the result or None if the array is empty.\n     */\n    public Optional<Integer> prod_signs(List<Integer> arr) {\n        if (arr.isEmpty()) return Optional.empty();\n\n        int sumOfMagnitudes = 0;\n        int productOfSigns = 1;\n\n        for (int num : arr) {\n            sumOfMagnitudes += Math.abs(num);\n            if (num == 0) {\n                productOfSigns = 0;\n                break; // If any number is zero, the product of signs will be zero.\n            } else if (num < 0) {\n                productOfSigns *= -1;\n            }\n        }\n\n        return Optional.of(sumOfMagnitudes * productOfSigns);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.prod_signs(Arrays.asList(1, 2, 2, -4))); // Expected: Optional[-9]\n        System.out.println(solution.prod_signs(Arrays.asList(0, 1)));         // Expected: Optional[0]\n        System.out.println(solution.prod_signs(Arrays.asList()));             // Expected: Optional.empty\n    }\n}\n"}
{"task_id": "Java/129", "generation": "import java.util.*;\n\nclass Solution {\n    public List<Integer> minPath(List<List<Integer>> grid, int k) {\n        // Directions for moving to adjacent cells (up, down, left, right)\n        int[][] directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n        \n        // Priority queue to store paths with their values\n        PriorityQueue<Path> pq = new PriorityQueue<>((a, b) -> a.pathValues.compareTo(b.pathValues));\n        \n        int N = grid.size();\n        \n        for (int i = 0; i < N; ++i) {\n            for (int j = 0; j < N; ++j) {\n                // Start from each cell\n                List<Integer> initialPath = new ArrayList<>();\n                initialPath.add(grid.get(i).get(j));\n                pq.offer(new Path(initialPath, i, j));\n            }\n        }\n\n        while (!pq.isEmpty()) {\n            Path current = pq.poll();\n            \n            if (current.pathValues.size() == k) {\n                return current.pathValues;\n            }\n            \n            for (int[] dir : directions) {\n                int newRow = current.row + dir[0];\n                int newCol = current.col + dir[1];\n                \n                // Check boundaries\n                if (newRow >= 0 && newRow < N && newCol >= 0 && newCol < N) {\n                    List<Integer> newPathValues = new ArrayList<>(current.pathValues);\n                    newPathValues.add(grid.get(newRow).get(newCol));\n                    \n                    pq.offer(new Path(newPathValues, newRow, newCol));\n                }\n            }\n        }\n\n        return Collections.emptyList(); // This should never happen given the problem constraints\n    }\n\n    private static class Path {\n        List<Integer> pathValues;\n        int row;\n        int col;\n\n        public Path(List<Integer> pathValues, int row, int col) {\n            this.pathValues = pathValues;\n            this.row = row;\n            this.col = col;\n        }\n    }\n\n    // Test code\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        List<List<Integer>> grid1 = Arrays.asList(\n                Arrays.asList(1, 2, 3),\n                Arrays.asList(4, 5, 6),\n                Arrays.asList(7, 8, 9)\n        );\n        System.out.println(solution.minPath(grid1, 3)); // Expected: [1, 2, 1]\n\n        List<List<Integer>> grid2 = Arrays.asList(\n                Arrays.asList(5, 9, 3),\n                Arrays.asList(4, 1, 6),\n                Arrays.asList(7, 8, 2)\n        );\n        System.out.println(solution.minPath(grid2, 1)); // Expected: [1]\n    }\n}\n"}
{"task_id": "Java/130", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Generates the first n + 1 numbers of the Tribonacci sequence.\n     *\n     * @param n The number up to which the Tribonacci sequence is generated.\n     * @return A list containing the first n + 1 numbers of the Tribonacci sequence.\n     */\n    public List<Integer> tri(int n) {\n        if (n < 0) return new ArrayList<>();\n        \n        int[] memo = new int[n + 2];\n        Arrays.fill(memo, -1);\n        memo[1] = 3; // Base case\n        \n        for (int i = 1; i <= n; i++) {\n            calculateTri(i, memo);\n        }\n        \n        List<Integer> result = new ArrayList<>();\n        for (int i = 0; i <= n; i++) {\n            if (i == 0) {\n                result.add(1); // Special case as per the problem statement\n            } else {\n                result.add(memo[i]);\n            }\n        }\n        \n        return result;\n    }\n\n    private int calculateTri(int n, int[] memo) {\n        if (n <= 0) return 0; // Base case for recursion\n        \n        if (memo[n] != -1) return memo[n];\n        \n        if (n % 2 == 0) {\n            memo[n] = 1 + n / 2;\n        } else {\n            memo[n] = calculateTri(n - 1, memo) + calculateTri(n - 2, memo) + calculateTri(n + 1, memo);\n        }\n        \n        return memo[n];\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.tri(3)); // Expected: [1, 3, 2, 8]\n        System.out.println(solution.tri(4)); // Expected: [1, 3, 2, 8, 3]\n    }\n}\n"}
{"task_id": "Java/131", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n     */\n    public int digits(int n) {\n        int product = 1;\n        boolean hasOddDigit = false;\n\n        while (n > 0) {\n            int digit = n % 10; // Extract the last digit\n            if (digit % 2 != 0) { // Check if it's odd\n                product *= digit;\n                hasOddDigit = true;\n            }\n            n /= 10; // Remove the last digit from n\n        }\n\n        return hasOddDigit ? product : 0;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.digits(1));   // Expected output: 1\n        System.out.println(solution.digits(4));   // Expected output: 0\n        System.out.println(solution.digits(235)); // Expected output: 15\n        System.out.println(solution.digits(2468)); // Expected output: 0\n        System.out.println(solution.digits(13579)); // Expected output: 945 (1*3*5*7*9)\n    }\n}\n"}
{"task_id": "Java/132", "generation": "class Solution {\n    public boolean is_nested(String string) {\n        int balance = 0;\n        boolean foundNested = false;\n\n        for (char c : string.toCharArray()) {\n            if (c == '[') {\n                balance++;\n                // If we find an opening bracket and there's already one open, it means nesting\n                if (balance > 1) {\n                    foundNested = true;\n                }\n            } else if (c == ']') {\n                balance--;\n                // Balance should never go below zero for a valid sequence\n                if (balance < 0) return false;\n            }\n        }\n\n        // The string is only considered nested if there was at least one nested pair and it's balanced\n        return foundNested && balance == 0;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.is_nested(\"[[]]\")); // true\n        System.out.println(solution.is_nested(\"[]]]]]]][[[[[]\")); // false\n        System.out.println(solution.is_nested(\"[][]\")); // false\n        System.out.println(solution.is_nested(\"[]\")); // false\n        System.out.println(solution.is_nested(\"[[][]]\")); // true\n        System.out.println(solution.is_nested(\"[[]][[\")); // true\n    }\n}\n"}
{"task_id": "Java/133", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int sum_squares(List<Double> lst) {\n        int result = 0;\n        for (Double num : lst) {\n            // Round up the number and square it, then add to the result\n            int roundedUpNum = (int)Math.ceil(num);\n            result += roundedUpNum * roundedUpNum;\n        }\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.sum_squares(Arrays.asList(1.0, 2.0, 3.0))); // Expected output: 14\n        System.out.println(solution.sum_squares(Arrays.asList(1.0, 4.0, 9.0))); // Expected output: 98\n        System.out.println(solution.sum_squares(Arrays.asList(1.0, 3.0, 5.0, 7.0))); // Expected output: 84\n        System.out.println(solution.sum_squares(Arrays.asList(1.4, 4.2, 0.0))); // Expected output: 29\n        System.out.println(solution.sum_squares(Arrays.asList(-2.4, 1.0, 1.0))); // Expected output: 6\n    }\n}\n"}
{"task_id": "Java/134", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public boolean check_if_last_char_is_a_letter(String txt) {\n        if (txt == null || txt.length() == 0) return false;\n\n        // Trim trailing spaces\n        String trimmed = txt.trim();\n        \n        // Check if the last character is a letter and not part of a word\n        char lastChar = trimmed.charAt(trimmed.length() - 1);\n        boolean isLastCharAlphabetical = Character.isLetter(lastChar);\n\n        // If the string has only one character, it must be checked directly.\n        if (trimmed.length() == 1) {\n            return isLastCharAlphabetical;\n        }\n\n        // Check that the last character is not part of a word\n        boolean isNotPartOfWord = trimmed.charAt(trimmed.length() - 2) == ' ';\n\n        return isLastCharAlphabetical && isNotPartOfWord;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.check_if_last_char_is_a_letter(\"apple pie\"));       // Expected: false\n        System.out.println(solution.check_if_last_char_is_a_letter(\"apple pi e\"));      // Expected: true\n        System.out.println(solution.check_if_last_char_is_a_letter(\"apple pi e \"));     // Expected: false\n        System.out.println(solution.check_if_last_char_is_a_letter(\"\"));                // Expected: false\n        System.out.println(solution.check_if_last_char_is_a_letter(\"a\"));               // Expected: true\n    }\n}\n"}
{"task_id": "Java/135", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Create a function which returns the largest index of an element which\n     * is not greater than or equal to the element immediately preceding it.\n     * If no such element exists then return -1. The given array will not contain\n     * duplicate values.\n     *\n     * @param arr List of integers representing the sequence.\n     * @return Largest index where the condition fails, or -1 if all elements are in ascending order.\n     */\n    public int can_arrange(List<Integer> arr) {\n        for (int i = arr.size() - 1; i > 0; --i) {\n            if (arr.get(i) < arr.get(i - 1)) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.can_arrange(Arrays.asList(1,2,4,3,5))); // Expected output: 3\n        System.out.println(solution.can_arrange(Arrays.asList(1,2,3)));     // Expected output: -1\n    }\n}\n"}
{"task_id": "Java/136", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Create a function that returns a tuple (a, b), where 'a' is\n     * the largest of negative integers, and 'b' is the smallest\n     * of positive integers in a list.\n     * If there is no negative or positive integers, return them as None.\n     */\n    public List<Optional<Integer>> largest_smallest_integers(List<Integer> lst) {\n        Optional<Integer> largestNegative = Optional.empty();\n        Optional<Integer> smallestPositive = Optional.empty();\n\n        for (Integer num : lst) {\n            if (num < 0 && (!largestNegative.isPresent() || num > largestNegative.get())) {\n                largestNegative = Optional.of(num);\n            } else if (num > 0 && (!smallestPositive.isPresent() || num < smallestPositive.get())) {\n                smallestPositive = Optional.of(num);\n            }\n        }\n\n        return Arrays.asList(largestNegative, smallestPositive);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.largest_smallest_integers(Arrays.asList(2, 4, 1, 3, 5, 7))); // Expected: [Optional.empty(), Optional[1]]\n        System.out.println(solution.largest_smallest_integers(Arrays.asList())); // Expected: [Optional.empty(), Optional.empty()]\n        System.out.println(solution.largest_smallest_integers(Arrays.asList(0))); // Expected: [Optional.empty(), Optional.empty()]\n        System.out.println(solution.largest_smallest_integers(Arrays.asList(-1, -2, -3, 4, 5, 6))); // Expected: [Optional[-1], Optional[4]]\n    }\n}\n"}
{"task_id": "Java/137", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public Optional<Object> compare_one(Object a, Object b) {\n        double aValue = toDouble(a);\n        double bValue = toDouble(b);\n\n        if (aValue == bValue) return Optional.empty();\n\n        // Determine which original object should be returned based on the larger value\n        if (aValue > bValue) return Optional.of(a);\n        else return Optional.of(b);\n    }\n\n    private double toDouble(Object obj) {\n        if (obj instanceof Integer) {\n            return ((Integer) obj).doubleValue();\n        } else if (obj instanceof Double) {\n            return (double) obj;\n        } else if (obj instanceof String) {\n            String str = (String) obj;\n            // Replace ',' with '.' to handle European decimal format\n            str = str.replace(',', '.');\n            try {\n                return Double.parseDouble(str);\n            } catch (NumberFormatException e) {\n                throw new IllegalArgumentException(\"Invalid number format: \" + str, e);\n            }\n        } else {\n            throw new IllegalArgumentException(\"Unsupported type: \" + obj.getClass().getName());\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.compare_one(1, 2.5)); // Optional.of(2.5)\n        System.out.println(solution.compare_one(1, \"2,3\")); // Optional.of(\"2,3\")\n        System.out.println(solution.compare_one(\"5,1\", \"6\")); // Optional.of(\"6\")\n        System.out.println(solution.compare_one(\"1\", 1)); // Optional.empty()\n    }\n}\n"}
{"task_id": "Java/138", "generation": "class Solution {\n    public boolean is_equalToSumEven(int n) {\n        // Check if n is less than the minimum possible sum or not even.\n        return n >= 8 && n % 2 == 0;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.is_equalToSumEven(4)); // Expected: false\n        System.out.println(solution.is_equalToSumEven(6)); // Expected: false\n        System.out.println(solution.is_equalToSumEven(8)); // Expected: true\n        System.out.println(solution.is_equalToSumEven(10)); // Expected: true\n        System.out.println(solution.is_equalToSumEven(24)); // Expected: true\n    }\n}\n"}
{"task_id": "Java/139", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * The Brazilian factorial is defined as:\n     * brazilian_factorial(n) = n! * (n-1)! * ... * 1!\n     * where n > 0\n     *\n     * @param n the input integer for which to calculate the special factorial.\n     * @return the calculated special factorial of the given integer.\n     */\n    public long special_factorial(int n) {\n        long result = 1;\n        for (int i = 1; i <= n; i++) {\n            result *= factorial(i);\n        }\n        return result;\n    }\n\n    private long factorial(int number) {\n        if (number == 0 || number == 1) {\n            return 1;\n        }\n        long fact = 1;\n        for (int i = 2; i <= number; i++) {\n            fact *= i;\n        }\n        return fact;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.special_factorial(4)); // Expected output: 288\n        System.out.println(solution.special_factorial(3)); // Expected output: 12\n        System.out.println(solution.special_factorial(5)); // Expected output: 34560\n    }\n}\n"}
{"task_id": "Java/140", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a string text, replace all spaces in it with underscores,\n     * and if a string has more than 2 consecutive spaces,\n     * then replace all consecutive spaces with -\n     *\n     * @param text the input string to process.\n     * @return the processed string according to the rules.\n     */\n    public String fix_spaces(String text) {\n        // Use StringBuilder for efficient string manipulation\n        StringBuilder result = new StringBuilder();\n        int spaceCount = 0;\n\n        for (char c : text.toCharArray()) {\n            if (c == ' ') {\n                spaceCount++;\n            } else {\n                if (spaceCount > 2) {\n                    result.append('-');\n                } else {\n                    while (spaceCount > 0) {\n                        result.append('_');\n                        spaceCount--;\n                    }\n                }\n                result.append(c);\n                spaceCount = 0;\n            }\n        }\n\n        // Handle trailing spaces\n        if (spaceCount > 2) {\n            result.append('-');\n        } else {\n            while (spaceCount > 0) {\n                result.append('_');\n                spaceCount--;\n            }\n        }\n\n        return result.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.fix_spaces(\"Example\").equals(\"Example\")); // true\n        System.out.println(solution.fix_spaces(\"Example 1\").equals(\"Example_1\")); // true\n        System.out.println(solution.fix_spaces(\" Example 2\").equals(\"_Example_2\")); // true\n        System.out.println(solution.fix_spaces(\" Example   3\").equals(\"_Example-3\")); // true\n    }\n}\n"}
{"task_id": "Java/141", "generation": "import java.util.*;\n\nclass Solution {\n\n    public String file_name_check(String file_name) {\n        // Check if there are more than three digits in the file name.\n        int digitCount = 0;\n        for (char c : file_name.toCharArray()) {\n            if (Character.isDigit(c)) {\n                digitCount++;\n            }\n        }\n        if (digitCount > 3) return \"No\";\n\n        // Split the file name by dot and check conditions\n        String[] parts = file_name.split(\"\\\\.\");\n        if (parts.length != 2) return \"No\"; // There should be exactly one dot.\n\n        String prefix = parts[0];\n        String suffix = parts[1];\n\n        // Check if the prefix is not empty, starts with a letter and contains no more than three digits.\n        if (prefix.isEmpty() || !Character.isLetter(prefix.charAt(0))) return \"No\";\n\n        // Valid extensions\n        List<String> validExtensions = Arrays.asList(\"txt\", \"exe\", \"dll\");\n        if (!validExtensions.contains(suffix)) return \"No\";\n\n        return \"Yes\";\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.file_name_check(\"example.txt\")); // Expected: Yes\n        System.out.println(solution.file_name_check(\"1example.dll\")); // Expected: No\n        System.out.println(solution.file_name_check(\"test.abc\")); // Expected: No (invalid extension)\n        System.out.println(solution.file_name_check(\".txt\")); // Expected: No (empty prefix)\n        System.out.println(solution.file_name_check(\"a2b3c4.txt\")); // Expected: Yes\n        System.out.println(solution.file_name_check(\"a1234.txt\")); // Expected: No (too many digits)\n    }\n}\n"}
{"task_id": "Java/142", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * This function takes a list of integers and modifies each entry based on its index:\n     * - Squares the integer if its index is a multiple of 3.\n     * - Cubes the integer if its index is a multiple of 4 but not a multiple of 3.\n     * It then returns the sum of all entries in the list after these modifications.\n     */\n    public int sum_squares(List<Integer> lst) {\n        int sum = 0;\n        \n        for (int i = 0; i < lst.size(); i++) {\n            if (i % 3 == 0 && i != 0) { // Check if index is a multiple of 3 and not zero\n                sum += Math.pow(lst.get(i), 2);\n            } else if (i % 4 == 0 && i % 3 != 0) { // Check if index is a multiple of 4 but not a multiple of 3\n                sum += Math.pow(lst.get(i), 3);\n            } else {\n                sum += lst.get(i); // Add the integer as it is, if none of the conditions are met.\n            }\n        }\n\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        List<Integer> test1 = Arrays.asList(1, 2, 3);\n        System.out.println(\"Test 1: \" + (solution.sum_squares(test1) == 6 ? \"Pass\" : \"Fail\"));\n\n        List<Integer> test2 = new ArrayList<>();\n        System.out.println(\"Test 2: \" + (solution.sum_squares(test2) == 0 ? \"Pass\" : \"Fail\"));\n        \n        List<Integer> test3 = Arrays.asList(-1, -5, 2, -1, -5);\n        System.out.println(\"Test 3: \" + (solution.sum_squares(test3) == -126 ? \"Pass\" : \"Fail\"));\n\n        // Additional tests\n        List<Integer> test4 = Arrays.asList(0, 1, 2, 3, 4, 5, 6);\n        System.out.println(\"Test 4: \" + (solution.sum_squares(test4) == 7 ? \"Pass\" : \"Fail\"));\n        \n        List<Integer> test5 = Arrays.asList(-2, -3, -4, -5, -6, -7, -8);\n        System.out.println(\"Test 5: \" + (solution.sum_squares(test5) == -109 ? \"Pass\" : \"Fail\"));\n    }\n}\n"}
{"task_id": "Java/143", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public String words_in_sentence(String sentence) {\n        // Split the sentence into individual words.\n        String[] words = sentence.split(\" \");\n        \n        StringBuilder result = new StringBuilder();\n        \n        // Iterate over each word and check if its length is a prime number.\n        for (String word : words) {\n            if (isPrime(word.length())) {\n                // Append the word to the result, followed by a space.\n                result.append(word).append(\" \");\n            }\n        }\n\n        // Remove the trailing space if there is any.\n        return result.toString().trim();\n    }\n\n    private boolean isPrime(int n) {\n        if (n <= 1) {\n            return false;\n        }\n        for (int i = 2; i * i <= n; i++) {\n            if (n % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.words_in_sentence(\"This is a test\")); // Output: \"is\"\n        System.out.println(solution.words_in_sentence(\"lets go for swimming\")); // Output: \"go for\"\n    }\n}\n"}
{"task_id": "Java/144", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Simplifies the expression x * n to determine if it evaluates to a whole number.\n     *\n     * @param x A string representing a fraction in the format <numerator>/<denominator>\n     * @param n Another string representing a fraction in the same format\n     * @return true if x * n is a whole number, false otherwise\n     */\n    public boolean simplify(String x, String n) {\n        // Parse fractions into numerators and denominators\n        long[] fractionX = parseFraction(x);\n        long[] fractionN = parseFraction(n);\n\n        // Multiply the numerators and denominators separately\n        long numeratorProduct = fractionX[0] * fractionN[0];\n        long denominatorProduct = fractionX[1] * fractionN[1];\n\n        // Check if the result is a whole number by seeing if there's no remainder when divided\n        return numeratorProduct % denominatorProduct == 0;\n    }\n\n    /**\n     * Parses a string representing a fraction into its numerical components.\n     *\n     * @param fraction The string representation of a fraction in the format <numerator>/<denominator>\n     * @return An array where [0] is the numerator and [1] is the denominator\n     */\n    private long[] parseFraction(String fraction) {\n        String[] parts = fraction.split(\"/\");\n        return new long[]{Long.parseLong(parts[0]), Long.parseLong(parts[1])};\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.simplify(\"1/5\", \"5/1\"));  // Expected: true\n        System.out.println(solution.simplify(\"1/6\", \"2/1\"));  // Expected: false\n        System.out.println(solution.simplify(\"7/10\", \"10/2\"));// Expected: false\n    }\n}\n"}
{"task_id": "Java/145", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Sorts the given list of integers in ascending order according to the sum of their digits.\n     * Note: if there are several items with similar sum of their digits,\n     * order them based on their index in original list.\n     * If an integer is negative, then its first digit will be negative:\n     * e.g. -123 has digits -1, 2, and 3.\n     *\n     * @param nums the list of integers to sort\n     * @return a new sorted list based on the sum of their digits\n     */\n    public List<Integer> order_by_points(List<Integer> nums) {\n        // Create an indexed list to preserve original indices for sorting\n        List<Pair<Integer, Integer>> indexedNums = new ArrayList<>();\n        for (int i = 0; i < nums.size(); i++) {\n            indexedNums.add(new Pair<>(i, nums.get(i)));\n        }\n\n        // Sort the indexed list based on sum of digits and then by original index\n        Collections.sort(indexedNums, Comparator.comparingInt((Pair<Integer, Integer> p) -> digitSum(p.getValue()))\n                .thenComparingInt(Pair::getKey));\n\n        // Extract sorted numbers from pairs\n        List<Integer> result = new ArrayList<>();\n        for (Pair<Integer, Integer> pair : indexedNums) {\n            result.add(pair.getValue());\n        }\n\n        return result;\n    }\n\n    private int digitSum(int num) {\n        int sum = 0;\n        boolean isNegative = num < 0;\n        while (num != 0) {\n            int digit = num % 10;\n            if (isNegative && sum == 0) {\n                // First digit of a negative number should be considered as negative\n                digit *= -1;\n            }\n            sum += Math.abs(digit);\n            num /= 10;\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        List<Integer> test1 = Arrays.asList(1, 11, -1, -11, -12);\n        System.out.println(solution.order_by_points(test1)); // Expected: [-1, -11, 1, -12, 11]\n\n        List<Integer> test2 = new ArrayList<>();\n        System.out.println(solution.order_by_points(test2)); // Expected: []\n\n        List<Integer> test3 = Arrays.asList(9, -8, 7, -6);\n        System.out.println(solution.order_by_points(test3)); // Expected: [-8, -6, 7, 9]\n\n        List<Integer> test4 = Arrays.asList(-102, 102, -120, 120);\n        System.out.println(solution.order_by_points(test4)); // Expected: [102, -102, 120, -120]\n    }\n\n    static class Pair<K, V> {\n        private K key;\n        private V value;\n\n        public Pair(K key, V value) {\n            this.key = key;\n            this.value = value;\n        }\n\n        public K getKey() {\n            return key;\n        }\n\n        public V getValue() {\n            return value;\n        }\n    }\n}\n"}
{"task_id": "Java/146", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Returns the number of elements in the array that are greater than 10 \n     * and both first and last digits of a number are odd (1, 3, 5, 7, 9).\n     */\n    public int specialFilter(List<Integer> nums) {\n        return (int) nums.stream()\n                .filter(num -> num > 10 && isFirstAndLastDigitOdd(num))\n                .count();\n    }\n\n    private boolean isFirstAndLastDigitOdd(int num) {\n        String strNum = Integer.toString(Math.abs(num));\n        int firstDigit = Character.getNumericValue(strNum.charAt(0));\n        int lastDigit = Character.getNumericValue(strNum.charAt(strNum.length() - 1));\n        return (firstDigit % 2 != 0 && lastDigit % 2 != 0);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.specialFilter(Arrays.asList(15, -73, 14, -15))); // Expected output: 1\n        System.out.println(solution.specialFilter(Arrays.asList(33, -2, -3, 45, 21, 109))); // Expected output: 2\n    }\n}\n"}
{"task_id": "Java/147", "generation": "class Solution {\n    public int get_max_triples(int n) {\n        // Create an array to store the values as per the given formula.\n        int[] a = new int[n];\n        for (int i = 1; i <= n; ++i) {\n            a[i - 1] = i * i - i + 1;\n        }\n\n        int count = 0;\n\n        // Iterate through all possible triples (i, j, k).\n        for (int i = 0; i < n - 2; ++i) {\n            for (int j = i + 1; j < n - 1; ++j) {\n                for (int k = j + 1; k < n; ++k) {\n                    // Check if the sum of a[i], a[j], and a[k] is divisible by 3.\n                    if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                        count++;\n                    }\n                }\n            }\n        }\n\n        return count;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        \n        // Test cases\n        System.out.println(sol.get_max_triples(5)); // Expected output: 1\n        System.out.println(sol.get_max_triples(6)); // Additional test case, expected output depends on the formula.\n    }\n}\n"}
{"task_id": "Java/148", "generation": "import java.util.*;\n\nclass Solution {\n    public List<String> bf(String planet1, String planet2) {\n        // Define the order of planets from closest to farthest from the Sun.\n        List<String> planets = Arrays.asList(\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\");\n        \n        // Get indices of both input planets\n        int index1 = planets.indexOf(planet1);\n        int index2 = planets.indexOf(planet2);\n\n        // Check if either planet name is invalid or both are the same.\n        if (index1 == -1 || index2 == -1 || index1 == index2) {\n            return new ArrayList<>();\n        }\n\n        // Ensure index1 < index2 for simplicity\n        int start = Math.min(index1, index2);\n        int end = Math.max(index1, index2);\n\n        // Return the sublist of planets between the two given indices.\n        return planets.subList(start + 1, end);\n    }\n    \n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.bf(\"Jupiter\", \"Neptune\")); // [\"Saturn\", \"Uranus\"]\n        System.out.println(solution.bf(\"Earth\", \"Mercury\"));   // [\"Venus\"]\n        System.out.println(solution.bf(\"Mercury\", \"Uranus\"));  // [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"]\n    }\n}\n"}
{"task_id": "Java/149", "generation": "import java.util.*;\n\nclass Solution {\n    public List<String> sorted_list_sum(List<String> lst) {\n        // Filter out strings with odd lengths and sort the list by length then alphabetically.\n        return lst.stream()\n                .filter(s -> s.length() % 2 == 0)\n                .sorted(Comparator.comparingInt(String::length).thenComparing(Comparator.naturalOrder()))\n                .collect(Collectors.toList());\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        List<String> test1 = Arrays.asList(\"aa\", \"a\", \"aaa\");\n        System.out.println(solution.sorted_list_sum(test1));  // Expected: [aa]\n\n        List<String> test2 = Arrays.asList(\"ab\", \"a\", \"aaa\", \"cd\");\n        System.out.println(solution.sorted_list_sum(test2));  // Expected: [ab, cd]\n        \n        List<String> test3 = Arrays.asList(\"abc\", \"defg\", \"hij\", \"klmno\", \"pqrstu\");\n        System.out.println(solution.sorted_list_sum(test3));  // Expected: [defg, pqrstu]\n\n        List<String> test4 = Arrays.asList(\"a\", \"bb\", \"ccc\", \"dddd\", \"eeeee\");\n        System.out.println(solution.sorted_list_sum(test4));  // Expected: [bb, dddd]\n    }\n}\n"}
{"task_id": "Java/150", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * A simple program which should return the value of x if n is\n     * a prime number and should return the value of y otherwise.\n     *\n     * Examples:\n     * for x_or_y(7, 34, 12) == 34\n     * for x_or_y(15, 8, 5) == 5\n     */\n    public int x_or_y(int n, int x, int y) {\n        if (isPrime(n)) {\n            return x;\n        } else {\n            return y;\n        }\n    }\n\n    private boolean isPrime(int number) {\n        if (number <= 1) {\n            return false;\n        }\n        for (int i = 2; i * i <= number; i++) {\n            if (number % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.x_or_y(7, 34, 12)); // Expected output: 34\n        System.out.println(solution.x_or_y(15, 8, 5));  // Expected output: 5\n        System.out.println(solution.x_or_y(11, 99, 10)); // Expected output: 99\n        System.out.println(solution.x_or_y(4, 23, 7));   // Expected output: 7\n    }\n}\n"}
{"task_id": "Java/151", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given a list of numbers, return the sum of squares of the numbers\n     * in the list that are odd. Ignore numbers that are negative or not integers.\n     *\n     * @param lst List containing objects (expected to be numbers)\n     * @return Sum of squares of odd positive integers from the list\n     */\n    public int sumOfSquaresOfOdds(List<Object> lst) {\n        return lst.stream()\n                .filter(o -> o instanceof Integer && (Integer) o > 0 && ((Integer) o) % 2 != 0)\n                .mapToInt(o -> (int) o)\n                .map(n -> n * n)\n                .sum();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.sumOfSquaresOfOdds(Arrays.asList(1, 3, 2, 0))); // Expected output: 10 (1^2 + 3^2)\n        System.out.println(solution.sumOfSquaresOfOdds(Arrays.asList(-1, -2, 0)));   // Expected output: 0\n        System.out.println(solution.sumOfSquaresOfOdds(Arrays.asList(9, -2)));       // Expected output: 81 (9^2)\n        System.out.println(solution.sumOfSquaresOfOdds(Arrays.asList(0)));           // Expected output: 0\n        System.out.println(solution.sumOfSquaresOfOdds(new ArrayList<>()));          // Expected output: 0\n    }\n}\n"}
{"task_id": "Java/152", "generation": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\nclass Solution {\n    /**\n     * Compares the actual scores of matches with guesses.\n     *\n     * @param game a list of integers representing the actual scores of each match.\n     * @param guess a list of integers representing the guessed scores for each match.\n     * @return a list where each element is either 0 if the guess was correct or\n     *         the absolute difference between the guess and the score.\n     */\n    public List<Integer> compare(List<Integer> game, List<Integer> guess) {\n        List<Integer> result = new ArrayList<>();\n        \n        for (int i = 0; i < game.size(); i++) {\n            int diff = Math.abs(game.get(i) - guess.get(i));\n            result.add(diff);\n        }\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case 1\n        List<Integer> gameScores1 = Arrays.asList(1,2,3,4,5,1);\n        List<Integer> guesses1 = Arrays.asList(1,2,3,4,2,-2);\n        System.out.println(solution.compare(gameScores1, guesses1)); // Expected: [0, 0, 0, 0, 3, 3]\n        \n        // Test case 2\n        List<Integer> gameScores2 = Arrays.asList(0,5,0,0,0,4);\n        List<Integer> guesses2 = Arrays.asList(4,1,1,0,0,-2);\n        System.out.println(solution.compare(gameScores2, guesses2)); // Expected: [4, 4, 1, 0, 0, 6]\n    }\n}\n"}
{"task_id": "Java/153", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Finds the strongest extension for a given class.\n     *\n     * @param className The name of the class.\n     * @param extensions A list of strings representing the extensions.\n     * @return A string in the format ClassName.Strongest_Extension.\n     */\n    public String Strongest_Extension(String className, List<String> extensions) {\n        int maxStrength = Integer.MIN_VALUE;\n        String strongestExtensionName = \"\";\n\n        for (String extension : extensions) {\n            int strength = calculateStrength(extension);\n            if (strength > maxStrength || (strength == maxStrength && strongestExtensionName.isEmpty())) {\n                maxStrength = strength;\n                strongestExtensionName = extension;\n            }\n        }\n\n        return className + \".\" + strongestExtensionName;\n    }\n\n    private int calculateStrength(String extension) {\n        int uppercaseCount = 0, lowercaseCount = 0;\n\n        for (char c : extension.toCharArray()) {\n            if (Character.isUpperCase(c)) {\n                uppercaseCount++;\n            } else if (Character.isLowerCase(c)) {\n                lowercaseCount++;\n            }\n        }\n\n        return uppercaseCount - lowercaseCount;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.Strongest_Extension(\"Slices\", Arrays.asList(\"SErviNGSliCes\", \"Cheese\", \"StuFfed\")));  // Expected: Slices.SErviNGSliCes\n        System.out.println(solution.Strongest_Extension(\"my_class\", Arrays.asList(\"AA\", \"Be\", \"CC\")));  // Expected: my_class.AA\n    }\n}\n"}
{"task_id": "Java/154", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public boolean cycpattern_check(String a, String b) {\n        // Concatenate string 'a' with itself to handle rotations.\n        String doubledA = a + a;\n        \n        // Check if 'b' is a substring of the concatenated version of 'a'.\n        return doubledA.contains(b);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.cycpattern_check(\"abcd\", \"abd\"));  // Expected: false\n        System.out.println(solution.cycpattern_check(\"hello\", \"ell\")); // Expected: true\n        System.out.println(solution.cycpattern_check(\"whassup\", \"psus\"));// Expected: false\n        System.out.println(solution.cycpattern_check(\"abab\", \"baa\"));  // Expected: true\n        System.out.println(solution.cycpattern_check(\"efef\", \"eeff\")); // Expected: false\n        System.out.println(solution.cycpattern_check(\"himenss\", \"simen\"));// Expected: true\n    }\n}\n"}
{"task_id": "Java/155", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given an integer, return a list that has the number of even and odd digits respectively.\n     *\n     * Example:\n     *      even_odd_count(-12) ==> [1, 1]\n     *      even_odd_count(123) ==> [1, 2]\n     */\n    public List<Integer> even_odd_count(int num) {\n        int evenCount = 0;\n        int oddCount = 0;\n\n        // Convert the number to its absolute value\n        num = Math.abs(num);\n\n        while (num > 0) {\n            int digit = num % 10; // Get the last digit\n            if (digit % 2 == 0) {\n                evenCount++;\n            } else {\n                oddCount++;\n            }\n            num /= 10; // Remove the last digit\n        }\n\n        List<Integer> result = new ArrayList<>();\n        result.add(evenCount);\n        result.add(oddCount);\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.even_odd_count(-12)); // Expected: [1, 1]\n        System.out.println(solution.even_odd_count(123)); // Expected: [1, 2]\n        System.out.println(solution.even_odd_count(0));   // Expected: [1, 0] (since 0 is even)\n        System.out.println(solution.even_odd_count(-987654321)); // Expected: [4, 5]\n    }\n}\n"}
{"task_id": "Java/156", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given a positive integer, obtain its roman numeral equivalent as a string,\n     * and return it in lowercase.\n     * Restrictions: 1 <= num <= 1000\n     *\n     * @param number the input integer to convert\n     * @return the Roman numeral representation of the given number in lowercase\n     */\n    public String int_to_mini_roman(int number) {\n        // Define arrays for storing Roman numerals and their corresponding values\n        String[] thousands = {\"\", \"m\", \"mm\", \"mmm\"};\n        String[] hundreds = {\"\", \"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"};\n        String[] tens = {\"\", \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\"};\n        String[] ones = {\"\", \"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\", \"ix\"};\n\n        // Convert the number to its Roman numeral representation\n        return thousands[number / 1000] +\n               hundreds[(number % 1000) / 100] +\n               tens[(number % 100) / 10] +\n               ones[number % 10];\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.int_to_mini_roman(19).equals(\"xix\"));   // true\n        System.out.println(solution.int_to_mini_roman(152).equals(\"clii\")); // true\n        System.out.println(solution.int_to_mini_roman(426).equals(\"cdxxvi\"));// true\n\n        // Additional test cases to ensure correctness\n        System.out.println(solution.int_to_mini_roman(3999).equals(\"mmmcmxcix\")); // false, out of range\n        System.out.println(solution.int_to_mini_roman(1000).equals(\"m\"));         // true\n        System.out.println(solution.int_to_mini_roman(58).equals(\"lviii\"));       // true\n    }\n}\n"}
{"task_id": "Java/157", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given the lengths of the three sides of a triangle. Return true if the three\n     * sides form a right-angled triangle, false otherwise.\n     * A right-angled triangle is a triangle in which one angle is right angle or\n     * 90 degree.\n     */\n    public boolean right_angle_triangle(int a, int b, int c) {\n        // First sort the sides to ensure that 'c' is the longest side (hypotenuse)\n        int[] sides = {a, b, c};\n        Arrays.sort(sides);\n        \n        // Check if the square of the hypotenuse equals the sum of squares of other two sides\n        return Math.pow(sides[2], 2) == (Math.pow(sides[0], 2) + Math.pow(sides[1], 2));\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases to verify the correctness of the function\n        System.out.println(solution.right_angle_triangle(3, 4, 5)); // Expected: true\n        System.out.println(solution.right_angle_triangle(1, 2, 3)); // Expected: false\n        System.out.println(solution.right_angle_triangle(5, 12, 13)); // Expected: true\n        System.out.println(solution.right_angle_triangle(8, 15, 17)); // Expected: true\n        System.out.println(solution.right_angle_triangle(6, 8, 10)); // Expected: true\n    }\n}\n"}
{"task_id": "Java/158", "generation": "import java.util.*;\n\nclass Solution {\n\n    /**\n     * Write a function that accepts a list of strings.\n     * The list contains different words. Return the word with maximum number\n     * of unique characters. If multiple strings have maximum number of unique\n     * characters, return the one which comes first in lexicographical order.\n     *\n     * @param words List of strings to process\n     * @return String with maximum number of unique characters or empty string if list is empty\n     */\n    public String find_max(List<String> words) {\n        if (words.isEmpty()) {\n            return \"\";\n        }\n\n        // Sort the list lexicographically first so that we can easily pick the one which comes first in case of a tie.\n        Collections.sort(words);\n\n        String result = \"\";\n        int maxUniqueChars = 0;\n\n        for (String word : words) {\n            Set<Character> uniqueChars = new HashSet<>();\n            for (char c : word.toCharArray()) {\n                uniqueChars.add(c);\n            }\n\n            if (uniqueChars.size() > maxUniqueChars) {\n                maxUniqueChars = uniqueChars.size();\n                result = word;\n            }\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        List<String> test1 = Arrays.asList(\"name\", \"of\", \"string\");\n        System.out.println(solution.find_max(test1));  // Expected: \"string\"\n\n        List<String> test2 = Arrays.asList(\"name\", \"enam\", \"game\");\n        System.out.println(solution.find_max(test2));  // Expected: \"enam\"\n\n        List<String> test3 = Arrays.asList(\"aaaaaaa\", \"bb\", \"cc\");\n        System.out.println(solution.find_max(test3));  // Expected: \"aaaaaaa\"\n    }\n}\n"}
{"task_id": "Java/159", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * You're a hungry rabbit, and you already have eaten a certain number of carrots,\n     * but now you need to eat more carrots to complete the day's meals.\n     * You should return an array of [ total number of eaten carrots after your meals,\n     *                                 the number of carrots left after your meals ]\n     * if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n     *\n     * @param number  the number of carrots that you have eaten.\n     * @param need    the number of carrots that you need to eat.\n     * @param remaining the number of remaining carrots in stock\n     * @return a List containing [total number of eaten carrots, number of carrots left]\n     */\n    public List<Integer> eat(int number, int need, int remaining) {\n        // Calculate how many more carrots can be eaten based on what's available\n        int toEat = Math.min(need, remaining);\n        \n        // Update the total number of carrots eaten and the remaining carrots\n        int totalEaten = number + toEat;\n        int leftOver = remaining - toEat;\n\n        return Arrays.asList(totalEaten, leftOver);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.eat(5, 6, 10)); // Expected: [11, 4]\n        System.out.println(solution.eat(4, 8, 9));  // Expected: [12, 1]\n        System.out.println(solution.eat(1, 10, 10));// Expected: [11, 0]\n        System.out.println(solution.eat(2, 11, 5)); // Expected: [7, 0]\n    }\n}\n"}
{"task_id": "Java/160", "generation": "import java.util.*;\n\nclass Solution {\n    public int do_algebra(List<String> operator, List<Integer> operand) {\n        // Support for basic operations\n        Map<String, BiFunction<Integer, Integer, Integer>> operations = new HashMap<>();\n        operations.put(\"+\", (a, b) -> a + b);\n        operations.put(\"-\", (a, b) -> a - b);\n        operations.put(\"*\", (a, b) -> a * b);\n        operations.put(\"/\", (a, b) -> a / b); // Floor division\n        operations.put(\"**\", (a, b) -> (int)Math.pow(a, b));\n\n        int result = operand.get(0);\n\n        for (int i = 0; i < operator.size(); i++) {\n            String op = operator.get(i);\n            Integer nextOperand = operand.get(i + 1);\n            \n            // Apply the operation\n            BiFunction<Integer, Integer, Integer> func = operations.get(op);\n            result = func.apply(result, nextOperand);\n        }\n\n        return result;\n    }\n    \n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        List<String> operators1 = Arrays.asList(\"+\", \"*\", \"-\");\n        List<Integer> operands1 = Arrays.asList(2, 3, 4, 5);\n        System.out.println(solution.do_algebra(operators1, operands1)); // Expected output: 9\n        \n        List<String> operators2 = Arrays.asList(\"**\", \"-\", \"/\");\n        List<Integer> operands2 = Arrays.asList(2, 3, 4, 2);\n        System.out.println(solution.do_algebra(operators2, operands2)); // Expected output: 5\n    }\n}\n"}
{"task_id": "Java/161", "generation": "class Solution {\n    public String solve(String s) {\n        // Check if there are any letters in the string\n        boolean hasLetters = false;\n        for (char c : s.toCharArray()) {\n            if (Character.isLetter(c)) {\n                hasLetters = true;\n                break;\n            }\n        }\n\n        // If no letters, reverse the entire string\n        if (!hasLetters) {\n            return new StringBuilder(s).reverse().toString();\n        }\n\n        // Otherwise, process each character in the string\n        StringBuilder result = new StringBuilder();\n        for (char c : s.toCharArray()) {\n            if (Character.isLetter(c)) {\n                if (Character.isLowerCase(c)) {\n                    result.append(Character.toUpperCase(c));\n                } else {\n                    result.append(Character.toLowerCase(c));\n                }\n            } else {\n                result.append(c);\n            }\n        }\n\n        return result.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.solve(\"1234\"));  // Expected: \"4321\"\n        System.out.println(solution.solve(\"ab\"));     // Expected: \"AB\"\n        System.out.println(solution.solve(\"#a@C\"));   // Expected: \"#A@c\"\n    }\n}\n"}
{"task_id": "Java/162", "generation": "import java.math.BigInteger;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.Optional;\n\nclass Solution {\n    public Optional<String> string_to_md5(String text) throws NoSuchAlgorithmException {\n        if (text.isEmpty()) {\n            return Optional.empty();\n        }\n        \n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        byte[] messageDigest = md.digest(text.getBytes());\n        BigInteger no = new BigInteger(1, messageDigest);\n        String hashtext = no.toString(16);\n\n        // Add leading zeros to make it 32 characters long\n        while (hashtext.length() < 32) {\n            hashtext = \"0\" + hashtext;\n        }\n        \n        return Optional.of(hashtext);\n    }\n}\n"}
{"task_id": "Java/163", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given two positive integers a and b, returns the even digits between a\n     * and b, in ascending order. The even digits refer to even numbers less than 10.\n     *\n     * @param a the first integer\n     * @param b the second integer\n     * @return a list of even digits between a and b\n     */\n    public List<Integer> generate_integers(int a, int b) {\n        // Ensure that a is always smaller or equal to b for simplicity.\n        if (a > b) {\n            int temp = a;\n            a = b;\n            b = temp;\n        }\n\n        List<Integer> result = new ArrayList<>();\n        \n        // Loop through the range and add even digits\n        for (int i = Math.max(a, 0); i <= Math.min(b, 8); i++) {\n            if (i % 2 == 0) {\n                result.add(i);\n            }\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.generate_integers(2, 8)); // Expected: [2, 4, 6, 8]\n        System.out.println(solution.generate_integers(8, 2)); // Expected: [2, 4, 6, 8]\n        System.out.println(solution.generate_integers(10, 14)); // Expected: []\n    }\n}\n"}
{"task_id": "Java/0", "generation": "import java.util.*;\n\nclass Solution {\n\n    /**\n     * Check if in given list of numbers, are any two numbers closer to each other than given threshold.\n     *\n     * @param numbers List of Double values to be checked.\n     * @param threshold The threshold value to compare the difference between any two elements.\n     * @return true if there exists at least one pair of numbers that are closer to each other than the threshold, false otherwise.\n     */\n    public boolean has_close_elements(List<Double> numbers, double threshold) {\n        // Sort the list first\n        Collections.sort(numbers);\n        \n        for (int i = 0; i < numbers.size() - 1; i++) {\n            if (numbers.get(i + 1) - numbers.get(i) <= threshold) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        List<Double> testList1 = Arrays.asList(1.0, 2.0, 3.0);\n        double threshold1 = 0.5;\n        System.out.println(solution.has_close_elements(testList1, threshold1)); // Expected: false\n\n        // Test case 2\n        List<Double> testList2 = Arrays.asList(1.0, 2.8, 3.0, 4.0, 5.0, 2.0);\n        double threshold2 = 0.3;\n        System.out.println(solution.has_close_elements(testList2, threshold2)); // Expected: true\n    }\n}\n"}
{"task_id": "Java/1", "generation": "import java.util.ArrayList;\nimport java.util.List;\n\nclass Solution {\n    public List<String> separate_paren_groups(String paren_string) {\n        // Remove spaces from input string for simplicity\n        String cleanString = paren_string.replaceAll(\"\\\\s+\", \"\");\n        \n        List<String> result = new ArrayList<>();\n        int balance = 0;  // Counter to keep track of open parentheses\n        \n        StringBuilder currentGroup = new StringBuilder();\n        \n        for (char c : cleanString.toCharArray()) {\n            if (c == '(') {\n                balance++;\n            } else if (c == ')') {\n                balance--;\n            }\n            \n            currentGroup.append(c);\n            \n            // When the balance is 0, we have a complete group\n            if (balance == 0 && !currentGroup.toString().isEmpty()) {\n                result.add(currentGroup.toString());\n                currentGroup = new StringBuilder();  // Reset for next group\n            }\n        }\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        List<String> test1Result = solution.separate_paren_groups(\"( ) (( )) (( )( ))\");\n        System.out.println(test1Result);  // Expected: [\"()\", \"(())\", \"(()())\"]\n        \n        List<String> test2Result = solution.separate_paren_groups(\"((())) (()) ()\");\n        System.out.println(test2Result);  // Expected: [\"((()))\", \"(())\", \"()\"]\n    }\n}\n"}
{"task_id": "Java/2", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a positive floating point number, it can be decomposed into\n     * an integer part (largest integer smaller than given number) and decimals\n     * (leftover part always smaller than 1).\n     *\n     * Return the decimal part of the number.\n     */\n    public double truncate_number(double number) {\n        return number - Math.floor(number);\n    }\n\n    // Test method to verify the correctness of the truncate_number function\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.truncate_number(3.5));  // Expected output: 0.5\n        System.out.println(solution.truncate_number(4.75)); // Expected output: 0.75\n        System.out.println(solution.truncate_number(123.99)); // Expected output: 0.99\n        System.out.println(solution.truncate_number(0.123)); // Expected output: 0.123\n        System.out.println(solution.truncate_number(8.0));   // Expected output: 0.0 (since there are no decimals)\n    }\n}\n"}
{"task_id": "Java/3", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * You're given a list of deposit and withdrawal operations on a bank account that starts with\n     * zero balance. Your task is to detect if at any point the balance of account falls below zero, \n     * and at that point function should return True. Otherwise it should return False.\n     *\n     * @param operations List of Integer representing deposits (positive values) and withdrawals (negative values)\n     * @return boolean indicating whether the balance fell below zero\n     */\n    public boolean below_zero(List<Integer> operations) {\n        int balance = 0; // Start with a zero balance\n\n        for (int operation : operations) {\n            balance += operation;\n            if (balance < 0) {\n                return true; // Balance falls below zero, return true immediately\n            }\n        }\n\n        return false; // No point where the balance fell below zero\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases to verify the correctness of the function\n        System.out.println(solution.below_zero(Arrays.asList(1, 2, 3))); // Expected: false\n        System.out.println(solution.below_zero(Arrays.asList(1, 2, -4, 5))); // Expected: true\n    }\n}\n"}
{"task_id": "Java/4", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Calculates Mean Absolute Deviation (MAD) around the mean for a given list of numbers.\n     *\n     * @param numbers List of Double values representing the dataset.\n     * @return The MAD as a double value.\n     */\n    public double mean_absolute_deviation(List<Double> numbers) {\n        if (numbers == null || numbers.isEmpty()) {\n            throw new IllegalArgumentException(\"List must not be null or empty\");\n        }\n\n        // Calculate the mean\n        double sum = 0.0;\n        for (Double number : numbers) {\n            sum += number;\n        }\n        double mean = sum / numbers.size();\n\n        // Calculate the Mean Absolute Deviation\n        double madSum = 0.0;\n        for (Double number : numbers) {\n            madSum += Math.abs(number - mean);\n        }\n        return madSum / numbers.size();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.mean_absolute_deviation(Arrays.asList(1.0, 2.0, 3.0, 4.0))); // Expected output: 1.0\n        System.out.println(solution.mean_absolute_deviation(Arrays.asList(-1.0, 0.0, 1.0)));      // Expected output: 1.0\n        System.out.println(solution.mean_absolute_deviation(Arrays.asList(5.0, 7.0, 9.0)));       // Expected output: 2.0\n    }\n}\n"}
{"task_id": "Java/5", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Insert a number 'delimiter' between every two consecutive elements of input list `numbers`\n     *\n     * @param numbers The list of integers.\n     * @param delimiter The integer to insert between each pair of consecutive elements in the list.\n     * @return A new List with delimiters interspersed.\n     */\n    public List<Integer> intersperse(List<Integer> numbers, int delimiter) {\n        if (numbers.isEmpty()) return Collections.emptyList();\n\n        List<Integer> result = new ArrayList<>();\n        for (int i = 0; i < numbers.size(); i++) {\n            result.add(numbers.get(i));\n            // Do not add the delimiter after the last element\n            if (i != numbers.size() - 1) {\n                result.add(delimiter);\n            }\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1: Empty list\n        System.out.println(solution.intersperse(new ArrayList<>(), 4)); // Expected output: []\n\n        // Test case 2: List with elements\n        System.out.println(solution.intersperse(Arrays.asList(1, 2, 3), 4)); // Expected output: [1, 4, 2, 4, 3]\n\n        // Additional test cases\n        System.out.println(solution.intersperse(Arrays.asList(5), 0)); // Expected output: [5]\n        System.out.println(solution.intersperse(Arrays.asList(-1, -2, -3), 99)); // Expected output: [-1, 99, -2, 99, -3]\n    }\n}\n"}
{"task_id": "Java/6", "generation": "import java.util.ArrayList;\nimport java.util.List;\n\nclass Solution {\n    public List<Integer> parse_nested_parens(String paren_string) {\n        List<Integer> result = new ArrayList<>();\n        String[] groups = paren_string.split(\" \");\n        \n        for (String group : groups) {\n            int maxDepth = 0, currentDepth = 0;\n            for (char c : group.toCharArray()) {\n                if (c == '(') {\n                    currentDepth++;\n                    maxDepth = Math.max(maxDepth, currentDepth);\n                } else if (c == ')') {\n                    currentDepth--;\n                }\n            }\n            result.add(maxDepth);\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case 1\n        List<Integer> testResult1 = solution.parse_nested_parens(\"(()()) ((())) () ((())()())\");\n        System.out.println(testResult1); // Expected: [2, 3, 1, 3]\n        \n        // Test case 2\n        List<Integer> testResult2 = solution.parse_nested_parens(\"(()) (()) (((())))\");\n        System.out.println(testResult2); // Expected: [2, 2, 3]\n\n        // Test case 3 - Edge cases with empty strings and single parentheses\n        List<Integer> testResult3 = solution.parse_nested_parens(\"() ((())) ()\");\n        System.out.println(testResult3); // Expected: [1, 3, 1]\n    }\n}\n"}
{"task_id": "Java/7", "generation": "import org.junit.jupiter.api.Test;\nimport java.util.Arrays;\nimport java.util.List;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nclass SolutionTest {\n    @Test\n    void testFilterBySubstring() {\n        Solution solution = new Solution();\n\n        // Test with an empty list\n        List<String> result1 = solution.filter_by_substring(List.of(), \"a\");\n        assertEquals(List.of(), result1);\n\n        // Test with a non-empty list and a substring that exists in some elements\n        List<String> input2 = Arrays.asList(\"abc\", \"bacd\", \"cde\", \"array\");\n        List<String> expected2 = Arrays.asList(\"abc\", \"bacd\", \"array\");\n        List<String> result2 = solution.filter_by_substring(input2, \"a\");\n        assertEquals(expected2, result2);\n\n        // Test with a substring that does not exist in any elements\n        List<String> input3 = Arrays.asList(\"hello\", \"world\", \"java\");\n        List<String> expected3 = List.of();\n        List<String> result3 = solution.filter_by_substring(input3, \"x\");\n        assertEquals(expected3, result3);\n    }\n}\n"}
{"task_id": "Java/8", "generation": "import java.util.*;\nimport org.junit.*;\n\nclass Solution {\n    /**\n     * For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n     * Empty sum should be equal to 0 and empty product should be equal to 1.\n     */\n    public List<Integer> sum_product(List<Integer> numbers) {\n        int sum = 0;\n        int product = 1;\n\n        for (Integer number : numbers) {\n            sum += number;\n            product *= number;\n        }\n\n        return Arrays.asList(sum, product);\n    }\n\n    @Test\n    public void testEmptyList() {\n        List<Integer> result = sum_product(new ArrayList<>());\n        Assert.assertEquals(Arrays.asList(0, 1), result);\n    }\n\n    @Test\n    public void testWithNumbers() {\n        List<Integer> numbers = Arrays.asList(1, 2, 3, 4);\n        List<Integer> result = sum_product(numbers);\n        Assert.assertEquals(Arrays.asList(10, 24), result);\n    }\n}\n"}
{"task_id": "Java/9", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * From a given list of integers, generate a list of rolling maximum element found until the given moment in the sequence.\n     *\n     * @param numbers List of integers to process.\n     * @return A new list containing the rolling max values.\n     */\n    public List<Integer> rolling_max(List<Integer> numbers) {\n        List<Integer> result = new ArrayList<>();\n        if (numbers == null || numbers.isEmpty()) return result;\n\n        int currentMax = Integer.MIN_VALUE;\n        for (int number : numbers) {\n            currentMax = Math.max(currentMax, number);\n            result.add(currentMax);\n        }\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case\n        List<Integer> input = Arrays.asList(1, 2, 3, 2, 3, 4, 2);\n        List<Integer> expectedOutput = Arrays.asList(1, 2, 3, 3, 3, 4, 4);\n\n        List<Integer> output = solution.rolling_max(input);\n\n        System.out.println(\"Input: \" + input);\n        System.out.println(\"Expected Output: \" + expectedOutput);\n        System.out.println(\"Actual Output: \" + output);\n\n        // Simple check to see if the test passed\n        boolean isCorrect = output.equals(expectedOutput);\n        System.out.println(\"Test Passed? \" + (isCorrect ? \"Yes\" : \"No\"));\n    }\n}\n"}
{"task_id": "Java/10", "generation": "import org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nclass SolutionTest {\n    private final Solution solution = new Solution();\n\n    @Test\n    void testEmptyString() {\n        assertEquals(\"\", solution.make_palindrome(\"\"));\n    }\n\n    @Test\n    void testSingleCharacter() {\n        assertEquals(\"a\", solution.make_palindrome(\"a\"));\n    }\n\n    @Test\n    void testSimplePalindrome() {\n        assertEquals(\"catac\", solution.make_palindrome(\"cat\"));\n    }\n\n    @Test\n    void testComplexCase() {\n        assertEquals(\"racecarabcdeedcba\", solution.make_palindrome(\"racecarabcde\"));\n    }\n\n    @Test\n    void testAlreadyAPalindrome() {\n        assertEquals(\"level\", solution.make_palindrome(\"level\"));\n    }\n}\n"}
{"task_id": "Java/11", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Perform binary XOR on two input strings consisting only of 1s and 0s.\n     *\n     * @param a The first string containing '0's and '1's.\n     * @param b The second string containing '0's and '1's.\n     * @return A string representing the result of performing binary XOR on inputs a and b.\n     */\n    public String string_xor(String a, String b) {\n        StringBuilder xorResult = new StringBuilder();\n        \n        // Ensure both strings are of equal length by padding with zeros if necessary\n        int maxLength = Math.max(a.length(), b.length());\n        while (a.length() < maxLength) a = \"0\" + a;\n        while (b.length() < maxLength) b = \"0\" + b;\n\n        for (int i = 0; i < maxLength; i++) {\n            // Perform XOR on each character and append to the result\n            char xorChar = ((a.charAt(i) == '1') ^ (b.charAt(i) == '1')) ? '1' : '0';\n            xorResult.append(xorChar);\n        }\n\n        return xorResult.toString();\n    }\n    \n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.string_xor(\"010\", \"110\"));  // Expected output: \"100\"\n        System.out.println(solution.string_xor(\"111\", \"000\"));  // Expected output: \"111\"\n        System.out.println(solution.string_xor(\"101010\", \"111111\"));  // Expected output: \"010101\"\n    }\n}\n"}
{"task_id": "Java/12", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Out of list of strings, return the longest one. Return the first one in case of multiple\n     * strings of the same length. Return Optional.empty() in case the input list is empty.\n     */\n    public Optional<String> longest(List<String> strings) {\n        if (strings.isEmpty()) {\n            return Optional.empty();\n        }\n\n        String longestString = \"\";\n        for (String str : strings) {\n            if (str.length() > longestString.length()) {\n                longestString = str;\n            }\n        }\n        return Optional.of(longestString);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.longest(List.of())); // Expected: Optional.empty\n        \n        List<String> list1 = Arrays.asList(\"a\", \"b\", \"c\");\n        System.out.println(solution.longest(list1)); // Expected: Optional[a]\n        \n        List<String> list2 = Arrays.asList(\"a\", \"bb\", \"ccc\");\n        System.out.println(solution.longest(list2)); // Expected: Optional[ccc]\n    }\n}\n\n// JUnit test class\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\nclass SolutionTest {\n    \n    @Test\n    void testLongest() {\n        Solution solution = new Solution();\n        \n        assertTrue(solution.longest(List.of()).isEmpty());\n        \n        List<String> list1 = Arrays.asList(\"a\", \"b\", \"c\");\n        assertEquals(Optional.of(\"a\"), solution.longest(list1));\n        \n        List<String> list2 = Arrays.asList(\"a\", \"bb\", \"ccc\");\n        assertEquals(Optional.of(\"ccc\"), solution.longest(list2));\n    }\n}\n"}
{"task_id": "Java/13", "generation": "import org.junit.Test;\nimport static org.junit.Assert.*;\n\nclass Solution {\n    \n    /**\n     * Return a greatest common divisor of two integers a and b.\n     */\n    public int greatest_common_divisor(int a, int b) {\n        while (b != 0) {\n            int temp = b;\n            b = a % b;\n            a = temp;\n        }\n        return a;\n    }\n\n    @Test\n    public void testGCD() {\n        assertEquals(1, greatest_common_divisor(3, 5));\n        assertEquals(5, greatest_common_divisor(25, 15));\n        assertEquals(6, greatest_common_divisor(18, 24)); // Additional test case\n        assertEquals(7, greatest_common_divisor(49, 14)); // Another additional test case\n    }\n}\n"}
{"task_id": "Java/14", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Return list of all prefixes from shortest to longest of the input string.\n     *\n     * @param string The input string for which we generate prefixes.\n     * @return A List containing all possible prefixes of the given string.\n     */\n    public List<String> all_prefixes(String string) {\n        List<String> prefixes = new ArrayList<>();\n        for (int i = 1; i <= string.length(); i++) {\n            prefixes.add(string.substring(0, i));\n        }\n        return prefixes;\n    }\n\n    // A simple test method to check the correctness of the all_prefixes function.\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        List<String> result1 = solution.all_prefixes(\"abc\");\n        System.out.println(result1);  // Expected: [a, ab, abc]\n        \n        List<String> result2 = solution.all_prefixes(\"\");\n        System.out.println(result2);  // Expected: []\n        \n        List<String> result3 = solution.all_prefixes(\"hello\");\n        System.out.println(result3);  // Expected: [h, he, hel, hell, hello]\n    }\n}\n"}
{"task_id": "Java/15", "generation": "import java.util.*;\nimport org.junit.*;\n\nclass Solution {\n    /**\n     * Return a string containing space-delimited numbers starting from 0 up to n inclusive.\n     *\n     * @param n The upper limit of the sequence (inclusive).\n     * @return A String with the sequence of numbers separated by spaces.\n     */\n    public String string_sequence(int n) {\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i <= n; i++) {\n            sb.append(i);\n            if (i < n) {\n                sb.append(\" \");\n            }\n        }\n        return sb.toString();\n    }\n\n    // Test class to verify the correctness of the string_sequence method.\n    public static class SolutionTest {\n        @Test\n        public void testStringSequence() {\n            Solution solution = new Solution();\n\n            Assert.assertEquals(\"0\", solution.string_sequence(0));\n            Assert.assertEquals(\"0 1\", solution.string_sequence(1));\n            Assert.assertEquals(\"0 1 2 3 4 5\", solution.string_sequence(5));\n\n            // Additional tests\n            Assert.assertEquals(\"\", solution.string_sequence(-1)); // Edge case: negative number\n        }\n    }\n\n    public static void main(String[] args) {\n        org.junit.runner.JUnitCore.main(\"Solution.SolutionTest\");\n    }\n}\n"}
{"task_id": "Java/16", "generation": "import java.util.HashSet;\nimport java.util.Set;\n\nclass Solution {\n    /**\n     * Given a string, find out how many distinct characters (regardless of case) does it consist of.\n     *\n     * @param string the input string to analyze\n     * @return the count of distinct characters in the string, ignoring case differences\n     */\n    public int count_distinct_characters(String string) {\n        if (string == null || string.isEmpty()) return 0;\n        \n        // Convert the string to lower case to ignore case sensitivity.\n        String lowerCaseString = string.toLowerCase();\n        \n        // Use a set to store unique characters.\n        Set<Character> distinctChars = new HashSet<>();\n        \n        for (char c : lowerCaseString.toCharArray()) {\n            distinctChars.add(c);\n        }\n        \n        return distinctChars.size();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        System.out.println(solution.count_distinct_characters(\"xyzXYZ\")); // Expected output: 3\n        \n        // Test case 2\n        System.out.println(solution.count_distinct_characters(\"Jerry\")); // Expected output: 4\n\n        // Additional test cases\n        System.out.println(solution.count_distinct_characters(\"AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz\")); // Expected output: 26\n        System.out.println(solution.count_distinct_characters(\"Hello, World!\")); // Expected output: 10 (ignoring punctuation and space)\n    }\n}\n"}
{"task_id": "Java/17", "generation": "import java.util.ArrayList;\nimport java.util.List;\n\nclass Solution {\n    /**\n     * Parses a string representing musical notes in a special ASCII format.\n     *\n     * @param string The input string containing musical notes.\n     * @return A list of integers corresponding to how many beats each note lasts.\n     */\n    public List<Integer> parse_music(String string) {\n        List<Integer> result = new ArrayList<>();\n        String[] notes = string.split(\" \");\n        \n        for (String note : notes) {\n            if (\"o\".equals(note)) {\n                result.add(4);\n            } else if (\"o|\".equals(note)) {\n                result.add(2);\n            } else if (\".|\".equals(note)) {\n                result.add(1);\n            }\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case\n        List<Integer> expected = Arrays.asList(4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4);\n        List<Integer> result = solution.parse_music(\"o o| .| o| o| .| .| .| .| o o\");\n        \n        System.out.println(\"Expected: \" + expected);\n        System.out.println(\"Result:   \" + result);\n\n        // Check if the test passed\n        boolean isCorrect = expected.equals(result);\n        System.out.println(\"Test Passed? \" + isCorrect);\n    }\n}\n"}
{"task_id": "Java/18", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Find how many times a given substring can be found in the original string.\n     * Count overlaping cases.\n     *\n     * @param string The original string to search within.\n     * @param substring The substring to find occurrences of.\n     * @return The number of times the substring is found, including overlaps.\n     */\n    public int how_many_times(String string, String substring) {\n        if (substring.isEmpty() || string.length() < substring.length()) return 0;\n        \n        int count = 0;\n        for (int i = 0; i <= string.length() - substring.length(); i++) {\n            if (string.substring(i, i + substring.length()).equals(substring)) {\n                count++;\n            }\n        }\n        return count;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.how_many_times(\"\", \"a\")); // Expected output: 0\n        System.out.println(solution.how_many_times(\"aaa\", \"a\")); // Expected output: 3\n        System.out.println(solution.how_many_times(\"aaaa\", \"aa\")); // Expected output: 3\n        System.out.println(solution.how_many_times(\"abcabcabc\", \"abc\")); // Expected output: 3\n        System.out.println(solution.how_many_times(\"ababa\", \"aba\")); // Expected output: 2\n    }\n}\n"}
{"task_id": "Java/19", "generation": "import java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nclass Solution {\n    /**\n     * Input is a space-delimited string of numberals from 'zero' to 'nine'.\n     * Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n     * Return the string with numbers sorted from smallest to largest\n     */\n    public String sort_numbers(String numbers) {\n        Map<String, Integer> numeralMap = new HashMap<>();\n        numeralMap.put(\"zero\", 0);\n        numeralMap.put(\"one\", 1);\n        numeralMap.put(\"two\", 2);\n        numeralMap.put(\"three\", 3);\n        numeralMap.put(\"four\", 4);\n        numeralMap.put(\"five\", 5);\n        numeralMap.put(\"six\", 6);\n        numeralMap.put(\"seven\", 7);\n        numeralMap.put(\"eight\", 8);\n        numeralMap.put(\"nine\", 9);\n\n        String[] numerals = numbers.split(\"\\\\s+\");\n        Arrays.sort(numerals, Comparator.comparingInt(numeralMap::get));\n        \n        return String.join(\" \", numerals);\n    }\n\n    @Test\n    public void testSortNumbers() {\n        assertEquals(\"one three five\", sort_numbers(\"three one five\"));\n        assertEquals(\"zero four six nine\", sort_numbers(\"nine zero six four\"));\n        assertEquals(\"two two eight seven\", sort_numbers(\"seven two eight two\"));\n    }\n}\n"}
{"task_id": "Java/20", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n     * other and return them in order (smaller number, larger number).\n     */\n    public List<Double> find_closest_elements(List<Double> numbers) {\n        // Sort the list to make finding the closest elements easier.\n        Collections.sort(numbers);\n\n        double minDiff = Double.MAX_VALUE;\n        List<Double> result = new ArrayList<>();\n        \n        for (int i = 0; i < numbers.size() - 1; i++) {\n            double diff = Math.abs(numbers.get(i) - numbers.get(i + 1));\n            if (diff < minDiff) {\n                minDiff = diff;\n                result.clear();\n                result.add(numbers.get(i));\n                result.add(numbers.get(i + 1));\n            }\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        List<Double> test1 = Arrays.asList(1.0, 2.0, 3.0, 4.0, 5.0, 2.2);\n        System.out.println(solution.find_closest_elements(test1)); // Expected: [2.0, 2.2]\n\n        List<Double> test2 = Arrays.asList(1.0, 2.0, 3.0, 4.0, 5.0, 2.0);\n        System.out.println(solution.find_closest_elements(test2)); // Expected: [2.0, 2.0]\n        \n        List<Double> test3 = Arrays.asList(1.5, 3.5, 2.5, 4.5, 5.5);\n        System.out.println(solution.find_closest_elements(test3)); // Expected: [1.5, 2.5] or [2.5, 3.5], depending on the sort order\n        \n        List<Double> test4 = Arrays.asList(0.9, 1.8, 2.7);\n        System.out.println(solution.find_closest_elements(test4)); // Expected: [0.9, 1.8]\n    }\n}\n"}
{"task_id": "Java/21", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given list of numbers (of at least two elements), apply a linear transform to that list,\n     * such that the smallest number will become 0 and the largest will become 1.\n     *\n     * @param numbers List of doubles to be rescaled.\n     * @return A new list with each element rescaled between 0 and 1.\n     */\n    public List<Double> rescale_to_unit(List<Double> numbers) {\n        if (numbers == null || numbers.size() < 2) {\n            throw new IllegalArgumentException(\"List must contain at least two elements.\");\n        }\n\n        double min = Collections.min(numbers);\n        double max = Collections.max(numbers);\n\n        // Avoid division by zero\n        if (min == max) {\n            throw new ArithmeticException(\"Cannot rescale list with all identical values.\");\n        }\n\n        List<Double> scaledNumbers = new ArrayList<>();\n        for (double number : numbers) {\n            double scaledValue = (number - min) / (max - min);\n            scaledNumbers.add(scaledValue);\n        }\n        \n        return scaledNumbers;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case 1\n        List<Double> testList1 = Arrays.asList(1.0, 2.0, 3.0, 4.0, 5.0);\n        System.out.println(solution.rescale_to_unit(testList1)); // Expected: [0.0, 0.25, 0.5, 0.75, 1.0]\n        \n        // Test case 2\n        List<Double> testList2 = Arrays.asList(10.0, 20.0);\n        System.out.println(solution.rescale_to_unit(testList2)); // Expected: [0.0, 1.0]\n        \n        // Test case 3 (edge case)\n        try {\n            List<Double> testList3 = Arrays.asList(5.0);\n            solution.rescale_to_unit(testList3); // Should throw an exception\n        } catch (IllegalArgumentException e) {\n            System.out.println(e.getMessage()); // Expected: \"List must contain at least two elements.\"\n        }\n        \n        // Test case 4 (edge case)\n        try {\n            List<Double> testList4 = Arrays.asList(5.0, 5.0);\n            solution.rescale_to_unit(testList4); // Should throw an exception\n        } catch (ArithmeticException e) {\n            System.out.println(e.getMessage()); // Expected: \"Cannot rescale list with all identical values.\"\n        }\n    }\n}\n"}
{"task_id": "Java/22", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Filter given list of any values only for integers.\n     *\n     * @param values List containing objects of various types.\n     * @return A new list containing only the Integer elements from the input list.\n     */\n    public List<Integer> filter_integers(List<Object> values) {\n        List<Integer> result = new ArrayList<>();\n        for (Object value : values) {\n            if (value instanceof Integer) {\n                result.add((Integer) value);\n            }\n        }\n        return result;\n    }\n\n    // Test cases to verify the correctness of the method.\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        List<Object> test1 = Arrays.asList('a', 3.14, 5);\n        System.out.println(solution.filter_integers(test1)); // Expected: [5]\n\n        List<Object> test2 = Arrays.asList(1, 2, 3, \"abc\", Map.of(), List.of());\n        System.out.println(solution.filter_integers(test2)); // Expected: [1, 2, 3]\n        \n        List<Object> test3 = Arrays.asList(\"hello\", 42, new ArrayList<>(), 789);\n        System.out.println(solution.filter_integers(test3)); // Expected: [42, 789]\n\n        List<Object> test4 = Arrays.asList(0, -1, null, \"world\");\n        System.out.println(solution.filter_integers(test4)); // Expected: [0, -1]\n    }\n}\n"}
{"task_id": "Java/23", "generation": "class Solution {\n    /**\n     * Return length of given string\n     */\n    public int strlen(String string) {\n        return string.length();\n    }\n}\n"}
{"task_id": "Java/24", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * For a given number n, find the largest number that divides n evenly, smaller than n.\n     *\n     * @param n The input integer to find the divisor for.\n     * @return The largest divisor of n that is smaller than n itself.\n     */\n    public int largest_divisor(int n) {\n        // Iterate from n-1 down to 1\n        for (int i = n - 1; i > 0; i--) {\n            if (n % i == 0) {\n                return i;\n            }\n        }\n        // If no divisor is found, which shouldn't happen as every number is divisible by 1.\n        return 1;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.largest_divisor(15)); // Expected output: 5\n        System.out.println(solution.largest_divisor(28)); // Expected output: 14\n        System.out.println(solution.largest_divisor(37)); // Expected output: 1 (since 37 is prime)\n    }\n}\n"}
{"task_id": "Java/25", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Return list of prime factors of given integer in the order from smallest to largest.\n     * Each of the factors should be listed number of times corresponding to how many times it appears in factorization.\n     * Input number should be equal to the product of all factors\n     */\n    public List<Integer> factorize(int n) {\n        List<Integer> factors = new ArrayList<>();\n        \n        // Divide by 2 until odd\n        while (n % 2 == 0) {\n            factors.add(2);\n            n /= 2;\n        }\n        \n        // Check for odd factors from 3 onwards\n        for (int i = 3; i <= Math.sqrt(n); i += 2) {\n            while (n % i == 0) {\n                factors.add(i);\n                n /= i;\n            }\n        }\n        \n        // If n is a prime number greater than 2\n        if (n > 2) {\n            factors.add(n);\n        }\n\n        return factors;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.factorize(8));  // Expected: [2, 2, 2]\n        System.out.println(solution.factorize(25)); // Expected: [5, 5]\n        System.out.println(solution.factorize(70)); // Expected: [2, 5, 7]\n    }\n}\n"}
{"task_id": "Java/26", "generation": "import java.util.*;\nimport java.util.stream.Collectors;\n\nclass Solution {\n    /**\n     * From a list of integers, remove all elements that occur more than once.\n     * Keep the order of elements left the same as in the input.\n     *\n     * @param numbers List of integers to process.\n     * @return A new list with duplicates removed and original order preserved.\n     */\n    public List<Integer> remove_duplicates(List<Integer> numbers) {\n        // Count occurrences of each number\n        Map<Integer, Long> counts = numbers.stream()\n                .collect(Collectors.groupingBy(e -> e, Collectors.counting()));\n\n        // Filter out elements that occur more than once and preserve order\n        return numbers.stream()\n                .filter(n -> counts.get(n) == 1)\n                .collect(Collectors.toList());\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        List<Integer> testList = Arrays.asList(1, 2, 3, 2, 4);\n        System.out.println(solution.remove_duplicates(testList)); // Expected: [1, 3, 4]\n        \n        List<Integer> emptyList = Collections.emptyList();\n        System.out.println(solution.remove_duplicates(emptyList)); // Expected: []\n        \n        List<Integer> allDuplicates = Arrays.asList(5, 5, 5);\n        System.out.println(solution.remove_duplicates(allDuplicates)); // Expected: []\n    }\n}\n"}
{"task_id": "Java/27", "generation": "class Solution {\n    /**\n     * For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n     *\n     * @param string The input string whose case needs to be flipped.\n     * @return A new string with the case of each character flipped.\n     */\n    public String flip_case(String string) {\n        StringBuilder result = new StringBuilder();\n        \n        for (char c : string.toCharArray()) {\n            if (Character.isUpperCase(c)) {\n                result.append(Character.toLowerCase(c));\n            } else if (Character.isLowerCase(c)) {\n                result.append(Character.toUpperCase(c));\n            } else {\n                // If it's not a letter, just append the character as is.\n                result.append(c);\n            }\n        }\n\n        return result.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.flip_case(\"Hello\")); // Expected: \"hELLO\"\n        System.out.println(solution.flip_case(\"Java123\")); // Expected: \"jAVA123\"\n        System.out.println(solution.flip_case(\"12345\")); // Expected: \"12345\" (no change)\n        System.out.println(solution.flip_case(\"TeStInG\")); // Expected: \"tEsTiNg\"\n    }\n}\n"}
{"task_id": "Java/28", "generation": "import java.util.Arrays;\nimport java.util.List;\n\nclass Solution {\n    /**\n     * Concatenate list of strings into a single string.\n     *\n     * @param strings List of strings to concatenate.\n     * @return A single concatenated string.\n     */\n    public String concatenate(List<String> strings) {\n        if (strings == null || strings.isEmpty()) {\n            return \"\";\n        }\n        \n        StringBuilder sb = new StringBuilder();\n        for (String str : strings) {\n            sb.append(str);\n        }\n        return sb.toString();\n    }\n\n    // Unit tests\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test with an empty list\n        String result1 = solution.concatenate(Arrays.asList());\n        System.out.println(result1.equals(\"\") ? \"Test 1 Passed\" : \"Test 1 Failed\");\n\n        // Test with a non-empty list\n        String result2 = solution.concatenate(Arrays.asList(\"a\", \"b\", \"c\"));\n        System.out.println(result2.equals(\"abc\") ? \"Test 2 Passed\" : \"Test 2 Failed\");\n    }\n}\n"}
{"task_id": "Java/29", "generation": "import java.util.*;\nimport java.util.stream.Collectors;\n\nclass Solution {\n    public List<String> filter_by_prefix(List<String> strings, String prefix) {\n        return strings.stream()\n                .filter(s -> s.startsWith(prefix))\n                .collect(Collectors.toList());\n    }\n}\n"}
{"task_id": "Java/30", "generation": "import java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nclass Solution {\n    /**\n     * Return only positive numbers in the list.\n     *\n     * @param l List of integers\n     * @return A new list containing only the positive numbers from the input list\n     */\n    public List<Integer> get_positive(List<Integer> l) {\n        return l.stream()\n                .filter(x -> x > 0)\n                .collect(Collectors.toList());\n    }\n}\n\nclass SolutionTest {\n\n    private final Solution solution = new Solution();\n\n    @Test\n    void testGetPositive() {\n        // Test with a list containing both positive and negative numbers\n        List<Integer> input1 = Arrays.asList(-1, 2, -4, 5, 6);\n        List<Integer> expected1 = Arrays.asList(2, 5, 6);\n        assertEquals(expected1, solution.get_positive(input1));\n\n        // Test with a list containing positive and negative numbers including zero\n        List<Integer> input2 = Arrays.asList(5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10);\n        List<Integer> expected2 = Arrays.asList(5, 3, 2, 3, 9, 123, 1);\n        assertEquals(expected2, solution.get_positive(input2));\n\n        // Test with an empty list\n        List<Integer> input3 = new ArrayList<>();\n        List<Integer> expected3 = new ArrayList<>();\n        assertEquals(expected3, solution.get_positive(input3));\n    }\n}\n"}
{"task_id": "Java/31", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return true if a given number is prime, and false otherwise.\n     */\n    public boolean is_prime(int n) {\n        // 1 is not a prime number\n        if (n <= 1) return false;\n        \n        // Check from 2 to the square root of n for factors\n        for (int i = 2; i * i <= n; i++) {\n            if (n % i == 0) return false;\n        }\n        \n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases to verify the correctness of is_prime method\n        System.out.println(solution.is_prime(6));     // Expected: false\n        System.out.println(solution.is_prime(101));   // Expected: true\n        System.out.println(solution.is_prime(11));    // Expected: true\n        System.out.println(solution.is_prime(13441)); // Expected: true\n        System.out.println(solution.is_prime(61));    // Expected: true\n        System.out.println(solution.is_prime(4));     // Expected: false\n        System.out.println(solution.is_prime(1));     // Expected: false\n    }\n}\n"}
{"task_id": "Java/32", "generation": "import java.util.Arrays;\nimport java.util.List;\n\nclass Solution {\n    /**\n     * Evaluates polynomial with coefficients xs at point x.\n     * return xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n\n     */\n    public double poly(List<Double> xs, double x) {\n        double result = 0;\n        for (int i = 0; i < xs.size(); i++) {\n            result += xs.get(i) * Math.pow(x, i);\n        }\n        return result;\n    }\n\n    /**\n     * Finds a zero of the polynomial with coefficients xs.\n     */\n    public double find_zero(List<Double> xs) {\n        // Placeholder for actual implementation\n        throw new UnsupportedOperationException(\"Not yet implemented\");\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases for poly method\n        List<Double> testPoly1 = Arrays.asList(1.0, 2.0);\n        double resultPoly1 = solution.poly(testPoly1, -0.5); // Expected: 0\n        System.out.println(\"Test Poly 1 (Expected 0): \" + resultPoly1);\n\n        List<Double> testPoly2 = Arrays.asList(-6.0, 11.0, -6.0, 1.0);\n        double resultPoly2 = solution.poly(testPoly2, 1); // Expected: 0\n        System.out.println(\"Test Poly 2 (Expected 0): \" + resultPoly2);\n\n        // Test cases for find_zero method\n        List<Double> testZero1 = Arrays.asList(1.0, 2.0);\n        double resultZero1 = solution.find_zero(testZero1); // Expected: -0.5\n        System.out.println(\"Test Zero 1 (Expected -0.5): \" + resultZero1);\n\n        List<Double> testZero2 = Arrays.asList(-6.0, 11.0, -6.0, 1.0);\n        double resultZero2 = solution.find_zero(testZero2); // Expected: 1.0\n        System.out.println(\"Test Zero 2 (Expected 1.0): \" + resultZero2);\n    }\n}\n"}
{"task_id": "Java/33", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * This function takes a list l and returns a list l' such that\n     * l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n     * to the values of the corresponding indicies of l, but sorted in ascending order.\n     *\n     * @param l The input list.\n     * @return A new list with elements at indices divisible by 3 sorted.\n     */\n    public List<Integer> sort_third(List<Integer> l) {\n        // Extract elements at indices divisible by three\n        ArrayList<Integer> toSort = new ArrayList<>();\n        for (int i = 0; i < l.size(); i++) {\n            if ((i + 1) % 3 == 0) { // Note: +1 because we want index 0, 3, 6... to be considered divisible by three\n                toSort.add(l.get(i));\n            }\n        }\n\n        // Sort these elements\n        Collections.sort(toSort);\n\n        // Create a new list with the sorted values at appropriate positions.\n        ArrayList<Integer> result = new ArrayList<>(l);\n        int sortIndex = 0;\n        for (int i = 0; i < l.size(); i++) {\n            if ((i + 1) % 3 == 0) { // Note: +1 because we want index 0, 3, 6... to be considered divisible by three\n                result.set(i, toSort.get(sortIndex++));\n            }\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.sort_third(Arrays.asList(1, 2, 3))); // Expected: [1, 2, 3]\n        System.out.println(solution.sort_third(Arrays.asList(5, 6, 3, 4, 8, 9, 2))); // Expected: [2, 6, 3, 4, 8, 9, 5]\n    }\n}\n"}
{"task_id": "Java/34", "generation": "import org.junit.jupiter.api.Test;\nimport java.util.Arrays;\nimport java.util.List;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nclass Solution {\n    /**\n     * Return sorted unique elements in a list.\n     *\n     * @param l the input list of integers\n     * @return a new list containing only unique elements from the input list, sorted in ascending order\n     */\n    public List<Integer> unique(List<Integer> l) {\n        return l.stream()\n                .distinct() // Remove duplicates\n                .sorted()   // Sort the stream\n                .toList();  // Collect results into a List\n    }\n\n    @Test\n    void testUnique() {\n        Solution solution = new Solution();\n        \n        List<Integer> inputList = Arrays.asList(5, 3, 5, 2, 3, 3, 9, 0, 123);\n        List<Integer> expectedOutput = Arrays.asList(0, 2, 3, 5, 9, 123);\n\n        assertEquals(expectedOutput, solution.unique(inputList));\n    }\n}\n"}
{"task_id": "Java/35", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Return maximum element in the list.\n     *\n     * @param l List of integers\n     * @return The maximum integer in the list\n     */\n    public int max_element(List<Integer> l) {\n        if (l == null || l.isEmpty()) {\n            throw new IllegalArgumentException(\"List must not be null or empty\");\n        }\n        \n        return Collections.max(l);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case 1\n        List<Integer> list1 = Arrays.asList(1, 2, 3);\n        System.out.println(\"Max element in [1, 2, 3]: \" + solution.max_element(list1)); // Expected: 3\n        \n        // Test case 2\n        List<Integer> list2 = Arrays.asList(5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10);\n        System.out.println(\"Max element in [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]: \" + solution.max_element(list2)); // Expected: 123\n        \n        // Test case 3 (Edge case with a single element)\n        List<Integer> list3 = Arrays.asList(42);\n        System.out.println(\"Max element in [42]: \" + solution.max_element(list3)); // Expected: 42\n        \n        // Test case 4 (Edge case with negative numbers)\n        List<Integer> list4 = Arrays.asList(-1, -5, -9, -7);\n        System.out.println(\"Max element in [-1, -5, -9, -7]: \" + solution.max_element(list4)); // Expected: -1\n    }\n}\n"}
{"task_id": "Java/36", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n     *\n     * @param n The upper limit (exclusive) for checking numbers.\n     * @return The count of digit '7' appearances in numbers less than `n` and divisible by 11 or 13.\n     */\n    public int fizz_buzz(int n) {\n        int count = 0;\n        for (int i = 1; i < n; i++) {\n            if ((i % 11 == 0 || i % 13 == 0)) {\n                String numStr = Integer.toString(i);\n                for (char c : numStr.toCharArray()) {\n                    if (c == '7') count++;\n                }\n            }\n        }\n        return count;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.fizz_buzz(50));  // Expected output: 0\n        System.out.println(solution.fizz_buzz(78));  // Expected output: 2\n        System.out.println(solution.fizz_buzz(79));  // Expected output: 3\n    }\n}\n"}
{"task_id": "Java/37", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * This function takes a list l and returns a list l' such that\n     * l' is identical to l in the odd indicies, while its values at the even indicies are equal\n     * to the values of the even indicies of l, but sorted.\n     */\n    public List<Integer> sort_even(List<Integer> l) {\n        // Extract elements at even indices and sort them\n        ArrayList<Integer> evenIndicesValues = new ArrayList<>();\n        for (int i = 0; i < l.size(); i += 2) {\n            evenIndicesValues.add(l.get(i));\n        }\n        Collections.sort(evenIndicesValues);\n\n        // Reconstruct the list with sorted values at even indices\n        List<Integer> result = new ArrayList<>(Collections.nCopies(l.size(), 0));\n        int evenIndex = 0;\n        for (int i = 0; i < l.size(); i++) {\n            if (i % 2 == 0) {\n                // Place sorted value at even index\n                result.set(i, evenIndicesValues.get(evenIndex++));\n            } else {\n                // Keep odd-indexed values as they are\n                result.set(i, l.get(i));\n            }\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        List<Integer> test1 = Arrays.asList(1, 2, 3);\n        System.out.println(solution.sort_even(test1)); // Expected: [1, 2, 3]\n\n        List<Integer> test2 = Arrays.asList(5, 6, 3, 4);\n        System.out.println(solution.sort_even(test2)); // Expected: [3, 6, 5, 4]\n    }\n}\n"}
{"task_id": "Java/38", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Returns encoded string by cycling groups of three characters.\n     */\n    public String encodeCyclic(String s) {\n        // split string to groups. Each of length 3.\n        List<String> groups = new ArrayList<>();\n        for (int i = 0; i < s.length(); i += 3) {\n            groups.add(s.substring(i, Math.min(i + 3, s.length())));\n        }\n        // cycle elements in each group. Unless group has fewer elements than 3.\n        for (int i = 0; i < groups.size(); i++) {\n            if (groups.get(i).length() == 3) {\n                groups.set(i, groups.get(i).substring(1) + groups.get(i).charAt(0));\n            }\n        }\n        return String.join(\"\", groups);\n    }\n\n    /**\n     * Takes as input string encoded with encodeCyclic function. Returns decoded string.\n     */\n    public String decode_cyclic(String s) {\n        // split string to groups. Each of length 3.\n        List<String> groups = new ArrayList<>();\n        for (int i = 0; i < s.length(); i += 3) {\n            groups.add(s.substring(i, Math.min(i + 3, s.length())));\n        }\n        // reverse cycle elements in each group. Unless group has fewer elements than 3.\n        for (int i = 0; i < groups.size(); i++) {\n            if (groups.get(i).length() == 3) {\n                char lastChar = groups.get(i).charAt(2);\n                String rest = groups.get(i).substring(0, 2);\n                groups.set(i, lastChar + rest);\n            }\n        }\n        return String.join(\"\", groups);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.decode_cyclic(solution.encodeCyclic(\"hello\"))); // Should print \"hello\"\n        System.out.println(solution.decode_cyclic(solution.encodeCyclic(\"world\"))); // Should print \"world\"\n        System.out.println(solution.decode_cyclic(solution.encodeCyclic(\"java\")));  // Should print \"java\"\n        System.out.println(solution.decode_cyclic(solution.encodeCyclic(\"python\"))); // Should print \"python\"\n    }\n}\n"}
{"task_id": "Java/39", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * prime_fib returns n-th number that is a Fibonacci number and it's also prime.\n     *\n     * @param n The position of the desired prime Fibonacci number in the sequence of all prime Fibonacci numbers.\n     * @return The n-th prime Fibonacci number.\n     */\n    public int prime_fib(int n) {\n        List<Integer> primes = new ArrayList<>();\n        int a = 0, b = 1;\n        \n        while (primes.size() < n) {\n            int fib = a + b;\n            a = b;\n            b = fib;\n            \n            if (isPrime(fib)) {\n                primes.add(fib);\n            }\n        }\n\n        return primes.get(n - 1);\n    }\n\n    private boolean isPrime(int number) {\n        if (number <= 1) {\n            return false;\n        }\n        \n        for (int i = 2; i * i <= number; i++) {\n            if (number % i == 0) {\n                return false;\n            }\n        }\n        \n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.prime_fib(1)); // Expected output: 2\n        System.out.println(solution.prime_fib(2)); // Expected output: 3\n        System.out.println(solution.prime_fib(3)); // Expected output: 5\n        System.out.println(solution.prime_fib(4)); // Expected output: 13\n        System.out.println(solution.prime_fib(5)); // Expected output: 89\n    }\n}\n"}
{"task_id": "Java/40", "generation": "import java.util.*;\n\nclass Solution {\n    public boolean triples_sum_to_zero(List<Integer> l) {\n        // If the list has less than 3 elements, return false as we cannot form a triple.\n        if (l.size() < 3) {\n            return false;\n        }\n\n        Collections.sort(l); // Sort the list to make it easier to find triples.\n\n        for (int i = 0; i < l.size() - 2; i++) { // Iterate through each element except the last two.\n            int left = i + 1; // Left pointer starts right after the current element.\n            int right = l.size() - 1; // Right pointer starts at the end of the list.\n\n            while (left < right) {\n                int sum = l.get(i) + l.get(left) + l.get(right);\n\n                if (sum == 0) { // If we find a triple that sums to zero.\n                    return true;\n                } else if (sum < 0) { // Move the left pointer to the right for a larger sum.\n                    left++;\n                } else { // Move the right pointer to the left for a smaller sum.\n                    right--;\n                }\n            }\n        }\n\n        return false; // Return false if no such triple is found.\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.triples_sum_to_zero(Arrays.asList(1, 3, 5, 0))); // Expected: false\n        System.out.println(solution.triples_sum_to_zero(Arrays.asList(1, 3, -2, 1))); // Expected: true\n        System.out.println(solution.triples_sum_to_zero(Arrays.asList(1, 2, 3, 7))); // Expected: false\n        System.out.println(solution.triples_sum_to_zero(Arrays.asList(2, 4, -5, 3, 9, 7))); // Expected: true\n        System.out.println(solution.triples_sum_to_zero(Arrays.asList(1))); // Expected: false\n    }\n}\n"}
{"task_id": "Java/41", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Calculates the number of collisions between two sets of n cars driving towards each other.\n     *\n     * @param n The number of cars in each set.\n     * @return The total number of collisions.\n     */\n    public int car_race_collision(int n) {\n        return n;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.car_race_collision(1));  // Expected output: 1\n        System.out.println(solution.car_race_collision(2));  // Expected output: 2\n        System.out.println(solution.car_race_collision(5));  // Expected output: 5\n        System.out.println(solution.car_race_collision(0));  // Expected output: 0 (Edge case)\n    }\n}\n"}
{"task_id": "Java/42", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return list with elements incremented by 1.\n     *\n     * @param l List of integers to be incremented.\n     * @return A new list where each element from the original list has been incremented by 1.\n     */\n    public List<Integer> incr_list(List<Integer> l) {\n        return l.stream().map(x -> x + 1).collect(Collectors.toList());\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case 1\n        List<Integer> list1 = Arrays.asList(1, 2, 3);\n        System.out.println(solution.incr_list(list1)); // Expected: [2, 3, 4]\n        \n        // Test case 2\n        List<Integer> list2 = Arrays.asList(5, 3, 5, 2, 3, 3, 9, 0, 123);\n        System.out.println(solution.incr_list(list2)); // Expected: [6, 4, 6, 3, 4, 4, 10, 1, 124]\n        \n        // Additional test case\n        List<Integer> list3 = Arrays.asList(-1, -5, 0);\n        System.out.println(solution.incr_list(list3)); // Expected: [0, -4, 1]\n    }\n}\n"}
{"task_id": "Java/43", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * pairs_sum_to_zero takes a list of integers as an input.\n     * It returns True if there are two distinct elements in the list that sum to zero, and False otherwise.\n     */\n    public boolean pairs_sum_to_zero(List<Integer> l) {\n        Set<Integer> seen = new HashSet<>();\n        \n        for (int num : l) {\n            // Check if the opposite number is already in the set\n            if (seen.contains(-num)) {\n                return true;\n            }\n            seen.add(num);\n        }\n        return false;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.pairs_sum_to_zero(Arrays.asList(1, 3, 5, 0))); // Expected: false\n        System.out.println(solution.pairs_sum_to_zero(Arrays.asList(1, 3, -2, 1))); // Expected: false\n        System.out.println(solution.pairs_sum_to_zero(Arrays.asList(1, 2, 3, 7))); // Expected: false\n        System.out.println(solution.pairs_sum_to_zero(Arrays.asList(2, 4, -5, 3, 5, 7))); // Expected: true\n        System.out.println(solution.pairs_sum_to_zero(Arrays.asList(1))); // Expected: false\n    }\n}\n"}
{"task_id": "Java/44", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Change numerical base of input number x to base.\n     * Return string representation after the conversion.\n     * Base numbers are less than 10.\n     */\n    public String change_base(int x, int base) {\n        if (base < 2 || base > 9) throw new IllegalArgumentException(\"Base must be between 2 and 9.\");\n        \n        StringBuilder result = new StringBuilder();\n        while (x > 0) {\n            result.insert(0, x % base);\n            x /= base;\n        }\n        return result.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.change_base(8, 3).equals(\"22\") ? \"Test 1 Passed\" : \"Test 1 Failed\");\n        System.out.println(solution.change_base(8, 2).equals(\"1000\") ? \"Test 2 Passed\" : \"Test 2 Failed\");\n        System.out.println(solution.change_base(7, 2).equals(\"111\") ? \"Test 3 Passed\" : \"Test 3 Failed\");\n\n        // Additional test cases\n        System.out.println(solution.change_base(9, 4).equals(\"21\") ? \"Test 4 Passed\" : \"Test 4 Failed\");\n        System.out.println(solution.change_base(15, 8).equals(\"17\") ? \"Test 5 Passed\" : \"Test 5 Failed\");\n    }\n}\n"}
{"task_id": "Java/45", "generation": "import org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nclass Solution {\n    /**\n     * Given length of a side and height return area for a triangle.\n     *\n     * @param a The base length of the triangle.\n     * @param h The height of the triangle.\n     * @return The area of the triangle.\n     */\n    public double triangle_area(double a, double h) {\n        return 0.5 * a * h;\n    }\n\n    // Test method for triangle_area\n    @Test\n    public void testTriangleArea() {\n        Solution solution = new Solution();\n        \n        assertEquals(7.5, solution.triangle_area(5, 3), 0.01);\n        assertEquals(12.0, solution.triangle_area(8, 3), 0.01);\n        assertEquals(0.0, solution.triangle_area(0, 3), 0.01);\n    }\n}\n"}
{"task_id": "Java/46", "generation": "class Solution {\n    public int fib4(int n) {\n        if (n < 0) return -1; // Invalid input\n\n        // Base cases\n        if (n == 0 || n == 1) return 0;\n        if (n == 2) return 2;\n        if (n == 3) return 0;\n\n        int[] fib = new int[n + 1];\n        fib[0] = 0; // fib4(0)\n        fib[1] = 0; // fib4(1)\n        fib[2] = 2; // fib4(2)\n        fib[3] = 0; // fib4(3)\n\n        for (int i = 4; i <= n; i++) {\n            fib[i] = fib[i - 1] + fib[i - 2] + fib[i - 3] + fib[i - 4];\n        }\n\n        return fib[n];\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.fib4(5)); // Expected output: 4\n        System.out.println(solution.fib4(6)); // Expected output: 8\n        System.out.println(solution.fib4(7)); // Expected output: 14\n\n        // Additional test cases\n        System.out.println(solution.fib4(0)); // Expected output: 0\n        System.out.println(solution.fib4(1)); // Expected output: 0\n        System.out.println(solution.fib4(2)); // Expected output: 2\n        System.out.println(solution.fib4(3)); // Expected output: 0\n    }\n}\n"}
{"task_id": "Java/47", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Return median of elements in the list l.\n     *\n     * @param l List of integers\n     * @return The median value as a double\n     */\n    public double median(List<Integer> l) {\n        Collections.sort(l); // Sort the list first\n        \n        int size = l.size();\n        \n        if (size % 2 == 1) { // If odd number of elements, return middle one\n            return l.get(size / 2);\n        } else { // If even number of elements, average the two middle ones\n            int midIndex = size / 2;\n            return (l.get(midIndex - 1) + l.get(midIndex)) / 2.0; \n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case 1: Odd number of elements\n        List<Integer> list1 = Arrays.asList(3, 1, 2, 4, 5);\n        System.out.println(\"Median of \" + list1 + \": \" + solution.median(list1)); // Expected output: 3\n        \n        // Test case 2: Even number of elements\n        List<Integer> list2 = Arrays.asList(-10, 4, 6, 1000, 10, 20);\n        System.out.println(\"Median of \" + list2 + \": \" + solution.median(list2)); // Expected output: 8.0\n        \n        // Additional test case\n        List<Integer> list3 = Arrays.asList(7, -5, 4, 9, 6, 1, 3);\n        System.out.println(\"Median of \" + list3 + \": \" + solution.median(list3)); // Expected output: 4 or 5 depending on sort order\n        \n    }\n}\n"}
{"task_id": "Java/48", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Checks if given string is a palindrome.\n     *\n     * @param text The input string to check.\n     * @return true if the string is a palindrome, false otherwise.\n     */\n    public boolean is_palindrome(String text) {\n        int left = 0;\n        int right = text.length() - 1;\n\n        while (left < right) {\n            if (text.charAt(left) != text.charAt(right)) {\n                return false;\n            }\n            left++;\n            right--;\n        }\n\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.is_palindrome(\"\"));       // Expected: true\n        System.out.println(solution.is_palindrome(\"aba\"));    // Expected: true\n        System.out.println(solution.is_palindrome(\"aaaaa\"));  // Expected: true\n        System.out.println(solution.is_palindrome(\"zbcd\"));   // Expected: false\n    }\n}\n"}
{"task_id": "Java/49", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n\n    /**\n     * Return 2^n modulo p (be aware of numerics).\n     *\n     * @param n The exponent.\n     * @param p The modulus.\n     * @return The result of (2^n) % p.\n     */\n    public int modp(int n, int p) {\n        // Using BigInteger for large numbers to avoid overflow\n        java.math.BigInteger base = java.math.BigInteger.valueOf(2);\n        java.math.BigInteger exponent = java.math.BigInteger.valueOf(n);\n        java.math.BigInteger modulus = java.math.BigInteger.valueOf(p);\n\n        return base.modPow(exponent, modulus).intValue();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.modp(3, 5));   // Expected output: 3\n        System.out.println(solution.modp(1101, 101)); // Expected output: 2\n        System.out.println(solution.modp(0, 101));    // Expected output: 1\n        System.out.println(solution.modp(3, 11));     // Expected output: 8\n        System.out.println(solution.modp(100, 101));  // Expected output: 1\n    }\n}\n"}
{"task_id": "Java/50", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Returns encoded string by shifting every character by 5 in the alphabet.\n     */\n    public String encodeShift(String s) {\n        StringBuilder sb = new StringBuilder();\n        for (char ch : s.toCharArray()) {\n            // Ensure that only lowercase letters are shifted\n            if (ch >= 'a' && ch <= 'z') {\n                sb.append((char) ('a' + ((ch - 'a' + 5) % 26)));\n            } else {\n                sb.append(ch);\n            }\n        }\n        return sb.toString();\n    }\n\n    /**\n     * Takes as input string encoded with encodeShift function. Returns decoded string.\n     */\n    public String decode_shift(String s) {\n        StringBuilder sb = new StringBuilder();\n        for (char ch : s.toCharArray()) {\n            // Ensure that only lowercase letters are shifted\n            if (ch >= 'a' && ch <= 'z') {\n                sb.append((char) ('a' + ((ch - 'a' - 5 + 26) % 26)));\n            } else {\n                sb.append(ch);\n            }\n        }\n        return sb.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        String test1 = \"hello\";\n        String encodedTest1 = solution.encodeShift(test1);\n        System.out.println(\"Encoded: \" + encodedTest1);  // Expected: \"mjqqt\"\n        \n        String decodedTest1 = solution.decode_shift(encodedTest1);\n        System.out.println(\"Decoded: \" + decodedTest1);  // Expected: \"hello\"\n\n        String test2 = \"world\";\n        String encodedTest2 = solution.encodeShift(test2);\n        System.out.println(\"Encoded: \" + encodedTest2);  // Expected: \"btwqi\"\n        \n        String decodedTest2 = solution.decode_shift(encodedTest2);\n        System.out.println(\"Decoded: \" + decodedTest2);  // Expected: \"world\"\n\n        String test3 = \"java\";\n        String encodedTest3 = solution.encodeShift(test3);\n        System.out.println(\"Encoded: \" + encodedTest3);  // Expected: \"ofef\"\n        \n        String decodedTest3 = solution.decode_shift(encodedTest3);\n        System.out.println(\"Decoded: \" + decodedTest3);  // Expected: \"java\"\n\n        // Test with non-alphabetic characters\n        String test4 = \"hello123!\";\n        String encodedTest4 = solution.encodeShift(test4);\n        System.out.println(\"Encoded: \" + encodedTest4);  // Expected: \"mjqqt123!\"\n        \n        String decodedTest4 = solution.decode_shift(encodedTest4);\n        System.out.println(\"Decoded: \" + decodedTest4);  // Expected: \"hello123!\"\n    }\n}\n"}
{"task_id": "Java/51", "generation": "import org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nclass Solution {\n    /**\n     * remove_vowels is a function that takes string and returns string without vowels.\n     */\n    public String remove_vowels(String text) {\n        if (text == null || text.isEmpty()) return text;\n        \n        StringBuilder result = new StringBuilder();\n        for (char c : text.toCharArray()) {\n            char lowerCaseChar = Character.toLowerCase(c);\n            if (lowerCaseChar != 'a' && lowerCaseChar != 'e' && lowerCaseChar != 'i'\n                    && lowerCaseChar != 'o' && lowerCaseChar != 'u') {\n                result.append(c);\n            }\n        }\n        \n        return result.toString();\n    }\n\n    @Test\n    public void testRemoveVowels() {\n        assertEquals(\"\", remove_vowels(\"\"));\n        assertEquals(\"bcdf\\nghjklm\", remove_vowels(\"abcdef\\nghijklm\"));\n        assertEquals(\"bcdf\", remove_vowels(\"abcdef\"));\n        assertEquals(\"\", remove_vowels(\"aaaaa\"));\n        assertEquals(\"B\", remove_vowels(\"aaBAA\"));\n        assertEquals(\"zbcd\", remove_vowels(\"zbcd\"));\n    }\n}\n"}
{"task_id": "Java/52", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Return True if all numbers in the list l are below threshold t.\n     *\n     * @param l List of integers to be checked.\n     * @param t The threshold value against which elements of the list are compared.\n     * @return true if all elements in the list are less than the threshold, false otherwise.\n     */\n    public boolean below_threshold(List<Integer> l, int t) {\n        for (int num : l) {\n            if (num >= t) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    // Method to test the functionality of below_threshold\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1: All numbers are below threshold\n        System.out.println(solution.below_threshold(Arrays.asList(1, 2, 4, 10), 100)); // Expected output: true\n\n        // Test case 2: Not all numbers are below threshold\n        System.out.println(solution.below_threshold(Arrays.asList(1, 20, 4, 10), 5)); // Expected output: false\n\n        // Additional test cases can be added here to further validate the method.\n    }\n}\n"}
{"task_id": "Java/53", "generation": "import org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nclass SolutionTest {\n    @Test\n    void testAdd() {\n        Solution solution = new Solution();\n        \n        // Test case 1: Adding positive numbers\n        assertEquals(5, solution.add(2, 3), \"Adding 2 and 3 should give 5\");\n        \n        // Test case 2: Another addition of positive numbers\n        assertEquals(12, solution.add(5, 7), \"Adding 5 and 7 should give 12\");\n\n        // Additional test cases can be added here to cover more scenarios\n    }\n}\n"}
{"task_id": "Java/54", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Check if two words have the same kind of characters.\n     */\n    public boolean same_chars(String s0, String s1) {\n        Set<Character> set0 = new HashSet<>();\n        Set<Character> set1 = new HashSet<>();\n\n        for (char c : s0.toCharArray()) {\n            set0.add(c);\n        }\n\n        for (char c : s1.toCharArray()) {\n            set1.add(c);\n        }\n\n        return set0.equals(set1);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.same_chars(\"eabcdzzzz\", \"dddzzzzzzzddeddabc\")); // true\n        System.out.println(solution.same_chars(\"abcd\", \"dddddddabc\"));              // true\n        System.out.println(solution.same_chars(\"dddddddabc\", \"abcd\"));              // true\n        System.out.println(solution.same_chars(\"eabcd\", \"dddddddabc\"));             // false\n        System.out.println(solution.same_chars(\"abcd\", \"dddddddabce\"));             // false\n        System.out.println(solution.same_chars(\"eabcdzzzz\", \"dddzzzzzzzddddabc\"));  // false\n    }\n}\n"}
{"task_id": "Java/55", "generation": "import org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nclass Solution {\n    /**\n     * Return n-th Fibonacci number.\n     */\n    public int fib(int n) {\n        if (n <= 1) return n; // Base case: fib(0)=0, fib(1)=1\n        int a = 0, b = 1;\n        for (int i = 2; i <= n; ++i) {\n            int temp = a + b;\n            a = b;\n            b = temp;\n        }\n        return b;\n    }\n\n    @Test\n    public void testFib() {\n        assertEquals(55, fib(10), \"fib(10) should be 55\");\n        assertEquals(1, fib(1), \"fib(1) should be 1\");\n        assertEquals(21, fib(8), \"fib(8) should be 21\");\n    }\n}\n"}
{"task_id": "Java/56", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Checks if every opening bracket \"<\" has a corresponding closing bracket \">\".\n     *\n     * @param brackets A string containing only \"<\" and \">\" characters.\n     * @return true if the sequence of brackets is correct, false otherwise.\n     */\n    public boolean correct_bracketing(String brackets) {\n        int balance = 0;\n        \n        for (int i = 0; i < brackets.length(); i++) {\n            char c = brackets.charAt(i);\n            \n            // Increase balance for opening bracket\n            if (c == '<') {\n                balance++;\n            }\n            // Decrease balance for closing bracket\n            else if (c == '>') {\n                balance--;\n                \n                // If balance is negative, there are more closing brackets than opening ones at some point.\n                if (balance < 0) {\n                    return false;\n                }\n            }\n        }\n        \n        // The sequence is correct only if the final balance is zero\n        return balance == 0;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.correct_bracketing(\"<\"));       // Expected: false\n        System.out.println(solution.correct_bracketing(\"<>\"));      // Expected: true\n        System.out.println(solution.correct_bracketing(\"<<><>>\"));  // Expected: true\n        System.out.println(solution.correct_bracketing(\"><<>\"));    // Expected: false\n    }\n}\n"}
{"task_id": "Java/57", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Return True if list elements are monotonically increasing or decreasing.\n     */\n    public boolean monotonic(List<Integer> l) {\n        // If the list has less than 2 elements, it's considered monotonic by definition.\n        if (l.size() < 2) return true;\n\n        // Determine whether to check for increasing or decreasing order\n        boolean isIncreasing = l.get(0) <= l.get(l.size() - 1);\n\n        // Check the list based on determined order\n        for (int i = 1; i < l.size(); i++) {\n            if ((isIncreasing && l.get(i) < l.get(i - 1)) || (!isIncreasing && l.get(i) > l.get(i - 1))) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.monotonic(Arrays.asList(1, 2, 4, 20))); // Expected: true\n        System.out.println(solution.monotonic(Arrays.asList(1, 20, 4, 10))); // Expected: false\n        System.out.println(solution.monotonic(Arrays.asList(4, 1, 0, -10))); // Expected: true\n    }\n}\n"}
{"task_id": "Java/58", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Return sorted unique common elements for two lists.\n     */\n    public List<Integer> common(List<Integer> l1, List<Integer> l2) {\n        // Convert both lists to sets to remove duplicates and find intersection\n        Set<Integer> set1 = new HashSet<>(l1);\n        Set<Integer> set2 = new HashSet<>(l2);\n\n        // Retain only the elements that are in both sets (intersection)\n        set1.retainAll(set2);\n\n        // Convert the result back to a list, sort it and return\n        List<Integer> commonElements = new ArrayList<>(set1);\n        Collections.sort(commonElements);\n        \n        return commonElements;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case 1\n        System.out.println(solution.common(Arrays.asList(1, 4, 3, 34, 653, 2, 5), Arrays.asList(5, 7, 1, 5, 9, 653, 121)));\n        // Expected: [1, 5, 653]\n        \n        // Test case 2\n        System.out.println(solution.common(Arrays.asList(5, 3, 2, 8), Arrays.asList(3, 2)));\n        // Expected: [2, 3]\n    }\n}\n"}
{"task_id": "Java/59", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return the largest prime factor of n.\n     * Assume n > 1 and is not a prime.\n     *\n     * @param n The number whose largest prime factor to find.\n     * @return The largest prime factor of n.\n     */\n    public int largest_prime_factor(int n) {\n        int maxPrime = -1;\n        \n        // Divide n by 2 until it's odd\n        while (n % 2 == 0) {\n            maxPrime = 2;\n            n /= 2;\n        }\n        \n        // Now n must be odd, start from 3 and check for factors.\n        for (int i = 3; i <= Math.sqrt(n); i += 2) {\n            while (n % i == 0) {\n                maxPrime = i;\n                n = n / i;\n            }\n        }\n\n        // If n is a prime number greater than 2\n        if (n > 2)\n            maxPrime = n;\n\n        return maxPrime;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.largest_prime_factor(13195)); // Should print: 29\n        System.out.println(solution.largest_prime_factor(2048));  // Should print: 2\n    }\n}\n"}
{"task_id": "Java/60", "generation": "import org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nclass Solution {\n    /**\n     * sum_to_n is a function that sums numbers from 1 to n.\n     *\n     * @param n the upper limit for summation\n     * @return the sum of all integers from 1 to n inclusive\n     */\n    public int sum_to_n(int n) {\n        return (n * (n + 1)) / 2; // Using the arithmetic series sum formula\n    }\n\n    /**\n     * Test cases for the sum_to_n function.\n     */\n    @Test\n    public void testSumToN() {\n        assertEquals(465, sum_to_n(30));\n        assertEquals(5050, sum_to_n(100));\n        assertEquals(15, sum_to_n(5));\n        assertEquals(55, sum_to_n(10));\n        assertEquals(1, sum_to_n(1));\n    }\n}\n"}
{"task_id": "Java/61", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * brackets is a string of \"(\" and \")\".\n     * return True if every opening bracket has a corresponding closing bracket.\n     *\n     * >>> correct_bracketing(\"(\")\n     * false\n     * >>> correct_bracketing(\"()\")\n     * true\n     * >>> correct_bracketing(\"(()())\")\n     * true\n     * >>> correct_bracketing(\")(()\")\n     * false\n     */\n    public boolean correct_bracketing(String brackets) {\n        Stack<Character> stack = new Stack<>();\n        \n        for (char ch : brackets.toCharArray()) {\n            if (ch == '(') {\n                stack.push(ch);\n            } else if (ch == ')') {\n                if (stack.isEmpty() || stack.pop() != '(') {\n                    return false;\n                }\n            }\n        }\n\n        // If the stack is empty, all opening brackets have been matched\n        return stack.isEmpty();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.correct_bracketing(\"(\"));       // Expected: false\n        System.out.println(solution.correct_bracketing(\"()\"));      // Expected: true\n        System.out.println(solution.correct_bracketing(\"(()())\"));  // Expected: true\n        System.out.println(solution.correct_bracketing(\")(()\"));    // Expected: false\n    }\n}\n"}
{"task_id": "Java/62", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * xs represent coefficients of a polynomial.\n     * xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     * Return derivative of this polynomial in the same form.\n     *\n     * @param xs List<Integer> representing the coefficients of the polynomial.\n     * @return List<Integer> representing the coefficients of the derivative polynomial.\n     */\n    public List<Integer> derivative(List<Integer> xs) {\n        if (xs == null || xs.size() <= 1) return Collections.emptyList();\n        \n        List<Integer> result = new ArrayList<>();\n        for (int i = 1; i < xs.size(); i++) {\n            result.add(xs.get(i) * i);\n        }\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        List<Integer> test1 = Arrays.asList(3, 1, 2, 4, 5);\n        System.out.println(\"Test Case 1: \" + solution.derivative(test1)); // Expected [1, 4, 12, 20]\n\n        // Test case 2\n        List<Integer> test2 = Arrays.asList(1, 2, 3);\n        System.out.println(\"Test Case 2: \" + solution.derivative(test2)); // Expected [2, 6]\n    }\n}\n"}
{"task_id": "Java/63", "generation": "class Solution {\n    public int fibfib(int n) {\n        // Base cases as defined in the problem statement.\n        if (n == 0 || n == 1) return 0;\n        if (n == 2) return 1;\n\n        // Initialize an array to store computed values for reuse.\n        int[] dp = new int[n + 1];\n        dp[0] = 0; // fibfib(0)\n        dp[1] = 0; // fibfib(1)\n        dp[2] = 1; // fibfib(2)\n\n        // Fill the DP array from index 3 to n.\n        for (int i = 3; i <= n; ++i) {\n            dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3];\n        }\n\n        return dp[n]; // Return the nth element of the sequence.\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.fibfib(1)); // Expected output: 0\n        System.out.println(solution.fibfib(5)); // Expected output: 4\n        System.out.println(solution.fibfib(8)); // Expected output: 24\n\n        // Additional test case to check larger values.\n        System.out.println(solution.fibfib(10)); // Expected output: 81\n    }\n}\n"}
{"task_id": "Java/64", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Returns the number of vowels in the string. Vowels are 'a', 'e', 'i', 'o', 'u'.\n     * Additionally, 'y' is considered a vowel only if it appears at the end of the word.\n     *\n     * @param s The input string representing a word\n     * @return The number of vowels in the string\n     */\n    public int vowels_count(String s) {\n        // Convert to lowercase for case-insensitive comparison\n        String lowerCaseWord = s.toLowerCase();\n        int count = 0;\n\n        // Check each character if it is a vowel\n        for (int i = 0; i < lowerCaseWord.length(); i++) {\n            char c = lowerCaseWord.charAt(i);\n            if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n                count++;\n            }\n        }\n\n        // Check the last character for 'y'\n        if (!lowerCaseWord.isEmpty() && lowerCaseWord.charAt(lowerCaseWord.length() - 1) == 'y') {\n            count++;\n        }\n\n        return count;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.vowels_count(\"abcde\")); // Expected output: 2\n        System.out.println(solution.vowels_count(\"ACEDY\")); // Expected output: 3\n        System.out.println(solution.vowels_count(\"rhythm\")); // Expected output: 0 (no vowels, 'y' is not at the end)\n        System.out.println(solution.vowels_count(\"sky\"));    // Expected output: 1 ('y' is at the end)\n        System.out.println(solution.vowels_count(\"AEIOU\"));  // Expected output: 5\n        System.out.println(solution.vowels_count(\"\"));       // Expected output: 0 (empty string)\n    }\n}\n"}
{"task_id": "Java/65", "generation": "class Solution {\n    /**\n     * Circular shift the digits of the integer x, shifting the digits right by shift.\n     * If shift > number of digits, return digits reversed.\n     *\n     * @param x The integer to be shifted.\n     * @param shift The number of positions to shift the digits.\n     * @return A string representing the result after circular shift or reversal if shift is greater than digit count.\n     */\n    public String circular_shift(int x, int shift) {\n        // Convert the integer into a string for easy manipulation\n        String str = Integer.toString(x);\n        int len = str.length();\n\n        // If shift is greater than the number of digits, reverse the string\n        if (shift >= len) {\n            return new StringBuilder(str).reverse().toString();\n        }\n\n        // Perform circular shift\n        shift %= len;  // Adjust shift in case it's larger than length but not enough to trigger reversal\n        String shifted = str.substring(len - shift) + str.substring(0, len - shift);\n        \n        return shifted;\n    }\n    \n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.circular_shift(12, 1).equals(\"21\") ? \"Test 1 Passed\" : \"Test 1 Failed\");\n        System.out.println(solution.circular_shift(12, 2).equals(\"12\") ? \"Test 2 Passed\" : \"Test 2 Failed\");\n        System.out.println(solution.circular_shift(12345, 7).equals(\"54321\") ? \"Test 3 Passed\" : \"Test 3 Failed\"); // Shift > digits\n        System.out.println(solution.circular_shift(98765, 3).equals(\"65987\") ? \"Test 4 Passed\" : \"Test 4 Failed\");\n    }\n}\n"}
{"task_id": "Java/66", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Sums the ASCII codes of upper-case letters in the input string.\n     *\n     * @param s The input string.\n     * @return The sum of ASCII values of all uppercase characters in the string.\n     */\n    public int digitSum(String s) {\n        if (s == null || s.isEmpty()) return 0;\n\n        int sum = 0;\n        for (char c : s.toCharArray()) {\n            if (Character.isUpperCase(c)) {\n                sum += (int)c;\n            }\n        }\n\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.digitSum(\"\") == 0 ? \"Test 1 Passed\" : \"Test 1 Failed\");\n        System.out.println(solution.digitSum(\"abAB\") == 131 ? \"Test 2 Passed\" : \"Test 2 Failed\");\n        System.out.println(solution.digitSum(\"abcCd\") == 67 ? \"Test 3 Passed\" : \"Test 3 Failed\");\n        System.out.println(solution.digitSum(\"helloE\") == 69 ? \"Test 4 Passed\" : \"Test 4 Failed\");\n        System.out.println(solution.digitSum(\"woArBld\") == 131 ? \"Test 5 Passed\" : \"Test 5 Failed\");\n        System.out.println(solution.digitSum(\"aAaaaXa\") == 153 ? \"Test 6 Passed\" : \"Test 6 Failed\");\n    }\n}\n"}
{"task_id": "Java/67", "generation": "import java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nclass Solution {\n    /**\n     * Calculates the number of mango fruits in the basket based on the total number of fruits and the provided string.\n     *\n     * @param s A string that represents the total number of apples and oranges, e.g., \"5 apples and 6 oranges\".\n     * @param n An integer representing the total number of fruits in the basket.\n     * @return The number of mango fruits in the basket.\n     */\n    public int fruit_distribution(String s, int n) {\n        Pattern pattern = Pattern.compile(\"(\\\\d+)\\\\s+apples\\\\s+and\\\\s+(\\\\d+)\\\\s+oranges\");\n        Matcher matcher = pattern.matcher(s);\n        \n        if (matcher.find()) {\n            int apples = Integer.parseInt(matcher.group(1));\n            int oranges = Integer.parseInt(matcher.group(2));\n            \n            return n - (apples + oranges); // Total fruits minus the sum of apples and oranges\n        }\n        \n        throw new IllegalArgumentException(\"Input string is not in expected format.\");\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.fruit_distribution(\"5 apples and 6 oranges\", 19)); // Expected output: 8\n        System.out.println(solution.fruit_distribution(\"0 apples and 1 oranges\", 3));   // Expected output: 2\n        System.out.println(solution.fruit_distribution(\"2 apples and 3 oranges\", 100)); // Expected output: 95\n        System.out.println(solution.fruit_distribution(\"100 apples and 1 oranges\", 120)); // Expected output: 19\n    }\n}\n"}
{"task_id": "Java/68", "generation": "import java.util.*;\n\nclass Solution {\n    public List<Integer> pluck(List<Integer> arr) {\n        int minValue = Integer.MAX_VALUE;\n        int minIndex = -1;\n\n        // Iterate through the list to find the smallest even number and its index.\n        for (int i = 0; i < arr.size(); i++) {\n            int value = arr.get(i);\n            if (value % 2 == 0 && value <= minValue) {\n                if (value < minValue || minIndex == -1) {\n                    minValue = value;\n                    minIndex = i;\n                }\n            }\n        }\n\n        // If no even number is found, return an empty list.\n        if (minIndex == -1) {\n            return new ArrayList<>();\n        } else {\n            List<Integer> result = new ArrayList<>();\n            result.add(minValue);\n            result.add(minIndex);\n            return result;\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.pluck(Arrays.asList(4, 2, 3))); // [2, 1]\n        System.out.println(solution.pluck(Arrays.asList(1, 2, 3))); // [2, 1]\n        System.out.println(solution.pluck(new ArrayList<>()));      // []\n        System.out.println(solution.pluck(Arrays.asList(5, 0, 3, 0, 4, 2))); // [0, 1]\n    }\n}\n"}
{"task_id": "Java/69", "generation": "import java.util.*;\n\nclass Solution {\n    public int search(List<Integer> lst) {\n        // Create a map to store the frequency of each integer in the list.\n        Map<Integer, Integer> freqMap = new HashMap<>();\n        \n        // Populate the frequency map.\n        for (int num : lst) {\n            freqMap.put(num, freqMap.getOrDefault(num, 0) + 1);\n        }\n        \n        int result = -1;\n        \n        // Check each entry in the map to find if any number's frequency is greater than or equal to its value.\n        for (Map.Entry<Integer, Integer> entry : freqMap.entrySet()) {\n            if (entry.getKey() <= entry.getValue()) {\n                result = Math.max(result, entry.getKey());\n            }\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case 1\n        List<Integer> list1 = Arrays.asList(4, 1, 2, 2, 3, 1);\n        System.out.println(solution.search(list1)); // Expected output: 2\n        \n        // Test case 2\n        List<Integer> list2 = Arrays.asList(1, 2, 2, 3, 3, 3, 4, 4, 4);\n        System.out.println(solution.search(list2)); // Expected output: 3\n        \n        // Test case 3\n        List<Integer> list3 = Arrays.asList(5, 5, 4, 4, 4);\n        System.out.println(solution.search(list3)); // Expected output: -1\n    }\n}\n"}
{"task_id": "Java/70", "generation": "import java.util.*;\n\nclass Solution {\n    public List<Integer> strange_sort_list(List<Integer> lst) {\n        // Sort the list in ascending order.\n        Collections.sort(lst);\n        \n        List<Integer> result = new ArrayList<>();\n        int left = 0;\n        int right = lst.size() - 1;\n\n        while (left <= right) {\n            if (left == right) {\n                // If there's only one element left, add it to the list.\n                result.add(lst.get(left));\n            } else {\n                // Add the smallest and then the largest remaining elements.\n                result.add(lst.get(left++));\n                result.add(lst.get(right--));\n            }\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        List<Integer> test1 = Arrays.asList(1, 2, 3, 4);\n        System.out.println(\"Test 1: \" + solution.strange_sort_list(test1));\n\n        List<Integer> test2 = Arrays.asList(5, 5, 5, 5);\n        System.out.println(\"Test 2: \" + solution.strange_sort_list(test2));\n\n        List<Integer> test3 = new ArrayList<>();\n        System.out.println(\"Test 3: \" + solution.strange_sort_list(test3));\n    }\n}\n"}
{"task_id": "Java/71", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given the lengths of the three sides of a triangle, return the area of\n     * the triangle rounded to 2 decimal points if the three sides form a valid triangle.\n     * Otherwise return -1. Three sides make a valid triangle when the sum of any two sides is greater\n     * than the third side.\n     *\n     * Example:\n     * triangle_area(3, 4, 5) == 6.00\n     * triangle_area(1, 2, 10) == -1\n     */\n    public double triangle_area(double a, double b, double c) {\n        // Check if the sides form a valid triangle\n        if (a + b <= c || a + c <= b || b + c <= a) {\n            return -1;\n        }\n\n        // Calculate semi-perimeter\n        double s = (a + b + c) / 2;\n\n        // Use Heron's formula to calculate the area\n        double area = Math.sqrt(s * (s - a) * (s - b) * (s - c));\n\n        // Round the result to two decimal places\n        return Math.round(area * 100.0) / 100.0;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.triangle_area(3, 4, 5)); // Expected output: 6.00\n        System.out.println(solution.triangle_area(1, 2, 10)); // Expected output: -1\n        System.out.println(solution.triangle_area(7, 8, 9)); // Expected output: 26.83\n    }\n}\n"}
{"task_id": "Java/72", "generation": "import java.util.*;\n\nclass Solution {\n    \n    /**\n     * Checks if an object will fly based on balance and weight conditions.\n     *\n     * @param q List of integers representing the object's elements.\n     * @param w Maximum possible weight for the object to fly.\n     * @return true if the object can fly, false otherwise.\n     */\n    public boolean will_it_fly(List<Integer> q, int w) {\n        // Check if the list is a palindrome\n        for (int i = 0; i < q.size() / 2; ++i) {\n            if (!q.get(i).equals(q.get(q.size() - 1 - i))) {\n                return false;\n            }\n        }\n\n        // Calculate sum of elements in the list\n        int sum = 0;\n        for (int num : q) {\n            sum += num;\n        }\n\n        // Check if the sum is less than or equal to w\n        return sum <= w;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.will_it_fly(Arrays.asList(1, 2), 5)); // false\n        System.out.println(solution.will_it_fly(Arrays.asList(3, 2, 3), 1)); // false\n        System.out.println(solution.will_it_fly(Arrays.asList(3, 2, 3), 9)); // true\n        System.out.println(solution.will_it_fly(Arrays.asList(3), 5)); // true\n    }\n}\n"}
{"task_id": "Java/73", "generation": "import java.util.*;\n\nclass Solution {\n    public int smallest_change(List<Integer> arr) {\n        if (arr == null || arr.size() <= 1) return 0;\n\n        int changes = 0;\n        int left = 0, right = arr.size() - 1;\n\n        while (left < right) {\n            if (!arr.get(left).equals(arr.get(right))) {\n                changes++;\n            }\n            left++;\n            right--;\n        }\n\n        return changes;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.smallest_change(Arrays.asList(1, 2, 3, 5, 4, 7, 9, 6))); // Expected output: 4\n        System.out.println(solution.smallest_change(Arrays.asList(1, 2, 3, 4, 3, 2, 2)));    // Expected output: 1\n        System.out.println(solution.smallest_change(Arrays.asList(1, 2, 3, 2, 1)));          // Expected output: 0\n        System.out.println(solution.smallest_change(Arrays.asList()));                       // Expected output: 0 (empty list)\n        System.out.println(solution.smallest_change(Arrays.asList(5)));                      // Expected output: 0 (single element)\n    }\n}\n"}
{"task_id": "Java/74", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Compares two lists of strings and returns the one with fewer total characters.\n     * If both have the same number, it returns the first list.\n     */\n    public List<String> total_match(List<String> lst1, List<String> lst2) {\n        int count1 = 0;\n        for (String s : lst1) {\n            count1 += s.length();\n        }\n\n        int count2 = 0;\n        for (String s : lst2) {\n            count2 += s.length();\n        }\n\n        if (count1 <= count2) {\n            return lst1;\n        } else {\n            return lst2;\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.total_match(new ArrayList<>(), new ArrayList<>())); // -> []\n        System.out.println(solution.total_match(Arrays.asList(\"hi\", \"admin\"), Arrays.asList(\"hI\", \"Hi\"))); // -> [\"hI\", \"Hi\"]\n        System.out.println(solution.total_match(Arrays.asList(\"hi\", \"admin\"), Arrays.asList(\"hi\", \"hi\", \"admin\", \"project\"))); // -> [\"hi\", \"admin\"]\n        System.out.println(solution.total_match(Arrays.asList(\"hi\", \"admin\"), Arrays.asList(\"hI\", \"hi\", \"hi\"))); // -> [\"hI\", \"hi\", \"hi\"]\n        System.out.println(solution.total_match(Arrays.asList(\"4\"), Arrays.asList(\"1\", \"2\", \"3\", \"4\", \"5\"))); // -> [\"4\"]\n    }\n}\n"}
{"task_id": "Java/75", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Checks if a number is the multiplication of 3 prime numbers.\n     *\n     * @param a The number to check.\n     * @return true if the number can be expressed as the product of exactly three primes, false otherwise.\n     */\n    public boolean is_multiply_prime(int a) {\n        // List of all prime numbers less than 100\n        int[] primes = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97};\n        \n        int count = 0;\n        for (int prime : primes) {\n            if (a % prime == 0) {\n                a /= prime; // Divide the number by the prime factor\n                count++;\n                \n                // If we have more than three factors or the remaining number is not 1, return false\n                if (count > 3 || (count == 3 && a != 1)) {\n                    return false;\n                }\n            }\n        }\n        \n        // The number should be exactly divisible by three primes and nothing else.\n        return count == 3 && a == 1;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.is_multiply_prime(30)); // true, because 30 = 2 * 3 * 5\n        System.out.println(solution.is_multiply_prime(60)); // false, because it has more than three prime factors (2*2*3*5)\n        System.out.println(solution.is_multiply_prime(105)); // true, because 105 = 3 * 5 * 7\n        System.out.println(solution.is_multiply_prime(49)); // false, because 49 is not the product of three primes (it's 7*7)\n    }\n}\n"}
{"task_id": "Java/76", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public boolean is_simple_power(int x, int n) {\n        if (n == 1) return x == 1; // Special case: the only simple power of 1 is 1 itself.\n        \n        long temp = 1;\n        while (temp < x) {\n            temp *= n;\n        }\n        return temp == x;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.is_simple_power(1, 4)); // Expected: true\n        System.out.println(solution.is_simple_power(2, 2)); // Expected: true\n        System.out.println(solution.is_simple_power(8, 2)); // Expected: true\n        System.out.println(solution.is_simple_power(3, 2)); // Expected: false\n        System.out.println(solution.is_simple_power(3, 1)); // Expected: false\n        System.out.println(solution.is_simple_power(5, 3)); // Expected: false\n    }\n}\n"}
{"task_id": "Java/77", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Checks whether the given integer 'a' is a perfect cube.\n     *\n     * @param a The integer to check.\n     * @return true if 'a' is a perfect cube, false otherwise.\n     */\n    public boolean iscube(int a) {\n        // Calculate the cube root of 'a'.\n        int cubeRoot = (int) Math.round(Math.cbrt(a));\n        \n        // Check if the cube of the calculated cube root equals 'a'\n        return cubeRoot * cubeRoot * cubeRoot == a;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.iscube(1));   // true\n        System.out.println(solution.iscube(2));   // false\n        System.out.println(solution.iscube(-1));  // true\n        System.out.println(solution.iscube(64));  // true\n        System.out.println(solution.iscube(0));   // true\n        System.out.println(solution.iscube(180)); // false\n    }\n}\n"}
{"task_id": "Java/78", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Counts the number of prime hexadecimal digits in a given string.\n     *\n     * @param num A string representing a hexadecimal number.\n     * @return The count of prime hexadecimal digits in the input string.\n     */\n    public int hex_key(String num) {\n        // Map to store which hexadecimal characters are primes\n        Set<Character> primeHexDigits = new HashSet<>(Arrays.asList('2', '3', '5', '7', 'B', 'D'));\n        \n        int count = 0;\n        for (char c : num.toCharArray()) {\n            if (primeHexDigits.contains(c)) {\n                count++;\n            }\n        }\n        return count;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.hex_key(\"AB\"));          // Expected output: 1\n        System.out.println(solution.hex_key(\"1077E\"));       // Expected output: 2\n        System.out.println(solution.hex_key(\"ABED1A33\"));    // Expected output: 4\n        System.out.println(solution.hex_key(\"123456789ABCDEF0\")); // Expected output: 6\n        System.out.println(solution.hex_key(\"2020\"));        // Expected output: 2\n    }\n}\n"}
{"task_id": "Java/79", "generation": "class Solution {\n    /**\n     * Converts a given decimal number to its binary format.\n     * The returned string will have 'db' prepended and appended to it.\n     *\n     * @param decimal The decimal number to convert.\n     * @return A String representing the binary format of the input, with 'db' at both ends.\n     */\n    public String decimal_to_binary(int decimal) {\n        // Convert the decimal number to a binary string\n        String binaryString = Integer.toBinaryString(decimal);\n        \n        // Add 'db' at the beginning and end of the binary string\n        return \"db\" + binaryString + \"db\";\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases to verify the correctness of the function\n        System.out.println(solution.decimal_to_binary(15));  // Expected output: db1111db\n        System.out.println(solution.decimal_to_binary(32));  // Expected output: db100000db\n    }\n}\n"}
{"task_id": "Java/80", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    \n    /**\n    You are given a string s.\n    Your task is to check if the string is happy or not.\n    A string is happy if its length is at least 3 and every 3 consecutive letters are distinct\n     */\n    public boolean is_happy(String s) {\n        // If the string's length is less than 3, it can't be a happy string by definition.\n        if (s.length() < 3) return false;\n\n        for (int i = 0; i <= s.length() - 3; i++) {\n            char firstChar = s.charAt(i);\n            char secondChar = s.charAt(i + 1);\n            char thirdChar = s.charAt(i + 2);\n\n            // Check if all three characters are distinct\n            if (firstChar == secondChar || firstChar == thirdChar || secondChar == thirdChar) {\n                return false;\n            }\n        }\n\n        // If no consecutive triplets were found to be non-distinct, the string is happy.\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.is_happy(\"a\"));       // Expected: false\n        System.out.println(solution.is_happy(\"aa\"));      // Expected: false\n        System.out.println(solution.is_happy(\"abcd\"));    // Expected: true\n        System.out.println(solution.is_happy(\"aabb\"));    // Expected: false\n        System.out.println(solution.is_happy(\"adb\"));     // Expected: true\n        System.out.println(solution.is_happy(\"xyy\"));     // Expected: false\n    }\n}\n"}
{"task_id": "Java/81", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Converts a list of numerical GPA values to their corresponding letter grades.\n     *\n     * @param grades A List<Double> containing the GPAs of students.\n     * @return A List<String> containing the letter grades for each input GPA.\n     */\n    public List<String> numerical_letter_grade(List<Double> grades) {\n        List<String> result = new ArrayList<>();\n        \n        // Iterate over each grade in the list\n        for (Double gpa : grades) {\n            if (gpa >= 4.0) {\n                result.add(\"A+\");\n            } else if (gpa > 3.7) {\n                result.add(\"A\");\n            } else if (gpa > 3.3) {\n                result.add(\"A-\");\n            } else if (gpa > 3.0) {\n                result.add(\"B+\");\n            } else if (gpa > 2.7) {\n                result.add(\"B\");\n            } else if (gpa > 2.3) {\n                result.add(\"B-\");\n            } else if (gpa > 2.0) {\n                result.add(\"C+\");\n            } else if (gpa > 1.7) {\n                result.add(\"C\");\n            } else if (gpa > 1.3) {\n                result.add(\"C-\");\n            } else if (gpa > 1.0) {\n                result.add(\"D+\");\n            } else if (gpa > 0.7) {\n                result.add(\"D\");\n            } else if (gpa >= 0.0) {\n                result.add(\"D-\");\n            } else {\n                // For values less than 0, assign \"E\"\n                result.add(\"E\");\n            }\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        List<Double> testGrades1 = Arrays.asList(4.0, 3.5, 2.7, 1.8);\n        System.out.println(solution.numerical_letter_grade(testGrades1)); // [\"A+\", \"A-\", \"B\", \"C-\"]\n        \n        List<Double> testGrades2 = Arrays.asList(3.9, 2.0, 1.5, 0.6);\n        System.out.println(solution.numerical_letter_grade(testGrades2)); // [\"A\", \"C+\", \"D+\", \"E\"]\n    }\n}\n"}
{"task_id": "Java/82", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Checks if the length of the provided string is a prime number.\n     *\n     * @param string The input string.\n     * @return true if the length of the string is a prime number, false otherwise.\n     */\n    public boolean prime_length(String string) {\n        int length = string.length();\n        return isPrime(length);\n    }\n\n    /**\n     * Helper method to check if a number is prime.\n     *\n     * @param num The number to check.\n     * @return true if the number is prime, false otherwise.\n     */\n    private boolean isPrime(int num) {\n        if (num <= 1) return false;\n        for (int i = 2; i <= Math.sqrt(num); i++) {\n            if (num % i == 0) return false;\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.prime_length(\"Hello\"));   // Expected: true\n        System.out.println(solution.prime_length(\"abcdcba\")); // Expected: true\n        System.out.println(solution.prime_length(\"kittens\")); // Expected: true\n        System.out.println(solution.prime_length(\"orange\"));  // Expected: false\n    }\n}\n"}
{"task_id": "Java/83", "generation": "class Solution {\n    /**\n     * Given a positive integer n, return the count of the numbers of n-digit\n     * positive integers that start or end with 1.\n     */\n    public int starts_one_ends(int n) {\n        if (n == 1) {\n            // If n is 1, all single-digit numbers starting or ending with 1 are: 1\n            return 1;\n        }\n        \n        // Count of numbers that start with 1 = 9^(n-1)\n        int startsWithOneCount = (int)Math.pow(9, n - 1);\n        \n        // Count of numbers that end with 1 = 9^(n-1)\n        int endsWithOneCount = (int)Math.pow(9, n - 1);\n\n        // Numbers that both start and end with 1 are counted twice\n        // So we subtract the count of such numbers which is 8^(n-2) for n > 1\n        int startsAndEndsWithOneCount = (n > 1) ? (int)Math.pow(8, n - 2) : 0;\n\n        return startsWithOneCount + endsWithOneCount - startsAndEndsWithOneCount;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.starts_one_ends(1)); // Expected output: 1\n        System.out.println(solution.starts_one_ends(2)); // Expected output: 17 (9 + 9 - 1)\n        System.out.println(solution.starts_one_ends(3)); // Expected output: 162 (81 + 81 - 10)\n    }\n}\n"}
{"task_id": "Java/84", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a positive integer N, return in binary the total sum of its digits.\n     *\n     * @param N The input number whose digit sum needs to be calculated and converted into binary.\n     * @return A string representing the binary form of the sum of digits of N.\n     */\n    public String solve(int N) {\n        int sum = 0;\n        \n        // Calculate the sum of digits\n        while (N > 0) {\n            sum += N % 10; // Add the last digit to sum\n            N /= 10;       // Remove the last digit from N\n        }\n        \n        // Convert the sum into binary and return as a string\n        return Integer.toBinaryString(sum);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.solve(1000));  // Expected output: \"1\"\n        System.out.println(solution.solve(150));   // Expected output: \"110\"\n        System.out.println(solution.solve(147));   // Expected output: \"1100\"\n    }\n}\n"}
{"task_id": "Java/85", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given a non-empty list of integers lst, add the even elements that are at odd indices.\n     *\n     * @param lst List of integers to process.\n     * @return The sum of even numbers located at odd indices in the list.\n     */\n    public int add(List<Integer> lst) {\n        if (lst == null || lst.isEmpty()) return 0;\n\n        int sum = 0;\n        for (int i = 1; i < lst.size(); i += 2) { // Start from index 1 and increment by 2 to stay at odd indices\n            int value = lst.get(i);\n            if (value % 2 == 0) {\n                sum += value;\n            }\n        }\n\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.add(Arrays.asList(4, 2, 6, 7))); // Expected output: 2\n        System.out.println(solution.add(Arrays.asList(1, 3, 5, 7, 9, 10))); // Expected output: 0 (no even elements at odd indices)\n        System.out.println(solution.add(Arrays.asList(2, 4, 6, 8, 10))); // Expected output: 12 (4 + 8)\n    }\n}\n"}
{"task_id": "Java/86", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Write a function that takes a string and returns an ordered version of it.\n     * Ordered version of string, is a string where all words (separated by space)\n     * are replaced by a new word where all the characters arranged in\n     * ascending order based on ascii value.\n     * Note: You should keep the order of words and blank spaces in the sentence.\n     *\n     * @param s The input string to be processed.\n     * @return A new string with each word's letters sorted in ascending ASCII order.\n     */\n    public String anti_shuffle(String s) {\n        // Splitting the input string into an array of words\n        String[] words = s.split(\" \");\n        \n        // Looping through each word and sorting its characters\n        for (int i = 0; i < words.length; i++) {\n            char[] chars = words[i].toCharArray();\n            Arrays.sort(chars);\n            words[i] = new String(chars);\n        }\n        \n        // Joining the sorted words back into a single string with spaces in between\n        return String.join(\" \", words);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases to verify the correctness of the function\n        System.out.println(solution.anti_shuffle(\"Hi\")); // Expected: \"Hi\"\n        System.out.println(solution.anti_shuffle(\"hello\")); // Expected: \"ehllo\"\n        System.out.println(solution.anti_shuffle(\"Hello World!!!\")); // Expected: \"Hello !!!Wdlor\"\n    }\n}\n"}
{"task_id": "Java/87", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Finds all occurrences of integer x within a 2D list and returns their coordinates.\n     * Coordinates are sorted by rows in ascending order and columns in descending order.\n     */\n    public List<List<Integer>> get_row(List<List<Integer>> lst, int x) {\n        // This will store the result as (row, column)\n        List<List<Integer>> result = new ArrayList<>();\n\n        for (int row = 0; row < lst.size(); row++) {\n            List<Integer> currentRow = lst.get(row);\n            for (int col = 0; col < currentRow.size(); col++) {\n                if (currentRow.get(col) == x) {\n                    // Add the coordinates to result\n                    result.add(Arrays.asList(row, col));\n                }\n            }\n        }\n\n        // Sort by row in ascending order and column in descending order within each row.\n        Collections.sort(result, new Comparator<List<Integer>>() {\n            @Override\n            public int compare(List<Integer> o1, List<Integer> o2) {\n                if (!o1.get(0).equals(o2.get(0))) {\n                    return o1.get(0) - o2.get(0); // Ascending order by row\n                } else {\n                    return o2.get(1) - o1.get(1); // Descending order by column within the same row\n                }\n            }\n        });\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        List<List<Integer>> test1 = Arrays.asList(\n            Arrays.asList(1, 2, 3, 4, 5, 6),\n            Arrays.asList(1, 2, 3, 4, 1, 6),\n            Arrays.asList(1, 2, 3, 4, 5, 1)\n        );\n        System.out.println(solution.get_row(test1, 1)); // Expected: [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n\n        List<List<Integer>> test2 = new ArrayList<>();\n        System.out.println(solution.get_row(test2, 1)); // Expected: []\n\n        List<List<Integer>> test3 = Arrays.asList(\n            new ArrayList<>(),\n            Arrays.asList(1),\n            Arrays.asList(1, 2, 3)\n        );\n        System.out.println(solution.get_row(test3, 3)); // Expected: [[2, 2]]\n    }\n}\n"}
{"task_id": "Java/88", "generation": "import java.util.*;\n\nclass Solution {\n    public List<Integer> sort_array(List<Integer> array) {\n        // Check if the array is empty or has only one element, then just return it as is.\n        if (array == null || array.size() <= 1) {\n            return new ArrayList<>(array);\n        }\n\n        // Create a copy of the original list to avoid modifying it.\n        List<Integer> sortedArray = new ArrayList<>(array);\n\n        // Determine sorting order based on the sum of first and last elements\n        boolean shouldSortAscending = (sortedArray.get(0) + sortedArray.get(sortedArray.size() - 1)) % 2 != 0;\n\n        if (shouldSortAscending) {\n            Collections.sort(sortedArray);\n        } else {\n            // For descending order, we can sort in ascending and then reverse the list\n            Collections.sort(sortedArray, Collections.reverseOrder());\n        }\n\n        return sortedArray;\n    }\n}\n\n// Test code to verify the solution\nclass Main {\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n\n        System.out.println(sol.sort_array(Arrays.asList())); // []\n        System.out.println(sol.sort_array(Arrays.asList(5))); // [5]\n        System.out.println(sol.sort_array(Arrays.asList(2, 4, 3, 0, 1, 5))); // [0, 1, 2, 3, 4, 5]\n        System.out.println(sol.sort_array(Arrays.asList(2, 4, 3, 0, 1, 5, 6))); // [6, 5, 4, 3, 2, 1, 0]\n    }\n}\n"}
{"task_id": "Java/89", "generation": "class Solution {\n    /**\n     * Encrypts a given string by rotating its characters down by 4 places.\n     *\n     * @param s The input string to be encrypted.\n     * @return The encrypted string.\n     */\n    public String encrypt(String s) {\n        StringBuilder result = new StringBuilder();\n        \n        for (char c : s.toCharArray()) {\n            if (Character.isLetter(c)) {\n                char base = Character.isUpperCase(c) ? 'A' : 'a';\n                // Rotate the character by 4 places\n                int rotatedChar = ((c - base + 4) % 26) + base;\n                result.append((char)rotatedChar);\n            } else {\n                // Non-alphabet characters are not encrypted, so we keep them as is.\n                result.append(c);\n            }\n        }\n\n        return result.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.encrypt(\"hi\"));  // Expected output: \"lm\"\n        System.out.println(solution.encrypt(\"asdfghjkl\"));  // Expected output: \"ewhjklnop\"\n        System.out.println(solution.encrypt(\"gf\"));  // Expected output: \"kj\"\n        System.out.println(solution.encrypt(\"et\"));  // Expected output: \"ix\"\n    }\n}\n"}
{"task_id": "Java/90", "generation": "import java.util.*;\n\nclass Solution {\n    public Optional<Integer> next_smallest(List<Integer> lst) {\n        if (lst == null || lst.size() < 2) {\n            return Optional.empty();\n        }\n\n        TreeSet<Integer> set = new TreeSet<>(lst);\n        Integer smallest = set.pollFirst(); // Remove the first element which is the smallest\n        return set.isEmpty() ? Optional.empty() : Optional.of(set.first()); // Return the next smallest or empty if there isn't one.\n    }\n    \n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.next_smallest(Arrays.asList(1, 2, 3, 4, 5))); // Optional[2]\n        System.out.println(solution.next_smallest(Arrays.asList(5, 1, 4, 3, 2))); // Optional[2]\n        System.out.println(solution.next_smallest(new ArrayList<>())); // Optional.empty\n        System.out.println(solution.next_smallest(Arrays.asList(1, 1))); // Optional.empty\n    }\n}\n"}
{"task_id": "Java/91", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Counts the number of sentences starting with \"I\".\n     *\n     * @param S The input string containing multiple sentences.\n     * @return The count of sentences starting with \"I\".\n     */\n    public int isBored(String S) {\n        // Split the text into sentences based on '.', '?' or '!'\n        String[] sentences = S.split(\"[.?!]\");\n        \n        int boredomCount = 0;\n        for (String sentence : sentences) {\n            // Trim leading and trailing spaces\n            sentence = sentence.trim();\n            \n            // Check if the sentence starts with \"I \"\n            if (!sentence.isEmpty() && sentence.startsWith(\"I \")) {\n                boredomCount++;\n            }\n        }\n        \n        return boredomCount;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.isBored(\"Hello world\"));  // Expected output: 0\n        System.out.println(solution.isBored(\"The sky is blue. The sun is shining. I love this weather.\"));  // Expected output: 1\n        System.out.println(solution.isBored(\"I am bored. Really, I am! Do you think I am?\"));  // Expected output: 2\n    }\n}\n"}
{"task_id": "Java/92", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Create a function that takes 3 numbers.\n     * Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n     * Returns false in any other cases.\n     */\n    public boolean any_int(Object x, Object y, Object z) {\n        // Check if all inputs are instances of Integer\n        if (!(x instanceof Integer && y instanceof Integer && z instanceof Integer)) {\n            return false;\n        }\n\n        int a = (Integer) x;\n        int b = (Integer) y;\n        int c = (Integer) z;\n\n        // Check if any number is the sum of the other two\n        return (a == b + c) || (b == a + c) || (c == a + b);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.any_int(5, 2, 7));   // true\n        System.out.println(solution.any_int(3, 2, 2));   // false\n        System.out.println(solution.any_int(3, -2, 1));  // true\n        System.out.println(solution.any_int(3.6, -2.2, 2));  // false\n    }\n}\n"}
{"task_id": "Java/93", "generation": "class Solution {\n    public String encode(String message) {\n        StringBuilder encodedMessage = new StringBuilder();\n        \n        for (char c : message.toCharArray()) {\n            if (Character.isLetter(c)) { // Ensure it's a letter\n                char lowerCaseChar = Character.toLowerCase(c);\n                \n                // Swap case\n                char swappedCaseChar = Character.isUpperCase(c) ? Character.toLowerCase(c) : Character.toUpperCase(c);\n                \n                // Replace vowels with the character 2 places ahead in the alphabet\n                if (\"aeiou\".indexOf(lowerCaseChar) != -1) {\n                    int newCharCode = lowerCaseChar + 2;\n                    \n                    // Wrap around for 'y' and 'z'\n                    if (newCharCode > 'z') {\n                        newCharCode -= 26; // Wrap around the alphabet\n                    }\n                    \n                    swappedCaseChar = Character.isUpperCase(c) ? Character.toUpperCase((char)newCharCode) : (char)newCharCode;\n                }\n                \n                encodedMessage.append(swappedCaseChar);\n            } else {\n                encodedMessage.append(c); // Non-letter characters are not modified\n            }\n        }\n\n        return encodedMessage.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.encode(\"test\")); // Expected: \"TGST\"\n        System.out.println(solution.encode(\"This is a message\")); // Expected: \"tHKS KS C MGSSCGG\"\n        System.out.println(solution.encode(\"Hello World\")); // Additional test case, expected: \"hKLLQ wQRMF\"\n    }\n}\n"}
{"task_id": "Java/94", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Finds the largest prime value in a list and returns the sum of its digits.\n     *\n     * @param lst List of integers.\n     * @return Sum of the digits of the largest prime number found in the list.\n     */\n    public int skjkasdkd(List<Integer> lst) {\n        // Find the maximum prime number\n        int maxPrime = Integer.MIN_VALUE;\n        for (int num : lst) {\n            if (isPrime(num)) {\n                maxPrime = Math.max(maxPrime, num);\n            }\n        }\n\n        // If no prime number is found, return 0.\n        if (maxPrime == Integer.MIN_VALUE) {\n            return 0;\n        }\n\n        // Calculate the sum of digits of the largest prime\n        int sumOfDigits = 0;\n        while (maxPrime > 0) {\n            sumOfDigits += maxPrime % 10;\n            maxPrime /= 10;\n        }\n        \n        return sumOfDigits;\n    }\n\n    /**\n     * Checks if a number is prime.\n     *\n     * @param num The number to check.\n     * @return true if the number is prime, false otherwise.\n     */\n    private boolean isPrime(int num) {\n        if (num <= 1) {\n            return false;\n        }\n        for (int i = 2; i <= Math.sqrt(num); i++) {\n            if (num % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        List<Integer> test1 = Arrays.asList(0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3);\n        System.out.println(solution.skjkasdkd(test1)); // Expected output: 10\n        \n        List<Integer> test2 = Arrays.asList(1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1);\n        System.out.println(solution.skjkasdkd(test2)); // Expected output: 25\n        \n        List<Integer> test3 = Arrays.asList(1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3);\n        System.out.println(solution.skjkasdkd(test3)); // Expected output: 13\n        \n        List<Integer> test4 = Arrays.asList(0,724,32,71,99,32,6,0,5,91,83,0,5,6);\n        System.out.println(solution.skjkasdkd(test4)); // Expected output: 11\n        \n        List<Integer> test5 = Arrays.asList(0,81,12,3,1,21);\n        System.out.println(solution.skjkasdkd(test5)); // Expected output: 3\n        \n        List<Integer> test6 = Arrays.asList(0,8,1,2,1,7);\n        System.out.println(solution.skjkasdkd(test6)); // Expected output: 7\n    }\n}\n"}
{"task_id": "Java/95", "generation": "import java.util.*;\n\nclass Solution {\n    public boolean check_dict_case(Map<Object, Object> dict) {\n        // Check if the dictionary is empty.\n        if (dict.isEmpty()) {\n            return false;\n        }\n\n        boolean hasLower = false;\n        boolean hasUpper = false;\n\n        for (Object key : dict.keySet()) {\n            // If any key is not a string, return false.\n            if (!(key instanceof String)) {\n                return false;\n            }\n            \n            String strKey = (String) key;\n            // Check the case of each key and set flags accordingly.\n            if (!strKey.equals(strKey.toLowerCase())) {\n                hasUpper = true;\n            }\n            if (!strKey.equals(strKey.toUpperCase())) {\n                hasLower = true;\n            }\n\n            // If both lower and upper cases are found, return false.\n            if (hasLower && hasUpper) {\n                return false;\n            }\n        }\n\n        // If the loop completes without finding mixed case keys, return true.\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        Map<Object, Object> dict1 = new HashMap<>();\n        dict1.put(\"a\", \"apple\");\n        dict1.put(\"b\", \"banana\");\n\n        Map<Object, Object> dict2 = new HashMap<>();\n        dict2.put(\"a\", \"apple\");\n        dict2.put(\"A\", \"banana\");\n        dict2.put(\"B\", \"banana\");\n\n        Map<Object, Object> dict3 = new HashMap<>();\n        dict3.put(\"a\", \"apple\");\n        dict3.put(8, \"banana\"); // This is not a string key.\n        dict3.put(\"a\", \"apple\");\n\n        Map<Object, Object> dict4 = new HashMap<>();\n        dict4.put(\"Name\", \"John\");\n        dict4.put(\"Age\", \"36\");\n        dict4.put(\"City\", \"Houston\");\n\n        Map<Object, Object> dict5 = new HashMap<>();\n        dict5.put(\"STATE\", \"NC\");\n        dict5.put(\"ZIP\", \"12345\");\n\n        System.out.println(solution.check_dict_case(dict1)); // Expected: true\n        System.out.println(solution.check_dict_case(dict2)); // Expected: false\n        System.out.println(solution.check_dict_case(dict3)); // Expected: false\n        System.out.println(solution.check_dict_case(dict4)); // Expected: false\n        System.out.println(solution.check_dict_case(dict5)); // Expected: true\n    }\n}\n"}
{"task_id": "Java/96", "generation": "import java.util.ArrayList;\nimport java.util.List;\n\nclass Solution {\n    public List<Integer> count_up_to(int n) {\n        List<Integer> primes = new ArrayList<>();\n        \n        for (int i = 2; i < n; i++) {\n            if (isPrime(i)) {\n                primes.add(i);\n            }\n        }\n\n        return primes;\n    }\n\n    private boolean isPrime(int num) {\n        if (num <= 1) {\n            return false;\n        }\n        for (int i = 2; i * i <= num; i++) {\n            if (num % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.count_up_to(5));   // Expected: [2,3]\n        System.out.println(solution.count_up_to(11));  // Expected: [2,3,5,7]\n        System.out.println(solution.count_up_to(0));   // Expected: []\n        System.out.println(solution.count_up_to(20));  // Expected: [2,3,5,7,11,13,17,19]\n        System.out.println(solution.count_up_to(1));   // Expected: []\n        System.out.println(solution.count_up_to(18));  // Expected: [2,3,5,7,11,13,17]\n    }\n}\n"}
{"task_id": "Java/97", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    \n    /**\n     * Takes two integers and returns the product of their unit digits.\n     *\n     * @param a First integer\n     * @param b Second integer\n     * @return The product of the unit digits of a and b\n     */\n    public int multiply(int a, int b) {\n        // Extracting the unit digit by taking modulo 10\n        int unitDigitA = Math.abs(a % 10);\n        int unitDigitB = Math.abs(b % 10);\n\n        // Returning the product of these digits\n        return unitDigitA * unitDigitB;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases to verify the correctness of the function\n        System.out.println(solution.multiply(148, 412)); // Expected output: 16\n        System.out.println(solution.multiply(19, 28));   // Expected output: 72\n        System.out.println(solution.multiply(2020, 1851)); // Expected output: 0\n        System.out.println(solution.multiply(14, -15)); // Expected output: 20\n    }\n}\n"}
{"task_id": "Java/98", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a string s, count the number of uppercase vowels in even indices.\n     *\n     * @param s The input string.\n     * @return The count of uppercase vowels at even indices.\n     */\n    public int count_upper(String s) {\n        // Define the set of uppercase vowels\n        Set<Character> vowels = new HashSet<>(Arrays.asList('A', 'E', 'I', 'O', 'U'));\n        \n        int count = 0;\n        for (int i = 0; i < s.length(); i += 2) { // Iterate over even indices\n            char c = s.charAt(i);\n            if (vowels.contains(c)) {\n                count++;\n            }\n        }\n        return count;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases to verify the correctness of the method\n        System.out.println(solution.count_upper(\"aBCdEf\"));  // Expected output: 1\n        System.out.println(solution.count_upper(\"abcdefg\")); // Expected output: 0\n        System.out.println(solution.count_upper(\"dBBE\"));    // Expected output: 0\n        System.out.println(solution.count_upper(\"AeIoU\"));   // Expected output: 2\n        System.out.println(solution.count_upper(\"AEIOUaeiou\")); // Expected output: 3\n    }\n}\n"}
{"task_id": "Java/99", "generation": "class Solution {\n    public int closest_integer(String value) {\n        double num = Double.parseDouble(value);\n        \n        if (num > 0) {\n            return (int)(Math.floor(num + 0.5));\n        } else {\n            return (int)(Math.ceil(num - 0.5));\n        }\n    }\n\n    // Test code to verify the correctness of the function\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.closest_integer(\"10\"));      // Expected output: 10\n        System.out.println(solution.closest_integer(\"15.3\"));    // Expected output: 15\n        System.out.println(solution.closest_integer(\"14.5\"));    // Expected output: 15\n        System.out.println(solution.closest_integer(\"-14.5\"));   // Expected output: -15\n        System.out.println(solution.closest_integer(\"0.5\"));     // Expected output: 1\n        System.out.println(solution.closest_integer(\"-0.5\"));    // Expected output: -1\n    }\n}\n"}
{"task_id": "Java/100", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given a positive integer n, makes a pile of n levels of stones.\n     * The first level has n stones.\n     * The number of stones in the next level is:\n     *   - the next odd number if n is odd.\n     *   - the next even number if n is even.\n     *\n     * @param n the number of levels\n     * @return a list where each element represents the number of stones at that level\n     */\n    public List<Integer> make_a_pile(int n) {\n        List<Integer> pile = new ArrayList<>();\n        int currentStones = n;\n        \n        for (int i = 0; i < n; i++) {\n            pile.add(currentStones);\n            // Determine the next number of stones based on whether current is odd or even\n            if (currentStones % 2 == 0) {\n                currentStones += 2; // Next even number\n            } else {\n                currentStones += 2; // Next odd number, same operation as for even\n            }\n        }\n\n        return pile;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.make_a_pile(3)); // Expected: [3, 5, 7]\n        System.out.println(solution.make_a_pile(4)); // Expected: [4, 6, 8, 10]\n    }\n}\n"}
{"task_id": "Java/101", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Splits the given string into words based on commas or spaces.\n     *\n     * @param s The input string containing words separated by commas or spaces.\n     * @return A List of strings representing each word in the input string.\n     */\n    public List<String> words_string(String s) {\n        // Replace commas with spaces to unify separators\n        String replaced = s.replaceAll(\"[, ]+\", \" \");\n        \n        // Split the string based on space and trim any leading/trailing whitespace\n        String[] splitArray = replaced.trim().split(\"\\\\s+\");\n        \n        // Convert array to list and return\n        return Arrays.asList(splitArray);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case 1: Mixed commas and spaces\n        List<String> result1 = solution.words_string(\"Hi, my name is John\");\n        System.out.println(result1.equals(Arrays.asList(\"Hi\", \"my\", \"name\", \"is\", \"John\"))); // Expected: true\n        \n        // Test case 2: Only commas as separators\n        List<String> result2 = solution.words_string(\"One, two, three, four, five, six\");\n        System.out.println(result2.equals(Arrays.asList(\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"))); // Expected: true\n        \n        // Test case 3: Only spaces as separators\n        List<String> result3 = solution.words_string(\"Hello world how are you today\");\n        System.out.println(result3.equals(Arrays.asList(\"Hello\", \"world\", \"how\", \"are\", \"you\", \"today\"))); // Expected: true\n        \n        // Test case 4: Leading and trailing spaces\n        List<String> result4 = solution.words_string(\"   This is a test    \");\n        System.out.println(result4.equals(Arrays.asList(\"This\", \"is\", \"a\", \"test\"))); // Expected: true\n    }\n}\n"}
{"task_id": "Java/102", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * This function takes two positive numbers x and y and returns the\n     * biggest even integer number that is in the range [x, y] inclusive. If\n     * there's no such number, then the function should return -1.\n     *\n     * @param x The lower bound of the range (inclusive).\n     * @param y The upper bound of the range (inclusive).\n     * @return The biggest even integer in the range [x, y] or -1 if none exists.\n     */\n    public int choose_num(int x, int y) {\n        // If x is greater than y, there's no valid range\n        if (x > y) return -1;\n\n        // Start from y and go down to find the first even number in the range\n        for (int i = y; i >= x; i--) {\n            if (i % 2 == 0) {\n                return i;\n            }\n        }\n\n        // If no even number is found, return -1\n        return -1;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases to verify the correctness of the choose_num method\n        System.out.println(solution.choose_num(12, 15)); // Expected output: 14\n        System.out.println(solution.choose_num(13, 12)); // Expected output: -1\n        System.out.println(solution.choose_num(8, 10));  // Expected output: 10\n        System.out.println(solution.choose_num(7, 9));   // Expected output: 8\n        System.out.println(solution.choose_num(5, 5));   // Expected output: -1 (since 5 is odd)\n    }\n}\n"}
{"task_id": "Java/103", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Computes the average of integers from n through m (inclusive), rounds it,\n     * converts it to binary format, and returns -1 if n > m.\n     */\n    public Object rounded_avg(int n, int m) {\n        // If n is greater than m, return -1\n        if (n > m) {\n            return -1;\n        }\n\n        // Calculate the sum of integers from n through m\n        long sum = 0;\n        for (int i = n; i <= m; i++) {\n            sum += i;\n        }\n        \n        // Calculate average and round it to nearest integer\n        int avg = (int) Math.round((double) sum / (m - n + 1));\n        \n        // Convert the rounded average to binary format as a string\n        return Integer.toBinaryString(avg);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.rounded_avg(1, 5));   // Expected output: \"11\"\n        System.out.println(solution.rounded_avg(7, 5));   // Expected output: -1\n        System.out.println(solution.rounded_avg(10, 20)); // Expected output: \"1111\"\n        System.out.println(solution.rounded_avg(20, 33)); // Expected output: \"11011\"\n    }\n}\n"}
{"task_id": "Java/104", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a list of positive integers x, returns a sorted list of all elements \n     * that do not have any even digits.\n     *\n     * @param x List of positive integers to be filtered and sorted.\n     * @return A sorted list containing only those numbers from the input list which don't contain any even digit.\n     */\n    public List<Integer> unique_digits(List<Integer> x) {\n        return x.stream()\n                .filter(this::hasNoEvenDigits)\n                .sorted()\n                .collect(Collectors.toList());\n    }\n\n    private boolean hasNoEvenDigits(int number) {\n        while (number > 0) {\n            int digit = number % 10;\n            if (digit % 2 == 0) return false; // If any digit is even, return false.\n            number /= 10;\n        }\n        return true; // All digits are odd.\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        List<Integer> testList1 = Arrays.asList(15, 33, 1422, 1);\n        System.out.println(solution.unique_digits(testList1)); // Expected: [1, 15, 33]\n\n        List<Integer> testList2 = Arrays.asList(152, 323, 1422, 10);\n        System.out.println(solution.unique_digits(testList2)); // Expected: []\n\n        List<Integer> testList3 = Arrays.asList(17, 29, 31, 48, 59);\n        System.out.println(solution.unique_digits(testList3)); // Expected: [17, 29, 31, 59]\n    }\n}\n"}
{"task_id": "Java/105", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given an array of integers, sort the integers that are between 1 and 9 inclusive,\n     * reverse the resulting array, and then replace each digit by its corresponding name from\n     * \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n     */\n    public List<String> by_length(List<Integer> arr) {\n        // Filter out numbers not between 1 and 9 inclusive.\n        List<Integer> filtered = new ArrayList<>();\n        for (Integer num : arr) {\n            if (num >= 1 && num <= 9) {\n                filtered.add(num);\n            }\n        }\n\n        // Sort the list\n        Collections.sort(filtered);\n\n        // Reverse the sorted list\n        Collections.reverse(filtered);\n\n        // Replace each digit with its corresponding name.\n        List<String> result = new ArrayList<>();\n        for (Integer num : filtered) {\n            switch (num) {\n                case 1:\n                    result.add(\"One\");\n                    break;\n                case 2:\n                    result.add(\"Two\");\n                    break;\n                case 3:\n                    result.add(\"Three\");\n                    break;\n                case 4:\n                    result.add(\"Four\");\n                    break;\n                case 5:\n                    result.add(\"Five\");\n                    break;\n                case 6:\n                    result.add(\"Six\");\n                    break;\n                case 7:\n                    result.add(\"Seven\");\n                    break;\n                case 8:\n                    result.add(\"Eight\");\n                    break;\n                case 9:\n                    result.add(\"Nine\");\n                    break;\n            }\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.by_length(Arrays.asList(2, 1, 1, 4, 5, 8, 2, 3)));\n        // Expected: [Eight, Five, Four, Three, Two, Two, One, One]\n\n        System.out.println(solution.by_length(new ArrayList<>()));\n        // Expected: []\n\n        System.out.println(solution.by_length(Arrays.asList(1, -1, 55)));\n        // Expected: [One]\n    }\n}\n"}
{"task_id": "Java/106", "generation": "import java.util.ArrayList;\nimport java.util.List;\n\nclass Solution {\n    \n    /**\n     * Returns a list where each element at index i (starting from 1) \n     * contains either the factorial of i if i is even, or the sum of numbers from 1 to i otherwise.\n     */\n    public List<Integer> f(int n) {\n        List<Integer> result = new ArrayList<>();\n        \n        for (int i = 1; i <= n; i++) {\n            if (i % 2 == 0) {\n                // If i is even, calculate factorial\n                result.add(factorial(i));\n            } else {\n                // Otherwise, sum numbers from 1 to i\n                int sum = 0;\n                for (int j = 1; j <= i; j++) {\n                    sum += j;\n                }\n                result.add(sum);\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * Helper method to calculate factorial of a number.\n     */\n    private int factorial(int num) {\n        if (num == 0 || num == 1) {\n            return 1;\n        }\n        \n        int fact = 1;\n        for (int i = 2; i <= num; i++) {\n            fact *= i;\n        }\n        \n        return fact;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        List<Integer> result = solution.f(5);\n        System.out.println(result); // Expected output: [1, 2, 6, 24, 15]\n    }\n}\n"}
{"task_id": "Java/107", "generation": "import java.util.*;\n\nclass Solution {\n    public List<Integer> even_odd_palindrome(int n) {\n        int evenCount = 0;\n        int oddCount = 0;\n\n        for (int i = 1; i <= n; i++) {\n            if (isPalindrome(i)) {\n                if (i % 2 == 0) {\n                    evenCount++;\n                } else {\n                    oddCount++;\n                }\n            }\n        }\n\n        List<Integer> result = new ArrayList<>();\n        result.add(evenCount);\n        result.add(oddCount);\n\n        return result;\n    }\n\n    private boolean isPalindrome(int number) {\n        String numStr = Integer.toString(number);\n        int left = 0, right = numStr.length() - 1;\n\n        while (left < right) {\n            if (numStr.charAt(left) != numStr.charAt(right)) {\n                return false;\n            }\n            left++;\n            right--;\n        }\n\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case 1\n        System.out.println(solution.even_odd_palindrome(3)); // Expected output: [1, 2]\n        \n        // Test case 2\n        System.out.println(solution.even_odd_palindrome(12)); // Expected output: [4, 6]\n    }\n}\n"}
{"task_id": "Java/108", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Counts elements with a sum of digits greater than 0.\n     *\n     * @param arr List of integers to process.\n     * @return The count of numbers whose digit sum is greater than 0.\n     */\n    public int count_nums(List<Integer> arr) {\n        return (int) arr.stream()\n                .filter(num -> sumOfDigits(num) > 0)\n                .count();\n    }\n\n    private int sumOfDigits(int num) {\n        int sum = 0;\n        boolean isNegative = num < 0;\n        while (num != 0) {\n            int digit = num % 10;\n            if (isNegative && sum == 0) { // Only the first digit should be negative\n                digit *= -1;\n            }\n            sum += digit;\n            num /= 10;\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.count_nums(Arrays.asList()) == 0 ? \"Test 1 Passed\" : \"Test 1 Failed\");\n        System.out.println(solution.count_nums(Arrays.asList(-1, 11, -11)) == 1 ? \"Test 2 Passed\" : \"Test 2 Failed\");\n        System.out.println(solution.count_nums(Arrays.asList(1, 1, 2)) == 3 ? \"Test 3 Passed\" : \"Test 3 Failed\");\n    }\n}\n"}
{"task_id": "Java/109", "generation": "import java.util.*;\n\nclass Solution {\n    public boolean move_one_ball(List<Integer> arr) {\n        if (arr.isEmpty()) return true;\n\n        int n = arr.size();\n        int count = 0;\n        \n        // Find the number of positions where the order is not maintained.\n        for (int i = 1; i < n; ++i) {\n            if (arr.get(i - 1) > arr.get(i)) {\n                count++;\n            }\n        }\n\n        // Check the last and first element as well to ensure circular condition\n        if (arr.get(n - 1) > arr.get(0)) {\n            count++;\n        }\n\n        // If there is more than one such position, it's not possible.\n        return count <= 1;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        \n        System.out.println(sol.move_one_ball(Arrays.asList(3, 4, 5, 1, 2))); // true\n        System.out.println(sol.move_one_ball(Arrays.asList(3, 5, 4, 1, 2))); // false\n    }\n}\n"}
{"task_id": "Java/110", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Determines whether it is possible to perform an exchange of elements between lst1 and lst2\n     * so that all numbers in lst1 become even.\n     *\n     * @param lst1 The first list of integers.\n     * @param lst2 The second list of integers.\n     * @return \"YES\" if it's possible to make all elements of lst1 even by exchanging with lst2, otherwise \"NO\".\n     */\n    public String exchange(List<Integer> lst1, List<Integer> lst2) {\n        // Count the number of odd numbers in lst1\n        long countOddLst1 = lst1.stream().filter(n -> n % 2 != 0).count();\n        \n        // If there are no odd numbers in lst1, we don't need to exchange anything.\n        if (countOddLst1 == 0) {\n            return \"YES\";\n        }\n        \n        // Count the number of even numbers in lst2\n        long countEvenLst2 = lst2.stream().filter(n -> n % 2 == 0).count();\n        \n        // If there are enough even numbers in lst2 to exchange with all odd numbers in lst1, return \"YES\"\n        if (countOddLst1 <= countEvenLst2) {\n            return \"YES\";\n        }\n        \n        // Otherwise, it's not possible to make all elements of lst1 even.\n        return \"NO\";\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.exchange(Arrays.asList(1, 2, 3, 4), Arrays.asList(1, 2, 3, 4))); // Expected: \"YES\"\n        System.out.println(solution.exchange(Arrays.asList(1, 2, 3, 4), Arrays.asList(1, 5, 3, 4))); // Expected: \"NO\"\n        System.out.println(solution.exchange(Arrays.asList(1, 3, 5, 7), Arrays.asList(2, 4, 6, 8))); // Expected: \"YES\"\n        System.out.println(solution.exchange(Arrays.asList(1, 3, 5, 7), Arrays.asList(1, 3, 5, 7))); // Expected: \"NO\"\n    }\n}\n"}
{"task_id": "Java/111", "generation": "import java.util.*;\n\nclass Solution {\n    public Map<String,Integer> histogram(String test) {\n        // Split the input string into an array of words (characters)\n        String[] letters = test.split(\" \");\n        \n        // Use a HashMap to count occurrences of each letter\n        Map<String, Integer> counts = new HashMap<>();\n        for (String letter : letters) {\n            if (!letter.isEmpty()) {  // Ensure we don't process empty strings\n                counts.put(letter, counts.getOrDefault(letter, 0) + 1);\n            }\n        }\n\n        // Find the maximum count of any character\n        int maxCount = Collections.max(counts.values(), Integer::compare);\n\n        // Filter out only those characters that have the maximum count\n        Map<String, Integer> result = new HashMap<>();\n        for (Map.Entry<String, Integer> entry : counts.entrySet()) {\n            if (entry.getValue() == maxCount) {\n                result.put(entry.getKey(), entry.getValue());\n            }\n        }\n\n        return result;\n    }\n\n    // Test code to verify the solution\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        \n        System.out.println(sol.histogram(\"a b c\"));  // Expected: {a=1, b=1, c=1}\n        System.out.println(sol.histogram(\"a b b a\"));  // Expected: {a=2, b=2}\n        System.out.println(sol.histogram(\"a b c a b\"));  // Expected: {a=2, b=2}\n        System.out.println(sol.histogram(\"b b b b a\"));  // Expected: {b=4}\n        System.out.println(sol.histogram(\"\"));  // Expected: {}\n    }\n}\n"}
{"task_id": "Java/112", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Task: We are given two strings s and c, you have to delete all the characters in s that are equal to any character in c.\n     * Then check if the result string is palindrome.\n     * A string is called palindrome if it reads the same backward as forward.\n     * You should return a tuple containing the result string and true/false for the check.\n     *\n     * Example:\n     * For s = \"abcde\", c = \"ae\", the result should be (\"bcd\", false)\n     * For s = \"abcdef\", c = \"b\"  the result should be (\"acdef\", false)\n     * For s = \"abcdedcba\", c = \"ab\", the result should be (\"cdedc\", true)\n     */\n    public List<Object> reverse_delete(String s, String c) {\n        StringBuilder sb = new StringBuilder();\n        \n        // Remove all characters from 's' that are present in 'c'\n        for (char ch : s.toCharArray()) {\n            if (c.indexOf(ch) == -1) {  // If character is not found in 'c', add it to the result\n                sb.append(ch);\n            }\n        }\n\n        String result = sb.toString();\n        \n        // Check if the resulting string is a palindrome\n        boolean isPalindrome = new StringBuilder(result).reverse().toString().equals(result);\n\n        return Arrays.asList(result, isPalindrome);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.reverse_delete(\"abcde\", \"ae\"));  // Expected: [bcd, false]\n        System.out.println(solution.reverse_delete(\"abcdef\", \"b\"));  // Expected: [acdef, false]\n        System.out.println(solution.reverse_delete(\"abcdedcba\", \"ab\"));// Expected: [cdedc, true]\n    }\n}\n"}
{"task_id": "Java/113", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a list of strings, where each string consists of only digits,\n     * return a list. Each element i of the output should be \"the number of odd elements in the\n     * string i of the input.\" where all the i's should be replaced by the number\n     * of odd digits in the i\"th string of the input.\n     */\n    public List<String> odd_count(List<String> lst) {\n        List<String> result = new ArrayList<>();\n        String template = \"the number of odd elements in the strin of the nput.\";\n        \n        for (String s : lst) {\n            int countOddDigits = 0;\n            for (char c : s.toCharArray()) {\n                if ((c - '0') % 2 != 0) { // Check if digit is odd\n                    countOddDigits++;\n                }\n            }\n            \n            String output = template.replace('i', (char)(countOddDigits + '0'))\n                                     .replace('n', (char)(countOddDigits + '0'));\n            result.add(output);\n        }\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case 1\n        List<String> input1 = Arrays.asList(\"1234567\");\n        System.out.println(solution.odd_count(input1));\n        \n        // Test case 2\n        List<String> input2 = Arrays.asList(\"3\", \"11111111\");\n        System.out.println(solution.odd_count(input2));\n    }\n}\n"}
{"task_id": "Java/114", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int minSubArraySum(List<Integer> nums) {\n        if (nums == null || nums.isEmpty()) return 0;\n\n        int currentMin = nums.get(0);\n        int globalMin = nums.get(0);\n\n        for (int i = 1; i < nums.size(); i++) {\n            // Update the current minimum sum to be either the current element or\n            // the sum of the current element and the previous subarray sum.\n            currentMin = Math.min(nums.get(i), currentMin + nums.get(i));\n            \n            // Update the global minimum if the current minimum is smaller.\n            globalMin = Math.min(globalMin, currentMin);\n        }\n\n        return globalMin;\n    }\n    \n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        List<Integer> test1 = Arrays.asList(2, 3, 4, 1, 2, 4);\n        System.out.println(\"Test Case 1: \" + (solution.minSubArraySum(test1) == 1));\n        \n        List<Integer> test2 = Arrays.asList(-1, -2, -3);\n        System.out.println(\"Test Case 2: \" + (solution.minSubArraySum(test2) == -6));\n    }\n}\n"}
{"task_id": "Java/115", "generation": "import java.util.*;\n\nclass Solution {\n    public int max_fill(List<List<Integer>> grid, int capacity) {\n        if (grid == null || grid.isEmpty()) return 0;\n        \n        // Calculate the number of times buckets need to be lowered for each column.\n        int totalDrops = 0;\n        for (int col = 0; col < grid.get(0).size(); col++) {\n            int waterUnitsInColumn = 0;\n            for (List<Integer> row : grid) {\n                waterUnitsInColumn += row.get(col);\n            }\n            // Calculate the number of drops needed for this column.\n            totalDrops += Math.ceil((double) waterUnitsInColumn / capacity);\n        }\n\n        return totalDrops;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        List<List<Integer>> grid1 = Arrays.asList(\n                Arrays.asList(0, 0, 1, 0),\n                Arrays.asList(0, 1, 0, 0),\n                Arrays.asList(1, 1, 1, 1)\n        );\n        System.out.println(solution.max_fill(grid1, 1)); // Output: 6\n\n        List<List<Integer>> grid2 = Arrays.asList(\n                Arrays.asList(0, 0, 1, 1),\n                Arrays.asList(0, 0, 0, 0),\n                Arrays.asList(1, 1, 1, 1),\n                Arrays.asList(0, 1, 1, 1)\n        );\n        System.out.println(solution.max_fill(grid2, 2)); // Output: 5\n\n        List<List<Integer>> grid3 = Arrays.asList(\n                Arrays.asList(0, 0, 0),\n                Arrays.asList(0, 0, 0)\n        );\n        System.out.println(solution.max_fill(grid3, 5)); // Output: 0\n    }\n}\n"}
{"task_id": "Java/116", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Sorts an array of integers according to the number of ones in their binary representation.\n     * For numbers with a similar number of ones, they are sorted based on their decimal value.\n     *\n     * @param arr The list of integers to be sorted.\n     * @return A new list containing the elements of `arr` sorted as described.\n     */\n    public List<Integer> sort_array(List<Integer> arr) {\n        // Sort using a custom comparator\n        Collections.sort(arr, (a, b) -> {\n            int countA = Integer.bitCount(a);\n            int countB = Integer.bitCount(b);\n\n            if (countA != countB) {\n                return Integer.compare(countA, countB);  // Ascending order of number of ones.\n            } else {\n                return Integer.compare(a, b);  // Ascending order of decimal value for tie-breaker.\n            }\n        });\n\n        return arr;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        List<Integer> test1 = Arrays.asList(1, 5, 2, 3, 4);\n        System.out.println(solution.sort_array(new ArrayList<>(test1)).equals(Arrays.asList(1, 2, 4, 3, 5)));\n\n        List<Integer> test2 = Arrays.asList(-2, -3, -4, -5, -6);\n        System.out.println(solution.sort_array(new ArrayList<>(test2)).equals(Arrays.asList(-4, -2, -6, -5, -3)));\n\n        List<Integer> test3 = Arrays.asList(1, 0, 2, 3, 4);\n        System.out.println(solution.sort_array(new ArrayList<>(test3)).equals(Arrays.asList(0, 1, 2, 4, 3)));\n    }\n}\n"}
{"task_id": "Java/117", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<String> select_words(String s, int n) {\n        // Check if the string is empty or null\n        if (s == null || s.trim().isEmpty()) return new ArrayList<>();\n\n        // Split the string into words based on spaces\n        String[] words = s.split(\"\\\\s+\");\n\n        // Create a list to hold the result\n        List<String> result = new ArrayList<>();\n\n        for (String word : words) {\n            // Count consonants in each word\n            int countConsonants = 0;\n            for (char c : word.toCharArray()) {\n                if (!Character.isLetter(c)) continue; // Skip non-letter characters, though not expected per problem statement.\n                char lowerCaseChar = Character.toLowerCase(c);\n                if (!(lowerCaseChar == 'a' || lowerCaseChar == 'e' || lowerCaseChar == 'i' ||\n                      lowerCaseChar == 'o' || lowerCaseChar == 'u')) {\n                    countConsonants++;\n                }\n            }\n\n            // If the number of consonants matches n, add to result\n            if (countConsonants == n) {\n                result.add(word);\n            }\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.select_words(\"Mary had a little lamb\", 4)); // [\"little\"]\n        System.out.println(solution.select_words(\"Mary had a little lamb\", 3)); // [\"Mary\", \"lamb\"]\n        System.out.println(solution.select_words(\"simple white space\", 2));     // []\n        System.out.println(solution.select_words(\"Hello world\", 4));            // [\"world\"]\n        System.out.println(solution.select_words(\"Uncle sam\", 3));              // [\"Uncle\"]\n    }\n}\n"}
{"task_id": "Java/118", "generation": "import java.util.*;\n\nclass Solution {\n    public String get_closest_vowel(String word) {\n        if (word == null || word.length() < 3) return \"\";\n        \n        // Convert the string to a char array for easier manipulation.\n        char[] chars = word.toCharArray();\n        int len = chars.length;\n        \n        // Iterate from right to left, looking for the pattern consonant-vowel-consonant\n        for (int i = len - 2; i > 0; i--) {\n            if (!isVowel(chars[i + 1]) && isVowel(chars[i]) && !isVowel(chars[i - 1])) {\n                return String.valueOf(chars[i]);\n            }\n        }\n\n        // If no vowel found that meets the condition, return an empty string.\n        return \"\";\n    }\n\n    private boolean isVowel(char c) {\n        return \"AEIOUaeiou\".indexOf(c) != -1;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.get_closest_vowel(\"yogurt\"));  // Expected: \"u\"\n        System.out.println(solution.get_closest_vowel(\"FULL\"));    // Expected: \"U\"\n        System.out.println(solution.get_closest_vowel(\"quick\"));   // Expected: \"\"\n        System.out.println(solution.get_closest_vowel(\"ab\"));      // Expected: \"\"\n        System.out.println(solution.get_closest_vowel(\"aeroplane\"));// Expected: \"o\"\n    }\n}\n"}
{"task_id": "Java/119", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Checks if it's possible to concatenate two strings in some order so that all parentheses are balanced.\n     *\n     * @param lst List containing two strings of parentheses.\n     * @return \"Yes\" if there is a way to make a good string, and \"No\" otherwise.\n     */\n    public String match_parens(List<String> lst) {\n        // Counters for open and close parentheses in both strings\n        int open1 = 0, close1 = 0;\n        int open2 = 0, close2 = 0;\n\n        // Count the number of open and close parentheses in each string\n        for (char c : lst.get(0).toCharArray()) {\n            if (c == '(') open1++;\n            else close1++;\n        }\n        for (char c : lst.get(1).toCharArray()) {\n            if (c == '(') open2++;\n            else close2++;\n        }\n\n        // Check both possible concatenations\n        boolean canConcatenate = (open1 >= close2 && open2 >= close1) || (open2 >= close1 && open1 >= close2);\n\n        return canConcatenate ? \"Yes\" : \"No\";\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.match_parens(Arrays.asList(\"()(\", \")\")));  // Expected: Yes\n        System.out.println(solution.match_parens(Arrays.asList(\")\", \")\")));     // Expected: No\n        System.out.println(solution.match_parens(Arrays.asList(\"(()\", \"())\"))); // Expected: Yes\n        System.out.println(solution.match_parens(Arrays.asList(\"))(\", \"(\")));   // Expected: No\n    }\n}\n"}
{"task_id": "Java/120", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given an array arr of integers and a positive integer k, return a sorted list\n     * of length k with the maximum k numbers in arr, in ascending order.\n     */\n    public List<Integer> maximum(List<Integer> arr, int k) {\n        // Sort the list in ascending order\n        Collections.sort(arr);\n        \n        // Create a new list to store the result\n        List<Integer> result = new ArrayList<>();\n        \n        // Extract the last k elements from the sorted list\n        for (int i = arr.size() - 1; i >= arr.size() - k && i >= 0; i--) {\n            result.add(arr.get(i));\n        }\n        \n        // Sort the result in ascending order before returning\n        Collections.sort(result);\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        List<Integer> test1 = Arrays.asList(-3, -4, 5);\n        System.out.println(solution.maximum(test1, 3)); // Expected: [-4, -3, 5]\n        \n        List<Integer> test2 = Arrays.asList(4, -4, 4);\n        System.out.println(solution.maximum(test2, 2)); // Expected: [4, 4]\n        \n        List<Integer> test3 = Arrays.asList(-3, 2, 1, 2, -1, -2, 1);\n        System.out.println(solution.maximum(test3, 1)); // Expected: [2]\n    }\n}\n"}
{"task_id": "Java/121", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n     *\n     * @param lst The input list of integers.\n     * @return The sum of all odd elements at even positions.\n     */\n    public int solution(List<Integer> lst) {\n        int sum = 0;\n        \n        // Iterate through the list, considering only even indices (0-based)\n        for (int i = 0; i < lst.size(); i += 2) {\n            if (lst.get(i) % 2 != 0) { // Check if the element is odd\n                sum += lst.get(i);\n            }\n        }\n\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n\n        // Test cases\n        System.out.println(sol.solution(Arrays.asList(5, 8, 7, 1))); // Should print: 12\n        System.out.println(sol.solution(Arrays.asList(3, 3, 3, 3, 3))); // Should print: 9\n        System.out.println(sol.solution(Arrays.asList(30, 13, 24, 321))); // Should print: 0\n    }\n}\n"}
{"task_id": "Java/122", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given a non-empty array of integers arr and an integer k,\n     * return the sum of the elements with at most two digits from the first k elements of arr.\n     *\n     * @param arr List<Integer> - The input list of integers.\n     * @param k int - The number of elements to consider from the start of the array.\n     * @return int - Sum of elements with at most two digits among the first k elements.\n     */\n    public int add_elements(List<Integer> arr, int k) {\n        int sum = 0;\n        for (int i = 0; i < k; i++) {\n            if (arr.get(i) >= -99 && arr.get(i) <= 99) { // Check if the number has at most two digits\n                sum += arr.get(i);\n            }\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        List<Integer> test1 = Arrays.asList(111, 21, 3, 4000, 5, 6, 7, 8, 9);\n        System.out.println(solution.add_elements(test1, 4)); // Expected output: 24\n        \n        List<Integer> test2 = Arrays.asList(-10, -20, 30, 40, 50, 60, 70, 80, 90);\n        System.out.println(solution.add_elements(test2, 9)); // Expected output: 270\n        \n        List<Integer> test3 = Arrays.asList(100, 200, 300, 400, 50, -60, 70, 80);\n        System.out.println(solution.add_elements(test3, 8)); // Expected output: 40\n        \n        List<Integer> test4 = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9);\n        System.out.println(solution.add_elements(test4, 9)); // Expected output: 45\n    }\n}\n"}
{"task_id": "Java/123", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n     */\n    public List<Integer> get_odd_collatz(int n) {\n        Set<Integer> oddNumbers = new LinkedHashSet<>();\n        \n        while (n != 1) {\n            if (n % 2 == 1) { // Check if n is odd\n                oddNumbers.add(n);\n            }\n            n = n % 2 == 0 ? n / 2 : 3 * n + 1; // Collatz sequence rule\n        }\n        \n        oddNumbers.add(1); // Add the final number in the sequence, which is always 1\n        \n        List<Integer> result = new ArrayList<>(oddNumbers);\n        Collections.sort(result); // Sort the list in increasing order\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.get_odd_collatz(5)); // Expected: [1, 5]\n        System.out.println(solution.get_odd_collatz(7)); // Expected: [1, 7, 11, 22, 34, 52, 80, 121]\n        System.out.println(solution.get_odd_collatz(1)); // Expected: [1]\n    }\n}\n"}
{"task_id": "Java/124", "generation": "import java.util.*;\n\nclass Solution {\n    public boolean valid_date(String date) {\n        // Check if the date string is empty or not in the correct format\n        if (date == null || !date.matches(\"\\\\d{2}-\\\\d{2}-\\\\d{4}\")) return false;\n\n        String[] parts = date.split(\"-\");\n        \n        int month = Integer.parseInt(parts[0]);\n        int day = Integer.parseInt(parts[1]);\n        int year = Integer.parseInt(parts[2]);\n\n        // Check if the month is valid\n        if (month < 1 || month > 12) return false;\n\n        // Check days based on months and leap years for February\n        boolean isLeapYear = (year % 4 == 0 && year % 100 != 0) || (year % 400 == 0);\n        \n        if ((month == 4 || month == 6 || month == 9 || month == 11) && day > 30) return false;\n        else if (month == 2) {\n            if (isLeapYear && day > 29) return false;\n            else if (!isLeapYear && day > 28) return false;\n        } else if (day < 1 || day > 31) return false;\n\n        // If all checks pass, the date is valid\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.valid_date(\"03-11-2000\")); // Expected: true\n        System.out.println(solution.valid_date(\"15-01-2012\")); // Expected: false\n        System.out.println(solution.valid_date(\"04-0-2040\"));  // Expected: false\n        System.out.println(solution.valid_date(\"06-04-2020\")); // Expected: true\n        System.out.println(solution.valid_date(\"06/04/2020\")); // Expected: false\n    }\n}\n"}
{"task_id": "Java/125", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n     * should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n     * alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n     */\n    public Object split_words(String txt) {\n        // Check for whitespace and split on it if present\n        if (txt.contains(\" \")) {\n            return Arrays.asList(txt.split(\"\\\\s+\"));\n        }\n        \n        // If no whitespaces exist, check for commas and split on them if present\n        else if (txt.contains(\",\")) {\n            return Arrays.asList(txt.split(\",\"));\n        }\n\n        // If neither whitespace nor comma exists, count the number of lowercase letters with odd order in the alphabet\n        int count = 0;\n        for (char c : txt.toCharArray()) {\n            if (Character.isLowerCase(c) && ((c - 'a') % 2 == 1)) {\n                count++;\n            }\n        }\n        \n        return count;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.split_words(\"Hello world!\")); // Expected: [Hello, world!]\n        System.out.println(solution.split_words(\"Hello,world!\")); // Expected: [Hello, world!]\n        System.out.println(solution.split_words(\"abcdef\"));       // Expected: 3\n\n        // Additional test cases\n        System.out.println(solution.split_words(\"a,b,c,d,e,f\")); // Expected: [a, b, c, d, e, f]\n        System.out.println(solution.split_words(\"abc def ghi,jkl mno,pqr stu,vwx,yz\")); // Expected: [abc, def, ghi, jkl, mno, pqr, stu, vwx, yz]\n    }\n}\n"}
{"task_id": "Java/126", "generation": "import java.util.*;\n\nclass Solution {\n    public boolean is_sorted(List<Integer> lst) {\n        // Check if list is empty or has only one element, it's sorted.\n        if (lst.size() <= 1) return true;\n\n        Map<Integer, Integer> countMap = new HashMap<>();\n        \n        for (int i = 0; i < lst.size(); i++) {\n            int num = lst.get(i);\n            \n            // Check for ascending order\n            if (i > 0 && lst.get(i - 1) > num) return false;\n            \n            // Count occurrences of each number\n            countMap.put(num, countMap.getOrDefault(num, 0) + 1);\n            \n            // If any number appears more than twice, return false.\n            if (countMap.get(num) > 2) return false;\n        }\n        \n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.is_sorted(Arrays.asList(5))); // -> true\n        System.out.println(solution.is_sorted(Arrays.asList(1, 2, 3, 4, 5))); // -> true\n        System.out.println(solution.is_sorted(Arrays.asList(1, 3, 2, 4, 5))); // -> false\n        System.out.println(solution.is_sorted(Arrays.asList(1, 2, 3, 4, 5, 6))); // -> true\n        System.out.println(solution.is_sorted(Arrays.asList(1, 2, 3, 4, 5, 6, 7))); // -> true\n        System.out.println(solution.is_sorted(Arrays.asList(1, 3, 2, 4, 5, 6, 7))); // -> false\n        System.out.println(solution.is_sorted(Arrays.asList(1, 2, 2, 3, 3, 4))); // -> true\n        System.out.println(solution.is_sorted(Arrays.asList(1, 2, 2, 2, 3, 4))); // -> false\n    }\n}\n"}
{"task_id": "Java/127", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Determines whether the length of intersection of two given intervals is a prime number.\n     *\n     * @param interval1 The first interval as a list containing start and end.\n     * @param interval2 The second interval as a list containing start and end.\n     * @return \"YES\" if the length of the intersection is a prime number, otherwise \"NO\".\n     */\n    public String intersection(List<Integer> interval1, List<Integer> interval2) {\n        int startMax = Math.max(interval1.get(0), interval2.get(0));\n        int endMin = Math.min(interval1.get(1), interval2.get(1));\n\n        // If there is no intersection\n        if (startMax > endMin) return \"NO\";\n\n        // Calculate the length of the intersection\n        int intersectionLength = endMin - startMax + 1;\n\n        // Check if the length is a prime number\n        if (isPrime(intersectionLength)) {\n            return \"YES\";\n        } else {\n            return \"NO\";\n        }\n    }\n\n    /**\n     * Helper method to check if a number is prime.\n     *\n     * @param num The number to check.\n     * @return true if the number is prime, false otherwise.\n     */\n    private boolean isPrime(int num) {\n        if (num <= 1) return false;\n        for (int i = 2; i <= Math.sqrt(num); i++) {\n            if (num % i == 0) return false;\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.intersection(Arrays.asList(1, 2), Arrays.asList(2, 3))); // \"NO\"\n        System.out.println(solution.intersection(Arrays.asList(-1, 1), Arrays.asList(0, 4))); // \"NO\"\n        System.out.println(solution.intersection(Arrays.asList(-3, -1), Arrays.asList(-5, 5))); // \"YES\"\n    }\n}\n"}
{"task_id": "Java/128", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * You are given an array arr of integers and you need to return\n     * sum of magnitudes of integers multiplied by product of all signs\n     * of each number in the array, represented by 1, -1 or 0.\n     * Note: return None for empty arr.\n     *\n     * Example:\n     * >>> prod_signs(Arrays.asList(1, 2, 2, -4)) == Optional.of(-9)\n     * >>> prod_signs(Arrays.asList(0, 1)) == Optional.of(0)\n     * >>> prod_signs(Arrays.asList()) == Optional.empty()\n     */\n    public Optional<Integer> prod_signs(List<Integer> arr) {\n        if (arr.isEmpty()) return Optional.empty();\n\n        int sumOfMagnitudes = 0;\n        int productOfSigns = 1;\n\n        for (int num : arr) {\n            sumOfMagnitudes += Math.abs(num);\n            if (num == 0) {\n                productOfSigns = 0;\n                break; // If there's a zero, the product of signs will be zero.\n            } else if (num < 0) {\n                productOfSigns *= -1;\n            }\n        }\n\n        return Optional.of(sumOfMagnitudes * productOfSigns);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.prod_signs(Arrays.asList(1, 2, 2, -4))); // Expected: Optional[-9]\n        System.out.println(solution.prod_signs(Arrays.asList(0, 1)));         // Expected: Optional[0]\n        System.out.println(solution.prod_signs(Arrays.asList()));             // Expected: Optional.empty\n    }\n}\n"}
{"task_id": "Java/129", "generation": "import java.util.*;\n\nclass Solution {\n    private int N;\n    private List<Integer> minPath = new ArrayList<>();\n    private boolean[][] visited;\n\n    public List<Integer> minPath(List<List<Integer>> grid, int k) {\n        this.N = (int)Math.sqrt(grid.size());\n        this.visited = new boolean[N][N];\n        \n        // Initialize the minimum path with a large value to ensure any valid path will be smaller\n        for (int i = 0; i < k; ++i) minPath.add(Integer.MAX_VALUE);\n\n        // Start DFS from every cell in the grid\n        for (int row = 0; row < N; ++row) {\n            for (int col = 0; col < N; ++col) {\n                List<Integer> currentPath = new ArrayList<>();\n                dfs(grid, row, col, k, currentPath);\n            }\n        }\n\n        return minPath;\n    }\n\n    private void dfs(List<List<Integer>> grid, int row, int col, int stepsLeft, List<Integer> path) {\n        // If we have visited this cell in the current path or it's out of bounds\n        if (row < 0 || col < 0 || row >= N || col >= N || visited[row][col]) return;\n\n        // Add the current cell value to the path\n        path.add(grid.get(row).get(col));\n\n        // Mark this cell as visited for the current path\n        visited[row][col] = true;\n\n        if (stepsLeft == 1) {\n            // If we have reached the required length, check if it's a new minimum path\n            if (isSmaller(path)) minPath = new ArrayList<>(path);\n        } else {\n            // Explore all possible moves from this cell\n            dfs(grid, row + 1, col, stepsLeft - 1, path); // Down\n            dfs(grid, row - 1, col, stepsLeft - 1, path); // Up\n            dfs(grid, row, col + 1, stepsLeft - 1, path); // Right\n            dfs(grid, row, col - 1, stepsLeft - 1, path); // Left\n        }\n\n        // Backtrack: remove the current cell value from the path and unmark it as visited\n        path.remove(path.size() - 1);\n        visited[row][col] = false;\n    }\n\n    private boolean isSmaller(List<Integer> path) {\n        for (int i = 0; i < minPath.size(); ++i) {\n            if (path.get(i).compareTo(minPath.get(i)) > 0) return false;\n            else if (path.get(i).compareTo(minPath.get(i)) < 0) return true;\n        }\n        return false;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        \n        // Test case 1\n        List<List<Integer>> grid1 = Arrays.asList(\n            Arrays.asList(1, 2, 3),\n            Arrays.asList(4, 5, 6),\n            Arrays.asList(7, 8, 9)\n        );\n        int k1 = 3;\n        System.out.println(sol.minPath(grid1, k1)); // Expected: [1, 2, 1]\n\n        // Test case 2\n        List<List<Integer>> grid2 = Arrays.asList(\n            Arrays.asList(5, 9, 3),\n            Arrays.asList(4, 1, 6),\n            Arrays.asList(7, 8, 2)\n        );\n        int k2 = 1;\n        System.out.println(sol.minPath(grid2, k2)); // Expected: [1]\n    }\n}\n"}
{"task_id": "Java/130", "generation": "import java.util.*;\n\nclass Solution {\n    public List<Integer> tri(int n) {\n        // Base cases as per definition\n        int[] baseCases = {1, 3, 2};\n        \n        if (n < 3) {\n            return Arrays.stream(baseCases).limit(n + 1).boxed().collect(Collectors.toList());\n        }\n        \n        List<Integer> result = new ArrayList<>(Arrays.asList(1, 3, 2));\n        \n        for (int i = 3; i <= n; i++) {\n            if (i % 2 == 0) {\n                // For even numbers\n                result.add(1 + i / 2);\n            } else {\n                // For odd numbers\n                int nextValue = result.get(i - 1) + result.get(i - 2) + result.get(i - 3);\n                result.add(nextValue);\n            }\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.tri(0)); // Expected: [1]\n        System.out.println(solution.tri(1)); // Expected: [1, 3]\n        System.out.println(solution.tri(2)); // Expected: [1, 3, 2]\n        System.out.println(solution.tri(3)); // Expected: [1, 3, 2, 8]\n    }\n}\n"}
{"task_id": "Java/131", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    \n    /**\n     * Given a positive integer n, return the product of the odd digits.\n     * Return 0 if all digits are even.\n     */\n    public int digits(int n) {\n        int product = 1;\n        boolean hasOddDigit = false;\n\n        while (n > 0) {\n            int digit = n % 10; // Get the last digit\n            if (digit % 2 != 0) { // Check if it's odd\n                product *= digit;\n                hasOddDigit = true;\n            }\n            n /= 10; // Remove the last digit\n        }\n\n        return hasOddDigit ? product : 0;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.digits(1));   // Expected output: 1\n        System.out.println(solution.digits(4));   // Expected output: 0\n        System.out.println(solution.digits(235)); // Expected output: 15\n        System.out.println(solution.digits(684)); // Expected output: 0\n        System.out.println(solution.digits(793)); // Expected output: 189 (7*9*3)\n    }\n}\n"}
{"task_id": "Java/132", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Checks if there is a valid subsequence of brackets where at least one bracket in the subsequence is nested.\n     *\n     * @param string The input string containing only square brackets.\n     * @return true if there exists at least one nested pair, false otherwise.\n     */\n    public boolean is_nested(String string) {\n        int balance = 0;\n        boolean hasNested = false;\n\n        for (char c : string.toCharArray()) {\n            if (c == '[') {\n                balance++;\n            } else if (c == ']') {\n                balance--;\n                // If we find a closing bracket and the balance is greater than zero,\n                // it means there was an opening bracket before, indicating nesting.\n                if (balance > 0) {\n                    hasNested = true;\n                }\n            }\n\n            // Early exit if balance goes negative\n            if (balance < 0) return false;\n        }\n\n        return hasNested && balance == 0;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.is_nested(\"[[]]\")); // true\n        System.out.println(solution.is_nested(\"[]]]]]]][[[[[]\")); // false\n        System.out.println(solution.is_nested(\"[][]\")); // false\n        System.out.println(solution.is_nested(\"[]\")); // false\n        System.out.println(solution.is_nested(\"[[][]]\")); // true\n        System.out.println(solution.is_nested(\"[[]][[\")); // true\n    }\n}\n"}
{"task_id": "Java/133", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int sum_squares(List<Double> lst) {\n        int sum = 0;\n        for (Double num : lst) {\n            // Round each element to the upper integer and square it.\n            int ceilNum = (int)Math.ceil(num);\n            sum += ceilNum * ceilNum;\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        List<Double> test1 = Arrays.asList(1.0, 2.0, 3.0); // Expected output: 14\n        System.out.println(solution.sum_squares(test1));\n\n        List<Double> test2 = Arrays.asList(1.0, 4.0, 9.0); // Expected output: 98\n        System.out.println(solution.sum_squares(test2));\n\n        List<Double> test3 = Arrays.asList(1.0, 3.0, 5.0, 7.0); // Expected output: 84\n        System.out.println(solution.sum_squares(test3));\n\n        List<Double> test4 = Arrays.asList(1.4, 4.2, 0.0); // Expected output: 29\n        System.out.println(solution.sum_squares(test4));\n\n        List<Double> test5 = Arrays.asList(-2.4, 1.0, 1.0); // Expected output: 6\n        System.out.println(solution.sum_squares(test5));\n    }\n}\n"}
{"task_id": "Java/134", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Create a function that returns true if the last character\n     * of a given string is an alphabetical character and is not\n     * a part of a word, and false otherwise.\n     * Note: \"word\" is a group of characters separated by space.\n     *\n     * Examples:\n     * check_if_last_char_is_a_letter(\"apple pie\") -> false\n     * check_if_last_char_is_a_letter(\"apple pi e\") -> true\n     * check_if_last_char_is_a_letter(\"apple pi e \") -> false\n     * check_if_last_char_is_a_letter(\"\") -> false\n     */\n    public boolean check_if_last_char_is_a_letter(String txt) {\n        if (txt == null || txt.length() == 0) return false;\n\n        int lastIndex = txt.length() - 1;\n        char lastChar = txt.charAt(lastIndex);\n\n        // Check if the last character is a letter and not part of a word\n        if (!Character.isLetter(lastChar)) {\n            return false;\n        }\n\n        // If there's only one character in the string, it must be a letter to return true.\n        if (txt.length() == 1) {\n            return true;\n        }\n\n        char secondLastChar = txt.charAt(lastIndex - 1);\n        return !Character.isLetter(secondLastChar); // Ensure it is not part of a word\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.check_if_last_char_is_a_letter(\"apple pie\")); // Expected: false\n        System.out.println(solution.check_if_last_char_is_a_letter(\"apple pi e\")); // Expected: true\n        System.out.println(solution.check_if_last_char_is_a_letter(\"apple pi e \")); // Expected: false\n        System.out.println(solution.check_if_last_char_is_a_letter(\"\")); // Expected: false\n    }\n}\n"}
{"task_id": "Java/135", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Create a function which returns the largest index of an element which\n     * is not greater than or equal to the element immediately preceding it.\n     * If no such element exists then return -1. The given array will not contain\n     * duplicate values.\n     *\n     * Examples:\n     * can_arrange(Arrays.asList(1,2,4,3,5)) = 3\n     * can_arrange(Arrays.asList(1,2,3)) = -1\n     */\n    public int can_arrange(List<Integer> arr) {\n        for (int i = arr.size() - 1; i > 0; --i) {\n            if (arr.get(i) < arr.get(i - 1)) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case 1\n        List<Integer> testList1 = Arrays.asList(1, 2, 4, 3, 5);\n        System.out.println(\"Test Case 1: \" + (solution.can_arrange(testList1) == 3 ? \"Pass\" : \"Fail\"));\n\n        // Test case 2\n        List<Integer> testList2 = Arrays.asList(1, 2, 3);\n        System.out.println(\"Test Case 2: \" + (solution.can_arrange(testList2) == -1 ? \"Pass\" : \"Fail\"));\n        \n        // Additional test cases can be added here as needed.\n    }\n}\n"}
{"task_id": "Java/136", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Optional<Integer>> largest_smallest_integers(List<Integer> lst) {\n        Optional<Integer> maxNegative = Optional.empty();\n        Optional<Integer> minPositive = Optional.empty();\n\n        for (Integer num : lst) {\n            if (num < 0 && (!maxNegative.isPresent() || num > maxNegative.get())) {\n                maxNegative = Optional.of(num);\n            } else if (num > 0 && (!minPositive.isPresent() || num < minPositive.get())) {\n                minPositive = Optional.of(num);\n            }\n        }\n\n        return Arrays.asList(maxNegative, minPositive);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        List<Integer> list1 = Arrays.asList(2, 4, 1, 3, 5, 7);\n        System.out.println(solution.largest_smallest_integers(list1)); // Expected: [Optional.empty(), Optional[1]]\n\n        // Test case 2\n        List<Integer> list2 = new ArrayList<>();\n        System.out.println(solution.largest_smallest_integers(list2)); // Expected: [Optional.empty(), Optional.empty()]\n\n        // Test case 3\n        List<Integer> list3 = Arrays.asList(0);\n        System.out.println(solution.largest_smallest_integers(list3)); // Expected: [Optional.empty(), Optional.empty()]\n\n        // Additional test cases\n        List<Integer> list4 = Arrays.asList(-1, -2, -3, -4);\n        System.out.println(solution.largest_smallest_integers(list4)); // Expected: [Optional[-1], Optional.empty()]\n\n        List<Integer> list5 = Arrays.asList(10, 9, 8, 7, 6, 5, 4, 3, 2, 1);\n        System.out.println(solution.largest_smallest_integers(list5)); // Expected: [Optional.empty(), Optional[1]]\n\n        List<Integer> list6 = Arrays.asList(-5, -10, 15, 20, 25, -15);\n        System.out.println(solution.largest_smallest_integers(list6)); // Expected: [Optional[-5], Optional[15]]\n    }\n}\n"}
{"task_id": "Java/137", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public Optional<Object> compare_one(Object a, Object b) {\n        double aValue = parseValue(a);\n        double bValue = parseValue(b);\n\n        if (aValue == bValue) {\n            return Optional.empty();\n        } else if (aValue > bValue) {\n            return Optional.of(a);\n        } else {\n            return Optional.of(b);\n        }\n    }\n\n    private double parseValue(Object value) {\n        if (value instanceof String) {\n            String str = ((String) value).replace(',', '.');\n            return Double.parseDouble(str);\n        } else if (value instanceof Integer) {\n            return ((Integer) value).doubleValue();\n        } else if (value instanceof Double) {\n            return (Double) value;\n        }\n        throw new IllegalArgumentException(\"Unsupported type\");\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.compare_one(1, 2.5)); // Optional.of(2.5)\n        System.out.println(solution.compare_one(1, \"2,3\")); // Optional.of(\"2,3\")\n        System.out.println(solution.compare_one(\"5,1\", \"6\")); // Optional.of(\"6\")\n        System.out.println(solution.compare_one(\"1\", 1)); // Optional.empty()\n    }\n}\n"}
{"task_id": "Java/138", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers.\n     *\n     * @param n The number to evaluate.\n     * @return true if n can be expressed as such a sum, false otherwise.\n     */\n    public boolean is_equalToSumEven(int n) {\n        // Since we're dealing with four even numbers, their minimum sum would be 2+2+2+2=8\n        // Any number less than 8 cannot be represented as the sum of exactly four positive even numbers.\n        if (n < 8) return false;\n\n        // If n is an even number and greater or equal to 8, it can always be expressed as a sum of four even numbers.\n        // This is because we can use 2+2+2+(n-6), where (n-6) must also be even for n to be even.\n        return n % 2 == 0;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.is_equalToSumEven(4)); // Expected: false\n        System.out.println(solution.is_equalToSumEven(6)); // Expected: false\n        System.out.println(solution.is_equalToSumEven(8)); // Expected: true\n        System.out.println(solution.is_equalToSumEven(10)); // Expected: true\n        System.out.println(solution.is_equalToSumEven(24)); // Expected: true\n    }\n}\n"}
{"task_id": "Java/139", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * The Brazilian factorial is defined as:\n     * brazilian_factorial(n) = n! * (n-1)! * ... * 1!\n     * where n > 0\n     *\n     * @param n the input integer\n     * @return the special factorial of this integer.\n     */\n    public long special_factorial(int n) {\n        if (n <= 0) return 0; // As per definition, n should be greater than 0\n\n        long result = 1;\n        for (int i = 1; i <= n; i++) {\n            result *= factorial(i);\n        }\n        return result;\n    }\n\n    private long factorial(int number) {\n        if (number == 0 || number == 1) return 1;\n\n        long fact = 1;\n        for (int i = 2; i <= number; i++) {\n            fact *= i;\n        }\n        return fact;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.special_factorial(4)); // Expected output: 288\n        System.out.println(solution.special_factorial(3)); // Expected output: 12\n        System.out.println(solution.special_factorial(5)); // Expected output: 34560\n    }\n}\n"}
{"task_id": "Java/140", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public String fix_spaces(String text) {\n        if (text == null || text.isEmpty()) return text;\n\n        StringBuilder result = new StringBuilder();\n        int spaceCount = 0;\n        \n        for (int i = 0; i < text.length(); i++) {\n            char c = text.charAt(i);\n            \n            if (c == ' ') {\n                spaceCount++;\n            } else {\n                if (spaceCount > 2) {\n                    result.append('-');\n                } else {\n                    while (spaceCount > 0) {\n                        result.append('_');\n                        spaceCount--;\n                    }\n                }\n                result.append(c);\n                spaceCount = 0;\n            }\n        }\n\n        // Handle trailing spaces\n        if (spaceCount > 2) {\n            result.append('-');\n        } else {\n            while (spaceCount > 0) {\n                result.append('_');\n                spaceCount--;\n            }\n        }\n\n        return result.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.fix_spaces(\"Example\"));       // \"Example\"\n        System.out.println(solution.fix_spaces(\"Example 1\"));     // \"Example_1\"\n        System.out.println(solution.fix_spaces(\" Example 2\"));    // \"_Example_2\"\n        System.out.println(solution.fix_spaces(\" Example   3\"));  // \"_Example-3\"\n        System.out.println(solution.fix_spaces(\"  Leading spaces\")); // \"__Leading_spaces\"\n        System.out.println(solution.fix_spaces(\"Trailing spaces  \")); // \"Trailing_spaces__\"\n    }\n}\n"}
{"task_id": "Java/141", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Checks if a given filename meets certain criteria.\n     *\n     * @param file_name The name of the file as a String.\n     * @return \"Yes\" if the filename is valid, otherwise \"No\".\n     */\n    public String file_name_check(String file_name) {\n        // Check for exactly one dot in the string\n        int dotCount = 0;\n        for (char c : file_name.toCharArray()) {\n            if (c == '.') dotCount++;\n        }\n        if (dotCount != 1) return \"No\";\n\n        // Split the filename into two parts: before and after the dot\n        String[] parts = file_name.split(\"\\\\.\");\n        if (parts.length != 2 || parts[0].isEmpty()) return \"No\";\n        \n        // Check for valid extension\n        Set<String> validExtensions = new HashSet<>(Arrays.asList(\"txt\", \"exe\", \"dll\"));\n        if (!validExtensions.contains(parts[1])) return \"No\";\n\n        // Check the first part of the filename\n        int digitCount = 0;\n        char firstChar = parts[0].charAt(0);\n        for (char c : parts[0].toCharArray()) {\n            if (Character.isDigit(c)) digitCount++;\n        }\n        if (!Character.isLetter(firstChar) || digitCount > 3) return \"No\";\n\n        // If all checks pass, the filename is valid\n        return \"Yes\";\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.file_name_check(\"example.txt\"));   // Expected: Yes\n        System.out.println(solution.file_name_check(\"1example.dll\"));  // Expected: No\n        System.out.println(solution.file_name_check(\"test.abc\"));      // Expected: No\n        System.out.println(solution.file_name_check(\".txt\"));          // Expected: No\n        System.out.println(solution.file_name_check(\"a2b3c4.txt\"));    // Expected: Yes\n        System.out.println(solution.file_name_check(\"a1234.dll\"));     // Expected: No\n        System.out.println(solution.file_name_check(\"test.exe.\"));     // Expected: No\n        System.out.println(solution.file_name_check(\"t123xt.dll\"));    // Expected: Yes\n    }\n}\n"}
{"task_id": "Java/142", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * This function takes a list of integers and modifies them based on their index:\n     * - Squares the integer if its index is a multiple of 3.\n     * - Cubes the integer if its index is a multiple of 4 but not a multiple of 3.\n     * It then returns the sum of all entries in the modified list.\n     */\n    public int sum_squares(List<Integer> lst) {\n        int sum = 0;\n        \n        for (int i = 0; i < lst.size(); i++) {\n            if (i % 3 == 0 && i != 0) { // Check if index is a multiple of 3 and not zero\n                sum += Math.pow(lst.get(i), 2);\n            } else if (i % 4 == 0) { // Check if index is a multiple of 4\n                sum += Math.pow(lst.get(i), 3);\n            } else {\n                sum += lst.get(i); // Add the integer as it is, if no condition matches\n            }\n        }\n\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        List<Integer> test1 = Arrays.asList(1, 2, 3);\n        System.out.println(\"Test 1: \" + (solution.sum_squares(test1) == 6 ? \"Pass\" : \"Fail\"));\n\n        List<Integer> test2 = new ArrayList<>();\n        System.out.println(\"Test 2: \" + (solution.sum_squares(test2) == 0 ? \"Pass\" : \"Fail\"));\n        \n        List<Integer> test3 = Arrays.asList(-1, -5, 2, -1, -5);\n        System.out.println(\"Test 3: \" + (solution.sum_squares(test3) == -126 ? \"Pass\" : \"Fail\"));\n\n        // Additional tests\n        List<Integer> test4 = Arrays.asList(0, 1, 2, 3, 4, 5);\n        System.out.println(\"Test 4: \" + solution.sum_squares(test4));\n        \n        List<Integer> test5 = Arrays.asList(-2, -3, -4, -5, -6);\n        System.out.println(\"Test 5: \" + solution.sum_squares(test5));\n    }\n}\n"}
{"task_id": "Java/143", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Checks if a number is prime.\n     */\n    private boolean isPrime(int n) {\n        if (n <= 1) return false;\n        for (int i = 2; i * i <= n; i++) {\n            if (n % i == 0) return false;\n        }\n        return true;\n    }\n\n    /**\n     * Returns a string containing only those words whose lengths are prime numbers.\n     */\n    public String words_in_sentence(String sentence) {\n        StringBuilder result = new StringBuilder();\n        for (String word : sentence.split(\" \")) {\n            if (isPrime(word.length())) {\n                if (result.length() > 0) {\n                    result.append(\" \");\n                }\n                result.append(word);\n            }\n        }\n        return result.toString();\n    }\n\n    /**\n     * Test cases to verify the solution.\n     */\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n\n        // Example 1\n        String sentence1 = \"This is a test\";\n        System.out.println(sol.words_in_sentence(sentence1)); // Expected: \"is\"\n\n        // Example 2\n        String sentence2 = \"lets go for swimming\";\n        System.out.println(sol.words_in_sentence(sentence2)); // Expected: \"go for\"\n\n        // Additional Test Cases\n        String sentence3 = \"Hello World\";\n        System.out.println(sol.words_in_sentence(sentence3)); // Expected: \"\"\n\n        String sentence4 = \"I am learning Java\";\n        System.out.println(sol.words_in_sentence(sentence4)); // Expected: \"am\"\n    }\n}\n"}
{"task_id": "Java/144", "generation": "class Solution {\n    public boolean simplify(String x, String n) {\n        // Parse the fractions\n        String[] partsX = x.split(\"/\");\n        int numeratorX = Integer.parseInt(partsX[0]);\n        int denominatorX = Integer.parseInt(partsX[1]);\n\n        String[] partsN = n.split(\"/\");\n        int numeratorN = Integer.parseInt(partsN[0]);\n        int denominatorN = Integer.parseInt(partsN[1]);\n\n        // Multiply the fractions\n        int resultNumerator = numeratorX * numeratorN;\n        int resultDenominator = denominatorX * denominatorN;\n\n        // Check if the result is a whole number\n        return (resultNumerator % resultDenominator == 0);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.simplify(\"1/5\", \"5/1\")); // true, because 1 * 5 / 5 * 1 is a whole number (1)\n        System.out.println(solution.simplify(\"1/6\", \"2/1\")); // false, because 1 * 2 / 6 * 1 is not a whole number\n        System.out.println(solution.simplify(\"7/10\", \"10/2\")); // false, because 7 * 10 / 10 * 2 is not a whole number (3.5)\n    }\n}\n"}
{"task_id": "Java/145", "generation": "import java.util.*;\n\nclass Solution {\n    public List<Integer> order_by_points(List<Integer> nums) {\n        // Create an array of pairs (index, number)\n        int[][] indexedNums = new int[nums.size()][2];\n        for (int i = 0; i < nums.size(); i++) {\n            indexedNums[i][0] = i;\n            indexedNums[i][1] = nums.get(i);\n        }\n\n        // Sort the array based on digit sum and then by original index\n        Arrays.sort(indexedNums, new Comparator<int[]>() {\n            @Override\n            public int compare(int[] o1, int[] o2) {\n                int sum1 = getDigitSum(o1[1]);\n                int sum2 = getDigitSum(o2[1]);\n                if (sum1 != sum2) return Integer.compare(sum1, sum2);\n                else return Integer.compare(o1[0], o2[0]);\n            }\n        });\n\n        // Extract the sorted numbers\n        List<Integer> result = new ArrayList<>();\n        for (int[] pair : indexedNums) {\n            result.add(pair[1]);\n        }\n\n        return result;\n    }\n\n    private int getDigitSum(int num) {\n        int sum = 0;\n        boolean isNegative = num < 0;\n        while (num != 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n        // If the number was negative, subtract twice the first digit\n        if (isNegative) {\n            sum -= 2 * ((int)Math.abs(num) % 10);\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        List<Integer> test1 = Arrays.asList(1, 11, -1, -11, -12);\n        List<Integer> expected1 = Arrays.asList(-1, -11, 1, -12, 11);\n        System.out.println(solution.order_by_points(test1).equals(expected1));\n\n        List<Integer> test2 = new ArrayList<>();\n        List<Integer> expected2 = new ArrayList<>();\n        System.out.println(solution.order_by_points(test2).equals(expected2));\n    }\n}\n"}
{"task_id": "Java/146", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Write a function that takes an array of numbers as input and returns\n     * the number of elements in the array that are greater than 10 and both\n     * first and last digits of a number are odd (1, 3, 5, 7, 9).\n     *\n     * @param nums List of integers to be filtered.\n     * @return The count of numbers meeting the criteria.\n     */\n    public int specialFilter(List<Integer> nums) {\n        return (int) nums.stream()\n                .filter(num -> num > 10 && isFirstAndLastDigitOdd(Math.abs(num)))\n                .count();\n    }\n\n    private boolean isFirstAndLastDigitOdd(int num) {\n        String strNum = Integer.toString(num);\n        int firstDigit = Character.getNumericValue(strNum.charAt(0));\n        int lastDigit = Character.getNumericValue(strNum.charAt(strNum.length() - 1));\n        return (firstDigit % 2 != 0) && (lastDigit % 2 != 0);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.specialFilter(Arrays.asList(15, -73, 14, -15))); // Expected output: 1\n        System.out.println(solution.specialFilter(Arrays.asList(33, -2, -3, 45, 21, 109))); // Expected output: 2\n    }\n}\n"}
{"task_id": "Java/147", "generation": "class Solution {\n    public int get_max_triples(int n) {\n        // Create an array based on the given formula.\n        int[] a = new int[n];\n        for (int i = 0; i < n; ++i) {\n            a[i] = (i + 1) * (i + 1) - (i + 1) + 1;\n        }\n\n        // Count triples where the sum is divisible by 3.\n        int count = 0;\n        for (int i = 0; i < n; ++i) {\n            for (int j = i + 1; j < n; ++j) {\n                for (int k = j + 1; k < n; ++k) {\n                    if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                        count++;\n                    }\n                }\n            }\n        }\n\n        return count;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.get_max_triples(5)); // Expected output: 1\n        System.out.println(solution.get_max_triples(6)); // Example for additional test case\n    }\n}\n"}
{"task_id": "Java/148", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Returns a list of planet names that are located between the orbits of planet1 and planet2.\n     */\n    public List<String> bf(String planet1, String planet2) {\n        // Define an ordered list of planets from closest to farthest from the Sun.\n        List<String> planets = Arrays.asList(\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\");\n\n        // Check if both planet names are valid\n        if (!planets.contains(planet1) || !planets.contains(planet2)) {\n            return Collections.emptyList();\n        }\n\n        int index1 = planets.indexOf(planet1);\n        int index2 = planets.indexOf(planet2);\n\n        // Ensure index1 is less than index2 for simplicity in slicing the list\n        if (index1 > index2) {\n            int temp = index1;\n            index1 = index2;\n            index2 = temp;\n        }\n\n        // Return the sublist of planets between index1 and index2, excluding the endpoints.\n        return planets.subList(index1 + 1, index2);\n    }\n    \n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.bf(\"Jupiter\", \"Neptune\")); // Expected: [Saturn, Uranus]\n        System.out.println(solution.bf(\"Earth\", \"Mercury\"));   // Expected: [Venus]\n        System.out.println(solution.bf(\"Mercury\", \"Uranus\"));  // Expected: [Venus, Earth, Mars, Jupiter, Saturn]\n    }\n}\n"}
{"task_id": "Java/149", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Write a function that accepts a list of strings as a parameter,\n     * deletes the strings that have odd lengths from it,\n     * and returns the resulted list with a sorted order.\n     * The list is always a list of strings and never an array of numbers,\n     * and it may contain duplicates.\n     * The order of the list should be ascending by length of each word, and you\n     * should return the list sorted by that rule.\n     * If two words have the same length, sort the list alphabetically.\n     * The function should return a list of strings in sorted order.\n     *\n     * @param lst List of strings to process.\n     * @return Sorted list with even-length strings only.\n     */\n    public List<String> sorted_list_sum(List<String> lst) {\n        // Filter out odd length strings\n        List<String> filteredList = new ArrayList<>();\n        for (String s : lst) {\n            if (s.length() % 2 == 0) {\n                filteredList.add(s);\n            }\n        }\n\n        // Sort the list by length, then alphabetically\n        Collections.sort(filteredList, new Comparator<String>() {\n            public int compare(String s1, String s2) {\n                int lenCompare = Integer.compare(s1.length(), s2.length());\n                if (lenCompare != 0) return lenCompare;\n                else return s1.compareTo(s2);\n            }\n        });\n\n        return filteredList;\n    }\n\n    // Test cases to verify the solution\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n\n        List<String> test1 = Arrays.asList(\"aa\", \"a\", \"aaa\");\n        System.out.println(sol.sorted_list_sum(test1));  // Expected: [aa]\n\n        List<String> test2 = Arrays.asList(\"ab\", \"a\", \"aaa\", \"cd\");\n        System.out.println(sol.sorted_list_sum(test2));  // Expected: [ab, cd]\n        \n        List<String> test3 = Arrays.asList(\"abcd\", \"efgh\", \"ijkl\", \"mnop\");\n        System.out.println(sol.sorted_list_sum(test3));  // Expected: [abcd, efgh, ijkl, mnop]\n\n        List<String> test4 = Arrays.asList(\"a\", \"bb\", \"ccc\", \"dddd\", \"eeeee\", \"ffffff\");\n        System.out.println(sol.sorted_list_sum(test4));  // Expected: [bb, dddd, ffffff]\n    }\n}\n"}
{"task_id": "Java/150", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * A simple program which should return the value of x if n is\n     * a prime number and should return the value of y otherwise.\n     *\n     * Examples:\n     * for x_or_y(7, 34, 12) == 34\n     * for x_or_y(15, 8, 5) == 5\n     */\n    public int x_or_y(int n, int x, int y) {\n        if (isPrime(n)) {\n            return x;\n        } else {\n            return y;\n        }\n    }\n\n    private boolean isPrime(int number) {\n        if (number <= 1) {\n            return false;\n        }\n        for (int i = 2; i * i <= number; i++) {\n            if (number % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.x_or_y(7, 34, 12)); // Expected output: 34\n        System.out.println(solution.x_or_y(15, 8, 5));  // Expected output: 5\n        System.out.println(solution.x_or_y(11, 99, 10)); // Expected output: 99\n        System.out.println(solution.x_or_y(4, 23, 7));   // Expected output: 7\n    }\n}\n"}
{"task_id": "Java/151", "generation": "import java.util.*;\n\nclass Solution {\n    public int sumOfSquaresOfOdds(List<Object> lst) {\n        return lst.stream()\n                .filter(o -> o instanceof Integer)\n                .mapToInt(o -> (Integer) o)\n                .filter(i -> i > 0 && i % 2 != 0)\n                .map(i -> i * i)\n                .sum();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.sumOfSquaresOfOdds(Arrays.asList(1, 3, 2, 0))); // Expected output: 10\n        System.out.println(solution.sumOfSquaresOfOdds(Arrays.asList(-1, -2, 0)));   // Expected output: 0\n        System.out.println(solution.sumOfSquaresOfOdds(Arrays.asList(9, -2)));       // Expected output: 81\n        System.out.println(solution.sumOfSquaresOfOdds(Arrays.asList(0)));           // Expected output: 0\n        System.out.println(solution.sumOfSquaresOfOdds(new ArrayList<>()));          // Expected output: 0\n    }\n}\n"}
{"task_id": "Java/152", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Compares the actual scores of matches with guesses.\n     *\n     * @param game A list of integers representing the actual scores of matches.\n     * @param guess A list of integers representing the guesses for each match score.\n     * @return A list of integers where each element is 0 if the guess was correct, or\n     *         the absolute difference between the guess and the score otherwise.\n     */\n    public List<Integer> compare(List<Integer> game, List<Integer> guess) {\n        List<Integer> result = new ArrayList<>();\n        \n        for (int i = 0; i < game.size(); i++) {\n            int diff = Math.abs(game.get(i) - guess.get(i));\n            result.add(diff);\n        }\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case 1\n        List<Integer> game1 = Arrays.asList(1,2,3,4,5,1);\n        List<Integer> guess1 = Arrays.asList(1,2,3,4,2,-2);\n        System.out.println(solution.compare(game1, guess1)); // Expected: [0, 0, 0, 0, 3, 3]\n        \n        // Test case 2\n        List<Integer> game2 = Arrays.asList(0,5,0,0,0,4);\n        List<Integer> guess2 = Arrays.asList(4,1,1,0,0,-2);\n        System.out.println(solution.compare(game2, guess2)); // Expected: [4, 4, 1, 0, 0, 6]\n    }\n}\n"}
{"task_id": "Java/153", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Finds the strongest extension for a given class name.\n     *\n     * @param class_name The name of the class to which extensions are added.\n     * @param extensions A list of string representing the names of the extensions.\n     * @return A string in the format ClassName.Strongest_Extension.\n     */\n    public String Strongest_Extension(String class_name, List<String> extensions) {\n        int maxStrength = Integer.MIN_VALUE;\n        String strongestExtension = \"\";\n\n        for (String extension : extensions) {\n            int strength = calculateStrength(extension);\n            if (strength > maxStrength || (strength == maxStrength && strongestExtension.isEmpty())) {\n                maxStrength = strength;\n                strongestExtension = extension;\n            }\n        }\n\n        return class_name + \".\" + strongestExtension;\n    }\n\n    private int calculateStrength(String extension) {\n        int upperCaseCount = 0, lowerCaseCount = 0;\n\n        for (char c : extension.toCharArray()) {\n            if (Character.isUpperCase(c)) upperCaseCount++;\n            else if (Character.isLowerCase(c)) lowerCaseCount++;\n        }\n\n        return upperCaseCount - lowerCaseCount;\n    }\n    \n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.Strongest_Extension(\"Slices\", Arrays.asList(\"SErviNGSliCes\", \"Cheese\", \"StuFfed\")));  // Expected: Slices.SErviNGSliCes\n        System.out.println(solution.Strongest_Extension(\"my_class\", Arrays.asList(\"AA\", \"Be\", \"CC\")));  // Expected: my_class.AA\n    }\n}\n"}
{"task_id": "Java/154", "generation": "import java.util.*;\n\nclass Solution {\n    public boolean cycpattern_check(String a, String b) {\n        // Concatenate the string 'a' with itself to handle rotation cases.\n        String doubledA = a + a;\n        \n        // Check if 'b' is a substring of the concatenated string.\n        return doubledA.contains(b);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.cycpattern_check(\"abcd\", \"abd\"));  // Expected: false\n        System.out.println(solution.cycpattern_check(\"hello\", \"ell\")); // Expected: true\n        System.out.println(solution.cycpattern_check(\"whassup\", \"psus\")); // Expected: false\n        System.out.println(solution.cycpattern_check(\"abab\", \"baa\"));  // Expected: true\n        System.out.println(solution.cycpattern_check(\"efef\", \"eeff\")); // Expected: false\n        System.out.println(solution.cycpattern_check(\"himenss\", \"simen\")); // Expected: true\n    }\n}\n"}
{"task_id": "Java/155", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given an integer, return a list that has the number of even and odd digits respectively.\n     *\n     * Example:\n     *      even_odd_count(-12) ==> [1, 1]\n     *      even_odd_count(123) ==> [1, 2]\n     */\n    public List<Integer> even_odd_count(int num) {\n        int evenCount = 0;\n        int oddCount = 0;\n\n        // Convert the number to a string and iterate over each character\n        String strNum = Integer.toString(Math.abs(num));\n        for (char c : strNum.toCharArray()) {\n            if ((c - '0') % 2 == 0) { // Check if digit is even\n                evenCount++;\n            } else { // If not even, it's odd\n                oddCount++;\n            }\n        }\n\n        List<Integer> result = new ArrayList<>();\n        result.add(evenCount);\n        result.add(oddCount);\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.even_odd_count(-12));  // Expected: [1, 1]\n        System.out.println(solution.even_odd_count(123));  // Expected: [1, 2]\n        System.out.println(solution.even_odd_count(0));    // Expected: [1, 0]\n        System.out.println(solution.even_odd_count(-987654321)); // Expected: [4, 5]\n    }\n}\n"}
{"task_id": "Java/156", "generation": "class Solution {\n    public String int_to_mini_roman(int number) {\n        if (number < 1 || number > 1000) throw new IllegalArgumentException(\"Number must be between 1 and 1000\");\n\n        // Define Roman numeral symbols and their values\n        int[] values = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n        String[] symbols = {\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n\n        StringBuilder roman = new StringBuilder();\n        \n        for (int i = 0; i < values.length && number > 0; i++) {\n            while (number >= values[i]) {\n                roman.append(symbols[i]);\n                number -= values[i];\n            }\n        }\n\n        return roman.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.int_to_mini_roman(19));  // Expected output: \"xix\"\n        System.out.println(solution.int_to_mini_roman(152)); // Expected output: \"clii\"\n        System.out.println(solution.int_to_mini_roman(426)); // Expected output: \"cdxxvi\"\n    }\n}\n"}
{"task_id": "Java/157", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given the lengths of the three sides of a triangle. Return true if the three\n     * sides form a right-angled triangle, false otherwise.\n     * A right-angled triangle is a triangle in which one angle is right angle or\n     * 90 degree.\n     *\n     * Example:\n     * right_angle_triangle(3, 4, 5) == true\n     * right_angle_triangle(1, 2, 3) == false\n     */\n    public boolean right_angle_triangle(int a, int b, int c) {\n        // Sort the sides to ensure that c is the longest side.\n        int[] sides = {a, b, c};\n        Arrays.sort(sides);\n        \n        // Check if the triangle satisfies Pythagoras' theorem: a^2 + b^2 == c^2\n        return Math.pow(sides[0], 2) + Math.pow(sides[1], 2) == Math.pow(sides[2], 2);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases to verify the correctness of the method\n        System.out.println(solution.right_angle_triangle(3, 4, 5)); // Expected: true\n        System.out.println(solution.right_angle_triangle(1, 2, 3)); // Expected: false\n        System.out.println(solution.right_angle_triangle(5, 12, 13)); // Expected: true\n        System.out.println(solution.right_angle_triangle(8, 15, 17)); // Expected: true\n        System.out.println(solution.right_angle_triangle(6, 8, 10)); // Expected: true\n        System.out.println(solution.right_angle_triangle(2, 3, 4)); // Expected: false\n    }\n}\n"}
{"task_id": "Java/158", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Finds the word with the maximum number of unique characters.\n     * If multiple strings have the same number of unique characters,\n     * returns the one that comes first in lexicographical order.\n     *\n     * @param words List of strings to be evaluated.\n     * @return The string with the most unique characters or the lexicographically smallest\n     *         if there are ties.\n     */\n    public String find_max(List<String> words) {\n        String maxWord = \"\";\n        int maxUniqueChars = 0;\n\n        for (String word : words) {\n            Set<Character> uniqueChars = new HashSet<>();\n            for (char c : word.toCharArray()) {\n                uniqueChars.add(c);\n            }\n            \n            if (uniqueChars.size() > maxUniqueChars ||\n                    (uniqueChars.size() == maxUniqueChars && word.compareTo(maxWord) < 0)) {\n                maxWord = word;\n                maxUniqueChars = uniqueChars.size();\n            }\n        }\n\n        return maxWord;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        List<String> test1 = Arrays.asList(\"name\", \"of\", \"string\");\n        System.out.println(solution.find_max(test1));  // Expected: string\n\n        List<String> test2 = Arrays.asList(\"name\", \"enam\", \"game\");\n        System.out.println(solution.find_max(test2));  // Expected: enam\n\n        List<String> test3 = Arrays.asList(\"aaaaaaa\", \"bb\" ,\"cc\");\n        System.out.println(solution.find_max(test3));  // Expected: aaaaaaa\n    }\n}\n"}
{"task_id": "Java/159", "generation": "import java.util.*;\n\nclass Solution {\n    public List<Integer> eat(int number, int need, int remaining) {\n        // Calculate how many additional carrots can be eaten based on availability.\n        int actualEaten = Math.min(need, remaining);\n        \n        // Update total eaten and remaining carrots.\n        int totalEaten = number + actualEaten;\n        int leftOver = remaining - actualEaten;\n\n        return Arrays.asList(totalEaten, leftOver);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.eat(5, 6, 10)); // Expected: [11, 4]\n        System.out.println(solution.eat(4, 8, 9));  // Expected: [12, 1]\n        System.out.println(solution.eat(1, 10, 10));// Expected: [11, 0]\n        System.out.println(solution.eat(2, 11, 5)); // Expected: [7, 0]\n    }\n}\n"}
{"task_id": "Java/160", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given two lists operator, and operand. The first list has basic algebra operations,\n     * and the second list is a list of integers. Use the two given lists to build the algebric\n     * expression and return the evaluation of this expression.\n     *\n     * @param operator List of strings representing operators.\n     * @param operand List of integers representing operands.\n     * @return The result of evaluating the algebraic expression.\n     */\n    public int do_algebra(List<String> operator, List<Integer> operand) {\n        Stack<Integer> stack = new Stack<>();\n        for (int i = 0; i < operand.size(); i++) {\n            if (!stack.isEmpty() && (operator.get(i - 1).equals(\"*\") || operator.get(i - 1).equals(\"/\") || operator.get(i - 1).equals(\"**\"))) {\n                int prevOperand = stack.pop();\n                String op = operator.get(i - 1);\n                switch (op) {\n                    case \"*\":\n                        stack.push(prevOperand * operand.get(i));\n                        break;\n                    case \"/\":\n                        stack.push(prevOperand / operand.get(i)); // Floor division\n                        break;\n                    case \"**\":\n                        stack.push((int)Math.pow(prevOperand, operand.get(i)));\n                        break;\n                }\n            } else {\n                stack.push(operand.get(i));\n            }\n        }\n\n        int result = stack.pop();\n        for (int i = 1; i < operator.size(); i++) {\n            String op = operator.get(i);\n            switch (op) {\n                case \"+\":\n                    result += stack.pop();\n                    break;\n                case \"-\":\n                    result -= stack.pop();\n                    break;\n            }\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        List<String> operators1 = Arrays.asList(\"+\", \"*\", \"-\");\n        List<Integer> operands1 = Arrays.asList(2, 3, 4, 5);\n        System.out.println(solution.do_algebra(operators1, operands1)); // Expected output: 9\n\n        List<String> operators2 = Arrays.asList(\"**\", \"-\", \"/\");\n        List<Integer> operands2 = Arrays.asList(2, 3, 4, 5);\n        System.out.println(solution.do_algebra(operators2, operands2)); // Expected output: -6\n    }\n}\n"}
{"task_id": "Java/161", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * You are given a string s.\n     * If s[i] is a letter, reverse its case from lower to upper or vice versa,\n     * otherwise keep it as it is.\n     * If the string contains no letters, reverse the string.\n     * The function should return the resulted string.\n     *\n     * Examples:\n     * solve(\"1234\") = \"4321\"\n     * solve(\"ab\") = \"AB\"\n     * solve(\"#a@C\") = \"#A@c\"\n     */\n    public String solve(String s) {\n        boolean containsLetter = false;\n        StringBuilder result = new StringBuilder();\n        \n        // Check if the string contains any letters\n        for (char c : s.toCharArray()) {\n            if (Character.isLetter(c)) {\n                containsLetter = true;\n                break;\n            }\n        }\n\n        // If no letters are found, reverse the entire string\n        if (!containsLetter) {\n            return new StringBuilder(s).reverse().toString();\n        }\n\n        // Process each character in the string\n        for (char c : s.toCharArray()) {\n            if (Character.isLowerCase(c)) {\n                result.append(Character.toUpperCase(c));\n            } else if (Character.isUpperCase(c)) {\n                result.append(Character.toLowerCase(c));\n            } else {\n                result.append(c);\n            }\n        }\n\n        return result.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.solve(\"1234\"));  // Expected: \"4321\"\n        System.out.println(solution.solve(\"ab\"));    // Expected: \"AB\"\n        System.out.println(solution.solve(\"#a@C\"));  // Expected: \"#A@c\"\n        System.out.println(solution.solve(\"Hello!\")); // Expected: \"hELLO!\"\n        System.out.println(solution.solve(\"1234567890\")); // Expected: \"0987654321\"\n    }\n}\n"}
{"task_id": "Java/162", "generation": "import java.math.BigInteger;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.Optional;\n\nclass Solution {\n    /**\n     * Given a string \"text\", return its md5 hash equivalent string with length being 32.\n     * If \"text\" is an empty string, return Optional.empty().\n     *\n     * @param text the input string to be hashed\n     * @return Optional<String> containing the MD5 hash or Optional.empty() if text is empty\n     */\n    public Optional<String> string_to_md5(String text) throws NoSuchAlgorithmException {\n        if (text.isEmpty()) {\n            return Optional.empty();\n        }\n        \n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        byte[] messageDigest = md.digest(text.getBytes());\n        BigInteger no = new BigInteger(1, messageDigest);\n        String hashtext = no.toString(16);\n        while (hashtext.length() < 32) {\n            hashtext = \"0\" + hashtext;\n        }\n        \n        return Optional.of(hashtext);\n    }\n\n    public static void main(String[] args) throws NoSuchAlgorithmException {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.string_to_md5(\"Hello world\").orElse(\"\"));  // Expected: \"3e25960a79dbc69b674cd4ec67a72c62\"\n        System.out.println(solution.string_to_md5(\"\").isPresent());             // Expected: false\n    }\n}\n"}
{"task_id": "Java/163", "generation": "import java.util.*;\n\nclass Solution {\n    public List<Integer> generate_integers(int a, int b) {\n        // Ensure a <= b for simplicity in iteration.\n        if (a > b) {\n            int temp = a;\n            a = b;\n            b = temp;\n        }\n\n        List<Integer> result = new ArrayList<>();\n        // Possible even digits less than 10\n        Integer[] possibleDigits = {2, 4, 6, 8};\n\n        for (int digit : possibleDigits) {\n            if (digit >= a && digit <= b) {\n                result.add(digit);\n            }\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.generate_integers(2, 8));   // Expected: [2, 4, 6, 8]\n        System.out.println(solution.generate_integers(8, 2));   // Expected: [2, 4, 6, 8]\n        System.out.println(solution.generate_integers(10, 14)); // Expected: []\n    }\n}\n"}
{"task_id": "Java/0", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Check if in given list of numbers, are any two numbers closer to each other than given threshold.\n     *\n     * @param numbers List of Double values.\n     * @param threshold The threshold value to compare the distance between elements.\n     * @return true if there exists at least one pair of numbers closer than the threshold; false otherwise.\n     */\n    public boolean has_close_elements(List<Double> numbers, double threshold) {\n        // Sort the list first\n        Collections.sort(numbers);\n\n        for (int i = 0; i < numbers.size() - 1; i++) {\n            if (numbers.get(i + 1) - numbers.get(i) <= threshold) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        List<Double> testList1 = Arrays.asList(1.0, 2.0, 3.0);\n        double threshold1 = 0.5;\n        System.out.println(solution.has_close_elements(testList1, threshold1)); // Expected: false\n\n        // Test case 2\n        List<Double> testList2 = Arrays.asList(1.0, 2.8, 3.0, 4.0, 5.0, 2.0);\n        double threshold2 = 0.3;\n        System.out.println(solution.has_close_elements(testList2, threshold2)); // Expected: true\n\n        // Additional test case\n        List<Double> testList3 = Arrays.asList(1.0, 1.4, 2.5, 3.6);\n        double threshold3 = 0.9;\n        System.out.println(solution.has_close_elements(testList3, threshold3)); // Expected: true\n    }\n}\n"}
{"task_id": "Java/1", "generation": "import java.util.*;\n\nclass Solution {\n    public List<String> separate_paren_groups(String paren_string) {\n        List<String> result = new ArrayList<>();\n        StringBuilder currentGroup = new StringBuilder();\n        int depth = 0;\n\n        for (char c : paren_string.replaceAll(\"\\\\s\", \"\").toCharArray()) { // Remove spaces and iterate\n            if (c == '(') {\n                depth++;\n            } else if (c == ')') {\n                depth--;\n            }\n            currentGroup.append(c);\n\n            if (depth == 0 && currentGroup.length() > 0) {\n                result.add(currentGroup.toString());\n                currentGroup = new StringBuilder(); // Reset for the next group\n            }\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        List<String> test1Result = solution.separate_paren_groups(\"( ) (( )) (( )( ))\");\n        System.out.println(test1Result); // Expected: [\"()\", \"(())\", \"(()())\"]\n        \n        List<String> test2Result = solution.separate_paren_groups(\"() (()) ()\");\n        System.out.println(test2Result); // Expected: [\"()\", \"(())\", \"()\"]\n    }\n}\n"}
{"task_id": "Java/2", "generation": "import org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nclass Solution {\n    /**\n     * Given a positive floating point number, it can be decomposed into\n     * and integer part (largest integer smaller than given number) and decimals\n     * (leftover part always smaller than 1).\n     *\n     * Return the decimal part of the number.\n     */\n    public double truncate_number(double number) {\n        return number - Math.floor(number);\n    }\n}\n\nclass SolutionTest {\n    @Test\n    void testTruncateNumber() {\n        Solution solution = new Solution();\n        \n        // Test case 1: Positive floating point number\n        assertEquals(0.5, solution.truncate_number(3.5), 0.001);\n\n        // Test case 2: Another positive floating point number\n        assertEquals(0.75, solution.truncate_number(4.75), 0.001);\n        \n        // Test case 3: Positive integer (should return 0)\n        assertEquals(0.0, solution.truncate_number(5.0), 0.001);\n\n        // Test case 4: Floating point number close to an integer\n        assertEquals(0.09999999999999787, solution.truncate_number(2.099999999999998), 0.001);\n    }\n}\n"}
{"task_id": "Java/3", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n    You're given a list of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account falls below zero, and\n    at that point function should return True. Otherwise it should return False.\n     */\n    public boolean below_zero(List<Integer> operations) {\n        int balance = 0;\n        for (int operation : operations) {\n            balance += operation;\n            if (balance < 0) {\n                return true; // Balance falls below zero\n            }\n        }\n        return false; // Never fell below zero\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1: No balance goes below zero\n        List<Integer> operations1 = Arrays.asList(1, 2, 3);\n        System.out.println(solution.below_zero(operations1)); // Expected output: false\n\n        // Test case 2: Balance falls below zero after the third operation (-4)\n        List<Integer> operations2 = Arrays.asList(1, 2, -4, 5);\n        System.out.println(solution.below_zero(operations2)); // Expected output: true\n\n        // Additional test cases\n        // Test case 3: Starts with a negative value\n        List<Integer> operations3 = Arrays.asList(-1, 2, 3);\n        System.out.println(solution.below_zero(operations3)); // Expected output: true\n\n        // Test case 4: No operation list (empty list)\n        List<Integer> operations4 = new ArrayList<>();\n        System.out.println(solution.below_zero(operations4)); // Expected output: false\n\n        // Test case 5: Operations that eventually balance out\n        List<Integer> operations5 = Arrays.asList(-1, -2, 3);\n        System.out.println(solution.below_zero(operations5)); // Expected output: true\n    }\n}\n"}
{"task_id": "Java/4", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * For a given list of input numbers, calculate Mean Absolute Deviation around the mean of this dataset.\n     * Mean Absolute Deviation is the average absolute difference between each element and a centerpoint (mean in this case):\n     * MAD = average | x - x_mean |\n     *\n     * @param numbers List of Double values\n     * @return double representing the Mean Absolute Deviation\n     */\n    public double mean_absolute_deviation(List<Double> numbers) {\n        if (numbers == null || numbers.isEmpty()) return 0.0;\n\n        // Calculate the mean of the dataset\n        double sum = 0;\n        for (Double number : numbers) {\n            sum += number;\n        }\n        double mean = sum / numbers.size();\n\n        // Calculate the Mean Absolute Deviation\n        double madSum = 0;\n        for (Double number : numbers) {\n            madSum += Math.abs(number - mean);\n        }\n\n        return madSum / numbers.size();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.mean_absolute_deviation(Arrays.asList(1.0, 2.0, 3.0, 4.0))); // Expected output: 1.0\n        System.out.println(solution.mean_absolute_deviation(Arrays.asList(-1.0, -2.0, -3.0, -4.0))); // Expected output: 1.5\n        System.out.println(solution.mean_absolute_deviation(Arrays.asList(5.0, 7.0, 9.0, 11.0))); // Expected output: 2.0\n        System.out.println(solution.mean_absolute_deviation(Arrays.asList())); // Expected output: 0.0 (empty list)\n    }\n}\n"}
{"task_id": "Java/5", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Insert a number 'delimiter' between every two consecutive elements of input list `numbers'.\n     *\n     * @param numbers List of integers.\n     * @param delimiter The integer to intersperse between the elements of the list.\n     * @return A new list with the delimiter inserted between each pair of consecutive elements.\n     */\n    public List<Integer> intersperse(List<Integer> numbers, int delimiter) {\n        if (numbers.isEmpty()) {\n            return Collections.emptyList();\n        }\n\n        List<Integer> result = new ArrayList<>();\n        for (int i = 0; i < numbers.size(); i++) {\n            result.add(numbers.get(i));\n            // Avoid adding the delimiter after the last element\n            if (i != numbers.size() - 1) {\n                result.add(delimiter);\n            }\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1: Empty list\n        System.out.println(solution.intersperse(new ArrayList<>(), 4)); // Expected output: []\n\n        // Test case 2: List with elements\n        System.out.println(solution.intersperse(Arrays.asList(1, 2, 3), 4)); // Expected output: [1, 4, 2, 4, 3]\n\n        // Additional test cases\n        System.out.println(solution.intersperse(Arrays.asList(5, 6), -1)); // Expected output: [5, -1, 6]\n        System.out.println(solution.intersperse(Arrays.asList(-7, 8, 9), 0)); // Expected output: [-7, 0, 8, 0, 9]\n    }\n}\n"}
{"task_id": "Java/6", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n     * For each of the group, output the deepest level of nesting of parentheses.\n     * E.g. (()()) has maximum two levels of nesting while ((())) has three.\n     *\n     * @param paren_string The input string containing groups of nested parentheses\n     * @return A list of integers representing the deepest level of nesting for each group\n     */\n    public List<Integer> parse_nested_parens(String paren_string) {\n        List<Integer> result = new ArrayList<>();\n        String[] groups = paren_string.split(\" \");\n        \n        for (String group : groups) {\n            int maxDepth = 0;\n            int currentDepth = 0;\n            \n            for (char c : group.toCharArray()) {\n                if (c == '(') {\n                    currentDepth++;\n                    maxDepth = Math.max(maxDepth, currentDepth);\n                } else if (c == ')') {\n                    currentDepth--;\n                }\n            }\n            result.add(maxDepth);\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        String test1 = \"(()()) ((())) () ((())()())\";\n        List<Integer> expected1 = Arrays.asList(2, 3, 1, 3);\n        System.out.println(\"Test Case 1: \" + (solution.parse_nested_parens(test1).equals(expected1) ? \"Passed\" : \"Failed\"));\n        \n        String test2 = \"(()) (()())\";\n        List<Integer> expected2 = Arrays.asList(2, 2);\n        System.out.println(\"Test Case 2: \" + (solution.parse_nested_parens(test2).equals(expected2) ? \"Passed\" : \"Failed\"));\n\n        // Add more tests as needed\n    }\n}\n"}
{"task_id": "Java/7", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Filter an input list of strings only for ones that contain given substring.\n     *\n     * @param strings List of strings to be filtered.\n     * @param substring The substring to filter the strings by.\n     * @return A new list containing only strings from the original list that include the specified substring.\n     */\n    public List<String> filter_by_substring(List<String> strings, String substring) {\n        List<String> result = new ArrayList<>();\n        for (String str : strings) {\n            if (str.contains(substring)) {\n                result.add(str);\n            }\n        }\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1: Empty list\n        List<String> testList1 = new ArrayList<>();\n        String substring1 = \"a\";\n        System.out.println(solution.filter_by_substring(testList1, substring1)); // Expected output: []\n\n        // Test case 2: Non-empty list with some strings containing the substring\n        List<String> testList2 = Arrays.asList(\"abc\", \"bacd\", \"cde\", \"array\");\n        String substring2 = \"a\";\n        System.out.println(solution.filter_by_substring(testList2, substring2)); // Expected output: [abc, bacd, array]\n    }\n}\n"}
{"task_id": "Java/8", "generation": "import java.util.Arrays;\nimport java.util.List;\n\nclass Solution {\n    /**\n     * For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n     * Empty sum should be equal to 0 and empty product should be equal to 1.\n     *\n     * @param numbers List of integers\n     * @return A List containing two elements: [sum, product]\n     */\n    public List<Integer> sum_product(List<Integer> numbers) {\n        int sum = 0;\n        int product = 1;\n\n        for (Integer number : numbers) {\n            sum += number;\n            product *= number;\n        }\n\n        return Arrays.asList(sum, product);\n    }\n}\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nclass SolutionTest {\n\n    @Test\n    public void testEmptyList() {\n        List<Integer> result = new Solution().sum_product(Arrays.asList());\n        assertEquals(Arrays.asList(0, 1), result);\n    }\n\n    @Test\n    public void testWithNumbers() {\n        List<Integer> result = new Solution().sum_product(Arrays.asList(1, 2, 3, 4));\n        assertEquals(Arrays.asList(10, 24), result);\n    }\n}\n"}
{"task_id": "Java/9", "generation": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\nclass Solution {\n    public List<Integer> rolling_max(List<Integer> numbers) {\n        List<Integer> result = new ArrayList<>();\n        if (numbers == null || numbers.isEmpty()) return result;\n\n        int maxSoFar = Integer.MIN_VALUE;\n        for (int num : numbers) {\n            maxSoFar = Math.max(maxSoFar, num);\n            result.add(maxSoFar);\n        }\n        return result;\n    }\n}\n"}
{"task_id": "Java/10", "generation": "import org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n"}
{"task_id": "Java/11", "generation": "class Solution {\n    /**\n     * Perform binary XOR on two given strings consisting only of 1s and 0s.\n     *\n     * @param a The first binary string.\n     * @param b The second binary string.\n     * @return A String representing the result of the binary XOR operation between a and b.\n     */\n    public String string_xor(String a, String b) {\n        StringBuilder xorResult = new StringBuilder();\n        \n        // Ensure both strings are of equal length by padding with zeros if necessary\n        int maxLength = Math.max(a.length(), b.length());\n        while (a.length() < maxLength) a = \"0\" + a;\n        while (b.length() < maxLength) b = \"0\" + b;\n\n        for (int i = 0; i < maxLength; i++) {\n            // Perform XOR on each bit\n            if (a.charAt(i) == b.charAt(i)) {\n                xorResult.append('0');\n            } else {\n                xorResult.append('1');\n            }\n        }\n\n        return xorResult.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case\n        String a = \"010\";\n        String b = \"110\";\n        System.out.println(\"XOR of \\\"\" + a + \"\\\" and \\\"\" + b + \"\\\": \" + solution.string_xor(a, b));\n    }\n}\n"}
{"task_id": "Java/12", "generation": "import java.util.*;\nimport java.lang.*;\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nclass Solution {\n    /**\n     * Out of list of strings, return the longest one. Return the first one in case of multiple\n     * strings of the same length. Return Optional.empty() in case the input list is empty.\n     */\n    public Optional<String> longest(List<String> strings) {\n        if (strings.isEmpty()) {\n            return Optional.empty();\n        }\n\n        String longestString = \"\";\n        for (String str : strings) {\n            if (str.length() > longestString.length()) {\n                longestString = str;\n            }\n        }\n        return Optional.of(longestString);\n    }\n\n    @Test\n    public void testEmptyList() {\n        assertEquals(Optional.empty(), longest(List.of()));\n    }\n\n    @Test\n    public void testSingleElement() {\n        assertEquals(Optional.of(\"a\"), longest(Arrays.asList(\"a\")));\n    }\n\n    @Test\n    public void testMultipleElements() {\n        assertEquals(Optional.of(\"ccc\"), longest(Arrays.asList(\"a\", \"bb\", \"ccc\")));\n    }\n\n    @Test\n    public void testEqualLengthStrings() {\n        // Since the requirement is to return the first one in case of multiple strings with the same length,\n        // we expect \"aa\" as it comes before \"bb\".\n        assertEquals(Optional.of(\"aa\"), longest(Arrays.asList(\"aa\", \"bb\")));\n    }\n}\n"}
{"task_id": "Java/13", "generation": "class Solution {\n    /**\n     * Return a greatest common divisor of two integers a and b.\n     *\n     * @param a first integer\n     * @param b second integer\n     * @return the greatest common divisor of a and b\n     */\n    public int greatest_common_divisor(int a, int b) {\n        // Base case: if b is 0, then gcd(a, b) = a\n        if (b == 0) return a;\n        \n        // Recursive call to find gcd using Euclid's algorithm\n        return greatest_common_divisor(b, a % b);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case 1: GCD of 3 and 5 should be 1\n        System.out.println(\"GCD(3, 5): \" + solution.greatest_common_divisor(3, 5)); // Expected output: 1\n        \n        // Test case 2: GCD of 25 and 15 should be 5\n        System.out.println(\"GCD(25, 15): \" + solution.greatest_common_divisor(25, 15)); // Expected output: 5\n        \n        // Additional test cases can be added here\n    }\n}\n"}
{"task_id": "Java/14", "generation": "import org.junit.jupiter.api.Test;\nimport java.util.List;\nimport java.util.Arrays;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nclass SolutionTest {\n    @Test\n    void testAllPrefixes() {\n        Solution solution = new Solution();\n        \n        // Test case 1: Normal string\n        List<String> expected1 = Arrays.asList(\"a\", \"ab\", \"abc\");\n        assertEquals(expected1, solution.all_prefixes(\"abc\"));\n        \n        // Test case 2: Single character string\n        List<String> expected2 = Arrays.asList(\"x\");\n        assertEquals(expected2, solution.all_prefixes(\"x\"));\n        \n        // Test case 3: Empty string\n        List<String> expected3 = new ArrayList<>();\n        assertEquals(expected3, solution.all_prefixes(\"\"));\n    }\n}\n"}
{"task_id": "Java/15", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return a string containing space-delimited numbers starting from 0 up to n inclusive.\n     *\n     * @param n The upper limit of the sequence (inclusive).\n     * @return A String with space-separated integers from 0 to n.\n     */\n    public String string_sequence(int n) {\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i <= n; i++) {\n            sb.append(i);\n            if (i < n) {\n                sb.append(\" \");\n            }\n        }\n        return sb.toString();\n    }\n\n    // Test cases to verify the correctness of string_sequence method\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.string_sequence(0).equals(\"0\") ? \"Test 1 Passed\" : \"Test 1 Failed\");\n        System.out.println(solution.string_sequence(5).equals(\"0 1 2 3 4 5\") ? \"Test 2 Passed\" : \"Test 2 Failed\");\n        System.out.println(solution.string_sequence(1).equals(\"0 1\") ? \"Test 3 Passed\" : \"Test 3 Failed\");\n    }\n}\n"}
{"task_id": "Java/16", "generation": "import java.util.HashSet;\nimport java.util.Set;\n\nclass Solution {\n    public int count_distinct_characters(String string) {\n        // Convert the input string to lower case to ignore case sensitivity.\n        String lowerCaseString = string.toLowerCase();\n        \n        // Use a HashSet to store distinct characters since it does not allow duplicates.\n        Set<Character> distinctChars = new HashSet<>();\n        \n        // Iterate over each character in the string and add it to the set.\n        for (char c : lowerCaseString.toCharArray()) {\n            distinctChars.add(c);\n        }\n        \n        // The size of the set represents the number of distinct characters.\n        return distinctChars.size();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.count_distinct_characters(\"xyzXYZ\")); // Expected output: 3\n        System.out.println(solution.count_distinct_characters(\"Jerry\"));   // Expected output: 4\n        System.out.println(solution.count_distinct_characters(\"HelloWorld\")); // Expected output: 7\n    }\n}\n"}
{"task_id": "Java/17", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Parses a string representing musical notes in a special ASCII format and returns a list of integers corresponding \n     * to the number of beats each note lasts.\n     *\n     * @param string The input string containing musical notes.\n     * @return A List<Integer> where each integer represents the duration (in beats) of the corresponding note.\n     */\n    public List<Integer> parse_music(String string) {\n        List<Integer> durations = new ArrayList<>();\n        String[] notes = string.split(\" \");\n        \n        for (String note : notes) {\n            if (\"o\".equals(note)) {\n                durations.add(4);\n            } else if (\"o|\".equals(note)) {\n                durations.add(2);\n            } else if (\".|\".equals(note)) {\n                durations.add(1);\n            }\n        }\n\n        return durations;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case\n        List<Integer> result = solution.parse_music(\"o o| .| o| o| .| .| .| .| o o\");\n        System.out.println(result);  // Expected output: [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n        \n        // Additional test cases\n        List<Integer> result2 = solution.parse_music(\"o| .| o\");\n        System.out.println(result2);  // Expected output: [2, 1, 4]\n\n        List<Integer> result3 = solution.parse_music(\".| .| .| .|\");\n        System.out.println(result3);  // Expected output: [1, 1, 1, 1]\n    }\n}\n"}
{"task_id": "Java/18", "generation": "class Solution {\n    /**\n     * Find how many times a given substring can be found in the original string.\n     * Count overlaping cases.\n     *\n     * @param string The original string to search within.\n     * @param substring The substring to find occurrences of.\n     * @return The number of times the substring is found, including overlaps.\n     */\n    public int how_many_times(String string, String substring) {\n        if (string == null || substring == null || substring.length() == 0) return 0;\n        \n        int count = 0;\n        int index = 0;\n\n        while ((index = string.indexOf(substring, index)) != -1) {\n            count++;\n            index++; // Move to the next character for overlapping matches\n        }\n\n        return count;\n    }\n    \n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.how_many_times(\"\", \"a\")); // Expected output: 0\n        System.out.println(solution.how_many_times(\"aaa\", \"a\")); // Expected output: 3\n        System.out.println(solution.how_many_times(\"aaaa\", \"aa\")); // Expected output: 3\n        \n        // Additional test cases\n        System.out.println(solution.how_many_times(\"ababa\", \"aba\")); // Expected output: 2\n        System.out.println(solution.how_many_times(\"testestest\", \"test\")); // Expected output: 3\n    }\n}\n"}
{"task_id": "Java/19", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Input is a space-delimited string of numberals from 'zero' to 'nine'.\n     * Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n     * Return the string with numbers sorted from smallest to largest\n     *\n     * @param numbers a space-delimited string of number words.\n     * @return a string with the number words sorted from smallest to largest.\n     */\n    public String sort_numbers(String numbers) {\n        Map<String, Integer> wordToNum = new HashMap<>();\n        wordToNum.put(\"zero\", 0);\n        wordToNum.put(\"one\", 1);\n        wordToNum.put(\"two\", 2);\n        wordToNum.put(\"three\", 3);\n        wordToNum.put(\"four\", 4);\n        wordToNum.put(\"five\", 5);\n        wordToNum.put(\"six\", 6);\n        wordToNum.put(\"seven\", 7);\n        wordToNum.put(\"eight\", 8);\n        wordToNum.put(\"nine\", 9);\n\n        // Convert the input string to a list of numbers\n        List<Integer> numList = new ArrayList<>();\n        for (String word : numbers.split(\"\\\\s+\")) {\n            if (!word.isEmpty()) {\n                numList.add(wordToNum.get(word));\n            }\n        }\n\n        // Sort the list of numbers\n        Collections.sort(numList);\n\n        // Convert back to words and join them into a string\n        StringBuilder result = new StringBuilder();\n        Map<Integer, String> numToWord = new HashMap<>();\n        for (Map.Entry<String, Integer> entry : wordToNum.entrySet()) {\n            numToWord.put(entry.getValue(), entry.getKey());\n        }\n        for (int i = 0; i < numList.size(); i++) {\n            if (i > 0) result.append(\" \");\n            result.append(numToWord.get(numList.get(i)));\n        }\n\n        return result.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.sort_numbers(\"three one five\")); // Expected: \"one three five\"\n        System.out.println(solution.sort_numbers(\"nine eight seven\")); // Expected: \"seven eight nine\"\n        System.out.println(solution.sort_numbers(\"zero four two\")); // Expected: \"zero two four\"\n    }\n}\n"}
{"task_id": "Java/20", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n     * other and return them in order (smaller number, larger number).\n     */\n    public List<Double> find_closest_elements(List<Double> numbers) {\n        // Sort the list first.\n        Collections.sort(numbers);\n\n        double minDiff = Double.MAX_VALUE;\n        List<Double> result = new ArrayList<>();\n\n        for (int i = 0; i < numbers.size() - 1; i++) {\n            double diff = Math.abs(numbers.get(i + 1) - numbers.get(i));\n            if (diff < minDiff) {\n                minDiff = diff;\n                result.clear();\n                result.add(numbers.get(i));\n                result.add(numbers.get(i + 1));\n            }\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.find_closest_elements(Arrays.asList(1.0, 2.0, 3.0, 4.0, 5.0, 2.2))); // [2.0, 2.2]\n        System.out.println(solution.find_closest_elements(Arrays.asList(1.0, 2.0, 3.0, 4.0, 5.0, 2.0))); // [2.0, 2.0]\n    }\n}\n"}
{"task_id": "Java/21", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a list of numbers (of at least two elements), apply a linear transform to that list,\n     * such that the smallest number will become 0 and the largest will become 1.\n     *\n     * @param numbers The input list of doubles.\n     * @return A new list where each element is scaled between 0 and 1.\n     */\n    public List<Double> rescale_to_unit(List<Double> numbers) {\n        if (numbers == null || numbers.size() < 2) {\n            throw new IllegalArgumentException(\"List must contain at least two elements.\");\n        }\n\n        double min = Collections.min(numbers);\n        double max = Collections.max(numbers);\n\n        // Avoid division by zero\n        if (min == max) {\n            throw new ArithmeticException(\"Cannot rescale when all numbers are the same.\");\n        }\n\n        List<Double> scaledNumbers = new ArrayList<>();\n        for (double number : numbers) {\n            double scaledValue = (number - min) / (max - min);\n            scaledNumbers.add(scaledValue);\n        }\n        return scaledNumbers;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        List<Double> testList1 = Arrays.asList(1.0, 2.0, 3.0, 4.0, 5.0);\n        System.out.println(solution.rescale_to_unit(testList1)); // Expected: [0.0, 0.25, 0.5, 0.75, 1.0]\n\n        // Test case 2\n        List<Double> testList2 = Arrays.asList(10.0, 20.0, 30.0);\n        System.out.println(solution.rescale_to_unit(testList2)); // Expected: [0.0, 0.5, 1.0]\n\n        // Test case 3\n        List<Double> testList3 = Arrays.asList(-1.0, -2.0, -3.0, -4.0);\n        System.out.println(solution.rescale_to_unit(testList3)); // Expected: [1.0, 0.75, 0.5, 0.25]\n\n        // Test case 4\n        List<Double> testList4 = Arrays.asList(1.0, 1.0);\n        try {\n            System.out.println(solution.rescale_to_unit(testList4));\n        } catch (ArithmeticException e) {\n            System.out.println(e.getMessage()); // Expected: Cannot rescale when all numbers are the same.\n        }\n    }\n}\n"}
{"task_id": "Java/22", "generation": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\nclass Solution {\n    public List<Integer> filter_integers(List<Object> values) {\n        List<Integer> result = new ArrayList<>();\n        for (Object value : values) {\n            if (value instanceof Integer) {\n                result.add((Integer)value);\n            }\n        }\n        return result;\n    }\n\n    // Test method to verify the correctness of the solution\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n\n        List<Object> test1 = Arrays.asList('a', 3.14, 5);\n        System.out.println(sol.filter_integers(test1)); // Expected: [5]\n\n        List<Object> test2 = Arrays.asList(1, 2, 3, \"abc\", Map.of(), List.of());\n        System.out.println(sol.filter_integers(test2)); // Expected: [1, 2, 3]\n    }\n}\n"}
{"task_id": "Java/23", "generation": "import org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\nclass Solution {\n    /**\n     * Return length of given string.\n     *\n     * @param string The input string.\n     * @return Length of the input string.\n     */\n    public int strlen(String string) {\n        return string.length();\n    }\n\n    // Test cases\n    @Test\n    void testStrlen() {\n        assertEquals(0, new Solution().strlen(\"\"));\n        assertEquals(3, new Solution().strlen(\"abc\"));\n        assertEquals(5, new Solution().strlen(\"hello\"));\n        assertEquals(12, new Solution().strlen(\"Hello, World!\"));\n    }\n}\n"}
{"task_id": "Java/24", "generation": "class Solution {\n    /**\n     * For a given number n, find the largest number that divides n evenly, smaller than n.\n     *\n     * @param n The input number.\n     * @return The largest divisor of n that is smaller than n.\n     */\n    public int largest_divisor(int n) {\n        for (int i = n - 1; i > 0; i--) {\n            if (n % i == 0) {\n                return i;\n            }\n        }\n        // In case no divisor found, which theoretically shouldn't happen\n        throw new IllegalArgumentException(\"No divisor found\");\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.largest_divisor(15));  // Expected output: 5\n        System.out.println(solution.largest_divisor(28));  // Expected output: 14\n        System.out.println(solution.largest_divisor(7));   // Expected output: 1 (since 7 is prime)\n    }\n}\n"}
{"task_id": "Java/25", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Return list of prime factors of given integer in the order from smallest to largest.\n     * Each of the factors should be listed number of times corresponding to how many times it appears in factorization.\n     * Input number should be equal to the product of all factors\n     */\n    public List<Integer> factorize(int n) {\n        List<Integer> factors = new ArrayList<>();\n        \n        // Divide by 2 until odd\n        while (n % 2 == 0) {\n            factors.add(2);\n            n /= 2;\n        }\n        \n        // Check for odd factors from 3 onwards\n        for (int i = 3; i <= Math.sqrt(n); i += 2) {\n            while (n % i == 0) {\n                factors.add(i);\n                n /= i;\n            }\n        }\n\n        // If n is a prime number greater than 2\n        if (n > 2) {\n            factors.add(n);\n        }\n        \n        return factors;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.factorize(8)); // Expected: [2, 2, 2]\n        System.out.println(solution.factorize(25)); // Expected: [5, 5]\n        System.out.println(solution.factorize(70)); // Expected: [2, 5, 7]\n    }\n}\n"}
{"task_id": "Java/26", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * From a list of integers, remove all elements that occur more than once.\n     * Keep the order of elements left the same as in the input.\n     *\n     * @param numbers List of integers from which to remove duplicates.\n     * @return A new list with duplicates removed and original order preserved.\n     */\n    public List<Integer> remove_duplicates(List<Integer> numbers) {\n        Map<Integer, Integer> frequencyMap = new HashMap<>();\n        \n        // Count the occurrences of each number\n        for (Integer num : numbers) {\n            frequencyMap.put(num, frequencyMap.getOrDefault(num, 0) + 1);\n        }\n        \n        List<Integer> result = new LinkedList<>(); // Use LinkedList to preserve order\n        \n        // Add only elements that occur once\n        for (Integer num : numbers) {\n            if (frequencyMap.get(num) == 1) {\n                result.add(num);\n            }\n        }\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        List<Integer> testList1 = Arrays.asList(1, 2, 3, 2, 4);\n        System.out.println(solution.remove_duplicates(testList1)); // Expected: [1, 3, 4]\n        \n        List<Integer> testList2 = Arrays.asList(5, 6, 7, 8, 9, 5, 6);\n        System.out.println(solution.remove_duplicates(testList2)); // Expected: [7, 8, 9]\n    }\n}\n"}
{"task_id": "Java/27", "generation": "class Solution {\n    /**\n     * For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n     *\n     * @param string The input string whose case needs to be flipped.\n     * @return A new string with the case of each character flipped.\n     */\n    public String flip_case(String string) {\n        StringBuilder result = new StringBuilder();\n        \n        for (char c : string.toCharArray()) {\n            if (Character.isUpperCase(c)) {\n                result.append(Character.toLowerCase(c));\n            } else if (Character.isLowerCase(c)) {\n                result.append(Character.toUpperCase(c));\n            } else {\n                // If the character is not a letter, append it as-is.\n                result.append(c);\n            }\n        }\n\n        return result.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.flip_case(\"Hello\")); // Expected: \"hELLO\"\n        System.out.println(solution.flip_case(\"Java\"));  // Expected: \"jAVA\"\n        System.out.println(solution.flip_case(\"123abcABC\")); // Expected: \"123ABCabc\"\n        System.out.println(solution.flip_case(\"TeSt123!\")); // Expected: \"tEsT123!\"\n    }\n}\n"}
{"task_id": "Java/28", "generation": "import java.util.Arrays;\nimport java.util.List;\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nclass Solution {\n    /**\n     * Concatenates a list of strings into a single string.\n     *\n     * @param strings the list of strings to concatenate\n     * @return the concatenated string\n     */\n    public String concatenate(List<String> strings) {\n        // Use StringBuilder for efficient concatenation\n        StringBuilder sb = new StringBuilder();\n        for (String str : strings) {\n            sb.append(str);\n        }\n        return sb.toString();\n    }\n\n    /**\n     * Test method to check if the concatenate function works as expected.\n     */\n    @Test\n    public void testConcatenate() {\n        // Test with an empty list\n        assertEquals(\"\", concatenate(List.of()), \"Expected concatenation of an empty list to be an empty string\");\n\n        // Test with a non-empty list\n        List<String> strings = Arrays.asList(\"a\", \"b\", \"c\");\n        assertEquals(\"abc\", concatenate(strings), \"Expected concatenation of ['a', 'b', 'c'] to be 'abc'\");\n    }\n}\n"}
{"task_id": "Java/29", "generation": "import org.junit.jupiter.api.Test;\nimport java.util.Arrays;\nimport java.util.List;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nclass Solution {\n    /**\n     * Filter an input list of strings only for ones that start with a given prefix.\n     *\n     * @param strings the list of strings to be filtered\n     * @param prefix  the prefix used as filter criteria\n     * @return a new list containing only strings starting with the specified prefix\n     */\n    public List<String> filter_by_prefix(List<String> strings, String prefix) {\n        return strings.stream()\n                .filter(s -> s.startsWith(prefix))\n                .collect(Collectors.toList());\n    }\n\n    // Test cases for the filter_by_prefix method.\n    @Test\n    void testFilterByPrefixWithEmptyList() {\n        List<String> input = new ArrayList<>();\n        List<String> expectedOutput = new ArrayList<>();\n        assertEquals(expectedOutput, new Solution().filter_by_prefix(input, \"a\"));\n    }\n\n    @Test\n    void testFilterByPrefixWithSomeMatches() {\n        List<String> input = Arrays.asList(\"abc\", \"bcd\", \"cde\", \"array\");\n        List<String> expectedOutput = Arrays.asList(\"abc\", \"array\");\n        assertEquals(expectedOutput, new Solution().filter_by_prefix(input, \"a\"));\n    }\n\n    @Test\n    void testFilterByPrefixWithNoMatches() {\n        List<String> input = Arrays.asList(\"xyz\", \"pqr\", \"lmn\");\n        List<String> expectedOutput = new ArrayList<>();\n        assertEquals(expectedOutput, new Solution().filter_by_prefix(input, \"a\"));\n    }\n}\n"}
{"task_id": "Java/30", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return only positive numbers in the list.\n     *\n     * @param l List of integers\n     * @return A new list containing only the positive numbers from the input list\n     */\n    public List<Integer> get_positive(List<Integer> l) {\n        return l.stream()\n                .filter(x -> x > 0)\n                .collect(Collectors.toList());\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        List<Integer> list1 = Arrays.asList(-1, 2, -4, 5, 6);\n        System.out.println(\"Test Case 1: \" + solution.get_positive(list1)); // Expected [2, 5, 6]\n\n        // Test case 2\n        List<Integer> list2 = Arrays.asList(5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10);\n        System.out.println(\"Test Case 2: \" + solution.get_positive(list2)); // Expected [5, 3, 2, 3, 9, 123, 1]\n\n        // Test case 3\n        List<Integer> list3 = Arrays.asList(-7, -8, -9);\n        System.out.println(\"Test Case 3: \" + solution.get_positive(list3)); // Expected []\n\n        // Test case 4\n        List<Integer> list4 = Arrays.asList(0, 1, 2, 3);\n        System.out.println(\"Test Case 4: \" + solution.get_positive(list4)); // Expected [1, 2, 3]\n    }\n}\n"}
{"task_id": "Java/31", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Return true if a given number is prime, and false otherwise.\n     */\n    public boolean is_prime(int n) {\n        // Corner cases\n        if (n <= 1) return false;\n        if (n == 2 || n == 3) return true;\n\n        // This is checked so that we can skip middle five numbers in below loop\n        if (n % 2 == 0 || n % 3 == 0) return false;\n\n        for (int i = 5; i * i <= n; i += 6) {\n            if (n % i == 0 || n % (i + 2) == 0)\n                return false;\n        }\n\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.is_prime(6));     // Expected: false\n        System.out.println(solution.is_prime(101));   // Expected: true\n        System.out.println(solution.is_prime(11));    // Expected: true\n        System.out.println(solution.is_prime(13441)); // Expected: true\n        System.out.println(solution.is_prime(61));    // Expected: true\n        System.out.println(solution.is_prime(4));     // Expected: false\n        System.out.println(solution.is_prime(1));     // Expected: false\n    }\n}\n"}
{"task_id": "Java/32", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Evaluates polynomial with coefficients xs at point x.\n     */\n    public double poly(List<Double> xs, double x) {\n        double result = 0;\n        for (int i = 0; i < xs.size(); i++) {\n            result += xs.get(i) * Math.pow(x, i);\n        }\n        return result;\n    }\n\n    /**\n     * Finds a zero of the polynomial defined by coefficients in xs.\n     */\n    public double find_zero(List<Double> xs) {\n        if (xs.size() % 2 != 0) {\n            throw new IllegalArgumentException(\"The list must have an even number of elements.\");\n        }\n        \n        // Initial guess interval\n        double left = -100;\n        double right = 100;\n\n        while ((right - left) > 1e-6) { // Precision check\n            double mid = (left + right) / 2.0;\n            \n            if (poly(xs, mid) == 0 || Math.abs(right - left) < 1e-6) {\n                return mid; // Found the root or close enough\n            }\n            \n            if (poly(xs, left) * poly(xs, mid) < 0) {\n                right = mid;\n            } else {\n                left = mid;\n            }\n        }\n\n        return (left + right) / 2.0;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        List<Double> test1 = Arrays.asList(1.0, 2.0);\n        System.out.println(\"Test case 1: \" + solution.find_zero(test1)); // Expected output -0.5\n        \n        List<Double> test2 = Arrays.asList(-6.0, 11.0, -6.0, 1.0);\n        System.out.println(\"Test case 2: \" + solution.find_zero(test2)); // Expected output 1.0\n    }\n}\n"}
{"task_id": "Java/33", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * This function takes a list l and returns a list l' such that\n     * l' is identical to l in the indices that are not divisible by three, while its values at the indices that are divisible by three are equal\n     * to the values of the corresponding indices of l, but sorted in ascending order.\n     *\n     * @param l The input list of integers.\n     * @return A new list with elements at indices divisible by 3 sorted.\n     */\n    public List<Integer> sort_third(List<Integer> l) {\n        // Extract elements at positions divisible by three\n        ArrayList<Integer> toSort = new ArrayList<>();\n        for (int i = 0; i < l.size(); i++) {\n            if ((i + 1) % 3 == 0) { // Indexes start from 0, so we use (i+1)\n                toSort.add(l.get(i));\n            }\n        }\n\n        // Sort the extracted elements\n        Collections.sort(toSort);\n\n        // Create a new list and fill it with sorted values at positions divisible by three\n        ArrayList<Integer> result = new ArrayList<>(l);\n        int sortIndex = 0;\n        for (int i = 0; i < l.size(); i++) {\n            if ((i + 1) % 3 == 0) { // Indexes start from 0, so we use (i+1)\n                result.set(i, toSort.get(sortIndex++));\n            }\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.sort_third(Arrays.asList(1, 2, 3))); // Expected: [1, 2, 3]\n        System.out.println(solution.sort_third(Arrays.asList(5, 6, 3, 4, 8, 9, 2))); // Expected: [2, 6, 3, 4, 8, 9, 5]\n    }\n}\n"}
{"task_id": "Java/34", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return sorted unique elements in a list.\n     *\n     * @param l List of integers that may contain duplicates.\n     * @return A new list containing only the unique elements from the input list, sorted in ascending order.\n     */\n    public List<Integer> unique(List<Integer> l) {\n        // Use LinkedHashSet to maintain insertion order and uniqueness\n        Set<Integer> set = new LinkedHashSet<>(l);\n        \n        // Convert the set back into a list for sorting\n        List<Integer> resultList = new ArrayList<>(set);\n        \n        // Sort the result list in ascending order\n        Collections.sort(resultList);\n        \n        return resultList;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case 1: Normal scenario with duplicates and sorting required.\n        List<Integer> testList1 = Arrays.asList(5, 3, 5, 2, 3, 3, 9, 0, 123);\n        System.out.println(solution.unique(testList1)); // Expected output: [0, 2, 3, 5, 9, 123]\n        \n        // Test case 2: List with all unique elements.\n        List<Integer> testList2 = Arrays.asList(7, 8, 9);\n        System.out.println(solution.unique(testList2)); // Expected output: [7, 8, 9]\n        \n        // Test case 3: Empty list scenario.\n        List<Integer> testList3 = new ArrayList<>();\n        System.out.println(solution.unique(testList3)); // Expected output: []\n    }\n}\n"}
{"task_id": "Java/35", "generation": "import java.util.*;\n\nclass Solution {\n\n    /**\n     * Return maximum element in the list.\n     *\n     * @param l List of integers\n     * @return The maximum integer in the list\n     */\n    public int max_element(List<Integer> l) {\n        if (l == null || l.isEmpty()) {\n            throw new IllegalArgumentException(\"List must not be null or empty\");\n        }\n        \n        return Collections.max(l);\n    }\n\n    /**\n     * A simple test method to check the correctness of the max_element function.\n     */\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        List<Integer> list1 = Arrays.asList(1, 2, 3);\n        System.out.println(\"Max element in \" + list1 + \": \" + solution.max_element(list1)); // Expected: 3\n\n        // Test case 2\n        List<Integer> list2 = Arrays.asList(5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10);\n        System.out.println(\"Max element in \" + list2 + \": \" + solution.max_element(list2)); // Expected: 123\n\n        // Test case 3 (Edge case with negative numbers)\n        List<Integer> list3 = Arrays.asList(-5, -3, -7);\n        System.out.println(\"Max element in \" + list3 + \": \" + solution.max_element(list3)); // Expected: -3\n\n        // Test case 4 (Single element list)\n        List<Integer> list4 = Collections.singletonList(10);\n        System.out.println(\"Max element in \" + list4 + \": \" + solution.max_element(list4)); // Expected: 10\n    }\n}\n"}
{"task_id": "Java/36", "generation": "class Solution {\n    /**\n     * Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n     *\n     * @param n The upper limit (exclusive) for checking numbers.\n     * @return The count of digit '7' appearances in numbers less than n and divisible by 11 or 13.\n     */\n    public int fizz_buzz(int n) {\n        int count = 0;\n        for (int i = 1; i < n; i++) {\n            if ((i % 11 == 0 || i % 13 == 0)) {\n                String numStr = Integer.toString(i);\n                for (char c : numStr.toCharArray()) {\n                    if (c == '7') count++;\n                }\n            }\n        }\n        return count;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.fizz_buzz(50));  // Expected output: 0\n        System.out.println(solution.fizz_buzz(78));  // Expected output: 2\n        System.out.println(solution.fizz_buzz(79));  // Expected output: 3\n    }\n}\n"}
{"task_id": "Java/37", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * This function takes a list l and returns a list l' such that\n     * l' is identical to l in the odd indicies, while its values at the even indicies are equal\n     * to the values of the even indicies of l, but sorted.\n     *\n     * @param l The input list.\n     * @return A new list where elements at even indices are sorted and odd indices remain unchanged.\n     */\n    public List<Integer> sort_even(List<Integer> l) {\n        // Extracting elements at even indices\n        ArrayList<Integer> evenIndicesValues = new ArrayList<>();\n        for (int i = 0; i < l.size(); i += 2) {\n            evenIndicesValues.add(l.get(i));\n        }\n\n        // Sorting the extracted values\n        Collections.sort(evenIndicesValues);\n\n        // Creating a new list to hold the result\n        List<Integer> sortedList = new ArrayList<>(Collections.nCopies(l.size(), 0));\n\n        // Placing back the sorted elements at even indices and keeping odd indices unchanged\n        int evenIndex = 0;\n        for (int i = 0; i < l.size(); i++) {\n            if (i % 2 == 0) {\n                sortedList.set(i, evenIndicesValues.get(evenIndex++));\n            } else {\n                sortedList.set(i, l.get(i));\n            }\n        }\n\n        return sortedList;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        List<Integer> list1 = Arrays.asList(1, 2, 3);\n        System.out.println(solution.sort_even(list1)); // Expected: [1, 2, 3]\n\n        // Test case 2\n        List<Integer> list2 = Arrays.asList(5, 6, 3, 4);\n        System.out.println(solution.sort_even(list2)); // Expected: [3, 6, 5, 4]\n    }\n}\n"}
{"task_id": "Java/38", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Returns encoded string by cycling groups of three characters.\n     */\n    public String encodeCyclic(String s) {\n        // split string to groups. Each of length 3.\n        List<String> groups = new ArrayList<>();\n        for (int i = 0; i < s.length(); i += 3) {\n            groups.add(s.substring(i, Math.min(i + 3, s.length())));\n        }\n        // cycle elements in each group. Unless group has fewer elements than 3.\n        for (int i = 0; i < groups.size(); i++) {\n            if (groups.get(i).length() == 3) {\n                groups.set(i, groups.get(i).substring(1) + groups.get(i).charAt(0));\n            }\n        }\n        return String.join(\"\", groups);\n    }\n\n    /**\n     * Takes as input string encoded with encodeCyclic function. Returns decoded string.\n     */\n    public String decode_cyclic(String s) {\n        // split string to groups. Each of length 3.\n        List<String> groups = new ArrayList<>();\n        for (int i = 0; i < s.length(); i += 3) {\n            groups.add(s.substring(i, Math.min(i + 3, s.length())));\n        }\n        // reverse cycle elements in each group. Unless group has fewer elements than 3.\n        for (int i = 0; i < groups.size(); i++) {\n            if (groups.get(i).length() == 3) {\n                char firstChar = groups.get(i).charAt(2);\n                String restOfGroup = groups.get(i).substring(0, 2);\n                groups.set(i, firstChar + restOfGroup);\n            }\n        }\n        return String.join(\"\", groups);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.encodeCyclic(\"hello\")); // Should print \"elhlo\"\n        System.out.println(solution.decode_cyclic(\"elhlo\")); // Should print \"hello\"\n\n        System.out.println(solution.encodeCyclic(\"worldwide\")); // Should print \"orlwrdiedw\"\n        System.out.println(solution.decode_cyclic(\"orlwrdiedw\")); // Should print \"worldwide\"\n\n        System.out.println(solution.encodeCyclic(\"java\")); // Should print \"jav\"\n        System.out.println(solution.decode_cyclic(\"jav\")); // Should print \"java\"\n\n        System.out.println(solution.encodeCyclic(\"programming\")); // Should print \"ogramprgmin\"\n        System.out.println(solution.decode_cyclic(\"ogramprgmin\")); // Should print \"programming\"\n    }\n}\n"}
{"task_id": "Java/39", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int prime_fib(int n) {\n        List<Integer> primes = new ArrayList<>();\n        int fib1 = 0, fib2 = 1;\n        \n        while (primes.size() < n) {\n            int nextFib = fib1 + fib2;\n            if (isPrime(nextFib)) {\n                primes.add(nextFib);\n            }\n            fib1 = fib2;\n            fib2 = nextFib;\n        }\n\n        return primes.get(n - 1);\n    }\n\n    private boolean isPrime(int number) {\n        if (number <= 1) {\n            return false;\n        }\n        for (int i = 2; i * i <= number; i++) {\n            if (number % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.prime_fib(1)); // Expected output: 2\n        System.out.println(solution.prime_fib(2)); // Expected output: 3\n        System.out.println(solution.prime_fib(3)); // Expected output: 5\n        System.out.println(solution.prime_fib(4)); // Expected output: 13\n        System.out.println(solution.prime_fib(5)); // Expected output: 89\n    }\n}\n"}
{"task_id": "Java/40", "generation": "import java.util.*;\n\nclass Solution {\n\n    /**\n     * triples_sum_to_zero takes a list of integers as an input.\n     * It returns True if there are three distinct elements in the list that sum to zero, and False otherwise.\n     */\n    public boolean triples_sum_to_zero(List<Integer> l) {\n        // Sort the array first\n        Collections.sort(l);\n\n        for (int i = 0; i < l.size() - 2; i++) {\n            int left = i + 1;\n            int right = l.size() - 1;\n\n            while (left < right) {\n                int sum = l.get(i) + l.get(left) + l.get(right);\n\n                if (sum == 0) {\n                    return true;\n                } else if (sum < 0) {\n                    left++;\n                } else {\n                    right--;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.triples_sum_to_zero(Arrays.asList(1, 3, 5, 0))); // Expected: false\n        System.out.println(solution.triples_sum_to_zero(Arrays.asList(1, 3, -2, 1))); // Expected: true\n        System.out.println(solution.triples_sum_to_zero(Arrays.asList(1, 2, 3, 7))); // Expected: false\n        System.out.println(solution.triples_sum_to_zero(Arrays.asList(2, 4, -5, 3, 9, 7))); // Expected: true\n        System.out.println(solution.triples_sum_to_zero(Arrays.asList(1))); // Expected: false\n    }\n}\n"}
{"task_id": "Java/41", "generation": "class Solution {\n    /**\n     * Calculates the number of collisions between two sets of cars moving in opposite directions.\n     *\n     * @param n The number of cars in each set.\n     * @return The total number of collisions.\n     */\n    public int car_race_collision(int n) {\n        return n * n;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.car_race_collision(1)); // Expected output: 1\n        System.out.println(solution.car_race_collision(2)); // Expected output: 4\n        System.out.println(solution.car_race_collision(3)); // Expected output: 9\n        System.out.println(solution.car_race_collision(5)); // Expected output: 25\n    }\n}\n"}
{"task_id": "Java/42", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return list with elements incremented by 1.\n     *\n     * @param l List of integers to be incremented.\n     * @return A new list where each element is the original plus one.\n     */\n    public List<Integer> incr_list(List<Integer> l) {\n        return l.stream().map(x -> x + 1).collect(Collectors.toList());\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        List<Integer> list1 = Arrays.asList(1, 2, 3);\n        System.out.println(solution.incr_list(list1)); // Expected: [2, 3, 4]\n\n        // Test case 2\n        List<Integer> list2 = Arrays.asList(5, 3, 5, 2, 3, 3, 9, 0, 123);\n        System.out.println(solution.incr_list(list2)); // Expected: [6, 4, 6, 3, 4, 4, 10, 1, 124]\n\n        // Test case 3 - empty list\n        List<Integer> list3 = new ArrayList<>();\n        System.out.println(solution.incr_list(list3)); // Expected: []\n\n        // Test case 4 - single element list\n        List<Integer> list4 = Arrays.asList(7);\n        System.out.println(solution.incr_list(list4)); // Expected: [8]\n    }\n}\n"}
{"task_id": "Java/43", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * pairs_sum_to_zero takes a list of integers as an input.\n     * It returns True if there are two distinct elements in the list that sum to zero, and False otherwise.\n     */\n    public boolean pairs_sum_to_zero(List<Integer> l) {\n        Set<Integer> seen = new HashSet<>();\n        \n        for (int num : l) {\n            // Check if the opposite number exists\n            if (seen.contains(-num)) {\n                return true;\n            }\n            seen.add(num);\n        }\n        return false;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.pairs_sum_to_zero(Arrays.asList(1, 3, 5, 0))); // Expected: false\n        System.out.println(solution.pairs_sum_to_zero(Arrays.asList(1, 3, -2, 1))); // Expected: false\n        System.out.println(solution.pairs_sum_to_zero(Arrays.asList(1, 2, 3, 7))); // Expected: false\n        System.out.println(solution.pairs_sum_to_zero(Arrays.asList(2, 4, -5, 3, 5, 7))); // Expected: true\n        System.out.println(solution.pairs_sum_to_zero(Arrays.asList(1))); // Expected: false\n    }\n}\n"}
{"task_id": "Java/44", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Change numerical base of input number x to base.\n     * return string representation after the conversion.\n     * base numbers are less than 10.\n     */\n    public String change_base(int x, int base) {\n        if (base < 2 || base > 9) throw new IllegalArgumentException(\"Base must be between 2 and 9.\");\n        \n        StringBuilder result = new StringBuilder();\n        while (x > 0) {\n            result.insert(0, x % base);\n            x /= base;\n        }\n        return result.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.change_base(8, 3)); // Expected output: \"22\"\n        System.out.println(solution.change_base(8, 2)); // Expected output: \"1000\"\n        System.out.println(solution.change_base(7, 2)); // Expected output: \"111\"\n\n        // Additional test cases\n        System.out.println(solution.change_base(9, 3)); // Expected output: \"100\"\n        System.out.println(solution.change_base(15, 8)); // Expected output: \"17\"\n    }\n}\n"}
{"task_id": "Java/45", "generation": "class Solution {\n    /**\n     * Given length of a side and high return area for a triangle.\n     *\n     * @param a The base length of the triangle.\n     * @param h The height of the triangle.\n     * @return The area of the triangle.\n     */\n    public double triangle_area(double a, double h) {\n        return 0.5 * a * h;\n    }\n}\n"}
{"task_id": "Java/46", "generation": "class Solution {\n    public int fib4(int n) {\n        if (n == 0 || n == 1) return 0;\n        if (n == 2) return 2;\n        if (n == 3) return 0;\n\n        // Initialize the first four values of the sequence.\n        int[] dp = new int[4];\n        dp[0] = 0; // fib4(0)\n        dp[1] = 0; // fib4(1)\n        dp[2] = 2; // fib4(2)\n        dp[3] = 0; // fib4(3)\n\n        for (int i = 4; i <= n; ++i) {\n            int nextValue = dp[0] + dp[1] + dp[2] + dp[3];\n            // Shift the values to the left and set the new value.\n            dp[0] = dp[1];\n            dp[1] = dp[2];\n            dp[2] = dp[3];\n            dp[3] = nextValue;\n        }\n\n        return dp[3];  // The last computed value is fib4(n)\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        \n        System.out.println(sol.fib4(5)); // Expected output: 4\n        System.out.println(sol.fib4(6)); // Expected output: 8\n        System.out.println(sol.fib4(7)); // Expected output: 14\n        \n        // Additional test cases\n        System.out.println(sol.fib4(0)); // Expected output: 0\n        System.out.println(sol.fib4(1)); // Expected output: 0\n        System.out.println(sol.fib4(2)); // Expected output: 2\n        System.out.println(sol.fib4(3)); // Expected output: 0\n    }\n}\n"}
{"task_id": "Java/47", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Return median of elements in the list l.\n     * >>> median(Arrays.asList(3, 1, 2, 4, 5))\n     * 3\n     * >>> median(Arrays.asList(-10, 4, 6, 1000, 10, 20))\n     * 8.0\n     */\n    public double median(List<Integer> l) {\n        Collections.sort(l);\n        int size = l.size();\n        if (size % 2 == 1) { // Odd number of elements\n            return l.get(size / 2);\n        } else { // Even number of elements\n            return (l.get((size - 1) / 2) + l.get(size / 2)) / 2.0;\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        List<Integer> testList1 = Arrays.asList(3, 1, 2, 4, 5);\n        System.out.println(\"Median of \" + testList1 + \": \" + solution.median(testList1)); // Expected: 3\n        \n        List<Integer> testList2 = Arrays.asList(-10, 4, 6, 1000, 10, 20);\n        System.out.println(\"Median of \" + testList2 + \": \" + solution.median(testList2)); // Expected: 8.0\n    }\n}\n"}
{"task_id": "Java/48", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Checks if given string is a palindrome.\n     *\n     * @param text The string to be checked.\n     * @return true if the string is a palindrome, false otherwise.\n     */\n    public boolean is_palindrome(String text) {\n        int left = 0;\n        int right = text.length() - 1;\n\n        while (left < right) {\n            if (text.charAt(left) != text.charAt(right)) {\n                return false;\n            }\n            left++;\n            right--;\n        }\n\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.is_palindrome(\"\"));      // Expected: true\n        System.out.println(solution.is_palindrome(\"aba\"));   // Expected: true\n        System.out.println(solution.is_palindrome(\"aaaaa\")); // Expected: true\n        System.out.println(solution.is_palindrome(\"zbcd\"));  // Expected: false\n    }\n}\n"}
{"task_id": "Java/49", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Return 2^n modulo p (be aware of numerics).\n     */\n    public int modp(int n, int p) {\n        long result = 1;\n        long base = 2;\n\n        while (n > 0) {\n            if ((n & 1) == 1) { // If the current bit is set\n                result = (result * base) % p;\n            }\n            base = (base * base) % p; // Square the base for the next iteration\n            n >>= 1; // Right shift n to process the next bit\n        }\n\n        return (int) result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.modp(3, 5));   // Expected output: 3\n        System.out.println(solution.modp(1101, 101)); // Expected output: 2\n        System.out.println(solution.modp(0, 101));    // Expected output: 1\n        System.out.println(solution.modp(3, 11));     // Expected output: 8\n        System.out.println(solution.modp(100, 101));  // Expected output: 1\n    }\n}\n"}
{"task_id": "Java/50", "generation": "class Solution {\n    /**\n     * Returns encoded string by shifting every character by 5 in the alphabet.\n     */\n    public String encodeShift(String s) {\n        StringBuilder sb = new StringBuilder();\n        for (char ch : s.toCharArray()) {\n            // Ensure that only lowercase letters are shifted, others remain unchanged\n            if (ch >= 'a' && ch <= 'z') {\n                sb.append((char) ('a' + ((ch - 'a' + 5) % 26)));\n            } else {\n                sb.append(ch);\n            }\n        }\n        return sb.toString();\n    }\n\n    /**\n     * Takes as input string encoded with encodeShift function. Returns decoded string.\n     */\n    public String decode_shift(String s) {\n        StringBuilder sb = new StringBuilder();\n        for (char ch : s.toCharArray()) {\n            // Ensure that only lowercase letters are shifted, others remain unchanged\n            if (ch >= 'a' && ch <= 'z') {\n                sb.append((char) ('a' + ((ch - 'a' - 5 + 26) % 26)));\n            } else {\n                sb.append(ch);\n            }\n        }\n        return sb.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        String test1 = \"hello\";\n        System.out.println(\"Original: \" + test1);\n        String encodedTest1 = solution.encodeShift(test1);\n        System.out.println(\"Encoded: \" + encodedTest1);\n        String decodedTest1 = solution.decode_shift(encodedTest1);\n        System.out.println(\"Decoded: \" + decodedTest1);\n\n        String test2 = \"java\";\n        System.out.println(\"\\nOriginal: \" + test2);\n        String encodedTest2 = solution.encodeShift(test2);\n        System.out.println(\"Encoded: \" + encodedTest2);\n        String decodedTest2 = solution.decode_shift(encodedTest2);\n        System.out.println(\"Decoded: \" + decodedTest2);\n\n        // Test case with non-alphabetic characters\n        String test3 = \"java123!\";\n        System.out.println(\"\\nOriginal: \" + test3);\n        String encodedTest3 = solution.encodeShift(test3);\n        System.out.println(\"Encoded: \" + encodedTest3);\n        String decodedTest3 = solution.decode_shift(encodedTest3);\n        System.out.println(\"Decoded: \" + decodedTest3);\n\n        // Check if the original and decoded strings are equal\n        boolean test1Pass = test1.equals(decodedTest1);\n        boolean test2Pass = test2.equals(decodedTest2);\n        boolean test3Pass = test3.equals(decodedTest3);\n\n        System.out.println(\"\\nTests passed: \" + (test1Pass && test2Pass && test3Pass));\n    }\n}\n"}
{"task_id": "Java/51", "generation": "import org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nclass Solution {\n    /**\n     * remove_vowels is a function that takes string and returns string without vowels.\n     */\n    public String remove_vowels(String text) {\n        if (text == null || text.isEmpty()) return text;\n        \n        StringBuilder result = new StringBuilder();\n        for (char c : text.toCharArray()) {\n            char lowerCaseChar = Character.toLowerCase(c);\n            if (lowerCaseChar != 'a' && lowerCaseChar != 'e' && lowerCaseChar != 'i'\n                && lowerCaseChar != 'o' && lowerCaseChar != 'u') {\n                result.append(c);\n            }\n        }\n        \n        return result.toString();\n    }\n\n    @Test\n    public void testRemoveVowels() {\n        assertEquals(\"\", remove_vowels(\"\"));\n        assertEquals(\"bcdf\\nghjklm\", remove_vowels(\"abcdef\\nghijklm\"));\n        assertEquals(\"bcdf\", remove_vowels(\"abcdef\"));\n        assertEquals(\"\", remove_vowels(\"aaaaa\"));\n        assertEquals(\"B\", remove_vowels(\"aaBAA\"));\n        assertEquals(\"zbcd\", remove_vowels(\"zbcd\"));\n    }\n}\n"}
{"task_id": "Java/52", "generation": "import java.util.List;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\nclass Solution {\n    /**\n     * Return True if all numbers in the list l are below threshold t.\n     */\n    public boolean below_threshold(List<Integer> l, int t) {\n        // Check each element to see if it is less than the threshold\n        for (int num : l) {\n            if (num >= t) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    @Test\n    public void testBelowThreshold() {\n        assertTrue(below_threshold(Arrays.asList(1, 2, 4, 10), 100));\n        assertFalse(below_threshold(Arrays.asList(1, 20, 4, 10), 5));\n        assertTrue(below_threshold(Arrays.asList(), 1)); // Test with an empty list\n        assertFalse(below_threshold(Arrays.asList(-1, -2, -3), 0)); // Negative numbers test case\n    }\n}\n"}
{"task_id": "Java/53", "generation": "class Solution {\n    /**\n     * Add two numbers x and y.\n     *\n     * @param x first number to add\n     * @param y second number to add\n     * @return sum of x and y\n     */\n    public int add(int x, int y) {\n        return x + y;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(\"Test Case 1: \" + (solution.add(2, 3) == 5 ? \"Pass\" : \"Fail\"));\n        System.out.println(\"Test Case 2: \" + (solution.add(5, 7) == 12 ? \"Pass\" : \"Fail\"));\n\n        // Additional test cases\n        System.out.println(\"Test Case 3: \" + (solution.add(-1, -1) == -2 ? \"Pass\" : \"Fail\"));\n        System.out.println(\"Test Case 4: \" + (solution.add(0, 0) == 0 ? \"Pass\" : \"Fail\"));\n    }\n}\n"}
{"task_id": "Java/54", "generation": "import java.util.*;\n\nclass Solution {\n\n    /**\n     * Check if two words have the same kind of characters.\n     *\n     * @param s0 first string\n     * @param s1 second string\n     * @return true if both strings contain exactly the same set of unique characters, false otherwise\n     */\n    public boolean same_chars(String s0, String s1) {\n        Set<Character> charsInS0 = new HashSet<>();\n        for (char c : s0.toCharArray()) {\n            charsInS0.add(c);\n        }\n\n        Set<Character> charsInS1 = new HashSet<>();\n        for (char c : s1.toCharArray()) {\n            charsInS1.add(c);\n        }\n\n        return charsInS0.equals(charsInS1);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.same_chars(\"eabcdzzzz\", \"dddzzzzzzzddeddabc\")); // true\n        System.out.println(solution.same_chars(\"abcd\", \"dddddddabc\"));              // true\n        System.out.println(solution.same_chars(\"dddddddabc\", \"abcd\"));             // true\n        System.out.println(solution.same_chars(\"eabcd\", \"dddddddabc\"));            // false\n        System.out.println(solution.same_chars(\"abcd\", \"dddddddabce\"));            // false\n        System.out.println(solution.same_chars(\"eabcdzzzz\", \"dddzzzzzzzddddabc\")); // false\n    }\n}\n"}
{"task_id": "Java/55", "generation": "import org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nclass Solution {\n    /**\n     * Return n-th Fibonacci number.\n     *\n     * @param n the position in the Fibonacci sequence\n     * @return the n-th Fibonacci number\n     */\n    public int fib(int n) {\n        if (n <= 1) {\n            return n;\n        }\n        int a = 0, b = 1, c;\n        for (int i = 2; i <= n; i++) {\n            c = a + b;\n            a = b;\n            b = c;\n        }\n        return b;\n    }\n\n    @Test\n    public void testFib() {\n        assertEquals(55, fib(10), \"fib(10) should be 55\");\n        assertEquals(1, fib(1), \"fib(1) should be 1\");\n        assertEquals(21, fib(8), \"fib(8) should be 21\");\n    }\n}\n"}
{"task_id": "Java/56", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Checks if every opening bracket '<' has a corresponding closing bracket '>'.\n     *\n     * @param brackets A string containing only '<' and '>' characters.\n     * @return true if the sequence of brackets is correct, false otherwise.\n     */\n    public boolean correct_bracketing(String brackets) {\n        int balance = 0;\n        \n        for (char c : brackets.toCharArray()) {\n            if (c == '<') {\n                balance++;\n            } else if (c == '>') {\n                balance--;\n                // If balance is negative, it means there's a closing bracket without an opening one\n                if (balance < 0) {\n                    return false;\n                }\n            }\n        }\n        \n        // If balance is zero at the end, all brackets are correctly matched\n        return balance == 0;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.correct_bracketing(\"<\"));       // false\n        System.out.println(solution.correct_bracketing(\"<>\"));      // true\n        System.out.println(solution.correct_bracketing(\"<<><>>\"));  // true\n        System.out.println(solution.correct_bracketing(\"><<>\"));    // false\n    }\n}\n"}
{"task_id": "Java/57", "generation": "import java.util.*;\n\nclass Solution {\n\n    /**\n     * Return True if list elements are monotonically increasing or decreasing.\n     *\n     * @param l List of integers to check for monotonicity.\n     * @return true if the list is monotonically increasing or decreasing, false otherwise.\n     */\n    public boolean monotonic(List<Integer> l) {\n        // Check if the list is empty or has only one element\n        if (l == null || l.size() <= 1) return true;\n\n        // Determine if the sequence should be increasing or decreasing based on first two elements\n        boolean increasing = l.get(1) >= l.get(0);\n        \n        for (int i = 2; i < l.size(); i++) {\n            if ((increasing && l.get(i) < l.get(i - 1)) || (!increasing && l.get(i) > l.get(i - 1))) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.monotonic(Arrays.asList(1, 2, 4, 20))); // Expected: true\n        System.out.println(solution.monotonic(Arrays.asList(1, 20, 4, 10))); // Expected: false\n        System.out.println(solution.monotonic(Arrays.asList(4, 1, 0, -10))); // Expected: true\n    }\n}\n"}
{"task_id": "Java/58", "generation": "import java.util.*;\n\nclass Solution {\n\n    /**\n     * Return sorted unique common elements for two lists.\n     *\n     * @param l1 first list of integers\n     * @param l2 second list of integers\n     * @return a List containing the sorted unique common elements between l1 and l2\n     */\n    public List<Integer> common(List<Integer> l1, List<Integer> l2) {\n        // Convert both lists to sets to remove duplicates and find intersection\n        Set<Integer> set1 = new HashSet<>(l1);\n        Set<Integer> set2 = new HashSet<>(l2);\n\n        // Retain only the elements that are in both sets (intersection)\n        set1.retainAll(set2);\n\n        // Convert the resulting set back to a list, sort it and return\n        List<Integer> result = new ArrayList<>(set1);\n        Collections.sort(result);\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        System.out.println(solution.common(Arrays.asList(1, 4, 3, 34, 653, 2, 5), Arrays.asList(5, 7, 1, 5, 9, 653, 121)));\n        // Expected output: [1, 5, 653]\n\n        // Test case 2\n        System.out.println(solution.common(Arrays.asList(5, 3, 2, 8), Arrays.asList(3, 2)));\n        // Expected output: [2, 3]\n    }\n}\n"}
{"task_id": "Java/59", "generation": "import java.util.*;\nimport org.junit.*;\n\nclass Solution {\n    /**\n     * Return the largest prime factor of n. Assume n > 1 and is not a prime.\n     *\n     * @param n The number to find the largest prime factor for.\n     * @return The largest prime factor of n.\n     */\n    public int largest_prime_factor(int n) {\n        int maxPrime = -1;\n        \n        // Divide n by 2 until it's odd\n        while (n % 2 == 0) {\n            maxPrime = 2;\n            n /= 2;\n        }\n        \n        // Now n is odd, start from 3 and check for factors\n        for (int i = 3; i <= Math.sqrt(n); i += 2) {\n            while (n % i == 0) {\n                maxPrime = i;\n                n = n / i;\n            }\n        }\n\n        // If n is a prime number greater than 2\n        if (n > 2)\n            maxPrime = n;\n\n        return maxPrime;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.largest_prime_factor(13195)); // Expected output: 29\n        System.out.println(solution.largest_prime_factor(2048));  // Expected output: 2\n    }\n}\n\n// JUnit test class for the largest_prime_factor method\nclass SolutionTest {\n    @Test\n    public void testLargestPrimeFactor() {\n        Solution solution = new Solution();\n        \n        assertEquals(29, solution.largest_prime_factor(13195));\n        assertEquals(2, solution.largest_prime_factor(2048));\n        assertEquals(7, solution.largest_prime_factor(49)); // Additional test case\n    }\n}\n"}
{"task_id": "Java/60", "generation": "import org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nclass Solution {\n    /**\n     * sum_to_n is a function that sums numbers from 1 to n.\n     *\n     * @param n the upper limit for summation\n     * @return the sum of all integers from 1 to n\n     */\n    public int sum_to_n(int n) {\n        return (n * (n + 1)) / 2; // Using the arithmetic series sum formula\n    }\n\n    /**\n     * Test cases for the sum_to_n function.\n     */\n    @Test\n    void testSumToN() {\n        assertEquals(465, sum_to_n(30));\n        assertEquals(5050, sum_to_n(100));\n        assertEquals(15, sum_to_n(5));\n        assertEquals(55, sum_to_n(10));\n        assertEquals(1, sum_to_n(1));\n    }\n}\n"}
{"task_id": "Java/61", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Checks if every opening bracket has a corresponding closing bracket.\n     *\n     * @param brackets A string containing only '(' and ')'.\n     * @return true if the brackets are correctly matched, false otherwise.\n     */\n    public boolean correct_bracketing(String brackets) {\n        Stack<Character> stack = new Stack<>();\n        \n        for (char ch : brackets.toCharArray()) {\n            if (ch == '(') {\n                stack.push(ch);\n            } else if (ch == ')') {\n                if (stack.isEmpty() || stack.pop() != '(') {\n                    return false;\n                }\n            }\n        }\n\n        // If the stack is empty, all opening brackets had a matching closing bracket\n        return stack.isEmpty();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.correct_bracketing(\"(\"));       // Expected: false\n        System.out.println(solution.correct_bracketing(\"()\"));      // Expected: true\n        System.out.println(solution.correct_bracketing(\"(()())\"));  // Expected: true\n        System.out.println(solution.correct_bracketing(\")(()\"));    // Expected: false\n    }\n}\n"}
{"task_id": "Java/62", "generation": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\nclass Solution {\n    /**\n     * xs represent coefficients of a polynomial.\n     * xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     * Return derivative of this polynomial in the same form.\n     */\n    public List<Integer> derivative(List<Integer> xs) {\n        List<Integer> result = new ArrayList<>();\n        for (int i = 1; i < xs.size(); i++) {\n            // The coefficient of the derivative is index times the original coefficient\n            result.add(i * xs.get(i));\n        }\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        List<Integer> test1 = Arrays.asList(3, 1, 2, 4, 5);\n        System.out.println(\"Derivative of [3, 1, 2, 4, 5]: \" + solution.derivative(test1));\n        // Expected: [1, 4, 12, 20]\n\n        List<Integer> test2 = Arrays.asList(1, 2, 3);\n        System.out.println(\"Derivative of [1, 2, 3]: \" + solution.derivative(test2));\n        // Expected: [2, 6]\n    }\n}\n"}
{"task_id": "Java/63", "generation": "class Solution {\n    public int fibfib(int n) {\n        if (n == 0 || n == 1) return 0;\n        if (n == 2) return 1;\n\n        // Initialize an array to store the computed values of FibFib sequence.\n        int[] dp = new int[n + 1];\n        dp[0] = 0; // fibfib(0)\n        dp[1] = 0; // fibfib(1)\n        dp[2] = 1; // fibfib(2)\n\n        for (int i = 3; i <= n; ++i) {\n            dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3];\n        }\n\n        return dp[n];\n    }\n    \n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.fibfib(1)); // Expected output: 0\n        System.out.println(solution.fibfib(5)); // Expected output: 4\n        System.out.println(solution.fibfib(8)); // Expected output: 24\n    }\n}\n"}
{"task_id": "Java/64", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Returns the number of vowels in the string. Vowels are 'a', 'e', 'i', 'o', 'u'.\n     * Additionally, 'y' is considered a vowel only if it is at the end of the word.\n     *\n     * @param s The input string representing a word\n     * @return The number of vowels in the string\n     */\n    public int vowels_count(String s) {\n        // Convert to lowercase for simplicity\n        String lowerCase = s.toLowerCase();\n        int count = 0;\n\n        // Iterate through each character and check if it's a vowel\n        for (int i = 0; i < lowerCase.length(); i++) {\n            char c = lowerCase.charAt(i);\n            if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n                count++;\n            } else if (c == 'y' && i == lowerCase.length() - 1) { // Check for 'y' at the end\n                count++;\n            }\n        }\n\n        return count;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases to verify the correctness of the function\n        System.out.println(solution.vowels_count(\"abcde\"));  // Expected output: 2\n        System.out.println(solution.vowels_count(\"ACEDY\"));  // Expected output: 3\n        System.out.println(solution.vowels_count(\"rhythm\")); // Expected output: 0 (no vowels)\n        System.out.println(solution.vowels_count(\"SYZYGY\")); // Expected output: 1 ('y' at the end is a vowel)\n    }\n}\n"}
{"task_id": "Java/65", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Circular shift the digits of the integer x, shifting the digits right by shift.\n     * If shift > number of digits, return digits reversed.\n     *\n     * @param x The integer whose digits are to be shifted.\n     * @param shift The amount to shift the digits to the right.\n     * @return A string representing the result after circularly shifting the digits of x.\n     */\n    public String circular_shift(int x, int shift) {\n        // Convert the number to a string for easy manipulation\n        String numStr = Integer.toString(x);\n        int len = numStr.length();\n\n        // If shift is greater than or equal to length, reverse the string\n        if (shift >= len) {\n            return new StringBuilder(numStr).reverse().toString();\n        }\n\n        // Calculate effective shift in case of multiple full rotations\n        shift %= len;\n\n        // Perform circular shift\n        String shifted = numStr.substring(len - shift) + numStr.substring(0, len - shift);\n        \n        return shifted;\n    }\n    \n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.circular_shift(12, 1)); // Expected: \"21\"\n        System.out.println(solution.circular_shift(12, 2)); // Expected: \"12\"\n        System.out.println(solution.circular_shift(12345, 2)); // Expected: \"45123\"\n        System.out.println(solution.circular_shift(12345, 7)); // Expected: \"54321\" (since shift > number of digits)\n    }\n}\n"}
{"task_id": "Java/66", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Write a function that takes a string as input and returns the sum of the upper characters only'\n     * ASCII codes.\n     *\n     * Examples:\n     * digitSum(\"\") => 0\n     * digitSum(\"abAB\") => 131\n     * digitSum(\"abcCd\") => 67\n     * digitSum(\"helloE\") => 69\n     * digitSum(\"woArBld\") => 131\n     * digitSum(\"aAaaaXa\") => 153\n     */\n    public int digitSum(String s) {\n        int sum = 0;\n        for (char c : s.toCharArray()) {\n            if (Character.isUpperCase(c)) {\n                sum += (int)c; // Add ASCII value of uppercase character to the sum.\n            }\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.digitSum(\"\")); // Expected output: 0\n        System.out.println(solution.digitSum(\"abAB\")); // Expected output: 131\n        System.out.println(solution.digitSum(\"abcCd\")); // Expected output: 67\n        System.out.println(solution.digitSum(\"helloE\")); // Expected output: 69\n        System.out.println(solution.digitSum(\"woArBld\")); // Expected output: 131\n        System.out.println(solution.digitSum(\"aAaaaXa\")); // Expected output: 153\n    }\n}\n"}
{"task_id": "Java/67", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Calculates the number of mangoes in the basket.\n     *\n     * @param s A string representing the total number of apples and oranges.\n     * @param n An integer representing the total number of fruits in the basket.\n     * @return The number of mangoes in the basket.\n     */\n    public int fruit_distribution(String s, int n) {\n        // Extract numbers from the string\n        String[] parts = s.split(\" \");\n        int apples = Integer.parseInt(parts[0]);\n        int oranges = Integer.parseInt(parts[3]);\n\n        // Calculate and return the number of mangoes\n        return n - (apples + oranges);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.fruit_distribution(\"5 apples and 6 oranges\", 19)); // Expected output: 8\n        System.out.println(solution.fruit_distribution(\"0 apples and 1 oranges\", 3));  // Expected output: 2\n        System.out.println(solution.fruit_distribution(\"2 apples and 3 oranges\", 100)); // Expected output: 95\n        System.out.println(solution.fruit_distribution(\"100 apples and 1 oranges\", 120)); // Expected output: 19\n    }\n}\n"}
{"task_id": "Java/68", "generation": "import java.util.*;\n\nclass Solution {\n    public List<Integer> pluck(List<Integer> arr) {\n        int minEvenValue = Integer.MAX_VALUE;\n        int minIndex = -1;\n\n        for (int i = 0; i < arr.size(); i++) {\n            int value = arr.get(i);\n            if (value % 2 == 0 && value <= minEvenValue) {\n                // If we find a smaller even number or the same one with a smaller index\n                if (value < minEvenValue || (value == minEvenValue && i < minIndex)) {\n                    minEvenValue = value;\n                    minIndex = i;\n                }\n            }\n        }\n\n        if (minIndex == -1) {\n            // No even number found, return an empty list\n            return Collections.emptyList();\n        } else {\n            // Return the smallest even value and its index\n            return Arrays.asList(minEvenValue, minIndex);\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        List<Integer> test1 = Arrays.asList(4, 2, 3);\n        System.out.println(solution.pluck(test1)); // Expected: [2, 1]\n\n        List<Integer> test2 = Arrays.asList(1, 2, 3);\n        System.out.println(solution.pluck(test2)); // Expected: [2, 1]\n\n        List<Integer> test3 = new ArrayList<>();\n        System.out.println(solution.pluck(test3)); // Expected: []\n\n        List<Integer> test4 = Arrays.asList(5, 0, 3, 0, 4, 2);\n        System.out.println(solution.pluck(test4)); // Expected: [0, 1]\n    }\n}\n"}
{"task_id": "Java/69", "generation": "import java.util.*;\n\nclass Solution {\n    public int search(List<Integer> lst) {\n        // Create a frequency map for each integer in the list.\n        Map<Integer, Integer> freqMap = new HashMap<>();\n        \n        // Populate the frequency map.\n        for (int num : lst) {\n            freqMap.put(num, freqMap.getOrDefault(num, 0) + 1);\n        }\n        \n        int result = -1;\n        \n        // Iterate through each entry in the frequency map to find the required integer.\n        for (Map.Entry<Integer, Integer> entry : freqMap.entrySet()) {\n            if (entry.getKey() <= entry.getValue()) {\n                result = Math.max(result, entry.getKey());\n            }\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.search(Arrays.asList(4, 1, 2, 2, 3, 1))); // Expected output: 2\n        System.out.println(solution.search(Arrays.asList(1, 2, 2, 3, 3, 3, 4, 4, 4))); // Expected output: 3\n        System.out.println(solution.search(Arrays.asList(5, 5, 4, 4, 4))); // Expected output: -1\n    }\n}\n"}
{"task_id": "Java/70", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given list of integers, return list in strange order.\n     * Strange sorting, is when you start with the minimum value,\n     * then maximum of the remaining integers, then minimum and so on.\n     *\n     * @param lst List of integers to be sorted strangely\n     * @return A new list containing elements sorted in a strange order\n     */\n    public List<Integer> strange_sort_list(List<Integer> lst) {\n        if (lst == null || lst.isEmpty()) {\n            return lst;\n        }\n\n        // Sort the list first\n        Collections.sort(lst);\n\n        LinkedList<Integer> result = new LinkedList<>();\n        int left = 0; // Start of the list\n        int right = lst.size() - 1; // End of the list\n\n        while (left <= right) {\n            if (left == right) {\n                result.add(lst.get(left));\n                break;\n            }\n            // Add minimum value first, then maximum\n            result.add(lst.get(left++));\n            result.add(lst.get(right--));\n        }\n\n        return new ArrayList<>(result);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        List<Integer> test1 = Arrays.asList(1, 2, 3, 4);\n        System.out.println(solution.strange_sort_list(test1)); // Expected: [1, 4, 2, 3]\n\n        List<Integer> test2 = Arrays.asList(5, 5, 5, 5);\n        System.out.println(solution.strange_sort_list(test2)); // Expected: [5, 5, 5, 5]\n\n        List<Integer> test3 = new ArrayList<>();\n        System.out.println(solution.strange_sort_list(test3)); // Expected: []\n    }\n}\n"}
{"task_id": "Java/71", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given the lengths of the three sides of a triangle.\n     * Return the area of the triangle rounded to 2 decimal points if the three sides form a valid triangle.\n     * Otherwise return -1\n     * Three sides make a valid triangle when the sum of any two sides is greater than the third side.\n     */\n    public double triangle_area(double a, double b, double c) {\n        // Check for validity of the triangle\n        if (a + b <= c || a + c <= b || b + c <= a) {\n            return -1;\n        }\n\n        // Calculate semi-perimeter\n        double s = (a + b + c) / 2;\n\n        // Using Heron's formula to calculate area\n        double area = Math.sqrt(s * (s - a) * (s - b) * (s - c));\n\n        // Round the result to two decimal places\n        return Math.round(area * 100.0) / 100.0;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.triangle_area(3, 4, 5)); // Expected output: 6.00\n        System.out.println(solution.triangle_area(1, 2, 10)); // Expected output: -1\n        System.out.println(solution.triangle_area(7, 8, 9)); // Expected output: 26.83\n    }\n}\n"}
{"task_id": "Java/72", "generation": "import java.util.*;\n\nclass Solution {\n    public boolean will_it_fly(List<Integer> q, int w) {\n        // Check if the list is a palindrome.\n        for (int i = 0; i < q.size() / 2; i++) {\n            if (!q.get(i).equals(q.get(q.size() - 1 - i))) {\n                return false;\n            }\n        }\n\n        // Calculate the sum of elements in the list.\n        int sum = 0;\n        for (int num : q) {\n            sum += num;\n        }\n\n        // Check if the sum is less than or equal to w.\n        return sum <= w;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.will_it_fly(Arrays.asList(1, 2), 5)); // Expected: false\n        System.out.println(solution.will_it_fly(Arrays.asList(3, 2, 3), 1)); // Expected: false\n        System.out.println(solution.will_it_fly(Arrays.asList(3, 2, 3), 9)); // Expected: true\n        System.out.println(solution.will_it_fly(Arrays.asList(3), 5)); // Expected: true\n    }\n}\n"}
{"task_id": "Java/73", "generation": "import java.util.*;\n\nclass Solution {\n    public int smallest_change(List<Integer> arr) {\n        if (arr == null || arr.size() <= 1) return 0;\n\n        int changes = 0;\n        int left = 0, right = arr.size() - 1;\n\n        while (left < right) {\n            if (!arr.get(left).equals(arr.get(right))) {\n                changes++;\n            }\n            left++;\n            right--;\n        }\n\n        return changes;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        List<Integer> arr1 = Arrays.asList(1, 2, 3, 5, 4, 7, 9, 6);\n        System.out.println(\"Test Case 1: \" + (solution.smallest_change(arr1) == 4 ? \"Passed\" : \"Failed\"));\n\n        // Test case 2\n        List<Integer> arr2 = Arrays.asList(1, 2, 3, 4, 3, 2, 2);\n        System.out.println(\"Test Case 2: \" + (solution.smallest_change(arr2) == 1 ? \"Passed\" : \"Failed\"));\n\n        // Test case 3\n        List<Integer> arr3 = Arrays.asList(1, 2, 3, 2, 1);\n        System.out.println(\"Test Case 3: \" + (solution.smallest_change(arr3) == 0 ? \"Passed\" : \"Failed\"));\n    }\n}\n"}
{"task_id": "Java/74", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Write a function that accepts two lists of strings and returns the list that has\n     * total number of chars in all strings of the list less than the other list.\n     *\n     * If the two lists have the same number of chars, return the first list.\n     */\n    public List<String> total_match(List<String> lst1, List<String> lst2) {\n        int count1 = 0;\n        for (String s : lst1) {\n            count1 += s.length();\n        }\n\n        int count2 = 0;\n        for (String s : lst2) {\n            count2 += s.length();\n        }\n\n        if (count1 <= count2) {\n            return lst1;\n        } else {\n            return lst2;\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.total_match(Arrays.asList(), Arrays.asList())); // -> []\n        System.out.println(solution.total_match(Arrays.asList(\"hi\", \"admin\"), Arrays.asList(\"hI\", \"Hi\"))); // -> [\"hI\", \"Hi\"]\n        System.out.println(solution.total_match(Arrays.asList(\"hi\", \"admin\"), Arrays.asList(\"hi\", \"hi\", \"admin\", \"project\"))); // -> [\"hi\", \"admin\"]\n        System.out.println(solution.total_match(Arrays.asList(\"hi\", \"admin\"), Arrays.asList(\"hI\", \"hi\", \"hi\"))); // -> [\"hI\", \"hi\", \"hi\"]\n        System.out.println(solution.total_match(Arrays.asList(\"4\"), Arrays.asList(\"1\", \"2\", \"3\", \"4\", \"5\"))); // -> [\"4\"]\n    }\n}\n"}
{"task_id": "Java/75", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Checks if a number is the multiplication of exactly 3 prime numbers.\n     *\n     * @param a The number to check.\n     * @return true if the given number is the product of three primes, false otherwise.\n     */\n    public boolean is_multiply_prime(int a) {\n        // List of all prime numbers less than 100\n        int[] primes = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97};\n        \n        // Loop through the primes to find three that multiply to a\n        for (int i = 0; i < primes.length; i++) {\n            if (a % primes[i] == 0) { // If prime is a factor of a\n                int b = a / primes[i];\n                for (int j = i; j < primes.length; j++) {\n                    if (b % primes[j] == 0) { // Check the second prime\n                        int c = b / primes[j];\n                        for (int k = j; k < primes.length; k++) {\n                            if (c == primes[k]) { // Check the third prime\n                                return true;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        \n        return false;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.is_multiply_prime(30));  // Expected: true (2 * 3 * 5)\n        System.out.println(solution.is_multiply_prime(60));  // Expected: true (2 * 2 * 15, but only unique primes are considered)\n        System.out.println(solution.is_multiply_prime(7));   // Expected: false\n        System.out.println(solution.is_multiply_prime(105)); // Expected: true (3 * 5 * 7)\n    }\n}\n"}
{"task_id": "Java/76", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Checks if x is a simple power of n.\n     *\n     * @param x The number to check.\n     * @param n The base number.\n     * @return true if x is a simple power of n, false otherwise.\n     */\n    public boolean is_simple_power(int x, int n) {\n        // Special case: any number to the power of 0 is 1\n        if (x == 1) return true;\n        \n        // If n is 1 and x is not 1, it's impossible for x to be a simple power of n.\n        if (n == 1 && x != 1) return false;\n\n        int temp = n;\n        while (temp < x) {\n            temp *= n;\n        }\n        \n        // If the loop ends with temp equaling x, then x is indeed a simple power of n\n        return temp == x;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.is_simple_power(1, 4)); // true\n        System.out.println(solution.is_simple_power(2, 2)); // true\n        System.out.println(solution.is_simple_power(8, 2)); // true\n        System.out.println(solution.is_simple_power(3, 2)); // false\n        System.out.println(solution.is_simple_power(3, 1)); // false\n        System.out.println(solution.is_simple_power(5, 3)); // false\n        \n        // Additional test cases\n        System.out.println(solution.is_simple_power(9, 3)); // true\n        System.out.println(solution.is_simple_power(27, 3)); // true\n        System.out.println(solution.is_simple_power(16, 4)); // true\n    }\n}\n"}
{"task_id": "Java/77", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Checks if a given integer 'a' is a perfect cube.\n     *\n     * @param a The integer to be checked.\n     * @return true if 'a' is a perfect cube, false otherwise.\n     */\n    public boolean iscube(int a) {\n        // Calculate the cube root of the absolute value of 'a'\n        double cubeRoot = Math.cbrt(Math.abs(a));\n        \n        // Check if the cube root is an integer by comparing it to its rounded version\n        return (Math.round(cubeRoot) - cubeRoot) == 0;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.iscube(1));   // Expected: true\n        System.out.println(solution.iscube(2));   // Expected: false\n        System.out.println(solution.iscube(-1));  // Expected: true\n        System.out.println(solution.iscube(64));  // Expected: true\n        System.out.println(solution.iscube(0));   // Expected: true\n        System.out.println(solution.iscube(180)); // Expected: false\n    }\n}\n"}
{"task_id": "Java/78", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Counts the number of hexadecimal digits that are primes.\n     *\n     * @param num A string representing a hexadecimal number.\n     * @return The count of prime hexadecimal digits in the input string.\n     */\n    public int hex_key(String num) {\n        // Map to store prime hexadecimal digits\n        Set<Character> primeHexDigits = new HashSet<>(Arrays.asList('2', '3', '5', '7', 'B', 'D'));\n        \n        int count = 0;\n        for (char c : num.toCharArray()) {\n            if (primeHexDigits.contains(c)) {\n                count++;\n            }\n        }\n        return count;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.hex_key(\"AB\"));          // Expected output: 1\n        System.out.println(solution.hex_key(\"1077E\"));       // Expected output: 2\n        System.out.println(solution.hex_key(\"ABED1A33\"));    // Expected output: 4\n        System.out.println(solution.hex_key(\"123456789ABCDEF0\")); // Expected output: 6\n        System.out.println(solution.hex_key(\"2020\"));        // Expected output: 2\n    }\n}\n"}
{"task_id": "Java/79", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n    Converts a given decimal number into binary format and returns it as a string.\n    The returned string has 'db' at both the beginning and end for formatting purposes.\n\n    Examples:\n    decimal_to_binary(15)   // returns \"db1111db\"\n    decimal_to_binary(32)   // returns \"db100000db\"\n     */\n    public String decimal_to_binary(int decimal) {\n        if (decimal < 0) {\n            throw new IllegalArgumentException(\"Decimal number must be non-negative.\");\n        }\n        \n        // Convert the decimal to binary\n        String binary = Integer.toBinaryString(decimal);\n        \n        // Add 'db' at the beginning and end of the string\n        return \"db\" + binary + \"db\";\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.decimal_to_binary(15));  // Expected: db1111db\n        System.out.println(solution.decimal_to_binary(32));  // Expected: db100000db\n        System.out.println(solution.decimal_to_binary(0));   // Expected: db0db\n        System.out.println(solution.decimal_to_binary(255)); // Expected: db11111111db\n        \n        try {\n            System.out.println(solution.decimal_to_binary(-1));  // Should throw an exception\n        } catch (IllegalArgumentException e) {\n            System.out.println(e.getMessage());  // Expected: Decimal number must be non-negative.\n        }\n    }\n}\n"}
{"task_id": "Java/80", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Checks if a string is happy.\n     * A string is happy if its length is at least 3 and every 3 consecutive letters are distinct.\n     *\n     * @param s The input string to check.\n     * @return true if the string is happy, false otherwise.\n     */\n    public boolean is_happy(String s) {\n        // Check if the string's length is less than 3\n        if (s.length() < 3) return false;\n\n        // Iterate through the string and check every 3 consecutive characters\n        for (int i = 0; i < s.length() - 2; i++) {\n            char first = s.charAt(i);\n            char second = s.charAt(i + 1);\n            char third = s.charAt(i + 2);\n\n            // If any of the three consecutive characters are not distinct, return false\n            if (first == second || first == third || second == third) {\n                return false;\n            }\n        }\n\n        // If all checks pass, the string is happy\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases to verify the correctness of the method\n        System.out.println(solution.is_happy(\"a\"));       // false\n        System.out.println(solution.is_happy(\"aa\"));      // false\n        System.out.println(solution.is_happy(\"abcd\"));    // true\n        System.out.println(solution.is_happy(\"aabb\"));    // false\n        System.out.println(solution.is_happy(\"adb\"));     // true\n        System.out.println(solution.is_happy(\"xyy\"));     // false\n    }\n}\n"}
{"task_id": "Java/81", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<String> numerical_letter_grade(List<Double> grades) {\n        List<String> result = new ArrayList<>();\n        \n        for (Double gpa : grades) {\n            if (gpa >= 4.0) {\n                result.add(\"A+\");\n            } else if (gpa > 3.7) {\n                result.add(\"A\");\n            } else if (gpa > 3.3) {\n                result.add(\"A-\");\n            } else if (gpa > 3.0) {\n                result.add(\"B+\");\n            } else if (gpa > 2.7) {\n                result.add(\"B\");\n            } else if (gpa > 2.3) {\n                result.add(\"B-\");\n            } else if (gpa > 2.0) {\n                result.add(\"C+\");\n            } else if (gpa > 1.7) {\n                result.add(\"C\");\n            } else if (gpa > 1.3) {\n                result.add(\"C-\");\n            } else if (gpa > 1.0) {\n                result.add(\"D+\");\n            } else if (gpa > 0.7) {\n                result.add(\"D\");\n            } else if (gpa >= 0.0) {\n                result.add(\"D-\");\n            } else {\n                result.add(\"E\");\n            }\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case\n        List<Double> testGrades1 = Arrays.asList(4.0, 3.0, 1.7, 2.0, 3.5);\n        System.out.println(solution.numerical_letter_grade(testGrades1)); // Expected: [A+, B, C-, C, A-]\n        \n        List<Double> testGrades2 = Arrays.asList(4.0, 3.8, 3.3, 2.7, 2.3);\n        System.out.println(solution.numerical_letter_grade(testGrades2)); // Expected: [A+, A, A-, B, B-]\n        \n        List<Double> testGrades3 = Arrays.asList(0.5, -1.0, 1.4, 2.8, 3.6);\n        System.out.println(solution.numerical_letter_grade(testGrades3)); // Expected: [D-, E, C-, B+, A-]\n    }\n}\n"}
{"task_id": "Java/82", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Checks if a given number is prime.\n     *\n     * @param num The number to check.\n     * @return true if the number is prime, false otherwise.\n     */\n    private boolean isPrime(int num) {\n        if (num <= 1) return false;\n        for (int i = 2; i * i <= num; i++) {\n            if (num % i == 0) return false;\n        }\n        return true;\n    }\n\n    /**\n     * Returns true if the string length is a prime number or false otherwise.\n     *\n     * @param string The input string to check.\n     * @return true if the length of the string is a prime number, false otherwise.\n     */\n    public boolean prime_length(String string) {\n        return isPrime(string.length());\n    }\n\n    /**\n     * Main method for testing the prime_length function with various test cases.\n     *\n     * @param args Command line arguments (not used).\n     */\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.prime_length(\"Hello\"));   // Expected: true\n        System.out.println(solution.prime_length(\"abcdcba\")); // Expected: true\n        System.out.println(solution.prime_length(\"kittens\")); // Expected: true\n        System.out.println(solution.prime_length(\"orange\"));  // Expected: false\n    }\n}\n"}
{"task_id": "Java/83", "generation": "class Solution {\n    /**\n     * Given a positive integer n, return the count of the numbers of n-digit\n     * positive integers that start or end with 1.\n     */\n    public int starts_one_ends(int n) {\n        if (n == 1) {\n            // If n is 1, there's only one digit number which can be 1 itself.\n            return 1;\n        }\n        \n        // Total count of n-digit numbers that start or end with 1\n        int total = 0;\n\n        // Count for numbers starting with 1: 10^(n-1)\n        total += (int) Math.pow(10, n - 1);\n\n        // Count for numbers ending with 1 but not starting with 1:\n        // There are 9 options for the first digit and 10^(n-2) options for the middle digits.\n        if (n > 1) {\n            total += 9 * (int) Math.pow(10, n - 2);\n        }\n\n        return total;\n    }\n    \n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.starts_one_ends(1));  // Expected output: 1\n        System.out.println(solution.starts_one_ends(2));  // Expected output: 19 (10 + 9)\n        System.out.println(solution.starts_one_ends(3));  // Expected output: 180 (100 + 9*10)\n    }\n}\n"}
{"task_id": "Java/84", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a positive integer N, return in binary the total sum of its digits.\n     *\n     * @param N The input number (0 <= N <= 10000).\n     * @return A string representing the binary form of the sum of digits.\n     */\n    public String solve(int N) {\n        int sum = 0;\n        \n        // Calculate the sum of digits\n        while (N > 0) {\n            sum += N % 10;\n            N /= 10;\n        }\n        \n        // Convert the sum to binary and return it as a string.\n        return Integer.toBinaryString(sum);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.solve(1000));  // Expected output: \"1\"\n        System.out.println(solution.solve(150));   // Expected output: \"110\"\n        System.out.println(solution.solve(147));   // Expected output: \"1100\"\n    }\n}\n"}
{"task_id": "Java/85", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given a non-empty list of integers lst, add the even elements that are at odd indices.\n     *\n     * @param lst List of integers.\n     * @return Sum of even elements at odd indices.\n     */\n    public int add(List<Integer> lst) {\n        if (lst == null || lst.isEmpty()) return 0;\n\n        int sum = 0;\n        // Iterate over the list, starting from index 1 and incrementing by 2 to only check odd indices\n        for (int i = 1; i < lst.size(); i += 2) {\n            if (lst.get(i) % 2 == 0) { // Check if element at current index is even\n                sum += lst.get(i);\n            }\n        }\n\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.add(Arrays.asList(4, 2, 6, 7))); // Expected output: 2\n        System.out.println(solution.add(Arrays.asList(1, 3, 5, 7, 9, 10))); // Expected output: 0 (no even elements at odd indices)\n        System.out.println(solution.add(Arrays.asList(2, 4, 6, 8, 10, 12))); // Expected output: 12\n    }\n}\n"}
{"task_id": "Java/86", "generation": "class Solution {\n    public String anti_shuffle(String s) {\n        // Split the string into words using space as delimiter.\n        String[] words = s.split(\" \");\n        \n        // Process each word to sort its characters.\n        for (int i = 0; i < words.length; i++) {\n            char[] chars = words[i].toCharArray();\n            Arrays.sort(chars);\n            words[i] = new String(chars);\n        }\n        \n        // Join the processed words back into a single string with spaces in between.\n        return String.join(\" \", words);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.anti_shuffle(\"Hi\"));  // Expected: \"Hi\"\n        System.out.println(solution.anti_shuffle(\"hello\"));  // Expected: \"ehllo\"\n        System.out.println(solution.anti_shuffle(\"Hello World!!!\"));  // Expected: \"Hello !!!Wdlor\"\n    }\n}\n"}
{"task_id": "Java/87", "generation": "import java.util.*;\n\nclass Solution {\n    public List<List<Integer>> get_row(List<List<Integer>> lst, int x) {\n        // Initialize the result list.\n        List<List<Integer>> result = new ArrayList<>();\n\n        // Iterate over each row in the 2D list.\n        for (int i = 0; i < lst.size(); i++) {\n            List<Integer> currentRow = lst.get(i);\n            \n            // For each element in the row, check if it matches x.\n            for (int j = 0; j < currentRow.size(); j++) {\n                if (currentRow.get(j) == x) {\n                    // If found, add its coordinates to the result list.\n                    List<Integer> coordinate = new ArrayList<>();\n                    coordinate.add(i);\n                    coordinate.add(j);\n                    result.add(coordinate);\n                }\n            }\n        }\n\n        // Sort the result by row in ascending order and then by column in descending order within each row.\n        Collections.sort(result, (a, b) -> {\n            int compareRows = a.get(0).compareTo(b.get(0));\n            if (compareRows == 0) {\n                return b.get(1).compareTo(a.get(1)); // Descending for columns\n            }\n            return compareRows;\n        });\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        List<List<Integer>> test1 = Arrays.asList(\n                Arrays.asList(1, 2, 3, 4, 5, 6),\n                Arrays.asList(1, 2, 3, 4, 1, 6),\n                Arrays.asList(1, 2, 3, 4, 5, 1)\n        );\n        System.out.println(solution.get_row(test1, 1)); // Expected: [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n\n        List<List<Integer>> test2 = new ArrayList<>();\n        System.out.println(solution.get_row(test2, 1)); // Expected: []\n\n        List<List<Integer>> test3 = Arrays.asList(\n                new ArrayList<>(),\n                Arrays.asList(1),\n                Arrays.asList(1, 2, 3)\n        );\n        System.out.println(solution.get_row(test3, 3)); // Expected: [[2, 2]]\n    }\n}\n"}
{"task_id": "Java/88", "generation": "import java.util.*;\n\nclass Solution {\n    public List<Integer> sort_array(List<Integer> array) {\n        // Check if the list is empty or has only one element, return as is.\n        if (array == null || array.size() <= 1) {\n            return new ArrayList<>(array);\n        }\n\n        // Create a copy of the input list to avoid modifying the original list\n        List<Integer> sortedArray = new ArrayList<>(array);\n\n        // Determine sorting order based on the sum of first and last elements\n        boolean isAscending = (sortedArray.get(0) + sortedArray.get(sortedArray.size() - 1)) % 2 != 0;\n\n        // Sort the array in ascending or descending order accordingly\n        if (isAscending) {\n            Collections.sort(sortedArray);\n        } else {\n            Collections.sort(sortedArray, Collections.reverseOrder());\n        }\n\n        return sortedArray;\n    }\n}\n"}
{"task_id": "Java/89", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Encrypts a string by rotating each letter down by four places.\n     *\n     * @param s The input string to be encrypted.\n     * @return The encrypted string.\n     */\n    public String encrypt(String s) {\n        StringBuilder result = new StringBuilder();\n        for (char c : s.toCharArray()) {\n            if (Character.isLetter(c)) {\n                char base = Character.isUpperCase(c) ? 'A' : 'a';\n                // Rotate the character down by four places\n                int rotatedChar = ((c - base + 4) % 26) + base;\n                result.append((char) rotatedChar);\n            } else {\n                // Non-letter characters are not encrypted and remain unchanged.\n                result.append(c);\n            }\n        }\n        return result.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.encrypt(\"hi\"));  // Expected: \"lm\"\n        System.out.println(solution.encrypt(\"asdfghjkl\"));  // Expected: \"ewhjklnop\"\n        System.out.println(solution.encrypt(\"gf\"));  // Expected: \"kj\"\n        System.out.println(solution.encrypt(\"et\"));  // Expected: \"ix\"\n\n        // Additional test cases\n        System.out.println(solution.encrypt(\"abc\"));  // Expected: \"efg\"\n        System.out.println(solution.encrypt(\"xyz\"));  // Expected: \"bcd\"\n        System.out.println(solution.encrypt(\"Hello, World!\"));  // Expected: \"Lipps, Asvph!\"\n    }\n}\n"}
{"task_id": "Java/90", "generation": "import java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\nclass Solution {\n    /**\n     * Finds the second smallest element in a list of integers.\n     *\n     * @param lst List of integers to search through.\n     * @return Optional containing the 2nd smallest integer, or empty if not applicable.\n     */\n    public Optional<Integer> next_smallest(List<Integer> lst) {\n        if (lst == null || lst.size() < 2) {\n            return Optional.empty();\n        }\n\n        TreeSet<Integer> sortedSet = new TreeSet<>(lst);\n        Integer secondSmallest = null;\n        \n        // Skip the first element which is the smallest\n        boolean foundFirst = false;\n        for (Integer num : sortedSet) {\n            if (!foundFirst) {\n                foundFirst = true;  // Mark that we've seen the smallest number\n            } else {\n                secondSmallest = num;  // The next one will be the second smallest\n                break;\n            }\n        }\n\n        return Optional.ofNullable(secondSmallest);\n    }\n\n    @Test\n    public void testNextSmallest() {\n        assertEquals(Optional.of(2), next_smallest(Arrays.asList(1, 2, 3, 4, 5)));\n        assertEquals(Optional.of(2), next_smallest(Arrays.asList(5, 1, 4, 3, 2)));\n        assertEquals(Optional.empty(), next_smallest(new ArrayList<>()));\n        assertEquals(Optional.empty(), next_smallest(Arrays.asList(1, 1)));\n    }\n}\n"}
{"task_id": "Java/91", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Counts the number of boredoms (sentences starting with \"I\").\n     *\n     * @param S The input string containing sentences.\n     * @return The count of boredoms in the given string.\n     */\n    public int isBored(String S) {\n        // Split the input string into sentences based on '.', '?' or '!'\n        String[] sentences = S.split(\"[.?!]\");\n        \n        int boredomCount = 0;\n        \n        for (String sentence : sentences) {\n            // Trim leading and trailing spaces\n            sentence = sentence.trim();\n            \n            // Check if the sentence starts with \"I\"\n            if (sentence.startsWith(\"I \")) {\n                boredomCount++;\n            }\n        }\n        \n        return boredomCount;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.isBored(\"Hello world\"));  // Expected output: 0\n        System.out.println(solution.isBored(\"The sky is blue. The sun is shining. I love this weather.\"));  // Expected output: 1\n        System.out.println(solution.isBored(\"I am happy. I am excited! Are you? I think so.\"));  // Expected output: 3\n    }\n}\n"}
{"task_id": "Java/92", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Create a function that takes 3 numbers.\n     * Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n     * Returns false in any other cases.\n     *\n     * Examples:\n     * any_int(5, 2, 7) -> true\n     * any_int(3, 2, 2) -> false\n     * any_int(3, -2, 1) -> true\n     * any_int(3.6, -2.2, 2) -> false\n     */\n    public boolean any_int(Object x, Object y, Object z) {\n        // Check if all inputs are integers\n        if (x instanceof Integer && y instanceof Integer && z instanceof Integer) {\n            int a = (Integer) x;\n            int b = (Integer) y;\n            int c = (Integer) z;\n\n            // Check if any number is the sum of the other two\n            return a == b + c || b == a + c || c == a + b;\n        }\n        return false;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.any_int(5, 2, 7)); // true\n        System.out.println(solution.any_int(3, 2, 2)); // false\n        System.out.println(solution.any_int(3, -2, 1)); // true\n        System.out.println(solution.any_int(3.6, -2.2, 2)); // false\n    }\n}\n"}
{"task_id": "Java/93", "generation": "class Solution {\n    /**\n     * Encodes a message by swapping case of all letters and replacing vowels\n     * with the letter that appears 2 places ahead in the English alphabet.\n     *\n     * @param message The input string to encode.\n     * @return The encoded string.\n     */\n    public String encode(String message) {\n        StringBuilder encoded = new StringBuilder();\n        \n        for (char c : message.toCharArray()) {\n            if (Character.isLetter(c)) {\n                // Swap case\n                char swappedCaseChar = Character.isUpperCase(c) ? Character.toLowerCase(c) : Character.toUpperCase(c);\n                \n                // Replace vowels with the letter 2 places ahead in the alphabet\n                char encodedChar = replaceVowel(swappedCaseChar);\n                encoded.append(encodedChar);\n            } else {\n                // If not a letter, just append it as is (though the problem assumes only letters)\n                encoded.append(c);\n            }\n        }\n\n        return encoded.toString();\n    }\n\n    private char replaceVowel(char c) {\n        String vowels = \"aeiou\";\n        String shiftedVowels = \"cdefghijklmnopqrstuvwxyzab\";\n\n        int index = vowels.indexOf(Character.toLowerCase(c));\n        if (index != -1) {\n            // Find the corresponding vowel in the shifted string\n            char newChar = shiftedVowels.charAt(index);\n            return Character.isUpperCase(c) ? Character.toUpperCase(newChar) : newChar;\n        }\n\n        return c;  // Return as is if not a vowel\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.encode(\"test\"));  // Expected: \"TGST\"\n        System.out.println(solution.encode(\"This is a message\"));  // Expected: \"tHKS KS C MGSSCGG\"\n    }\n}\n"}
{"task_id": "Java/94", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Finds the largest prime value in the list and returns the sum of its digits.\n     *\n     * @param lst List of integers to search through.\n     * @return Sum of the digits of the largest prime number found, or 0 if no primes are found.\n     */\n    public int skjkasdkd(List<Integer> lst) {\n        // Find the largest prime in the list\n        Integer maxPrime = null;\n        for (Integer num : lst) {\n            if (isPrime(num)) {\n                if (maxPrime == null || num > maxPrime) {\n                    maxPrime = num;\n                }\n            }\n        }\n\n        // If no primes were found, return 0\n        if (maxPrime == null) {\n            return 0;\n        }\n\n        // Calculate and return the sum of digits of the largest prime\n        return sumOfDigits(maxPrime);\n    }\n\n    /**\n     * Checks if a number is prime.\n     *\n     * @param num The number to check.\n     * @return true if the number is prime, false otherwise.\n     */\n    private boolean isPrime(Integer num) {\n        if (num <= 1) return false;\n        for (int i = 2; i <= Math.sqrt(num); i++) {\n            if (num % i == 0) return false;\n        }\n        return true;\n    }\n\n    /**\n     * Calculates the sum of digits of a number.\n     *\n     * @param num The number whose digits are to be summed.\n     * @return Sum of the digits.\n     */\n    private int sumOfDigits(Integer num) {\n        int sum = 0;\n        while (num > 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n        return sum;\n    }\n\n    // Test cases\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.skjkasdkd(Arrays.asList(0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3))); // 10\n        System.out.println(solution.skjkasdkd(Arrays.asList(1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1))); // 25\n        System.out.println(solution.skjkasdkd(Arrays.asList(1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3))); // 13\n        System.out.println(solution.skjkasdkd(Arrays.asList(0,724,32,71,99,32,6,0,5,91,83,0,5,6))); // 11\n        System.out.println(solution.skjkasdkd(Arrays.asList(0,81,12,3,1,21))); // 3\n        System.out.println(solution.skjkasdkd(Arrays.asList(0,8,1,2,1,7))); // 7\n    }\n}\n"}
{"task_id": "Java/95", "generation": "import java.util.*;\n\nclass Solution {\n    public boolean check_dict_case(Map<Object, Object> dict) {\n        // Check if the dictionary is empty\n        if (dict.isEmpty()) return false;\n\n        boolean hasLower = false;\n        boolean hasUpper = false;\n\n        for (Object key : dict.keySet()) {\n            // If any key is not a String, return False\n            if (!(key instanceof String)) return false;\n\n            String strKey = (String) key;\n            // Check the case of each string key\n            if (!strKey.equals(strKey.toLowerCase())) hasUpper = true;\n            if (!strKey.equals(strKey.toUpperCase())) hasLower = true;\n\n            // If both lower and upper cases are found, return False\n            if (hasLower && hasUpper) return false;\n        }\n\n        // If the loop completes without returning False, it means all keys are either in lowercase or uppercase\n        return true;\n    }\n}\n\n// Test code to verify the solution\nclass Main {\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n\n        Map<Object, Object> dict1 = new HashMap<>();\n        dict1.put(\"a\", \"apple\");\n        dict1.put(\"b\", \"banana\");\n\n        Map<Object, Object> dict2 = new HashMap<>();\n        dict2.put(\"a\", \"apple\");\n        dict2.put(\"A\", \"banana\");\n        dict2.put(\"B\", \"banana\");\n\n        Map<Object, Object> dict3 = new HashMap<>();\n        dict3.put(\"a\", \"apple\");\n        dict3.put(8, \"banana\"); // This is not a String key\n        dict3.put(\"a\", \"apple\");\n\n        Map<Object, Object> dict4 = new HashMap<>();\n        dict4.put(\"Name\", \"John\");\n        dict4.put(\"Age\", \"36\");\n        dict4.put(\"City\", \"Houston\");\n\n        Map<Object, Object> dict5 = new HashMap<>();\n        dict5.put(\"STATE\", \"NC\");\n        dict5.put(\"ZIP\", \"12345\");\n\n        System.out.println(sol.check_dict_case(dict1)); // Expected: true\n        System.out.println(sol.check_dict_case(dict2)); // Expected: false\n        System.out.println(sol.check_dict_case(dict3)); // Expected: false\n        System.out.println(sol.check_dict_case(dict4)); // Expected: false\n        System.out.println(sol.check_dict_case(dict5)); // Expected: true\n    }\n}\n"}
{"task_id": "Java/96", "generation": "import java.util.ArrayList;\nimport java.util.List;\n\nclass Solution {\n    public List<Integer> count_up_to(int n) {\n        List<Integer> primes = new ArrayList<>();\n        \n        for (int i = 2; i < n; i++) {\n            if (isPrime(i)) {\n                primes.add(i);\n            }\n        }\n\n        return primes;\n    }\n\n    private boolean isPrime(int num) {\n        if (num <= 1) {\n            return false;\n        }\n        for (int i = 2; i * i <= num; i++) {\n            if (num % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.count_up_to(5));   // [2,3]\n        System.out.println(solution.count_up_to(11));  // [2,3,5,7]\n        System.out.println(solution.count_up_to(0));   // []\n        System.out.println(solution.count_up_to(20));  // [2,3,5,7,11,13,17,19]\n        System.out.println(solution.count_up_to(1));   // []\n        System.out.println(solution.count_up_to(18));  // [2,3,5,7,11,13,17]\n    }\n}\n"}
{"task_id": "Java/97", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Takes two integers and returns the product of their unit digits.\n     * Assume the input is always valid.\n     *\n     * @param a first integer\n     * @param b second integer\n     * @return product of the unit digits of a and b\n     */\n    public int multiply(int a, int b) {\n        // Get the last digit of both numbers by using modulo 10\n        int lastDigitA = Math.abs(a % 10);\n        int lastDigitB = Math.abs(b % 10);\n\n        // Return the product of these digits\n        return lastDigitA * lastDigitB;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases to verify the correctness of the function\n        System.out.println(solution.multiply(148, 412)); // Expected output: 16\n        System.out.println(solution.multiply(19, 28));   // Expected output: 72\n        System.out.println(solution.multiply(2020, 1851)); // Expected output: 0\n        System.out.println(solution.multiply(14, -15)); // Expected output: 20\n    }\n}\n"}
{"task_id": "Java/98", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Given a string s, count the number of uppercase vowels in even indices.\n     *\n     * @param s The input string.\n     * @return The count of uppercase vowels at even indices.\n     */\n    public int count_upper(String s) {\n        // Define the set of uppercase vowels\n        Set<Character> uppercaseVowels = new HashSet<>(Arrays.asList('A', 'E', 'I', 'O', 'U'));\n        \n        int count = 0;\n        for (int i = 0; i < s.length(); i += 2) {\n            char c = s.charAt(i);\n            if (uppercaseVowels.contains(c)) {\n                count++;\n            }\n        }\n        return count;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.count_upper(\"aBCdEf\"));  // Expected output: 1\n        System.out.println(solution.count_upper(\"abcdefg\")); // Expected output: 0\n        System.out.println(solution.count_upper(\"dBBE\"));    // Expected output: 0\n        System.out.println(solution.count_upper(\"AeIoU\"));   // Expected output: 2\n        System.out.println(solution.count_upper(\"aEiOu\"));   // Expected output: 1\n    }\n}\n"}
{"task_id": "Java/99", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Create a function that takes a value (string) representing a number\n     * and returns the closest integer to it. If the number is equidistant\n     * from two integers, round it away from zero.\n     *\n     * @param value The string representation of the number.\n     * @return The closest integer to the given number, rounded away from zero if necessary.\n     */\n    public int closest_integer(String value) {\n        double num = Double.parseDouble(value);\n        \n        // Check if the number is exactly halfway between two integers\n        boolean isHalfway = Math.abs(num - Math.round(num)) == 0.5;\n        \n        if (isHalfway) {\n            return num > 0 ? (int)Math.ceil(num) : (int)Math.floor(num);\n        } else {\n            return (int)Math.round(num);\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.closest_integer(\"10\"));      // Expected: 10\n        System.out.println(solution.closest_integer(\"15.3\"));    // Expected: 15\n        System.out.println(solution.closest_integer(\"14.5\"));    // Expected: 15\n        System.out.println(solution.closest_integer(\"-14.5\"));   // Expected: -15\n        System.out.println(solution.closest_integer(\"0.5\"));     // Expected: 1\n        System.out.println(solution.closest_integer(\"-0.5\"));    // Expected: -1\n    }\n}\n"}
{"task_id": "Java/100", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given a positive integer n, makes a pile of n levels of stones.\n     * The first level has n stones.\n     * The number of stones in the next level is:\n     *      - the next odd number if n is odd.\n     *      - the next even number if n is even.\n     *\n     * @param n the number of levels\n     * @return a list where each element represents the number of stones at that level\n     */\n    public List<Integer> make_a_pile(int n) {\n        List<Integer> pile = new ArrayList<>();\n        int currentStones = n;\n        \n        for (int i = 0; i < n; i++) {\n            pile.add(currentStones);\n            // Determine the next number of stones based on whether current is odd or even\n            if (currentStones % 2 == 0) { \n                currentStones += 2; // Next even number\n            } else {\n                currentStones += 2; // Next odd number\n            }\n        }\n\n        return pile;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.make_a_pile(3)); // Expected: [3, 5, 7]\n        System.out.println(solution.make_a_pile(4)); // Expected: [4, 6, 8, 10]\n    }\n}\n"}
{"task_id": "Java/101", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Splits a string into words based on commas or spaces.\n     *\n     * @param s The input string containing words separated by commas or spaces.\n     * @return A List of strings, each representing a word from the input string.\n     */\n    public List<String> words_string(String s) {\n        // Replace commas with spaces to unify separators\n        String replacedString = s.replaceAll(\"[,\\\\s]+\", \" \").trim();\n        // Split the string by space and convert it into a list\n        return Arrays.asList(replacedString.split(\"\\\\s+\"));\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1: Words separated by spaces\n        List<String> result1 = solution.words_string(\"Hi, my name is John\");\n        System.out.println(result1.equals(Arrays.asList(\"Hi\", \"my\", \"name\", \"is\", \"John\"))); // Expected output: true\n\n        // Test case 2: Words separated by commas and spaces\n        List<String> result2 = solution.words_string(\"One, two, three, four, five, six\");\n        System.out.println(result2.equals(Arrays.asList(\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"))); // Expected output: true\n\n        // Test case 3: Mixed separators\n        List<String> result3 = solution.words_string(\"Hello , world this is a test\");\n        System.out.println(result3.equals(Arrays.asList(\"Hello\", \"world\", \"this\", \"is\", \"a\", \"test\"))); // Expected output: true\n\n        // Test case 4: Single word\n        List<String> result4 = solution.words_string(\"SingleWord\");\n        System.out.println(result4.equals(Arrays.asList(\"SingleWord\"))); // Expected output: true\n\n        // Test case 5: Empty string\n        List<String> result5 = solution.words_string(\"\");\n        System.out.println(result5.isEmpty()); // Expected output: true\n    }\n}\n"}
{"task_id": "Java/102", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * This function takes two positive numbers x and y and returns the\n     * biggest even integer number that is in the range [x, y] inclusive. If\n     * there's no such number, then the function should return -1.\n     *\n     * For example:\n     * choose_num(12, 15) = 14\n     * choose_num(13, 12) = -1\n     */\n    public int choose_num(int x, int y) {\n        // Ensure that x is less than or equal to y for the range check.\n        if (x > y) return -1;\n\n        // Start from y and move downwards until we find an even number or reach below x.\n        for (int i = y; i >= x; i--) {\n            if (i % 2 == 0) {\n                return i;\n            }\n        }\n\n        // If no even number is found in the range, return -1.\n        return -1;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.choose_num(12, 15)); // Expected output: 14\n        System.out.println(solution.choose_num(13, 12)); // Expected output: -1\n        System.out.println(solution.choose_num(8, 10));  // Expected output: 10\n        System.out.println(solution.choose_num(9, 9));   // Expected output: -1 (since 9 is odd)\n        System.out.println(solution.choose_num(2, 5));   // Expected output: 4\n    }\n}\n"}
{"task_id": "Java/103", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public Object rounded_avg(int n, int m) {\n        if (n > m) return -1;\n        \n        // Calculate the sum of integers from n through m.\n        long sum = 0;\n        for (int i = n; i <= m; ++i) {\n            sum += i;\n        }\n        \n        // Calculate average and round it to nearest integer\n        int avg = Math.round((float)sum / (m - n + 1));\n        \n        // Convert the rounded average to binary string\n        return Integer.toBinaryString(avg);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.rounded_avg(1, 5));   // Expected: \"11\"\n        System.out.println(solution.rounded_avg(7, 5));   // Expected: -1\n        System.out.println(solution.rounded_avg(10, 20)); // Expected: \"1111\"\n        System.out.println(solution.rounded_avg(20, 33)); // Expected: \"11011\"\n    }\n}\n"}
{"task_id": "Java/104", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given a list of positive integers x. return a sorted list of all\n     * elements that hasn't any even digit.\n     *\n     * Note: Returned list should be sorted in increasing order.\n     */\n    public List<Integer> unique_digits(List<Integer> x) {\n        List<Integer> result = new ArrayList<>();\n        \n        for (Integer num : x) {\n            if (!hasEvenDigit(num)) {\n                result.add(num);\n            }\n        }\n\n        Collections.sort(result); // Sorting the list in increasing order\n        return result;\n    }\n\n    private boolean hasEvenDigit(int number) {\n        while (number > 0) {\n            int digit = number % 10;\n            if (digit % 2 == 0) {\n                return true; // Found an even digit\n            }\n            number /= 10;\n        }\n        return false; // No even digits found\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        List<Integer> test1 = Arrays.asList(15, 33, 1422, 1);\n        System.out.println(solution.unique_digits(test1)); // Expected: [1, 15, 33]\n\n        List<Integer> test2 = Arrays.asList(152, 323, 1422, 10);\n        System.out.println(solution.unique_digits(test2)); // Expected: []\n\n        List<Integer> test3 = Arrays.asList(17, 29, 38, 41, 56);\n        System.out.println(solution.unique_digits(test3)); // Expected: [17, 29, 41]\n    }\n}\n"}
{"task_id": "Java/105", "generation": "import java.util.*;\n\nclass Solution {\n    public List<String> by_length(List<Integer> arr) {\n        // Filter out numbers that are not between 1 and 9 inclusive.\n        List<Integer> filtered = new ArrayList<>();\n        for (Integer num : arr) {\n            if (num >= 1 && num <= 9) {\n                filtered.add(num);\n            }\n        }\n\n        // Sort the list\n        Collections.sort(filtered);\n\n        // Reverse the sorted list\n        Collections.reverse(filtered);\n\n        // Map numbers to their corresponding names.\n        List<String> result = new ArrayList<>();\n        for (Integer num : filtered) {\n            switch (num) {\n                case 1:\n                    result.add(\"One\");\n                    break;\n                case 2:\n                    result.add(\"Two\");\n                    break;\n                case 3:\n                    result.add(\"Three\");\n                    break;\n                case 4:\n                    result.add(\"Four\");\n                    break;\n                case 5:\n                    result.add(\"Five\");\n                    break;\n                case 6:\n                    result.add(\"Six\");\n                    break;\n                case 7:\n                    result.add(\"Seven\");\n                    break;\n                case 8:\n                    result.add(\"Eight\");\n                    break;\n                case 9:\n                    result.add(\"Nine\");\n                    break;\n            }\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        List<Integer> test1 = Arrays.asList(2, 1, 1, 4, 5, 8, 2, 3);\n        System.out.println(solution.by_length(test1)); // Expected: [Eight, Five, Four, Three, Two, Two, One, One]\n\n        List<Integer> test2 = new ArrayList<>();\n        System.out.println(solution.by_length(test2)); // Expected: []\n\n        List<Integer> test3 = Arrays.asList(1, -1, 55);\n        System.out.println(solution.by_length(test3)); // Expected: [One]\n    }\n}\n"}
{"task_id": "Java/106", "generation": "import java.util.ArrayList;\nimport java.util.List;\n\nclass Solution {\n    public List<Integer> f(int n) {\n        List<Integer> result = new ArrayList<>();\n        \n        for (int i = 1; i <= n; i++) {\n            if (i % 2 == 0) {\n                // If i is even, calculate factorial\n                int fact = 1;\n                for (int j = 1; j <= i; j++) {\n                    fact *= j;\n                }\n                result.add(fact);\n            } else {\n                // If i is odd, sum numbers from 1 to i\n                int sum = 0;\n                for (int j = 1; j <= i; j++) {\n                    sum += j;\n                }\n                result.add(sum);\n            }\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case 1\n        List<Integer> test1Result = solution.f(5);\n        System.out.println(\"Test Case 1: \" + test1Result.toString()); // Expected [1, 2, 6, 24, 15]\n        \n        // Test case 2\n        List<Integer> test2Result = solution.f(3);\n        System.out.println(\"Test Case 2: \" + test2Result.toString()); // Expected [1, 2, 6]\n\n        // Additional test cases can be added here as needed.\n    }\n}\n"}
{"task_id": "Java/107", "generation": "import java.util.*;\n\nclass Solution {\n    public List<Integer> even_odd_palindrome(int n) {\n        int evenCount = 0;\n        int oddCount = 0;\n\n        for (int i = 1; i <= n; i++) {\n            if (isPalindrome(i)) {\n                if (i % 2 == 0) {\n                    evenCount++;\n                } else {\n                    oddCount++;\n                }\n            }\n        }\n\n        List<Integer> result = new ArrayList<>();\n        result.add(evenCount);\n        result.add(oddCount);\n\n        return result;\n    }\n\n    private boolean isPalindrome(int number) {\n        String numStr = Integer.toString(number);\n        int left = 0, right = numStr.length() - 1;\n\n        while (left < right) {\n            if (numStr.charAt(left++) != numStr.charAt(right--)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        List<Integer> result1 = solution.even_odd_palindrome(3);\n        System.out.println(result1); // Expected output: [1, 2]\n\n        // Test case 2\n        List<Integer> result2 = solution.even_odd_palindrome(12);\n        System.out.println(result2); // Expected output: [4, 6]\n    }\n}\n"}
{"task_id": "Java/108", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Write a function count_nums which takes an array of integers and returns\n     * the number of elements which has a sum of digits > 0.\n     * If a number is negative, then its first signed digit will be negative:\n     * e.g. -123 has signed digits -1, 2, and 3.\n     */\n    public int count_nums(List<Integer> arr) {\n        return (int) arr.stream()\n                .filter(num -> sumOfDigits(num) > 0)\n                .count();\n    }\n\n    private int sumOfDigits(int num) {\n        boolean isNegative = num < 0;\n        int sum = 0;\n        while (num != 0) {\n            int digit = num % 10;\n            // If the number was negative, make only the first digit negative\n            if (isNegative && sum == 0) {\n                digit *= -1;\n            }\n            sum += digit;\n            num /= 10;\n        }\n        return isNegative ? -sum : sum; // Adjusting for Java's division behavior with negatives\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.count_nums(Arrays.asList()) == 0);\n        System.out.println(solution.count_nums(Arrays.asList(-1, 11, -11)) == 1);\n        System.out.println(solution.count_nums(Arrays.asList(1, 1, 2)) == 3);\n\n        // Additional test cases\n        System.out.println(solution.count_nums(Arrays.asList(-10, -11, -12)) == 0); // All negative numbers with sum of digits <= 0\n        System.out.println(solution.count_nums(Arrays.asList(10, 11, 12)) == 3);    // All positive numbers with sum of digits > 0\n        System.out.println(solution.count_nums(Arrays.asList(-999, -888, 777)) == 1); // Mixed list\n    }\n}\n"}
{"task_id": "Java/109", "generation": "import java.util.*;\n\nclass Solution {\n    public boolean move_one_ball(List<Integer> arr) {\n        if (arr.isEmpty()) return true;\n\n        int n = arr.size();\n        int count = 0;\n        \n        // Find the number of times the order is broken.\n        for (int i = 1; i < n; i++) {\n            if (arr.get(i - 1) > arr.get(i)) {\n                count++;\n            }\n        }\n\n        // Check the last and first element as well.\n        if (arr.get(n - 1) > arr.get(0)) {\n            count++;\n        }\n\n        // If count is more than 1, it means we cannot sort by right shifts.\n        return count <= 1;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        \n        List<Integer> test1 = Arrays.asList(3, 4, 5, 1, 2);\n        System.out.println(sol.move_one_ball(test1)); // Expected: true\n\n        List<Integer> test2 = Arrays.asList(3, 5, 4, 1, 2);\n        System.out.println(sol.move_one_ball(test2)); // Expected: false\n    }\n}\n"}
{"task_id": "Java/110", "generation": "import java.util.*;\n\nclass Solution {\n    public String exchange(List<Integer> lst1, List<Integer> lst2) {\n        // Count the number of odd elements in lst1 and even elements in both lists.\n        int oddCountInLst1 = 0;\n        int evenCountInBothLists = 0;\n\n        for (int num : lst1) {\n            if (num % 2 != 0) {\n                oddCountInLst1++;\n            }\n        }\n\n        for (int num : lst1) {\n            if (num % 2 == 0) {\n                evenCountInBothLists++;\n            }\n        }\n\n        for (int num : lst2) {\n            if (num % 2 == 0) {\n                evenCountInBothLists++;\n            }\n        }\n\n        // If there are enough even numbers to replace all odd numbers in lst1, return \"YES\".\n        if (evenCountInBothLists >= oddCountInLst1) {\n            return \"YES\";\n        } else {\n            return \"NO\";\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.exchange(Arrays.asList(1, 2, 3, 4), Arrays.asList(1, 2, 3, 4))); // \"YES\"\n        System.out.println(solution.exchange(Arrays.asList(1, 2, 3, 4), Arrays.asList(1, 5, 3, 4))); // \"NO\"\n    }\n}\n"}
{"task_id": "Java/111", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given a string representing space-separated lowercase letters, returns a dictionary\n     * of the letter(s) with the most repetition and their corresponding counts.\n     * If several letters have the same occurrence, return all of them.\n     */\n    public Map<String, Integer> histogram(String test) {\n        if (test == null || test.trim().isEmpty()) {\n            return new HashMap<>();\n        }\n\n        String[] parts = test.split(\" \");\n        Map<String, Integer> countMap = new HashMap<>();\n\n        // Count the occurrences\n        for (String part : parts) {\n            countMap.put(part, countMap.getOrDefault(part, 0) + 1);\n        }\n\n        // Find the maximum occurrence\n        int maxCount = Collections.max(countMap.values());\n\n        // Filter out only those with the highest frequency\n        Map<String, Integer> result = new HashMap<>();\n        for (Map.Entry<String, Integer> entry : countMap.entrySet()) {\n            if (entry.getValue() == maxCount) {\n                result.put(entry.getKey(), entry.getValue());\n            }\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.histogram(\"a b c\")); // {\"a\": 1, \"b\": 1, \"c\": 1}\n        System.out.println(solution.histogram(\"a b b a\")); // {\"a\": 2, \"b\": 2}\n        System.out.println(solution.histogram(\"a b c a b\")); // {\"a\": 2, \"b\": 2}\n        System.out.println(solution.histogram(\"b b b b a\")); // {\"b\": 4}\n        System.out.println(solution.histogram(\"\")); // {}\n    }\n}\n"}
{"task_id": "Java/112", "generation": "import java.util.*;\n\nclass Solution {\n    public List<Object> reverse_delete(String s, String c) {\n        // Remove all characters from 's' that are present in 'c'\n        StringBuilder result = new StringBuilder();\n        for (char ch : s.toCharArray()) {\n            if (c.indexOf(ch) == -1) {  // If character is not found in 'c', add it to the result\n                result.append(ch);\n            }\n        }\n\n        // Check if the resulting string is a palindrome\n        String strResult = result.toString();\n        boolean isPalindrome = true;\n        int left = 0, right = strResult.length() - 1;\n        while (left < right) {\n            if (strResult.charAt(left++) != strResult.charAt(right--)) {\n                isPalindrome = false;\n                break;\n            }\n        }\n\n        // Return the result as a list containing the modified string and palindrome check\n        return Arrays.asList(strResult, isPalindrome);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.reverse_delete(\"abcde\", \"ae\"));  // Expected: [\"bcd\", false]\n        System.out.println(solution.reverse_delete(\"abcdef\", \"b\"));  // Expected: [\"acdef\", false]\n        System.out.println(solution.reverse_delete(\"abcdedcba\", \"ab\"));  // Expected: [\"cdedc\", true]\n    }\n}\n"}
{"task_id": "Java/113", "generation": "import java.util.*;\n\nclass Solution {\n    \n    /**\n     * Given a list of strings, where each string consists of only digits,\n     * return a list. Each element i of the output should be \"the number of odd elements in the\n     * string i of the input.\" where all the i's should be replaced by the number\n     * of odd digits in the i\"th string of the input.\n     */\n    public List<String> odd_count(List<String> lst) {\n        List<String> result = new ArrayList<>();\n        \n        for (String s : lst) {\n            int countOddDigits = 0;\n            \n            // Count the number of odd digits\n            for (char c : s.toCharArray()) {\n                if ((c - '0') % 2 != 0) {\n                    countOddDigits++;\n                }\n            }\n\n            // Create the result string with replacements\n            String output = \"the number of odd elements \" + countOddDigits +\n                            \"n the str\" + countOddDigits + \n                            \"ng \" + countOddDigits + \n                            \" of the \" + countOddDigits + \n                            \"nput.\";\n            \n            result.add(output);\n        }\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case 1\n        List<String> input1 = Arrays.asList(\"1234567\");\n        System.out.println(solution.odd_count(input1));\n        \n        // Test case 2\n        List<String> input2 = Arrays.asList(\"3\", \"11111111\");\n        System.out.println(solution.odd_count(input2));\n    }\n}\n"}
{"task_id": "Java/114", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given an array of integers nums, finds the minimum sum of any non-empty sub-array\n     * of nums.\n     *\n     * @param nums List of integers representing the input array.\n     * @return The minimum sum of any non-empty subarray in nums.\n     */\n    public int minSubArraySum(List<Integer> nums) {\n        if (nums == null || nums.isEmpty()) return 0;\n\n        int currentMin = nums.get(0);\n        int globalMin = nums.get(0);\n\n        for (int i = 1; i < nums.size(); i++) {\n            // Update the current minimum sum ending at index i\n            currentMin = Math.min(nums.get(i), currentMin + nums.get(i));\n            // Update the global minimum sum found so far\n            globalMin = Math.min(globalMin, currentMin);\n        }\n\n        return globalMin;\n    }\n    \n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        List<Integer> test1 = Arrays.asList(2, 3, 4, 1, 2, 4);\n        System.out.println(\"Test Case 1: \" + (solution.minSubArraySum(test1) == 1));\n        \n        List<Integer> test2 = Arrays.asList(-1, -2, -3);\n        System.out.println(\"Test Case 2: \" + (solution.minSubArraySum(test2) == -6));\n    }\n}\n"}
{"task_id": "Java/115", "generation": "import java.util.*;\n\nclass Solution {\n    public int max_fill(List<List<Integer>> grid, int capacity) {\n        if (grid == null || grid.isEmpty() || grid.get(0).isEmpty()) return 0;\n\n        int rows = grid.size();\n        int cols = grid.get(0).size();\n        int totalDrops = 0;\n\n        for (int col = 0; col < cols; col++) {\n            int waterUnitsInColumn = 0;\n            for (int row = 0; row < rows; row++) {\n                waterUnitsInColumn += grid.get(row).get(col);\n            }\n            totalDrops += Math.ceil((double) waterUnitsInColumn / capacity);\n        }\n\n        return totalDrops;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test Case 1\n        List<List<Integer>> grid1 = Arrays.asList(\n                Arrays.asList(0, 0, 1, 0),\n                Arrays.asList(0, 1, 0, 0),\n                Arrays.asList(1, 1, 1, 1)\n        );\n        int capacity1 = 1;\n        System.out.println(solution.max_fill(grid1, capacity1)); // Expected output: 6\n\n        // Test Case 2\n        List<List<Integer>> grid2 = Arrays.asList(\n                Arrays.asList(0, 0, 1, 1),\n                Arrays.asList(0, 0, 0, 0),\n                Arrays.asList(1, 1, 1, 1),\n                Arrays.asList(0, 1, 1, 1)\n        );\n        int capacity2 = 2;\n        System.out.println(solution.max_fill(grid2, capacity2)); // Expected output: 5\n\n        // Test Case 3\n        List<List<Integer>> grid3 = Arrays.asList(\n                Arrays.asList(0, 0, 0),\n                Arrays.asList(0, 0, 0)\n        );\n        int capacity3 = 5;\n        System.out.println(solution.max_fill(grid3, capacity3)); // Expected output: 0\n    }\n}\n"}
{"task_id": "Java/116", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Sorts an array of integers according to the number of ones in their binary representation.\n     * For similar numbers of ones, it sorts based on the decimal value.\n     *\n     * @param arr List of integers to be sorted.\n     * @return Sorted list of integers.\n     */\n    public List<Integer> sort_array(List<Integer> arr) {\n        Collections.sort(arr, new Comparator<Integer>() {\n            @Override\n            public int compare(Integer o1, Integer o2) {\n                // Count the number of ones in binary representation\n                int countOnesO1 = Integer.bitCount(o1);\n                int countOnesO2 = Integer.bitCount(o2);\n\n                if (countOnesO1 == countOnesO2) {\n                    return o1.compareTo(o2);  // Sort by decimal value if the number of ones is equal\n                } else {\n                    return Integer.compare(countOnesO1, countOnesO2);\n                }\n            }\n        });\n\n        return arr;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        List<Integer> test1 = Arrays.asList(1, 5, 2, 3, 4);\n        System.out.println(solution.sort_array(test1).equals(Arrays.asList(1, 2, 4, 3, 5)));\n\n        List<Integer> test2 = Arrays.asList(-2, -3, -4, -5, -6);\n        System.out.println(solution.sort_array(test2).equals(Arrays.asList(-4, -2, -6, -5, -3)));\n\n        List<Integer> test3 = Arrays.asList(1, 0, 2, 3, 4);\n        System.out.println(solution.sort_array(test3).equals(Arrays.asList(0, 1, 2, 4, 3)));\n    }\n}\n"}
{"task_id": "Java/117", "generation": "import java.util.ArrayList;\nimport java.util.List;\n\nclass Solution {\n    public List<String> select_words(String s, int n) {\n        List<String> result = new ArrayList<>();\n        if (s == null || s.trim().isEmpty()) return result; // Return empty list for empty string\n\n        String[] words = s.split(\"\\\\s+\"); // Split the string into words\n        for (String word : words) {\n            if (countConsonants(word) == n) { // Check if the number of consonants matches n\n                result.add(word);\n            }\n        }\n\n        return result;\n    }\n\n    private int countConsonants(String word) {\n        String vowels = \"aeiouAEIOU\";\n        int count = 0;\n        for (char c : word.toCharArray()) {\n            if (!vowels.contains(\"\" + c) && Character.isLetter(c)) { // Check if the character is a consonant\n                count++;\n            }\n        }\n        return count;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.select_words(\"Mary had a little lamb\", 4)); // [\"little\"]\n        System.out.println(solution.select_words(\"Mary had a little lamb\", 3)); // [\"Mary\", \"lamb\"]\n        System.out.println(solution.select_words(\"simple white space\", 2));     // []\n        System.out.println(solution.select_words(\"Hello world\", 4));            // [\"world\"]\n        System.out.println(solution.select_words(\"Uncle sam\", 3));              // [\"Uncle\"]\n    }\n}\n"}
{"task_id": "Java/118", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Finds the closest vowel standing between two consonants from the right side of the word.\n     *\n     * @param word The input string containing English letters only.\n     * @return A String representing the closest vowel that meets the condition, or an empty string if no such vowel exists.\n     */\n    public String get_closest_vowel(String word) {\n        // Define vowels\n        Set<Character> vowels = new HashSet<>(Arrays.asList('a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'));\n        \n        // Iterate from the end of the string to find a vowel between two consonants.\n        for (int i = word.length() - 2; i > 0; i--) {\n            char currentChar = word.charAt(i);\n            \n            if (!vowels.contains(currentChar) && vowels.contains(word.charAt(i + 1)) && !vowels.contains(word.charAt(i - 1))) {\n                return String.valueOf(word.charAt(i + 1));\n            }\n        }\n\n        // Return empty string if no vowel between two consonants is found.\n        return \"\";\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.get_closest_vowel(\"yogurt\")); // Expected: \"u\"\n        System.out.println(solution.get_closest_vowel(\"FULL\"));   // Expected: \"U\"\n        System.out.println(solution.get_closest_vowel(\"quick\"));  // Expected: \"\"\n        System.out.println(solution.get_closest_vowel(\"ab\"));     // Expected: \"\"\n    }\n}\n"}
{"task_id": "Java/119", "generation": "import java.util.*;\n\nclass Solution {\n    public String match_parens(List<String> lst) {\n        int open1 = 0, close1 = 0;\n        int open2 = 0, close2 = 0;\n\n        // Count the number of open and close parentheses in each string.\n        for (char c : lst.get(0).toCharArray()) {\n            if (c == '(') open1++;\n            else close1++;\n        }\n        for (char c : lst.get(1).toCharArray()) {\n            if (c == '(') open2++;\n            else close2++;\n        }\n\n        // Check if concatenating in either order results in a balanced string.\n        boolean canConcatenate = (open1 >= close2 && open2 >= close1) || (open2 >= close1 && open1 >= close2);\n\n        return canConcatenate ? \"Yes\" : \"No\";\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case 1: Should return Yes\n        System.out.println(solution.match_parens(Arrays.asList(\"()(\", \")\"))); // Expected output: Yes\n        \n        // Test case 2: Should return No\n        System.out.println(solution.match_parens(Arrays.asList(\")\", \")\"))); // Expected output: No\n        \n        // Additional test cases\n        System.out.println(solution.match_parens(Arrays.asList(\"(()\", \"))\"))); // Expected output: Yes\n        System.out.println(solution.match_parens(Arrays.asList(\"(\", \"))))\")); // Expected output: No\n    }\n}\n"}
{"task_id": "Java/120", "generation": "import java.util.*;\n\nclass Solution {\n    public List<Integer> maximum(List<Integer> arr, int k) {\n        // Use a priority queue (min-heap) to keep track of top k elements.\n        PriorityQueue<Integer> minHeap = new PriorityQueue<>();\n        \n        for (int num : arr) {\n            if (minHeap.size() < k) {\n                // If the heap has less than k elements, add the current number\n                minHeap.offer(num);\n            } else if (num > minHeap.peek()) {\n                // Replace the smallest element in the heap with the current number\n                // only if the current number is larger.\n                minHeap.poll();\n                minHeap.offer(num);\n            }\n        }\n\n        // Convert the priority queue to a list and sort it in ascending order.\n        List<Integer> result = new ArrayList<>(minHeap);\n        Collections.sort(result);\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        \n        System.out.println(sol.maximum(Arrays.asList(-3, -4, 5), 3)); // [-4, -3, 5]\n        System.out.println(sol.maximum(Arrays.asList(4, -4, 4), 2));   // [4, 4]\n        System.out.println(sol.maximum(Arrays.asList(-3, 2, 1, 2, -1, -2, 1), 1)); // [2]\n    }\n}\n"}
{"task_id": "Java/121", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n     *\n     * Examples:\n     * solution(Arrays.asList(5, 8, 7, 1)) ==> 12 (5 + 7)\n     * solution(Arrays.asList(3, 3, 3, 3, 3)) ==> 9 (3 + 3 + 3)\n     * solution(Arrays.asList(30, 13, 24, 321)) ==> 0\n     */\n    public int solution(List<Integer> lst) {\n        // Initialize sum to zero.\n        int sum = 0;\n        \n        // Iterate through the list with index and value.\n        for (int i = 0; i < lst.size(); i++) {\n            // Check if the position is even (i.e., i % 2 == 0)\n            // And check if the element at this position is odd\n            if ((i % 2 == 0) && (lst.get(i) % 2 != 0)) {\n                sum += lst.get(i);\n            }\n        }\n\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        \n        // Test cases\n        System.out.println(sol.solution(Arrays.asList(5, 8, 7, 1))); // Expected output: 12\n        System.out.println(sol.solution(Arrays.asList(3, 3, 3, 3, 3))); // Expected output: 9\n        System.out.println(sol.solution(Arrays.asList(30, 13, 24, 321))); // Expected output: 0\n    }\n}\n"}
{"task_id": "Java/122", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given a non-empty array of integers arr and an integer k,\n     * return the sum of the elements with at most two digits from the first k elements of arr.\n     *\n     * @param arr List<Integer> - The list of integers to process.\n     * @param k int - The number of elements from the start of the list to consider.\n     * @return int - Sum of elements with at most two digits within the first k elements.\n     */\n    public int add_elements(List<Integer> arr, int k) {\n        int sum = 0;\n        for (int i = 0; i < k; i++) {\n            if (arr.get(i) >= -99 && arr.get(i) <= 99) { // Check if the number has at most two digits\n                sum += arr.get(i);\n            }\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        List<Integer> testArr1 = Arrays.asList(111, 21, 3, 4000, 5, 6, 7, 8, 9);\n        int k1 = 4;\n        System.out.println(\"Test Case 1 Output: \" + solution.add_elements(testArr1, k1)); // Expected output: 24\n\n        // Test case 2\n        List<Integer> testArr2 = Arrays.asList(10, -5, 98, 76);\n        int k2 = 3;\n        System.out.println(\"Test Case 2 Output: \" + solution.add_elements(testArr2, k2)); // Expected output: 103\n\n        // Test case 3\n        List<Integer> testArr3 = Arrays.asList(100, -99, 56);\n        int k3 = 2;\n        System.out.println(\"Test Case 3 Output: \" + solution.add_elements(testArr3, k3)); // Expected output: -48\n\n        // Test case 4\n        List<Integer> testArr4 = Arrays.asList(10, 20, 30);\n        int k4 = 3;\n        System.out.println(\"Test Case 4 Output: \" + solution.add_elements(testArr4, k4)); // Expected output: 60\n\n        // Test case 5\n        List<Integer> testArr5 = Arrays.asList(123, -987);\n        int k5 = 1;\n        System.out.println(\"Test Case 5 Output: \" + solution.add_elements(testArr5, k5)); // Expected output: 0\n    }\n}\n"}
{"task_id": "Java/123", "generation": "import java.util.*;\n\nclass Solution {\n    public List<Integer> get_odd_collatz(int n) {\n        Set<Integer> oddNumbers = new LinkedHashSet<>();\n        \n        while (n != 1) {\n            if (n % 2 == 1) { // Check if n is odd\n                oddNumbers.add(n);\n            }\n            n = n % 2 == 0 ? n / 2 : 3 * n + 1;\n        }\n        oddNumbers.add(1); // Adding the last number of the sequence which is always 1\n        \n        List<Integer> sortedOddNumbers = new ArrayList<>(oddNumbers);\n        Collections.sort(sortedOddNumbers);\n        \n        return sortedOddNumbers;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.get_odd_collatz(5)); // Expected: [1, 5]\n        System.out.println(solution.get_odd_collatz(7)); // Expected: [1, 7, 11, 22, 34, 52, 80, 121]\n        System.out.println(solution.get_odd_collatz(1)); // Expected: [1]\n    }\n}\n"}
{"task_id": "Java/124", "generation": "import java.util.*;\n\nclass Solution {\n    public boolean valid_date(String date) {\n        // Check for empty string\n        if (date == null || date.isEmpty()) return false;\n\n        // Split the date into parts\n        String[] parts = date.split(\"-\");\n        \n        // Check if the split resulted in 3 parts and the format is correct\n        if (parts.length != 3 || !date.matches(\"\\\\d{2}-\\\\d{2}-\\\\d{4}\")) return false;\n\n        int month, day, year;\n        try {\n            month = Integer.parseInt(parts[0]);\n            day = Integer.parseInt(parts[1]);\n            year = Integer.parseInt(parts[2]);\n        } catch (NumberFormatException e) {\n            // If parsing fails, the date is invalid\n            return false;\n        }\n\n        // Check if month and day are within valid ranges\n        if (month < 1 || month > 12) return false;\n\n        int maxDay = 31; // Default to maximum days in a month\n\n        switch(month) {\n            case 4:\n            case 6:\n            case 9:\n            case 11: \n                maxDay = 30;\n                break;\n            case 2:\n                if ((year % 4 == 0 && year % 100 != 0) || (year % 400 == 0)) {\n                    // Leap year\n                    maxDay = 29;\n                } else {\n                    maxDay = 28;\n                }\n                break;\n        }\n\n        if (day < 1 || day > maxDay) return false;\n\n        // If all checks pass, the date is valid\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.valid_date(\"03-11-2000\"));  // Expected: true\n        System.out.println(solution.valid_date(\"15-01-2012\"));  // Expected: false\n        System.out.println(solution.valid_date(\"04-0-2040\"));   // Expected: false\n        System.out.println(solution.valid_date(\"06-04-2020\"));  // Expected: true\n        System.out.println(solution.valid_date(\"06/04/2020\"));  // Expected: false\n    }\n}\n"}
{"task_id": "Java/125", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given a string of words, return a list of words split on whitespace,\n     * if no whitespaces exist in the text you should split on commas ','\n     * if no commas exist you should return the number of lower-case letters with odd order in the alphabet.\n     */\n    public Object split_words(String txt) {\n        // Check for spaces\n        if (txt.contains(\" \")) {\n            return Arrays.asList(txt.split(\"\\\\s+\"));\n        }\n        // Check for commas\n        else if (txt.contains(\",\")) {\n            return Arrays.asList(txt.split(\",\"));\n        } \n        // Count odd-ordered lowercase letters\n        else {\n            int count = 0;\n            for (char c : txt.toCharArray()) {\n                if (Character.isLowerCase(c) && ((c - 'a') % 2 == 1)) {\n                    count++;\n                }\n            }\n            return count;\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.split_words(\"Hello world!\")); // [\"Hello\", \"world!\"]\n        System.out.println(solution.split_words(\"Hello,world!\")); // [\"Hello\", \"world!\"]\n        System.out.println(solution.split_words(\"abcdef\"));       // 3\n        \n        // Additional test cases\n        System.out.println(solution.split_words(\"a,b,c,d,e,f\")); // [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"]\n        System.out.println(solution.split_words(\"abc,def,ghi,jkl,mno,pqr,stu,vwx,yz\")); // [\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqr\", \"stu\", \"vwx\", \"yz\"]\n    }\n}\n"}
{"task_id": "Java/126", "generation": "import java.util.*;\n\nclass Solution {\n    public boolean is_sorted(List<Integer> lst) {\n        // Check for empty or single element list, which are trivially sorted.\n        if (lst.size() <= 1) return true;\n\n        Map<Integer, Integer> countMap = new HashMap<>();\n\n        for (int i = 0; i < lst.size(); i++) {\n            int current = lst.get(i);\n\n            // Check the ascending order\n            if (i > 0 && current < lst.get(i - 1)) {\n                return false;\n            }\n\n            // Count occurrences of each number and check if any exceeds two.\n            countMap.put(current, countMap.getOrDefault(current, 0) + 1);\n            if (countMap.get(current) > 2) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.is_sorted(Arrays.asList(5))); // -> true\n        System.out.println(solution.is_sorted(Arrays.asList(1, 2, 3, 4, 5))); // -> true\n        System.out.println(solution.is_sorted(Arrays.asList(1, 3, 2, 4, 5))); // -> false\n        System.out.println(solution.is_sorted(Arrays.asList(1, 2, 3, 4, 5, 6))); // -> true\n        System.out.println(solution.is_sorted(Arrays.asList(1, 2, 3, 4, 5, 6, 7))); // -> true\n        System.out.println(solution.is_sorted(Arrays.asList(1, 3, 2, 4, 5, 6, 7))); // -> false\n        System.out.println(solution.is_sorted(Arrays.asList(1, 2, 2, 3, 3, 4))); // -> true\n        System.out.println(solution.is_sorted(Arrays.asList(1, 2, 2, 2, 3, 4))); // -> false\n    }\n}\n"}
{"task_id": "Java/127", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Determines whether the length of the intersection of two intervals is a prime number.\n     *\n     * @param interval1 The first interval as a list of two integers [start, end].\n     * @param interval2 The second interval as a list of two integers [start, end].\n     * @return \"YES\" if the length of the intersection is a prime number, otherwise \"NO\".\n     */\n    public String intersection(List<Integer> interval1, List<Integer> interval2) {\n        int startMax = Math.max(interval1.get(0), interval2.get(0));\n        int endMin = Math.min(interval1.get(1), interval2.get(1));\n\n        // If there is no intersection\n        if (startMax > endMin) return \"NO\";\n\n        int lengthOfIntersection = endMin - startMax + 1;\n\n        // Check if the length of intersection is a prime number\n        if (isPrime(lengthOfIntersection)) {\n            return \"YES\";\n        } else {\n            return \"NO\";\n        }\n    }\n\n    private boolean isPrime(int n) {\n        if (n <= 1) return false;\n        for (int i = 2; i * i <= n; i++) {\n            if (n % i == 0) return false;\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.intersection(Arrays.asList(1, 2), Arrays.asList(2, 3))); // NO\n        System.out.println(solution.intersection(Arrays.asList(-1, 1), Arrays.asList(0, 4))); // NO\n        System.out.println(solution.intersection(Arrays.asList(-3, -1), Arrays.asList(-5, 5))); // YES\n    }\n}\n"}
{"task_id": "Java/128", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Calculates the sum of magnitudes of integers multiplied by product of all signs.\n     *\n     * @param arr List of integers.\n     * @return Optional<Integer> representing the result or empty if arr is empty.\n     */\n    public Optional<Integer> prod_signs(List<Integer> arr) {\n        if (arr.isEmpty()) return Optional.empty();\n\n        int sumOfMagnitudes = 0;\n        int productOfSigns = 1;\n\n        for (Integer num : arr) {\n            sumOfMagnitudes += Math.abs(num);\n            if (num == 0) {\n                productOfSigns = 0; // If any number is zero, the whole product becomes zero.\n                break;\n            } else if (num < 0) {\n                productOfSigns *= -1;\n            }\n        }\n\n        return Optional.of(sumOfMagnitudes * productOfSigns);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.prod_signs(Arrays.asList(1, 2, 2, -4))); // Expected: Optional[-9]\n        System.out.println(solution.prod_signs(Arrays.asList(0, 1)));         // Expected: Optional[0]\n        System.out.println(solution.prod_signs(Arrays.asList()));             // Expected: Optional.empty\n    }\n}\n"}
{"task_id": "Java/129", "generation": "import java.util.*;\n\nclass Solution {\n    private int N;\n    private List<List<Integer>> grid;\n    private List<Integer> minPath = new ArrayList<>();\n    private boolean[][] visited;\n\n    public List<Integer> minPath(List<List<Integer>> grid, int k) {\n        this.N = grid.size();\n        this.grid = grid;\n        this.visited = new boolean[N][N];\n\n        // Initialize the minimum path with a large value\n        for (int i = 0; i < k; ++i) {\n            minPath.add(Integer.MAX_VALUE);\n        }\n\n        // Start DFS from each cell in the grid\n        for (int row = 0; row < N; ++row) {\n            for (int col = 0; col < N; ++col) {\n                dfs(row, col, k, new ArrayList<>());\n            }\n        }\n\n        return minPath;\n    }\n\n    private void dfs(int row, int col, int stepsLeft, List<Integer> currentPath) {\n        // Add the current cell's value to the path\n        currentPath.add(grid.get(row).get(col));\n\n        // If we have reached the required length of the path\n        if (stepsLeft == 1) {\n            updateMinPath(currentPath);\n        } else {\n            // Explore all possible moves: up, down, left, right\n            int[][] directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n            for (int[] dir : directions) {\n                int newRow = row + dir[0];\n                int newCol = col + dir[1];\n\n                // Check if the move is within bounds and not visited\n                if (newRow >= 0 && newRow < N && newCol >= 0 && newCol < N && !visited[newRow][newCol]) {\n                    visited[newRow][newCol] = true;\n                    dfs(newRow, newCol, stepsLeft - 1, currentPath);\n                    visited[newRow][newCol] = false; // Backtrack\n                }\n            }\n        }\n\n        // Remove the last added value to backtrack\n        currentPath.remove(currentPath.size() - 1);\n    }\n\n    private void updateMinPath(List<Integer> path) {\n        if (path.compareTo(minPath) < 0) {\n            minPath = new ArrayList<>(path);\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        List<List<Integer>> grid1 = Arrays.asList(\n                Arrays.asList(1, 2, 3),\n                Arrays.asList(4, 5, 6),\n                Arrays.asList(7, 8, 9)\n        );\n        System.out.println(solution.minPath(grid1, 3)); // Expected: [1, 2, 1]\n\n        List<List<Integer>> grid2 = Arrays.asList(\n                Arrays.asList(5, 9, 3),\n                Arrays.asList(4, 1, 6),\n                Arrays.asList(7, 8, 2)\n        );\n        System.out.println(solution.minPath(grid2, 1)); // Expected: [1]\n    }\n}\n"}
{"task_id": "Java/130", "generation": "import java.util.*;\n\nclass Solution {\n    public List<Integer> tri(int n) {\n        List<Integer> result = new ArrayList<>();\n        \n        // Base cases\n        if (n >= 0) result.add(1); // tri(0)\n        if (n >= 1) result.add(3); // tri(1)\n\n        for (int i = 2; i <= n; i++) {\n            if (i % 2 == 0) { // Even\n                result.add(1 + i / 2);\n            } else { // Odd\n                int val = result.get(i - 1) + result.get(i - 2);\n                if (i >= 3) val += result.get(i - 3); \n                result.add(val);\n            }\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        \n        // Test cases\n        System.out.println(sol.tri(0)); // [1]\n        System.out.println(sol.tri(1)); // [1, 3]\n        System.out.println(sol.tri(2)); // [1, 3, 2]\n        System.out.println(sol.tri(3)); // [1, 3, 2, 8]\n        System.out.println(sol.tri(4)); // [1, 3, 2, 8, 3]\n    }\n}\n"}
{"task_id": "Java/131", "generation": "class Solution {\n    /**\n     * Given a positive integer n, returns the product of the odd digits.\n     * Returns 0 if all digits are even.\n     *\n     * @param n The input number\n     * @return The product of odd digits or 0 if all digits are even\n     */\n    public int digits(int n) {\n        int product = 1;\n        boolean hasOddDigit = false;\n\n        while (n > 0) {\n            int digit = n % 10; // Get the last digit\n            if (digit % 2 != 0) { // Check if it's odd\n                product *= digit;\n                hasOddDigit = true;\n            }\n            n /= 10; // Remove the last digit\n        }\n\n        return hasOddDigit ? product : 0;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases to verify the correctness of the method\n        System.out.println(solution.digits(1));   // Expected output: 1\n        System.out.println(solution.digits(4));   // Expected output: 0\n        System.out.println(solution.digits(235)); // Expected output: 15\n        System.out.println(solution.digits(2468)); // Expected output: 0\n        System.out.println(solution.digits(13579)); // Expected output: 945 (1*3*5*7*9)\n    }\n}\n"}
{"task_id": "Java/132", "generation": "import java.util.*;\n\nclass Solution {\n    public boolean is_nested(String string) {\n        Stack<Character> stack = new Stack<>();\n        for (char c : string.toCharArray()) {\n            if (c == '[') {\n                stack.push(c);\n            } else if (!stack.isEmpty() && c == ']') {\n                // Pop the last opening bracket\n                stack.pop();\n                // If there's still an opening bracket in the stack, it means we have a nested structure.\n                if (!stack.isEmpty()) return true;\n            }\n        }\n        return false;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.is_nested(\"[[]]\")); // Expected: true\n        System.out.println(solution.is_nested(\"[]]]]]]][[[[[]\")); // Expected: false\n        System.out.println(solution.is_nested(\"[][]\")); // Expected: false\n        System.out.println(solution.is_nested(\"[]\")); // Expected: false\n        System.out.println(solution.is_nested(\"[[][]]\")); // Expected: true\n        System.out.println(solution.is_nested(\"[[]][[\")); // Expected: true\n    }\n}\n"}
{"task_id": "Java/133", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Returns the sum of squared numbers in the given list,\n     * round each element in the list to the upper int(Ceiling) first.\n     */\n    public int sum_squares(List<Double> lst) {\n        return lst.stream()\n                .map(Math::ceil)\n                .mapToInt(Double::intValue)\n                .map(x -> x * x)\n                .sum();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        List<Double> test1 = Arrays.asList(1.0, 2.0, 3.0);\n        System.out.println(solution.sum_squares(test1)); // Expected output: 14\n\n        List<Double> test2 = Arrays.asList(1.0, 4.0, 9.0);\n        System.out.println(solution.sum_squares(test2)); // Expected output: 98\n\n        List<Double> test3 = Arrays.asList(1.0, 3.0, 5.0, 7.0);\n        System.out.println(solution.sum_squares(test3)); // Expected output: 84\n\n        List<Double> test4 = Arrays.asList(1.4, 4.2, 0.0);\n        System.out.println(solution.sum_squares(test4)); // Expected output: 29\n\n        List<Double> test5 = Arrays.asList(-2.4, 1.0, 1.0);\n        System.out.println(solution.sum_squares(test5)); // Expected output: 6\n    }\n}\n"}
{"task_id": "Java/134", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Create a function that returns true if the last character\n     * of a given string is an alphabetical character and is not\n     * a part of a word, and false otherwise.\n     * Note: \"word\" is a group of characters separated by space.\n     */\n    public boolean check_if_last_char_is_a_letter(String txt) {\n        // Check if the input string is empty or ends with a space\n        if (txt == null || txt.isEmpty() || txt.endsWith(\" \")) {\n            return false;\n        }\n\n        // Get the last character of the string\n        char lastChar = txt.charAt(txt.length() - 1);\n\n        // Check if the last character is alphabetical and not part of a word\n        return Character.isLetter(lastChar) && (txt.length() == 1 || !Character.isLetter(txt.charAt(txt.length() - 2)));\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.check_if_last_char_is_a_letter(\"apple pie\"));       // Expected: false\n        System.out.println(solution.check_if_last_char_is_a_letter(\"apple pi e\"));      // Expected: true\n        System.out.println(solution.check_if_last_char_is_a_letter(\"apple pi e \"));     // Expected: false\n        System.out.println(solution.check_if_last_char_is_a_letter(\"\"));                // Expected: false\n        System.out.println(solution.check_if_last_char_is_a_letter(\"a\"));               // Expected: true\n    }\n}\n"}
{"task_id": "Java/135", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Create a function which returns the largest index of an element which\n     * is not greater than or equal to the element immediately preceding it.\n     * If no such element exists then return -1. The given array will not contain\n     * duplicate values.\n     *\n     * Examples:\n     * can_arrange(Arrays.asList(1,2,4,3,5)) = 3\n     * can_arrange(Arrays.asList(1,2,3)) = -1\n     */\n    public int can_arrange(List<Integer> arr) {\n        for (int i = arr.size() - 1; i > 0; --i) {\n            if (arr.get(i) < arr.get(i - 1)) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        List<Integer> test1 = Arrays.asList(1, 2, 4, 3, 5);\n        System.out.println(\"Test Case 1: \" + (solution.can_arrange(test1) == 3 ? \"Pass\" : \"Fail\"));\n\n        List<Integer> test2 = Arrays.asList(1, 2, 3);\n        System.out.println(\"Test Case 2: \" + (solution.can_arrange(test2) == -1 ? \"Pass\" : \"Fail\"));\n\n        // Additional test cases\n        List<Integer> test3 = Arrays.asList(5, 4, 3, 2, 1);\n        System.out.println(\"Test Case 3: \" + (solution.can_arrange(test3) == 4 ? \"Pass\" : \"Fail\"));\n\n        List<Integer> test4 = Arrays.asList(10, 20, 30, 25, 40);\n        System.out.println(\"Test Case 4: \" + (solution.can_arrange(test4) == 3 ? \"Pass\" : \"Fail\"));\n    }\n}\n"}
{"task_id": "Java/136", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n\n    public List<Optional<Integer>> largest_smallest_integers(List<Integer> lst) {\n        Optional<Integer> maxNegative = Optional.empty();\n        Optional<Integer> minPositive = Optional.empty();\n\n        for (Integer num : lst) {\n            if (num < 0 && (!maxNegative.isPresent() || num > maxNegative.get())) {\n                maxNegative = Optional.of(num);\n            } else if (num > 0 && (!minPositive.isPresent() || num < minPositive.get())) {\n                minPositive = Optional.of(num);\n            }\n        }\n\n        return Arrays.asList(maxNegative, minPositive);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        List<Integer> list1 = Arrays.asList(2, 4, 1, 3, 5, 7);\n        System.out.println(solution.largest_smallest_integers(list1)); // Expected: [Optional.empty(), Optional[1]]\n\n        // Test case 2\n        List<Integer> list2 = new ArrayList<>();\n        System.out.println(solution.largest_smallest_integers(list2)); // Expected: [Optional.empty(), Optional.empty()]\n\n        // Test case 3\n        List<Integer> list3 = Arrays.asList(0);\n        System.out.println(solution.largest_smallest_integers(list3)); // Expected: [Optional.empty(), Optional.empty()]\n\n        // Additional test cases\n        List<Integer> list4 = Arrays.asList(-1, -2, -3, -4);\n        System.out.println(solution.largest_smallest_integers(list4)); // Expected: [Optional[-1], Optional.empty()]\n\n        List<Integer> list5 = Arrays.asList(10, 9, 8, 7, 6, 5, 4, 3, 2, 1);\n        System.out.println(solution.largest_smallest_integers(list5)); // Expected: [Optional.empty(), Optional[1]]\n\n        List<Integer> list6 = Arrays.asList(-5, -10, 15, 20, 25, -30);\n        System.out.println(solution.largest_smallest_integers(list6)); // Expected: [Optional[-5], Optional[15]]\n    }\n}\n"}
{"task_id": "Java/137", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Create a function that takes integers, floats, or strings representing\n     * real numbers, and returns the larger variable in its given variable type.\n     * Return Optional.empty() if the values are equal.\n     * Note: If a real number is represented as a string, the floating point might be . or ,\n     */\n    public Optional<Object> compare_one(Object a, Object b) {\n        double aValue = toDouble(a);\n        double bValue = toDouble(b);\n\n        if (aValue == bValue) {\n            return Optional.empty();\n        } else if (aValue > bValue) {\n            return Optional.of(a);\n        } else {\n            return Optional.of(b);\n        }\n    }\n\n    private double toDouble(Object value) {\n        if (value instanceof Integer || value instanceof Double) {\n            return ((Number)value).doubleValue();\n        } else if (value instanceof String) {\n            String strValue = (String) value;\n            strValue = strValue.replace(',', '.');\n            return Double.parseDouble(strValue);\n        }\n        throw new IllegalArgumentException(\"Unsupported type\");\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.compare_one(1, 2.5)); // Optional.of(2.5)\n        System.out.println(solution.compare_one(1, \"2,3\")); // Optional.of(\"2,3\")\n        System.out.println(solution.compare_one(\"5,1\", \"6\")); // Optional.of(\"6\")\n        System.out.println(solution.compare_one(\"1\", 1)); // Optional.empty()\n    }\n}\n"}
{"task_id": "Java/138", "generation": "class Solution {\n    public boolean is_equalToSumEven(int n) {\n        // Check if n is less than 8 or odd.\n        return n >= 8 && n % 2 == 0;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.is_equalToSumEven(4)); // Expected: false\n        System.out.println(solution.is_equalToSumEven(6)); // Expected: false\n        System.out.println(solution.is_equalToSumEven(8)); // Expected: true\n        System.out.println(solution.is_equalToSumEven(10)); // Expected: true\n        System.out.println(solution.is_equalToSumEven(20)); // Expected: true\n    }\n}\n"}
{"task_id": "Java/139", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Calculates the Brazilian factorial (or special factorial) of n.\n     *\n     * @param n The input number for which to calculate the special factorial.\n     * @return The calculated Brazilian factorial value.\n     */\n    public long special_factorial(int n) {\n        long result = 1;\n        while (n > 0) {\n            result *= factorial(n);\n            n--;\n        }\n        return result;\n    }\n\n    /**\n     * Helper method to calculate the factorial of a number.\n     *\n     * @param num The input number for which to calculate the factorial.\n     * @return The calculated factorial value.\n     */\n    private long factorial(int num) {\n        if (num == 0 || num == 1) return 1;\n        long fact = 1;\n        while (num > 1) {\n            fact *= num--;\n        }\n        return fact;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.special_factorial(4)); // Expected output: 288\n        System.out.println(solution.special_factorial(3)); // Expected output: 12\n        System.out.println(solution.special_factorial(5)); // Expected output: 34560\n    }\n}\n"}
{"task_id": "Java/140", "generation": "class Solution {\n    public String fix_spaces(String text) {\n        if (text == null || text.isEmpty()) return text;\n\n        StringBuilder result = new StringBuilder();\n        int spaceCount = 0;\n        \n        for (int i = 0; i < text.length(); i++) {\n            char currentChar = text.charAt(i);\n            \n            if (currentChar == ' ') {\n                spaceCount++;\n                \n                // If we encounter a non-space character after spaces\n                if ((i + 1 < text.length() && text.charAt(i + 1) != ' ') || i == text.length() - 1) {\n                    if (spaceCount > 2) {\n                        result.append('-');\n                    } else {\n                        for (int j = 0; j < spaceCount; j++) {\n                            result.append('_');\n                        }\n                    }\n                    spaceCount = 0;\n                }\n            } else {\n                // Append the non-space character to the result\n                if (spaceCount > 2) {\n                    // If there were more than two consecutive spaces before, append a dash and reset count\n                    result.append('-');\n                    spaceCount = 0; // Reset since we've already processed this sequence of spaces\n                }\n                result.append(currentChar);\n            }\n        }\n\n        return result.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.fix_spaces(\"Example\")); // Example\n        System.out.println(solution.fix_spaces(\"Example 1\")); // Example_1\n        System.out.println(solution.fix_spaces(\" Example 2\")); // _Example_2\n        System.out.println(solution.fix_spaces(\" Example   3\")); // _Example-3\n    }\n}\n"}
{"task_id": "Java/141", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public String file_name_check(String file_name) {\n        // Check if there are more than three digits in the filename.\n        long digitCount = file_name.chars().filter(Character::isDigit).count();\n        if (digitCount > 3) return \"No\";\n\n        // Split the string by dot and check conditions.\n        String[] parts = file_name.split(\"\\\\.\", -1);\n        if (parts.length != 2 || parts[0].isEmpty() || !Character.isLetter(parts[0].charAt(0))) {\n            return \"No\";\n        }\n\n        // Check valid extensions\n        List<String> validExtensions = Arrays.asList(\"txt\", \"exe\", \"dll\");\n        if (!validExtensions.contains(parts[1])) {\n            return \"No\";\n        }\n        \n        return \"Yes\";\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.file_name_check(\"example.txt\"));  // Expected: Yes\n        System.out.println(solution.file_name_check(\"1example.dll\")); // Expected: No\n        System.out.println(solution.file_name_check(\"test123.exe\"));  // Expected: Yes\n        System.out.println(solution.file_name_check(\".txt\"));         // Expected: No\n        System.out.println(solution.file_name_check(\"a.abc\"));        // Expected: No\n        System.out.println(solution.file_name_check(\"file1234.dll\")); // Expected: No\n    }\n}\n"}
{"task_id": "Java/142", "generation": "import java.util.*;\n\nclass Solution {\n    public int sum_squares(List<Integer> lst) {\n        if (lst.isEmpty()) return 0;\n\n        int sum = 0;\n        for (int i = 0; i < lst.size(); i++) {\n            if (i % 3 == 0 && i % 4 != 0) {\n                // Square the integer at index that is a multiple of 3\n                sum += Math.pow(lst.get(i), 2);\n            } else if (i % 4 == 0) {\n                // Cube the integer at index that is a multiple of 4\n                sum += Math.pow(lst.get(i), 3);\n            } else {\n                // Add the integer as it is for other indices\n                sum += lst.get(i);\n            }\n        }\n\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        List<Integer> test1 = Arrays.asList(1, 2, 3); // Expected output: 6 (1^2 + 2 + 3)\n        System.out.println(\"Test case 1 result: \" + solution.sum_squares(test1));\n\n        List<Integer> test2 = new ArrayList<>(); // Expected output: 0\n        System.out.println(\"Test case 2 result: \" + solution.sum_squares(test2));\n\n        List<Integer> test3 = Arrays.asList(-1, -5, 2, -1, -5); // Expected output: -126 (-1^3 + -5 + 2 + -1^2 + -5)\n        System.out.println(\"Test case 3 result: \" + solution.sum_squares(test3));\n    }\n}\n"}
{"task_id": "Java/143", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Returns a string that contains the words from the original sentence,\n     * whose lengths are prime numbers, preserving their order.\n     *\n     * @param sentence The input sentence containing words separated by spaces.\n     * @return A new string with only those words whose lengths are prime numbers.\n     */\n    public String words_in_sentence(String sentence) {\n        // Splitting the sentence into individual words\n        String[] words = sentence.split(\" \");\n        \n        StringBuilder result = new StringBuilder();\n        for (String word : words) {\n            if (isPrime(word.length())) {\n                if (result.length() > 0) {\n                    result.append(\" \");\n                }\n                result.append(word);\n            }\n        }\n\n        return result.toString();\n    }\n\n    // Helper method to check if a number is prime\n    private boolean isPrime(int n) {\n        if (n <= 1) {\n            return false;\n        }\n        for (int i = 2; i * i <= n; i++) {\n            if (n % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    // Test cases to verify the correctness of the solution\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        \n        System.out.println(sol.words_in_sentence(\"This is a test\")); // Expected: \"is\"\n        System.out.println(sol.words_in_sentence(\"lets go for swimming\")); // Expected: \"go for\"\n        System.out.println(sol.words_in_sentence(\"Hello world from Java\")); // Expected: \"world from\"\n    }\n}\n"}
{"task_id": "Java/144", "generation": "import java.util.*;\n\nclass Solution {\n    public boolean simplify(String x, String n) {\n        // Parse fractions into numerators and denominators\n        String[] partsX = x.split(\"/\");\n        int numeratorX = Integer.parseInt(partsX[0]);\n        int denominatorX = Integer.parseInt(partsX[1]);\n\n        String[] partsN = n.split(\"/\");\n        int numeratorN = Integer.parseInt(partsN[0]);\n        int denominatorN = Integer.parseInt(partsN[1]);\n\n        // Multiply the fractions\n        long resultNumerator = (long)numeratorX * numeratorN;\n        long resultDenominator = (long)denominatorX * denominatorN;\n\n        // Check if the result is a whole number\n        return resultNumerator % resultDenominator == 0;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.simplify(\"1/5\", \"5/1\")); // Expected: true\n        System.out.println(solution.simplify(\"1/6\", \"2/1\")); // Expected: false\n        System.out.println(solution.simplify(\"7/10\", \"10/2\")); // Expected: false\n\n        // Additional test cases\n        System.out.println(solution.simplify(\"3/4\", \"8/3\")); // Expected: true\n        System.out.println(solution.simplify(\"5/9\", \"9/5\")); // Expected: true\n    }\n}\n"}
{"task_id": "Java/145", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Sorts the given list of integers in ascending order according to the sum of their digits.\n     * If there are several items with similar sums, they are ordered based on their index in the original list.\n     * Negative numbers have their first digit considered negative.\n     *\n     * @param nums List of integers\n     * @return Sorted list of integers\n     */\n    public List<Integer> order_by_points(List<Integer> nums) {\n        // Create a list to hold pairs of (originalIndex, number)\n        List<Pair> indexedNums = new ArrayList<>();\n        \n        for (int i = 0; i < nums.size(); i++) {\n            indexedNums.add(new Pair(i, nums.get(i)));\n        }\n        \n        // Sort the list based on the sum of digits and then by original index\n        Collections.sort(indexedNums, Comparator.comparingInt((Pair p) -> digitSum(p.number))\n                .thenComparingInt(Pair::index));\n        \n        // Extract the sorted numbers from the pairs\n        List<Integer> result = new ArrayList<>();\n        for (Pair pair : indexedNums) {\n            result.add(pair.number);\n        }\n        \n        return result;\n    }\n\n    private int digitSum(int number) {\n        if (number == 0) return 0;\n        boolean isNegative = number < 0;\n        int sum = 0;\n        while (number != 0) {\n            sum += number % 10;\n            number /= 10;\n        }\n        // If the original number was negative, negate the first digit\n        if (isNegative && sum > 0) {\n            sum -= 2 * (sum % 10);\n        }\n        return sum;\n    }\n\n    private static class Pair {\n        int index;\n        int number;\n\n        public Pair(int index, int number) {\n            this.index = index;\n            this.number = number;\n        }\n\n        public int index() { return index; }\n    }\n\n    // Test cases\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        List<Integer> test1 = Arrays.asList(1, 11, -1, -11, -12);\n        System.out.println(solution.order_by_points(test1)); // Expected: [-1, -11, 1, -12, 11]\n        \n        List<Integer> test2 = new ArrayList<>();\n        System.out.println(solution.order_by_points(test2)); // Expected: []\n    }\n}\n"}
{"task_id": "Java/146", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * Filters an array of numbers based on specific criteria.\n     *\n     * @param nums List of integers to be filtered.\n     * @return The count of elements that are greater than 10 and have both first and last digits odd.\n     */\n    public int specialFilter(List<Integer> nums) {\n        return (int) nums.stream()\n                .filter(num -> num > 10 && isFirstAndLastDigitOdd(num))\n                .count();\n    }\n\n    private boolean isFirstAndLastDigitOdd(int num) {\n        String strNum = Integer.toString(Math.abs(num));\n        int firstDigit = Character.getNumericValue(strNum.charAt(0));\n        int lastDigit = Character.getNumericValue(strNum.charAt(strNum.length() - 1));\n        return (firstDigit % 2 != 0 && lastDigit % 2 != 0);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        List<Integer> testList1 = Arrays.asList(15, -73, 14, -15);\n        System.out.println(\"Test Case 1: \" + (solution.specialFilter(testList1) == 1));\n\n        // Test case 2\n        List<Integer> testList2 = Arrays.asList(33, -2, -3, 45, 21, 109);\n        System.out.println(\"Test Case 2: \" + (solution.specialFilter(testList2) == 2));\n    }\n}\n"}
{"task_id": "Java/147", "generation": "import java.util.*;\n\nclass Solution {\n    public int get_max_triples(int n) {\n        // Generate array based on given formula\n        int[] a = new int[n];\n        for (int i = 1; i <= n; ++i) {\n            a[i - 1] = i * i - i + 1;\n        }\n\n        int count = 0;\n\n        // Iterate through all possible triples\n        for (int i = 0; i < n; ++i) {\n            for (int j = i + 1; j < n; ++j) {\n                for (int k = j + 1; k < n; ++k) {\n                    if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                        count++;\n                    }\n                }\n            }\n        }\n\n        return count;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        \n        // Test case\n        int n = 5; // Example input\n        System.out.println(sol.get_max_triples(n)); // Expected output: 1\n        \n        // Additional test cases\n        System.out.println(sol.get_max_triples(6)); // Output depends on the pattern of multiples of 3 in generated array\n    }\n}\n"}
{"task_id": "Java/148", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Returns a list of planets that orbit between the two given planets.\n     *\n     * @param planet1 The first planet name.\n     * @param planet2 The second planet name.\n     * @return A List containing names of all planets located between the orbits of planet1 and planet2, sorted by proximity to the Sun.\n     */\n    public List<String> bf(String planet1, String planet2) {\n        // Define an ordered list of planets from closest to farthest from the sun\n        List<String> planets = Arrays.asList(\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\");\n\n        // Check if both planet names are valid\n        if (!planets.contains(planet1) || !planets.contains(planet2)) {\n            return Collections.emptyList();\n        }\n\n        int index1 = planets.indexOf(planet1);\n        int index2 = planets.indexOf(planet2);\n\n        // Ensure index1 is less than index2 for simplicity\n        if (index1 > index2) {\n            int temp = index1;\n            index1 = index2;\n            index2 = temp;\n        }\n\n        // Return the sublist of planets between index1 and index2, exclusive\n        return new ArrayList<>(planets.subList(index1 + 1, index2));\n    }\n    \n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.bf(\"Jupiter\", \"Neptune\")); // Expected: [Saturn, Uranus]\n        System.out.println(solution.bf(\"Earth\", \"Mercury\"));   // Expected: [Venus]\n        System.out.println(solution.bf(\"Mercury\", \"Uranus\"));  // Expected: [Venus, Earth, Mars, Jupiter, Saturn]\n    }\n}\n"}
{"task_id": "Java/149", "generation": "import java.util.*;\n\nclass Solution {\n    public List<String> sorted_list_sum(List<String> lst) {\n        // Filter out strings of odd lengths\n        List<String> filteredList = new ArrayList<>();\n        for (String s : lst) {\n            if (s.length() % 2 == 0) {\n                filteredList.add(s);\n            }\n        }\n\n        // Sort the list by length and then alphabetically\n        Collections.sort(filteredList, new Comparator<String>() {\n            public int compare(String s1, String s2) {\n                int lenCompare = Integer.compare(s1.length(), s2.length());\n                if (lenCompare != 0) return lenCompare;\n                else return s1.compareTo(s2);\n            }\n        });\n\n        return filteredList;\n    }\n\n    // Test cases\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        List<String> test1 = Arrays.asList(\"aa\", \"a\", \"aaa\");\n        System.out.println(solution.sorted_list_sum(test1));  // Expected: [aa]\n\n        List<String> test2 = Arrays.asList(\"ab\", \"a\", \"aaa\", \"cd\");\n        System.out.println(solution.sorted_list_sum(test2));  // Expected: [ab, cd]\n\n        List<String> test3 = Arrays.asList(\"abcd\", \"abc\", \"defg\", \"efgh\");\n        System.out.println(solution.sorted_list_sum(test3));  // Expected: [abcd, defg, efgh]\n    }\n}\n"}
{"task_id": "Java/150", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n     * A simple program which should return the value of x if n is\n     * a prime number and should return the value of y otherwise.\n     *\n     * Examples:\n     * for x_or_y(7, 34, 12) == 34\n     * for x_or_y(15, 8, 5) == 5\n     */\n    public int x_or_y(int n, int x, int y) {\n        if (isPrime(n)) {\n            return x;\n        } else {\n            return y;\n        }\n    }\n\n    private boolean isPrime(int number) {\n        if (number <= 1) {\n            return false;\n        }\n        for (int i = 2; i * i <= number; i++) {\n            if (number % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1: n is prime\n        int result1 = solution.x_or_y(7, 34, 12);\n        System.out.println(\"Test Case 1 (n=7): \" + (result1 == 34 ? \"Pass\" : \"Fail\"));\n\n        // Test case 2: n is not prime\n        int result2 = solution.x_or_y(15, 8, 5);\n        System.out.println(\"Test Case 2 (n=15): \" + (result2 == 5 ? \"Pass\" : \"Fail\"));\n    }\n}\n"}
{"task_id": "Java/151", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given a list of numbers, return the sum of squares of the numbers\n     * in the list that are odd. Ignore numbers that are negative or not integers.\n     *\n     * @param lst List containing objects (expected to be numbers)\n     * @return Sum of squares of odd positive integers from the list\n     */\n    public int sumOfSquaresOfOdds(List<Object> lst) {\n        return lst.stream()\n                .filter(o -> o instanceof Integer && ((Integer) o > 0))\n                .mapToInt(o -> (int) o)\n                .filter(n -> n % 2 != 0)\n                .map(n -> n * n)\n                .sum();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.sumOfSquaresOfOdds(Arrays.asList(1, 3, 2, 0))); // Expected output: 10 (1^2 + 3^2)\n        System.out.println(solution.sumOfSquaresOfOdds(Arrays.asList(-1, -2, 0)));   // Expected output: 0\n        System.out.println(solution.sumOfSquaresOfOdds(Arrays.asList(9, -2)));       // Expected output: 81 (9^2)\n        System.out.println(solution.sumOfSquaresOfOdds(Arrays.asList(0)));           // Expected output: 0\n        System.out.println(solution.sumOfSquaresOfOdds(new ArrayList<>()));          // Expected output: 0\n    }\n}\n"}
{"task_id": "Java/152", "generation": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\nclass Solution {\n    /**\n     * Compares the guesses with the actual game scores.\n     *\n     * @param game  A list of integers representing the actual scores of the matches.\n     * @param guess A list of integers representing the guessed scores for each match.\n     * @return A list of integers where each element represents how far off the corresponding guess was from the actual score. \n     */\n    public List<Integer> compare(List<Integer> game, List<Integer> guess) {\n        List<Integer> result = new ArrayList<>();\n        \n        // Ensure both lists have the same length\n        if (game.size() != guess.size()) {\n            throw new IllegalArgumentException(\"The size of 'game' and 'guess' must be equal.\");\n        }\n        \n        for (int i = 0; i < game.size(); i++) {\n            int diff = Math.abs(game.get(i) - guess.get(i));\n            result.add(diff);\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case 1\n        List<Integer> gameScores1 = Arrays.asList(1,2,3,4,5,1);\n        List<Integer> guessScores1 = Arrays.asList(1,2,3,4,2,-2);\n        System.out.println(solution.compare(gameScores1, guessScores1)); // Expected: [0, 0, 0, 0, 3, 3]\n\n        // Test case 2\n        List<Integer> gameScores2 = Arrays.asList(0,5,0,0,0,4);\n        List<Integer> guessScores2 = Arrays.asList(4,1,1,0,0,-2);\n        System.out.println(solution.compare(gameScores2, guessScores2)); // Expected: [4, 4, 1, 0, 0, 6]\n    }\n}\n"}
{"task_id": "Java/153", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public String Strongest_Extension(String class_name, List<String> extensions) {\n        int maxStrength = Integer.MIN_VALUE;\n        String strongestExtension = \"\";\n\n        for (String extension : extensions) {\n            int strength = calculateStrength(extension);\n            if (strength > maxStrength || (strength == maxStrength && strongestExtension.isEmpty())) {\n                maxStrength = strength;\n                strongestExtension = extension;\n            }\n        }\n\n        return class_name + \".\" + strongestExtension;\n    }\n\n    private int calculateStrength(String extension) {\n        int upperCaseCount = 0, lowerCaseCount = 0;\n\n        for (char c : extension.toCharArray()) {\n            if (Character.isUpperCase(c)) {\n                upperCaseCount++;\n            } else if (Character.isLowerCase(c)) {\n                lowerCaseCount++;\n            }\n        }\n\n        return upperCaseCount - lowerCaseCount;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case 1\n        String class_name1 = \"Slices\";\n        List<String> extensions1 = Arrays.asList(\"SErviNGSliCes\", \"Cheese\", \"StuFfed\");\n        System.out.println(solution.Strongest_Extension(class_name1, extensions1)); // Expected: Slices.SErviNGSliCes\n        \n        // Test case 2\n        String class_name2 = \"my_class\";\n        List<String> extensions2 = Arrays.asList(\"AA\", \"Be\", \"CC\");\n        System.out.println(solution.Strongest_Extension(class_name2, extensions2)); // Expected: my_class.AA\n\n        // Additional test cases can be added here to further validate the solution\n    }\n}\n"}
{"task_id": "Java/154", "generation": "import java.util.*;\n\nclass Solution {\n    public boolean cycpattern_check(String a, String b) {\n        // Concatenate 'a' with itself to handle rotation checks easily.\n        String doubledA = a + a;\n        \n        // Check if 'b' is a substring of the concatenated string.\n        return doubledA.contains(b);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.cycpattern_check(\"abcd\", \"abd\"));  // Expected: false\n        System.out.println(solution.cycpattern_check(\"hello\", \"ell\")); // Expected: true\n        System.out.println(solution.cycpattern_check(\"whassup\", \"psus\")); // Expected: false\n        System.out.println(solution.cycpattern_check(\"abab\", \"baa\"));  // Expected: true\n        System.out.println(solution.cycpattern_check(\"efef\", \"eeff\")); // Expected: false\n        System.out.println(solution.cycpattern_check(\"himenss\", \"simen\")); // Expected: true\n    }\n}\n"}
{"task_id": "Java/155", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given an integer, return a list that has the number of even and odd digits respectively.\n     *\n     * Example:\n     *      even_odd_count(-12) ==> [1, 1]\n     *      even_odd_count(123) ==> [1, 2]\n     */\n    public List<Integer> even_odd_count(int num) {\n        // Convert the number to a string and remove any negative sign\n        String strNum = Integer.toString(Math.abs(num));\n        \n        int evenCount = 0;\n        int oddCount = 0;\n\n        for (char c : strNum.toCharArray()) {\n            if ((c - '0') % 2 == 0) {\n                evenCount++;\n            } else {\n                oddCount++;\n            }\n        }\n\n        List<Integer> result = new ArrayList<>();\n        result.add(evenCount);\n        result.add(oddCount);\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.even_odd_count(-12));  // Expected: [1, 1]\n        System.out.println(solution.even_odd_count(123));  // Expected: [1, 2]\n        System.out.println(solution.even_odd_count(0));    // Expected: [1, 0]\n        System.out.println(solution.even_odd_count(-987654321));  // Expected: [4, 5]\n    }\n}\n"}
{"task_id": "Java/156", "generation": "import java.util.*;\n\nclass Solution {\n    public String int_to_mini_roman(int number) {\n        // Define arrays for Roman numerals and their corresponding integer values.\n        int[] values = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n        String[] numerals = {\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n\n        StringBuilder roman = new StringBuilder();\n        \n        // Iterate over the values and numerals arrays.\n        for (int i = 0; i < values.length && number > 0; i++) {\n            while (number >= values[i]) {\n                number -= values[i];\n                roman.append(numerals[i]);\n            }\n        }\n\n        return roman.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.int_to_mini_roman(19).equals(\"xix\") ? \"Test 1 Passed\" : \"Test 1 Failed\");\n        System.out.println(solution.int_to_mini_roman(152).equals(\"clii\") ? \"Test 2 Passed\" : \"Test 2 Failed\");\n        System.out.println(solution.int_to_mini_roman(426).equals(\"cdxxvi\") ? \"Test 3 Passed\" : \"Test 3 Failed\");\n\n        // Additional test cases\n        System.out.println(solution.int_to_mini_roman(1000).equals(\"m\") ? \"Test 4 Passed\" : \"Test 4 Failed\");\n        System.out.println(solution.int_to_mini_roman(947).equals(\"cmxlvii\") ? \"Test 5 Passed\" : \"Test 5 Failed\");\n    }\n}\n"}
{"task_id": "Java/157", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given the lengths of the three sides of a triangle, return true if the three\n     * sides form a right-angled triangle, false otherwise.\n     *\n     * @param a length of side A\n     * @param b length of side B\n     * @param c length of side C\n     * @return boolean indicating whether it forms a right-angled triangle\n     */\n    public boolean right_angle_triangle(int a, int b, int c) {\n        // Sort the sides to ensure that 'c' is the longest side.\n        int[] sides = {a, b, c};\n        Arrays.sort(sides);\n        \n        // Check if the square of the longest side equals the sum of squares of the other two sides\n        return Math.pow(sides[2], 2) == (Math.pow(sides[0], 2) + Math.pow(sides[1], 2));\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases to verify the correctness of the method\n        System.out.println(\"right_angle_triangle(3, 4, 5): \" + solution.right_angle_triangle(3, 4, 5)); // Expected: true\n        System.out.println(\"right_angle_triangle(1, 2, 3): \" + solution.right_angle_triangle(1, 2, 3)); // Expected: false\n        System.out.println(\"right_angle_triangle(5, 12, 13): \" + solution.right_angle_triangle(5, 12, 13)); // Expected: true\n        System.out.println(\"right_angle_triangle(8, 15, 17): \" + solution.right_angle_triangle(8, 15, 17)); // Expected: true\n        System.out.println(\"right_angle_triangle(6, 8, 10): \" + solution.right_angle_triangle(6, 8, 10)); // Expected: true\n    }\n}\n"}
{"task_id": "Java/158", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Returns the word with the maximum number of unique characters.\n     * If multiple strings have the same number of unique characters,\n     * returns the one that comes first in lexicographical order.\n     *\n     * @param words List of strings to be evaluated.\n     * @return The string with the most unique characters or the first\n     *         such string in lexicographical order if there are ties.\n     */\n    public String find_max(List<String> words) {\n        String result = \"\";\n        int maxUniqueChars = 0;\n\n        for (String word : words) {\n            Set<Character> uniqueChars = new HashSet<>();\n            for (char c : word.toCharArray()) {\n                uniqueChars.add(c);\n            }\n            \n            if (uniqueChars.size() > maxUniqueChars ||\n                (uniqueChars.size() == maxUniqueChars && word.compareTo(result) < 0)) {\n                result = word;\n                maxUniqueChars = uniqueChars.size();\n            }\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        List<String> test1 = Arrays.asList(\"name\", \"of\", \"string\");\n        System.out.println(solution.find_max(test1)); // Expected: string\n\n        List<String> test2 = Arrays.asList(\"name\", \"enam\", \"game\");\n        System.out.println(solution.find_max(test2)); // Expected: enam\n\n        List<String> test3 = Arrays.asList(\"aaaaaaa\", \"bb\", \"cc\");\n        System.out.println(solution.find_max(test3)); // Expected: aaaaaaa\n    }\n}\n"}
{"task_id": "Java/159", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * You're a hungry rabbit, and you already have eaten a certain number of carrots,\n     * but now you need to eat more carrots to complete the day's meals.\n     * You should return an array of [ total number of eaten carrots after your meals,\n     *                                 the number of carrots left after your meals ]\n     * if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n     *\n     * @param number  the number of carrots that you have already eaten.\n     * @param need    the number of carrots that you need to eat.\n     * @param remaining the number of remaining carrots in stock\n     * @return a list containing [total number of eaten carrots, number of carrots left]\n     */\n    public List<Integer> eat(int number, int need, int remaining) {\n        // Calculate how many more carrots can be eaten based on what's available.\n        int toEat = Math.min(need, remaining);\n        \n        // Update the total number of carrots eaten and the remaining carrots.\n        int totalEaten = number + toEat;\n        int leftOver = remaining - toEat;\n\n        return Arrays.asList(totalEaten, leftOver);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.eat(5, 6, 10)); // Expected: [11, 4]\n        System.out.println(solution.eat(4, 8, 9));  // Expected: [12, 1]\n        System.out.println(solution.eat(1, 10, 10));// Expected: [11, 0]\n        System.out.println(solution.eat(2, 11, 5)); // Expected: [7, 0]\n    }\n}\n"}
{"task_id": "Java/160", "generation": "import java.util.*;\n\nclass Solution {\n    public int do_algebra(List<String> operator, List<Integer> operand) {\n        if (operator.isEmpty() || operand.size() < 2) {\n            throw new IllegalArgumentException(\"Invalid input\");\n        }\n\n        // Start with the first operand.\n        int result = operand.get(0);\n\n        for (int i = 0; i < operator.size(); i++) {\n            String op = operator.get(i);\n            int nextOperand = operand.get(i + 1);\n\n            switch (op) {\n                case \"+\":\n                    result += nextOperand;\n                    break;\n                case \"-\":\n                    result -= nextOperand;\n                    break;\n                case \"*\":\n                    result *= nextOperand;\n                    break;\n                case \"/\":\n                    // Floor division is the default behavior for integer division in Java.\n                    result /= nextOperand;\n                    break;\n                case \"**\":\n                    result = (int) Math.pow(result, nextOperand);\n                    break;\n                default:\n                    throw new IllegalArgumentException(\"Unsupported operator: \" + op);\n            }\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test Case 1\n        List<String> operators1 = Arrays.asList(\"+\", \"*\", \"-\");\n        List<Integer> operands1 = Arrays.asList(2, 3, 4, 5);\n        System.out.println(solution.do_algebra(operators1, operands1)); // Expected output: 9\n\n        // Test Case 2\n        List<String> operators2 = Arrays.asList(\"**\", \"/\", \"+\");\n        List<Integer> operands2 = Arrays.asList(2, 3, 4, 5);\n        System.out.println(solution.do_algebra(operators2, operands2)); // Expected output: 10\n\n        // Test Case 3\n        List<String> operators3 = Arrays.asList(\"-\", \"*\", \"**\", \"/\");\n        List<Integer> operands3 = Arrays.asList(8, 2, 4, 3, 6);\n        System.out.println(solution.do_algebra(operators3, operands3)); // Expected output: -10\n\n        // Test Case 4\n        List<String> operators4 = Arrays.asList(\"+\", \"**\");\n        List<Integer> operands4 = Arrays.asList(5, 2, 3);\n        System.out.println(solution.do_algebra(operators4, operands4)); // Expected output: 13\n    }\n}\n"}
{"task_id": "Java/161", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n    You are given a string s.\n    if s[i] is a letter, reverse its case from lower to upper or vise versa,\n    otherwise keep it as it is.\n    If the string contains no letters, reverse the string.\n    The function should return the resulted string.\n    Examples\n    solve(\"1234\") = \"4321\"\n    solve(\"ab\") = \"AB\"\n    solve(\"#a@C\") = \"#A@c\"\n     */\n    public String solve(String s) {\n        boolean containsLetter = false;\n        StringBuilder result = new StringBuilder();\n        \n        for (char c : s.toCharArray()) {\n            if (Character.isLetter(c)) {\n                containsLetter = true;\n                if (Character.isLowerCase(c)) {\n                    result.append(Character.toUpperCase(c));\n                } else {\n                    result.append(Character.toLowerCase(c));\n                }\n            } else {\n                result.append(c);\n            }\n        }\n\n        // If the string contains no letters, reverse it.\n        if (!containsLetter) {\n            return result.reverse().toString();\n        }\n        \n        return result.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.solve(\"1234\").equals(\"4321\") ? \"Test 1 Passed\" : \"Test 1 Failed\");\n        System.out.println(solution.solve(\"ab\").equals(\"AB\") ? \"Test 2 Passed\" : \"Test 2 Failed\");\n        System.out.println(solution.solve(\"#a@C\").equals(\"#A@c\") ? \"Test 3 Passed\" : \"Test 3 Failed\");\n        \n        // Additional test cases\n        System.out.println(solution.solve(\"\").equals(\"\") ? \"Test 4 Passed\" : \"Test 4 Failed\"); // Empty string case\n        System.out.println(solution.solve(\"123a\").equals(\"123A\") ? \"Test 5 Passed\" : \"Test 5 Failed\");\n    }\n}\n"}
{"task_id": "Java/162", "generation": "import java.math.BigInteger;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.Optional;\n\nclass Solution {\n    /**\n     * Given a string \"text\", return its md5 hash equivalent string with length being 32.\n     * If \"text\" is an empty string, return Optional.empty().\n     *\n     * @param text the input string to be hashed\n     * @return Optional<String> containing the MD5 hash or Optional.empty() if text is empty\n     */\n    public Optional<String> string_to_md5(String text) throws NoSuchAlgorithmException {\n        if (text.isEmpty()) {\n            return Optional.empty();\n        }\n        \n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        byte[] messageDigest = md.digest(text.getBytes());\n        BigInteger no = new BigInteger(1, messageDigest);\n        String hashtext = no.toString(16);\n        while (hashtext.length() < 32) {\n            hashtext = \"0\" + hashtext;\n        }\n        \n        return Optional.of(hashtext);\n    }\n\n    public static void main(String[] args) throws NoSuchAlgorithmException {\n        Solution solution = new Solution();\n        System.out.println(solution.string_to_md5(\"Hello world\").orElse(\"\")); // Should print: 3e25960a79dbc69b674cd4ec67a72c62\n    }\n}\n\n// Test class for the Solution class\nclass SolutionTest {\n    public static void main(String[] args) throws NoSuchAlgorithmException {\n        Solution solution = new Solution();\n        \n        // Test with a non-empty string\n        Optional<String> result1 = solution.string_to_md5(\"Hello world\");\n        assert result1.isPresent() && \"3e25960a79dbc69b674cd4ec67a72c62\".equals(result1.get()) : \"Test failed for 'Hello world'\";\n        \n        // Test with an empty string\n        Optional<String> result2 = solution.string_to_md5(\"\");\n        assert !result2.isPresent() : \"Test failed for empty string\";\n        \n        System.out.println(\"All tests passed.\");\n    }\n}\n"}
{"task_id": "Java/163", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given two positive integers a and b, returns the even digits between a\n     * and b, in ascending order. Please note that the even digits refer to even numbers less than 10.\n     *\n     * @param a The first integer.\n     * @param b The second integer.\n     * @return A list of even digits between a and b.\n     */\n    public List<Integer> generate_integers(int a, int b) {\n        // Ensure a is the smaller number\n        if (a > b) {\n            int temp = a;\n            a = b;\n            b = temp;\n        }\n\n        List<Integer> result = new ArrayList<>();\n        for (int i = 0; i < 10; i += 2) { // Iterate over even digits: 0, 2, 4, 6, 8\n            if (i >= a && i <= b) {\n                result.add(i);\n            }\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.generate_integers(2, 8));   // Expected: [2, 4, 6, 8]\n        System.out.println(solution.generate_integers(8, 2));   // Expected: [2, 4, 6, 8]\n        System.out.println(solution.generate_integers(10, 14)); // Expected: []\n    }\n}\n"}
