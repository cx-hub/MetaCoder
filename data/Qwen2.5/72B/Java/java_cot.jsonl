{"task_id": "Java/0", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public boolean has_close_elements(List<Double> numbers, double threshold) {\n        // Sort the list to make it easier to find the closest elements\n        Collections.sort(numbers);\n\n        // Iterate through the sorted list and check the difference between consecutive elements\n        for (int i = 0; i < numbers.size() - 1; i++) {\n            double diff = Math.abs(numbers.get(i) - numbers.get(i + 1));\n            if (diff < threshold) {\n                return true;\n            }\n        }\n\n        // If no two elements are closer than the threshold, return false\n        return false;\n    }\n}\n"}
{"task_id": "Java/1", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<String> separate_paren_groups(String paren_string) {\n        // Remove spaces from the input string\n        String cleanedString = paren_string.replaceAll(\"\\\\s+\", \"\");\n\n        // Initialize a list to store the separated groups\n        List<String> groups = new ArrayList<>();\n\n        // Initialize variables to track the balance of parentheses and the current group\n        int balance = 0;\n        StringBuilder currentGroup = new StringBuilder();\n\n        // Iterate through each character in the cleaned string\n        for (char c : cleanedString.toCharArray()) {\n            // Append the character to the current group\n            currentGroup.append(c);\n\n            // Update the balance based on the character\n            if (c == '(') {\n                balance++;\n            } else if (c == ')') {\n                balance--;\n            }\n\n            // If the balance is zero, we have a complete group\n            if (balance == 0) {\n                groups.add(currentGroup.toString());\n                currentGroup = new StringBuilder(); // Reset the current group\n            }\n        }\n\n        return groups;\n    }\n}\n"}
{"task_id": "Java/2", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Given a positive floating point number, it can be decomposed into\n    and integer part (largest integer smaller than given number) and decimals\n    (leftover part always smaller than 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n    0.5\n     */\n    public double truncate_number(double number) {\n        // Step 1: Extract the integer part of the number\n        int integerPart = (int) number;\n\n        // Step 2: Subtract the integer part from the original number to get the decimal part\n        double decimalPart = number - integerPart;\n\n        // Step 3: Return the decimal part\n        return decimalPart;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.truncate_number(3.5)); // Expected output: 0.5\n        System.out.println(solution.truncate_number(7.25)); // Expected output: 0.25\n        System.out.println(solution.truncate_number(10.99)); // Expected output: 0.99\n    }\n}\n"}
{"task_id": "Java/3", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    You're given a list of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account falls below zero, and\n    at that point function should return True. Otherwise it should return False.\n    >>> below_zero(Arrays.asList(1, 2, 3))\n    false\n    >>> below_zero(Arrays.asList(1, 2, -4, 5))\n    true\n     */\n    public boolean below_zero(List<Integer> operations) {\n        // Initialize the balance to zero\n        int balance = 0;\n\n        // Iterate through each operation in the list\n        for (int operation : operations) {\n            // Update the balance based on the current operation\n            balance += operation;\n\n            // Check if the balance falls below zero\n            if (balance < 0) {\n                return true;\n            }\n        }\n\n        // If the loop completes without the balance falling below zero, return false\n        return false;\n    }\n}\n"}
{"task_id": "Java/4", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation(Arrays.asList(1.0, 2.0, 3.0, 4.0))\n    1.0\n     */\n    public double mean_absolute_deviation(List<Double> numbers) {\n        // Step 1: Calculate the mean of the numbers\n        double sum = 0.0;\n        for (double num : numbers) {\n            sum += num;\n        }\n        double mean = sum / numbers.size();\n\n        // Step 2: Calculate the absolute differences from the mean\n        double totalAbsDiff = 0.0;\n        for (double num : numbers) {\n            totalAbsDiff += Math.abs(num - mean);\n        }\n\n        // Step 3: Calculate the Mean Absolute Deviation\n        double mad = totalAbsDiff / numbers.size();\n\n        return mad;\n    }\n}\n"}
{"task_id": "Java/5", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Insert a number 'delimiter' between every two consecutive elements of input list `numbers'\n    >>> intersperse(List.of(), 4)\n    []\n    >>> intersperse(Arrays.asList(1, 2, 3), 4)\n    [1, 4, 2, 4, 3]\n     */\n    public List<Integer> intersperse(List<Integer> numbers, int delimiter) {\n        // If the list is empty or has only one element, return it as is\n        if (numbers == null || numbers.size() <= 1) {\n            return numbers;\n        }\n\n        // Create a new list to store the result\n        List<Integer> result = new ArrayList<>();\n\n        // Iterate through the list and add elements and delimiters\n        for (int i = 0; i < numbers.size(); i++) {\n            result.add(numbers.get(i));\n            // Add the delimiter after every element except the last one\n            if (i < numbers.size() - 1) {\n                result.add(delimiter);\n            }\n        }\n\n        return result;\n    }\n}\n"}
{"task_id": "Java/6", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> parse_nested_parens(String paren_string) {\n        List<Integer> result = new ArrayList<>();\n        String[] groups = paren_string.split(\" \");\n        \n        for (String group : groups) {\n            int max_depth = 0;\n            int current_depth = 0;\n            \n            for (char c : group.toCharArray()) {\n                if (c == '(') {\n                    current_depth++;\n                    if (current_depth > max_depth) {\n                        max_depth = current_depth;\n                    }\n                } else if (c == ')') {\n                    current_depth--;\n                }\n            }\n            \n            result.add(max_depth);\n        }\n        \n        return result;\n    }\n}\n"}
{"task_id": "Java/7", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring(List.of(), \"a\")\n    []\n    >>> filter_by_substring(Arrays.asList(\"abc\", \"bacd\", \"cde\", \"array\"), \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n     */\n    public List<String> filter_by_substring(List<String> strings, String substring) {\n        // Create a list to store the filtered results\n        List<String> filteredStrings = new ArrayList<>();\n\n        // Iterate through each string in the input list\n        for (String str : strings) {\n            // Check if the current string contains the given substring\n            if (str.contains(substring)) {\n                // If it does, add it to the filtered list\n                filteredStrings.add(str);\n            }\n        }\n\n        // Return the filtered list\n        return filteredStrings;\n    }\n}\n"}
{"task_id": "Java/8", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product(List.of())\n    [0, 1]\n    >>> sum_product(Arrays.asList(1, 2, 3, 4))\n    [10, 24]\n     */\n    public List<Integer> sum_product(List<Integer> numbers) {\n        // Initialize sum and product\n        int sum = 0;\n        int product = 1;\n\n        // Iterate through the list and calculate sum and product\n        for (int number : numbers) {\n            sum += number;\n            product *= number;\n        }\n\n        // Create a list to store the results\n        List<Integer> result = new ArrayList<>();\n        result.add(sum);\n        result.add(product);\n\n        // Return the result\n        return result;\n    }\n}\n"}
{"task_id": "Java/9", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> rolling_max(List<Integer> numbers) {\n        List<Integer> result = new ArrayList<>();\n        if (numbers == null || numbers.isEmpty()) {\n            return result;\n        }\n\n        int current_max = numbers.get(0);\n        for (int num : numbers) {\n            if (num > current_max) {\n                current_max = num;\n            }\n            result.add(current_max);\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        List<Integer> numbers = Arrays.asList(1, 2, 3, 2, 3, 4, 2);\n        List<Integer> rollingMax = solution.rolling_max(numbers);\n        System.out.println(rollingMax); // Expected output: [1, 2, 3, 3, 3, 4, 4]\n    }\n}\n"}
{"task_id": "Java/10", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Test if given string is a palindrome\n     */\n    public boolean isPalindrome(String string) {\n        int i = 0;\n        int j = string.length() - 1;\n        while (i < j) {\n            if (string.charAt(i) != string.charAt(j)) {\n                return false;\n            }\n            i++;\n            j--;\n        }\n        return true;\n    }\n\n    /**\n    Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome(\"\")\n    \"\"\n    >>> make_palindrome(\"cat\")\n    \"catac\"\n    >>> make_palindrome(\"cata\")\n    \"catac\"\n     */\n    public String make_palindrome(String string) {\n        // If the string is already a palindrome, return it as is\n        if (isPalindrome(string)) {\n            return string;\n        }\n\n        // Find the longest palindromic suffix\n        int len = string.length();\n        int i = len;\n        while (i > 0 && !isPalindrome(string.substring(len - i))) {\n            i--;\n        }\n\n        // The prefix that needs to be reversed and appended\n        String prefixToReverse = string.substring(0, len - i);\n\n        // Reverse the prefix and append it to the original string\n        StringBuilder reversedPrefix = new StringBuilder(prefixToReverse);\n        reversedPrefix.reverse();\n\n        return string + reversedPrefix.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.make_palindrome(\"\")); // Output: \"\"\n        System.out.println(solution.make_palindrome(\"cat\")); // Output: \"catac\"\n        System.out.println(solution.make_palindrome(\"cata\")); // Output: \"catac\"\n    }\n}\n"}
{"task_id": "Java/11", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n     */\n    public String string_xor(String a, String b) {\n        // Step 1: Ensure both strings are of the same length\n        if (a.length() != b.length()) {\n            throw new IllegalArgumentException(\"Strings must be of the same length\");\n        }\n\n        // Step 2: Initialize a StringBuilder to store the result\n        StringBuilder result = new StringBuilder();\n\n        // Step 3: Iterate through each character of the strings\n        for (int i = 0; i < a.length(); i++) {\n            // Step 4: Perform XOR operation on the current characters\n            char charA = a.charAt(i);\n            char charB = b.charAt(i);\n            char xorResult = (charA == charB) ? '0' : '1';\n            // Step 5: Append the result to the StringBuilder\n            result.append(xorResult);\n        }\n\n        // Step 6: Return the final result as a string\n        return result.toString();\n    }\n}\n"}
{"task_id": "Java/12", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest(List.of())\n    Optional.empty\n    >>> longest(Arrays.asList(\"a\", \"b\", \"c\"))\n    Optional[a]\n    >>> longest(Arrays.asList(\"a\", \"bb\", \"ccc\"))\n    Optional[ccc]\n     */\n    public Optional<String> longest(List<String> strings) {\n        // If the list is empty, return Optional.empty()\n        if (strings.isEmpty()) {\n            return Optional.empty();\n        }\n\n        // Initialize the longest string with the first string in the list\n        String longestString = strings.get(0);\n\n        // Iterate through the list to find the longest string\n        for (String str : strings) {\n            if (str.length() > longestString.length()) {\n                longestString = str;\n            }\n        }\n\n        // Return the longest string wrapped in an Optional\n        return Optional.of(longestString);\n    }\n}\n"}
{"task_id": "Java/13", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n     */\n    public int greatest_common_divisor(int a, int b) {\n        // Ensure a is always greater than or equal to b\n        if (a < b) {\n            int temp = a;\n            a = b;\n            b = temp;\n        }\n\n        // Use the Euclidean algorithm to find the GCD\n        while (b != 0) {\n            int remainder = a % b;\n            a = b;\n            b = remainder;\n        }\n\n        return a;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.greatest_common_divisor(3, 5)); // Output: 1\n        System.out.println(solution.greatest_common_divisor(25, 15)); // Output: 5\n    }\n}\n"}
{"task_id": "Java/14", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes(\"abc\")\n    [\"a\", \"ab\", \"abc\"]\n     */\n    public List<String> all_prefixes(String string) {\n        // Initialize an empty list to store the prefixes\n        List<String> prefixes = new ArrayList<>();\n\n        // Iterate through the string to generate all prefixes\n        for (int i = 1; i <= string.length(); i++) {\n            // Extract the prefix from the start of the string to the current index\n            String prefix = string.substring(0, i);\n            // Add the prefix to the list\n            prefixes.add(prefix);\n        }\n\n        // Return the list of prefixes\n        return prefixes;\n    }\n\n    // Main method for testing\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        List<String> result = solution.all_prefixes(\"abc\");\n        System.out.println(result); // Expected output: [a, ab, abc]\n    }\n}\n"}
{"task_id": "Java/15", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n    >>> string_sequence(0)\n    \"0\"\n    >>> string_sequence(5)\n    \"0 1 2 3 4 5\"\n     */\n    public String string_sequence(int n) {\n        // Step 1: Initialize a StringBuilder to build the result string.\n        StringBuilder result = new StringBuilder();\n\n        // Step 2: Loop from 0 to n inclusive.\n        for (int i = 0; i <= n; i++) {\n            // Step 3: Append the current number to the result string.\n            result.append(i);\n\n            // Step 4: If the current number is not the last number, append a space.\n            if (i < n) {\n                result.append(\" \");\n            }\n        }\n\n        // Step 5: Return the final result string.\n        return result.toString();\n    }\n}\n"}
{"task_id": "Java/16", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters(\"xyzXYZ\")\n    3\n    >>> count_distinct_characters(\"Jerry\")\n    4\n     */\n    public int count_distinct_characters(String string) {\n        // Convert the string to lowercase to ignore case differences\n        String lowerCaseString = string.toLowerCase();\n\n        // Use a HashSet to store unique characters\n        Set<Character> uniqueChars = new HashSet<>();\n\n        // Iterate through the string and add each character to the set\n        for (char c : lowerCaseString.toCharArray()) {\n            uniqueChars.add(c);\n        }\n\n        // The size of the set represents the number of distinct characters\n        return uniqueChars.size();\n    }\n}\n"}
{"task_id": "Java/17", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    \"o\" - whole note, lasts four beats\n    \"o|\" - half note, lasts two beats\n    \".|\" - quater note, lasts one beat\n\n    >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n     */\n    public List<Integer> parse_music(String string) {\n        // Split the input string by spaces to get individual notes\n        String[] notes = string.split(\" \");\n        \n        // Initialize a list to store the beats for each note\n        List<Integer> beats = new ArrayList<>();\n        \n        // Iterate through each note and determine its corresponding beats\n        for (String note : notes) {\n            switch (note) {\n                case \"o\":\n                    beats.add(4); // Whole note lasts 4 beats\n                    break;\n                case \"o|\":\n                    beats.add(2); // Half note lasts 2 beats\n                    break;\n                case \".|\":\n                    beats.add(1); // Quarter note lasts 1 beat\n                    break;\n                default:\n                    throw new IllegalArgumentException(\"Invalid note: \" + note);\n            }\n        }\n        \n        // Return the list of beats\n        return beats;\n    }\n}\n"}
{"task_id": "Java/18", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Find how many times a given substring can be found in the original string. Count overlapping cases.\n    */\n    public int how_many_times(String string, String substring) {\n        // If the substring is empty or longer than the string, return 0\n        if (substring.isEmpty() || substring.length() > string.length()) {\n            return 0;\n        }\n\n        int count = 0;\n        int index = 0;\n\n        // Loop through the string to find all occurrences of the substring\n        while (index != -1) {\n            // Find the next occurrence of the substring starting from the current index\n            index = string.indexOf(substring, index);\n\n            // If a match is found, increment the count and move the index forward by 1\n            if (index != -1) {\n                count++;\n                index++;\n            }\n        }\n\n        return count;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.how_many_times(\"\", \"a\")); // Output: 0\n        System.out.println(solution.how_many_times(\"aaa\", \"a\")); // Output: 3\n        System.out.println(solution.how_many_times(\"aaaa\", \"aa\")); // Output: 3\n    }\n}\n"}
{"task_id": "Java/19", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public String sort_numbers(String numbers) {\n        // Step 1: Create a mapping from words to their corresponding numeric values\n        Map<String, Integer> numberMap = new HashMap<>();\n        numberMap.put(\"zero\", 0);\n        numberMap.put(\"one\", 1);\n        numberMap.put(\"two\", 2);\n        numberMap.put(\"three\", 3);\n        numberMap.put(\"four\", 4);\n        numberMap.put(\"five\", 5);\n        numberMap.put(\"six\", 6);\n        numberMap.put(\"seven\", 7);\n        numberMap.put(\"eight\", 8);\n        numberMap.put(\"nine\", 9);\n\n        // Step 2: Split the input string into an array of words\n        String[] numberWords = numbers.split(\" \");\n\n        // Step 3: Convert the words to their numeric values using the map\n        List<Integer> numberValues = new ArrayList<>();\n        for (String word : numberWords) {\n            numberValues.add(numberMap.get(word));\n        }\n\n        // Step 4: Sort the numeric values\n        Collections.sort(numberValues);\n\n        // Step 5: Convert the sorted numeric values back to words\n        StringBuilder result = new StringBuilder();\n        for (int value : numberValues) {\n            for (Map.Entry<String, Integer> entry : numberMap.entrySet()) {\n                if (entry.getValue().equals(value)) {\n                    result.append(entry.getKey()).append(\" \");\n                    break;\n                }\n            }\n        }\n\n        // Step 6: Remove the trailing space and return the result\n        return result.toString().trim();\n    }\n}\n"}
{"task_id": "Java/20", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Double> find_closest_elements(List<Double> numbers) {\n        // Step 1: Sort the list of numbers\n        Collections.sort(numbers);\n\n        // Step 2: Initialize variables\n        double min_diff = Double.MAX_VALUE;\n        List<Double> closest_pair = new ArrayList<>();\n\n        // Step 3: Iterate through the sorted list\n        for (int i = 0; i < numbers.size() - 1; i++) {\n            double diff = Math.abs(numbers.get(i) - numbers.get(i + 1));\n            if (diff < min_diff) {\n                min_diff = diff;\n                closest_pair.clear();\n                closest_pair.add(numbers.get(i));\n                closest_pair.add(numbers.get(i + 1));\n            }\n        }\n\n        // Step 4: Return the closest pair\n        return closest_pair;\n    }\n}\n"}
{"task_id": "Java/21", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit(Arrays.asList(1.0, 2.0, 3.0, 4.0, 5.0))\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n     */\n    public List<Double> rescale_to_unit(List<Double> numbers) {\n        // Step 1: Find the minimum and maximum values in the list\n        double min = Collections.min(numbers);\n        double max = Collections.max(numbers);\n\n        // Step 2: Apply the linear transformation to each element\n        List<Double> transformedNumbers = new ArrayList<>();\n        for (double num : numbers) {\n            double transformedValue = (num - min) / (max - min);\n            transformedNumbers.add(transformedValue);\n        }\n\n        return transformedNumbers;\n    }\n}\n"}
{"task_id": "Java/22", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Filter given list of any values only for integers\n    >>> filter_integers(Arrays.asList('a', 3.14, 5))\n    [5]\n    >>> filter_integers(Arrays.asList(1, 2, 3, \"abc\", Map.of(), List.of()))\n    [1, 2, 3]\n     */\n    public List<Integer> filter_integers(List<Object> values) {\n        List<Integer> filteredIntegers = new ArrayList<>();\n        for (Object value : values) {\n            if (value instanceof Integer) {\n                filteredIntegers.add((Integer) value);\n            }\n        }\n        return filteredIntegers;\n    }\n}\n"}
{"task_id": "Java/23", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Return length of given string\n    >>> strlen(\"\")\n    0\n    >>> strlen(\"abc\")\n    3\n     */\n    public int strlen(String string) {\n        // Return the length of the string using the length() method\n        return string.length();\n    }\n}\n"}
{"task_id": "Java/24", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n     */\n    public int largest_divisor(int n) {\n        // Start from n-1 and go down to 1 to find the largest divisor\n        for (int i = n - 1; i > 0; i--) {\n            if (n % i == 0) {\n                return i;\n            }\n        }\n        // If no divisor is found, return 1 (every number is divisible by 1)\n        return 1;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.largest_divisor(15)); // Output: 5\n        System.out.println(solution.largest_divisor(17)); // Output: 1 (since 17 is prime)\n    }\n}\n"}
{"task_id": "Java/25", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n     */\n    public List<Integer> factorize(int n) {\n        List<Integer> factors = new ArrayList<>();\n        \n        // Handle the case of 2 separately to make the loop simpler\n        while (n % 2 == 0) {\n            factors.add(2);\n            n /= 2;\n        }\n        \n        // Check for odd factors from 3 onwards\n        for (int i = 3; i <= Math.sqrt(n); i += 2) {\n            while (n % i == 0) {\n                factors.add(i);\n                n /= i;\n            }\n        }\n        \n        // If n is a prime number greater than 2\n        if (n > 2) {\n            factors.add(n);\n        }\n        \n        return factors;\n    }\n}\n"}
{"task_id": "Java/26", "generation": "import java.util.*;\nimport java.lang.*;\nimport java.util.stream.Collectors;\n\nclass Solution {\n    public List<Integer> remove_duplicates(List<Integer> numbers) {\n        // Create a frequency map to count occurrences of each number\n        Map<Integer, Integer> frequencyMap = new HashMap<>();\n        for (int number : numbers) {\n            frequencyMap.put(number, frequencyMap.getOrDefault(number, 0) + 1);\n        }\n\n        // Filter the list to keep only those numbers that appear exactly once\n        List<Integer> result = numbers.stream()\n                                     .filter(number -> frequencyMap.get(number) == 1)\n                                     .collect(Collectors.toList());\n\n        return result;\n    }\n}\n"}
{"task_id": "Java/27", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n    >>> flip_case(\"Hello\")\n    \"hELLO\"\n     */\n    public String flip_case(String string) {\n        // Step 1: Convert the input string to a character array\n        char[] chars = string.toCharArray();\n        \n        // Step 2: Iterate through each character in the array\n        for (int i = 0; i < chars.length; i++) {\n            // Step 3: Check if the character is lowercase\n            if (Character.isLowerCase(chars[i])) {\n                // Step 4: Convert it to uppercase\n                chars[i] = Character.toUpperCase(chars[i]);\n            } else if (Character.isUpperCase(chars[i])) {\n                // Step 5: If the character is uppercase, convert it to lowercase\n                chars[i] = Character.toLowerCase(chars[i]);\n            }\n        }\n        \n        // Step 6: Convert the character array back to a string and return it\n        return new String(chars);\n    }\n}\n"}
{"task_id": "Java/28", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Concatenate list of strings into a single string\n    >>> concatenate(List.of())\n    \"\"\n    >>> concatenate(Arrays.asList(\"a\", \"b\", \"c\"))\n    \"abc\"\n     */\n    public String concatenate(List<String> strings) {\n        // Initialize a StringBuilder to efficiently build the concatenated string\n        StringBuilder result = new StringBuilder();\n\n        // Iterate through each string in the list and append it to the result\n        for (String str : strings) {\n            result.append(str);\n        }\n\n        // Convert the StringBuilder to a String and return it\n        return result.toString();\n    }\n}\n"}
{"task_id": "Java/29", "generation": "import java.util.*;\nimport java.lang.*;\nimport java.util.stream.Collectors;\n\nclass Solution {\n    /**\n    Filter an input list of strings only for ones that start with a given prefix.\n    >>> filter_by_prefix(List.of(), \"a\")\n    []\n    >>> filter_by_prefix(Arrays.asList(\"abc\", \"bcd\", \"cde\", \"array\"), \"a\")\n    [\"abc\", \"array\"]\n     */\n    public List<String> filter_by_prefix(List<String> strings, String prefix) {\n        // Use Java Streams to filter the list based on the prefix\n        return strings.stream()\n                      .filter(s -> s.startsWith(prefix))\n                      .collect(Collectors.toList());\n    }\n}\n"}
{"task_id": "Java/30", "generation": "import java.util.*;\nimport java.lang.*;\nimport java.util.stream.Collectors;\n\nclass Solution {\n    /**\n    Return only positive numbers in the list.\n    >>> get_positive(Arrays.asList(-1, 2, -4, 5, 6))\n    [2, 5, 6]\n    >>> get_positive(Arrays.asList(5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10))\n    [5, 3, 2, 3, 9, 123, 1]\n     */\n    public List<Integer> get_positive(List<Integer> l) {\n        // Filter the list to include only positive numbers\n        return l.stream()\n                .filter(num -> num > 0)\n                .collect(Collectors.toList());\n    }\n}\n"}
{"task_id": "Java/31", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Return true if a given number is prime, and false otherwise.\n    */\n    public boolean is_prime(int n) {\n        // Step 1: Handle edge cases\n        if (n <= 1) {\n            return false;\n        }\n        if (n == 2 || n == 3) {\n            return true;\n        }\n        if (n % 2 == 0 || n % 3 == 0) {\n            return false;\n        }\n\n        // Step 2: Check divisibility from 5 to sqrt(n)\n        for (int i = 5; i * i <= n; i += 6) {\n            if (n % i == 0 || n % (i + 2) == 0) {\n                return false;\n            }\n        }\n\n        // Step 3: If no divisors found, the number is prime\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.is_prime(6));    // false\n        System.out.println(solution.is_prime(101));  // true\n        System.out.println(solution.is_prime(11));   // true\n        System.out.println(solution.is_prime(13441)); // true\n        System.out.println(solution.is_prime(61));   // true\n        System.out.println(solution.is_prime(4));    // false\n        System.out.println(solution.is_prime(1));    // false\n    }\n}\n"}
{"task_id": "Java/32", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Evaluates polynomial with coefficients xs at point x.\n    return xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n\n     */\n    public double poly(List<Double> xs, double x) {\n        double result = 0;\n        for (int i = 0; i < xs.size(); i++) {\n            result += xs.get(i) * Math.pow(x, i);\n        }\n        return result;\n    }\n\n    /**\n    Computes the derivative of the polynomial with coefficients xs.\n     */\n    public List<Double> derivative(List<Double> xs) {\n        List<Double> derivativeCoeffs = new ArrayList<>();\n        for (int i = 1; i < xs.size(); i++) {\n            derivativeCoeffs.add(xs.get(i) * i);\n        }\n        return derivativeCoeffs;\n    }\n\n    /**\n    Finds a zero of the polynomial with coefficients xs using the Newton-Raphson method.\n     */\n    public double find_zero(List<Double> xs) {\n        List<Double> derivativeCoeffs = derivative(xs);\n        double x = 0;  // Initial guess\n        double tolerance = 1e-7;  // Convergence criterion\n        int maxIterations = 1000;  // Maximum number of iterations\n\n        for (int i = 0; i < maxIterations; i++) {\n            double fx = poly(xs, x);\n            double dfx = poly(derivativeCoeffs, x);\n\n            if (Math.abs(dfx) < tolerance) {\n                break;  // Avoid division by zero\n            }\n\n            double xNew = x - fx / dfx;\n\n            if (Math.abs(xNew - x) < tolerance) {\n                return xNew;\n            }\n\n            x = xNew;\n        }\n\n        return x;  // Return the best estimate\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        List<Double> xs1 = Arrays.asList(1.0, 2.0);\n        System.out.println(sol.find_zero(xs1));  // Output: -0.5\n\n        List<Double> xs2 = Arrays.asList(-6.0, 11.0, -6.0, 1.0);\n        System.out.println(sol.find_zero(xs2));  // Output: 1.0\n    }\n}\n"}
{"task_id": "Java/33", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> sort_third(List<Integer> l) {\n        // Step 1: Identify indices divisible by 3\n        List<Integer> indices_divisible_by_3 = new ArrayList<>();\n        for (int i = 0; i < l.size(); i++) {\n            if (i % 3 == 0) {\n                indices_divisible_by_3.add(i);\n            }\n        }\n\n        // Step 2: Extract elements at these indices\n        List<Integer> elements_to_sort = new ArrayList<>();\n        for (int index : indices_divisible_by_3) {\n            elements_to_sort.add(l.get(index));\n        }\n\n        // Step 3: Sort the extracted elements\n        Collections.sort(elements_to_sort);\n\n        // Step 4: Replace elements at the identified indices with the sorted elements\n        for (int i = 0; i < indices_divisible_by_3.size(); i++) {\n            l.set(indices_divisible_by_3.get(i), elements_to_sort.get(i));\n        }\n\n        // Step 5: Return the modified list\n        return l;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.sort_third(Arrays.asList(1, 2, 3))); // [1, 2, 3]\n        System.out.println(solution.sort_third(Arrays.asList(5, 6, 3, 4, 8, 9, 2))); // [2, 6, 3, 4, 8, 9, 5]\n    }\n}\n"}
{"task_id": "Java/34", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Return sorted unique elements in a list\n    >>> unique(Arrays.asList(5, 3, 5, 2, 3, 3, 9, 0, 123))\n    [0, 2, 3, 5, 9, 123]\n     */\n    public List<Integer> unique(List<Integer> l) {\n        // Step 1: Use a HashSet to remove duplicates\n        Set<Integer> set = new HashSet<>(l);\n\n        // Step 2: Convert the HashSet back to a List\n        List<Integer> uniqueList = new ArrayList<>(set);\n\n        // Step 3: Sort the List\n        Collections.sort(uniqueList);\n\n        // Step 4: Return the sorted unique list\n        return uniqueList;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        List<Integer> input = Arrays.asList(5, 3, 5, 2, 3, 3, 9, 0, 123);\n        List<Integer> result = solution.unique(input);\n        System.out.println(result); // Expected output: [0, 2, 3, 5, 9, 123]\n    }\n}\n"}
{"task_id": "Java/35", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Return maximum element in the list.\n    >>> max_element(Arrays.asList(1, 2, 3))\n    3\n    >>> max_element(Arrays.asList(5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10))\n    123\n     */\n    public int max_element(List<Integer> l) {\n        // Check if the list is empty\n        if (l.isEmpty()) {\n            throw new IllegalArgumentException(\"List is empty\");\n        }\n\n        // Initialize the maximum element with the first element of the list\n        int max = l.get(0);\n\n        // Iterate through the list to find the maximum element\n        for (int num : l) {\n            if (num > max) {\n                max = num;\n            }\n        }\n\n        // Return the maximum element\n        return max;\n    }\n}\n"}
{"task_id": "Java/36", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int fizz_buzz(int n) {\n        int count = 0;\n        for (int i = 1; i < n; i++) {\n            if (i % 11 == 0 || i % 13 == 0) {\n                String numStr = Integer.toString(i);\n                for (int j = 0; j < numStr.length(); j++) {\n                    if (numStr.charAt(j) == '7') {\n                        count++;\n                    }\n                }\n            }\n        }\n        return count;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.fizz_buzz(50)); // Output: 0\n        System.out.println(solution.fizz_buzz(78)); // Output: 2\n        System.out.println(solution.fizz_buzz(79)); // Output: 3\n    }\n}\n"}
{"task_id": "Java/37", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even(Arrays.asList(1, 2, 3))\n    [1, 2, 3]\n    >>> sort_even(Arrays.asList(5, 6, 3, 4))\n    [3, 6, 5, 4]\n     */\n    public List<Integer> sort_even(List<Integer> l) {\n        // Extract even indices values\n        List<Integer> evenIndicesValues = new ArrayList<>();\n        for (int i = 0; i < l.size(); i += 2) {\n            evenIndicesValues.add(l.get(i));\n        }\n\n        // Sort the even indices values\n        Collections.sort(evenIndicesValues);\n\n        // Create the result list\n        List<Integer> result = new ArrayList<>(l.size());\n        int evenIndex = 0;\n\n        for (int i = 0; i < l.size(); i++) {\n            if (i % 2 == 0) {\n                // Even index, use sorted value\n                result.add(evenIndicesValues.get(evenIndex++));\n            } else {\n                // Odd index, use original value\n                result.add(l.get(i));\n            }\n        }\n\n        return result;\n    }\n}\n"}
{"task_id": "Java/38", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    returns encoded string by cycling groups of three characters.\n     */\n    public String encodeCyclic(String s) {\n        List<String> groups = new ArrayList<>();\n        for (int i = 0; i < s.length(); i += 3) {\n            groups.add(s.substring(i, Math.min(i + 3, s.length())));\n        }\n        for (int i = 0; i < groups.size(); i++) {\n            if (groups.get(i).length() == 3) {\n                groups.set(i, groups.get(i).substring(1) + groups.get(i).charAt(0));\n            }\n        }\n        return String.join(\"\", groups);\n    }\n\n    /**\n    takes as input string encoded with encodeCyclic function. Returns decoded string.\n     */\n    public String decode_cyclic(String s) {\n        List<String> groups = new ArrayList<>();\n        for (int i = 0; i < s.length(); i += 3) {\n            groups.add(s.substring(i, Math.min(i + 3, s.length())));\n        }\n        for (int i = 0; i < groups.size(); i++) {\n            if (groups.get(i).length() == 3) {\n                groups.set(i, groups.get(i).charAt(2) + groups.get(i).substring(0, 2));\n            }\n        }\n        return String.join(\"\", groups);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        String encoded = solution.encodeCyclic(\"hellothere\");\n        System.out.println(\"Encoded: \" + encoded); // Expected: \"elhlohtree\"\n        String decoded = solution.decode_cyclic(encoded);\n        System.out.println(\"Decoded: \" + decoded); // Expected: \"hellothere\"\n    }\n}\n"}
{"task_id": "Java/39", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int prime_fib(int n) {\n        int a = 0, b = 1, c = a + b;\n        int count = 0;\n\n        while (count < n) {\n            c = a + b;\n            a = b;\n            b = c;\n            if (isPrime(c)) {\n                count++;\n                if (count == n) {\n                    return c;\n                }\n            }\n        }\n        return -1; // This line should never be reached if n is valid\n    }\n\n    private boolean isPrime(int num) {\n        if (num <= 1) return false;\n        if (num <= 3) return true;\n        if (num % 2 == 0 || num % 3 == 0) return false;\n        for (int i = 5; i * i <= num; i += 6) {\n            if (num % i == 0 || num % (i + 2) == 0) return false;\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.prime_fib(1)); // 2\n        System.out.println(solution.prime_fib(2)); // 3\n        System.out.println(solution.prime_fib(3)); // 5\n        System.out.println(solution.prime_fib(4)); // 13\n        System.out.println(solution.prime_fib(5)); // 89\n    }\n}\n"}
{"task_id": "Java/40", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public boolean triples_sum_to_zero(List<Integer> l) {\n        // If the list has less than 3 elements, return false\n        if (l.size() < 3) {\n            return false;\n        }\n\n        // Sort the list to make it easier to find triplets\n        Collections.sort(l);\n\n        // Iterate through the list and use two pointers to find triplets\n        for (int i = 0; i < l.size() - 2; i++) {\n            int left = i + 1;\n            int right = l.size() - 1;\n\n            while (left < right) {\n                int sum = l.get(i) + l.get(left) + l.get(right);\n\n                if (sum == 0) {\n                    return true;\n                } else if (sum < 0) {\n                    left++;\n                } else {\n                    right--;\n                }\n            }\n        }\n\n        // If no triplet sums to zero, return false\n        return false;\n    }\n}\n"}
{"task_id": "Java/41", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Imagine a road that's a perfectly straight infinitely long line.\n    n cars are driving left to right;  simultaneously, a different set of n cars\n    are driving right to left.   The two sets of cars start out being very far from\n    each other.  All cars move in the same speed.  Two cars are said to collide\n    when a car that's moving left to right hits a car that's moving right to left.\n    However, the cars are infinitely sturdy and strong; as a result, they continue moving\n    in their trajectory as if they did not collide.\n\n    This function outputs the number of such collisions.\n     */\n    public int car_race_collision(int n) {\n        // Each car moving left to right will collide with each car moving right to left\n        return n * n;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.car_race_collision(3)); // Output: 9\n        System.out.println(solution.car_race_collision(5)); // Output: 25\n    }\n}\n"}
{"task_id": "Java/42", "generation": "import java.util.*;\nimport java.lang.*;\nimport java.util.stream.Collectors;\n\nclass Solution {\n    /**\n    Return list with elements incremented by 1.\n    >>> incr_list(Arrays.asList(1, 2, 3))\n    [2, 3, 4]\n    >>> incr_list(Arrays.asList(5, 3, 5, 2, 3, 3, 9, 0, 123))\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n     */\n    public List<Integer> incr_list(List<Integer> l) {\n        // Use Java Streams to map each element to its incremented value\n        return l.stream()\n                .map(n -> n + 1)\n                .collect(Collectors.toList());\n    }\n}\n"}
{"task_id": "Java/43", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public boolean pairs_sum_to_zero(List<Integer> l) {\n        Set<Integer> seen = new HashSet<>();\n        \n        for (int num : l) {\n            if (seen.contains(-num)) {\n                return true;\n            }\n            seen.add(num);\n        }\n        \n        return false;\n    }\n}\n"}
{"task_id": "Java/44", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    \"22\"\n    >>> change_base(8, 2)\n    \"1000\"\n    >>> change_base(7, 2)\n    \"111\"\n     */\n    public String change_base(int x, int base) {\n        // Step 1: Initialize a StringBuilder to store the result\n        StringBuilder result = new StringBuilder();\n\n        // Step 2: Handle the case where x is 0\n        if (x == 0) {\n            return \"0\";\n        }\n\n        // Step 3: Convert the number to the new base\n        while (x > 0) {\n            int remainder = x % base;\n            result.append(remainder);\n            x /= base;\n        }\n\n        // Step 4: Reverse the result to get the correct order\n        return result.reverse().toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.change_base(8, 3)); // Output: \"22\"\n        System.out.println(solution.change_base(8, 2)); // Output: \"1000\"\n        System.out.println(solution.change_base(7, 2)); // Output: \"111\"\n    }\n}\n"}
{"task_id": "Java/45", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Given length of a side and height return area for a triangle.\n    >>> triangle_area(5, 3)\n    7.5\n     */\n    public double triangle_area(double a, double h) {\n        // The formula for the area of a triangle is (base * height) / 2\n        return (a * h) / 2;\n    }\n}\n"}
{"task_id": "Java/46", "generation": "import java.util.*;\n\nclass Solution {\n    public int fib4(int n) {\n        // Base cases\n        if (n == 0 || n == 1 || n == 3) {\n            return 0;\n        }\n        if (n == 2) {\n            return 2;\n        }\n\n        // Initialize the first four elements of the sequence\n        int[] fib4Sequence = new int[n + 1];\n        fib4Sequence[0] = 0;\n        fib4Sequence[1] = 0;\n        fib4Sequence[2] = 2;\n        fib4Sequence[3] = 0;\n\n        // Compute the sequence iteratively\n        for (int i = 4; i <= n; i++) {\n            fib4Sequence[i] = fib4Sequence[i - 1] + fib4Sequence[i - 2] + fib4Sequence[i - 3] + fib4Sequence[i - 4];\n        }\n\n        return fib4Sequence[n];\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.fib4(5)); // Output: 4\n        System.out.println(solution.fib4(6)); // Output: 8\n        System.out.println(solution.fib4(7)); // Output: 14\n    }\n}\n"}
{"task_id": "Java/47", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public double median(List<Integer> l) {\n        // Step 1: Sort the list\n        Collections.sort(l);\n\n        // Step 2: Determine the size of the list\n        int n = l.size();\n\n        // Step 3: Calculate the median\n        if (n % 2 == 1) {\n            // If the list size is odd, return the middle element\n            return l.get(n / 2);\n        } else {\n            // If the list size is even, return the average of the two middle elements\n            return (l.get(n / 2 - 1) + l.get(n / 2)) / 2.0;\n        }\n    }\n}\n"}
{"task_id": "Java/48", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Checks if given string is a palindrome\n    >>> is_palindrome(\"\")\n    true\n    >>> is_palindrome(\"aba\")\n    true\n    >>> is_palindrome(\"aaaaa\")\n    true\n    >>> is_palindrome(\"zbcd\")\n    false\n     */\n    public boolean is_palindrome(String text) {\n        // Step 1: Understand the problem\n        // A palindrome is a string that reads the same backward as forward.\n        \n        // Step 2: Algorithm/Method Selection\n        // We can check if a string is a palindrome by comparing characters from the start and end moving towards the center.\n        \n        // Step 3: Pseudocode Creation\n        // 1. Initialize two pointers, one at the start and one at the end of the string.\n        // 2. While the start pointer is less than the end pointer:\n        //    a. If the characters at the start and end pointers are not equal, return false.\n        //    b. Move the start pointer one step forward.\n        //    c. Move the end pointer one step backward.\n        // 3. If the loop completes without returning false, return true.\n        \n        // Step 4: Code Generation\n        int start = 0;\n        int end = text.length() - 1;\n        \n        while (start < end) {\n            if (text.charAt(start) != text.charAt(end)) {\n                return false;\n            }\n            start++;\n            end--;\n        }\n        \n        return true;\n    }\n}\n"}
{"task_id": "Java/49", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n     */\n    public int modp(int n, int p) {\n        int result = 1;\n        int base = 2;\n\n        while (n > 0) {\n            if (n % 2 == 1) {\n                result = (result * base) % p;\n            }\n            base = (base * base) % p;\n            n = n / 2;\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.modp(3, 5));    // Output: 3\n        System.out.println(solution.modp(1101, 101)); // Output: 2\n        System.out.println(solution.modp(0, 101));  // Output: 1\n        System.out.println(solution.modp(3, 11));   // Output: 8\n        System.out.println(solution.modp(100, 101)); // Output: 1\n    }\n}\n"}
{"task_id": "Java/50", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    returns encoded string by shifting every character by 5 in the alphabet.\n     */\n    public String encodeShift(String s) {\n        StringBuilder sb = new StringBuilder();\n        for (char ch : s.toCharArray()) {\n            char shiftedChar = (char) ('a' + ((ch - 'a' + 5) % 26));\n            sb.append(shiftedChar);\n        }\n        return sb.toString();\n    }\n\n    /**\n    takes as input string encoded with encodeShift function. Returns decoded string.\n     */\n    public String decode_shift(String s) {\n        StringBuilder sb = new StringBuilder();\n        for (char ch : s.toCharArray()) {\n            char shiftedChar = (char) ('a' + ((ch - 'a' - 5 + 26) % 26));\n            sb.append(shiftedChar);\n        }\n        return sb.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        String original = \"hello\";\n        String encoded = solution.encodeShift(original);\n        String decoded = solution.decode_shift(encoded);\n        System.out.println(\"Original: \" + original);\n        System.out.println(\"Encoded: \" + encoded);\n        System.out.println(\"Decoded: \" + decoded);\n    }\n}\n"}
{"task_id": "Java/51", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels(\"\")\n    \"\"\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    \"bcdf\\nghjklm\"\n    >>> remove_vowels(\"abcdef\")\n    \"bcdf\"\n    >>> remove_vowels(\"aaaaa\")\n    \"\"\n    >>> remove_vowels(\"aaBAA\")\n    \"B\"\n    >>> remove_vowels(\"zbcd\")\n    \"zbcd\"\n     */\n    public String remove_vowels(String text) {\n        // Define a set of vowels (both lowercase and uppercase)\n        Set<Character> vowels = new HashSet<>(Arrays.asList('a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'));\n        \n        // StringBuilder to build the result string\n        StringBuilder result = new StringBuilder();\n        \n        // Iterate through each character in the input string\n        for (char c : text.toCharArray()) {\n            // If the character is not a vowel, append it to the result\n            if (!vowels.contains(c)) {\n                result.append(c);\n            }\n        }\n        \n        // Return the result string\n        return result.toString();\n    }\n}\n"}
{"task_id": "Java/52", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Return True if all numbers in the list l are below threshold t.\n    >>> below_threshold(Arrays.asList(1, 2, 4, 10), 100)\n    true\n    >>> below_threshold(Arrays.asList(1, 20, 4, 10), 5)\n    false\n     */\n    public boolean below_threshold(List<Integer> l, int t) {\n        // Iterate through the list and check if any number is greater than or equal to the threshold\n        for (int num : l) {\n            if (num >= t) {\n                return false; // If any number is greater than or equal to the threshold, return false\n            }\n        }\n        return true; // If no number is greater than or equal to the threshold, return true\n    }\n}\n"}
{"task_id": "Java/53", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n     */\n    public int add(int x, int y) {\n        // Simply return the sum of x and y\n        return x + y;\n    }\n}\n"}
{"task_id": "Java/54", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public boolean same_chars(String s0, String s1) {\n        // Create sets to store unique characters from both strings\n        Set<Character> set0 = new HashSet<>();\n        Set<Character> set1 = new HashSet<>();\n\n        // Add characters from the first string to set0\n        for (char c : s0.toCharArray()) {\n            set0.add(c);\n        }\n\n        // Add characters from the second string to set1\n        for (char c : s1.toCharArray()) {\n            set1.add(c);\n        }\n\n        // Check if the sets are equal\n        return set0.equals(set1);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.same_chars(\"eabcdzzzz\", \"dddzzzzzzzddeddabc\")); // true\n        System.out.println(solution.same_chars(\"abcd\", \"dddddddabc\")); // true\n        System.out.println(solution.same_chars(\"dddddddabc\", \"abcd\")); // true\n        System.out.println(solution.same_chars(\"eabcd\", \"dddddddabc\")); // false\n        System.out.println(solution.same_chars(\"abcd\", \"dddddddabce\")); // false\n        System.out.println(solution.same_chars(\"eabcdzzzz\", \"dddzzzzzzzddddabc\")); // false\n    }\n}\n"}
{"task_id": "Java/55", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n     */\n    public int fib(int n) {\n        // Base cases\n        if (n == 0) return 0;\n        if (n == 1) return 1;\n\n        // Initialize the first two Fibonacci numbers\n        int a = 0, b = 1;\n\n        // Compute the n-th Fibonacci number iteratively\n        for (int i = 2; i <= n; i++) {\n            int temp = a + b;\n            a = b;\n            b = temp;\n        }\n\n        return b;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.fib(10)); // Output: 55\n        System.out.println(solution.fib(1));  // Output: 1\n        System.out.println(solution.fib(8));  // Output: 21\n    }\n}\n"}
{"task_id": "Java/56", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public boolean correct_bracketing(String brackets) {\n        int counter = 0;\n        \n        for (char c : brackets.toCharArray()) {\n            if (c == '<') {\n                counter++;\n            } else if (c == '>') {\n                counter--;\n                if (counter < 0) {\n                    return false;\n                }\n            }\n        }\n        \n        return counter == 0;\n    }\n}\n"}
{"task_id": "Java/57", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public boolean monotonic(List<Integer> l) {\n        // Check if the list is empty or has only one element\n        if (l == null || l.size() <= 1) {\n            return true;\n        }\n\n        // Determine if the list is increasing or decreasing\n        boolean increasing = l.get(1) > l.get(0);\n        boolean decreasing = l.get(1) < l.get(0);\n\n        // If the first two elements are equal, we need to find the next pair that is not equal\n        if (l.get(1).equals(l.get(0))) {\n            for (int i = 2; i < l.size(); i++) {\n                if (!l.get(i).equals(l.get(i - 1))) {\n                    increasing = l.get(i) > l.get(i - 1);\n                    decreasing = l.get(i) < l.get(i - 1);\n                    break;\n                }\n            }\n        }\n\n        // Check the rest of the list based on the determined direction\n        for (int i = 1; i < l.size(); i++) {\n            if (increasing && l.get(i) < l.get(i - 1)) {\n                return false;\n            }\n            if (decreasing && l.get(i) > l.get(i - 1)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n}\n"}
{"task_id": "Java/58", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> common(List<Integer> l1, List<Integer> l2) {\n        // Step 1: Convert both lists to sets to remove duplicates and allow for set operations\n        Set<Integer> set1 = new HashSet<>(l1);\n        Set<Integer> set2 = new HashSet<>(l2);\n\n        // Step 2: Find the intersection of the two sets\n        set1.retainAll(set2);\n\n        // Step 3: Convert the resulting set back to a list\n        List<Integer> result = new ArrayList<>(set1);\n\n        // Step 4: Sort the result list\n        Collections.sort(result);\n\n        // Step 5: Return the sorted list of common elements\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.common(Arrays.asList(1, 4, 3, 34, 653, 2, 5), Arrays.asList(5, 7, 1, 5, 9, 653, 121))); // [1, 5, 653]\n        System.out.println(solution.common(Arrays.asList(5, 3, 2, 8), Arrays.asList(3, 2))); // [2, 3]\n    }\n}\n"}
{"task_id": "Java/59", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n     */\n    public int largest_prime_factor(int n) {\n        // Step 1: Initialize the largest prime factor variable\n        int largestPrimeFactor = -1;\n\n        // Step 2: Divide n by 2 to remove all even factors\n        while (n % 2 == 0) {\n            largestPrimeFactor = 2;\n            n /= 2;\n        }\n\n        // Step 3: Check for odd factors from 3 onwards\n        for (int i = 3; i <= Math.sqrt(n); i += 2) {\n            while (n % i == 0) {\n                largestPrimeFactor = i;\n                n /= i;\n            }\n        }\n\n        // Step 4: If n is still greater than 2, then n must be a prime number\n        if (n > 2) {\n            largestPrimeFactor = n;\n        }\n\n        return largestPrimeFactor;\n    }\n}\n"}
{"task_id": "Java/60", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    sum_to_n is a function that sums numbers from 1 to n.\n    >>> sum_to_n(30)\n    465\n    >>> sum_to_n(100)\n    5050\n    >>> sum_to_n(5)\n    15\n    >>> sum_to_n(10)\n    55\n    >>> sum_to_n(1)\n    1\n     */\n    public int sum_to_n(int n) {\n        // The formula to calculate the sum of the first n natural numbers is n * (n + 1) / 2\n        return n * (n + 1) / 2;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.sum_to_n(30)); // 465\n        System.out.println(solution.sum_to_n(100)); // 5050\n        System.out.println(solution.sum_to_n(5)); // 15\n        System.out.println(solution.sum_to_n(10)); // 55\n        System.out.println(solution.sum_to_n(1)); // 1\n    }\n}\n"}
{"task_id": "Java/61", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public boolean correct_bracketing(String brackets) {\n        // Initialize a counter for tracking the balance of brackets\n        int balance = 0;\n\n        // Iterate through each character in the string\n        for (char c : brackets.toCharArray()) {\n            // If the character is an opening bracket, increment the balance\n            if (c == '(') {\n                balance++;\n            } \n            // If the character is a closing bracket, decrement the balance\n            else if (c == ')') {\n                balance--;\n            }\n\n            // If at any point the balance is negative, it means there are more closing brackets than opening ones\n            if (balance < 0) {\n                return false;\n            }\n        }\n\n        // After processing all characters, the balance should be zero for the string to be correctly bracketed\n        return balance == 0;\n    }\n}\n"}
{"task_id": "Java/62", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative(Arrays.asList(3, 1, 2, 4, 5))\n    [1, 4, 12, 20]\n    >>> derivative(Arrays.asList(1, 2, 3))\n    [2, 6]\n     */\n    public List<Integer> derivative(List<Integer> xs) {\n        // Step 1: Initialize an empty list to store the coefficients of the derivative polynomial.\n        List<Integer> derivativeCoefficients = new ArrayList<>();\n\n        // Step 2: Iterate through the coefficients starting from the first non-constant term.\n        for (int i = 1; i < xs.size(); i++) {\n            // Step 3: Calculate the coefficient of the derivative term.\n            int coefficient = xs.get(i) * i;\n\n            // Step 4: Add the calculated coefficient to the derivative coefficients list.\n            derivativeCoefficients.add(coefficient);\n        }\n\n        // Step 5: Return the list of derivative coefficients.\n        return derivativeCoefficients;\n    }\n}\n"}
{"task_id": "Java/63", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int fibfib(int n) {\n        if (n == 0 || n == 1) {\n            return 0;\n        }\n        if (n == 2) {\n            return 1;\n        }\n\n        int[] dp = new int[n + 1];\n        dp[0] = 0;\n        dp[1] = 0;\n        dp[2] = 1;\n\n        for (int i = 3; i <= n; i++) {\n            dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3];\n        }\n\n        return dp[n];\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.fibfib(1)); // Output: 0\n        System.out.println(solution.fibfib(5)); // Output: 4\n        System.out.println(solution.fibfib(8)); // Output: 24\n    }\n}\n"}
{"task_id": "Java/64", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int vowels_count(String s) {\n        // Convert the string to lowercase to handle both uppercase and lowercase letters\n        String lowerCaseString = s.toLowerCase();\n        \n        // Initialize a counter for vowels\n        int count = 0;\n        \n        // Define the set of vowels\n        Set<Character> vowels = new HashSet<>(Arrays.asList('a', 'e', 'i', 'o', 'u'));\n        \n        // Iterate through each character in the string\n        for (int i = 0; i < lowerCaseString.length(); i++) {\n            char c = lowerCaseString.charAt(i);\n            \n            // Check if the character is a vowel\n            if (vowels.contains(c)) {\n                count++;\n            }\n            \n            // Special case for 'y' at the end of the word\n            if (c == 'y' && i == lowerCaseString.length() - 1) {\n                count++;\n            }\n        }\n        \n        return count;\n    }\n}\n"}
{"task_id": "Java/65", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public String circular_shift(int x, int shift) {\n        // Convert the integer to a string to easily manipulate the digits\n        String numStr = Integer.toString(x);\n        int len = numStr.length();\n\n        // If shift is greater than the number of digits, reverse the string\n        if (shift >= len) {\n            return new StringBuilder(numStr).reverse().toString();\n        }\n\n        // Calculate the effective shift (in case shift is greater than the length)\n        shift = shift % len;\n\n        // Perform the circular shift\n        String shiftedStr = numStr.substring(len - shift) + numStr.substring(0, len - shift);\n\n        return shiftedStr;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        System.out.println(sol.circular_shift(12, 1)); // Output: \"21\"\n        System.out.println(sol.circular_shift(12, 2)); // Output: \"12\"\n        System.out.println(sol.circular_shift(12345, 3)); // Output: \"34512\"\n        System.out.println(sol.circular_shift(12345, 7)); // Output: \"54321\"\n    }\n}\n"}
{"task_id": "Java/66", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Write a function that takes a string as input and returns the sum of the upper characters only'\n    ASCII codes.\n\n    Examples:\n        digitSum(\"\") => 0\n        digitSum(\"abAB\") => 131\n        digitSum(\"abcCd\") => 67\n        digitSum(\"helloE\") => 69\n        digitSum(\"woArBld\") => 131\n        digitSum(\"aAaaaXa\") => 153\n     */\n    public int digitSum(String s) {\n        // Initialize the sum to 0\n        int sum = 0;\n\n        // Iterate through each character in the string\n        for (int i = 0; i < s.length(); i++) {\n            char c = s.charAt(i);\n\n            // Check if the character is an uppercase letter\n            if (Character.isUpperCase(c)) {\n                // Add the ASCII value of the character to the sum\n                sum += (int) c;\n            }\n        }\n\n        // Return the final sum\n        return sum;\n    }\n\n    // Main method for testing\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.digitSum(\"\")); // 0\n        System.out.println(solution.digitSum(\"abAB\")); // 131\n        System.out.println(solution.digitSum(\"abcCd\")); // 67\n        System.out.println(solution.digitSum(\"helloE\")); // 69\n        System.out.println(solution.digitSum(\"woArBld\")); // 131\n        System.out.println(solution.digitSum(\"aAaaaXa\")); // 153\n    }\n}\n"}
{"task_id": "Java/67", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int fruit_distribution(String s, int n) {\n        // Split the input string to extract the number of apples and oranges\n        String[] parts = s.split(\" \");\n        \n        // Parse the number of apples and oranges from the string\n        int apples = Integer.parseInt(parts[0]);\n        int oranges = Integer.parseInt(parts[3]);\n        \n        // Calculate the number of mangoes by subtracting the number of apples and oranges from the total number of fruits\n        int mangoes = n - apples - oranges;\n        \n        return mangoes;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        System.out.println(sol.fruit_distribution(\"5 apples and 6 oranges\", 19)); // Output: 8\n        System.out.println(sol.fruit_distribution(\"0 apples and 1 oranges\", 3));  // Output: 2\n        System.out.println(sol.fruit_distribution(\"2 apples and 3 oranges\", 100)); // Output: 95\n        System.out.println(sol.fruit_distribution(\"100 apples and 1 oranges\", 120)); // Output: 19\n    }\n}\n"}
{"task_id": "Java/68", "generation": "import java.util.*;\n\nclass Solution {\n    public List<Integer> pluck(List<Integer> arr) {\n        // Initialize variables to store the smallest even value and its index\n        int smallestEvenValue = Integer.MAX_VALUE;\n        int smallestIndex = -1;\n\n        // Iterate through the array to find the smallest even value and its index\n        for (int i = 0; i < arr.size(); i++) {\n            int value = arr.get(i);\n            // Check if the current value is even and smaller than the current smallest even value\n            if (value % 2 == 0 && value < smallestEvenValue) {\n                smallestEvenValue = value;\n                smallestIndex = i;\n            }\n        }\n\n        // Create the result list\n        List<Integer> result = new ArrayList<>();\n        // If an even value was found, add it and its index to the result list\n        if (smallestIndex != -1) {\n            result.add(smallestEvenValue);\n            result.add(smallestIndex);\n        }\n\n        return result;\n    }\n}\n"}
{"task_id": "Java/69", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int search(List<Integer> lst) {\n        // Step 1: Create a frequency map to store the frequency of each integer\n        Map<Integer, Integer> frequencyMap = new HashMap<>();\n        for (int num : lst) {\n            frequencyMap.put(num, frequencyMap.getOrDefault(num, 0) + 1);\n        }\n\n        // Step 2: Iterate through the frequency map to find the greatest integer\n        // whose frequency is greater than or equal to its value\n        int result = -1;\n        for (Map.Entry<Integer, Integer> entry : frequencyMap.entrySet()) {\n            int num = entry.getKey();\n            int freq = entry.getValue();\n            if (freq >= num && num > result) {\n                result = num;\n            }\n        }\n\n        // Step 3: Return the result\n        return result;\n    }\n\n    // Test cases to verify the solution\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        System.out.println(sol.search(Arrays.asList(4, 1, 2, 2, 3, 1))); // Expected output: 2\n        System.out.println(sol.search(Arrays.asList(1, 2, 2, 3, 3, 3, 4, 4, 4))); // Expected output: 3\n        System.out.println(sol.search(Arrays.asList(5, 5, 4, 4, 4))); // Expected output: -1\n    }\n}\n"}
{"task_id": "Java/70", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> strange_sort_list(List<Integer> lst) {\n        // Create a copy of the original list to avoid modifying it\n        List<Integer> sortedList = new ArrayList<>(lst);\n        // Sort the list in ascending order\n        Collections.sort(sortedList);\n        \n        // Initialize the result list\n        List<Integer> result = new ArrayList<>();\n        \n        // While there are elements in the sorted list\n        while (!sortedList.isEmpty()) {\n            // Add the smallest element\n            result.add(sortedList.remove(0));\n            \n            // If the list is not empty, add the largest element\n            if (!sortedList.isEmpty()) {\n                result.add(sortedList.remove(sortedList.size() - 1));\n            }\n        }\n        \n        return result;\n    }\n}\n"}
{"task_id": "Java/71", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Given the lengths of the three sides of a triangle. Return the area of\n    the triangle rounded to 2 decimal points if the three sides form a valid triangle.\n    Otherwise return -1\n    Three sides make a valid triangle when the sum of any two sides is greater\n    than the third side.\n    Example:\n    triangle_area(3, 4, 5) == 6.00\n    triangle_area(1, 2, 10) == -1\n     */\n    public double triangle_area(double a, double b, double c) {\n        // Check if the sides form a valid triangle\n        if (a + b > c && a + c > b && b + c > a) {\n            // Calculate the semi-perimeter\n            double s = (a + b + c) / 2;\n            // Calculate the area using Heron's formula\n            double area = Math.sqrt(s * (s - a) * (s - b) * (s - c));\n            // Round the area to 2 decimal points\n            return Math.round(area * 100.0) / 100.0;\n        } else {\n            // If the sides do not form a valid triangle, return -1\n            return -1;\n        }\n    }\n}\n"}
{"task_id": "Java/72", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public boolean will_it_fly(List<Integer> q, int w) {\n        // Check if the list is a palindrome\n        boolean isBalanced = isPalindrome(q);\n        \n        // Calculate the sum of the elements in the list\n        int sum = q.stream().mapToInt(Integer::intValue).sum();\n        \n        // Check if the list is balanced and the sum is less than or equal to the maximum weight\n        return isBalanced && sum <= w;\n    }\n\n    // Helper method to check if a list is a palindrome\n    private boolean isPalindrome(List<Integer> list) {\n        int left = 0;\n        int right = list.size() - 1;\n        \n        while (left < right) {\n            if (!list.get(left).equals(list.get(right))) {\n                return false;\n            }\n            left++;\n            right--;\n        }\n        return true;\n    }\n}\n"}
{"task_id": "Java/73", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Given an array arr of integers, find the minimum number of elements that\n    need to be changed to make the array palindromic. A palindromic array is an array that\n    is read the same backwards and forwards. In one change, you can change one element to any other element.\n    */\n\n    public int smallest_change(List<Integer> arr) {\n        // Step 1: Initialize the count of changes needed\n        int changes = 0;\n\n        // Step 2: Use two pointers to compare elements from the start and end of the array\n        int left = 0;\n        int right = arr.size() - 1;\n\n        // Step 3: Iterate until the pointers meet in the middle\n        while (left < right) {\n            // Step 4: If the elements at the pointers are not equal, increment the change count\n            if (!arr.get(left).equals(arr.get(right))) {\n                changes++;\n            }\n\n            // Step 5: Move the pointers towards the center\n            left++;\n            right--;\n        }\n\n        // Step 6: Return the total number of changes needed\n        return changes;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.smallest_change(Arrays.asList(1, 2, 3, 5, 4, 7, 9, 6))); // Output: 4\n        System.out.println(solution.smallest_change(Arrays.asList(1, 2, 3, 4, 3, 2, 2))); // Output: 1\n        System.out.println(solution.smallest_change(Arrays.asList(1, 2, 3, 2, 1))); // Output: 0\n    }\n}\n"}
{"task_id": "Java/74", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<String> total_match(List<String> lst1, List<String> lst2) {\n        // Calculate the total number of characters in lst1\n        int totalCharsLst1 = lst1.stream().mapToInt(String::length).sum();\n        \n        // Calculate the total number of characters in lst2\n        int totalCharsLst2 = lst2.stream().mapToInt(String::length).sum();\n        \n        // Compare the total number of characters and return the appropriate list\n        if (totalCharsLst1 <= totalCharsLst2) {\n            return lst1;\n        } else {\n            return lst2;\n        }\n    }\n}\n"}
{"task_id": "Java/75", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public boolean is_multiply_prime(int a) {\n        // Step 1: Generate a list of prime numbers less than 100\n        List<Integer> primes = generatePrimesLessThan100();\n\n        // Step 2: Check if the given number can be expressed as the product of exactly 3 primes\n        for (int i = 0; i < primes.size(); i++) {\n            for (int j = i; j < primes.size(); j++) {\n                for (int k = j; k < primes.size(); k++) {\n                    if (primes.get(i) * primes.get(j) * primes.get(k) == a) {\n                        return true;\n                    }\n                }\n            }\n        }\n\n        return false;\n    }\n\n    // Helper method to generate a list of prime numbers less than 100\n    private List<Integer> generatePrimesLessThan100() {\n        List<Integer> primes = new ArrayList<>();\n        boolean[] isPrime = new boolean[100];\n        Arrays.fill(isPrime, true);\n        isPrime[0] = false; // 0 is not a prime number\n        isPrime[1] = false; // 1 is not a prime number\n\n        for (int i = 2; i < 100; i++) {\n            if (isPrime[i]) {\n                primes.add(i);\n                for (int j = i * i; j < 100; j += i) {\n                    isPrime[j] = false;\n                }\n            }\n        }\n\n        return primes;\n    }\n}\n"}
{"task_id": "Java/76", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Your task is to write a function that returns true if a number x is a simple\n    power of n and false in other cases.\n    x is a simple power of n if n**int=x\n    For example:\n    is_simple_power(1, 4) => true\n    is_simple_power(2, 2) => true\n    is_simple_power(8, 2) => true\n    is_simple_power(3, 2) => false\n    is_simple_power(3, 1) => false\n    is_simple_power(5, 3) => false\n     */\n    public boolean is_simple_power(int x, int n) {\n        // If n is 1, the only simple power is 1 itself\n        if (n == 1) {\n            return x == 1;\n        }\n\n        // If x is 1, it can only be a simple power of 1\n        if (x == 1) {\n            return n == 1;\n        }\n\n        // Start with the base case\n        int power = 1;\n\n        // Multiply n by itself until we either match x or exceed it\n        while (power < x) {\n            power *= n;\n        }\n\n        // If power equals x, then x is a simple power of n\n        return power == x;\n    }\n}\n"}
{"task_id": "Java/77", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public boolean iscube(int a) {\n        // Special case for 0\n        if (a == 0) {\n            return true;\n        }\n\n        // Compute the cube root of the absolute value of a\n        double cubeRoot = Math.cbrt(Math.abs(a));\n\n        // Round the cube root to the nearest integer\n        int roundedCubeRoot = (int) Math.round(cubeRoot);\n\n        // Check if the cube of the rounded integer equals a\n        return Math.pow(roundedCubeRoot, 3) == a;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.iscube(1));    // true\n        System.out.println(solution.iscube(2));    // false\n        System.out.println(solution.iscube(-1));   // true\n        System.out.println(solution.iscube(64));   // true\n        System.out.println(solution.iscube(0));    // true\n        System.out.println(solution.iscube(180));  // false\n    }\n}\n"}
{"task_id": "Java/78", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int hex_key(String num) {\n        // Define the set of prime hexadecimal digits\n        Set<Character> primeHexDigits = new HashSet<>(Arrays.asList('2', '3', '5', '7', 'B', 'D'));\n        \n        // Initialize a counter for the prime digits\n        int primeCount = 0;\n        \n        // Iterate through each character in the input string\n        for (char c : num.toCharArray()) {\n            // Check if the current character is a prime hexadecimal digit\n            if (primeHexDigits.contains(c)) {\n                primeCount++;\n            }\n        }\n        \n        // Return the count of prime hexadecimal digits\n        return primeCount;\n    }\n}\n"}
{"task_id": "Java/79", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    You will be given a number in decimal form and your task is to convert it to\n    binary format. The function should return a string, with each character representing a binary\n    number. Each character in the string will be '0' or '1'.\n\n    There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    The extra characters are there to help with the format.\n\n    Examples:\n    decimal_to_binary(15)   // returns \"db1111db\"\n    decimal_to_binary(32)   // returns \"db100000db\"\n     */\n    public String decimal_to_binary(int decimal) {\n        // Step 1: Convert the decimal number to binary using built-in methods.\n        // Step 2: Add 'db' at the beginning and end of the binary string.\n        \n        // Pseudocode:\n        // 1. Convert the decimal number to a binary string.\n        // 2. Prepend 'db' to the binary string.\n        // 3. Append 'db' to the binary string.\n        // 4. Return the formatted binary string.\n        \n        // Convert the decimal number to a binary string\n        String binaryString = Integer.toBinaryString(decimal);\n        \n        // Add 'db' at the beginning and end of the binary string\n        return \"db\" + binaryString + \"db\";\n    }\n}\n"}
{"task_id": "Java/80", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    You are given a string s.\n    Your task is to check if the string is happy or not.\n    A string is happy if its length is at least 3 and every 3 consecutive letters are distinct\n    For example:\n    is_happy(a) => false\n    is_happy(aa) => false\n    is_happy(abcd) => true\n    is_happy(aabb) => false\n    is_happy(adb) => true\n    is_happy(xyy) => false\n     */\n    public boolean is_happy(String s) {\n        // Check if the string length is less than 3\n        if (s.length() < 3) {\n            return false;\n        }\n\n        // Iterate through the string to check every 3 consecutive characters\n        for (int i = 0; i < s.length() - 2; i++) {\n            char first = s.charAt(i);\n            char second = s.charAt(i + 1);\n            char third = s.charAt(i + 2);\n\n            // If any 3 consecutive characters are not distinct, return false\n            if (first == second || second == third || first == third) {\n                return false;\n            }\n        }\n\n        // If all checks pass, the string is happy\n        return true;\n    }\n}\n"}
{"task_id": "Java/81", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Converts a list of numerical GPAs to their corresponding letter grades.\n    */\n    public List<String> numerical_letter_grade(List<Double> grades) {\n        List<String> letterGrades = new ArrayList<>();\n        \n        for (Double gpa : grades) {\n            if (gpa == 4.0) {\n                letterGrades.add(\"A+\");\n            } else if (gpa > 3.7) {\n                letterGrades.add(\"A\");\n            } else if (gpa > 3.3) {\n                letterGrades.add(\"A-\");\n            } else if (gpa > 3.0) {\n                letterGrades.add(\"B+\");\n            } else if (gpa > 2.7) {\n                letterGrades.add(\"B\");\n            } else if (gpa > 2.3) {\n                letterGrades.add(\"B-\");\n            } else if (gpa > 2.0) {\n                letterGrades.add(\"C+\");\n            } else if (gpa > 1.7) {\n                letterGrades.add(\"C\");\n            } else if (gpa > 1.3) {\n                letterGrades.add(\"C-\");\n            } else if (gpa > 1.0) {\n                letterGrades.add(\"D+\");\n            } else if (gpa > 0.7) {\n                letterGrades.add(\"D\");\n            } else if (gpa > 0.0) {\n                letterGrades.add(\"D-\");\n            } else {\n                letterGrades.add(\"E\");\n            }\n        }\n        \n        return letterGrades;\n    }\n\n    // Example usage\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        List<Double> grades = Arrays.asList(4.0, 3.0, 1.7, 2.0, 3.5);\n        List<String> letterGrades = solution.numerical_letter_grade(grades);\n        System.out.println(letterGrades); // Output: [A+, B, C-, C, A-]\n    }\n}\n"}
{"task_id": "Java/82", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Write a function that takes a string and returns true if the string\n    length is a prime number or false otherwise\n    Examples\n    prime_length(\"Hello\") == true\n    prime_length(\"abcdcba\") == true\n    prime_length(\"kittens\") == true\n    prime_length(\"orange\") == false\n     */\n    public boolean prime_length(String string) {\n        // Step 1: Calculate the length of the string\n        int length = string.length();\n\n        // Step 2: Check if the length is less than 2 (not a prime number)\n        if (length < 2) {\n            return false;\n        }\n\n        // Step 3: Check if the length is divisible by any number from 2 to the square root of the length\n        for (int i = 2; i <= Math.sqrt(length); i++) {\n            if (length % i == 0) {\n                return false;\n            }\n        }\n\n        // Step 4: If no divisors were found, the length is a prime number\n        return true;\n    }\n}\n"}
{"task_id": "Java/83", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int starts_one_ends(int n) {\n        if (n == 1) {\n            return 1; // Only one 1-digit number starts or ends with 1\n        }\n\n        long power10_n_minus_1 = (long) Math.pow(10, n - 1);\n        long power10_n_minus_2 = (long) Math.pow(10, n - 2);\n\n        long countStartsWith1 = power10_n_minus_1;\n        long countEndsWith1 = 9 * power10_n_minus_2;\n        long countBothStartAndEndWith1 = power10_n_minus_2;\n\n        long result = countStartsWith1 + countEndsWith1 - countBothStartAndEndWith1;\n\n        return (int) result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.starts_one_ends(1)); // Output: 1\n        System.out.println(solution.starts_one_ends(2)); // Output: 18\n        System.out.println(solution.starts_one_ends(3)); // Output: 180\n    }\n}\n"}
{"task_id": "Java/84", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public String solve(int N) {\n        int sum_of_digits = 0;\n        \n        // Step 1: Compute the sum of digits\n        while (N > 0) {\n            int digit = N % 10;\n            sum_of_digits += digit;\n            N /= 10;\n        }\n        \n        // Step 2: Convert the sum to binary\n        String binary_sum = convertToBinary(sum_of_digits);\n        \n        return binary_sum;\n    }\n\n    private String convertToBinary(int number) {\n        StringBuilder binaryString = new StringBuilder();\n        \n        // Step 3: Convert the number to binary\n        while (number > 0) {\n            binaryString.insert(0, number % 2);\n            number /= 2;\n        }\n        \n        return binaryString.toString();\n    }\n}\n"}
{"task_id": "Java/85", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Given a non-empty list of integers lst. Add the even elements that are at odd indices.\n\n    Examples:\n        add(Arrays.asList(4, 2, 6, 7)) ==> 2\n     */\n    public int add(List<Integer> lst) {\n        // Initialize the sum to 0\n        int sum = 0;\n\n        // Iterate through the list\n        for (int i = 0; i < lst.size(); i++) {\n            // Check if the index is odd and the element is even\n            if (i % 2 != 0 && lst.get(i) % 2 == 0) {\n                // Add the element to the sum\n                sum += lst.get(i);\n            }\n        }\n\n        // Return the final sum\n        return sum;\n    }\n}\n"}
{"task_id": "Java/86", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle(\"Hi\") returns \"Hi\"\n    anti_shuffle(\"hello\") returns \"ehllo\"\n    anti_shuffle(\"Hello World!!!\") returns \"Hello !!!Wdlor\"\n     */\n    public String anti_shuffle(String s) {\n        // Split the input string into words\n        String[] words = s.split(\" \");\n        \n        // Process each word to sort its characters\n        StringBuilder result = new StringBuilder();\n        for (String word : words) {\n            char[] chars = word.toCharArray();\n            Arrays.sort(chars);\n            result.append(new String(chars)).append(\" \");\n        }\n        \n        // Remove the trailing space\n        return result.toString().trim();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.anti_shuffle(\"Hi\")); // Output: \"Hi\"\n        System.out.println(solution.anti_shuffle(\"hello\")); // Output: \"ehllo\"\n        System.out.println(solution.anti_shuffle(\"Hello World!!!\")); // Output: \"Hello !!!Wdlor\"\n    }\n}\n"}
{"task_id": "Java/87", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<List<Integer>> get_row(List<List<Integer>> lst, int x) {\n        List<List<Integer>> result = new ArrayList<>();\n\n        // Iterate through each row\n        for (int i = 0; i < lst.size(); i++) {\n            List<Integer> row = lst.get(i);\n            // Iterate through each column in reverse order to ensure descending order\n            for (int j = row.size() - 1; j >= 0; j--) {\n                if (row.get(j).equals(x)) {\n                    // Add the coordinate (row, column) to the result\n                    result.add(Arrays.asList(i, j));\n                }\n            }\n        }\n\n        // Sort the result by rows in ascending order\n        result.sort((a, b) -> a.get(0).compareTo(b.get(0)));\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        List<List<Integer>> lst1 = Arrays.asList(\n            Arrays.asList(1, 2, 3, 4, 5, 6),\n            Arrays.asList(1, 2, 3, 4, 1, 6),\n            Arrays.asList(1, 2, 3, 4, 5, 1)\n        );\n        System.out.println(solution.get_row(lst1, 1)); // [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n\n        List<List<Integer>> lst2 = new ArrayList<>();\n        System.out.println(solution.get_row(lst2, 1)); // []\n\n        List<List<Integer>> lst3 = Arrays.asList(\n            new ArrayList<>(),\n            Arrays.asList(1),\n            Arrays.asList(1, 2, 3)\n        );\n        System.out.println(solution.get_row(lst3, 3)); // [[2, 2]]\n    }\n}\n"}
{"task_id": "Java/88", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> sort_array(List<Integer> array) {\n        // Create a copy of the original array to avoid modifying it\n        List<Integer> sortedArray = new ArrayList<>(array);\n\n        // Check if the array is empty or has only one element\n        if (sortedArray.isEmpty() || sortedArray.size() == 1) {\n            return sortedArray;\n        }\n\n        // Calculate the sum of the first and last elements\n        int sum = sortedArray.get(0) + sortedArray.get(sortedArray.size() - 1);\n\n        // Determine the sorting order based on the sum\n        if (sum % 2 == 0) {\n            // Sort in descending order\n            sortedArray.sort(Collections.reverseOrder());\n        } else {\n            // Sort in ascending order\n            sortedArray.sort(Comparator.naturalOrder());\n        }\n\n        return sortedArray;\n    }\n}\n"}
{"task_id": "Java/89", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated.\n    The alphabet should be rotated in a manner such that the letters\n    shift down by two multiplied to two places (i.e., 4 places).\n    For example:\n    encrypt(\"hi\") returns \"lm\"\n    encrypt(\"asdfghjkl\") returns \"ewhjklnop\"\n    encrypt(\"gf\") returns \"kj\"\n    encrypt(\"et\") returns \"ix\"\n     */\n    public String encrypt(String s) {\n        // Define the shift amount\n        int shift = 4;\n        // Initialize a StringBuilder to build the encrypted string\n        StringBuilder encrypted = new StringBuilder();\n        \n        // Iterate over each character in the input string\n        for (char c : s.toCharArray()) {\n            // Check if the character is a lowercase letter\n            if (c >= 'a' && c <= 'z') {\n                // Calculate the new character after shifting\n                char shiftedChar = (char) ((c - 'a' + shift) % 26 + 'a');\n                encrypted.append(shiftedChar);\n            } else {\n                // If not a lowercase letter, append the character as is\n                encrypted.append(c);\n            }\n        }\n        \n        // Return the encrypted string\n        return encrypted.toString();\n    }\n\n    // Test the function\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.encrypt(\"hi\")); // Output: lm\n        System.out.println(solution.encrypt(\"asdfghjkl\")); // Output: ewhjklnop\n        System.out.println(solution.encrypt(\"gf\")); // Output: kj\n        System.out.println(solution.encrypt(\"et\")); // Output: ix\n    }\n}\n"}
{"task_id": "Java/90", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public Optional<Integer> next_smallest(List<Integer> lst) {\n        // If the list has less than 2 elements, return Optional.empty\n        if (lst.size() < 2) {\n            return Optional.empty();\n        }\n\n        // Convert the list to a set to remove duplicates\n        Set<Integer> set = new HashSet<>(lst);\n\n        // If the set has less than 2 unique elements, return Optional.empty\n        if (set.size() < 2) {\n            return Optional.empty();\n        }\n\n        // Convert the set back to a list and sort it\n        List<Integer> sortedList = new ArrayList<>(set);\n        Collections.sort(sortedList);\n\n        // Return the second smallest element\n        return Optional.of(sortedList.get(1));\n    }\n}\n"}
{"task_id": "Java/91", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    You'll be given a string of words, and your task is to count the number\n    of boredoms. A boredom is a sentence that starts with the word \"I\".\n    Sentences are delimited by '.', '?' or '!'.\n\n    For example:\n    >>> is_bored(\"Hello world\")\n    0\n    >>> is_bored(\"The sky is blue. The sun is shining. I love this weather\")\n    1\n     */\n    public int is_bored(String S) {\n        // Step 1: Split the input string into sentences using delimiters '.', '?', '!'\n        String[] sentences = S.split(\"[.?!]\");\n        \n        // Step 2: Initialize a counter to keep track of the number of boredoms\n        int boredomCount = 0;\n        \n        // Step 3: Iterate through each sentence\n        for (String sentence : sentences) {\n            // Step 4: Trim leading and trailing whitespace from the sentence\n            String trimmedSentence = sentence.trim();\n            \n            // Step 5: Check if the sentence starts with \"I\"\n            if (trimmedSentence.startsWith(\"I\")) {\n                // Step 6: Increment the boredom count\n                boredomCount++;\n            }\n        }\n        \n        // Step 7: Return the final boredom count\n        return boredomCount;\n    }\n}\n"}
{"task_id": "Java/92", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Create a function that takes 3 numbers.\n    Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n    Returns false in any other cases.\n\n    Examples\n    any_int(5, 2, 7) -> true\n\n    any_int(3, 2, 2) -> false\n\n    any_int(3, -2, 1) -> true\n\n    any_int(3.6, -2.2, 2) -> false\n     */\n    public boolean any_int(Object x, Object y, Object z) {\n        // Step 1: Convert the objects to doubles to handle both integer and floating-point inputs\n        double num1 = ((Number) x).doubleValue();\n        double num2 = ((Number) y).doubleValue();\n        double num3 = ((Number) z).doubleValue();\n\n        // Step 2: Check if all numbers are integers\n        boolean allIntegers = (num1 == Math.floor(num1) && !Double.isInfinite(num1)) &&\n                             (num2 == Math.floor(num2) && !Double.isInfinite(num2)) &&\n                             (num3 == Math.floor(num3) && !Double.isInfinite(num3));\n\n        // Step 3: Check if one of the numbers is equal to the sum of the other two\n        boolean sumCondition = (num1 == num2 + num3) || (num2 == num1 + num3) || (num3 == num1 + num2);\n\n        // Step 4: Return true if both conditions are met, otherwise return false\n        return allIntegers && sumCondition;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.any_int(5, 2, 7)); // true\n        System.out.println(solution.any_int(3, 2, 2)); // false\n        System.out.println(solution.any_int(3, -2, 1)); // true\n        System.out.println(solution.any_int(3.6, -2.2, 2)); // false\n    }\n}\n"}
{"task_id": "Java/93", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public String encode(String message) {\n        // Define a map for vowel replacements\n        Map<Character, Character> vowelMap = new HashMap<>();\n        vowelMap.put('a', 'c');\n        vowelMap.put('e', 'g');\n        vowelMap.put('i', 'k');\n        vowelMap.put('o', 'q');\n        vowelMap.put('u', 'w');\n        vowelMap.put('A', 'C');\n        vowelMap.put('E', 'G');\n        vowelMap.put('I', 'K');\n        vowelMap.put('O', 'Q');\n        vowelMap.put('U', 'W');\n\n        StringBuilder encodedMessage = new StringBuilder();\n\n        // Iterate through each character in the message\n        for (char c : message.toCharArray()) {\n            // Check if the character is a vowel and replace it\n            if (vowelMap.containsKey(c)) {\n                encodedMessage.append(vowelMap.get(c));\n            } else {\n                // Swap the case of the character\n                if (Character.isLowerCase(c)) {\n                    encodedMessage.append(Character.toUpperCase(c));\n                } else {\n                    encodedMessage.append(Character.toLowerCase(c));\n                }\n            }\n        }\n\n        return encodedMessage.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.encode(\"test\")); // Output: \"TGST\"\n        System.out.println(solution.encode(\"This is a message\")); // Output: \"tHKS KS C MGSSCGG\"\n    }\n}\n"}
{"task_id": "Java/94", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    // Method to check if a number is prime\n    private boolean isPrime(int num) {\n        if (num <= 1) return false;\n        if (num == 2) return true;\n        if (num % 2 == 0) return false;\n        for (int i = 3; i * i <= num; i += 2) {\n            if (num % i == 0) return false;\n        }\n        return true;\n    }\n\n    // Method to sum the digits of a number\n    private int sumOfDigits(int num) {\n        int sum = 0;\n        while (num > 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n        return sum;\n    }\n\n    public int skjkasdkd(List<Integer> lst) {\n        int largestPrime = Integer.MIN_VALUE;\n\n        // Find the largest prime number in the list\n        for (int num : lst) {\n            if (isPrime(num) && num > largestPrime) {\n                largestPrime = num;\n            }\n        }\n\n        // Sum the digits of the largest prime number\n        return sumOfDigits(largestPrime);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.skjkasdkd(Arrays.asList(0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3))); // 10\n        System.out.println(solution.skjkasdkd(Arrays.asList(1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1))); // 25\n        System.out.println(solution.skjkasdkd(Arrays.asList(1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3))); // 13\n        System.out.println(solution.skjkasdkd(Arrays.asList(0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6))); // 11\n        System.out.println(solution.skjkasdkd(Arrays.asList(0, 81, 12, 3, 1, 21))); // 3\n        System.out.println(solution.skjkasdkd(Arrays.asList(0, 8, 1, 2, 1, 7))); // 7\n    }\n}\n"}
{"task_id": "Java/95", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public boolean check_dict_case(Map<Object, Object> dict) {\n        // If the dictionary is empty, return false\n        if (dict.isEmpty()) {\n            return false;\n        }\n\n        // Initialize variables to track the case of the first key\n        boolean isFirstKeyLowerCase = true;\n        boolean isFirstKeyUpperCase = true;\n\n        // Iterate through the keys of the dictionary\n        for (Object key : dict.keySet()) {\n            // Check if the key is not a string\n            if (!(key instanceof String)) {\n                return false;\n            }\n\n            String strKey = (String) key;\n\n            // Check the case of the first key\n            if (isFirstKeyLowerCase && !strKey.equals(strKey.toLowerCase())) {\n                isFirstKeyLowerCase = false;\n            }\n            if (isFirstKeyUpperCase && !strKey.equals(strKey.toUpperCase())) {\n                isFirstKeyUpperCase = false;\n            }\n\n            // If both cases are invalid, return false\n            if (!isFirstKeyLowerCase && !isFirstKeyUpperCase) {\n                return false;\n            }\n        }\n\n        // If all keys are either all lowercase or all uppercase, return true\n        return true;\n    }\n}\n"}
{"task_id": "Java/96", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Implement a function that takes a non-negative integer and returns a list of the first n\n    integers that are prime numbers and less than n.\n    for example:\n    count_up_to(5) => [2,3]\n    count_up_to(11) => [2,3,5,7]\n    count_up_to(0) => []\n    count_up_to(20) => [2,3,5,7,11,13,17,19]\n    count_up_to(1) => []\n    count_up_to(18) => [2,3,5,7,11,13,17]\n     */\n    public List<Integer> count_up_to(int n) {\n        List<Integer> primes = new ArrayList<>();\n        \n        // Helper method to check if a number is prime\n        for (int i = 2; i < n; i++) {\n            if (isPrime(i)) {\n                primes.add(i);\n            }\n        }\n        \n        return primes;\n    }\n\n    private boolean isPrime(int num) {\n        if (num <= 1) {\n            return false;\n        }\n        for (int i = 2; i <= Math.sqrt(num); i++) {\n            if (num % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n"}
{"task_id": "Java/97", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Complete the function that takes two integers and returns\n    the product of their unit digits.\n    Assume the input is always valid.\n    Examples:\n    multiply(148, 412) should return 16.\n    multiply(19, 28) should return 72.\n    multiply(2020, 1851) should return 0.\n    multiply(14, -15) should return 20.\n     */\n    public int multiply(int a, int b) {\n        // Extract the unit digit of both numbers\n        int unitDigitA = Math.abs(a % 10);\n        int unitDigitB = Math.abs(b % 10);\n\n        // Calculate the product of the unit digits\n        int product = unitDigitA * unitDigitB;\n\n        // Return the product\n        return product;\n    }\n}\n"}
{"task_id": "Java/98", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Given a string s, count the number of uppercase vowels in even indices.\n    \n    For example:\n    count_upper(\"aBCdEf\") returns 1\n    count_upper(\"abcdefg\") returns 0\n    count_upper(\"dBBE\") returns 0\n     */    \n    public int count_upper(String s) {\n        // Define the set of uppercase vowels\n        Set<Character> uppercaseVowels = new HashSet<>(Arrays.asList('A', 'E', 'I', 'O', 'U'));\n        \n        // Initialize a counter for uppercase vowels in even indices\n        int count = 0;\n        \n        // Iterate through the string, checking only even indices\n        for (int i = 0; i < s.length(); i += 2) {\n            char currentChar = s.charAt(i);\n            if (uppercaseVowels.contains(currentChar)) {\n                count++;\n            }\n        }\n        \n        // Return the final count\n        return count;\n    }\n}\n"}
{"task_id": "Java/99", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n     */\n    public int closest_integer(String value) {\n        // Convert the string to a double\n        double num = Double.parseDouble(value);\n\n        // Get the floor and ceiling values of the number\n        int floorValue = (int) Math.floor(num);\n        int ceilValue = (int) Math.ceil(num);\n\n        // Check if the number is exactly halfway between two integers\n        if (num - floorValue == 0.5) {\n            // Round away from zero\n            return num > 0 ? ceilValue : floorValue - 1;\n        } else if (ceilValue - num == 0.5) {\n            // Round away from zero\n            return num > 0 ? ceilValue : floorValue - 1;\n        } else {\n            // Round to the nearest integer\n            return (int) Math.round(num);\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.closest_integer(\"10\"));    // Output: 10\n        System.out.println(solution.closest_integer(\"15.3\"));  // Output: 15\n        System.out.println(solution.closest_integer(\"14.5\"));  // Output: 15\n        System.out.println(solution.closest_integer(\"-14.5\")); // Output: -15\n    }\n}\n"}
{"task_id": "Java/100", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Given a positive integer n, you have to make a pile of n levels of stones.\n    The first level has n stones.\n    The number of stones in the next level is:\n        - the next odd number if n is odd.\n        - the next even number if n is even.\n    Return the number of stones in each level in a list, where element at index\n    i represents the number of stones in the level (i+1).\n\n    Examples:\n    >>> make_a_pile(3)\n    [3, 5, 7]\n     */\n    public List<Integer> make_a_pile(int n) {\n        // Initialize the list to store the number of stones in each level\n        List<Integer> pile = new ArrayList<>();\n\n        // The number of stones in the current level\n        int currentStones = n;\n\n        // Loop through each level from 1 to n\n        for (int i = 0; i < n; i++) {\n            // Add the current number of stones to the pile\n            pile.add(currentStones);\n\n            // Determine the next number of stones based on the current number\n            if (currentStones % 2 == 0) {\n                // If the current number of stones is even, add 2 to get the next even number\n                currentStones += 2;\n            } else {\n                // If the current number of stones is odd, add 2 to get the next odd number\n                currentStones += 2;\n            }\n        }\n\n        // Return the list of stones in each level\n        return pile;\n    }\n\n    // Main method to test the function\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.make_a_pile(3)); // Output: [3, 5, 7]\n    }\n}\n"}
{"task_id": "Java/101", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    You will be given a string of words separated by commas or spaces. Your task is\n    to split the string into words and return an array of the words.\n    \n    For example:\n    words_string(\"Hi, my name is John\").equals(Arrays.asList(\"Hi\", \"my\", \"name\", \"is\", \"John\"))\n    words_string(\"One, two, three, four, five, six\").equals(Arrays.asList(\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"))\n     */\n    public List<String> words_string(String s) {\n        // Step 1: Replace all commas with spaces to standardize the delimiter\n        String standardizedString = s.replaceAll(\",\", \" \");\n        \n        // Step 2: Split the string by spaces to get the individual words\n        String[] wordsArray = standardizedString.split(\"\\\\s+\");\n        \n        // Step 3: Convert the array to a list and return it\n        return Arrays.asList(wordsArray);\n    }\n}\n"}
{"task_id": "Java/102", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    This function takes two positive numbers x and y and returns the\n    biggest even integer number that is in the range [x, y] inclusive. If\n    there's no such number, then the function should return -1.\n    \n    For example:\n    choose_num(12, 15) = 14\n    choose_num(13, 12) = -1\n     */\n    public int choose_num(int x, int y) {\n        // Ensure x is less than or equal to y\n        if (x > y) {\n            return -1;\n        }\n\n        // Start from y and move downwards to find the largest even number\n        for (int i = y; i >= x; i--) {\n            if (i % 2 == 0) {\n                return i;\n            }\n        }\n\n        // If no even number is found, return -1\n        return -1;\n    }\n}\n"}
{"task_id": "Java/103", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public Object rounded_avg(int n, int m) {\n        // Check if n is greater than m\n        if (n > m) {\n            return -1;\n        }\n\n        // Calculate the sum of integers from n to m\n        int sum = 0;\n        for (int i = n; i <= m; i++) {\n            sum += i;\n        }\n\n        // Calculate the number of integers from n to m\n        int count = m - n + 1;\n\n        // Calculate the average and round it to the nearest integer\n        int average = Math.round((float) sum / count);\n\n        // Convert the rounded average to binary\n        String binary = Integer.toBinaryString(average);\n\n        return binary;\n    }\n}\n"}
{"task_id": "Java/104", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> unique_digits(List<Integer> x) {\n        // Step 1: Create a list to store the result\n        List<Integer> result = new ArrayList<>();\n\n        // Step 2: Iterate through each number in the input list\n        for (Integer num : x) {\n            // Step 3: Check if the number contains any even digit\n            if (!containsEvenDigit(num)) {\n                // Step 4: If no even digit is found, add the number to the result list\n                result.add(num);\n            }\n        }\n\n        // Step 5: Sort the result list in increasing order\n        Collections.sort(result);\n\n        // Step 6: Return the result list\n        return result;\n    }\n\n    // Helper method to check if a number contains any even digit\n    private boolean containsEvenDigit(int num) {\n        while (num > 0) {\n            int digit = num % 10;\n            if (digit % 2 == 0) {\n                return true;\n            }\n            num /= 10;\n        }\n        return false;\n    }\n}\n"}
{"task_id": "Java/105", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<String> by_length(List<Integer> arr) {\n        // Define the mapping from digits to their names\n        String[] digitNames = {\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"};\n\n        // Filter out numbers that are not between 1 and 9\n        List<Integer> filteredList = arr.stream()\n                                        .filter(num -> num >= 1 && num <= 9)\n                                        .sorted()\n                                        .collect(Collectors.toList());\n\n        // Reverse the filtered and sorted list\n        Collections.reverse(filteredList);\n\n        // Convert the numbers to their corresponding names\n        List<String> result = new ArrayList<>();\n        for (int num : filteredList) {\n            result.add(digitNames[num - 1]);\n        }\n\n        return result;\n    }\n}\n"}
{"task_id": "Java/106", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Implement the function f that takes n as a parameter,\n    and returns a list of size n, such that the value of the element at index i is the factorial of i if i is even\n    or the sum of numbers from 1 to i otherwise.\n    i starts from 1.\n    the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).\n    Example:\n    f(5) == [1, 2, 6, 24, 15]\n     */\n    public List<Integer> f(int n) {\n        List<Integer> result = new ArrayList<>();\n        for (int i = 1; i <= n; i++) {\n            if (i % 2 == 0) {\n                result.add(factorial(i));\n            } else {\n                result.add(sumToI(i));\n            }\n        }\n        return result;\n    }\n\n    private int factorial(int num) {\n        int result = 1;\n        for (int i = 1; i <= num; i++) {\n            result *= i;\n        }\n        return result;\n    }\n\n    private int sumToI(int num) {\n        int result = 0;\n        for (int i = 1; i <= num; i++) {\n            result += i;\n        }\n        return result;\n    }\n}\n"}
{"task_id": "Java/107", "generation": "import java.util.*;\n\nclass Solution {\n    public List<Integer> even_odd_palindrome(int n) {\n        int evenCount = 0;\n        int oddCount = 0;\n\n        for (int i = 1; i <= n; i++) {\n            if (isPalindrome(i)) {\n                if (i % 2 == 0) {\n                    evenCount++;\n                } else {\n                    oddCount++;\n                }\n            }\n        }\n\n        List<Integer> result = new ArrayList<>();\n        result.add(evenCount);\n        result.add(oddCount);\n\n        return result;\n    }\n\n    private boolean isPalindrome(int number) {\n        String numStr = Integer.toString(number);\n        int left = 0;\n        int right = numStr.length() - 1;\n\n        while (left < right) {\n            if (numStr.charAt(left) != numStr.charAt(right)) {\n                return false;\n            }\n            left++;\n            right--;\n        }\n\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.even_odd_palindrome(3)); // Output: [1, 2]\n        System.out.println(solution.even_odd_palindrome(12)); // Output: [4, 6]\n    }\n}\n"}
{"task_id": "Java/108", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums(Arrays.asList()) == 0\n    >>> count_nums(Arrays.asList(-1, 11, -11)) == 1\n    >>> count_nums(Arrays.asList(1, 1, 2)) == 3\n     */\n    public int count_nums(List<Integer> arr) {\n        int count = 0;\n        for (Integer num : arr) {\n            if (sumOfDigits(num) > 0) {\n                count++;\n            }\n        }\n        return count;\n    }\n\n    private int sumOfDigits(int num) {\n        boolean isNegative = num < 0;\n        int sum = 0;\n        while (num != 0) {\n            int digit = num % 10;\n            if (isNegative && num < 0) {\n                digit = -digit;\n            }\n            sum += digit;\n            num /= 10;\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.count_nums(Arrays.asList())); // Output: 0\n        System.out.println(solution.count_nums(Arrays.asList(-1, 11, -11))); // Output: 1\n        System.out.println(solution.count_nums(Arrays.asList(1, 1, 2))); // Output: 3\n    }\n}\n"}
{"task_id": "Java/109", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public boolean moveOneBall(List<Integer> arr) {\n        // If the array is empty, return true\n        if (arr.isEmpty()) {\n            return true;\n        }\n\n        // Create a copy of the original list and sort it\n        List<Integer> sortedArr = new ArrayList<>(arr);\n        Collections.sort(sortedArr);\n\n        // Check if the original array is already sorted\n        if (arr.equals(sortedArr)) {\n            return true;\n        }\n\n        // Try to find the number of right shifts needed to make the array sorted\n        for (int i = 0; i < arr.size(); i++) {\n            // Perform a right shift\n            Integer lastElement = arr.remove(arr.size() - 1);\n            arr.add(0, lastElement);\n\n            // Check if the array is now sorted\n            if (arr.equals(sortedArr)) {\n                return true;\n            }\n        }\n\n        // If no number of right shifts can make the array sorted, return false\n        return false;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.moveOneBall(Arrays.asList(3, 4, 5, 1, 2))); // true\n        System.out.println(solution.moveOneBall(Arrays.asList(3, 5, 4, 1, 2))); // false\n    }\n}\n"}
{"task_id": "Java/110", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public String exchange(List<Integer> lst1, List<Integer> lst2) {\n        // Count the number of odd elements in lst1\n        long oddCountLst1 = lst1.stream().filter(num -> num % 2 != 0).count();\n        \n        // Count the number of even elements in lst2\n        long evenCountLst2 = lst2.stream().filter(num -> num % 2 == 0).count();\n        \n        // Check if the number of odd elements in lst1 can be replaced by even elements from lst2\n        if (oddCountLst1 <= evenCountLst2) {\n            return \"YES\";\n        } else {\n            return \"NO\";\n        }\n    }\n}\n"}
{"task_id": "Java/111", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public Map<String, Integer> histogram(String test) {\n        // Step 1: Initialize an empty map to store the letter counts\n        Map<String, Integer> letterCounts = new HashMap<>();\n\n        // Step 2: Split the input string into an array of letters\n        String[] letters = test.split(\" \");\n\n        // Step 3: Iterate through the array and update the count of each letter in the map\n        for (String letter : letters) {\n            if (!letter.isEmpty()) {\n                letterCounts.put(letter, letterCounts.getOrDefault(letter, 0) + 1);\n            }\n        }\n\n        // Step 4: Find the maximum count from the map\n        int maxCount = 0;\n        for (int count : letterCounts.values()) {\n            if (count > maxCount) {\n                maxCount = count;\n            }\n        }\n\n        // Step 5: Create a new map to store the letters with the maximum count\n        Map<String, Integer> result = new HashMap<>();\n\n        // Step 6: Iterate through the original map and add letters with the maximum count to the new map\n        for (Map.Entry<String, Integer> entry : letterCounts.entrySet()) {\n            if (entry.getValue() == maxCount) {\n                result.put(entry.getKey(), entry.getValue());\n            }\n        }\n\n        // Step 7: Return the new map\n        return result;\n    }\n}\n"}
{"task_id": "Java/112", "generation": "import java.util.*;\n\nclass Solution {\n    public List<Object> reverse_delete(String s, String c) {\n        // Step 1: Create a set of characters from string c for quick lookup\n        Set<Character> charsToRemove = new HashSet<>();\n        for (char ch : c.toCharArray()) {\n            charsToRemove.add(ch);\n        }\n\n        // Step 2: Build the result string by excluding characters present in the set\n        StringBuilder result = new StringBuilder();\n        for (char ch : s.toCharArray()) {\n            if (!charsToRemove.contains(ch)) {\n                result.append(ch);\n            }\n        }\n\n        // Step 3: Check if the result string is a palindrome\n        String resultStr = result.toString();\n        String reversedStr = result.reverse().toString();\n        boolean isPalindrome = resultStr.equals(reversedStr);\n\n        // Step 4: Return the result string and the palindrome check result as a list\n        List<Object> resultList = new ArrayList<>();\n        resultList.add(resultStr);\n        resultList.add(isPalindrome);\n\n        return resultList;\n    }\n}\n"}
{"task_id": "Java/113", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<String> odd_count(List<String> lst) {\n        List<String> result = new ArrayList<>();\n        \n        for (String s : lst) {\n            int oddCount = 0;\n            for (char c : s.toCharArray()) {\n                if ((c - '0') % 2 != 0) {\n                    oddCount++;\n                }\n            }\n            String formattedString = \"the number of odd elements \" + oddCount + \"n the str\" + oddCount + \"ng \" + oddCount + \" of the \" + oddCount + \"nput.\";\n            result.add(formattedString);\n        }\n        \n        return result;\n    }\n}\n"}
{"task_id": "Java/114", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Given an array of integers nums, find the minimum sum of any non-empty sub-array\n    of nums.\n    Example\n    minSubArraySum(Arrays.asList(2, 3, 4, 1, 2, 4)) == 1\n    minSubArraySum(Arrays.asList(-1, -2, -3)) == -6\n     */\n    public int minSubArraySum(List<Integer> nums) {\n        // Initialize variables to store the current minimum sum and the overall minimum sum\n        int currentMinSum = nums.get(0);\n        int overallMinSum = nums.get(0);\n\n        // Iterate through the list starting from the second element\n        for (int i = 1; i < nums.size(); i++) {\n            // Update the current minimum sum by either adding the current element to the previous sum\n            // or starting a new sub-array with the current element\n            currentMinSum = Math.min(nums.get(i), currentMinSum + nums.get(i));\n\n            // Update the overall minimum sum if the current minimum sum is smaller\n            overallMinSum = Math.min(overallMinSum, currentMinSum);\n        }\n\n        // Return the overall minimum sum\n        return overallMinSum;\n    }\n}\n"}
{"task_id": "Java/115", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int max_fill(List<List<Integer>> grid, int capacity) {\n        // Initialize the total number of bucket uses\n        int totalBucketUses = 0;\n\n        // Iterate over each column in the grid\n        for (int col = 0; col < grid.get(0).size(); col++) {\n            int waterUnits = 0;\n\n            // Count the total water units in the current column\n            for (int row = 0; row < grid.size(); row++) {\n                waterUnits += grid.get(row).get(col);\n            }\n\n            // Calculate the number of bucket uses needed for this column\n            int bucketUsesForColumn = (int) Math.ceil((double) waterUnits / capacity);\n\n            // Add the bucket uses for this column to the total\n            totalBucketUses += bucketUsesForColumn;\n        }\n\n        return totalBucketUses;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Example 1\n        List<List<Integer>> grid1 = Arrays.asList(\n            Arrays.asList(0, 0, 1, 0),\n            Arrays.asList(0, 1, 0, 0),\n            Arrays.asList(1, 1, 1, 1)\n        );\n        int capacity1 = 1;\n        System.out.println(solution.max_fill(grid1, capacity1)); // Output: 6\n\n        // Example 2\n        List<List<Integer>> grid2 = Arrays.asList(\n            Arrays.asList(0, 0, 1, 1),\n            Arrays.asList(0, 0, 0, 0),\n            Arrays.asList(1, 1, 1, 1),\n            Arrays.asList(0, 1, 1, 1)\n        );\n        int capacity2 = 2;\n        System.out.println(solution.max_fill(grid2, capacity2)); // Output: 5\n\n        // Example 3\n        List<List<Integer>> grid3 = Arrays.asList(\n            Arrays.asList(0, 0, 0),\n            Arrays.asList(0, 0, 0)\n        );\n        int capacity3 = 5;\n        System.out.println(solution.max_fill(grid3, capacity3)); // Output: 0\n    }\n}\n"}
{"task_id": "Java/116", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> sort_array(List<Integer> arr) {\n        // Sort the array using a custom comparator\n        arr.sort((a, b) -> {\n            // Count the number of ones in the binary representation of both numbers\n            int countA = Integer.bitCount(a);\n            int countB = Integer.bitCount(b);\n\n            // If the number of ones is the same, sort by the decimal value\n            if (countA == countB) {\n                return a - b;\n            }\n\n            // Otherwise, sort by the number of ones\n            return countA - countB;\n        });\n\n        return arr;\n    }\n}\n"}
{"task_id": "Java/117", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<String> select_words(String s, int n) {\n        // Step 1: Check if the string is empty\n        if (s.isEmpty()) {\n            return new ArrayList<>();\n        }\n\n        // Step 2: Split the string into words\n        String[] words = s.split(\"\\\\s+\");\n\n        // Step 3: Initialize a list to store the result\n        List<String> result = new ArrayList<>();\n\n        // Step 4: Iterate through each word\n        for (String word : words) {\n            // Step 5: Count the number of consonants in the word\n            int consonantCount = countConsonants(word);\n\n            // Step 6: If the number of consonants matches n, add the word to the result list\n            if (consonantCount == n) {\n                result.add(word);\n            }\n        }\n\n        // Step 7: Return the result list\n        return result;\n    }\n\n    // Helper method to count the number of consonants in a word\n    private int countConsonants(String word) {\n        int count = 0;\n        for (char c : word.toCharArray()) {\n            if (isConsonant(c)) {\n                count++;\n            }\n        }\n        return count;\n    }\n\n    // Helper method to check if a character is a consonant\n    private boolean isConsonant(char c) {\n        return !isVowel(c) && Character.isLetter(c);\n    }\n\n    // Helper method to check if a character is a vowel\n    private boolean isVowel(char c) {\n        return \"AEIOUaeiou\".indexOf(c) != -1;\n    }\n}\n"}
{"task_id": "Java/118", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public String get_closest_vowel(String word) {\n        // Define vowels\n        Set<Character> vowels = new HashSet<>(Arrays.asList('a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'));\n        \n        // Iterate from the end of the word to the beginning\n        for (int i = word.length() - 2; i > 0; i--) {\n            // Check if the current character is a vowel and surrounded by consonants\n            if (vowels.contains(word.charAt(i)) && !vowels.contains(word.charAt(i - 1)) && !vowels.contains(word.charAt(i + 1))) {\n                return String.valueOf(word.charAt(i));\n            }\n        }\n        \n        // Return empty string if no such vowel is found\n        return \"\";\n    }\n}\n"}
{"task_id": "Java/119", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    You are given a list of two strings, both strings consist of open\n    parentheses \"(\" or close parentheses \")\" only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string \"(())()\" is good, while the string\n    \"())\" is not.\n    Return \"Yes\" if there's a way to make a good string, and return \"No\" otherwise.\n\n    Examples:\n    match_parens(Arrays.asList(\"()(\", \")\")) == \"Yes\"\n    match_parens(Arrays.asList(\")\", \")\")) == \"No\"\n     */\n    public String match_parens(List<String> lst) {\n        // Step 1: Check if concatenating in the first order results in a balanced string\n        String firstConcat = lst.get(0) + lst.get(1);\n        if (isBalanced(firstConcat)) {\n            return \"Yes\";\n        }\n\n        // Step 2: Check if concatenating in the second order results in a balanced string\n        String secondConcat = lst.get(1) + lst.get(0);\n        if (isBalanced(secondConcat)) {\n            return \"Yes\";\n        }\n\n        // Step 3: If neither order results in a balanced string, return \"No\"\n        return \"No\";\n    }\n\n    // Helper method to check if a string of parentheses is balanced\n    private boolean isBalanced(String s) {\n        int balance = 0;\n        for (char c : s.toCharArray()) {\n            if (c == '(') {\n                balance++;\n            } else if (c == ')') {\n                balance--;\n                if (balance < 0) {\n                    return false; // Early exit if balance goes negative\n                }\n            }\n        }\n        return balance == 0; // Final check to ensure all parentheses are balanced\n    }\n}\n"}
{"task_id": "Java/120", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Given an array arr of integers and a positive integer k, return a sorted list\n    of length k with the maximum k numbers in arr, in ascending order.\n     */\n    public List<Integer> maximum(List<Integer> arr, int k) {\n        // Step 1: Sort the array in descending order\n        // Step 2: Create a new list to store the first k elements\n        // Step 3: Sort the new list in ascending order\n        // Step 4: Return the new list\n\n        // Pseudocode:\n        // 1. Sort the array in descending order\n        // 2. Create a new list to store the first k elements\n        // 3. Add the first k elements from the sorted array to the new list\n        // 4. Sort the new list in ascending order\n        // 5. Return the new list\n\n        // Java Code:\n        Collections.sort(arr, Collections.reverseOrder());\n        List<Integer> result = new ArrayList<>(arr.subList(0, Math.min(k, arr.size())));\n        Collections.sort(result);\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        List<Integer> arr1 = Arrays.asList(-3, -4, 5);\n        int k1 = 3;\n        System.out.println(solution.maximum(arr1, k1)); // Output: [-4, -3, 5]\n\n        List<Integer> arr2 = Arrays.asList(4, -4, 4);\n        int k2 = 2;\n        System.out.println(solution.maximum(arr2, k2)); // Output: [4, 4]\n\n        List<Integer> arr3 = Arrays.asList(-3, 2, 1, 2, -1, -2, 1);\n        int k3 = 1;\n        System.out.println(solution.maximum(arr3, k3)); // Output: [2]\n    }\n}\n"}
{"task_id": "Java/121", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int solution(List<Integer> lst) {\n        int sum = 0;\n        for (int i = 0; i < lst.size(); i++) {\n            if (i % 2 == 0 && lst.get(i) % 2 != 0) {\n                sum += lst.get(i);\n            }\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        System.out.println(sol.solution(Arrays.asList(5, 8, 7, 1))); // Output: 12\n        System.out.println(sol.solution(Arrays.asList(3, 3, 3, 3, 3))); // Output: 9\n        System.out.println(sol.solution(Arrays.asList(30, 13, 24, 321))); // Output: 0\n    }\n}\n"}
{"task_id": "Java/122", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int add_elements(List<Integer> arr, int k) {\n        // Initialize the sum to 0\n        int sum = 0;\n\n        // Iterate through the first k elements of the array\n        for (int i = 0; i < k; i++) {\n            // Check if the current element has at most two digits\n            if (arr.get(i) >= -99 && arr.get(i) <= 99) {\n                // Add the element to the sum\n                sum += arr.get(i);\n            }\n        }\n\n        // Return the final sum\n        return sum;\n    }\n}\n"}
{"task_id": "Java/123", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> get_odd_collatz(int n) {\n        // Step 1: Generate the Collatz sequence starting from n\n        List<Integer> collatzSequence = new ArrayList<>();\n        while (n != 1) {\n            collatzSequence.add(n);\n            if (n % 2 == 0) {\n                n /= 2;\n            } else {\n                n = 3 * n + 1;\n            }\n        }\n        collatzSequence.add(1); // Add 1 to the sequence as it is always the last element\n\n        // Step 2: Filter out the odd numbers from the Collatz sequence\n        List<Integer> oddNumbers = new ArrayList<>();\n        for (int num : collatzSequence) {\n            if (num % 2 != 0) {\n                oddNumbers.add(num);\n            }\n        }\n\n        // Step 3: Sort the list of odd numbers in increasing order\n        Collections.sort(oddNumbers);\n\n        // Step 4: Return the sorted list of odd numbers\n        return oddNumbers;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.get_odd_collatz(5)); // Output: [1, 5]\n        System.out.println(solution.get_odd_collatz(6)); // Output: [1, 3]\n        System.out.println(solution.get_odd_collatz(7)); // Output: [1, 7, 11, 23]\n    }\n}\n"}
{"task_id": "Java/124", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public boolean valid_date(String date) {\n        // Check if the date string is empty\n        if (date == null || date.isEmpty()) {\n            return false;\n        }\n\n        // Check if the date is in the correct format mm-dd-yyyy\n        String[] parts = date.split(\"-\");\n        if (parts.length != 3) {\n            return false;\n        }\n\n        // Parse the date parts\n        try {\n            int month = Integer.parseInt(parts[0]);\n            int day = Integer.parseInt(parts[1]);\n            int year = Integer.parseInt(parts[2]);\n\n            // Check if the month is valid\n            if (month < 1 || month > 12) {\n                return false;\n            }\n\n            // Check if the day is valid based on the month\n            if (day < 1 || day > 31) {\n                return false;\n            }\n\n            // Check specific day limits for each month\n            if (month == 2 && day > 29) {\n                return false;\n            } else if ((month == 4 || month == 6 || month == 9 || month == 11) && day > 30) {\n                return false;\n            }\n\n            // If all checks pass, the date is valid\n            return true;\n        } catch (NumberFormatException e) {\n            // If parsing fails, the date is invalid\n            return false;\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.valid_date(\"03-11-2000\")); // true\n        System.out.println(solution.valid_date(\"15-01-2012\")); // false\n        System.out.println(solution.valid_date(\"04-0-2040\"));  // false\n        System.out.println(solution.valid_date(\"06-04-2020\")); // true\n        System.out.println(solution.valid_date(\"06/04/2020\")); // false\n    }\n}\n"}
{"task_id": "Java/125", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public Object split_words(String txt) {\n        // Check if the string contains whitespace\n        if (txt.contains(\" \")) {\n            // Split the string on whitespace and return the list\n            return Arrays.asList(txt.split(\" \"));\n        }\n        // Check if the string contains commas\n        else if (txt.contains(\",\")) {\n            // Split the string on commas and return the list\n            return Arrays.asList(txt.split(\",\"));\n        } else {\n            // Count the number of lowercase letters with odd order in the alphabet\n            int count = 0;\n            for (char c : txt.toCharArray()) {\n                if (Character.isLowerCase(c) && ((c - 'a') % 2 == 1)) {\n                    count++;\n                }\n            }\n            return count;\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.split_words(\"Hello world!\")); // [\"Hello\", \"world!\"]\n        System.out.println(solution.split_words(\"Hello,world!\")); // [\"Hello\", \"world!\"]\n        System.out.println(solution.split_words(\"abcdef\")); // 3\n    }\n}\n"}
{"task_id": "Java/126", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public boolean is_sorted(List<Integer> lst) {\n        if (lst.size() <= 1) {\n            return true;\n        }\n\n        int previous = lst.get(0);\n        int count = 1;\n\n        for (int i = 1; i < lst.size(); i++) {\n            int current = lst.get(i);\n\n            if (current < previous) {\n                return false; // Not sorted\n            }\n\n            if (current == previous) {\n                count++;\n                if (count > 2) {\n                    return false; // Element appears more than twice\n                }\n            } else {\n                count = 1; // Reset count for a new element\n            }\n\n            previous = current;\n        }\n\n        return true;\n    }\n}\n"}
{"task_id": "Java/127", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public String intersection(List<Integer> interval1, List<Integer> interval2) {\n        // Step 1: Determine the intersection of the two intervals\n        int start = Math.max(interval1.get(0), interval2.get(0));\n        int end = Math.min(interval1.get(1), interval2.get(1));\n\n        // Step 2: Check if there is no intersection\n        if (start > end) {\n            return \"NO\";\n        }\n\n        // Step 3: Calculate the length of the intersection\n        int length = end - start + 1;\n\n        // Step 4: Check if the length is a prime number\n        if (isPrime(length)) {\n            return \"YES\";\n        } else {\n            return \"NO\";\n        }\n    }\n\n    // Helper method to check if a number is prime\n    private boolean isPrime(int n) {\n        if (n <= 1) {\n            return false;\n        }\n        if (n == 2) {\n            return true;\n        }\n        if (n % 2 == 0) {\n            return false;\n        }\n        for (int i = 3; i * i <= n; i += 2) {\n            if (n % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n"}
{"task_id": "Java/128", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public Optional<Integer> prod_signs(List<Integer> arr) {\n        // If the array is empty, return Optional.empty()\n        if (arr.isEmpty()) {\n            return Optional.empty();\n        }\n\n        // Initialize variables to store the sum of magnitudes and the product of signs\n        int sumOfMagnitudes = 0;\n        int productOfSigns = 1;\n\n        // Iterate through the array to calculate the sum of magnitudes and the product of signs\n        for (int num : arr) {\n            if (num == 0) {\n                productOfSigns = 0;\n                break; // If any number is zero, the product of signs will be zero\n            }\n            sumOfMagnitudes += Math.abs(num);\n            productOfSigns *= (num > 0) ? 1 : -1;\n        }\n\n        // Return the result as an Optional\n        return Optional.of(sumOfMagnitudes * productOfSigns);\n    }\n}\n"}
{"task_id": "Java/129", "generation": "import java.util.*;\n\nclass Solution {\n    public List<Integer> minPath(List<List<Integer>> grid, int k) {\n        int N = grid.size();\n        PriorityQueue<Path> pq = new PriorityQueue<>((a, b) -> {\n            for (int i = 0; i < Math.min(a.path.size(), b.path.size()); i++) {\n                if (!a.path.get(i).equals(b.path.get(i))) {\n                    return a.path.get(i) - b.path.get(i);\n                }\n            }\n            return a.path.size() - b.path.size();\n        });\n\n        // Directions: up, down, left, right\n        int[][] directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n\n        // Add all starting positions to the priority queue\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                pq.offer(new Path(grid.get(i).get(j), new ArrayList<>(List.of(grid.get(i).get(j))), new int[]{i, j}));\n            }\n        }\n\n        while (!pq.isEmpty()) {\n            Path current = pq.poll();\n            if (current.path.size() == k) {\n                return current.path;\n            }\n            int[] pos = current.position;\n            for (int[] dir : directions) {\n                int newX = pos[0] + dir[0];\n                int newY = pos[1] + dir[1];\n                if (newX >= 0 && newX < N && newY >= 0 && newY < N) {\n                    List<Integer> newPath = new ArrayList<>(current.path);\n                    newPath.add(grid.get(newX).get(newY));\n                    pq.offer(new Path(grid.get(newX).get(newY), newPath, new int[]{newX, newY}));\n                }\n            }\n        }\n\n        return new ArrayList<>(); // Should never reach here\n    }\n\n    static class Path {\n        int currentValue;\n        List<Integer> path;\n        int[] position;\n\n        Path(int currentValue, List<Integer> path, int[] position) {\n            this.currentValue = currentValue;\n            this.path = path;\n            this.position = position;\n        }\n    }\n}\n"}
{"task_id": "Java/130", "generation": "import java.util.*;\n\nclass Solution {\n    public List<Integer> tri(int n) {\n        List<Integer> result = new ArrayList<>();\n        if (n == 0) {\n            result.add(1);\n            return result;\n        }\n\n        // Initialize the base cases\n        result.add(1); // tri(0) = 1\n        result.add(3); // tri(1) = 3\n\n        // Compute the Tribonacci sequence up to n\n        for (int i = 2; i <= n; i++) {\n            if (i % 2 == 0) {\n                result.add(1 + i / 2);\n            } else {\n                result.add(triRecursive(result, i));\n            }\n        }\n\n        return result;\n    }\n\n    private int triRecursive(List<Integer> result, int n) {\n        if (n == 0) return 1;\n        if (n == 1) return 3;\n\n        if (n % 2 == 0) {\n            return 1 + n / 2;\n        } else {\n            return result.get(n - 1) + result.get(n - 2) + triRecursive(result, n + 1);\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.tri(3)); // Output: [1, 3, 2, 8]\n    }\n}\n"}
{"task_id": "Java/131", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n     */\n    public int digits(int n) {\n        // Step 1: Initialize the product variable to 1.\n        int product = 1;\n        // Step 2: Initialize a boolean flag to check if there are any odd digits.\n        boolean hasOddDigit = false;\n\n        // Step 3: Loop through each digit of the number.\n        while (n > 0) {\n            // Step 4: Extract the last digit.\n            int digit = n % 10;\n            // Step 5: Check if the digit is odd.\n            if (digit % 2 != 0) {\n                // Step 6: Multiply the product by the odd digit.\n                product *= digit;\n                // Step 7: Set the flag to true since we found an odd digit.\n                hasOddDigit = true;\n            }\n            // Step 8: Remove the last digit from the number.\n            n /= 10;\n        }\n\n        // Step 9: If no odd digits were found, return 0.\n        if (!hasOddDigit) {\n            return 0;\n        }\n\n        // Step 10: Return the product of the odd digits.\n        return product;\n    }\n}\n"}
{"task_id": "Java/132", "generation": "import java.util.*;\n\nclass Solution {\n    public boolean is_nested(String string) {\n        Stack<Character> stack = new Stack<>();\n        boolean nested = false;\n\n        for (char c : string.toCharArray()) {\n            if (c == '[') {\n                stack.push(c);\n            } else if (c == ']') {\n                if (stack.isEmpty()) {\n                    // Unmatched closing bracket\n                    return false;\n                }\n                stack.pop();\n                if (!stack.isEmpty()) {\n                    // If the stack is not empty after popping, it means we have a nested structure\n                    nested = true;\n                }\n            }\n        }\n\n        // Check if there are any unmatched opening brackets left\n        if (!stack.isEmpty()) {\n            return false;\n        }\n\n        return nested;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.is_nested(\"[[]]\")); // true\n        System.out.println(solution.is_nested(\"[]]]]]]][[[[[]\")); // false\n        System.out.println(solution.is_nested(\"[][]\")); // false\n        System.out.println(solution.is_nested(\"[]\")); // false\n        System.out.println(solution.is_nested(\"[[][]]\")); // true\n        System.out.println(solution.is_nested(\"[[]][[\")); // true\n    }\n}\n"}
{"task_id": "Java/133", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int sum_squares(List<Double> lst) {\n        // Initialize the sum variable to store the sum of squared numbers\n        int sum = 0;\n\n        // Iterate through each number in the list\n        for (Double num : lst) {\n            // Round the number to the upper integer using Math.ceil\n            int roundedNum = (int) Math.ceil(num);\n\n            // Square the rounded number and add it to the sum\n            sum += roundedNum * roundedNum;\n        }\n\n        // Return the final sum\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.sum_squares(Arrays.asList(1.0, 2.0, 3.0))); // Output: 14\n        System.out.println(solution.sum_squares(Arrays.asList(1.0, 4.0, 9.0))); // Output: 98\n        System.out.println(solution.sum_squares(Arrays.asList(1.0, 3.0, 5.0, 7.0))); // Output: 84\n        System.out.println(solution.sum_squares(Arrays.asList(1.4, 4.2, 0.0))); // Output: 29\n        System.out.println(solution.sum_squares(Arrays.asList(-2.4, 1.0, 1.0))); // Output: 6\n    }\n}\n"}
{"task_id": "Java/134", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Create a function that returns true if the last character\n    of a given string is an alphabetical character and is not\n    a part of a word, and false otherwise.\n    Note: \"word\" is a group of characters separated by space.\n\n    Examples:\n    check_if_last_char_is_a_letter(\"apple pie\") -> false\n    check_if_last_char_is_a_letter(\"apple pi e\") -> true\n    check_if_last_char_is_a_letter(\"apple pi e \") -> false\n    check_if_last_char_is_a_letter(\"\") -> false\n     */\n    public boolean check_if_last_char_is_a_letter(String txt) {\n        // Check if the string is empty\n        if (txt.isEmpty()) {\n            return false;\n        }\n\n        // Get the last character of the string\n        char lastChar = txt.charAt(txt.length() - 1);\n\n        // Check if the last character is a letter and not a part of a word\n        return Character.isLetter(lastChar) && (txt.length() == 1 || txt.charAt(txt.length() - 2) == ' ');\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.check_if_last_char_is_a_letter(\"apple pie\")); // false\n        System.out.println(solution.check_if_last_char_is_a_letter(\"apple pi e\")); // true\n        System.out.println(solution.check_if_last_char_is_a_letter(\"apple pi e \")); // false\n        System.out.println(solution.check_if_last_char_is_a_letter(\"\")); // false\n    }\n}\n"}
{"task_id": "Java/135", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Create a function which returns the largest index of an element which\n    is not greater than or equal to the element immediately preceding it. If\n    no such element exists then return -1. The given array will not contain\n    duplicate values.\n\n    Examples:\n    can_arrange(Arrays.asList(1,2,4,3,5)) = 3\n    can_arrange(Arrays.asList(1,2,3)) = -1\n     */\n    public int can_arrange(List<Integer> arr) {\n        // Initialize the result index to -1\n        int resultIndex = -1;\n\n        // Iterate through the list starting from the second element\n        for (int i = 1; i < arr.size(); i++) {\n            // Check if the current element is less than the previous element\n            if (arr.get(i) < arr.get(i - 1)) {\n                // Update the result index to the current index\n                resultIndex = i;\n            }\n        }\n\n        // Return the result index\n        return resultIndex;\n    }\n}\n"}
{"task_id": "Java/136", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Optional<Integer>> largest_smallest_integers(List<Integer> lst) {\n        // Initialize variables to store the largest negative and smallest positive integers\n        Optional<Integer> largestNegative = Optional.empty();\n        Optional<Integer> smallestPositive = Optional.empty();\n\n        // Iterate through the list to find the largest negative and smallest positive integers\n        for (Integer num : lst) {\n            if (num < 0) {\n                if (largestNegative.isPresent()) {\n                    largestNegative = Optional.of(Math.max(largestNegative.get(), num));\n                } else {\n                    largestNegative = Optional.of(num);\n                }\n            } else if (num > 0) {\n                if (smallestPositive.isPresent()) {\n                    smallestPositive = Optional.of(Math.min(smallestPositive.get(), num));\n                } else {\n                    smallestPositive = Optional.of(num);\n                }\n            }\n        }\n\n        // Return the results as a list of Optionals\n        return Arrays.asList(largestNegative, smallestPositive);\n    }\n}\n"}
{"task_id": "Java/137", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public Optional<Object> compare_one(Object a, Object b) {\n        double numA = convertToDouble(a);\n        double numB = convertToDouble(b);\n\n        if (numA == numB) {\n            return Optional.empty();\n        } else if (numA > numB) {\n            return Optional.of(a);\n        } else {\n            return Optional.of(b);\n        }\n    }\n\n    private double convertToDouble(Object value) {\n        if (value instanceof String) {\n            String strValue = (String) value;\n            strValue = strValue.replace(',', '.');\n            return Double.parseDouble(strValue);\n        } else if (value instanceof Integer) {\n            return ((Integer) value).doubleValue();\n        } else if (value instanceof Double) {\n            return (Double) value;\n        } else {\n            throw new IllegalArgumentException(\"Unsupported type: \" + value.getClass().getName());\n        }\n    }\n}\n"}
{"task_id": "Java/138", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers\n    Example\n    is_equal_to_sum_even(4) == false\n    is_equal_to_sum_even(6) == false\n    is_equal_to_sum_even(8) == true\n     */\n    public boolean is_equal_to_sum_even(int n) {\n        // Step 1: Understand the problem\n        // We need to check if the given number n can be expressed as the sum of exactly 4 positive even numbers.\n        // Positive even numbers are 2, 4, 6, 8, etc.\n\n        // Step 2: Analyze the conditions\n        // The smallest sum of 4 positive even numbers is 2 + 2 + 2 + 2 = 8.\n        // Any number less than 8 cannot be expressed as the sum of 4 positive even numbers.\n        // For any number greater than or equal to 8, we can always express it as 8 + (n-8), where (n-8) is a multiple of 2.\n\n        // Step 3: Create the algorithm\n        // 1. If n is less than 8, return false.\n        // 2. If n is greater than or equal to 8 and (n - 8) is even, return true.\n        // 3. Otherwise, return false.\n\n        // Step 4: Implement the algorithm in Java\n\n        if (n < 8) {\n            return false;\n        }\n\n        // Check if (n - 8) is even\n        return (n - 8) % 2 == 0;\n    }\n}\n"}
{"task_id": "Java/139", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n     */\n    public long special_factorial(int n) {\n        long result = 1;\n        for (int i = 1; i <= n; i++) {\n            result *= factorial(i);\n        }\n        return result;\n    }\n\n    private long factorial(int k) {\n        long fact = 1;\n        for (int i = 1; i <= k; i++) {\n            fact *= i;\n        }\n        return fact;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.special_factorial(4)); // Expected output: 288\n    }\n}\n"}
{"task_id": "Java/140", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public String fix_spaces(String text) {\n        // Step 1: Replace all spaces with underscores\n        String replacedWithUnderscore = text.replace(' ', '_');\n        \n        // Step 2: Replace sequences of 2 or more underscores with a single dash\n        String result = replacedWithUnderscore.replaceAll(\"_+\", \"-\");\n        \n        return result;\n    }\n}\n"}
{"task_id": "Java/141", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public String file_name_check(String file_name) {\n        // Define the valid extensions\n        Set<String> validExtensions = new HashSet<>(Arrays.asList(\"txt\", \"exe\", \"dll\"));\n        \n        // Split the file name by the dot\n        String[] parts = file_name.split(\"\\\\.\", -1);\n        \n        // Check if there is exactly one dot\n        if (parts.length != 2) {\n            return \"No\";\n        }\n        \n        // Extract the name and extension parts\n        String namePart = parts[0];\n        String extensionPart = parts[1];\n        \n        // Check if the name part starts with a letter and contains no more than three digits\n        if (!Character.isLetter(namePart.charAt(0)) || countDigits(namePart) > 3) {\n            return \"No\";\n        }\n        \n        // Check if the extension part is valid\n        if (!validExtensions.contains(extensionPart)) {\n            return \"No\";\n        }\n        \n        // If all checks pass, the file name is valid\n        return \"Yes\";\n    }\n    \n    // Helper method to count the number of digits in a string\n    private int countDigits(String s) {\n        int count = 0;\n        for (char c : s.toCharArray()) {\n            if (Character.isDigit(c)) {\n                count++;\n            }\n        }\n        return count;\n    }\n}\n"}
{"task_id": "Java/142", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int sum_squares(List<Integer> lst) {\n        // Initialize the sum to 0\n        int sum = 0;\n\n        // Iterate through the list\n        for (int i = 0; i < lst.size(); i++) {\n            int num = lst.get(i);\n\n            // Check if the index is a multiple of 3\n            if (i % 3 == 0) {\n                sum += num * num; // Square the number and add to sum\n            } \n            // Check if the index is a multiple of 4 but not a multiple of 3\n            else if (i % 4 == 0 && i % 3 != 0) {\n                sum += num * num * num; // Cube the number and add to sum\n            } \n            // If the index is neither a multiple of 3 nor 4, add the number as is\n            else {\n                sum += num;\n            }\n        }\n\n        // Return the final sum\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.sum_squares(Arrays.asList(1, 2, 3))); // Output: 6\n        System.out.println(solution.sum_squares(Arrays.asList())); // Output: 0\n        System.out.println(solution.sum_squares(Arrays.asList(-1, -5, 2, -1, -5))); // Output: -126\n    }\n}\n"}
{"task_id": "Java/143", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    // Helper function to check if a number is prime\n    private boolean isPrime(int num) {\n        if (num <= 1) return false;\n        if (num == 2) return true;\n        if (num % 2 == 0) return false;\n        for (int i = 3; i * i <= num; i += 2) {\n            if (num % i == 0) return false;\n        }\n        return true;\n    }\n\n    public String words_in_sentence(String sentence) {\n        // Split the sentence into words\n        String[] words = sentence.split(\" \");\n        \n        // Initialize a list to store words with prime lengths\n        List<String> primeLengthWords = new ArrayList<>();\n        \n        // Iterate through each word\n        for (String word : words) {\n            // Check if the length of the word is prime\n            if (isPrime(word.length())) {\n                primeLengthWords.add(word);\n            }\n        }\n        \n        // Join the list of words into a single string with spaces\n        return String.join(\" \", primeLengthWords);\n    }\n}\n"}
{"task_id": "Java/144", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Your task is to implement a function that will simplify the expression\n    x * n. The function returns true if x * n evaluates to a whole number and false\n    otherwise. Both x and n, are string representation of a fraction, and have the following format,\n    <numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n\n    You can assume that x, and n are valid fractions, and do not have zero as denominator.\n\n    simplify(\"1/5\", \"5/1\") = true\n    simplify(\"1/6\", \"2/1\") = false\n    simplify(\"7/10\", \"10/2\") = false\n     */\n\n    public boolean simplify(String x, String n) {\n        // Split the fractions into numerator and denominator\n        String[] xParts = x.split(\"/\");\n        String[] nParts = n.split(\"/\");\n\n        // Parse the numerators and denominators\n        int xNumerator = Integer.parseInt(xParts[0]);\n        int xDenominator = Integer.parseInt(xParts[1]);\n        int nNumerator = Integer.parseInt(nParts[0]);\n        int nDenominator = Integer.parseInt(nParts[1]);\n\n        // Calculate the product of the fractions\n        int productNumerator = xNumerator * nNumerator;\n        int productDenominator = xDenominator * nDenominator;\n\n        // Check if the product is a whole number\n        return productNumerator % productDenominator == 0;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.simplify(\"1/5\", \"5/1\")); // true\n        System.out.println(solution.simplify(\"1/6\", \"2/1\")); // false\n        System.out.println(solution.simplify(\"7/10\", \"10/2\")); // false\n    }\n}\n"}
{"task_id": "Java/145", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> order_by_points(List<Integer> nums) {\n        // Helper function to calculate the sum of digits of an integer\n        class DigitSumComparator implements Comparator<Integer> {\n            @Override\n            public int compare(Integer num1, Integer num2) {\n                int sum1 = sumOfDigits(num1);\n                int sum2 = sumOfDigits(num2);\n                if (sum1 != sum2) {\n                    return sum1 - sum2;\n                } else {\n                    return nums.indexOf(num1) - nums.indexOf(num2);\n                }\n            }\n\n            private int sumOfDigits(int num) {\n                boolean isNegative = num < 0;\n                int sum = 0;\n                while (num != 0) {\n                    int digit = num % 10;\n                    if (isNegative && num < 0) {\n                        digit = -digit;\n                    }\n                    sum += digit;\n                    num /= 10;\n                }\n                return sum;\n            }\n        }\n\n        // Sort the list using the custom comparator\n        Collections.sort(nums, new DigitSumComparator());\n\n        return nums;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        List<Integer> nums1 = Arrays.asList(1, 11, -1, -11, -12);\n        System.out.println(solution.order_by_points(nums1)); // Output: [-1, -11, 1, -12, 11]\n\n        List<Integer> nums2 = Arrays.asList();\n        System.out.println(solution.order_by_points(nums2)); // Output: []\n    }\n}\n"}
{"task_id": "Java/146", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int specialFilter(List<Integer> nums) {\n        // Initialize a counter to keep track of the numbers that meet the criteria\n        int count = 0;\n\n        // Iterate through each number in the list\n        for (int num : nums) {\n            // Check if the number is greater than 10\n            if (num > 10) {\n                // Convert the number to a string to easily access the first and last digits\n                String numStr = String.valueOf(Math.abs(num));\n                char firstDigit = numStr.charAt(0);\n                char lastDigit = numStr.charAt(numStr.length() - 1);\n\n                // Check if both the first and last digits are odd\n                if (isOdd(firstDigit) && isOdd(lastDigit)) {\n                    // Increment the counter if the number meets all criteria\n                    count++;\n                }\n            }\n        }\n\n        // Return the final count\n        return count;\n    }\n\n    // Helper method to check if a character represents an odd digit\n    private boolean isOdd(char digit) {\n        return digit == '1' || digit == '3' || digit == '5' || digit == '7' || digit == '9';\n    }\n}\n"}
{"task_id": "Java/147", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int get_max_triples(int n) {\n        // Step 1: Generate the array a based on the given formula\n        int[] a = new int[n];\n        for (int i = 1; i <= n; i++) {\n            a[i - 1] = i * i - i + 1;\n        }\n\n        // Step 2: Count the number of valid triples (a[i], a[j], a[k]) where i < j < k\n        int count = 0;\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                for (int k = j + 1; k < n; k++) {\n                    if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                        count++;\n                    }\n                }\n            }\n        }\n\n        // Step 3: Return the count of valid triples\n        return count;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int n = 5;\n        System.out.println(solution.get_max_triples(n)); // Output: 1\n    }\n}\n"}
{"task_id": "Java/148", "generation": "import java.util.*;\n\nclass Solution {\n    public List<String> bf(String planet1, String planet2) {\n        // Define the list of planets in order of proximity to the Sun\n        List<String> planets = Arrays.asList(\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\");\n        \n        // Check if both planet names are valid\n        if (!planets.contains(planet1) || !planets.contains(planet2)) {\n            return new ArrayList<>();\n        }\n        \n        // Find the indices of the input planets\n        int index1 = planets.indexOf(planet1);\n        int index2 = planets.indexOf(planet2);\n        \n        // Ensure index1 is less than index2\n        if (index1 > index2) {\n            int temp = index1;\n            index1 = index2;\n            index2 = temp;\n        }\n        \n        // Extract the sublist of planets between the two indices\n        List<String> result = planets.subList(index1 + 1, index2);\n        \n        // Return the result\n        return result;\n    }\n}\n"}
{"task_id": "Java/149", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<String> sorted_list_sum(List<String> lst) {\n        // Step 1: Remove strings with odd lengths\n        List<String> filteredList = new ArrayList<>();\n        for (String s : lst) {\n            if (s.length() % 2 == 0) {\n                filteredList.add(s);\n            }\n        }\n\n        // Step 2: Sort the list by length and then alphabetically\n        Collections.sort(filteredList, new Comparator<String>() {\n            @Override\n            public int compare(String s1, String s2) {\n                if (s1.length() != s2.length()) {\n                    return s1.length() - s2.length();\n                } else {\n                    return s1.compareTo(s2);\n                }\n            }\n        });\n\n        return filteredList;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        List<String> testList1 = Arrays.asList(\"aa\", \"a\", \"aaa\");\n        List<String> testList2 = Arrays.asList(\"ab\", \"a\", \"aaa\", \"cd\");\n\n        System.out.println(solution.sorted_list_sum(testList1)); // Output: [\"aa\"]\n        System.out.println(solution.sorted_list_sum(testList2)); // Output: [\"ab\", \"cd\"]\n    }\n}\n"}
{"task_id": "Java/150", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    // Helper function to check if a number is prime\n    private boolean isPrime(int n) {\n        if (n < 2) {\n            return false;\n        }\n        for (int i = 2; i <= Math.sqrt(n); i++) {\n            if (n % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    // Main function to return x if n is prime, otherwise y\n    public int x_or_y(int n, int x, int y) {\n        if (isPrime(n)) {\n            return x;\n        } else {\n            return y;\n        }\n    }\n\n    // Main method for testing\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.x_or_y(7, 34, 12)); // Output: 34\n        System.out.println(solution.x_or_y(15, 8, 5));  // Output: 5\n    }\n}\n"}
{"task_id": "Java/151", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Given a list of numbers, return the sum of squares of the numbers\n    in the list that are odd. Ignore numbers that are negative or not integers.\n\n    double_the_difference(Arrays.asList(1, 3, 2, 0)) == 1 + 9 + 0 + 0 = 10\n    double_the_difference(Arrays.asList(-1, -2, 0)) == 0\n    double_the_difference(Arrays.asList(9, -2)) == 81\n    double_the_difference(Arrays.asList(0)) == 0\n\n    If the input list is empty, return 0.\n     */\n    public int double_the_difference(List<Object> lst) {\n        int sumOfSquares = 0;\n\n        for (Object obj : lst) {\n            if (obj instanceof Integer) {\n                int num = (Integer) obj;\n                if (num > 0 && num % 2 != 0) {\n                    sumOfSquares += num * num;\n                }\n            }\n        }\n\n        return sumOfSquares;\n    }\n}\n"}
{"task_id": "Java/152", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> compare(List<Integer> game, List<Integer> guess) {\n        List<Integer> differences = new ArrayList<>();\n        \n        // Iterate through the lists and calculate the absolute difference\n        for (int i = 0; i < game.size(); i++) {\n            int diff = Math.abs(game.get(i) - guess.get(i));\n            differences.add(diff);\n        }\n        \n        return differences;\n    }\n}\n"}
{"task_id": "Java/153", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public String Strongest_Extension(String class_name, List<String> extensions) {\n        // Initialize variables to keep track of the strongest extension\n        String strongestExtension = \"\";\n        int maxStrength = Integer.MIN_VALUE;\n\n        // Iterate through each extension to calculate its strength\n        for (String extension : extensions) {\n            int cap = 0; // Number of uppercase letters\n            int sm = 0;  // Number of lowercase letters\n\n            // Calculate the number of uppercase and lowercase letters\n            for (char c : extension.toCharArray()) {\n                if (Character.isUpperCase(c)) {\n                    cap++;\n                } else if (Character.isLowerCase(c)) {\n                    sm++;\n                }\n            }\n\n            // Calculate the strength of the extension\n            int strength = cap - sm;\n\n            // Update the strongest extension if the current one is stronger\n            if (strength > maxStrength) {\n                maxStrength = strength;\n                strongestExtension = extension;\n            }\n        }\n\n        // Return the class name and the strongest extension in the required format\n        return class_name + \".\" + strongestExtension;\n    }\n}\n"}
{"task_id": "Java/154", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public boolean cycpattern_check(String a, String b) {\n        // Step 1: Concatenate the first string with itself\n        String concatenated = a + a;\n        \n        // Step 2: Check if the second string or any of its rotations is a substring of the concatenated string\n        for (int i = 0; i < b.length(); i++) {\n            String rotated = b.substring(i) + b.substring(0, i);\n            if (concatenated.contains(rotated)) {\n                return true;\n            }\n        }\n        \n        // Step 3: If no rotation is found, return false\n        return false;\n    }\n}\n"}
{"task_id": "Java/155", "generation": "import java.util.*;\n\nclass Solution {\n    public List<Integer> even_odd_count(int num) {\n        num = Math.abs(num); // Handle negative numbers\n        int even_count = 0;\n        int odd_count = 0;\n        \n        String num_str = Integer.toString(num);\n        \n        for (char c : num_str.toCharArray()) {\n            int digit = Character.getNumericValue(c);\n            if (digit % 2 == 0) {\n                even_count++;\n            } else {\n                odd_count++;\n            }\n        }\n        \n        return Arrays.asList(even_count, odd_count);\n    }\n}\n"}
{"task_id": "Java/156", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Given a positive integer, obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19) == \"xix\"\n    >>> int_to_mini_roman(152) == \"clii\"\n    >>> int_to_mini_roman(426) == \"cdxxvi\"\n     */\n    public String int_to_mini_roman(int number) {\n        // Define the Roman numeral symbols and their corresponding values\n        int[] values = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n        String[] symbols = {\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n\n        StringBuilder roman = new StringBuilder();\n\n        // Convert the number to a Roman numeral\n        for (int i = 0; i < values.length; i++) {\n            while (number >= values[i]) {\n                number -= values[i];\n                roman.append(symbols[i]);\n            }\n        }\n\n        return roman.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.int_to_mini_roman(19));  // Output: \"xix\"\n        System.out.println(solution.int_to_mini_roman(152)); // Output: \"clii\"\n        System.out.println(solution.int_to_mini_roman(426)); // Output: \"cdxxvi\"\n    }\n}\n"}
{"task_id": "Java/157", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Given the lengths of the three sides of a triangle. Return true if the three\n    sides form a right-angled triangle, false otherwise.\n    A right-angled triangle is a triangle in which one angle is right angle or\n    90 degree.\n    Example:\n    right_angle_triangle(3, 4, 5) == true\n    right_angle_triangle(1, 2, 3) == false\n     */\n    public boolean right_angle_triangle(int a, int b, int c) {\n        // Step 1: Sort the sides to ensure the largest side is considered as the hypotenuse\n        int[] sides = {a, b, c};\n        Arrays.sort(sides);\n\n        // Step 2: Check if the square of the largest side is equal to the sum of the squares of the other two sides\n        return Math.pow(sides[2], 2) == Math.pow(sides[0], 2) + Math.pow(sides[1], 2);\n    }\n}\n"}
{"task_id": "Java/158", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Write a function that accepts a list of strings.\n    The list contains different words. Return the word with the maximum number\n    of unique characters. If multiple strings have the maximum number of unique\n    characters, return the one which comes first in lexicographical order.\n\n    find_max([\"name\", \"of\", \"string\"]) == \"string\"\n    find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n    find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"aaaaaaa\"\n     */\n    public String find_max(List<String> words) {\n        // Initialize variables to keep track of the word with the maximum unique characters\n        String maxWord = \"\";\n        int maxUniqueChars = 0;\n\n        // Iterate through each word in the list\n        for (String word : words) {\n            // Use a HashSet to count the unique characters in the current word\n            Set<Character> uniqueChars = new HashSet<>();\n            for (char c : word.toCharArray()) {\n                uniqueChars.add(c);\n            }\n\n            // Check if the current word has more unique characters than the previous max\n            if (uniqueChars.size() > maxUniqueChars || (uniqueChars.size() == maxUniqueChars && word.compareTo(maxWord) < 0)) {\n                maxWord = word;\n                maxUniqueChars = uniqueChars.size();\n            }\n        }\n\n        return maxWord;\n    }\n}\n"}
{"task_id": "Java/159", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> eat(int number, int need, int remaining) {\n        // Calculate the total number of carrots eaten after the meals\n        int totalEaten = number + Math.min(need, remaining);\n        \n        // Calculate the number of carrots left after the meals\n        int carrotsLeft = remaining - Math.min(need, remaining);\n        \n        // Create a list to store the results\n        List<Integer> result = new ArrayList<>();\n        result.add(totalEaten);\n        result.add(carrotsLeft);\n        \n        return result;\n    }\n}\n"}
{"task_id": "Java/160", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int do_algebra(List<String> operator, List<Integer> operand) {\n        // Initialize the result with the first operand\n        int result = operand.get(0);\n\n        // Iterate through the operators and operands\n        for (int i = 0; i < operator.size(); i++) {\n            String op = operator.get(i);\n            int nextOperand = operand.get(i + 1);\n\n            // Apply the current operator to the result and the next operand\n            switch (op) {\n                case \"+\":\n                    result += nextOperand;\n                    break;\n                case \"-\":\n                    result -= nextOperand;\n                    break;\n                case \"*\":\n                    result *= nextOperand;\n                    break;\n                case \"/\":\n                    result /= nextOperand;\n                    break;\n                case \"**\":\n                    result = (int) Math.pow(result, nextOperand);\n                    break;\n                default:\n                    throw new IllegalArgumentException(\"Unsupported operator: \" + op);\n            }\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        List<String> operator = Arrays.asList(\"+\", \"*\", \"-\");\n        List<Integer> operand = Arrays.asList(2, 3, 4, 5);\n        int result = solution.do_algebra(operator, operand);\n        System.out.println(\"Result: \" + result); // Output: 9\n    }\n}\n"}
{"task_id": "Java/161", "generation": "import java.util.*;\n\nclass Solution {\n    public String solve(String s) {\n        // Check if the string contains any letters\n        boolean containsLetters = false;\n        for (char c : s.toCharArray()) {\n            if (Character.isLetter(c)) {\n                containsLetters = true;\n                break;\n            }\n        }\n\n        // If the string contains no letters, reverse the string\n        if (!containsLetters) {\n            return new StringBuilder(s).reverse().toString();\n        }\n\n        // Otherwise, reverse the case of each letter\n        StringBuilder result = new StringBuilder();\n        for (char c : s.toCharArray()) {\n            if (Character.isLetter(c)) {\n                if (Character.isLowerCase(c)) {\n                    result.append(Character.toUpperCase(c));\n                } else {\n                    result.append(Character.toLowerCase(c));\n                }\n            } else {\n                result.append(c);\n            }\n        }\n\n        return result.toString();\n    }\n}\n"}
{"task_id": "Java/162", "generation": "import java.math.BigInteger;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.Optional;\n\nclass Solution {\n    /**\n    Given a string \"text\", return its md5 hash equivalent string with length being 32.\n    If \"text\" is an empty string, return Optional.empty().\n    \n    >>> string_to_md5(\"Hello world\") == \"3e25960a79dbc69b674cd4ec67a72c62\"\n     */\n    public Optional<String> string_to_md5(String text) throws NoSuchAlgorithmException {\n        if (text.isEmpty()) {\n            return Optional.empty();\n        }\n\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        byte[] messageDigest = md.digest(text.getBytes());\n\n        BigInteger no = new BigInteger(1, messageDigest);\n        String hashtext = no.toString(16);\n\n        // Add leading zeros to make it 32 characters long\n        while (hashtext.length() < 32) {\n            hashtext = \"0\" + hashtext;\n        }\n\n        return Optional.of(hashtext);\n    }\n}\n"}
{"task_id": "Java/163", "generation": "import java.util.*;\n\nclass Solution {\n    public List<Integer> generate_integers(int a, int b) {\n        // Ensure a is always less than or equal to b\n        if (a > b) {\n            int temp = a;\n            a = b;\n            b = temp;\n        }\n\n        // List to store the even digits\n        List<Integer> evenDigits = new ArrayList<>();\n\n        // Iterate through the range from a to b\n        for (int i = a; i <= b; i++) {\n            // Check if the current number is a single digit and even\n            if (i >= 0 && i < 10 && i % 2 == 0) {\n                evenDigits.add(i);\n            }\n        }\n\n        // Return the list of even digits\n        return evenDigits;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.generate_integers(2, 8)); // [2, 4, 6, 8]\n        System.out.println(solution.generate_integers(8, 2)); // [2, 4, 6, 8]\n        System.out.println(solution.generate_integers(10, 14)); // []\n    }\n}\n"}
