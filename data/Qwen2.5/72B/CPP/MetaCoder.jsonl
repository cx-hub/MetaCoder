{"task_id": "CPP/41", "generation": "#include <iostream>\nusing namespace std;\n\nint car_race_collision(int n) {\n    // Each car going left to right will collide with each car going right to left\n    return n * n;\n}\n\n", "py_code": "def car_race_collision(n):\n    # Each car going left to right will collide with each car going right to left\n    return n * n\n", "py_summary": "The Python code defines a function `car_race_collision` that takes an integer `n` as input and returns the number of collisions that occur between two sets of cars. Here's the analysis:\n\n1. **Problem Understanding**:\n   - There are `n` cars driving left to right and `n` cars driving right to left.\n   - All cars move at the same speed.\n   - A collision occurs when a car moving left to right hits a car moving right to left.\n   - Despite collisions, cars continue their trajectories as if they did not collide.\n\n2. **Solution Logic**:\n   - Each car moving left to right will eventually collide with each car moving right to left.\n   - Since there are `n` cars in each direction, the total number of collisions is the product of the number of cars in each direction, which is `n * n`.\n\n3. **Code Explanation**:\n   - The function `car_race_collision` simply returns `n * n`, which represents the total number of collisions.\n\nThis approach is efficient and straightforward, as it directly computes the result without simulating the movement of the cars.\n\n"}
{"task_id": "CPP/116", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <bitset>\n\n// Helper function to count the number of ones in the binary representation of an integer\nint count_ones(int n) {\n    return std::bitset<32>(n).count();\n}\n\n// Custom comparator for sorting\nbool custom_compare(int a, int b) {\n    int count_a = count_ones(a);\n    int count_b = count_ones(b);\n    if (count_a == count_b) {\n        return a < b;\n    }\n    return count_a < count_b;\n}\n\nvector<int> sort_array(vector<int> arr) {\n    // Sort the array using the custom comparator\n    std::sort(arr.begin(), arr.end(), custom_compare);\n    return arr;\n}\n\n// Function to test the sort_array function\nvoid test_sort_array() {\n    std::vector<int> test1 = {1, 5, 2, 3, 4};\n    std::vector<int> expected1 = {1, 2, 4, 3, 5};\n    assert(sort_array(test1) == expected1);\n\n    std::vector<int> test2 = {-2, -3, -4, -5, -6};\n    std::vector<int> expected2 = {-4, -2, -6, -5, -3};\n    assert(sort_array(test2) == expected2);\n\n    std::vector<int> test3 = {1, 0, 2, 3, 4};\n    std::vector<int> expected3 = {0, 1, 2, 4, 3};\n    assert(sort_array(test3) == expected3);\n\n    std::cout << \"All tests passed!\" << std::endl;\n}\n\n", "py_code": "def count_ones(n):\n    return bin(n).count('1')\n\ndef sort_array(arr):\n    return sorted(arr, key=lambda x: (count_ones(x), x))\n", "py_summary": "The Python code defines a function `sort_array` that sorts a list of integers based on the number of ones in their binary representation. For integers with the same number of ones, it sorts them based on their decimal values.\n\nHere's a breakdown of the code:\n\n1. **Helper Function `count_ones`**:\n   - This function takes an integer `n` and returns the count of ones in its binary representation.\n   - It uses the `bin` function to convert the integer to its binary string representation and the `count` method to count the occurrences of '1' in the string.\n\n2. **Main Function `sort_array`**:\n   - This function takes a list of integers `arr` as input.\n   - It uses the `sorted` function with a custom key to sort the list.\n   - The key is a lambda function that returns a tuple `(count_ones(x), x)` for each element `x` in the list.\n   - The `sorted` function first sorts the elements based on the number of ones in their binary representation. If two elements have the same number of ones, it then sorts them based on their decimal values.\n\nThis approach ensures that the list is sorted according to the specified criteria.\n\n"}
{"task_id": "CPP/61", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    int balance = 0;\n    for (char ch : brackets) {\n        if (ch == '(') {\n            balance += 1;\n        } else if (ch == ')') {\n            balance -= 1;\n        }\n        if (balance < 0) {\n            return false;\n        }\n    }\n    return balance == 0;\n}\n\n", "py_code": "def correct_bracketing(brackets):\n    balance = 0\n    for char in brackets:\n        if char == '(':\n            balance += 1\n        elif char == ')':\n            balance -= 1\n        if balance < 0:\n            return False\n    return balance == 0\n", "py_summary": "The Python code defines a function `correct_bracketing` that checks if a string of parentheses is correctly balanced. Here's a step-by-step analysis of the code:\n\n1. **Initialization**: The function initializes a variable `balance` to 0. This variable will keep track of the balance between opening and closing parentheses.\n2. **Iteration**: The function iterates through each character in the input string `brackets`.\n   - If the character is an opening parenthesis `(`, the `balance` is incremented by 1.\n   - If the character is a closing parenthesis `)`, the `balance` is decremented by 1.\n3. **Early Termination**: If at any point the `balance` becomes negative, it means there are more closing parentheses than opening ones up to that point, and the function returns `False` immediately.\n4. **Final Check**: After iterating through the entire string, the function checks if the `balance` is zero. If it is, it means every opening parenthesis has a corresponding closing parenthesis, and the function returns `True`. Otherwise, it returns `False`.\n\nThis approach ensures that the string is checked efficiently and correctly for balanced parentheses.\n\n"}
{"task_id": "CPP/25", "generation": "#include <iostream>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\nvector<int> factorize(int n) {\n    vector<int> factors;\n    \n    // Check for number of 2s in n\n    while (n % 2 == 0) {\n        factors.push_back(2);\n        n /= 2;\n    }\n    \n    // n must be odd at this point, so we can skip even numbers\n    for (int i = 3; i <= sqrt(n); i += 2) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n    \n    // This condition is to check if n is a prime number greater than 2\n    if (n > 2) {\n        factors.push_back(n);\n    }\n    \n    return factors;\n}\n\n// Function to test the factorize function\nvoid test_factorize() {\n    vector<int> result;\n    \n    result = factorize(8);\n    cout << \"factorize(8): \";\n    for (int factor : result) {\n        cout << factor << \" \";\n    }\n    cout << endl;\n    \n    result = factorize(25);\n    cout << \"factorize(25): \";\n    for (int factor : result) {\n        cout << factor << \" \";\n    }\n    cout << endl;\n    \n    result = factorize(70);\n    cout << \"factorize(70): \";\n    for (int factor : result) {\n        cout << factor << \" \";\n    }\n    cout << endl;\n}\n\n", "py_code": "def factorize(n):\n    factors = []\n    # Check for number of 2s in n\n    while n % 2 == 0:\n        factors.append(2)\n        n = n // 2\n    # n must be odd at this point, so we can skip even numbers\n    for i in range(3, int(n**0.5) + 1, 2):\n        while n % i == 0:\n            factors.append(i)\n            n = n // i\n    # This condition is to check if n is a prime number greater than 2\n    if n > 2:\n        factors.append(n)\n    return factors\n", "py_summary": "The Python code defines a function `factorize` that takes an integer `n` and returns a list of its prime factors in ascending order. The function works as follows:\n\n1. **Initialize the Factors List**: An empty list `factors` is created to store the prime factors.\n\n2. **Check for Factors of 2**: The function first checks how many times 2 divides `n`. If `n` is divisible by 2, it appends 2 to the `factors` list and divides `n` by 2. This process continues until `n` is no longer divisible by 2.\n\n3. **Check for Odd Factors**: After removing all factors of 2, `n` must be odd. The function then iterates over odd numbers starting from 3 up to the square root of `n` (inclusive). For each odd number `i`, it checks if `i` divides `n`. If `i` is a factor, it appends `i` to the `factors` list and divides `n` by `i`. This process continues until `n` is no longer divisible by `i`.\n\n4. **Check for Remaining Prime Factor**: If `n` is still greater than 2 after the above steps, it means `n` itself is a prime number. In this case, `n` is appended to the `factors` list.\n\n5. **Return the Factors**: Finally, the function returns the list of prime factors.\n\nThis approach ensures that all prime factors are listed in ascending order and each factor appears the number of times it divides `n`.\n\n### Example Walkthrough:\n- For `n = 8`:\n  - 8 is divisible by 2 three times, so the factors are `[2, 2, 2]`.\n- For `n = 25`:\n  - 25 is not divisible by 2, so it moves to checking odd factors.\n  - 25 is divisible by 5 two times, so the factors are `[5, 5]`.\n- For `n = 70`:\n  - 70 is divisible by 2 once, so the factors are `[2]`.\n  - 35 is not divisible by 3, so it moves to the next odd number.\n  - 35 is divisible by 5 once, so the factors are `[2, 5]`.\n  - 7 is a prime number, so it is appended to the factors list, resulting in `[2, 5, 7]`.\n\nThis method efficiently finds all prime factors of a given integer."}
{"task_id": "CPP/137", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <boost/any.hpp>\n#include <sstream>\n\nusing namespace std;\n\n// Function to convert a string to a float, handling both '.' and ',' as decimal separators\nfloat string_to_float(const string& str) {\n    string modified_str = str;\n    replace(modified_str.begin(), modified_str.end(), ',', '.');\n    return stof(modified_str);\n}\n\nboost::any compare_one(boost::any a, boost::any b) {\n    float val_a, val_b;\n\n    // Convert a to float if it is a string\n    if (a.type() == typeid(string)) {\n        val_a = string_to_float(boost::any_cast<string>(a));\n    } else if (a.type() == typeid(int)) {\n        val_a = static_cast<float>(boost::any_cast<int>(a));\n    } else if (a.type() == typeid(float)) {\n        val_a = boost::any_cast<float>(a);\n    } else {\n        throw runtime_error(\"Unsupported type for a\");\n    }\n\n    // Convert b to float if it is a string\n    if (b.type() == typeid(string)) {\n        val_b = string_to_float(boost::any_cast<string>(b));\n    } else if (b.type() == typeid(int)) {\n        val_b = static_cast<float>(boost::any_cast<int>(b));\n    } else if (b.type() == typeid(float)) {\n        val_b = boost::any_cast<float>(b);\n    } else {\n        throw runtime_error(\"Unsupported type for b\");\n    }\n\n    // Compare the values\n    if (val_a == val_b) {\n        return \"None\";\n    } else if (val_a > val_b) {\n        return a;\n    } else {\n        return b;\n    }\n}\n\n", "py_code": "def compare_one(a, b):\n    # Convert string representations of numbers to float\n    if isinstance(a, str):\n        a = float(a.replace(',', '.'))\n    if isinstance(b, str):\n        b = float(b.replace(',', '.'))\n\n    # Compare the values\n    if a == b:\n        return \"None\"\n    elif a > b:\n        return a\n    else:\n        return b\n", "py_summary": "The Python code defines a function `compare_one` that takes two arguments, `a` and `b`, which can be integers, floats, or strings representing real numbers. The function performs the following steps:\n\n1. **Convert String Representations to Floats**: If either `a` or `b` is a string, it replaces any commas with dots and converts the string to a float. This ensures that the function can handle both dot and comma-separated decimal representations.\n\n2. **Compare the Values**: After converting the inputs to a common type (float), the function compares the values:\n   - If `a` and `b` are equal, it returns the string \"None\".\n   - If `a` is greater than `b`, it returns `a`.\n   - Otherwise, it returns `b`.\n\nThis approach ensures that the function can handle different types of inputs and return the larger value in its original type, or \"None\" if the values are equal.\n\n### Summary:\n- **Type Conversion**: Strings are converted to floats to handle different decimal separators.\n- **Comparison**: The function compares the numerical values and returns the larger one or \"None\" if they are equal.\n- **Return Type**: The function returns the larger value in its original type or \"None\" as a string.\n\nNow, let's move on to the C++ solution."}
{"task_id": "CPP/102", "generation": "#include <iostream>\nusing namespace std;\n\nint choose_num(int x, int y) {\n    // Ensure x is less than or equal to y\n    if (x > y) {\n        return -1;\n    }\n\n    // Start from the upper bound and move downwards\n    for (int num = y; num >= x; --num) {\n        if (num % 2 == 0) {\n            return num;\n        }\n    }\n\n    // If no even number is found, return -1\n    return -1;\n}\n\n// Function to test the choose_num function\nvoid test_choose_num() {\n    cout << \"choose_num(12, 15) = \" << choose_num(12, 15) << \" (Expected: 14)\" << endl;\n    cout << \"choose_num(13, 12) = \" << choose_num(13, 12) << \" (Expected: -1)\" << endl;\n    cout << \"choose_num(8, 10) = \" << choose_num(8, 10) << \" (Expected: 10)\" << endl;\n    cout << \"choose_num(1, 1) = \" << choose_num(1, 1) << \" (Expected: -1)\" << endl;\n    cout << \"choose_num(2, 2) = \" << choose_num(2, 2) << \" (Expected: 2)\" << endl;\n}\n\n", "py_code": "def choose_num(x, y):\n    # Ensure x is less than or equal to y\n    if x > y:\n        return -1\n    \n    # Start from the upper bound and move downwards\n    for num in range(y, x - 1, -1):\n        if num % 2 == 0:\n            return num\n    \n    # If no even number is found, return -1\n    return -1\n", "py_summary": "The Python code defines a function `choose_num` that takes two positive integers `x` and `y` as input and returns the largest even integer within the range `[x, y]` inclusive. If no such number exists, it returns `-1`.\n\nHere's a step-by-step analysis of the code:\n\n1. **Input Validation**:\n   - The function first checks if `x` is greater than `y`. If it is, it means the range is invalid, and the function returns `-1`.\n\n2. **Range Iteration**:\n   - The function uses a `for` loop to iterate from `y` down to `x` (inclusive). This ensures that the largest possible even number is found first.\n   - For each number in this range, it checks if the number is even using the modulus operator (`num % 2 == 0`).\n\n3. **Return the Result**:\n   - If an even number is found, it is immediately returned.\n   - If the loop completes without finding an even number, the function returns `-1`.\n\nThis approach ensures that the function efficiently finds the largest even number in the given range or returns `-1` if no such number exists.\n\n"}
{"task_id": "CPP/10", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nbool is_palindrome(const string& str) {\n    // Test if given string is a palindrome\n    string s(str.rbegin(), str.rend());\n    return s == str;\n}\n\nstring make_palindrome(const string& str) {\n    // Find the shortest palindrome that begins with a supplied string\n    if (str.empty()) {\n        return \"\";\n    }\n\n    // Find the longest palindromic suffix\n    int n = str.length();\n    int i;\n    for (i = 0; i < n; ++i) {\n        if (is_palindrome(str.substr(i))) {\n            break;\n        }\n    }\n\n    // The prefix that needs to be reversed and appended\n    string prefix_to_reverse = str.substr(0, i);\n\n    // Append the reversed prefix to the original string\n    reverse(prefix_to_reverse.begin(), prefix_to_reverse.end());\n    return str + prefix_to_reverse;\n}\n", "py_code": "def is_palindrome(s: str) -> bool:\n    return s == s[::-1]\n\ndef make_palindrome(s: str) -> str:\n    if not s:\n        return \"\"\n    \n    # Find the longest palindromic suffix\n    for i in range(len(s)):\n        if is_palindrome(s[i:]):\n            break\n    \n    # The prefix that needs to be reversed and appended\n    prefix_to_reverse = s[:i]\n    \n    # Append the reversed prefix to the original string\n    return s + prefix_to_reverse[::-1]\n", "py_summary": "### Analysis of the Python Code\n\nThe Python code defines two functions: `is_palindrome` and `make_palindrome`.\n\n1. **`is_palindrome(s: str) -> bool`**:\n   - This function checks if a given string `s` is a palindrome.\n   - It does this by comparing the string `s` with its reverse (`s[::-1]`).\n   - If the string and its reverse are the same, it returns `True`; otherwise, it returns `False`.\n\n2. **`make_palindrome(s: str) -> str`**:\n   - This function finds the shortest palindrome that begins with the supplied string `s`.\n   - The algorithm works as follows:\n     - If the input string `s` is empty, it returns an empty string.\n     - It iterates through the string to find the longest palindromic suffix.\n     - Once the longest palindromic suffix is found, it identifies the prefix that comes before this suffix.\n     - It then appends the reverse of this prefix to the original string to form the shortest palindrome.\n\n### Detailed Steps:\n1. **Check for Empty String**:\n   - If the input string `s` is empty, the function returns an empty string immediately.\n\n2. **Find Longest Palindromic Suffix**:\n   - The function iterates through the string from the beginning to the end.\n   - For each position `i`, it checks if the substring `s[i:]` is a palindrome using the `is_palindrome` function.\n   - If a palindromic suffix is found, the loop breaks, and `i` is the starting index of the palindromic suffix.\n\n3. **Identify Prefix to Reverse**:\n   - The prefix that needs to be reversed and appended is the substring `s[:i]`.\n\n4. **Form the Shortest Palindrome**:\n   - The function appends the reverse of the identified prefix to the original string `s` to form the shortest palindrome.\n\nThis approach ensures that the resulting string is the shortest possible palindrome that starts with the given string `s`."}
{"task_id": "CPP/76", "generation": "#include <iostream>\n#include <cmath>\nusing namespace std;\n\nbool is_simple_power(int x, int n) {\n    if (n == 1) {\n        return x == 1;\n    }\n    if (x == 1) {\n        return true;\n    }\n    if (n <= 0 || x <= 0) {\n        return false;\n    }\n    int power = 0;\n    while (pow(n, power) <= x) {\n        if (pow(n, power) == x) {\n            return true;\n        }\n        power += 1;\n    }\n    return false;\n}\n\n", "py_code": "def is_simple_power(x, n):\n    if n == 1:\n        return x == 1\n    if x == 1:\n        return True\n    if n <= 0 or x <= 0:\n        return False\n    power = 0\n    while n ** power <= x:\n        if n ** power == x:\n            return True\n        power += 1\n    return False\n", "py_summary": "The Python code defines a function `is_simple_power(x, n)` that checks if a number `x` is a simple power of `n`. Here's a detailed breakdown of how the function works:\n\n1. **Edge Cases Handling**:\n   - If `n` is 1, the only way `x` can be a simple power of `n` is if `x` is also 1. This is because any power of 1 is always 1.\n   - If `x` is 1, it is a simple power of any `n` (since \\( n^0 = 1 \\)).\n   - If either `n` or `x` is less than or equal to 0, the function returns `False` because non-positive numbers cannot be simple powers of positive integers.\n\n2. **Main Logic**:\n   - Initialize a variable `power` to 0.\n   - Use a while loop to check if \\( n^{\\text{power}} \\) is less than or equal to `x`.\n   - Inside the loop, if \\( n^{\\text{power}} \\) equals `x`, return `True` because `x` is a simple power of `n`.\n   - Increment `power` by 1 in each iteration.\n   - If the loop completes without finding a match, return `False`.\n\nThis approach ensures that the function efficiently checks all possible powers of `n` up to the point where \\( n^{\\text{power}} \\) exceeds `x`.\n\n"}
{"task_id": "CPP/94", "generation": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <string>\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int n) {\n    if (n <= 1) {\n        return false;\n    }\n    for (int i = 2; i <= sqrt(n); ++i) {\n        if (n % i == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\n// Function to calculate the sum of digits of a number\nint sum_of_digits(int n) {\n    int sum = 0;\n    while (n > 0) {\n        sum += n % 10;\n        n /= 10;\n    }\n    return sum;\n}\n\n// Main function to find the largest prime and return the sum of its digits\nint skjkasdkd(vector<int> lst) {\n    int largest_prime = -1;\n    for (int num : lst) {\n        if (is_prime(num) && num > largest_prime) {\n            largest_prime = num;\n        }\n    }\n    return largest_prime != -1 ? sum_of_digits(largest_prime) : 0;\n}\n\n// Function to test the solution with provided examples\nvoid test() {\n    assert(skjkasdkd({0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3}) == 10);\n    assert(skjkasdkd({1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1}) == 25);\n    assert(skjkasdkd({1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3}) == 13);\n    assert(skjkasdkd({0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6}) == 11);\n    assert(skjkasdkd({0, 81, 12, 3, 1, 21}) == 3);\n    assert(skjkasdkd({0, 8, 1, 2, 1, 7}) == 7);\n    cout << \"All tests passed!\" << endl;\n}\n\n", "py_code": "def is_prime(n):\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef sum_of_digits(n):\n    return sum(int(digit) for digit in str(n))\n\ndef skjkasdkd(lst):\n    largest_prime = -1\n    for num in lst:\n        if is_prime(num) and num > largest_prime:\n            largest_prime = num\n    return sum_of_digits(largest_prime) if largest_prime != -1 else 0\n", "py_summary": "The Python code defines a function `skjkasdkd` that takes a list of integers as input and returns the sum of the digits of the largest prime number in the list. Here's a step-by-step analysis of the code:\n\n1. **Prime Check Function (`is_prime`)**:\n   - This function checks if a given number `n` is a prime number.\n   - It returns `False` if `n` is less than or equal to 1.\n   - It iterates from 2 to the square root of `n` (inclusive) and checks if `n` is divisible by any number in this range. If it is, the function returns `False`.\n   - If no divisors are found, the function returns `True`.\n\n2. **Sum of Digits Function (`sum_of_digits`)**:\n   - This function calculates the sum of the digits of a given number `n`.\n   - It converts the number to a string and iterates over each character, converting it back to an integer and summing these integers.\n\n3. **Main Function (`skjkasdkd`)**:\n   - This function initializes a variable `largest_prime` to -1, which will store the largest prime number found in the list.\n   - It iterates through each number in the input list `lst`.\n   - For each number, it checks if the number is a prime using the `is_prime` function and if it is greater than the current `largest_prime`. If both conditions are met, it updates `largest_prime`.\n   - After iterating through the list, it calls the `sum_of_digits` function on `largest_prime` and returns the result. If no prime number is found, it returns 0.\n\nThis approach ensures that the function correctly identifies the largest prime number in the list and computes the sum of its digits.\n\n"}
{"task_id": "CPP/32", "generation": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <Eigen/Dense>\n\nusing namespace std;\nusing namespace Eigen;\n\ndouble poly(const vector<double>& xs, double x) {\n    double sum = 0;\n    for (size_t i = 0; i < xs.size(); ++i) {\n        sum += xs[i] * pow(x, i);\n    }\n    return sum;\n}\n\ndouble find_zero(const vector<double>& xs) {\n    // Ensure the list has an even number of coefficients\n    if (xs.size() % 2 != 0) {\n        throw invalid_argument(\"The list of coefficients must have an even number of elements.\");\n    }\n\n    // Convert the vector to an Eigen Polynomial\n    VectorXd coefficients(xs.size());\n    for (size_t i = 0; i < xs.size(); ++i) {\n        coefficients(i) = xs[i];\n    }\n\n    // Create a polynomial object\n    Polynomial<double> poly(coefficients);\n\n    // Find the roots of the polynomial\n    Eigen::VectorXd roots = poly.roots();\n\n    // Filter real roots\n    vector<double> real_roots;\n    for (int i = 0; i < roots.size(); ++i) {\n        if (std::imag(roots(i)) == 0) {\n            real_roots.push_back(std::real(roots(i)));\n        }\n    }\n\n    // Return the first real root\n    if (!real_roots.empty()) {\n        return real_roots[0];\n    } else {\n        throw runtime_error(\"No real roots found.\");\n    }\n}\n\n", "py_code": "import numpy as np\n\ndef poly(xs, x):\n    return sum(coef * (x ** i) for i, coef in enumerate(xs))\n\ndef find_zero(xs):\n    # Ensure the list has an even number of coefficients\n    if len(xs) % 2 != 0:\n        raise ValueError(\"The list of coefficients must have an even number of elements.\")\n    \n    # Find the roots of the polynomial\n    roots = np.roots(xs)\n    \n    # Filter real roots\n    real_roots = [root.real for root in roots if np.isreal(root)]\n    \n    # Return the first real root\n    if real_roots:\n        return real_roots[0]\n    else:\n        raise ValueError(\"No real roots found.\")\n\n", "py_summary": "### Analysis of the Python Code\n\nThe Python code consists of two functions: `poly` and `find_zero`.\n\n1. **`poly(xs, x)` Function:**\n   - This function evaluates a polynomial at a given point `x`.\n   - The polynomial is defined by its coefficients stored in the list `xs`.\n   - The function uses a generator expression inside the `sum` function to compute the polynomial value.\n   - For each coefficient `coef` at index `i`, it calculates `coef * (x ** i)` and sums these values to get the final polynomial value.\n\n2. **`find_zero(xs)` Function:**\n   - This function finds a root (zero) of the polynomial defined by the coefficients in `xs`.\n   - It first checks if the list of coefficients has an even number of elements. If not, it raises a `ValueError`.\n   - It uses the `np.roots` function from the NumPy library to find all roots of the polynomial.\n   - It filters out the real roots from the complex roots using a list comprehension and the `np.isreal` function.\n   - If there are any real roots, it returns the first one. If no real roots are found, it raises a `ValueError`.\n\n### Summary\n- The `poly` function evaluates the polynomial at a given point using a straightforward summation of terms.\n- The `find_zero` function leverages NumPy's `roots` function to find the roots of the polynomial and returns the first real root.\n- The code ensures that the list of coefficients has an even number of elements, which is a requirement specified in the problem statement.\n\nThis approach is efficient and leverages the power of NumPy for polynomial root finding. The next step is to translate this logic into C++.\n\n"}
{"task_id": "CPP/33", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> sort_third(vector<int> l) {\n    // Extract elements at indices divisible by 3\n    vector<int> divisible_by_three;\n    for (size_t i = 0; i < l.size(); ++i) {\n        if (i % 3 == 0) {\n            divisible_by_three.push_back(l[i]);\n        }\n    }\n\n    // Sort the extracted elements\n    sort(divisible_by_three.begin(), divisible_by_three.end());\n\n    // Replace the elements in the original list with the sorted elements\n    size_t j = 0;\n    for (size_t i = 0; i < l.size(); ++i) {\n        if (i % 3 == 0) {\n            l[i] = divisible_by_three[j];\n            ++j;\n        }\n    }\n\n    return l;\n}\n\n// Function to test the sort_third function\nvoid test_sort_third() {\n    vector<int> test1 = {1, 2, 3};\n    vector<int> expected1 = {1, 2, 3};\n    assert(sort_third(test1) == expected1);\n\n    vector<int> test2 = {5, 6, 3, 4, 8, 9, 2};\n    vector<int> expected2 = {2, 6, 3, 4, 8, 9, 5};\n    assert(sort_third(test2) == expected2);\n\n    cout << \"All tests passed!\" << endl;\n}\n\n", "py_code": "def sort_third(l):\n    # Extract elements at indices divisible by 3\n    divisible_by_three = [l[i] for i in range(len(l)) if i % 3 == 0]\n    \n    # Sort the extracted elements\n    divisible_by_three.sort()\n    \n    # Replace the elements in the original list with the sorted elements\n    j = 0\n    for i in range(len(l)):\n        if i % 3 == 0:\n            l[i] = divisible_by_three[j]\n            j += 1\n    \n    return l\n", "py_summary": "The Python code defines a function `sort_third` that takes a list `l` as input and returns a new list `l'` with the following properties:\n- For indices that are not divisible by 3, the elements remain unchanged.\n- For indices that are divisible by 3, the elements are replaced with the sorted version of the elements at those indices.\n\nHere's a step-by-step breakdown of the code:\n\n1. **Extract Elements at Indices Divisible by 3**:\n   - The list comprehension `[l[i] for i in range(len(l)) if i % 3 == 0]` creates a new list `divisible_by_three` containing elements from `l` at indices that are divisible by 3.\n\n2. **Sort the Extracted Elements**:\n   - The `divisible_by_three.sort()` method sorts the extracted elements in ascending order.\n\n3. **Replace Elements in the Original List**:\n   - A variable `j` is initialized to 0 to keep track of the index in the sorted `divisible_by_three` list.\n   - A for loop iterates through the original list `l`. For each index `i` that is divisible by 3, the element at `l[i]` is replaced with the corresponding element from the sorted `divisible_by_three` list, and `j` is incremented.\n\n4. **Return the Modified List**:\n   - The modified list `l` is returned.\n\nThis approach ensures that the elements at indices divisible by 3 are sorted while the rest of the elements remain unchanged."}
{"task_id": "CPP/88", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> sort_array(vector<int> array) {\n    // Check for empty vector\n    if (array.empty()) {\n        return {};\n    }\n\n    // Calculate the sum of the first and last elements\n    int sum_first_last = array.front() + array.back();\n\n    // Create a copy of the array to avoid modifying the original\n    vector<int> sorted_array = array;\n\n    // Determine the sorting order based on the sum\n    if (sum_first_last % 2 == 0) {\n        // Sort in descending order\n        sort(sorted_array.begin(), sorted_array.end(), greater<int>());\n    } else {\n        // Sort in ascending order\n        sort(sorted_array.begin(), sorted_array.end());\n    }\n\n    return sorted_array;\n}\n\n// Function to test the sort_array function\nvoid test_sort_array() {\n    vector<int> test1 = {};\n    vector<int> test2 = {5};\n    vector<int> test3 = {2, 4, 3, 0, 1, 5};\n    vector<int> test4 = {2, 4, 3, 0, 1, 5, 6};\n\n    vector<int> result1 = sort_array(test1);\n    vector<int> result2 = sort_array(test2);\n    vector<int> result3 = sort_array(test3);\n    vector<int> result4 = sort_array(test4);\n\n    // Print results\n    cout << \"Test 1: \";\n    for (int num : result1) {\n        cout << num << \" \";\n    }\n    cout << endl;\n\n    cout << \"Test 2: \";\n    for (int num : result2) {\n        cout << num << \" \";\n    }\n    cout << endl;\n\n    cout << \"Test 3: \";\n    for (int num : result3) {\n        cout << num << \" \";\n    }\n    cout << endl;\n\n    cout << \"Test 4: \";\n    for (int num : result4) {\n        cout << num << \" \";\n    }\n    cout << endl;\n}\n\n", "py_code": "def sort_array(array):\n    if not array:\n        return []\n    \n    # Calculate the sum of the first and last elements\n    sum_first_last = array[0] + array[-1]\n    \n    # Determine the sorting order based on the sum\n    if sum_first_last % 2 == 0:\n        # Sort in descending order\n        sorted_array = sorted(array, reverse=True)\n    else:\n        # Sort in ascending order\n        sorted_array = sorted(array)\n    \n    return sorted_array\n", "py_summary": "The Python code defines a function `sort_array` that takes a list of non-negative integers as input and returns a new list that is sorted based on the sum of the first and last elements of the input list.\n\n1. **Check for Empty List**:\n   - If the input list `array` is empty, the function returns an empty list immediately.\n\n2. **Calculate the Sum of the First and Last Elements**:\n   - The function calculates the sum of the first element (`array[0]`) and the last element (`array[-1]`).\n\n3. **Determine the Sorting Order**:\n   - If the sum is even (`sum_first_last % 2 == 0`), the function sorts the list in descending order using `sorted(array, reverse=True)`.\n   - If the sum is odd, the function sorts the list in ascending order using `sorted(array)`.\n\n4. **Return the Sorted List**:\n   - The function returns the sorted list.\n\nThis approach ensures that the original list remains unchanged, and a new sorted list is returned based on the specified conditions."}
{"task_id": "CPP/15", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\nusing namespace std;\n\nstring string_sequence(int n) {\n    stringstream ss;\n    for (int i = 0; i <= n; ++i) {\n        ss << i;\n        if (i < n) {\n            ss << \" \";\n        }\n    }\n    return ss.str();\n}\n\n", "py_code": "def string_sequence(n):\n    return ' '.join(str(i) for i in range(n + 1))\n", "py_summary": "The Python code defines a function `string_sequence` that takes an integer `n` as input and returns a string containing space-delimited numbers starting from 0 up to `n` inclusive. Here's a breakdown of how the function works:\n\n1. **Range Generation**: The `range(n + 1)` function generates a sequence of numbers from 0 to `n` inclusive.\n2. **String Conversion**: The `str(i)` function converts each number in the sequence to a string.\n3. **Joining Strings**: The `' '.join(...)` function joins all the string representations of the numbers with a single space as the delimiter.\n4. **Return Statement**: The function returns the resulting string.\n\nThis approach ensures that the output is a single string with numbers separated by spaces, as required.\n\n"}
{"task_id": "CPP/163", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> generate_integers(int a, int b) {\n    // Ensure a is less than or equal to b\n    if (a > b) {\n        swap(a, b);\n    }\n\n    // Define the even digits\n    vector<int> even_digits = {2, 4, 6, 8};\n\n    // Filter the even digits that fall within the range [a, b]\n    vector<int> result;\n    for (int digit : even_digits) {\n        if (a <= digit && digit <= b) {\n            result.push_back(digit);\n        }\n    }\n\n    return result;\n}\n\n// Function to print the vector for testing\nvoid print_vector(const vector<int>& vec) {\n    cout << \"{\";\n    for (size_t i = 0; i < vec.size(); ++i) {\n        cout << vec[i];\n        if (i < vec.size() - 1) {\n            cout << \", \";\n        }\n    }\n    cout << \"}\" << endl;\n}\n\n", "py_code": "def generate_integers(a, b):\n    # Ensure a is less than or equal to b\n    if a > b:\n        a, b = b, a\n    \n    # Define the even digits\n    even_digits = [2, 4, 6, 8]\n    \n    # Filter the even digits that fall within the range [a, b]\n    result = [digit for digit in even_digits if a <= digit <= b]\n    \n    return result\n", "py_summary": "The Python code defines a function `generate_integers(a, b)` that returns a list of even digits between two given integers `a` and `b`, inclusive. The function follows these steps:\n\n1. **Ensure Order**: The function first ensures that `a` is less than or equal to `b` by swapping them if necessary. This step simplifies the logic for filtering the even digits.\n\n2. **Define Even Digits**: The function defines a list of even digits `[2, 4, 6, 8]`.\n\n3. **Filter Even Digits**: The function uses a list comprehension to filter the even digits that fall within the range `[a, b]`. It checks each even digit to see if it is greater than or equal to `a` and less than or equal to `b`.\n\n4. **Return Result**: The function returns the filtered list of even digits.\n\nThis approach ensures that the function correctly handles both cases where `a` is less than or equal to `b` and where `a` is greater than `b`. The list comprehension provides a concise and efficient way to filter the even digits.\n\n### Summary:\n- **Ordering**: Ensures `a` is less than or equal to `b`.\n- **Even Digits**: Defines a fixed list of even digits.\n- **Filtering**: Uses a list comprehension to filter even digits within the range.\n- **Result**: Returns the filtered list of even digits."}
{"task_id": "CPP/1", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> separate_paren_groups(string paren_string) {\n    // Remove spaces from the input string\n    paren_string.erase(remove(paren_string.begin(), paren_string.end(), ' '), paren_string.end());\n\n    vector<string> groups;\n    vector<char> stack;\n    string current_group;\n\n    for (char ch : paren_string) {\n        if (ch == '(') {\n            stack.push_back(ch);\n            current_group += ch;\n        } else if (ch == ')') {\n            stack.pop_back();\n            current_group += ch;\n            if (stack.empty()) {\n                groups.push_back(current_group);\n                current_group.clear();\n            }\n        }\n    }\n\n    return groups;\n}\n\n// Function to test the solution\nvoid test_separate_paren_groups() {\n    string input = \"( ) (( )) (( )( ))\";\n    vector<string> expected = {\"()\", \"(())\", \"(()())\"};\n    vector<string> result = separate_paren_groups(input);\n\n    if (result == expected) {\n        cout << \"Test passed!\" << endl;\n    } else {\n        cout << \"Test failed!\" << endl;\n    }\n}\n\n", "py_code": "def separate_paren_groups(paren_string):\n    paren_string = paren_string.replace(\" \", \"\")  # Remove spaces\n    groups = []\n    stack = []\n    current_group = \"\"\n    \n    for char in paren_string:\n        if char == '(':\n            stack.append(char)\n            current_group += char\n        elif char == ')':\n            stack.pop()\n            current_group += char\n            if not stack:\n                groups.append(current_group)\n                current_group = \"\"\n    \n    return groups\n", "py_summary": "The Python code defines a function `separate_paren_groups` that takes a string containing multiple groups of nested parentheses and separates those groups into separate strings. Here's a step-by-step analysis of how the function works:\n\n1. **Remove Spaces**: The function first removes any spaces from the input string using the `replace` method. This ensures that only the parentheses are processed.\n\n2. **Initialize Variables**: \n   - `groups`: A list to store the separated groups of parentheses.\n   - `stack`: A list used to keep track of the opening parentheses.\n   - `current_group`: A string to build the current group of parentheses.\n\n3. **Iterate Through Characters**: The function iterates through each character in the cleaned input string:\n   - If the character is an opening parenthesis `(`, it is added to the `stack` and appended to `current_group`.\n   - If the character is a closing parenthesis `)`, it is removed from the `stack` and appended to `current_group`. If the `stack` becomes empty after removing the opening parenthesis, it means the current group of parentheses is complete, and it is added to the `groups` list. The `current_group` is then reset to an empty string to start building the next group.\n\n4. **Return Result**: After processing all characters, the function returns the `groups` list, which contains the separated groups of parentheses.\n\nThis approach ensures that each group of parentheses is correctly identified and separated, even if they are nested within each other.\n\n"}
{"task_id": "CPP/69", "generation": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint search(vector<int> lst) {\n    // Create a frequency map to count the occurrences of each integer\n    unordered_map<int, int> freq;\n    for (int num : lst) {\n        freq[num]++;\n    }\n\n    // Initialize the maximum value to -1\n    int max_val = -1;\n\n    // Iterate through the frequency map to find the greatest integer that meets the criteria\n    for (const auto& entry : freq) {\n        int num = entry.first;\n        int count = entry.second;\n        if (num <= count && num > max_val) {\n            max_val = num;\n        }\n    }\n\n    // Return the result\n    return max_val;\n}\n\n// Function to test the search function\nvoid test_search() {\n    cout << \"Test Case 1: \" << (search({4, 1, 2, 2, 3, 1}) == 2 ? \"Passed\" : \"Failed\") << endl;\n    cout << \"Test Case 2: \" << (search({1, 2, 2, 3, 3, 3, 4, 4, 4}) == 3 ? \"Passed\" : \"Failed\") << endl;\n    cout << \"Test Case 3: \" << (search({5, 5, 4, 4, 4}) == -1 ? \"Passed\" : \"Failed\") << endl;\n}\n\n", "py_code": "from collections import Counter\n\ndef search(lst):\n    freq = Counter(lst)\n    max_val = -1\n    for num, count in freq.items():\n        if num <= count and num > max_val:\n            max_val = num\n    return max_val\n", "py_summary": "The Python code defines a function `search` that takes a list of positive integers as input and returns the greatest integer that has a frequency greater than or equal to its value. Here's a step-by-step analysis of the code:\n\n1. **Importing Counter**: The `Counter` class from the `collections` module is imported. This class is used to count the frequency of each element in the list.\n\n2. **Counting Frequencies**: The `Counter` object `freq` is created by passing the list `lst` to it. This object will store the frequency of each integer in the list.\n\n3. **Initialization**: A variable `max_val` is initialized to -1. This variable will keep track of the maximum integer that meets the criteria (frequency >= value).\n\n4. **Iterating Through Frequencies**: The code iterates through the items in the `freq` dictionary using a for loop. For each key-value pair `(num, count)`:\n   - It checks if the integer `num` is less than or equal to its frequency `count`.\n   - If the condition is met and `num` is greater than the current `max_val`, `max_val` is updated to `num`.\n\n5. **Returning the Result**: After the loop, the function returns `max_val`. If no integer meets the criteria, `max_val` will remain -1.\n\nThis approach ensures that the function efficiently finds the greatest integer that satisfies the given condition by leveraging the `Counter` class for frequency counting and a simple iteration to check the conditions."}
{"task_id": "CPP/31", "generation": "#include <iostream>\nusing namespace std;\n\nbool is_prime(long long n) {\n    if (n <= 1) {\n        return false;\n    }\n    if (n <= 3) {\n        return true;\n    }\n    if (n % 2 == 0 || n % 3 == 0) {\n        return false;\n    }\n    for (long long i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\n", "py_code": "def is_prime(n):\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n", "py_summary": "The Python code defines a function `is_prime` that determines whether a given number `n` is a prime number. Here's a step-by-step analysis of the code:\n\n1. **Initial Checks**:\n   - If `n` is less than or equal to 1, it is not a prime number, so the function returns `False`.\n   - If `n` is 2 or 3, it is a prime number, so the function returns `True`.\n\n2. **Simple Divisibility Checks**:\n   - If `n` is divisible by 2 or 3, it is not a prime number, so the function returns `False`.\n\n3. **Efficient Prime Checking**:\n   - The function uses a loop to check divisibility starting from 5 and incrementing by 6 each time (i.e., checking `i` and `i + 2`).\n   - This is because any prime number greater than 3 can be written in the form of 6k \u00b1 1, where k is an integer.\n   - The loop continues as long as `i * i` is less than or equal to `n`. This is an optimization to reduce the number of checks needed.\n\n4. **Return True**:\n   - If no divisors are found, the function returns `True`, indicating that `n` is a prime number.\n\nThis approach ensures that the function efficiently checks for primality, especially for large numbers.\n\n"}
{"task_id": "CPP/147", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint get_max_triples(int n) {\n    // Generate the sequence a\n    vector<int> a(n);\n    for (int i = 1; i <= n; ++i) {\n        a[i - 1] = i * i - i + 1;\n    }\n\n    // Initialize the count of valid triples\n    int count = 0;\n\n    // Iterate over all possible triples (i, j, k) where i < j < k\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            for (int k = j + 1; k < n; ++k) {\n                // Check if the sum of the triple is a multiple of 3\n                if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                    count += 1;\n                }\n            }\n        }\n    }\n\n    return count;\n}\n\n", "py_code": "def get_max_triples(n):\n    # Generate the sequence a\n    a = [i * i - i + 1 for i in range(1, n + 1)]\n    \n    # Initialize the count of valid triples\n    count = 0\n    \n    # Iterate over all possible triples (i, j, k) where i < j < k\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                # Check if the sum of the triple is a multiple of 3\n                if (a[i] + a[j] + a[k]) % 3 == 0:\n                    count += 1\n    \n    return count\n", "py_summary": "The Python code defines a function `get_max_triples` that takes a positive integer `n` as input and returns the number of valid triples `(a[i], a[j], a[k])` where `i < j < k` and the sum `a[i] + a[j] + a[k]` is a multiple of 3.\n\nHere's a step-by-step analysis of the code:\n\n1. **Generate the Sequence `a`**:\n   - The sequence `a` is generated using a list comprehension. For each `i` from 1 to `n`, the value `a[i]` is calculated as `i * i - i + 1`.\n   - This results in a list `a` of length `n` where each element is computed based on the formula.\n\n2. **Initialize the Count of Valid Triples**:\n   - A variable `count` is initialized to 0. This variable will keep track of the number of valid triples found.\n\n3. **Iterate Over All Possible Triples**:\n   - Three nested loops are used to iterate over all possible triples `(i, j, k)` where `i < j < k`:\n     - The outer loop iterates over `i` from 0 to `n-1`.\n     - The middle loop iterates over `j` from `i+1` to `n-1`.\n     - The inner loop iterates over `k` from `j+1` to `n-1`.\n\n4. **Check the Sum of the Triple**:\n   - For each triple `(i, j, k)`, the sum `a[i] + a[j] + a[k]` is calculated.\n   - If the sum is a multiple of 3 (i.e., `(a[i] + a[j] + a[k]) % 3 == 0`), the `count` is incremented by 1.\n\n5. **Return the Count**:\n   - After all possible triples have been checked, the function returns the value of `count`.\n\nThis approach ensures that all possible combinations of triples are considered, and the count of valid triples is accurately determined. However, the time complexity of this solution is \\(O(n^3)\\), which may not be efficient for large values of `n`. For practical purposes, especially with large `n`, optimizations might be necessary."}
{"task_id": "CPP/105", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\nvector<string> by_length(vector<int> arr) {\n    // Define the mapping from digits to their names\n    map<int, string> digit_names = {\n        {1, \"One\"},\n        {2, \"Two\"},\n        {3, \"Three\"},\n        {4, \"Four\"},\n        {5, \"Five\"},\n        {6, \"Six\"},\n        {7, \"Seven\"},\n        {8, \"Eight\"},\n        {9, \"Nine\"}\n    };\n\n    // Filter out numbers not in the range 1-9\n    vector<int> filtered_arr;\n    for (int num : arr) {\n        if (1 <= num && num <= 9) {\n            filtered_arr.push_back(num);\n        }\n    }\n\n    // Sort the filtered array\n    sort(filtered_arr.begin(), filtered_arr.end());\n\n    // Reverse the sorted array\n    reverse(filtered_arr.begin(), filtered_arr.end());\n\n    // Replace each digit with its corresponding name\n    vector<string> result;\n    for (int num : filtered_arr) {\n        result.push_back(digit_names[num]);\n    }\n\n    return result;\n}\n\n// Function to test the by_length function\nvoid test_by_length() {\n    vector<int> arr1 = {2, 1, 1, 4, 5, 8, 2, 3};\n    vector<string> expected1 = {\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"};\n    assert(by_length(arr1) == expected1);\n\n    vector<int> arr2 = {};\n    vector<string> expected2 = {};\n    assert(by_length(arr2) == expected2);\n\n    vector<int> arr3 = {1, -1, 55};\n    vector<string> expected3 = {\"One\"};\n    assert(by_length(arr3) == expected3);\n\n    cout << \"All tests passed!\" << endl;\n}\n\n", "py_code": "def by_length(arr):\n    # Define the mapping from digits to their names\n    digit_names = {\n        1: \"One\",\n        2: \"Two\",\n        3: \"Three\",\n        4: \"Four\",\n        5: \"Five\",\n        6: \"Six\",\n        7: \"Seven\",\n        8: \"Eight\",\n        9: \"Nine\"\n    }\n    \n    # Filter out numbers not in the range 1-9\n    filtered_arr = [num for num in arr if 1 <= num <= 9]\n    \n    # Sort the filtered array\n    filtered_arr.sort()\n    \n    # Reverse the sorted array\n    filtered_arr.reverse()\n    \n    # Replace each digit with its corresponding name\n    result = [digit_names[num] for num in filtered_arr]\n    \n    return result\n", "py_summary": "The Python code defines a function `by_length` that processes a list of integers and returns a list of strings representing the names of the digits. Here's a step-by-step analysis of the code:\n\n1. **Mapping Definition**:\n   - A dictionary `digit_names` is defined to map integers from 1 to 9 to their corresponding names (\"One\" to \"Nine\").\n\n2. **Filtering**:\n   - A list comprehension is used to filter out numbers from the input list `arr` that are not in the range 1 to 9. This ensures that only valid digits are processed.\n\n3. **Sorting**:\n   - The filtered list is sorted in ascending order using the `sort` method.\n\n4. **Reversing**:\n   - The sorted list is reversed using the `reverse` method to get the desired order.\n\n5. **Replacing Digits with Names**:\n   - Another list comprehension is used to replace each digit in the reversed list with its corresponding name from the `digit_names` dictionary.\n\n6. **Returning the Result**:\n   - The final list of names is returned.\n\nThis approach ensures that the function handles edge cases such as empty lists and invalid numbers correctly. The filtering step ensures that only valid digits are processed, and the sorting and reversing steps ensure that the output is in the correct order.\n\n### Summary:\n- **Input**: A list of integers.\n- **Output**: A list of strings representing the names of the digits in the specified order.\n- **Steps**:\n  1. Filter out invalid numbers.\n  2. Sort the valid numbers.\n  3. Reverse the sorted list.\n  4. Map each digit to its name.\n  5. Return the resulting list of names."}
{"task_id": "CPP/22", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <boost/any.hpp>\n#include <list>\n#include <typeinfo>\n\ntypedef std::list<boost::any> list_any;\nusing namespace std;\n\nvector<int> filter_integers(list_any values) {\n    vector<int> result;\n    for (const auto& value : values) {\n        if (value.type() == typeid(int)) {\n            result.push_back(boost::any_cast<int>(value));\n        }\n    }\n    return result;\n}\n\n// Function to test the filter_integers function\nvoid test_filter_integers() {\n    list_any values1 = {\"a\", 3.14, 5};\n    vector<int> result1 = filter_integers(values1);\n    for (int val : result1) {\n        cout << val << \" \";\n    }\n    cout << endl;\n\n    list_any values2 = {1, 2, 3, \"abc\", {}, {}};\n    vector<int> result2 = filter_integers(values2);\n    for (int val : result2) {\n        cout << val << \" \";\n    }\n    cout << endl;\n}\n\n", "py_code": "from typing import List, Any\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    return [value for value in values if isinstance(value, int)]\n", "py_summary": "The Python code defines a function `filter_integers` that takes a list of values of any type and returns a new list containing only the integer values from the input list. The function uses a list comprehension to iterate over the input list and filter out non-integer values using the `isinstance` function.\n\nHere's a breakdown of the code:\n1. **Function Definition**: The function `filter_integers` is defined to take a single parameter `values`, which is expected to be a list of values of any type.\n2. **List Comprehension**: Inside the function, a list comprehension is used to iterate over each value in the input list `values`.\n3. **Type Checking**: For each value, the `isinstance` function checks if the value is an instance of the `int` type.\n4. **Filtering**: If the value is an integer, it is included in the resulting list.\n5. **Return**: The function returns the filtered list of integers.\n\nThis approach ensures that only integer values are retained in the output list, effectively filtering out all other types of values."}
{"task_id": "CPP/52", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool below_threshold(vector<int> l, int t) {\n    for (int x : l) {\n        if (x >= t) {\n            return false;\n        }\n    }\n    return true;\n}\n\n", "py_code": "def below_threshold(l, t):\n    return all(x < t for x in l)\n", "py_summary": "The Python code defines a function `below_threshold` that takes a list `l` and a threshold `t` as input. The function uses a generator expression inside the `all` function to check if every element `x` in the list `l` is less than the threshold `t`. The `all` function returns `True` if all elements in the generator expression are `True`, otherwise it returns `False`.\n\nHere's a step-by-step breakdown:\n1. The function `below_threshold` is defined with parameters `l` (a list of integers) and `t` (an integer threshold).\n2. The generator expression `(x < t for x in l)` iterates over each element `x` in the list `l` and checks if `x` is less than `t`.\n3. The `all` function evaluates the generator expression and returns `True` if all elements in the list satisfy the condition `x < t`, otherwise it returns `False`.\n\nThis approach is concise and leverages Python's built-in functions to achieve the desired result efficiently.\n\n"}
{"task_id": "CPP/154", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool cycpattern_check(string a, string b) {\n    // Concatenate the first word with itself\n    string concatenated = a + a;\n    // Check if the second word is a substring of the concatenated word\n    return concatenated.find(b) != string::npos;\n}\n\n", "py_code": "def cycpattern_check(a, b):\n    # Concatenate the first word with itself\n    concatenated = a + a\n    # Check if the second word or any of its rotations is a substring of the concatenated word\n    return b in concatenated\n", "py_summary": "The Python code defines a function `cycpattern_check` that takes two strings `a` and `b` as input. The goal is to determine if the second string `b` or any of its rotations is a substring of the first string `a`.\n\nHere's a step-by-step analysis of the code:\n\n1. **Concatenation of the First Word**: \n   - The function concatenates the first word `a` with itself. This creates a new string `concatenated` which contains all possible rotations of `a` as substrings. For example, if `a` is \"abc\", then `concatenated` will be \"abcabc\".\n\n2. **Substring Check**:\n   - The function checks if the second word `b` is a substring of the concatenated string `concatenated`. If `b` is found in `concatenated`, it means that `b` or one of its rotations is a substring of `a`.\n\n3. **Return Result**:\n   - The function returns `True` if `b` is found in `concatenated`, otherwise it returns `False`.\n\nThis approach works because concatenating `a` with itself ensures that all possible rotations of `a` are included in the resulting string. Therefore, if `b` is a substring of this concatenated string, it must be a rotation of a substring of `a`.\n\n### Example Usage:\n- `cycpattern_check(\"abcd\", \"abd\")` returns `False` because \"abd\" is not a substring of \"abcdabcd\".\n- `cycpattern_check(\"hello\", \"ell\")` returns `True` because \"ell\" is a substring of \"hellohello\".\n- `cycpattern_check(\"whassup\", \"psus\")` returns `False` because \"psus\" is not a substring of \"whassupwhassup\".\n- `cycpattern_check(\"abab\", \"baa\")` returns `True` because \"baa\" is a substring of \"abababab\".\n- `cycpattern_check(\"efef\", \"eeff\")` returns `False` because \"eeff\" is not a substring of \"efefefef\".\n- `cycpattern_check(\"himenss\", \"simen\")` returns `True` because \"simen\" is a substring of \"himensshimenss\".\n\n"}
{"task_id": "CPP/115", "generation": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint max_fill(vector<vector<int>> grid, int capacity) {\n    // Calculate the maximum number of units of water in any well\n    int max_water = 0;\n    for (const auto& row : grid) {\n        int water_in_well = accumulate(row.begin(), row.end(), 0);\n        max_water = max(max_water, water_in_well);\n    }\n\n    // Calculate the number of times we need to lower the buckets\n    return (max_water + capacity - 1) / capacity;\n}\n", "py_code": "def max_fill(grid, capacity):\n    # Calculate the maximum number of units of water in any well\n    max_water = max(sum(row) for row in grid)\n    \n    # Calculate the number of times we need to lower the buckets\n    return (max_water + capacity - 1) // capacity\n", "py_summary": "The Python code defines a function `max_fill` that takes a 2D list `grid` and an integer `capacity` as input. The goal is to determine the number of times we need to lower the buckets to empty all the wells.\n\n1. **Calculate the Maximum Water in Any Well**:\n   - The function uses a generator expression inside the `max` function to calculate the sum of water units in each row (well) of the grid. This gives us the maximum number of water units in any single well.\n   \n2. **Calculate the Number of Bucket Lowerings**:\n   - The function then calculates the number of times we need to lower the buckets to empty the well with the maximum water. This is done using the formula `(max_water + capacity - 1) // capacity`. This formula ensures that we round up to the nearest whole number of bucket lowerings, which is necessary because even if there is a small amount of water left, we still need to lower the bucket one more time.\n\n3. **Return the Result**:\n   - The function returns the calculated number of bucket lowerings.\n\nThis approach ensures that we efficiently determine the minimum number of bucket lowerings required to empty all the wells, considering the capacity of the buckets.\n\n"}
{"task_id": "CPP/131", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint digits(int n) {\n    int product = 1;\n    bool has_odd_digit = false;\n\n    while (n > 0) {\n        int digit = n % 10;\n        if (digit % 2 != 0) {\n            product *= digit;\n            has_odd_digit = true;\n        }\n        n /= 10;\n    }\n\n    return has_odd_digit ? product : 0;\n}\n\n", "py_code": "def digits(n):\n    product = 1\n    has_odd_digit = False\n    while n > 0:\n        digit = n % 10\n        if digit % 2 != 0:\n            product *= digit\n            has_odd_digit = True\n        n //= 10\n    return product if has_odd_digit else 0\n", "py_summary": "The Python code defines a function `digits` that takes a positive integer `n` as input and returns the product of the odd digits in `n`. If all digits are even, the function returns 0.\n\nHere's a step-by-step breakdown of how the function works:\n\n1. **Initialization**:\n   - `product` is initialized to 1. This will store the product of the odd digits.\n   - `has_odd_digit` is initialized to `False`. This flag will help determine if there is at least one odd digit in the number.\n\n2. **Digit Extraction and Processing**:\n   - The function enters a while loop that continues as long as `n` is greater than 0.\n   - Inside the loop, the last digit of `n` is extracted using `n % 10`.\n   - The function checks if the digit is odd by using the condition `digit % 2 != 0`.\n   - If the digit is odd, it multiplies `product` by the digit and sets `has_odd_digit` to `True`.\n   - The last digit is removed from `n` by performing integer division `n //= 10`.\n\n3. **Result Calculation**:\n   - After the loop, the function checks the value of `has_odd_digit`.\n   - If `has_odd_digit` is `True`, it returns the `product`.\n   - If `has_odd_digit` is `False`, it returns 0, indicating that all digits were even.\n\nThis approach ensures that the function correctly handles both cases where there are odd digits and where there are no odd digits."}
{"task_id": "CPP/37", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<float> sort_even(vector<float> l) {\n    // Extract even indices and their corresponding values\n    vector<int> even_indices;\n    vector<float> even_values;\n    for (int i = 0; i < l.size(); i++) {\n        if (i % 2 == 0) {\n            even_indices.push_back(i);\n            even_values.push_back(l[i]);\n        }\n    }\n\n    // Sort the even values\n    sort(even_values.begin(), even_values.end());\n\n    // Create a copy of the input vector\n    vector<float> l_prime = l;\n\n    // Update the even indices in the new vector with the sorted values\n    for (size_t i = 0; i < even_indices.size(); i++) {\n        l_prime[even_indices[i]] = even_values[i];\n    }\n\n    return l_prime;\n}\n\n// Function to test the sort_even function\nvoid test_sort_even() {\n    vector<float> test1 = {1, 2, 3};\n    vector<float> expected1 = {1, 2, 3};\n    assert(sort_even(test1) == expected1);\n\n    vector<float> test2 = {5, 6, 3, 4};\n    vector<float> expected2 = {3, 6, 5, 4};\n    assert(sort_even(test2) == expected2);\n\n    cout << \"All tests passed!\" << endl;\n}\n\n", "py_code": "def sort_even(l):\n    even_indices = [i for i in range(len(l)) if i % 2 == 0]\n    even_values = [l[i] for i in even_indices]\n    even_values.sort()\n    \n    l_prime = l.copy()\n    for i, value in zip(even_indices, even_values):\n        l_prime[i] = value\n    \n    return l_prime\n", "py_summary": "The Python code defines a function `sort_even` that takes a list `l` as input and returns a new list `l_prime` where the elements at even indices are sorted, while the elements at odd indices remain unchanged.\n\nHere's a step-by-step breakdown of the code:\n\n1. **Extract Even Indices and Values**:\n   - `even_indices` is a list comprehension that collects the indices of the even positions in the input list `l`.\n   - `even_values` is another list comprehension that collects the values at those even indices.\n\n2. **Sort Even Values**:\n   - The `even_values` list is sorted using the `sort` method.\n\n3. **Create a Copy of the Input List**:\n   - `l_prime` is created as a copy of the input list `l` to preserve the original list.\n\n4. **Update Even Indices in the New List**:\n   - A `for` loop iterates over the `even_indices` and `even_values` simultaneously using the `zip` function.\n   - For each even index, the corresponding sorted value is placed in the `l_prime` list.\n\n5. **Return the Modified List**:\n   - The modified list `l_prime` is returned.\n\nThis approach ensures that the elements at odd indices remain unchanged while the elements at even indices are sorted in ascending order."}
{"task_id": "CPP/92", "generation": "#include <iostream>\n#include <cmath>\nusing namespace std;\n\nbool is_integer(float num) {\n    return floor(num) == num;\n}\n\nbool any_int(float a, float b, float c) {\n    // Check if all numbers are integers\n    if (!is_integer(a) || !is_integer(b) || !is_integer(c)) {\n        return false;\n    }\n\n    // Check if any number is equal to the sum of the other two\n    if (a == b + c || b == a + c || c == a + b) {\n        return true;\n    }\n\n    return false;\n}\n\n", "py_code": "def any_int(a, b, c):\n    # Check if all numbers are integers\n    if not (a.is_integer() and b.is_integer() and c.is_integer()):\n        return False\n    \n    # Check if any number is equal to the sum of the other two\n    if a == b + c or b == a + c or c == a + b:\n        return True\n    \n    return False\n", "py_summary": "The Python code defines a function `any_int` that takes three floating-point numbers as input and returns a boolean value. The function performs the following steps:\n\n1. **Check if all numbers are integers**: The function uses the `is_integer()` method to check if each of the three numbers (`a`, `b`, and `c`) is an integer. If any of the numbers is not an integer, the function immediately returns `False`.\n\n2. **Check if any number is equal to the sum of the other two**: The function checks if any of the following conditions are true:\n   - `a` is equal to the sum of `b` and `c`.\n   - `b` is equal to the sum of `a` and `c`.\n   - `c` is equal to the sum of `a` and `b`.\n\n3. **Return the result**: If any of the above conditions are true, the function returns `True`. Otherwise, it returns `False`.\n\nThis approach ensures that the function only returns `True` if all three numbers are integers and one of them is the sum of the other two. Otherwise, it returns `False`."}
{"task_id": "CPP/118", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nstring get_closest_vowel(string word) {\n    string vowels = \"aeiouAEIOU\";\n    string closest_vowel = \"\";\n\n    // Iterate from the end of the word to the beginning\n    for (int i = word.length() - 2; i > 0; --i) {\n        if (vowels.find(word[i]) != string::npos && \n            vowels.find(word[i-1]) == string::npos && \n            vowels.find(word[i+1]) == string::npos) {\n            closest_vowel = word[i];\n            break;\n        }\n    }\n\n    return closest_vowel;\n}\n\n// Function to test the solution\nvoid test_get_closest_vowel() {\n    cout << \"get_closest_vowel(\\\"yogurt\\\") -> \" << get_closest_vowel(\"yogurt\") << endl; // \"u\"\n    cout << \"get_closest_vowel(\\\"FULL\\\") -> \" << get_closest_vowel(\"FULL\") << endl; // \"U\"\n    cout << \"get_closest_vowel(\\\"quick\\\") -> \" << get_closest_vowel(\"quick\") << endl; // \"\"\n    cout << \"get_closest_vowel(\\\"ab\\\") -> \" << get_closest_vowel(\"ab\") << endl; // \"\"\n}\n\n", "py_code": "def get_closest_vowel(word):\n    vowels = \"aeiouAEIOU\"\n    closest_vowel = \"\"\n    \n    # Iterate from the end of the word to the beginning\n    for i in range(len(word) - 2, 0, -1):\n        if word[i] in vowels and word[i-1] not in vowels and word[i+1] not in vowels:\n            closest_vowel = word[i]\n            break\n    \n    return closest_vowel\n", "py_summary": "The Python code defines a function `get_closest_vowel` that takes a string `word` as input and returns the closest vowel that stands between two consonants from the right side of the word. Here's a step-by-step analysis of the code:\n\n1. **Define Vowels**: The string `vowels` contains all the vowels in both uppercase and lowercase.\n2. **Initialize Closest Vowel**: The variable `closest_vowel` is initialized to an empty string. This will store the closest vowel that meets the criteria.\n3. **Iterate from Right to Left**: The function uses a `for` loop to iterate from the second-to-last character to the second character of the word (i.e., from `len(word) - 2` to `1`). This ensures that the first and last characters are not considered.\n4. **Check Conditions**: For each character in the loop:\n   - Check if the current character is a vowel (`word[i] in vowels`).\n   - Check if the character before the current character is a consonant (`word[i-1] not in vowels`).\n   - Check if the character after the current character is a consonant (`word[i+1] not in vowels`).\n5. **Update Closest Vowel**: If all conditions are met, update `closest_vowel` to the current character and break out of the loop.\n6. **Return Result**: After the loop, return the value of `closest_vowel`.\n\nThis approach ensures that the function finds the closest vowel that stands between two consonants from the right side of the word, and returns an empty string if no such vowel exists."}
{"task_id": "CPP/6", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\nusing namespace std;\n\nvector<int> parse_nested_parens(string paren_string) {\n    vector<int> results;\n    stringstream ss(paren_string);\n    string group;\n\n    while (getline(ss, group, ' ')) {\n        int max_depth = 0;\n        int current_depth = 0;\n\n        for (char ch : group) {\n            if (ch == '(') {\n                current_depth += 1;\n                max_depth = max(max_depth, current_depth);\n            } else if (ch == ')') {\n                current_depth -= 1;\n            }\n        }\n\n        results.push_back(max_depth);\n    }\n\n    return results;\n}\n\n", "py_code": "def parse_nested_parens(paren_string):\n    groups = paren_string.split()\n    results = []\n    for group in groups:\n        max_depth = 0\n        current_depth = 0\n        for char in group:\n            if char == '(':\n                current_depth += 1\n                max_depth = max(max_depth, current_depth)\n            elif char == ')':\n                current_depth -= 1\n        results.append(max_depth)\n    return results\n", "py_summary": "The Python code defines a function `parse_nested_parens` that takes a string of nested parentheses groups separated by spaces and returns a list of integers representing the deepest level of nesting for each group.\n\n1. **Split the Input String**: The input string is split into individual groups using the `split()` method, which splits the string by spaces.\n2. **Initialize Results List**: An empty list `results` is initialized to store the maximum depth of nesting for each group.\n3. **Iterate Over Groups**: For each group in the split string:\n   - **Initialize Depth Variables**: Two variables, `max_depth` and `current_depth`, are initialized to 0. `max_depth` will store the maximum depth of nesting encountered in the current group, and `current_depth` will keep track of the current depth as we iterate through the characters.\n   - **Iterate Over Characters**: For each character in the group:\n     - If the character is '(', increment `current_depth` by 1 and update `max_depth` if `current_depth` is greater than `max_depth`.\n     - If the character is ')', decrement `current_depth` by 1.\n4. **Append Maximum Depth**: After processing all characters in the group, append `max_depth` to the `results` list.\n5. **Return Results**: Finally, the function returns the `results` list containing the maximum depth of nesting for each group.\n\nThis approach ensures that the function correctly identifies the deepest level of nesting for each group of parentheses."}
{"task_id": "CPP/87", "generation": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<vector<int>> get_row(vector<vector<int>> lst, int x) {\n    vector<vector<int>> coordinates;\n\n    // Iterate through the nested list to find occurrences of x\n    for (int i = 0; i < lst.size(); ++i) {\n        for (int j = 0; j < lst[i].size(); ++j) {\n            if (lst[i][j] == x) {\n                coordinates.push_back({i, j});\n            }\n        }\n    }\n\n    // Sort the coordinates by rows in ascending order and columns in descending order\n    sort(coordinates.begin(), coordinates.end(), [](const vector<int>& a, const vector<int>& b) {\n        if (a[0] == b[0]) {\n            return a[1] > b[1]; // Descending order for columns\n        }\n        return a[0] < b[0]; // Ascending order for rows\n    });\n\n    return coordinates;\n}\n", "py_code": "def get_row(lst, x):\n    coordinates = []\n    for i, row in enumerate(lst):\n        for j, value in enumerate(row):\n            if value == x:\n                coordinates.append([i, j])\n    # Sort by rows in ascending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    return coordinates\n", "py_summary": "The Python code defines a function `get_row` that takes a nested list `lst` and an integer `x` as input. The function aims to find all occurrences of `x` in the nested list and return a list of coordinates where each coordinate is a list `[i, j]` representing the row and column indices of the occurrence of `x`.\n\nHere's a step-by-step breakdown of how the code works:\n\n1. **Initialization**: An empty list `coordinates` is initialized to store the coordinates of the occurrences of `x`.\n\n2. **Iterate through the nested list**: The function uses a nested loop to iterate through each element in the nested list `lst`.\n   - The outer loop iterates over the rows of the list using `enumerate` to get both the index `i` and the row itself.\n   - The inner loop iterates over the elements in the current row using `enumerate` to get both the index `j` and the value of the element.\n\n3. **Check for the target value**: Inside the inner loop, the function checks if the current element `value` is equal to `x`. If it is, the coordinates `[i, j]` are appended to the `coordinates` list.\n\n4. **Sort the coordinates**: After collecting all the coordinates, the function sorts the `coordinates` list. The sorting is done first by the row index `i` in ascending order and then by the column index `j` in descending order. This is achieved using the `key` parameter of the `sort` method with a lambda function that returns a tuple `(coord[0], -coord[1])`.\n\n5. **Return the sorted coordinates**: Finally, the function returns the sorted list of coordinates.\n\nThis approach ensures that the coordinates are returned in the required format and order.\n\n### Summary:\n- **Input**: A nested list `lst` and an integer `x`.\n- **Output**: A list of coordinates `[i, j]` where `lst[i][j] == x`, sorted by rows in ascending order and columns in descending order.\n- **Steps**:\n  1. Initialize an empty list to store coordinates.\n  2. Iterate through the nested list to find occurrences of `x`.\n  3. Append the coordinates to the list.\n  4. Sort the coordinates by rows in ascending order and columns in descending order.\n  5. Return the sorted list of coordinates."}
{"task_id": "CPP/2", "generation": "#include <stdio.h>\n#include <math.h>\nusing namespace std;\n\nfloat truncate_number(float number) {\n    int integer_part = static_cast<int>(number);\n    float decimal_part = number - integer_part;\n    return decimal_part;\n}\n\n", "py_code": "def truncate_number(number):\n    integer_part = int(number)\n    decimal_part = number - integer_part\n    return decimal_part\n", "py_summary": "The Python code defines a function `truncate_number` that takes a floating-point number as input and returns its decimal part. Here's a breakdown of how the function works:\n\n1. **Extract the Integer Part**: The `int()` function is used to convert the floating-point number to its integer part. This effectively truncates the decimal part, leaving only the largest integer smaller than the given number.\n\n2. **Calculate the Decimal Part**: The decimal part is obtained by subtracting the integer part from the original number. This results in a value that is always between 0 (inclusive) and 1 (exclusive).\n\n3. **Return the Decimal Part**: The function returns the calculated decimal part.\n\nThis approach ensures that the decimal part is accurately extracted and returned.\n\n### Example Usage:\n- For `number = 3.5`, the integer part is `3` and the decimal part is `0.5`.\n- For `number = 7.25`, the integer part is `7` and the decimal part is `0.25`.\n\nThe function handles both cases correctly by performing simple arithmetic operations."}
{"task_id": "CPP/16", "generation": "#include <iostream>\n#include <string>\n#include <set>\n#include <cctype> // for tolower function\n\nusing namespace std;\n\nint count_distinct_characters(string str) {\n    // Convert the string to lowercase to ignore case differences\n    for (char &c : str) {\n        c = tolower(c);\n    }\n\n    // Use a set to store unique characters\n    set<char> unique_chars(str.begin(), str.end());\n\n    // Return the number of unique characters\n    return unique_chars.size();\n}\n\n", "py_code": "def count_distinct_characters(s):\n    # Convert the string to lowercase to ignore case differences\n    s = s.lower()\n    # Use a set to store unique characters\n    unique_chars = set(s)\n    # Return the number of unique characters\n    return len(unique_chars)\n", "py_summary": "The Python code defines a function `count_distinct_characters` that takes a string `s` as input and returns the number of distinct characters in the string, ignoring case differences. Here's a step-by-step breakdown of how the function works:\n\n1. **Convert the String to Lowercase**: The input string `s` is converted to lowercase using the `lower()` method. This ensures that character comparison is case-insensitive.\n2. **Use a Set to Store Unique Characters**: A set is used to store the unique characters from the lowercase string. Sets automatically handle duplicates, so only unique characters are stored.\n3. **Return the Number of Unique Characters**: The length of the set, which represents the number of unique characters, is returned.\n\nThis approach is efficient because converting the string to lowercase and using a set both have linear time complexity, making the overall complexity O(n), where n is the length of the string.\n\n### Summary:\n- **Input**: A string `s`.\n- **Output**: An integer representing the number of distinct characters in the string, ignoring case differences.\n- **Steps**:\n  1. Convert the string to lowercase.\n  2. Use a set to store unique characters.\n  3. Return the size of the set."}
{"task_id": "CPP/135", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint can_arrange(vector<int> arr) {\n    int largest_index = -1;\n    for (int i = 1; i < arr.size(); ++i) {\n        if (arr[i] < arr[i - 1]) {\n            largest_index = i;\n        }\n    }\n    return largest_index;\n}\n\n// Function to test the can_arrange function\nvoid test_can_arrange() {\n    vector<int> test1 = {1, 2, 4, 3, 5};\n    vector<int> test2 = {1, 2, 3};\n    vector<int> test3 = {5, 4, 3, 2, 1};\n    vector<int> test4 = {1, 3, 2, 4, 5};\n\n    cout << \"can_arrange({1, 2, 4, 3, 5}) = \" << can_arrange(test1) << \" (Expected: 3)\" << endl;\n    cout << \"can_arrange({1, 2, 3}) = \" << can_arrange(test2) << \" (Expected: -1)\" << endl;\n    cout << \"can_arrange({5, 4, 3, 2, 1}) = \" << can_arrange(test3) << \" (Expected: 1)\" << endl;\n    cout << \"can_arrange({1, 3, 2, 4, 5}) = \" << can_arrange(test4) << \" (Expected: 2)\" << endl;\n}\n\n", "py_code": "def can_arrange(arr):\n    largest_index = -1\n    for i in range(1, len(arr)):\n        if arr[i] < arr[i - 1]:\n            largest_index = i\n    return largest_index\n", "py_summary": "The Python code defines a function `can_arrange` that takes a list of integers as input and returns the largest index of an element which is not greater than or equal to the element immediately preceding it. If no such element exists, the function returns -1.\n\nHere's a step-by-step breakdown of how the function works:\n\n1. **Initialization**: The variable `largest_index` is initialized to -1. This will store the index of the element that does not meet the condition of being greater than or equal to the previous element.\n\n2. **Iteration**: The function iterates through the list starting from the second element (index 1) to the last element. For each element at index `i`, it checks if the current element `arr[i]` is less than the previous element `arr[i - 1]`.\n\n3. **Condition Check**: If the condition `arr[i] < arr[i - 1]` is true, it updates `largest_index` to the current index `i`.\n\n4. **Return**: After the loop completes, the function returns the value of `largest_index`. If no such element was found, `largest_index` remains -1.\n\nThis approach ensures that the function finds the largest index where the condition is violated, as it iterates through the list in a single pass.\n\n### Summary:\n- **Input**: A list of integers `arr`.\n- **Output**: The largest index of an element that is not greater than or equal to the element immediately preceding it, or -1 if no such element exists.\n- **Algorithm**: Iterate through the list and check the condition for each element, updating the largest index when the condition is met."}
{"task_id": "CPP/106", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Helper function to calculate factorial\nint factorial(int x) {\n    if (x == 0 || x == 1) {\n        return 1;\n    }\n    int result = 1;\n    for (int i = 2; i <= x; ++i) {\n        result *= i;\n    }\n    return result;\n}\n\n// Helper function to calculate the sum of numbers from 1 to x\nint sum_of_numbers(int x) {\n    return x * (x + 1) / 2;\n}\n\n// Main function to generate the vector\nvector<int> f(int n) {\n    vector<int> result;\n    for (int i = 1; i <= n; ++i) {\n        if (i % 2 == 0) {\n            result.push_back(factorial(i));\n        } else {\n            result.push_back(sum_of_numbers(i));\n        }\n    }\n    return result;\n}\n\n// Function to test the implementation\nvoid test_f() {\n    vector<int> expected = {1, 2, 6, 24, 15};\n    vector<int> result = f(5);\n    if (result == expected) {\n        cout << \"Test passed.\" << endl;\n    } else {\n        cout << \"Test failed.\" << endl;\n    }\n}\n\n", "py_code": "def f(n):\n    def factorial(x):\n        if x == 0 or x == 1:\n            return 1\n        result = 1\n        for i in range(2, x + 1):\n            result *= i\n        return result\n\n    def sum_of_numbers(x):\n        return x * (x + 1) // 2\n\n    result = []\n    for i in range(1, n + 1):\n        if i % 2 == 0:\n            result.append(factorial(i))\n        else:\n            result.append(sum_of_numbers(i))\n    return result\n", "py_summary": "The Python code defines a function `f` that takes an integer `n` as a parameter and returns a list of integers of size `n`. The value at each index `i` (starting from 1) in the list is determined based on whether `i` is even or odd:\n\n- If `i` is even, the value is the factorial of `i`.\n- If `i` is odd, the value is the sum of numbers from 1 to `i`.\n\nThe function uses two helper functions:\n1. `factorial(x)`: This function calculates the factorial of a given number `x`. It handles the base cases where `x` is 0 or 1 and returns 1. For other values, it multiplies all integers from 2 to `x`.\n2. `sum_of_numbers(x)`: This function calculates the sum of numbers from 1 to `x` using the formula \\( \\frac{x \\times (x + 1)}{2} \\).\n\nThe main function `f` initializes an empty list `result` and iterates from 1 to `n`. For each index `i`, it checks if `i` is even or odd and appends the appropriate value to the `result` list. Finally, it returns the `result` list.\n\n### Example:\nFor `n = 5`:\n- `i = 1` (odd): Sum of numbers from 1 to 1 is 1.\n- `i = 2` (even): Factorial of 2 is 2.\n- `i = 3` (odd): Sum of numbers from 1 to 3 is 6.\n- `i = 4` (even): Factorial of 4 is 24.\n- `i = 5` (odd): Sum of numbers from 1 to 5 is 15.\n\nThus, `f(5)` returns `[1, 2, 6, 24, 15]`."}
{"task_id": "CPP/162", "generation": "#include <iostream>\n#include <string>\n#include <openssl/md5.h>\n#include <sstream>\n\nusing namespace std;\n\nstring string_to_md5(string text) {\n    if (text.empty()) {\n        return \"None\";\n    }\n\n    unsigned char digest[MD5_DIGEST_LENGTH];\n    MD5((unsigned char*)text.c_str(), text.length(), (unsigned char*)&digest);  \n\n    stringstream ss;\n    for (int i = 0; i < MD5_DIGEST_LENGTH; i++) {\n        ss << hex << setw(2) << setfill('0') << (int)digest[i];\n    }\n\n    return ss.str();\n}\n\n", "py_code": "import hashlib\n\ndef string_to_md5(text):\n    if not text:\n        return None\n    md5_hash = hashlib.md5(text.encode()).hexdigest()\n    return md5_hash\n", "py_summary": "The Python code defines a function `string_to_md5` that takes a string `text` as input and returns its MD5 hash equivalent string. Here's a step-by-step analysis of the code:\n\n1. **Check for Empty String**: The function first checks if the input string `text` is empty. If it is, the function returns `None`.\n2. **Encode the String**: If the string is not empty, it encodes the string using UTF-8 encoding. This is necessary because the `hashlib.md5` function requires a byte-like object.\n3. **Compute the MD5 Hash**: The `hashlib.md5` function is used to compute the MD5 hash of the encoded string.\n4. **Convert to Hexadecimal String**: The `hexdigest` method of the MD5 hash object is called to convert the hash to a hexadecimal string.\n5. **Return the Result**: The function returns the hexadecimal string representing the MD5 hash.\n\nThis approach ensures that the function handles both non-empty and empty strings correctly and efficiently computes the MD5 hash for non-empty strings.\n\n"}
{"task_id": "CPP/5", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> intersperse(vector<int> numbers, int delimiter) {\n    vector<int> result;\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        result.push_back(numbers[i]);\n        if (i < numbers.size() - 1) {\n            result.push_back(delimiter);\n        }\n    }\n    return result;\n}\n\n// Function to test the intersperse function\nvoid test_intersperse() {\n    vector<int> test1 = intersperse({}, 4);\n    vector<int> expected1 = {};\n    assert(test1 == expected1);\n\n    vector<int> test2 = intersperse({1, 2, 3}, 4);\n    vector<int> expected2 = {1, 4, 2, 4, 3};\n    assert(test2 == expected2);\n\n    cout << \"All tests passed!\" << endl;\n}\n\n", "py_code": "def intersperse(numbers, delimiter):\n    result = []\n    for i, num in enumerate(numbers):\n        result.append(num)\n        if i < len(numbers) - 1:\n            result.append(delimiter)\n    return result\n", "py_summary": "The Python code defines a function `intersperse` that takes a list of integers `numbers` and an integer `delimiter` as input. The function returns a new list where the `delimiter` is inserted between every two consecutive elements of the input list.\n\nHere's a step-by-step breakdown of how the function works:\n\n1. **Initialization**: An empty list `result` is created to store the final output.\n2. **Iteration**: The function iterates over the `numbers` list using a `for` loop with `enumerate` to get both the index `i` and the value `num` of each element.\n3. **Appending Elements**: For each element in `numbers`, the element is appended to the `result` list.\n4. **Inserting Delimiter**: If the current index `i` is less than the length of `numbers` minus one (i.e., not the last element), the `delimiter` is appended to the `result` list.\n5. **Return Result**: After the loop completes, the `result` list is returned.\n\nThis approach ensures that the `delimiter` is inserted between every pair of consecutive elements in the input list, and the resulting list is returned.\n\n### Example:\n- For `numbers = [1, 2, 3]` and `delimiter = 4`, the function will produce the list `[1, 4, 2, 4, 3]`.\n\n"}
{"task_id": "CPP/97", "generation": "#include <iostream>\n#include <cmath>\nusing namespace std;\n\nint multiply(int a, int b) {\n    // Extract the unit digit of both numbers\n    int unit_digit_a = abs(a) % 10;\n    int unit_digit_b = abs(b) % 10;\n    \n    // Return the product of the unit digits\n    return unit_digit_a * unit_digit_b;\n}\n\n// Function to test the multiply function\nvoid test_multiply() {\n    cout << \"multiply(148, 412) = \" << multiply(148, 412) << \" (Expected: 16)\" << endl;\n    cout << \"multiply(19, 28) = \" << multiply(19, 28) << \" (Expected: 72)\" << endl;\n    cout << \"multiply(2020, 1851) = \" << multiply(2020, 1851) << \" (Expected: 0)\" << endl;\n    cout << \"multiply(14, -15) = \" << multiply(14, -15) << \" (Expected: 20)\" << endl;\n}\n\n", "py_code": "def multiply(a, b):\n    # Extract the unit digit of both numbers\n    unit_digit_a = a % 10\n    unit_digit_b = b % 10\n    # Return the product of the unit digits\n    return unit_digit_a * unit_digit_b\n", "py_summary": "The Python code defines a function `multiply` that takes two integers `a` and `b` as input and returns the product of their unit digits. Here's a step-by-step breakdown of how the function works:\n\n1. **Extract Unit Digits**:\n   - The unit digit of a number is the remainder when the number is divided by 10. This is achieved using the modulus operator `%`.\n   - `unit_digit_a = a % 10` extracts the unit digit of `a`.\n   - `unit_digit_b = b % 10` extracts the unit digit of `b`.\n\n2. **Calculate Product**:\n   - The function then multiplies the two unit digits together: `return unit_digit_a * unit_digit_b`.\n\n3. **Return Result**:\n   - The product of the unit digits is returned as the result.\n\nThis approach ensures that the function correctly handles both positive and negative integers, as the modulus operation works the same way for both.\n\n### Examples:\n- `multiply(148, 412)`:\n  - Unit digit of 148 is 8.\n  - Unit digit of 412 is 2.\n  - Product is \\(8 \\times 2 = 16\\).\n\n- `multiply(19, 28)`:\n  - Unit digit of 19 is 9.\n  - Unit digit of 28 is 8.\n  - Product is \\(9 \\times 8 = 72\\).\n\n- `multiply(2020, 1851)`:\n  - Unit digit of 2020 is 0.\n  - Unit digit of 1851 is 1.\n  - Product is \\(0 \\times 1 = 0\\).\n\n- `multiply(14, -15)`:\n  - Unit digit of 14 is 4.\n  - Unit digit of -15 is 5 (modulus operation gives 5).\n  - Product is \\(4 \\times 5 = 20\\).\n\nThis function is straightforward and efficient, making it suitable for the given problem."}
{"task_id": "CPP/44", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring change_base(int x, int base) {\n    if (base < 2 || base > 9) {\n        throw invalid_argument(\"Base must be between 2 and 9\");\n    }\n\n    if (x == 0) {\n        return \"0\";\n    }\n\n    string result = \"\";\n    while (x > 0) {\n        int remainder = x % base;\n        result = to_string(remainder) + result;\n        x = x / base;\n    }\n\n    return result;\n}\n\n// Test cases\n", "py_code": "def change_base(x, base):\n    if base < 2 or base > 9:\n        raise ValueError(\"Base must be between 2 and 9\")\n    \n    if x == 0:\n        return \"0\"\n    \n    result = \"\"\n    while x > 0:\n        remainder = x % base\n        result = str(remainder) + result\n        x = x // base\n    \n    return result\n", "py_summary": "The Python code defines a function `change_base` that converts a given integer `x` to a specified base and returns the string representation of the converted number. Here's a detailed analysis of the code:\n\n1. **Input Validation**:\n   - The function first checks if the base is within the valid range (2 to 9). If not, it raises a `ValueError`.\n\n2. **Handling Zero**:\n   - If the input number `x` is zero, the function immediately returns the string `\"0\"`.\n\n3. **Conversion Process**:\n   - The function initializes an empty string `result` to store the digits of the converted number.\n   - It enters a loop that continues until `x` becomes zero.\n   - In each iteration, it calculates the remainder of `x` divided by the base and prepends this remainder to the `result` string.\n   - It then updates `x` by performing integer division by the base.\n\n4. **Return Result**:\n   - After the loop completes, the function returns the `result` string, which contains the digits of the converted number in the specified base.\n\nThis approach ensures that the number is correctly converted to the desired base and returned as a string. The use of string concatenation in the loop allows the digits to be added in the correct order from most significant to least significant."}
{"task_id": "CPP/161", "generation": "#include <iostream>\n#include <string>\n#include <cctype> // for isalpha, islower, toupper, tolower\nusing namespace std;\n\nstring solve(string s) {\n    bool containsLetter = false;\n    \n    // Check if the string contains any letters\n    for (char c : s) {\n        if (isalpha(c)) {\n            containsLetter = true;\n            break;\n        }\n    }\n    \n    // If the string contains no letters, reverse the string\n    if (!containsLetter) {\n        reverse(s.begin(), s.end());\n        return s;\n    }\n    \n    // Otherwise, reverse the case of each letter\n    for (char &c : s) {\n        if (isalpha(c)) {\n            if (islower(c)) {\n                c = toupper(c);\n            } else {\n                c = tolower(c);\n            }\n        }\n    }\n    \n    return s;\n}\n\n// Function to test the solve function\nvoid test_solve() {\n    cout << (solve(\"1234\") == \"4321\") << endl; // Should print 1 (true)\n    cout << (solve(\"ab\") == \"AB\") << endl;     // Should print 1 (true)\n    cout << (solve(\"#a@C\") == \"#A@c\") << endl; // Should print 1 (true)\n}\n\n", "py_code": "def solve(s):\n    # Check if the string contains any letters\n    if not any(c.isalpha() for c in s):\n        return s[::-1]  # Reverse the string if no letters are present\n    \n    # Otherwise, reverse the case of each letter\n    result = []\n    for c in s:\n        if c.isalpha():\n            if c.islower():\n                result.append(c.upper())\n            else:\n                result.append(c.lower())\n        else:\n            result.append(c)\n    \n    return ''.join(result)\n", "py_summary": "The Python code defines a function `solve` that takes a string `s` as input and returns a modified version of the string based on the following rules:\n\n1. **Check for Letters**: The function first checks if the string contains any letters using the `any` function combined with a generator expression `c.isalpha() for c in s`. If no letters are found, the function reverses the entire string using slicing `s[::-1]`.\n\n2. **Reverse Case of Letters**: If the string contains at least one letter, the function iterates through each character in the string. For each character:\n   - If the character is a letter (`c.isalpha()`), it checks if the letter is lowercase (`c.islower()`). If it is, the character is converted to uppercase using `c.upper()`. If the letter is uppercase, it is converted to lowercase using `c.lower()`.\n   - If the character is not a letter, it is appended to the result as is.\n\n3. **Return Result**: The modified characters are collected in a list `result`, which is then joined into a single string using `''.join(result)` and returned.\n\nThis approach ensures that the string is processed correctly according to the given rules, handling both cases where the string contains letters and where it does not."}
{"task_id": "CPP/38", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring encode_cyclic(string s) { \n    // returns encoded string by cycling groups of three characters.  \n    // split string to groups. Each of length 3.\n    int l = s.length();\n    int num = (l + 2) / 3;\n    string x, output;\n    for (int i = 0; i * 3 < l; i++) {\n        // cycle elements in each group. Unless group has fewer elements than 3.\n        x = s.substr(i * 3, 3);\n        if (x.length() == 3) {\n            x = x.substr(1) + x[0];\n        }\n        output += x;\n    }\n    return output;\n}\n\nstring decode_cyclic(string s) { \n    // takes as input string encoded with encode_cyclic function. Returns decoded string. \n    int l = s.length();\n    int num = (l + 2) / 3;\n    string x, output;\n    for (int i = 0; i * 3 < l; i++) {\n        // reverse the cycling of elements in each group. Unless group has fewer elements than 3.\n        x = s.substr(i * 3, 3);\n        if (x.length() == 3) {\n            x = x[2] + x.substr(0, 2);\n        }\n        output += x;\n    }\n    return output;\n}\n\n// Test the functions\n", "py_code": "def encode_cyclic(s: str) -> str:\n    # Split the string into groups of three characters\n    groups = [s[i:i+3] for i in range(0, len(s), 3)]\n    \n    # Cycle the elements in each group unless the group has fewer than 3 elements\n    encoded_groups = [group[1:] + group[0] if len(group) == 3 else group for group in groups]\n    \n    # Join the encoded groups back into a single string\n    return ''.join(encoded_groups)\n\ndef decode_cyclic(s: str) -> str:\n    # Split the string into groups of three characters\n    groups = [s[i:i+3] for i in range(0, len(s), 3)]\n    \n    # Reverse the cycling of the elements in each group unless the group has fewer than 3 elements\n    decoded_groups = [group[-1] + group[:-1] if len(group) == 3 else group for group in groups]\n    \n    # Join the decoded groups back into a single string\n    return ''.join(decoded_groups)\n", "py_summary": "### Analysis of the Python Code\n\n#### `encode_cyclic` Function\n1. **Splitting the String into Groups**:\n   - The string `s` is split into groups of three characters using a list comprehension: `[s[i:i+3] for i in range(0, len(s), 3)]`.\n   - This creates a list of substrings, each of length 3, except possibly the last one which could be shorter.\n\n2. **Cycling the Elements in Each Group**:\n   - For each group, if the group has exactly 3 characters, the first character is moved to the end of the group using `group[1:] + group[0]`.\n   - If the group has fewer than 3 characters, it remains unchanged.\n\n3. **Joining the Encoded Groups**:\n   - The encoded groups are joined back into a single string using `''.join(encoded_groups)`.\n\n#### `decode_cyclic` Function\n1. **Splitting the String into Groups**:\n   - Similar to the `encode_cyclic` function, the string `s` is split into groups of three characters using the same list comprehension.\n\n2. **Reversing the Cycling of the Elements in Each Group**:\n   - For each group, if the group has exactly 3 characters, the last character is moved to the beginning of the group using `group[-1] + group[:-1]`.\n   - If the group has fewer than 3 characters, it remains unchanged.\n\n3. **Joining the Decoded Groups**:\n   - The decoded groups are joined back into a single string using `''.join(decoded_groups)`.\n\n### Summary\n- The `encode_cyclic` function cycles the first character of each group of three characters to the end.\n- The `decode_cyclic` function reverses this process by moving the last character of each group of three characters to the beginning.\n- Both functions handle groups with fewer than 3 characters by leaving them unchanged.\n- The functions ensure that the original string can be accurately encoded and decoded using these operations."}
{"task_id": "CPP/93", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\n// Function to swap case of a character\nchar swap_case(char c) {\n    if (islower(c)) {\n        return toupper(c);\n    } else {\n        return tolower(c);\n    }\n}\n\n// Function to replace vowels with the letter 2 places ahead\nchar replace_vowel(char c) {\n    string vowels = \"aeiouAEIOU\";\n    string vowel_replacements = \"cgikqwCGIKQW\";\n    size_t pos = vowels.find(c);\n    if (pos != string::npos) {\n        return vowel_replacements[pos];\n    }\n    return c;\n}\n\nstring encode(string message) {\n    // Encode the message\n    string encoded_message;\n    for (char c : message) {\n        if (isalpha(c)) {\n            c = swap_case(c);\n            c = replace_vowel(c);\n        }\n        encoded_message += c;\n    }\n\n    return encoded_message;\n}\n\n// Main function to test the encode function\n", "py_code": "def encode(message):\n    vowels = 'aeiouAEIOU'\n    vowel_map = {'a': 'c', 'e': 'g', 'i': 'k', 'o': 'q', 'u': 'w',\n                 'A': 'C', 'E': 'G', 'I': 'K', 'O': 'Q', 'U': 'W'}\n    \n    encoded_message = []\n    for char in message:\n        if char.isalpha():\n            # Swap case\n            if char.islower():\n                char = char.upper()\n            else:\n                char = char.lower()\n            \n            # Replace vowels\n            if char in vowels:\n                char = vowel_map[char]\n        \n        encoded_message.append(char)\n    \n    return ''.join(encoded_message)\n", "py_summary": "The Python code defines a function `encode` that takes a string `message` as input and returns an encoded version of the message according to the specified rules:\n\n1. **Case Swapping**: For each alphabetic character in the message, the function swaps its case. If the character is lowercase, it converts it to uppercase, and vice versa.\n2. **Vowel Replacement**: For each vowel in the message, the function replaces it with the letter that appears 2 places ahead of it in the English alphabet. This is done using a predefined dictionary `vowel_map` that maps each vowel to its corresponding replacement.\n\nThe function works as follows:\n- It initializes a string `vowels` containing all the vowels in both lowercase and uppercase.\n- It creates a dictionary `vowel_map` that maps each vowel to the letter 2 places ahead of it.\n- It iterates through each character in the input message:\n  - If the character is an alphabetic letter, it swaps its case.\n  - If the character is a vowel, it replaces it with the corresponding letter from the `vowel_map`.\n- It appends the processed character to the `encoded_message` list.\n- Finally, it joins the list into a single string and returns it.\n\nThis approach ensures that the message is encoded correctly according to the given rules."}
{"task_id": "CPP/152", "generation": "#include <iostream>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\nvector<int> compare(vector<int> game, vector<int> guess) {\n    vector<int> result;\n    for (size_t i = 0; i < game.size(); ++i) {\n        int diff = abs(game[i] - guess[i]);\n        result.push_back(diff);\n    }\n    return result;\n}\n\n// Function to test the compare function\nvoid test_compare() {\n    vector<int> game1 = {1, 2, 3, 4, 5, 1};\n    vector<int> guess1 = {1, 2, 3, 4, 2, -2};\n    vector<int> expected1 = {0, 0, 0, 0, 3, 3};\n    assert(compare(game1, guess1) == expected1);\n\n    vector<int> game2 = {0, 5, 0, 0, 0, 4};\n    vector<int> guess2 = {4, 1, 1, 0, 0, -2};\n    vector<int> expected2 = {4, 4, 1, 0, 0, 6};\n    assert(compare(game2, guess2) == expected2);\n\n    cout << \"All tests passed!\" << endl;\n}\n\n", "py_code": "def compare(game, guess):\n    result = []\n    for i in range(len(game)):\n        diff = abs(game[i] - guess[i])\n        result.append(diff)\n    return result\n", "py_summary": "The Python code defines a function `compare` that takes two lists, `game` and `guess`, as input. These lists represent the actual scores and the guessed scores for a series of matches, respectively. The function returns a list of the same length, where each element represents the absolute difference between the actual score and the guessed score for each match.\n\nHere's a step-by-step breakdown of the code:\n\n1. **Initialization**: An empty list `result` is initialized to store the differences.\n2. **Iteration**: A `for` loop iterates over the indices of the `game` list.\n3. **Difference Calculation**: For each index `i`, the absolute difference between `game[i]` and `guess[i]` is calculated using the `abs` function.\n4. **Appending Results**: The calculated difference is appended to the `result` list.\n5. **Return**: After the loop completes, the `result` list is returned.\n\nThis approach ensures that the function correctly computes the absolute differences for each match and returns the results in a list of the same length as the input lists.\n\n"}
{"task_id": "CPP/62", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<float> derivative(vector<float> xs) {\n    vector<float> result;\n    for (size_t i = 1; i < xs.size(); ++i) {\n        result.push_back(i * xs[i]);\n    }\n    return result;\n}\n\n// Function to print the vector for testing purposes\nvoid print_vector(const vector<float>& vec) {\n    for (float val : vec) {\n        cout << val << \" \";\n    }\n    cout << endl;\n}\n\n", "py_code": "def derivative(xs):\n    return [i * xs[i] for i in range(1, len(xs))]\n", "py_summary": "The Python code defines a function `derivative` that takes a list of coefficients `xs` representing a polynomial and returns a new list of coefficients representing the derivative of the polynomial.\n\n1. **Input**: The input `xs` is a list of floats where `xs[i]` represents the coefficient of the term \\( x^i \\) in the polynomial.\n2. **Output**: The output is a list of floats representing the coefficients of the derivative of the polynomial.\n3. **Logic**:\n   - The function uses a list comprehension to iterate over the indices of the input list starting from 1 (since the constant term \\( x^0 \\) has no derivative).\n   - For each index `i`, it multiplies the coefficient `xs[i]` by `i` to get the coefficient of the term \\( x^{i-1} \\) in the derivative.\n   - The resulting list of coefficients is returned.\n\nFor example, if the input is `[3, 1, 2, 4, 5]`, the output will be `[1, 4, 12, 20]`, which represents the derivative of the polynomial \\( 3 + x + 2x^2 + 4x^3 + 5x^4 \\).\n\n"}
{"task_id": "CPP/7", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> filter_by_substring(vector<string> strings, string substring) {\n    vector<string> filtered_strings;\n    for (const string& s : strings) {\n        if (s.find(substring) != string::npos) {\n            filtered_strings.push_back(s);\n        }\n    }\n    return filtered_strings;\n}\n\n// Function to test the filter_by_substring function\nvoid test_filter_by_substring() {\n    vector<string> test1 = {};\n    vector<string> expected1 = {};\n    assert(filter_by_substring(test1, \"a\") == expected1);\n\n    vector<string> test2 = {\"abc\", \"bacd\", \"cde\", \"vector\"};\n    vector<string> expected2 = {\"abc\", \"bacd\", \"vector\"};\n    assert(filter_by_substring(test2, \"a\") == expected2);\n\n    cout << \"All tests passed!\" << endl;\n}\n\n", "py_code": "def filter_by_substring(strings, substring):\n    filtered_strings = [s for s in strings if substring in s]\n    return filtered_strings\n", "py_summary": "The Python code defines a function `filter_by_substring` that takes two parameters: a list of strings (`strings`) and a substring (`substring`). The function uses a list comprehension to filter the input list, keeping only those strings that contain the specified substring. The resulting list of filtered strings is then returned.\n\nHere's a step-by-step breakdown of the code:\n\n1. **Function Definition**: The function `filter_by_substring` is defined with two parameters: `strings` (a list of strings) and `substring` (a string).\n2. **List Comprehension**: A list comprehension is used to iterate over each string `s` in the input list `strings`. For each string, the condition `if substring in s` checks if the substring is present in the string `s`.\n3. **Return Statement**: The list comprehension generates a new list containing only the strings that satisfy the condition, and this list is returned by the function.\n\nThis approach is efficient and concise, leveraging Python's powerful list comprehension feature to filter the strings in a single line of code.\n\n"}
{"task_id": "CPP/24", "generation": "#include <iostream>\nusing namespace std;\n\nint largest_divisor(int n) {\n    for (int i = n - 1; i > 0; --i) {\n        if (n % i == 0) {\n            return i;\n        }\n    }\n    return 1; // In case no divisor is found, which should not happen for n > 1\n}\n\n", "py_code": "def largest_divisor(n):\n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i\n    return 1  # In case no divisor is found, which should not happen for n > 1\n", "py_summary": "The Python code defines a function `largest_divisor` that takes an integer `n` as input and returns the largest number that divides `n` evenly and is smaller than `n`. Here's a step-by-step analysis of the code:\n\n1. **Function Definition**: The function `largest_divisor` is defined to take a single parameter `n`.\n\n2. **Loop Initialization**: A `for` loop is initialized to iterate from `n-1` down to `1`. This is because we are looking for the largest divisor of `n` that is smaller than `n`.\n\n3. **Divisibility Check**: Inside the loop, the code checks if `n` is divisible by the current value of `i` using the modulus operator (`%`). If `n % i == 0`, it means `i` is a divisor of `n`.\n\n4. **Return the Divisor**: If a divisor is found, the function immediately returns `i`.\n\n5. **Default Return**: If the loop completes without finding any divisors (which should only happen if `n` is 1), the function returns `1`. However, for any `n > 1`, there will always be at least one divisor (1).\n\nThis approach ensures that the largest possible divisor is found efficiently by starting the search from the largest possible candidate and working downwards.\n\n"}
{"task_id": "CPP/79", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring decimal_to_binary(int decimal) {\n    if (decimal == 0) {\n        return \"db0db\";\n    }\n    string binary = \"\";\n    while (decimal > 0) {\n        binary = to_string(decimal % 2) + binary;\n        decimal = decimal / 2;\n    }\n    return \"db\" + binary + \"db\";\n}\n\n// Function to test the decimal_to_binary function\nvoid test_decimal_to_binary() {\n    cout << \"decimal_to_binary(15) = \" << decimal_to_binary(15) << endl; // Expected: \"db1111db\"\n    cout << \"decimal_to_binary(32) = \" << decimal_to_binary(32) << endl; // Expected: \"db100000db\"\n    cout << \"decimal_to_binary(0) = \" << decimal_to_binary(0) << endl;   // Expected: \"db0db\"\n}\n\n", "py_code": "def decimal_to_binary(decimal):\n    if decimal == 0:\n        return \"db0db\"\n    binary = \"\"\n    while decimal > 0:\n        binary = str(decimal % 2) + binary\n        decimal = decimal // 2\n    return f\"db{binary}db\"\n", "py_summary": "The Python code defines a function `decimal_to_binary` that converts a given decimal number to its binary representation and formats it with \"db\" at the beginning and end of the binary string.\n\n1. **Base Case Handling**: If the input decimal number is 0, the function immediately returns \"db0db\".\n2. **Binary Conversion**: For non-zero decimal numbers, the function initializes an empty string `binary`.\n3. **Loop for Conversion**: The function enters a loop where it repeatedly divides the decimal number by 2 and prepends the remainder (0 or 1) to the `binary` string. This process continues until the decimal number becomes 0.\n4. **Formatting**: After the loop, the function constructs the final string by concatenating \"db\" at the beginning and end of the `binary` string.\n5. **Return**: The function returns the formatted binary string.\n\nThis approach ensures that the binary representation is correctly formed and formatted as required."}
{"task_id": "CPP/155", "generation": "#include <iostream>\n#include <cmath>\n#include <string>\n#include <vector>\nusing namespace std;\n\nvector<int> even_odd_count(int num) {\n    // Convert the number to a string to iterate over each digit\n    string num_str = to_string(abs(num));\n    \n    // Initialize counters for even and odd digits\n    int even_count = 0;\n    int odd_count = 0;\n    \n    // Iterate over each character in the string\n    for (char char_digit : num_str) {\n        int digit = char_digit - '0'; // Convert character to integer\n        if (digit % 2 == 0) {\n            even_count += 1;\n        } else {\n            odd_count += 1;\n        }\n    }\n    \n    // Return the counts as a vector\n    return {even_count, odd_count};\n}\n\n// Function to test the even_odd_count function\nvoid test_even_odd_count() {\n    vector<int> result1 = even_odd_count(-12);\n    vector<int> expected1 = {1, 1};\n    cout << \"Test 1: \" << (result1 == expected1 ? \"Passed\" : \"Failed\") << endl;\n\n    vector<int> result2 = even_odd_count(123);\n    vector<int> expected2 = {1, 2};\n    cout << \"Test 2: \" << (result2 == expected2 ? \"Passed\" : \"Failed\") << endl;\n}\n\n", "py_code": "def even_odd_count(num):\n    # Convert the number to a string to iterate over each digit\n    num_str = str(abs(num))\n    \n    # Initialize counters for even and odd digits\n    even_count = 0\n    odd_count = 0\n    \n    # Iterate over each character in the string\n    for char in num_str:\n        digit = int(char)\n        if digit % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n    \n    # Return the counts as a list\n    return [even_count, odd_count]\n", "py_summary": "The Python code defines a function `even_odd_count` that takes an integer `num` as input and returns a list containing the count of even and odd digits in the number. Here's a step-by-step analysis of the code:\n\n1. **Convert the Number to a String**:\n   - The function first converts the absolute value of the input number to a string using `str(abs(num))`. This ensures that negative signs are ignored and each digit can be processed individually.\n\n2. **Initialize Counters**:\n   - Two counters, `even_count` and `odd_count`, are initialized to zero. These will keep track of the number of even and odd digits, respectively.\n\n3. **Iterate Over Each Digit**:\n   - The function iterates over each character in the string representation of the number using a for loop.\n   - For each character, it converts the character back to an integer using `int(char)` and checks if the digit is even or odd using the modulus operator `%`.\n\n4. **Update Counters**:\n   - If the digit is even (`digit % 2 == 0`), the `even_count` is incremented.\n   - If the digit is odd, the `odd_count` is incremented.\n\n5. **Return the Result**:\n   - After processing all digits, the function returns a list containing the counts of even and odd digits.\n\nThis approach ensures that the function correctly counts the even and odd digits in the input number and returns the counts in a list format."}
{"task_id": "CPP/4", "generation": "#include <iostream>\n#include <cmath>\n#include <vector>\nusing namespace std;\n\nfloat mean_absolute_deviation(vector<float> numbers) {\n    // Calculate the mean of the numbers\n    float sum = 0.0;\n    for (float num : numbers) {\n        sum += num;\n    }\n    float mean = sum / numbers.size();\n\n    // Calculate the sum of absolute differences\n    float abs_diff_sum = 0.0;\n    for (float num : numbers) {\n        abs_diff_sum += abs(num - mean);\n    }\n\n    // Calculate the Mean Absolute Deviation\n    float mad = abs_diff_sum / numbers.size();\n\n    return mad;\n}\n\n// Function to test the mean_absolute_deviation function\n", "py_code": "from typing import List\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    mean = sum(numbers) / len(numbers)\n    mad = sum(abs(x - mean) for x in numbers) / len(numbers)\n    return mad\n", "py_summary": "The Python code defines a function `mean_absolute_deviation` that calculates the Mean Absolute Deviation (MAD) of a list of numbers. Here's a step-by-step breakdown of how the function works:\n\n1. **Calculate the Mean**:\n   - The mean of the numbers is calculated by summing all the elements in the list and dividing by the number of elements (`len(numbers)`).\n\n2. **Calculate the Absolute Differences**:\n   - For each element in the list, the absolute difference between the element and the mean is calculated using a generator expression inside the `sum` function.\n\n3. **Calculate the Mean Absolute Deviation**:\n   - The sum of these absolute differences is then divided by the number of elements to get the average absolute difference, which is the Mean Absolute Deviation (MAD).\n\n4. **Return the Result**:\n   - The function returns the calculated MAD.\n\nThis approach ensures that the function correctly computes the MAD by following the mathematical definition of the Mean Absolute Deviation.\n\n### Summary:\n- **Input**: A list of floating-point numbers.\n- **Output**: A single floating-point number representing the Mean Absolute Deviation.\n- **Steps**:\n  1. Compute the mean of the input numbers.\n  2. Compute the sum of the absolute differences between each number and the mean.\n  3. Divide the sum by the number of elements to get the MAD.\n  4. Return the MAD."}
{"task_id": "CPP/56", "generation": "#include <iostream>\n#include <string>\n#include <stack>\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    stack<char> stack;\n    for (char ch : brackets) {\n        if (ch == '<') {\n            stack.push(ch);\n        } else if (ch == '>') {\n            if (stack.empty()) {\n                return false;\n            }\n            stack.pop();\n        }\n    }\n    return stack.empty();\n}\n\n", "py_code": "def correct_bracketing(brackets):\n    stack = []\n    for char in brackets:\n        if char == '<':\n            stack.append(char)\n        elif char == '>':\n            if not stack:\n                return False\n            stack.pop()\n    return len(stack) == 0\n", "py_summary": "The Python code defines a function `correct_bracketing` that checks if a string of angle brackets (`<` and `>`) is correctly bracketed. Here's a step-by-step analysis of the code:\n\n1. **Initialization**: \n   - A list `stack` is initialized to keep track of the opening brackets (`<`).\n\n2. **Iteration**:\n   - The function iterates through each character in the input string `brackets`.\n   - If the character is an opening bracket (`<`), it is pushed onto the stack.\n   - If the character is a closing bracket (`>`), the function checks if the stack is empty. If the stack is empty, it means there is no corresponding opening bracket for this closing bracket, and the function returns `False`.\n   - If the stack is not empty, the top element of the stack (an opening bracket) is popped off, indicating that the current closing bracket has a matching opening bracket.\n\n3. **Final Check**:\n   - After iterating through all characters, the function checks if the stack is empty. If the stack is empty, it means all opening brackets have been matched with closing brackets, and the function returns `True`. Otherwise, it returns `False`.\n\nThis approach ensures that the string is correctly bracketed by maintaining a stack to track the opening brackets and ensuring that each closing bracket has a corresponding opening bracket.\n\n"}
{"task_id": "CPP/159", "generation": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> eat(int number, int need, int remaining) {\n    int total_eaten = number + min(need, remaining);\n    int carrots_left = max(0, remaining - need);\n    return {total_eaten, carrots_left};\n}\n", "py_code": "def eat(number, need, remaining):\n    total_eaten = number + min(need, remaining)\n    carrots_left = max(0, remaining - need)\n    return [total_eaten, carrots_left]\n", "py_summary": "The Python code defines a function `eat` that takes three parameters: `number`, `need`, and `remaining`. These parameters represent the number of carrots already eaten, the number of carrots needed to complete the day's meals, and the number of carrots remaining in stock, respectively.\n\nHere's a step-by-step breakdown of how the function works:\n\n1. **Calculate Total Eaten Carrots**:\n   - The function calculates the total number of carrots eaten after the meal by adding the number of carrots already eaten (`number`) to the minimum of the number of carrots needed (`need`) and the number of carrots remaining (`remaining`). This ensures that the rabbit eats as many carrots as possible without exceeding the available stock.\n   - The expression `min(need, remaining)` ensures that the rabbit does not eat more carrots than are available.\n\n2. **Calculate Carrots Left**:\n   - The function calculates the number of carrots left after the meal by subtracting the number of carrots needed from the number of carrots remaining.\n   - The expression `max(0, remaining - need)` ensures that the number of carrots left is non-negative. If the number of carrots needed exceeds the number of carrots remaining, the result will be zero, indicating that all remaining carrots have been eaten.\n\n3. **Return the Result**:\n   - The function returns a list containing two elements: the total number of carrots eaten and the number of carrots left.\n\nThis approach ensures that the function correctly handles all edge cases, such as when there are not enough remaining carrots to satisfy the need.\n\n### Summary:\n- **Total Eaten Carrots**: `number + min(need, remaining)`\n- **Carrots Left**: `max(0, remaining - need)`\n- **Return Value**: `[total_eaten, carrots_left]`\n\nThis logic ensures that the rabbit eats as many carrots as possible and accurately reports the state after the meal."}
{"task_id": "CPP/83", "generation": "#include <iostream>\n#include <cmath>\nusing namespace std;\n\nint starts_one_ends(int n) {\n    if (n == 1) {\n        return 1;  // Only one 1-digit number starts and ends with 1, which is 1 itself.\n    }\n\n    // For n > 1, there are 9^(n-1) numbers that start with 1 and 9^(n-1) numbers that end with 1.\n    // However, we need to subtract the overlap (numbers that start and end with 1) to avoid double-counting.\n    int count_start_with_1 = pow(9, n - 1);\n    int count_end_with_1 = pow(9, n - 1);\n    int count_both_start_and_end_with_1 = (n > 1) ? pow(9, n - 2) : 0;\n\n    return count_start_with_1 + count_end_with_1 - count_both_start_and_end_with_1;\n}\n\n", "py_code": "def starts_one_ends(n):\n    if n == 1:\n        return 1  # Only one 1-digit number starts and ends with 1, which is 1 itself.\n    \n    # For n > 1, there are 9^(n-1) numbers that start with 1 and 9^(n-1) numbers that end with 1.\n    # However, we need to subtract the overlap (numbers that start and end with 1) to avoid double-counting.\n    count_start_with_1 = 9 ** (n - 1)\n    count_end_with_1 = 9 ** (n - 1)\n    count_both_start_and_end_with_1 = 9 ** (n - 2) if n > 1 else 0\n    \n    return count_start_with_1 + count_end_with_1 - count_both_start_and_end_with_1\n", "py_summary": "The Python code defines a function `starts_one_ends` that calculates the count of n-digit positive integers that start or end with 1. Here's a detailed breakdown of the logic:\n\n1. **Base Case (n == 1)**:\n   - If `n` is 1, there is only one 1-digit number that starts and ends with 1, which is 1 itself. Therefore, the function returns 1.\n\n2. **General Case (n > 1)**:\n   - For `n > 1`, we need to consider two sets of numbers:\n     - Numbers that start with 1.\n     - Numbers that end with 1.\n   - There are `9^(n-1)` numbers that start with 1 because the remaining `n-1` digits can be any digit from 0 to 9 except 0 (since the number must be n-digit).\n   - Similarly, there are `9^(n-1)` numbers that end with 1.\n   - However, we need to subtract the overlap (numbers that start and end with 1) to avoid double-counting. There are `9^(n-2)` such numbers if `n > 1`.\n\n3. **Final Calculation**:\n   - The total count is the sum of the numbers that start with 1 and the numbers that end with 1, minus the overlap.\n   - The function returns this final count.\n\nThis approach ensures that we correctly count all n-digit numbers that start or end with 1 without double-counting those that both start and end with 1."}
{"task_id": "CPP/27", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring flip_case(string str) {\n    for (char &c : str) {\n        if (islower(c)) {\n            c = toupper(c);\n        } else if (isupper(c)) {\n            c = tolower(c);\n        }\n    }\n    return str;\n}\n\n", "py_code": "def flip_case(s):\n    return s.swapcase()\n", "py_summary": "The Python code defines a function `flip_case` that takes a string `s` as input and returns a new string where all lowercase characters are converted to uppercase and all uppercase characters are converted to lowercase. This is achieved using the built-in `swapcase()` method, which performs the case flipping operation efficiently.\n\nHere's a breakdown of the code:\n1. **Function Definition**: The function `flip_case` is defined to take a single parameter `s`, which is the input string.\n2. **Case Flipping**: The `swapcase()` method is called on the input string `s`. This method returns a new string where each uppercase character is converted to lowercase and each lowercase character is converted to uppercase.\n3. **Return Result**: The function returns the new string with flipped cases.\n\nThis approach is concise and leverages Python's built-in string manipulation capabilities to achieve the desired result.\n\n"}
{"task_id": "CPP/146", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\nusing namespace std;\n\nbool is_odd_digit(int digit) {\n    return digit % 2 != 0;\n}\n\nbool first_last_odd(int num) {\n    string num_str = to_string(abs(num));\n    int first_digit = num_str[0] - '0';\n    int last_digit = num_str.back() - '0';\n    return is_odd_digit(first_digit) && is_odd_digit(last_digit);\n}\n\nint specialFilter(vector<int> nums) {\n    int count = 0;\n    for (int num : nums) {\n        if (num > 10 && first_last_odd(num)) {\n            count++;\n        }\n    }\n    return count;\n}\n\n// Test cases\n", "py_code": "def specialFilter(nums):\n    def is_odd_digit(n):\n        return n % 2 != 0\n\n    def first_last_odd(num):\n        num_str = str(abs(num))\n        first_digit = int(num_str[0])\n        last_digit = int(num_str[-1])\n        return is_odd_digit(first_digit) and is_odd_digit(last_digit)\n\n    count = 0\n    for num in nums:\n        if num > 10 and first_last_odd(num):\n            count += 1\n    return count\n", "py_summary": "The Python code defines a function `specialFilter` that takes a list of integers as input and returns the number of elements in the list that meet the following criteria:\n1. The element is greater than 10.\n2. Both the first and last digits of the element are odd (1, 3, 5, 7, 9).\n\nThe function works as follows:\n1. It defines a helper function `is_odd_digit` that checks if a given digit is odd.\n2. It defines another helper function `first_last_odd` that checks if both the first and last digits of a number are odd. This function converts the number to a string to easily access the first and last characters, converts them back to integers, and uses the `is_odd_digit` function to check if they are odd.\n3. It initializes a counter `count` to zero.\n4. It iterates through each number in the input list `nums`.\n   - For each number, it checks if the number is greater than 10 and if both the first and last digits are odd using the `first_last_odd` function.\n   - If both conditions are met, it increments the counter `count`.\n5. Finally, it returns the value of `count`.\n\nThis approach ensures that the function correctly counts the number of elements in the list that satisfy the given conditions."}
{"task_id": "CPP/81", "generation": "#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nvector<string> numerical_letter_grade(vector<float> grades) {\n    vector<string> letter_grades;\n    for (float gpa : grades) {\n        if (gpa == 4.0) {\n            letter_grades.push_back(\"A+\");\n        } else if (gpa > 3.7) {\n            letter_grades.push_back(\"A\");\n        } else if (gpa > 3.3) {\n            letter_grades.push_back(\"A-\");\n        } else if (gpa > 3.0) {\n            letter_grades.push_back(\"B+\");\n        } else if (gpa > 2.7) {\n            letter_grades.push_back(\"B\");\n        } else if (gpa > 2.3) {\n            letter_grades.push_back(\"B-\");\n        } else if (gpa > 2.0) {\n            letter_grades.push_back(\"C+\");\n        } else if (gpa > 1.7) {\n            letter_grades.push_back(\"C\");\n        } else if (gpa > 1.3) {\n            letter_grades.push_back(\"C-\");\n        } else if (gpa > 1.0) {\n            letter_grades.push_back(\"D+\");\n        } else if (gpa > 0.7) {\n            letter_grades.push_back(\"D\");\n        } else if (gpa > 0.0) {\n            letter_grades.push_back(\"D-\");\n        } else {\n            letter_grades.push_back(\"E\");\n        }\n    }\n    return letter_grades;\n}\n\n", "py_code": "def numerical_letter_grade(grades):\n    grade_mapping = {\n        4.0: 'A+',\n        3.7: 'A',\n        3.3: 'A-',\n        3.0: 'B+',\n        2.7: 'B',\n        2.3: 'B-',\n        2.0: 'C+',\n        1.7: 'C',\n        1.3: 'C-',\n        1.0: 'D+',\n        0.7: 'D',\n        0.0: 'D-'\n    }\n    \n    def get_letter_grade(gpa):\n        if gpa == 4.0:\n            return grade_mapping[4.0]\n        elif gpa > 3.7:\n            return grade_mapping[3.7]\n        elif gpa > 3.3:\n            return grade_mapping[3.3]\n        elif gpa > 3.0:\n            return grade_mapping[3.0]\n        elif gpa > 2.7:\n            return grade_mapping[2.7]\n        elif gpa > 2.3:\n            return grade_mapping[2.3]\n        elif gpa > 2.0:\n            return grade_mapping[2.0]\n        elif gpa > 1.7:\n            return grade_mapping[1.7]\n        elif gpa > 1.3:\n            return grade_mapping[1.3]\n        elif gpa > 1.0:\n            return grade_mapping[1.0]\n        elif gpa > 0.7:\n            return grade_mapping[0.7]\n        elif gpa > 0.0:\n            return grade_mapping[0.0]\n        else:\n            return 'E'\n    \n    return [get_letter_grade(gpa) for gpa in grades]\n\n", "py_summary": "The Python code defines a function `numerical_letter_grade` that converts a list of numerical GPAs into their corresponding letter grades based on a predefined grading scale. Here's a detailed breakdown of how the code works:\n\n1. **Grade Mapping Dictionary**:\n   - A dictionary `grade_mapping` is created to map specific GPA values to their corresponding letter grades. This dictionary is used to look up the letter grades for certain GPA thresholds.\n\n2. **Helper Function `get_letter_grade`**:\n   - This function takes a single GPA value as input and returns the corresponding letter grade.\n   - It uses a series of `if-elif-else` statements to check the GPA value against the thresholds defined in the grading scale.\n   - For each threshold, it returns the appropriate letter grade from the `grade_mapping` dictionary.\n   - If the GPA is exactly 4.0, it directly returns 'A+'.\n   - If the GPA is less than or equal to 0.0, it returns 'E'.\n\n3. **Main Function `numerical_letter_grade`**:\n   - This function takes a list of GPAs as input.\n   - It uses a list comprehension to apply the `get_letter_grade` function to each GPA in the input list.\n   - The result is a list of letter grades corresponding to the input GPAs.\n\n4. **Return Statement**:\n   - The function returns the list of letter grades.\n\nThis approach ensures that the grading logic is encapsulated in a clear and modular way, making the code easy to understand and maintain. The use of a dictionary and a helper function makes the code more readable and efficient.\n\n### Summary\n- **Input**: A list of numerical GPAs.\n- **Output**: A list of corresponding letter grades.\n- **Logic**: Uses a dictionary for mapping and a helper function to determine the letter grade for each GPA based on predefined thresholds."}
{"task_id": "CPP/136", "generation": "#include <vector>\n#include <limits>\nusing namespace std;\n\nvector<int> largest_smallest_integers(vector<int> lst) {\n    int largest_negative = numeric_limits<int>::min();\n    int smallest_positive = numeric_limits<int>::max();\n\n    for (int num : lst) {\n        if (num < 0) {\n            if (num > largest_negative) {\n                largest_negative = num;\n            }\n        } else if (num > 0) {\n            if (num < smallest_positive) {\n                smallest_positive = num;\n            }\n        }\n    }\n\n    // If no negative or positive integers were found, set them to 0\n    if (largest_negative == numeric_limits<int>::min()) {\n        largest_negative = 0;\n    }\n    if (smallest_positive == numeric_limits<int>::max()) {\n        smallest_positive = 0;\n    }\n\n    return {largest_negative, smallest_positive};\n}\n", "py_code": "def largest_smallest_integers(lst):\n    largest_negative = None\n    smallest_positive = None\n\n    for num in lst:\n        if num < 0:\n            if largest_negative is None or num > largest_negative:\n                largest_negative = num\n        elif num > 0:\n            if smallest_positive is None or num < smallest_positive:\n                smallest_positive = num\n\n    return [largest_negative if largest_negative is not None else 0, smallest_positive if smallest_positive is not None else 0]\n", "py_summary": "The Python code defines a function `largest_smallest_integers` that takes a list of integers as input and returns a list of two integers. The first integer in the returned list is the largest negative integer in the input list, and the second integer is the smallest positive integer. If there are no negative or positive integers in the input list, the function returns 0 for those positions.\n\nHere's a step-by-step breakdown of the code:\n\n1. **Initialization**:\n   - `largest_negative` is initialized to `None`. This will store the largest negative integer found in the list.\n   - `smallest_positive` is initialized to `None`. This will store the smallest positive integer found in the list.\n\n2. **Iteration**:\n   - The function iterates through each number in the input list `lst`.\n   - For each number:\n     - If the number is negative (`num < 0`):\n       - Check if `largest_negative` is `None` or if the current number is greater than `largest_negative`. If so, update `largest_negative` to the current number.\n     - If the number is positive (`num > 0`):\n       - Check if `smallest_positive` is `None` or if the current number is smaller than `smallest_positive`. If so, update `smallest_positive` to the current number.\n\n3. **Return**:\n   - After the iteration, the function returns a list containing:\n     - `largest_negative` if it is not `None`, otherwise 0.\n     - `smallest_positive` if it is not `None`, otherwise 0.\n\nThis approach ensures that the function correctly identifies the largest negative and smallest positive integers in the list, or returns 0 if no such integers exist."}
{"task_id": "CPP/67", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <stdexcept>\n\nint fruit_distribution(const std::string& s, int n) {\n    // Initialize variables to store the number of apples and oranges\n    int apples = 0, oranges = 0;\n\n    // Create a stringstream object to parse the input string\n    std::istringstream iss(s);\n\n    // Parse the string to extract the number of apples and oranges\n    std::string token;\n    while (iss >> token) {\n        if (token == \"apples\" && !iss.eof()) {\n            iss >> token;\n            apples = std::stoi(token);\n        } else if (token == \"oranges\" && !iss.eof()) {\n            iss >> token;\n            oranges = std::stoi(token);\n        }\n    }\n\n    // Calculate the number of mangoes\n    int mangoes = n - (apples + oranges);\n\n    // Return the number of mangoes\n    return mangoes;\n}\n\n// Function to test the fruit_distribution function\nvoid test_fruit_distribution() {\n    std::cout << fruit_distribution(\"5 apples and 6 oranges\", 19) << \" (Expected: 8)\" << std::endl;\n    std::cout << fruit_distribution(\"0 apples and 1 oranges\", 3) << \" (Expected: 2)\" << std::endl;\n    std::cout << fruit_distribution(\"2 apples and 3 oranges\", 100) << \" (Expected: 95)\" << std::endl;\n    std::cout << fruit_distribution(\"100 apples and 1 oranges\", 120) << \" (Expected: 19)\" << std::endl;\n}\n\n", "py_code": "import re\n\ndef fruit_distribution(s, n):\n    # Extract the number of apples and oranges using regular expressions\n    match = re.search(r'(\\d+) apples and (\\d+) oranges', s)\n    if match:\n        apples = int(match.group(1))\n        oranges = int(match.group(2))\n        # Calculate the number of mangoes\n        mangoes = n - (apples + oranges)\n        return mangoes\n    else:\n        raise ValueError(\"Input string does not match the expected format.\")\n", "py_summary": "The Python code defines a function `fruit_distribution` that takes a string `s` and an integer `n` as input. The string `s` represents the number of apples and oranges in the basket, and the integer `n` represents the total number of fruits in the basket. The function aims to calculate and return the number of mangoes in the basket.\n\nHere's a step-by-step analysis of the code:\n\n1. **Importing the `re` module**: The `re` module is imported to use regular expressions for extracting the number of apples and oranges from the input string.\n\n2. **Using a regular expression to extract numbers**:\n   - The `re.search` function is used to search for a pattern in the input string `s`.\n   - The pattern `r'(\\d+) apples and (\\d+) oranges'` matches two groups of digits separated by the words \"apples and\" and \"oranges\".\n   - If a match is found, the `match.group(1)` and `match.group(2)` methods are used to extract the number of apples and oranges, respectively.\n\n3. **Converting extracted strings to integers**:\n   - The extracted strings are converted to integers using the `int` function.\n\n4. **Calculating the number of mangoes**:\n   - The number of mangoes is calculated by subtracting the sum of apples and oranges from the total number of fruits `n`.\n\n5. **Returning the result**:\n   - The function returns the number of mangoes.\n\n6. **Error handling**:\n   - If the input string does not match the expected format, a `ValueError` is raised with an appropriate error message.\n\nThis approach ensures that the function correctly parses the input string and performs the necessary calculations to determine the number of mangoes in the basket."}
{"task_id": "CPP/48", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_palindrome(string text) {\n    int left = 0;\n    int right = text.length() - 1;\n    \n    while (left < right) {\n        if (text[left] != text[right]) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n    return true;\n}\n\n", "py_code": "def is_palindrome(text):\n    return text == text[::-1]\n", "py_summary": "The Python code defines a function `is_palindrome` that checks whether a given string is a palindrome. A palindrome is a string that reads the same forwards and backwards. The function works by comparing the original string with its reverse. If they are the same, the function returns `True`, indicating that the string is a palindrome. Otherwise, it returns `False`.\n\nHere's a step-by-step breakdown of the code:\n1. The function `is_palindrome` takes a single argument `text`, which is the string to be checked.\n2. The expression `text[::-1]` creates a reversed version of the string `text`.\n3. The function compares the original string `text` with its reversed version using the equality operator `==`.\n4. If the original string and the reversed string are the same, the function returns `True`. Otherwise, it returns `False`.\n\nThis approach is simple and efficient for checking palindromes.\n\n"}
{"task_id": "CPP/125", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <cassert>\nusing namespace std;\n\nvector<string> split_words(const string& txt) {\n    // Check for whitespace\n    if (txt.find(' ') != string::npos) {\n        stringstream ss(txt);\n        vector<string> words;\n        string word;\n        while (ss >> word) {\n            words.push_back(word);\n        }\n        return words;\n    }\n\n    // Check for commas\n    if (txt.find(',') != string::npos) {\n        stringstream ss(txt);\n        vector<string> words;\n        string word;\n        while (getline(ss, word, ',')) {\n            words.push_back(word);\n        }\n        return words;\n    }\n\n    // Count lowercase letters with odd order\n    int count = 0;\n    for (char c : txt) {\n        if (islower(c) && ((c - 'a') % 2 == 1)) {\n            count++;\n        }\n    }\n    return {to_string(count)};\n}\n\n// Function to test the split_words function\nvoid test_split_words() {\n    vector<string> result1 = split_words(\"Hello world!\");\n    assert((result1 == vector<string>{\"Hello\", \"world!\"}));\n\n    vector<string> result2 = split_words(\"Hello,world!\");\n    assert((result2 == vector<string>{\"Hello\", \"world!\"}));\n\n    vector<string> result3 = split_words(\"abcdef\");\n    assert((result3 == vector<string>{\"3\"}));\n\n    cout << \"All tests passed!\" << endl;\n}\n\n", "py_code": "def split_words(txt):\n    if ' ' in txt:\n        return txt.split()\n    elif ',' in txt:\n        return txt.split(',')\n    else:\n        count = sum(1 for c in txt if c.islower() and (ord(c) - ord('a')) % 2 == 1)\n        return [str(count)]\n", "py_summary": "The Python code defines a function `split_words` that takes a string `txt` as input and returns a list of words based on the following rules:\n\n1. **Whitespace Splitting**: If the string contains any whitespace characters, it splits the string on whitespace and returns the resulting list of words.\n2. **Comma Splitting**: If the string does not contain any whitespace but contains commas, it splits the string on commas and returns the resulting list of words.\n3. **Counting Lowercase Letters with Odd Order**: If the string contains neither whitespace nor commas, it counts the number of lowercase letters in the string that have an odd order in the alphabet (where 'a' has an order of 0, 'b' has an order of 1, etc.). It then returns a list containing a single string representation of this count.\n\nThe function uses the `split` method to handle the splitting on whitespace and commas. For counting the lowercase letters with odd order, it uses a generator expression inside the `sum` function to iterate over the characters in the string, check if they are lowercase, and if their order is odd. The result is converted to a string and returned as a single-element list.\n\n### Summary:\n- **Whitespace Splitting**: `txt.split()`\n- **Comma Splitting**: `txt.split(',')`\n- **Counting Lowercase Letters with Odd Order**: `sum(1 for c in txt if c.islower() and (ord(c) - ord('a')) % 2 == 1)`\n\nThis approach ensures that the function handles all three cases as specified in the problem statement."}
{"task_id": "CPP/160", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\nint do_algebra(vector<string> operators, vector<int> operands) {\n    // Initialize the result with the first operand\n    int result = operands[0];\n    \n    // Iterate through the operators and operands\n    for (size_t i = 0; i < operators.size(); ++i) {\n        if (operators[i] == \"+\") {\n            result += operands[i + 1];\n        } else if (operators[i] == \"-\") {\n            result -= operands[i + 1];\n        } else if (operators[i] == \"*\") {\n            result *= operands[i + 1];\n        } else if (operators[i] == \"//\") {\n            result /= operands[i + 1]; // Floor division in C++ is done using the / operator\n        } else if (operators[i] == \"**\") {\n            result = pow(result, operands[i + 1]);\n        }\n    }\n    \n    return result;\n}\n\n// Function to test the do_algebra function\nvoid test_do_algebra() {\n    vector<string> operators1 = {\"+\", \"*\", \"-\"};\n    vector<int> operands1 = {2, 3, 4, 5};\n    assert(do_algebra(operators1, operands1) == 9);\n\n    vector<string> operators2 = {\"-\", \"*\", \"+\"};\n    vector<int> operands2 = {10, 5, 2, 3};\n    assert(do_algebra(operators2, operands2) == 13);\n\n    vector<string> operators3 = {\"**\", \"//\", \"+\"};\n    vector<int> operands3 = {2, 3, 4, 5};\n    assert(do_algebra(operators3, operands3) == 13);\n\n    cout << \"All tests passed!\" << endl;\n}\n\n", "py_code": "def do_algebra(operators, operands):\n    # Initialize the result with the first operand\n    result = operands[0]\n    \n    # Iterate through the operators and operands\n    for i, op in enumerate(operators):\n        if op == '+':\n            result += operands[i + 1]\n        elif op == '-':\n            result -= operands[i + 1]\n        elif op == '*':\n            result *= operands[i + 1]\n        elif op == '//':\n            result //= operands[i + 1]\n        elif op == '**':\n            result **= operands[i + 1]\n    \n    return result\n", "py_summary": "The Python code defines a function `do_algebra` that takes two parameters: `operators` (a list of strings representing algebraic operations) and `operands` (a list of integers). The function evaluates the algebraic expression formed by these operators and operands and returns the result.\n\nHere's a step-by-step analysis of the code:\n\n1. **Initialization**:\n   - The function initializes the `result` variable with the first element of the `operands` list. This is because the first operand does not have an operator preceding it.\n\n2. **Iteration**:\n   - The function uses a `for` loop to iterate through the `operators` list. The loop variable `i` is used to index both the `operators` and `operands` lists.\n   - For each operator, the function checks the type of operation and applies it to the `result` and the next operand (`operands[i + 1]`).\n\n3. **Operations**:\n   - **Addition (`+`)**: Adds the next operand to the `result`.\n   - **Subtraction (`-`)**: Subtracts the next operand from the `result`.\n   - **Multiplication (`*`)**: Multiplies the `result` by the next operand.\n   - **Floor Division (`//`)**: Performs floor division of the `result` by the next operand.\n   - **Exponentiation (`**`)**: Raises the `result` to the power of the next operand.\n\n4. **Return**:\n   - After processing all the operators and operands, the function returns the final value of `result`.\n\nThis approach ensures that the algebraic expression is evaluated correctly according to the given operators and operands.\n\n"}
{"task_id": "CPP/151", "generation": "#include <iostream>\n#include <cmath>\n#include <vector>\nusing namespace std;\n\nlong long double_the_difference(vector<float> lst) {\n    long long sum = 0;\n    for (float x : lst) {\n        if (x > 0 && floor(x) == x && static_cast<int>(x) % 2 != 0) {\n            sum += static_cast<long long>(pow(x, 2));\n        }\n    }\n    return sum;\n}\n\n", "py_code": "def double_the_difference(lst):\n    return sum(x**2 for x in lst if x > 0 and x == int(x) and x % 2 != 0)\n", "py_summary": "The Python code defines a function `double_the_difference` that takes a list of numbers as input and returns the sum of the squares of the numbers that are odd, positive, and integers. Here's a step-by-step breakdown of how the function works:\n\n1. **List Comprehension**: The function uses a list comprehension to filter and process the input list `lst`.\n   - `x**2`: This computes the square of each number `x`.\n   - `for x in lst`: This iterates over each element `x` in the input list `lst`.\n   - `if x > 0 and x == int(x) and x % 2 != 0`: This is the filtering condition:\n     - `x > 0`: Ensures the number is positive.\n     - `x == int(x)`: Ensures the number is an integer (by checking if it equals its integer representation).\n     - `x % 2 != 0`: Ensures the number is odd.\n\n2. **Sum Function**: The `sum` function is used to add up all the squared values that meet the filtering conditions.\n\n3. **Return Value**: The function returns the computed sum.\n\nThis approach ensures that only positive, integer, and odd numbers are considered, and their squares are summed up.\n\n"}
{"task_id": "CPP/117", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\nusing namespace std;\n\nbool is_consonant(char c) {\n    string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    return consonants.find(c) != string::npos;\n}\n\nint count_consonants(const string& word) {\n    int count = 0;\n    for (char c : word) {\n        if (is_consonant(c)) {\n            count++;\n        }\n    }\n    return count;\n}\n\nvector<string> select_words(const string& s, int n) {\n    vector<string> result;\n    stringstream ss(s);\n    string word;\n    while (ss >> word) {\n        if (count_consonants(word) == n) {\n            result.push_back(word);\n        }\n    }\n    return result;\n}\n\n// Test cases\n", "py_code": "def count_consonants(word):\n    consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\n    return sum(1 for char in word if char in consonants)\n\ndef select_words(s, n):\n    words = s.split()\n    result = [word for word in words if count_consonants(word) == n]\n    return result\n", "py_summary": "The Python code defines a function `select_words` that takes a string `s` and an integer `n` as input and returns a list of words from the string `s` that contain exactly `n` consonants. Here's a detailed breakdown of how the code works:\n\n1. **Helper Function `count_consonants`**:\n   - This function takes a single word as input and counts the number of consonants in it.\n   - It uses a predefined string `consonants` which contains all the consonant letters (both uppercase and lowercase).\n   - It iterates over each character in the word and checks if it is in the `consonants` string. If it is, it increments the count.\n   - The function returns the total count of consonants in the word.\n\n2. **Main Function `select_words`**:\n   - This function takes a string `s` and an integer `n` as input.\n   - It splits the string `s` into a list of words using the `split()` method, which splits the string at spaces.\n   - It then uses a list comprehension to filter the words that have exactly `n` consonants. It does this by calling the `count_consonants` function on each word and checking if the result is equal to `n`.\n   - The function returns the list of filtered words.\n\nThis approach ensures that the function efficiently finds and returns the words with the specified number of consonants, maintaining the order in which they appear in the original string.\n\n"}
{"task_id": "CPP/78", "generation": "#include <iostream>\n#include <string>\n#include <unordered_set>\nusing namespace std;\n\nint hex_key(string num) {\n    // Define the set of prime hexadecimal digits\n    unordered_set<char> prime_hex_digits = {'2', '3', '5', '7', 'B', 'D'};\n    \n    // Initialize the count of prime hexadecimal digits\n    int count = 0;\n    \n    // Iterate over each character in the input string\n    for (char digit : num) {\n        // Check if the digit is in the set of prime hexadecimal digits\n        if (prime_hex_digits.find(digit) != prime_hex_digits.end()) {\n            count++;\n        }\n    }\n    \n    return count;\n}\n\n// Function to test the hex_key function\nvoid test_hex_key() {\n    cout << hex_key(\"AB\") << \" (Expected: 1)\" << endl;\n    cout << hex_key(\"1077E\") << \" (Expected: 2)\" << endl;\n    cout << hex_key(\"ABED1A33\") << \" (Expected: 4)\" << endl;\n    cout << hex_key(\"123456789ABCDEF0\") << \" (Expected: 6)\" << endl;\n    cout << hex_key(\"2020\") << \" (Expected: 2)\" << endl;\n}\n\n", "py_code": "def hex_key(num):\n    # Define the set of prime hexadecimal digits\n    prime_hex_digits = {'2', '3', '5', '7', 'B', 'D'}\n    \n    # Count the number of prime hexadecimal digits in the input string\n    count = sum(1 for digit in num if digit in prime_hex_digits)\n    \n    return count\n", "py_summary": "The Python code defines a function `hex_key` that takes a hexadecimal number as a string and counts the number of hexadecimal digits that are prime. Here's a breakdown of how the code works:\n\n1. **Define the Set of Prime Hexadecimal Digits**:\n   - The set `prime_hex_digits` contains the hexadecimal digits that are prime: `'2'`, `'3'`, `'5'`, `'7'`, `'B'`, and `'D'`.\n\n2. **Count the Prime Hexadecimal Digits**:\n   - The function uses a generator expression inside the `sum` function to iterate over each character in the input string `num`.\n   - For each character, it checks if the character is in the `prime_hex_digits` set.\n   - If the character is a prime hexadecimal digit, it contributes `1` to the sum.\n   - The `sum` function adds up all these `1`s to get the total count of prime hexadecimal digits.\n\n3. **Return the Count**:\n   - The function returns the total count of prime hexadecimal digits found in the input string.\n\nThis approach is efficient and straightforward, leveraging Python's set membership check and generator expressions for concise and readable code. The function assumes that the input string is always valid and contains only uppercase hexadecimal digits, as specified in the problem statement."}
{"task_id": "CPP/74", "generation": "#include <vector>\n#include <string>\nusing namespace std;\n\n// Helper function to count the total number of characters in a vector of strings\nint count_chars(const vector<string>& lst) {\n    int total = 0;\n    for (const string& s : lst) {\n        total += s.length();\n    }\n    return total;\n}\n\n// Main function to determine which vector has fewer total characters\nvector<string> total_match(vector<string> lst1, vector<string> lst2) {\n    int count1 = count_chars(lst1);\n    int count2 = count_chars(lst2);\n\n    if (count1 <= count2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n", "py_code": "def total_match(lst1, lst2):\n    def count_chars(lst):\n        return sum(len(s) for s in lst)\n    \n    if count_chars(lst1) <= count_chars(lst2):\n        return lst1\n    else:\n        return lst2\n", "py_summary": "The Python code defines a function `total_match` that takes two lists of strings (`lst1` and `lst2`) as input and returns the list with the fewer total characters. If both lists have the same total number of characters, it returns the first list (`lst1`).\n\nHere's a step-by-step breakdown of the code:\n\n1. **Helper Function `count_chars`**:\n   - This function takes a list of strings as input and returns the total number of characters in all the strings combined.\n   - It uses a generator expression inside the `sum` function to calculate the total length of all strings in the list.\n\n2. **Main Function `total_match`**:\n   - It first calls the `count_chars` function to get the total number of characters in `lst1` and `lst2`.\n   - It then compares these totals:\n     - If the total number of characters in `lst1` is less than or equal to the total number of characters in `lst2`, it returns `lst1`.\n     - Otherwise, it returns `lst2`.\n\nThis approach ensures that the function correctly identifies and returns the list with fewer characters, or the first list if they have the same number of characters.\n\n"}
{"task_id": "CPP/53", "generation": "#include <stdio.h>\n#include <stdlib.h>\nusing namespace std;\n\nint add(int x, int y) {\n    return x + y;\n}\n\n// Function to test the add function\nvoid test_add() {\n    int result1 = add(2, 3);\n    int result2 = add(5, 7);\n    printf(\"add(2, 3) = %d\\n\", result1); // Expected output: 5\n    printf(\"add(5, 7) = %d\\n\", result2); // Expected output: 12\n}\n\n", "py_code": "def add(x, y):\n    return x + y\n", "py_summary": "The Python code defines a simple function named `add` that takes two integer arguments, `x` and `y`. The function returns the sum of these two integers. The implementation is straightforward and uses the addition operator `+` to compute the sum.\n\nHere's a breakdown of the code:\n1. **Function Definition**: The function `add` is defined with two parameters, `x` and `y`.\n2. **Return Statement**: The function returns the result of adding `x` and `y`.\n\nThis function can handle any two integers and will correctly return their sum.\n\n### Example Usage:\n```python\nprint(add(2, 3))  # Output: 5\nprint(add(5, 7))  # Output: 12\n```\n\nThe function works as expected and is simple to understand and use."}
{"task_id": "CPP/98", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint count_upper(const string& s) {\n    string vowels = \"AEIOU\";\n    int count = 0;\n    for (size_t i = 0; i < s.length(); i += 2) {\n        if (vowels.find(s[i]) != string::npos) {\n            count++;\n        }\n    }\n    return count;\n}\n\n// Test cases\n", "py_code": "def count_upper(s):\n    vowels = \"AEIOU\"\n    count = 0\n    for i in range(0, len(s), 2):\n        if s[i] in vowels:\n            count += 1\n    return count\n", "py_summary": "The Python code defines a function `count_upper` that takes a string `s` as input and returns the number of uppercase vowels at even indices in the string. Here's a breakdown of how the function works:\n\n1. **Initialization**:\n   - `vowels = \"AEIOU\"`: This string contains all the uppercase vowels.\n   - `count = 0`: This variable is initialized to zero and will be used to keep track of the number of uppercase vowels found at even indices.\n\n2. **Iteration**:\n   - The function uses a `for` loop to iterate over the string `s` with a step of 2, starting from index 0. This ensures that only even indices are considered.\n   - For each character at an even index, the function checks if the character is in the `vowels` string using the `in` operator.\n   - If the character is an uppercase vowel, the `count` is incremented by 1.\n\n3. **Return**:\n   - After the loop completes, the function returns the `count`, which represents the number of uppercase vowels at even indices in the string.\n\nThis approach ensures that the function efficiently counts the desired characters by only examining every other character in the string, starting from the first character."}
{"task_id": "CPP/140", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring fix_spaces(string text) {\n    string result;\n    int consecutive_spaces = 0;\n\n    for (char ch : text) {\n        if (ch == ' ') {\n            consecutive_spaces += 1;\n        } else {\n            if (consecutive_spaces == 1) {\n                result += '_';\n            } else if (consecutive_spaces > 1) {\n                result += '-';\n            }\n            consecutive_spaces = 0;\n            result += ch;\n        }\n    }\n\n    if (consecutive_spaces == 1) {\n        result += '_';\n    } else if (consecutive_spaces > 1) {\n        result += '-';\n    }\n\n    return result;\n}\n\n", "py_code": "def fix_spaces(text):\n    result = []\n    consecutive_spaces = 0\n\n    for char in text:\n        if char == ' ':\n            consecutive_spaces += 1\n        else:\n            if consecutive_spaces == 1:\n                result.append('_')\n            elif consecutive_spaces > 1:\n                result.append('-')\n            consecutive_spaces = 0\n            result.append(char)\n\n    if consecutive_spaces == 1:\n        result.append('_')\n    elif consecutive_spaces > 1:\n        result.append('-')\n\n    return ''.join(result)\n", "py_summary": "The Python code defines a function `fix_spaces` that takes a string `text` as input and returns a new string with spaces replaced according to the following rules:\n1. Single spaces are replaced with underscores (`_`).\n2. Consecutive spaces (more than 2) are replaced with a single hyphen (`-`).\n\nHere's a step-by-step breakdown of how the function works:\n1. **Initialization**: \n   - `result` is an empty list that will store the characters of the modified string.\n   - `consecutive_spaces` is a counter initialized to 0 to keep track of consecutive spaces.\n\n2. **Iterate through the string**:\n   - For each character in the input string `text`, check if it is a space.\n   - If it is a space, increment the `consecutive_spaces` counter.\n   - If it is not a space:\n     - Check the value of `consecutive_spaces`:\n       - If `consecutive_spaces` is 1, append an underscore (`_`) to `result`.\n       - If `consecutive_spaces` is greater than 1, append a hyphen (`-`) to `result`.\n     - Reset `consecutive_spaces` to 0.\n     - Append the current character to `result`.\n\n3. **Final check**:\n   - After the loop, if there are any trailing spaces, handle them:\n     - If `consecutive_spaces` is 1, append an underscore (`_`) to `result`.\n     - If `consecutive_spaces` is greater than 1, append a hyphen (`-`) to `result`.\n\n4. **Return the result**:\n   - Convert the list `result` to a string using `''.join(result)` and return it.\n\nThis approach ensures that all spaces are handled correctly according to the specified rules."}
{"task_id": "CPP/34", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> unique(vector<int> l) {\n    // Sort the vector\n    sort(l.begin(), l.end());\n    \n    // Remove duplicates using unique and erase\n    auto last = unique(l.begin(), l.end());\n    l.erase(last, l.end());\n    \n    return l;\n}\n\n", "py_code": "def unique(l):\n    return sorted(set(l))\n", "py_summary": "The Python code defines a function `unique` that takes a list `l` as input and returns a new list containing the unique elements of `l`, sorted in ascending order. Here's a breakdown of how the function works:\n\n1. **Set Conversion**: The `set(l)` function call converts the list `l` into a set. Sets automatically remove duplicate elements, ensuring that only unique elements remain.\n2. **Sorting**: The `sorted()` function is then called on the set to convert it back into a list and sort the elements in ascending order.\n3. **Return**: The sorted list of unique elements is returned.\n\nThis approach is efficient and concise, leveraging Python's built-in data structures and functions to achieve the desired result.\n\n"}
{"task_id": "CPP/66", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint digitSum(string s) {\n    int sum = 0;\n    for (char c : s) {\n        if (isupper(c)) {\n            sum += static_cast<int>(c);\n        }\n    }\n    return sum;\n}\n\n// Test cases to verify the correctness of the function\n", "py_code": "def digit_sum(s):\n    return sum(ord(c) for c in s if c.isupper())\n", "py_summary": "The Python code defines a function `digit_sum` that takes a string `s` as input and returns the sum of the ASCII values of the uppercase characters in the string. Here's a breakdown of how the function works:\n\n1. **List Comprehension**: The function uses a list comprehension to iterate over each character `c` in the string `s`.\n2. **Condition Check**: For each character, it checks if the character is an uppercase letter using the `isupper()` method.\n3. **ASCII Value Calculation**: If the character is uppercase, it calculates its ASCII value using the `ord()` function.\n4. **Summation**: The list comprehension generates a list of ASCII values for all uppercase characters, and the `sum()` function adds these values together.\n5. **Return Result**: The function returns the total sum of the ASCII values of the uppercase characters.\n\nThis approach ensures that only uppercase characters are considered, and their ASCII values are summed efficiently.\n\n"}
{"task_id": "CPP/120", "generation": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> maximum(vector<int> arr, int k) {\n    // Sort the array in descending order\n    sort(arr.begin(), arr.end(), greater<int>());\n    \n    // Create a vector to store the first k elements\n    vector<int> result(arr.begin(), arr.begin() + k);\n    \n    // Sort the result in ascending order\n    sort(result.begin(), result.end());\n    \n    return result;\n}\n", "py_code": "def maximum(arr, k):\n    # Sort the array in descending order\n    arr.sort(reverse=True)\n    \n    # Take the first k elements\n    result = arr[:k]\n    \n    # Sort the result in ascending order\n    result.sort()\n    \n    return result\n", "py_summary": "The Python code defines a function `maximum` that takes a list of integers `arr` and a positive integer `k` as input. The function aims to return a sorted list of length `k` containing the maximum `k` numbers from the input list `arr`.\n\nHere's a step-by-step breakdown of how the function works:\n\n1. **Sort the Array in Descending Order**:\n   - The input list `arr` is sorted in descending order using `arr.sort(reverse=True)`. This ensures that the largest elements come first.\n\n2. **Select the First k Elements**:\n   - The first `k` elements from the sorted list are selected using slicing: `arr[:k]`. This gives us the `k` largest elements from the original list.\n\n3. **Sort the Result in Ascending Order**:\n   - The selected `k` elements are then sorted in ascending order using `result.sort()`. This ensures that the final output is in the required format.\n\n4. **Return the Result**:\n   - The function returns the sorted list of the `k` largest elements.\n\nThis approach ensures that the function efficiently finds and returns the `k` largest elements in the correct order.\n\n### Example Walkthrough\n\n- **Input**: `arr = [-3, -4, 5]`, `k = 3`\n  - After sorting in descending order: `[5, -3, -4]`\n  - Select the first 3 elements: `[5, -3, -4]`\n  - Sort the result in ascending order: `[-4, -3, 5]`\n  - **Output**: `[-4, -3, 5]`\n\n- **Input**: `arr = [4, -4, 4]`, `k = 2`\n  - After sorting in descending order: `[4, 4, -4]`\n  - Select the first 2 elements: `[4, 4]`\n  - Sort the result in ascending order: `[4, 4]`\n  - **Output**: `[4, 4]`\n\n- **Input**: `arr = [-3, 2, 1, 2, -1, -2, 1]`, `k = 1`\n  - After sorting in descending order: `[2, 2, 1, 1, -1, -2, -3]`\n  - Select the first 1 element: `[2]`\n  - Sort the result in ascending order: `[2]`\n  - **Output**: `[2]`\n\nThis approach is efficient and straightforward, leveraging Python's built-in sorting capabilities to achieve the desired result."}
{"task_id": "CPP/139", "generation": "#include <iostream>\nusing namespace std;\n\n// Function to calculate the factorial of a number\nlong long factorial(int num) {\n    if (num == 0 || num == 1) {\n        return 1;\n    }\n    long long result = 1;\n    for (int i = 2; i <= num; ++i) {\n        result *= i;\n    }\n    return result;\n}\n\n// Function to calculate the Brazilian factorial\nlong long special_factorial(int n) {\n    long long result = 1;\n    for (int i = 1; i <= n; ++i) {\n        result *= factorial(i);\n    }\n    return result;\n}\n\n// Main function to test the special_factorial function\n", "py_code": "def factorial(num):\n    if num == 0 or num == 1:\n        return 1\n    result = 1\n    for i in range(2, num + 1):\n        result *= i\n    return result\n\ndef special_factorial(n):\n    result = 1\n    for i in range(1, n + 1):\n        result *= factorial(i)\n    return result\n", "py_summary": "The Python code defines two functions: `factorial` and `special_factorial`.\n\n1. **`factorial(num)`**:\n   - This function calculates the factorial of a given number `num`.\n   - It handles the base cases where `num` is 0 or 1, returning 1 in both cases.\n   - For other values of `num`, it initializes a variable `result` to 1 and multiplies it by each integer from 2 to `num` inclusive.\n   - The function returns the computed factorial.\n\n2. **`special_factorial(n)`**:\n   - This function calculates the Brazilian factorial of a given number `n`.\n   - It initializes a variable `result` to 1.\n   - It iterates from 1 to `n` inclusive, and for each value `i`, it multiplies `result` by the factorial of `i` (computed using the `factorial` function).\n   - The function returns the final value of `result`.\n\nThe `special_factorial` function effectively computes the product of the factorials of all integers from 1 to `n`.\n\n### Summary:\n- The `factorial` function computes the factorial of a single number.\n- The `special_factorial` function uses the `factorial` function to compute the Brazilian factorial by multiplying the factorials of all integers from 1 to `n`."}
{"task_id": "CPP/12", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <optional>\nusing namespace std;\n\noptional<string> longest(vector<string> strings) {\n    if (strings.empty()) {\n        return nullopt;\n    }\n\n    string longest_str = strings[0];\n    for (const string& s : strings) {\n        if (s.length() > longest_str.length()) {\n            longest_str = s;\n        }\n    }\n    return longest_str;\n}\n\n", "py_code": "from typing import List, Optional\n\ndef longest(strings: List[str]) -> Optional[str]:\n    if not strings:\n        return None\n    longest_str = strings[0]\n    for s in strings:\n        if len(s) > len(longest_str):\n            longest_str = s\n    return longest_str\n", "py_summary": "The Python code defines a function `longest` that takes a list of strings as input and returns the longest string in the list. If the input list is empty, the function returns `None`.\n\n1. **Input Validation**: The function first checks if the input list `strings` is empty. If it is, the function returns `None`.\n2. **Initialization**: The function initializes a variable `longest_str` with the first string in the list. This variable will keep track of the longest string found so far.\n3. **Iteration and Comparison**: The function iterates through each string `s` in the list. For each string, it compares the length of `s` with the length of `longest_str`. If `s` is longer, `longest_str` is updated to `s`.\n4. **Return Result**: After iterating through all the strings, the function returns `longest_str`, which contains the longest string in the list.\n\nThis approach ensures that the function returns the first longest string in case there are multiple strings of the same maximum length. If the list is empty, it correctly returns `None`.\n\n"}
{"task_id": "CPP/121", "generation": "#include <vector>\nusing namespace std;\n\nint solution(vector<int> lst) {\n    int sum_odd = 0;\n    for (size_t i = 0; i < lst.size(); i += 2) {\n        if (lst[i] % 2 != 0) {\n            sum_odd += lst[i];\n        }\n    }\n    return sum_odd;\n}\n", "py_code": "def solution(lst):\n    sum_odd = 0\n    for i in range(0, len(lst), 2):\n        if lst[i] % 2 != 0:\n            sum_odd += lst[i]\n    return sum_odd\n", "py_summary": "The Python code defines a function `solution` that takes a list of integers as input and returns the sum of all the odd elements that are located at even indices (0-based indexing).\n\nHere's a step-by-step breakdown of the code:\n\n1. **Initialization**: The variable `sum_odd` is initialized to 0. This variable will store the sum of the odd elements at even positions.\n\n2. **Iteration**: The function uses a `for` loop to iterate over the list `lst` with a step of 2, starting from index 0. This ensures that only even indices are considered.\n\n3. **Condition Check**: For each element at an even index, the code checks if the element is odd using the condition `lst[i] % 2 != 0`.\n\n4. **Sum Calculation**: If the element is odd, it is added to the `sum_odd` variable.\n\n5. **Return Result**: After the loop completes, the function returns the value of `sum_odd`.\n\nThis approach ensures that only elements at even indices are considered, and only those that are odd are summed up.\n\n"}
{"task_id": "CPP/35", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nfloat max_element(vector<float> l) {\n    if (l.empty()) {\n        throw runtime_error(\"Vector is empty\");\n    }\n    return *max_element(l.begin(), l.end());\n}\n\n", "py_code": "def max_element(l):\n    return max(l)\n", "py_summary": "The Python code defines a function `max_element` that takes a list of numbers as input and returns the maximum element in the list. The function uses the built-in `max` function to find the maximum value. This approach is straightforward and leverages Python's built-in functionality to achieve the desired result.\n\nHere's a step-by-step breakdown of the code:\n1. The function `max_element` is defined to take a single parameter `l`, which is expected to be a list of numbers.\n2. The `max` function is called with the list `l` as its argument. The `max` function returns the largest element in the list.\n3. The maximum element is returned by the function.\n\nThis approach is efficient and concise, making use of Python's built-in capabilities to find the maximum element in a list.\n\n"}
{"task_id": "CPP/20", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\nvector<float> find_closest_elements(vector<float> numbers) {\n    // Sort the numbers in ascending order\n    sort(numbers.begin(), numbers.end());\n\n    // Initialize variables to store the minimum difference and the closest pair\n    float min_diff = INFINITY;\n    vector<float> result(2);\n\n    // Iterate through the sorted list to find the closest pair\n    for (size_t i = 0; i < numbers.size() - 1; ++i) {\n        float diff = numbers[i + 1] - numbers[i];\n        if (diff < min_diff) {\n            min_diff = diff;\n            result[0] = numbers[i];\n            result[1] = numbers[i + 1];\n        }\n    }\n\n    // Return the closest pair\n    return result;\n}\n\n// Function to test the solution\nvoid test_find_closest_elements() {\n    vector<float> test1 = {1.0, 2.0, 3.0, 4.0, 5.0, 2.2};\n    vector<float> result1 = find_closest_elements(test1);\n    cout << \"(\" << result1[0] << \", \" << result1[1] << \")\" << endl; // Expected: (2.0, 2.2)\n\n    vector<float> test2 = {1.0, 2.0, 3.0, 4.0, 5.0, 2.0};\n    vector<float> result2 = find_closest_elements(test2);\n    cout << \"(\" << result2[0] << \", \" << result2[1] << \")\" << endl; // Expected: (2.0, 2.0)\n}\n\n", "py_code": "from typing import Tuple\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    numbers.sort()\n    min_diff = float('inf')\n    result = (0, 0)\n    for i in range(len(numbers) - 1):\n        diff = numbers[i + 1] - numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            result = (numbers[i], numbers[i + 1])\n    return result\n", "py_summary": "The Python code defines a function `find_closest_elements` that takes a list of floating-point numbers as input and returns a tuple containing the two numbers that are closest to each other in the list. Here's a step-by-step analysis of the code:\n\n1. **Sorting the List**:\n   - The input list `numbers` is sorted in ascending order using the `sort()` method. This ensures that we only need to compare adjacent elements to find the smallest difference.\n\n2. **Initialization**:\n   - `min_diff` is initialized to positive infinity (`float('inf')`). This variable will store the minimum difference found between any two adjacent elements.\n   - `result` is initialized to a tuple `(0, 0)`. This tuple will store the pair of numbers that have the smallest difference.\n\n3. **Iterating Through the Sorted List**:\n   - The function iterates through the sorted list using a `for` loop, comparing each pair of adjacent elements.\n   - For each pair of adjacent elements, the difference `diff` is calculated as `numbers[i + 1] - numbers[i]`.\n   - If the calculated difference `diff` is smaller than the current `min_diff`, `min_diff` is updated to `diff`, and `result` is updated to the current pair of numbers `(numbers[i], numbers[i + 1])`.\n\n4. **Returning the Result**:\n   - After the loop completes, the function returns the `result` tuple, which contains the two closest numbers in the list.\n\nThis approach ensures that the function efficiently finds the two closest numbers by leveraging the sorted order of the list, reducing the complexity to O(n log n) due to the sorting step, and O(n) for the single pass through the list."}
{"task_id": "CPP/19", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <map>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nstring sort_numbers(string numbers) {\n    // Mapping words to their corresponding numeric values\n    map<string, int> number_map = {\n        {\"zero\", 0},\n        {\"one\", 1},\n        {\"two\", 2},\n        {\"three\", 3},\n        {\"four\", 4},\n        {\"five\", 5},\n        {\"six\", 6},\n        {\"seven\", 7},\n        {\"eight\", 8},\n        {\"nine\", 9}\n    };\n\n    // Split the input string into a vector of words\n    stringstream ss(numbers);\n    vector<string> words;\n    string word;\n    while (ss >> word) {\n        words.push_back(word);\n    }\n\n    // Convert words to their corresponding numeric values\n    vector<int> nums;\n    for (const string& word : words) {\n        nums.push_back(number_map[word]);\n    }\n\n    // Sort the numeric values\n    sort(nums.begin(), nums.end());\n\n    // Convert the sorted numeric values back to words\n    vector<string> sorted_words;\n    for (int num : nums) {\n        for (const auto& pair : number_map) {\n            if (pair.second == num) {\n                sorted_words.push_back(pair.first);\n                break;\n            }\n        }\n    }\n\n    // Join the sorted words back into a single string\n    string result;\n    for (size_t i = 0; i < sorted_words.size(); ++i) {\n        result += sorted_words[i];\n        if (i < sorted_words.size() - 1) {\n            result += \" \";\n        }\n    }\n\n    return result;\n}\n\n", "py_code": "def sort_numbers(numbers):\n    number_map = {\n        \"zero\": 0,\n        \"one\": 1,\n        \"two\": 2,\n        \"three\": 3,\n        \"four\": 4,\n        \"five\": 5,\n        \"six\": 6,\n        \"seven\": 7,\n        \"eight\": 8,\n        \"nine\": 9\n    }\n    \n    # Split the input string into a list of words\n    words = numbers.split()\n    \n    # Convert words to their corresponding numeric values\n    nums = [number_map[word] for word in words]\n    \n    # Sort the numeric values\n    nums.sort()\n    \n    # Convert the sorted numeric values back to words\n    sorted_words = [k for v in nums for k, val in number_map.items() if val == v]\n    \n    # Join the sorted words back into a single string\n    return ' '.join(sorted_words)\n", "py_summary": "The Python code defines a function `sort_numbers` that takes a space-delimited string of number words (from \"zero\" to \"nine\") and returns a new string with these number words sorted from smallest to largest.\n\nHere's a step-by-step breakdown of how the code works:\n\n1. **Mapping Words to Numbers**:\n   - A dictionary `number_map` is created to map each number word to its corresponding numeric value. This allows easy conversion between the word form and the numeric form.\n\n2. **Splitting the Input String**:\n   - The input string `numbers` is split into a list of words using the `split()` method. This converts the string \"three one five\" into the list `['three', 'one', 'five']`.\n\n3. **Converting Words to Numeric Values**:\n   - A list comprehension is used to convert each word in the list to its corresponding numeric value using the `number_map` dictionary. For example, `['three', 'one', 'five']` is converted to `[3, 1, 5]`.\n\n4. **Sorting the Numeric Values**:\n   - The list of numeric values is sorted using the `sort()` method. This converts `[3, 1, 5]` to `[1, 3, 5]`.\n\n5. **Converting Sorted Numeric Values Back to Words**:\n   - Another list comprehension is used to convert the sorted numeric values back to their corresponding words using the `number_map` dictionary. For example, `[1, 3, 5]` is converted to `['one', 'three', 'five']`.\n\n6. **Joining the Sorted Words**:\n   - The sorted list of words is joined back into a single string using the `join()` method. This converts `['one', 'three', 'five']` to the string `\"one three five\"`.\n\nFinally, the function returns the sorted string.\n\nThis approach ensures that the input string is correctly parsed, converted, sorted, and then converted back to the desired format."}
{"task_id": "CPP/85", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint add(vector<int> lst) {\n    int result = 0;\n    for (size_t i = 1; i < lst.size(); i += 2) {  // Iterate over odd indices\n        if (lst[i] % 2 == 0) {  // Check if the element is even\n            result += lst[i];\n        }\n    }\n    return result;\n}\n\n// Function to test the add function\nvoid test_add() {\n    vector<int> test1 = {4, 2, 6, 7};\n    vector<int> test2 = {1, 4, 3, 8, 5, 10};\n    vector<int> test3 = {2, 3, 4, 5, 6, 7, 8};\n\n    cout << \"Test 1: \" << add(test1) << \" (Expected: 2)\" << endl;\n    cout << \"Test 2: \" << add(test2) << \" (Expected: 18)\" << endl;\n    cout << \"Test 3: \" << add(test3) << \" (Expected: 12)\" << endl;\n}\n\n", "py_code": "def add(lst):\n    result = 0\n    for i in range(1, len(lst), 2):  # Iterate over odd indices\n        if lst[i] % 2 == 0:  # Check if the element is even\n            result += lst[i]\n    return result\n", "py_summary": "The Python code defines a function `add` that takes a list of integers `lst` as input and returns the sum of even elements that are located at odd indices in the list. Here's a breakdown of how the function works:\n\n1. **Initialization**: The variable `result` is initialized to 0. This variable will store the sum of the even elements at odd indices.\n\n2. **Iteration**: The function uses a `for` loop to iterate over the list `lst` starting from index 1 (the first odd index) and increments by 2 in each step. This ensures that only odd indices are considered.\n\n3. **Condition Check**: Inside the loop, the function checks if the element at the current index `i` is even by using the modulus operator (`%`). If the element is even, it adds the element to the `result`.\n\n4. **Return**: After the loop completes, the function returns the `result`, which contains the sum of even elements at odd indices.\n\nThis approach ensures that only the elements at odd indices are considered, and only those that are even are added to the sum. The function is efficient and straightforward, leveraging Python's list indexing and conditional statements."}
{"task_id": "CPP/21", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\nvector<float> rescale_to_unit(vector<float> numbers) {\n    // Find the minimum and maximum values in the vector\n    float min_num = *min_element(numbers.begin(), numbers.end());\n    float max_num = *max_element(numbers.begin(), numbers.end());\n\n    // Calculate the range\n    float range_num = max_num - min_num;\n\n    // Apply the linear transformation to each element\n    vector<float> transformed_numbers;\n    for (float num : numbers) {\n        transformed_numbers.push_back((num - min_num) / range_num);\n    }\n\n    return transformed_numbers;\n}\n\n// Function to print the vector for testing\nvoid print_vector(const vector<float>& vec) {\n    for (float val : vec) {\n        cout << val << \" \";\n    }\n    cout << endl;\n}\n\n", "py_code": "def rescale_to_unit(numbers):\n    min_num = min(numbers)\n    max_num = max(numbers)\n    range_num = max_num - min_num\n    return [(num - min_num) / range_num for num in numbers]\n\n", "py_summary": "The Python code defines a function `rescale_to_unit` that takes a list of numbers as input and applies a linear transformation to scale the values such that the smallest number becomes 0 and the largest number becomes 1. Here's a step-by-step analysis of the code:\n\n1. **Find the Minimum and Maximum Values**:\n   - `min_num = min(numbers)`: This line finds the smallest number in the list.\n   - `max_num = max(numbers)`: This line finds the largest number in the list.\n\n2. **Calculate the Range**:\n   - `range_num = max_num - min_num`: This line calculates the range of the numbers, which is the difference between the maximum and minimum values.\n\n3. **Apply the Linear Transformation**:\n   - The list comprehension `[(num - min_num) / range_num for num in numbers]` iterates over each number in the input list and applies the linear transformation formula `(num - min_num) / range_num`. This formula scales each number such that the smallest number becomes 0 and the largest number becomes 1.\n\n4. **Return the Transformed List**:\n   - The function returns the transformed list of numbers.\n\nThis approach ensures that the transformed values are scaled linearly between 0 and 1, maintaining the relative differences between the original numbers.\n\n"}
{"task_id": "CPP/119", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nbool is_balanced(const string& s) {\n    int balance = 0;\n    for (char ch : s) {\n        if (ch == '(') {\n            balance += 1;\n        } else {\n            balance -= 1;\n        }\n        if (balance < 0) {\n            return false;\n        }\n    }\n    return balance == 0;\n}\n\nstring match_parens(vector<string> lst) {\n    string s1 = lst[0];\n    string s2 = lst[1];\n    \n    if (is_balanced(s1 + s2) || is_balanced(s2 + s1)) {\n        return \"Yes\";\n    }\n    return \"No\";\n}\n\n", "py_code": "def match_parens(lst):\n    def is_balanced(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            else:\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    s1, s2 = lst\n    if is_balanced(s1 + s2) or is_balanced(s2 + s1):\n        return \"Yes\"\n    return \"No\"\n", "py_summary": "The Python code defines a function `match_parens` that takes a list of two strings as input and checks if it is possible to concatenate these strings in some order to form a balanced string of parentheses. Here's a detailed breakdown of the code:\n\n1. **Helper Function `is_balanced`**:\n   - This function takes a string `s` as input and checks if the parentheses in the string are balanced.\n   - It initializes a variable `balance` to 0, which keeps track of the balance of parentheses.\n   - It iterates through each character in the string:\n     - If the character is '(', it increments the `balance`.\n     - If the character is ')', it decrements the `balance`.\n     - If at any point the `balance` becomes negative, it means there are more closing parentheses than opening ones up to that point, and the function returns `False`.\n   - After the loop, if the `balance` is zero, it means the string is balanced, and the function returns `True`. Otherwise, it returns `False`.\n\n2. **Main Function `match_parens`**:\n   - This function takes a list `lst` containing two strings.\n   - It unpacks the list into two strings `s1` and `s2`.\n   - It checks if concatenating `s1` and `s2` in either order (`s1 + s2` or `s2 + s1`) results in a balanced string using the `is_balanced` function.\n   - If either concatenation is balanced, it returns \"Yes\".\n   - If neither concatenation is balanced, it returns \"No\".\n\nThis approach ensures that the function correctly identifies whether the two strings can be concatenated to form a balanced string of parentheses.\n\n"}
{"task_id": "CPP/30", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<float> get_positive(vector<float> l) {\n    vector<float> result;\n    for (float num : l) {\n        if (num > 0) {\n            result.push_back(num);\n        }\n    }\n    return result;\n}\n\n// Function to test the get_positive function\nvoid test_get_positive() {\n    vector<float> test1 = {-1, 2, -4, 5, 6};\n    vector<float> expected1 = {2, 5, 6};\n    assert(get_positive(test1) == expected1);\n\n    vector<float> test2 = {5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10};\n    vector<float> expected2 = {5, 3, 2, 3, 9, 123, 1};\n    assert(get_positive(test2) == expected2);\n\n    cout << \"All tests passed!\" << endl;\n}\n\n", "py_code": "def get_positive(l):\n    return [num for num in l if num > 0]\n", "py_summary": "The Python code defines a function `get_positive` that takes a list `l` as input and returns a new list containing only the positive numbers from the input list. This is achieved using a list comprehension, which iterates through each element in the input list and includes it in the new list only if the element is greater than zero.\n\nHere's a breakdown of the code:\n1. **List Comprehension**: `[num for num in l if num > 0]`\n   - `num` is the variable representing each element in the input list `l`.\n   - The condition `if num > 0` ensures that only positive numbers are included in the resulting list.\n2. **Return Statement**: The function returns the list of positive numbers.\n\nThis approach is concise and efficient, leveraging Python's powerful list comprehension feature to filter the list in a single line of code."}
{"task_id": "CPP/64", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint vowels_count(string s) {\n    string vowels = \"aeiouAEIOU\";\n    int count = 0;\n\n    // Iterate through the string to count vowels\n    for (char ch : s) {\n        if (vowels.find(ch) != string::npos) {\n            count++;\n        }\n    }\n\n    // Check if the last character is 'y' or 'Y'\n    if (!s.empty() && (s.back() == 'y' || s.back() == 'Y')) {\n        count++;\n    }\n\n    return count;\n}\n\n// Function to test the vowels_count function\nvoid test_vowels_count() {\n    cout << \"vowels_count(\\\"abcde\\\"): \" << vowels_count(\"abcde\") << \" (Expected: 2)\" << endl;\n    cout << \"vowels_count(\\\"ACEDY\\\"): \" << vowels_count(\"ACEDY\") << \" (Expected: 3)\" << endl;\n    cout << \"vowels_count(\\\"rhythm\\\"): \" << vowels_count(\"rhythm\") << \" (Expected: 1)\" << endl;\n    cout << \"vowels_count(\\\"sky\\\"): \" << vowels_count(\"sky\") << \" (Expected: 1)\" << endl;\n    cout << \"vowels_count(\\\"quick\\\"): \" << vowels_count(\"quick\") << \" (Expected: 1)\" << endl;\n}\n\n", "py_code": "def vowels_count(s):\n    vowels = \"aeiouAEIOU\"\n    count = 0\n    for char in s:\n        if char in vowels:\n            count += 1\n    if s and s[-1] in \"yY\":\n        count += 1\n    return count\n", "py_summary": "The Python code defines a function `vowels_count` that takes a string `s` as input and returns the number of vowels in the string. The function works as follows:\n\n1. **Initialize Variables**:\n   - `vowels`: A string containing all the vowels, both lowercase and uppercase.\n   - `count`: An integer initialized to 0 to keep track of the number of vowels.\n\n2. **Iterate Through the String**:\n   - The function iterates through each character in the input string `s`.\n   - For each character, it checks if the character is in the `vowels` string.\n   - If the character is a vowel, it increments the `count` by 1.\n\n3. **Check for 'y' at the End**:\n   - After the loop, the function checks if the last character of the string `s` is 'y' or 'Y'.\n   - If it is, it increments the `count` by 1.\n\n4. **Return the Count**:\n   - Finally, the function returns the `count`.\n\nThis approach ensures that all vowels are counted correctly, including the special case for 'y' at the end of the word.\n\n"}
{"task_id": "CPP/128", "generation": "#include <iostream>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\nint prod_signs(vector<int> arr) {\n    if (arr.empty()) {\n        return -32768;\n    }\n\n    int sign_product = 1;\n    int magnitude_sum = 0;\n\n    for (int num : arr) {\n        if (num == 0) {\n            return 0;\n        }\n        sign_product *= (num > 0) ? 1 : -1;\n        magnitude_sum += abs(num);\n    }\n\n    return magnitude_sum * sign_product;\n}\n\n// Test cases\n", "py_code": "def prod_signs(arr):\n    if not arr:\n        return -32768\n    \n    sign_product = 1\n    magnitude_sum = 0\n    \n    for num in arr:\n        if num == 0:\n            return 0\n        sign_product *= 1 if num > 0 else -1\n        magnitude_sum += abs(num)\n    \n    return magnitude_sum * sign_product\n", "py_summary": "The Python code defines a function `prod_signs` that takes a list of integers `arr` as input and returns the sum of the magnitudes of the integers multiplied by the product of their signs. Here's a step-by-step analysis of the code:\n\n1. **Check for Empty List**:\n   - If the input list `arr` is empty, the function immediately returns `-32768`. This handles the edge case where no numbers are provided.\n\n2. **Initialize Variables**:\n   - `sign_product` is initialized to `1`. This variable will store the product of the signs of all the numbers in the list.\n   - `magnitude_sum` is initialized to `0`. This variable will store the sum of the absolute values (magnitudes) of all the numbers in the list.\n\n3. **Iterate Through the List**:\n   - The function iterates through each number in the list `arr`.\n   - For each number:\n     - If the number is `0`, the function returns `0` immediately because the product of the signs will be `0` (since any number multiplied by `0` is `0`).\n     - If the number is positive, `sign_product` is multiplied by `1`.\n     - If the number is negative, `sign_product` is multiplied by `-1`.\n     - The absolute value of the number is added to `magnitude_sum`.\n\n4. **Return the Result**:\n   - After iterating through all the numbers, the function returns the product of `magnitude_sum` and `sign_product`.\n\nThis approach ensures that the function correctly handles the requirements of the problem, including edge cases and the calculation of both the sum of magnitudes and the product of signs."}
{"task_id": "CPP/127", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int n) {\n    if (n <= 1) {\n        return false;\n    }\n    for (int i = 2; i <= sqrt(n); ++i) {\n        if (n % i == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\n// Function to determine if the length of the intersection of two intervals is a prime number\nstring intersection(vector<int> interval1, vector<int> interval2) {\n    int start1 = interval1[0], end1 = interval1[1];\n    int start2 = interval2[0], end2 = interval2[1];\n\n    // Calculate the intersection\n    int start_intersect = max(start1, start2);\n    int end_intersect = min(end1, end2);\n\n    // Check if there is no intersection\n    if (start_intersect > end_intersect) {\n        return \"NO\";\n    }\n\n    // Calculate the length of the intersection\n    int length_intersect = end_intersect - start_intersect + 1;\n\n    // Check if the length is a prime number\n    if (is_prime(length_intersect)) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n\n// Main function to test the intersection function\n", "py_code": "def is_prime(n):\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef intersection(interval1, interval2):\n    start1, end1 = interval1\n    start2, end2 = interval2\n    \n    # Calculate the intersection\n    start_intersect = max(start1, start2)\n    end_intersect = min(end1, end2)\n    \n    # Check if there is no intersection\n    if start_intersect > end_intersect:\n        return \"NO\"\n    \n    # Calculate the length of the intersection\n    length_intersect = end_intersect - start_intersect + 1\n    \n    # Check if the length is a prime number\n    if is_prime(length_intersect):\n        return \"YES\"\n    else:\n        return \"NO\"\n", "py_summary": "The Python code defines a function `intersection` that determines whether the length of the intersection of two given intervals is a prime number. Here's a step-by-step analysis of the code:\n\n1. **Prime Number Check Function (`is_prime`)**:\n   - This helper function checks if a given number `n` is a prime number.\n   - It returns `False` if `n` is less than or equal to 1.\n   - It iterates from 2 to the square root of `n` (inclusive) to check for any divisors. If a divisor is found, it returns `False`.\n   - If no divisors are found, it returns `True`.\n\n2. **Intersection Calculation**:\n   - The function `intersection` takes two intervals as input, each represented as a tuple `(start, end)`.\n   - It extracts the start and end points of both intervals.\n   - It calculates the start and end points of the intersection using `max(start1, start2)` and `min(end1, end2)` respectively.\n\n3. **Intersection Validation**:\n   - It checks if the start point of the intersection is greater than the end point. If so, it means the intervals do not intersect, and the function returns \"NO\".\n\n4. **Length Calculation**:\n   - If the intervals intersect, it calculates the length of the intersection as `end_intersect - start_intersect + 1`.\n\n5. **Prime Length Check**:\n   - It uses the `is_prime` function to check if the length of the intersection is a prime number.\n   - If the length is a prime number, it returns \"YES\".\n   - Otherwise, it returns \"NO\".\n\nThis approach ensures that the function correctly identifies whether the length of the intersection of two intervals is a prime number.\n\n"}
{"task_id": "CPP/122", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint add_elements(vector<int> arr, int k) {\n    // Initialize the sum to zero\n    int total_sum = 0;\n\n    // Iterate through the first k elements of the array\n    for (int i = 0; i < k; ++i) {\n        // Check if the element has at most two digits\n        if (-100 <= arr[i] && arr[i] <= 99) {\n            total_sum += arr[i];\n        }\n    }\n\n    return total_sum;\n}\n\n// Function to test the add_elements function\nvoid test_add_elements() {\n    vector<int> arr = {111, 21, 3, 4000, 5, 6, 7, 8, 9};\n    int k = 4;\n    int result = add_elements(arr, k);\n    cout << \"Output: \" << result << endl; // Expected output: 24\n}\n\n", "py_code": "def add_elements(arr, k):\n    # Initialize the sum to zero\n    total_sum = 0\n    \n    # Iterate through the first k elements of the array\n    for i in range(k):\n        # Check if the element has at most two digits\n        if -100 <= arr[i] <= 99:\n            total_sum += arr[i]\n    \n    return total_sum\n", "py_summary": "The Python code defines a function `add_elements` that takes a list of integers `arr` and an integer `k` as input. The function aims to return the sum of the elements from the first `k` elements of `arr` that have at most two digits.\n\nHere's a step-by-step breakdown of the code:\n\n1. **Initialization**: The variable `total_sum` is initialized to zero. This variable will store the sum of the valid elements.\n2. **Iteration**: The function iterates through the first `k` elements of the array using a `for` loop.\n3. **Condition Check**: For each element, the function checks if the element has at most two digits. This is done using the condition `-100 <= arr[i] <= 99`. This condition ensures that the element is between -100 and 99, inclusive.\n4. **Sum Calculation**: If the element satisfies the condition, it is added to `total_sum`.\n5. **Return Result**: After the loop completes, the function returns the value of `total_sum`.\n\nThis approach ensures that only elements with at most two digits from the first `k` elements are summed up and returned.\n\n"}
{"task_id": "CPP/59", "generation": "#include <iostream>\nusing namespace std;\n\nint largest_prime_factor(int n) {\n    int factor = 2;\n    int last_factor = 1;\n    while (factor * factor <= n) {\n        if (n % factor == 0) {\n            last_factor = factor;\n            n /= factor;\n        } else {\n            factor += 1;\n        }\n    }\n    if (n > 1) {\n        last_factor = n;\n    }\n    return last_factor;\n}\n\n", "py_code": "def largest_prime_factor(n):\n    # Start with the smallest prime factor\n    factor = 2\n    last_factor = 1\n    while factor * factor <= n:\n        if n % factor == 0:\n            last_factor = factor\n            n //= factor\n        else:\n            factor += 1\n    if n > 1:\n        last_factor = n\n    return last_factor\n", "py_summary": "The Python code defines a function `largest_prime_factor` that takes an integer `n` as input and returns the largest prime factor of `n`. The function works as follows:\n\n1. **Initialization**:\n   - `factor` is initialized to 2, the smallest prime number.\n   - `last_factor` is initialized to 1, which will store the largest prime factor found.\n\n2. **Factorization Loop**:\n   - The loop runs while `factor * factor` is less than or equal to `n`. This ensures that we only check up to the square root of `n`, which is efficient.\n   - Inside the loop, it checks if `n` is divisible by `factor`.\n     - If `n` is divisible by `factor`, it updates `last_factor` to `factor` and divides `n` by `factor` to reduce `n`.\n     - If `n` is not divisible by `factor`, it increments `factor` by 1 to check the next potential factor.\n\n3. **Final Check**:\n   - After the loop, if `n` is greater than 1, it means `n` itself is a prime number and is the largest prime factor. In this case, `last_factor` is updated to `n`.\n\n4. **Return**:\n   - The function returns `last_factor`, which contains the largest prime factor of `n`.\n\nThis approach ensures that the function efficiently finds the largest prime factor by continuously dividing `n` by its smallest factors and updating the largest factor found."}
{"task_id": "CPP/134", "generation": "#include <iostream>\n#include <string>\n#include <cctype> // for isalpha function\nusing namespace std;\n\nbool check_if_last_char_is_a_letter(string txt) {\n    // Check if the string is empty\n    if (txt.empty()) {\n        return false;\n    }\n\n    // Remove trailing spaces\n    while (!txt.empty() && txt.back() == ' ') {\n        txt.pop_back();\n    }\n\n    // Check if the string is now empty after removing trailing spaces\n    if (txt.empty()) {\n        return false;\n    }\n\n    // Check the last character\n    char last_char = txt.back();\n    if (isalpha(last_char)) {\n        // Check if the last character is the only character or the character before it is a space\n        if (txt.length() == 1 || txt[txt.length() - 2] == ' ') {\n            return true;\n        }\n    }\n\n    return false;\n}\n\n// Function to test the solution\nvoid test() {\n    cout << (check_if_last_char_is_a_letter(\"apple pie\") ? \"true\" : \"false\") << endl; // \u279e false\n    cout << (check_if_last_char_is_a_letter(\"apple pi e\") ? \"true\" : \"false\") << endl; // \u279e true\n    cout << (check_if_last_char_is_a_letter(\"apple pi e \") ? \"true\" : \"false\") << endl; // \u279e false\n    cout << (check_if_last_char_is_a_letter(\"\") ? \"true\" : \"false\") << endl; // \u279e false\n}\n\n", "py_code": "def check_if_last_char_is_a_letter(txt):\n    if not txt:\n        return False\n    # Remove trailing spaces\n    txt = txt.rstrip()\n    if not txt:\n        return False\n    # Check if the last character is an alphabetical character\n    last_char = txt[-1]\n    return last_char.isalpha() and (len(txt) == 1 or txt[-2] == ' ')\n", "py_summary": "The Python code defines a function `check_if_last_char_is_a_letter` that takes a string `txt` as input and returns a boolean value indicating whether the last character of the string is an alphabetical character and is not part of a word. Here's a step-by-step analysis of the code:\n\n1. **Check if the string is empty**:\n   - If the input string `txt` is empty, the function immediately returns `False`.\n\n2. **Remove trailing spaces**:\n   - The `rstrip()` method is used to remove any trailing whitespace characters from the end of the string. This ensures that we are only checking the actual content of the string, not any trailing spaces.\n\n3. **Check if the string is now empty after removing trailing spaces**:\n   - After removing trailing spaces, if the string is empty, the function returns `False`.\n\n4. **Check the last character**:\n   - The last character of the string is accessed using `txt[-1]`.\n   - The function checks if this character is an alphabetical character using the `isalpha()` method.\n   - Additionally, it checks if the last character is either the only character in the string (`len(txt) == 1`) or if the character before the last character is a space (`txt[-2] == ' '`).\n\n5. **Return the result**:\n   - The function returns `True` if both conditions are met (the last character is an alphabetical character and it is not part of a word), otherwise it returns `False`.\n\nThis approach ensures that the function correctly identifies whether the last character of the string meets the specified criteria."}
{"task_id": "CPP/42", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> incr_list(vector<int> l) {\n    for (int& x : l) {\n        x += 1;\n    }\n    return l;\n}\n\n// Test cases\n", "py_code": "def incr_list(l):\n    return [x + 1 for x in l]\n", "py_summary": "The Python code defines a function `incr_list` that takes a list `l` as input and returns a new list where each element of the input list is incremented by 1. This is achieved using a list comprehension, which is a concise way to create a new list by applying an operation to each element of the original list.\n\nHere's a step-by-step breakdown of the code:\n1. The function `incr_list` is defined with a single parameter `l`, which is expected to be a list of integers.\n2. Inside the function, a list comprehension `[x + 1 for x in l]` is used to create a new list. For each element `x` in the input list `l`, the expression `x + 1` is evaluated, and the result is added to the new list.\n3. The new list, where each element is incremented by 1, is returned by the function.\n\nThis approach is efficient and concise, leveraging Python's powerful list comprehension feature to perform the increment operation in a single line."}
{"task_id": "CPP/11", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring string_xor(string a, string b) {\n    string result = \"\";\n    for (size_t i = 0; i < a.length(); ++i) {\n        // Perform XOR operation on each bit\n        if (a[i] == b[i]) {\n            result += '0';\n        } else {\n            result += '1';\n        }\n    }\n    return result;\n}\n\n// Function to test the string_xor function\nvoid test_string_xor() {\n    string a = \"010\";\n    string b = \"110\";\n    string expected = \"100\";\n    string result = string_xor(a, b);\n    if (result == expected) {\n        cout << \"Test passed: \" << a << \" XOR \" << b << \" = \" << result << endl;\n    } else {\n        cout << \"Test failed: \" << a << \" XOR \" << b << \" = \" << result << \" (expected: \" << expected << \")\" << endl;\n    }\n}\n\n", "py_code": "def string_xor(a, b):\n    result = []\n    for i in range(len(a)):\n        # Perform XOR operation on each bit\n        if a[i] == b[i]:\n            result.append('0')\n        else:\n            result.append('1')\n    return ''.join(result)\n", "py_summary": "The Python code defines a function `string_xor` that takes two strings `a` and `b` as input, both consisting only of '1's and '0's. The function performs a bitwise XOR operation on these strings and returns the result as a new string.\n\nHere's a step-by-step breakdown of how the function works:\n\n1. **Initialization**: An empty list `result` is created to store the result of the XOR operation.\n2. **Iteration**: The function iterates over the characters of the strings `a` and `b` using a for loop. The loop runs from 0 to the length of the strings (assuming both strings are of equal length).\n3. **XOR Operation**: For each pair of characters at the same position in `a` and `b`, the function checks if they are the same:\n   - If `a[i]` is equal to `b[i]`, it appends '0' to the `result` list (since 0 XOR 0 = 0 and 1 XOR 1 = 0).\n   - If `a[i]` is not equal to `b[i]`, it appends '1' to the `result` list (since 0 XOR 1 = 1 and 1 XOR 0 = 1).\n4. **Result Construction**: After the loop completes, the `result` list is converted to a string using `''.join(result)` and returned.\n\nThis approach ensures that the function correctly performs the bitwise XOR operation on the input strings and returns the result as a string.\n\n"}
{"task_id": "CPP/40", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nbool triples_sum_to_zero(vector<int> l) {\n    // Sort the vector\n    sort(l.begin(), l.end());\n    \n    int n = l.size();\n    \n    // Iterate through the vector\n    for (int i = 0; i < n - 2; ++i) {\n        int left = i + 1;\n        int right = n - 1;\n        \n        // Use two-pointer technique to find a pair that sums to zero with l[i]\n        while (left < right) {\n            int total = l[i] + l[left] + l[right];\n            \n            if (total == 0) {\n                return true;\n            } else if (total < 0) {\n                left++;\n            } else {\n                right--;\n            }\n        }\n    }\n    \n    // Return false if no such triplet is found\n    return false;\n}\n\n// Function to test the solution\nvoid test_triples_sum_to_zero() {\n    cout << boolalpha; // Print bools as true/false\n    cout << \"Test 1: \" << triples_sum_to_zero({1, 3, 5, 0}) << \" (Expected: false)\" << endl;\n    cout << \"Test 2: \" << triples_sum_to_zero({1, 3, -2, 1}) << \" (Expected: true)\" << endl;\n    cout << \"Test 3: \" << triples_sum_to_zero({1, 2, 3, 7}) << \" (Expected: false)\" << endl;\n    cout << \"Test 4: \" << triples_sum_to_zero({2, 4, -5, 3, 9, 7}) << \" (Expected: true)\" << endl;\n    cout << \"Test 5: \" << triples_sum_to_zero({1}) << \" (Expected: false)\" << endl;\n}\n\n", "py_code": "def triples_sum_to_zero(nums):\n    nums.sort()\n    n = len(nums)\n    for i in range(n - 2):\n        left, right = i + 1, n - 1\n        while left < right:\n            total = nums[i] + nums[left] + nums[right]\n            if total == 0:\n                return True\n            elif total < 0:\n                left += 1\n            else:\n                right -= 1\n    return False\n", "py_summary": "The Python code defines a function `triples_sum_to_zero` that checks if there are three distinct elements in the input list `nums` that sum to zero. Here's a step-by-step analysis of the code:\n\n1. **Sorting the List**: The function first sorts the input list `nums`. Sorting helps in efficiently finding the triplets that sum to zero using the two-pointer technique.\n\n2. **Iterating Through the List**: The function iterates through the list using a for loop, with the index `i` ranging from 0 to `n-3` (where `n` is the length of the list). This ensures that there are at least two elements remaining after the current element to form a triplet.\n\n3. **Two-Pointer Technique**: For each element at index `i`, the function uses two pointers, `left` and `right`, to find a pair of elements that, when added to the element at index `i`, sum to zero.\n   - `left` starts from `i + 1`.\n   - `right` starts from the last element of the list (`n - 1`).\n\n4. **Checking the Sum**:\n   - If the sum of the elements at indices `i`, `left`, and `right` is zero, the function returns `True`.\n   - If the sum is less than zero, the `left` pointer is moved one step to the right to increase the sum.\n   - If the sum is greater than zero, the `right` pointer is moved one step to the left to decrease the sum.\n\n5. **Returning the Result**: If no such triplet is found after iterating through the list, the function returns `False`.\n\nThis approach ensures that the function runs in O(n^2) time complexity due to the nested loops and the two-pointer technique, which is efficient for this problem.\n\n"}
{"task_id": "CPP/13", "generation": "#include <iostream>\nusing namespace std;\n\nint greatest_common_divisor(int a, int b) {\n    while (b != 0) {\n        int temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n\n", "py_code": "def greatest_common_divisor(a, b):\n    while b != 0:\n        a, b = b, a % b\n    return a\n", "py_summary": "The Python code defines a function `greatest_common_divisor` that calculates the greatest common divisor (GCD) of two integers `a` and `b`. The function uses the Euclidean algorithm, which is an efficient method for computing the GCD. Here's a step-by-step breakdown of how the code works:\n\n1. **Initialization**: The function starts with the two input integers `a` and `b`.\n2. **Loop**: The function enters a loop that continues until `b` becomes zero.\n3. **Update**: Inside the loop, the values of `a` and `b` are updated. Specifically, `a` is set to the current value of `b`, and `b` is set to the remainder of `a` divided by `b` (`a % b`).\n4. **Termination**: The loop terminates when `b` becomes zero. At this point, `a` contains the GCD of the original two numbers.\n5. **Return**: The function returns the value of `a`, which is the GCD.\n\nThis algorithm works because the GCD of two numbers does not change if the larger number is replaced by its difference with the smaller number. The process continues until the two numbers become equal, which is the GCD.\n\n### Summary:\n- **Algorithm**: Euclidean algorithm\n- **Time Complexity**: O(log(min(a, b)))\n- **Space Complexity**: O(1)\n\nThis method is efficient and widely used for computing the GCD of two integers."}
{"task_id": "CPP/130", "generation": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\n// Helper function to compute the Tribonacci sequence using memoization\nint tribonacci(int i, unordered_map<int, int>& memo) {\n    if (memo.find(i) != memo.end()) {\n        return memo[i];\n    }\n    if (i == 1) {\n        return 3;\n    } else if (i % 2 == 0) {\n        return 1 + i / 2;\n    } else {\n        return tribonacci(i - 1, memo) + tribonacci(i - 2, memo) + tribonacci(i + 1, memo);\n    }\n}\n\n// Main function to generate the first n + 1 numbers of the Tribonacci sequence\nvector<int> tri(int n) {\n    unordered_map<int, int> memo;\n    vector<int> result;\n    for (int i = 1; i <= n; ++i) {\n        result.push_back(tribonacci(i, memo));\n    }\n    return result;\n}\n\n// Function to print the vector\nvoid printVector(const vector<int>& vec) {\n    for (int val : vec) {\n        cout << val << \" \";\n    }\n    cout << endl;\n}\n\n// Main function to test the implementation\n", "py_code": "def tri(n):\n    def tribonacci(i):\n        if i == 1:\n            return 3\n        elif i % 2 == 0:\n            return 1 + i // 2\n        else:\n            return tribonacci(i - 1) + tribonacci(i - 2) + tribonacci(i + 1)\n    \n    result = []\n    for i in range(1, n + 1):\n        result.append(tribonacci(i))\n    return result\n", "py_summary": "The Python code defines a function `tri(n)` that generates the first `n + 1` numbers of the Tribonacci sequence. The function uses a helper function `tribonacci(i)` to compute the value of the Tribonacci sequence at index `i`.\n\nHere's a detailed breakdown of the code:\n\n1. **Helper Function `tribonacci(i)`**:\n   - **Base Case**: If `i` is 1, the function returns 3.\n   - **Even Case**: If `i` is even, the function returns `1 + i // 2`.\n   - **Odd Case**: If `i` is odd, the function recursively calls itself to compute the sum of `tribonacci(i - 1)`, `tribonacci(i - 2)`, and `tribonacci(i + 1)`.\n\n2. **Main Function `tri(n)`**:\n   - Initializes an empty list `result` to store the Tribonacci sequence values.\n   - Iterates from 1 to `n + 1` and appends the result of `tribonacci(i)` to the `result` list.\n   - Returns the `result` list containing the first `n + 1` numbers of the Tribonacci sequence.\n\nThis approach ensures that the Tribonacci sequence is computed correctly according to the given recurrence relation. However, the recursive approach can be inefficient for large values of `n` due to repeated calculations. To optimize, we can use memoization or dynamic programming.\n\n### Optimized Python Code with Memoization:\n```python\ndef tri(n):\n    memo = {}\n    \n    def tribonacci(i):\n        if i in memo:\n            return memo[i]\n        if i == 1:\n            return 3\n        elif i % 2 == 0:\n            result = 1 + i // 2\n        else:\n            result = tribonacci(i - 1) + tribonacci(i - 2) + tribonacci(i + 1)\n        memo[i] = result\n        return result\n    \n    result = []\n    for i in range(1, n + 1):\n        result.append(tribonacci(i))\n    return result\n```\n\nThis optimized version uses a dictionary `memo` to store previously computed values of the Tribonacci sequence, reducing redundant calculations and improving efficiency."}
{"task_id": "CPP/60", "generation": "#include <iostream>\nusing namespace std;\n\nint sum_to_n(int n) {\n    return n * (n + 1) / 2;\n}\n\n", "py_code": "def sum_to_n(n):\n    return n * (n + 1) // 2\n", "py_summary": "The Python code defines a function `sum_to_n` that calculates the sum of all integers from 1 to `n`. The function uses the formula for the sum of the first `n` natural numbers, which is given by:\n\n\\[ \\text{sum} = \\frac{n \\times (n + 1)}{2} \\]\n\nThis formula is derived from the arithmetic series sum formula. The function performs the following steps:\n1. It takes an integer `n` as input.\n2. It calculates the sum using the formula \\( n \\times (n + 1) \\) and then divides the result by 2 using integer division (`//`).\n3. It returns the calculated sum.\n\nThis approach is efficient and runs in constant time \\( O(1) \\), making it very fast even for large values of `n`.\n\n"}
{"task_id": "CPP/23", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nint strlen(string str) {\n    return str.length();\n}\n\n// Test cases\n", "py_code": "def strlen(s):\n    return len(s)\n", "py_summary": "The Python code defines a function `strlen` that takes a string `s` as input and returns the length of the string using the built-in `len` function. This function is straightforward and leverages Python's built-in capabilities to determine the length of a string.\n\n### Summary:\n- **Function**: `strlen(s)`\n- **Input**: A string `s`\n- **Output**: An integer representing the length of the string `s`\n- **Implementation**: Uses the built-in `len` function to get the length of the string.\n\nThis approach is simple and efficient, as the `len` function in Python is optimized for performance. The function works by counting the number of characters in the string, including spaces and special characters."}
{"task_id": "CPP/46", "generation": "#include <iostream>\nusing namespace std;\n\nint fib4(int n) {\n    if (n == 0 || n == 1 || n == 3) {\n        return 0;\n    } else if (n == 2) {\n        return 2;\n    }\n\n    // Initialize the base cases\n    int a = 0, b = 0, c = 2, d = 0;\n\n    // Compute the n-th element iteratively\n    for (int i = 4; i <= n; ++i) {\n        int temp = a + b + c + d;\n        a = b;\n        b = c;\n        c = d;\n        d = temp;\n    }\n\n    return d;\n}\n\n", "py_code": "def fib4(n):\n    if n == 0 or n == 1 or n == 3:\n        return 0\n    elif n == 2:\n        return 2\n    \n    # Initialize the base cases\n    a, b, c, d = 0, 0, 2, 0\n    \n    # Compute the n-th element iteratively\n    for _ in range(4, n + 1):\n        a, b, c, d = b, c, d, a + b + c + d\n    \n    return d\n", "py_summary": "The Python code defines a function `fib4` that computes the n-th element of the Fib4 number sequence without using recursion. The function handles the base cases directly:\n\n- `fib4(0)`, `fib4(1)`, and `fib4(3)` return 0.\n- `fib4(2)` returns 2.\n\nFor values of `n` greater than 3, the function uses an iterative approach to compute the n-th element. It initializes four variables `a`, `b`, `c`, and `d` to represent the first four elements of the sequence (`fib4(0)`, `fib4(1)`, `fib4(2)`, and `fib4(3)` respectively).\n\nThe function then iterates from 4 to `n`, updating the values of `a`, `b`, `c`, and `d` in each iteration to reflect the next element in the sequence. Specifically, in each iteration, the new value of `d` is computed as the sum of the previous four values (`a + b + c + d`), and the values of `a`, `b`, and `c` are updated to shift the window of the last four elements.\n\nFinally, the function returns the value of `d`, which represents the n-th element of the Fib4 sequence.\n\nThis approach ensures that the function runs in O(n) time complexity and uses O(1) space complexity, making it efficient for large values of `n`."}
{"task_id": "CPP/51", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nstring remove_vowels(string text) {\n    // Define the set of vowels\n    string vowels = \"aeiouAEIOU\";\n    \n    // Use erase-remove idiom to remove vowels from the string\n    text.erase(remove_if(text.begin(), text.end(), [&vowels](char c) {\n        return vowels.find(c) != string::npos;\n    }), text.end());\n    \n    return text;\n}\n\n// Function to test the remove_vowels function\nvoid test_remove_vowels() {\n    assert(remove_vowels(\"\") == \"\");\n    assert(remove_vowels(\"abcdef\\nghijklm\") == \"bcdf\\nghjklm\");\n    assert(remove_vowels(\"abcdef\") == \"bcdf\");\n    assert(remove_vowels(\"aaaaa\") == \"\");\n    assert(remove_vowels(\"aaBAA\") == \"B\");\n    assert(remove_vowels(\"zbcd\") == \"zbcd\");\n    cout << \"All tests passed!\" << endl;\n}\n\n", "py_code": "def remove_vowels(text):\n    vowels = \"aeiouAEIOU\"\n    return ''.join([char for char in text if char not in vowels])\n", "py_summary": "The Python code defines a function `remove_vowels` that takes a string `text` as input and returns a new string with all vowels removed. Here's a step-by-step analysis of the code:\n\n1. **Define Vowels**: A string `vowels` is defined containing all the vowel characters (both lowercase and uppercase).\n\n2. **List Comprehension**: A list comprehension is used to iterate over each character in the input string `text`. For each character, it checks if the character is not in the `vowels` string.\n\n3. **Join Characters**: The list comprehension generates a list of characters that are not vowels. The `join` method is then used to concatenate these characters into a single string.\n\n4. **Return Result**: The resulting string, which contains only the non-vowel characters from the input string, is returned.\n\nThis approach is efficient and concise, leveraging Python's powerful list comprehension and string manipulation capabilities. The function handles both uppercase and lowercase vowels and preserves the original order of the non-vowel characters.\n\n"}
{"task_id": "CPP/18", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint how_many_times(string str, string substring) {\n    int count = 0;\n    size_t start = 0;\n    while (true) {\n        start = str.find(substring, start);\n        if (start == string::npos) {\n            break;\n        }\n        count++;\n        start++; // Move to the next character to allow for overlapping matches\n    }\n    return count;\n}\n\n", "py_code": "def how_many_times(s, sub):\n    count = 0\n    start = 0\n    while True:\n        start = s.find(sub, start) + 1\n        if start == 0:\n            break\n        count += 1\n    return count\n", "py_summary": "The Python code defines a function `how_many_times` that takes two strings, `s` and `sub`, as input and returns the number of times the substring `sub` appears in the string `s`, including overlapping occurrences.\n\nHere's a step-by-step breakdown of how the function works:\n\n1. **Initialization**:\n   - `count` is initialized to 0 to keep track of the number of occurrences.\n   - `start` is initialized to 0 to keep track of the starting index for the search.\n\n2. **Loop**:\n   - The function enters a `while` loop that continues until no more occurrences of `sub` are found in `s`.\n   - Inside the loop, `s.find(sub, start)` is used to find the next occurrence of `sub` starting from the current `start` index.\n   - If `find` returns -1, it means no more occurrences are found, and the loop breaks.\n   - Otherwise, the `start` index is updated to the position right after the found occurrence (i.e., `start + 1`), and the `count` is incremented by 1.\n\n3. **Return**:\n   - After the loop ends, the function returns the total count of occurrences.\n\nThis approach ensures that overlapping occurrences are counted correctly by incrementing the `start` index by 1 each time an occurrence is found."}
{"task_id": "CPP/143", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <vector>\nusing namespace std;\n\nbool is_prime(int n) {\n    if (n <= 1) {\n        return false;\n    }\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nstring words_in_sentence(string sentence) {\n    stringstream ss(sentence);\n    string word;\n    vector<string> prime_length_words;\n    \n    while (ss >> word) {\n        if (is_prime(word.length())) {\n            prime_length_words.push_back(word);\n        }\n    }\n    \n    string result;\n    for (const auto& w : prime_length_words) {\n        if (!result.empty()) {\n            result += \" \";\n        }\n        result += w;\n    }\n    \n    return result;\n}\n\n", "py_code": "def is_prime(n):\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef words_in_sentence(sentence):\n    words = sentence.split()\n    prime_length_words = [word for word in words if is_prime(len(word))]\n    return ' '.join(prime_length_words)\n", "py_summary": "The Python code defines a function `words_in_sentence` that takes a string `sentence` as input and returns a new string containing only the words whose lengths are prime numbers. The function works as follows:\n\n1. **Prime Check Function (`is_prime`)**:\n   - This helper function checks if a given number `n` is a prime number.\n   - It returns `False` if `n` is less than or equal to 1.\n   - It iterates from 2 to the square root of `n` (inclusive) and checks if `n` is divisible by any number in this range. If it is, the function returns `False`.\n   - If no divisors are found, the function returns `True`.\n\n2. **Main Function (`words_in_sentence`)**:\n   - The input sentence is split into a list of words using the `split()` method.\n   - A list comprehension is used to filter out words whose lengths are prime numbers by calling the `is_prime` function.\n   - The filtered words are joined back into a single string using the `join()` method, with spaces separating the words.\n   - The resulting string is returned.\n\nThis approach ensures that the order of the words in the output string is the same as in the original sentence, and only words with prime lengths are included."}
{"task_id": "CPP/108", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\nusing namespace std;\n\n// Helper function to calculate the sum of digits of a number\nint sum_of_digits(int num) {\n    bool is_negative = num < 0;\n    if (is_negative) {\n        num = -num; // Make the number positive for easier digit extraction\n    }\n\n    int sum = 0;\n    while (num > 0) {\n        int digit = num % 10;\n        sum += digit;\n        num /= 10;\n    }\n\n    if (is_negative) {\n        sum -= 2 * (sum % 10); // Adjust the sum to account for the first digit being negative\n    }\n\n    return sum;\n}\n\n// Main function to count the number of elements with a sum of digits > 0\nint count_nums(vector<int> n) {\n    int count = 0;\n    for (int num : n) {\n        if (sum_of_digits(num) > 0) {\n            count++;\n        }\n    }\n    return count;\n}\n\n// Function to test the count_nums function\nvoid test_count_nums() {\n    assert(count_nums({}) == 0);\n    assert(count_nums({-1, 11, -11}) == 1);\n    assert(count_nums({1, 1, 2}) == 3);\n    cout << \"All test cases passed!\" << endl;\n}\n\n", "py_code": "def count_nums(nums):\n    def sum_of_digits(num):\n        return sum(int(digit) for digit in str(num) if digit != '-')\n    \n    count = 0\n    for num in nums:\n        if sum_of_digits(num) > 0:\n            count += 1\n    return count\n", "py_summary": "The Python code defines a function `count_nums` that takes a list of integers as input and returns the number of elements whose sum of digits is greater than 0. The function uses a helper function `sum_of_digits` to calculate the sum of the digits of a given number.\n\nHere's a step-by-step breakdown of the code:\n\n1. **Helper Function `sum_of_digits`**:\n   - This function converts the number to a string to easily iterate over each digit.\n   - It uses a generator expression to sum the digits, ignoring the '-' sign if the number is negative.\n   - The `sum` function then adds up these digits.\n\n2. **Main Function `count_nums`**:\n   - Initializes a counter `count` to 0.\n   - Iterates through each number in the input list `nums`.\n   - For each number, it calls the `sum_of_digits` function to get the sum of its digits.\n   - If the sum of the digits is greater than 0, it increments the counter `count`.\n   - Finally, it returns the value of `count`.\n\nThis approach ensures that the function correctly handles both positive and negative numbers and counts only those numbers whose sum of digits is greater than 0.\n\n"}
{"task_id": "CPP/43", "generation": "#include <iostream>\n#include <vector>\n#include <unordered_set>\nusing namespace std;\n\nbool pairs_sum_to_zero(vector<int> l) {\n    unordered_set<int> seen;\n    for (int num : l) {\n        if (seen.find(-num) != seen.end()) {\n            return true;\n        }\n        seen.insert(num);\n    }\n    return false;\n}\n\n", "py_code": "def pairs_sum_to_zero(l):\n    seen = set()\n    for num in l:\n        if -num in seen:\n            return True\n        seen.add(num)\n    return False\n", "py_summary": "The Python code defines a function `pairs_sum_to_zero` that takes a list of integers as input and returns `True` if there are two distinct elements in the list that sum to zero, and `False` otherwise.\n\nHere's a step-by-step breakdown of how the function works:\n\n1. **Initialization**: A set named `seen` is initialized to keep track of the numbers we have encountered so far.\n2. **Iteration**: The function iterates through each number in the input list `l`.\n3. **Check for Complement**: For each number `num`, it checks if `-num` (the complement that would sum to zero with `num`) is already in the `seen` set.\n   - If `-num` is found in `seen`, it means we have found a pair of numbers that sum to zero, so the function returns `True`.\n4. **Add to Set**: If `-num` is not found in `seen`, the current number `num` is added to the `seen` set.\n5. **Return False**: If the loop completes without finding any such pair, the function returns `False`.\n\nThis approach ensures that the function runs efficiently with a time complexity of O(n), where n is the length of the input list, because both the set operations (checking membership and adding elements) are average O(1) operations.\n\n### Summary\n- **Time Complexity**: O(n)\n- **Space Complexity**: O(n)\n- **Logic**: Use a set to keep track of seen numbers and check for their complements to find pairs that sum to zero."}
{"task_id": "CPP/70", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> strange_sort_list(vector<int> lst) {\n    vector<int> result;\n    while (!lst.empty()) {\n        // Find and remove the minimum value\n        auto min_it = min_element(lst.begin(), lst.end());\n        result.push_back(*min_it);\n        lst.erase(min_it);\n\n        // Check if the list is empty before finding the maximum value\n        if (!lst.empty()) {\n            auto max_it = max_element(lst.begin(), lst.end());\n            result.push_back(*max_it);\n            lst.erase(max_it);\n        }\n    }\n    return result;\n}\n\n// Function to test the strange_sort_list function\nvoid test_strange_sort_list() {\n    vector<int> test1 = {1, 2, 3, 4};\n    vector<int> expected1 = {1, 4, 2, 3};\n    assert(strange_sort_list(test1) == expected1);\n\n    vector<int> test2 = {5, 5, 5, 5};\n    vector<int> expected2 = {5, 5, 5, 5};\n    assert(strange_sort_list(test2) == expected2);\n\n    vector<int> test3 = {};\n    vector<int> expected3 = {};\n    assert(strange_sort_list(test3) == expected3);\n\n    cout << \"All tests passed!\" << endl;\n}\n\n", "py_code": "def strange_sort_list(lst):\n    result = []\n    while lst:\n        # Append the minimum value\n        min_val = min(lst)\n        lst.remove(min_val)\n        result.append(min_val)\n        \n        if lst:\n            # Append the maximum value\n            max_val = max(lst)\n            lst.remove(max_val)\n            result.append(max_val)\n    \n    return result\n", "py_summary": "The Python code defines a function `strange_sort_list` that takes a list of integers as input and returns a new list sorted in a \"strange\" order. The \"strange\" order is defined as follows:\n\n1. Start with the minimum value from the list.\n2. Remove the minimum value from the list and append it to the result list.\n3. If the list is not empty, find the maximum value from the remaining elements.\n4. Remove the maximum value from the list and append it to the result list.\n5. Repeat steps 1-4 until the original list is empty.\n\nHere's a step-by-step breakdown of the code:\n\n1. **Initialization**: An empty list `result` is created to store the final sorted list.\n2. **While Loop**: The loop continues as long as there are elements in the input list `lst`.\n3. **Append Minimum Value**:\n   - The minimum value in the list is found using `min(lst)`.\n   - This minimum value is removed from the list using `lst.remove(min_val)`.\n   - The minimum value is appended to the `result` list.\n4. **Check for Remaining Elements**:\n   - If the list is still not empty, the maximum value in the list is found using `max(lst)`.\n   - This maximum value is removed from the list using `lst.remove(max_val)`.\n   - The maximum value is appended to the `result` list.\n5. **Return Result**: Once the loop completes, the `result` list, which contains the elements in the \"strange\" order, is returned.\n\nThis approach ensures that the list is processed in the specified \"strange\" order, alternating between the minimum and maximum values until the list is exhausted.\n\n"}
{"task_id": "CPP/63", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint fibfib(int n) {\n    if (n == 0 || n == 1) {\n        return 0;\n    } else if (n == 2) {\n        return 1;\n    }\n\n    vector<int> dp(3, 0);\n    dp[0] = 0;\n    dp[1] = 0;\n    dp[2] = 1;\n\n    for (int i = 3; i <= n; ++i) {\n        int next_value = dp[0] + dp[1] + dp[2];\n        dp[0] = dp[1];\n        dp[1] = dp[2];\n        dp[2] = next_value;\n    }\n\n    return dp[2];\n}\n\n", "py_code": "def fibfib(n):\n    if n == 0 or n == 1:\n        return 0\n    elif n == 2:\n        return 1\n    else:\n        dp = [0, 0, 1]\n        for i in range(3, n + 1):\n            dp.append(dp[-1] + dp[-2] + dp[-3])\n        return dp[n]\n", "py_summary": "The Python code defines a function `fibfib` that computes the n-th element of the FibFib sequence. The FibFib sequence is defined as follows:\n- `fibfib(0) == 0`\n- `fibfib(1) == 0`\n- `fibfib(2) == 1`\n- `fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3)` for `n > 2`\n\nThe function uses dynamic programming to efficiently compute the n-th element. Here's a step-by-step breakdown of the code:\n\n1. **Base Cases**:\n   - If `n` is 0 or 1, the function returns 0.\n   - If `n` is 2, the function returns 1.\n\n2. **Dynamic Programming Array**:\n   - An array `dp` is initialized with the first three elements of the FibFib sequence: `[0, 0, 1]`.\n\n3. **Filling the DP Array**:\n   - The function iterates from 3 to `n` (inclusive).\n   - For each `i`, it appends the sum of the last three elements of the `dp` array to the `dp` array. This is done using `dp.append(dp[-1] + dp[-2] + dp[-3])`.\n\n4. **Return the Result**:\n   - After filling the `dp` array up to the n-th element, the function returns `dp[n]`.\n\nThis approach ensures that the function runs in O(n) time complexity and O(n) space complexity, making it efficient for large values of `n`.\n\n"}
{"task_id": "CPP/89", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring encrypt(string s) {\n    string result = \"\";\n    int shift = 2 * 2; // Rotate by 4 places\n\n    for (char c : s) {\n        if (isalpha(c)) {\n            int offset = isupper(c) ? 65 : 97;\n            char shifted_char = static_cast<char>(((c - offset + shift) % 26) + offset);\n            result += shifted_char;\n        } else {\n            result += c;\n        }\n    }\n\n    return result;\n}\n\n", "py_code": "def encrypt(s):\n    result = []\n    shift = 2 * 2  # Rotate by 4 places\n    for char in s:\n        if char.isalpha():\n            offset = 65 if char.isupper() else 97\n            shifted_char = chr(((ord(char) - offset + shift) % 26) + offset)\n            result.append(shifted_char)\n        else:\n            result.append(char)\n    return ''.join(result)\n", "py_summary": "The Python code defines a function `encrypt` that takes a string `s` as input and returns a new string where each letter is shifted down by 4 places in the alphabet. Here's a detailed breakdown of how the function works:\n\n1. **Initialization**:\n   - `result`: An empty list to store the characters of the encrypted string.\n   - `shift`: The number of positions to shift each character. In this case, it is set to `2 * 2`, which equals 4.\n\n2. **Iterate through the input string**:\n   - For each character `char` in the input string `s`, the function checks if the character is an alphabetic letter using `char.isalpha()`.\n\n3. **Calculate the shifted character**:\n   - If the character is an alphabetic letter, the function determines whether it is uppercase or lowercase by checking `char.isupper()`.\n   - The `offset` is set to 65 for uppercase letters (ASCII value of 'A') and 97 for lowercase letters (ASCII value of 'a').\n   - The shifted character is calculated using the formula `chr(((ord(char) - offset + shift) % 26) + offset)`. This formula ensures that the character wraps around the alphabet if it goes beyond 'Z' or 'z'.\n\n4. **Handle non-alphabetic characters**:\n   - If the character is not an alphabetic letter, it is appended to the `result` list without any modification.\n\n5. **Join the result list into a string**:\n   - The `result` list is joined into a single string using `''.join(result)` and returned as the output.\n\nThis approach ensures that the function correctly handles both uppercase and lowercase letters and leaves non-alphabetic characters unchanged."}
{"task_id": "CPP/26", "generation": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <algorithm>\nusing namespace std;\n\nvector<int> remove_duplicates(vector<int> numbers) {\n    unordered_map<int, int> seen;\n    vector<int> result;\n\n    // Count occurrences of each element\n    for (int num : numbers) {\n        seen[num]++;\n    }\n\n    // Add elements to result if they appear exactly once\n    for (int num : numbers) {\n        if (seen[num] == 1) {\n            result.push_back(num);\n        }\n    }\n\n    return result;\n}\n\n// Function to print the vector for testing\nvoid print_vector(const vector<int>& vec) {\n    cout << \"{\";\n    for (size_t i = 0; i < vec.size(); ++i) {\n        cout << vec[i];\n        if (i < vec.size() - 1) {\n            cout << \", \";\n        }\n    }\n    cout << \"}\" << endl;\n}\n\n", "py_code": "from typing import List\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    seen = {}\n    result = []\n    for num in numbers:\n        if num not in seen:\n            seen[num] = 1\n            result.append(num)\n        else:\n            seen[num] += 1\n    return [num for num in result if seen[num] == 1]\n", "py_summary": "The Python code defines a function `remove_duplicates` that takes a list of integers as input and returns a new list with all duplicate elements removed, while preserving the order of the remaining elements.\n\nHere's a step-by-step analysis of the code:\n\n1. **Initialization**:\n   - `seen` is a dictionary used to keep track of the count of each element in the input list.\n   - `result` is a list that will store the elements that appear only once in the input list.\n\n2. **Iterate through the input list**:\n   - For each element `num` in the input list `numbers`, the code checks if `num` is already in the `seen` dictionary.\n   - If `num` is not in `seen`, it is added to `seen` with a count of 1 and appended to the `result` list.\n   - If `num` is already in `seen`, its count is incremented.\n\n3. **Filter out duplicates**:\n   - After the initial pass, the `result` list contains all elements that appeared at least once in the input list.\n   - The final list comprehension `[num for num in result if seen[num] == 1]` filters out any elements that appeared more than once, leaving only those that appeared exactly once.\n\n4. **Return the result**:\n   - The function returns the filtered list, which contains only the unique elements in their original order.\n\nThis approach ensures that the order of the elements in the output list matches their order in the input list, and all duplicates are removed."}
{"task_id": "CPP/104", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nbool has_even_digit(int n) {\n    while (n > 0) {\n        int digit = n % 10;\n        if (digit % 2 == 0) {\n            return true;\n        }\n        n /= 10;\n    }\n    return false;\n}\n\nvector<int> unique_digits(vector<int> x) {\n    vector<int> filtered_list;\n    for (int num : x) {\n        if (!has_even_digit(num)) {\n            filtered_list.push_back(num);\n        }\n    }\n    sort(filtered_list.begin(), filtered_list.end());\n    return filtered_list;\n}\n\n// Test cases\n", "py_code": "def unique_digits(x):\n    def has_even_digit(n):\n        return any(int(digit) % 2 == 0 for digit in str(n))\n    \n    filtered_list = [num for num in x if not has_even_digit(num)]\n    filtered_list.sort()\n    return filtered_list\n", "py_summary": "The Python code defines a function `unique_digits` that takes a list of positive integers `x` and returns a sorted list of all elements that do not contain any even digits.\n\n1. **Helper Function `has_even_digit`**:\n   - This function checks if a given number `n` contains any even digit.\n   - It converts the number to a string and iterates through each character (digit).\n   - It uses the `any` function to return `True` if any digit is even (i.e., `int(digit) % 2 == 0`).\n\n2. **Filtering the List**:\n   - The list comprehension `[num for num in x if not has_even_digit(num)]` filters the input list `x` to include only those numbers that do not have any even digits.\n   - The `not has_even_digit(num)` condition ensures that only numbers without even digits are included.\n\n3. **Sorting the Filtered List**:\n   - The `filtered_list.sort()` method sorts the filtered list in increasing order.\n\n4. **Returning the Result**:\n   - The function returns the sorted list of numbers that do not contain any even digits.\n\nThis approach ensures that the function efficiently filters and sorts the list as required."}
{"task_id": "CPP/90", "generation": "#include <iostream>\n#include <vector>\n#include <set>\n#include <optional>\nusing namespace std;\n\noptional<int> next_smallest(vector<int> lst) {\n    if (lst.size() < 2) {\n        return nullopt;\n    }\n\n    set<int> unique_lst(lst.begin(), lst.end());\n    if (unique_lst.size() < 2) {\n        return nullopt;\n    }\n\n    auto it = unique_lst.begin();\n    advance(it, 1); // Move iterator to the second element\n    return *it;\n}\n\n", "py_code": "def next_smallest(lst):\n    if len(lst) < 2:\n        return None\n    unique_lst = list(set(lst))\n    if len(unique_lst) < 2:\n        return None\n    unique_lst.sort()\n    return unique_lst[1]\n", "py_summary": "The Python code defines a function `next_smallest` that takes a list of integers as input and returns the second smallest element in the list. Here's a step-by-step analysis of the code:\n\n1. **Check Length of List**:\n   - The function first checks if the length of the list is less than 2. If it is, the function returns `None` because there cannot be a second smallest element in a list with fewer than 2 elements.\n\n2. **Remove Duplicates**:\n   - The function converts the list to a set to remove any duplicate elements. This ensures that we only consider unique elements when finding the second smallest element.\n\n3. **Check Length of Unique List**:\n   - After removing duplicates, the function checks if the length of the unique list is less than 2. If it is, the function returns `None` because there cannot be a second smallest element in a list with fewer than 2 unique elements.\n\n4. **Sort the Unique List**:\n   - The function sorts the unique list in ascending order.\n\n5. **Return the Second Smallest Element**:\n   - The function returns the second element in the sorted unique list, which is the second smallest element.\n\nThis approach ensures that the function correctly handles edge cases such as empty lists and lists with duplicate elements.\n\n"}
{"task_id": "CPP/126", "generation": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nbool is_sorted(vector<int> lst) {\n    if (lst.size() <= 1) {\n        return true;\n    }\n\n    int prev_num = lst[0];\n    int count = 1;\n\n    for (size_t i = 1; i < lst.size(); ++i) {\n        int num = lst[i];\n        if (num < prev_num) {\n            return false;\n        }\n        if (num == prev_num) {\n            count += 1;\n            if (count > 2) {\n                return false;\n            }\n        } else {\n            count = 1;\n        }\n        prev_num = num;\n    }\n\n    return true;\n}\n", "py_code": "def is_sorted(lst):\n    if len(lst) <= 1:\n        return True\n\n    prev_num = lst[0]\n    count = 1\n\n    for num in lst[1:]:\n        if num < prev_num:\n            return False\n        if num == prev_num:\n            count += 1\n            if count > 2:\n                return False\n        else:\n            count = 1\n        prev_num = num\n\n    return True\n", "py_summary": "The Python code defines a function `is_sorted` that takes a list of integers as input and returns a boolean indicating whether the list is sorted in ascending order and if any number appears more than twice. Here's a detailed breakdown of how the function works:\n\n1. **Initial Check**: If the list has one or zero elements, it is trivially sorted, so the function returns `True`.\n\n2. **Initialization**: \n   - `prev_num` is initialized to the first element of the list.\n   - `count` is initialized to 1, representing the count of the current number being tracked.\n\n3. **Iteration**:\n   - The function iterates through the list starting from the second element.\n   - For each element `num`:\n     - If `num` is less than `prev_num`, the list is not sorted, and the function returns `False`.\n     - If `num` is equal to `prev_num`, the count is incremented. If the count exceeds 2, the function returns `False` because the number appears more than twice.\n     - If `num` is greater than `prev_num`, the count is reset to 1, and `prev_num` is updated to `num`.\n\n4. **Final Return**: If the loop completes without returning `False`, the function returns `True`, indicating that the list is sorted and no number appears more than twice.\n\nThis approach ensures that the function checks both the sorting order and the frequency of each number efficiently."}
{"task_id": "CPP/68", "generation": "#include <vector>\n#include <limits>\nusing namespace std;\n\nvector<int> pluck(vector<int> arr) {\n    if (arr.empty()) {\n        return {};\n    }\n\n    int min_even_value = numeric_limits<int>::max();\n    int min_index = -1;\n\n    for (int i = 0; i < arr.size(); ++i) {\n        if (arr[i] % 2 == 0 && arr[i] < min_even_value) {\n            min_even_value = arr[i];\n            min_index = i;\n        }\n    }\n\n    if (min_even_value == numeric_limits<int>::max()) {\n        return {};\n    }\n\n    return {min_even_value, min_index};\n}\n", "py_code": "def pluck(arr):\n    if not arr:\n        return []\n    \n    min_even_value = float('inf')\n    min_index = -1\n    \n    for i, value in enumerate(arr):\n        if value % 2 == 0 and value < min_even_value:\n            min_even_value = value\n            min_index = i\n    \n    if min_even_value == float('inf'):\n        return []\n    \n    return [min_even_value, min_index]\n", "py_summary": "The Python code defines a function `pluck` that takes a list of integers `arr` as input and returns a list containing the smallest even value and its index. Here's a step-by-step analysis of the code:\n\n1. **Check if the input list is empty**:\n   - If the input list `arr` is empty, the function immediately returns an empty list `[]`.\n\n2. **Initialize variables**:\n   - `min_even_value` is initialized to positive infinity (`float('inf')`). This variable will store the smallest even value found in the list.\n   - `min_index` is initialized to `-1`. This variable will store the index of the smallest even value found in the list.\n\n3. **Iterate through the list**:\n   - The function uses a `for` loop with `enumerate` to iterate through the list. The `enumerate` function provides both the index `i` and the value `value` of each element in the list.\n   - For each element, the function checks if the value is even (`value % 2 == 0`) and if it is smaller than the current `min_even_value`.\n   - If both conditions are met, the function updates `min_even_value` to the current value and `min_index` to the current index.\n\n4. **Check if an even value was found**:\n   - After the loop, the function checks if `min_even_value` is still positive infinity. If it is, it means no even value was found in the list, and the function returns an empty list `[]`.\n\n5. **Return the result**:\n   - If an even value was found, the function returns a list containing the smallest even value and its index `[min_even_value, min_index]`.\n\nThis approach ensures that the function finds the smallest even value and its index efficiently, handling edge cases such as an empty list or a list with no even values."}
{"task_id": "CPP/58", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\nusing namespace std;\n\nvector<int> common(vector<int> l1, vector<int> l2) {\n    // Convert vectors to sets to get unique elements\n    set<int> set1(l1.begin(), l1.end());\n    set<int> set2(l2.begin(), l2.end());\n    \n    // Find the intersection of the two sets\n    vector<int> common_elements;\n    set_intersection(set1.begin(), set1.end(), set2.begin(), set2.end(), back_inserter(common_elements));\n    \n    // The result is already sorted because sets are ordered\n    return common_elements;\n}\n\n// Function to test the common function\nvoid test_common() {\n    vector<int> result1 = common({1, 4, 3, 34, 653, 2, 5}, {5, 7, 1, 5, 9, 653, 121});\n    vector<int> expected1 = {1, 5, 653};\n    assert(result1 == expected1);\n\n    vector<int> result2 = common({5, 3, 2, 8}, {3, 2});\n    vector<int> expected2 = {2, 3};\n    assert(result2 == expected2);\n\n    cout << \"All tests passed!\" << endl;\n}\n\n", "py_code": "def common(l1, l2):\n    # Convert lists to sets to get unique elements\n    set1 = set(l1)\n    set2 = set(l2)\n    \n    # Find the intersection of the two sets\n    common_elements = set1.intersection(set2)\n    \n    # Convert the set back to a sorted list\n    return sorted(list(common_elements))\n", "py_summary": "The Python code defines a function `common` that takes two lists `l1` and `l2` as input and returns a sorted list of their unique common elements. Here's a step-by-step analysis of the code:\n\n1. **Convert Lists to Sets**:\n   - The function converts both input lists `l1` and `l2` into sets using the `set()` function. This step ensures that each element in the sets is unique and removes any duplicates.\n   - `set1 = set(l1)` creates a set of unique elements from `l1`.\n   - `set2 = set(l2)` creates a set of unique elements from `l2`.\n\n2. **Find the Intersection**:\n   - The function uses the `intersection()` method to find the common elements between `set1` and `set2`. This method returns a new set containing only the elements that are present in both sets.\n   - `common_elements = set1.intersection(set2)` computes the intersection.\n\n3. **Convert the Set to a Sorted List**:\n   - The function converts the resulting set of common elements back to a list using the `list()` function.\n   - `sorted(list(common_elements))` sorts the list in ascending order.\n   - The sorted list is then returned as the output of the function.\n\nThis approach is efficient and leverages the properties of sets to quickly find and sort the common elements.\n\n"}
{"task_id": "CPP/112", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nvector<string> reverse_delete(string s, string c) {\n    // Remove all characters in s that are present in c\n    string result;\n    for (char ch : s) {\n        if (c.find(ch) == string::npos) {\n            result += ch;\n        }\n    }\n\n    // Check if the result string is a palindrome\n    string reversed_result = result;\n    reverse(reversed_result.begin(), reversed_result.end());\n    bool is_palindrome = (result == reversed_result);\n\n    // Return the result string and the palindrome check result\n    return {result, is_palindrome ? \"True\" : \"False\"};\n}\n\n// Function to test the reverse_delete function\nvoid test_reverse_delete() {\n    vector<pair<string, string>> test_cases = {\n        {\"abcde\", \"ae\"},\n        {\"abcdef\", \"b\"},\n        {\"abcdedcba\", \"ab\"}\n    };\n\n    for (const auto& [s, c] : test_cases) {\n        vector<string> result = reverse_delete(s, c);\n        cout << \"For s = \\\"\" << s << \"\\\", c = \\\"\" << c << \"\\\": \";\n        cout << \"(\" << result[0] << \", \" << result[1] << \")\" << endl;\n    }\n}\n\n", "py_code": "def reverse_delete(s, c):\n    # Remove all characters in s that are present in c\n    result = ''.join(ch for ch in s if ch not in c)\n    \n    # Check if the result string is a palindrome\n    is_palindrome = result == result[::-1]\n    \n    # Return the result string and the palindrome check result\n    return [result, str(is_palindrome)]\n", "py_summary": "The Python code defines a function `reverse_delete` that takes two strings `s` and `c` as input. The function performs the following steps:\n\n1. **Remove Characters**: It removes all characters from `s` that are present in `c`. This is done using a list comprehension that iterates over each character in `s` and includes it in the result only if it is not in `c`.\n\n2. **Check Palindrome**: It checks if the resulting string is a palindrome. A string is a palindrome if it reads the same backward as forward. This is done by comparing the string to its reverse.\n\n3. **Return Result**: It returns a list containing the resulting string and a string representation of the boolean value indicating whether the resulting string is a palindrome.\n\nThe function effectively filters out unwanted characters and performs the palindrome check, returning the results in a structured format.\n\n### Summary:\n- **Input**: Two strings `s` and `c`.\n- **Output**: A list containing the filtered string and a string indicating whether it is a palindrome.\n- **Steps**:\n  1. Filter out characters in `s` that are in `c`.\n  2. Check if the filtered string is a palindrome.\n  3. Return the filtered string and the palindrome check result."}
{"task_id": "CPP/96", "generation": "#include <iostream>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\nbool is_prime(int num) {\n    if (num <= 1) {\n        return false;\n    }\n    for (int i = 2; i <= sqrt(num); ++i) {\n        if (num % i == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nvector<int> count_up_to(int n) {\n    vector<int> primes;\n    for (int num = 2; num < n; ++num) {\n        if (is_prime(num)) {\n            primes.push_back(num);\n        }\n    }\n    return primes;\n}\n\n// Test cases\n", "py_code": "def count_up_to(n):\n    def is_prime(num):\n        if num <= 1:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    primes = []\n    for num in range(2, n):\n        if is_prime(num):\n            primes.append(num)\n    return primes\n", "py_summary": "The Python code defines a function `count_up_to` that takes a non-negative integer `n` and returns a list of the first `n` integers that are prime numbers and less than `n`.\n\n1. **Helper Function `is_prime`**:\n   - This function checks if a given number `num` is a prime number.\n   - It returns `False` if `num` is less than or equal to 1, as 1 and negative numbers are not prime.\n   - It iterates from 2 to the square root of `num` (inclusive) and checks if `num` is divisible by any of these numbers. If it is, the function returns `False`.\n   - If no divisors are found, the function returns `True`, indicating that `num` is a prime number.\n\n2. **Main Function `count_up_to`**:\n   - This function initializes an empty list `primes` to store the prime numbers.\n   - It iterates through all numbers from 2 to `n-1`.\n   - For each number, it calls the `is_prime` function to check if the number is prime.\n   - If the number is prime, it appends it to the `primes` list.\n   - Finally, the function returns the list of prime numbers.\n\nThis approach ensures that all prime numbers less than `n` are found and returned in a list.\n\n"}
{"task_id": "CPP/157", "generation": "#include <iostream>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\n\nbool right_angle_triangle(float a, float b, float c) {\n    // Sort the sides to ensure c is the longest side\n    float sides[3] = {a, b, c};\n    sort(sides, sides + 3);\n    a = sides[0];\n    b = sides[1];\n    c = sides[2];\n\n    // Check if the Pythagorean theorem holds\n    return abs(a * a + b * b - c * c) < 1e-6;\n}\n\n", "py_code": "def right_angle_triangle(a, b, c):\n    # Sort the sides to ensure c is the longest side\n    sides = sorted([a, b, c])\n    a, b, c = sides\n\n    # Check if the Pythagorean theorem holds\n    return abs(a**2 + b**2 - c**2) < 1e-6\n", "py_summary": "The Python code defines a function `right_angle_triangle` that takes three side lengths of a triangle as input and returns `True` if the triangle is a right-angled triangle, and `False` otherwise. The function works as follows:\n\n1. **Sorting the Sides**: The function first sorts the side lengths to ensure that `c` is the longest side. This is important because in a right-angled triangle, the square of the longest side (hypotenuse) should be equal to the sum of the squares of the other two sides.\n\n2. **Pythagorean Theorem Check**: The function then checks if the Pythagorean theorem holds for the sorted sides. Specifically, it checks if \\( a^2 + b^2 \\) is approximately equal to \\( c^2 \\). To account for floating-point precision issues, the function uses a small tolerance (`1e-6`) when comparing the values.\n\n3. **Return Result**: If the condition is met, the function returns `True`, indicating that the triangle is a right-angled triangle. Otherwise, it returns `False`.\n\nThis approach ensures that the function correctly identifies right-angled triangles even when dealing with floating-point numbers."}
{"task_id": "CPP/99", "generation": "#include <iostream>\n#include <cmath>\n#include <string>\nusing namespace std;\n\nint closest_integer(string value) {\n    double num = stod(value); // Convert the string to a double\n    int floor_val = static_cast<int>(floor(num)); // Floor value\n    int ceil_val = static_cast<int>(ceil(num)); // Ceiling value\n\n    // Calculate the fractional part\n    double fractional_part = num - floor_val;\n\n    // Determine the closest integer\n    if (fractional_part < 0.5) {\n        return floor_val;\n    } else if (fractional_part > 0.5) {\n        return ceil_val;\n    } else {\n        // If the number is equidistant from two integers, round away from zero\n        return (num > 0) ? ceil_val : floor_val;\n    }\n}\n\n// Function to test the closest_integer function\nvoid test_closest_integer() {\n    cout << \"closest_integer(\\\"10\\\") = \" << closest_integer(\"10\") << endl; // Expected: 10\n    cout << \"closest_integer(\\\"15.3\\\") = \" << closest_integer(\"15.3\") << endl; // Expected: 15\n    cout << \"closest_integer(\\\"14.5\\\") = \" << closest_integer(\"14.5\") << endl; // Expected: 15\n    cout << \"closest_integer(\\\"-14.5\\\") = \" << closest_integer(\"-14.5\") << endl; // Expected: -15\n}\n\n", "py_code": "def closest_integer(value: str) -> int:\n    num = float(value)\n    floor_val = int(num // 1)\n    ceil_val = int(num // 1) + 1 if num > 0 else int(num // 1) - 1\n    if num - floor_val < 0.5:\n        return floor_val\n    elif num - floor_val > 0.5:\n        return ceil_val\n    else:\n        return ceil_val if num > 0 else floor_val\n", "py_summary": "The Python code defines a function `closest_integer` that takes a string `value` representing a number and returns the closest integer to it. The function follows these steps:\n\n1. **Convert the Input String to a Float**: The input string is converted to a floating-point number using `float(value)`.\n2. **Calculate Floor and Ceiling Values**:\n   - `floor_val` is the largest integer less than or equal to the number, calculated using `int(num // 1)`.\n   - `ceil_val` is the smallest integer greater than the number. If the number is positive, it is calculated as `int(num // 1) + 1`. If the number is negative, it is calculated as `int(num // 1) - 1`.\n3. **Determine the Closest Integer**:\n   - If the fractional part of the number (`num - floor_val`) is less than 0.5, the function returns `floor_val`.\n   - If the fractional part is greater than 0.5, the function returns `ceil_val`.\n   - If the fractional part is exactly 0.5, the function returns `ceil_val` if the number is positive, and `floor_val` if the number is negative. This ensures rounding away from zero.\n\nThis approach ensures that the function correctly handles both positive and negative numbers and rounds them away from zero when they are equidistant from two integers.\n\n"}
{"task_id": "CPP/149", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nvector<string> sorted_list_sum(vector<string> lst) {\n    // Filter out strings with odd lengths\n    lst.erase(remove_if(lst.begin(), lst.end(), [](const string& s) {\n        return s.length() % 2 != 0;\n    }), lst.end());\n\n    // Sort the list by length and then alphabetically\n    sort(lst.begin(), lst.end(), [](const string& a, const string& b) {\n        if (a.length() == b.length()) {\n            return a < b;\n        }\n        return a.length() < b.length();\n    });\n\n    return lst;\n}\n\n// Function to test the solution\nvoid test_sorted_list_sum() {\n    assert((sorted_list_sum({\"aa\", \"a\", \"aaa\"}) == vector<string>{\"aa\"}));\n    assert((sorted_list_sum({\"ab\", \"a\", \"aaa\", \"cd\"}) == vector<string>{\"ab\", \"cd\"}));\n    cout << \"All tests passed!\" << endl;\n}\n\n", "py_code": "def sorted_list_sum(lst):\n    # Filter out strings with odd lengths\n    filtered_lst = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort the list by length and then alphabetically\n    filtered_lst.sort(key=lambda x: (len(x), x))\n    \n    return filtered_lst\n", "py_summary": "The Python code defines a function `sorted_list_sum` that takes a list of strings as input and returns a new list of strings after performing the following operations:\n\n1. **Filtering Out Odd-Length Strings**: The function uses a list comprehension to filter out strings that have odd lengths. This is done by checking if the length of each string is even (`len(s) % 2 == 0`).\n\n2. **Sorting the List**: The filtered list is then sorted using the `sort` method. The sorting is done first by the length of the strings and then alphabetically for strings of the same length. This is achieved by passing a lambda function as the key to the `sort` method: `key=lambda x: (len(x), x)`.\n\n3. **Returning the Result**: Finally, the function returns the sorted list of strings.\n\nThis approach ensures that the resulting list contains only strings with even lengths and is sorted in the required order.\n\n"}
{"task_id": "CPP/86", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <sstream>\nusing namespace std;\n\nstring anti_shuffle(string s) {\n    stringstream ss(s);\n    string word, result;\n    bool first_word = true;\n\n    while (ss >> word) {\n        sort(word.begin(), word.end());\n        if (!first_word) {\n            result += \" \";\n        }\n        result += word;\n        first_word = false;\n    }\n\n    // Add any remaining spaces at the end\n    int original_length = s.length();\n    int result_length = result.length();\n    if (original_length > result_length) {\n        result.append(s.substr(result_length));\n    }\n\n    return result;\n}\n\n", "py_code": "def anti_shuffle(s):\n    words = s.split()\n    sorted_words = [''.join(sorted(word)) for word in words]\n    return ' '.join(sorted_words)\n\n", "py_summary": "The Python code defines a function `anti_shuffle` that takes a string `s` as input and returns a new string where each word in the original string is replaced by a new word with its characters sorted in ascending ASCII order. Here's a step-by-step breakdown of how the function works:\n\n1. **Split the String into Words**: The input string `s` is split into a list of words using the `split()` method. This method splits the string at each space character and returns a list of words.\n\n2. **Sort Characters in Each Word**: For each word in the list, the `sorted()` function is used to sort the characters in ascending ASCII order. The `sorted()` function returns a list of characters, which is then joined back into a string using `''.join()`.\n\n3. **Join the Sorted Words**: The list of sorted words is joined back into a single string using `' '.join()`, which inserts a space between each word.\n\n4. **Return the Result**: The function returns the resulting string where each word has its characters sorted in ascending ASCII order.\n\nThis approach ensures that the order of words and spaces in the original string is preserved, while the characters within each word are sorted.\n\n### Example:\n- Input: `\"Hello World!!!\"`\n- Split: `['Hello', 'World!!!']`\n- Sort: `['Hello', '!!!Wdlor']`\n- Join: `\"Hello !!!Wdlor\"`\n\nThe function correctly handles the sorting of characters within each word while maintaining the overall structure of the sentence."}
{"task_id": "CPP/129", "generation": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <tuple>\n#include <algorithm>\n\nusing namespace std;\n\n// Define a custom comparator for the priority queue\nstruct Compare {\n    bool operator()(const tuple<int, int, int, vector<int>>& a, const tuple<int, int, int, vector<int>>& b) {\n        // Compare the last element of the path\n        int last_a = get<0>(a);\n        int last_b = get<0>(b);\n        if (last_a != last_b) {\n            return last_a > last_b;\n        }\n        // If the last elements are the same, compare the entire path\n        const vector<int>& path_a = get<3>(a);\n        const vector<int>& path_b = get<3>(b);\n        return path_a > path_b;\n    }\n};\n\nvector<int> minPath(vector<vector<int>> grid, int k) {\n    int N = grid.size();\n    vector<pair<int, int>> directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n    \n    // Priority queue to store (current value, x, y, path)\n    priority_queue<tuple<int, int, int, vector<int>>, vector<tuple<int, int, int, vector<int>>>, Compare> pq;\n    \n    // Initialize the priority queue with all possible starting positions\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            pq.push({grid[i][j], i, j, {grid[i][j]}});\n        }\n    }\n    \n    while (!pq.empty()) {\n        auto [current_value, x, y, path] = pq.top();\n        pq.pop();\n        \n        if (path.size() == k) {\n            return path;\n        }\n        \n        for (auto& [dx, dy] : directions) {\n            int nx = x + dx, ny = y + dy;\n            if (0 <= nx && nx < N && 0 <= ny && ny < N) {\n                vector<int> new_path = path;\n                new_path.push_back(grid[nx][ny]);\n                pq.push({grid[nx][ny], nx, ny, new_path});\n            }\n        }\n    }\n    \n    return {};\n}\n\n", "py_code": "from typing import List\nimport heapq\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    N = len(grid)\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Priority queue to store (current path, current position)\n    pq = []\n    for i in range(N):\n        for j in range(N):\n            heapq.heappush(pq, (grid[i][j], (i, j), [grid[i][j]]))\n    \n    while pq:\n        current_value, (x, y), path = heapq.heappop(pq)\n        \n        if len(path) == k:\n            return path\n        \n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < N and 0 <= ny < N:\n                new_path = path + [grid[nx][ny]]\n                heapq.heappush(pq, (new_path[-1], (nx, ny), new_path))\n    \n    return []\n\n", "py_summary": "### Analysis of the Python Code\n\nThe Python code defines a function `minPath` that finds the minimum path of length `k` in a given grid. Here's a detailed breakdown of how the code works:\n\n1. **Initialization**:\n   - `N` is the size of the grid (number of rows or columns).\n   - `directions` is a list of tuples representing the possible moves (right, down, left, up).\n\n2. **Priority Queue**:\n   - A priority queue (`pq`) is used to explore paths in the grid. Each element in the priority queue is a tuple containing:\n     - The value of the current cell.\n     - The current position `(x, y)`.\n     - The path taken so far as a list of cell values.\n   - The priority queue is initialized by pushing all possible starting positions into it. Each starting position is represented by the value of the cell, the position `(x, y)`, and a path containing only the current cell value.\n\n3. **Breadth-First Search (BFS) with Priority Queue**:\n   - The code uses a while loop to process the priority queue until it finds a path of length `k`.\n   - In each iteration, the smallest element (based on the last value in the path) is popped from the priority queue.\n   - If the length of the current path is equal to `k`, the function returns the path.\n   - Otherwise, the code explores all possible moves from the current position `(x, y)` by iterating over the `directions` list.\n   - For each valid move `(nx, ny)`, a new path is created by appending the value of the new cell to the current path, and this new path is pushed into the priority queue.\n\n4. **Return**:\n   - The function returns the path of length `k` when it is found.\n\nThis approach ensures that the path returned is the lexicographically smallest path of length `k` because the priority queue always processes the smallest possible next step first.\n\n### Summary\n- **Data Structures**: Priority queue (min-heap) to efficiently find the next smallest path.\n- **Algorithm**: BFS with a priority queue to explore all possible paths and ensure the lexicographically smallest path is found.\n- **Complexity**: The time complexity is dominated by the operations on the priority queue, which is \\(O(N^2 \\log N^2)\\) in the worst case, where \\(N\\) is the size of the grid.\n\nNow, let's proceed to the C++ solution based on this analysis."}
{"task_id": "CPP/49", "generation": "#include <iostream>\nusing namespace std;\n\nint modp(int n, int p) {\n    int result = 1;\n    int base = 2;\n\n    while (n > 0) {\n        if (n % 2 == 1) {\n            result = (result * base) % p;\n        }\n        base = (base * base) % p;\n        n /= 2;\n    }\n\n    return result;\n}\n\n", "py_code": "def modp(n, p):\n    return pow(2, n, p)\n", "py_summary": "The Python code defines a function `modp` that calculates \\(2^n \\mod p\\). The function uses the built-in `pow` function, which efficiently computes the power of a number and applies the modulo operation in a single step. This is particularly useful for large values of `n` and `p`, as it avoids potential overflow issues that could arise from computing \\(2^n\\) directly before applying the modulo.\n\nHere's a breakdown of the code:\n- `pow(2, n, p)`: This function call computes \\(2^n \\mod p\\). The `pow` function in Python is optimized for such operations and handles large numbers efficiently.\n\n"}
{"task_id": "CPP/156", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring int_to_mini_roman(int number) {\n    vector<int> val = {\n        1000, 900, 500, 400,\n        100, 90, 50, 40,\n        10, 9, 5, 4,\n        1\n    };\n    vector<string> syms = {\n        \"m\", \"cm\", \"d\", \"cd\",\n        \"c\", \"xc\", \"l\", \"xl\",\n        \"x\", \"ix\", \"v\", \"iv\",\n        \"i\"\n    };\n    string roman_num = \"\";\n    int i = 0;\n    while (number > 0) {\n        while (number >= val[i]) {\n            roman_num += syms[i];\n            number -= val[i];\n        }\n        i++;\n    }\n    return roman_num;\n}\n\n// Test cases\n", "py_code": "def int_to_mini_roman(number):\n    val = [\n        1000, 900, 500, 400,\n        100, 90, 50, 40,\n        10, 9, 5, 4,\n        1\n    ]\n    syms = [\n        \"m\", \"cm\", \"d\", \"cd\",\n        \"c\", \"xc\", \"l\", \"xl\",\n        \"x\", \"ix\", \"v\", \"iv\",\n        \"i\"\n    ]\n    roman_num = ''\n    i = 0\n    while number > 0:\n        for _ in range(number // val[i]):\n            roman_num += syms[i]\n            number -= val[i]\n        i += 1\n    return roman_num\n", "py_summary": "The Python code defines a function `int_to_mini_roman` that converts a given integer to its Roman numeral equivalent in lowercase. Here's a detailed breakdown of how the function works:\n\n1. **Value and Symbol Lists**:\n   - Two lists, `val` and `syms`, are defined. The `val` list contains the integer values corresponding to Roman numerals, and the `syms` list contains the corresponding Roman numeral symbols in lowercase.\n   - These lists are ordered from the largest value to the smallest value, which allows the function to construct the Roman numeral by starting with the largest possible values.\n\n2. **Initialization**:\n   - An empty string `roman_num` is initialized to store the resulting Roman numeral.\n   - An index variable `i` is initialized to 0 to iterate through the `val` and `syms` lists.\n\n3. **Conversion Loop**:\n   - The function enters a `while` loop that continues until `number` becomes 0.\n   - Inside the loop, a nested `for` loop runs `number // val[i]` times. This loop appends the corresponding Roman numeral symbol `syms[i]` to `roman_num` and subtracts `val[i]` from `number` for each iteration.\n   - After the inner loop, the index `i` is incremented to move to the next value and symbol in the lists.\n\n4. **Return Result**:\n   - Once the `while` loop completes, the function returns the constructed Roman numeral string `roman_num`.\n\nThis approach ensures that the function constructs the Roman numeral using the largest possible values first, which is the standard way to represent Roman numerals.\n\n### Example Walkthrough:\n- For `number = 19`:\n  - `19 // 10` is 1, so append \"x\" and subtract 10: `number = 9`.\n  - `9 // 9` is 1, so append \"ix\" and subtract 9: `number = 0`.\n  - Result: \"xix\".\n\n- For `number = 152`:\n  - `152 // 100` is 1, so append \"c\" and subtract 100: `number = 52`.\n  - `52 // 50` is 1, so append \"l\" and subtract 50: `number = 2`.\n  - `2 // 1` is 2, so append \"ii\" and subtract 2: `number = 0`.\n  - Result: \"clii\".\n\n- For `number = 426`:\n  - `426 // 400` is 1, so append \"cd\" and subtract 400: `number = 26`.\n  - `26 // 10` is 2, so append \"xx\" and subtract 20: `number = 6`.\n  - `6 // 5` is 1, so append \"v\" and subtract 5: `number = 1`.\n  - `1 // 1` is 1, so append \"i\" and subtract 1: `number = 0`.\n  - Result: \"cdxxvi\".\n\nThis method ensures that the function correctly converts any integer within the specified range to its Roman numeral equivalent in lowercase."}
{"task_id": "CPP/65", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring circular_shift(int x, int shift) {\n    string s = to_string(x);\n    int n = s.length();\n    shift %= n;  // Handle cases where shift > number of digits\n\n    // Perform the circular shift\n    string shifted = s.substr(n - shift) + s.substr(0, n - shift);\n    return shifted;\n}\n\n", "py_code": "def circular_shift(x, shift):\n    s = str(x)\n    n = len(s)\n    shift %= n  # Handle cases where shift > number of digits\n    return s[-shift:] + s[:-shift]\n", "py_summary": "The Python code defines a function `circular_shift` that takes two parameters: `x` (an integer) and `shift` (an integer representing the number of positions to shift the digits to the right). The function performs the following steps:\n\n1. Convert the integer `x` to a string `s` to easily manipulate the digits.\n2. Calculate the effective shift by taking `shift % n`, where `n` is the length of the string `s`. This handles cases where `shift` is greater than the number of digits in `x`.\n3. Perform the circular shift by slicing the string:\n   - `s[-shift:]` gets the last `shift` characters of the string.\n   - `s[:-shift]` gets the characters from the start of the string up to the `shift`-th character from the end.\n4. Concatenate the two slices to form the shifted string and return it.\n\nThis approach ensures that the function correctly handles both cases where `shift` is less than or equal to the number of digits and where `shift` is greater than the number of digits, effectively reversing the digits in the latter case."}
{"task_id": "CPP/9", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> rolling_max(vector<int> numbers) {\n    if (numbers.empty()) {\n        return {};\n    }\n\n    vector<int> result;\n    int current_max = numbers[0];\n    for (int num : numbers) {\n        if (num > current_max) {\n            current_max = num;\n        }\n        result.push_back(current_max);\n    }\n    return result;\n}\n\n// Function to test the rolling_max function\nvoid test_rolling_max() {\n    vector<int> input = {1, 2, 3, 2, 3, 4, 2};\n    vector<int> expected_output = {1, 2, 3, 3, 3, 4, 4};\n    vector<int> output = rolling_max(input);\n\n    if (output == expected_output) {\n        cout << \"Test passed.\" << endl;\n    } else {\n        cout << \"Test failed.\" << endl;\n    }\n}\n\n", "py_code": "def rolling_max(numbers):\n    if not numbers:\n        return []\n    \n    result = []\n    current_max = numbers[0]\n    for num in numbers:\n        if num > current_max:\n            current_max = num\n        result.append(current_max)\n    return result\n", "py_summary": "The Python code defines a function `rolling_max` that takes a list of integers as input and returns a list of the rolling maximum elements found up to each position in the sequence.\n\n1. **Input Validation**: The function first checks if the input list `numbers` is empty. If it is, the function returns an empty list.\n2. **Initialization**: It initializes an empty list `result` to store the rolling maximum values and sets `current_max` to the first element of the input list.\n3. **Iteration**: The function iterates through each element in the input list `numbers`.\n   - For each element, it checks if the current element is greater than `current_max`. If it is, `current_max` is updated to the current element.\n   - The current value of `current_max` is appended to the `result` list.\n4. **Return**: Finally, the function returns the `result` list, which contains the rolling maximum values.\n\nThis approach ensures that the function correctly computes the rolling maximum for each position in the input list.\n\n"}
{"task_id": "CPP/158", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <set>\nusing namespace std;\n\n// Function to count the number of unique characters in a string\nint unique_chars(const string& word) {\n    set<char> unique_set(word.begin(), word.end());\n    return unique_set.size();\n}\n\n// Function to find the word with the maximum number of unique characters\nstring find_max(vector<string> words) {\n    // Sort the words based on the number of unique characters (in descending order)\n    // and lexicographical order (in ascending order)\n    sort(words.begin(), words.end(), [](const string& a, const string& b) {\n        int unique_a = unique_chars(a);\n        int unique_b = unique_chars(b);\n        if (unique_a == unique_b) {\n            return a < b; // Lexicographical order\n        }\n        return unique_a > unique_b; // Descending order of unique characters\n    });\n\n    // The first word in the sorted list is the one with the maximum number of unique characters\n    // and, in case of ties, the lexicographically smallest one\n    return words[0];\n}\n\n// Main function to test the find_max function\n", "py_code": "from typing import List\n\ndef find_max(words: List[str]) -> str:\n    def unique_chars(word: str) -> int:\n        return len(set(word))\n    \n    words.sort(key=lambda word: (-unique_chars(word), word))\n    return words[0]\n", "py_summary": "The Python code defines a function `find_max` that takes a list of strings as input and returns the string with the maximum number of unique characters. If there are multiple strings with the same maximum number of unique characters, it returns the one that comes first in lexicographical order.\n\nHere's a step-by-step breakdown of the code:\n\n1. **Helper Function `unique_chars`**:\n   - This function takes a word as input and returns the number of unique characters in the word. It does this by converting the word to a set (which automatically removes duplicates) and then returning the length of the set.\n\n2. **Sorting the Words**:\n   - The `words` list is sorted using the `sort` method with a custom key.\n   - The key is a lambda function that returns a tuple `(-unique_chars(word), word)`.\n     - `-unique_chars(word)` ensures that words with more unique characters come first.\n     - `word` ensures that if two words have the same number of unique characters, they are sorted lexicographically.\n\n3. **Returning the Result**:\n   - After sorting, the first element in the sorted list is the word with the maximum number of unique characters and, in case of ties, the lexicographically smallest one. This word is returned by the function.\n\nThis approach ensures that the function efficiently finds the desired word by leveraging Python's built-in sorting capabilities and the properties of sets to count unique characters."}
{"task_id": "CPP/8", "generation": "#include <vector>\n#include <iostream>\nusing namespace std;\n\nvector<int> sum_product(vector<int> numbers) {\n    if (numbers.empty()) {\n        return {0, 1};\n    }\n\n    int total_sum = 0;\n    int total_product = 1;\n\n    for (int number : numbers) {\n        total_sum += number;\n        total_product *= number;\n    }\n\n    return {total_sum, total_product};\n}\n\n// Function to test the sum_product function\nvoid test_sum_product() {\n    vector<int> empty = {};\n    vector<int> test1 = {1, 2, 3, 4};\n    vector<int> result_empty = sum_product(empty);\n    vector<int> result_test1 = sum_product(test1);\n\n    cout << \"Test with empty vector: (\" << result_empty[0] << \", \" << result_empty[1] << \")\" << endl;\n    cout << \"Test with {1, 2, 3, 4}: (\" << result_test1[0] << \", \" << result_test1[1] << \")\" << endl;\n}\n\n", "py_code": "from typing import List\n\ndef sum_product(numbers: List[int]) -> List[int]:\n    if not numbers:\n        return [0, 1]\n    \n    total_sum = sum(numbers)\n    total_product = 1\n    for number in numbers:\n        total_product *= number\n    \n    return [total_sum, total_product]\n", "py_summary": "The Python code defines a function `sum_product` that takes a list of integers as input and returns a list containing the sum and product of all the integers in the input list. Here's a detailed breakdown of how the function works:\n\n1. **Check for Empty Input**:\n   - If the input list `numbers` is empty, the function immediately returns `[0, 1]`. This is because the sum of an empty list is 0, and the product of an empty list is 1.\n\n2. **Calculate the Sum**:\n   - The `sum` function is used to calculate the sum of all the integers in the list. This is a built-in Python function that adds up all the elements in the list.\n\n3. **Calculate the Product**:\n   - The variable `total_product` is initialized to 1. This is because multiplying by 1 does not change the value.\n   - The function then iterates through each number in the list and multiplies it to `total_product`.\n\n4. **Return the Result**:\n   - Finally, the function returns a list containing the calculated sum and product.\n\nThis approach ensures that the function handles both non-empty and empty lists correctly and efficiently.\n\n### Summary:\n- **Empty List Handling**: Returns `[0, 1]` for an empty list.\n- **Sum Calculation**: Uses the built-in `sum` function.\n- **Product Calculation**: Iterates through the list and multiplies each element to a running product.\n- **Result**: Returns a list containing the sum and product."}
{"task_id": "CPP/95", "generation": "#include <iostream>\n#include <string>\n#include <map>\n#include <cctype>\n#include <algorithm>\nusing namespace std;\n\nbool isLowercase(const string& str) {\n    return all_of(str.begin(), str.end(), ::islower);\n}\n\nbool isUppercase(const string& str) {\n    return all_of(str.begin(), str.end(), ::isupper);\n}\n\nbool check_dict_case(map<string, string> dict) {\n    if (dict.empty()) {\n        return false;\n    }\n\n    bool all_lower = true;\n    bool all_upper = true;\n\n    for (const auto& kv : dict) {\n        if (!isLowercase(kv.first)) {\n            all_lower = false;\n        }\n        if (!isUppercase(kv.first)) {\n            all_upper = false;\n        }\n    }\n\n    return all_lower || all_upper;\n}\n\n", "py_code": "def check_dict_case(d):\n    if not d:\n        return False\n\n    all_lower = all(k.islower() for k in d.keys())\n    all_upper = all(k.isupper() for k in d.keys())\n\n    return all_lower or all_upper\n", "py_summary": "The Python code defines a function `check_dict_case` that takes a dictionary `d` as input and returns a boolean value indicating whether all keys in the dictionary are either all lowercase or all uppercase. Here's a step-by-step analysis of the code:\n\n1. **Check if the dictionary is empty**:\n   - The function first checks if the dictionary `d` is empty using the condition `if not d`. If the dictionary is empty, it immediately returns `False`.\n\n2. **Check if all keys are lowercase**:\n   - The function uses a generator expression `all(k.islower() for k in d.keys())` to check if all keys in the dictionary are lowercase. The `islower()` method returns `True` if all characters in the string are lowercase, and `False` otherwise. The `all()` function returns `True` if all elements in the iterable (in this case, the generator expression) are `True`.\n\n3. **Check if all keys are uppercase**:\n   - Similarly, the function uses another generator expression `all(k.isupper() for k in d.keys())` to check if all keys in the dictionary are uppercase. The `isupper()` method returns `True` if all characters in the string are uppercase, and `False` otherwise. The `all()` function again returns `True` if all elements in the iterable are `True`.\n\n4. **Return the result**:\n   - The function returns `True` if either all keys are lowercase or all keys are uppercase. Otherwise, it returns `False`.\n\nThis approach ensures that the function correctly identifies whether the keys in the dictionary are consistently in the same case (either all lowercase or all uppercase) or not.\n\n"}
{"task_id": "CPP/55", "generation": "#include <iostream>\nusing namespace std;\n\nint fib(int n) {\n    if (n <= 0) {\n        return 0;\n    } else if (n == 1) {\n        return 1;\n    } else {\n        int a = 0, b = 1;\n        for (int i = 2; i <= n; ++i) {\n            int temp = a + b;\n            a = b;\n            b = temp;\n        }\n        return b;\n    }\n}\n\n", "py_code": "def fib(n):\n    if n <= 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        a, b = 0, 1\n        for _ in range(2, n + 1):\n            a, b = b, a + b\n        return b\n", "py_summary": "The Python code defines a function `fib` that calculates the n-th Fibonacci number using an iterative approach. Here's a breakdown of how the code works:\n\n1. **Base Cases**:\n   - If `n` is less than or equal to 0, the function returns 0. This handles the case where the input is not a positive integer.\n   - If `n` is 1, the function returns 1. This is the first Fibonacci number.\n\n2. **Iterative Calculation**:\n   - For values of `n` greater than 1, the function uses a loop to calculate the Fibonacci number iteratively.\n   - Two variables, `a` and `b`, are initialized to 0 and 1, respectively. These represent the first two Fibonacci numbers.\n   - The loop runs from 2 to `n` (inclusive). In each iteration, the values of `a` and `b` are updated to the next Fibonacci numbers in the sequence.\n   - After the loop completes, `b` contains the n-th Fibonacci number, which is returned by the function.\n\nThis approach is efficient and avoids the exponential time complexity associated with the recursive approach. It has a time complexity of O(n) and a space complexity of O(1).\n\n"}
{"task_id": "CPP/29", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> filter_by_prefix(vector<string> strings, string prefix) {\n    vector<string> filtered_strings;\n    for (const string& s : strings) {\n        if (s.substr(0, prefix.length()) == prefix) {\n            filtered_strings.push_back(s);\n        }\n    }\n    return filtered_strings;\n}\n\n// Function to test the filter_by_prefix function\nvoid test_filter_by_prefix() {\n    vector<string> test1 = {};\n    vector<string> result1 = filter_by_prefix(test1, \"a\");\n    cout << \"Test 1: \";\n    for (const string& s : result1) {\n        cout << s << \" \";\n    }\n    cout << endl;\n\n    vector<string> test2 = {\"abc\", \"bcd\", \"cde\", \"vector\"};\n    vector<string> result2 = filter_by_prefix(test2, \"a\");\n    cout << \"Test 2: \";\n    for (const string& s : result2) {\n        cout << s << \" \";\n    }\n    cout << endl;\n}\n\n", "py_code": "def filter_by_prefix(strings, prefix):\n    return [s for s in strings if s.startswith(prefix)]\n", "py_summary": "The Python code defines a function `filter_by_prefix` that takes a list of strings and a prefix string as input. The function uses a list comprehension to filter the input list, returning only those strings that start with the given prefix. The `startswith` method of the string class is used to check if a string starts with the specified prefix. The resulting list of filtered strings is then returned.\n\nHere's a step-by-step breakdown:\n1. **Input Parameters**: The function takes two parameters:\n   - `strings`: A list of strings to be filtered.\n   - `prefix`: A string that serves as the prefix to filter the strings.\n2. **List Comprehension**: The function uses a list comprehension to iterate over each string `s` in the `strings` list.\n3. **Condition Check**: For each string `s`, the `startswith` method checks if `s` starts with the `prefix`.\n4. **Result Construction**: If the condition is true, the string `s` is included in the resulting list.\n5. **Return Value**: The function returns the list of strings that start with the given prefix.\n\nThis approach is efficient and concise, leveraging Python's built-in string methods and list comprehensions to achieve the desired filtering."}
{"task_id": "CPP/72", "generation": "#include <iostream>\n#include <vector>\n#include <numeric> // for std::accumulate\n\nbool will_it_fly(const std::vector<int>& q, int w) {\n    // Check if the vector is a palindrome\n    bool is_palindrome = true;\n    for (size_t i = 0, j = q.size() - 1; i < j; ++i, --j) {\n        if (q[i] != q[j]) {\n            is_palindrome = false;\n            break;\n        }\n    }\n\n    // Calculate the sum of the elements\n    int total_weight = std::accumulate(q.begin(), q.end(), 0);\n\n    // Check if the total weight is less than or equal to the maximum weight\n    return is_palindrome && total_weight <= w;\n}\n\n", "py_code": "def will_it_fly(q, w):\n    # Check if the list is a palindrome\n    is_palindrome = q == q[::-1]\n    \n    # Calculate the sum of the elements\n    total_weight = sum(q)\n    \n    # Check if the total weight is less than or equal to the maximum weight\n    return is_palindrome and total_weight <= w\n", "py_summary": "The Python code defines a function `will_it_fly` that takes a list of integers `q` and an integer `w` as input. The function returns `True` if the object represented by `q` will fly, and `False` otherwise. The object will fly if it meets two conditions:\n\n1. **Balanced (Palindromic):** The list `q` is a palindrome, meaning it reads the same forwards and backwards. This is checked using the expression `q == q[::-1]`, which compares the list `q` with its reverse.\n2. **Weight Constraint:** The sum of the elements in `q` is less than or equal to the maximum possible weight `w`. This is checked using the expression `sum(q) <= w`.\n\nThe function combines these two conditions using the logical `and` operator and returns the result. If both conditions are met, the function returns `True`; otherwise, it returns `False`.\n\n### Example Analysis:\n- `will_it_fly([1, 2], 5)` returns `False` because `[1, 2]` is not a palindrome.\n- `will_it_fly([3, 2, 3], 1)` returns `False` because the sum of `[3, 2, 3]` is 8, which is greater than 1.\n- `will_it_fly([3, 2, 3], 9)` returns `True` because `[3, 2, 3]` is a palindrome and the sum is 8, which is less than or equal to 9.\n- `will_it_fly([3], 5)` returns `True` because `[3]` is a palindrome and the sum is 3, which is less than or equal to 5.\n\n"}
{"task_id": "CPP/54", "generation": "#include <iostream>\n#include <string>\n#include <unordered_set>\nusing namespace std;\n\nbool same_chars(string s0, string s1) {\n    // Convert both strings to sets of characters\n    unordered_set<char> set_s0(s0.begin(), s0.end());\n    unordered_set<char> set_s1(s1.begin(), s1.end());\n    \n    // Check if the sets are equal\n    return set_s0 == set_s1;\n}\n\n", "py_code": "def same_chars(s0, s1):\n    # Convert both strings to sets of characters\n    set_s0 = set(s0)\n    set_s1 = set(s1)\n    \n    # Check if the sets are equal\n    return set_s0 == set_s1\n", "py_summary": "The Python code defines a function `same_chars` that takes two strings `s0` and `s1` as input and returns `True` if both strings contain exactly the same unique characters, and `False` otherwise.\n\nHere's a step-by-step analysis of the code:\n\n1. **Convert Strings to Sets**:\n   - The function converts each string into a set of characters using the `set()` function. This removes any duplicate characters and leaves only the unique characters in each string.\n   - `set_s0 = set(s0)` creates a set of unique characters from `s0`.\n   - `set_s1 = set(s1)` creates a set of unique characters from `s1`.\n\n2. **Compare the Sets**:\n   - The function then compares the two sets using the equality operator `==`.\n   - If the sets are equal, it means both strings contain exactly the same unique characters, and the function returns `True`.\n   - If the sets are not equal, it means the strings do not contain the same unique characters, and the function returns `False`.\n\nThis approach is efficient because converting a string to a set and comparing sets are both operations that run in linear time relative to the length of the strings. This ensures that the function performs well even for large input strings."}
{"task_id": "CPP/91", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint is_bored(const string& S) {\n    // Define the delimiters for splitting the string into sentences\n    const string delimiters = \".!?\";\n\n    // Vector to store the sentences\n    vector<string> sentences;\n\n    // Temporary string to hold the current sentence\n    string temp;\n\n    // Iterate through the string to split it into sentences\n    for (char ch : S) {\n        if (delimiters.find(ch) != string::npos) {\n            if (!temp.empty()) {\n                sentences.push_back(temp);\n                temp.clear();\n            }\n        } else {\n            temp += ch;\n        }\n    }\n\n    // Add the last sentence if it exists\n    if (!temp.empty()) {\n        sentences.push_back(temp);\n    }\n\n    // Count the number of sentences that start with \"I\"\n    int boredom_count = 0;\n    for (const string& sentence : sentences) {\n        if (sentence.substr(0, 2) == \"I \") {\n            boredom_count++;\n        } else if (sentence == \"I\") {\n            boredom_count++;\n        }\n    }\n\n    return boredom_count;\n}\n\n// Function to test the is_bored function\nvoid test_is_bored() {\n    cout << is_bored(\"Hello world\") << endl; // Expected output: 0\n    cout << is_bored(\"The sky is blue. The sun is shining. I love this weather\") << endl; // Expected output: 1\n    cout << is_bored(\"I am bored. I really am. Are you?\") << endl; // Expected output: 2\n}\n\n", "py_code": "def is_bored(S):\n    sentences = S.split('.')\n    sentences = [s.strip() for s in sentences if s.strip()]\n    boredom_count = 0\n    for sentence in sentences:\n        if sentence.startswith('I'):\n            boredom_count += 1\n    return boredom_count\n", "py_summary": "The Python code defines a function `is_bored` that takes a string `S` as input and returns the number of sentences that start with the word \"I\". Here's a breakdown of how the function works:\n\n1. **Splitting Sentences**: The input string `S` is split into sentences using the `split('.')` method. This method splits the string at each period (`.`) and returns a list of substrings.\n\n2. **Stripping Whitespace**: The list of substrings is then processed to remove any leading or trailing whitespace using a list comprehension. This ensures that we only consider non-empty sentences.\n\n3. **Counting Boredom Sentences**: The function initializes a counter `boredom_count` to zero. It then iterates through each sentence in the list. For each sentence, it checks if the sentence starts with the word \"I\" using the `startswith('I')` method. If the condition is true, the counter is incremented.\n\n4. **Returning the Result**: Finally, the function returns the value of `boredom_count`, which represents the number of sentences that start with \"I\".\n\nThis approach ensures that the function accurately counts the number of boredom sentences in the input string. However, it currently only considers periods (`.`) as sentence delimiters. To fully meet the problem requirements, we should also consider question marks (`?`) and exclamation marks (`!`) as delimiters.\n\nLet's update the Python code to handle all three delimiters:\n\n```python\nimport re\n\ndef is_bored(S):\n    # Split the string into sentences using '.', '?', and '!' as delimiters\n    sentences = re.split(r'[.!?]', S)\n    sentences = [s.strip() for s in sentences if s.strip()]\n    boredom_count = 0\n    for sentence in sentences:\n        if sentence.startswith('I'):\n            boredom_count += 1\n    return boredom_count\n```\n\nNow, the function uses the `re.split` method from the `re` module to split the string at any of the specified delimiters (`.`), (`?`), or (`!`). This ensures that all types of sentences are correctly identified and counted."}
{"task_id": "CPP/77", "generation": "#include <cmath>\n#include <iostream>\n\nbool iscube(int a) {\n    if (a < 0) {\n        a = -a;\n    }\n    int root = round(cbrt(a));\n    return root * root * root == a;\n}\n\n", "py_code": "import math\n\ndef iscube(a):\n    if a < 0:\n        a = -a\n    root = round(a ** (1/3))\n    return root ** 3 == a\n", "py_summary": "The Python code defines a function `iscube` that checks whether a given integer `a` is a perfect cube of some integer. Here's a step-by-step analysis of the code:\n\n1. **Handling Negative Numbers**: The function first checks if the input `a` is negative. If it is, the function converts `a` to its absolute value. This is because the cube root of a negative number is also negative, and we need to handle both positive and negative inputs uniformly.\n\n2. **Calculating the Cube Root**: The function calculates the cube root of `a` using the expression `a ** (1/3)`. This gives a floating-point number.\n\n3. **Rounding the Cube Root**: The cube root is rounded to the nearest integer using the `round` function. This is necessary because the cube root of an integer might not be an exact integer due to floating-point precision issues.\n\n4. **Checking the Cube**: The function then checks if the cube of the rounded root is equal to the original number `a`. If it is, the function returns `True`, indicating that `a` is a perfect cube. Otherwise, it returns `False`.\n\nThis approach ensures that the function correctly identifies both positive and negative perfect cubes, as well as zero.\n\n"}
{"task_id": "CPP/73", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint smallest_change(vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n    int left = 0;\n    int right = n - 1;\n\n    while (left < right) {\n        if (arr[left] != arr[right]) {\n            changes += 1;\n        }\n        left += 1;\n        right -= 1;\n    }\n\n    return changes;\n}\n\n// Test cases\n", "py_code": "def smallest_change(arr):\n    n = len(arr)\n    changes = 0\n    left = 0\n    right = n - 1\n    \n    while left < right:\n        if arr[left] != arr[right]:\n            changes += 1\n        left += 1\n        right -= 1\n    \n    return changes\n", "py_summary": "The Python code defines a function `smallest_change` that takes a list of integers `arr` as input and returns the minimum number of elements that need to be changed to make the list palindromic. Here's a step-by-step analysis of the code:\n\n1. **Initialization**:\n   - `n` is set to the length of the input list `arr`.\n   - `changes` is initialized to 0 to keep track of the number of changes needed.\n   - `left` is initialized to 0, representing the start index of the list.\n   - `right` is initialized to `n - 1`, representing the end index of the list.\n\n2. **Two-pointer Technique**:\n   - The function uses a while loop to iterate through the list from both ends towards the center.\n   - The loop continues as long as `left` is less than `right`.\n\n3. **Comparison and Counting Changes**:\n   - Inside the loop, the function compares the elements at the `left` and `right` indices.\n   - If the elements are not equal, it increments the `changes` counter by 1, indicating that one change is needed to make these elements equal.\n   - Regardless of whether a change is needed or not, the `left` pointer is incremented and the `right` pointer is decremented to move towards the center of the list.\n\n4. **Return Result**:\n   - After the loop completes, the function returns the total number of changes needed to make the list palindromic.\n\nThis approach ensures that the function efficiently determines the minimum number of changes required by only making a single pass through the list, resulting in a time complexity of O(n).\n\n"}
{"task_id": "CPP/71", "generation": "#include <iostream>\n#include <cmath>\n#include <iomanip>\nusing namespace std;\n\nfloat triangle_area(float a, float b, float c) {\n    // Check if the sides form a valid triangle\n    if (a + b > c && a + c > b && b + c > a) {\n        // Calculate the semi-perimeter\n        float s = (a + b + c) / 2;\n        // Calculate the area using Heron's formula\n        float area = sqrt(s * (s - a) * (s - b) * (s - c));\n        // Round the area to 2 decimal places\n        return round(area * 100) / 100;\n    } else {\n        return -1;\n    }\n}\n\n", "py_code": "def triangle_area(a, b, c):\n    # Check if the sides form a valid triangle\n    if a + b > c and a + c > b and b + c > a:\n        # Calculate the semi-perimeter\n        s = (a + b + c) / 2\n        # Calculate the area using Heron's formula\n        area = (s * (s - a) * (s - b) * (s - c)) ** 0.5\n        # Round the area to 2 decimal places\n        return round(area, 2)\n    else:\n        return -1\n", "py_summary": "The Python code defines a function `triangle_area` that takes three parameters `a`, `b`, and `c`, which represent the lengths of the sides of a triangle. The function performs the following steps:\n\n1. **Validation of Triangle Sides**: It first checks if the given sides can form a valid triangle. According to the triangle inequality theorem, the sum of the lengths of any two sides must be greater than the length of the remaining side. This is checked using the conditions `a + b > c`, `a + c > b`, and `b + c > a`.\n\n2. **Calculation of Semi-Perimeter**: If the sides form a valid triangle, the function calculates the semi-perimeter `s` of the triangle using the formula:\n   \\[\n   s = \\frac{a + b + c}{2}\n   \\]\n\n3. **Calculation of Area**: The function then calculates the area of the triangle using Heron's formula:\n   \\[\n   \\text{area} = \\sqrt{s \\cdot (s - a) \\cdot (s - b) \\cdot (s - c)}\n   \\]\n\n4. **Rounding the Area**: The area is rounded to 2 decimal places using the `round` function.\n\n5. **Return the Result**: If the sides do not form a valid triangle, the function returns `-1`. Otherwise, it returns the rounded area.\n\nThis approach ensures that the function correctly handles both valid and invalid triangle inputs and provides the area with the required precision.\n\n"}
{"task_id": "CPP/82", "generation": "#include <iostream>\n#include <string>\n#include <cmath>\nusing namespace std;\n\nbool is_prime(int n) {\n    if (n <= 1) {\n        return false;\n    }\n    if (n <= 3) {\n        return true;\n    }\n    if (n % 2 == 0 || n % 3 == 0) {\n        return false;\n    }\n    for (int i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nbool prime_length(string str) {\n    return is_prime(static_cast<int>(str.length()));\n}\n\n", "py_code": "def is_prime(n):\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef prime_length(s):\n    return is_prime(len(s))\n", "py_summary": "The Python code defines a function `prime_length` that determines whether the length of a given string is a prime number. The function works as follows:\n\n1. **Helper Function `is_prime`**:\n   - This function checks if a given integer `n` is a prime number.\n   - It first handles edge cases: if `n` is less than or equal to 1, it returns `False` (since 0 and 1 are not prime).\n   - For small values of `n` (2 and 3), it returns `True`.\n   - It then checks if `n` is divisible by 2 or 3, returning `False` if it is.\n   - For larger values of `n`, it uses a loop to check divisibility by numbers of the form `6k \u00b1 1` up to the square root of `n`. This is an optimized way to check for primality.\n\n2. **Main Function `prime_length`**:\n   - This function takes a string `s` as input.\n   - It calculates the length of the string using `len(s)`.\n   - It calls the `is_prime` function with the length of the string and returns the result.\n\nThis approach ensures that the function efficiently determines whether the length of the string is a prime number.\n\n"}
{"task_id": "CPP/114", "generation": "#include <iostream>\n#include <vector>\n#include <climits>\nusing namespace std;\n\nlong long minSubArraySum(vector<long long> nums) {\n    long long min_sum = LLONG_MAX; // Initialize min_sum to the maximum possible value\n    long long current_sum = 0; // Initialize current_sum to 0\n\n    for (long long num : nums) {\n        current_sum = min(num, current_sum + num); // Update current_sum\n        min_sum = min(min_sum, current_sum); // Update min_sum\n    }\n\n    return min_sum; // Return the minimum sum of any non-empty sub-vector\n}\n\n// Function to test the solution\nvoid test() {\n    vector<long long> test1 = {2, 3, 4, 1, 2, 4};\n    vector<long long> test2 = {-1, -2, -3};\n\n    cout << \"Test 1: Expected: 1, Got: \" << minSubArraySum(test1) << endl;\n    cout << \"Test 2: Expected: -6, Got: \" << minSubArraySum(test2) << endl;\n}\n\n", "py_code": "def minSubArraySum(nums):\n    min_sum = float('inf')\n    current_sum = 0\n    for num in nums:\n        current_sum = min(num, current_sum + num)\n        min_sum = min(min_sum, current_sum)\n    return min_sum\n", "py_summary": "The Python code defines a function `minSubArraySum` that takes a list of integers `nums` as input and returns the minimum sum of any non-empty sub-vector of `nums`. Here's a step-by-step analysis of the code:\n\n1. **Initialization**:\n   - `min_sum` is initialized to positive infinity (`float('inf')`). This variable will store the minimum sum encountered during the iteration.\n   - `current_sum` is initialized to 0. This variable will store the sum of the current sub-vector being considered.\n\n2. **Iteration**:\n   - The function iterates through each element `num` in the input list `nums`.\n   - For each element, it updates `current_sum` to be the minimum of the current element `num` and the sum of the current sub-vector plus the current element (`current_sum + num`). This step ensures that `current_sum` always represents the minimum sum sub-vector ending at the current element.\n   - It then updates `min_sum` to be the minimum of the current `min_sum` and the updated `current_sum`.\n\n3. **Return**:\n   - After iterating through all elements, the function returns `min_sum`, which contains the minimum sum of any non-empty sub-vector of `nums`.\n\nThis approach uses a dynamic programming technique known as Kadane's algorithm, which efficiently finds the minimum sub-vector sum in linear time.\n\n"}
{"task_id": "CPP/138", "generation": "#include <iostream>\nusing namespace std;\n\nbool is_equal_to_sum_even(int n) {\n    // The smallest sum of 4 positive even numbers is 2 + 2 + 2 + 2 = 8\n    // Any number less than 8 cannot be expressed as the sum of 4 positive even numbers\n    if (n < 8) {\n        return false;\n    }\n    // If n is even and greater than or equal to 8, it can always be expressed as the sum of 4 even numbers\n    return n % 2 == 0;\n}\n\n", "py_code": "def is_equal_to_sum_even(n):\n    # The smallest sum of 4 positive even numbers is 2 + 2 + 2 + 2 = 8\n    # Any number less than 8 cannot be expressed as the sum of 4 positive even numbers\n    if n < 8:\n        return False\n    # If n is even and greater than or equal to 8, it can always be expressed as the sum of 4 even numbers\n    return n % 2 == 0\n", "py_summary": "The Python code defines a function `is_equal_to_sum_even` that determines whether a given integer `n` can be written as the sum of exactly 4 positive even numbers. Here's a step-by-step analysis of the code:\n\n1. **Check if `n` is less than 8**:\n   - The smallest possible sum of 4 positive even numbers is \\(2 + 2 + 2 + 2 = 8\\).\n   - Therefore, any number less than 8 cannot be expressed as the sum of 4 positive even numbers.\n   - If `n` is less than 8, the function immediately returns `False`.\n\n2. **Check if `n` is even**:\n   - For a number to be the sum of 4 even numbers, it must itself be even.\n   - The function checks if `n` is even using the modulus operator (`%`). If `n % 2 == 0`, then `n` is even.\n\n3. **Return the result**:\n   - If both conditions are satisfied (i.e., `n` is at least 8 and `n` is even), the function returns `True`.\n   - Otherwise, it returns `False`.\n\nThis approach ensures that the function correctly identifies whether `n` can be expressed as the sum of 4 positive even numbers.\n\n"}
{"task_id": "CPP/132", "generation": "#include <iostream>\n#include <string>\n#include <stack>\nusing namespace std;\n\nbool is_nested(const string& str) {\n    stack<char> stack;\n    bool nested = false;\n\n    for (char ch : str) {\n        if (ch == '[') {\n            stack.push(ch);\n        } else if (ch == ']') {\n            if (!stack.empty()) {\n                if (stack.size() > 1) {\n                    nested = true;\n                }\n                stack.pop();\n            } else {\n                return false;\n            }\n        }\n    }\n\n    return nested && stack.empty();\n}\n\n", "py_code": "def is_nested(s):\n    stack = []\n    nested = False\n\n    for char in s:\n        if char == '[':\n            stack.append(char)\n        elif char == ']':\n            if stack:\n                if len(stack) > 1:\n                    nested = True\n                stack.pop()\n            else:\n                return False\n\n    return nested and not stack\n", "py_summary": "The Python code defines a function `is_nested` that takes a string `s` as input, which contains only square brackets. The function returns `True` if and only if there is a valid subsequence of brackets where at least one bracket in the subsequence is nested. Here's a detailed breakdown of how the function works:\n\n1. **Initialization**:\n   - `stack`: A list used to keep track of the opening brackets `[`.\n   - `nested`: A boolean flag initialized to `False`. This flag will be set to `True` if a nested bracket is found.\n\n2. **Iterate through the string**:\n   - For each character `char` in the string `s`:\n     - If `char` is an opening bracket `[`, it is pushed onto the stack.\n     - If `char` is a closing bracket `]`:\n       - Check if the stack is not empty (i.e., there is an unmatched opening bracket).\n       - If the stack has more than one element, it means there is a nested bracket, so set `nested` to `True`.\n       - Pop the top element from the stack.\n       - If the stack is empty and a closing bracket is encountered, return `False` because it indicates an invalid sequence.\n\n3. **Final check**:\n   - After iterating through the string, the function checks if `nested` is `True` and the stack is empty. If both conditions are met, it means there is a valid nested subsequence, and the function returns `True`. Otherwise, it returns `False`.\n\nThis approach ensures that the function correctly identifies valid nested subsequences while maintaining the balance of brackets.\n\n"}
{"task_id": "CPP/3", "generation": "#include <vector>\nusing namespace std;\n\nbool below_zero(vector<int> operations) {\n    int balance = 0;\n    for (int operation : operations) {\n        balance += operation;\n        if (balance < 0) {\n            return true;\n        }\n    }\n    return false;\n}\n", "py_code": "def below_zero(operations):\n    balance = 0\n    for operation in operations:\n        balance += operation\n        if balance < 0:\n            return True\n    return False\n", "py_summary": "The Python code defines a function `below_zero` that takes a list of integers representing deposit and withdrawal operations on a bank account. The function initializes a variable `balance` to zero, which represents the current balance of the account. It then iterates through each operation in the list, updating the balance by adding the value of the current operation.\n\nAfter updating the balance, the function checks if the balance is less than zero. If it is, the function immediately returns `True`, indicating that the balance has fallen below zero at some point. If the loop completes without the balance falling below zero, the function returns `False`, indicating that the balance never went below zero.\n\nThis approach ensures that the function efficiently detects the first instance where the balance goes negative, and it does so in a straightforward and easy-to-understand manner.\n\n"}
{"task_id": "CPP/142", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint sum_squares(vector<int> lst) {\n    int result = 0;\n    for (size_t i = 0; i < lst.size(); ++i) {\n        if (i % 3 == 0) {\n            result += lst[i] * lst[i]; // Square the number\n        } else if (i % 4 == 0 && i % 3 != 0) {\n            result += lst[i] * lst[i] * lst[i]; // Cube the number\n        } else {\n            result += lst[i]; // Leave the number unchanged\n        }\n    }\n    return result;\n}\n\n// Test cases\n", "py_code": "def sum_squares(lst):\n    result = 0\n    for i, num in enumerate(lst):\n        if i % 3 == 0:\n            result += num ** 2\n        elif i % 4 == 0:\n            result += num ** 3\n        else:\n            result += num\n    return result\n", "py_summary": "The Python code defines a function `sum_squares` that takes a list of integers as input and returns the sum of the modified list. The modifications are as follows:\n\n1. **Square the integer if its index is a multiple of 3**: This is checked using `if i % 3 == 0`.\n2. **Cube the integer if its index is a multiple of 4 but not a multiple of 3**: This is checked using `elif i % 4 == 0`.\n3. **Leave the integer unchanged if its index is neither a multiple of 3 nor a multiple of 4**: This is handled by the `else` block.\n\nThe function iterates over the list using `enumerate` to get both the index and the value of each element. It then applies the appropriate operation based on the index and adds the result to the `result` variable. Finally, the function returns the sum of the modified list.\n\n### Example Walkthrough:\n- For `lst = [1, 2, 3]`:\n  - Index 0: 1 (multiple of 3) -> 1^2 = 1\n  - Index 1: 2 (not a multiple of 3 or 4) -> 2\n  - Index 2: 3 (not a multiple of 3 or 4) -> 3\n  - Result: 1 + 2 + 3 = 6\n\n- For `lst = [-1, -5, 2, -1, -5]`:\n  - Index 0: -1 (multiple of 3) -> (-1)^2 = 1\n  - Index 1: -5 (not a multiple of 3 or 4) -> -5\n  - Index 2: 2 (not a multiple of 3 or 4) -> 2\n  - Index 3: -1 (multiple of 3) -> (-1)^2 = 1\n  - Index 4: -5 (multiple of 4, not 3) -> (-5)^3 = -125\n  - Result: 1 + (-5) + 2 + 1 + (-125) = -126\n\n"}
{"task_id": "CPP/50", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring encode_shift(string s) {\n    // Returns encoded string by shifting every character by 5 in the alphabet.\n    string out;\n    for (size_t i = 0; i < s.length(); ++i) {\n        int w = ((int)s[i] + 5 - (int)'a') % 26 + (int)'a';\n        out += (char)w;\n    }\n    return out;\n}\n\nstring decode_shift(string s) {\n    // Takes as input string encoded with encode_shift function. Returns decoded string.\n    string out;\n    for (size_t i = 0; i < s.length(); ++i) {\n        int w = ((int)s[i] - 5 - (int)'a' + 26) % 26 + (int)'a'; // Ensure non-negative result\n        out += (char)w;\n    }\n    return out;\n}\n\n", "py_code": "def encode_shift(s: str) -> str:\n    out = \"\"\n    for char in s:\n        shifted_char = chr(((ord(char) - ord('a') + 5) % 26) + ord('a'))\n        out += shifted_char\n    return out\n\ndef decode_shift(s: str) -> str:\n    out = \"\"\n    for char in s:\n        shifted_char = chr(((ord(char) - ord('a') - 5) % 26) + ord('a'))\n        out += shifted_char\n    return out\n", "py_summary": "### Analysis of the Python Code\n\nThe Python code defines two functions: `encode_shift` and `decode_shift`.\n\n1. **`encode_shift(s: str) -> str`**:\n   - **Purpose**: This function encodes a given string by shifting each character 5 positions forward in the alphabet.\n   - **Steps**:\n     - Initialize an empty string `out` to store the encoded result.\n     - Iterate over each character `char` in the input string `s`.\n     - Calculate the new character position using the formula: `((ord(char) - ord('a') + 5) % 26) + ord('a')`. This formula ensures that the character wraps around the alphabet if it goes beyond 'z'.\n     - Convert the new character position back to a character using `chr` and append it to `out`.\n     - Return the encoded string `out`.\n\n2. **`decode_shift(s: str) -> str`**:\n   - **Purpose**: This function decodes a string that was encoded using the `encode_shift` function by shifting each character 5 positions backward in the alphabet.\n   - **Steps**:\n     - Initialize an empty string `out` to store the decoded result.\n     - Iterate over each character `char` in the input string `s`.\n     - Calculate the original character position using the formula: `((ord(char) - ord('a') - 5) % 26) + ord('a')`. This formula ensures that the character wraps around the alphabet if it goes before 'a'.\n     - Convert the original character position back to a character using `chr` and append it to `out`.\n     - Return the decoded string `out`.\n\n### Summary\n- Both functions handle the wrapping of characters around the alphabet using modulo arithmetic.\n- The encoding function shifts characters forward by 5 positions, while the decoding function shifts characters backward by 5 positions.\n- The functions are designed to work with lowercase letters only, as they use the ASCII values of 'a' and 'z' for calculations."}
{"task_id": "CPP/103", "generation": "#include <iostream>\n#include <string>\n#include <cmath>\nusing namespace std;\n\nstring rounded_avg(int n, int m) {\n    if (n > m) {\n        return \"-1\";\n    }\n\n    int total_sum = 0;\n    for (int i = n; i <= m; ++i) {\n        total_sum += i;\n    }\n\n    int count = m - n + 1;\n    int average = total_sum / count;\n\n    string binary_representation = \"\";\n    while (average > 0) {\n        binary_representation = to_string(average % 2) + binary_representation;\n        average /= 2;\n    }\n\n    return binary_representation.empty() ? \"0\" : binary_representation;\n}\n\n", "py_code": "def rounded_avg(n, m):\n    if n > m:\n        return \"-1\"\n    \n    total_sum = sum(range(n, m + 1))\n    count = m - n + 1\n    average = total_sum // count\n    \n    return bin(average)[2:]\n", "py_summary": "The Python code defines a function `rounded_avg` that takes two positive integers `n` and `m` as input and returns a string representing the binary form of the rounded average of the integers from `n` to `m` (inclusive). If `n` is greater than `m`, the function returns \"-1\".\n\nHere's a step-by-step breakdown of the code:\n\n1. **Check if `n` is greater than `m`:**\n   - If `n` is greater than `m`, the function immediately returns \"-1\" because the range is invalid.\n\n2. **Calculate the sum of integers from `n` to `m`:**\n   - The `sum(range(n, m + 1))` expression generates a range of integers from `n` to `m` (inclusive) and calculates their sum.\n\n3. **Calculate the count of integers in the range:**\n   - The `count = m - n + 1` expression calculates the number of integers in the range from `n` to `m`.\n\n4. **Calculate the average:**\n   - The `average = total_sum // count` expression computes the integer division of the total sum by the count, which gives the floor value of the average.\n\n5. **Convert the average to binary:**\n   - The `bin(average)[2:]` expression converts the average to a binary string, removing the \"0b\" prefix.\n\n6. **Return the binary string:**\n   - The function returns the binary string representation of the average.\n\nThis approach ensures that the average is rounded down to the nearest integer and then converted to binary. If the range is invalid, it returns \"-1\"."}
{"task_id": "CPP/57", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool monotonic(vector<float> l) {\n    bool increasing = true;\n    bool decreasing = true;\n\n    for (size_t i = 0; i < l.size() - 1; ++i) {\n        if (l[i] > l[i + 1]) {\n            increasing = false;\n        }\n        if (l[i] < l[i + 1]) {\n            decreasing = false;\n        }\n    }\n\n    return increasing || decreasing;\n}\n\n", "py_code": "def monotonic(l):\n    increasing = all(l[i] <= l[i + 1] for i in range(len(l) - 1))\n    decreasing = all(l[i] >= l[i + 1] for i in range(len(l) - 1))\n    return increasing or decreasing\n", "py_summary": "The Python code defines a function `monotonic` that checks whether a list of numbers is either monotonically increasing or monotonically decreasing. Here's a detailed breakdown of how the function works:\n\n1. **Initialization**:\n   - The function takes a list `l` as input.\n\n2. **Check for Monotonic Increasing**:\n   - The `increasing` variable is assigned the result of the `all` function, which checks if every element in the list is less than or equal to the next element. This is done using a generator expression `l[i] <= l[i + 1] for i in range(len(l) - 1)`.\n   - If all elements satisfy this condition, `increasing` will be `True`; otherwise, it will be `False`.\n\n3. **Check for Monotonic Decreasing**:\n   - Similarly, the `decreasing` variable is assigned the result of the `all` function, which checks if every element in the list is greater than or equal to the next element. This is done using a generator expression `l[i] >= l[i + 1] for i in range(len(l) - 1)`.\n   - If all elements satisfy this condition, `decreasing` will be `True`; otherwise, it will be `False`.\n\n4. **Return Result**:\n   - The function returns `True` if either `increasing` or `decreasing` is `True`, indicating that the list is monotonically increasing or decreasing. Otherwise, it returns `False`.\n\nThis approach ensures that the function correctly identifies whether the list is monotonically increasing or decreasing by checking both conditions separately and combining the results with a logical OR operation."}
{"task_id": "CPP/28", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring concatenate(vector<string> strings) {\n    string result;\n    for (const string& str : strings) {\n        result += str;\n    }\n    return result;\n}\n\n// Test cases\n", "py_code": "def concatenate(strings):\n    return ''.join(strings)\n", "py_summary": "The Python code defines a function `concatenate` that takes a list of strings as input and returns a single string that is the concatenation of all the strings in the list. The function uses the `join` method of the string class, which efficiently concatenates all the elements of the list into a single string. The `join` method is called on an empty string `''`, which means that no additional characters are inserted between the concatenated strings.\n\nHere's a step-by-step breakdown of the code:\n1. The function `concatenate` is defined, taking a single parameter `strings`, which is expected to be a list of strings.\n2. The `join` method is called on an empty string `''`.\n3. The `join` method concatenates all the strings in the `strings` list and returns the resulting string.\n4. The function returns the concatenated string.\n\nThis approach is efficient and concise, leveraging Python's built-in string operations to achieve the desired result."}
{"task_id": "CPP/39", "generation": "#include <iostream>\n#include <cmath>\n#include <vector>\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    if (num <= 3) return true;\n    if (num % 2 == 0 || num % 3 == 0) return false;\n    for (int i = 5; i * i <= num; i += 6) {\n        if (num % i == 0 || num % (i + 2) == 0) return false;\n    }\n    return true;\n}\n\n// Function to generate the n-th Fibonacci number\nint fib(int x) {\n    int a = 0, b = 1;\n    for (int i = 0; i < x; ++i) {\n        int temp = a;\n        a = b;\n        b = temp + b;\n    }\n    return a;\n}\n\n// Function to find the n-th prime Fibonacci number\nint prime_fib(int n) {\n    int count = 0;\n    int i = 1;\n    while (true) {\n        int fib_num = fib(i);\n        if (is_prime(fib_num)) {\n            count += 1;\n            if (count == n) {\n                return fib_num;\n            }\n        }\n        i += 1;\n    }\n}\n\n", "py_code": "from sympy import isprime\n\ndef prime_fib(n):\n    def fib(x):\n        a, b = 0, 1\n        for _ in range(x):\n            a, b = b, a + b\n        return a\n    \n    count = 0\n    i = 1\n    while True:\n        fib_num = fib(i)\n        if isprime(fib_num):\n            count += 1\n            if count == n:\n                return fib_num\n        i += 1\n", "py_summary": "The Python code defines a function `prime_fib` that returns the n-th Fibonacci number that is also a prime number. Here's a detailed breakdown of how the code works:\n\n1. **Importing `isprime` from `sympy`**:\n   - The `isprime` function from the `sympy` library is used to check if a number is prime. This is a convenient and efficient way to determine primality.\n\n2. **Defining the `fib` function**:\n   - The `fib` function is a helper function that generates the x-th Fibonacci number using an iterative approach. It initializes two variables `a` and `b` to 0 and 1, respectively, and iterates `x` times to compute the Fibonacci number.\n\n3. **Main logic in `prime_fib`**:\n   - Initialize a counter `count` to keep track of the number of prime Fibonacci numbers found.\n   - Initialize an index `i` to iterate through Fibonacci numbers.\n   - Use a `while` loop to generate Fibonacci numbers indefinitely.\n   - For each Fibonacci number, check if it is prime using the `isprime` function.\n   - If the Fibonacci number is prime, increment the `count`.\n   - If the `count` reaches `n`, return the current Fibonacci number.\n   - Increment the index `i` to move to the next Fibonacci number.\n\nThis approach ensures that the function will continue generating Fibonacci numbers until it finds the n-th prime Fibonacci number.\n\n"}
{"task_id": "CPP/45", "generation": "#include <iostream>\n#include <cmath>\nusing namespace std;\n\nfloat triangle_area(float a, float h) {\n    return 0.5 * a * h;\n}\n\n", "py_code": "def triangle_area(a, h):\n    return 0.5 * a * h\n", "py_summary": "The Python code defines a function `triangle_area` that calculates the area of a triangle given its base length `a` and height `h`. The formula used to calculate the area is:\n\n\\[ \\text{Area} = \\frac{1}{2} \\times \\text{base} \\times \\text{height} \\]\n\nThe function multiplies the base `a` by the height `h`, and then multiplies the result by 0.5 to get the area. The function returns the calculated area.\n\nThis approach is straightforward and directly applies the mathematical formula for the area of a triangle. The function is simple and efficient, making it easy to understand and use."}
{"task_id": "CPP/145", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\n// Helper function to calculate the sum of digits of an integer\nint digit_sum(int n) {\n    bool is_negative = n < 0;\n    int sum = 0;\n    string num_str = to_string(abs(n));\n    for (char d : num_str) {\n        sum += d - '0';\n    }\n    if (is_negative) {\n        sum -= 2 * (num_str[0] - '0');\n    }\n    return sum;\n}\n\n// Custom comparator for sorting\nbool compare(const pair<int, int>& a, const pair<int, int>& b) {\n    int sum_a = digit_sum(a.first);\n    int sum_b = digit_sum(b.first);\n    if (sum_a == sum_b) {\n        return a.second < b.second;\n    }\n    return sum_a < sum_b;\n}\n\nvector<int> order_by_points(vector<int> nums) {\n    // Create a vector of pairs (number, original index)\n    vector<pair<int, int>> indexed_nums;\n    for (int i = 0; i < nums.size(); ++i) {\n        indexed_nums.push_back({nums[i], i});\n    }\n\n    // Sort the vector using the custom comparator\n    sort(indexed_nums.begin(), indexed_nums.end(), compare);\n\n    // Extract the sorted numbers\n    vector<int> sorted_nums;\n    for (const auto& p : indexed_nums) {\n        sorted_nums.push_back(p.first);\n    }\n\n    return sorted_nums;\n}\n\n", "py_code": "def order_by_points(nums):\n    def digit_sum(n):\n        return sum(int(d) for d in str(n) if d != '-') - (n < 0) * 2 * int(str(n)[1])\n    \n    return sorted(nums, key=lambda x: (digit_sum(x), nums.index(x)))\n\n", "py_summary": "The Python code defines a function `order_by_points` that sorts a list of integers based on the sum of their digits. Here's a detailed breakdown of how the code works:\n\n1. **Helper Function `digit_sum`**:\n   - This function calculates the sum of the digits of a given integer `n`.\n   - It converts the integer to a string to iterate over each character.\n   - It sums the digits, excluding the '-' sign.\n   - For negative numbers, it subtracts twice the value of the first digit (after the '-') to account for the negative sign correctly.\n\n2. **Sorting the List**:\n   - The `sorted` function is used to sort the list `nums`.\n   - The `key` parameter of the `sorted` function is a lambda function that returns a tuple `(digit_sum(x), nums.index(x))` for each element `x` in the list.\n   - The tuple ensures that the primary sorting criterion is the sum of the digits, and the secondary criterion is the original index of the element in the list.\n\n3. **Return the Sorted List**:\n   - The function returns the sorted list of integers.\n\nThis approach ensures that the list is sorted according to the sum of the digits of the integers, and in case of ties, the original order is preserved.\n\n### Example Usage:\n```python\nprint(order_by_points([1, 11, -1, -11, -12]))  # Output: [-1, -11, 1, -12, 11]\nprint(order_by_points([]))  # Output: []\n```\n\n### Summary:\n- The `digit_sum` function correctly handles both positive and negative integers.\n- The `sorted` function with a custom key ensures the desired sorting behavior.\n- The original order is preserved in case of ties in the sum of digits."}
{"task_id": "CPP/84", "generation": "#include <iostream>\n#include <string>\n#include <bitset>\nusing namespace std;\n\nstring solve(int N) {\n    // Calculate the sum of the digits of N\n    int digit_sum = 0;\n    while (N > 0) {\n        digit_sum += N % 10;\n        N /= 10;\n    }\n\n    // Convert the sum to binary and return it as a string\n    string binary_representation = bitset<14>(digit_sum).to_string();\n\n    // Remove leading zeros\n    size_t pos = binary_representation.find_first_not_of('0');\n    if (pos != string::npos) {\n        binary_representation = binary_representation.substr(pos);\n    } else {\n        binary_representation = \"0\"; // Handle the case where digit_sum is 0\n    }\n\n    return binary_representation;\n}\n\n", "py_code": "def solve(N):\n    # Calculate the sum of the digits of N\n    digit_sum = sum(int(digit) for digit in str(N))\n    \n    # Convert the sum to binary and return it as a string\n    binary_representation = bin(digit_sum)[2:]\n    \n    return binary_representation\n", "py_summary": "The Python code defines a function `solve` that takes an integer `N` as input and returns a string representing the binary form of the sum of its digits. Here's a step-by-step breakdown of how the code works:\n\n1. **Calculate the Sum of Digits**:\n   - The function converts the integer `N` to a string using `str(N)`.\n   - It then iterates over each character in the string representation of `N`, converting each character back to an integer using `int(digit)`.\n   - The `sum` function is used to add up all these integers, resulting in the sum of the digits of `N`.\n\n2. **Convert the Sum to Binary**:\n   - The built-in `bin` function is used to convert the sum of the digits to its binary representation.\n   - The `bin` function returns a string prefixed with '0b'. To get the binary number without the prefix, we slice the string starting from the third character using `[2:]`.\n\n3. **Return the Result**:\n   - The function returns the binary representation as a string.\n\nThis approach ensures that the function correctly computes the sum of the digits and converts it to a binary string, which is then returned.\n\n### Example Walkthrough:\n- For `N = 1000`:\n  - Digits: `1, 0, 0, 0`\n  - Sum: `1`\n  - Binary: `1`\n- For `N = 150`:\n  - Digits: `1, 5, 0`\n  - Sum: `6`\n  - Binary: `110`\n- For `N = 147`:\n  - Digits: `1, 4, 7`\n  - Sum: `12`\n  - Binary: `1100`\n\nNow, let's move on to the C++ solution.\n\n"}
{"task_id": "CPP/113", "generation": "#include <vector>\n#include <string>\n#include <cctype>\n#include <algorithm>\nusing namespace std;\n\n// Helper function to count the number of odd digits in a string\nint count_odd_digits(const string& s) {\n    int count = 0;\n    for (char c : s) {\n        if ((c - '0') % 2 != 0) {\n            count++;\n        }\n    }\n    return count;\n}\n\n// Main function to generate the required output\nvector<string> odd_count(vector<string> lst) {\n    vector<string> result;\n    for (const string& s : lst) {\n        int odd_count = count_odd_digits(s);\n        string formatted_string = \"the number of odd elements \" + to_string(odd_count) +\n                                  \"n the str\" + to_string(odd_count) +\n                                  \"ng \" + to_string(odd_count) +\n                                  \" of the \" + to_string(odd_count) +\n                                  \"nput.\";\n        result.push_back(formatted_string);\n    }\n    return result;\n}\n", "py_code": "def odd_count(lst):\n    def count_odd_digits(s):\n        return sum(int(char) % 2 != 0 for char in s)\n    \n    result = []\n    for s in lst:\n        odd_count = count_odd_digits(s)\n        result.append(f'the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.')\n    return result\n", "py_summary": "The Python code defines a function `odd_count` that takes a list of strings as input, where each string consists of only digits. The function returns a list of strings, where each element is a formatted string indicating the number of odd digits in the corresponding input string.\n\nHere's a step-by-step breakdown of the code:\n\n1. **Helper Function `count_odd_digits`**:\n   - This function takes a string `s` as input.\n   - It uses a generator expression inside the `sum` function to count the number of odd digits in the string.\n   - For each character in the string, it converts the character to an integer and checks if it is odd using the modulus operator `%`.\n   - The `sum` function adds up all the `True` values (which are treated as 1) to get the total count of odd digits.\n\n2. **Main Function `odd_count`**:\n   - This function initializes an empty list `result` to store the formatted strings.\n   - It iterates over each string `s` in the input list `lst`.\n   - For each string, it calls the `count_odd_digits` function to get the count of odd digits.\n   - It then formats a string using an f-string, replacing the placeholder `{odd_count}` with the actual count of odd digits.\n   - The formatted string is appended to the `result` list.\n   - Finally, the function returns the `result` list.\n\nThis approach ensures that the output is correctly formatted and matches the required pattern for each input string."}
{"task_id": "CPP/36", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint fizz_buzz(int n) {\n    int count = 0;\n    for (int i = 1; i < n; ++i) {\n        if (i % 11 == 0 || i % 13 == 0) {\n            string num_str = to_string(i);\n            for (char digit : num_str) {\n                if (digit == '7') {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}\n\n", "py_code": "def fizz_buzz(n):\n    count = 0\n    for i in range(1, n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count\n", "py_summary": "The Python code defines a function `fizz_buzz` that takes an integer `n` as input and returns the number of times the digit '7' appears in integers less than `n` that are divisible by either 11 or 13.\n\nHere's a step-by-step breakdown of how the function works:\n\n1. **Initialization**: The function initializes a counter `count` to zero. This counter will keep track of the number of times the digit '7' appears in the qualifying numbers.\n\n2. **Loop Through Numbers**: The function uses a `for` loop to iterate through all integers from 1 to `n-1`.\n\n3. **Check Divisibility**: For each integer `i` in the loop, the function checks if `i` is divisible by 11 or 13 using the modulo operator (`%`). If `i % 11 == 0` or `i % 13 == 0`, the number `i` is divisible by either 11 or 13.\n\n4. **Count Digit '7'**: If the number `i` is divisible by 11 or 13, the function converts `i` to a string and counts the occurrences of the digit '7' using the `str.count` method. The result is added to the `count` variable.\n\n5. **Return Result**: After the loop completes, the function returns the value of `count`, which represents the total number of times the digit '7' appears in the qualifying numbers.\n\nThis approach ensures that the function efficiently counts the occurrences of the digit '7' in the specified range and returns the correct result."}
{"task_id": "CPP/144", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\n\n// Function to compute the greatest common divisor (GCD)\nint gcd(int a, int b) {\n    while (b != 0) {\n        int temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n\n// Function to parse a fraction string and return the numerator and denominator\nstd::pair<int, int> parseFraction(const std::string& fraction) {\n    std::istringstream iss(fraction);\n    int numerator, denominator;\n    char slash;\n    iss >> numerator >> slash >> denominator;\n    return {numerator, denominator};\n}\n\n// Function to multiply two fractions and return the result as a simplified fraction\nstd::pair<int, int> multiplyFractions(const std::pair<int, int>& frac1, const std::pair<int, int>& frac2) {\n    int numerator = frac1.first * frac2.first;\n    int denominator = frac1.second * frac2.second;\n    int gcd_value = gcd(numerator, denominator);\n    return {numerator / gcd_value, denominator / gcd_value};\n}\n\n// Function to check if the result of the multiplication is a whole number\nbool isWholeNumber(const std::pair<int, int>& fraction) {\n    return fraction.second == 1;\n}\n\nbool simplify(const std::string& x, const std::string& n) {\n    auto frac_x = parseFraction(x);\n    auto frac_n = parseFraction(n);\n    auto result = multiplyFractions(frac_x, frac_n);\n    return isWholeNumber(result);\n}\n\n", "py_code": "from fractions import Fraction\n\ndef simplify(x, n):\n    # Convert the string fractions to Fraction objects\n    frac_x = Fraction(x)\n    frac_n = Fraction(n)\n    \n    # Multiply the fractions\n    result = frac_x * frac_n\n    \n    # Check if the result is a whole number\n    return result.denominator == 1\n", "py_summary": "The Python code defines a function `simplify` that takes two string arguments `x` and `n`, which represent fractions. The function performs the following steps:\n\n1. **Convert Strings to Fractions**: The function uses the `Fraction` class from the `fractions` module to convert the string representations of the fractions into `Fraction` objects. This ensures that the fractions are handled correctly and simplifies the arithmetic operations.\n\n2. **Multiply the Fractions**: The function multiplies the two `Fraction` objects `frac_x` and `frac_n`.\n\n3. **Check if the Result is a Whole Number**: After multiplying the fractions, the function checks if the resulting fraction is a whole number by examining the `denominator` attribute of the resulting `Fraction` object. If the denominator is 1, the result is a whole number, and the function returns `True`. Otherwise, it returns `False`.\n\nThis approach leverages the built-in capabilities of the `Fraction` class to handle the arithmetic and simplification of fractions, making the implementation straightforward and reliable.\n\n"}
{"task_id": "CPP/0", "generation": "#include <vector>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\nbool has_close_elements(vector<float> numbers, float threshold) {\n    // Sort the numbers in ascending order\n    sort(numbers.begin(), numbers.end());\n\n    // Iterate through the sorted list to check the difference between adjacent elements\n    for (size_t i = 0; i < numbers.size() - 1; ++i) {\n        if (abs(numbers[i + 1] - numbers[i]) < threshold) {\n            return true;\n        }\n    }\n\n    // If no such pair is found, return false\n    return false;\n}\n", "py_code": "def has_close_elements(numbers, threshold):\n    numbers.sort()\n    for i in range(len(numbers) - 1):\n        if abs(numbers[i + 1] - numbers[i]) < threshold:\n            return True\n    return False\n", "py_summary": "The Python code defines a function `has_close_elements` that takes a list of numbers and a threshold value as input. The function checks if there are any two numbers in the list that are closer to each other than the given threshold.\n\nHere's a step-by-step analysis of the code:\n\n1. **Sorting the Numbers**: The function first sorts the list of numbers in ascending order. Sorting helps in efficiently checking the difference between adjacent elements, as they will be the closest pairs in the sorted list.\n\n2. **Iterating Through the Sorted List**: The function then iterates through the sorted list using a for loop. For each element, it calculates the absolute difference between the current element and the next element.\n\n3. **Checking the Threshold**: If the calculated difference is less than the given threshold, the function immediately returns `True`, indicating that there are two numbers in the list that are closer to each other than the threshold.\n\n4. **Returning False**: If the loop completes without finding any such pair, the function returns `False`, indicating that no two numbers in the list are closer to each other than the threshold.\n\nThis approach ensures that the function runs efficiently with a time complexity of O(n log n) due to the sorting step, followed by a linear scan of the list.\n\n"}
{"task_id": "CPP/17", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\nusing namespace std;\n\nvector<int> parse_music(string music_string) {\n    vector<int> beats;\n    stringstream ss(music_string);\n    string note;\n\n    while (ss >> note) {\n        if (note == \"o\") {\n            beats.push_back(4);\n        } else if (note == \"o|\") {\n            beats.push_back(2);\n        } else if (note == \".|\") {\n            beats.push_back(1);\n        }\n    }\n\n    return beats;\n}\n\n// Function to test the parse_music function\nvoid test_parse_music() {\n    string input = \"o o| .| o| o| .| .| .| .| o o\";\n    vector<int> expected_output = {4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4};\n    vector<int> output = parse_music(input);\n\n    if (output == expected_output) {\n        cout << \"Test passed!\" << endl;\n    } else {\n        cout << \"Test failed!\" << endl;\n    }\n}\n\n", "py_code": "def parse_music(music_string):\n    notes = music_string.split()\n    beats = []\n    for note in notes:\n        if note == \"o\":\n            beats.append(4)\n        elif note == \"o|\":\n            beats.append(2)\n        elif note == \".|\":\n            beats.append(1)\n    return beats\n", "py_summary": "The Python code defines a function `parse_music` that takes a string `music_string` as input and returns a list of integers representing the number of beats each note lasts. The function works as follows:\n\n1. **Split the Input String**: The input string is split into individual notes using the `split()` method, which splits the string by whitespace and returns a list of substrings.\n2. **Initialize the Beats List**: An empty list `beats` is initialized to store the number of beats for each note.\n3. **Iterate Through Notes**: The function iterates through each note in the list of notes.\n   - If the note is \"o\", it appends 4 to the `beats` list (whole note).\n   - If the note is \"o|\", it appends 2 to the `beats` list (half note).\n   - If the note is \".|\", it appends 1 to the `beats` list (quarter note).\n4. **Return the Beats List**: After processing all notes, the function returns the `beats` list.\n\nThis approach ensures that each note in the input string is correctly parsed and its corresponding number of beats is added to the output list."}
{"task_id": "CPP/47", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nfloat median(vector<float> l) {\n    // Sort the vector\n    sort(l.begin(), l.end());\n    \n    int n = l.size();\n    \n    // Check if the size of the vector is even\n    if (n % 2 == 0) {\n        // For even-sized vector, the median is the average of the two middle elements\n        return (l[n / 2 - 1] + l[n / 2]) / 2.0;\n    } else {\n        // For odd-sized vector, the median is the middle element\n        return l[n / 2];\n    }\n}\n\n", "py_code": "def median(l):\n    l.sort()\n    n = len(l)\n    if n % 2 == 0:\n        return (l[n // 2 - 1] + l[n // 2]) / 2\n    else:\n        return l[n // 2]\n", "py_summary": "The Python code defines a function `median` that calculates the median of a list of numbers. Here's a step-by-step analysis of the code:\n\n1. **Sorting the List**: The function first sorts the input list `l` using the `sort()` method. Sorting is necessary to determine the middle element(s) of the list.\n\n2. **Determining the Length**: The length of the sorted list `n` is calculated using `len(l)`.\n\n3. **Checking for Even Length**:\n   - If the length `n` is even (`n % 2 == 0`), the median is the average of the two middle elements. These elements are located at indices `n // 2 - 1` and `n // 2`.\n   - The median is calculated as `(l[n // 2 - 1] + l[n // 2]) / 2`.\n\n4. **Checking for Odd Length**:\n   - If the length `n` is odd, the median is the middle element, which is located at index `n // 2`.\n   - The median is simply `l[n // 2]`.\n\n5. **Returning the Median**: The function returns the calculated median value.\n\nThis approach ensures that the median is correctly computed for both even and odd lengths of the input list.\n\n"}
{"task_id": "CPP/75", "generation": "#include <iostream>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\n// Helper function to check if a number is prime\nbool is_prime(int n) {\n    if (n <= 1) {\n        return false;\n    }\n    for (int i = 2; i <= sqrt(n); ++i) {\n        if (n % i == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\n// Function to determine if the given number is the product of exactly 3 prime numbers\nbool is_multiply_prime(int a) {\n    vector<int> primes;\n    // Generate list of prime numbers less than 100\n    for (int i = 2; i < 100; ++i) {\n        if (is_prime(i)) {\n            primes.push_back(i);\n        }\n    }\n\n    int count = 0;\n    // Count the number of prime factors\n    for (int prime : primes) {\n        if (a % prime == 0) {\n            a /= prime;\n            count += 1;\n        }\n        if (count > 3) {\n            break;\n        }\n    }\n\n    // Check if the number is the product of exactly 3 prime factors\n    return count == 3 && a == 1;\n}\n\n", "py_code": "def is_multiply_prime(a):\n    def is_prime(n):\n        if n <= 1:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    primes = [i for i in range(2, 100) if is_prime(i)]\n    count = 0\n\n    for prime in primes:\n        if a % prime == 0:\n            a //= prime\n            count += 1\n        if count > 3:\n            break\n\n    return count == 3 and a == 1\n", "py_summary": "The Python code defines a function `is_multiply_prime(a)` that checks if the given number `a` is the product of exactly three prime numbers, where each prime number is less than 100. Here's a step-by-step breakdown of how the code works:\n\n1. **Prime Check Function (`is_prime`)**:\n   - This helper function `is_prime(n)` determines whether a number `n` is a prime number.\n   - It returns `False` if `n` is less than or equal to 1.\n   - It checks divisibility from 2 up to the square root of `n`. If any number divides `n` without a remainder, `n` is not a prime, and the function returns `False`.\n   - If no divisors are found, the function returns `True`.\n\n2. **Generate List of Primes**:\n   - A list comprehension is used to generate a list of prime numbers between 2 and 99 using the `is_prime` function.\n\n3. **Count Prime Factors**:\n   - Initialize a counter `count` to keep track of the number of prime factors found.\n   - Iterate through the list of primes.\n   - For each prime, check if it divides `a` without a remainder.\n   - If it does, divide `a` by the prime and increment the counter.\n   - If the counter exceeds 3, break out of the loop early to avoid unnecessary computations.\n\n4. **Final Check**:\n   - After the loop, check if the counter is exactly 3 and `a` has been reduced to 1.\n   - If both conditions are met, return `True`; otherwise, return `False`.\n\nThis approach ensures that the function efficiently checks if `a` is the product of exactly three prime numbers, all of which are less than 100."}
{"task_id": "CPP/124", "generation": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nbool valid_date(const string& date) {\n    // Check if the date string is empty\n    if (date.empty()) {\n        return false;\n    }\n\n    // Check if the date is in the correct format mm-dd-yyyy\n    if (date.length() != 10 || date[2] != '-' || date[5] != '-') {\n        return false;\n    }\n\n    // Extract month, day, and year from the date string\n    int month = stoi(date.substr(0, 2));\n    int day = stoi(date.substr(3, 2));\n    int year = stoi(date.substr(6, 4));\n\n    // Check if the month is valid\n    if (month < 1 || month > 12) {\n        return false;\n    }\n\n    // Check if the day is valid based on the month\n    if (month == 2) {\n        if (day < 1 || day > 29) {\n            return false;\n        }\n    } else if (month == 4 || month == 6 || month == 9 || month == 11) {\n        if (day < 1 || day > 30) {\n            return false;\n        }\n    } else {\n        if (day < 1 || day > 31) {\n            return false;\n        }\n    }\n\n    // If all checks pass, the date is valid\n    return true;\n}\n\n", "py_code": "def valid_date(date: str) -> bool:\n    # Check if the date string is empty\n    if not date:\n        return False\n    \n    # Check if the date is in the correct format mm-dd-yyyy\n    if len(date) != 10 or date[2] != '-' or date[5] != '-':\n        return False\n    \n    # Extract month, day, and year from the date string\n    month = int(date[0:2])\n    day = int(date[3:5])\n    year = int(date[6:10])\n    \n    # Check if the month is valid\n    if month < 1 or month > 12:\n        return False\n    \n    # Check if the day is valid based on the month\n    if month in [1, 3, 5, 7, 8, 10, 12]:\n        if day < 1 or day > 31:\n            return False\n    elif month in [4, 6, 9, 11]:\n        if day < 1 or day > 30:\n            return False\n    elif month == 2:\n        if day < 1 or day > 29:\n            return False\n    \n    # If all checks pass, the date is valid\n    return True\n", "py_summary": "The Python code defines a function `valid_date` that takes a date string as input and returns `True` if the date is valid, otherwise `False`. The function follows these steps to validate the date:\n\n1. **Check if the date string is empty**: If the date string is empty, the function immediately returns `False`.\n\n2. **Check the date format**: The function checks if the date string is exactly 10 characters long and if the hyphens are in the correct positions (at indices 2 and 5). If the format is incorrect, the function returns `False`.\n\n3. **Extract month, day, and year**: The function extracts the month, day, and year from the date string using slicing.\n\n4. **Validate the month**: The function checks if the month is between 1 and 12. If the month is invalid, the function returns `False`.\n\n5. **Validate the day based on the month**:\n   - For months with 31 days (1, 3, 5, 7, 8, 10, 12), the function checks if the day is between 1 and 31.\n   - For months with 30 days (4, 6, 9, 11), the function checks if the day is between 1 and 30.\n   - For February (month 2), the function checks if the day is between 1 and 29.\n\n6. **Return the result**: If all checks pass, the function returns `True`, indicating that the date is valid.\n\nThis approach ensures that the date string is validated according to the specified rules and format."}
{"task_id": "CPP/101", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <cctype>\n\nusing namespace std;\n\nvector<string> words_string(string s) {\n    vector<string> words;\n    string word;\n    istringstream stream(s);\n\n    while (getline(stream, word, ',')) {  // Split by commas first\n        istringstream substream(word);\n        while (substream >> word) {  // Split by spaces within each comma-separated segment\n            words.push_back(word);\n        }\n    }\n\n    return words;\n}\n\n// Function to test the solution\nvoid test_words_string() {\n    vector<string> result1 = words_string(\"Hi, my name is John\");\n    vector<string> expected1 = {\"Hi\", \"my\", \"name\", \"is\", \"John\"};\n    assert(result1 == expected1);\n\n    vector<string> result2 = words_string(\"One, two, three, four, five, six\");\n    vector<string> expected2 = {\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"};\n    assert(result2 == expected2);\n\n    cout << \"All tests passed!\" << endl;\n}\n\n", "py_code": "import re\n\ndef words_string(s):\n    # Use regular expression to split the string by commas or spaces\n    words = re.split(r'[,\\s]+', s)\n    return words\n", "py_summary": "The Python code defines a function `words_string` that takes a string `s` as input and returns a list of words. The function uses the `re.split` method from the `re` module to split the input string by commas or spaces. Here's a breakdown of the code:\n\n1. **Import the `re` module**: This module provides support for regular expressions in Python.\n2. **Define the function `words_string`**: The function takes a single parameter `s`, which is the input string.\n3. **Use `re.split` to split the string**: The `re.split` method splits the string `s` using the regular expression pattern `[,\\s]+`. This pattern matches any sequence of commas or whitespace characters (spaces, tabs, newlines, etc.).\n4. **Return the list of words**: The function returns the list of words obtained from the split operation.\n\nThis approach ensures that the string is split correctly, handling both commas and spaces as delimiters.\n\n### Example Usage\n```python\nprint(words_string(\"Hi, my name is John\"))  # Output: ['Hi', 'my', 'name', 'is', 'John']\nprint(words_string(\"One, two, three, four, five, six\"))  # Output: ['One', 'two', 'three', 'four', 'five', 'six']\n```\n\n### Summary\nThe Python code effectively splits the input string into words using a regular expression to handle both commas and spaces as delimiters. The resulting list of words is returned by the function."}
{"task_id": "CPP/14", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> all_prefixes(string str) {\n    vector<string> prefixes;\n    for (size_t i = 1; i <= str.length(); ++i) {\n        prefixes.push_back(str.substr(0, i));\n    }\n    return prefixes;\n}\n\n// Function to test the all_prefixes function\nvoid test_all_prefixes() {\n    vector<string> result = all_prefixes(\"abc\");\n    for (const string& prefix : result) {\n        cout << prefix << \" \";\n    }\n    cout << endl;\n}\n\n", "py_code": "def all_prefixes(s):\n    prefixes = []\n    for i in range(1, len(s) + 1):\n        prefixes.append(s[:i])\n    return prefixes\n", "py_summary": "The Python code defines a function `all_prefixes` that takes a string `s` as input and returns a list of all possible prefixes of the string, ordered from the shortest to the longest. Here's a step-by-step breakdown of how the function works:\n\n1. **Initialization**: An empty list `prefixes` is created to store the prefixes.\n2. **Loop through the string**: A `for` loop iterates from 1 to the length of the string `s` (inclusive). This ensures that we consider all possible prefix lengths.\n3. **Generate prefixes**: For each iteration, the substring from the start of the string to the current index `i` is appended to the `prefixes` list. This is done using slicing notation `s[:i]`.\n4. **Return the result**: After the loop completes, the `prefixes` list, which now contains all the prefixes, is returned.\n\nThis approach ensures that the prefixes are generated in the correct order, from the shortest to the longest.\n\n### Example:\nFor the input string `\"abc\"`, the function will generate the following prefixes:\n- `\"a\"` (prefix of length 1)\n- `\"ab\"` (prefix of length 2)\n- `\"abc\"` (prefix of length 3)\n\nThe final output will be `[\"a\", \"ab\", \"abc\"]`."}
{"task_id": "CPP/141", "generation": "#include <iostream>\n#include <string>\n#include <cctype>\n#include <algorithm>\nusing namespace std;\n\nstring file_name_check(string file_name) {\n    // Find the position of the dot\n    size_t dot_pos = file_name.find('.');\n    \n    // Check if there is exactly one dot in the file name\n    if (dot_pos == string::npos || file_name.find('.', dot_pos + 1) != string::npos) {\n        return \"No\";\n    }\n    \n    // Split the file name into name part and extension part\n    string name_part = file_name.substr(0, dot_pos);\n    string extension_part = file_name.substr(dot_pos + 1);\n    \n    // Check if the name part is non-empty and starts with a letter\n    if (name_part.empty() || !isalpha(name_part[0])) {\n        return \"No\";\n    }\n    \n    // Check if the name part contains more than three digits\n    int digit_count = count_if(name_part.begin(), name_part.end(), ::isdigit);\n    if (digit_count > 3) {\n        return \"No\";\n    }\n    \n    // Check if the extension part is one of the allowed extensions\n    if (extension_part != \"txt\" && extension_part != \"exe\" && extension_part != \"dll\") {\n        return \"No\";\n    }\n    \n    return \"Yes\";\n}\n\n// Function to test the file_name_check function\nvoid test_file_name_check() {\n    cout << \"file_name_check(\\\"example.txt\\\") => \" << file_name_check(\"example.txt\") << endl;\n    cout << \"file_name_check(\\\"1example.dll\\\") => \" << file_name_check(\"1example.dll\") << endl;\n    cout << \"file_name_check(\\\"file123.txt\\\") => \" << file_name_check(\"file123.txt\") << endl;\n    cout << \"file_name_check(\\\"file1234.txt\\\") => \" << file_name_check(\"file1234.txt\") << endl;\n    cout << \"file_name_check(\\\".txt\\\") => \" << file_name_check(\".txt\") << endl;\n    cout << \"file_name_check(\\\"file.txt.exe\\\") => \" << file_name_check(\"file.txt.exe\") << endl;\n}\n\n", "py_code": "def file_name_check(file_name):\n    # Split the file name into name and extension parts\n    parts = file_name.split('.')\n    \n    # Check if there is exactly one dot in the file name\n    if len(parts) != 2:\n        return \"No\"\n    \n    name_part, extension_part = parts\n    \n    # Check if the name part is non-empty and starts with a letter\n    if not name_part or not name_part[0].isalpha():\n        return \"No\"\n    \n    # Check if the name part contains more than three digits\n    if sum(c.isdigit() for c in name_part) > 3:\n        return \"No\"\n    \n    # Check if the extension part is one of the allowed extensions\n    if extension_part not in {\"txt\", \"exe\", \"dll\"}:\n        return \"No\"\n    \n    return \"Yes\"\n", "py_summary": "The Python code defines a function `file_name_check` that takes a string `file_name` as input and returns \"Yes\" if the file name is valid, and \"No\" otherwise. The function checks the validity of the file name based on the following conditions:\n\n1. **Exactly One Dot**: The file name must contain exactly one dot (`.`). This is checked by splitting the file name using the dot as a delimiter and ensuring the resulting list has exactly two parts.\n2. **Non-Empty Name Part**: The part of the file name before the dot (name part) must be non-empty and must start with a letter from the Latin alphabet (`a-z` or `A-Z`).\n3. **Digit Limit**: The name part should not contain more than three digits (`0-9`).\n4. **Valid Extension**: The part of the file name after the dot (extension part) must be one of the allowed extensions: `txt`, `exe`, or `dll`.\n\nThe function performs these checks in sequence and returns \"No\" as soon as any condition fails. If all conditions are met, it returns \"Yes\".\n\n### Summary of the Python Code:\n- **Split the File Name**: The file name is split into two parts using the dot as a delimiter.\n- **Check for Exactly One Dot**: Ensure the split results in exactly two parts.\n- **Check Non-Empty and Starts with a Letter**: Ensure the name part is non-empty and starts with a letter.\n- **Check Digit Limit**: Count the number of digits in the name part and ensure it does not exceed three.\n- **Check Valid Extension**: Ensure the extension part is one of the allowed extensions.\n\nIf all conditions are satisfied, the function returns \"Yes\"; otherwise, it returns \"No\"."}
{"task_id": "CPP/123", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> get_odd_collatz(int n) {\n    vector<int> collatz_sequence;\n    while (n != 1) {\n        collatz_sequence.push_back(n);\n        if (n % 2 == 0) {\n            n = n / 2;\n        } else {\n            n = 3 * n + 1;\n        }\n    }\n    collatz_sequence.push_back(1);  // Add the final 1 to the sequence\n\n    vector<int> odd_numbers;\n    for (int num : collatz_sequence) {\n        if (num % 2 != 0) {\n            odd_numbers.push_back(num);\n        }\n    }\n\n    sort(odd_numbers.begin(), odd_numbers.end());\n    return odd_numbers;\n}\n\n// Function to test the get_odd_collatz function\nvoid test_get_odd_collatz() {\n    vector<int> result = get_odd_collatz(5);\n    for (int num : result) {\n        cout << num << \" \";\n    }\n    cout << endl;  // Expected output: 1 5\n}\n\n", "py_code": "def get_odd_collatz(n):\n    collatz_sequence = []\n    while n != 1:\n        collatz_sequence.append(n)\n        if n % 2 == 0:\n            n = n // 2\n        else:\n            n = 3 * n + 1\n    collatz_sequence.append(1)  # Add the final 1 to the sequence\n    odd_numbers = [num for num in collatz_sequence if num % 2 != 0]\n    odd_numbers.sort()\n    return odd_numbers\n", "py_summary": "The Python code defines a function `get_odd_collatz` that takes a positive integer `n` as input and returns a sorted list of the odd numbers in the Collatz sequence for `n`.\n\n1. **Initialization**: An empty list `collatz_sequence` is initialized to store the Collatz sequence.\n2. **Generating the Collatz Sequence**:\n   - A `while` loop runs until `n` becomes 1.\n   - In each iteration, the current value of `n` is appended to `collatz_sequence`.\n   - If `n` is even, it is divided by 2.\n   - If `n` is odd, it is transformed to `3 * n + 1`.\n3. **Adding the Final 1**: After the loop, 1 is appended to `collatz_sequence` to ensure the sequence is complete.\n4. **Filtering Odd Numbers**: A list comprehension is used to filter out the odd numbers from `collatz_sequence`.\n5. **Sorting the Odd Numbers**: The filtered list of odd numbers is sorted in ascending order.\n6. **Returning the Result**: The sorted list of odd numbers is returned.\n\nThis approach ensures that the function correctly generates the Collatz sequence, filters the odd numbers, and returns them in sorted order."}
{"task_id": "CPP/148", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nvector<string> bf(string planet1, string planet2) {\n    vector<string> planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n    \n    // Check if both planet names are valid\n    if (find(planets.begin(), planets.end(), planet1) == planets.end() || \n        find(planets.begin(), planets.end(), planet2) == planets.end()) {\n        return {};\n    }\n    \n    // Find the indices of the planets\n    int start_index = find(planets.begin(), planets.end(), planet1) - planets.begin();\n    int end_index = find(planets.begin(), planets.end(), planet2) - planets.begin();\n    \n    // Ensure start_index is less than or equal to end_index\n    if (start_index > end_index) {\n        swap(start_index, end_index);\n    }\n    \n    // Extract the planets between the two indices\n    vector<string> result;\n    for (int i = start_index + 1; i < end_index; ++i) {\n        result.push_back(planets[i]);\n    }\n    \n    return result;\n}\n\n// Function to test the bf function\nvoid test_bf() {\n    vector<string> result1 = bf(\"Jupiter\", \"Neptune\");\n    vector<string> expected1 = {\"Saturn\", \"Uranus\"};\n    assert(result1 == expected1);\n\n    vector<string> result2 = bf(\"Earth\", \"Mercury\");\n    vector<string> expected2 = {\"Venus\"};\n    assert(result2 == expected2);\n\n    vector<string> result3 = bf(\"Mercury\", \"Uranus\");\n    vector<string> expected3 = {\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"};\n    assert(result3 == expected3);\n\n    vector<string> result4 = bf(\"Pluto\", \"Neptune\");\n    vector<string> expected4 = {};\n    assert(result4 == expected4);\n\n    cout << \"All tests passed!\" << endl;\n}\n\n", "py_code": "def bf(planet1, planet2):\n    planets = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n    \n    if planet1 not in planets or planet2 not in planets:\n        return []\n    \n    start_index = planets.index(planet1)\n    end_index = planets.index(planet2)\n    \n    if start_index > end_index:\n        start_index, end_index = end_index, start_index\n    \n    return planets[start_index + 1:end_index]\n", "py_summary": "The Python code defines a function `bf` that takes two planet names as strings (`planet1` and `planet2`) and returns a list of planets whose orbits are located between the orbits of `planet1` and `planet2`, sorted by their proximity to the Sun.\n\nHere's a step-by-step analysis of the code:\n\n1. **Planet List Initialization**:\n   - A list `planets` is defined containing the names of the eight planets in the solar system, ordered by their proximity to the Sun.\n\n2. **Input Validation**:\n   - The function checks if both `planet1` and `planet2` are valid planet names by verifying if they are in the `planets` list. If either planet name is invalid, the function returns an empty list.\n\n3. **Index Determination**:\n   - The indices of `planet1` and `planet2` in the `planets` list are determined using the `index` method.\n\n4. **Ordering Planets**:\n   - To ensure that `start_index` is always less than or equal to `end_index`, the function swaps the indices if `start_index` is greater than `end_index`.\n\n5. **Extracting Intermediate Planets**:\n   - The function uses list slicing to extract the planets between `start_index + 1` and `end_index` (exclusive) and returns this list.\n\nThis approach ensures that the function correctly handles the input and returns the desired list of intermediate planets.\n\n"}
{"task_id": "CPP/133", "generation": "#include <iostream>\n#include <cmath>\n#include <vector>\nusing namespace std;\n\nint sum_squares(vector<float> lst) {\n    int sum = 0;\n    for (float num : lst) {\n        // Round the number to the nearest upper integer (ceiling)\n        int rounded_num = ceil(num);\n        // Square the rounded number and add it to the sum\n        sum += rounded_num * rounded_num;\n    }\n    return sum;\n}\n\n// Function to test the sum_squares function\nvoid test_sum_squares() {\n    vector<float> test_cases[] = {\n        {1, 2, 3},\n        {1, 4, 9},\n        {1, 3, 5, 7},\n        {1.4, 4.2, 0},\n        {-2.4, 1, 1}\n    };\n    int expected_results[] = {14, 98, 84, 29, 6};\n\n    for (int i = 0; i < 5; ++i) {\n        int result = sum_squares(test_cases[i]);\n        if (result == expected_results[i]) {\n            cout << \"Test case \" << i + 1 << \" passed.\" << endl;\n        } else {\n            cout << \"Test case \" << i + 1 << \" failed. Expected \" << expected_results[i] << \", got \" << result << \".\" << endl;\n        }\n    }\n}\n\n", "py_code": "import math\n\ndef sum_squares(lst):\n    # Round each element to the ceiling\n    rounded_lst = [math.ceil(x) for x in lst]\n    # Calculate the sum of squares\n    sum_of_squares = sum(x ** 2 for x in rounded_lst)\n    return sum_of_squares\n", "py_summary": "The Python code defines a function `sum_squares` that takes a list of floating-point numbers as input and returns the sum of the squares of these numbers after rounding each number to the nearest upper integer (ceiling).\n\nHere's a step-by-step breakdown of the code:\n\n1. **Import the `math` module**: This module provides the `ceil` function, which is used to round numbers up to the nearest integer.\n2. **Round each element to the ceiling**: The list comprehension `[math.ceil(x) for x in lst]` iterates over each element in the input list `lst` and applies the `math.ceil` function to round each element to the nearest upper integer.\n3. **Calculate the sum of squares**: Another list comprehension `[x ** 2 for x in rounded_lst]` is used to square each rounded number. The `sum` function then adds up all the squared values.\n4. **Return the result**: The function returns the computed sum of squares.\n\nThis approach ensures that each number is rounded up before squaring, and the final result is the sum of these squared values.\n\n### Example Usage:\n- For `lst = [1, 2, 3]`, the rounded list is `[1, 2, 3]`, and the sum of squares is `1^2 + 2^2 + 3^2 = 1 + 4 + 9 = 14`.\n- For `lst = [1, 4, 9]`, the rounded list is `[1, 4, 9]`, and the sum of squares is `1^2 + 4^2 + 9^2 = 1 + 16 + 81 = 98`.\n- For `lst = [1, 3, 5, 7]`, the rounded list is `[1, 3, 5, 7]`, and the sum of squares is `1^2 + 3^2 + 5^2 + 7^2 = 1 + 9 + 25 + 49 = 84`.\n- For `lst = [1.4, 4.2, 0]`, the rounded list is `[2, 5, 0]`, and the sum of squares is `2^2 + 5^2 + 0^2 = 4 + 25 + 0 = 29`.\n- For `lst = [-2.4, 1, 1]`, the rounded list is `[-2, 1, 1]`, and the sum of squares is `(-2)^2 + 1^2 + 1^2 = 4 + 1 + 1 = 6`.\n\nNow, let's move on to the C++ solution.\n\n"}
{"task_id": "CPP/109", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nbool move_one_ball(vector<int> arr) {\n    if (arr.empty()) {\n        return true;\n    }\n\n    int n = arr.size();\n    // Find the index where the array should start to be sorted\n    int break_point = -1;\n    for (int i = 0; i < n - 1; ++i) {\n        if (arr[i] > arr[i + 1]) {\n            break_point = i;\n            break;\n        }\n    }\n\n    // If no break point is found, the array is already sorted\n    if (break_point == -1) {\n        return true;\n    }\n\n    // Check if the array can be sorted by a single rotation\n    vector<int> rotated_arr(n);\n    for (int i = 0; i < n; ++i) {\n        rotated_arr[i] = arr[(i + break_point + 1) % n];\n    }\n\n    // Check if the rotated array is sorted\n    for (int i = 0; i < n - 1; ++i) {\n        if (rotated_arr[i] > rotated_arr[i + 1]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\n", "py_code": "def move_one_ball(arr):\n    if not arr:\n        return True\n\n    n = len(arr)\n    # Find the index where the array should start to be sorted\n    for i in range(n - 1):\n        if arr[i] > arr[i + 1]:\n            break\n    else:\n        # The array is already sorted\n        return True\n\n    # Check if the array can be sorted by a single rotation\n    rotated_arr = arr[i + 1:] + arr[:i + 1]\n    for j in range(n - 1):\n        if rotated_arr[j] > rotated_arr[j + 1]:\n            return False\n\n    return True\n", "py_summary": "The Python code defines a function `move_one_ball` that determines whether a given list of integers can be sorted in non-decreasing order by performing right shift operations. Here's a step-by-step analysis of the code:\n\n1. **Check for Empty Array**:\n   - If the input array `arr` is empty, the function returns `True` because an empty array is trivially sorted.\n\n2. **Find the Break Point**:\n   - The code iterates through the array to find the first index `i` where the current element is greater than the next element (`arr[i] > arr[i + 1]`). This break point indicates where the array should be split to check for a potential sorted sequence after a rotation.\n   - If no such break point is found (i.e., the array is already sorted), the function returns `True`.\n\n3. **Check Rotated Array**:\n   - If a break point is found, the code creates a new array `rotated_arr` by concatenating the subarray from `i + 1` to the end of the original array with the subarray from the beginning to `i + 1`.\n   - The code then checks if this rotated array is sorted in non-decreasing order by iterating through it and comparing each element with the next one. If any element is greater than the next one, the function returns `False`.\n\n4. **Return Result**:\n   - If the rotated array is sorted, the function returns `True`.\n\nThis approach ensures that the function correctly identifies whether the array can be sorted by performing right shift operations.\n\n### Summary:\n- The function first checks if the array is empty or already sorted.\n- If a break point is found, it constructs a rotated array and checks if it is sorted.\n- The function returns `True` if the array can be sorted by right shifts, otherwise `False`."}
{"task_id": "CPP/100", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> make_a_pile(int n) {\n    vector<int> stones;\n    int current_stones = n;\n    for (int i = 0; i < n; ++i) {\n        stones.push_back(current_stones);\n        if (current_stones % 2 == 0) {\n            current_stones += 2;  // Next even number\n        } else {\n            current_stones += 2;  // Next odd number\n        }\n    }\n    return stones;\n}\n", "py_code": "def make_a_pile(n):\n    stones = []\n    current_stones = n\n    for _ in range(n):\n        stones.append(current_stones)\n        if current_stones % 2 == 0:\n            current_stones += 2  # Next even number\n        else:\n            current_stones += 2  # Next odd number\n    return stones\n", "py_summary": "The Python code defines a function `make_a_pile` that takes a positive integer `n` as input and returns a list of integers representing the number of stones in each level of a pile with `n` levels. Here's a step-by-step analysis of the code:\n\n1. **Initialization**:\n   - An empty list `stones` is created to store the number of stones in each level.\n   - The variable `current_stones` is initialized to `n`, which represents the number of stones in the first level.\n\n2. **Loop through levels**:\n   - A for loop runs `n` times, once for each level of the pile.\n   - In each iteration, the current number of stones (`current_stones`) is appended to the `stones` list.\n   - The `current_stones` value is updated based on whether it is even or odd:\n     - If `current_stones` is even, the next even number is calculated by adding 2.\n     - If `current_stones` is odd, the next odd number is calculated by adding 2.\n\n3. **Return the result**:\n   - After the loop completes, the `stones` list is returned, which contains the number of stones in each level.\n\nThis approach ensures that the number of stones in each subsequent level follows the specified rules: the next odd number if the current number is odd, and the next even number if the current number is even.\n\n"}
{"task_id": "CPP/150", "generation": "#include <iostream>\n#include <cmath>\nusing namespace std;\n\nbool is_prime(int num) {\n    if (num <= 1) {\n        return false;\n    }\n    for (int i = 2; i <= sqrt(num); ++i) {\n        if (num % i == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint x_or_y(int n, int x, int y) {\n    if (is_prime(n)) {\n        return x;\n    } else {\n        return y;\n    }\n}\n\n", "py_code": "def is_prime(num):\n    if num <= 1:\n        return False\n    for i in range(2, int(num**0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef x_or_y(n, x, y):\n    if is_prime(n):\n        return x\n    else:\n        return y\n", "py_summary": "The Python code defines a function `is_prime` that checks whether a given number `num` is a prime number. A prime number is a natural number greater than 1 that has no positive divisors other than 1 and itself. The function works as follows:\n\n1. If the number is less than or equal to 1, it returns `False` because 1 and any number less than 1 are not prime.\n2. It then iterates from 2 to the square root of the number (inclusive). This is because a larger factor of the number would necessarily be paired with a smaller factor that has already been checked.\n3. If the number is divisible by any of these factors, it returns `False`.\n4. If no factors are found, it returns `True`.\n\nThe `x_or_y` function uses the `is_prime` function to determine whether the input number `n` is a prime number. If `n` is prime, it returns the value of `x`; otherwise, it returns the value of `y`.\n\n### Summary:\n- The `is_prime` function efficiently checks if a number is prime by iterating up to the square root of the number.\n- The `x_or_y` function uses the result of `is_prime` to decide which value to return based on whether `n` is prime or not."}
{"task_id": "CPP/153", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\n// Helper function to calculate the strength of an extension\nint calculate_strength(const string& extension) {\n    int cap = 0, sm = 0;\n    for (char ch : extension) {\n        if (isupper(ch)) {\n            cap++;\n        } else if (islower(ch)) {\n            sm++;\n        }\n    }\n    return cap - sm;\n}\n\nstring Strongest_Extension(string class_name, vector<string> extensions) {\n    int max_strength = INT_MIN;\n    string strongest_extension = \"\";\n\n    for (const string& extension : extensions) {\n        int strength = calculate_strength(extension);\n        if (strength > max_strength) {\n            max_strength = strength;\n            strongest_extension = extension;\n        }\n    }\n\n    return class_name + \".\" + strongest_extension;\n}\n\n", "py_code": "def Strongest_Extension(class_name, extensions):\n    def calculate_strength(extension):\n        cap = sum(1 for char in extension if char.isupper())\n        sm = sum(1 for char in extension if char.islower())\n        return cap - sm\n\n    strongest_extension = None\n    max_strength = float('-inf')\n\n    for extension in extensions:\n        strength = calculate_strength(extension)\n        if strength > max_strength:\n            max_strength = strength\n            strongest_extension = extension\n\n    return f\"{class_name}.{strongest_extension}\"\n", "py_summary": "The Python code defines a function `Strongest_Extension` that takes a class name and a list of extensions as input. The goal is to determine the strongest extension based on a specific strength calculation and return a string in the format `ClassName.StrongestExtensionName`.\n\nHere's a detailed breakdown of the code:\n\n1. **Helper Function `calculate_strength`**:\n   - This function takes an extension name as input.\n   - It calculates the number of uppercase letters (`cap`) and the number of lowercase letters (`sm`) in the extension name.\n   - The strength of the extension is defined as `cap - sm`.\n   - The function returns the calculated strength.\n\n2. **Initialization**:\n   - `strongest_extension` is initialized to `None` to keep track of the strongest extension found so far.\n   - `max_strength` is initialized to negative infinity to ensure any valid strength value will be greater initially.\n\n3. **Iterate Through Extensions**:\n   - The code iterates through each extension in the `extensions` list.\n   - For each extension, it calculates the strength using the `calculate_strength` function.\n   - If the calculated strength is greater than the current `max_strength`, it updates `max_strength` and sets `strongest_extension` to the current extension.\n\n4. **Return Result**:\n   - After iterating through all extensions, the function constructs and returns the result string in the format `ClassName.StrongestExtensionName`.\n\nThis approach ensures that the strongest extension is selected, and if multiple extensions have the same strength, the first one encountered in the list is chosen."}
{"task_id": "CPP/107", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nbool is_palindrome(int num) {\n    string str_num = to_string(num);\n    string reversed_str = str_num;\n    reverse(reversed_str.begin(), reversed_str.end());\n    return str_num == reversed_str;\n}\n\nvector<int> even_odd_palindrome(int n) {\n    int even_count = 0;\n    int odd_count = 0;\n\n    for (int i = 1; i <= n; ++i) {\n        if (is_palindrome(i)) {\n            if (i % 2 == 0) {\n                even_count++;\n            } else {\n                odd_count++;\n            }\n        }\n    }\n\n    return {even_count, odd_count};\n}\n\n", "py_code": "def even_odd_palindrome(n):\n    def is_palindrome(num):\n        return str(num) == str(num)[::-1]\n    \n    even_count = 0\n    odd_count = 0\n    \n    for i in range(1, n + 1):\n        if is_palindrome(i):\n            if i % 2 == 0:\n                even_count += 1\n            else:\n                odd_count += 1\n    \n    return [even_count, odd_count]\n", "py_summary": "The Python code defines a function `even_odd_palindrome` that takes a positive integer `n` as input and returns a list containing the number of even and odd integer palindromes within the range [1, n].\n\n1. **Helper Function `is_palindrome`**:\n   - This function checks if a given number is a palindrome by converting it to a string and comparing it to its reverse.\n   - It returns `True` if the number is a palindrome and `False` otherwise.\n\n2. **Initialization**:\n   - Two counters, `even_count` and `odd_count`, are initialized to zero. These will keep track of the number of even and odd palindromes, respectively.\n\n3. **Iterate Through Range**:\n   - The function iterates through all integers from 1 to `n` (inclusive).\n   - For each integer, it checks if it is a palindrome using the `is_palindrome` function.\n   - If the integer is a palindrome, it further checks if it is even or odd and increments the appropriate counter.\n\n4. **Return Result**:\n   - After the loop completes, the function returns a list containing the counts of even and odd palindromes.\n\nThis approach ensures that all integers within the specified range are checked, and the counts of even and odd palindromes are accurately determined.\n\n"}
{"task_id": "CPP/110", "generation": "#include <vector>\n#include <string>\nusing namespace std;\n\nstring exchange(vector<int> lst1, vector<int> lst2) {\n    // Count the number of odd elements in lst1\n    int odd_count_lst1 = 0;\n    for (int x : lst1) {\n        if (x % 2 != 0) {\n            odd_count_lst1++;\n        }\n    }\n\n    // Count the number of even elements in lst2\n    int even_count_lst2 = 0;\n    for (int x : lst2) {\n        if (x % 2 == 0) {\n            even_count_lst2++;\n        }\n    }\n\n    // Check if we have enough even elements in lst2 to replace all odd elements in lst1\n    if (even_count_lst2 >= odd_count_lst1) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n", "py_code": "def exchange(lst1, lst2):\n    # Count the number of odd elements in lst1\n    odd_count_lst1 = sum(1 for x in lst1 if x % 2 != 0)\n    \n    # Count the number of even elements in lst2\n    even_count_lst2 = sum(1 for x in lst2 if x % 2 == 0)\n    \n    # Check if we have enough even elements in lst2 to replace all odd elements in lst1\n    if even_count_lst2 >= odd_count_lst1:\n        return \"YES\"\n    else:\n        return \"NO\"\n", "py_summary": "The Python code defines a function `exchange` that takes two lists of integers, `lst1` and `lst2`, and determines whether it is possible to exchange elements between them to make all elements in `lst1` even.\n\nHere's a step-by-step analysis of the code:\n\n1. **Count Odd Elements in `lst1`**:\n   - The function uses a generator expression inside the `sum` function to count the number of odd elements in `lst1`. This is done by iterating over each element `x` in `lst1` and checking if `x % 2 != 0`. If true, it adds 1 to the sum, otherwise, it adds 0.\n\n2. **Count Even Elements in `lst2`**:\n   - Similarly, the function counts the number of even elements in `lst2` using another generator expression inside the `sum` function. This is done by iterating over each element `x` in `lst2` and checking if `x % 2 == 0`. If true, it adds 1 to the sum, otherwise, it adds 0.\n\n3. **Check Feasibility**:\n   - The function then checks if the number of even elements in `lst2` (`even_count_lst2`) is greater than or equal to the number of odd elements in `lst1` (`odd_count_lst1`). If this condition is met, it means there are enough even elements in `lst2` to replace all the odd elements in `lst1`, making all elements in `lst1` even. In this case, the function returns \"YES\".\n   - If the condition is not met, it means there are not enough even elements in `lst2` to replace all the odd elements in `lst1`, and the function returns \"NO\".\n\nThis approach ensures that the function efficiently determines the feasibility of making all elements in `lst1` even by exchanging elements with `lst2`.\n\n"}
{"task_id": "CPP/111", "generation": "#include <iostream>\n#include <string>\n#include <map>\n#include <cassert>\nusing namespace std;\n\nmap<char, int> histogram(string test) {\n    map<char, int> freq;\n    for (char c : test) {\n        if (c != ' ') {\n            freq[c]++;\n        }\n    }\n\n    int max_count = 0;\n    for (const auto& pair : freq) {\n        if (pair.second > max_count) {\n            max_count = pair.second;\n        }\n    }\n\n    map<char, int> result;\n    for (const auto& pair : freq) {\n        if (pair.second == max_count) {\n            result.insert(pair);\n        }\n    }\n\n    return result;\n}\n\nvoid test_histogram() {\n    assert((histogram(\"a b c\") == map<char, int>{{'a', 1}, {'b', 1}, {'c', 1}}));\n    assert((histogram(\"a b b a\") == map<char, int>{{'a', 2}, {'b', 2}}));\n    assert((histogram(\"a b c a b\") == map<char, int>{{'a', 2}, {'b', 2}}));\n    assert((histogram(\"b b b b a\") == map<char, int>{{'b', 4}}));\n    assert((histogram(\"\") == map<char, int>{}));\n    cout << \"All tests passed!\" << endl;\n}\n\n", "py_code": "from collections import Counter\n\ndef histogram(test):\n    # Split the string into a list of characters\n    chars = test.split()\n    \n    # Count the occurrences of each character\n    char_count = Counter(chars)\n    \n    # Find the maximum count\n    max_count = max(char_count.values())\n    \n    # Filter the characters that have the maximum count\n    result = {char: count for char, count in char_count.items() if count == max_count}\n    \n    return result\n", "py_summary": "The Python code defines a function `histogram` that takes a string `test` as input and returns a dictionary containing the characters with the highest frequency and their corresponding counts. Here's a step-by-step analysis of the code:\n\n1. **Split the String**: The input string `test` is split into a list of characters using the `split()` method. This method splits the string at spaces and returns a list of substrings.\n   ```python\n   chars = test.split()\n   ```\n\n2. **Count Occurrences**: The `Counter` class from the `collections` module is used to count the occurrences of each character in the list `chars`. The `Counter` object is a dictionary subclass that helps count hashable objects.\n   ```python\n   char_count = Counter(chars)\n   ```\n\n3. **Find Maximum Count**: The `max` function is used to find the maximum value in the values of the `char_count` dictionary. This gives the highest frequency of any character in the input string.\n   ```python\n   max_count = max(char_count.values())\n   ```\n\n4. **Filter Characters with Maximum Count**: A dictionary comprehension is used to filter out the characters that have the maximum count. The resulting dictionary contains only those characters and their counts.\n   ```python\n   result = {char: count for char, count in char_count.items() if count == max_count}\n   ```\n\n5. **Return Result**: The filtered dictionary is returned as the result.\n   ```python\n   return result\n   ```\n\nThis approach ensures that the function correctly identifies and returns the characters with the highest frequency, even if there are multiple characters with the same highest frequency."}
{"task_id": "CPP/80", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_happy(string s) {\n    // Check if the length of the string is less than 3\n    if (s.length() < 3) {\n        return false;\n    }\n\n    // Iterate through the string to check every 3 consecutive letters\n    for (size_t i = 0; i < s.length() - 2; ++i) {\n        if (s[i] == s[i + 1] || s[i + 1] == s[i + 2] || s[i] == s[i + 2]) {\n            return false;\n        }\n    }\n\n    // If no set of 3 consecutive letters are the same, return true\n    return true;\n}\n\n// Function to test the is_happy function\nvoid test_is_happy() {\n    cout << \"is_happy(\\\"a\\\"): \" << is_happy(\"a\") << endl;      // false\n    cout << \"is_happy(\\\"aa\\\"): \" << is_happy(\"aa\") << endl;    // false\n    cout << \"is_happy(\\\"abcd\\\"): \" << is_happy(\"abcd\") << endl; // true\n    cout << \"is_happy(\\\"aabb\\\"): \" << is_happy(\"aabb\") << endl; // false\n    cout << \"is_happy(\\\"adb\\\"): \" << is_happy(\"adb\") << endl;   // true\n    cout << \"is_happy(\\\"xyy\\\"): \" << is_happy(\"xyy\") << endl;   // false\n}\n\n", "py_code": "def is_happy(s: str) -> bool:\n    if len(s) < 3:\n        return False\n    for i in range(len(s) - 2):\n        if s[i] == s[i + 1] or s[i + 1] == s[i + 2] or s[i] == s[i + 2]:\n            return False\n    return True\n", "py_summary": "The Python code defines a function `is_happy` that checks if a given string `s` is happy or not. A string is considered happy if its length is at least 3 and every set of 3 consecutive letters are distinct.\n\nHere's a step-by-step breakdown of the code:\n\n1. **Check Length**: The function first checks if the length of the string `s` is less than 3. If it is, the function immediately returns `False` because a happy string must have at least 3 characters.\n\n2. **Iterate Through String**: The function then iterates through the string using a loop that runs from the start of the string to the third-to-last character (`len(s) - 2`). This ensures that we always have a window of 3 consecutive characters to check.\n\n3. **Check Consecutive Characters**: For each position `i` in the string, the function checks if any of the three consecutive characters are the same:\n   - `s[i] == s[i + 1]`: Checks if the first and second characters are the same.\n   - `s[i + 1] == s[i + 2]`: Checks if the second and third characters are the same.\n   - `s[i] == s[i + 2]`: Checks if the first and third characters are the same.\n   \n   If any of these conditions are true, the function returns `False` because the string is not happy.\n\n4. **Return True**: If the loop completes without finding any set of 3 consecutive characters that are the same, the function returns `True`, indicating that the string is happy.\n\nThis approach ensures that the function efficiently checks the happiness of the string by only iterating through the string once and performing constant-time checks for each set of 3 consecutive characters."}
