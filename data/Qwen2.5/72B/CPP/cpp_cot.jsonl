{"task_id": "CPP/0", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\nbool has_close_elements(vector<float> numbers, float threshold) {\n    // Step 1: Sort the vector\n    sort(numbers.begin(), numbers.end());\n\n    // Step 2: Iterate through the sorted vector\n    for (size_t i = 1; i < numbers.size(); ++i) {\n        // Step 3: Check the difference between adjacent elements\n        if (abs(numbers[i] - numbers[i - 1]) < threshold) {\n            return true;\n        }\n    }\n\n    // Step 4: If no such pair is found, return false\n    return false;\n}\n\n// Example usage\n"}
{"task_id": "CPP/1", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\nusing namespace std;\n\nvector<string> separate_paren_groups(string paren_string) {\n    // Remove spaces from the input string\n    paren_string.erase(remove(paren_string.begin(), paren_string.end(), ' '), paren_string.end());\n\n    vector<string> result;\n    stack<char> s;\n    string current_group = \"\";\n\n    for (char c : paren_string) {\n        if (c == '(') {\n            s.push(c);\n            current_group += c;\n        } else if (c == ')') {\n            s.pop();\n            current_group += c;\n            if (s.empty()) {\n                result.push_back(current_group);\n                current_group = \"\";\n            }\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/2", "generation": "#include <stdio.h>\n#include <math.h>\nusing namespace std;\n\nfloat truncate_number(float number) {\n    float integer_part = floor(number);\n    float decimal_part = number - integer_part;\n    return decimal_part;\n}\n\n// Test the function\n"}
{"task_id": "CPP/3", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nbool below_zero(vector<int> operations) {\n    int balance = 0;\n    for (int op : operations) {\n        balance += op;\n        if (balance < 0) {\n            return true;\n        }\n    }\n    return false;\n}\n\n// Test cases\n"}
{"task_id": "CPP/4", "generation": "#include <stdio.h>\n#include <cmath>\n#include <vector>\nusing namespace std;\n\nfloat mean_absolute_deviation(vector<float> numbers) {\n    // Step 1: Calculate the mean of the vector\n    float sum = 0.0;\n    for (float num : numbers) {\n        sum += num;\n    }\n    float mean = sum / numbers.size();\n\n    // Step 2: Calculate the total absolute difference\n    float total_abs_diff = 0.0;\n    for (float num : numbers) {\n        total_abs_diff += abs(num - mean);\n    }\n\n    // Step 3: Calculate the Mean Absolute Deviation\n    float mad = total_abs_diff / numbers.size();\n\n    return mad;\n}\n\n// Example usage\n"}
{"task_id": "CPP/5", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nvector<int> intersperse(vector<int> numbers, int delimiter) {\n    vector<int> result;\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        result.push_back(numbers[i]);\n        if (i < numbers.size() - 1) {\n            result.push_back(delimiter);\n        }\n    }\n    return result;\n}\n\n// Example usage\n"}
{"task_id": "CPP/6", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\nusing namespace std;\n\nvector<int> parse_nested_parens(string paren_string) {\n    vector<int> result;\n    stringstream ss(paren_string);\n    string group;\n\n    while (getline(ss, group, ' ')) {\n        int current_depth = 0;\n        int max_depth = 0;\n\n        for (char c : group) {\n            if (c == '(') {\n                current_depth++;\n                if (current_depth > max_depth) {\n                    max_depth = current_depth;\n                }\n            } else if (c == ')') {\n                current_depth--;\n            }\n        }\n\n        result.push_back(max_depth);\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/7", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> filter_by_substring(vector<string> strings, string substring) {\n    vector<string> result;\n    for (const string& str : strings) {\n        if (str.find(substring) != string::npos) {\n            result.push_back(str);\n        }\n    }\n    return result;\n}\n\n// Function to test the filter_by_substring function\nvoid test_filter_by_substring() {\n    vector<string> test1 = {};\n    vector<string> expected1 = {};\n    assert(filter_by_substring(test1, \"a\") == expected1);\n\n    vector<string> test2 = {\"abc\", \"bacd\", \"cde\", \"vector\"};\n    vector<string> expected2 = {\"abc\", \"bacd\", \"vector\"};\n    assert(filter_by_substring(test2, \"a\") == expected2);\n\n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/8", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nvector<int> sum_product(vector<int> numbers) {\n    int sum = 0;\n    int product = 1;\n\n    for (int num : numbers) {\n        sum += num;\n        product *= num;\n    }\n\n    return {sum, product};\n}\n\n// Example usage\n"}
{"task_id": "CPP/9", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nvector<int> rolling_max(vector<int> numbers) {\n    vector<int> result;\n    if (numbers.empty()) {\n        return result;\n    }\n    \n    int current_max = numbers[0];\n    for (int num : numbers) {\n        if (num > current_max) {\n            current_max = num;\n        }\n        result.push_back(current_max);\n    }\n    return result;\n}\n\n// Example usage\n"}
{"task_id": "CPP/10", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_palindrome(const string& str) {\n    string s(str.rbegin(), str.rend());\n    return s == str;\n}\n\nstring make_palindrome(string str) {\n    int n = str.length();\n    for (int i = n; i >= 0; --i) {\n        if (is_palindrome(str.substr(i))) {\n            string prefix = str.substr(0, i);\n            string reversed_prefix = string(prefix.rbegin(), prefix.rend());\n            return str + reversed_prefix;\n        }\n    }\n    return str;\n}\n\n"}
{"task_id": "CPP/11", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nstring string_xor(string a, string b) {\n    string result = \"\";\n    for (size_t i = 0; i < a.length(); ++i) {\n        if (a[i] == b[i]) {\n            result += \"0\";\n        } else {\n            result += \"1\";\n        }\n    }\n    return result;\n}\n\n// Example usage\n"}
{"task_id": "CPP/12", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring longest(vector<string> strings) {\n    if (strings.empty()) {\n        return \"\"; // Return an empty string to represent None\n    }\n\n    string maxString = strings[0]; // Initialize with the first string\n\n    for (const string& str : strings) {\n        if (str.length() > maxString.length()) {\n            maxString = str;\n        }\n    }\n\n    return maxString;\n}\n\n"}
{"task_id": "CPP/13", "generation": "#include <stdio.h>\nusing namespace std;\n\nint greatest_common_divisor(int a, int b) {\n    if (b == 0) {\n        return a;\n    } else {\n        return greatest_common_divisor(b, a % b);\n    }\n}\n\n"}
{"task_id": "CPP/14", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> all_prefixes(string str) {\n    vector<string> prefixes;\n    for (size_t i = 1; i <= str.length(); ++i) {\n        prefixes.push_back(str.substr(0, i));\n    }\n    return prefixes;\n}\n\n// Example usage\n"}
{"task_id": "CPP/15", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nstring string_sequence(int n) {\n    string result = \"\";\n    for (int i = 0; i <= n; ++i) {\n        result += to_string(i);\n        if (i < n) {\n            result += \" \";\n        }\n    }\n    return result;\n}\n\n// Test cases\n"}
{"task_id": "CPP/16", "generation": "#include <iostream>\n#include <string>\n#include <set>\n#include <algorithm>\nusing namespace std;\n\nint count_distinct_characters(string str) {\n    // Convert the string to lowercase\n    transform(str.begin(), str.end(), str.begin(), ::tolower);\n    \n    // Initialize an empty set to store unique characters\n    set<char> unique_chars;\n    \n    // Iterate through the string and add each character to the set\n    for (char c : str) {\n        unique_chars.insert(c);\n    }\n    \n    // Return the size of the set\n    return unique_chars.size();\n}\n\n// Function to test the solution\nvoid test() {\n    cout << count_distinct_characters(\"xyzXYZ\") << endl; // Output: 3\n    cout << count_distinct_characters(\"Jerry\") << endl;  // Output: 4\n}\n\n"}
{"task_id": "CPP/17", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<int> parse_music(string music_string) {\n    vector<int> result;\n    int i = 0;\n    while (i < music_string.length()) {\n        if (music_string[i] == 'o') {\n            if (i + 1 < music_string.length() && music_string[i + 1] == '|') {\n                // Half note\n                result.push_back(2);\n                i += 2;\n            } else {\n                // Whole note\n                result.push_back(4);\n                i += 1;\n            }\n        } else if (music_string[i] == '.') {\n            // Quarter note\n            result.push_back(1);\n            i += 2;\n        } else {\n            // Skip spaces and other characters\n            i += 1;\n        }\n    }\n    return result;\n}\n\n// Example usage\n"}
{"task_id": "CPP/18", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nint how_many_times(string str, string substring) {\n    int count = 0;\n    int n = str.length();\n    int m = substring.length();\n\n    // Iterate through the string\n    for (int i = 0; i <= n - m; ++i) {\n        // Check if the substring starting from position i matches the given substring\n        if (str.substr(i, m) == substring) {\n            count++;\n        }\n    }\n\n    return count;\n}\n\n"}
{"task_id": "CPP/19", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <map>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nstring sort_numbers(string numbers) {\n    // Map to convert number words to integers\n    map<string, int> number_map = {\n        {\"zero\", 0}, {\"one\", 1}, {\"two\", 2}, {\"three\", 3},\n        {\"four\", 4}, {\"five\", 5}, {\"six\", 6}, {\"seven\", 7},\n        {\"eight\", 8}, {\"nine\", 9}\n    };\n\n    // Split the input string into a list of number words\n    stringstream ss(numbers);\n    vector<string> number_words;\n    string word;\n    while (ss >> word) {\n        number_words.push_back(word);\n    }\n\n    // Convert number words to integers\n    vector<int> numbers_int;\n    for (const string& word : number_words) {\n        numbers_int.push_back(number_map[word]);\n    }\n\n    // Sort the integers\n    sort(numbers_int.begin(), numbers_int.end());\n\n    // Convert sorted integers back to number words\n    vector<string> sorted_number_words;\n    for (int num : numbers_int) {\n        for (const auto& pair : number_map) {\n            if (pair.second == num) {\n                sorted_number_words.push_back(pair.first);\n                break;\n            }\n        }\n    }\n\n    // Join the sorted number words into a single string\n    string result;\n    for (size_t i = 0; i < sorted_number_words.size(); ++i) {\n        result += sorted_number_words[i];\n        if (i < sorted_number_words.size() - 1) {\n            result += \" \";\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/20", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\nvector<float> find_closest_elements(vector<float> numbers) {\n    // Step 1: Sort the vector\n    sort(numbers.begin(), numbers.end());\n\n    // Step 2: Initialize variables\n    float min_diff = numeric_limits<float>::max();\n    vector<float> closest_pair(2);\n\n    // Step 3: Iterate through the sorted vector\n    for (size_t i = 0; i < numbers.size() - 1; ++i) {\n        float diff = abs(numbers[i] - numbers[i + 1]);\n        if (diff < min_diff) {\n            min_diff = diff;\n            closest_pair[0] = numbers[i];\n            closest_pair[1] = numbers[i + 1];\n        }\n    }\n\n    // Step 4: Return the closest pair\n    return closest_pair;\n}\n\n// Function to test the solution\nvoid test_find_closest_elements() {\n    vector<float> result1 = find_closest_elements({1.0, 2.0, 3.0, 4.0, 5.0, 2.2});\n    cout << \"(\" << result1[0] << \", \" << result1[1] << \")\" << endl; // Expected: (2.0, 2.2)\n\n    vector<float> result2 = find_closest_elements({1.0, 2.0, 3.0, 4.0, 5.0, 2.0});\n    cout << \"(\" << result2[0] << \", \" << result2[1] << \")\" << endl; // Expected: (2.0, 2.0)\n}\n\n"}
{"task_id": "CPP/21", "generation": "#include <stdio.h>\n#include <math.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<float> rescale_to_unit(vector<float> numbers) {\n    // Step 1: Find the minimum and maximum values in the vector\n    float min_value = *min_element(numbers.begin(), numbers.end());\n    float max_value = *max_element(numbers.begin(), numbers.end());\n\n    // Step 2: Create a new vector to store the transformed values\n    vector<float> transformed_numbers;\n\n    // Step 3: Apply the transformation formula to each element\n    for (float value : numbers) {\n        float new_value = (value - min_value) / (max_value - min_value);\n        transformed_numbers.push_back(new_value);\n    }\n\n    // Step 4: Return the new vector\n    return transformed_numbers;\n}\n\n// Example usage\n"}
{"task_id": "CPP/22", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <boost/any.hpp>\n#include <list>\n#include <typeinfo>\n\ntypedef std::list<boost::any> list_any;\nusing namespace std;\n\nvector<int> filter_integers(list_any values) {\n    vector<int> result;\n    for (const auto& value : values) {\n        if (value.type() == typeid(int)) {\n            result.push_back(boost::any_cast<int>(value));\n        }\n    }\n    return result;\n}\n\n// Function to test the filter_integers function\nvoid test_filter_integers() {\n    list_any values1 = {\"a\", 3.14, 5};\n    vector<int> result1 = filter_integers(values1);\n    for (int val : result1) {\n        cout << val << \" \";\n    }\n    cout << endl;\n\n    list_any values2 = {1, 2, 3, \"abc\", {}, {}};\n    vector<int> result2 = filter_integers(values2);\n    for (int val : result2) {\n        cout << val << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/23", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nint strlen(string str) {\n    return str.size();\n}\n\n// Test cases\n"}
{"task_id": "CPP/24", "generation": "#include <stdio.h>\nusing namespace std;\n\nint largest_divisor(int n) {\n    int largest_div = -1; // Initialize with -1 to indicate no divisor found\n    for (int i = n - 1; i >= 1; --i) {\n        if (n % i == 0) {\n            largest_div = i;\n            break;\n        }\n    }\n    return largest_div;\n}\n\n"}
{"task_id": "CPP/25", "generation": "#include <stdio.h>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\nvector<int> factorize(int n) {\n    vector<int> factors;\n    // Check for divisibility by 2\n    while (n % 2 == 0) {\n        factors.push_back(2);\n        n /= 2;\n    }\n    // Check for divisibility by odd numbers starting from 3\n    for (int i = 3; i <= sqrt(n); i += 2) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n    // If n is a prime number greater than 2\n    if (n > 2) {\n        factors.push_back(n);\n    }\n    return factors;\n}\n\n// Function to test the factorize function\nvoid test_factorize() {\n    vector<int> result;\n    result = factorize(8);\n    for (int factor : result) printf(\"%d \", factor); printf(\"\\n\"); // Output: 2 2 2\n\n    result = factorize(25);\n    for (int factor : result) printf(\"%d \", factor); printf(\"\\n\"); // Output: 5 5\n\n    result = factorize(70);\n    for (int factor : result) printf(\"%d \", factor); printf(\"\\n\"); // Output: 2 5 7\n}\n\n"}
{"task_id": "CPP/26", "generation": "#include <stdio.h>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nvector<int> remove_duplicates(vector<int> numbers) {\n    // Step 1: Initialize a hash map to store the frequency of each element\n    unordered_map<int, int> frequency;\n\n    // Step 2: Iterate through the input vector and update the frequency in the hash map\n    for (int num : numbers) {\n        frequency[num]++;\n    }\n\n    // Step 3: Initialize an empty result vector\n    vector<int> result;\n\n    // Step 4: Iterate through the input vector again and add elements to the result vector if their frequency is 1\n    for (int num : numbers) {\n        if (frequency[num] == 1) {\n            result.push_back(num);\n        }\n    }\n\n    // Step 5: Return the result vector\n    return result;\n}\n\n// Example usage\n"}
{"task_id": "CPP/27", "generation": "#include <stdio.h>\n#include <string>\n#include <cctype> // for islower, isupper, tolower, toupper\nusing namespace std;\n\nstring flip_case(string str) {\n    string result = \"\";\n    for (char ch : str) {\n        if (islower(ch)) {\n            result += toupper(ch);\n        } else if (isupper(ch)) {\n            result += tolower(ch);\n        } else {\n            result += ch; // Non-alphabetic characters remain unchanged\n        }\n    }\n    return result;\n}\n\n// Test cases\n"}
{"task_id": "CPP/28", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring concatenate(vector<string> strings) {\n    string result = \"\";\n    for (const string& str : strings) {\n        result += str;\n    }\n    return result;\n}\n\n// Test cases\n"}
{"task_id": "CPP/29", "generation": "#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> filter_by_prefix(vector<string> strings, string prefix) {\n    vector<string> result;\n    for (const string& str : strings) {\n        if (str.substr(0, prefix.length()) == prefix) {\n            result.push_back(str);\n        }\n    }\n    return result;\n}\n\n// Example usage\n#include <iostream>\n"}
{"task_id": "CPP/30", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nvector<float> get_positive(vector<float> l) {\n    vector<float> result;\n    for (float num : l) {\n        if (num > 0) {\n            result.push_back(num);\n        }\n    }\n    return result;\n}\n\n// Example usage\n"}
{"task_id": "CPP/31", "generation": "#include <stdio.h>\n#include <cmath>\nusing namespace std;\n\nbool is_prime(long long n) {\n    // Handle edge cases\n    if (n < 2) {\n        return false;\n    }\n    if (n == 2) {\n        return true;\n    }\n    if (n % 2 == 0) {\n        return false;\n    }\n\n    // Check divisibility from 3 to sqrt(n)\n    for (long long i = 3; i <= sqrt(n); i += 2) {\n        if (n % i == 0) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\n// Test cases\n"}
{"task_id": "CPP/32", "generation": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <limits>\n\nusing namespace std;\n\n// Function to evaluate the polynomial at point x\ndouble poly(const vector<double>& xs, double x) {\n    double sum = 0;\n    for (size_t i = 0; i < xs.size(); ++i) {\n        sum += xs[i] * pow(x, i);\n    }\n    return sum;\n}\n\n// Function to evaluate the derivative of the polynomial at point x\ndouble poly_derivative(const vector<double>& xs, double x) {\n    double sum = 0;\n    for (size_t i = 1; i < xs.size(); ++i) {\n        sum += i * xs[i] * pow(x, i - 1);\n    }\n    return sum;\n}\n\n// Function to find a zero of the polynomial using Newton-Raphson method\ndouble find_zero(const vector<double>& xs) {\n    double x = 0; // Initial guess\n    double epsilon = 1e-6; // Convergence threshold\n    double max_iterations = 1000; // Maximum number of iterations\n\n    for (int i = 0; i < max_iterations; ++i) {\n        double f_x = poly(xs, x);\n        double f_prime_x = poly_derivative(xs, x);\n\n        if (fabs(f_prime_x) < epsilon) {\n            // Derivative is too small, avoid division by zero\n            break;\n        }\n\n        double next_x = x - f_x / f_prime_x;\n\n        if (fabs(next_x - x) < epsilon) {\n            // Convergence criterion met\n            return next_x;\n        }\n\n        x = next_x;\n    }\n\n    return x; // Return the best guess found\n}\n\n"}
{"task_id": "CPP/33", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> sort_third(vector<int> l) {\n    // Step 1: Identify indices divisible by three\n    vector<int> divisible_indices;\n    for (int i = 0; i < l.size(); ++i) {\n        if (i % 3 == 0) {\n            divisible_indices.push_back(i);\n        }\n    }\n    \n    // Step 2: Extract values at these indices\n    vector<int> values_to_sort;\n    for (int index : divisible_indices) {\n        values_to_sort.push_back(l[index]);\n    }\n    \n    // Step 3: Sort these values\n    sort(values_to_sort.begin(), values_to_sort.end());\n    \n    // Step 4: Replace values at the identified indices with the sorted values\n    for (int i = 0; i < divisible_indices.size(); ++i) {\n        l[divisible_indices[i]] = values_to_sort[i];\n    }\n    \n    // Step 5: Return the modified vector\n    return l;\n}\n\n// Example usage\n"}
{"task_id": "CPP/34", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> unique(vector<int> l) {\n    // Step 1: Sort the vector\n    sort(l.begin(), l.end());\n    \n    // Step 2: Remove consecutive duplicates\n    auto new_end = unique(l.begin(), l.end());\n    \n    // Step 3: Resize the vector to remove the extra elements\n    l.erase(new_end, l.end());\n    \n    // Step 4: Return the resulting vector\n    return l;\n}\n\n// Example usage\n"}
{"task_id": "CPP/35", "generation": "#include <stdio.h>\n#include <limits>\n#include <vector>\nusing namespace std;\n\nfloat max_element(vector<float> l) {\n    // Initialize max_val to the smallest possible float value\n    float max_val = -numeric_limits<float>::max();\n    \n    // Iterate through each element in the vector\n    for (float val : l) {\n        // Update max_val if the current element is greater\n        if (val > max_val) {\n            max_val = val;\n        }\n    }\n    \n    // Return the maximum value found\n    return max_val;\n}\n\n// Example usage\n"}
{"task_id": "CPP/36", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint fizz_buzz(int n) {\n    int count = 0;\n    for (int i = 1; i < n; ++i) {\n        if (i % 11 == 0 || i % 13 == 0) {\n            string numStr = to_string(i);\n            for (char c : numStr) {\n                if (c == '7') {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}\n\n"}
{"task_id": "CPP/37", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<float> sort_even(vector<float> l) {\n    vector<float> even_indices_elements;\n    \n    // Extract elements at even indices\n    for (int i = 0; i < l.size(); i++) {\n        if (i % 2 == 0) {\n            even_indices_elements.push_back(l[i]);\n        }\n    }\n    \n    // Sort the extracted elements\n    sort(even_indices_elements.begin(), even_indices_elements.end());\n    \n    // Create the result vector\n    vector<float> result(l.size());\n    int even_index = 0;\n    \n    // Place sorted elements at even indices and original elements at odd indices\n    for (int i = 0; i < l.size(); i++) {\n        if (i % 2 == 0) {\n            result[i] = even_indices_elements[even_index++];\n        } else {\n            result[i] = l[i];\n        }\n    }\n    \n    return result;\n}\n\n// Example usage\n"}
{"task_id": "CPP/38", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring encode_cyclic(string s) { \n    int l = s.length();\n    int num = (l + 2) / 3;\n    string x, output;\n    for (int i = 0; i * 3 < l; i++) {\n        x = s.substr(i * 3, 3);\n        if (x.length() == 3) x = x.substr(1) + x[0];\n        output += x;\n    }\n    return output;\n}\n\nstring decode_cyclic(string s) { \n    int l = s.length();\n    int num = (l + 2) / 3;\n    string x, output;\n    for (int i = 0; i * 3 < l; i++) {\n        x = s.substr(i * 3, 3);\n        if (x.length() == 3) x = x[2] + x.substr(0, 2);\n        output += x;\n    }\n    return output;\n}\n\n"}
{"task_id": "CPP/39", "generation": "#include <iostream>\n#include <cmath>\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    if (num == 2) return true;\n    if (num % 2 == 0) return false;\n    for (int i = 3; i <= sqrt(num); i += 2) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\n// Function to generate the n-th prime Fibonacci number\nint prime_fib(int n) {\n    int a = 0, b = 1, c = a + b;\n    int count = 0;\n\n    while (count < n) {\n        c = a + b;\n        a = b;\n        b = c;\n        if (is_prime(c)) {\n            count++;\n        }\n    }\n    return c;\n}\n\n"}
{"task_id": "CPP/40", "generation": "#include <algorithm>\n#include <vector>\nusing namespace std;\n\nbool triples_sum_to_zero(vector<int> l) {\n    // Sort the vector\n    sort(l.begin(), l.end());\n\n    // Iterate through the vector\n    for (int i = 0; i < l.size() - 2; i++) {\n        // Initialize two pointers\n        int left = i + 1;\n        int right = l.size() - 1;\n\n        // Use two pointers to find a pair that sums to -l[i]\n        while (left < right) {\n            int sum = l[i] + l[left] + l[right];\n\n            if (sum == 0) {\n                // Found a triplet that sums to zero\n                return true;\n            } else if (sum < 0) {\n                // Move the left pointer to the right to increase the sum\n                left++;\n            } else {\n                // Move the right pointer to the left to decrease the sum\n                right--;\n            }\n        }\n    }\n\n    // No triplet found that sums to zero\n    return false;\n}\n"}
{"task_id": "CPP/41", "generation": "#include <stdio.h>\nusing namespace std;\n\nint car_race_collision(int n) {\n    // Each car moving left to right will collide with each car moving right to left\n    return n * n;\n}\n\n// Example usage\n"}
{"task_id": "CPP/42", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> incr_list(vector<int> l) {\n    // Use std::transform to increment each element by 1\n    std::transform(l.begin(), l.end(), l.begin(), [](int x) { return x + 1; });\n    return l;\n}\n\n// Function to test the incr_list function\nvoid test_incr_list() {\n    vector<int> test1 = {1, 2, 3};\n    vector<int> expected1 = {2, 3, 4};\n    assert(incr_list(test1) == expected1);\n\n    vector<int> test2 = {5, 3, 5, 2, 3, 3, 9, 0, 123};\n    vector<int> expected2 = {6, 4, 6, 3, 4, 4, 10, 1, 124};\n    assert(incr_list(test2) == expected2);\n\n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/43", "generation": "#include <iostream>\n#include <vector>\n#include <unordered_set>\nusing namespace std;\n\nbool pairs_sum_to_zero(vector<int> l) {\n    unordered_set<int> seen;\n    for (int num : l) {\n        if (seen.find(-num) != seen.end()) {\n            return true;\n        }\n        seen.insert(num);\n    }\n    return false;\n}\n\n"}
{"task_id": "CPP/44", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nstring change_base(int x, int base) {\n    string result = \"\";\n    while (x > 0) {\n        int remainder = x % base;\n        result = to_string(remainder) + result;\n        x /= base;\n    }\n    return result;\n}\n\n// Test cases\n"}
{"task_id": "CPP/45", "generation": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n\nfloat triangle_area(float a, float h) {\n    // The formula for the area of a triangle is (base * height) / 2\n    return (a * h) / 2;\n}\n\n// Example usage\n"}
{"task_id": "CPP/46", "generation": "#include <stdio.h>\nusing namespace std;\n\nint fib4(int n) {\n    // Base cases\n    if (n == 0) return 0;\n    if (n == 1) return 0;\n    if (n == 2) return 2;\n    if (n == 3) return 0;\n\n    // Initialize the first four values\n    int a = 0, b = 0, c = 2, d = 0;\n\n    // Iterate to compute the n-th value\n    for (int i = 4; i <= n; ++i) {\n        int next = a + b + c + d;\n        a = b;\n        b = c;\n        c = d;\n        d = next;\n    }\n\n    return d;\n}\n\n// Test cases\n"}
{"task_id": "CPP/47", "generation": "#include <stdio.h>\n#include <math.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nfloat median(vector<float> l) {\n    // Sort the vector\n    sort(l.begin(), l.end());\n    \n    int n = l.size();\n    \n    // Check if the number of elements is odd\n    if (n % 2 == 1) {\n        // Return the middle element\n        return l[n / 2];\n    } else {\n        // Return the average of the two middle elements\n        return (l[n / 2 - 1] + l[n / 2]) / 2.0;\n    }\n}\n\n// Example usage\n"}
{"task_id": "CPP/48", "generation": "   #include <iostream>\n   #include <string>\n   using namespace std;\n\n   bool is_palindrome(string text) {\n       if (text.empty()) {\n           return true;\n       }\n       int left = 0;\n       int right = text.length() - 1;\n       while (left < right) {\n           if (text[left] != text[right]) {\n               return false;\n           }\n           left++;\n           right--;\n       }\n       return true;\n   }\n\n   "}
{"task_id": "CPP/49", "generation": "#include<stdio.h>\nusing namespace std;\n\nint modp(int n, int p) {\n    int result = 1;\n    int base = 2;\n\n    while (n > 0) {\n        if (n % 2 == 1) {\n            result = (result * base) % p;\n        }\n        base = (base * base) % p;\n        n /= 2;\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/50", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nstring encode_shift(string s) {\n    string out;\n    for (char c : s) {\n        int shifted = ((int)c - (int)'a' + 5) % 26 + (int)'a';\n        out += (char)shifted;\n    }\n    return out;\n}\n\nstring decode_shift(string s) {\n    string out;\n    for (char c : s) {\n        int shifted = ((int)c - (int)'a' - 5 + 26) % 26 + (int)'a';\n        out += (char)shifted;\n    }\n    return out;\n}\n\n// Test cases\n"}
{"task_id": "CPP/51", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nbool is_vowel(char c) {\n    string vowels = \"aeiouAEIOU\";\n    return vowels.find(c) != string::npos;\n}\n\nstring remove_vowels(string text) {\n    // Use std::remove_if to remove vowels from the string\n    text.erase(remove_if(text.begin(), text.end(), is_vowel), text.end());\n    return text;\n}\n\n"}
{"task_id": "CPP/52", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nbool below_threshold(vector<int> l, int t) {\n    bool all_below_threshold = true;\n    for (int num : l) {\n        if (num >= t) {\n            all_below_threshold = false;\n            break;\n        }\n    }\n    return all_below_threshold;\n}\n\n// Test cases\n"}
{"task_id": "CPP/53", "generation": "#include<stdio.h>\n#include<stdlib.h>\nusing namespace std;\n\n// Function to add two numbers\nint add(int x, int y) {\n    // Return the sum of x and y\n    return x + y;\n}\n\n// Main function to test the add function\n"}
{"task_id": "CPP/54", "generation": "#include <iostream>\n#include <string>\n#include <set>\nusing namespace std;\n\nbool same_chars(string s0, string s1) {\n    // Initialize sets to store unique characters\n    set<char> set0, set1;\n\n    // Add characters from the first string to set0\n    for (char c : s0) {\n        set0.insert(c);\n    }\n\n    // Add characters from the second string to set1\n    for (char c : s1) {\n        set1.insert(c);\n    }\n\n    // Compare the two sets\n    return set0 == set1;\n}\n\n"}
{"task_id": "CPP/55", "generation": "#include <stdio.h>\nusing namespace std;\n\nint fib(int n) {\n    if (n == 0) return 0;\n    if (n == 1) return 1;\n\n    int a = 0, b = 1;\n    for (int i = 2; i <= n; ++i) {\n        int nextFib = a + b;\n        a = b;\n        b = nextFib;\n    }\n    return b;\n}\n\n"}
{"task_id": "CPP/56", "generation": "#include <stdio.h>\n#include <string>\n#include <stack>\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    stack<char> stack;\n    for (char ch : brackets) {\n        if (ch == '<') {\n            stack.push(ch);\n        } else if (ch == '>') {\n            if (stack.empty()) {\n                return false;\n            }\n            stack.pop();\n        }\n    }\n    return stack.empty();\n}\n\n"}
{"task_id": "CPP/57", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nbool monotonic(vector<float> l) {\n    bool isIncreasing = true;\n    bool isDecreasing = true;\n\n    for (size_t i = 1; i < l.size(); ++i) {\n        if (l[i] < l[i - 1]) {\n            isIncreasing = false;\n        }\n        if (l[i] > l[i - 1]) {\n            isDecreasing = false;\n        }\n    }\n\n    return isIncreasing || isDecreasing;\n}\n\n"}
{"task_id": "CPP/58", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\n#include <set>\nusing namespace std;\n\nvector<int> common(vector<int> l1, vector<int> l2) {\n    // Step 1: Sort both vectors\n    sort(l1.begin(), l1.end());\n    sort(l2.begin(), l2.end());\n\n    // Step 2: Initialize pointers and a set for common elements\n    int i = 0, j = 0;\n    set<int> commonElements;\n\n    // Step 3: Use two-pointer technique to find common elements\n    while (i < l1.size() && j < l2.size()) {\n        if (l1[i] == l2[j]) {\n            commonElements.insert(l1[i]);\n            i++;\n            j++;\n        } else if (l1[i] < l2[j]) {\n            i++;\n        } else {\n            j++;\n        }\n    }\n\n    // Step 4: Convert the set to a vector\n    vector<int> result(commonElements.begin(), commonElements.end());\n\n    // Step 5: Return the result\n    return result;\n}\n\n// Example usage\n"}
{"task_id": "CPP/59", "generation": "#include <iostream>\n#include <cmath>\nusing namespace std;\n\nint largest_prime_factor(int n) {\n    int largest_factor = 1;\n\n    // Remove factors of 2\n    while (n % 2 == 0) {\n        largest_factor = 2;\n        n /= 2;\n    }\n\n    // Check for odd factors\n    for (int i = 3; i <= sqrt(n); i += 2) {\n        while (n % i == 0) {\n            largest_factor = i;\n            n /= i;\n        }\n    }\n\n    // If n is a prime number greater than 2\n    if (n > 2) {\n        largest_factor = n;\n    }\n\n    return largest_factor;\n}\n\n"}
{"task_id": "CPP/60", "generation": "#include <stdio.h>\nusing namespace std;\n\nint sum_to_n(int n) {\n    // Calculate the sum using the formula\n    int sum = (n * (n + 1)) / 2;\n    return sum;\n}\n\n// Test cases\n"}
{"task_id": "CPP/61", "generation": "#include <stdio.h>\n#include <string>\n#include <stack>\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    stack<char> s;\n    for (char c : brackets) {\n        if (c == '(') {\n            s.push(c);\n        } else if (c == ')') {\n            if (s.empty()) {\n                return false;\n            }\n            s.pop();\n        }\n    }\n    return s.empty();\n}\n\n"}
{"task_id": "CPP/62", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nvector<float> derivative(vector<float> xs) {\n    vector<float> result;\n    for (int i = 1; i < xs.size(); ++i) {\n        result.push_back(xs[i] * i);\n    }\n    return result;\n}\n\n// Example usage\n"}
{"task_id": "CPP/63", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint fibfib(int n) {\n    if (n == 0 || n == 1) return 0;\n    if (n == 2) return 1;\n\n    vector<int> dp(n + 1);\n    dp[0] = 0;\n    dp[1] = 0;\n    dp[2] = 1;\n\n    for (int i = 3; i <= n; ++i) {\n        dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3];\n    }\n\n    return dp[n];\n}\n\n"}
{"task_id": "CPP/64", "generation": "#include <stdio.h>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nint vowels_count(string s) {\n    int count = 0;\n    // Convert the string to lowercase to handle both uppercase and lowercase vowels\n    transform(s.begin(), s.end(), s.begin(), ::tolower);\n    \n    // Iterate through each character in the string\n    for (char c : s) {\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n            count++;\n        }\n    }\n    \n    // Check if the last character is 'y'\n    if (!s.empty() && s.back() == 'y') {\n        count++;\n    }\n    \n    return count;\n}\n\n// Example usage\n"}
{"task_id": "CPP/65", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nstring circular_shift(int x, int shift) {\n    // Convert the integer to a string\n    string s = to_string(x);\n    \n    // Calculate the number of digits\n    int n = s.length();\n    \n    // Calculate the effective shift\n    int effective_shift = shift % n;\n    \n    // If the effective shift is zero, reverse the string\n    if (effective_shift == 0) {\n        reverse(s.begin(), s.end());\n    } else {\n        // Perform the circular shift\n        rotate(s.rbegin(), s.rbegin() + effective_shift, s.rend());\n    }\n    \n    // Return the resulting string\n    return s;\n}\n\n// Function to test the circular_shift function\nvoid test_circular_shift() {\n    cout << \"circular_shift(12, 1) = \" << circular_shift(12, 1) << \" (Expected: 21)\" << endl;\n    cout << \"circular_shift(12, 2) = \" << circular_shift(12, 2) << \" (Expected: 12)\" << endl;\n    cout << \"circular_shift(12345, 2) = \" << circular_shift(12345, 2) << \" (Expected: 45123)\" << endl;\n    cout << \"circular_shift(12345, 7) = \" << circular_shift(12345, 7) << \" (Expected: 54321)\" << endl;\n}\n\n"}
{"task_id": "CPP/66", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint digitSum(string s) {\n    int sum = 0;\n    for (char c : s) {\n        if (isupper(c)) {\n            sum += static_cast<int>(c);\n        }\n    }\n    return sum;\n}\n\n// Test cases\n"}
{"task_id": "CPP/67", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\nusing namespace std;\n\nint fruit_distribution(string s, int n) {\n    int apples = 0, oranges = 0;\n    stringstream ss(s);\n    string word;\n\n    while (ss >> word) {\n        if (word == \"apples\") {\n            ss >> word; // Skip \"and\"\n            ss >> word; // Read the number of oranges\n            oranges = stoi(word);\n        } else if (word == \"oranges\") {\n            break; // No need to continue parsing after \"oranges\"\n        } else {\n            apples = stoi(word); // Read the number of apples\n        }\n    }\n\n    int mangoes = n - (apples + oranges);\n    return mangoes;\n}\n\n"}
{"task_id": "CPP/68", "generation": "#include <stdio.h>\n#include <vector>\n#include <limits>\nusing namespace std;\n\nvector<int> pluck(vector<int> arr) {\n    if (arr.empty()) {\n        return {};\n    }\n\n    int smallest_even_value = numeric_limits<int>::max();\n    int smallest_index = -1;\n\n    for (int i = 0; i < arr.size(); ++i) {\n        if (arr[i] % 2 == 0 && arr[i] < smallest_even_value) {\n            smallest_even_value = arr[i];\n            smallest_index = i;\n        }\n    }\n\n    if (smallest_even_value == numeric_limits<int>::max()) {\n        return {};\n    }\n\n    return {smallest_even_value, smallest_index};\n}\n"}
{"task_id": "CPP/69", "generation": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint search(vector<int> lst) {\n    // Step 1: Create a frequency map\n    unordered_map<int, int> frequencyMap;\n\n    // Step 2: Populate the frequency map\n    for (int num : lst) {\n        frequencyMap[num]++;\n    }\n\n    // Step 3: Initialize result to -1\n    int result = -1;\n\n    // Step 4: Iterate through the frequency map\n    for (const auto& entry : frequencyMap) {\n        int num = entry.first;\n        int freq = entry.second;\n\n        // Check if the frequency is greater than or equal to the value\n        if (freq >= num) {\n            // Update result to the maximum of the current result and the integer\n            result = max(result, num);\n        }\n    }\n\n    // Step 5: Return the result\n    return result;\n}\n\n// Function to test the solution\nvoid test() {\n    cout << search({4, 1, 2, 2, 3, 1}) << \" == 2\" << endl;\n    cout << search({1, 2, 2, 3, 3, 3, 4, 4, 4}) << \" == 3\" << endl;\n    cout << search({5, 5, 4, 4, 4}) << \" == -1\" << endl;\n}\n\n"}
{"task_id": "CPP/70", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> strange_sort_list(vector<int> lst) {\n    vector<int> result;\n    while (!lst.empty()) {\n        // Find and remove the minimum value\n        auto min_it = min_element(lst.begin(), lst.end());\n        result.push_back(*min_it);\n        lst.erase(min_it);\n\n        // If the list is not empty, find and remove the maximum value\n        if (!lst.empty()) {\n            auto max_it = max_element(lst.begin(), lst.end());\n            result.push_back(*max_it);\n            lst.erase(max_it);\n        }\n    }\n    return result;\n}\n\n// Example usage\n"}
{"task_id": "CPP/71", "generation": "#include <stdio.h>\n#include <math.h>\n#include <iomanip>\n#include <iostream>\nusing namespace std;\n\nfloat triangle_area(float a, float b, float c) {\n    // Check if the sides form a valid triangle\n    if (a + b > c && a + c > b && b + c > a) {\n        // Calculate the semi-perimeter\n        float s = (a + b + c) / 2.0f;\n        // Calculate the area using Heron's formula\n        float area = sqrt(s * (s - a) * (s - b) * (s - c));\n        // Round the area to 2 decimal points\n        return round(area * 100.0f) / 100.0f;\n    } else {\n        // Return -1 if the sides do not form a valid triangle\n        return -1.0f;\n    }\n}\n\n"}
{"task_id": "CPP/72", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Function to check if a vector is a palindrome\nbool is_palindrome(const vector<int>& q) {\n    int n = q.size();\n    for (int i = 0; i < n / 2; ++i) {\n        if (q[i] != q[n - i - 1]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n// Function to calculate the sum of elements in a vector\nint sum_vector(const vector<int>& q) {\n    int sum = 0;\n    for (int num : q) {\n        sum += num;\n    }\n    return sum;\n}\n\n// Function to determine if the object q will fly\nbool will_it_fly(vector<int> q, int w) {\n    if (is_palindrome(q) && sum_vector(q) <= w) {\n        return true;\n    }\n    return false;\n}\n\n// Main function to test the will_it_fly function\n"}
{"task_id": "CPP/73", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nint smallest_change(vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n    int left = 0;\n    int right = n - 1;\n    \n    while (left < right) {\n        if (arr[left] != arr[right]) {\n            changes += 1;\n        }\n        left += 1;\n        right -= 1;\n    }\n    \n    return changes;\n}\n\n// Example usage\n"}
{"task_id": "CPP/74", "generation": "#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> total_match(vector<string> lst1, vector<string> lst2) {\n    int total_chars_lst1 = 0;\n    int total_chars_lst2 = 0;\n\n    // Calculate total characters in lst1\n    for (const string& str : lst1) {\n        total_chars_lst1 += str.length();\n    }\n\n    // Calculate total characters in lst2\n    for (const string& str : lst2) {\n        total_chars_lst2 += str.length();\n    }\n\n    // Compare and return the appropriate vector\n    if (total_chars_lst1 <= total_chars_lst2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n"}
{"task_id": "CPP/75", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    for (int i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) return false;\n    }\n    return true;\n}\n\n// Function to generate a list of prime numbers less than 100\nvector<int> generate_primes() {\n    vector<int> primes;\n    for (int i = 2; i < 100; ++i) {\n        if (is_prime(i)) {\n            primes.push_back(i);\n        }\n    }\n    return primes;\n}\n\n// Function to check if a number is the product of three prime numbers\nbool is_multiply_prime(int a) {\n    vector<int> primes = generate_primes();\n    for (int i = 0; i < primes.size(); ++i) {\n        for (int j = i; j < primes.size(); ++j) {\n            for (int k = j; k < primes.size(); ++k) {\n                if (primes[i] * primes[j] * primes[k] == a) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n\n"}
{"task_id": "CPP/76", "generation": "#include <stdio.h>\n#include <math.h>\nusing namespace std;\n\nbool is_simple_power(int x, int n) {\n    // Special case: n^0 = 1\n    if (x == 1) return true;\n    \n    // Special case: 1^k = 1, but 1^k != x if x != 1\n    if (n == 1) return false;\n    \n    // Calculate the logarithm of x with base n\n    double log_result = log(x) / log(n);\n    \n    // Check if the result is an integer\n    return floor(log_result) == log_result;\n}\n\n// Test cases\n"}
{"task_id": "CPP/77", "generation": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n\nbool iscube(int a) {\n    // Handle the special case where a is zero\n    if (a == 0) {\n        return true;\n    }\n\n    // Compute the cube root of the absolute value of a\n    double cubeRoot = cbrt(abs(a));\n\n    // Round the cube root to the nearest integer\n    int roundedCubeRoot = round(cubeRoot);\n\n    // Check if the cube of the rounded integer equals a\n    return pow(roundedCubeRoot, 3) == a;\n}\n\n// Test cases\n"}
{"task_id": "CPP/78", "generation": "#include <iostream>\n#include <string>\n#include <set>\nusing namespace std;\n\nint hex_key(string num) {\n    // Set of prime hexadecimal digits\n    set<char> prime_hex_digits = {'2', '3', '5', '7', 'B', 'D'};\n    \n    // Counter for prime hexadecimal digits\n    int count = 0;\n    \n    // Iterate through each character in the string\n    for (char c : num) {\n        // Check if the character is a prime hexadecimal digit\n        if (prime_hex_digits.find(c) != prime_hex_digits.end()) {\n            count++;\n        }\n    }\n    \n    // Return the count\n    return count;\n}\n\n// Function to test the hex_key function\nvoid test_hex_key() {\n    cout << \"Test 1: \" << (hex_key(\"AB\") == 1 ? \"Passed\" : \"Failed\") << endl;\n    cout << \"Test 2: \" << (hex_key(\"1077E\") == 2 ? \"Passed\" : \"Failed\") << endl;\n    cout << \"Test 3: \" << (hex_key(\"ABED1A33\") == 4 ? \"Passed\" : \"Failed\") << endl;\n    cout << \"Test 4: \" << (hex_key(\"123456789ABCDEF0\") == 6 ? \"Passed\" : \"Failed\") << endl;\n    cout << \"Test 5: \" << (hex_key(\"2020\") == 2 ? \"Passed\" : \"Failed\") << endl;\n}\n\n"}
{"task_id": "CPP/79", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nstring decimal_to_binary(int decimal) {\n    string binary = \"\";\n    \n    // Convert decimal to binary\n    while (decimal > 0) {\n        binary = to_string(decimal % 2) + binary;\n        decimal /= 2;\n    }\n    \n    // Handle the case when the decimal number is 0\n    if (binary.empty()) {\n        binary = \"0\";\n    }\n    \n    // Add \"db\" at the beginning and the end\n    binary = \"db\" + binary + \"db\";\n    \n    return binary;\n}\n\n// Example usage\n"}
{"task_id": "CPP/80", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nbool is_happy(string s) {\n    // Check if the length of the string is less than 3\n    if (s.length() < 3) {\n        return false;\n    }\n\n    // Iterate through the string from index 0 to length-3\n    for (int i = 0; i <= s.length() - 3; i++) {\n        // Check if the current set of 3 consecutive characters are distinct\n        if (s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]) {\n            return false;\n        }\n    }\n\n    // If all sets of 3 consecutive characters are distinct, return true\n    return true;\n}\n\n// Example usage\n"}
{"task_id": "CPP/81", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> numerical_letter_grade(vector<float> grades) {\n    vector<string> letter_grades;\n    \n    for (float gpa : grades) {\n        if (gpa == 4.0) {\n            letter_grades.push_back(\"A+\");\n        } else if (gpa > 3.7) {\n            letter_grades.push_back(\"A\");\n        } else if (gpa > 3.3) {\n            letter_grades.push_back(\"A-\");\n        } else if (gpa > 3.0) {\n            letter_grades.push_back(\"B+\");\n        } else if (gpa > 2.7) {\n            letter_grades.push_back(\"B\");\n        } else if (gpa > 2.3) {\n            letter_grades.push_back(\"B-\");\n        } else if (gpa > 2.0) {\n            letter_grades.push_back(\"C+\");\n        } else if (gpa > 1.7) {\n            letter_grades.push_back(\"C\");\n        } else if (gpa > 1.3) {\n            letter_grades.push_back(\"C-\");\n        } else if (gpa > 1.0) {\n            letter_grades.push_back(\"D+\");\n        } else if (gpa > 0.7) {\n            letter_grades.push_back(\"D\");\n        } else if (gpa > 0.0) {\n            letter_grades.push_back(\"D-\");\n        } else {\n            letter_grades.push_back(\"E\");\n        }\n    }\n    \n    return letter_grades;\n}\n\n// Example usage\n"}
{"task_id": "CPP/82", "generation": "#include <iostream>\n#include <string>\n#include <cmath>\nusing namespace std;\n\nbool is_prime(int n) {\n    if (n <= 1) {\n        return false;\n    }\n    for (int i = 2; i <= sqrt(n); ++i) {\n        if (n % i == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nbool prime_length(string str) {\n    int length = str.length();\n    return is_prime(length);\n}\n\n"}
{"task_id": "CPP/83", "generation": "#include <iostream>\n#include <cmath>\nusing namespace std;\n\nint starts_one_ends(int n) {\n    if (n == 1) {\n        return 1; // Only one 1-digit number starts or ends with 1, which is 1 itself.\n    }\n\n    int start_with_1 = pow(10, n - 1);\n    int end_with_1 = 9 * pow(10, n - 2);\n    int both_start_and_end_with_1 = pow(10, n - 2);\n\n    return start_with_1 + end_with_1 - both_start_and_end_with_1;\n}\n\n"}
{"task_id": "CPP/84", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nstring solve(int N) {\n    int sum = 0;\n    while (N > 0) {\n        sum += N % 10; // Add the last digit to sum\n        N /= 10;       // Remove the last digit\n    }\n\n    // Convert sum to binary\n    string binary = \"\";\n    if (sum == 0) {\n        return \"0\";\n    }\n    while (sum > 0) {\n        binary = to_string(sum % 2) + binary; // Prepend the binary digit\n        sum /= 2;\n    }\n\n    return binary;\n}\n\n// Example usage\n"}
{"task_id": "CPP/85", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nint add(vector<int> lst) {\n    int total = 0;\n    for (int i = 1; i < lst.size(); i += 2) {\n        if (lst[i] % 2 == 0) {\n            total += lst[i];\n        }\n    }\n    return total;\n}\n\n// Example usage\n"}
{"task_id": "CPP/86", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <sstream>\nusing namespace std;\n\nstring anti_shuffle(string s) {\n    stringstream ss(s);\n    string word, result;\n    bool first = true;\n\n    while (ss >> word) {\n        // Sort the characters in the word\n        sort(word.begin(), word.end());\n\n        // Append the sorted word to the result\n        if (!first) {\n            result += \" \";\n        }\n        result += word;\n        first = false;\n    }\n\n    // Handle trailing spaces\n    int lastNonSpace = s.find_last_not_of(' ');\n    if (lastNonSpace != string::npos) {\n        result += s.substr(lastNonSpace + 1);\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/87", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<vector<int>> get_row(vector<vector<int>> lst, int x) {\n    vector<vector<int>> result;\n\n    // Find all occurrences of x and store their coordinates\n    for (int row = 0; row < lst.size(); ++row) {\n        for (int col = 0; col < lst[row].size(); ++col) {\n            if (lst[row][col] == x) {\n                result.push_back({row, col});\n            }\n        }\n    }\n\n    // Sort by row in ascending order\n    sort(result.begin(), result.end(), [](const vector<int>& a, const vector<int>& b) {\n        return a[0] < b[0];\n    });\n\n    // Sort by column in descending order within each row\n    stable_sort(result.begin(), result.end(), [](const vector<int>& a, const vector<int>& b) {\n        return a[0] == b[0] && a[1] > b[1];\n    });\n\n    return result;\n}\n\n// Function to print the result for testing\nvoid print_result(const vector<vector<int>>& result) {\n    for (const auto& coord : result) {\n        cout << \"{\" << coord[0] << \", \" << coord[1] << \"} \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/88", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> sort_array(vector<int> array) {\n    // Check if the array is empty\n    if (array.empty()) {\n        return array;\n    }\n\n    // Calculate the sum of the first and last elements\n    int sum = array.front() + array.back();\n\n    // Create a copy of the original array\n    vector<int> sorted_array = array;\n\n    // Determine the sorting order based on the sum\n    if (sum % 2 == 1) {\n        // Sort in ascending order\n        sort(sorted_array.begin(), sorted_array.end());\n    } else {\n        // Sort in descending order\n        sort(sorted_array.begin(), sorted_array.end(), greater<int>());\n    }\n\n    // Return the sorted array\n    return sorted_array;\n}\n"}
{"task_id": "CPP/89", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring encrypt(string s) {\n    string result = \"\";\n    for (char c : s) {\n        if (islower(c)) {\n            // Apply the shift formula\n            char new_char = ((c - 'a' + 4) % 26) + 'a';\n            result += new_char;\n        } else {\n            // If not a lowercase letter, keep the character as is\n            result += c;\n        }\n    }\n    return result;\n}\n\n"}
{"task_id": "CPP/90", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <optional>\nusing namespace std;\n\noptional<int> next_smallest(vector<int> lst) {\n    // Check if the vector is empty\n    if (lst.empty()) {\n        return nullopt;\n    }\n\n    // Sort the vector\n    sort(lst.begin(), lst.end());\n\n    // Find the second smallest unique element\n    int smallest = lst[0];\n    for (size_t i = 1; i < lst.size(); ++i) {\n        if (lst[i] != smallest) {\n            return lst[i];\n        }\n    }\n\n    // If no second smallest element is found, return None\n    return nullopt;\n}\n\n// Function to test the next_smallest function\nvoid test_next_smallest() {\n    assert(next_smallest({1, 2, 3, 4, 5}) == 2);\n    assert(next_smallest({5, 1, 4, 3, 2}) == 2);\n    assert(next_smallest({}) == nullopt);\n    assert(next_smallest({1, 1}) == nullopt);\n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/91", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <cctype>\nusing namespace std;\n\n// Function to trim leading and trailing whitespace from a string\nstring trim(const string& str) {\n    size_t first = str.find_first_not_of(' ');\n    if (string::npos == first) {\n        return str;\n    }\n    size_t last = str.find_last_not_of(' ');\n    return str.substr(first, (last - first + 1));\n}\n\nint is_bored(string S) {\n    int count = 0;\n    stringstream ss(S);\n    string sentence;\n    \n    // Delimiters for splitting sentences\n    char delimiters[] = {'.', '?', '!'};\n    \n    while (getline(ss, sentence, '.')) {\n        // Further split by '?' and '!'\n        stringstream inner_ss(sentence);\n        string inner_sentence;\n        \n        while (getline(inner_ss, inner_sentence, '?')) {\n            stringstream innermost_ss(inner_sentence);\n            string innermost_sentence;\n            \n            while (getline(innermost_ss, innermost_sentence, '!')) {\n                innermost_sentence = trim(innermost_sentence);\n                if (!innermost_sentence.empty() && innermost_sentence[0] == 'I' && (innermost_sentence.size() == 1 || innermost_sentence[1] == ' ')) {\n                    count++;\n                }\n            }\n        }\n    }\n    \n    return count;\n}\n\n"}
{"task_id": "CPP/92", "generation": "#include <iostream>\n#include <cmath>\nusing namespace std;\n\n// Function to check if a number is an integer\nbool is_integer(float num) {\n    return floor(num) == num;\n}\n\n// Function to check if one number is the sum of the other two and all are integers\nbool any_int(float a, float b, float c) {\n    // Check if all numbers are integers\n    if (!is_integer(a) || !is_integer(b) || !is_integer(c)) {\n        return false;\n    }\n    \n    // Check if any one number is the sum of the other two\n    if (a == b + c || b == a + c || c == a + b) {\n        return true;\n    }\n    \n    return false;\n}\n\n// Main function to test the any_int function\n"}
{"task_id": "CPP/93", "generation": "#include <iostream>\n#include <string>\n#include <cctype>\nusing namespace std;\n\nchar next_vowel(char vowel) {\n    switch (tolower(vowel)) {\n        case 'a': return toupper(vowel) == vowel ? 'C' : 'c';\n        case 'e': return toupper(vowel) == vowel ? 'G' : 'g';\n        case 'i': return toupper(vowel) == vowel ? 'K' : 'k';\n        case 'o': return toupper(vowel) == vowel ? 'Q' : 'q';\n        case 'u': return toupper(vowel) == vowel ? 'W' : 'w';\n        default: return vowel; // In case of non-vowel characters\n    }\n}\n\nstring encode(string message) {\n    string result = \"\";\n    for (char c : message) {\n        if (isalpha(c)) {\n            if (islower(c)) {\n                c = toupper(c);\n            } else {\n                c = tolower(c);\n            }\n            if (strchr(\"aeiouAEIOU\", c)) {\n                c = next_vowel(c);\n            }\n        }\n        result += c;\n    }\n    return result;\n}\n\n"}
{"task_id": "CPP/94", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Helper function to check if a number is prime\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    if (n == 2) return true;\n    if (n % 2 == 0) return false;\n    for (int i = 3; i * i <= n; i += 2) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\nint skjkasdkd(vector<int> lst) {\n    int largest_prime = 2; // Initialize with the smallest prime number\n\n    // Find the largest prime number in the list\n    for (int num : lst) {\n        if (num > largest_prime && is_prime(num)) {\n            largest_prime = num;\n        }\n    }\n\n    // Calculate the sum of the digits of the largest prime\n    int sum_of_digits = 0;\n    while (largest_prime > 0) {\n        sum_of_digits += largest_prime % 10;\n        largest_prime /= 10;\n    }\n\n    return sum_of_digits;\n}\n\n// Example usage\n"}
{"task_id": "CPP/95", "generation": "#include <iostream>\n#include <string>\n#include <map>\nusing namespace std;\n\nbool check_dict_case(map<string, string> dict) {\n    if (dict.empty()) {\n        return false;\n    }\n\n    bool allLower = true;\n    bool allUpper = true;\n\n    for (const auto& pair : dict) {\n        const string& key = pair.first;\n        for (char c : key) {\n            if (isupper(c)) {\n                allLower = false;\n            }\n            if (islower(c)) {\n                allUpper = false;\n            }\n        }\n    }\n\n    return allLower || allUpper;\n}\n\n"}
{"task_id": "CPP/96", "generation": "#include <stdio.h>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\nvector<int> count_up_to(int n) {\n    vector<int> primes;\n    for (int i = 2; i < n; ++i) {\n        bool is_prime = true;\n        for (int j = 2; j <= sqrt(i); ++j) {\n            if (i % j == 0) {\n                is_prime = false;\n                break;\n            }\n        }\n        if (is_prime) {\n            primes.push_back(i);\n        }\n    }\n    return primes;\n}\n\n// Function to test the correctness of the solution\nvoid test() {\n    vector<int> result1 = count_up_to(5);\n    vector<int> expected1 = {2, 3};\n    assert(result1 == expected1);\n\n    vector<int> result2 = count_up_to(11);\n    vector<int> expected2 = {2, 3, 5, 7};\n    assert(result2 == expected2);\n\n    vector<int> result3 = count_up_to(0);\n    vector<int> expected3 = {};\n    assert(result3 == expected3);\n\n    vector<int> result4 = count_up_to(20);\n    vector<int> expected4 = {2, 3, 5, 7, 11, 13, 17, 19};\n    assert(result4 == expected4);\n\n    vector<int> result5 = count_up_to(1);\n    vector<int> expected5 = {};\n    assert(result5 == expected5);\n\n    vector<int> result6 = count_up_to(18);\n    vector<int> expected6 = {2, 3, 5, 7, 11, 13, 17};\n    assert(result6 == expected6);\n\n    printf(\"All tests passed!\\n\");\n}\n\n"}
{"task_id": "CPP/97", "generation": "#include <stdio.h>\n#include <math.h>\nusing namespace std;\n\nint multiply(int a, int b) {\n    // Extract the unit digit of a\n    int unitDigitA = abs(a) % 10;\n    // Extract the unit digit of b\n    int unitDigitB = abs(b) % 10;\n    // Compute the product of the unit digits\n    int product = unitDigitA * unitDigitB;\n    // Return the product\n    return product;\n}\n\n// Function to test the multiply function\nvoid testMultiply() {\n    printf(\"multiply(148, 412) = %d\\n\", multiply(148, 412)); // Should return 16\n    printf(\"multiply(19, 28) = %d\\n\", multiply(19, 28));     // Should return 72\n    printf(\"multiply(2020, 1851) = %d\\n\", multiply(2020, 1851)); // Should return 0\n    printf(\"multiply(14, -15) = %d\\n\", multiply(14, -15));   // Should return 20\n}\n\n"}
{"task_id": "CPP/98", "generation": "#include <stdio.h>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nint count_upper(string s) {\n    int count = 0;\n    for (int i = 0; i < s.length(); i += 2) {\n        char c = s[i];\n        if (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n            count++;\n        }\n    }\n    return count;\n}\n\n// Example usage\n"}
{"task_id": "CPP/99", "generation": "#include <stdio.h>\n#include <math.h>\n#include <string>\n#include <sstream>\nusing namespace std;\n\nint closest_integer(string value) {\n    // Convert the string to a floating-point number\n    stringstream ss(value);\n    double number;\n    ss >> number;\n\n    // Determine the floor and ceiling values\n    int floor_value = floor(number);\n    int ceil_value = ceil(number);\n\n    // Check if the number is equidistant from two integers\n    if (number - floor_value == 0.5) {\n        if (number > 0) {\n            return ceil_value;\n        } else {\n            return floor_value;\n        }\n    } else if (ceil_value - number == 0.5) {\n        if (number > 0) {\n            return ceil_value;\n        } else {\n            return floor_value;\n        }\n    } else {\n        // Round to the nearest integer\n        return round(number);\n    }\n}\n\n// Test cases\n"}
{"task_id": "CPP/100", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> make_a_pile(int n) {\n    vector<int> pile;\n    int current_stones = n;\n\n    for (int i = 0; i < n; ++i) {\n        pile.push_back(current_stones);\n        // Determine the next number of stones\n        if (current_stones % 2 == 0) {\n            current_stones += 2; // Next even number\n        } else {\n            current_stones += 2; // Next odd number\n        }\n    }\n\n    return pile;\n}\n\n// Example usage\n"}
{"task_id": "CPP/101", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\nusing namespace std;\n\nvector<string> words_string(string s) {\n    vector<string> words;\n    string word;\n    // Use istringstream to split the string by spaces and commas\n    istringstream iss(s);\n    while (getline(iss, word, ',')) {\n        istringstream wordStream(word);\n        string subWord;\n        while (wordStream >> subWord) {\n            words.push_back(subWord);\n        }\n    }\n    return words;\n}\n\n// Function to test the words_string function\nvoid test_words_string() {\n    vector<string> result1 = words_string(\"Hi, my name is John\");\n    vector<string> expected1 = {\"Hi\", \"my\", \"name\", \"is\", \"John\"};\n    assert(result1 == expected1);\n\n    vector<string> result2 = words_string(\"One, two, three, four, five, six\");\n    vector<string> expected2 = {\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"};\n    assert(result2 == expected2);\n\n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/102", "generation": "#include <stdio.h>\nusing namespace std;\n\nint choose_num(int x, int y) {\n    // Check if the range is valid\n    if (x > y) {\n        return -1;\n    }\n\n    // Check if y is even\n    if (y % 2 == 0) {\n        return y;\n    }\n\n    // Check if y - 1 is within the range\n    if (y - 1 >= x) {\n        return y - 1;\n    }\n\n    // No even number in the range\n    return -1;\n}\n\n// Example usage\n"}
{"task_id": "CPP/103", "generation": "#include <stdio.h>\n#include <math.h>\n#include <string>\nusing namespace std;\n\nstring convert_to_binary(int number) {\n    if (number == 0) {\n        return \"0\";\n    }\n    string binary = \"\";\n    while (number > 0) {\n        binary = to_string(number % 2) + binary;\n        number = number / 2;\n    }\n    return binary;\n}\n\nstring rounded_avg(int n, int m) {\n    if (n > m) {\n        return \"-1\";\n    }\n    int sum = 0;\n    int count = 0;\n    for (int i = n; i <= m; ++i) {\n        sum += i;\n        count += 1;\n    }\n    double average = static_cast<double>(sum) / count;\n    int rounded_average = floor(average + 0.5);\n    return convert_to_binary(rounded_average);\n}\n\n"}
{"task_id": "CPP/104", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n// Helper function to check if a number has any even digit\nbool hasEvenDigit(int num) {\n    while (num > 0) {\n        int digit = num % 10;\n        if (digit % 2 == 0) {\n            return true;\n        }\n        num /= 10;\n    }\n    return false;\n}\n\nvector<int> unique_digits(vector<int> x) {\n    vector<int> result;\n    for (int num : x) {\n        if (!hasEvenDigit(num)) {\n            result.push_back(num);\n        }\n    }\n    sort(result.begin(), result.end());\n    return result;\n}\n\n// Example usage\n"}
{"task_id": "CPP/105", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\nvector<string> by_length(vector<int> arr) {\n    // Step 1: Initialize the map for integer-to-word mapping\n    map<int, string> numberWords = {\n        {1, \"One\"}, {2, \"Two\"}, {3, \"Three\"}, {4, \"Four\"},\n        {5, \"Five\"}, {6, \"Six\"}, {7, \"Seven\"}, {8, \"Eight\"}, {9, \"Nine\"}\n    };\n\n    // Step 2: Create a vector to store the filtered integers\n    vector<int> filteredArr;\n\n    // Step 3: Filter the input vector\n    for (int num : arr) {\n        if (num >= 1 && num <= 9) {\n            filteredArr.push_back(num);\n        }\n    }\n\n    // Step 4: Sort the filtered vector\n    sort(filteredArr.begin(), filteredArr.end());\n\n    // Step 5: Reverse the sorted vector\n    reverse(filteredArr.begin(), filteredArr.end());\n\n    // Step 6: Create a result vector to store the words\n    vector<string> result;\n\n    // Step 7: Map each integer to its corresponding word\n    for (int num : filteredArr) {\n        result.push_back(numberWords[num]);\n    }\n\n    // Step 8: Return the result vector\n    return result;\n}\n\n// Function to test the solution\nvoid test() {\n    vector<int> arr1 = {2, 1, 1, 4, 5, 8, 2, 3};\n    vector<string> result1 = by_length(arr1);\n    for (const string& word : result1) {\n        cout << word << \" \";\n    }\n    cout << endl; // Expected: Eight Five Four Three Two Two One One\n\n    vector<int> arr2 = {};\n    vector<string> result2 = by_length(arr2);\n    for (const string& word : result2) {\n        cout << word << \" \";\n    }\n    cout << endl; // Expected: (empty)\n\n    vector<int> arr3 = {1, -1, 55};\n    vector<string> result3 = by_length(arr3);\n    for (const string& word : result3) {\n        cout << word << \" \";\n    }\n    cout << endl; // Expected: One\n}\n\n"}
{"task_id": "CPP/106", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\n// Function to compute the factorial of a number\nint factorial(int x) {\n    if (x == 0 || x == 1) {\n        return 1;\n    }\n    int result = 1;\n    for (int j = 2; j <= x; ++j) {\n        result *= j;\n    }\n    return result;\n}\n\n// Function to compute the sum of numbers from 1 to x\nint sum_of_numbers_from_1_to_i(int x) {\n    return (x * (x + 1)) / 2;\n}\n\n// Main function to generate the vector\nvector<int> f(int n) {\n    vector<int> result(n);\n    for (int i = 1; i <= n; ++i) {\n        if (i % 2 == 0) {\n            result[i - 1] = factorial(i);\n        } else {\n            result[i - 1] = sum_of_numbers_from_1_to_i(i);\n        }\n    }\n    return result;\n}\n\n// Example usage\n"}
{"task_id": "CPP/107", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nbool is_palindrome(int num) {\n    string str_num = to_string(num);\n    string reversed_str_num = str_num;\n    reverse(reversed_str_num.begin(), reversed_str_num.end());\n    return str_num == reversed_str_num;\n}\n\nvector<int> even_odd_palindrome(int n) {\n    int even_count = 0;\n    int odd_count = 0;\n    for (int i = 1; i <= n; ++i) {\n        if (is_palindrome(i)) {\n            if (i % 2 == 0) {\n                even_count++;\n            } else {\n                odd_count++;\n            }\n        }\n    }\n    return {even_count, odd_count};\n}\n\n// Example usage\n"}
{"task_id": "CPP/108", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nint count_nums(vector<int> n) {\n    int count = 0;\n    for (int number : n) {\n        int sum_of_digits = 0;\n        if (number < 0) {\n            number = -number;\n            sum_of_digits -= number % 10;\n            number /= 10;\n        }\n        while (number > 0) {\n            sum_of_digits += number % 10;\n            number /= 10;\n        }\n        if (sum_of_digits > 0) {\n            count++;\n        }\n    }\n    return count;\n}\n\n// Test cases\n"}
{"task_id": "CPP/109", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nbool isSorted(const vector<int>& arr) {\n    for (size_t i = 1; i < arr.size(); ++i) {\n        if (arr[i] < arr[i - 1]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nbool move_one_ball(vector<int> arr) {\n    if (arr.empty()) {\n        return true;\n    }\n\n    size_t n = arr.size();\n    size_t breakPoint = -1;\n\n    // Find the break point\n    for (size_t i = 1; i < n; ++i) {\n        if (arr[i] < arr[i - 1]) {\n            if (breakPoint != -1) {\n                // More than one break point, cannot be sorted by right shifts\n                return false;\n            }\n            breakPoint = i;\n        }\n    }\n\n    // If no break point, the array is already sorted\n    if (breakPoint == -1) {\n        return true;\n    }\n\n    // Perform the right shift from the break point\n    vector<int> shiftedArr = arr;\n    rotate(shiftedArr.rbegin(), shiftedArr.rbegin() + (n - breakPoint), shiftedArr.rend());\n\n    // Check if the shifted array is sorted\n    return isSorted(shiftedArr);\n}\n\n// Example usage\n"}
{"task_id": "CPP/110", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring exchange(vector<int> lst1, vector<int> lst2) {\n    int count_odd_lst1 = 0;\n    int count_even_lst2 = 0;\n\n    // Count the number of odd elements in lst1\n    for (int num : lst1) {\n        if (num % 2 != 0) {\n            count_odd_lst1++;\n        }\n    }\n\n    // Count the number of even elements in lst2\n    for (int num : lst2) {\n        if (num % 2 == 0) {\n            count_even_lst2++;\n        }\n    }\n\n    // Check if it's possible to make all elements in lst1 even\n    if (count_odd_lst1 <= count_even_lst2) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n\n// Example usage\n"}
{"task_id": "CPP/111", "generation": "#include <iostream>\n#include <string>\n#include <map>\n#include <sstream>\nusing namespace std;\n\nmap<char, int> histogram(string test) {\n    map<char, int> letterCounts;\n    map<char, int> result;\n    stringstream ss(test);\n    char letter;\n\n    // Count the occurrences of each letter\n    while (ss >> letter) {\n        letterCounts[letter]++;\n    }\n\n    // Find the maximum count\n    int maxCount = 0;\n    for (const auto& pair : letterCounts) {\n        if (pair.second > maxCount) {\n            maxCount = pair.second;\n        }\n    }\n\n    // Create the result map with letters that have the maximum count\n    for (const auto& pair : letterCounts) {\n        if (pair.second == maxCount) {\n            result.insert(pair);\n        }\n    }\n\n    return result;\n}\n\n// Function to test the histogram function\nvoid testHistogram() {\n    map<char, int> result;\n\n    result = histogram(\"a b c\");\n    assert(result == map<char, int>{{'a', 1}, {'b', 1}, {'c', 1}});\n\n    result = histogram(\"a b b a\");\n    assert(result == map<char, int>{{'a', 2}, {'b', 2}});\n\n    result = histogram(\"a b c a b\");\n    assert(result == map<char, int>{{'a', 2}, {'b', 2}});\n\n    result = histogram(\"b b b b a\");\n    assert(result == map<char, int>{{'b', 4}});\n\n    result = histogram(\"\");\n    assert(result.empty());\n\n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/112", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nvector<string> reverse_delete(string s, string c) {\n    // Step 1: Initialize an empty string to store the result\n    string result = \"\";\n\n    // Step 2: Iterate through each character in s\n    for (char ch : s) {\n        // If the character is not in c, append it to result\n        if (c.find(ch) == string::npos) {\n            result += ch;\n        }\n    }\n\n    // Step 3: Check if result is a palindrome\n    string reversed = result;\n    reverse(reversed.begin(), reversed.end());\n    bool is_palindrome = (result == reversed);\n\n    // Step 4: Return a vector containing the result and the palindrome check result\n    return {result, is_palindrome ? \"True\" : \"False\"};\n}\n\n// Example usage\n"}
{"task_id": "CPP/113", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to replace all occurrences of 'old_char' with 'new_char' in the string 's'\nstring replace_all(string s, char old_char, int new_char) {\n    for (char &c : s) {\n        if (c == old_char) {\n            c = '0' + new_char; // Convert int to char\n        }\n    }\n    return s;\n}\n\nvector<string> odd_count(vector<string> lst) {\n    vector<string> result;\n    string template_str = \"the number of odd elements in the string i of the input.\";\n    \n    for (const string &s : lst) {\n        int count_odd = 0;\n        for (char c : s) {\n            if ((c - '0') % 2 != 0) { // Check if the digit is odd\n                count_odd++;\n            }\n        }\n        string modified_string = replace_all(template_str, 'i', count_odd);\n        result.push_back(modified_string);\n    }\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/114", "generation": "#include <stdio.h>\n#include <vector>\n#include <climits>\nusing namespace std;\n\nlong long minSubArraySum(vector<long long> nums) {\n    long long minSum = LLONG_MAX; // Initialize minSum to the largest possible value\n    long long currentSum = 0; // Initialize currentSum to 0\n\n    for (long long num : nums) {\n        currentSum += num; // Add the current element to currentSum\n        if (currentSum < minSum) {\n            minSum = currentSum; // Update minSum if currentSum is smaller\n        }\n        if (currentSum > 0) {\n            currentSum = 0; // Reset currentSum if it becomes positive\n        }\n    }\n\n    return minSum; // Return the minimum sum found\n}\n\n// Example usage\n"}
{"task_id": "CPP/115", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint max_fill(vector<vector<int>> grid, int capacity) {\n    int max_water = 0;\n    int num_rows = grid.size();\n    int num_cols = grid[0].size();\n\n    // Calculate the maximum number of units of water in any column\n    for (int j = 0; j < num_cols; ++j) {\n        int current_column_water = 0;\n        for (int i = 0; i < num_rows; ++i) {\n            current_column_water += grid[i][j];\n        }\n        max_water = max(max_water, current_column_water);\n    }\n\n    // Calculate the total number of lowerings required\n    int total_lowerings = (max_water + capacity - 1) / capacity;\n\n    return total_lowerings;\n}\n\n// Function to test the solution\nvoid test_max_fill() {\n    vector<vector<int>> grid1 = {{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}};\n    int capacity1 = 1;\n    cout << \"Test 1: \" << (max_fill(grid1, capacity1) == 6 ? \"Passed\" : \"Failed\") << endl;\n\n    vector<vector<int>> grid2 = {{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}};\n    int capacity2 = 2;\n    cout << \"Test 2: \" << (max_fill(grid2, capacity2) == 5 ? \"Passed\" : \"Failed\") << endl;\n\n    vector<vector<int>> grid3 = {{0, 0, 0}, {0, 0, 0}};\n    int capacity3 = 5;\n    cout << \"Test 3: \" << (max_fill(grid3, capacity3) == 0 ? \"Passed\" : \"Failed\") << endl;\n}\n\n"}
{"task_id": "CPP/116", "generation": "#include <stdio.h>\n#include <math.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n// Helper function to count the number of ones in the binary representation\nint countOnes(int n) {\n    int count = 0;\n    while (n) {\n        count += n & 1;\n        n >>= 1;\n    }\n    return count;\n}\n\n// Custom comparator for sorting\nbool customComparator(int a, int b) {\n    int onesA = countOnes(a);\n    int onesB = countOnes(b);\n    if (onesA == onesB) {\n        return a < b;\n    }\n    return onesA < onesB;\n}\n\nvector<int> sort_array(vector<int> arr) {\n    // Sort the array using the custom comparator\n    sort(arr.begin(), arr.end(), customComparator);\n    return arr;\n}\n\n// Example usage\n"}
{"task_id": "CPP/117", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\nusing namespace std;\n\n// Function to count the number of consonants in a word\nint count_consonants(const string& word) {\n    string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    int count = 0;\n    for (char ch : word) {\n        if (consonants.find(ch) != string::npos) {\n            count++;\n        }\n    }\n    return count;\n}\n\n// Function to split a string into words\nvector<string> split_string_into_words(const string& s) {\n    vector<string> words;\n    stringstream ss(s);\n    string word;\n    while (ss >> word) {\n        words.push_back(word);\n    }\n    return words;\n}\n\n// Main function to select words with exactly n consonants\nvector<string> select_words(const string& s, int n) {\n    vector<string> result;\n    vector<string> words = split_string_into_words(s);\n    for (const string& word : words) {\n        if (count_consonants(word) == n) {\n            result.push_back(word);\n        }\n    }\n    return result;\n}\n\n// Function to test the implementation\nvoid test_select_words() {\n    vector<string> result1 = select_words(\"Mary had a little lamb\", 4);\n    assert(result1 == vector<string>{\"little\"});\n\n    vector<string> result2 = select_words(\"Mary had a little lamb\", 3);\n    assert(result2 == vector<string>{\"Mary\", \"lamb\"});\n\n    vector<string> result3 = select_words(\"simple white space\", 2);\n    assert(result3.empty());\n\n    vector<string> result4 = select_words(\"Hello world\", 4);\n    assert(result4 == vector<string>{\"world\"});\n\n    vector<string> result5 = select_words(\"Uncle sam\", 3);\n    assert(result5 == vector<string>{\"Uncle\"});\n\n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/118", "generation": "#include <iostream>\n#include <string>\n#include <cctype>\nusing namespace std;\n\nbool is_vowel(char c) {\n    return c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' ||\n           c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U';\n}\n\nstring get_closest_vowel(string word) {\n    string result = \"\";\n    for (int i = word.length() - 2; i > 0; --i) {\n        if (is_vowel(word[i]) && !is_vowel(word[i - 1]) && !is_vowel(word[i + 1])) {\n            result = word[i];\n            break;\n        }\n    }\n    return result;\n}\n\n"}
{"task_id": "CPP/119", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring match_parens(vector<string> lst) {\n    // Initialize counters for open and close parentheses\n    int open1 = 0, close1 = 0, open2 = 0, close2 = 0;\n\n    // Count open and close parentheses in the first string\n    for (char c : lst[0]) {\n        if (c == '(') open1++;\n        else close1++;\n    }\n\n    // Count open and close parentheses in the second string\n    for (char c : lst[1]) {\n        if (c == '(') open2++;\n        else close2++;\n    }\n\n    // Check if concatenating the first string followed by the second string is balanced\n    if (open1 >= close1 && open2 >= close2 && open1 + open2 == close1 + close2) {\n        return \"Yes\";\n    }\n\n    // Check if concatenating the second string followed by the first string is balanced\n    if (open2 >= close2 && open1 >= close1 && open1 + open2 == close1 + close2) {\n        return \"Yes\";\n    }\n\n    // If neither concatenation is balanced, return \"No\"\n    return \"No\";\n}\n\n// Example usage\n"}
{"task_id": "CPP/120", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> maximum(vector<int> arr, int k) {\n    // Step 1: Sort the vector in ascending order\n    sort(arr.begin(), arr.end());\n    \n    // Step 2: Create a new vector to store the last k elements\n    vector<int> result(k);\n    \n    // Step 3: Copy the last k elements from arr to result\n    copy(arr.end() - k, arr.end(), result.begin());\n    \n    // Step 4: Return the result vector\n    return result;\n}\n\n// Example usage\n"}
{"task_id": "CPP/121", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nint solution(vector<int> lst) {\n    int sum = 0;\n    for (int i = 0; i < lst.size(); i++) {\n        if (i % 2 == 0 && lst[i] % 2 != 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n\n// Example usage\n"}
{"task_id": "CPP/122", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nint add_elements(vector<int> arr, int k) {\n    int sum = 0;\n    for (int i = 0; i < k; i++) {\n        if (arr[i] >= -99 && arr[i] <= 99) {\n            sum += arr[i];\n        }\n    }\n    return sum;\n}\n\n// Example usage\n"}
{"task_id": "CPP/123", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> get_odd_collatz(int n) {\n    vector<int> odd_numbers;\n    \n    while (n != 1) {\n        if (n % 2 == 1) {\n            odd_numbers.push_back(n);\n        }\n        if (n % 2 == 0) {\n            n /= 2;\n        } else {\n            n = 3 * n + 1;\n        }\n    }\n    odd_numbers.push_back(1); // The sequence always ends with 1\n    \n    sort(odd_numbers.begin(), odd_numbers.end());\n    \n    return odd_numbers;\n}\n\n// Example usage\n"}
{"task_id": "CPP/124", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <vector>\nusing namespace std;\n\nbool valid_date(string date) {\n    // Check if the date string is empty\n    if (date.empty()) {\n        return false;\n    }\n\n    // Split the date string by '-'\n    stringstream ss(date);\n    string token;\n    vector<string> parts;\n    while (getline(ss, token, '-')) {\n        parts.push_back(token);\n    }\n\n    // Check if the split results in exactly three parts\n    if (parts.size() != 3) {\n        return false;\n    }\n\n    // Convert the month, day, and year to integers\n    int month, day, year;\n    try {\n        month = stoi(parts[0]);\n        day = stoi(parts[1]);\n        year = stoi(parts[2]);\n    } catch (const invalid_argument& e) {\n        return false;\n    }\n\n    // Validate the month (1-12)\n    if (month < 1 || month > 12) {\n        return false;\n    }\n\n    // Validate the day based on the month\n    if (month == 2) {\n        if (day < 1 || day > 29) {\n            return false;\n        }\n    } else if (month == 4 || month == 6 || month == 9 || month == 11) {\n        if (day < 1 || day > 30) {\n            return false;\n        }\n    } else {\n        if (day < 1 || day > 31) {\n            return false;\n        }\n    }\n\n    // If all checks pass, return true\n    return true;\n}\n\n"}
{"task_id": "CPP/125", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <cctype>\nusing namespace std;\n\nvector<string> split_words(string txt) {\n    // Check if the string contains whitespace\n    if (txt.find(' ') != string::npos) {\n        stringstream ss(txt);\n        vector<string> words;\n        string word;\n        while (ss >> word) {\n            words.push_back(word);\n        }\n        return words;\n    }\n\n    // Check if the string contains commas\n    if (txt.find(',') != string::npos) {\n        stringstream ss(txt);\n        vector<string> words;\n        string word;\n        while (getline(ss, word, ',')) {\n            words.push_back(word);\n        }\n        return words;\n    }\n\n    // Count the number of lowercase letters with odd order in the alphabet\n    int count = 0;\n    for (char c : txt) {\n        if (islower(c) && ((c - 'a') % 2 == 1)) {\n            count++;\n        }\n    }\n\n    return {to_string(count)};\n}\n\n// Test cases\n"}
{"task_id": "CPP/126", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nbool is_sorted(vector<int> lst) {\n    if (lst.empty() || lst.size() == 1) {\n        return true;\n    }\n\n    int previous = lst[0];\n    int count = 1;\n\n    for (size_t i = 1; i < lst.size(); ++i) {\n        if (lst[i] < previous) {\n            return false; // Not sorted\n        }\n        if (lst[i] == previous) {\n            count++;\n            if (count > 2) {\n                return false; // More than two occurrences\n            }\n        } else {\n            previous = lst[i];\n            count = 1;\n        }\n    }\n\n    return true;\n}\n"}
{"task_id": "CPP/127", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to check if a number is prime\nbool isPrime(int n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    for (int i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) return false;\n    }\n    return true;\n}\n\n// Main function to determine if the intersection length is prime\nstring intersection(vector<int> interval1, vector<int> interval2) {\n    int start1 = interval1[0], end1 = interval1[1];\n    int start2 = interval2[0], end2 = interval2[1];\n\n    // Find the intersection\n    int intersectionStart = max(start1, start2);\n    int intersectionEnd = min(end1, end2);\n\n    // Check if there is no intersection\n    if (intersectionStart > intersectionEnd) {\n        return \"NO\";\n    }\n\n    // Calculate the length of the intersection\n    int intersectionLength = intersectionEnd - intersectionStart + 1;\n\n    // Check if the length is prime\n    if (isPrime(intersectionLength)) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n\n// Example usage\n"}
{"task_id": "CPP/128", "generation": "#include <stdio.h>\n#include <cmath>\n#include <vector>\nusing namespace std;\n\nint prod_signs(vector<int> arr) {\n    if (arr.empty()) {\n        return -32768;\n    }\n\n    int sum_of_magnitudes = 0;\n    int product_of_signs = 1;\n\n    for (int num : arr) {\n        sum_of_magnitudes += abs(num);\n        if (num == 0) {\n            product_of_signs = 0;\n            break;\n        } else if (num < 0) {\n            product_of_signs *= -1;\n        }\n    }\n\n    return sum_of_magnitudes * product_of_signs;\n}\n"}
{"task_id": "CPP/129", "generation": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <tuple>\n#include <climits>\n\nusing namespace std;\n\n// Define a structure to store the path and its current position\nstruct Path {\n    vector<int> values;\n    int x, y;\n};\n\n// Comparator for the priority queue to ensure lexicographical order\nstruct Compare {\n    bool operator()(const Path& a, const Path& b) const {\n        return a.values > b.values;\n    }\n};\n\nvector<int> minPath(vector<vector<int>>& grid, int k) {\n    int N = grid.size();\n    priority_queue<Path, vector<Path>, Compare> pq;\n\n    // Add all initial paths of length 1 to the priority queue\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            Path path = {{grid[i][j]}, i, j};\n            pq.push(path);\n        }\n    }\n\n    // Directions for moving to neighboring cells\n    vector<pair<int, int>> directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n\n    while (!pq.empty()) {\n        Path current = pq.top();\n        pq.pop();\n\n        // If the current path length is k, return the path\n        if (current.values.size() == k) {\n            return current.values;\n        }\n\n        // Explore all neighboring cells\n        for (auto& dir : directions) {\n            int nx = current.x + dir.first;\n            int ny = current.y + dir.second;\n\n            // Check if the new position is within the grid\n            if (nx >= 0 && nx < N && ny >= 0 && ny < N) {\n                Path newPath = current;\n                newPath.values.push_back(grid[nx][ny]);\n                newPath.x = nx;\n                newPath.y = ny;\n                pq.push(newPath);\n            }\n        }\n    }\n\n    // This line should never be reached due to the problem guarantee\n    return {};\n}\n\n"}
{"task_id": "CPP/130", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nvector<int> tri(int n) {\n    vector<int> result(n + 1, -1); // Initialize result vector with -1\n\n    // Helper function to compute Tribonacci number\n    int computeTri(int k, vector<int>& result) {\n        if (k == 1) {\n            return 3;\n        }\n        if (result[k] != -1) {\n            return result[k];\n        }\n        if (k % 2 == 0) {\n            result[k] = 1 + k / 2;\n        } else {\n            result[k] = computeTri(k - 1, result) + computeTri(k - 2, result) + computeTri(k + 1, result);\n        }\n        return result[k];\n    }\n\n    // Compute the first n + 1 Tribonacci numbers\n    for (int i = 0; i <= n; ++i) {\n        result[i] = computeTri(i, result);\n    }\n\n    return result;\n}\n\n// Example usage\n"}
{"task_id": "CPP/131", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nint digits(int n) {\n    int product = 1;\n    bool has_odd_digit = false;\n    string str_n = to_string(n);\n\n    for (char c : str_n) {\n        int digit = c - '0';\n        if (digit % 2 != 0) {\n            product *= digit;\n            has_odd_digit = true;\n        }\n    }\n\n    if (!has_odd_digit) {\n        return 0;\n    }\n\n    return product;\n}\n\n// Test cases\n"}
{"task_id": "CPP/132", "generation": "#include <iostream>\n#include <string>\n#include <stack>\nusing namespace std;\n\nbool is_nested(string str) {\n    stack<char> s;\n    bool nested = false;\n\n    for (char c : str) {\n        if (c == '[') {\n            s.push(c);\n        } else if (c == ']') {\n            if (s.empty()) {\n                return false; // Invalid sequence\n            }\n            s.pop();\n            if (!s.empty()) {\n                nested = true; // Found a nested structure\n            }\n        }\n    }\n\n    return nested;\n}\n\n"}
{"task_id": "CPP/133", "generation": "#include <cmath>\n#include <vector>\nusing namespace std;\n\nint sum_squares(vector<float> lst) {\n    int sum = 0;\n    for (float num : lst) {\n        int ceiling_value = ceil(num);\n        int squared_value = ceiling_value * ceiling_value;\n        sum += squared_value;\n    }\n    return sum;\n}\n"}
{"task_id": "CPP/134", "generation": "#include <iostream>\n#include <string>\n#include <cctype>\nusing namespace std;\n\nbool check_if_last_char_is_a_letter(string txt) {\n    // Trim trailing spaces\n    while (!txt.empty() && txt.back() == ' ') {\n        txt.pop_back();\n    }\n\n    // Check if the string is empty after trimming\n    if (txt.empty()) {\n        return false;\n    }\n\n    // Get the last character\n    char lastChar = txt.back();\n\n    // Check if the last character is an alphabetical character\n    if (isalpha(lastChar)) {\n        // Check if the last character is not part of a word\n        if (txt.length() == 1 || txt[txt.length() - 2] == ' ') {\n            return true;\n        }\n    }\n\n    return false;\n}\n\n"}
{"task_id": "CPP/135", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nint can_arrange(vector<int> arr) {\n    int largest_index = -1;\n    for (int i = arr.size() - 1; i > 0; --i) {\n        if (arr[i] < arr[i - 1]) {\n            largest_index = i;\n            break;\n        }\n    }\n    return largest_index;\n}\n\n// Test cases\n"}
{"task_id": "CPP/136", "generation": "#include <iostream>\n#include <vector>\n#include <climits>\nusing namespace std;\n\nvector<int> largest_smallest_integers(vector<int> lst) {\n    int largest_negative = INT_MIN;\n    int smallest_positive = INT_MAX;\n\n    for (int num : lst) {\n        if (num < 0) {\n            if (largest_negative == INT_MIN || num > largest_negative) {\n                largest_negative = num;\n            }\n        } else if (num > 0) {\n            if (smallest_positive == INT_MAX || num < smallest_positive) {\n                smallest_positive = num;\n            }\n        }\n    }\n\n    // Convert INT_MIN and INT_MAX back to 0 if no valid values were found\n    if (largest_negative == INT_MIN) {\n        largest_negative = 0;\n    }\n    if (smallest_positive == INT_MAX) {\n        smallest_positive = 0;\n    }\n\n    return {largest_negative, smallest_positive};\n}\n\n// Test cases\n"}
{"task_id": "CPP/137", "generation": "#include <iostream>\n#include <string>\n#include <boost/any.hpp>\n#include <sstream>\n\nboost::any compare_one(boost::any a, boost::any b) {\n    // Helper function to convert string to float\n    float string_to_float(const std::string& str) {\n        std::replace(str.begin(), str.end(), ',', '.');\n        return std::stof(str);\n    }\n\n    // Extract the types of the inputs\n    bool is_a_string = a.type() == typeid(std::string);\n    bool is_b_string = b.type() == typeid(std::string);\n\n    float a_val, b_val;\n\n    // Convert to float if necessary\n    if (is_a_string) {\n        a_val = string_to_float(boost::any_cast<std::string>(a));\n    } else {\n        a_val = boost::any_cast<float>(a);\n    }\n\n    if (is_b_string) {\n        b_val = string_to_float(boost::any_cast<std::string>(b));\n    } else {\n        b_val = boost::any_cast<float>(b);\n    }\n\n    // Compare the values\n    if (a_val == b_val) {\n        return \"None\";\n    } else if (a_val > b_val) {\n        return a;\n    } else {\n        return b;\n    }\n}\n\n"}
{"task_id": "CPP/138", "generation": "#include <iostream>\nusing namespace std;\n\nbool is_equal_to_sum_even(int n) {\n    // The smallest sum of 4 positive even numbers is 2 + 2 + 2 + 2 = 8\n    // Any number less than 8 cannot be expressed as the sum of 4 positive even numbers\n    if (n < 8) {\n        return false;\n    }\n\n    // If n is even and greater than or equal to 8, it can always be expressed as the sum of 4 even numbers\n    // This is because we can use 2 + 2 + 2 + (n - 6) where (n - 6) is even if n is even\n    return n % 2 == 0;\n}\n\n"}
{"task_id": "CPP/139", "generation": "#include <iostream>\nusing namespace std;\n\n// Function to calculate the factorial of a number\nlong long factorial(int num) {\n    long long fact = 1;\n    for (int i = 1; i <= num; ++i) {\n        fact *= i;\n    }\n    return fact;\n}\n\n// Function to calculate the Brazilian factorial\nlong long special_factorial(int n) {\n    long long result = 1;\n    for (int i = 1; i <= n; ++i) {\n        result *= factorial(i);\n    }\n    return result;\n}\n\n// Main function to test the special_factorial function\n"}
{"task_id": "CPP/140", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring fix_spaces(string text) {\n    string result = \"\";\n    int consecutive_spaces = 0;\n\n    for (char c : text) {\n        if (c == ' ') {\n            consecutive_spaces++;\n        } else {\n            if (consecutive_spaces > 2) {\n                result += \"-\";\n            } else {\n                result += string(consecutive_spaces, '_');\n            }\n            result += c;\n            consecutive_spaces = 0;\n        }\n    }\n\n    if (consecutive_spaces > 2) {\n        result += \"-\";\n    } else {\n        result += string(consecutive_spaces, '_');\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/141", "generation": "#include <iostream>\n#include <string>\n#include <cctype>\nusing namespace std;\n\nstring file_name_check(string file_name) {\n    // Check if the file name contains exactly one dot\n    size_t dot_pos = file_name.find('.');\n    if (dot_pos == string::npos || file_name.find('.', dot_pos + 1) != string::npos) {\n        return \"No\";\n    }\n\n    // Split the file name into two parts\n    string name_part = file_name.substr(0, dot_pos);\n    string extension_part = file_name.substr(dot_pos + 1);\n\n    // Check if the name part is not empty and starts with a letter\n    if (name_part.empty() || !isalpha(name_part[0])) {\n        return \"No\";\n    }\n\n    // Count the digits in the name part\n    int digit_count = 0;\n    for (char c : name_part) {\n        if (isdigit(c)) {\n            digit_count++;\n        }\n    }\n    if (digit_count > 3) {\n        return \"No\";\n    }\n\n    // Check if the extension part is one of the allowed extensions\n    if (extension_part != \"txt\" && extension_part != \"exe\" && extension_part != \"dll\") {\n        return \"No\";\n    }\n\n    // If all conditions are met, return \"Yes\"\n    return \"Yes\";\n}\n\n"}
{"task_id": "CPP/142", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nint sum_squares(vector<int> lst) {\n    int sum = 0;\n    for (int i = 0; i < lst.size(); ++i) {\n        if (i % 3 == 0) {\n            sum += lst[i] * lst[i]; // Square the element\n        } else if (i % 4 == 0) {\n            sum += lst[i] * lst[i] * lst[i]; // Cube the element\n        } else {\n            sum += lst[i]; // Add the element as is\n        }\n    }\n    return sum;\n}\n\n// Example usage\n"}
{"task_id": "CPP/143", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <cmath>\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i <= sqrt(n); ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\n// Function to filter words with prime lengths\nstring words_in_sentence(string sentence) {\n    stringstream ss(sentence);\n    string word;\n    string result;\n    while (ss >> word) {\n        if (is_prime(word.length())) {\n            if (!result.empty()) result += \" \";\n            result += word;\n        }\n    }\n    return result;\n}\n\n// Main function to test the solution\n"}
{"task_id": "CPP/144", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\nusing namespace std;\n\n// Function to parse the fraction string and return the numerator and denominator\npair<int, int> parseFraction(const string& fraction) {\n    stringstream ss(fraction);\n    string part;\n    int numerator, denominator;\n    getline(ss, part, '/'); // Read the numerator\n    numerator = stoi(part);\n    getline(ss, part); // Read the denominator\n    denominator = stoi(part);\n    return {numerator, denominator};\n}\n\nbool simplify(string x, string n) {\n    // Parse the fractions\n    pair<int, int> xFraction = parseFraction(x);\n    pair<int, int> nFraction = parseFraction(n);\n\n    // Extract numerators and denominators\n    int xNumerator = xFraction.first;\n    int xDenominator = xFraction.second;\n    int nNumerator = nFraction.first;\n    int nDenominator = nFraction.second;\n\n    // Multiply the numerators and denominators\n    int resultNumerator = xNumerator * nNumerator;\n    int resultDenominator = xDenominator * nDenominator;\n\n    // Check if the result is a whole number\n    return (resultNumerator % resultDenominator == 0);\n}\n\n"}
{"task_id": "CPP/145", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\n// Helper function to calculate the sum of digits of an integer\nint sum_of_digits(int num) {\n    int sum = 0;\n    bool isNegative = num < 0;\n    while (num != 0) {\n        int digit = num % 10;\n        if (isNegative && num < 0) {\n            digit = -digit;\n        }\n        sum += digit;\n        num /= 10;\n    }\n    return sum;\n}\n\n// Custom comparator for sorting pairs\nbool compare(const std::pair<int, int>& a, const std::pair<int, int>& b) {\n    if (a.second == b.second) {\n        return a.first < b.first;\n    }\n    return a.second < b.second;\n}\n\nstd::vector<int> order_by_points(std::vector<int> nums) {\n    // Create a vector of pairs (integer, sum of digits)\n    std::vector<std::pair<int, int>> pairs;\n    for (int i = 0; i < nums.size(); ++i) {\n        pairs.push_back({nums[i], sum_of_digits(nums[i])});\n    }\n\n    // Sort the pairs using the custom comparator\n    std::sort(pairs.begin(), pairs.end(), compare);\n\n    // Extract the sorted integers\n    std::vector<int> sorted_nums;\n    for (const auto& p : pairs) {\n        sorted_nums.push_back(p.first);\n    }\n\n    return sorted_nums;\n}\n\n// Function to test the solution\nvoid test_order_by_points() {\n    std::vector<int> test1 = {1, 11, -1, -11, -12};\n    std::vector<int> expected1 = {-1, -11, 1, -12, 11};\n    assert(order_by_points(test1) == expected1);\n\n    std::vector<int> test2 = {};\n    std::vector<int> expected2 = {};\n    assert(order_by_points(test2) == expected2);\n\n    std::cout << \"All tests passed!\" << std::endl;\n}\n\n"}
{"task_id": "CPP/146", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nbool isOdd(int digit) {\n    return digit % 2 != 0;\n}\n\nint specialFilter(vector<int> nums) {\n    int count = 0;\n    for (int num : nums) {\n        if (num > 10) {\n            string numStr = to_string(num);\n            int firstDigit = numStr[0] - '0';\n            int lastDigit = numStr[numStr.length() - 1] - '0';\n            if (isOdd(firstDigit) && isOdd(lastDigit)) {\n                count++;\n            }\n        }\n    }\n    return count;\n}\n\n// Example usage\n"}
{"task_id": "CPP/147", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nint get_max_triples(int n) {\n    // Step 1: Initialize the vector a\n    vector<int> a(n);\n    \n    // Step 2: Populate the vector a\n    for (int i = 1; i <= n; ++i) {\n        a[i-1] = i * i - i + 1;\n    }\n    \n    // Step 3: Initialize the counter\n    int count = 0;\n    \n    // Step 4: Iterate through all possible triples (i, j, k)\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            for (int k = j + 1; k < n; ++k) {\n                // Step 5: Check if the sum is a multiple of 3\n                if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                    count++;\n                }\n            }\n        }\n    }\n    \n    // Step 6: Return the count\n    return count;\n}\n\n// Example usage\n"}
{"task_id": "CPP/148", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nvector<string> bf(string planet1, string planet2) {\n    // List of planets in order of proximity to the Sun\n    vector<string> planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n    \n    // Check if both planet names are valid\n    if (find(planets.begin(), planets.end(), planet1) == planets.end() || \n        find(planets.begin(), planets.end(), planet2) == planets.end()) {\n        return {};\n    }\n    \n    // Find the indices of the input planets\n    int index1 = find(planets.begin(), planets.end(), planet1) - planets.begin();\n    int index2 = find(planets.begin(), planets.end(), planet2) - planets.begin();\n    \n    // Ensure index1 is less than index2\n    if (index1 > index2) {\n        swap(index1, index2);\n    }\n    \n    // Extract the planets between the indices\n    vector<string> result;\n    for (int i = index1 + 1; i < index2; ++i) {\n        result.push_back(planets[i]);\n    }\n    \n    return result;\n}\n\n// Function to test the bf function\nvoid test_bf() {\n    vector<string> result1 = bf(\"Jupiter\", \"Neptune\");\n    for (const auto& planet : result1) {\n        cout << planet << \" \";\n    }\n    cout << endl;\n\n    vector<string> result2 = bf(\"Earth\", \"Mercury\");\n    for (const auto& planet : result2) {\n        cout << planet << \" \";\n    }\n    cout << endl;\n\n    vector<string> result3 = bf(\"Mercury\", \"Uranus\");\n    for (const auto& planet : result3) {\n        cout << planet << \" \";\n    }\n    cout << endl;\n}\n\n"}
{"task_id": "CPP/149", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nvector<string> sorted_list_sum(vector<string> lst) {\n    // Step 1: Filter out strings with odd lengths\n    vector<string> result;\n    for (const string& str : lst) {\n        if (str.length() % 2 == 0) {\n            result.push_back(str);\n        }\n    }\n\n    // Step 2: Sort the result vector\n    // First, sort by length\n    sort(result.begin(), result.end(), [](const string& a, const string& b) {\n        if (a.length() == b.length()) {\n            return a < b; // Alphabetical order if lengths are equal\n        }\n        return a.length() < b.length(); // Length order\n    });\n\n    return result;\n}\n\n// Function to test the sorted_list_sum function\nvoid test_sorted_list_sum() {\n    assert((sorted_list_sum({\"aa\", \"a\", \"aaa\"}) == vector<string>{\"aa\"}));\n    assert((sorted_list_sum({\"ab\", \"a\", \"aaa\", \"cd\"}) == vector<string>{\"ab\", \"cd\"}));\n    assert((sorted_list_sum({\"abc\", \"def\", \"ghi\", \"jkl\"}) == vector<string>{}));\n    assert((sorted_list_sum({\"one\", \"two\", \"three\", \"four\", \"five\"}) == vector<string>{\"one\", \"four\"}));\n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/150", "generation": "#include <iostream>\n#include <cmath>\nusing namespace std;\n\n// Helper function to check if a number is prime\nbool is_prime(int n) {\n    if (n <= 1) {\n        return false;\n    }\n    for (int i = 2; i <= sqrt(n); i++) {\n        if (n % i == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\n// Main function to return x if n is prime, y otherwise\nint x_or_y(int n, int x, int y) {\n    if (is_prime(n)) {\n        return x;\n    } else {\n        return y;\n    }\n}\n\n// Function to test the x_or_y function\nvoid test_x_or_y() {\n    cout << \"x_or_y(7, 34, 12) = \" << x_or_y(7, 34, 12) << \" (Expected: 34)\" << endl;\n    cout << \"x_or_y(15, 8, 5) = \" << x_or_y(15, 8, 5) << \" (Expected: 5)\" << endl;\n}\n\n"}
{"task_id": "CPP/151", "generation": "#include <stdio.h>\n#include <math.h>\n#include <vector>\nusing namespace std;\n\nlong long double_the_difference(vector<float> lst) {\n    long long sum_of_squares = 0;\n    for (float num : lst) {\n        // Check if the number is a non-negative integer\n        if (num >= 0 && floor(num) == num) {\n            int int_num = static_cast<int>(num);\n            // Check if the number is odd\n            if (int_num % 2 != 0) {\n                sum_of_squares += int_num * int_num;\n            }\n        }\n    }\n    return sum_of_squares;\n}\n\n// Example usage\n"}
{"task_id": "CPP/152", "generation": "#include <stdio.h>\n#include <math.h>\n#include <vector>\nusing namespace std;\n\nvector<int> compare(vector<int> game, vector<int> guess) {\n    vector<int> differences;\n    for (size_t i = 0; i < game.size(); ++i) {\n        int diff = abs(game[i] - guess[i]);\n        differences.push_back(diff);\n    }\n    return differences;\n}\n\n// Example usage\n"}
{"task_id": "CPP/153", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring Strongest_Extension(string class_name, vector<string> extensions) {\n    int max_strength = INT_MIN;\n    int strongest_index = 0;\n\n    for (int i = 0; i < extensions.size(); ++i) {\n        int cap = 0, sm = 0;\n        for (char c : extensions[i]) {\n            if (isupper(c)) {\n                cap++;\n            } else if (islower(c)) {\n                sm++;\n            }\n        }\n        int strength = cap - sm;\n        if (strength > max_strength) {\n            max_strength = strength;\n            strongest_index = i;\n        }\n    }\n\n    return class_name + \".\" + extensions[strongest_index];\n}\n\n// Example usage\n"}
{"task_id": "CPP/154", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool cycpattern_check(string a, string b) {\n    // Concatenate the first word with itself\n    string concatenated = a + a;\n    \n    // Check if the second word is a substring of the concatenated string\n    return concatenated.find(b) != string::npos;\n}\n\n"}
{"task_id": "CPP/155", "generation": "#include <stdio.h>\n#include <string>\n#include <vector>\nusing namespace std;\n\nvector<int> even_odd_count(int num) {\n    // Handle negative numbers\n    if (num < 0) {\n        num = -num;\n    }\n\n    // Convert the number to a string\n    string num_str = to_string(num);\n\n    // Initialize counters\n    int even_count = 0;\n    int odd_count = 0;\n\n    // Iterate through each character in the string\n    for (char c : num_str) {\n        int digit = c - '0'; // Convert char to integer\n        if (digit % 2 == 0) {\n            even_count++;\n        } else {\n            odd_count++;\n        }\n    }\n\n    // Return the result as a vector\n    return {even_count, odd_count};\n}\n\n// Example usage\n"}
{"task_id": "CPP/156", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring int_to_mini_roman(int number) {\n    // Define the Roman numeral values and their corresponding symbols\n    vector<pair<int, string>> romanNumerals = {\n        {1000, \"m\"}, {900, \"cm\"}, {500, \"d\"}, {400, \"cd\"},\n        {100, \"c\"}, {90, \"xc\"}, {50, \"l\"}, {40, \"xl\"},\n        {10, \"x\"}, {9, \"ix\"}, {5, \"v\"}, {4, \"iv\"}, {1, \"i\"}\n    };\n\n    string result = \"\";\n\n    // Iterate through the Roman numeral values\n    for (const auto& valueSymbolPair : romanNumerals) {\n        while (number >= valueSymbolPair.first) {\n            number -= valueSymbolPair.first;\n            result += valueSymbolPair.second;\n        }\n    }\n\n    return result;\n}\n\n// Function to test the conversion\nvoid test() {\n    cout << (int_to_mini_roman(19) == \"xix\") << endl;\n    cout << (int_to_mini_roman(152) == \"clii\") << endl;\n    cout << (int_to_mini_roman(426) == \"cdxxvi\") << endl;\n}\n\n"}
{"task_id": "CPP/157", "generation": "#include <stdio.h>\n#include <math.h>\n#include <algorithm>\nusing namespace std;\n\nbool right_angle_triangle(float a, float b, float c) {\n    // Store the sides in an array\n    float sides[3] = {a, b, c};\n    \n    // Sort the sides to ensure the longest side is last\n    sort(sides, sides + 3);\n    \n    // Apply the Pythagorean theorem\n    return (pow(sides[0], 2) + pow(sides[1], 2) == pow(sides[2], 2));\n}\n\n// Example usage\n"}
{"task_id": "CPP/158", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <set>\n#include <algorithm>\nusing namespace std;\n\nstring find_max(vector<string> words) {\n    int max_unique_count = 0;\n    string result = \"\";\n    \n    for (const string& word : words) {\n        set<char> unique_chars(word.begin(), word.end());\n        int unique_count = unique_chars.size();\n        \n        if (unique_count > max_unique_count || (unique_count == max_unique_count && word < result)) {\n            max_unique_count = unique_count;\n            result = word;\n        }\n    }\n    \n    return result;\n}\n\n// Test cases\n"}
{"task_id": "CPP/159", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nvector<int> eat(int number, int need, int remaining) {\n    // Calculate the total number of carrots eaten\n    int total_eaten = number + min(need, remaining);\n    \n    // Calculate the number of carrots left\n    int left = max(remaining - need, 0);\n    \n    // Return the result as a vector\n    return {total_eaten, left};\n}\n\n// Example usage\n"}
{"task_id": "CPP/160", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\n#include <cmath>\n\nint do_algebra(std::vector<std::string> operato, std::vector<int> operand) {\n    std::stack<int> stack;\n\n    for (size_t i = 0; i < operand.size(); ++i) {\n        stack.push(operand[i]);\n\n        if (i < operato.size()) {\n            std::string op = operato[i];\n\n            if (op == \"+\" || op == \"-\") {\n                int b = stack.top();\n                stack.pop();\n                int a = stack.top();\n                stack.pop();\n\n                if (op == \"+\") {\n                    stack.push(a + b);\n                } else {\n                    stack.push(a - b);\n                }\n            } else if (op == \"*\" || op == \"//\" || op == \"**\") {\n                int b = stack.top();\n                stack.pop();\n                int a = stack.top();\n                stack.pop();\n\n                if (op == \"*\") {\n                    stack.push(a * b);\n                } else if (op == \"//\") {\n                    stack.push(a / b);\n                } else if (op == \"**\") {\n                    stack.push(static_cast<int>(pow(a, b)));\n                }\n            }\n        }\n    }\n\n    return stack.top();\n}\n\n"}
{"task_id": "CPP/161", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring solve(string s) {\n    bool containsLetter = false;\n    string result = \"\";\n\n    for (char c : s) {\n        if (isalpha(c)) {\n            if (islower(c)) {\n                result += toupper(c);\n            } else {\n                result += tolower(c);\n            }\n            containsLetter = true;\n        } else {\n            result += c;\n        }\n    }\n\n    if (!containsLetter) {\n        reverse(result.begin(), result.end());\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/162", "generation": "#include <iostream>\n#include <string>\n#include <openssl/md5.h>\n\nusing namespace std;\n\nstring string_to_md5(string text) {\n    if (text.empty()) {\n        return \"None\";\n    }\n\n    unsigned char digest[MD5_DIGEST_LENGTH];\n    MD5((unsigned char*)text.c_str(), text.length(), (unsigned char*)&digest); \n\n    char mdString[33];\n    for (int i = 0; i < 16; ++i) {\n        sprintf(&mdString[i*2], \"%02x\", (unsigned int)digest[i]);\n    }\n\n    return string(mdString);\n}\n\n"}
{"task_id": "CPP/163", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> generate_integers(int a, int b) {\n    // Ensure a is the smaller number and b is the larger number\n    if (a > b) {\n        swap(a, b);\n    }\n\n    // Initialize an empty vector to store the even digits\n    vector<int> even_digits;\n\n    // Iterate through the range from a to b\n    for (int i = a; i <= b; ++i) {\n        // Check if the number is an even digit\n        if (i == 0 || i == 2 || i == 4 || i == 6 || i == 8) {\n            even_digits.push_back(i);\n        }\n    }\n\n    // Return the vector of even digits\n    return even_digits;\n}\n\n// Example usage\n"}
