{"task_id": "CPP/0", "generation": "#include <vector>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\nbool has_close_elements(vector<float> numbers, float threshold) {\n    // Step 1: Input Validation\n    if (numbers.empty()) {\n        return false;\n    }\n\n    // Step 2: Sort the Vector\n    sort(numbers.begin(), numbers.end());\n\n    // Step 3: Compare Adjacent Elements\n    for (size_t i = 0; i < numbers.size() - 1; ++i) {\n        if (abs(numbers[i] - numbers[i + 1]) < threshold) {\n            return true;\n        }\n    }\n\n    // Step 4: Return Result\n    return false;\n}\n"}
{"task_id": "CPP/1", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\n#include <cassert>\nusing namespace std;\n\n// Function to remove spaces from the input string\nstring remove_spaces(const string& input) {\n    string result;\n    for (char c : input) {\n        if (c != ' ') {\n            result += c;\n        }\n    }\n    return result;\n}\n\n// Main function to separate groups of balanced parentheses\nvector<string> separate_paren_groups(string paren_string) {\n    paren_string = remove_spaces(paren_string);\n    vector<string> result;\n    stack<char> s;\n    string current_group;\n\n    for (char c : paren_string) {\n        if (c == '(') {\n            s.push(c);\n            current_group += c;\n        } else if (c == ')') {\n            s.pop();\n            current_group += c;\n            if (s.empty()) {\n                result.push_back(current_group);\n                current_group.clear();\n            }\n        }\n    }\n\n    return result;\n}\n\n// Helper function to compare two vectors of strings\nbool compare_vectors(const vector<string>& v1, const vector<string>& v2) {\n    return v1 == v2;\n}\n\n// Test function to validate the implementation\nvoid test_separate_paren_groups() {\n    assert(compare_vectors(separate_paren_groups(\"( ) (( )) (( )( ))\"), vector<string>{\"()\", \"(())\", \"(()())\"}));\n    assert(compare_vectors(separate_paren_groups(\"((())) (()) ()\"), vector<string>{\"((()))\", \"(())\", \"()\"}));\n    assert(compare_vectors(separate_paren_groups(\"()\"), vector<string>{\"()\"}));\n    assert(compare_vectors(separate_paren_groups(\"\"), vector<string>{}));\n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/2", "generation": "#include <stdio.h>\n#include <math.h>\n\nfloat truncate_number(float number) {\n    if (number <= 0) {\n        // Handle invalid input (e.g., return -1 or throw an exception)\n        return -1; // Example: returning -1 to indicate an error\n    }\n\n    float integer_part = floor(number);\n    float decimal_part = number - integer_part;\n\n    return decimal_part;\n}\n\n"}
{"task_id": "CPP/3", "generation": "#include <vector>\nusing namespace std;\n\nbool below_zero(vector<int> operations) {\n    int balance = 0; // Initialize balance to 0\n    \n    // Iterate through each operation\n    for (int op : operations) {\n        // Update balance\n        balance += op;\n        \n        // Check if balance falls below zero\n        if (balance < 0) {\n            return true; // Return true if balance falls below zero\n        }\n    }\n    \n    // Return false if balance never falls below zero\n    return false;\n}\n"}
{"task_id": "CPP/4", "generation": "#include <vector>\n#include <cmath>\n#include <stdexcept>\nusing namespace std;\n\nfloat mean_absolute_deviation(vector<float> numbers) {\n    // Step 1: Input Validation\n    if (numbers.empty()) {\n        throw invalid_argument(\"Input vector cannot be empty\");\n    }\n\n    // Step 2: Calculate the Mean\n    float sum = 0.0;\n    for (float num : numbers) {\n        sum += num;\n    }\n    float mean = sum / numbers.size();\n\n    // Step 3: Calculate Absolute Differences\n    float sum_of_abs_diff = 0.0;\n    for (float num : numbers) {\n        sum_of_abs_diff += fabs(num - mean);\n    }\n\n    // Step 4: Calculate the Mean Absolute Deviation\n    float mad = sum_of_abs_diff / numbers.size();\n\n    // Step 5: Return the Result\n    return mad;\n}\n"}
{"task_id": "CPP/5", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> intersperse(vector<int> numbers, int delimiter) {\n    if (numbers.empty()) {\n        return {};\n    }\n\n    vector<int> result;\n\n    for (size_t i = 0; i < numbers.size() - 1; ++i) {\n        result.push_back(numbers[i]);\n        result.push_back(delimiter);\n    }\n\n    result.push_back(numbers.back());\n\n    return result;\n}\n"}
{"task_id": "CPP/6", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\nusing namespace std;\n\nvector<int> parse_nested_parens(string paren_string) {\n    vector<int> result;\n    stringstream ss(paren_string);\n    string group;\n\n    while (getline(ss, group, ' ')) {\n        int current_depth = 0;\n        int max_depth = 0;\n\n        for (char c : group) {\n            if (c == '(') {\n                current_depth++;\n                if (current_depth > max_depth) {\n                    max_depth = current_depth;\n                }\n            } else if (c == ')') {\n                current_depth--;\n            }\n        }\n\n        result.push_back(max_depth);\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/7", "generation": "#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> filter_by_substring(vector<string> strings, string substring) {\n    // Input Validation\n    if (strings.empty() || substring.empty()) {\n        return {};\n    }\n\n    // Initialize Result Vector\n    vector<string> result;\n\n    // Iterate Through Input Vector\n    for (const auto& str : strings) {\n        // Check for Substring\n        if (str.find(substring) != std::string::npos) {\n            // Result Collection\n            result.push_back(str);\n        }\n    }\n\n    // Return Result\n    return result;\n}\n"}
{"task_id": "CPP/8", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> sum_product(vector<int> numbers) {\n    // Handle empty vector\n    if (numbers.empty()) {\n        return {0, 1};\n    }\n\n    // Initialize variables\n    int sum = 0;\n    int product = 1;\n\n    // Calculate sum\n    for (int num : numbers) {\n        sum += num;\n    }\n\n    // Calculate product\n    for (int num : numbers) {\n        product *= num;\n    }\n\n    // Return result\n    return {sum, product};\n}\n"}
{"task_id": "CPP/9", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> rolling_max(vector<int> numbers) {\n    if (numbers.empty()) {\n        return {};\n    }\n    if (numbers.size() == 1) {\n        return numbers;\n    }\n\n    int current_max = numbers[0];\n    vector<int> result;\n    result.push_back(current_max);\n\n    for (size_t i = 1; i < numbers.size(); ++i) {\n        if (numbers[i] > current_max) {\n            current_max = numbers[i];\n        }\n        result.push_back(current_max);\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/10", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\n// Function to check if a string is a palindrome\nbool is_palindrome(const string& str) {\n    string reversed(str.rbegin(), str.rend());\n    return reversed == str;\n}\n\n// Function to find the shortest palindrome that begins with a supplied string\nstring make_palindrome(const string& str) {\n    int n = str.length();\n    string longest_palindromic_suffix = \"\";\n\n    // Find the longest palindromic suffix\n    for (int i = 0; i < n; ++i) {\n        string suffix = str.substr(i);\n        if (is_palindrome(suffix)) {\n            longest_palindromic_suffix = suffix;\n            break;\n        }\n    }\n\n    // Extract the prefix before the palindromic suffix\n    string prefix = str.substr(0, n - longest_palindromic_suffix.length());\n\n    // Reverse the prefix\n    string reversed_prefix(prefix.rbegin(), prefix.rend());\n\n    // Append the reversed prefix to the end of the input string\n    return str + reversed_prefix;\n}\n\n"}
{"task_id": "CPP/11", "generation": "#include <iostream>\n#include <string>\n#include <stdexcept>\n\nusing namespace std;\n\nbool isValidString(const string& s) {\n    for (char c : s) {\n        if (c != '0' && c != '1') {\n            return false;\n        }\n    }\n    return true;\n}\n\nstring string_xor(string a, string b) {\n    // Input validation\n    if (!isValidString(a) || !isValidString(b)) {\n        throw invalid_argument(\"Both strings must contain only '0' and '1'.\");\n    }\n\n    // Ensure both strings are of the same length\n    while (a.length() < b.length()) {\n        a = \"0\" + a;\n    }\n    while (b.length() < a.length()) {\n        b = \"0\" + b;\n    }\n\n    // Binary XOR operation\n    string result = \"\";\n    for (size_t i = 0; i < a.length(); ++i) {\n        char xorResult = (a[i] == b[i]) ? '0' : '1';\n        result += xorResult;\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/12", "generation": "#include <vector>\n#include <string>\nusing namespace std;\n\nstring longest(vector<string> strings) {\n    if (strings.empty()) {\n        return \"\";\n    }\n\n    int max_length = 0;\n    string longest_string = \"\";\n\n    for (const string& str : strings) {\n        if (str.length() > max_length) {\n            max_length = str.length();\n            longest_string = str;\n        }\n    }\n\n    return longest_string;\n}\n"}
{"task_id": "CPP/13", "generation": "#include <iostream>\n\nint greatest_common_divisor(int a, int b) {\n    if (a == 0 && b == 0) {\n        return 0; // or handle error\n    }\n    while (b != 0) {\n        int temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n\n"}
{"task_id": "CPP/14", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> all_prefixes(string str) {\n    vector<string> prefixes;\n    for (size_t i = 1; i <= str.length(); ++i) {\n        string prefix = str.substr(0, i);\n        prefixes.push_back(prefix);\n    }\n    return prefixes;\n}\n\n"}
{"task_id": "CPP/15", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\nusing namespace std;\n\nstring string_sequence(int n) {\n    if (n < 0) {\n        return \"\";\n    }\n\n    string result = \"\";\n    for (int i = 0; i <= n; ++i) {\n        result += to_string(i) + \" \";\n    }\n\n    if (!result.empty()) {\n        result.pop_back(); // Remove the trailing space\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/16", "generation": "#include <iostream>\n#include <string>\n#include <set>\n#include <cctype> // for std::tolower\n\nint count_distinct_characters(const std::string& str) {\n    std::set<char> unique_chars;\n    \n    // Convert the string to lowercase and store unique characters\n    for (char c : str) {\n        char lower_c = std::tolower(c);\n        unique_chars.insert(lower_c);\n    }\n    \n    // Return the number of unique characters\n    return unique_chars.size();\n}\n\n"}
{"task_id": "CPP/17", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\nusing namespace std;\n\nvector<int> parse_music(string music_string) {\n    vector<int> beats;\n    std::istringstream iss(music_string);\n    string note;\n    while (iss >> note) {\n        int beat = 0;\n        if (note == \"o\") {\n            beat = 4;\n        } else if (note == \"o|\") {\n            beat = 2;\n        } else if (note == \".|\") {\n            beat = 1;\n        }\n        beats.push_back(beat);\n    }\n    return beats;\n}\n\n// Test function to verify the correctness\nvoid test_parse_music() {\n    string input = \"o o| .| o| o| .| .| .| .| o o\";\n    vector<int> expected = {4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4};\n    vector<int> result = parse_music(input);\n    if (result == expected) {\n        cout << \"Test passed!\" << endl;\n    } else {\n        cout << \"Test failed!\" << endl;\n    }\n}\n\n"}
{"task_id": "CPP/18", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint how_many_times(string str, string substring) {\n    // Input validation\n    if (str.empty() || substring.empty()) {\n        return 0;\n    }\n\n    // Initialize count\n    int count = 0;\n\n    // Iterate through the string\n    for (size_t i = 0; i <= str.length() - substring.length(); ++i) {\n        if (str.substr(i, substring.length()) == substring) {\n            count++;\n        }\n    }\n\n    // Return the count\n    return count;\n}\n\n// Test cases\n"}
{"task_id": "CPP/19", "generation": "#include <iostream>\n#include <string>\n#include <vector>\n#include <map>\n#include <algorithm>\n\nusing namespace std;\n\n// Initialize the mapping\nmap<string, int> numeral_to_int = {\n    {\"zero\", 0}, {\"one\", 1}, {\"two\", 2}, {\"three\", 3}, {\"four\", 4},\n    {\"five\", 5}, {\"six\", 6}, {\"seven\", 7}, {\"eight\", 8}, {\"nine\", 9}\n};\n\n// Function to parse the input string\nvector<string> parse_input(const string& input) {\n    vector<string> words;\n    string word;\n    stringstream ss(input);\n    while (ss >> word) {\n        words.push_back(word);\n    }\n    return words;\n}\n\n// Function to convert numerals to integers\nvector<int> convert_to_integers(const vector<string>& words) {\n    vector<int> integers;\n    for (const auto& word : words) {\n        integers.push_back(numeral_to_int[word]);\n    }\n    return integers;\n}\n\n// Function to sort the integers\nvoid sort_integers(vector<int>& integers) {\n    sort(integers.begin(), integers.end());\n}\n\n// Function to convert integers back to numerals\nvector<string> convert_to_numerals(const vector<int>& integers) {\n    vector<string> numerals;\n    for (int num : integers) {\n        for (const auto& pair : numeral_to_int) {\n            if (pair.second == num) {\n                numerals.push_back(pair.first);\n                break;\n            }\n        }\n    }\n    return numerals;\n}\n\n// Function to reconstruct the output string\nstring reconstruct_output(const vector<string>& numerals) {\n    string result;\n    for (size_t i = 0; i < numerals.size(); ++i) {\n        result += numerals[i];\n        if (i < numerals.size() - 1) {\n            result += \" \";\n        }\n    }\n    return result;\n}\n\n// Main function to sort the numbers\nstring sort_numbers(const string& numbers) {\n    // Parse the input\n    vector<string> words = parse_input(numbers);\n    \n    // Convert numerals to integers\n    vector<int> integers = convert_to_integers(words);\n    \n    // Sort the integers\n    sort_integers(integers);\n    \n    // Convert integers back to numerals\n    vector<string> numerals = convert_to_numerals(integers);\n    \n    // Reconstruct the output string\n    return reconstruct_output(numerals);\n}\n\n"}
{"task_id": "CPP/20", "generation": "#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <stdexcept>\n\nstd::vector<float> find_closest_elements(std::vector<float> numbers) {\n    // Step 1: Input Validation\n    if (numbers.size() < 2) {\n        throw std::invalid_argument(\"Input vector must contain at least two elements.\");\n    }\n\n    // Step 2: Sorting the Vector\n    std::sort(numbers.begin(), numbers.end());\n\n    // Step 3: Finding the Closest Pair\n    float min_diff = std::numeric_limits<float>::max();\n    std::vector<float> closest_pair(2);\n\n    for (size_t i = 1; i < numbers.size(); ++i) {\n        float diff = std::abs(numbers[i] - numbers[i - 1]);\n        if (diff < min_diff) {\n            min_diff = diff;\n            closest_pair[0] = numbers[i - 1];\n            closest_pair[1] = numbers[i];\n        }\n    }\n\n    // Step 4: Returning the Result\n    return closest_pair;\n}\n"}
{"task_id": "CPP/21", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <stdexcept>\n\nstd::vector<float> rescale_to_unit(const std::vector<float>& numbers) {\n    // Input validation\n    if (numbers.size() < 2) {\n        throw std::invalid_argument(\"Vector must contain at least two elements.\");\n    }\n\n    // Find the minimum and maximum values\n    float min_value = *std::min_element(numbers.begin(), numbers.end());\n    float max_value = *std::max_element(numbers.begin(), numbers.end());\n\n    // Calculate the range\n    float range = max_value - min_value;\n\n    // Apply the linear transformation\n    std::vector<float> transformed_numbers;\n    for (float value : numbers) {\n        float new_value = (value - min_value) / range;\n        transformed_numbers.push_back(new_value);\n    }\n\n    // Return the transformed vector\n    return transformed_numbers;\n}\n\n"}
{"task_id": "CPP/22", "generation": "#include <iostream>\n#include <vector>\n#include <list>\n#include <boost/any.hpp>\n\nstd::vector<int> filter_integers(std::list<boost::any> values) {\n    std::vector<int> result;\n\n    for (const auto& value : values) {\n        if (value.type() == typeid(int)) {\n            int intValue = boost::any_cast<int>(value);\n            result.push_back(intValue);\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/23", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint strlen(const string& str) {\n    // Check if the string is empty\n    if (str.empty()) {\n        return 0;\n    }\n\n    // Calculate the length of the string\n    return str.size();\n}\n\n"}
{"task_id": "CPP/24", "generation": "#include <iostream>\n\nint largest_divisor(int n) {\n    if (n <= 1) {\n        return -1; // Handle edge case where n is 1 or less\n    }\n\n    for (int i = n - 1; i >= 1; --i) {\n        if (n % i == 0) {\n            return i;\n        }\n    }\n\n    return -1; // This line should theoretically never be reached for n > 1\n}\n\n"}
{"task_id": "CPP/25", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> factorize(int n) {\n    vector<int> factors;\n    int divisor = 2;\n    while (n > 1) {\n        while (n % divisor == 0) {\n            factors.push_back(divisor);\n            n /= divisor;\n        }\n        divisor++;\n    }\n    return factors;\n}\n"}
{"task_id": "CPP/26", "generation": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nvector<int> remove_duplicates(vector<int> numbers) {\n    // Step 1: Initialize data structures\n    unordered_map<int, int> countMap;\n    vector<int> result;\n\n    // Step 2: Count occurrences\n    for (int num : numbers) {\n        countMap[num]++;\n    }\n\n    // Step 3: Filter and maintain order\n    for (int num : numbers) {\n        if (countMap[num] == 1) {\n            result.push_back(num);\n        }\n    }\n\n    // Step 4: Return the result\n    return result;\n}\n\n// Example usage\n"}
{"task_id": "CPP/27", "generation": "#include <iostream>\n#include <string>\n#include <cctype> // for islower, isupper, tolower, toupper\n\nusing namespace std;\n\nstring flip_case(string str) {\n    if (str.empty()) {\n        return \"\";\n    }\n\n    string result = \"\";\n    for (char c : str) {\n        if (islower(c)) {\n            result += toupper(c);\n        } else if (isupper(c)) {\n            result += tolower(c);\n        } else {\n            result += c; // Non-alphabetic characters remain unchanged\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/28", "generation": "#include <vector>\n#include <string>\nusing namespace std;\n\nstring concatenate(vector<string> strings) {\n    if (strings.empty()) {\n        return \"\";\n    }\n\n    string result = \"\";\n    for (const string& str : strings) {\n        result += str;\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/29", "generation": "#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> filter_by_prefix(vector<string> strings, string prefix) {\n    vector<string> result;\n    for (const auto& str : strings) {\n        if (str.substr(0, prefix.length()) == prefix) {\n            result.push_back(str);\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/30", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<float> get_positive(vector<float> l) {\n    vector<float> positive_numbers;\n    for (float num : l) {\n        if (num > 0) {\n            positive_numbers.push_back(num);\n        }\n    }\n    return positive_numbers;\n}\n\n"}
{"task_id": "CPP/31", "generation": "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\nbool is_prime(long long n) {\n    // Step 1: Input Validation\n    if (n < 2) {\n        return false;\n    }\n    if (n == 2) {\n        return true;\n    }\n    if (n % 2 == 0) {\n        return false;\n    }\n\n    // Step 2: Prime Number Check\n    for (long long i = 3; i * i <= n; i += 2) {\n        if (n % i == 0) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\n"}
{"task_id": "CPP/32", "generation": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\ndouble poly(const vector<double>& xs, double x) {\n    double sum = 0;\n    for (size_t i = 0; i < xs.size(); ++i) {\n        sum += xs[i] * pow(x, i);\n    }\n    return sum;\n}\n\ndouble find_zero(const vector<double>& xs) {\n    // Validate input\n    assert(xs.size() % 2 == 0 && \"The number of coefficients must be even.\");\n    assert(xs.back() != 0 && \"The largest non-zero coefficient must be present.\");\n\n    // Initial guess and tolerance\n    double x = 0.0;\n    double tolerance = 1e-6;\n    double step = 0.1;\n\n    // Simple bisection method\n    double left = -10.0;\n    double right = 10.0;\n    while (right - left > tolerance) {\n        double mid = (left + right) / 2.0;\n        if (poly(xs, mid) == 0) {\n            return mid;\n        } else if (poly(xs, mid) * poly(xs, left) < 0) {\n            right = mid;\n        } else {\n            left = mid;\n        }\n    }\n\n    return (left + right) / 2.0;\n}\n\n"}
{"task_id": "CPP/33", "generation": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> sort_third(vector<int> l) {\n    // Step 1: Initialize variables\n    vector<int> indices;\n    vector<int> elements;\n\n    // Step 2: Identify and extract elements\n    for (int i = 0; i < l.size(); ++i) {\n        if (i % 3 == 0) {\n            indices.push_back(i);\n            elements.push_back(l[i]);\n        }\n    }\n\n    // Step 3: Sort the extracted elements\n    sort(elements.begin(), elements.end());\n\n    // Step 4: Reconstruct the output vector\n    vector<int> l_prime = l;\n    for (int i = 0; i < indices.size(); ++i) {\n        l_prime[indices[i]] = elements[i];\n    }\n\n    // Step 5: Return the result\n    return l_prime;\n}\n"}
{"task_id": "CPP/34", "generation": "#include <iostream>\n#include <vector>\n#include <set>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> unique(vector<int> l) {\n    // Use a set to remove duplicates\n    set<int> unique_set(l.begin(), l.end());\n    \n    // Convert the set back to a vector\n    vector<int> result(unique_set.begin(), unique_set.end());\n    \n    // Return the sorted unique vector\n    return result;\n}\n\n"}
{"task_id": "CPP/35", "generation": "#include <vector>\n#include <limits>\n#include <stdexcept>\nusing namespace std;\n\nfloat max_element(vector<float> l) {\n    // Input validation\n    if (l.empty()) {\n        throw std::invalid_argument(\"The input vector is empty.\");\n    }\n\n    // Initialize the maximum element\n    float max_val = std::numeric_limits<float>::lowest();\n\n    // Iterate through the vector\n    for (float num : l) {\n        if (num > max_val) {\n            max_val = num;\n        }\n    }\n\n    // Return the maximum element\n    return max_val;\n}\n"}
{"task_id": "CPP/36", "generation": "#include <iostream>\n#include <string>\n\nint fizz_buzz(int n) {\n    int count = 0; // Initialize counter\n\n    for (int i = 1; i < n; ++i) {\n        // Check if the number is divisible by 11 or 13\n        if (i % 11 == 0 || i % 13 == 0) {\n            // Convert the number to a string\n            std::string num_str = std::to_string(i);\n\n            // Count occurrences of '7'\n            for (char c : num_str) {\n                if (c == '7') {\n                    count++;\n                }\n            }\n        }\n    }\n\n    return count; // Return the total count\n}\n\n"}
{"task_id": "CPP/37", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<float> sort_even(vector<float> l) {\n    // Extract even indices elements\n    vector<float> even_elements;\n    for (size_t i = 0; i < l.size(); i += 2) {\n        even_elements.push_back(l[i]);\n    }\n\n    // Sort even indices elements\n    std::sort(even_elements.begin(), even_elements.end());\n\n    // Construct the result vector\n    vector<float> l_prime(l.size());\n    size_t even_index = 0;\n    for (size_t i = 0; i < l.size(); ++i) {\n        if (i % 2 == 0) {\n            l_prime[i] = even_elements[even_index++];\n        } else {\n            l_prime[i] = l[i];\n        }\n    }\n\n    // Return the result\n    return l_prime;\n}\n\n"}
{"task_id": "CPP/38", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring encode_cyclic(string s) { \n    int l = s.length();\n    int num = (l + 2) / 3;\n    string output;\n    for (int i = 0; i < num; ++i) {\n        string x = s.substr(i * 3, 3);\n        if (x.length() == 3) {\n            x = x.substr(1) + x[0];\n        }\n        output += x;\n    }\n    return output;\n}\n\nstring decode_cyclic(string s) { \n    int l = s.length();\n    int num = (l + 2) / 3;\n    string output;\n    for (int i = 0; i < num; ++i) {\n        string x = s.substr(i * 3, 3);\n        if (x.length() == 3) {\n            x = x[2] + x.substr(0, 2);\n        }\n        output += x;\n    }\n    return output;\n}\n\n// Test cases\n"}
{"task_id": "CPP/39", "generation": "#include <iostream>\n#include <vector>\n\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    if (num == 2) return true;\n    if (num % 2 == 0) return false;\n    for (int i = 3; i * i <= num; i += 2) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\nint fibonacci(int n) {\n    if (n <= 0) return 0;\n    if (n == 1) return 1;\n    int a = 0, b = 1, c;\n    for (int i = 2; i <= n; ++i) {\n        c = a + b;\n        a = b;\n        b = c;\n    }\n    return b;\n}\n\nint prime_fib(int n) {\n    int count = 0;\n    int i = 1;\n    std::vector<int> fib_primes;\n    while (count < n) {\n        int fib_num = fibonacci(i);\n        if (is_prime(fib_num)) {\n            fib_primes.push_back(fib_num);\n            count++;\n        }\n        i++;\n    }\n    return fib_primes[n - 1];\n}\n\n"}
{"task_id": "CPP/40", "generation": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nbool triples_sum_to_zero(vector<int> l) {\n    // Input validation\n    if (l.size() < 3) {\n        return false;\n    }\n\n    // Sort the vector\n    sort(l.begin(), l.end());\n\n    // Find triplets\n    for (int i = 0; i < l.size() - 2; ++i) {\n        // Skip duplicate elements\n        if (i > 0 && l[i] == l[i - 1]) {\n            continue;\n        }\n\n        int left = i + 1;\n        int right = l.size() - 1;\n\n        while (left < right) {\n            int sum = l[i] + l[left] + l[right];\n\n            if (sum == 0) {\n                return true;\n            } else if (sum < 0) {\n                ++left;\n            } else {\n                --right;\n            }\n\n            // Skip duplicate elements\n            while (left < right && l[left] == l[left - 1]) {\n                ++left;\n            }\n            while (left < right && l[right] == l[right + 1]) {\n                --right;\n            }\n        }\n    }\n\n    // Return false if no triplet found\n    return false;\n}\n"}
{"task_id": "CPP/41", "generation": "#include <iostream>\n#include <stdexcept>\n\nint car_race_collision(int n) {\n    // Input validation\n    if (n < 0) {\n        // Handle invalid input (e.g., throw an exception)\n        throw std::invalid_argument(\"Number of cars must be non-negative\");\n    }\n\n    // Calculate the number of collisions\n    int collisions = n * n;\n\n    // Return the result\n    return collisions;\n}\n\n// Main function for testing\n"}
{"task_id": "CPP/42", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> incr_vector(vector<int> l) {\n    if (l.empty()) {\n        return {}; // Return an empty vector if the input is empty\n    }\n\n    vector<int> result;\n    for (int num : l) {\n        result.push_back(num + 1);\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/43", "generation": "#include <vector>\n#include <unordered_set>\nusing namespace std;\n\nbool pairs_sum_to_zero(vector<int> l) {\n    // Handle edge case: empty vector or single element vector\n    if (l.size() < 2) {\n        return false;\n    }\n\n    // Initialize a hash set to store elements\n    unordered_set<int> seen;\n\n    // Iterate through each element in the vector\n    for (int num : l) {\n        // Check if the negation of the current element exists in the set\n        if (seen.find(-num) != seen.end()) {\n            return true;\n        }\n        // Add the current element to the set\n        seen.insert(num);\n    }\n\n    // No pairs found that sum to zero\n    return false;\n}\n"}
{"task_id": "CPP/44", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nstring change_base(int x, int base) {\n    if (base < 2 || base > 9) {\n        return \"Invalid base\"; // or throw an exception\n    }\n    if (x < 0) {\n        return \"Invalid input\"; // or handle negative numbers if required\n    }\n    if (x == 0) {\n        return \"0\";\n    }\n\n    string result = \"\";\n    while (x > 0) {\n        int remainder = x % base;\n        result = to_string(remainder) + result;\n        x /= base;\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/45", "generation": "#include <stdio.h>\n\nfloat triangle_area(float a, float h) {\n    if (a < 0 || h < 0) {\n        // Handle invalid input\n        printf(\"Error: Base and height must be non-negative.\\n\");\n        return -1; // Indicate an error\n    }\n    float area = 0.5 * a * h;\n    return area;\n}\n\n"}
{"task_id": "CPP/46", "generation": "#include <iostream>\n\nint fib4(int n) {\n    // Base cases\n    if (n == 0) return 0;\n    if (n == 1) return 0;\n    if (n == 2) return 2;\n    if (n == 3) return 0;\n\n    // Initialize the first four values\n    int a = 0, b = 0, c = 2, d = 0;\n\n    // Iterative computation\n    for (int i = 4; i <= n; ++i) {\n        int temp = a + b + c + d;\n        a = b;\n        b = c;\n        c = d;\n        d = temp;\n    }\n\n    // Return the result\n    return d;\n}\n\n"}
{"task_id": "CPP/47", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <stdexcept>\n\nfloat median(std::vector<float> l) {\n    if (l.empty()) {\n        throw std::invalid_argument(\"Input vector cannot be empty.\");\n    }\n    std::sort(l.begin(), l.end());\n    int n = l.size();\n    if (n % 2 == 1) {\n        return l[n / 2];\n    } else {\n        return (l[n / 2 - 1] + l[n / 2]) / 2.0;\n    }\n}\n\n"}
{"task_id": "CPP/48", "generation": "#include <iostream>\n#include <string>\n\nbool is_palindrome(const std::string& text) {\n    // Step 1: Input Validation\n    if (text.empty()) {\n        return true;\n    }\n\n    // Step 2: String Length Calculation\n    int len = text.length();\n\n    // Step 3: Palindrome Check\n    for (int i = 0; i < len / 2; ++i) {\n        if (text[i] != text[len - i - 1]) {\n            return false;\n        }\n    }\n\n    // Step 4: Return Result\n    return true;\n}\n\n"}
{"task_id": "CPP/49", "generation": "#include <iostream>\n\n// Helper function for modular exponentiation\nint modExp(int base, int exp, int mod) {\n    int result = 1;\n    base = base % mod;\n    while (exp > 0) {\n        if (exp % 2 == 1) {\n            result = (result * base) % mod;\n        }\n        exp = exp >> 1;\n        base = (base * base) % mod;\n    }\n    return result;\n}\n\n// Main function to compute 2^n % p\nint modp(int n, int p) {\n    if (p <= 0) {\n        // Handle invalid input (e.g., throw an exception or return an error code)\n        return -1; // Example error handling\n    }\n    int result = modExp(2, n, p);\n    return result;\n}\n\n// Test cases\n"}
{"task_id": "CPP/50", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nchar shift_char(char c, int shift) {\n    if (c >= 'a' && c <= 'z') {\n        return ((c - 'a' + shift) % 26) + 'a';\n    } else if (c >= 'A' && c <= 'Z') {\n        return ((c - 'A' + shift) % 26) + 'A';\n    } else {\n        return c; // Non-alphabetic characters remain unchanged\n    }\n}\n\nchar reverse_shift_char(char c, int shift) {\n    if (c >= 'a' && c <= 'z') {\n        return ((c - 'a' - shift + 26) % 26) + 'a';\n    } else if (c >= 'A' && c <= 'Z') {\n        return ((c - 'A' - shift + 26) % 26) + 'A';\n    } else {\n        return c; // Non-alphabetic characters remain unchanged\n    }\n}\n\nstring encode_shift(string s) {\n    string out;\n    for (char c : s) {\n        out += shift_char(c, 5);\n    }\n    return out;\n}\n\nstring decode_shift(string s) {\n    string out;\n    for (char c : s) {\n        out += reverse_shift_char(c, 5);\n    }\n    return out;\n}\n\nvoid test_functions() {\n    string test_str = \"HelloWorld\";\n    string encoded = encode_shift(test_str);\n    string decoded = decode_shift(encoded);\n\n    cout << \"Original: \" << test_str << endl;\n    cout << \"Encoded: \" << encoded << endl;\n    cout << \"Decoded: \" << decoded << endl;\n\n    assert(decoded == test_str);\n}\n\n"}
{"task_id": "CPP/51", "generation": "#include <iostream>\n#include <string>\n#include <set>\nusing namespace std;\n\nstring remove_vowels(string text) {\n    const set<char> vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'};\n    string result;\n\n    for (char ch : text) {\n        if (vowels.find(ch) == vowels.end()) {\n            result += ch;\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/52", "generation": "#include <vector>\nusing namespace std;\n\nbool below_threshold(vector<int> l, int t) {\n    // Input validation\n    if (l.empty()) {\n        return true;\n    }\n\n    // Iterate through the vector\n    for (int num : l) {\n        // Check each element\n        if (num >= t) {\n            return false;\n        }\n    }\n\n    // Determine the result\n    return true;\n}\n"}
{"task_id": "CPP/53", "generation": "#include <iostream>\n\nint add(int x, int y) {\n    return x + y;\n}\n\n"}
{"task_id": "CPP/54", "generation": "#include <iostream>\n#include <string>\n#include <set>\n\nbool same_chars(const std::string& s0, const std::string& s1) {\n    std::set<char> unique_chars_s0(s0.begin(), s0.end());\n    std::set<char> unique_chars_s1(s1.begin(), s1.end());\n    return unique_chars_s0 == unique_chars_s1;\n}\n\n"}
{"task_id": "CPP/55", "generation": "/*\nReturn n-th Fibonacci number.\n>>> fib(10)\n55\n>>> fib(1)\n1\n>>> fib(8)\n21\n*/\n#include <stdio.h>\n\nint fib(int n) {\n    if (n == 0) {\n        return 0;\n    }\n    if (n == 1) {\n        return 1;\n    }\n    int a = 0, b = 1;\n    for (int i = 2; i <= n; ++i) {\n        int nextFib = a + b;\n        a = b;\n        b = nextFib;\n    }\n    return b;\n}\n\n"}
{"task_id": "CPP/56", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    int counter = 0;\n\n    for (char ch : brackets) {\n        if (ch == '<') {\n            counter++;\n        } else if (ch == '>') {\n            counter--;\n            if (counter < 0) {\n                return false; // Early exit if a closing bracket appears before a matching opening bracket\n            }\n        } else {\n            // Handle invalid characters if necessary\n            return false;\n        }\n    }\n\n    return counter == 0; // Return true if all brackets are properly nested\n}\n\n"}
{"task_id": "CPP/57", "generation": "#include <vector>\nusing namespace std;\n\nbool monotonic(vector<float> l) {\n    if (l.size() <= 1) {\n        return true; // A single element or empty vector is trivially monotonic\n    }\n\n    bool isIncreasing = true;\n    bool isDecreasing = true;\n\n    for (size_t i = 1; i < l.size(); ++i) {\n        if (l[i] < l[i - 1]) {\n            isIncreasing = false;\n        }\n        if (l[i] > l[i - 1]) {\n            isDecreasing = false;\n        }\n    }\n\n    return isIncreasing || isDecreasing;\n}\n"}
{"task_id": "CPP/58", "generation": "#include <iostream>\n#include <vector>\n#include <set>\n#include <algorithm>\nusing namespace std;\n\nvector<int> common(vector<int> l1, vector<int> l2) {\n    // Step 1: Initialize sets\n    set<int> set1;\n    set<int> resultSet;\n\n    // Step 2: Populate set1 with elements of l1\n    for (int num : l1) {\n        set1.insert(num);\n    }\n\n    // Step 3: Find common elements\n    for (int num : l2) {\n        if (set1.find(num) != set1.end()) {\n            resultSet.insert(num);\n        }\n    }\n\n    // Step 4: Convert resultSet to vector\n    vector<int> resultVector(resultSet.begin(), resultSet.end());\n\n    // Step 5: Sort the vector (already sorted due to set properties)\n    // No need to sort again as set stores elements in sorted order\n\n    // Step 6: Return the sorted vector\n    return resultVector;\n}\n\n"}
{"task_id": "CPP/59", "generation": "#include <iostream>\n#include <cmath>\n\n// Helper function to check if a number is prime\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    if (num == 2) return true;\n    if (num % 2 == 0) return false;\n    for (int i = 3; i <= sqrt(num); i += 2) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\n// Function to find the largest prime factor\nint largest_prime_factor(int n) {\n    int largest_prime = -1;\n\n    // Divide n by 2 to remove all even factors\n    while (n % 2 == 0) {\n        largest_prime = 2;\n        n /= 2;\n    }\n\n    // n must be odd at this point, so we can skip one element (Note i = i + 2)\n    for (int i = 3; i <= sqrt(n); i += 2) {\n        // While i divides n, print i and divide n\n        while (n % i == 0) {\n            largest_prime = i;\n            n /= i;\n        }\n    }\n\n    // This condition is to handle the case when n is a prime number greater than 2\n    if (n > 2) {\n        largest_prime = n;\n    }\n\n    return largest_prime;\n}\n\n// Main function to test the largest_prime_factor function\n"}
{"task_id": "CPP/60", "generation": "#include <stdio.h>\n#include <assert.h>\n\nint sum_to_n(int n) {\n    if (n < 0) {\n        return 0; // Handle negative input\n    }\n    return (n * (n + 1)) / 2;\n}\n\nvoid test_sum_to_n() {\n    assert(sum_to_n(30) == 465);\n    assert(sum_to_n(100) == 5050);\n    assert(sum_to_n(5) == 15);\n    assert(sum_to_n(10) == 55);\n    assert(sum_to_n(1) == 1);\n    assert(sum_to_n(-1) == 0); // Test negative input\n    printf(\"All test cases passed.\\n\");\n}\n\n"}
{"task_id": "CPP/61", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    int counter = 0;\n\n    // Iterate through each character in the string\n    for (char c : brackets) {\n        if (c == '(') {\n            counter++;\n        } else if (c == ')') {\n            counter--;\n            if (counter < 0) {\n                return false; // Unmatched closing bracket\n            }\n        } else {\n            // Handle invalid characters (optional, depending on requirements)\n            return false;\n        }\n    }\n\n    // Final check for unmatched opening brackets\n    return counter == 0;\n}\n\n"}
{"task_id": "CPP/62", "generation": "#include <vector>\n#include <stdexcept>\n\nstd::vector<float> derivative(const std::vector<float>& xs) {\n    // Input Validation\n    if (xs.empty()) {\n        throw std::invalid_argument(\"Input vector cannot be empty.\");\n    }\n\n    // Initialize the Output Vector\n    std::vector<float> result;\n\n    // Calculate the Derivative Coefficients\n    for (size_t i = 1; i < xs.size(); ++i) {\n        result.push_back(i * xs[i]);\n    }\n\n    // Return the Result\n    return result;\n}\n"}
{"task_id": "CPP/63", "generation": "#include <iostream>\n\nint fibfib(int n) {\n    if (n == 0 || n == 1) return 0;\n    if (n == 2) return 1;\n\n    int a = 0, b = 0, c = 1, d;\n    for (int i = 3; i <= n; ++i) {\n        d = a + b + c;\n        a = b;\n        b = c;\n        c = d;\n    }\n    return c;\n}\n\n"}
{"task_id": "CPP/64", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n\nint vowels_count(std::string s) {\n    // Convert the string to lowercase\n    std::transform(s.begin(), s.end(), s.begin(), ::tolower);\n\n    // Initialize a counter\n    int count = 0;\n\n    // Count vowels in the string\n    for (char c : s) {\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n            count++;\n        }\n    }\n\n    // Check for 'y' at the end\n    if (!s.empty() && s.back() == 'y') {\n        count++;\n    }\n\n    // Return the result\n    return count;\n}\n\n// Example usage\n"}
{"task_id": "CPP/65", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n\nstring circular_shift(int x, int shift) {\n    // Convert the integer to a string\n    string str_x = to_string(x);\n    \n    // Calculate the length of the string\n    int len = str_x.length();\n    \n    // Check if shift exceeds the number of digits\n    if (shift > len) {\n        // Reverse the string and return it\n        reverse(str_x.begin(), str_x.end());\n        return str_x;\n    }\n    \n    // Perform the circular shift\n    // Calculate the effective shift (in case shift is greater than len)\n    shift = shift % len;\n    string shifted_str = str_x.substr(len - shift) + str_x.substr(0, len - shift);\n    \n    // Return the result\n    return shifted_str;\n}\n\n"}
{"task_id": "CPP/66", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint digitSum(string s) {\n    int sum = 0;\n    for (char c : s) {\n        if (c >= 'A' && c <= 'Z') {\n            sum += static_cast<int>(c);\n        }\n    }\n    return sum;\n}\n\n// Test cases\n"}
{"task_id": "CPP/67", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\nusing namespace std;\n\nint extract_number(const string& str) {\n    istringstream iss(str);\n    int number;\n    iss >> number;\n    return number;\n}\n\nint fruit_distribution(string s, int n) {\n    // Find the position of \"apples\" and \"oranges\"\n    size_t pos_apples = s.find(\"apples\");\n    size_t pos_oranges = s.find(\"oranges\");\n\n    // Extract the number of apples and oranges\n    string apples_str = s.substr(0, pos_apples - 1);\n    string oranges_str = s.substr(pos_apples + 7, pos_oranges - pos_apples - 8);\n\n    int apples = extract_number(apples_str);\n    int oranges = extract_number(oranges_str);\n\n    // Calculate the number of mangoes\n    int mangoes = n - (apples + oranges);\n\n    return mangoes;\n}\n\n"}
{"task_id": "CPP/68", "generation": "#include <vector>\n#include <climits>\nusing namespace std;\n\nvector<int> pluck(vector<int> arr) {\n    int smallest_even_value = INT_MAX;\n    int smallest_index = -1;\n\n    // Iterate through the vector\n    for (int i = 0; i < arr.size(); ++i) {\n        // Check if the current element is even\n        if (arr[i] % 2 == 0) {\n            // Update the smallest even value and its index\n            if (arr[i] < smallest_even_value || (arr[i] == smallest_even_value && i < smallest_index)) {\n                smallest_even_value = arr[i];\n                smallest_index = i;\n            }\n        }\n    }\n\n    // Return the result\n    if (smallest_index != -1) {\n        return {smallest_even_value, smallest_index};\n    } else {\n        return {};\n    }\n}\n"}
{"task_id": "CPP/69", "generation": "#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint search(vector<int> lst) {\n    unordered_map<int, int> frequencyMap;\n\n    // Calculate frequencies\n    for (int num : lst) {\n        frequencyMap[num]++;\n    }\n\n    int result = -1;\n    // Filter and find the greatest integer\n    for (const auto& pair : frequencyMap) {\n        if (pair.first <= pair.second && pair.first > result) {\n            result = pair.first;\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/70", "generation": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> strange_sort_list(vector<int> lst) {\n    // Step 1: Check for empty vector\n    if (lst.empty()) {\n        return {};\n    }\n\n    // Step 2: Sort the input vector\n    sort(lst.begin(), lst.end());\n\n    // Step 3: Initialize pointers and result vector\n    int start = 0;\n    int end = lst.size() - 1;\n    vector<int> result;\n\n    // Step 4: Alternate between minimum and maximum\n    while (start <= end) {\n        result.push_back(lst[start]);\n        start++;\n        if (start <= end) {\n            result.push_back(lst[end]);\n            end--;\n        }\n    }\n\n    // Step 5: Return the result vector\n    return result;\n}\n"}
{"task_id": "CPP/71", "generation": "#include <stdio.h>\n#include <math.h>\n\nfloat triangle_area(float a, float b, float c) {\n    // Input validation\n    if (a + b <= c || a + c <= b || b + c <= a) {\n        return -1;\n    }\n\n    // Calculate the semi-perimeter\n    float s = (a + b + c) / 2;\n\n    // Calculate the area using Heron's formula\n    float area = sqrt(s * (s - a) * (s - b) * (s - c));\n\n    // Round the area to 2 decimal points\n    area = round(area * 100) / 100;\n\n    // Return the result\n    return area;\n}\n\n"}
{"task_id": "CPP/72", "generation": "#include <vector>\nusing namespace std;\n\nbool will_it_fly(vector<int> q, int w) {\n    // Check if the vector is palindromic\n    int start = 0;\n    int end = q.size() - 1;\n    while (start < end) {\n        if (q[start] != q[end]) {\n            return false; // Not palindromic\n        }\n        start++;\n        end--;\n    }\n\n    // Calculate the sum of the elements\n    int sum = 0;\n    for (int i = 0; i < q.size(); i++) {\n        sum += q[i];\n    }\n\n    // Compare the sum with the maximum possible weight\n    if (sum > w) {\n        return false; // Sum exceeds the maximum weight\n    }\n\n    // Return the final result\n    return true; // Palindromic and sum <= w\n}\n"}
{"task_id": "CPP/73", "generation": "#include <vector>\nusing namespace std;\n\nint smallest_change(vector<int> arr) {\n    int changes = 0;\n    int n = arr.size();\n\n    for (int i = 0; i < n / 2; ++i) {\n        if (arr[i] != arr[n - i - 1]) {\n            changes++;\n        }\n    }\n\n    return changes;\n}\n"}
{"task_id": "CPP/74", "generation": "#include <vector>\n#include <string>\nusing namespace std;\n\nint calculate_total_chars(const vector<string>& lst) {\n    int total = 0;\n    for (const auto& str : lst) {\n        total += str.length();\n    }\n    return total;\n}\n\nvector<string> total_match(vector<string> lst1, vector<string> lst2) {\n    int total_chars_lst1 = calculate_total_chars(lst1);\n    int total_chars_lst2 = calculate_total_chars(lst2);\n\n    if (total_chars_lst1 <= total_chars_lst2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n"}
{"task_id": "CPP/75", "generation": "#include <iostream>\n#include <vector>\n\n// Function to generate all prime numbers less than 100\nstd::vector<int> generate_primes() {\n    std::vector<bool> is_prime(100, true);\n    std::vector<int> primes;\n    is_prime[0] = is_prime[1] = false;\n\n    for (int i = 2; i < 100; ++i) {\n        if (is_prime[i]) {\n            primes.push_back(i);\n            for (int j = i * i; j < 100; j += i) {\n                is_prime[j] = false;\n            }\n        }\n    }\n    return primes;\n}\n\n// Function to check if a number is the product of exactly 3 prime numbers\nbool is_multiply_prime(int a) {\n    std::vector<int> primes = generate_primes();\n\n    for (size_t i = 0; i < primes.size(); ++i) {\n        for (size_t j = i; j < primes.size(); ++j) {\n            for (size_t k = j; k < primes.size(); ++k) {\n                if (primes[i] * primes[j] * primes[k] == a) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n\n"}
{"task_id": "CPP/76", "generation": "#include <iostream>\n#include <cmath>\n\nbool is_simple_power(int x, int n) {\n    // Input validation\n    if (n == 0) {\n        return x == 0; // Special case: 0^0 is considered true\n    }\n    if (n == 1) {\n        return x == 1; // 1^k = 1 only if k = 0\n    }\n\n    // Logarithmic calculation\n    double log_result = log(x) / log(n);\n    int rounded_log_result = round(log_result);\n\n    // Return the result\n    return abs(log_result - rounded_log_result) < 1e-9; // Check if log_result is an integer\n}\n\n"}
{"task_id": "CPP/77", "generation": "#include <stdio.h>\n#include <math.h>\nusing namespace std;\n\nbool iscube(int a) {\n    // Handle special case for zero\n    if (a == 0) {\n        return true;\n    }\n\n    // Convert negative numbers to positive\n    int abs_a = abs(a);\n\n    // Compute the cube root\n    double cube_root = cbrt(abs_a);\n\n    // Round the cube root to the nearest integer\n    int rounded_cube_root = round(cube_root);\n\n    // Check if the cube of the rounded cube root equals the original input\n    return (rounded_cube_root * rounded_cube_root * rounded_cube_root == abs_a);\n}\n"}
{"task_id": "CPP/78", "generation": "#include <iostream>\n#include <string>\n#include <set>\n\nint hex_key(const std::string& num) {\n    // Initialize the set of prime hexadecimal digits\n    const std::set<char> prime_hex_digits = {'2', '3', '5', '7', 'B', 'D'};\n\n    // Initialize a counter for prime digits\n    int prime_count = 0;\n\n    // Iterate through each character in the input string\n    for (char c : num) {\n        // Check if the character is a prime hexadecimal digit\n        if (prime_hex_digits.find(c) != prime_hex_digits.end()) {\n            // Increment the counter\n            ++prime_count;\n        }\n    }\n\n    // Return the count of prime digits\n    return prime_count;\n}\n\n"}
{"task_id": "CPP/79", "generation": "#include <iostream>\n#include <string>\n#include <stdexcept>\n\nstd::string decimal_to_binary(int decimal) {\n    // Input Validation\n    if (decimal < 0) {\n        throw std::invalid_argument(\"Input must be a non-negative integer.\");\n    }\n    if (decimal == 0) {\n        return \"db0db\";\n    }\n\n    // Decimal to Binary Conversion\n    std::string binary = \"\";\n    while (decimal > 0) {\n        binary = std::to_string(decimal % 2) + binary;\n        decimal /= 2;\n    }\n\n    // String Formatting\n    binary = \"db\" + binary + \"db\";\n\n    // Return the Result\n    return binary;\n}\n\n"}
{"task_id": "CPP/80", "generation": "#include <string>\nusing namespace std;\n\nbool is_happy(string s) {\n    // Step 1: Check the length of the string\n    if (s.size() < 3) {\n        return false;\n    }\n\n    // Step 2: Check consecutive characters\n    for (int i = 0; i <= s.size() - 3; i++) {\n        if (s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]) {\n            return false;\n        }\n    }\n\n    // Step 3: Return true if all checks pass\n    return true;\n}\n"}
{"task_id": "CPP/81", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stdexcept>\n\n// Function to map GPA to letter grade\nstd::string get_letter_grade(float gpa) {\n    if (gpa == 4.0) return \"A+\";\n    else if (gpa > 3.7) return \"A\";\n    else if (gpa > 3.3) return \"A-\";\n    else if (gpa > 3.0) return \"B+\";\n    else if (gpa > 2.7) return \"B\";\n    else if (gpa > 2.3) return \"B-\";\n    else if (gpa > 2.0) return \"C+\";\n    else if (gpa > 1.7) return \"C\";\n    else if (gpa > 1.3) return \"C-\";\n    else if (gpa > 1.0) return \"D+\";\n    else if (gpa > 0.7) return \"D\";\n    else if (gpa > 0.0) return \"D-\";\n    else return \"E\";\n}\n\n// Function to convert a vector of GPAs to a vector of letter grades\nstd::vector<std::string> numerical_letter_grade(std::vector<float> grades) {\n    // Input validation\n    if (grades.empty()) {\n        throw std::invalid_argument(\"Input vector is empty.\");\n    }\n    for (float gpa : grades) {\n        if (gpa < 0.0 || gpa > 4.0) {\n            throw std::invalid_argument(\"Invalid GPA value.\");\n        }\n    }\n\n    // Convert each GPA to a letter grade\n    std::vector<std::string> result;\n    for (float gpa : grades) {\n        result.push_back(get_letter_grade(gpa));\n    }\n\n    return result;\n}\n\n// Main function to demonstrate the usage\n"}
{"task_id": "CPP/82", "generation": "#include <iostream>\n#include <string>\n#include <cmath>\n\n// Helper function to check if a number is prime\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    for (int i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) return false;\n    }\n    return true;\n}\n\n// Main function to check if the string length is prime\nbool prime_length(std::string str) {\n    int length = str.size();\n    return is_prime(length);\n}\n\n// Example usage\n"}
{"task_id": "CPP/83", "generation": "#include <cmath>\n\nint starts_one_ends(int n) {\n    if (n == 1) {\n        return 1; // Only one number: 1\n    }\n\n    int count_start_with_1 = pow(10, n - 1);\n    int count_end_with_1 = 9 * pow(10, n - 2);\n    int count_start_and_end_with_1 = pow(10, n - 2);\n\n    int total_count = count_start_with_1 + count_end_with_1 - count_start_and_end_with_1;\n\n    return total_count;\n}\n"}
{"task_id": "CPP/84", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring solve(int N) {\n    int sum = 0;\n    \n    // Extract digits and compute sum\n    while (N > 0) {\n        sum += N % 10; // Add the last digit to the sum\n        N /= 10; // Remove the last digit\n    }\n    \n    // Convert sum to binary\n    string binarySum = \"\";\n    if (sum == 0) {\n        binarySum = \"0\";\n    } else {\n        while (sum > 0) {\n            binarySum = to_string(sum % 2) + binarySum; // Prepend the binary digit\n            sum /= 2; // Divide by 2 to get the next bit\n        }\n    }\n    \n    // Return the result\n    return binarySum;\n}\n\n"}
{"task_id": "CPP/85", "generation": "#include <vector>\nusing namespace std;\n\nint add(vector<int> lst) {\n    int sum = 0;\n    for (size_t i = 0; i < lst.size(); ++i) {\n        if (i % 2 != 0) {  // Check if the index is odd\n            if (lst[i] % 2 == 0) {  // Check if the element is even\n                sum += lst[i];\n            }\n        }\n    }\n    return sum;\n}\n"}
{"task_id": "CPP/86", "generation": "#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <string>\n\nusing namespace std;\n\nstring anti_shuffle(string s) {\n    // Step 1: Split the input string into words\n    stringstream ss(s);\n    string word;\n    vector<string> words;\n    while (ss >> word) {\n        words.push_back(word);\n    }\n\n    // Step 2: Sort characters in each word\n    for (auto &w : words) {\n        sort(w.begin(), w.end());\n    }\n\n    // Step 3: Reconstruct the sentence\n    string result;\n    int index = 0;\n    for (char c : s) {\n        if (c == ' ') {\n            result += c;\n        } else {\n            result += words[index][0];\n            words[index].erase(words[index].begin());\n            if (words[index].empty()) {\n                index++;\n            }\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/87", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<vector<int>> get_row(vector<vector<int>> lst, int x) {\n    vector<vector<int>> coordinates;\n\n    // Traverse the 2D data structure\n    for (int i = 0; i < lst.size(); ++i) {\n        for (int j = 0; j < lst[i].size(); ++j) {\n            if (lst[i][j] == x) {\n                coordinates.push_back({i, j});\n            }\n        }\n    }\n\n    // Custom comparator for sorting\n    auto compare = [](const vector<int>& a, const vector<int>& b) {\n        if (a[0] == b[0]) {\n            return a[1] > b[1]; // Sort by column in descending order\n        }\n        return a[0] < b[0]; // Sort by row in ascending order\n    };\n\n    // Sort the coordinates\n    sort(coordinates.begin(), coordinates.end(), compare);\n\n    return coordinates;\n}\n\n// Example usage\n"}
{"task_id": "CPP/88", "generation": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> sort_array(vector<int> array) {\n    // Step 1: Input Validation\n    if (array.empty()) {\n        return {};\n    }\n\n    // Step 2: Determine Sorting Order\n    int sum = array.front() + array.back();\n    bool is_odd = (sum % 2 != 0);\n\n    // Step 3: Create a Copy of the Vector\n    vector<int> sorted_array = array;\n\n    // Step 4: Sort the Vector\n    if (is_odd) {\n        sort(sorted_array.begin(), sorted_array.end());\n    } else {\n        sort(sorted_array.begin(), sorted_array.end(), greater<int>());\n    }\n\n    // Step 5: Return the Result\n    return sorted_array;\n}\n"}
{"task_id": "CPP/89", "generation": "#include <iostream>\n#include <string>\n#include <cctype>\nusing namespace std;\n\nchar rotate_char(char c) {\n    if (isalpha(c)) {\n        char base = islower(c) ? 'a' : 'A';\n        return (c - base + 4) % 26 + base;\n    }\n    return c;\n}\n\nstring process_string(const string& input) {\n    string result;\n    for (char c : input) {\n        result += rotate_char(c);\n    }\n    return result;\n}\n\nstring encrypt(const string& s) {\n    return process_string(s);\n}\n\nvoid test_encrypt() {\n    assert(encrypt(\"hi\") == \"lm\");\n    assert(encrypt(\"asdfghjkl\") == \"ewhjklnop\");\n    assert(encrypt(\"gf\") == \"kj\");\n    assert(encrypt(\"et\") == \"ix\");\n    assert(encrypt(\"\") == \"\");\n    assert(encrypt(\"123\") == \"123\");\n    assert(encrypt(\"Hello, World!\") == \"Lipps, Asvph!\");\n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/90", "generation": "#include <iostream>\n#include <vector>\n#include <set>\n\nint* next_smallest(const std::vector<int>& lst) {\n    // Check if the vector is empty\n    if (lst.empty()) {\n        return nullptr;\n    }\n\n    // Remove duplicates using a set\n    std::set<int> unique_elements(lst.begin(), lst.end());\n\n    // Check if there are fewer than two unique elements\n    if (unique_elements.size() < 2) {\n        return nullptr;\n    }\n\n    // Find the second smallest element\n    auto it = unique_elements.begin();\n    ++it; // Move to the second element\n    static int result = *it;\n    return &result;\n}\n\n// Test cases\n"}
{"task_id": "CPP/91", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <cctype>\n\nusing namespace std;\n\nint is_bored(const string& S) {\n    // Step 1: Parse the input string into sentences\n    istringstream iss(S);\n    string token;\n    string delimiter = \".!?\";\n    vector<string> sentences;\n    while (getline(iss, token, ' ')) {\n        size_t pos = 0;\n        while ((pos = token.find_first_of(delimiter)) != string::npos) {\n            sentences.push_back(token.substr(0, pos + 1));\n            token.erase(0, pos + 1);\n        }\n        if (!token.empty()) {\n            sentences.push_back(token);\n        }\n    }\n\n    // Step 2: Identify and count boredom sentences\n    int boredom_count = 0;\n    for (const auto& sentence : sentences) {\n        // Trim leading spaces\n        size_t start = sentence.find_first_not_of(\" \");\n        if (start == string::npos) continue; // Skip empty sentences\n        string trimmed_sentence = sentence.substr(start);\n\n        // Check if the sentence starts with \"I\"\n        if (trimmed_sentence.size() >= 2 && trimmed_sentence[0] == 'I' && (trimmed_sentence[1] == ' ' || trimmed_sentence[1] == '.' || trimmed_sentence[1] == '?' || trimmed_sentence[1] == '!')) {\n            ++boredom_count;\n        }\n    }\n\n    // Step 3: Return the result\n    return boredom_count;\n}\n\n"}
{"task_id": "CPP/92", "generation": "#include <stdio.h>\n#include <math.h>\n\nusing namespace std;\n\nbool any_int(float a, float b, float c) {\n    // Check if all numbers are integers\n    if (fmod(a, 1.0) != 0.0 || fmod(b, 1.0) != 0.0 || fmod(c, 1.0) != 0.0) {\n        return false;\n    }\n\n    // Check if one number is the sum of the other two\n    if (a == b + c || b == a + c || c == a + b) {\n        return true;\n    } else {\n        return false;\n    }\n}\n\n"}
{"task_id": "CPP/93", "generation": "#include <iostream>\n#include <string>\n#include <cctype>\n#include <algorithm>\n\nusing namespace std;\n\nstring encode(string message) {\n    string encoded_message = \"\";\n    for (char c : message) {\n        if (isalpha(c)) {\n            // Swap case\n            c = islower(c) ? toupper(c) : tolower(c);\n        }\n        // Vowel replacement\n        switch (c) {\n            case 'A': c = 'C'; break;\n            case 'E': c = 'G'; break;\n            case 'I': c = 'K'; break;\n            case 'O': c = 'Q'; break;\n            case 'U': c = 'W'; break;\n            case 'a': c = 'c'; break;\n            case 'e': c = 'g'; break;\n            case 'i': c = 'k'; break;\n            case 'o': c = 'q'; break;\n            case 'u': c = 'w'; break;\n        }\n        encoded_message += c;\n    }\n    return encoded_message;\n}\n\n"}
{"task_id": "CPP/94", "generation": "#include <vector>\n#include <cmath>\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    for (int i = 2; i * i <= num; ++i) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\n// Function to find the largest prime number in the list\nint find_largest_prime(const vector<int>& lst) {\n    int largest_prime = -1;\n    for (int num : lst) {\n        if (is_prime(num) && num > largest_prime) {\n            largest_prime = num;\n        }\n    }\n    return largest_prime;\n}\n\n// Function to sum the digits of a number\nint sum_of_digits(int num) {\n    int sum = 0;\n    while (num > 0) {\n        sum += num % 10;\n        num /= 10;\n    }\n    return sum;\n}\n\n// Main function to find the largest prime and return the sum of its digits\nint skjkasdkd(vector<int> lst) {\n    int largest_prime = find_largest_prime(lst);\n    if (largest_prime == -1) return 0; // No prime number found\n    return sum_of_digits(largest_prime);\n}\n"}
{"task_id": "CPP/95", "generation": "#include <iostream>\n#include <string>\n#include <map>\nusing namespace std;\n\nbool check_dict_case(map<string, string> dict) {\n    // Step 1: Check if the map is empty\n    if (dict.empty()) {\n        return false;\n    }\n\n    // Step 2: Initialize variables\n    bool isLowercase = true;\n    bool isUppercase = true;\n\n    // Step 3: Iterate through the map\n    for (const auto& pair : dict) {\n        const string& key = pair.first;\n\n        // Check if the current key is consistent with the case of the first key\n        for (char c : key) {\n            if (!islower(c)) {\n                isLowercase = false;\n            }\n            if (!isupper(c)) {\n                isUppercase = false;\n            }\n        }\n\n        // If both isLowercase and isUppercase are false, return false\n        if (!isLowercase && !isUppercase) {\n            return false;\n        }\n    }\n\n    // Step 4: Return true if all keys are consistent\n    return true;\n}\n\n"}
{"task_id": "CPP/96", "generation": "#include <vector>\n#include <cmath>\nusing namespace std;\n\nvector<int> count_up_to(int n) {\n    if (n < 2) {\n        return {};\n    }\n\n    vector<bool> is_prime(n, true);\n    is_prime[0] = is_prime[1] = false;\n\n    for (int i = 2; i * i < n; ++i) {\n        if (is_prime[i]) {\n            for (int j = i * i; j < n; j += i) {\n                is_prime[j] = false;\n            }\n        }\n    }\n\n    vector<int> primes;\n    for (int i = 2; i < n; ++i) {\n        if (is_prime[i]) {\n            primes.push_back(i);\n        }\n    }\n\n    return primes;\n}\n"}
{"task_id": "CPP/97", "generation": "#include <iostream>\n#include <cmath>\n\nint multiply(int a, int b) {\n    int unitDigitA = abs(a) % 10;\n    int unitDigitB = abs(b) % 10;\n    int product = unitDigitA * unitDigitB;\n    return product;\n}\n\n"}
{"task_id": "CPP/98", "generation": "#include <iostream>\n#include <string>\n#include <set>\n\nusing namespace std;\n\nint count_upper(const string& s) {\n    int counter = 0;\n    set<char> uppercase_vowels = {'A', 'E', 'I', 'O', 'U'};\n    \n    for (size_t i = 0; i < s.length(); i += 2) {\n        if (uppercase_vowels.find(s[i]) != uppercase_vowels.end()) {\n            counter++;\n        }\n    }\n    \n    return counter;\n}\n\n"}
{"task_id": "CPP/99", "generation": "#include <iostream>\n#include <string>\n#include <cmath>\n#include <stdexcept>\n\nint closest_integer(const std::string& value) {\n    try {\n        // Step 1: Parse the input string to a double\n        double num = std::stod(value);\n\n        // Step 2: Calculate the floor and ceiling values\n        double floor_value = std::floor(num);\n        double ceil_value = std::ceil(num);\n\n        // Step 3: Determine the closest integer\n        double fractional_part = num - floor_value;\n\n        if (fractional_part == 0.5) {\n            // Rounding away from zero\n            if (num > 0) {\n                return static_cast<int>(ceil_value);\n            } else {\n                return static_cast<int>(floor_value);\n            }\n        } else {\n            // Standard rounding\n            return static_cast<int>(std::round(num));\n        }\n\n    } catch (const std::invalid_argument& e) {\n        // Handle invalid input\n        throw std::invalid_argument(\"Invalid input: \" + value);\n    }\n}\n\n// Test cases\n"}
{"task_id": "CPP/100", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> make_a_pile(int n) {\n    vector<int> stones;\n    int current_stones = n;\n    stones.push_back(current_stones);\n\n    for (int i = 1; i < n; ++i) {\n        current_stones += 2;\n        stones.push_back(current_stones);\n    }\n\n    return stones;\n}\n"}
{"task_id": "CPP/101", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> words_string(const string& s) {\n    vector<string> result;\n    string temp = \"\";\n\n    // Iterate through the string\n    for (char ch : s) {\n        // Check for delimiters\n        if (ch == ',' || ch == ' ') {\n            if (!temp.empty()) {\n                result.push_back(temp);\n                temp = \"\"; // Reset the temporary string\n            }\n        } else {\n            temp += ch; // Accumulate characters\n        }\n    }\n\n    // Add the last word if there is any\n    if (!temp.empty()) {\n        result.push_back(temp);\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/102", "generation": "#include <iostream>\nusing namespace std;\n\nint choose_num(int x, int y) {\n    // Input validation\n    if (x <= 0 || y <= 0) {\n        return -1;\n    }\n\n    // Determine the range\n    if (x > y) {\n        int temp = x;\n        x = y;\n        y = temp;\n    }\n\n    // Find the largest even number\n    for (int i = y; i >= x; i--) {\n        if (i % 2 == 0) {\n            return i;\n        }\n    }\n\n    // Return -1 if no even number is found\n    return -1;\n}\n\n"}
{"task_id": "CPP/103", "generation": "#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n\nstd::string rounded_avg(int n, int m) {\n    // Step 1: Input Validation\n    if (n > m) {\n        return \"-1\";\n    }\n\n    // Step 2: Sum Calculation\n    int sum = (m * (m + 1) / 2) - ((n - 1) * n / 2);\n\n    // Step 3: Count Calculation\n    int count = m - n + 1;\n\n    // Step 4: Average Calculation\n    double average = static_cast<double>(sum) / count;\n\n    // Step 5: Rounding\n    int rounded_average = static_cast<int>(floor(average + 0.5));\n\n    // Step 6: Binary Conversion\n    std::string binary_representation = std::bitset<32>(rounded_average).to_string();\n    // Remove leading zeros\n    size_t first_one = binary_representation.find('1');\n    if (first_one != std::string::npos) {\n        binary_representation = binary_representation.substr(first_one);\n    }\n\n    return binary_representation;\n}\n"}
{"task_id": "CPP/104", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// Helper function to check if a number has any even digit\nbool has_even_digit(int num) {\n    while (num > 0) {\n        int digit = num % 10;\n        if (digit % 2 == 0) {\n            return true;\n        }\n        num /= 10;\n    }\n    return false;\n}\n\nvector<int> unique_digits(vector<int> x) {\n    vector<int> result;\n    \n    // Filter elements without even digits\n    for (int num : x) {\n        if (!has_even_digit(num)) {\n            result.push_back(num);\n        }\n    }\n    \n    // Sort the filtered vector\n    sort(result.begin(), result.end());\n    \n    return result;\n}\n\n// Test cases\n"}
{"task_id": "CPP/105", "generation": "#include <vector>\n#include <string>\n#include <algorithm>\n#include <map>\nusing namespace std;\n\nvector<string> by_length(vector<int> arr) {\n    // Step 1: Initialize the mapping\n    map<int, string> num_to_name = {\n        {1, \"One\"}, {2, \"Two\"}, {3, \"Three\"}, {4, \"Four\"},\n        {5, \"Five\"}, {6, \"Six\"}, {7, \"Seven\"}, {8, \"Eight\"}, {9, \"Nine\"}\n    };\n\n    // Step 2: Filter the input vector\n    vector<int> filtered_arr;\n    for (int num : arr) {\n        if (num >= 1 && num <= 9) {\n            filtered_arr.push_back(num);\n        }\n    }\n\n    // Step 3: Sort the filtered vector\n    sort(filtered_arr.begin(), filtered_arr.end());\n\n    // Step 4: Reverse the sorted vector\n    reverse(filtered_arr.begin(), filtered_arr.end());\n\n    // Step 5: Map integers to names\n    vector<string> result;\n    for (int num : filtered_arr) {\n        result.push_back(num_to_name[num]);\n    }\n\n    // Step 6: Return the result\n    return result;\n}\n"}
{"task_id": "CPP/106", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// Helper function to calculate the factorial of a number\nint factorial(int i) {\n    int result = 1;\n    for (int j = 1; j <= i; ++j) {\n        result *= j;\n    }\n    return result;\n}\n\n// Helper function to calculate the sum of numbers from 1 to i\nint sum_to_i(int i) {\n    return (i * (i + 1)) / 2;\n}\n\n// Main function to implement the requirement\nvector<int> f(int n) {\n    vector<int> result(n);\n    for (int i = 1; i <= n; ++i) {\n        if (i % 2 == 0) {\n            result[i - 1] = factorial(i);\n        } else {\n            result[i - 1] = sum_to_i(i);\n        }\n    }\n    return result;\n}\n\n// Example usage\n"}
{"task_id": "CPP/107", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool isPalindrome(int num) {\n    int originalNum = num;\n    int reversedNum = 0;\n    while (num > 0) {\n        int digit = num % 10;\n        reversedNum = reversedNum * 10 + digit;\n        num /= 10;\n    }\n    return originalNum == reversedNum;\n}\n\nvector<int> even_odd_palindrome(int n) {\n    int evenCount = 0;\n    int oddCount = 0;\n\n    for (int i = 1; i <= n; ++i) {\n        if (isPalindrome(i)) {\n            if (i % 2 == 0) {\n                evenCount++;\n            } else {\n                oddCount++;\n            }\n        }\n    }\n\n    return {evenCount, oddCount};\n}\n\n"}
{"task_id": "CPP/108", "generation": "#include <vector>\nusing namespace std;\n\nint count_nums(vector<int> n) {\n    int count = 0; // Initialize the counter\n\n    for (int num : n) {\n        int sum = 0; // Initialize the sum of digits for the current number\n        bool isNegative = num < 0; // Check if the number is negative\n        num = abs(num); // Convert the number to positive for easier extraction\n\n        while (num > 0) {\n            int digit = num % 10; // Extract the last digit\n            if (isNegative && num / 10 == 0) { // If it's the first digit of a negative number\n                digit *= -1; // Make the first digit negative\n            }\n            sum += digit; // Add the digit to the sum\n            num /= 10; // Remove the last digit\n        }\n\n        if (sum > 0) {\n            count++; // Increment the counter if the sum is greater than 0\n        }\n    }\n\n    return count; // Return the final count\n}\n"}
{"task_id": "CPP/109", "generation": "#include <vector>\nusing namespace std;\n\nbool move_one_ball(vector<int> arr) {\n    if (arr.empty()) {\n        return true;\n    }\n\n    int N = arr.size();\n    int breakpoint_count = 0;\n    int breakpoint_index = -1;\n\n    for (int i = 0; i < N; ++i) {\n        if (arr[i] > arr[(i + 1) % N]) {\n            breakpoint_count++;\n            breakpoint_index = i;\n        }\n    }\n\n    if (breakpoint_count > 1) {\n        return false;\n    }\n\n    if (breakpoint_count == 0) {\n        return true;  // The array is already sorted\n    }\n\n    // Verify the sorted sequence\n    for (int i = 0; i < N - 1; ++i) {\n        if (arr[(breakpoint_index + i + 1) % N] < arr[(breakpoint_index + i) % N]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n"}
{"task_id": "CPP/110", "generation": "#include <vector>\n#include <string>\nusing namespace std;\n\nstring exchange(vector<int> lst1, vector<int> lst2) {\n    int oddCount = 0;\n    int evenCount = 0;\n\n    // Count odd elements in lst1\n    for (int num : lst1) {\n        if (num % 2 != 0) {\n            oddCount++;\n        }\n    }\n\n    // Count even elements in lst2\n    for (int num : lst2) {\n        if (num % 2 == 0) {\n            evenCount++;\n        }\n    }\n\n    // Check feasibility of exchange\n    if (oddCount <= evenCount) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n"}
{"task_id": "CPP/111", "generation": "#include <iostream>\n#include <string>\n#include <map>\nusing namespace std;\n\nmap<char, int> histogram(string test) {\n    map<char, int> char_count;\n    map<char, int> result;\n\n    // Parse the input string and count characters\n    for (char c : test) {\n        if (c != ' ') {\n            char_count[c]++;\n        }\n    }\n\n    // Determine the maximum frequency\n    int max_count = 0;\n    for (const auto& pair : char_count) {\n        if (pair.second > max_count) {\n            max_count = pair.second;\n        }\n    }\n\n    // Filter characters with the maximum frequency\n    for (const auto& pair : char_count) {\n        if (pair.second == max_count) {\n            result[pair.first] = pair.second;\n        }\n    }\n\n    return result;\n}\n\n// Example usage\n"}
{"task_id": "CPP/112", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <set>\n#include <algorithm>\nusing namespace std;\n\nvector<string> reverse_delete(string s, string c) {\n    // Initialize a set to store characters from c\n    set<char> charsToDelete;\n    for (char ch : c) {\n        charsToDelete.insert(ch);\n    }\n\n    // Initialize a string to store the result after deleting characters\n    string result;\n    for (char ch : s) {\n        if (charsToDelete.find(ch) == charsToDelete.end()) {\n            result += ch;\n        }\n    }\n\n    // Check if the result string is a palindrome\n    bool isPalindrome = true;\n    int left = 0, right = result.length() - 1;\n    while (left < right) {\n        if (result[left] != result[right]) {\n            isPalindrome = false;\n            break;\n        }\n        left++;\n        right--;\n    }\n\n    // Construct and return the result vector\n    vector<string> resultVector;\n    resultVector.push_back(result);\n    resultVector.push_back(isPalindrome ? \"True\" : \"False\");\n    return resultVector;\n}\n\n"}
{"task_id": "CPP/113", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> odd_count(vector<string> lst) {\n    vector<string> result;\n\n    for (const string& s : lst) {\n        int oddCount = 0;\n        for (char c : s) {\n            int digit = c - '0';\n            if (digit % 2 != 0) {\n                oddCount++;\n            }\n        }\n\n        string output = \"the number of odd elements \" + to_string(oddCount) +\n                        \"n the str\" + to_string(oddCount) + \"ng \" + to_string(oddCount) + \" of the \" + to_string(oddCount) + \"nput.\";\n        result.push_back(output);\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/114", "generation": "#include <vector>\n#include <climits>\nusing namespace std;\n\nlong long minSubArraySum(vector<long long> nums) {\n    long long min_sum = LLONG_MAX;\n    long long current_sum = 0;\n\n    for (long long num : nums) {\n        current_sum += num;\n        if (current_sum < min_sum) {\n            min_sum = current_sum;\n        }\n        if (current_sum > 0) {\n            current_sum = 0;\n        }\n    }\n\n    return min_sum;\n}\n"}
{"task_id": "CPP/115", "generation": "#include <vector>\n#include <iostream>\n\nint max_fill(std::vector<std::vector<int>> grid, int bucket_capacity) {\n    int total_lowerings = 0;\n\n    for (const auto& row : grid) {\n        int water_units = 0;\n        for (int cell : row) {\n            if (cell == 1) {\n                water_units++;\n            }\n        }\n\n        int lowerings_for_well = (water_units + bucket_capacity - 1) / bucket_capacity;\n        total_lowerings += lowerings_for_well;\n    }\n\n    return total_lowerings;\n}\n\n"}
{"task_id": "CPP/116", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <bitset>\n\n// Function to count the number of ones in the binary representation of an integer\nint count_ones(int num) {\n    return __builtin_popcount(abs(num));\n}\n\n// Custom comparator function\nbool custom_comparator(int a, int b) {\n    int ones_a = count_ones(a);\n    int ones_b = count_ones(b);\n    if (ones_a == ones_b) {\n        return a < b;\n    }\n    return ones_a < ones_b;\n}\n\n// Function to sort the array based on the number of ones in binary representation\nstd::vector<int> sort_array(std::vector<int> arr) {\n    std::sort(arr.begin(), arr.end(), custom_comparator);\n    return arr;\n}\n\n// Main function to test the implementation\n"}
{"task_id": "CPP/117", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\nusing namespace std;\n\n// Function to check if a character is a consonant\nbool is_consonant(char c) {\n    c = tolower(c);\n    return !(c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') && isalpha(c);\n}\n\n// Function to count consonants in a word\nint count_consonants(const string& word) {\n    int count = 0;\n    for (char c : word) {\n        if (is_consonant(c)) {\n            count++;\n        }\n    }\n    return count;\n}\n\n// Main function to select words with exactly n consonants\nvector<string> select_words(const string& s, int n) {\n    vector<string> result;\n    stringstream ss(s);\n    string word;\n    \n    // Split the string into words\n    while (ss >> word) {\n        // Count consonants in the word\n        if (count_consonants(word) == n) {\n            result.push_back(word);\n        }\n    }\n    \n    return result;\n}\n\n// Example usage\n"}
{"task_id": "CPP/118", "generation": "#include <iostream>\n#include <string>\n#include <set>\n\nusing namespace std;\n\nstring get_closest_vowel(string word) {\n    // Define the set of vowels\n    set<char> vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'};\n    \n    // Initialize the result as an empty string\n    string result = \"\";\n    \n    // Traverse the word from right to left, skipping the first and last characters\n    for (int i = word.length() - 2; i > 0; --i) {\n        char current_char = word[i];\n        \n        // Check if the current character is a vowel\n        if (vowels.find(current_char) != vowels.end()) {\n            // Check if the characters immediately before and after are consonants\n            if (vowels.find(word[i - 1]) == vowels.end() && vowels.find(word[i + 1]) == vowels.end()) {\n                result = current_char;\n                break; // Found the closest vowel, no need to continue\n            }\n        }\n    }\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/119", "generation": "#include <vector>\n#include <string>\nusing namespace std;\n\nbool is_balanced(const string& s) {\n    int balance = 0;\n    for (char c : s) {\n        if (c == '(') {\n            balance++;\n        } else if (c == ')') {\n            balance--;\n            if (balance < 0) {\n                return false; // Early exit if imbalance is detected\n            }\n        }\n    }\n    return balance == 0;\n}\n\nstring match_parens(vector<string> lst) {\n    // Input validation\n    if (lst.size() != 2) {\n        throw invalid_argument(\"Input must be a vector of exactly two strings.\");\n    }\n    for (const auto& str : lst) {\n        for (char c : str) {\n            if (c != '(' && c != ')') {\n                throw invalid_argument(\"Strings must contain only '(' and ')' characters.\");\n            }\n        }\n    }\n\n    // Check concatenation possibilities\n    string first_concat = lst[0] + lst[1];\n    string second_concat = lst[1] + lst[0];\n\n    if (is_balanced(first_concat) || is_balanced(second_concat)) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\n"}
{"task_id": "CPP/120", "generation": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> maximum(vector<int> arr, int k) {\n    // Step 1: Input Validation\n    if (arr.empty()) {\n        throw invalid_argument(\"Error: Input vector cannot be empty.\");\n    }\n    if (k < 0 || k > arr.size()) {\n        throw invalid_argument(\"Error: Invalid value of k.\");\n    }\n\n    // Step 2: Sorting and Selection\n    sort(arr.begin(), arr.end(), greater<int>());\n    vector<int> top_k(arr.begin(), arr.begin() + k);\n\n    // Step 3: Output Preparation\n    sort(top_k.begin(), top_k.end());\n\n    return top_k;\n}\n"}
{"task_id": "CPP/121", "generation": "#include <vector>\nusing namespace std;\n\nint solution(vector<int> lst) {\n    int sum = 0;\n\n    for (size_t i = 0; i < lst.size(); i += 2) {\n        if (lst[i] % 2 != 0) {\n            sum += lst[i];\n        }\n    }\n\n    return sum;\n}\n"}
{"task_id": "CPP/122", "generation": "#include <iostream>\n#include <vector>\n\nint add_elements(std::vector<int> arr, int k) {\n    int sum = 0;\n    std::vector<int> sub_vector(arr.begin(), arr.begin() + k);\n\n    for (int element : sub_vector) {\n        if (element >= -99 && element <= 99) {\n            sum += element;\n        }\n    }\n\n    return sum;\n}\n\n"}
{"task_id": "CPP/123", "generation": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> get_odd_collatz(int n) {\n    vector<int> collatz_sequence;\n    vector<int> odd_numbers;\n\n    // Generate the Collatz sequence\n    while (n != 1) {\n        collatz_sequence.push_back(n);\n        if (n % 2 == 0) {\n            n = n / 2;\n        } else {\n            n = 3 * n + 1;\n        }\n    }\n    collatz_sequence.push_back(1); // Add 1 to the sequence\n\n    // Filter odd numbers\n    for (int num : collatz_sequence) {\n        if (num % 2 != 0) {\n            odd_numbers.push_back(num);\n        }\n    }\n\n    // Sort the odd numbers\n    sort(odd_numbers.begin(), odd_numbers.end());\n\n    // Return the sorted vector of odd numbers\n    return odd_numbers;\n}\n"}
{"task_id": "CPP/124", "generation": "#include <iostream>\n#include <string>\n#include <regex>\nusing namespace std;\n\nbool valid_date(string date) {\n    // Step 1: Check if the date string is empty\n    if (date.empty()) {\n        return false;\n    }\n\n    // Step 2: Check the date string format\n    regex date_format(R\"(^(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])-\\d{4}$)\");\n    if (!regex_match(date, date_format)) {\n        return false;\n    }\n\n    // Step 3: Parse the date string\n    int month, day, year;\n    sscanf(date.c_str(), \"%d-%d-%d\", &month, &day, &year);\n\n    // Step 4: Validate the month\n    if (month < 1 || month > 12) {\n        return false;\n    }\n\n    // Step 5: Validate the day based on the month\n    switch (month) {\n        case 1: case 3: case 5: case 7: case 8: case 10: case 12:\n            if (day < 1 || day > 31) {\n                return false;\n            }\n            break;\n        case 4: case 6: case 9: case 11:\n            if (day < 1 || day > 30) {\n                return false;\n            }\n            break;\n        case 2:\n            if (day < 1 || day > 29) {\n                return false;\n            }\n            break;\n    }\n\n    // Step 6: Return true if all checks pass\n    return true;\n}\n\n"}
{"task_id": "CPP/125", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\nusing namespace std;\n\nbool contains_whitespace(const string& txt) {\n    return txt.find(' ') != string::npos;\n}\n\nvector<string> split_on_whitespace(const string& txt) {\n    vector<string> result;\n    stringstream ss(txt);\n    string word;\n    while (ss >> word) {\n        result.push_back(word);\n    }\n    return result;\n}\n\nbool contains_commas(const string& txt) {\n    return txt.find(',') != string::npos;\n}\n\nvector<string> split_on_commas(const string& txt) {\n    vector<string> result;\n    stringstream ss(txt);\n    string segment;\n    while (getline(ss, segment, ',')) {\n        result.push_back(segment);\n    }\n    return result;\n}\n\nint count_odd_order_lowercase(const string& txt) {\n    int count = 0;\n    for (char c : txt) {\n        if (islower(c) && ((c - 'a') % 2 == 1)) {\n            count++;\n        }\n    }\n    return count;\n}\n\nvector<string> split_words(const string& txt) {\n    if (contains_whitespace(txt)) {\n        return split_on_whitespace(txt);\n    } else if (contains_commas(txt)) {\n        return split_on_commas(txt);\n    } else {\n        int count = count_odd_order_lowercase(txt);\n        return {to_string(count)};\n    }\n}\n\n// Example usage\n"}
{"task_id": "CPP/126", "generation": "#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nbool is_sorted(vector<int> lst) {\n    bool is_ascending = true;\n    unordered_map<int, int> count_map;\n\n    // Check if the vector is sorted in ascending order\n    for (int i = 0; i < lst.size() - 1; ++i) {\n        if (lst[i] > lst[i + 1]) {\n            is_ascending = false;\n            break;\n        }\n    }\n\n    // Count occurrences of each number\n    for (int num : lst) {\n        count_map[num]++;\n        if (count_map[num] > 2) {\n            return false;\n        }\n    }\n\n    // Final check\n    return is_ascending;\n}\n"}
{"task_id": "CPP/127", "generation": "#include <vector>\n#include <string>\n#include <algorithm>\n\n// Function to check if a number is prime\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    for (int i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) return false;\n    }\n    return true;\n}\n\n// Function to determine if the length of the intersection is a prime number\nstd::string intersection(std::vector<int> interval1, std::vector<int> interval2) {\n    int start1 = interval1[0], end1 = interval1[1];\n    int start2 = interval2[0], end2 = interval2[1];\n\n    int max_start = std::max(start1, start2);\n    int min_end = std::min(end1, end2);\n\n    if (max_start > min_end) {\n        return \"NO\"; // Intervals do not intersect\n    }\n\n    int length = min_end - max_start + 1;\n\n    if (is_prime(length)) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n"}
{"task_id": "CPP/128", "generation": "#include <vector>\n#include <cmath>\nusing namespace std;\n\nint prod_signs(vector<int> arr) {\n    // Step 1: Input Validation\n    if (arr.empty()) {\n        return -32768;\n    }\n\n    // Step 2: Sum of Magnitudes\n    int sum_magnitudes = 0;\n    for (int num : arr) {\n        sum_magnitudes += abs(num);\n    }\n\n    // Step 3: Product of Signs\n    int product_signs = 1;\n    for (int num : arr) {\n        if (num == 0) {\n            product_signs = 0;\n            break;\n        } else if (num < 0) {\n            product_signs *= -1;\n        }\n    }\n\n    // Step 4: Combine Results\n    return sum_magnitudes * product_signs;\n}\n"}
{"task_id": "CPP/129", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nbool is_valid_move(int x, int y, int N) {\n    return x >= 0 && x < N && y >= 0 && y < N;\n}\n\nvoid dfs(vector<vector<int>>& grid, int x, int y, int k, vector<int>& path, vector<int>& min_path) {\n    if (k == 0) {\n        if (min_path.empty() || path < min_path) {\n            min_path = path;\n        }\n        return;\n    }\n    path.push_back(grid[x][y]);\n    int dx[] = {0, 1, 0, -1};\n    int dy[] = {1, 0, -1, 0};\n    for (int i = 0; i < 4; ++i) {\n        int nx = x + dx[i];\n        int ny = y + dy[i];\n        if (is_valid_move(nx, ny, grid.size())) {\n            dfs(grid, nx, ny, k - 1, path, min_path);\n        }\n    }\n    path.pop_back();\n}\n\nvector<int> minPath(vector<vector<int>> grid, int k) {\n    int N = grid.size();\n    vector<int> min_path;\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            vector<int> path;\n            dfs(grid, i, j, k, path, min_path);\n        }\n    }\n    return min_path;\n}\n\n"}
{"task_id": "CPP/130", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> tri(int n) {\n    // Initialize the vector with the base case\n    vector<int> result(n + 1, 0);\n    result[1] = 3;\n\n    // Helper function to compute the Tribonacci value\n    function<int(int)> computeTri = [&](int k) -> int {\n        if (k == 1) return 3;\n        if (k % 2 == 0) {\n            result[k] = 1 + k / 2;\n        } else {\n            result[k] = computeTri(k - 1) + computeTri(k - 2) + computeTri(k + 1);\n        }\n        return result[k];\n    };\n\n    // Fill the vector\n    for (int i = 2; i <= n; ++i) {\n        computeTri(i);\n    }\n\n    // Return the result\n    return result;\n}\n"}
{"task_id": "CPP/131", "generation": "#include <iostream>\n\nint digits(int n) {\n    int product = 1;\n    bool hasOddDigit = false;\n\n    while (n > 0) {\n        int digit = n % 10; // Extract the last digit\n        if (digit % 2 != 0) { // Check if the digit is odd\n            product *= digit;\n            hasOddDigit = true;\n        }\n        n /= 10; // Remove the last digit\n    }\n\n    if (hasOddDigit) {\n        return product;\n    } else {\n        return 0;\n    }\n}\n\n"}
{"task_id": "CPP/132", "generation": "#include <iostream>\n#include <stack>\n#include <string>\nusing namespace std;\n\nbool is_nested(string str) {\n    stack<char> bracket_stack;\n    bool nested_found = false;\n\n    for (char ch : str) {\n        if (ch == '[') {\n            bracket_stack.push(ch);\n        } else if (ch == ']') {\n            if (!bracket_stack.empty()) {\n                bracket_stack.pop();\n                if (!bracket_stack.empty()) {\n                    nested_found = true;\n                }\n            }\n        }\n    }\n\n    return nested_found;\n}\n\n"}
{"task_id": "CPP/133", "generation": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nint sum_squares(vector<float> lst) {\n    int sum = 0;\n    for (float num : lst) {\n        int rounded_num = ceil(num);\n        int squared_num = rounded_num * rounded_num;\n        sum += squared_num;\n    }\n    return sum;\n}\n\n"}
{"task_id": "CPP/134", "generation": "#include <iostream>\n#include <string>\n#include <cctype>\nusing namespace std;\n\nbool check_if_last_char_is_a_letter(string txt) {\n    // Step 1: Check if the string is empty\n    if (txt.empty()) {\n        return false;\n    }\n\n    // Step 2: Identify the last character\n    char last_char = txt.back();\n\n    // Step 3: Check if the last character is an alphabetical character\n    if (!isalpha(last_char)) {\n        return false;\n    }\n\n    // Step 4: Check if the last character is not part of a word\n    if (txt.length() > 1 && txt[txt.length() - 2] != ' ') {\n        return false;\n    }\n\n    // Step 5: Return the result\n    return true;\n}\n\n"}
{"task_id": "CPP/135", "generation": "#include <vector>\nusing namespace std;\n\nint can_arrange(vector<int> arr) {\n    // Initial checks\n    if (arr.empty() || arr.size() == 1) {\n        return -1;\n    }\n\n    // Initialize max_index\n    int max_index = -1;\n\n    // Iterate through the vector\n    for (int i = 1; i < arr.size(); ++i) {\n        // Condition check\n        if (arr[i] < arr[i - 1]) {\n            max_index = i;\n        }\n    }\n\n    // Return the result\n    return max_index;\n}\n"}
{"task_id": "CPP/136", "generation": "#include <vector>\n#include <limits>\nusing namespace std;\n\nvector<int> largest_smallest_integers(vector<int> lst) {\n    int a = 0; // Default value for the largest negative integer\n    int b = 0; // Default value for the smallest positive integer\n    bool hasNegative = false;\n    bool hasPositive = false;\n\n    // Filter and process negative integers\n    for (int num : lst) {\n        if (num < 0) {\n            if (!hasNegative || num > a) {\n                a = num;\n                hasNegative = true;\n            }\n        }\n    }\n\n    // Filter and process positive integers\n    for (int num : lst) {\n        if (num > 0) {\n            if (!hasPositive || num < b) {\n                b = num;\n                hasPositive = true;\n            }\n        }\n    }\n\n    // Handle edge cases\n    if (!hasNegative) {\n        a = 0;\n    }\n    if (!hasPositive) {\n        b = 0;\n    }\n\n    return {a, b};\n}\n"}
{"task_id": "CPP/137", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <boost/any.hpp>\n#include <stdexcept>\n\nusing namespace std;\n\nstd::string getType(const boost::any& value) {\n    if (value.type() == typeid(int)) return \"int\";\n    else if (value.type() == typeid(float)) return \"float\";\n    else if (value.type() == typeid(std::string)) return \"string\";\n    else throw std::runtime_error(\"Unsupported type\");\n}\n\nfloat stringToFloat(const std::string& str) {\n    std::string cleanedStr = str;\n    std::replace(cleanedStr.begin(), cleanedStr.end(), ',', '.');\n    return std::stof(cleanedStr);\n}\n\nboost::any compare_one(boost::any a, boost::any b) {\n    std::string typeA = getType(a);\n    std::string typeB = getType(b);\n\n    float numA, numB;\n\n    if (typeA == \"string\") {\n        numA = stringToFloat(boost::any_cast<std::string>(a));\n    } else if (typeA == \"int\") {\n        numA = static_cast<float>(boost::any_cast<int>(a));\n    } else {\n        numA = boost::any_cast<float>(a);\n    }\n\n    if (typeB == \"string\") {\n        numB = stringToFloat(boost::any_cast<std::string>(b));\n    } else if (typeB == \"int\") {\n        numB = static_cast<float>(boost::any_cast<int>(b));\n    } else {\n        numB = boost::any_cast<float>(b);\n    }\n\n    if (numA == numB) {\n        return \"None\";\n    } else if (numA > numB) {\n        return a;\n    } else {\n        return b;\n    }\n}\n\n"}
{"task_id": "CPP/138", "generation": "#include <iostream>\n\nbool is_equal_to_sum_even(int n) {\n    // Input validation\n    if (n <= 0) {\n        return false;\n    }\n\n    // Initial check\n    if (n < 8) {\n        return false;\n    }\n\n    // Even number check\n    if (n % 2 != 0) {\n        return false;\n    }\n\n    // Sum of four even numbers\n    if (n % 4 == 0) {\n        return true;\n    } else {\n        return false;\n    }\n}\n\n"}
{"task_id": "CPP/139", "generation": "#include <iostream>\n#include <stdexcept>\n\n// Helper function to calculate factorial\nlong long factorial(int k) {\n    if (k == 0 || k == 1) {\n        return 1;\n    }\n    long long result = 1;\n    for (int i = 2; i <= k; ++i) {\n        result *= i;\n    }\n    return result;\n}\n\n// Main function to calculate Brazilian factorial\nlong long special_factorial(int n) {\n    if (n <= 0) {\n        throw std::invalid_argument(\"Input must be a positive integer.\");\n    }\n\n    long long result = 1;\n    for (int i = 1; i <= n; ++i) {\n        result *= factorial(i);\n    }\n    return result;\n}\n\n// Function to test the special_factorial function\nvoid test_special_factorial() {\n    assert(special_factorial(1) == 1);\n    assert(special_factorial(2) == 2);\n    assert(special_factorial(3) == 12);\n    assert(special_factorial(4) == 288);\n    // Add more test cases as needed\n}\n\n"}
{"task_id": "CPP/140", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring fix_spaces(string text) {\n    string result;\n    int space_count = 0;\n\n    for (char ch : text) {\n        if (ch == ' ') {\n            space_count++;\n        } else {\n            if (space_count > 2) {\n                result += '-';\n            } else if (space_count > 0) {\n                result.append(space_count, '_');\n            }\n            space_count = 0;\n            result += ch;\n        }\n    }\n\n    // Handle trailing spaces\n    if (space_count > 2) {\n        result += '-';\n    } else if (space_count > 0) {\n        result.append(space_count, '_');\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/141", "generation": "#include <iostream>\n#include <string>\n#include <cctype>\n#include <vector>\n\nusing namespace std;\n\nstring file_name_check(string file_name) {\n    // Step 1: Parse the file name\n    size_t dot_pos = file_name.find('.');\n    if (dot_pos == string::npos || file_name.find('.', dot_pos + 1) != string::npos) {\n        return \"No\"; // More than one dot or no dot found\n    }\n\n    string name_part = file_name.substr(0, dot_pos);\n    string extension_part = file_name.substr(dot_pos + 1);\n\n    // Step 2: Validate the substring before the dot\n    if (name_part.empty() || !isalpha(name_part[0])) {\n        return \"No\"; // Empty or does not start with a letter\n    }\n\n    // Step 3: Validate the substring after the dot\n    vector<string> valid_extensions = {\"txt\", \"exe\", \"dll\"};\n    if (find(valid_extensions.begin(), valid_extensions.end(), extension_part) == valid_extensions.end()) {\n        return \"No\"; // Invalid extension\n    }\n\n    // Step 4: Count the digits in the file name\n    int digit_count = 0;\n    for (char c : file_name) {\n        if (isdigit(c)) {\n            digit_count++;\n        }\n    }\n    if (digit_count > 3) {\n        return \"No\"; // More than three digits\n    }\n\n    // Step 5: Return the result\n    return \"Yes\";\n}\n\n"}
{"task_id": "CPP/142", "generation": "#include <vector>\nusing namespace std;\n\nint sum_squares(vector<int> lst) {\n    int sum = 0; // Initialize sum to 0\n\n    // Iterate through the vector\n    for (size_t i = 0; i < lst.size(); ++i) {\n        int value = lst[i];\n\n        // Check if the index is a multiple of 3\n        if (i % 3 == 0) {\n            value = value * value; // Square the value\n        }\n        // Check if the index is a multiple of 4 and not a multiple of 3\n        else if (i % 4 == 0) {\n            value = value * value * value; // Cube the value\n        }\n\n        // Add the transformed value to the sum\n        sum += value;\n    }\n\n    // Return the final sum\n    return sum;\n}\n"}
{"task_id": "CPP/143", "generation": "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <string>\n\n// Function to check if a number is prime\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    if (n == 2) return true;\n    if (n % 2 == 0) return false;\n    for (int i = 3; i * i <= n; i += 2) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\n// Function to filter words with prime lengths\nstd::string words_in_sentence(std::string sentence) {\n    std::istringstream iss(sentence);\n    std::vector<std::string> words;\n    std::string word;\n    \n    // Split the sentence into words\n    while (iss >> word) {\n        words.push_back(word);\n    }\n    \n    std::vector<std::string> prime_words;\n    \n    // Filter words with prime lengths\n    for (const auto& w : words) {\n        if (is_prime(w.length())) {\n            prime_words.push_back(w);\n        }\n    }\n    \n    // Reconstruct the sentence\n    std::string result;\n    for (size_t i = 0; i < prime_words.size(); ++i) {\n        result += prime_words[i];\n        if (i < prime_words.size() - 1) {\n            result += \" \";\n        }\n    }\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/144", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\nusing namespace std;\n\n// Helper function to parse the fraction\nvoid parseFraction(const string& fraction, int& numerator, int& denominator) {\n    stringstream ss(fraction);\n    string part;\n    getline(ss, part, '/'); // Read numerator\n    numerator = stoi(part);\n    getline(ss, part); // Read denominator\n    denominator = stoi(part);\n}\n\n// Main function to simplify the expression x * n\nbool simplify(const string& x, const string& n) {\n    int x_num, x_den, n_num, n_den;\n\n    // Parse the fractions\n    parseFraction(x, x_num, x_den);\n    parseFraction(n, n_num, n_den);\n\n    // Multiply the fractions\n    int result_num = x_num * n_num;\n    int result_den = x_den * n_den;\n\n    // Check if the result is a whole number\n    return (result_num % result_den == 0);\n}\n\n// Main function for testing\n"}
{"task_id": "CPP/145", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\n// Helper function to calculate the sum of digits\nint sum_of_digits(int num) {\n    int sum = 0;\n    bool is_negative = num < 0;\n    while (num != 0) {\n        int digit = num % 10;\n        if (is_negative && num < 0) {\n            digit *= -1; // Consider the first digit as negative\n            is_negative = false;\n        }\n        sum += digit;\n        num /= 10;\n    }\n    return sum;\n}\n\n// Struct for pairing integers with their indices\nstruct IndexedInt {\n    int value;\n    int index;\n};\n\n// Custom comparator\nbool custom_comparator(const IndexedInt& a, const IndexedInt& b) {\n    int sum_a = sum_of_digits(a.value);\n    int sum_b = sum_of_digits(b.value);\n    if (sum_a == sum_b) {\n        return a.index < b.index;\n    }\n    return sum_a < sum_b;\n}\n\n// Main function to sort the vector\nstd::vector<int> order_by_points(std::vector<int> nums) {\n    // Transform the input vector into a vector of IndexedInt\n    std::vector<IndexedInt> indexed_nums;\n    for (int i = 0; i < nums.size(); ++i) {\n        indexed_nums.push_back({nums[i], i});\n    }\n\n    // Sort the transformed vector using the custom comparator\n    std::sort(indexed_nums.begin(), indexed_nums.end(), custom_comparator);\n\n    // Extract the sorted integers\n    std::vector<int> sorted_nums;\n    for (const auto& indexed_num : indexed_nums) {\n        sorted_nums.push_back(indexed_num.value);\n    }\n\n    return sorted_nums;\n}\n\n// Main function for testing\n"}
{"task_id": "CPP/146", "generation": "#include <vector>\n#include <string>\nusing namespace std;\n\nint specialFilter(vector<int> nums) {\n    int count = 0;\n    for (int num : nums) {\n        if (num > 10) {\n            string numStr = to_string(num);\n            int firstDigit = numStr[0] - '0';\n            int lastDigit = numStr[numStr.length() - 1] - '0';\n            if (firstDigit % 2 != 0 && lastDigit % 2 != 0) {\n                count++;\n            }\n        }\n    }\n    return count;\n}\n"}
{"task_id": "CPP/147", "generation": "#include <iostream>\n#include <vector>\n\n// Function to generate the vector a\nstd::vector<int> generate_vector(int n) {\n    std::vector<int> a(n);\n    for (int i = 1; i <= n; ++i) {\n        a[i-1] = i * i - i + 1;\n    }\n    return a;\n}\n\n// Function to count valid triples\nint count_valid_triples(const std::vector<int>& a) {\n    int count = 0;\n    int n = a.size();\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            for (int k = j + 1; k < n; ++k) {\n                if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                    ++count;\n                }\n            }\n        }\n    }\n    return count;\n}\n\n// Main function to get the number of valid triples\nint get_max_triples(int n) {\n    std::vector<int> a = generate_vector(n);\n    return count_valid_triples(a);\n}\n\n"}
{"task_id": "CPP/148", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nconst vector<string> planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n\nbool isValidPlanet(const string& planet) {\n    return find(planets.begin(), planets.end(), planet) != planets.end();\n}\n\nvector<string> bf(string planet1, string planet2) {\n    if (!isValidPlanet(planet1) || !isValidPlanet(planet2)) {\n        return {};\n    }\n\n    int pos1 = find(planets.begin(), planets.end(), planet1) - planets.begin();\n    int pos2 = find(planets.begin(), planets.end(), planet2) - planets.begin();\n\n    if (pos1 > pos2) {\n        swap(pos1, pos2);\n    }\n\n    vector<string> result;\n    for (int i = pos1 + 1; i < pos2; ++i) {\n        result.push_back(planets[i]);\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/149", "generation": "#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nvector<string> vector_sort(vector<string> lst) {\n    // Filter strings with even lengths\n    vector<string> filtered_lst;\n    for (const auto& str : lst) {\n        if (str.length() % 2 == 0) {\n            filtered_lst.push_back(str);\n        }\n    }\n\n    // Sort the filtered strings\n    sort(filtered_lst.begin(), filtered_lst.end(), [](const string& a, const string& b) {\n        if (a.length() == b.length()) {\n            return a < b; // Lexicographical order\n        }\n        return a.length() < b.length(); // Length order\n    });\n\n    // Return the sorted vector\n    return filtered_lst;\n}\n"}
{"task_id": "CPP/150", "generation": "#include <iostream>\n#include <cmath>\n#include <cassert>\n\nbool is_prime(int n) {\n    if (n <= 1) return false; // 0 and 1 are not prime numbers\n    if (n == 2) return true; // 2 is the only even prime number\n    if (n % 2 == 0) return false; // Exclude even numbers greater than 2\n    for (int i = 3; i * i <= n; i += 2) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\nint x_or_y(int n, int x, int y) {\n    if (is_prime(n)) {\n        return x;\n    } else {\n        return y;\n    }\n}\n\nvoid test_is_prime() {\n    assert(is_prime(2) == true);\n    assert(is_prime(3) == true);\n    assert(is_prime(4) == false);\n    assert(is_prime(5) == true);\n    assert(is_prime(15) == false);\n    assert(is_prime(17) == true);\n    assert(is_prime(1) == false);\n    assert(is_prime(0) == false);\n    assert(is_prime(-1) == false);\n    std::cout << \"All tests for is_prime passed.\" << std::endl;\n}\n\nvoid test_x_or_y() {\n    assert(x_or_y(7, 34, 12) == 34);\n    assert(x_or_y(15, 8, 5) == 5);\n    assert(x_or_y(2, 10, 20) == 10);\n    assert(x_or_y(4, 10, 20) == 20);\n    std::cout << \"All tests for x_or_y passed.\" << std::endl;\n}\n\n"}
{"task_id": "CPP/151", "generation": "#include <vector>\n#include <cmath>\nusing namespace std;\n\nlong long double_the_difference(vector<float> lst) {\n    long long sum_of_squares = 0;\n\n    // Step 1: Input Validation\n    if (lst.empty()) {\n        return 0;\n    }\n\n    // Step 2: Filtering and Processing\n    for (float num : lst) {\n        // Check if the number is an integer\n        if (num > 0 && floor(num) == num) {\n            int int_num = static_cast<int>(num);\n            // Check if the number is odd\n            if (int_num % 2 != 0) {\n                // Compute the square and add to the sum\n                sum_of_squares += int_num * int_num;\n            }\n        }\n    }\n\n    // Step 3: Return the Result\n    return sum_of_squares;\n}\n"}
{"task_id": "CPP/152", "generation": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nvector<int> compare(vector<int> game, vector<int> guess) {\n    // Input validation\n    if (game.size() != guess.size()) {\n        // Handle error: vectors are not of equal length\n        return {}; // Return an empty vector or throw an exception\n    }\n\n    // Initialize the result vector\n    vector<int> differences;\n\n    // Calculate the differences\n    for (size_t i = 0; i < game.size(); ++i) {\n        int diff = abs(game[i] - guess[i]);\n        differences.push_back(diff);\n    }\n\n    // Return the result\n    return differences;\n}\n\n// Example usage\n"}
{"task_id": "CPP/153", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <climits>\n#include <cctype>\n\nusing namespace std;\n\nstring Strongest_Extension(string class_name, vector<string> extensions) {\n    string strongest_extension = \"\";\n    int max_strength = INT_MIN;\n\n    for (const string& extension : extensions) {\n        int cap = 0, sm = 0;\n        for (char c : extension) {\n            if (isupper(c)) cap++;\n            else if (islower(c)) sm++;\n        }\n        int strength = cap - sm;\n\n        if (strength > max_strength || (strength == max_strength && strongest_extension.empty())) {\n            strongest_extension = extension;\n            max_strength = strength;\n        }\n    }\n\n    return class_name + \".\" + strongest_extension;\n}\n\n"}
{"task_id": "CPP/154", "generation": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\n// Helper function to generate all rotations of a string\nvector<string> generate_rotations(const string& b) {\n    vector<string> rotations;\n    int n = b.length();\n    for (int i = 0; i < n; ++i) {\n        string rotated = b.substr(i) + b.substr(0, i);\n        rotations.push_back(rotated);\n    }\n    return rotations;\n}\n\n// Helper function to check if a string is a substring of another string\nbool is_substring(const string& a, const string& b) {\n    return a.find(b) != string::npos;\n}\n\n// Main function to check if any rotation of b is a substring of a\nbool cycpattern_check(const string& a, const string& b) {\n    vector<string> rotations = generate_rotations(b);\n    for (const string& rotation : rotations) {\n        if (is_substring(a, rotation)) {\n            return true;\n        }\n    }\n    return false;\n}\n\n"}
{"task_id": "CPP/155", "generation": "#include <vector>\n#include <string>\n#include <cmath>\n\nusing namespace std;\n\nvector<int> even_odd_count(int num) {\n    // Handle negative numbers\n    num = abs(num);\n\n    // Convert integer to string\n    string num_str = to_string(num);\n\n    // Initialize counters\n    int even_count = 0;\n    int odd_count = 0;\n\n    // Iterate through digits\n    for (char digit : num_str) {\n        int digit_value = digit - '0';\n        if (digit_value % 2 == 0) {\n            even_count++;\n        } else {\n            odd_count++;\n        }\n    }\n\n    // Create and return the result vector\n    return {even_count, odd_count};\n}\n"}
{"task_id": "CPP/156", "generation": "#include <vector>\n#include <string>\nusing namespace std;\n\nvector<pair<int, string>> romanMap = {\n    {1000, \"m\"}, {900, \"cm\"}, {500, \"d\"}, {400, \"cd\"},\n    {100, \"c\"}, {90, \"xc\"}, {50, \"l\"}, {40, \"xl\"},\n    {10, \"x\"}, {9, \"ix\"}, {5, \"v\"}, {4, \"iv\"}, {1, \"i\"}\n};\n\nstring int_to_mini_roman(int number) {\n    string result = \"\";\n    for (const auto& [value, numeral] : romanMap) {\n        while (number >= value) {\n            number -= value;\n            result += numeral;\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/157", "generation": "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\nbool right_angle_triangle(float a, float b, float c) {\n    // Step 1: Input Validation\n    if (a <= 0 || b <= 0 || c <= 0) {\n        return false; // Sides must be positive\n    }\n    if (a + b <= c || a + c <= b || b + c <= a) {\n        return false; // Triangle inequality theorem\n    }\n\n    // Step 2: Identify the Hypotenuse\n    float hypotenuse, side1, side2;\n    if (a >= b && a >= c) {\n        hypotenuse = a;\n        side1 = b;\n        side2 = c;\n    } else if (b >= a && b >= c) {\n        hypotenuse = b;\n        side1 = a;\n        side2 = c;\n    } else {\n        hypotenuse = c;\n        side1 = a;\n        side2 = b;\n    }\n\n    // Step 3: Apply the Pythagorean Theorem\n    float hypotenuse_squared = pow(hypotenuse, 2);\n    float sum_of_squares = pow(side1, 2) + pow(side2, 2);\n\n    // Step 4: Return the Result\n    return hypotenuse_squared == sum_of_squares;\n}\n\n"}
{"task_id": "CPP/158", "generation": "#include <vector>\n#include <string>\n#include <algorithm>\n#include <set>\n\nusing namespace std;\n\n// Helper function to count unique characters in a string\nint count_unique_chars(const string& str) {\n    set<char> unique_chars(str.begin(), str.end());\n    return unique_chars.size();\n}\n\n// Main function to find the word with the maximum number of unique characters\nstring find_max(vector<string> words) {\n    int max_unique = 0;\n    vector<string> candidates;\n\n    // Iterate through the vector of strings\n    for (const auto& word : words) {\n        int unique_count = count_unique_chars(word);\n        if (unique_count > max_unique) {\n            max_unique = unique_count;\n            candidates.clear();\n            candidates.push_back(word);\n        } else if (unique_count == max_unique) {\n            candidates.push_back(word);\n        }\n    }\n\n    // Sort the candidates lexicographically\n    sort(candidates.begin(), candidates.end());\n\n    // Return the first string in the sorted list\n    return candidates.front();\n}\n"}
{"task_id": "CPP/159", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // For std::min and std::max\n\nusing namespace std;\n\nvector<int> eat(int number, int need, int remaining) {\n    // Input validation\n    if (number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining > 1000) {\n        throw invalid_argument(\"Input values must be between 0 and 1000.\");\n    }\n\n    // Calculate total carrots eaten\n    int total_eaten = number + min(need, remaining);\n\n    // Calculate remaining carrots\n    int remaining_after_meals = max(0, remaining - need);\n\n    // Return the result\n    return {total_eaten, remaining_after_meals};\n}\n\n"}
{"task_id": "CPP/160", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\n#include <sstream>\n#include <cmath>\nusing namespace std;\n\nbool validate_input(const vector<string>& operators, const vector<int>& operands) {\n    if (operators.size() != operands.size() - 1) return false;\n    for (const auto& op : operators) {\n        if (op != \"+\" && op != \"-\" && op != \"*\" && op != \"//\" && op != \"**\") return false;\n    }\n    for (const auto& num : operands) {\n        if (num < 0) return false;\n    }\n    return true;\n}\n\nstring construct_expression(const vector<string>& operators, const vector<int>& operands) {\n    string expression;\n    for (size_t i = 0; i < operands.size(); ++i) {\n        expression += to_string(operands[i]);\n        if (i < operators.size()) {\n            expression += \" \" + operators[i] + \" \";\n        }\n    }\n    return expression;\n}\n\nint precedence(const string& op) {\n    if (op == \"+\" || op == \"-\") return 1;\n    if (op == \"*\" || op == \"//\") return 2;\n    if (op == \"**\") return 3;\n    return 0;\n}\n\nint apply_op(const string& op, int a, int b) {\n    if (op == \"+\") return a + b;\n    if (op == \"-\") return a - b;\n    if (op == \"*\") return a * b;\n    if (op == \"//\") return a / b;\n    if (op == \"**\") return pow(a, b);\n    return 0;\n}\n\nint evaluate_expression(const string& expression) {\n    stack<int> values;\n    stack<string> ops;\n\n    istringstream iss(expression);\n    string token;\n    while (iss >> token) {\n        if (isdigit(token[0]) || (token.size() > 1 && isdigit(token[1]))) {\n            values.push(stoi(token));\n        } else {\n            while (!ops.empty() && precedence(ops.top()) >= precedence(token)) {\n                int val2 = values.top(); values.pop();\n                int val1 = values.top(); values.pop();\n                values.push(apply_op(ops.top(), val1, val2));\n                ops.pop();\n            }\n            ops.push(token);\n        }\n    }\n\n    while (!ops.empty()) {\n        int val2 = values.top(); values.pop();\n        int val1 = values.top(); values.pop();\n        values.push(apply_op(ops.top(), val1, val2));\n        ops.pop();\n    }\n\n    return values.top();\n}\n\nint do_algebra(vector<string> operators, vector<int> operands) {\n    if (!validate_input(operators, operands)) {\n        throw invalid_argument(\"Invalid input\");\n    }\n\n    string expression = construct_expression(operators, operands);\n    return evaluate_expression(expression);\n}\n\n"}
{"task_id": "CPP/161", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring solve(string s) {\n    bool containsLetter = false;\n    string result = \"\";\n\n    // Iterate through the string\n    for (char c : s) {\n        if (isalpha(c)) {  // Check if the character is a letter\n            containsLetter = true;\n            if (islower(c)) {\n                result += toupper(c);  // Convert lowercase to uppercase\n            } else {\n                result += tolower(c);  // Convert uppercase to lowercase\n            }\n        } else {\n            result += c;  // Keep non-letter characters as is\n        }\n    }\n\n    // If no letters are found, reverse the string\n    if (!containsLetter) {\n        reverse(result.begin(), result.end());\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/162", "generation": "#include <stdio.h>\n#include <string>\n#include <openssl/md5.h>\nusing namespace std;\n\nstring string_to_md5(string text) {\n    if (text.empty()) {\n        return \"None\";\n    }\n\n    unsigned char digest[MD5_DIGEST_LENGTH];\n    MD5_CTX ctx;\n    MD5_Init(&ctx);\n    MD5_Update(&ctx, text.c_str(), text.length());\n    MD5_Final(digest, &ctx);\n\n    char mdString[33];\n    for (int i = 0; i < 16; ++i) {\n        sprintf(&mdString[i*2], \"%02x\", (unsigned int)digest[i]);\n    }\n\n    return string(mdString);\n}\n"}
{"task_id": "CPP/163", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <stdexcept>\n\nusing namespace std;\n\nvector<int> generate_integers(int a, int b) {\n    if (a < 0 || b < 0) {\n        throw invalid_argument(\"Both a and b must be positive integers.\");\n    }\n    if (a > b) {\n        swap(a, b);\n    }\n\n    vector<int> even_digits = {0, 2, 4, 6, 8};\n    vector<int> result;\n\n    for (int digit : even_digits) {\n        if (digit >= a && digit <= b) {\n            result.push_back(digit);\n        }\n    }\n\n    return result;\n}\n\n"}
