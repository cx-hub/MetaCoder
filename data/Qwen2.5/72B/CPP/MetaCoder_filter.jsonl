{"task_id": "CPP/41", "generation": "#include <iostream>\nusing namespace std;\n\nint car_race_collision(int n) {\n    // Each car moving left to right will collide with each car moving right to left.\n    return n * n;\n}\n\n"}
{"task_id": "CPP/116", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <bitset>\n\nusing namespace std;\n\n// Helper function to count the number of ones in the binary representation of an integer\nint count_ones(int n) {\n    return bitset<32>(n).count();\n}\n\n// Custom comparator for sorting\nbool custom_sort(int a, int b) {\n    int ones_a = count_ones(a);\n    int ones_b = count_ones(b);\n    if (ones_a == ones_b) {\n        return a < b;\n    }\n    return ones_a < ones_b;\n}\n\nvector<int> sort_array(vector<int> arr) {\n    // Sort the array using the custom comparator\n    sort(arr.begin(), arr.end(), custom_sort);\n    return arr;\n}\n\n// Function to test the sort_array function\nvoid test_sort_array() {\n    vector<int> test1 = {1, 5, 2, 3, 4};\n    vector<int> expected1 = {1, 2, 4, 3, 5};\n    assert(sort_array(test1) == expected1);\n\n    vector<int> test2 = {-2, -3, -4, -5, -6};\n    vector<int> expected2 = {-4, -2, -6, -5, -3};\n    assert(sort_array(test2) == expected2);\n\n    vector<int> test3 = {1, 0, 2, 3, 4};\n    vector<int> expected3 = {0, 1, 2, 4, 3};\n    assert(sort_array(test3) == expected3);\n\n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/61", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool correct_bracketing(const string& brackets) {\n    int balance = 0;\n    for (char c : brackets) {\n        if (c == '(') {\n            balance++;\n        } else if (c == ')') {\n            balance--;\n            if (balance < 0) {\n                return false; // More closing brackets than opening ones\n            }\n        }\n    }\n    return balance == 0; // All opening brackets must be closed\n}\n\n"}
{"task_id": "CPP/25", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> factorize(int n) {\n    vector<int> factors;\n    // Check for number of 2s in n\n    while (n % 2 == 0) {\n        factors.push_back(2);\n        n = n / 2;\n    }\n    // n must be odd at this point, so we can skip one element (Note i = i + 2)\n    for (int i = 3; i * i <= n; i += 2) {\n        // While i divides n, append i and divide n\n        while (n % i == 0) {\n            factors.push_back(i);\n            n = n / i;\n        }\n    }\n    // This condition is to handle the case when n is a prime number greater than 2\n    if (n > 2) {\n        factors.push_back(n);\n    }\n    return factors;\n}\n\n// Function to print the vector\nvoid printFactors(const vector<int>& factors) {\n    cout << \"{\";\n    for (size_t i = 0; i < factors.size(); ++i) {\n        cout << factors[i];\n        if (i < factors.size() - 1) {\n            cout << \", \";\n        }\n    }\n    cout << \"}\" << endl;\n}\n\n"}
{"task_id": "CPP/137", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <boost/any.hpp>\n#include <sstream>\n\nusing namespace std;\n\n// Function to convert a string to a float, handling both '.' and ',' as decimal separators\nfloat string_to_float(const string& s) {\n    string modified_s = s;\n    replace(modified_s.begin(), modified_s.end(), ',', '.');\n    return stof(modified_s);\n}\n\nboost::any compare_one(boost::any a, boost::any b) {\n    float a_val, b_val;\n\n    // Convert a to float if it's a string\n    if (a.type() == typeid(string)) {\n        a_val = string_to_float(boost::any_cast<string>(a));\n    } else if (a.type() == typeid(int)) {\n        a_val = static_cast<float>(boost::any_cast<int>(a));\n    } else if (a.type() == typeid(float)) {\n        a_val = boost::any_cast<float>(a);\n    } else {\n        throw runtime_error(\"Unsupported type for a\");\n    }\n\n    // Convert b to float if it's a string\n    if (b.type() == typeid(string)) {\n        b_val = string_to_float(boost::any_cast<string>(b));\n    } else if (b.type() == typeid(int)) {\n        b_val = static_cast<float>(boost::any_cast<int>(b));\n    } else if (b.type() == typeid(float)) {\n        b_val = boost::any_cast<float>(b);\n    } else {\n        throw runtime_error(\"Unsupported type for b\");\n    }\n\n    // Compare the values\n    if (a_val == b_val) {\n        return \"None\";\n    } else if (a_val > b_val) {\n        return a;\n    } else {\n        return b;\n    }\n}\n\n"}
{"task_id": "CPP/102", "generation": "#include <iostream>\nusing namespace std;\n\nint choose_num(int x, int y) {\n    // Ensure x is less than or equal to y\n    if (x > y) {\n        return -1;\n    }\n\n    // Start from y and decrement until we find an even number or reach x\n    for (int i = y; i >= x; --i) {\n        if (i % 2 == 0) {\n            return i;\n        }\n    }\n\n    // If no even number is found, return -1\n    return -1;\n}\n\n"}
{"task_id": "CPP/10", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_palindrome(const string& str) {\n    // Test if given string is a palindrome\n    string s(str.rbegin(), str.rend());\n    return s == str;\n}\n\nstring make_palindrome(const string& str) {\n    int n = str.length();\n    for (int i = 0; i < n; ++i) {\n        // Check if the suffix starting from i is a palindrome\n        if (is_palindrome(str.substr(i))) {\n            // If it is, then the non-palindromic prefix is the substring from 0 to i-1\n            string prefix = str.substr(0, i);\n            // Reverse the prefix and append it to the original string\n            string reversed_prefix = string(prefix.rbegin(), prefix.rend());\n            return str + reversed_prefix;\n        }\n    }\n    // If no palindromic suffix is found (which won't happen because an empty string is a palindrome)\n    return str;\n}\n\n"}
{"task_id": "CPP/76", "generation": "#include <iostream>\n#include <cmath>\nusing namespace std;\n\nbool is_simple_power(int x, int n) {\n    if (n == 1) {\n        return x == 1;\n    }\n    if (x == 1) {\n        return n == 1;\n    }\n    if (n <= 0 || x <= 0) {\n        return false;\n    }\n    int power = 0;\n    while (pow(n, power) <= x) {\n        if (pow(n, power) == x) {\n            return true;\n        }\n        power += 1;\n    }\n    return false;\n}\n\n"}
{"task_id": "CPP/94", "generation": "#include <vector>\n#include <cmath>\nusing namespace std;\n\n// Helper function to check if a number is prime\nbool isPrime(int n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    for (int i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) return false;\n    }\n    return true;\n}\n\n// Function to find the largest prime and return the sum of its digits\nint skjkasdkd(vector<int> lst) {\n    int largestPrime = -1;\n    \n    // Find the largest prime in the list\n    for (int num : lst) {\n        if (isPrime(num) && num > largestPrime) {\n            largestPrime = num;\n        }\n    }\n    \n    // If no prime number is found, return 0\n    if (largestPrime == -1) return 0;\n    \n    // Calculate the sum of the digits of the largest prime\n    int sumOfDigits = 0;\n    while (largestPrime > 0) {\n        sumOfDigits += largestPrime % 10;\n        largestPrime /= 10;\n    }\n    \n    return sumOfDigits;\n}\n\n// Example usage\n"}
{"task_id": "CPP/32", "generation": "#include <iostream>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\ndouble poly(const vector<double>& xs, double x) {\n    double sum = 0;\n    for (size_t i = 0; i < xs.size(); ++i) {\n        sum += xs[i] * pow(x, i);\n    }\n    return sum;\n}\n\ndouble poly_derivative(const vector<double>& xs, double x) {\n    double sum = 0;\n    for (size_t i = 1; i < xs.size(); ++i) {\n        sum += i * xs[i] * pow(x, i - 1);\n    }\n    return sum;\n}\n\ndouble find_zero(const vector<double>& xs) {\n    // Initial guess\n    double x = 0.0;\n    double epsilon = 1e-6; // Tolerance for convergence\n    double max_iterations = 1000; // Maximum number of iterations\n\n    for (int i = 0; i < max_iterations; ++i) {\n        double f_x = poly(xs, x);\n        double f_prime_x = poly_derivative(xs, x);\n\n        if (fabs(f_prime_x) < epsilon) {\n            // Derivative is too small, avoid division by zero\n            break;\n        }\n\n        double next_x = x - f_x / f_prime_x;\n\n        if (fabs(next_x - x) < epsilon) {\n            // Convergence criterion met\n            return next_x;\n        }\n\n        x = next_x;\n    }\n\n    // If no convergence, return the last value of x\n    return x;\n}\n\n"}
{"task_id": "CPP/33", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> sort_third(vector<int> l) {\n    vector<int> indices_to_sort;\n    \n    // Collect indices divisible by 3\n    for (size_t i = 0; i < l.size(); ++i) {\n        if (i % 3 == 0) {\n            indices_to_sort.push_back(l[i]);\n        }\n    }\n    \n    // Sort the collected indices\n    sort(indices_to_sort.begin(), indices_to_sort.end());\n    \n    // Replace the original elements with the sorted ones\n    size_t sorted_index = 0;\n    for (size_t i = 0; i < l.size(); ++i) {\n        if (i % 3 == 0) {\n            l[i] = indices_to_sort[sorted_index++];\n        }\n    }\n    \n    return l;\n}\n\n"}
{"task_id": "CPP/88", "generation": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> sort_array(vector<int> array) {\n    // Create a copy of the original vector to avoid modifying it\n    vector<int> sorted_array = array;\n\n    // Check if the vector is empty or has only one element\n    if (array.empty() || array.size() == 1) {\n        return sorted_array;\n    }\n\n    // Calculate the sum of the first and last elements\n    int sum = array.front() + array.back();\n\n    // Determine the sorting order based on the sum\n    if (sum % 2 == 0) {\n        // Sort in descending order if the sum is even\n        sort(sorted_array.begin(), sorted_array.end(), greater<int>());\n    } else {\n        // Sort in ascending order if the sum is odd\n        sort(sorted_array.begin(), sorted_array.end());\n    }\n\n    return sorted_array;\n}\n\n// Example usage\n"}
{"task_id": "CPP/15", "generation": "#include <sstream> // For std::ostringstream\n\nstring string_sequence(int n) {\n    std::ostringstream oss;\n    for (int i = 0; i <= n; ++i) {\n        if (i > 0) {\n            oss << \" \"; // Add a space before each number except the first one\n        }\n        oss << i;\n    }\n    return oss.str();\n}\n"}
{"task_id": "CPP/163", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> generate_integers(int a, int b) {\n    // Ensure a is always less than or equal to b\n    if (a > b) swap(a, b);\n\n    vector<int> even_digits = {0, 2, 4, 6, 8};\n    vector<int> result;\n\n    for (int digit : even_digits) {\n        if (digit >= a && digit <= b) {\n            result.push_back(digit);\n        }\n    }\n\n    return result;\n}\n\n// Function to test the generate_integers function\nvoid test_generate_integers() {\n    vector<int> result1 = generate_integers(2, 8);\n    vector<int> expected1 = {2, 4, 6, 8};\n    cout << \"Test 1: \" << (result1 == expected1 ? \"Passed\" : \"Failed\") << endl;\n\n    vector<int> result2 = generate_integers(8, 2);\n    vector<int> expected2 = {2, 4, 6, 8};\n    cout << \"Test 2: \" << (result2 == expected2 ? \"Passed\" : \"Failed\") << endl;\n\n    vector<int> result3 = generate_integers(10, 14);\n    vector<int> expected3 = {};\n    cout << \"Test 3: \" << (result3 == expected3 ? \"Passed\" : \"Failed\") << endl;\n}\n\n"}
{"task_id": "CPP/1", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\nusing namespace std;\n\nvector<string> separate_paren_groups(string paren_string) {\n    vector<string> result;\n    stack<char> stk;\n    string temp = \"\";\n\n    // Remove spaces from the input string\n    paren_string.erase(remove(paren_string.begin(), paren_string.end(), ' '), paren_string.end());\n\n    for (char c : paren_string) {\n        if (c == '(') {\n            stk.push(c);\n            temp += c;\n        } else if (c == ')') {\n            stk.pop();\n            temp += c;\n            if (stk.empty()) {\n                result.push_back(temp);\n                temp = \"\";\n            }\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/69", "generation": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint search(vector<int> lst) {\n    // Step 1: Count the frequency of each integer\n    unordered_map<int, int> freq;\n    for (int num : lst) {\n        freq[num]++;\n    }\n\n    // Step 2: Find the greatest integer that satisfies the condition\n    int result = -1;\n    for (const auto& pair : freq) {\n        if (pair.first <= pair.second && pair.first > result) {\n            result = pair.first;\n        }\n    }\n\n    // Step 3: Return the result\n    return result;\n}\n\n// Function to test the solution\nvoid test() {\n    cout << search({4, 1, 2, 2, 3, 1}) << \" == 2\" << endl;\n    cout << search({1, 2, 2, 3, 3, 3, 4, 4, 4}) << \" == 3\" << endl;\n    cout << search({5, 5, 4, 4, 4}) << \" == -1\" << endl;\n}\n\n"}
{"task_id": "CPP/31", "generation": "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\nbool is_prime(long long n) {\n    // Handle special cases\n    if (n <= 1) return false; // 0 and 1 are not prime numbers\n    if (n == 2 || n == 3) return true; // 2 and 3 are prime numbers\n    if (n % 2 == 0 || n % 3 == 0) return false; // Eliminate multiples of 2 and 3\n\n    // Check for factors from 5 to sqrt(n)\n    for (long long i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) return false;\n    }\n\n    return true;\n}\n\n"}
{"task_id": "CPP/147", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint get_max_triples(int n) {\n    vector<int> a(n);\n    vector<int> remainder_count(3, 0);\n\n    // Generate the vector a and count the remainders\n    for (int i = 1; i <= n; ++i) {\n        a[i-1] = i * i - i + 1;\n        int remainder = a[i-1] % 3;\n        remainder_count[remainder]++;\n    }\n\n    // Count the number of valid triples\n    long long count = 0;\n\n    // Case 1: All three remainders are 0\n    count += (long long)remainder_count[0] * (remainder_count[0] - 1) * (remainder_count[0] - 2) / 6;\n\n    // Case 2: All three remainders are 1\n    count += (long long)remainder_count[1] * (remainder_count[1] - 1) * (remainder_count[1] - 2) / 6;\n\n    // Case 3: All three remainders are 2\n    count += (long long)remainder_count[2] * (remainder_count[2] - 1) * (remainder_count[2] - 2) / 6;\n\n    // Case 4: One remainder is 0, one is 1, and one is 2\n    count += (long long)remainder_count[0] * remainder_count[1] * remainder_count[2];\n\n    return count;\n}\n\n"}
{"task_id": "CPP/105", "generation": "#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nvector<string> by_length(vector<int> arr) {\n    // Define the mapping from numbers to words\n    const vector<string> numberWords = {\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"};\n\n    // Filter, sort, and reverse the array\n    vector<int> filteredArr;\n    for (int num : arr) {\n        if (num >= 1 && num <= 9) {\n            filteredArr.push_back(num);\n        }\n    }\n\n    sort(filteredArr.begin(), filteredArr.end());\n    reverse(filteredArr.begin(), filteredArr.end());\n\n    // Convert numbers to words\n    vector<string> result;\n    for (int num : filteredArr) {\n        result.push_back(numberWords[num - 1]);\n    }\n\n    return result;\n}\n\n// Example usage\n"}
{"task_id": "CPP/22", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <boost/any.hpp>\n#include <list>\n\ntypedef std::list<boost::any> list_any;\n\nstd::vector<int> filter_integers(const list_any& values) {\n    std::vector<int> result;\n    \n    for (const auto& value : values) {\n        if (value.type() == typeid(int)) {\n            result.push_back(boost::any_cast<int>(value));\n        }\n    }\n    \n    return result;\n}\n\n// Function to test the filter_integers function\nvoid test_filter_integers() {\n    list_any test1 = {\"a\", 3.14, 5};\n    list_any test2 = {1, 2, 3, \"abc\", {}, {}};\n    \n    std::vector<int> result1 = filter_integers(test1);\n    std::vector<int> result2 = filter_integers(test2);\n    \n    // Print results\n    std::cout << \"Test 1: \";\n    for (int num : result1) {\n        std::cout << num << \" \";\n    }\n    std::cout << std::endl;\n    \n    std::cout << \"Test 2: \";\n    for (int num : result2) {\n        std::cout << num << \" \";\n    }\n    std::cout << std::endl;\n}\n\n"}
{"task_id": "CPP/52", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool below_threshold(vector<int> l, int t) {\n    for (int num : l) {\n        if (num >= t) {\n            return false;\n        }\n    }\n    return true;\n}\n\n"}
{"task_id": "CPP/154", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool cycpattern_check(string a, string b) {\n    // Concatenate the first word with itself\n    string concatenated = a + a;\n    // Check if the second word is a substring of the concatenated word\n    return concatenated.find(b) != string::npos;\n}\n\n"}
{"task_id": "CPP/115", "generation": "#include <vector>\n#include <cmath>\nusing namespace std;\n\nint max_fill(vector<vector<int>> grid, int capacity) {\n    int total_lowers = 0;\n    \n    // Iterate through each well (row in the grid)\n    for (const auto& well : grid) {\n        int water_units = 0;\n        \n        // Calculate the total water units in the current well\n        for (int unit : well) {\n            water_units += unit;\n        }\n        \n        // Calculate the number of times the bucket needs to be lowered for this well\n        int lowers = ceil(static_cast<double>(water_units) / capacity);\n        \n        // Add the number of lowers for this well to the total\n        total_lowers += lowers;\n    }\n    \n    return total_lowers;\n}\n\n// Example usage\n"}
{"task_id": "CPP/131", "generation": "#include <iostream>\nusing namespace std;\n\nint digits(int n) {\n    int product = 1;\n    bool hasOdd = false; // Flag to check if there is at least one odd digit\n\n    while (n > 0) {\n        int digit = n % 10; // Extract the last digit\n        if (digit % 2 != 0) { // Check if the digit is odd\n            product *= digit;\n            hasOdd = true;\n        }\n        n /= 10; // Remove the last digit\n    }\n\n    return hasOdd ? product : 0;\n}\n\n"}
{"task_id": "CPP/37", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<float> sort_even(vector<float> l) {\n    // Step 1: Extract elements at even indices\n    vector<float> even_elements;\n    for (size_t i = 0; i < l.size(); i += 2) {\n        even_elements.push_back(l[i]);\n    }\n\n    // Step 2: Sort the extracted elements\n    sort(even_elements.begin(), even_elements.end());\n\n    // Step 3: Replace elements at even indices in the original vector\n    for (size_t i = 0, j = 0; i < l.size(); i += 2, ++j) {\n        l[i] = even_elements[j];\n    }\n\n    // Step 4: Return the modified vector\n    return l;\n}\n\n// Function to test the sort_even function\nvoid test_sort_even() {\n    vector<float> test1 = {1, 2, 3};\n    vector<float> expected1 = {1, 2, 3};\n    assert(sort_even(test1) == expected1);\n\n    vector<float> test2 = {5, 6, 3, 4};\n    vector<float> expected2 = {3, 6, 5, 4};\n    assert(sort_even(test2) == expected2);\n\n    vector<float> test3 = {9, 8, 7, 6, 5, 4};\n    vector<float> expected3 = {5, 8, 7, 6, 9, 4};\n    assert(sort_even(test3) == expected3);\n\n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/92", "generation": "#include <iostream>\n#include <cmath>\n\nbool any_int(float a, float b, float c) {\n    // Check if all numbers are integers\n    if (floor(a) == a && floor(b) == b && floor(c) == c) {\n        // Check if any number is equal to the sum of the other two\n        if (a == b + c || b == a + c || c == a + b) {\n            return true;\n        }\n    }\n    return false;\n}\n\n"}
{"task_id": "CPP/118", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\n// Function to check if a character is a vowel\nbool is_vowel(char c) {\n    return c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ||\n           c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u';\n}\n\n// Function to check if a character is a consonant\nbool is_consonant(char c) {\n    return !is_vowel(c) && isalpha(c);\n}\n\n// Function to find the closest vowel between two consonants from the right side\nstring get_closest_vowel(const string& word) {\n    int n = word.length();\n    \n    // Iterate from the right side of the word\n    for (int i = n - 2; i > 0; --i) {\n        if (is_vowel(word[i]) && is_consonant(word[i - 1]) && is_consonant(word[i + 1])) {\n            return string(1, word[i]);\n        }\n    }\n    \n    // If no such vowel is found, return an empty string\n    return \"\";\n}\n\n"}
{"task_id": "CPP/6", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\nusing namespace std;\n\nvector<int> parse_nested_parens(string paren_string) {\n    vector<int> result;\n    stringstream ss(paren_string);\n    string group;\n\n    while (getline(ss, group, ' ')) {\n        int max_depth = 0;\n        int current_depth = 0;\n\n        for (char c : group) {\n            if (c == '(') {\n                current_depth++;\n                max_depth = max(max_depth, current_depth);\n            } else if (c == ')') {\n                current_depth--;\n            }\n        }\n\n        result.push_back(max_depth);\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/87", "generation": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\n// Function to compare two coordinates for sorting\nbool compare(const vector<int>& a, const vector<int>& b) {\n    if (a[0] == b[0]) {\n        // If the row is the same, sort by column in descending order\n        return a[1] > b[1];\n    }\n    // Otherwise, sort by row in ascending order\n    return a[0] < b[0];\n}\n\nvector<vector<int>> get_row(vector<vector<int>> lst, int x) {\n    vector<vector<int>> result;\n\n    // Iterate through each row\n    for (int i = 0; i < lst.size(); ++i) {\n        // Iterate through each element in the current row\n        for (int j = 0; j < lst[i].size(); ++j) {\n            // If the element matches x, add its coordinates to the result\n            if (lst[i][j] == x) {\n                result.push_back({i, j});\n            }\n        }\n    }\n\n    // Sort the result based on the custom comparator\n    sort(result.begin(), result.end(), compare);\n\n    return result;\n}\n\n// Example usage\n"}
{"task_id": "CPP/2", "generation": "#include <iostream>\n#include <cmath>\n\nfloat truncate_number(float number) {\n    // Extract the integer part of the number\n    float integer_part = floor(number);\n    \n    // Subtract the integer part from the original number to get the decimal part\n    float decimal_part = number - integer_part;\n    \n    return decimal_part;\n}\n\n"}
{"task_id": "CPP/16", "generation": "#include <iostream>\n#include <string>\n#include <set>\n#include <algorithm>\nusing namespace std;\n\nint count_distinct_characters(const string& str) {\n    // Convert the string to lowercase\n    string lower_str = str;\n    transform(lower_str.begin(), lower_str.end(), lower_str.begin(), ::tolower);\n\n    // Use a set to store unique characters\n    set<char> unique_chars(lower_str.begin(), lower_str.end());\n\n    // The size of the set is the number of distinct characters\n    return unique_chars.size();\n}\n\n// Function to test the solution\nvoid test() {\n    cout << count_distinct_characters(\"xyzXYZ\") << endl; // Output: 3\n    cout << count_distinct_characters(\"Jerry\") << endl;  // Output: 4\n}\n\n"}
{"task_id": "CPP/135", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint can_arrange(vector<int> arr) {\n    // Start from the second last element and move backwards\n    for (int i = arr.size() - 1; i > 0; --i) {\n        if (arr[i] < arr[i - 1]) {\n            return i;\n        }\n    }\n    // If no such element is found, return -1\n    return -1;\n}\n\n// Function to test the can_arrange function\nvoid test_can_arrange() {\n    vector<int> test1 = {1, 2, 4, 3, 5};\n    vector<int> test2 = {1, 2, 3};\n    vector<int> test3 = {5, 4, 3, 2, 1};\n\n    cout << \"can_arrange({1, 2, 4, 3, 5}) = \" << can_arrange(test1) << \" (Expected: 3)\" << endl;\n    cout << \"can_arrange({1, 2, 3}) = \" << can_arrange(test2) << \" (Expected: -1)\" << endl;\n    cout << \"can_arrange({5, 4, 3, 2, 1}) = \" << can_arrange(test3) << \" (Expected: 1)\" << endl;\n}\n\n"}
{"task_id": "CPP/106", "generation": "#include <iostream>\n#include <vector>\n\n// Function to calculate the factorial of a number\nint factorial(int num) {\n    int result = 1;\n    for (int i = 1; i <= num; ++i) {\n        result *= i;\n    }\n    return result;\n}\n\n// Function to calculate the sum of numbers from 1 to num\nint sumTo(int num) {\n    return (num * (num + 1)) / 2;\n}\n\n// Main function to generate the vector\nvector<int> f(int n) {\n    vector<int> result(n);\n    for (int i = 1; i <= n; ++i) {\n        if (i % 2 == 0) {\n            // If i is even, store the factorial of i\n            result[i - 1] = factorial(i);\n        } else {\n            // If i is odd, store the sum of numbers from 1 to i\n            result[i - 1] = sumTo(i);\n        }\n    }\n    return result;\n}\n\n// Function to test the implementation\nvoid test() {\n    vector<int> result = f(5);\n    for (int num : result) {\n        std::cout << num << \" \";\n    }\n    std::cout << std::endl;\n}\n\n"}
{"task_id": "CPP/162", "generation": "#include <iostream>\n#include <string>\n#include <openssl/md5.h>\n#include <iomanip>\n#include <sstream>\n\nusing namespace std;\n\nstring string_to_md5(string text) {\n    if (text.empty()) {\n        return \"None\";\n    }\n\n    unsigned char digest[MD5_DIGEST_LENGTH];\n    MD5((unsigned char*)text.c_str(), text.length(), (unsigned char*)&digest);    \n\n    stringstream ss;\n    for (int i = 0; i < MD5_DIGEST_LENGTH; i++) {\n        ss << hex << setw(2) << setfill('0') << (int)digest[i];\n    }\n\n    return ss.str();\n}\n\n"}
{"task_id": "CPP/5", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> intersperse(vector<int> numbers, int delimiter) {\n    vector<int> result;\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        result.push_back(numbers[i]);\n        if (i < numbers.size() - 1) {\n            result.push_back(delimiter);\n        }\n    }\n    return result;\n}\n\n// Function to print the vector for testing\nvoid printVector(const vector<int>& vec) {\n    cout << \"{\";\n    for (size_t i = 0; i < vec.size(); ++i) {\n        cout << vec[i];\n        if (i < vec.size() - 1) {\n            cout << \", \";\n        }\n    }\n    cout << \"}\" << endl;\n}\n\n"}
{"task_id": "CPP/97", "generation": "#include <iostream>\nusing namespace std;\n\nint multiply(int a, int b) {\n    // Extract the unit digit of both numbers\n    int unitDigitA = abs(a) % 10;\n    int unitDigitB = abs(b) % 10;\n\n    // Return the product of the unit digits\n    return unitDigitA * unitDigitB;\n}\n\n// Function to test the multiply function\nvoid testMultiply() {\n    cout << \"Test 1: \" << (multiply(148, 412) == 16 ? \"Passed\" : \"Failed\") << endl;\n    cout << \"Test 2: \" << (multiply(19, 28) == 72 ? \"Passed\" : \"Failed\") << endl;\n    cout << \"Test 3: \" << (multiply(2020, 1851) == 0 ? \"Passed\" : \"Failed\") << endl;\n    cout << \"Test 4: \" << (multiply(14, -15) == 20 ? \"Passed\" : \"Failed\") << endl;\n}\n\n"}
{"task_id": "CPP/44", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nstring change_base(int x, int base) {\n    if (base < 2 || base > 9) {\n        throw invalid_argument(\"Base must be between 2 and 9\");\n    }\n\n    string result = \"\";\n    while (x > 0) {\n        int remainder = x % base;\n        result += to_string(remainder);\n        x /= base;\n    }\n\n    // Reverse the result since we've built it backwards\n    reverse(result.begin(), result.end());\n\n    return result.empty() ? \"0\" : result;\n}\n\n"}
{"task_id": "CPP/161", "generation": "#include <iostream>\n#include <string>\n#include <cctype> // for isalpha and tolower/toupper functions\n\nusing namespace std;\n\nstring solve(string s) {\n    bool hasLetter = false;\n    \n    // Check if the string contains any letters\n    for (char c : s) {\n        if (isalpha(c)) {\n            hasLetter = true;\n            break;\n        }\n    }\n\n    // If the string contains no letters, reverse the string\n    if (!hasLetter) {\n        reverse(s.begin(), s.end());\n        return s;\n    }\n\n    // If the string contains letters, reverse their case\n    for (char &c : s) {\n        if (isalpha(c)) {\n            if (islower(c)) {\n                c = toupper(c);\n            } else {\n                c = tolower(c);\n            }\n        }\n    }\n\n    return s;\n}\n\n"}
{"task_id": "CPP/38", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring encode_cyclic(string s) { \n    // returns encoded string by cycling groups of three characters.  \n    // split string to groups. Each of length 3.\n    int l = s.length();\n    int num = (l + 2) / 3;\n    string x, output;\n    for (int i = 0; i * 3 < l; i++) {\n        // cycle elements in each group. Unless group has fewer elements than 3.\n        x = s.substr(i * 3, 3);\n        if (x.length() == 3) x = x.substr(1) + x[0];\n        output += x;\n    }\n    return output;\n}\n\nstring decode_cyclic(string s) { \n    // takes as input string encoded with encode_cyclic function. Returns decoded string. \n    int l = s.length();\n    int num = (l + 2) / 3;\n    string x, output;\n    for (int i = 0; i * 3 < l; i++) {\n        // reverse the cyclic shift for each group of three characters\n        x = s.substr(i * 3, 3);\n        if (x.length() == 3) x = x[2] + x.substr(0, 2);\n        output += x;\n    }\n    return output;\n}\n\n"}
{"task_id": "CPP/93", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nstring encode(string message) {\n    // Vowel mapping\n    const unordered_map<char, char> vowel_map = {\n        {'a', 'c'}, {'e', 'g'}, {'i', 'k'}, {'o', 'q'}, {'u', 'w'},\n        {'A', 'C'}, {'E', 'G'}, {'I', 'K'}, {'O', 'Q'}, {'U', 'W'}\n    };\n\n    string encoded_message;\n    for (char ch : message) {\n        if (isalpha(ch)) {\n            if (vowel_map.find(ch) != vowel_map.end()) {\n                // Replace vowel with the mapped character\n                encoded_message += vowel_map.at(ch);\n            } else {\n                // Swap case for non-vowel alphabetic characters\n                if (islower(ch)) {\n                    encoded_message += toupper(ch);\n                } else {\n                    encoded_message += tolower(ch);\n                }\n            }\n        } else {\n            // Non-alphabetic characters remain unchanged\n            encoded_message += ch;\n        }\n    }\n\n    return encoded_message;\n}\n\n// Function to test the encode function\nvoid test_encode() {\n    cout << encode(\"test\") << endl; // Expected: \"TGST\"\n    cout << encode(\"This is a message\") << endl; // Expected: \"tHKS KS C MGSSCGG\"\n}\n\n"}
{"task_id": "CPP/152", "generation": "#include <iostream>\n#include <vector>\n#include <cmath> // For std::abs\n\nusing namespace std;\n\nvector<int> compare(vector<int> game, vector<int> guess) {\n    vector<int> result;\n    for (size_t i = 0; i < game.size(); ++i) {\n        int difference = abs(game[i] - guess[i]);\n        result.push_back(difference);\n    }\n    return result;\n}\n\n// Function to test the compare function\nvoid test_compare() {\n    vector<int> game1 = {1, 2, 3, 4, 5, 1};\n    vector<int> guess1 = {1, 2, 3, 4, 2, -2};\n    vector<int> expected1 = {0, 0, 0, 0, 3, 3};\n    assert(compare(game1, guess1) == expected1);\n\n    vector<int> game2 = {0, 5, 0, 0, 0, 4};\n    vector<int> guess2 = {4, 1, 1, 0, 0, -2};\n    vector<int> expected2 = {4, 4, 1, 0, 0, 6};\n    assert(compare(game2, guess2) == expected2);\n\n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/62", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<float> derivative(vector<float> xs) {\n    vector<float> result;\n    for (size_t i = 1; i < xs.size(); ++i) {\n        result.push_back(i * xs[i]);\n    }\n    return result;\n}\n\n"}
{"task_id": "CPP/7", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> filter_by_substring(vector<string> strings, string substring) {\n    vector<string> result;\n    for (const auto& str : strings) {\n        if (str.find(substring) != string::npos) {\n            result.push_back(str);\n        }\n    }\n    return result;\n}\n\n// Function to test the filter_by_substring function\nvoid test_filter_by_substring() {\n    vector<string> test1 = {};\n    vector<string> expected1 = {};\n    assert(filter_by_substring(test1, \"a\") == expected1);\n\n    vector<string> test2 = {\"abc\", \"bacd\", \"cde\", \"vector\"};\n    vector<string> expected2 = {\"abc\", \"bacd\", \"vector\"};\n    assert(filter_by_substring(test2, \"a\") == expected2);\n\n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/24", "generation": "#include <iostream>\nusing namespace std;\n\nint largest_divisor(int n) {\n    // Start from n-1 and go down to 1\n    for (int i = n - 1; i > 0; --i) {\n        if (n % i == 0) {\n            return i; // i is the largest divisor of n that is smaller than n\n        }\n    }\n    return 1; // If no divisor is found, return 1 (every number is divisible by 1)\n}\n\n"}
{"task_id": "CPP/79", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring decimal_to_binary(int decimal) {\n    if (decimal == 0) {\n        return \"db0db\";\n    }\n\n    string binary = \"\";\n    while (decimal > 0) {\n        binary = to_string(decimal % 2) + binary;\n        decimal /= 2;\n    }\n\n    return \"db\" + binary + \"db\";\n}\n\n"}
{"task_id": "CPP/155", "generation": "#include <iostream>\n#include <cmath>\n#include <string>\n#include <vector>\nusing namespace std;\n\nvector<int> even_odd_count(int num) {\n    // Handle negative numbers\n    num = abs(num);\n    \n    // Convert the number to a string\n    string num_str = to_string(num);\n    \n    // Initialize counters for even and odd digits\n    int even_count = 0;\n    int odd_count = 0;\n    \n    // Iterate through each digit in the string\n    for (char digit : num_str) {\n        int digit_value = digit - '0'; // Convert char to int\n        if (digit_value % 2 == 0) {\n            even_count++;\n        } else {\n            odd_count++;\n        }\n    }\n    \n    // Return the result as a vector\n    return {even_count, odd_count};\n}\n\n// Function to test the even_odd_count function\nvoid test_even_odd_count() {\n    vector<int> result1 = even_odd_count(-12);\n    cout << \"even_odd_count(-12) ==> {\" << result1[0] << \", \" << result1[1] << \"}\" << endl;\n    \n    vector<int> result2 = even_odd_count(123);\n    cout << \"even_odd_count(123) ==> {\" << result2[0] << \", \" << result2[1] << \"}\" << endl;\n}\n\n"}
{"task_id": "CPP/4", "generation": "#include <iostream>\n#include <vector>\n#include <numeric> // for std::accumulate\n\nusing namespace std;\n\nfloat mean_absolute_deviation(vector<float> numbers) {\n    if (numbers.empty()) return 0.0f; // Handle empty vector case\n\n    // Step 1: Calculate the mean of the dataset\n    float sum = accumulate(numbers.begin(), numbers.end(), 0.0f);\n    float mean = sum / numbers.size();\n\n    // Step 2: Compute the absolute differences between each element and the mean\n    float total_abs_diff = 0.0f;\n    for (float num : numbers) {\n        total_abs_diff += abs(num - mean);\n    }\n\n    // Step 3: Calculate the average of these absolute differences\n    float mad = total_abs_diff / numbers.size();\n\n    return mad;\n}\n\n"}
{"task_id": "CPP/56", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool correct_bracketing(const string& brackets) {\n    int counter = 0;\n    for (char c : brackets) {\n        if (c == '<') {\n            counter++;\n        } else if (c == '>') {\n            counter--;\n            if (counter < 0) {\n                return false; // More closing brackets than opening ones\n            }\n        }\n    }\n    return counter == 0; // All brackets must be closed\n}\n\n"}
{"task_id": "CPP/159", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvector<int> eat(int number, int need, int remaining) {\n    // Calculate the total number of carrots eaten after the meal\n    int total_eaten = number + min(need, remaining);\n    \n    // Calculate the number of carrots left after the meal\n    int carrots_left = max(0, remaining - need);\n    \n    // Return the results as a vector\n    return {total_eaten, carrots_left};\n}\n\n"}
{"task_id": "CPP/83", "generation": "#include <iostream>\n#include <cmath>\n\nint starts_one_ends(int n) {\n    if (n == 1) {\n        return 1; // Only one 1-digit number that starts or ends with 1\n    }\n    \n    int count_start_with_1 = pow(10, n - 1);\n    int count_end_with_1 = 9 * pow(10, n - 2);\n    int count_start_and_end_with_1 = pow(10, n - 2);\n    \n    return count_start_with_1 + count_end_with_1 - count_start_and_end_with_1;\n}\n\n"}
{"task_id": "CPP/27", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring flip_case(string str) {\n    for (char &c : str) {\n        if (islower(c)) {\n            c = toupper(c);\n        } else if (isupper(c)) {\n            c = tolower(c);\n        }\n    }\n    return str;\n}\n\n"}
{"task_id": "CPP/146", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\nusing namespace std;\n\n// Function to check if a digit is odd\nbool isOdd(int digit) {\n    return digit % 2 != 0;\n}\n\n// Function to get the first digit of a number\nint getFirstDigit(int num) {\n    while (num >= 10) {\n        num /= 10;\n    }\n    return abs(num); // Ensure it's positive\n}\n\n// Function to get the last digit of a number\nint getLastDigit(int num) {\n    return abs(num) % 10; // Ensure it's positive\n}\n\n// Main function to filter the numbers\nint specialFilter(vector<int> nums) {\n    int count = 0;\n    for (int num : nums) {\n        if (num > 10 && isOdd(getFirstDigit(num)) && isOdd(getLastDigit(num))) {\n            count++;\n        }\n    }\n    return count;\n}\n\n// Function to test the specialFilter function\nvoid testSpecialFilter() {\n    vector<int> test1 = {15, -73, 14, -15};\n    vector<int> test2 = {33, -2, -3, 45, 21, 109};\n    \n    cout << \"Test 1: Expected 1, Got \" << specialFilter(test1) << endl;\n    cout << \"Test 2: Expected 2, Got \" << specialFilter(test2) << endl;\n}\n\n"}
{"task_id": "CPP/81", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\nvector<string> numerical_letter_grade(vector<float> grades) {\n    // Define the GPA to letter grade mapping\n    map<float, string, greater<float>> grade_map = {\n        {4.0, \"A+\"},\n        {3.7, \"A\"},\n        {3.3, \"A-\"},\n        {3.0, \"B+\"},\n        {2.7, \"B\"},\n        {2.3, \"B-\"},\n        {2.0, \"C+\"},\n        {1.7, \"C\"},\n        {1.3, \"C-\"},\n        {1.0, \"D+\"},\n        {0.7, \"D\"},\n        {0.0, \"D-\"}\n    };\n\n    vector<string> letter_grades;\n\n    // Iterate through each GPA in the input list\n    for (float gpa : grades) {\n        // Determine the letter grade\n        for (auto it = grade_map.begin(); it != grade_map.end(); ++it) {\n            if (gpa >= it->first) {\n                letter_grades.push_back(it->second);\n                break;\n            }\n        }\n        // If no condition is met, the GPA is less than 0.0, assign 'E'\n        if (letter_grades.empty() || letter_grades.back().empty()) {\n            letter_grades.push_back(\"E\");\n        }\n    }\n\n    return letter_grades;\n}\n\n// Function to test the grading function\nvoid test_numerical_letter_grade() {\n    vector<float> grades = {4.0, 3.0, 1.7, 2.0, 3.5};\n    vector<string> expected = {\"A+\", \"B+\", \"C\", \"C+\", \"A-\"};\n    vector<string> result = numerical_letter_grade(grades);\n\n    if (result == expected) {\n        cout << \"Test passed!\" << endl;\n    } else {\n        cout << \"Test failed!\" << endl;\n        cout << \"Expected: \";\n        for (const auto& grade : expected) {\n            cout << grade << \" \";\n        }\n        cout << endl << \"Got: \";\n        for (const auto& grade : result) {\n            cout << grade << \" \";\n        }\n        cout << endl;\n    }\n}\n\n"}
{"task_id": "CPP/136", "generation": "#include <vector>\n#include <limits>\n#include <algorithm>\nusing namespace std;\n\nvector<int> largest_smallest_integers(vector<int> lst) {\n    int largest_negative = numeric_limits<int>::min();\n    int smallest_positive = numeric_limits<int>::max();\n    \n    for (int num : lst) {\n        if (num < 0) {\n            largest_negative = max(largest_negative, num);\n        } else if (num > 0) {\n            smallest_positive = min(smallest_positive, num);\n        }\n    }\n    \n    // If no negative or positive integers were found, set them to 0\n    if (largest_negative == numeric_limits<int>::min()) {\n        largest_negative = 0;\n    }\n    if (smallest_positive == numeric_limits<int>::max()) {\n        smallest_positive = 0;\n    }\n    \n    return {largest_negative, smallest_positive};\n}\n\n// Example usage\n#include <iostream>\n"}
{"task_id": "CPP/67", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <stdexcept>\n\nint fruit_distribution(const std::string& s, int n) {\n    // Parse the input string to extract the number of apples and oranges\n    std::istringstream iss(s);\n    int apples, oranges;\n    std::string temp;\n\n    // Read the number of apples\n    iss >> apples >> temp >> temp >> temp >> oranges >> temp;\n\n    // Check if the parsing was successful\n    if (iss.fail() || temp != \"oranges\") {\n        throw std::invalid_argument(\"Input string does not match the expected format.\");\n    }\n\n    // Calculate the number of mangoes\n    int mangoes = n - (apples + oranges);\n\n    return mangoes;\n}\n\n"}
{"task_id": "CPP/48", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_palindrome(string text) {\n    int left = 0;\n    int right = text.length() - 1;\n\n    while (left < right) {\n        if (text[left] != text[right]) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n    return true;\n}\n\n"}
{"task_id": "CPP/125", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <cctype>\nusing namespace std;\n\nvector<string> split_words(string txt) {\n    // Check for whitespace\n    if (txt.find(' ') != string::npos) {\n        stringstream ss(txt);\n        vector<string> words;\n        string word;\n        while (ss >> word) {\n            words.push_back(word);\n        }\n        return words;\n    }\n    // Check for commas\n    else if (txt.find(',') != string::npos) {\n        stringstream ss(txt);\n        vector<string> words;\n        string word;\n        while (getline(ss, word, ',')) {\n            words.push_back(word);\n        }\n        return words;\n    }\n    else {\n        // Count the number of lowercase letters with odd order in the alphabet\n        int count = 0;\n        for (char c : txt) {\n            if (islower(c) && ((c - 'a') % 2 == 1)) {\n                count++;\n            }\n        }\n        return {to_string(count)};\n    }\n}\n\n// Function to test the split_words function\nvoid test_split_words() {\n    vector<string> result1 = split_words(\"Hello world!\");\n    vector<string> expected1 = {\"Hello\", \"world!\"};\n    assert(result1 == expected1);\n\n    vector<string> result2 = split_words(\"Hello,world!\");\n    vector<string> expected2 = {\"Hello\", \"world!\"};\n    assert(result2 == expected2);\n\n    vector<string> result3 = split_words(\"abcdef\");\n    vector<string> expected3 = {\"3\"};\n    assert(result3 == expected3);\n\n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/160", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\nusing namespace std;\n\nint do_algebra(vector<string> operators, vector<int> operands) {\n    // Initialize the result with the first operand\n    int result = operands[0];\n    \n    // Iterate through the operators and apply them to the corresponding operands\n    for (size_t i = 0; i < operators.size(); ++i) {\n        string op = operators[i];\n        int next_operand = operands[i + 1];\n        \n        if (op == \"+\") {\n            result += next_operand;\n        } else if (op == \"-\") {\n            result -= next_operand;\n        } else if (op == \"*\") {\n            result *= next_operand;\n        } else if (op == \"//\") {\n            result /= next_operand; // C++ uses / for integer division, which is equivalent to floor division for positive integers\n        } else if (op == \"**\") {\n            result = pow(result, next_operand);\n        }\n    }\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/151", "generation": "#include <vector>\n#include <cmath>\nusing namespace std;\n\nlong long double_the_difference(vector<float> lst) {\n    long long sum = 0;\n    for (float num : lst) {\n        // Check if the number is a positive integer and odd\n        if (num > 0 && floor(num) == num && static_cast<int>(num) % 2 != 0) {\n            sum += static_cast<long long>(num) * static_cast<long long>(num);\n        }\n    }\n    return sum;\n}\n\n// Example usage:\n"}
{"task_id": "CPP/117", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\nusing namespace std;\n\nbool is_consonant(char c) {\n    string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    return consonants.find(c) != string::npos;\n}\n\nint count_consonants(const string& word) {\n    int count = 0;\n    for (char c : word) {\n        if (is_consonant(c)) {\n            count++;\n        }\n    }\n    return count;\n}\n\nvector<string> select_words(string s, int n) {\n    vector<string> result;\n    stringstream ss(s);\n    string word;\n    while (ss >> word) {\n        if (count_consonants(word) == n) {\n            result.push_back(word);\n        }\n    }\n    return result;\n}\n\n// Test cases\n"}
{"task_id": "CPP/78", "generation": "#include <iostream>\n#include <string>\n#include <unordered_set>\n\nusing namespace std;\n\nint hex_key(string num) {\n    // Define the set of prime hexadecimal digits\n    unordered_set<char> prime_hex_digits = {'2', '3', '5', '7', 'B', 'D'};\n    \n    int count = 0;\n    \n    // Iterate through each character in the input string\n    for (char c : num) {\n        // Check if the character is a prime hexadecimal digit\n        if (prime_hex_digits.find(c) != prime_hex_digits.end()) {\n            count++;\n        }\n    }\n    \n    return count;\n}\n\n// Function to test the hex_key function\nvoid test_hex_key() {\n    cout << hex_key(\"AB\") << \" (Expected: 1)\" << endl;\n    cout << hex_key(\"1077E\") << \" (Expected: 2)\" << endl;\n    cout << hex_key(\"ABED1A33\") << \" (Expected: 4)\" << endl;\n    cout << hex_key(\"123456789ABCDEF0\") << \" (Expected: 6)\" << endl;\n    cout << hex_key(\"2020\") << \" (Expected: 2)\" << endl;\n}\n\n"}
{"task_id": "CPP/74", "generation": "#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to calculate the total number of characters in a vector of strings\nint total_chars(const vector<string>& vec) {\n    int total = 0;\n    for (const auto& str : vec) {\n        total += str.length();\n    }\n    return total;\n}\n\n// Function to compare two vectors and return the one with fewer total characters\nvector<string> total_match(vector<string> lst1, vector<string> lst2) {\n    int total1 = total_chars(lst1);\n    int total2 = total_chars(lst2);\n\n    if (total1 <= total2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n"}
{"task_id": "CPP/53", "generation": "#include <iostream>\nusing namespace std;\n\n// Function to add two integers\nint add(int x, int y) {\n    return x + y;\n}\n\n// Main function to test the add function\n"}
{"task_id": "CPP/98", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint count_upper(const string& s) {\n    int count = 0;\n    for (size_t i = 0; i < s.length(); i += 2) { // Iterate over even indices\n        char c = s[i];\n        if (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n            count++;\n        }\n    }\n    return count;\n}\n\n"}
{"task_id": "CPP/140", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring fix_spaces(string text) {\n    string result;\n    int space_count = 0;\n\n    for (char ch : text) {\n        if (ch == ' ') {\n            space_count++;\n        } else {\n            if (space_count > 2) {\n                result += '-';\n            } else if (space_count > 0) {\n                result.append(space_count, '_');\n            }\n            space_count = 0;\n            result += ch;\n        }\n    }\n\n    // Handle trailing spaces\n    if (space_count > 2) {\n        result += '-';\n    } else if (space_count > 0) {\n        result.append(space_count, '_');\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/34", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> unique(vector<int> l) {\n    // Step 1: Sort the vector\n    sort(l.begin(), l.end());\n    \n    // Step 2: Remove duplicates\n    auto new_end = unique(l.begin(), l.end());\n    \n    // Step 3: Resize the vector to remove the extra elements\n    l.erase(new_end, l.end());\n    \n    return l;\n}\n\n"}
{"task_id": "CPP/66", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint digitSum(string s) {\n    int sum = 0;\n    for (char c : s) {\n        if (isupper(c)) {\n            sum += c;\n        }\n    }\n    return sum;\n}\n\n// Function to test the digitSum function\nvoid testDigitSum() {\n    cout << \"Testing digitSum function:\" << endl;\n    cout << \"digitSum(\\\"\\\") => \" << digitSum(\"\") << \" (Expected: 0)\" << endl;\n    cout << \"digitSum(\\\"abAB\\\") => \" << digitSum(\"abAB\") << \" (Expected: 131)\" << endl;\n    cout << \"digitSum(\\\"abcCd\\\") => \" << digitSum(\"abcCd\") << \" (Expected: 67)\" << endl;\n    cout << \"digitSum(\\\"helloE\\\") => \" << digitSum(\"helloE\") << \" (Expected: 69)\" << endl;\n    cout << \"digitSum(\\\"woArBld\\\") => \" << digitSum(\"woArBld\") << \" (Expected: 131)\" << endl;\n    cout << \"digitSum(\\\"aAaaaXa\\\") => \" << digitSum(\"aAaaaXa\") << \" (Expected: 153)\" << endl;\n}\n\n"}
{"task_id": "CPP/120", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> maximum(vector<int> arr, int k) {\n    // Step 1: Sort the vector in ascending order\n    sort(arr.begin(), arr.end());\n    \n    // Step 2: Extract the last k elements\n    vector<int> result;\n    if (k > 0) {\n        result.assign(arr.end() - k, arr.end());\n    }\n    \n    // Step 3: Return the result\n    return result;\n}\n\n// Function to test the solution\nvoid test() {\n    vector<int> arr1 = {-3, -4, 5};\n    int k1 = 3;\n    vector<int> result1 = maximum(arr1, k1);\n    for (int num : result1) {\n        cout << num << \" \";\n    }\n    cout << endl; // Output: -4 -3 5\n\n    vector<int> arr2 = {4, -4, 4};\n    int k2 = 2;\n    vector<int> result2 = maximum(arr2, k2);\n    for (int num : result2) {\n        cout << num << \" \";\n    }\n    cout << endl; // Output: 4 4\n\n    vector<int> arr3 = {-3, 2, 1, 2, -1, -2, 1};\n    int k3 = 1;\n    vector<int> result3 = maximum(arr3, k3);\n    for (int num : result3) {\n        cout << num << \" \";\n    }\n    cout << endl; // Output: 2\n}\n\n"}
{"task_id": "CPP/139", "generation": "#include <iostream>\nusing namespace std;\n\n// Helper function to compute the factorial of a single number\nlong long factorial(int num) {\n    if (num == 0 || num == 1) {\n        return 1;\n    }\n    long long result = 1;\n    for (int i = 2; i <= num; ++i) {\n        result *= i;\n    }\n    return result;\n}\n\n// Function to compute the Brazilian factorial\nlong long special_factorial(int n) {\n    long long result = 1;\n    for (int i = 1; i <= n; ++i) {\n        result *= factorial(i);\n    }\n    return result;\n}\n\n// Main function to test the special_factorial function\n"}
{"task_id": "CPP/12", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring longest(vector<string> strings) {\n    if (strings.empty()) {\n        return \"\"; // Return an empty string to represent None\n    }\n\n    size_t max_length = 0;\n    string longest_string = \"\";\n\n    for (const string& s : strings) {\n        if (s.length() > max_length) {\n            max_length = s.length();\n            longest_string = s;\n        }\n    }\n\n    return longest_string;\n}\n\n"}
{"task_id": "CPP/121", "generation": "#include <vector>\nusing namespace std;\n\nint solution(vector<int> lst) {\n    int sum = 0;\n    // Iterate through the vector, considering only even indices\n    for (size_t i = 0; i < lst.size(); i += 2) {\n        // Check if the element at the current even index is odd\n        if (lst[i] % 2 != 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n"}
{"task_id": "CPP/35", "generation": "#include <iostream>\n#include <vector>\n#include <climits> // For INT_MIN\nusing namespace std;\n\nfloat max_element(vector<float> l) {\n    if (l.empty()) {\n        throw runtime_error(\"Vector is empty\");\n    }\n    \n    float max_val = l[0]; // Initialize max_val with the first element of the vector\n    for (float num : l) {\n        if (num > max_val) {\n            max_val = num; // Update max_val if a larger element is found\n        }\n    }\n    return max_val;\n}\n\n"}
{"task_id": "CPP/20", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // For sort()\n#include <cmath>     // For fabs()\n\nusing namespace std;\n\nvector<float> find_closest_elements(vector<float> numbers) {\n    // Ensure the vector has at least two elements\n    if (numbers.size() < 2) {\n        throw invalid_argument(\"Vector must contain at least two elements\");\n    }\n\n    // Sort the vector\n    sort(numbers.begin(), numbers.end());\n\n    // Initialize variables to store the closest pair and the minimum difference\n    float min_diff = FLT_MAX; // Use FLT_MAX from <cfloat> for maximum floating-point value\n    vector<float> closest_pair(2);\n\n    // Iterate through the sorted vector to find the closest pair\n    for (size_t i = 0; i < numbers.size() - 1; ++i) {\n        float diff = fabs(numbers[i + 1] - numbers[i]);\n        if (diff < min_diff) {\n            min_diff = diff;\n            closest_pair[0] = numbers[i];\n            closest_pair[1] = numbers[i + 1];\n        }\n    }\n\n    return closest_pair;\n}\n\n// Function to test the solution\nvoid test_find_closest_elements() {\n    vector<float> result1 = find_closest_elements({1.0, 2.0, 3.0, 4.0, 5.0, 2.2});\n    cout << \"(\" << result1[0] << \", \" << result1[1] << \")\" << endl; // Expected: (2.0, 2.2)\n\n    vector<float> result2 = find_closest_elements({1.0, 2.0, 3.0, 4.0, 5.0, 2.0});\n    cout << \"(\" << result2[0] << \", \" << result2[1] << \")\" << endl; // Expected: (2.0, 2.0)\n}\n\n"}
{"task_id": "CPP/19", "generation": "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <map>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to sort the numbers represented as words\nstring sort_numbers(string numbers) {\n    // Mapping of number words to their numeric values\n    map<string, int> number_map = {\n        {\"zero\", 0}, {\"one\", 1}, {\"two\", 2}, {\"three\", 3},\n        {\"four\", 4}, {\"five\", 5}, {\"six\", 6}, {\"seven\", 7},\n        {\"eight\", 8}, {\"nine\", 9}\n    };\n\n    // Vector to store the words\n    vector<string> words;\n    stringstream ss(numbers);\n    string word;\n\n    // Split the input string into words\n    while (ss >> word) {\n        words.push_back(word);\n    }\n\n    // Sort the words based on their numeric values\n    sort(words.begin(), words.end(), [&](const string &a, const string &b) {\n        return number_map[a] < number_map[b];\n    });\n\n    // Join the sorted words back into a single string\n    string result;\n    for (size_t i = 0; i < words.size(); ++i) {\n        if (i > 0) {\n            result += \" \";\n        }\n        result += words[i];\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/85", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint add(vector<int> lst) {\n    int sum = 0;\n    // Start from index 1 (second element) and increment by 2 to check only odd indices\n    for (int i = 1; i < lst.size(); i += 2) {\n        if (lst[i] % 2 == 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n\n// Function to test the add function\nvoid test() {\n    vector<int> test1 = {4, 2, 6, 7};\n    cout << \"Test 1: \" << (add(test1) == 2 ? \"Passed\" : \"Failed\") << endl;\n\n    vector<int> test2 = {1, 3, 5, 7, 9, 11};\n    cout << \"Test 2: \" << (add(test2) == 0 ? \"Passed\" : \"Failed\") << endl;\n\n    vector<int> test3 = {2, 4, 6, 8, 10};\n    cout << \"Test 3: \" << (add(test3) == 12 ? \"Passed\" : \"Failed\") << endl;\n\n    vector<int> test4 = {0, -2, -4, -6, -8};\n    cout << \"Test 4: \" << (add(test4) == -8 ? \"Passed\" : \"Failed\") << endl;\n}\n\n"}
{"task_id": "CPP/21", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\nvector<float> rescale_to_unit(vector<float> numbers) {\n    if (numbers.size() < 2) {\n        throw invalid_argument(\"Vector must contain at least two elements.\");\n    }\n\n    // Find the minimum and maximum values in the vector\n    float min_val = *min_element(numbers.begin(), numbers.end());\n    float max_val = *max_element(numbers.begin(), numbers.end());\n\n    // Compute the range\n    float range = max_val - min_val;\n\n    // Apply the linear transformation\n    vector<float> scaled_numbers;\n    for (float num : numbers) {\n        scaled_numbers.push_back((num - min_val) / range);\n    }\n\n    return scaled_numbers;\n}\n\n"}
{"task_id": "CPP/119", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to check if a string is balanced\nbool is_balanced(const string& s) {\n    int balance = 0;\n    for (char c : s) {\n        if (c == '(') {\n            balance++;\n        } else if (c == ')') {\n            balance--;\n        }\n        if (balance < 0) {\n            return false; // Early exit if imbalance is detected\n        }\n    }\n    return balance == 0;\n}\n\n// Function to check if concatenating the two strings in some order results in a balanced string\nstring match_parens(vector<string> lst) {\n    string str1 = lst[0];\n    string str2 = lst[1];\n\n    // Check both possible concatenations\n    if (is_balanced(str1 + str2) || is_balanced(str2 + str1)) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\n\n// Main function to test the solution\n"}
{"task_id": "CPP/30", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<float> get_positive(vector<float> l) {\n    vector<float> result;\n    for (float num : l) {\n        if (num > 0) {\n            result.push_back(num);\n        }\n    }\n    return result;\n}\n\n// Function to print the vector for testing purposes\nvoid print_vector(const vector<float>& vec) {\n    cout << \"{\";\n    for (size_t i = 0; i < vec.size(); ++i) {\n        cout << vec[i];\n        if (i != vec.size() - 1) {\n            cout << \", \";\n        }\n    }\n    cout << \"}\" << endl;\n}\n\n"}
{"task_id": "CPP/64", "generation": "#include <iostream>\n#include <string>\n#include <cctype> // for tolower function\n\nusing namespace std;\n\nint vowels_count(const string& s) {\n    int count = 0;\n    string vowels = \"aeiou\";\n    \n    for (size_t i = 0; i < s.length(); ++i) {\n        char c = tolower(s[i]); // Convert character to lowercase for case-insensitive comparison\n        if (vowels.find(c) != string::npos) {\n            count++;\n        }\n    }\n    \n    // Check if the last character is 'y' and add to count if true\n    if (!s.empty() && tolower(s.back()) == 'y') {\n        count++;\n    }\n    \n    return count;\n}\n\n"}
{"task_id": "CPP/128", "generation": "#include <vector>\n#include <cmath>\nusing namespace std;\n\nint prod_signs(vector<int> arr) {\n    if (arr.empty()) {\n        return -32768;\n    }\n\n    int sum_of_magnitudes = 0;\n    int product_of_signs = 1;\n\n    for (int num : arr) {\n        if (num == 0) {\n            product_of_signs = 0;\n            break;\n        }\n        sum_of_magnitudes += abs(num);\n        product_of_signs *= (num > 0) ? 1 : -1;\n    }\n\n    return sum_of_magnitudes * product_of_signs;\n}\n\n// Example usage\n"}
{"task_id": "CPP/127", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nbool is_prime(int n) {\n    if (n <= 1) {\n        return false;\n    }\n    if (n <= 3) {\n        return true;\n    }\n    if (n % 2 == 0 || n % 3 == 0) {\n        return false;\n    }\n    for (int i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nstring intersection(vector<int> interval1, vector<int> interval2) {\n    int start1 = interval1[0], end1 = interval1[1];\n    int start2 = interval2[0], end2 = interval2[1];\n\n    // Calculate the intersection\n    int start_inter = max(start1, start2);\n    int end_inter = min(end1, end2);\n\n    // Check if there is no intersection\n    if (start_inter > end_inter) {\n        return \"NO\";\n    }\n\n    // Calculate the length of the intersection\n    int length_inter = end_inter - start_inter + 1;\n\n    // Check if the length is a prime number\n    if (is_prime(length_inter)) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n\n"}
{"task_id": "CPP/122", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint add_elements(vector<int> arr, int k) {\n    int sum = 0;\n    for (int i = 0; i < k; ++i) {\n        // Check if the current element has at most two digits\n        if (arr[i] >= -99 && arr[i] <= 99) {\n            sum += arr[i];\n        }\n    }\n    return sum;\n}\n\n// Function to test the solution\nvoid test_add_elements() {\n    vector<int> arr = {111, 21, 3, 4000, 5, 6, 7, 8, 9};\n    int k = 4;\n    int result = add_elements(arr, k);\n    cout << \"Output: \" << result << endl; // Expected output: 24\n}\n\n"}
{"task_id": "CPP/59", "generation": "#include <iostream>\nusing namespace std;\n\nint largest_prime_factor(int n) {\n    int max_prime = -1;\n\n    // Divide n by 2 to remove all even factors\n    while (n % 2 == 0) {\n        max_prime = 2;\n        n /= 2;\n    }\n\n    // n must be odd at this point, so we can skip one element (Note i = i + 2)\n    for (int i = 3; i * i <= n; i += 2) {\n        // While i divides n, replace n and update max_prime\n        while (n % i == 0) {\n            max_prime = i;\n            n /= i;\n        }\n    }\n\n    // This condition is to handle the case when n is a prime number greater than 2\n    if (n > 2) {\n        max_prime = n;\n    }\n\n    return max_prime;\n}\n\n"}
{"task_id": "CPP/134", "generation": "#include <iostream>\n#include <string>\n#include <cctype> // for isalpha function\n\nusing namespace std;\n\nbool check_if_last_char_is_a_letter(const string& txt) {\n    // Check if the string is empty\n    if (txt.empty()) {\n        return false;\n    }\n\n    // Get the last character of the string\n    char last_char = txt[txt.size() - 1];\n\n    // Check if the last character is an alphabetical character\n    if (isalpha(last_char)) {\n        // Check if the last character is not part of a word\n        // This means it should either be the only character in the string\n        // or the character before it should be a space\n        if (txt.size() == 1 || txt[txt.size() - 2] == ' ') {\n            return true;\n        }\n    }\n\n    return false;\n}\n\n"}
{"task_id": "CPP/42", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> incr_list(vector<int> l) {\n    for (int &element : l) {\n        element += 1;\n    }\n    return l;\n}\n\n// Function to test the incr_list function\nvoid test_incr_list() {\n    vector<int> test1 = {1, 2, 3};\n    vector<int> expected1 = {2, 3, 4};\n    assert(incr_list(test1) == expected1);\n\n    vector<int> test2 = {5, 3, 5, 2, 3, 3, 9, 0, 123};\n    vector<int> expected2 = {6, 4, 6, 3, 4, 4, 10, 1, 124};\n    assert(incr_list(test2) == expected2);\n\n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/11", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring string_xor(string a, string b) {\n    string result = \"\";\n    // Ensure both strings are of the same length\n    if (a.length() != b.length()) {\n        return \"Error: Strings must be of the same length\";\n    }\n\n    // Perform XOR operation on each pair of characters\n    for (size_t i = 0; i < a.length(); ++i) {\n        // Convert characters to integers (0 or 1)\n        int bitA = a[i] - '0';\n        int bitB = b[i] - '0';\n\n        // Compute XOR and convert back to character\n        char xorResult = (bitA ^ bitB) + '0';\n\n        // Append the result to the result string\n        result += xorResult;\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/40", "generation": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nbool triples_sum_to_zero(vector<int> l) {\n    // If the vector has less than 3 elements, it's impossible to have three elements sum to zero\n    if (l.size() < 3) {\n        return false;\n    }\n\n    // Sort the vector to use the two-pointer technique\n    sort(l.begin(), l.end());\n\n    // Iterate through the vector, using each element as a potential first element of the triplet\n    for (int i = 0; i < l.size() - 2; ++i) {\n        // Skip duplicate elements to avoid checking the same triplet multiple times\n        if (i > 0 && l[i] == l[i - 1]) {\n            continue;\n        }\n\n        int left = i + 1;\n        int right = l.size() - 1;\n\n        // Use two pointers to find the other two elements\n        while (left < right) {\n            int sum = l[i] + l[left] + l[right];\n\n            if (sum == 0) {\n                return true; // Found a triplet that sums to zero\n            } else if (sum < 0) {\n                ++left; // Move the left pointer to the right to increase the sum\n            } else {\n                --right; // Move the right pointer to the left to decrease the sum\n            }\n\n            // Skip duplicate elements to avoid checking the same triplet multiple times\n            while (left < right && l[left] == l[left - 1]) {\n                ++left;\n            }\n            while (left < right && l[right] == l[right + 1]) {\n                --right;\n            }\n        }\n    }\n\n    return false; // No triplet found that sums to zero\n}\n"}
{"task_id": "CPP/13", "generation": "#include <iostream>\nusing namespace std;\n\nint greatest_common_divisor(int a, int b) {\n    while (b != 0) {\n        int temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n\n"}
{"task_id": "CPP/130", "generation": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\n// Helper function to compute the Tribonacci number with memoization\nint tribonacci(int num, unordered_map<int, int>& memo) {\n    if (memo.find(num) != memo.end()) {\n        return memo[num];\n    }\n    if (num == 1) {\n        return 3;\n    }\n    if (num % 2 == 0) {\n        return 1 + num / 2;\n    } else {\n        int result = tribonacci(num - 1, memo) + tribonacci(num - 2, memo) + tribonacci(num + 1, memo);\n        memo[num] = result;\n        return result;\n    }\n}\n\nvector<int> tri(int n) {\n    if (n == 1) {\n        return {1, 3};\n    }\n\n    unordered_map<int, int> memo;\n    vector<int> result(n + 1);\n    result[0] = 1; // The first element is always 1\n\n    for (int i = 1; i <= n; ++i) {\n        result[i] = tribonacci(i, memo);\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/60", "generation": "#include <iostream>\n\nint sum_to_n(int n) {\n    // Using the formula for the sum of the first n natural numbers: n * (n + 1) / 2\n    return n * (n + 1) / 2;\n}\n\n"}
{"task_id": "CPP/23", "generation": "#include <iostream>\n#include <string>\n\n// Function to return the length of a given string\nint string_length(const std::string& str) {\n    return str.length();\n}\n\n"}
{"task_id": "CPP/46", "generation": "#include <iostream>\nusing namespace std;\n\nint fib4(int n) {\n    // Base cases\n    if (n == 0 || n == 1 || n == 3) return 0;\n    if (n == 2) return 2;\n\n    // Initialize the first four elements of the sequence\n    int a = 0, b = 0, c = 2, d = 0;\n\n    // Compute the n-th element iteratively\n    for (int i = 4; i <= n; ++i) {\n        int temp = a + b + c + d;\n        a = b;\n        b = c;\n        c = d;\n        d = temp;\n    }\n\n    return d;\n}\n\n"}
{"task_id": "CPP/51", "generation": "#include <iostream>\n#include <string>\n#include <cctype> // for tolower function\n\nusing namespace std;\n\nstring remove_vowels(string text) {\n    string result = \"\";\n    string vowels = \"aeiouAEIOU\";\n\n    for (char ch : text) {\n        if (vowels.find(ch) == string::npos) {\n            result += ch;\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/18", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint how_many_times(const string& str, const string& substring) {\n    if (substring.empty()) return 0; // If the substring is empty, return 0\n\n    int count = 0;\n    size_t pos = 0;\n\n    while ((pos = str.find(substring, pos)) != string::npos) {\n        count++;\n        pos++; // Move to the next character to allow for overlapping matches\n    }\n\n    return count;\n}\n\n"}
{"task_id": "CPP/143", "generation": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    for (int i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) return false;\n    }\n    return true;\n}\n\n// Function to process the sentence and return words with prime lengths\nstring words_in_sentence(string sentence) {\n    stringstream ss(sentence);\n    string word;\n    string result;\n    while (ss >> word) {\n        if (is_prime(word.length())) {\n            if (!result.empty()) result += \" \";\n            result += word;\n        }\n    }\n    return result;\n}\n\n// Main function to test the solution\n"}
{"task_id": "CPP/108", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\nusing namespace std;\n\n// Helper function to calculate the sum of digits of a number\nint sum_of_digits(int num) {\n    bool is_negative = num < 0;\n    int sum = 0;\n    num = abs(num); // Convert to positive to handle digits easily\n\n    while (num > 0) {\n        int digit = num % 10;\n        sum += digit;\n        num /= 10;\n    }\n\n    if (is_negative) {\n        sum -= 2 * (sum % 10); // Adjust the first digit to be negative\n    }\n\n    return sum;\n}\n\n// Main function to count the number of elements with a sum of digits > 0\nint count_nums(vector<int> n) {\n    int count = 0;\n    for (int num : n) {\n        if (sum_of_digits(num) > 0) {\n            count++;\n        }\n    }\n    return count;\n}\n\n// Function to test the correctness of the solution\nvoid test() {\n    assert(count_nums({}) == 0);\n    assert(count_nums({-1, 11, -11}) == 1);\n    assert(count_nums({1, 1, 2}) == 3);\n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/43", "generation": "#include <iostream>\n#include <vector>\n#include <unordered_set>\n\nusing namespace std;\n\nbool pairs_sum_to_zero(vector<int> l) {\n    unordered_set<int> seen;\n\n    for (int num : l) {\n        if (seen.find(-num) != seen.end()) {\n            return true; // Found two numbers that sum to zero\n        }\n        seen.insert(num);\n    }\n\n    return false; // No such pair found\n}\n\n"}
{"task_id": "CPP/70", "generation": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> strange_sort_list(vector<int> lst) {\n    vector<int> result;\n    while (!lst.empty()) {\n        // Find the minimum element\n        auto min_it = min_element(lst.begin(), lst.end());\n        result.push_back(*min_it);\n        lst.erase(min_it);\n\n        if (!lst.empty()) {\n            // Find the maximum element\n            auto max_it = max_element(lst.begin(), lst.end());\n            result.push_back(*max_it);\n            lst.erase(max_it);\n        }\n    }\n    return result;\n}\n\n// Example usage\n"}
{"task_id": "CPP/63", "generation": "#include <iostream>\n#include <vector>\n\nint fibfib(int n) {\n    if (n == 0 || n == 1) return 0;\n    if (n == 2) return 1;\n\n    // Initialize a vector to store the FibFib values up to n\n    std::vector<int> dp(n + 1, 0);\n    dp[0] = 0;\n    dp[1] = 0;\n    dp[2] = 1;\n\n    // Compute the FibFib values iteratively\n    for (int i = 3; i <= n; ++i) {\n        dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3];\n    }\n\n    return dp[n];\n}\n\n"}
{"task_id": "CPP/89", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\n// Function to encrypt the string by rotating the alphabet\nstring encrypt(string s) {\n    for (char &c : s) {\n        if (isalpha(c)) {\n            char base = islower(c) ? 'a' : 'A';\n            c = base + (c - base + 4) % 26;\n        }\n    }\n    return s;\n}\n\n"}
{"task_id": "CPP/26", "generation": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nvector<int> remove_duplicates(vector<int> numbers) {\n    // Step 1: Count the occurrences of each number\n    unordered_map<int, int> count;\n    for (int num : numbers) {\n        count[num]++;\n    }\n\n    // Step 2: Create a new vector to store the result\n    vector<int> result;\n    for (int num : numbers) {\n        // Only add numbers that appear exactly once\n        if (count[num] == 1) {\n            result.push_back(num);\n        }\n    }\n\n    return result;\n}\n\n// Function to test the remove_duplicates function\nvoid test_remove_duplicates() {\n    vector<int> input = {1, 2, 3, 2, 4};\n    vector<int> expected_output = {1, 3, 4};\n    vector<int> output = remove_duplicates(input);\n\n    if (output == expected_output) {\n        cout << \"Test passed.\" << endl;\n    } else {\n        cout << \"Test failed.\" << endl;\n    }\n}\n\n"}
{"task_id": "CPP/104", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to check if a number contains any even digit\nbool has_even_digit(int num) {\n    while (num > 0) {\n        int digit = num % 10;\n        if (digit % 2 == 0) {\n            return true;\n        }\n        num /= 10;\n    }\n    return false;\n}\n\n// Function to filter and sort the vector\nvector<int> unique_digits(vector<int> x) {\n    vector<int> result;\n    \n    // Filter out numbers with even digits\n    for (int num : x) {\n        if (!has_even_digit(num)) {\n            result.push_back(num);\n        }\n    }\n    \n    // Sort the result vector\n    sort(result.begin(), result.end());\n    \n    return result;\n}\n\n// Function to test the unique_digits function\nvoid test_unique_digits() {\n    vector<int> test1 = {15, 33, 1422, 1};\n    vector<int> expected1 = {1, 15, 33};\n    assert(unique_digits(test1) == expected1);\n\n    vector<int> test2 = {152, 323, 1422, 10};\n    vector<int> expected2 = {};\n    assert(unique_digits(test2) == expected2);\n\n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/90", "generation": "#include <iostream>\n#include <vector>\n#include <set>\n#include <optional>\nusing namespace std;\n\noptional<int> next_smallest(vector<int> lst) {\n    if (lst.size() < 2) {\n        return nullopt;\n    }\n\n    set<int> unique_lst(lst.begin(), lst.end());\n    if (unique_lst.size() < 2) {\n        return nullopt;\n    }\n\n    auto it = unique_lst.begin();\n    advance(it, 1); // Move to the second element in the set\n\n    return *it;\n}\n\n"}
{"task_id": "CPP/126", "generation": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nbool is_sorted(vector<int> lst) {\n    if (lst.empty()) return true; // An empty list is considered sorted\n\n    int prev = lst[0];\n    int count = 1; // Count of the current number\n\n    for (size_t i = 1; i < lst.size(); ++i) {\n        if (lst[i] < prev) {\n            // If the current number is less than the previous one, it's not sorted\n            return false;\n        } else if (lst[i] == prev) {\n            // If the current number is the same as the previous one, increment the count\n            count++;\n            if (count > 2) {\n                // If the count exceeds 2, return false\n                return false;\n            }\n        } else {\n            // Reset the count for a new number\n            prev = lst[i];\n            count = 1;\n        }\n    }\n\n    return true;\n}\n"}
{"task_id": "CPP/68", "generation": "#include <vector>\n#include <climits>\nusing namespace std;\n\nvector<int> pluck(vector<int> arr) {\n    int minEvenValue = INT_MAX;\n    int minIndex = -1;\n\n    for (int i = 0; i < arr.size(); ++i) {\n        if (arr[i] % 2 == 0 && arr[i] < minEvenValue) {\n            minEvenValue = arr[i];\n            minIndex = i;\n        }\n    }\n\n    if (minIndex == -1) {\n        return {}; // No even value found\n    } else {\n        return {minEvenValue, minIndex};\n    }\n}\n\n// Example usage\n"}
{"task_id": "CPP/58", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> common(vector<int> l1, vector<int> l2) {\n    // Step 1: Sort both vectors\n    sort(l1.begin(), l1.end());\n    sort(l2.begin(), l2.end());\n\n    vector<int> result;\n    int i = 0, j = 0;\n\n    // Step 2: Use two pointers to find common elements\n    while (i < l1.size() && j < l2.size()) {\n        if (l1[i] == l2[j]) {\n            // Step 3: Add to result if it's not already in the result\n            if (result.empty() || result.back() != l1[i]) {\n                result.push_back(l1[i]);\n            }\n            i++;\n            j++;\n        } else if (l1[i] < l2[j]) {\n            i++;\n        } else {\n            j++;\n        }\n    }\n\n    return result;\n}\n\n// Function to test the common function\nvoid test_common() {\n    vector<int> l1 = {1, 4, 3, 34, 653, 2, 5};\n    vector<int> l2 = {5, 7, 1, 5, 9, 653, 121};\n    vector<int> expected1 = {1, 5, 653};\n    vector<int> result1 = common(l1, l2);\n    assert(result1 == expected1);\n\n    vector<int> l3 = {5, 3, 2, 8};\n    vector<int> l4 = {3, 2};\n    vector<int> expected2 = {2, 3};\n    vector<int> result2 = common(l3, l4);\n    assert(result2 == expected2);\n\n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/112", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\n// Function to check if a string is a palindrome\nbool isPalindrome(const string& str) {\n    int left = 0, right = str.size() - 1;\n    while (left < right) {\n        if (str[left] != str[right]) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n    return true;\n}\n\n// Function to remove characters from s that are present in c and check if the result is a palindrome\nvector<string> reverse_delete(string s, string c) {\n    // Remove characters from s that are present in c\n    s.erase(remove_if(s.begin(), s.end(), [&c](char ch) {\n        return c.find(ch) != string::npos;\n    }), s.end());\n\n    // Check if the resulting string is a palindrome\n    bool isPal = isPalindrome(s);\n\n    // Prepare the result vector\n    vector<string> result;\n    result.push_back(s);\n    result.push_back(isPal ? \"True\" : \"False\");\n\n    return result;\n}\n\n// Function to test the solution\nvoid test_reverse_delete() {\n    vector<string> result1 = reverse_delete(\"abcde\", \"ae\");\n    cout << \"(\" << result1[0] << \",\\\"\" << result1[1] << \"\\\")\" << endl; // Expected: (bcd,\"False\")\n\n    vector<string> result2 = reverse_delete(\"abcdef\", \"b\");\n    cout << \"(\" << result2[0] << \",\\\"\" << result2[1] << \"\\\")\" << endl; // Expected: (acdef,\"False\")\n\n    vector<string> result3 = reverse_delete(\"abcdedcba\", \"ab\");\n    cout << \"(\" << result3[0] << \",\\\"\" << result3[1] << \"\\\")\" << endl; // Expected: (cdedc,\"True\")\n}\n\n"}
{"task_id": "CPP/96", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    if (num == 2) return true;\n    if (num % 2 == 0) return false;\n    for (int i = 3; i * i <= num; i += 2) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\n// Function to return a vector of prime numbers less than n\nvector<int> count_up_to(int n) {\n    vector<int> primes;\n    for (int i = 2; i < n; ++i) {\n        if (is_prime(i)) {\n            primes.push_back(i);\n        }\n    }\n    return primes;\n}\n\n// Function to test the implementation\nvoid test_count_up_to() {\n    assert((count_up_to(5) == vector<int>{2, 3}));\n    assert((count_up_to(11) == vector<int>{2, 3, 5, 7}));\n    assert((count_up_to(0) == vector<int>{}));\n    assert((count_up_to(20) == vector<int>{2, 3, 5, 7, 11, 13, 17, 19}));\n    assert((count_up_to(1) == vector<int>{}));\n    assert((count_up_to(18) == vector<int>{2, 3, 5, 7, 11, 13, 17}));\n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/157", "generation": "#include <iostream>\n#include <cmath>\n\nbool right_angle_triangle(float a, float b, float c) {\n    // First, sort the sides to ensure c is the longest side (hypotenuse)\n    float sides[3] = {a, b, c};\n    std::sort(sides, sides + 3);\n    \n    // Apply the Pythagorean theorem\n    return std::abs(sides[0] * sides[0] + sides[1] * sides[1] - sides[2] * sides[2]) < 1e-6;\n}\n\n"}
{"task_id": "CPP/99", "generation": "#include <iostream>\n#include <cmath>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nint closest_integer(const string& value) {\n    // Convert the string to a double\n    stringstream ss(value);\n    double num;\n    ss >> num;\n\n    // Determine the closest integer\n    double fractionalPart = num - floor(num);\n    if (fractionalPart == 0.5 || fractionalPart == -0.5) {\n        // Rounding away from zero\n        return num > 0 ? ceil(num) : floor(num);\n    } else {\n        // Standard rounding\n        return round(num);\n    }\n}\n\n// Function to test the closest_integer function\nvoid test_closest_integer() {\n    cout << closest_integer(\"10\") << \" (Expected: 10)\" << endl;\n    cout << closest_integer(\"15.3\") << \" (Expected: 15)\" << endl;\n    cout << closest_integer(\"14.5\") << \" (Expected: 15)\" << endl;\n    cout << closest_integer(\"-14.5\") << \" (Expected: -15)\" << endl;\n    cout << closest_integer(\"14.1\") << \" (Expected: 14)\" << endl;\n    cout << closest_integer(\"-14.1\") << \" (Expected: -14)\" << endl;\n}\n\n"}
{"task_id": "CPP/149", "generation": "#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nvector<string> sorted_list_sum(vector<string> lst) {\n    // Step 1: Remove strings with odd lengths\n    lst.erase(remove_if(lst.begin(), lst.end(), [](const string& s) {\n        return s.length() % 2 != 0;\n    }), lst.end());\n\n    // Step 2: Sort the remaining strings\n    // First by length, then alphabetically\n    sort(lst.begin(), lst.end(), [](const string& a, const string& b) {\n        if (a.length() == b.length()) {\n            return a < b; // Alphabetical order\n        }\n        return a.length() < b.length(); // Length order\n    });\n\n    return lst;\n}\n\n// Example usage and test cases\n"}
{"task_id": "CPP/86", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nstring anti_shuffle(string s) {\n    int n = s.length();\n    string result = \"\";\n    string word = \"\";\n\n    for (int i = 0; i <= n; ++i) {\n        if (i < n && s[i] != ' ') {\n            // Accumulate characters of the current word\n            word += s[i];\n        } else {\n            // Sort the characters of the current word\n            sort(word.begin(), word.end());\n            // Append the sorted word to the result\n            result += word;\n            // If not at the end of the string, add a space\n            if (i < n) {\n                result += ' ';\n            }\n            // Reset the word for the next iteration\n            word = \"\";\n        }\n    }\n\n    return result;\n}\n\n// Function to test the anti_shuffle function\nvoid test_anti_shuffle() {\n    cout << anti_shuffle(\"Hi\") << endl;  // Output: \"Hi\"\n    cout << anti_shuffle(\"hello\") << endl;  // Output: \"ehllo\"\n    cout << anti_shuffle(\"Hello World!!!\") << endl;  // Output: \"Hello !!!Wdlor\"\n}\n\n"}
{"task_id": "CPP/129", "generation": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <tuple>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> minPath(vector<vector<int>> grid, int k) {\n    int N = grid.size();\n    vector<pair<int, int>> directions = {{0, 1}, {1, 0}, {-1, 0}, {0, -1}};\n    \n    // Priority queue to store (current path, current position)\n    using State = tuple<int, int, int, vector<int>>;\n    auto comp = [](const State& a, const State& b) {\n        return vector<int>(get<3>(a)) > vector<int>(get<3>(b));\n    };\n    priority_queue<State, vector<State>, decltype(comp)> pq(comp);\n    \n    // Initialize the priority queue with all possible starting positions\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            pq.emplace(grid[i][j], i, j, vector<int>{grid[i][j]});\n        }\n    }\n    \n    while (!pq.empty()) {\n        int current_value, x, y;\n        vector<int> path;\n        tie(current_value, x, y, path) = pq.top();\n        pq.pop();\n        \n        if (path.size() == k) {\n            return path;\n        }\n        \n        for (const auto& dir : directions) {\n            int nx = x + dir.first, ny = y + dir.second;\n            if (0 <= nx && nx < N && 0 <= ny && ny < N) {\n                vector<int> new_path = path;\n                new_path.push_back(grid[nx][ny]);\n                pq.emplace(grid[nx][ny], nx, ny, new_path);\n            }\n        }\n    }\n    \n    return {}; // This line should never be reached given the problem constraints\n}\n\n"}
{"task_id": "CPP/49", "generation": "#include <iostream>\nusing namespace std;\n\nint modp(int n, int p) {\n    int result = 1;\n    int base = 2;\n\n    while (n > 0) {\n        if (n % 2 == 1) {  // If n is odd, multiply the result by the current base\n            result = (result * base) % p;\n        }\n        base = (base * base) % p;  // Square the base\n        n = n / 2;  // Divide n by 2\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/156", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring int_to_mini_roman(int number) {\n    // Define the Roman numeral mappings\n    vector<pair<int, string>> roman_map = {\n        {1000, \"m\"}, {900, \"cm\"}, {500, \"d\"}, {400, \"cd\"},\n        {100, \"c\"}, {90, \"xc\"}, {50, \"l\"}, {40, \"xl\"},\n        {10, \"x\"}, {9, \"ix\"}, {5, \"v\"}, {4, \"iv\"}, {1, \"i\"}\n    };\n\n    string result = \"\";\n\n    // Iterate through the roman_map to construct the Roman numeral\n    for (const auto &p : roman_map) {\n        while (number >= p.first) {\n            result += p.second;\n            number -= p.first;\n        }\n    }\n\n    return result;\n}\n\n// Function to test the correctness of the solution\nvoid test() {\n    cout << (int_to_mini_roman(19) == \"xix\") << endl;\n    cout << (int_to_mini_roman(152) == \"clii\") << endl;\n    cout << (int_to_mini_roman(426) == \"cdxxvi\") << endl;\n}\n\n"}
{"task_id": "CPP/65", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring circular_shift(int x, int shift) {\n    string s = to_string(x);\n    int n = s.length();\n    shift %= n;  // Handle cases where shift > number of digits\n\n    // Perform the circular shift\n    string shifted = s.substr(n - shift) + s.substr(0, n - shift);\n    return shifted;\n}\n\n"}
{"task_id": "CPP/9", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> rolling_max(vector<int> numbers) {\n    vector<int> result;\n    if (numbers.empty()) return result; // Handle empty input\n\n    int current_max = numbers[0];\n    for (int num : numbers) {\n        if (num > current_max) {\n            current_max = num;\n        }\n        result.push_back(current_max);\n    }\n    return result;\n}\n\n// Function to test the rolling_max function\nvoid test_rolling_max() {\n    vector<int> input = {1, 2, 3, 2, 3, 4, 2};\n    vector<int> expected_output = {1, 2, 3, 3, 3, 4, 4};\n    vector<int> output = rolling_max(input);\n\n    if (output == expected_output) {\n        cout << \"Test passed!\" << endl;\n    } else {\n        cout << \"Test failed!\" << endl;\n    }\n}\n\n"}
{"task_id": "CPP/158", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <set>\n\nusing namespace std;\n\nstring find_max(vector<string> words) {\n    string max_word = \"\";\n    int max_unique_chars = 0;\n\n    for (const string& word : words) {\n        set<char> unique_chars(word.begin(), word.end());\n        int num_unique_chars = unique_chars.size();\n\n        if (num_unique_chars > max_unique_chars || \n            (num_unique_chars == max_unique_chars && word < max_word)) {\n            max_word = word;\n            max_unique_chars = num_unique_chars;\n        }\n    }\n\n    return max_word;\n}\n\n"}
{"task_id": "CPP/8", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Function to calculate sum and product of elements in a vector\nvector<int> sum_product(const vector<int>& numbers) {\n    int sum = 0;\n    int product = 1;\n\n    for (int num : numbers) {\n        sum += num;\n        product *= num;\n    }\n\n    return {sum, product};\n}\n\n// Function to test the sum_product function\nvoid test_sum_product() {\n    // Test with an empty vector\n    vector<int> result1 = sum_product({});\n    cout << \"Test with empty vector: (\" << result1[0] << \", \" << result1[1] << \")\" << endl;\n\n    // Test with a non-empty vector\n    vector<int> result2 = sum_product({1, 2, 3, 4});\n    cout << \"Test with {1, 2, 3, 4}: (\" << result2[0] << \", \" << result2[1] << \")\" << endl;\n}\n\n"}
{"task_id": "CPP/95", "generation": "#include <iostream>\n#include <string>\n#include <map>\n#include <cctype>\nusing namespace std;\n\nbool isLowercase(const string& str) {\n    for (char ch : str) {\n        if (!islower(ch)) return false;\n    }\n    return true;\n}\n\nbool isUppercase(const string& str) {\n    for (char ch : str) {\n        if (!isupper(ch)) return false;\n    }\n    return true;\n}\n\nbool check_dict_case(map<string, string> dict) {\n    if (dict.empty()) return false;\n\n    bool hasLower = false;\n    bool hasUpper = false;\n\n    for (const auto& pair : dict) {\n        if (isLowercase(pair.first)) {\n            hasLower = true;\n        } else if (isUppercase(pair.first)) {\n            hasUpper = true;\n        } else {\n            return false; // Mixed case or non-alphabetic characters\n        }\n\n        if (hasLower && hasUpper) return false; // Both lowercase and uppercase found\n    }\n\n    return true;\n}\n\n"}
{"task_id": "CPP/55", "generation": "#include <iostream>\nusing namespace std;\n\nint fib(int n) {\n    if (n <= 1) {\n        return n;\n    }\n    return fib(n - 1) + fib(n - 2);\n}\n\n"}
{"task_id": "CPP/29", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> filter_by_prefix(vector<string> strings, string prefix) {\n    vector<string> result;\n    for (const auto& str : strings) {\n        if (str.substr(0, prefix.size()) == prefix) {\n            result.push_back(str);\n        }\n    }\n    return result;\n}\n\n// Function to test the filter_by_prefix function\nvoid test_filter_by_prefix() {\n    vector<string> test1 = {};\n    vector<string> expected1 = {};\n    assert(filter_by_prefix(test1, \"a\") == expected1);\n\n    vector<string> test2 = {\"abc\", \"bcd\", \"cde\", \"vector\"};\n    vector<string> expected2 = {\"abc\", \"vector\"};\n    assert(filter_by_prefix(test2, \"a\") == expected2);\n\n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/72", "generation": "#include <vector>\nusing namespace std;\n\nbool is_palindromic(const vector<int>& q) {\n    int n = q.size();\n    for (int i = 0; i < n / 2; ++i) {\n        if (q[i] != q[n - 1 - i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nbool will_it_fly(vector<int> q, int w) {\n    // Check if the vector is palindromic\n    if (!is_palindromic(q)) {\n        return false;\n    }\n\n    // Calculate the sum of the elements\n    int sum = 0;\n    for (int num : q) {\n        sum += num;\n    }\n\n    // Check if the sum is within the weight limit\n    return sum <= w;\n}\n\n// Example usage\n"}
{"task_id": "CPP/54", "generation": "#include <iostream>\n#include <string>\n#include <set>\nusing namespace std;\n\nbool same_chars(const string& s0, const string& s1) {\n    // Create sets to store unique characters from each string\n    set<char> chars_s0(s0.begin(), s0.end());\n    set<char> chars_s1(s1.begin(), s1.end());\n\n    // Compare the sets\n    return chars_s0 == chars_s1;\n}\n\n"}
{"task_id": "CPP/91", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <vector>\n\nusing namespace std;\n\nint is_bored(const string& S) {\n    // Vector to store the sentences\n    vector<string> sentences;\n    // String stream to help split the input string\n    stringstream ss(S);\n    string token;\n    \n    // Split the string into sentences based on delimiters\n    while (getline(ss, token, '.')) {\n        sentences.push_back(token);\n    }\n    while (getline(ss, token, '?')) {\n        sentences.push_back(token);\n    }\n    while (getline(ss, token, '!')) {\n        sentences.push_back(token);\n    }\n\n    int boredom_count = 0;\n\n    // Check each sentence to see if it starts with \"I\"\n    for (const auto& sentence : sentences) {\n        // Trim leading spaces\n        size_t start = sentence.find_first_not_of(\" \");\n        if (start == string::npos) continue; // Skip empty sentences\n\n        // Extract the first word\n        string first_word = sentence.substr(start, 2); // \"I\" is 2 characters long\n\n        // Check if the first word is \"I\"\n        if (first_word == \"I \") {\n            boredom_count++;\n        }\n    }\n\n    return boredom_count;\n}\n\n"}
{"task_id": "CPP/77", "generation": "#include <cmath>\n#include <iostream>\n\nbool iscube(int a) {\n    if (a < 0) {\n        a = -a;\n    }\n    int root = round(cbrt(a));\n    return root * root * root == a;\n}\n\n"}
{"task_id": "CPP/73", "generation": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint smallest_change(vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n\n    // Use two pointers to compare elements from the start and end\n    for (int i = 0, j = n - 1; i < j; ++i, --j) {\n        if (arr[i] != arr[j]) {\n            ++changes;\n        }\n    }\n\n    return changes;\n}\n\n// Example usage\n"}
{"task_id": "CPP/71", "generation": "#include <iostream>\n#include <cmath>\n#include <iomanip>\n\nusing namespace std;\n\nfloat triangle_area(float a, float b, float c) {\n    // Check if the sides form a valid triangle\n    if (a + b <= c || a + c <= b || b + c <= a) {\n        return -1.0f;\n    }\n\n    // Calculate the semi-perimeter\n    float s = (a + b + c) / 2.0f;\n\n    // Calculate the area using Heron's formula\n    float area = sqrt(s * (s - a) * (s - b) * (s - c));\n\n    // Round the area to 2 decimal places\n    return round(area * 100.0f) / 100.0f;\n}\n\n"}
{"task_id": "CPP/82", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int n) {\n    if (n <= 1) return false; // 0 and 1 are not prime numbers\n    if (n <= 3) return true; // 2 and 3 are prime numbers\n\n    // This is checked so that we can skip middle five numbers in below loop\n    if (n % 2 == 0 || n % 3 == 0) return false;\n\n    for (int i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) return false;\n    }\n\n    return true;\n}\n\n// Function to check if the length of the string is prime\nbool prime_length(const string& str) {\n    int length = str.length();\n    return is_prime(length);\n}\n\n// Main function to test the prime_length function\n"}
{"task_id": "CPP/114", "generation": "#include <vector>\n#include <climits>\nusing namespace std;\n\nlong long minSubArraySum(vector<long long> nums) {\n    long long min_sum = LLONG_MAX; // Initialize min_sum to the largest possible value\n    long long current_sum = 0;      // Initialize current_sum to 0\n\n    for (long long num : nums) {\n        current_sum += num; // Add the current number to the current_sum\n        if (current_sum < min_sum) {\n            min_sum = current_sum; // Update min_sum if current_sum is smaller\n        }\n        if (current_sum > 0) {\n            current_sum = 0; // Reset current_sum to 0 if it becomes positive\n        }\n    }\n\n    return min_sum;\n}\n\n// Example usage\n"}
{"task_id": "CPP/138", "generation": "#include <iostream>\nusing namespace std;\n\nbool is_equal_to_sum_even(int n) {\n    // Check if n is even and at least 8\n    return (n % 2 == 0) && (n >= 8);\n}\n\n"}
{"task_id": "CPP/132", "generation": "#include <iostream>\n#include <string>\n#include <stack>\nusing namespace std;\n\nbool is_nested(const string& str) {\n    stack<char> stack;\n    int max_depth = 0;\n    int current_depth = 0;\n\n    for (char ch : str) {\n        if (ch == '[') {\n            stack.push(ch);\n            current_depth += 1;\n            max_depth = max(max_depth, current_depth);\n        } else if (ch == ']') {\n            if (stack.empty()) {\n                return false;\n            }\n            stack.pop();\n            current_depth -= 1;\n        }\n    }\n\n    return max_depth > 1 && stack.empty();\n}\n\n"}
{"task_id": "CPP/3", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool below_zero(const vector<int>& operations) {\n    int balance = 0; // Start with zero balance\n\n    for (int op : operations) {\n        balance += op; // Update the balance with each operation\n        if (balance < 0) {\n            return true; // Return true if balance falls below zero\n        }\n    }\n\n    return false; // Return false if balance never falls below zero\n}\n\n"}
{"task_id": "CPP/142", "generation": "#include <vector>\nusing namespace std;\n\nint sum_squares(vector<int> lst) {\n    int sum = 0;\n    \n    for (size_t i = 0; i < lst.size(); ++i) {\n        if (i % 3 == 0) {\n            // Square the element if the index is a multiple of 3\n            sum += lst[i] * lst[i];\n        } else if (i % 4 == 0) {\n            // Cube the element if the index is a multiple of 4 and not a multiple of 3\n            sum += lst[i] * lst[i] * lst[i];\n        } else {\n            // Add the element as it is if the index is neither a multiple of 3 nor 4\n            sum += lst[i];\n        }\n    }\n    \n    return sum;\n}\n\n// Example usage\n"}
{"task_id": "CPP/50", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring encode_shift(string s) {\n    // Returns encoded string by shifting every character by 5 in the alphabet.\n    string out;\n    for (int i = 0; i < s.length(); i++) {\n        int w = ((int)s[i] + 5 - (int)'a') % 26 + (int)'a';\n        out += (char)w;\n    }\n    return out;\n}\n\nstring decode_shift(string s) {\n    // Takes as input string encoded with encode_shift function. Returns decoded string.\n    string out;\n    for (int i = 0; i < s.length(); i++) {\n        int w = ((int)s[i] - 5 - (int)'a' + 26) % 26 + (int)'a'; // Adding 26 to ensure non-negative result\n        out += (char)w;\n    }\n    return out;\n}\n\n"}
{"task_id": "CPP/103", "generation": "#include <iostream>\n#include <string>\n#include <cmath>\nusing namespace std;\n\nstring rounded_avg(int n, int m) {\n    if (n > m) {\n        return \"-1\";\n    }\n\n    // Calculate the sum of the range from n to m\n    long long total_sum = 0;\n    for (int i = n; i <= m; ++i) {\n        total_sum += i;\n    }\n\n    // Calculate the count of numbers in the range\n    int count = m - n + 1;\n\n    // Compute the average and round down to the nearest integer\n    int average = total_sum / count;\n\n    // Convert the average to a binary string\n    string binary = \"\";\n    while (average > 0) {\n        binary = to_string(average % 2) + binary;\n        average /= 2;\n    }\n\n    return binary.empty() ? \"0\" : binary;\n}\n\n"}
{"task_id": "CPP/57", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool monotonic(vector<float> l) {\n    // If the vector is empty or has only one element, it is trivially monotonic\n    if (l.size() <= 1) {\n        return true;\n    }\n\n    // Determine the initial trend\n    bool increasing = l[1] >= l[0];\n    bool decreasing = l[1] <= l[0];\n\n    // If the first two elements are equal, we need to check further\n    if (increasing && decreasing) {\n        for (size_t i = 2; i < l.size(); ++i) {\n            if (l[i] > l[i - 1]) {\n                increasing = true;\n                decreasing = false;\n                break;\n            } else if (l[i] < l[i - 1]) {\n                increasing = false;\n                decreasing = true;\n                break;\n            }\n        }\n    }\n\n    // Check the rest of the vector based on the determined trend\n    for (size_t i = 2; i < l.size(); ++i) {\n        if (increasing && l[i] < l[i - 1]) {\n            return false;\n        }\n        if (decreasing && l[i] > l[i - 1]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\n"}
{"task_id": "CPP/28", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <numeric> // For std::accumulate\n\nusing namespace std;\n\nstring concatenate(const vector<string>& strings) {\n    // Using std::accumulate to concatenate all strings in the vector\n    return accumulate(strings.begin(), strings.end(), string(\"\"));\n}\n\n"}
{"task_id": "CPP/39", "generation": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    if (num == 2) return true;\n    if (num % 2 == 0) return false;\n    for (int i = 3; i <= sqrt(num); i += 2) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\n// Function to return the n-th prime Fibonacci number\nint prime_fib(int n) {\n    int count = 0; // To keep track of the number of prime Fibonacci numbers found\n    int a = 0, b = 1; // First two Fibonacci numbers\n\n    while (true) {\n        int fib = a + b; // Next Fibonacci number\n        a = b;\n        b = fib;\n\n        if (is_prime(fib)) {\n            count++;\n            if (count == n) {\n                return fib;\n            }\n        }\n    }\n}\n\n"}
{"task_id": "CPP/45", "generation": "#include <iostream>\nusing namespace std;\n\n// Function to calculate the area of a triangle\nfloat triangle_area(float base, float height) {\n    return 0.5 * base * height;\n}\n\n"}
{"task_id": "CPP/145", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\n// Helper function to calculate the sum of digits of an integer\nint digit_sum(int n) {\n    int sum = 0;\n    bool is_negative = n < 0;\n    string num_str = to_string(abs(n));\n    \n    for (char d : num_str) {\n        int digit = d - '0';\n        if (is_negative && &d == &num_str[0]) {\n            digit *= -1;\n        }\n        sum += digit;\n    }\n    return sum;\n}\n\n// Comparator function to sort the vector based on the sum of digits and original index\nbool compare(const pair<int, int>& a, const pair<int, int>& b) {\n    int sum_a = digit_sum(a.first);\n    int sum_b = digit_sum(b.first);\n    if (sum_a == sum_b) {\n        return a.second < b.second;\n    }\n    return sum_a < sum_b;\n}\n\nvector<int> order_by_points(vector<int> nums) {\n    // Create a vector of pairs to store the original value and its index\n    vector<pair<int, int>> indexed_nums;\n    for (int i = 0; i < nums.size(); ++i) {\n        indexed_nums.push_back({nums[i], i});\n    }\n\n    // Sort the vector using the custom comparator\n    sort(indexed_nums.begin(), indexed_nums.end(), compare);\n\n    // Extract the sorted values into the result vector\n    vector<int> result;\n    for (const auto& p : indexed_nums) {\n        result.push_back(p.first);\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/84", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\n// Function to calculate the sum of digits of a number\nint sumOfDigits(int N) {\n    int sum = 0;\n    while (N > 0) {\n        sum += N % 10;\n        N /= 10;\n    }\n    return sum;\n}\n\n// Function to convert a number to its binary representation as a string\nstring toBinary(int num) {\n    if (num == 0) return \"0\";\n    string binary = \"\";\n    while (num > 0) {\n        binary = to_string(num % 2) + binary;\n        num /= 2;\n    }\n    return binary;\n}\n\n// Main function to solve the problem\nstring solve(int N) {\n    int sum = sumOfDigits(N);\n    return toBinary(sum);\n}\n\n// Function to test the solution\nvoid test() {\n    cout << solve(1000) << \" (Expected: 1)\" << endl;\n    cout << solve(150) << \" (Expected: 110)\" << endl;\n    cout << solve(147) << \" (Expected: 1100)\" << endl;\n}\n\n"}
{"task_id": "CPP/113", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> odd_count(vector<string> lst) {\n    vector<string> result;\n    for (const auto& str : lst) {\n        int odd_count = 0;\n        for (char c : str) {\n            if ((c - '0') % 2 != 0) {\n                odd_count++;\n            }\n        }\n        // Construct the result string\n        string output = \"the number of odd elements \" + to_string(odd_count) +\n                        \"n the str\" + to_string(odd_count) + \"ng \" + to_string(odd_count) +\n                        \" of the \" + to_string(odd_count) + \"nput.\";\n        result.push_back(output);\n    }\n    return result;\n}\n\n"}
{"task_id": "CPP/36", "generation": "#include <iostream>\n#include <string>\n\nint count_sevens(int num) {\n    int count = 0;\n    while (num > 0) {\n        if (num % 10 == 7) {\n            count++;\n        }\n        num /= 10;\n    }\n    return count;\n}\n\nint fizz_buzz(int n) {\n    int count = 0;\n    for (int i = 1; i < n; ++i) {\n        if (i % 11 == 0 || i % 13 == 0) {\n            count += count_sevens(i);\n        }\n    }\n    return count;\n}\n\n"}
{"task_id": "CPP/144", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\n// Function to parse a fraction string into numerator and denominator\nvoid parseFraction(const string& fraction, int& numerator, int& denominator) {\n    stringstream ss(fraction);\n    char slash;\n    ss >> numerator >> slash >> denominator;\n}\n\n// Function to simplify the expression x * n\nbool simplify(const string& x, const string& n) {\n    int xNum, xDen, nNum, nDen;\n    \n    // Parse the fractions\n    parseFraction(x, xNum, xDen);\n    parseFraction(n, nNum, nDen);\n    \n    // Multiply the numerators and denominators\n    int resultNum = xNum * nNum;\n    int resultDen = xDen * nDen;\n    \n    // Check if the result is a whole number\n    return (resultNum % resultDen == 0);\n}\n\n"}
{"task_id": "CPP/0", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // for sort\n\nusing namespace std;\n\nbool has_close_elements(vector<float> numbers, float threshold) {\n    // Sort the vector\n    sort(numbers.begin(), numbers.end());\n    \n    // Check the difference between consecutive elements\n    for (size_t i = 1; i < numbers.size(); ++i) {\n        if (numbers[i] - numbers[i - 1] < threshold) {\n            return true;\n        }\n    }\n    \n    return false;\n}\n\n"}
{"task_id": "CPP/17", "generation": "#include <vector>\n#include <string>\nusing namespace std;\n\nvector<int> parse_music(string music_string) {\n    vector<int> beats;\n    int i = 0;\n    while (i < music_string.length()) {\n        if (music_string[i] == 'o') {\n            if (i + 1 < music_string.length() && music_string[i + 1] == '|') {\n                // Half note\n                beats.push_back(2);\n                i += 2; // Skip \"o|\"\n            } else {\n                // Whole note\n                beats.push_back(4);\n                i += 1; // Skip \"o\"\n            }\n        } else if (music_string[i] == '.') {\n            if (i + 1 < music_string.length() && music_string[i + 1] == '|') {\n                // Quarter note\n                beats.push_back(1);\n                i += 2; // Skip \".|\"\n            } else {\n                // Invalid note\n                break;\n            }\n        } else {\n            // Skip spaces and other characters\n            i += 1;\n        }\n    }\n    return beats;\n}\n\n// Example usage\n"}
{"task_id": "CPP/47", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // For sort()\n\nusing namespace std;\n\nfloat median(vector<float> l) {\n    // Step 1: Sort the vector\n    sort(l.begin(), l.end());\n\n    int n = l.size();\n    \n    // Step 2: Check if the number of elements is odd or even\n    if (n % 2 == 0) {\n        // Step 4: If even, return the average of the two middle elements\n        return (l[n / 2 - 1] + l[n / 2]) / 2.0;\n    } else {\n        // Step 3: If odd, return the middle element\n        return l[n / 2];\n    }\n}\n\n"}
{"task_id": "CPP/75", "generation": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\n// Function to generate all prime numbers less than 100 using Sieve of Eratosthenes\nvector<int> generate_primes() {\n    vector<bool> is_prime(100, true);\n    vector<int> primes;\n    is_prime[0] = is_prime[1] = false; // 0 and 1 are not prime numbers\n\n    for (int i = 2; i < 100; ++i) {\n        if (is_prime[i]) {\n            primes.push_back(i);\n            for (int j = i * i; j < 100; j += i) {\n                is_prime[j] = false;\n            }\n        }\n    }\n    return primes;\n}\n\n// Function to check if the given number is the product of three prime numbers\nbool is_multiply_prime(int a) {\n    vector<int> primes = generate_primes();\n    int n = primes.size();\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = i; j < n; ++j) {\n            for (int k = j; k < n; ++k) {\n                if (primes[i] * primes[j] * primes[k] == a) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n\n"}
{"task_id": "CPP/124", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\n\nbool is_leap_year(int year) {\n    return (year % 4 == 0 && (year % 100 != 0 || year % 400 == 0));\n}\n\nbool valid_date(const std::string& date) {\n    // Check if the date string is empty\n    if (date.empty()) {\n        return false;\n    }\n\n    // Check the format of the date string\n    if (date.size() != 10 || date[2] != '-' || date[5] != '-') {\n        return false;\n    }\n\n    // Extract month, day, and year from the date string\n    int month, day, year;\n    std::istringstream ss(date);\n    char dash;\n    ss >> month >> dash >> day >> dash >> year;\n\n    // Check if extraction was successful\n    if (ss.fail()) {\n        return false;\n    }\n\n    // Validate month\n    if (month < 1 || month > 12) {\n        return false;\n    }\n\n    // Validate day based on the month\n    if (day < 1) {\n        return false;\n    }\n    if (month == 2) {\n        if (is_leap_year(year)) {\n            if (day > 29) {\n                return false;\n            }\n        } else {\n            if (day > 28) {\n                return false;\n            }\n        }\n    } else if (month == 4 || month == 6 || month == 9 || month == 11) {\n        if (day > 30) {\n            return false;\n        }\n    } else {\n        if (day > 31) {\n            return false;\n        }\n    }\n\n    // If all checks pass, the date is valid\n    return true;\n}\n\n"}
{"task_id": "CPP/101", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <cctype>\n\nusing namespace std;\n\nvector<string> words_string(const string& s) {\n    vector<string> words;\n    string word;\n    istringstream iss(s);\n\n    while (getline(iss, word, ',')) { // Split by commas first\n        istringstream wordStream(word);\n        while (wordStream >> word) { // Then split by spaces\n            words.push_back(word);\n        }\n    }\n\n    return words;\n}\n\n// Function to test the implementation\nvoid test_words_string() {\n    vector<string> result1 = words_string(\"Hi, my name is John\");\n    vector<string> expected1 = {\"Hi\", \"my\", \"name\", \"is\", \"John\"};\n    assert(result1 == expected1);\n\n    vector<string> result2 = words_string(\"One, two, three, four, five, six\");\n    vector<string> expected2 = {\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"};\n    assert(result2 == expected2);\n\n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/14", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> all_prefixes(const string& str) {\n    vector<string> prefixes;\n    for (size_t i = 1; i <= str.size(); ++i) {\n        prefixes.push_back(str.substr(0, i));\n    }\n    return prefixes;\n}\n\n"}
{"task_id": "CPP/141", "generation": "#include <iostream>\n#include <string>\n#include <cctype>\n#include <vector>\n\nusing namespace std;\n\nstring file_name_check(const string& file_name) {\n    // Check for exactly one dot\n    size_t dot_pos = file_name.find('.');\n    if (dot_pos == string::npos || file_name.find('.', dot_pos + 1) != string::npos) {\n        return \"No\";\n    }\n\n    // Check the substring before the dot\n    string name_part = file_name.substr(0, dot_pos);\n    if (name_part.empty() || !isalpha(name_part[0])) {\n        return \"No\";\n    }\n\n    int digit_count = 0;\n    for (char ch : name_part) {\n        if (isdigit(ch)) {\n            digit_count++;\n        }\n        if (digit_count > 3) {\n            return \"No\";\n        }\n    }\n\n    // Check the substring after the dot\n    string extension = file_name.substr(dot_pos + 1);\n    vector<string> valid_extensions = {\"txt\", \"exe\", \"dll\"};\n    if (find(valid_extensions.begin(), valid_extensions.end(), extension) == valid_extensions.end()) {\n        return \"No\";\n    }\n\n    return \"Yes\";\n}\n\n"}
{"task_id": "CPP/123", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> get_odd_collatz(int n) {\n    vector<int> collatz_sequence;\n    vector<int> odd_numbers;\n\n    // Generate the Collatz sequence\n    while (n != 1) {\n        collatz_sequence.push_back(n);\n        if (n % 2 == 0) {\n            n /= 2;\n        } else {\n            n = 3 * n + 1;\n        }\n    }\n    collatz_sequence.push_back(1); // Add the final 1 to the sequence\n\n    // Filter out the odd numbers\n    for (int num : collatz_sequence) {\n        if (num % 2 != 0) {\n            odd_numbers.push_back(num);\n        }\n    }\n\n    // Sort the odd numbers\n    sort(odd_numbers.begin(), odd_numbers.end());\n\n    return odd_numbers;\n}\n\n// Function to test the solution\nvoid test_get_odd_collatz() {\n    vector<int> result = get_odd_collatz(5);\n    for (int num : result) {\n        cout << num << \" \";\n    }\n    cout << endl; // Expected output: 1 5\n\n    result = get_odd_collatz(7);\n    for (int num : result) {\n        cout << num << \" \";\n    }\n    cout << endl; // Expected output: 1 7 11 17 21 85\n}\n\n"}
{"task_id": "CPP/148", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to get the index of a planet in the solar system\nint getPlanetIndex(const string& planet) {\n    const vector<string> planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n    \n    for (int i = 0; i < planets.size(); ++i) {\n        if (planets[i] == planet) {\n            return i;\n        }\n    }\n    return -1; // Return -1 if the planet name is invalid\n}\n\n// Function to find planets between two given planets\nvector<string> bf(const string& planet1, const string& planet2) {\n    const vector<string> planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n    \n    int index1 = getPlanetIndex(planet1);\n    int index2 = getPlanetIndex(planet2);\n    \n    if (index1 == -1 || index2 == -1) {\n        return {}; // Return an empty vector if either planet name is invalid\n    }\n    \n    if (index1 > index2) {\n        swap(index1, index2); // Ensure index1 is always less than or equal to index2\n    }\n    \n    vector<string> result;\n    for (int i = index1 + 1; i < index2; ++i) {\n        result.push_back(planets[i]);\n    }\n    \n    return result;\n}\n\n// Main function to test the bf function\n"}
{"task_id": "CPP/133", "generation": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nint sum_squares(vector<float> lst) {\n    int sum = 0;\n    for (float num : lst) {\n        // Step 1: Round to the upper integer\n        int ceil_num = ceil(num);\n        // Step 2: Square the rounded number\n        int squared_num = ceil_num * ceil_num;\n        // Step 3: Add the squared number to the sum\n        sum += squared_num;\n    }\n    return sum;\n}\n\n"}
{"task_id": "CPP/109", "generation": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nbool move_one_ball(vector<int> arr) {\n    if (arr.empty()) {\n        return true;\n    }\n\n    int n = arr.size();\n    int breakPoint = -1;\n\n    // Find the break point\n    for (int i = 0; i < n - 1; ++i) {\n        if (arr[i] > arr[i + 1]) {\n            if (breakPoint != -1) {\n                // More than one break point found\n                return false;\n            }\n            breakPoint = i;\n        }\n    }\n\n    // Check if the array is already sorted\n    if (breakPoint == -1) {\n        return true;\n    }\n\n    // Check if the array can be sorted by a single right shift\n    if (arr[n - 1] > arr[0]) {\n        return false;\n    }\n\n    // Verify the rest of the array\n    for (int i = 0; i < breakPoint; ++i) {\n        if (arr[i] > arr[i + 1]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n"}
{"task_id": "CPP/100", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> make_a_pile(int n) {\n    vector<int> result;\n    int current_stones = n;\n    \n    for (int i = 0; i < n; ++i) {\n        result.push_back(current_stones);\n        \n        // Determine the next number of stones\n        if (current_stones % 2 == 0) {\n            // If current_stones is even, add 2 to get the next even number\n            current_stones += 2;\n        } else {\n            // If current_stones is odd, add 2 to get the next odd number\n            current_stones += 2;\n        }\n    }\n    \n    return result;\n}\n\n// Example usage\n#include <iostream>\n"}
{"task_id": "CPP/150", "generation": "#include <iostream>\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int n) {\n    if (n <= 1) return false; // 0 and 1 are not prime numbers\n    if (n == 2) return true;  // 2 is the only even prime number\n    if (n % 2 == 0) return false; // Exclude other even numbers\n\n    // Check for factors from 3 to sqrt(n)\n    for (int i = 3; i * i <= n; i += 2) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\n// Function to return x if n is prime, otherwise return y\nint x_or_y(int n, int x, int y) {\n    return is_prime(n) ? x : y;\n}\n\n// Main function to test the x_or_y function\n"}
{"task_id": "CPP/153", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\n// Function to calculate the strength of an extension\nint calculate_strength(const string& extension) {\n    int cap = 0, sm = 0;\n    for (char c : extension) {\n        if (isupper(c)) cap++;\n        else if (islower(c)) sm++;\n    }\n    return cap - sm;\n}\n\nstring Strongest_Extension(string class_name, vector<string> extensions) {\n    // Initialize the strongest extension and its strength\n    string strongest_extension = \"\";\n    int max_strength = INT_MIN;\n\n    // Iterate through each extension to find the strongest one\n    for (const string& extension : extensions) {\n        int strength = calculate_strength(extension);\n        if (strength > max_strength) {\n            max_strength = strength;\n            strongest_extension = extension;\n        }\n    }\n\n    // Return the class name and the strongest extension in the required format\n    return class_name + \".\" + strongest_extension;\n}\n\n// Function to test the solution\nvoid test() {\n    string class_name = \"Slices\";\n    vector<string> extensions = {\"SErviNGSliCes\", \"Cheese\", \"StuFfed\"};\n    string result = Strongest_Extension(class_name, extensions);\n    cout << \"Result: \" << result << endl; // Expected: \"Slices.SErviNGSliCes\"\n\n    class_name = \"my_class\";\n    extensions = {\"AA\", \"Be\", \"CC\"};\n    result = Strongest_Extension(class_name, extensions);\n    cout << \"Result: \" << result << endl; // Expected: \"my_class.AA\"\n}\n\n"}
{"task_id": "CPP/107", "generation": "#include <vector>\n#include <string>\n#include <iostream>\n\n// Function to check if a number is a palindrome\nbool is_palindrome(int num) {\n    std::string str = std::to_string(num);\n    int left = 0, right = str.length() - 1;\n    while (left < right) {\n        if (str[left] != str[right]) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n    return true;\n}\n\n// Function to count even and odd palindromic numbers up to n\nstd::vector<int> even_odd_palindrome(int n) {\n    int even_count = 0, odd_count = 0;\n    \n    for (int i = 1; i <= n; ++i) {\n        if (is_palindrome(i)) {\n            if (i % 2 == 0) {\n                even_count++;\n            } else {\n                odd_count++;\n            }\n        }\n    }\n    \n    return {even_count, odd_count};\n}\n\n// Main function to test the solution\n"}
{"task_id": "CPP/110", "generation": "#include <vector>\n#include <string>\nusing namespace std;\n\nstring exchange(vector<int> lst1, vector<int> lst2) {\n    int oddCount = 0; // Count of odd elements in lst1\n    int evenCount = 0; // Count of even elements in lst2\n\n    // Count odd elements in lst1\n    for (int num : lst1) {\n        if (num % 2 != 0) {\n            oddCount++;\n        }\n    }\n\n    // Count even elements in lst2\n    for (int num : lst2) {\n        if (num % 2 == 0) {\n            evenCount++;\n        }\n    }\n\n    // Check if there are enough even elements in lst2 to replace all odd elements in lst1\n    if (evenCount >= oddCount) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n"}
{"task_id": "CPP/111", "generation": "#include <iostream>\n#include <string>\n#include <map>\n#include <sstream>\nusing namespace std;\n\nmap<char, int> histogram(const string& test) {\n    map<char, int> freqMap;\n    stringstream ss(test);\n    char ch;\n\n    // Count the frequency of each character\n    while (ss >> ch) {\n        freqMap[ch]++;\n    }\n\n    // Find the maximum frequency\n    int maxFreq = 0;\n    for (const auto& pair : freqMap) {\n        if (pair.second > maxFreq) {\n            maxFreq = pair.second;\n        }\n    }\n\n    // Create a result map with only the characters that have the maximum frequency\n    map<char, int> result;\n    for (const auto& pair : freqMap) {\n        if (pair.second == maxFreq) {\n            result.insert(pair);\n        }\n    }\n\n    return result;\n}\n\n// Function to test the histogram function\nvoid testHistogram() {\n    auto printMap = [](const map<char, int>& m) {\n        cout << \"{\";\n        for (const auto& pair : m) {\n            cout << \"{\" << pair.first << \", \" << pair.second << \"} \";\n        }\n        cout << \"}\" << endl;\n    };\n\n    printMap(histogram(\"a b c\")); // {{a, 1} {b, 1} {c, 1}}\n    printMap(histogram(\"a b b a\")); // {{a, 2} {b, 2}}\n    printMap(histogram(\"a b c a b\")); // {{a, 2} {b, 2}}\n    printMap(histogram(\"b b b b a\")); // {{b, 4}}\n    printMap(histogram(\"\")); // {}\n}\n\n"}
{"task_id": "CPP/80", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_happy(const string& s) {\n    // Check if the length of the string is less than 3\n    if (s.length() < 3) {\n        return false;\n    }\n\n    // Iterate through the string and check every 3 consecutive characters\n    for (size_t i = 0; i < s.length() - 2; ++i) {\n        if (s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]) {\n            return false;\n        }\n    }\n\n    // If all sets of 3 consecutive characters are distinct, the string is happy\n    return true;\n}\n\n"}
