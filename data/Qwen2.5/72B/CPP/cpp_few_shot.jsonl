{"task_id": "CPP/0", "generation": "#include<stdio.h>\n#include<vector>\n#include<math.h>\nusing namespace std;\n\nbool has_close_elements(vector<float> numbers, float threshold) {\n    // Sort the vector to make it easier to find close elements\n    sort(numbers.begin(), numbers.end());\n\n    // Iterate through the sorted vector and check the difference between consecutive elements\n    for (size_t i = 1; i < numbers.size(); ++i) {\n        if (abs(numbers[i] - numbers[i - 1]) < threshold) {\n            return true;\n        }\n    }\n\n    return false;\n}\n"}
{"task_id": "CPP/1", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> separate_paren_groups(string paren_string) {\n    vector<string> groups;\n    int balance = 0;\n    string current_group = \"\";\n\n    for (char c : paren_string) {\n        if (c == ' ') continue; // Ignore spaces\n\n        if (c == '(') {\n            balance++;\n            current_group += c;\n        } else if (c == ')') {\n            balance--;\n            current_group += c;\n            if (balance == 0) {\n                groups.push_back(current_group);\n                current_group = \"\";\n            }\n        }\n    }\n\n    return groups;\n}\n"}
{"task_id": "CPP/2", "generation": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n\nfloat truncate_number(float number) {\n    float integerPart = floor(number);\n    float decimalPart = number - integerPart;\n    return decimalPart;\n}\n"}
{"task_id": "CPP/3", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nbool below_zero(vector<int> operations) {\n    int balance = 0;\n    for (int op : operations) {\n        balance += op;\n        if (balance < 0) {\n            return true;\n        }\n    }\n    return false;\n}\n"}
{"task_id": "CPP/4", "generation": "#include <stdio.h>\n#include <math.h>\n#include <vector>\n#include <numeric>\nusing namespace std;\n\nfloat mean_absolute_deviation(vector<float> numbers) {\n    // Calculate the mean of the numbers\n    float mean = accumulate(numbers.begin(), numbers.end(), 0.0f) / numbers.size();\n    \n    // Calculate the sum of absolute differences from the mean\n    float sum_of_abs_diff = 0.0f;\n    for (float num : numbers) {\n        sum_of_abs_diff += abs(num - mean);\n    }\n    \n    // Calculate the mean absolute deviation\n    float mad = sum_of_abs_diff / numbers.size();\n    \n    return mad;\n}\n"}
{"task_id": "CPP/5", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> intersperse(vector<int> numbers, int delimiter) {\n    vector<int> result;\n    if (numbers.empty()) {\n        return result;\n    }\n    for (size_t i = 0; i < numbers.size() - 1; ++i) {\n        result.push_back(numbers[i]);\n        result.push_back(delimiter);\n    }\n    result.push_back(numbers.back());\n    return result;\n}\n"}
{"task_id": "CPP/6", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <sstream>\nusing namespace std;\n\nvector<int> parse_nested_parens(string paren_string) {\n    vector<int> result;\n    stringstream ss(paren_string);\n    string group;\n\n    while (getline(ss, group, ' ')) {\n        int max_depth = 0;\n        int current_depth = 0;\n        for (char c : group) {\n            if (c == '(') {\n                current_depth++;\n                max_depth = max(max_depth, current_depth);\n            } else if (c == ')') {\n                current_depth--;\n            }\n        }\n        result.push_back(max_depth);\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/7", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\nvector<string> filter_by_substring(vector<string> strings, string substring){\n    vector<string> filtered_strings;\n    for (const string& str : strings) {\n        if (str.find(substring) != string::npos) {\n            filtered_strings.push_back(str);\n        }\n    }\n    return filtered_strings;\n}\n"}
{"task_id": "CPP/8", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> sum_product(vector<int> numbers) {\n    int sum = 0;\n    int product = 1;\n\n    for (int num : numbers) {\n        sum += num;\n        product *= num;\n    }\n\n    return {sum, product};\n}\n"}
{"task_id": "CPP/9", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\nvector<int> rolling_max(vector<int> numbers){\n    vector<int> result;\n    if (numbers.empty()) return result;\n\n    int maxSoFar = numbers[0];\n    result.push_back(maxSoFar);\n\n    for (size_t i = 1; i < numbers.size(); ++i) {\n        if (numbers[i] > maxSoFar) {\n            maxSoFar = numbers[i];\n        }\n        result.push_back(maxSoFar);\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/10", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nbool is_palindrome(const string& str) {\n    string s(str.rbegin(), str.rend());\n    return s == str;\n}\n\nstring make_palindrome(const string& str) {\n    int n = str.length();\n    for (int i = 0; i < n; ++i) {\n        string suffix = str.substr(i);\n        if (is_palindrome(suffix)) {\n            string prefix = str.substr(0, i);\n            reverse(prefix.begin(), prefix.end());\n            return str + prefix;\n        }\n    }\n    return str;\n}\n\n"}
{"task_id": "CPP/11", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring string_xor(string a, string b) {\n    string result = \"\";\n    for (size_t i = 0; i < a.length(); ++i) {\n        // XOR the bits and append to the result string\n        if (a[i] == b[i]) {\n            result += \"0\";\n        } else {\n            result += \"1\";\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/12", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring longest(vector<string> strings) {\n    if (strings.empty()) {\n        return \"\"; // Return an empty string to represent None\n    }\n\n    string max_str = strings[0];\n    for (const string& str : strings) {\n        if (str.length() > max_str.length()) {\n            max_str = str;\n        }\n    }\n    return max_str;\n}\n\n// Test cases\n"}
{"task_id": "CPP/13", "generation": "#include<stdio.h>\nusing namespace std;\n\nint greatest_common_divisor(int a, int b) {\n    while (b != 0) {\n        int temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n\n// Test cases\n"}
{"task_id": "CPP/14", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\nvector<string> all_prefixes(string str){\n    vector<string> prefixes;\n    for (size_t i = 1; i <= str.length(); ++i) {\n        prefixes.push_back(str.substr(0, i));\n    }\n    return prefixes;\n}\n"}
{"task_id": "CPP/15", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring string_sequence(int n) {\n    string result = \"\";\n    for (int i = 0; i <= n; ++i) {\n        result += to_string(i);\n        if (i < n) {\n            result += \" \";\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/16", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<set>\nusing namespace std;\n\nint count_distinct_characters(string str) { \n    set<char> distinct_chars;\n    for (char c : str) {\n        distinct_chars.insert(tolower(c));\n    }\n    return distinct_chars.size();\n}\n"}
{"task_id": "CPP/17", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<int> parse_music(string music_string) {\n    vector<int> beats;\n    size_t start = 0;\n    size_t end = music_string.find(' ');\n\n    while (end != string::npos) {\n        string note = music_string.substr(start, end - start);\n        if (note == \"o\") {\n            beats.push_back(4);\n        } else if (note == \"o|\") {\n            beats.push_back(2);\n        } else if (note == \".|\") {\n            beats.push_back(1);\n        }\n        start = end + 1;\n        end = music_string.find(' ', start);\n    }\n\n    // Handle the last note\n    string last_note = music_string.substr(start);\n    if (last_note == \"o\") {\n        beats.push_back(4);\n    } else if (last_note == \"o|\") {\n        beats.push_back(2);\n    } else if (last_note == \".|\") {\n        beats.push_back(1);\n    }\n\n    return beats;\n}\n"}
{"task_id": "CPP/18", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nint how_many_times(string str, string substring) {\n    if (substring.empty()) return 0;\n\n    int count = 0;\n    size_t pos = 0;\n\n    while ((pos = str.find(substring, pos)) != string::npos) {\n        count++;\n        pos++; // Move to the next character to allow overlapping matches\n    }\n\n    return count;\n}\n"}
{"task_id": "CPP/19", "generation": "#include <iostream>\n#include <string>\n#include <vector>\n#include <map>\n#include <sstream>\n#include <algorithm>\n\nusing namespace std;\n\nstring sort_numbers(string numbers) {\n    // Map of number words to their numeric values\n    map<string, int> numberMap = {\n        {\"zero\", 0},\n        {\"one\", 1},\n        {\"two\", 2},\n        {\"three\", 3},\n        {\"four\", 4},\n        {\"five\", 5},\n        {\"six\", 6},\n        {\"seven\", 7},\n        {\"eight\", 8},\n        {\"nine\", 9}\n    };\n\n    // Split the input string into words\n    stringstream ss(numbers);\n    vector<string> words;\n    string word;\n    while (ss >> word) {\n        words.push_back(word);\n    }\n\n    // Convert words to their numeric values\n    vector<int> nums;\n    for (const string& word : words) {\n        nums.push_back(numberMap[word]);\n    }\n\n    // Sort the numeric values\n    sort(nums.begin(), nums.end());\n\n    // Convert the sorted numeric values back to words\n    vector<string> sortedWords;\n    for (int num : nums) {\n        for (const auto& pair : numberMap) {\n            if (pair.second == num) {\n                sortedWords.push_back(pair.first);\n                break;\n            }\n        }\n    }\n\n    // Join the sorted words back into a single string\n    stringstream result;\n    for (size_t i = 0; i < sortedWords.size(); ++i) {\n        if (i > 0) {\n            result << \" \";\n        }\n        result << sortedWords[i];\n    }\n\n    return result.str();\n}\n\n"}
{"task_id": "CPP/20", "generation": "#include <vector>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\n\nvector<float> find_closest_elements(vector<float> numbers) {\n    // Sort the vector to make finding the closest elements easier\n    sort(numbers.begin(), numbers.end());\n\n    float min_diff = INFINITY;\n    vector<float> closest_pair(2);\n\n    // Iterate through the sorted vector to find the closest pair\n    for (size_t i = 0; i < numbers.size() - 1; ++i) {\n        float diff = numbers[i + 1] - numbers[i];\n        if (diff < min_diff) {\n            min_diff = diff;\n            closest_pair[0] = numbers[i];\n            closest_pair[1] = numbers[i + 1];\n        }\n    }\n\n    return closest_pair;\n}\n"}
{"task_id": "CPP/21", "generation": "#include <stdio.h>\n#include <math.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<float> rescale_to_unit(vector<float> numbers) {\n    // Find the minimum and maximum values in the vector\n    float min_val = *min_element(numbers.begin(), numbers.end());\n    float max_val = *max_element(numbers.begin(), numbers.end());\n\n    // Calculate the range\n    float range = max_val - min_val;\n\n    // Apply the linear transformation\n    for (float& num : numbers) {\n        num = (num - min_val) / range;\n    }\n\n    return numbers;\n}\n"}
{"task_id": "CPP/22", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <boost/any.hpp>\n#include <list>\n#include <typeinfo>\n\ntypedef std::list<boost::any> list_any;\nusing namespace std;\n\nvector<int> filter_integers(list_any values) {\n    vector<int> result;\n    for (const auto& value : values) {\n        if (value.type() == typeid(int)) {\n            result.push_back(boost::any_cast<int>(value));\n        }\n    }\n    return result;\n}\n\n// Test cases\n"}
{"task_id": "CPP/23", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nint strlen(string str) {\n    return str.length();\n}\n"}
{"task_id": "CPP/24", "generation": "#include<stdio.h>\nusing namespace std;\n\nint largest_divisor(int n) {\n    for (int i = n / 2; i >= 1; --i) {\n        if (n % i == 0) {\n            return i;\n        }\n    }\n    return 1; // If no divisor is found, return 1 (every number is divisible by 1)\n}\n\n// Example usage\n"}
{"task_id": "CPP/25", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> factorize(int n) {\n    vector<int> factors;\n    // Check for number of 2s in n\n    while (n % 2 == 0) {\n        factors.push_back(2);\n        n /= 2;\n    }\n    // Check for odd factors\n    for (int i = 3; i * i <= n; i += 2) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n    // If n is a prime number greater than 2\n    if (n > 2) {\n        factors.push_back(n);\n    }\n    return factors;\n}\n"}
{"task_id": "CPP/26", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\n#include<unordered_map>\nusing namespace std;\n\nvector<int> remove_duplicates(vector<int> numbers) {\n    unordered_map<int, int> countMap;\n    vector<int> result;\n\n    // Count occurrences of each number\n    for (int num : numbers) {\n        countMap[num]++;\n    }\n\n    // Add numbers to result if they occur only once\n    for (int num : numbers) {\n        if (countMap[num] == 1) {\n            result.push_back(num);\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/27", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring flip_case(string str) {\n    for (char &c : str) {\n        if (islower(c)) {\n            c = toupper(c);\n        } else if (isupper(c)) {\n            c = tolower(c);\n        }\n    }\n    return str;\n}\n"}
{"task_id": "CPP/28", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring concatenate(vector<string> strings) {\n    string result = \"\";\n    for (const string& str : strings) {\n        result += str;\n    }\n    return result;\n}\n"}
{"task_id": "CPP/29", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\nvector<string> filter_by_prefix(vector<string> strings, string prefix){\n    vector<string> filteredStrings;\n    for (const string& str : strings) {\n        if (str.substr(0, prefix.length()) == prefix) {\n            filteredStrings.push_back(str);\n        }\n    }\n    return filteredStrings;\n}\n"}
{"task_id": "CPP/30", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\nvector<float> get_positive(vector<float> l) {\n    vector<float> result;\n    for (float num : l) {\n        if (num > 0) {\n            result.push_back(num);\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/31", "generation": "#include <iostream>\nusing namespace std;\n\nbool is_prime(long long n) {\n    if (n <= 1) return false; // 0 and 1 are not prime numbers\n    if (n == 2 || n == 3) return true; // 2 and 3 are prime numbers\n    if (n % 2 == 0 || n % 3 == 0) return false; // Eliminate multiples of 2 and 3\n\n    // Check for factors from 5 to sqrt(n), skipping even numbers and multiples of 3\n    for (long long i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) return false;\n    }\n\n    return true;\n}\n\n// Test cases\n"}
{"task_id": "CPP/32", "generation": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <limits>\n\nusing namespace std;\n\n// Function to evaluate the polynomial\ndouble poly(const vector<double>& xs, double x) {\n    double sum = 0;\n    for (size_t i = 0; i < xs.size(); ++i) {\n        sum += xs[i] * pow(x, i);\n    }\n    return sum;\n}\n\n// Function to evaluate the derivative of the polynomial\ndouble poly_derivative(const vector<double>& xs, double x) {\n    double sum = 0;\n    for (size_t i = 1; i < xs.size(); ++i) {\n        sum += i * xs[i] * pow(x, i - 1);\n    }\n    return sum;\n}\n\n// Function to find a zero of the polynomial using the Newton-Raphson method\ndouble find_zero(const vector<double>& xs) {\n    // Initial guess\n    double x = 0.0;\n    double epsilon = 1e-6; // Tolerance for convergence\n    double max_iterations = 1000; // Maximum number of iterations\n\n    for (int i = 0; i < max_iterations; ++i) {\n        double f_x = poly(xs, x);\n        double f_prime_x = poly_derivative(xs, x);\n\n        // Check if the derivative is zero to avoid division by zero\n        if (fabs(f_prime_x) < epsilon) {\n            break;\n        }\n\n        // Update the guess using the Newton-Raphson formula\n        double new_x = x - f_x / f_prime_x;\n\n        // Check for convergence\n        if (fabs(new_x - x) < epsilon) {\n            return new_x;\n        }\n\n        x = new_x;\n    }\n\n    // If no convergence, return the best guess found\n    return x;\n}\n\n"}
{"task_id": "CPP/33", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<int> sort_third(vector<int> l) {\n    vector<int> to_sort;\n    \n    // Collect elements at indices divisible by 3\n    for (int i = 0; i < l.size(); i++) {\n        if (i % 3 == 0) {\n            to_sort.push_back(l[i]);\n        }\n    }\n    \n    // Sort the collected elements\n    sort(to_sort.begin(), to_sort.end());\n    \n    // Replace elements at indices divisible by 3 with sorted elements\n    int sort_index = 0;\n    for (int i = 0; i < l.size(); i++) {\n        if (i % 3 == 0) {\n            l[i] = to_sort[sort_index++];\n        }\n    }\n    \n    return l;\n}\n"}
{"task_id": "CPP/34", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<int> unique(vector<int> l) {\n    sort(l.begin(), l.end()); // Sort the vector\n    auto last = unique(l.begin(), l.end()); // Remove duplicates\n    l.erase(last, l.end()); // Erase the duplicates from the vector\n    return l;\n}\n"}
{"task_id": "CPP/35", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\nfloat max_element(vector<float> l) {\n    if (l.empty()) {\n        throw std::invalid_argument(\"The vector is empty\");\n    }\n    float max_val = l[0];\n    for (float val : l) {\n        if (val > max_val) {\n            max_val = val;\n        }\n    }\n    return max_val;\n}\n"}
{"task_id": "CPP/36", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint countSevens(int number) {\n    int count = 0;\n    while (number > 0) {\n        if (number % 10 == 7) {\n            count++;\n        }\n        number /= 10;\n    }\n    return count;\n}\n\nint fizz_buzz(int n) {\n    int count = 0;\n    for (int i = 1; i < n; ++i) {\n        if (i % 11 == 0 || i % 13 == 0) {\n            count += countSevens(i);\n        }\n    }\n    return count;\n}\n\n"}
{"task_id": "CPP/37", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<float> sort_even(vector<float> l) {\n    vector<float> evenElements;\n    \n    // Extract even-indexed elements\n    for (size_t i = 0; i < l.size(); i += 2) {\n        evenElements.push_back(l[i]);\n    }\n    \n    // Sort the even-indexed elements\n    sort(evenElements.begin(), evenElements.end());\n    \n    // Place the sorted even-indexed elements back into the original vector\n    for (size_t i = 0, j = 0; i < l.size(); i += 2, ++j) {\n        l[i] = evenElements[j];\n    }\n    \n    return l;\n}\n\n// Example usage\n"}
{"task_id": "CPP/38", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring encode_cyclic(string s) { \n    // returns encoded string by cycling groups of three characters.  \n    // split string to groups. Each of length 3.\n    int l = s.length();\n    int num = (l + 2) / 3;\n    string x, output;\n    for (int i = 0; i * 3 < l; i++) {\n        // cycle elements in each group. Unless group has fewer elements than 3.\n        x = s.substr(i * 3, 3);\n        if (x.length() == 3) x = x.substr(1) + x[0];\n        output += x;\n    }\n    return output;\n}\n\nstring decode_cyclic(string s) { \n    // takes as input string encoded with encode_cyclic function. Returns decoded string. \n    int l = s.length();\n    int num = (l + 2) / 3;\n    string x, output;\n    for (int i = 0; i * 3 < l; i++) {\n        // reverse the cyclic shift for each group of three characters.\n        x = s.substr(i * 3, 3);\n        if (x.length() == 3) x = x[2] + x.substr(0, 2);\n        output += x;\n    }\n    return output;\n}\n\n"}
{"task_id": "CPP/39", "generation": "#include <iostream>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    if (num == 2) return true;\n    if (num % 2 == 0) return false;\n    for (int i = 3; i <= sqrt(num); i += 2) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\n// Function to find the n-th prime Fibonacci number\nint prime_fib(int n) {\n    int count = 0;\n    int a = 0, b = 1;\n    while (true) {\n        int fib = a + b;\n        a = b;\n        b = fib;\n        if (is_prime(fib)) {\n            count++;\n            if (count == n) {\n                return fib;\n            }\n        }\n    }\n}\n\n"}
{"task_id": "CPP/40", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nbool triples_sum_to_zero(vector<int> l) {\n    // Sort the vector to make it easier to find triplets\n    sort(l.begin(), l.end());\n\n    // Iterate through the vector, trying to find a triplet that sums to zero\n    for (int i = 0; i < l.size() - 2; ++i) {\n        // Use two pointers to find the other two elements\n        int left = i + 1;\n        int right = l.size() - 1;\n\n        while (left < right) {\n            int sum = l[i] + l[left] + l[right];\n\n            if (sum == 0) {\n                return true;\n            } else if (sum < 0) {\n                left++; // Move the left pointer to the right to increase the sum\n            } else {\n                right--; // Move the right pointer to the left to decrease the sum\n            }\n        }\n    }\n\n    return false;\n}\n\n// Test cases\n"}
{"task_id": "CPP/41", "generation": "#include <stdio.h>\nusing namespace std;\n\nint car_race_collision(int n) {\n    // Since each car going left to right will eventually collide with each car going right to left,\n    // the total number of collisions is simply the product of the number of cars in each direction.\n    return n * n;\n}\n"}
{"task_id": "CPP/42", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> incr_list(vector<int> l) {\n    for (int& element : l) {\n        element += 1;\n    }\n    return l;\n}\n"}
{"task_id": "CPP/43", "generation": "#include <iostream>\n#include <vector>\n#include <unordered_set>\nusing namespace std;\n\nbool pairs_sum_to_zero(vector<int> l) {\n    unordered_set<int> seen;\n    for (int num : l) {\n        if (seen.find(-num) != seen.end()) {\n            return true;\n        }\n        seen.insert(num);\n    }\n    return false;\n}\n\n"}
{"task_id": "CPP/44", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring change_base(int x, int base) {\n    string result = \"\";\n    while (x > 0) {\n        int remainder = x % base;\n        result = to_string(remainder) + result;\n        x /= base;\n    }\n    return result.empty() ? \"0\" : result;\n}\n\n// Test cases\n"}
{"task_id": "CPP/45", "generation": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n\nfloat triangle_area(float a, float h) {\n    return 0.5 * a * h;\n}\n"}
{"task_id": "CPP/46", "generation": "#include<stdio.h>\nusing namespace std;\n\nint fib4(int n) {\n    if (n == 0 || n == 1 || n == 3) return 0;\n    if (n == 2) return 2;\n\n    int a = 0, b = 0, c = 2, d = 0;\n    for (int i = 4; i <= n; ++i) {\n        int next = a + b + c + d;\n        a = b;\n        b = c;\n        c = d;\n        d = next;\n    }\n    return d;\n}\n\n// Test cases\n"}
{"task_id": "CPP/47", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nfloat median(vector<float> l) {\n    // Sort the vector\n    sort(l.begin(), l.end());\n    \n    int n = l.size();\n    // If the size of the vector is odd, return the middle element\n    if (n % 2 == 1) {\n        return l[n / 2];\n    } else {\n        // If the size of the vector is even, return the average of the two middle elements\n        return (l[n / 2 - 1] + l[n / 2]) / 2.0;\n    }\n}\n"}
{"task_id": "CPP/48", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nbool is_palindrome(string text) {\n    int left = 0;\n    int right = text.length() - 1;\n    \n    while (left < right) {\n        if (text[left] != text[right]) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n    return true;\n}\n"}
{"task_id": "CPP/49", "generation": "#include <iostream>\nusing namespace std;\n\nint modp(int n, int p) {\n    int result = 1;\n    int base = 2;\n\n    while (n > 0) {\n        if (n % 2 == 1) { // If n is odd\n            result = (result * base) % p;\n        }\n        base = (base * base) % p; // Square the base\n        n = n / 2; // Divide n by 2\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/50", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nstring encode_shift(string s) {\n    // returns encoded string by shifting every character by 5 in the alphabet.\n    string out;\n    for (char c : s) {\n        int w = ((int)c + 5 - (int)'a') % 26 + (int)'a';   \n        out += (char)w;\n    }\n    return out;\n}\n\nstring decode_shift(string s) {\n    // takes as input string encoded with encode_shift function. Returns decoded string.\n    string out;\n    for (char c : s) {\n        int w = ((int)c - 5 - (int)'a' + 26) % 26 + (int)'a'; // Ensure the result is within the valid range\n        out += (char)w;\n    }\n    return out;\n}\n"}
{"task_id": "CPP/51", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nstring remove_vowels(string text) {\n    string vowels = \"aeiouAEIOU\";\n    text.erase(remove_if(text.begin(), text.end(), [&vowels](char c) {\n        return vowels.find(c) != string::npos;\n    }), text.end());\n    return text;\n}\n\n"}
{"task_id": "CPP/52", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nbool below_threshold(vector<int> l, int t) {\n    for (int num : l) {\n        if (num >= t) {\n            return false;\n        }\n    }\n    return true;\n}\n"}
{"task_id": "CPP/53", "generation": "#include<stdio.h>\n#include<stdlib.h>\nusing namespace std;\n\nint add(int x, int y) {\n    return x + y;\n}\n"}
{"task_id": "CPP/54", "generation": "#include<stdio.h>\n#include<string>\n#include<algorithm>\n#include<set>\nusing namespace std;\n\nbool same_chars(string s0, string s1) {\n    set<char> chars_s0(s0.begin(), s0.end());\n    set<char> chars_s1(s1.begin(), s1.end());\n\n    return chars_s0 == chars_s1;\n}\n"}
{"task_id": "CPP/55", "generation": "#include<stdio.h>\nusing namespace std;\n\nint fib(int n) {\n    if (n <= 1) {\n        return n;\n    }\n    int a = 0, b = 1, c;\n    for (int i = 2; i <= n; ++i) {\n        c = a + b;\n        a = b;\n        b = c;\n    }\n    return c;\n}\n\n// Test cases\n"}
{"task_id": "CPP/56", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    int balance = 0;\n    for (char bracket : brackets) {\n        if (bracket == '<') {\n            balance++;\n        } else if (bracket == '>') {\n            balance--;\n            if (balance < 0) {\n                return false; // More closing brackets than opening brackets\n            }\n        }\n    }\n    return balance == 0; // True if all opening brackets have corresponding closing brackets\n}\n"}
{"task_id": "CPP/57", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nbool monotonic(vector<float> l) {\n    bool increasing = true;\n    bool decreasing = true;\n\n    for (size_t i = 1; i < l.size(); ++i) {\n        if (l[i] > l[i - 1]) {\n            decreasing = false;\n        } else if (l[i] < l[i - 1]) {\n            increasing = false;\n        }\n    }\n\n    return increasing || decreasing;\n}\n"}
{"task_id": "CPP/58", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<int> common(vector<int> l1, vector<int> l2) {\n    // Sort both vectors\n    sort(l1.begin(), l1.end());\n    sort(l2.begin(), l2.end());\n\n    vector<int> result;\n    // Use set_intersection to find common elements\n    set_intersection(l1.begin(), l1.end(), l2.begin(), l2.end(), back_inserter(result));\n\n    // Remove duplicates\n    auto last = unique(result.begin(), result.end());\n    result.erase(last, result.end());\n\n    return result;\n}\n"}
{"task_id": "CPP/59", "generation": "#include <iostream>\n#include <cmath>\nusing namespace std;\n\nint largest_prime_factor(int n) {\n    int maxPrime = -1;\n    while (n % 2 == 0) {\n        maxPrime = 2;\n        n /= 2;\n    }\n\n    for (int i = 3; i <= sqrt(n); i += 2) {\n        while (n % i == 0) {\n            maxPrime = i;\n            n = n / i;\n        }\n    }\n\n    if (n > 2)\n        maxPrime = n;\n\n    return maxPrime;\n}\n\n"}
{"task_id": "CPP/60", "generation": "#include<stdio.h>\nusing namespace std;\n\nint sum_to_n(int n) {\n    // Using the formula for the sum of the first n natural numbers: n * (n + 1) / 2\n    return n * (n + 1) / 2;\n}\n\n// Test cases\n"}
{"task_id": "CPP/61", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    int balance = 0;\n    for (char c : brackets) {\n        if (c == '(') {\n            balance++;\n        } else if (c == ')') {\n            balance--;\n        }\n        if (balance < 0) {\n            return false; // A closing bracket appears before a matching opening bracket\n        }\n    }\n    return balance == 0; // All opening brackets have a corresponding closing bracket\n}\n"}
{"task_id": "CPP/62", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\nvector<float> derivative(vector<float> xs) {\n    vector<float> result;\n    for (size_t i = 1; i < xs.size(); ++i) {\n        result.push_back(i * xs[i]);\n    }\n    return result;\n}\n"}
{"task_id": "CPP/63", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint fibfib(int n) {\n    if (n == 0 || n == 1) return 0;\n    if (n == 2) return 1;\n\n    // Initialize a vector to store the FibFib values up to n\n    vector<int> dp(n + 1);\n    dp[0] = 0;\n    dp[1] = 0;\n    dp[2] = 1;\n\n    // Compute the FibFib values iteratively\n    for (int i = 3; i <= n; ++i) {\n        dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3];\n    }\n\n    return dp[n];\n}\n\n"}
{"task_id": "CPP/64", "generation": "#include <stdio.h>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nint vowels_count(string s) {\n    int count = 0;\n    string vowels = \"aeiouAEIOU\";\n    for (char c : s) {\n        if (vowels.find(c) != string::npos) {\n            count++;\n        }\n    }\n    if (s.back() == 'y' || s.back() == 'Y') {\n        count++;\n    }\n    return count;\n}\n"}
{"task_id": "CPP/65", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nstring circular_shift(int x, int shift) {\n    string digits = to_string(x);\n    int n = digits.length();\n    shift %= n; // In case shift is greater than the number of digits\n    if (shift == 0) {\n        return digits;\n    }\n    // Perform the circular shift\n    string shifted = digits.substr(n - shift) + digits.substr(0, n - shift);\n    return shifted;\n}\n\n// Example usage\n"}
{"task_id": "CPP/66", "generation": "#include <string>\nusing namespace std;\n\nint digitSum(string s) {\n    int sum = 0;\n    for (char c : s) {\n        if (isupper(c)) {\n            sum += c;\n        }\n    }\n    return sum;\n}\n"}
{"task_id": "CPP/67", "generation": "#include <string>\n#include <sstream>\n#include <iostream>\nusing namespace std;\n\nint fruit_distribution(string s, int n) {\n    int apples, oranges;\n    // Parse the input string to extract the number of apples and oranges\n    stringstream ss(s);\n    ss >> apples >> ws; // Read the number of apples and ignore whitespace\n    ss.ignore(10, ' '); // Ignore the word \"apples\" and \"and\"\n    ss >> oranges; // Read the number of oranges\n\n    // Calculate the number of mangoes\n    int mangoes = n - (apples + oranges);\n    return mangoes;\n}\n\n// Function to test the solution\nvoid test_fruit_distribution() {\n    cout << fruit_distribution(\"5 apples and 6 oranges\", 19) << endl; // Expected output: 8\n    cout << fruit_distribution(\"0 apples and 1 oranges\", 3) << endl; // Expected output: 2\n    cout << fruit_distribution(\"2 apples and 3 oranges\", 100) << endl; // Expected output: 95\n    cout << fruit_distribution(\"100 apples and 1 oranges\", 120) << endl; // Expected output: 19\n}\n\n"}
{"task_id": "CPP/68", "generation": "#include <vector>\n#include <limits>\nusing namespace std;\n\nvector<int> pluck(vector<int> arr) {\n    int smallest_even_value = numeric_limits<int>::max();\n    int smallest_index = -1;\n\n    for (int i = 0; i < arr.size(); ++i) {\n        if (arr[i] % 2 == 0 && arr[i] < smallest_even_value) {\n            smallest_even_value = arr[i];\n            smallest_index = i;\n        }\n    }\n\n    if (smallest_index == -1) {\n        return {};\n    } else {\n        return {smallest_even_value, smallest_index};\n    }\n}\n"}
{"task_id": "CPP/69", "generation": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <algorithm>\nusing namespace std;\n\nint search(vector<int> lst) {\n    unordered_map<int, int> freqMap;\n    \n    // Count the frequency of each element\n    for (int num : lst) {\n        freqMap[num]++;\n    }\n    \n    int result = -1;\n    \n    // Check for the greatest integer that meets the condition\n    for (const auto& entry : freqMap) {\n        if (entry.first > 0 && entry.second >= entry.first) {\n            result = max(result, entry.first);\n        }\n    }\n    \n    return result;\n}\n\n// Test cases\n"}
{"task_id": "CPP/70", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<int> strange_sort_list(vector<int> lst) {\n    vector<int> sortedList;\n    while (!lst.empty()) {\n        // Find and remove the minimum element\n        auto minIt = min_element(lst.begin(), lst.end());\n        sortedList.push_back(*minIt);\n        lst.erase(minIt);\n\n        if (!lst.empty()) {\n            // Find and remove the maximum element\n            auto maxIt = max_element(lst.begin(), lst.end());\n            sortedList.push_back(*maxIt);\n            lst.erase(maxIt);\n        }\n    }\n    return sortedList;\n}\n"}
{"task_id": "CPP/71", "generation": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n\nfloat triangle_area(float a, float b, float c) {\n    // Check if the sides form a valid triangle\n    if (a + b <= c || a + c <= b || b + c <= a) {\n        return -1;\n    }\n\n    // Calculate the semi-perimeter\n    float s = (a + b + c) / 2;\n\n    // Calculate the area using Heron's formula\n    float area = sqrt(s * (s - a) * (s - b) * (s - c));\n\n    // Round the area to 2 decimal points\n    return round(area * 100) / 100;\n}\n"}
{"task_id": "CPP/72", "generation": "#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nbool will_it_fly(vector<int> q, int w) {\n    // Check if the vector is a palindrome\n    bool isBalanced = true;\n    for (size_t i = 0; i < q.size() / 2; ++i) {\n        if (q[i] != q[q.size() - 1 - i]) {\n            isBalanced = false;\n            break;\n        }\n    }\n\n    // Calculate the sum of the elements\n    int sum = accumulate(q.begin(), q.end(), 0);\n\n    // Check if the object will fly\n    return isBalanced && sum <= w;\n}\n"}
{"task_id": "CPP/73", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint smallest_change(vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n\n    for (int i = 0; i < n / 2; ++i) {\n        if (arr[i] != arr[n - 1 - i]) {\n            changes++;\n        }\n    }\n\n    return changes;\n}\n\n// Test cases\n"}
{"task_id": "CPP/74", "generation": "#include <vector>\n#include <string>\n#include <numeric>\nusing namespace std;\n\nvector<string> total_match(vector<string> lst1, vector<string> lst2) {\n    // Helper function to calculate the total number of characters in a vector of strings\n    auto totalChars = [](const vector<string>& lst) {\n        return accumulate(lst.begin(), lst.end(), 0, [](int sum, const string& s) {\n            return sum + s.length();\n        });\n    };\n\n    int total1 = totalChars(lst1);\n    int total2 = totalChars(lst2);\n\n    if (total1 <= total2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n"}
{"task_id": "CPP/75", "generation": "#include <iostream>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    for (int i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) return false;\n    }\n    return true;\n}\n\nbool is_multiply_prime(int a) {\n    if (a < 2) return false;\n    vector<int> primes;\n    for (int i = 2; i < 100; ++i) {\n        if (is_prime(i)) {\n            primes.push_back(i);\n        }\n    }\n\n    for (int i : primes) {\n        if (a % i == 0) {\n            int quotient = a / i;\n            for (int j : primes) {\n                if (quotient % j == 0) {\n                    int second_quotient = quotient / j;\n                    for (int k : primes) {\n                        if (second_quotient % k == 0 && second_quotient / k == 1) {\n                            return true;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return false;\n}\n\n"}
{"task_id": "CPP/76", "generation": "#include <cmath>\n#include <iostream>\n\nbool is_simple_power(int x, int n) {\n    if (n == 1) {\n        return x == 1;\n    }\n    if (x == 1) {\n        return n == 1;\n    }\n    if (x == 0 || n == 0) {\n        return false;\n    }\n\n    int power = 0;\n    while (std::pow(n, power) < x) {\n        power++;\n    }\n\n    return std::pow(n, power) == x;\n}\n\n// Test cases\n"}
{"task_id": "CPP/77", "generation": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n\nbool iscube(int a) {\n    if (a == 0) return true; // 0 is a cube of 0\n    int root = round(cbrt(a)); // Calculate the cube root and round it to the nearest integer\n    return root * root * root == a; // Check if the cube of the rounded root equals the original number\n}\n\n// Test cases\n"}
{"task_id": "CPP/78", "generation": "#include <string>\n#include <algorithm>\nusing namespace std;\n\nint hex_key(string num) {\n    // Define the set of prime hexadecimal digits\n    const string primeHexDigits = \"2357BD\";\n    \n    // Initialize the count of prime digits\n    int primeCount = 0;\n    \n    // Iterate through each character in the input string\n    for (char c : num) {\n        // Check if the current character is a prime hexadecimal digit\n        if (primeHexDigits.find(c) != string::npos) {\n            primeCount++;\n        }\n    }\n    \n    return primeCount;\n}\n\n// Example usage\n"}
{"task_id": "CPP/79", "generation": "#include <string>\nusing namespace std;\n\nstring decimal_to_binary(int decimal) {\n    if (decimal == 0) return \"db0db\";\n\n    string binary = \"\";\n    while (decimal > 0) {\n        binary = to_string(decimal % 2) + binary;\n        decimal /= 2;\n    }\n\n    return \"db\" + binary + \"db\";\n}\n"}
{"task_id": "CPP/80", "generation": "#include <string>\nusing namespace std;\n\nbool is_happy(string s) {\n    // Check if the length of the string is less than 3\n    if (s.length() < 3) {\n        return false;\n    }\n\n    // Iterate through the string to check every 3 consecutive letters\n    for (size_t i = 0; i < s.length() - 2; ++i) {\n        if (s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]) {\n            return false;\n        }\n    }\n\n    // If no three consecutive letters are the same, the string is happy\n    return true;\n}\n"}
{"task_id": "CPP/81", "generation": "#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> numerical_letter_grade(vector<float> grades) {\n    vector<string> letterGrades;\n    for (float gpa : grades) {\n        if (gpa == 4.0) letterGrades.push_back(\"A+\");\n        else if (gpa > 3.7) letterGrades.push_back(\"A\");\n        else if (gpa > 3.3) letterGrades.push_back(\"A-\");\n        else if (gpa > 3.0) letterGrades.push_back(\"B+\");\n        else if (gpa > 2.7) letterGrades.push_back(\"B\");\n        else if (gpa > 2.3) letterGrades.push_back(\"B-\");\n        else if (gpa > 2.0) letterGrades.push_back(\"C+\");\n        else if (gpa > 1.7) letterGrades.push_back(\"C\");\n        else if (gpa > 1.3) letterGrades.push_back(\"C-\");\n        else if (gpa > 1.0) letterGrades.push_back(\"D+\");\n        else if (gpa > 0.7) letterGrades.push_back(\"D\");\n        else if (gpa > 0.0) letterGrades.push_back(\"D-\");\n        else letterGrades.push_back(\"E\");\n    }\n    return letterGrades;\n}\n"}
{"task_id": "CPP/82", "generation": "#include <stdio.h>\n#include <string>\n#include <cmath>\nusing namespace std;\n\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    for (int i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) return false;\n    }\n    return true;\n}\n\nbool prime_length(string str) {\n    int length = str.length();\n    return is_prime(length);\n}\n"}
{"task_id": "CPP/83", "generation": "#include <iostream>\nusing namespace std;\n\nint starts_one_ends(int n) {\n    if (n == 1) {\n        return 1; // Only one 1-digit number starts and ends with 1, which is 1 itself.\n    }\n\n    // For n > 1, we can calculate the count as follows:\n    // - Numbers starting with 1: There are 10^(n-1) such numbers.\n    // - Numbers ending with 1: There are 10^(n-1) such numbers.\n    // - Numbers starting and ending with 1: There are 10^(n-2) such numbers (to avoid double-counting).\n\n    long long total_start_with_1 = pow(10, n - 1);\n    long long total_end_with_1 = pow(10, n - 1);\n    long long total_start_and_end_with_1 = pow(10, n - 2);\n\n    // Total count = (Numbers starting with 1) + (Numbers ending with 1) - (Numbers starting and ending with 1)\n    return total_start_with_1 + total_end_with_1 - total_start_and_end_with_1;\n}\n\n"}
{"task_id": "CPP/84", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring solve(int N) {\n    // Step 1: Calculate the sum of the digits\n    int sum = 0;\n    while (N > 0) {\n        sum += N % 10;\n        N /= 10;\n    }\n\n    // Step 2: Convert the sum to binary\n    string binary = \"\";\n    if (sum == 0) {\n        return \"0\";\n    }\n    while (sum > 0) {\n        binary = to_string(sum % 2) + binary;\n        sum /= 2;\n    }\n\n    // Step 3: Return the binary representation\n    return binary;\n}\n\n// Function to test the solution\nvoid test() {\n    cout << solve(1000) << \" (Expected: 1)\" << endl;\n    cout << solve(150) << \" (Expected: 110)\" << endl;\n    cout << solve(147) << \" (Expected: 1100)\" << endl;\n}\n\n"}
{"task_id": "CPP/85", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nint add(vector<int> lst) {\n    int sum = 0;\n    for (size_t i = 1; i < lst.size(); i += 2) {\n        if (lst[i] % 2 == 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n"}
{"task_id": "CPP/86", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nstring anti_shuffle(string s) {\n    // Lambda function to sort a word's characters\n    auto sort_word = [](string& word) {\n        sort(word.begin(), word.end());\n    };\n\n    // Variables to store the result and track the start of each word\n    string result = \"\";\n    int word_start = 0;\n\n    // Iterate through the string\n    for (int i = 0; i <= s.length(); ++i) {\n        // Check if we reached the end of a word or the end of the string\n        if (i == s.length() || s[i] == ' ') {\n            // Sort the current word\n            sort_word(s.substr(word_start, i - word_start));\n            // Append the sorted word to the result\n            result += s.substr(word_start, i - word_start);\n            // If not at the end of the string, add a space\n            if (i < s.length()) {\n                result += ' ';\n            }\n            // Update the start of the next word\n            word_start = i + 1;\n        }\n    }\n\n    return result;\n}\n\n// Function to test the anti_shuffle function\nvoid test_anti_shuffle() {\n    cout << anti_shuffle(\"Hi\") << endl; // Output: \"Hi\"\n    cout << anti_shuffle(\"hello\") << endl; // Output: \"ehllo\"\n    cout << anti_shuffle(\"Hello World!!!\") << endl; // Output: \"Hello !!!Wdlor\"\n}\n\n"}
{"task_id": "CPP/87", "generation": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<vector<int>> get_row(vector<vector<int>> lst, int x) {\n    vector<vector<int>> result;\n\n    // Iterate through each row and column to find occurrences of x\n    for (int i = 0; i < lst.size(); ++i) {\n        for (int j = 0; j < lst[i].size(); ++j) {\n            if (lst[i][j] == x) {\n                result.push_back({i, j});\n            }\n        }\n    }\n\n    // Sort the result by rows in ascending order\n    sort(result.begin(), result.end(), [](const vector<int>& a, const vector<int>& b) {\n        if (a[0] == b[0]) {\n            return a[1] > b[1]; // Sort columns in descending order within the same row\n        }\n        return a[0] < b[0];\n    });\n\n    return result;\n}\n"}
{"task_id": "CPP/88", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<int> sort_array(vector<int> array) {\n    if (array.empty()) {\n        return array;\n    }\n\n    int first = array.front();\n    int last = array.back();\n    int sum = first + last;\n\n    vector<int> sortedArray = array;\n\n    if (sum % 2 == 0) {\n        // Sort in descending order\n        sort(sortedArray.begin(), sortedArray.end(), greater<int>());\n    } else {\n        // Sort in ascending order\n        sort(sortedArray.begin(), sortedArray.end());\n    }\n\n    return sortedArray;\n}\n"}
{"task_id": "CPP/89", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring encrypt(string s) {\n    string result = \"\";\n    for (char c : s) {\n        if (islower(c)) {\n            // Shift lowercase letter by 4 positions\n            result += 'a' + (c - 'a' + 4) % 26;\n        } else if (isupper(c)) {\n            // Shift uppercase letter by 4 positions\n            result += 'A' + (c - 'A' + 4) % 26;\n        } else {\n            // Non-alphabetic characters remain unchanged\n            result += c;\n        }\n    }\n    return result;\n}\n\n"}
{"task_id": "CPP/90", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nint next_smallest(vector<int> lst) {\n    if (lst.size() < 2) {\n        return -1; // Return -1 to indicate None\n    }\n\n    // Sort the vector\n    sort(lst.begin(), lst.end());\n\n    // Find the second smallest element\n    for (int i = 1; i < lst.size(); ++i) {\n        if (lst[i] != lst[0]) {\n            return lst[i];\n        }\n    }\n\n    // If all elements are the same, return -1 to indicate None\n    return -1;\n}\n"}
{"task_id": "CPP/91", "generation": "#include <iostream>\n#include <string>\n#include <cctype>\nusing namespace std;\n\nint is_bored(string S) {\n    int count = 0;\n    bool isNewSentence = true;\n\n    for (size_t i = 0; i < S.length(); ++i) {\n        if (isNewSentence && S[i] == 'I' && (i + 1 < S.length() && S[i + 1] == ' ')) {\n            count++;\n        }\n        isNewSentence = S[i] == '.' || S[i] == '?' || S[i] == '!';\n    }\n\n    return count;\n}\n\n// Test cases\n"}
{"task_id": "CPP/92", "generation": "#include <cmath>\n#include <iostream>\n\nusing namespace std;\n\nbool is_integer(float num) {\n    return floor(num) == num;\n}\n\nbool any_int(float a, float b, float c) {\n    // Check if all numbers are integers\n    if (!is_integer(a) || !is_integer(b) || !is_integer(c)) {\n        return false;\n    }\n\n    // Check if any number is equal to the sum of the other two\n    if (a == b + c || b == a + c || c == a + b) {\n        return true;\n    }\n\n    return false;\n}\n\n// Test cases\n"}
{"task_id": "CPP/93", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nstring encode(string message) {\n    // Function to swap the case of a character\n    auto swapCase = [](char c) -> char {\n        if (islower(c)) return toupper(c);\n        if (isupper(c)) return tolower(c);\n        return c;\n    };\n\n    // Function to replace vowels with the letter 2 places ahead\n    auto replaceVowel = [](char c) -> char {\n        switch (tolower(c)) {\n            case 'a': return 'C';\n            case 'e': return 'G';\n            case 'i': return 'K';\n            case 'o': return 'Q';\n            case 'u': return 'W';\n            default: return c;\n        }\n    };\n\n    // Encode the message\n    for (char &c : message) {\n        c = swapCase(c);\n        c = replaceVowel(c);\n    }\n\n    return message;\n}\n\n// Test cases\n"}
{"task_id": "CPP/94", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Helper function to check if a number is prime\nbool isPrime(int n) {\n    if (n <= 1) return false;\n    if (n == 2) return true;\n    if (n % 2 == 0) return false;\n    for (int i = 3; i * i <= n; i += 2) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\n// Function to sum the digits of a number\nint sumOfDigits(int n) {\n    int sum = 0;\n    while (n > 0) {\n        sum += n % 10;\n        n /= 10;\n    }\n    return sum;\n}\n\n// Main function to find the largest prime and return the sum of its digits\nint skjkasdkd(vector<int> lst) {\n    int largestPrime = -1;\n    for (int num : lst) {\n        if (isPrime(num) && num > largestPrime) {\n            largestPrime = num;\n        }\n    }\n    if (largestPrime == -1) {\n        return 0; // No prime number found\n    }\n    return sumOfDigits(largestPrime);\n}\n\n// Example usage\n"}
{"task_id": "CPP/95", "generation": "#include <iostream>\n#include <string>\n#include <map>\n#include <cctype>\nusing namespace std;\n\nbool isLowercase(const string& str) {\n    for (char c : str) {\n        if (!islower(c)) return false;\n    }\n    return true;\n}\n\nbool isUppercase(const string& str) {\n    for (char c : str) {\n        if (!isupper(c)) return false;\n    }\n    return true;\n}\n\nbool check_dict_case(map<string, string> dict) {\n    if (dict.empty()) return false;\n\n    bool allLowercase = true;\n    bool allUppercase = true;\n\n    for (const auto& pair : dict) {\n        if (!isLowercase(pair.first)) allLowercase = false;\n        if (!isUppercase(pair.first)) allUppercase = false;\n    }\n\n    return allLowercase || allUppercase;\n}\n\n"}
{"task_id": "CPP/96", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool isPrime(int num) {\n    if (num <= 1) return false;\n    if (num == 2) return true;\n    if (num % 2 == 0) return false;\n    for (int i = 3; i * i <= num; i += 2) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\nvector<int> count_up_to(int n) {\n    vector<int> primes;\n    for (int i = 2; i < n; ++i) {\n        if (isPrime(i)) {\n            primes.push_back(i);\n        }\n    }\n    return primes;\n}\n\n// Test cases\n"}
{"task_id": "CPP/97", "generation": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n\nint multiply(int a, int b) {\n    // Extract the unit digits of both numbers\n    int unitDigitA = abs(a) % 10;\n    int unitDigitB = abs(b) % 10;\n\n    // Return the product of the unit digits\n    return unitDigitA * unitDigitB;\n}\n\n// Test cases\n"}
{"task_id": "CPP/98", "generation": "#include <stdio.h>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nint count_upper(string s) {\n    int count = 0;\n    for (int i = 0; i < s.length(); i += 2) {\n        char c = s[i];\n        if (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n            count++;\n        }\n    }\n    return count;\n}\n\n// Test cases\n"}
{"task_id": "CPP/99", "generation": "#include <iostream>\n#include <cmath>\n#include <string>\nusing namespace std;\n\nint closest_integer(string value) {\n    // Convert the string to a floating-point number\n    double num = stod(value);\n\n    // Get the floor and ceiling values\n    double floorValue = floor(num);\n    double ceilValue = ceil(num);\n\n    // Check if the number is equidistant from two integers\n    if (num - floorValue == ceilValue - num) {\n        // Round away from zero\n        if (num > 0) {\n            return static_cast<int>(ceilValue);\n        } else {\n            return static_cast<int>(floorValue);\n        }\n    } else {\n        // Use standard rounding rules\n        return static_cast<int>(round(num));\n    }\n}\n\n// Test cases\n"}
{"task_id": "CPP/100", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> make_a_pile(int n) {\n    vector<int> pile;\n    int current_stones = n;\n    for (int i = 0; i < n; ++i) {\n        pile.push_back(current_stones);\n        if (n % 2 == 0) {\n            // If n is even, the next number is the next even number\n            current_stones += 2;\n        } else {\n            // If n is odd, the next number is the next odd number\n            current_stones += 2;\n        }\n    }\n    return pile;\n}\n\n// Test cases\n#include <iostream>\n"}
{"task_id": "CPP/101", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\nusing namespace std;\n\nvector<string> words_string(string s) {\n    vector<string> words;\n    stringstream ss(s);\n    string word;\n    while (getline(ss, word, ',')) {\n        istringstream iss(word);\n        while (iss >> word) {\n            words.push_back(word);\n        }\n    }\n    return words;\n}\n\n// Test cases\n"}
{"task_id": "CPP/102", "generation": "#include<stdio.h>\nusing namespace std;\n\nint choose_num(int x, int y) {\n    // Ensure x is less than or equal to y\n    if (x > y) {\n        return -1;\n    }\n\n    // Start from y and move downwards to find the largest even number\n    for (int i = y; i >= x; i--) {\n        if (i % 2 == 0) {\n            return i;\n        }\n    }\n\n    // If no even number is found, return -1\n    return -1;\n}\n"}
{"task_id": "CPP/103", "generation": "#include <stdio.h>\n#include <math.h>\n#include <string>\nusing namespace std;\n\nstring rounded_avg(int n, int m) {\n    if (n > m) {\n        return \"-1\";\n    }\n    int sum = 0;\n    for (int i = n; i <= m; ++i) {\n        sum += i;\n    }\n    int count = m - n + 1;\n    int average = sum / count;\n    string binary = \"\";\n    if (average == 0) {\n        return \"0\";\n    }\n    while (average > 0) {\n        binary = to_string(average % 2) + binary;\n        average /= 2;\n    }\n    return binary;\n}\n"}
{"task_id": "CPP/104", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nbool hasEvenDigit(int n) {\n    while (n > 0) {\n        int digit = n % 10;\n        if (digit % 2 == 0) {\n            return true;\n        }\n        n /= 10;\n    }\n    return false;\n}\n\nvector<int> unique_digits(vector<int> x) {\n    vector<int> result;\n    for (int num : x) {\n        if (!hasEvenDigit(num)) {\n            result.push_back(num);\n        }\n    }\n    sort(result.begin(), result.end());\n    return result;\n}\n"}
{"task_id": "CPP/105", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<map>\n#include<algorithm>\nusing namespace std;\n\nvector<string> by_length(vector<int> arr) {\n    // Define the mapping from digits to their names\n    map<int, string> digit_to_name = {\n        {1, \"One\"}, {2, \"Two\"}, {3, \"Three\"}, {4, \"Four\"},\n        {5, \"Five\"}, {6, \"Six\"}, {7, \"Seven\"}, {8, \"Eight\"}, {9, \"Nine\"}\n    };\n\n    // Filter, sort, and reverse the array\n    vector<int> filtered_arr;\n    for (int num : arr) {\n        if (num >= 1 && num <= 9) {\n            filtered_arr.push_back(num);\n        }\n    }\n\n    sort(filtered_arr.begin(), filtered_arr.end());\n    reverse(filtered_arr.begin(), filtered_arr.end());\n\n    // Convert the numbers to their corresponding names\n    vector<string> result;\n    for (int num : filtered_arr) {\n        result.push_back(digit_to_name[num]);\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/106", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\n// Helper function to calculate factorial\nint factorial(int num) {\n    int result = 1;\n    for (int i = 1; i <= num; ++i) {\n        result *= i;\n    }\n    return result;\n}\n\n// Helper function to calculate the sum of numbers from 1 to num\nint sumToN(int num) {\n    return (num * (num + 1)) / 2;\n}\n\nvector<int> f(int n) {\n    vector<int> result(n);\n    for (int i = 1; i <= n; ++i) {\n        if (i % 2 == 0) {\n            result[i - 1] = factorial(i);\n        } else {\n            result[i - 1] = sumToN(i);\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/107", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nbool isPalindrome(int num) {\n    string strNum = to_string(num);\n    int left = 0, right = strNum.length() - 1;\n    while (left < right) {\n        if (strNum[left] != strNum[right]) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n    return true;\n}\n\nvector<int> even_odd_palindrome(int n) {\n    int evenCount = 0, oddCount = 0;\n    for (int i = 1; i <= n; ++i) {\n        if (isPalindrome(i)) {\n            if (i % 2 == 0) {\n                evenCount++;\n            } else {\n                oddCount++;\n            }\n        }\n    }\n    return {evenCount, oddCount};\n}\n"}
{"task_id": "CPP/108", "generation": "#include <stdio.h>\n#include <math.h>\n#include <vector>\nusing namespace std;\n\nint sum_of_digits(int num) {\n    int sum = 0;\n    bool is_negative = num < 0;\n    while (num != 0) {\n        int digit = num % 10;\n        if (is_negative && num < 0) {\n            digit = -digit;\n            is_negative = false;\n        }\n        sum += digit;\n        num /= 10;\n    }\n    return sum;\n}\n\nint count_nums(vector<int> n) {\n    int count = 0;\n    for (int num : n) {\n        if (sum_of_digits(num) > 0) {\n            count++;\n        }\n    }\n    return count;\n}\n"}
{"task_id": "CPP/109", "generation": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nbool move_one_ball(vector<int> arr) {\n    if (arr.empty()) {\n        return true;\n    }\n\n    // Find the index where the array should start to be sorted\n    int n = arr.size();\n    int start_index = -1;\n    for (int i = 0; i < n - 1; ++i) {\n        if (arr[i] > arr[i + 1]) {\n            if (start_index != -1) {\n                // More than one place where the array is not sorted\n                return false;\n            }\n            start_index = i + 1;\n        }\n    }\n\n    // If the array is already sorted\n    if (start_index == -1) {\n        return true;\n    }\n\n    // Check if the array is sorted after the potential rotation\n    for (int i = start_index; i < n - 1; ++i) {\n        if (arr[i] > arr[i + 1]) {\n            return false;\n        }\n    }\n\n    // Check the wrap-around condition\n    if (arr[n - 1] > arr[0]) {\n        return false;\n    }\n\n    return true;\n}\n"}
{"task_id": "CPP/110", "generation": "#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nstring exchange(vector<int> lst1, vector<int> lst2) {\n    // Count the number of odd elements in lst1\n    int oddCountLst1 = count_if(lst1.begin(), lst1.end(), [](int x) { return x % 2 != 0; });\n\n    // Count the number of even elements in lst2\n    int evenCountLst2 = count_if(lst2.begin(), lst2.end(), [](int x) { return x % 2 == 0; });\n\n    // If there are enough even elements in lst2 to replace all odd elements in lst1, return \"YES\"\n    if (oddCountLst1 <= evenCountLst2) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n"}
{"task_id": "CPP/111", "generation": "#include <iostream>\n#include <string>\n#include <map>\n#include <sstream>\n#include <vector>\nusing namespace std;\n\nmap<char, int> histogram(string test) {\n    map<char, int> freqMap;\n    stringstream ss(test);\n    string token;\n    \n    // Count the frequency of each character\n    while (getline(ss, token, ' ')) {\n        if (!token.empty()) {\n            char ch = token[0];\n            freqMap[ch]++;\n        }\n    }\n\n    // Find the maximum frequency\n    int maxFreq = 0;\n    for (const auto& entry : freqMap) {\n        if (entry.second > maxFreq) {\n            maxFreq = entry.second;\n        }\n    }\n\n    // Filter the map to keep only the characters with the maximum frequency\n    map<char, int> result;\n    for (const auto& entry : freqMap) {\n        if (entry.second == maxFreq) {\n            result.insert(entry);\n        }\n    }\n\n    return result;\n}\n\n// Function to test the histogram function\nvoid testHistogram() {\n    auto check = [](const string& test, const map<char, int>& expected) {\n        map<char, int> result = histogram(test);\n        if (result == expected) {\n            cout << \"Test passed\" << endl;\n        } else {\n            cout << \"Test failed\" << endl;\n        }\n    };\n\n    check(\"a b c\", {{'a', 1}, {'b', 1}, {'c', 1}});\n    check(\"a b b a\", {{'a', 2}, {'b', 2}});\n    check(\"a b c a b\", {{'a', 2}, {'b', 2}});\n    check(\"b b b b a\", {{'b', 4}});\n    check(\"\", {});\n}\n\n"}
{"task_id": "CPP/112", "generation": "#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nvector<string> reverse_delete(string s, string c) {\n    // Remove all characters in s that are present in c\n    s.erase(remove_if(s.begin(), s.end(), [&c](char ch) {\n        return c.find(ch) != string::npos;\n    }), s.end());\n\n    // Check if the resulting string is a palindrome\n    string reversed = s;\n    reverse(reversed.begin(), reversed.end());\n    bool isPalindrome = (s == reversed);\n\n    // Prepare the result vector\n    vector<string> result = {s, isPalindrome ? \"True\" : \"False\"};\n    return result;\n}\n"}
{"task_id": "CPP/113", "generation": "#include <vector>\n#include <string>\n#include <iostream>\nusing namespace std;\n\nvector<string> odd_count(vector<string> lst) {\n    vector<string> result;\n    for (const string& s : lst) {\n        int oddCount = 0;\n        for (char c : s) {\n            if ((c - '0') % 2 != 0) {\n                oddCount++;\n            }\n        }\n        string output = \"the number of odd elements \" + to_string(oddCount) + \"n the str\" + to_string(oddCount) + \"ng \" + to_string(oddCount) + \" of the \" + to_string(oddCount) + \"nput.\";\n        result.push_back(output);\n    }\n    return result;\n}\n\n// Test cases\n"}
{"task_id": "CPP/114", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nlong long minSubArraySum(vector<long long> nums) {\n    long long minSum = nums[0];\n    long long currentSum = nums[0];\n\n    for (size_t i = 1; i < nums.size(); ++i) {\n        currentSum = min(nums[i], currentSum + nums[i]);\n        minSum = min(minSum, currentSum);\n    }\n\n    return minSum;\n}\n"}
{"task_id": "CPP/115", "generation": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint max_fill(vector<vector<int>> grid, int capacity) {\n    int total_buckets_needed = 0;\n    for (const auto& row : grid) {\n        int water_units = accumulate(row.begin(), row.end(), 0);\n        total_buckets_needed += (water_units + capacity - 1) / capacity; // Ceiling division\n    }\n    return total_buckets_needed;\n}\n"}
{"task_id": "CPP/116", "generation": "#include <stdio.h>\n#include <math.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n// Function to count the number of ones in the binary representation of a number\nint countOnes(int n) {\n    int count = 0;\n    while (n) {\n        count += n & 1;\n        n >>= 1;\n    }\n    return count;\n}\n\n// Custom comparator for sorting\nbool compare(int a, int b) {\n    int countA = countOnes(a);\n    int countB = countOnes(b);\n    if (countA == countB) {\n        return a < b;\n    }\n    return countA < countB;\n}\n\nvector<int> sort_array(vector<int> arr) {\n    // Sort the array using the custom comparator\n    sort(arr.begin(), arr.end(), compare);\n    return arr;\n}\n"}
{"task_id": "CPP/117", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <cctype>\nusing namespace std;\n\nbool isConsonant(char c) {\n    c = tolower(c);\n    return !(c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') && isalpha(c);\n}\n\nvector<string> select_words(string s, int n) {\n    vector<string> result;\n    stringstream ss(s);\n    string word;\n    \n    while (ss >> word) {\n        int consonantCount = 0;\n        for (char c : word) {\n            if (isConsonant(c)) {\n                consonantCount++;\n            }\n        }\n        if (consonantCount == n) {\n            result.push_back(word);\n        }\n    }\n    return result;\n}\n\n// Test cases\n"}
{"task_id": "CPP/118", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nbool is_vowel(char c) {\n    return c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' ||\n           c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U';\n}\n\nbool is_consonant(char c) {\n    return !is_vowel(c) && isalpha(c);\n}\n\nstring get_closest_vowel(string word) {\n    int n = word.length();\n    for (int i = n - 2; i > 0; --i) {\n        if (is_consonant(word[i - 1]) && is_vowel(word[i]) && is_consonant(word[i + 1])) {\n            return string(1, word[i]);\n        }\n    }\n    return \"\";\n}\n\n"}
{"task_id": "CPP/119", "generation": "#include <vector>\n#include <string>\nusing namespace std;\n\nstring match_parens(vector<string> lst) {\n    // Count the number of open and close parentheses in both strings\n    int open1 = 0, close1 = 0;\n    for (char c : lst[0]) {\n        if (c == '(') open1++;\n        else close1++;\n    }\n\n    int open2 = 0, close2 = 0;\n    for (char c : lst[1]) {\n        if (c == '(') open2++;\n        else close2++;\n    }\n\n    // Check if concatenating in either order results in a balanced string\n    if ((open1 >= close2 && open1 + open2 == close1 + close2) || (open2 >= close1 && open1 + open2 == close1 + close2)) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\n"}
{"task_id": "CPP/120", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> maximum(vector<int> arr, int k) {\n    // Sort the array in ascending order\n    sort(arr.begin(), arr.end());\n    \n    // If k is 0, return an empty vector\n    if (k == 0) {\n        return {};\n    }\n    \n    // Extract the last k elements from the sorted array\n    vector<int> result(arr.end() - k, arr.end());\n    \n    return result;\n}\n\n// Function to test the solution\nvoid test_maximum() {\n    vector<int> arr1 = {-3, -4, 5};\n    int k1 = 3;\n    vector<int> expected1 = {-4, -3, 5};\n    assert(maximum(arr1, k1) == expected1);\n\n    vector<int> arr2 = {4, -4, 4};\n    int k2 = 2;\n    vector<int> expected2 = {4, 4};\n    assert(maximum(arr2, k2) == expected2);\n\n    vector<int> arr3 = {-3, 2, 1, 2, -1, -2, 1};\n    int k3 = 1;\n    vector<int> expected3 = {2};\n    assert(maximum(arr3, k3) == expected3);\n\n    cout << \"All test cases passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/121", "generation": "#include <vector>\nusing namespace std;\n\nint solution(vector<int> lst) {\n    int sum = 0;\n    for (size_t i = 0; i < lst.size(); i += 2) { // Iterate over even indices\n        if (lst[i] % 2 != 0) { // Check if the element is odd\n            sum += lst[i]; // Add to sum if it is odd\n        }\n    }\n    return sum;\n}\n"}
{"task_id": "CPP/122", "generation": "#include <vector>\n#include <iostream>\nusing namespace std;\n\nint add_elements(vector<int> arr, int k) {\n    int sum = 0;\n    for (int i = 0; i < k; ++i) {\n        if (arr[i] >= -99 && arr[i] <= 99) {\n            sum += arr[i];\n        }\n    }\n    return sum;\n}\n\n// Example usage\n"}
{"task_id": "CPP/123", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<int> get_odd_collatz(int n) {\n    vector<int> oddNumbers;\n    while (n != 1) {\n        if (n % 2 != 0) {\n            oddNumbers.push_back(n);\n        }\n        if (n % 2 == 0) {\n            n /= 2;\n        } else {\n            n = 3 * n + 1;\n        }\n    }\n    oddNumbers.push_back(1); // 1 is always part of the sequence and is odd\n    sort(oddNumbers.begin(), oddNumbers.end());\n    return oddNumbers;\n}\n\n// Example usage:\n// vector<int> result = get_odd_collatz(5);\n// for (int num : result) {\n//     printf(\"%d \", num);\n// }\n// Output: 1 5\n"}
{"task_id": "CPP/124", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <vector>\nusing namespace std;\n\nbool isLeapYear(int year) {\n    return (year % 4 == 0 && (year % 100 != 0 || year % 400 == 0));\n}\n\nbool valid_date(string date) {\n    // Check if the date string is empty\n    if (date.empty()) {\n        return false;\n    }\n\n    // Check the format of the date string\n    if (date.find('-') == string::npos || count(date.begin(), date.end(), '-') != 2) {\n        return false;\n    }\n\n    // Parse the date string\n    stringstream ss(date);\n    string token;\n    vector<int> parts;\n    while (getline(ss, token, '-')) {\n        if (token.empty()) {\n            return false;\n        }\n        parts.push_back(stoi(token));\n    }\n\n    // Extract month, day, and year\n    int month = parts[0];\n    int day = parts[1];\n    int year = parts[2];\n\n    // Validate month\n    if (month < 1 || month > 12) {\n        return false;\n    }\n\n    // Validate day based on month\n    if (day < 1) {\n        return false;\n    }\n    if (month == 2) {\n        if (isLeapYear(year)) {\n            if (day > 29) {\n                return false;\n            }\n        } else {\n            if (day > 28) {\n                return false;\n            }\n        }\n    } else if (month == 4 || month == 6 || month == 9 || month == 11) {\n        if (day > 30) {\n            return false;\n        }\n    } else {\n        if (day > 31) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\n// Test cases\n"}
{"task_id": "CPP/125", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nvector<string> split_words(string txt) {\n    vector<string> result;\n\n    // Check for whitespace\n    if (txt.find(' ') != string::npos) {\n        // Split on whitespace\n        size_t start = 0;\n        size_t end = txt.find(' ');\n        while (end != string::npos) {\n            result.push_back(txt.substr(start, end - start));\n            start = end + 1;\n            end = txt.find(' ', start);\n        }\n        result.push_back(txt.substr(start));\n    } else if (txt.find(',') != string::npos) {\n        // Split on commas\n        size_t start = 0;\n        size_t end = txt.find(',');\n        while (end != string::npos) {\n            result.push_back(txt.substr(start, end - start));\n            start = end + 1;\n            end = txt.find(',', start);\n        }\n        result.push_back(txt.substr(start));\n    } else {\n        // Count lower-case letters with odd order in the alphabet\n        int count = 0;\n        for (char c : txt) {\n            if (islower(c) && ((c - 'a') % 2 == 1)) {\n                count++;\n            }\n        }\n        result.push_back(to_string(count));\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/126", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nbool is_sorted(vector<int> lst) {\n    if (lst.empty()) return true;\n\n    int prev = lst[0];\n    int count = 1;\n\n    for (size_t i = 1; i < lst.size(); ++i) {\n        if (lst[i] < prev) {\n            return false; // Not in ascending order\n        } else if (lst[i] == prev) {\n            count++;\n            if (count > 2) {\n                return false; // Number appears more than twice\n            }\n        } else {\n            prev = lst[i];\n            count = 1;\n        }\n    }\n\n    return true;\n}\n"}
{"task_id": "CPP/127", "generation": "#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to check if a number is prime\nbool isPrime(int n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    for (int i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) return false;\n    }\n    return true;\n}\n\nstring intersection(vector<int> interval1, vector<int> interval2) {\n    // Find the start and end of the intersection\n    int start = max(interval1[0], interval2[0]);\n    int end = min(interval1[1], interval2[1]);\n\n    // Check if there is a valid intersection\n    if (start > end) {\n        return \"NO\";\n    }\n\n    // Calculate the length of the intersection\n    int length = end - start + 1;\n\n    // Check if the length is a prime number\n    if (isPrime(length)) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n"}
{"task_id": "CPP/128", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\nint prod_signs(vector<int> arr) {\n    if (arr.empty()) {\n        return -32768;\n    }\n\n    int signProduct = 1;\n    int magnitudeSum = 0;\n\n    for (int num : arr) {\n        if (num == 0) {\n            signProduct = 0;\n            break;\n        }\n        signProduct *= (num > 0) ? 1 : -1;\n        magnitudeSum += abs(num);\n    }\n\n    return signProduct * magnitudeSum;\n}\n"}
{"task_id": "CPP/129", "generation": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <tuple>\n#include <climits>\n\nusing namespace std;\n\n// Define a structure for the priority queue\nstruct PathState {\n    vector<int> path;\n    int row, col;\n    int length;\n};\n\n// Comparator for the priority queue to ensure lexicographical order\nstruct Compare {\n    bool operator()(const PathState& a, const PathState& b) {\n        for (int i = 0; i < min(a.path.size(), b.path.size()); ++i) {\n            if (a.path[i] != b.path[i]) {\n                return a.path[i] > b.path[i];\n            }\n        }\n        return a.path.size() > b.path.size();\n    }\n};\n\nvector<int> minPath(vector<vector<int>>& grid, int k) {\n    int N = grid.size();\n    priority_queue<PathState, vector<PathState>, Compare> pq;\n\n    // Initialize the priority queue with all possible starting points\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            pq.push({{grid[i][j]}, i, j, 1});\n        }\n    }\n\n    // Directions for moving up, down, left, right\n    vector<pair<int, int>> directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n\n    while (!pq.empty()) {\n        auto [path, row, col, length] = pq.top();\n        pq.pop();\n\n        if (length == k) {\n            return path;\n        }\n\n        for (auto& [dr, dc] : directions) {\n            int newRow = row + dr;\n            int newCol = col + dc;\n\n            if (newRow >= 0 && newRow < N && newCol >= 0 && newCol < N) {\n                vector<int> newPath = path;\n                newPath.push_back(grid[newRow][newCol]);\n                pq.push({newPath, newRow, newCol, length + 1});\n            }\n        }\n    }\n\n    return {}; // Should never reach here if input is valid\n}\n\n"}
{"task_id": "CPP/130", "generation": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\n// Function to compute the Tribonacci sequence using memoization\nint computeTri(int n, unordered_map<int, int>& memo) {\n    if (memo.find(n) != memo.end()) {\n        return memo[n];\n    }\n\n    if (n == 1) {\n        return 3;\n    }\n\n    if (n % 2 == 0) {\n        return memo[n] = 1 + n / 2;\n    } else {\n        return memo[n] = computeTri(n - 1, memo) + computeTri(n - 2, memo) + computeTri(n + 1, memo);\n    }\n}\n\n// Function to generate the first n + 1 numbers of the Tribonacci sequence\nvector<int> tri(int n) {\n    vector<int> result(n + 1);\n    unordered_map<int, int> memo;\n\n    for (int i = 1; i <= n; ++i) {\n        result[i] = computeTri(i, memo);\n    }\n\n    // Special case for tri(0)\n    result[0] = 1;\n\n    return result;\n}\n\n// Main function to test the implementation\n"}
{"task_id": "CPP/131", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nint digits(int n) {\n    string numStr = to_string(n);\n    int product = 1;\n    bool hasOdd = false;\n\n    for (char digit : numStr) {\n        int d = digit - '0';\n        if (d % 2 != 0) {\n            product *= d;\n            hasOdd = true;\n        }\n    }\n\n    return hasOdd ? product : 0;\n}\n"}
{"task_id": "CPP/132", "generation": "#include <string>\n#include <stack>\nusing namespace std;\n\nbool is_nested(string str) {\n    stack<char> s;\n    bool nested = false;\n\n    for (char c : str) {\n        if (c == '[') {\n            s.push(c);\n        } else if (c == ']' && !s.empty()) {\n            s.pop();\n            // If the stack is not empty after popping, it means we have a nested structure\n            if (!s.empty()) {\n                nested = true;\n            }\n        }\n    }\n\n    return nested;\n}\n"}
{"task_id": "CPP/133", "generation": "#include <cmath>\n#include <vector>\nusing namespace std;\n\nint sum_squares(vector<float> lst) {\n    int sum = 0;\n    for (float num : lst) {\n        int ceil_num = ceil(num);\n        sum += ceil_num * ceil_num;\n    }\n    return sum;\n}\n"}
{"task_id": "CPP/134", "generation": "#include <string>\nusing namespace std;\n\nbool check_if_last_char_is_a_letter(string txt) {\n    if (txt.empty()) {\n        return false;\n    }\n\n    // Remove trailing spaces\n    while (!txt.empty() && txt.back() == ' ') {\n        txt.pop_back();\n    }\n\n    // Check if the last character is an alphabetical character\n    if (txt.empty() || !isalpha(txt.back())) {\n        return false;\n    }\n\n    // Check if the last character is not part of a word\n    if (txt.length() > 1 && txt[txt.length() - 2] != ' ') {\n        return false;\n    }\n\n    return true;\n}\n"}
{"task_id": "CPP/135", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nint can_arrange(vector<int> arr) {\n    int largestIndex = -1;\n    for (int i = 1; i < arr.size(); ++i) {\n        if (arr[i] < arr[i - 1]) {\n            largestIndex = i;\n        }\n    }\n    return largestIndex;\n}\n"}
{"task_id": "CPP/136", "generation": "#include <vector>\n#include <limits>\n#include <algorithm>\nusing namespace std;\n\nvector<int> largest_smallest_integers(vector<int> lst) {\n    int largest_negative = numeric_limits<int>::min();\n    int smallest_positive = numeric_limits<int>::max();\n\n    for (int num : lst) {\n        if (num < 0) {\n            largest_negative = max(largest_negative, num);\n        } else if (num > 0) {\n            smallest_positive = min(smallest_positive, num);\n        }\n    }\n\n    if (largest_negative == numeric_limits<int>::min()) {\n        largest_negative = 0;\n    }\n    if (smallest_positive == numeric_limits<int>::max()) {\n        smallest_positive = 0;\n    }\n\n    return {largest_negative, smallest_positive};\n}\n"}
{"task_id": "CPP/137", "generation": "#include <iostream>\n#include <string>\n#include <boost/any.hpp>\n#include <sstream>\n#include <stdexcept>\n\nusing namespace std;\n\n// Function to convert a string to a double, handling both '.' and ',' as decimal separators\ndouble stringToDouble(const string& str) {\n    string modifiedStr = str;\n    size_t pos = modifiedStr.find(',');\n    if (pos != string::npos) {\n        modifiedStr[pos] = '.';\n    }\n    try {\n        return stod(modifiedStr);\n    } catch (const invalid_argument& e) {\n        throw runtime_error(\"Invalid number format\");\n    }\n}\n\n// Function to compare two boost::any values\nboost::any compare_one(boost::any a, boost::any b) {\n    double valA, valB;\n\n    // Convert a to double\n    if (a.type() == typeid(int)) {\n        valA = any_cast<int>(a);\n    } else if (a.type() == typeid(double)) {\n        valA = any_cast<double>(a);\n    } else if (a.type() == typeid(string)) {\n        valA = stringToDouble(any_cast<string>(a));\n    } else {\n        throw runtime_error(\"Unsupported type for a\");\n    }\n\n    // Convert b to double\n    if (b.type() == typeid(int)) {\n        valB = any_cast<int>(b);\n    } else if (b.type() == typeid(double)) {\n        valB = any_cast<double>(b);\n    } else if (b.type() == typeid(string)) {\n        valB = stringToDouble(any_cast<string>(b));\n    } else {\n        throw runtime_error(\"Unsupported type for b\");\n    }\n\n    // Compare the values\n    if (valA == valB) {\n        return \"None\";\n    } else if (valA > valB) {\n        return a;\n    } else {\n        return b;\n    }\n}\n\n"}
{"task_id": "CPP/138", "generation": "#include <iostream>\nusing namespace std;\n\nbool is_equal_to_sum_even(int n) {\n    // The smallest sum of 4 positive even numbers is 2 + 2 + 2 + 2 = 8\n    // Any number less than 8 cannot be expressed as the sum of 4 positive even numbers\n    if (n < 8) {\n        return false;\n    }\n    // If n is greater than or equal to 8 and is even, it can always be expressed as the sum of 4 positive even numbers\n    // This is because we can use 2 + 2 + 2 + (n - 6) where (n - 6) is also even\n    return (n % 2 == 0);\n}\n\n"}
{"task_id": "CPP/139", "generation": "#include <iostream>\nusing namespace std;\n\n// Helper function to compute the factorial of a number\nlong long factorial(int num) {\n    long long fact = 1;\n    for (int i = 1; i <= num; ++i) {\n        fact *= i;\n    }\n    return fact;\n}\n\n// Function to compute the Brazilian factorial\nlong long special_factorial(int n) {\n    long long result = 1;\n    for (int i = 1; i <= n; ++i) {\n        result *= factorial(i);\n    }\n    return result;\n}\n\n// Main function to test the special_factorial function\n"}
{"task_id": "CPP/140", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring fix_spaces(string text) {\n    string result;\n    int spaceCount = 0;\n\n    for (char ch : text) {\n        if (ch == ' ') {\n            spaceCount++;\n        } else {\n            if (spaceCount > 2) {\n                result += '-';\n            } else if (spaceCount > 0) {\n                result += string(spaceCount, '_');\n            }\n            spaceCount = 0;\n            result += ch;\n        }\n    }\n\n    if (spaceCount > 2) {\n        result += '-';\n    } else if (spaceCount > 0) {\n        result += string(spaceCount, '_');\n    }\n\n    return result;\n}\n\n// Test cases\n"}
{"task_id": "CPP/141", "generation": "#include <iostream>\n#include <string>\n#include <cctype>\n#include <algorithm>\nusing namespace std;\n\nstring file_name_check(string file_name) {\n    // Check if the file name contains exactly one dot\n    size_t dotPos = file_name.find('.');\n    if (dotPos == string::npos || file_name.find('.', dotPos + 1) != string::npos) {\n        return \"No\";\n    }\n\n    // Check if the substring before the dot is non-empty and starts with a letter\n    string namePart = file_name.substr(0, dotPos);\n    if (namePart.empty() || !isalpha(namePart[0])) {\n        return \"No\";\n    }\n\n    // Check if there are more than three digits in the name part\n    int digitCount = count_if(namePart.begin(), namePart.end(), ::isdigit);\n    if (digitCount > 3) {\n        return \"No\";\n    }\n\n    // Check if the substring after the dot is one of the allowed extensions\n    string extensionPart = file_name.substr(dotPos + 1);\n    if (extensionPart != \"txt\" && extensionPart != \"exe\" && extensionPart != \"dll\") {\n        return \"No\";\n    }\n\n    return \"Yes\";\n}\n\n// Test cases\n"}
{"task_id": "CPP/142", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nint sum_squares(vector<int> lst) {\n    int sum = 0;\n    for (size_t i = 0; i < lst.size(); ++i) {\n        if (i % 3 == 0) {\n            sum += lst[i] * lst[i]; // Square the element if index is a multiple of 3\n        } else if (i % 4 == 0) {\n            sum += lst[i] * lst[i] * lst[i]; // Cube the element if index is a multiple of 4 and not 3\n        } else {\n            sum += lst[i]; // Add the element as is if index is neither a multiple of 3 nor 4\n        }\n    }\n    return sum;\n}\n\n// Test cases\n"}
{"task_id": "CPP/143", "generation": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\nusing namespace std;\n\n// Function to check if a number is prime\nbool isPrime(int n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    for (int i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) return false;\n    }\n    return true;\n}\n\n// Function to extract words with prime lengths from the sentence\nstring words_in_sentence(string sentence) {\n    stringstream ss(sentence);\n    string word;\n    string result;\n    while (ss >> word) {\n        if (isPrime(word.length())) {\n            if (!result.empty()) result += \" \";\n            result += word;\n        }\n    }\n    return result;\n}\n\n// Main function to test the implementation\n"}
{"task_id": "CPP/144", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <cassert>\n\nusing namespace std;\n\n// Function to parse a fraction string into numerator and denominator\npair<long long, long long> parseFraction(const string& fraction) {\n    stringstream ss(fraction);\n    string numeratorStr, denominatorStr;\n    getline(ss, numeratorStr, '/');\n    getline(ss, denominatorStr, '/');\n    long long numerator = stoll(numeratorStr);\n    long long denominator = stoll(denominatorStr);\n    return {numerator, denominator};\n}\n\n// Function to simplify the product of two fractions\nbool simplify(string x, string n) {\n    // Parse the fractions\n    auto [xNum, xDen] = parseFraction(x);\n    auto [nNum, nDen] = parseFraction(n);\n\n    // Multiply the fractions\n    long long resultNumerator = xNum * nNum;\n    long long resultDenominator = xDen * nDen;\n\n    // Check if the result is a whole number\n    return (resultNumerator % resultDenominator == 0);\n}\n\n// Function to test the simplify function\nvoid testSimplify() {\n    assert(simplify(\"1/5\", \"5/1\") == true);\n    assert(simplify(\"1/6\", \"2/1\") == false);\n    assert(simplify(\"7/10\", \"10/2\") == false);\n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/145", "generation": "#include <vector>\n#include <string>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\n// Function to calculate the sum of digits of a number\nint sum_of_digits(int n) {\n    int sum = 0;\n    bool isNegative = n < 0;\n    while (n != 0) {\n        int digit = n % 10;\n        if (isNegative && n < 0) {\n            digit = -digit;\n        }\n        sum += digit;\n        n /= 10;\n    }\n    return sum;\n}\n\n// Comparator function to sort based on the sum of digits\nbool compare(int a, int b) {\n    int sumA = sum_of_digits(a);\n    int sumB = sum_of_digits(b);\n    if (sumA == sumB) {\n        return a < b; // Maintain original order if sums are equal\n    }\n    return sumA < sumB;\n}\n\nvector<int> order_by_points(vector<int> nums) {\n    stable_sort(nums.begin(), nums.end(), compare);\n    return nums;\n}\n"}
{"task_id": "CPP/146", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nbool isFirstAndLastDigitOdd(int num) {\n    string strNum = to_string(abs(num));\n    int firstDigit = strNum[0] - '0';\n    int lastDigit = strNum[strNum.size() - 1] - '0';\n    return (firstDigit % 2 != 0) && (lastDigit % 2 != 0);\n}\n\nint specialFilter(vector<int> nums) {\n    int count = 0;\n    for (int num : nums) {\n        if (num > 10 && isFirstAndLastDigitOdd(num)) {\n            count++;\n        }\n    }\n    return count;\n}\n\n// Test cases\n"}
{"task_id": "CPP/147", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nint get_max_triples(int n) {\n    // Create the vector a based on the given formula\n    vector<int> a(n);\n    for (int i = 1; i <= n; ++i) {\n        a[i - 1] = i * i - i + 1;\n    }\n\n    // Count the number of valid triples (a[i], a[j], a[k]) where i < j < k\n    int count = 0;\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            for (int k = j + 1; k < n; ++k) {\n                if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                    count++;\n                }\n            }\n        }\n    }\n\n    return count;\n}\n\n// Example usage\n"}
{"task_id": "CPP/148", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nvector<string> bf(string planet1, string planet2) {\n    vector<string> planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n    \n    // Check if both planet names are valid\n    if (find(planets.begin(), planets.end(), planet1) == planets.end() || \n        find(planets.begin(), planets.end(), planet2) == planets.end()) {\n        return {}; // Return an empty vector if either planet name is invalid\n    }\n\n    // Find the indices of the planets\n    int index1 = find(planets.begin(), planets.end(), planet1) - planets.begin();\n    int index2 = find(planets.begin(), planets.end(), planet2) - planets.begin();\n\n    // Ensure index1 is less than index2\n    if (index1 > index2) {\n        swap(index1, index2);\n    }\n\n    // Collect the planets between the two indices\n    vector<string> result;\n    for (int i = index1 + 1; i < index2; ++i) {\n        result.push_back(planets[i]);\n    }\n\n    return result;\n}\n\n// Function to test the bf function\nvoid test_bf() {\n    vector<string> result1 = bf(\"Jupiter\", \"Neptune\");\n    vector<string> expected1 = {\"Saturn\", \"Uranus\"};\n    assert(result1 == expected1);\n\n    vector<string> result2 = bf(\"Earth\", \"Mercury\");\n    vector<string> expected2 = {\"Venus\"};\n    assert(result2 == expected2);\n\n    vector<string> result3 = bf(\"Mercury\", \"Uranus\");\n    vector<string> expected3 = {\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"};\n    assert(result3 == expected3);\n\n    vector<string> result4 = bf(\"Pluto\", \"Neptune\");\n    vector<string> expected4 = {};\n    assert(result4 == expected4);\n\n    cout << \"All tests passed!\" << endl;\n}\n\n"}
{"task_id": "CPP/149", "generation": "#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nvector<string> sorted_list_sum(vector<string> lst) {\n    // Remove strings with odd lengths\n    lst.erase(remove_if(lst.begin(), lst.end(), [](const string& s) {\n        return s.length() % 2 != 0;\n    }), lst.end());\n\n    // Sort the list first by length, then alphabetically\n    sort(lst.begin(), lst.end(), [](const string& a, const string& b) {\n        if (a.length() == b.length()) {\n            return a < b;\n        }\n        return a.length() < b.length();\n    });\n\n    return lst;\n}\n"}
{"task_id": "CPP/150", "generation": "#include <stdio.h>\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int n) {\n    if (n <= 1) return false; // 0 and 1 are not prime numbers\n    if (n <= 3) return true; // 2 and 3 are prime numbers\n\n    // This is checked so that we can skip middle five numbers in below loop\n    if (n % 2 == 0 || n % 3 == 0) return false;\n\n    for (int i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) return false;\n    }\n\n    return true;\n}\n\n// Function to return x if n is prime, otherwise return y\nint x_or_y(int n, int x, int y) {\n    if (is_prime(n)) {\n        return x;\n    } else {\n        return y;\n    }\n}\n\n// Main function to test the x_or_y function\n"}
{"task_id": "CPP/151", "generation": "#include <vector>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\n\nlong long double_the_difference(vector<float> lst) {\n    long long sum = 0;\n    for (float num : lst) {\n        // Check if the number is non-negative and an integer\n        if (num >= 0 && floor(num) == num) {\n            int intNum = static_cast<int>(num);\n            // Check if the number is odd\n            if (intNum % 2 != 0) {\n                sum += intNum * intNum;\n            }\n        }\n    }\n    return sum;\n}\n"}
{"task_id": "CPP/152", "generation": "#include <stdio.h>\n#include <math.h>\n#include <vector>\nusing namespace std;\n\nvector<int> compare(vector<int> game, vector<int> guess) {\n    vector<int> differences;\n    for (size_t i = 0; i < game.size(); ++i) {\n        differences.push_back(abs(game[i] - guess[i]));\n    }\n    return differences;\n}\n"}
{"task_id": "CPP/153", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nint calculateStrength(const string& extension) {\n    int cap = 0, sm = 0;\n    for (char c : extension) {\n        if (isupper(c)) cap++;\n        else if (islower(c)) sm++;\n    }\n    return cap - sm;\n}\n\nstring Strongest_Extension(string class_name, vector<string> extensions) {\n    string strongest_extension = \"\";\n    int max_strength = INT_MIN;\n\n    for (const string& extension : extensions) {\n        int strength = calculateStrength(extension);\n        if (strength > max_strength) {\n            max_strength = strength;\n            strongest_extension = extension;\n        }\n    }\n\n    return class_name + \".\" + strongest_extension;\n}\n\n// Example usage\n"}
{"task_id": "CPP/154", "generation": "#include <string>\n#include <algorithm>\nusing namespace std;\n\nbool cycpattern_check(string a, string b) {\n    if (b.length() > a.length()) {\n        return false;\n    }\n\n    string concatenated = a + a; // Concatenate the string with itself\n    for (size_t i = 0; i < b.length(); ++i) {\n        string rotated = b.substr(i) + b.substr(0, i); // Generate all rotations of b\n        if (concatenated.find(rotated) != string::npos) {\n            return true;\n        }\n    }\n    return false;\n}\n"}
{"task_id": "CPP/155", "generation": "#include <stdio.h>\n#include <math.h>\n#include <string>\n#include <vector>\nusing namespace std;\n\nvector<int> even_odd_count(int num) {\n    // Convert the number to a positive value to handle negative numbers\n    num = abs(num);\n    \n    // Initialize counters for even and odd digits\n    int evenCount = 0;\n    int oddCount = 0;\n    \n    // Process each digit of the number\n    while (num > 0) {\n        int digit = num % 10; // Extract the last digit\n        if (digit % 2 == 0) {\n            evenCount++; // Increment even digit count\n        } else {\n            oddCount++; // Increment odd digit count\n        }\n        num /= 10; // Remove the last digit\n    }\n    \n    // Return the counts as a vector\n    return {evenCount, oddCount};\n}\n"}
{"task_id": "CPP/156", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring int_to_mini_roman(int number) {\n    // Define the Roman numeral mappings\n    vector<pair<int, string>> roman_map = {\n        {1000, \"m\"}, {900, \"cm\"}, {500, \"d\"}, {400, \"cd\"},\n        {100, \"c\"}, {90, \"xc\"}, {50, \"l\"}, {40, \"xl\"},\n        {10, \"x\"}, {9, \"ix\"}, {5, \"v\"}, {4, \"iv\"}, {1, \"i\"}\n    };\n\n    string result = \"\";\n    for (const auto& [value, symbol] : roman_map) {\n        while (number >= value) {\n            result += symbol;\n            number -= value;\n        }\n    }\n    return result;\n}\n\n// Test cases\n"}
{"task_id": "CPP/157", "generation": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n\nbool right_angle_triangle(float a, float b, float c) {\n    // Sort the sides to ensure c is the longest side\n    float sides[3] = {a, b, c};\n    sort(sides, sides + 3);\n\n    // Check if the square of the longest side is equal to the sum of the squares of the other two sides\n    return fabs(sides[0] * sides[0] + sides[1] * sides[1] - sides[2] * sides[2]) < 1e-6;\n}\n"}
{"task_id": "CPP/158", "generation": "#include <vector>\n#include <string>\n#include <algorithm>\n#include <set>\nusing namespace std;\n\nstring find_max(vector<string> words) {\n    string maxWord = \"\";\n    int maxUniqueChars = 0;\n\n    for (const string& word : words) {\n        set<char> uniqueChars(word.begin(), word.end());\n        int numUniqueChars = uniqueChars.size();\n\n        if (numUniqueChars > maxUniqueChars || (numUniqueChars == maxUniqueChars && word < maxWord)) {\n            maxUniqueChars = numUniqueChars;\n            maxWord = word;\n        }\n    }\n\n    return maxWord;\n}\n"}
{"task_id": "CPP/159", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> eat(int number, int need, int remaining) {\n    int totalEaten = number + min(need, remaining);\n    int newRemaining = max(0, remaining - need);\n    return {totalEaten, newRemaining};\n}\n"}
{"task_id": "CPP/160", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\nusing namespace std;\n\nint do_algebra(vector<string> operato, vector<int> operand) {\n    int result = operand[0]; // Initialize result with the first operand\n\n    for (size_t i = 0; i < operato.size(); ++i) {\n        if (operato[i] == \"+\") {\n            result += operand[i + 1];\n        } else if (operato[i] == \"-\") {\n            result -= operand[i + 1];\n        } else if (operato[i] == \"*\") {\n            result *= operand[i + 1];\n        } else if (operato[i] == \"//\") {\n            result /= operand[i + 1]; // Floor division\n        } else if (operato[i] == \"**\") {\n            result = pow(result, operand[i + 1]);\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/161", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring solve(string s) {\n    bool hasLetters = false;\n    for (char& c : s) {\n        if (isalpha(c)) {\n            hasLetters = true;\n            if (islower(c)) {\n                c = toupper(c);\n            } else {\n                c = tolower(c);\n            }\n        }\n    }\n    if (!hasLetters) {\n        reverse(s.begin(), s.end());\n    }\n    return s;\n}\n\n"}
{"task_id": "CPP/162", "generation": "#include <iostream>\n#include <string>\n#include <openssl/md5.h>\nusing namespace std;\n\nstring string_to_md5(string text) {\n    if (text.empty()) {\n        return nullptr;\n    }\n\n    unsigned char digest[MD5_DIGEST_LENGTH];\n    MD5((unsigned char*)text.c_str(), text.length(), (unsigned char*)&digest);    \n\n    char mdString[33];\n    for(int i = 0; i < 16; ++i)\n        sprintf(&mdString[i*2], \"%02x\", (unsigned int)digest[i]);\n\n    return string(mdString);\n}\n\n// Test function to verify the correctness of the solution\nvoid test_string_to_md5() {\n    string test1 = \"Hello world\";\n    string expected1 = \"3e25960a79dbc69b674cd4ec67a72c62\";\n    assert(string_to_md5(test1) == expected1);\n\n    string test2 = \"\";\n    assert(string_to_md5(test2) == nullptr);\n\n    cout << \"All tests passed successfully.\" << endl;\n}\n\n"}
{"task_id": "CPP/163", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> generate_integers(int a, int b) {\n    // Ensure a is less than or equal to b\n    if (a > b) {\n        swap(a, b);\n    }\n\n    vector<int> evenDigits = {2, 4, 6, 8};\n    vector<int> result;\n\n    // Iterate through the even digits and add those within the range [a, b]\n    for (int digit : evenDigits) {\n        if (digit >= a && digit <= b) {\n            result.push_back(digit);\n        }\n    }\n\n    return result;\n}\n"}
