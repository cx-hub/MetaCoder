{"task_id": "Java/0", "generation": "import java.util.*;\n\nclass Solution {\n    public boolean has_close_elements(List<Double> numbers, double threshold) {\n        for (int i = 0; i < numbers.size(); i++) {\n            for (int j = 0; j < numbers.size(); j++) {\n                if (i != j) {\n                    double distance = Math.abs(numbers.get(i) - numbers.get(j));\n                    if (distance < threshold) {\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }\n}\n", "py_code": "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    for idx, elem in enumerate(numbers):\n        for idx2, elem2 in enumerate(numbers):\n            if idx != idx2:\n                distance = abs(elem - elem2)\n                if distance < threshold:\n                    return True\n\n    return False\n", "py_summary": "The Python code defines a function `has_close_elements` that takes a list of numbers and a threshold as input and checks if there are any two numbers in the list that are closer to each other than the given threshold. The function iterates through each pair of numbers in the list and calculates the absolute difference between them. If the difference is less than the threshold, the function returns `True` indicating that there are two close elements. If no such pair is found after checking all combinations, the function returns `False`."}
{"task_id": "Java/1", "generation": "import java.util.*;\n\nclass Solution {\n    public List<String> separate_paren_groups(String paren_string) {\n        List<String> result = new ArrayList<>();\n        List<Character> currentString = new ArrayList<>();\n        int currentDepth = 0;\n\n        for (char c : paren_string.toCharArray()) {\n            if (c == '(') {\n                currentDepth++;\n                currentString.add(c);\n            } else if (c == ')') {\n                currentDepth--;\n                currentString.add(c);\n\n                if (currentDepth == 0) {\n                    StringBuilder sb = new StringBuilder();\n                    for (char ch : currentString) {\n                        sb.append(ch);\n                    }\n                    result.add(sb.toString());\n                    currentString.clear();\n                }\n            }\n        }\n\n        return result;\n    }\n}\n", "py_code": "from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n", "py_summary": "The Python code defines a function that takes a string containing multiple groups of nested parentheses as input and separates those groups into separate strings. It iterates through the input string character by character and maintains a current depth count to keep track of the nesting level of parentheses. \n\n- If an opening parenthesis '(' is encountered, the current depth is incremented, and the character is added to the current string.\n- If a closing parenthesis ')' is encountered, the current depth is decremented, and the character is added to the current string.\n- When the current depth reaches 0 (indicating a balanced group), the current string is added to the result list, and the current string is cleared for the next group.\n\nThe function returns a list of strings, each representing a separated and balanced group of parentheses from the input string."}
{"task_id": "Java/2", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public double truncate_number(double number) {\n        return number % 1.0;\n    }\n}\n", "py_code": "def truncate_number(number: float) -> float:\n    return number % 1.0\n", "py_summary": "The Python code defines a function that takes a positive floating-point number as input and returns the decimal part of the number. It uses the modulo operator (%) to calculate the remainder when the input number is divided by 1.0, which effectively extracts the decimal part of the number."}
{"task_id": "Java/3", "generation": "import java.util.*;\n\nclass Solution {\n    public boolean below_zero(List<Integer> operations) {\n        int balance = 0;\n\n        for (int op : operations) {\n            balance += op;\n            if (balance < 0) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n}\n", "py_code": "from typing import List\n\n\ndef below_zero(operations: List[int]) -> bool:\n    balance = 0\n\n    for op in operations:\n        balance += op\n        if balance < 0:\n            return True\n\n    return False\n", "py_summary": "The Python code defines a function that takes a list of deposit and withdrawal operations as input and checks if the balance of the account falls below zero at any point. It initializes a variable `balance` to keep track of the account balance, starting from zero.\n\nThe function then iterates through each operation in the input list and updates the account balance accordingly. If at any point the balance becomes negative, the function returns `True` indicating that the balance fell below zero. If the balance remains non-negative after processing all operations, the function returns `False`."}
{"task_id": "Java/4", "generation": "import java.util.*;\n\nclass Solution {\n    public double mean_absolute_deviation(List<Double> numbers) {\n        double sum = 0;\n        for (double num : numbers) {\n            sum += num;\n        }\n        double mean = sum / numbers.size();\n        \n        double absoluteDiffSum = 0;\n        for (double num : numbers) {\n            absoluteDiffSum += Math.abs(num - mean);\n        }\n        \n        return absoluteDiffSum / numbers.size();\n    }\n}\n", "py_code": "from typing import List\n\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    mean = sum(numbers) / len(numbers)\n    return sum(abs(x - mean) for x in numbers) / len(numbers)\n", "py_summary": "The Python code defines a function that calculates the Mean Absolute Deviation (MAD) for a given list of numbers. The MAD is calculated as the average of the absolute differences between each element in the list and the mean of the list. \n\n1. Calculate the mean of the input numbers by summing all numbers and dividing by the total count of numbers.\n2. Calculate the absolute difference between each number and the mean, sum up all these absolute differences.\n3. Divide the sum of absolute differences by the total count of numbers to get the average absolute difference, which is the Mean Absolute Deviation.\n\nThe function returns the Mean Absolute Deviation value as a float."}
{"task_id": "Java/5", "generation": "import java.util.*;\n\nclass Solution {\n    public List<Integer> intersperse(List<Integer> numbers, int delimiter) {\n        List<Integer> result = new ArrayList<>();\n        \n        if (numbers.isEmpty()) {\n            return result;\n        }\n        \n        for (int i = 0; i < numbers.size() - 1; i++) {\n            result.add(numbers.get(i));\n            result.add(delimiter);\n        }\n        \n        result.add(numbers.get(numbers.size() - 1));\n        \n        return result;\n    }\n}\n", "py_code": "from typing import List\n\n\ndef intersperse(numbers: List[int], delimeter: int) -> List[int]:\n    if not numbers:\n        return []\n\n    result = []\n\n    for n in numbers[:-1]:\n        result.append(n)\n        result.append(delimeter)\n\n    result.append(numbers[-1])\n\n    return result\n", "py_summary": "The Python code defines a function `intersperse` that takes a list of integers `numbers` and an integer `delimiter` as input. It inserts the `delimiter` between every two consecutive elements of the input list `numbers`. \n\n1. It first checks if the input list `numbers` is empty, and if so, returns an empty list.\n2. It initializes an empty list `result` to store the interspersed elements.\n3. It then iterates through all elements of `numbers` except the last one, appends the current element and the `delimiter` to the `result` list.\n4. Finally, it appends the last element of `numbers` to the `result` list.\n5. It returns the final `result` list with the delimiters interspersed between consecutive elements of the input list."}
{"task_id": "Java/6", "generation": "import java.util.*;\n\nclass Solution {\n    public List<Integer> parse_nested_parens(String paren_string) {\n        List<Integer> depths = new ArrayList<>();\n        String[] groups = paren_string.split(\" \");\n        \n        for (String group : groups) {\n            depths.add(parseParenGroup(group));\n        }\n        \n        return depths;\n    }\n    \n    private int parseParenGroup(String s) {\n        int depth = 0;\n        int maxDepth = 0;\n        \n        for (char c : s.toCharArray()) {\n            if (c == '(') {\n                depth++;\n                maxDepth = Math.max(depth, maxDepth);\n            } else {\n                depth--;\n            }\n        }\n        \n        return maxDepth;\n    }\n}\n", "py_code": "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    def parse_paren_group(s):\n        depth = 0\n        max_depth = 0\n        for c in s:\n            if c == '(':\n                depth += 1\n                max_depth = max(depth, max_depth)\n            else:\n                depth -= 1\n\n        return max_depth\n\n    return [parse_paren_group(x) for x in paren_string.split(' ') if x]\n", "py_summary": "The Python code defines a function `parse_nested_parens` that takes a string `paren_string` as input and returns a list of integers representing the deepest level of nesting of parentheses for each group of nested parentheses in the input string. \n\nWithin the function, there is a nested function `parse_paren_group` that calculates the maximum nesting depth for a single group of parentheses. It iterates through each character in the group and increments the depth counter for each opening parenthesis '('. If it encounters a closing parenthesis ')', it decrements the depth counter. The function keeps track of the maximum depth reached during the iteration and returns that value.\n\nThe main function `parse_nested_parens` splits the input string by spaces to extract each group of parentheses. It then applies the `parse_paren_group` function to each group and collects the results in a list, excluding any empty groups. Finally, it returns the list of maximum depths for each group."}
{"task_id": "Java/7", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<String> filter_by_substring(List<String> strings, String substring) {\n        List<String> filteredStrings = new ArrayList<>();\n        for (String str : strings) {\n            if (str.contains(substring)) {\n                filteredStrings.add(str);\n            }\n        }\n        return filteredStrings;\n    }\n}\n", "py_code": "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    return [x for x in strings if substring in x]\n", "py_summary": "The Python code defines a function that takes a list of strings and a substring as input, and filters the list to only include strings that contain the given substring. A list comprehension is used to iterate over the input list of strings and include only those strings where the substring is found using the `in` operator. The filtered list is then returned as the output."}
{"task_id": "Java/8", "generation": "import java.util.*;\n\nclass Solution {\n    public List<Integer> sum_product(List<Integer> numbers) {\n        int sum = 0;\n        int product = 1;\n\n        for (int num : numbers) {\n            sum += num;\n            product *= num;\n        }\n\n        List<Integer> result = new ArrayList<>();\n        result.add(sum);\n        result.add(product);\n\n        return result;\n    }\n}\n", "py_code": "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    sum_value = 0\n    prod_value = 1\n\n    for n in numbers:\n        sum_value += n\n        prod_value *= n\n    return sum_value, prod_value\n", "py_summary": "The Python code defines a function `sum_product` that takes a list of integers as input and returns a tuple containing the sum and product of all the integers in the list. It initializes variables `sum_value` to 0 and `prod_value` to 1 to keep track of the sum and product, respectively. \n\nThe function then iterates through the input list, updating the `sum_value` by adding each integer and updating the `prod_value` by multiplying each integer. Finally, it returns a tuple containing the calculated sum and product of all the integers in the list."}
{"task_id": "Java/9", "generation": "import java.util.*;\n\nclass Solution {\n    public List<Integer> rolling_max(List<Integer> numbers) {\n        List<Integer> result = new ArrayList<>();\n        Integer runningMax = null;\n\n        for (Integer n : numbers) {\n            if (runningMax == null) {\n                runningMax = n;\n            } else {\n                runningMax = Math.max(runningMax, n);\n            }\n            result.add(runningMax);\n        }\n\n        return result;\n    }\n}\n", "py_code": "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    running_max = None\n    result = []\n\n    for n in numbers:\n        if running_max is None:\n            running_max = n\n        else:\n            running_max = max(running_max, n)\n\n        result.append(running_max)\n\n    return result\n", "py_summary": "The Python code defines a function `rolling_max` that takes a list of integers as input and returns a list of rolling maximum elements found until a given moment in the sequence. The function initializes variables `running_max` to `None` and an empty list `result` to store the rolling maximum values.\n\nIt then iterates through the input list of numbers and updates the `running_max` variable to the maximum value between the current element and the previous `running_max`. The function appends the updated `running_max` to the `result` list at each step.\n\nFinally, the function returns the list `result` containing the rolling maximum elements."}
{"task_id": "Java/10", "generation": "import java.util.*;\n\nclass Solution {\n    public boolean isPalindrome(String string) {\n        int i = 0;\n        int j = string.length() - 1;\n        while (i < j) {\n            if (string.charAt(i) != string.charAt(j)) {\n                return false;\n            }\n            i++;\n            j--;\n        }\n        return true;\n    }\n\n    public String make_palindrome(String string) {\n        if (string.isEmpty()) {\n            return \"\";\n        }\n\n        int beginningOfSuffix = 0;\n        while (!isPalindrome(string.substring(beginningOfSuffix))) {\n            beginningOfSuffix++;\n        }\n\n        return string + new StringBuilder(string.substring(0, beginningOfSuffix)).reverse().toString();\n    }\n}\n", "py_code": "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    if not string:\n        return ''\n\n    beginning_of_suffix = 0\n\n    while not is_palindrome(string[beginning_of_suffix:]):\n        beginning_of_suffix += 1\n\n    return string + string[:beginning_of_suffix][::-1]\n", "py_summary": "The `is_palindrome` function checks if a given string is a palindrome by comparing the string with its reverse. If the string is equal to its reverse, it returns `True`, indicating that the string is a palindrome.\n\nThe `make_palindrome` function constructs the shortest palindrome that begins with the supplied string. It iterates through the string to find the longest postfix that is a palindrome. Then, it appends the reverse of the prefix that comes before the palindromic suffix to the end of the string. If the input string is empty, it returns an empty string."}
{"task_id": "Java/11", "generation": "import java.util.*;\n\nclass Solution {\n    public String string_xor(String a, String b) {\n        StringBuilder result = new StringBuilder();\n        for (int i = 0; i < a.length(); i++) {\n            if (a.charAt(i) == b.charAt(i)) {\n                result.append('0');\n            } else {\n                result.append('1');\n            }\n        }\n        return result.toString();\n    }\n}\n", "py_code": "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    def xor(i, j):\n        if i == j:\n            return '0'\n        else:\n            return '1'\n\n    return ''.join(xor(x, y) for x, y in zip(a, b))\n", "py_summary": "The Python code defines a function `string_xor` that takes two binary strings `a` and `b` as input and performs a bitwise XOR operation on them. The function internally uses a helper function `xor` to perform the XOR operation on individual bits. \n\nThe `xor` function compares two bits `i` and `j` and returns '0' if they are equal, and '1' otherwise. \n\nThe main function `string_xor` then iterates through the corresponding bits of strings `a` and `b` using `zip` and applies the `xor` function to each pair of bits. The result of the XOR operation for each pair is concatenated to form the final result string, which is then returned."}
{"task_id": "Java/12", "generation": "import java.util.*;\n\nclass Solution {\n    public Optional<String> longest(List<String> strings) {\n        if (strings.isEmpty()) {\n            return Optional.empty();\n        }\n\n        int maxLength = 0;\n        String longestString = \"\";\n        for (String s : strings) {\n            if (s.length() > maxLength) {\n                maxLength = s.length();\n                longestString = s;\n            }\n        }\n        return Optional.of(longestString);\n    }\n}\n", "py_code": "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    if not strings:\n        return None\n\n    maxlen = max(len(x) for x in strings)\n    for s in strings:\n        if len(s) == maxlen:\n            return s\n", "py_summary": "The Python code defines a function that takes a list of strings as input and returns the longest string in the list. If the input list is empty, the function returns `None`. It first checks if the input list is empty and returns `None` if it is. Then, it calculates the maximum length of the strings in the list. Next, it iterates through the strings in the list and returns the first string that has a length equal to the maximum length found."}
{"task_id": "Java/13", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int greatest_common_divisor(int a, int b) {\n        while (b != 0) {\n            int temp = b;\n            b = a % b;\n            a = temp;\n        }\n        return a;\n    }\n}\n", "py_code": "def greatest_common_divisor(a: int, b: int) -> int:\n    while b:\n        a, b = b, a % b\n    return a\n", "py_summary": "The Python code defines a function that calculates the greatest common divisor (GCD) of two integers `a` and `b` using the Euclidean algorithm. The function iteratively calculates the remainder of `a` divided by `b` and updates `a` to `b` and `b` to the remainder until `b` becomes 0. At this point, the GCD is the value of `a`, which is then returned."}
{"task_id": "Java/14", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<String> all_prefixes(String string) {\n        List<String> result = new ArrayList<>();\n        \n        for (int i = 0; i < string.length(); i++) {\n            result.add(string.substring(0, i + 1));\n        }\n        \n        return result;\n    }\n}\n", "py_code": "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    result = []\n\n    for i in range(len(string)):\n        result.append(string[:i+1])\n    return result\n", "py_summary": "The Python code defines a function that takes a string as input and returns a list of all prefixes of the input string from the shortest to the longest. The function initializes an empty list `result` to store the prefixes. It then iterates through the indices of the input string and appends the substring from index 0 to the current index (inclusive) to the `result` list. Finally, the function returns the list of prefixes."}
{"task_id": "Java/15", "generation": "import java.util.*;\n\nclass Solution {\n    public String string_sequence(int n) {\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i <= n; i++) {\n            sb.append(i).append(\" \");\n        }\n        return sb.toString().trim();\n    }\n}\n", "py_code": "def string_sequence(n: int) -> str:\n    return ' '.join([str(x) for x in range(n + 1)])\n", "py_summary": "The Python code defines a function `string_sequence` that takes an integer `n` as input and returns a string containing space-delimited numbers starting from 0 up to `n` (inclusive). \n\nIt uses a list comprehension to generate a list of numbers from 0 to `n`, converts each number to a string, and then joins these strings with a space delimiter using the `join` method. Finally, the function returns the concatenated string."}
{"task_id": "Java/16", "generation": "import java.util.*;\n\nclass Solution {\n    public int count_distinct_characters(String string) {\n        Set<Character> charSet = new HashSet<>();\n        for (char c : string.toLowerCase().toCharArray()) {\n            charSet.add(c);\n        }\n        return charSet.size();\n    }\n}\n", "py_code": "def count_distinct_characters(string: str) -> int:\n    return len(set(string.lower()))\n", "py_summary": "The Python code defines a function that takes a string as input and returns the count of distinct characters in the string, regardless of case. It converts the string to lowercase using the `lower()` method to ensure case insensitivity. Then, it converts the string to a set to get unique characters and finally returns the length of the set, which represents the count of distinct characters in the string."}
{"task_id": "Java/17", "generation": "import java.util.*;\n\nclass Solution {\n    public List<Integer> parse_music(String string) {\n        Map<String, Integer> noteMap = new HashMap<>();\n        noteMap.put(\"o\", 4);\n        noteMap.put(\"o|\", 2);\n        noteMap.put(\".|\", 1);\n        \n        List<Integer> durations = new ArrayList<>();\n        String[] notes = string.split(\" \");\n        \n        for (String note : notes) {\n            if (noteMap.containsKey(note)) {\n                durations.add(noteMap.get(note));\n            }\n        }\n        \n        return durations;\n    }\n}\n", "py_code": "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    note_map = {'o': 4, 'o|': 2, '.|': 1}\n    return [note_map[x] for x in music_string.split(' ') if x]\n", "py_summary": "The Python code defines a function `parse_music` that takes a string representing musical notes in a special ASCII format as input and returns a list of integers corresponding to the duration of each note. It uses a dictionary `note_map` to map each note to its corresponding duration in beats. \n\nThe function then splits the input string by spaces to extract individual notes. It iterates over the split notes, looks up the duration in the `note_map` dictionary, and appends the duration to the result list if the note is valid (not an empty string). Finally, it returns the list of durations."}
{"task_id": "Java/18", "generation": "import java.util.*;\n\nclass Solution {\n    public int how_many_times(String string, String substring) {\n        int times = 0;\n        \n        for (int i = 0; i <= string.length() - substring.length(); i++) {\n            if (string.substring(i, i + substring.length()).equals(substring)) {\n                times++;\n            }\n        }\n        \n        return times;\n    }\n}\n", "py_code": "def how_many_times(string: str, substring: str) -> int:\n    times = 0\n\n    for i in range(len(string) - len(substring) + 1):\n        if string[i:i+len(substring)] == substring:\n            times += 1\n\n    return times\n", "py_summary": "The Python code defines a function `how_many_times` that takes two strings as input: `string` and `substring`. It then iterates through the `string` using a sliding window approach to check if the current substring of length equal to the length of the `substring` matches the `substring`. If there is a match, it increments the `times` counter. Finally, it returns the total count of occurrences of the `substring` in the `string`, considering overlapping cases."}
{"task_id": "Java/19", "generation": "import java.util.*;\n\nclass Solution {\n    public String sort_numbers(String numbers) {\n        Map<String, Integer> valueMap = new HashMap<>();\n        valueMap.put(\"zero\", 0);\n        valueMap.put(\"one\", 1);\n        valueMap.put(\"two\", 2);\n        valueMap.put(\"three\", 3);\n        valueMap.put(\"four\", 4);\n        valueMap.put(\"five\", 5);\n        valueMap.put(\"six\", 6);\n        valueMap.put(\"seven\", 7);\n        valueMap.put(\"eight\", 8);\n        valueMap.put(\"nine\", 9);\n\n        List<String> numberList = new ArrayList<>(Arrays.asList(numbers.split(\" \")));\n        numberList.removeIf(String::isEmpty);\n        numberList.sort(Comparator.comparingInt(valueMap::get));\n\n        return String.join(\" \", numberList);\n    }\n}\n", "py_code": "from typing import List\n\n\ndef sort_numbers(numbers: str) -> str:\n    value_map = {\n        'zero': 0,\n        'one': 1,\n        'two': 2,\n        'three': 3,\n        'four': 4,\n        'five': 5,\n        'six': 6,\n        'seven': 7,\n        'eight': 8,\n        'nine': 9\n    }\n    return ' '.join(sorted([x for x in numbers.split(' ') if x], key=lambda x: value_map[x]))\n", "py_summary": "The Python code defines a function `sort_numbers` that takes a space-delimited string of numbers in words as input and returns a string with the numbers sorted from smallest to largest. It first creates a dictionary `value_map` that maps each word representation of a number to its corresponding numerical value. \n\nThe function then splits the input string into individual words, filters out any empty strings, sorts the words based on their numerical values using the `value_map`, and finally joins the sorted words back into a string with space as the delimiter. The sorted string is then returned as the output."}
{"task_id": "Java/20", "generation": "import java.util.*;\n\nclass Solution {\n    public List<Double> find_closest_elements(List<Double> numbers) {\n        List<Double> closestPair = new ArrayList<>();\n        Double[] result = new Double[2];\n        Double distance = null;\n\n        for (int i = 0; i < numbers.size(); i++) {\n            for (int j = 0; j < numbers.size(); j++) {\n                if (i != j) {\n                    Double num1 = numbers.get(i);\n                    Double num2 = numbers.get(j);\n                    Double newDistance = Math.abs(num1 - num2);\n                    if (distance == null || newDistance < distance) {\n                        distance = newDistance;\n                        result[0] = num1;\n                        result[1] = num2;\n                    }\n                }\n            }\n        }\n\n        closestPair.add(result[0]);\n        closestPair.add(result[1]);\n        Collections.sort(closestPair);\n        return closestPair;\n    }\n}\n", "py_code": "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    closest_pair = None\n    distance = None\n\n    for idx, elem in enumerate(numbers):\n        for idx2, elem2 in enumerate(numbers):\n            if idx != idx2:\n                if distance is None:\n                    distance = abs(elem - elem2)\n                    closest_pair = tuple(sorted([elem, elem2]))\n                else:\n                    new_distance = abs(elem - elem2)\n                    if new_distance < distance:\n                        distance = new_distance\n                        closest_pair = tuple(sorted([elem, elem2]))\n\n    return closest_pair\n", "py_summary": "The Python code defines a function `find_closest_elements` that takes a list of floating-point numbers as input and returns a tuple containing the two numbers that are closest to each other in the list. \n\n1. It initializes variables `closest_pair` and `distance` to None.\n2. It then iterates through the input list using nested loops to compare each pair of numbers.\n3. For each pair of numbers, it calculates the absolute difference and checks if it is smaller than the current smallest distance found.\n4. If a new smallest distance is found, it updates the `closest_pair` tuple with the pair of numbers and updates the `distance`.\n5. Finally, it returns the `closest_pair` tuple containing the two closest elements.\n\nThis approach compares all possible pairs of numbers in the list to find the pair with the smallest absolute difference.\n\n### Last step, write the Java solution according to the python code and the analysis."}
{"task_id": "Java/21", "generation": "import java.util.*;\n\nclass Solution {\n    public List<Double> rescale_to_unit(List<Double> numbers) {\n        double minNumber = Collections.min(numbers);\n        double maxNumber = Collections.max(numbers);\n        List<Double> rescaledNumbers = new ArrayList<>();\n        \n        for (double num : numbers) {\n            double rescaledValue = (num - minNumber) / (maxNumber - minNumber);\n            rescaledNumbers.add(rescaledValue);\n        }\n        \n        return rescaledNumbers;\n    }\n}\n", "py_code": "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    min_number = min(numbers)\n    max_number = max(numbers)\n    return [(x - min_number) / (max_number - min_number) for x in numbers]\n", "py_summary": "The Python code defines a function that takes a list of numbers as input and applies a linear transformation to rescale the numbers to the unit interval [0, 1]. The function first finds the minimum and maximum numbers in the input list. Then, it calculates the rescaled value for each number in the list using the formula: \n\nrescaled_value = (x - min_number) / (max_number - min_number)\n\nwhere x is the original number, min_number is the minimum number in the list, and max_number is the maximum number in the list. Finally, the function returns a new list containing the rescaled values of the input numbers."}
{"task_id": "Java/22", "generation": "import java.util.*;\n\nclass Solution {\n    public List<Integer> filter_integers(List<Object> values) {\n        List<Integer> integers = new ArrayList<>();\n        for (Object value : values) {\n            if (value instanceof Integer) {\n                integers.add((Integer) value);\n            }\n        }\n        return integers;\n    }\n}\n", "py_code": "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    return [x for x in values if isinstance(x, int)]\n", "py_summary": "The Python code defines a function that takes a list of values of any type as input and filters out only the integer values from the list. It uses a list comprehension to iterate through the input list and includes only the elements that are of type `int` in the output list. The function then returns the filtered list containing only integer values."}
{"task_id": "Java/23", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int strlen(String string) {\n        return string.length();\n    }\n}\n", "py_code": "def strlen(string: str) -> int:\n    return len(string)\n", "py_summary": "The Python code defines a function `strlen` that takes a string as input and returns the length of the string using the `len()` function, which calculates the number of characters in the string."}
{"task_id": "Java/24", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int largest_divisor(int n) {\n        for (int i = n - 1; i > 0; i--) {\n            if (n % i == 0) {\n                return i;\n            }\n        }\n        return -1; // If no divisor found (should not reach this point for positive n)\n    }\n}\n", "py_code": "def largest_divisor(n: int) -> int:\n    for i in reversed(range(n)):\n        if n % i == 0:\n            return i\n", "py_summary": "The Python code defines a function that takes an integer `n` as input and finds the largest number that evenly divides `n` and is smaller than `n`. The function iterates in reverse order from `n-1` down to `1` (exclusive) and checks if the current number is a divisor of `n` by checking if the remainder of `n` divided by the current number is zero. If a divisor is found, the function immediately returns that number as the largest divisor."}
{"task_id": "Java/25", "generation": "import java.util.*;\n\nclass Solution {\n    public List<Integer> factorize(int n) {\n        List<Integer> factors = new ArrayList<>();\n        int i = 2;\n        while (i <= Math.sqrt(n) + 1) {\n            if (n % i == 0) {\n                factors.add(i);\n                n /= i;\n            } else {\n                i++;\n            }\n        }\n\n        if (n > 1) {\n            factors.add(n);\n        }\n        return factors;\n    }\n}\n", "py_code": "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    import math\n    fact = []\n    i = 2\n    while i <= int(math.sqrt(n) + 1):\n        if n % i == 0:\n            fact.append(i)\n            n //= i\n        else:\n            i += 1\n\n    if n > 1:\n        fact.append(n)\n    return fact\n", "py_summary": "The Python code defines a function `factorize` that takes an integer `n` as input and returns a list of prime factors of the input integer in ascending order. The function initializes an empty list `fact` to store the prime factors. It then iterates from 2 up to the square root of `n` (inclusive) and checks if `n` is divisible by the current number `i`. If it is divisible, `i` is a prime factor of `n`, and it is added to the `fact` list while updating `n` by dividing it by `i`. If `n` is not divisible by `i`, `i` is incremented by 1.\n\nAfter the loop, if `n` is greater than 1, it means that `n` itself is a prime factor, and it is added to the `fact` list. Finally, the function returns the list of prime factors of `n`.\n\nThe code effectively factors the input integer `n` into its prime factors and returns them in the order from smallest to largest."}
{"task_id": "Java/26", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> remove_duplicates(List<Integer> numbers) {\n        Map<Integer, Integer> countMap = new HashMap<>();\n        List<Integer> result = new ArrayList<>();\n        \n        for (Integer num : numbers) {\n            countMap.put(num, countMap.getOrDefault(num, 0) + 1);\n            if (countMap.get(num) == 1) {\n                result.add(num);\n            }\n        }\n        \n        return result;\n    }\n}\n", "py_code": "from typing import List\n\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    import collections\n    c = collections.Counter(numbers)\n    return [n for n in numbers if c[n] <= 1]\n", "py_summary": "The Python code defines a function that takes a list of integers as input and removes all elements that occur more than once in the list. It uses the `Counter` class from the `collections` module to count the occurrences of each element in the input list. Then, it creates a new list comprehension that filters out elements from the original list if their count is greater than 1, effectively removing duplicates. The function returns the filtered list with duplicates removed while maintaining the original order of elements."}
{"task_id": "Java/27", "generation": "import java.util.*;\n\nclass Solution {\n    public String flip_case(String string) {\n        char[] chars = string.toCharArray();\n        for (int i = 0; i < chars.length; i++) {\n            if (Character.isUpperCase(chars[i])) {\n                chars[i] = Character.toLowerCase(chars[i]);\n            } else if (Character.isLowerCase(chars[i])) {\n                chars[i] = Character.toUpperCase(chars[i]);\n            }\n        }\n        return new String(chars);\n    }\n}\n", "py_code": "def flip_case(string: str) -> str:\n    return string.swapcase()\n", "py_summary": "The Python code defines a function `flip_case` that takes a string as input and returns a new string where the case of each character is flipped (lowercase characters become uppercase and vice versa). The `swapcase()` method is used to achieve this functionality in Python. It directly swaps the case of each character in the string and returns the modified string."}
{"task_id": "Java/28", "generation": "import java.util.*;\n\nclass Solution {\n    public String concatenate(List<String> strings) {\n        StringBuilder sb = new StringBuilder();\n        for (String str : strings) {\n            sb.append(str);\n        }\n        return sb.toString();\n    }\n}\n", "py_code": "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    return ''.join(strings)\n", "py_summary": "The Python code defines a function that takes a list of strings as input and concatenates them into a single string. It uses the `join` method to concatenate all the strings in the list without any separator between them. The function then returns the concatenated string."}
{"task_id": "Java/29", "generation": "import java.util.*;\nimport java.lang.*;\nimport java.util.stream.Collectors;\n\nclass Solution {\n    public List<String> filter_by_prefix(List<String> strings, String prefix) {\n        return strings.stream()\n                .filter(s -> s.startsWith(prefix))\n                .collect(Collectors.toList());\n    }\n}\n", "py_code": "from typing import List\n\n\ndef filter_by_prefix(strings: List[str], prefix: str) -> List[str]:\n    return [x for x in strings if x.startswith(prefix)]\n", "py_summary": "The Python code defines a function that takes a list of strings and a prefix as input, and returns a new list containing only the strings that start with the given prefix. It uses a list comprehension to iterate over each string in the input list and filters out the strings that do not start with the specified prefix using the `startswith()` method. The filtered strings are then returned as a new list."}
{"task_id": "Java/30", "generation": "import java.util.*;\nimport java.lang.*;\nimport java.util.stream.Collectors;\n\nclass Solution {\n    public List<Integer> get_positive(List<Integer> l) {\n        return l.stream()\n                .filter(e -> e > 0)\n                .collect(Collectors.toList());\n    }\n}\n", "py_code": "def get_positive(l: list):\n    return [e for e in l if e > 0]\n", "py_summary": "The Python code defines a function that takes a list of integers as input and returns a new list containing only the positive numbers from the input list. It uses list comprehension to iterate over the elements in the input list and filter out the positive numbers by checking if each element is greater than 0. The function then returns the list of positive numbers."}
{"task_id": "Java/31", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public boolean is_prime(int n) {\n        if (n < 2) {\n            return false;\n        }\n        for (int k = 2; k < n; k++) {\n            if (n % k == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n", "py_code": "def is_prime(n):\n    if n < 2:\n        return False\n    for k in range(2, n - 1):\n        if n % k == 0:\n            return False\n    return True\n", "py_summary": "The Python code defines a function that checks if a given number is prime or not. It first checks if the number is less than 2, in which case it returns False as numbers less than 2 are not prime. Then, it iterates from 2 to n-1 and checks if n is divisible by any number in that range. If n is divisible by any number, it returns False as it indicates that n is not a prime number. If the loop completes without finding any divisors, it returns True, indicating that n is a prime number."}
{"task_id": "Java/32", "generation": "import java.util.*;\n\nclass Solution {\n    public double poly(List<Double> xs, double x) {\n        double result = 0;\n        for (int i = 0; i < xs.size(); i++) {\n            result += xs.get(i) * Math.pow(x, i);\n        }\n        return result;\n    }\n\n    public double find_zero(List<Double> xs) {\n        double begin = -1.0;\n        double end = 1.0;\n        while (poly(xs, begin) * poly(xs, end) > 0) {\n            begin *= 2.0;\n            end *= 2.0;\n        }\n        while (end - begin > 1e-10) {\n            double center = (begin + end) / 2.0;\n            if (poly(xs, center) * poly(xs, begin) > 0) {\n                begin = center;\n            } else {\n                end = center;\n            }\n        }\n        return begin;\n    }\n}\n", "py_code": "import math\n\n\ndef poly(xs: list, x: float):\n    \"\"\"\n    Evaluates polynomial with coefficients xs at point x.\n    return xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n\n    \"\"\"\n    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])\n\n\ndef find_zero(xs: list):\n    begin, end = -1., 1.\n    while poly(xs, begin) * poly(xs, end) > 0:\n        begin *= 2.0\n        end *= 2.0\n    while end - begin > 1e-10:\n        center = (begin + end) / 2.0\n        if poly(xs, center) * poly(xs, begin) > 0:\n            begin = center\n        else:\n            end = center\n    return begin\n", "py_summary": "The Python code consists of two functions:\n1. `poly(xs: list, x: float)`: This function evaluates a polynomial with coefficients `xs` at a given point `x`. It iterates through the coefficients and calculates the value of the polynomial at point `x` by summing up the terms `coeff * x^i` for each coefficient in `xs`.\n2. `find_zero(xs: list)`: This function finds a zero point of the polynomial defined by the coefficients in the list `xs`. It uses the binary search method to find the root within a given range. It first expands the range where the root might lie by doubling the interval until the signs of the function values at the endpoints are different. Then, it performs binary search within this range to find the zero point with a precision of `1e-10`.\n\nThe `find_zero` function ensures that it returns only one zero point even if there are multiple zeros, and it only works with lists of coefficients having an even number of elements and the largest non-zero coefficient to guarantee a solution."}
{"task_id": "Java/33", "generation": "import java.util.*;\n\nclass Solution {\n    public List<Integer> sort_third(List<Integer> l) {\n        List<Integer> sortedList = new ArrayList<>(l);\n        for (int i = 2; i < l.size(); i += 3) {\n            List<Integer> sublist = new ArrayList<>();\n            for (int j = i; j < l.size(); j += 3) {\n                sublist.add(l.get(j));\n            }\n            Collections.sort(sublist);\n            int index = 0;\n            for (int j = i; j < l.size(); j += 3) {\n                sortedList.set(j, sublist.get(index));\n                index++;\n            }\n        }\n        return sortedList;\n    }\n}\n", "py_code": "def sort_third(l: list):\n    l = list(l)\n    l[::3] = sorted(l[::3])\n    return l\n", "py_summary": "The Python code defines a function that takes a list of integers as input and returns a new list where the values at indices divisible by three are sorted in ascending order, while the values at indices not divisible by three remain unchanged. \n\n1. It first converts the input list `l` to a mutable list.\n2. It then uses list slicing with a step of 3 (`l[::3]`) to access the elements at indices divisible by three and sorts them in ascending order.\n3. Finally, it assigns the sorted values back to the corresponding indices in the original list and returns the modified list."}
{"task_id": "Java/34", "generation": "import java.util.*;\n\nclass Solution {\n    public List<Integer> unique(List<Integer> l) {\n        Set<Integer> uniqueSet = new HashSet<>(l);\n        List<Integer> uniqueList = new ArrayList<>(uniqueSet);\n        Collections.sort(uniqueList);\n        return uniqueList;\n    }\n}\n", "py_code": "def unique(l: list):\n    return sorted(list(set(l)))\n", "py_summary": "The Python code defines a function that takes a list of integers as input and returns a new list containing the unique elements from the input list in sorted order. It achieves this by first converting the input list to a set to remove duplicates, then converting the set back to a list, and finally sorting the list in ascending order before returning it."}
{"task_id": "Java/35", "generation": "import java.util.*;\n\nclass Solution {\n    public int max_element(List<Integer> l) {\n        int m = l.get(0);\n        for (int i = 1; i < l.size(); i++) {\n            if (l.get(i) > m) {\n                m = l.get(i);\n            }\n        }\n        return m;\n    }\n}\n", "py_code": "def max_element(l: list):\n    m = l[0]\n    for e in l:\n        if e > m:\n            m = e\n    return m\n", "py_summary": "The Python code defines a function that takes a list of integers as input and returns the maximum element in the list. It initializes a variable `m` to the first element of the list. Then, it iterates through the list and updates `m` to the current element if the current element is greater than `m`. Finally, it returns the maximum element `m`."}
{"task_id": "Java/36", "generation": "import java.util.*;\n\nclass Solution {\n    public int fizz_buzz(int n) {\n        List<Integer> ns = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            if (i % 11 == 0 || i % 13 == 0) {\n                ns.add(i);\n            }\n        }\n        String s = \"\";\n        for (int num : ns) {\n            s += num;\n        }\n        int ans = 0;\n        for (char c : s.toCharArray()) {\n            if (c == '7') {\n                ans++;\n            }\n        }\n        return ans;\n    }\n}\n", "py_code": "def fizz_buzz(n: int):\n    ns = []\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            ns.append(i)\n    s = ''.join(list(map(str, ns)))\n    ans = 0\n    for c in s:\n        ans += (c == '7')\n    return ans\n", "py_summary": "The Python code defines a function `fizz_buzz` that takes an integer `n` as input and returns the number of times the digit 7 appears in integers less than `n` which are divisible by 11 or 13. \n1. It initializes an empty list `ns` to store the numbers divisible by 11 or 13.\n2. It iterates through numbers from 0 to `n-1` and checks if the number is divisible by 11 or 13. If it is, the number is added to the list `ns`.\n3. It converts the list of numbers to a string `s` by joining them.\n4. It initializes a variable `ans` to 0 to count the number of times digit 7 appears.\n5. It iterates through each character in the string `s` and increments `ans` by 1 if the character is '7'.\n6. Finally, it returns the total count of digit 7 in the selected numbers.\n\nThe code effectively finds the count of digit 7 in numbers less than `n` that are divisible by 11 or 13."}
{"task_id": "Java/37", "generation": "import java.util.*;\n\nclass Solution {\n    public List<Integer> sort_even(List<Integer> l) {\n        List<Integer> evens = new ArrayList<>();\n        List<Integer> odds = new ArrayList<>();\n        \n        for (int i = 0; i < l.size(); i++) {\n            if (i % 2 == 0) {\n                evens.add(l.get(i));\n            } else {\n                odds.add(l.get(i));\n            }\n        }\n        \n        Collections.sort(evens);\n        \n        List<Integer> ans = new ArrayList<>();\n        int evenIndex = 0;\n        int oddIndex = 0;\n        \n        for (int i = 0; i < l.size(); i++) {\n            if (i % 2 == 0) {\n                ans.add(evens.get(evenIndex));\n                evenIndex++;\n            } else {\n                ans.add(odds.get(oddIndex));\n                oddIndex++;\n            }\n        }\n        \n        if (evens.size() > odds.size()) {\n            ans.add(evens.get(evens.size() - 1));\n        }\n        \n        return ans;\n    }\n}\n", "py_code": "def sort_even(l: list):\n    evens = l[::2]\n    odds = l[1::2]\n    evens.sort()\n    ans = []\n    for e, o in zip(evens, odds):\n        ans.extend([e, o])\n    if len(evens) > len(odds):\n        ans.append(evens[-1])\n    return ans\n", "py_summary": "The Python code defines a function `sort_even` that takes a list `l` as input and returns a new list `ans` based on the following rules:\n1. The even indices of the output list `ans` will contain the sorted values of the even indices of the input list `l`.\n2. The odd indices of the output list `ans` will contain the values of the odd indices of the input list `l`.\n\nThe function first extracts the even and odd elements from the input list `l`. It then sorts the even elements. Next, it iterates through the sorted even elements and the odd elements simultaneously using `zip`, constructing the output list `ans` by interleaving the sorted even elements and the odd elements.\n\nIf the number of even elements is greater than the number of odd elements, the last even element is appended to the output list `ans`. Finally, the function returns the modified list `ans`."}
{"task_id": "Java/38", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n    returns encoded string by cycling groups of three characters.\n     */\n    public String encodeCyclic(String s) {\n        List<String> groups = new ArrayList<>();\n        for (int i = 0; i < s.length(); i += 3) {\n            groups.add(s.substring(i, Math.min(i + 3, s.length())));\n        }\n        for (int i = 0; i < groups.size(); i++) {\n            if (groups.get(i).length() == 3) {\n                groups.set(i, groups.get(i).substring(1) + groups.get(i).charAt(0));\n            }\n        }\n        return String.join(\"\", groups);\n    }\n\n    /**\n    takes as input string encoded with encodeCyclic function. Returns decoded string.\n     */\n    public String decode_cyclic(String s) {\n        return encodeCyclic(encodeCyclic(s));\n    }\n}\n", "py_code": "def encode_cyclic(s: str):\n    \"\"\"\n    returns encoded string by cycling groups of three characters.\n    \"\"\"\n    # split string to groups. Each of length 3.\n    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]\n    # cycle elements in each group. Unless group has fewer elements than 3.\n    groups = [(group[1:] + group[0]) if len(group) == 3 else group for group in groups]\n    return \"\".join(groups)\n\n\ndef decode_cyclic(s: str):\n    return encode_cyclic(encode_cyclic(s))\n", "py_summary": "The Python code defines two functions:\n1. `encode_cyclic(s: str)`: This function takes a string `s` as input and encodes it by cycling groups of three characters. It first splits the input string into groups of length 3. Then, it cycles the elements in each group by moving the first character to the end, unless the group has fewer than 3 elements. Finally, it joins the modified groups together and returns the encoded string.\n\n2. `decode_cyclic(s: str)`: This function decodes a string that was encoded using the `encode_cyclic` function. It does this by applying the `encode_cyclic` function twice on the input string, effectively reversing the encoding process.\n\nThe encoding process involves splitting the string into groups of 3 characters and cycling the characters within each group. The decoding process reverses this encoding by applying the encoding process in reverse.\n\nThe functions are designed to work together to encode and decode strings cyclically in groups of three characters."}
{"task_id": "Java/39", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int prime_fib(int n) {\n        List<Integer> fibonacci = new ArrayList<>();\n        fibonacci.add(0);\n        fibonacci.add(1);\n        \n        while (true) {\n            int size = fibonacci.size();\n            fibonacci.add(fibonacci.get(size - 1) + fibonacci.get(size - 2));\n            if (isPrime(fibonacci.get(size))) {\n                n--;\n            }\n            if (n == 0) {\n                return fibonacci.get(size);\n            }\n        }\n    }\n    \n    public boolean isPrime(int num) {\n        if (num < 2) {\n            return false;\n        }\n        for (int i = 2; i <= Math.min((int) Math.sqrt(num) + 1, num - 1); i++) {\n            if (num % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n", "py_code": "def prime_fib(n: int):\n    import math\n\n    def is_prime(p):\n        if p < 2:\n            return False\n        for k in range(2, min(int(math.sqrt(p)) + 1, p - 1)):\n            if p % k == 0:\n                return False\n        return True\n    f = [0, 1]\n    while True:\n        f.append(f[-1] + f[-2])\n        if is_prime(f[-1]):\n            n -= 1\n        if n == 0:\n            return f[-1]\n", "py_summary": "The Python code defines a function `prime_fib` that takes an integer `n` as input and returns the n-th number that is both a Fibonacci number and a prime number. \n\n1. The function first defines an inner function `is_prime` to check if a given number is prime. It iterates from 2 up to the square root of the number (or up to the number - 1 if the number is less than the square root) and checks if the number is divisible by any of the integers in that range. If it finds a divisor, it returns `False`; otherwise, it returns `True`.\n\n2. It initializes a list `f` with the first two Fibonacci numbers [0, 1].\n\n3. It then enters a loop where it calculates the next Fibonacci number by adding the last two numbers in the list. If the newly calculated Fibonacci number is prime, it decrements the value of `n`.\n\n4. Once `n` becomes 0, the function returns the last Fibonacci number that was found to be prime.\n\n5. The function effectively finds the n-th Fibonacci number that is also a prime number and returns it.\n\nNow, let's write the Java solution based on the Python solution and the Python code summary."}
{"task_id": "Java/40", "generation": "import java.util.*;\n\nclass Solution {\n    public boolean triples_sum_to_zero(List<Integer> l) {\n        for (int i = 0; i < l.size(); i++) {\n            for (int j = i + 1; j < l.size(); j++) {\n                for (int k = j + 1; k < l.size(); k++) {\n                    if (l.get(i) + l.get(j) + l.get(k) == 0) {\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }\n}\n", "py_code": "def triples_sum_to_zero(l: list):\n    for i in range(len(l)):\n        for j in range(i + 1, len(l)):\n            for k in range(j + 1, len(l)):\n                if l[i] + l[j] + l[k] == 0:\n                    return True\n    return False\n", "py_summary": "The Python code defines a function `triples_sum_to_zero` that takes a list of integers as input and returns `True` if there exist three distinct elements in the list that sum to zero, and `False` otherwise. The function uses three nested loops to iterate through all possible combinations of three elements in the list. It then checks if the sum of the current triplet is equal to zero. If such a triplet is found, the function returns `True`. If no triplet sums to zero, the function returns `False`."}
{"task_id": "Java/41", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int car_race_collision(int n) {\n        return n * n;\n    }\n}\n", "py_code": "def car_race_collision(n: int):\n    return n**2\n", "py_summary": "The Python code defines a function that calculates the number of collisions that will occur between the left-moving cars and right-moving cars on an infinitely long straight road. The function takes the number of cars (n) as input and returns the square of the number of cars (n^2) as the output. This is because each left-moving car can potentially collide with each right-moving car, resulting in a collision count of n^2."}
{"task_id": "Java/42", "generation": "import java.util.*;\nimport java.lang.*;\nimport java.util.stream.Collectors;\n\nclass Solution {\n    public List<Integer> incr_list(List<Integer> l) {\n        return l.stream().map(num -> num + 1).collect(Collectors.toList());\n    }\n}\n", "py_code": "def incr_list(l: list):\n    return [(e + 1) for e in l]\n", "py_summary": "The Python code defines a function that takes a list of integers as input and returns a new list where each element is incremented by 1. It uses list comprehension to iterate over each element in the input list, adding 1 to each element, and returning the new list with the incremented values."}
{"task_id": "Java/43", "generation": "import java.util.*;\n\nclass Solution {\n    public boolean pairs_sum_to_zero(List<Integer> l) {\n        for (int i = 0; i < l.size(); i++) {\n            for (int j = i + 1; j < l.size(); j++) {\n                if (l.get(i) + l.get(j) == 0) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n}\n", "py_code": "def pairs_sum_to_zero(l):\n    for i, l1 in enumerate(l):\n        for j in range(i + 1, len(l)):\n            if l1 + l[j] == 0:\n                return True\n    return False\n", "py_summary": "The Python code defines a function `pairs_sum_to_zero` that takes a list of integers as input and returns `True` if there are two distinct elements in the list that sum to zero, and `False` otherwise. The function iterates through the list using nested loops to check all possible pairs of elements. If the sum of any two elements is equal to zero, the function returns `True`. If no such pair is found after checking all combinations, the function returns `False`."}
{"task_id": "Java/44", "generation": "import java.util.*;\n\nclass Solution {\n    public String change_base(int x, int base) {\n        StringBuilder sb = new StringBuilder();\n        while (x > 0) {\n            sb.insert(0, x % base);\n            x /= base;\n        }\n        return sb.toString();\n    }\n}\n", "py_code": "def change_base(x: int, base: int):\n    ret = \"\"\n    while x > 0:\n        ret = str(x % base) + ret\n        x //= base\n    return ret\n", "py_summary": "The Python code defines a function that converts a given number `x` from its base 10 representation to a different base specified by the `base` parameter. The function iteratively calculates the remainder of `x` when divided by the new base and appends it to the result string. It then updates `x` to be the result of the integer division of `x` by the new base. This process continues until `x` becomes 0, at which point the function returns the string representation of the converted number."}
{"task_id": "Java/45", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public double triangle_area(double a, double h) {\n        return a * h / 2.0;\n    }\n}\n", "py_code": "def triangle_area(a, h):\n    return a * h / 2.0\n", "py_summary": "The Python code defines a function that calculates the area of a triangle given the length of one of its sides (a) and the corresponding height (h). The formula used to calculate the area of a triangle is (base * height) / 2.0. The function simply applies this formula and returns the calculated area as a floating-point number."}
{"task_id": "Java/46", "generation": "import java.util.*;\n\nclass Solution {\n    public int fib4(int n) {\n        List<Integer> results = new ArrayList<>(List.of(0, 0, 2, 0));\n        if (n < 4) {\n            return results.get(n);\n        }\n\n        for (int i = 4; i <= n; i++) {\n            int next = results.get(3) + results.get(2) + results.get(1) + results.get(0);\n            results.add(next);\n            results.remove(0);\n        }\n\n        return results.get(3);\n    }\n}\n", "py_code": "def fib4(n: int):\n    results = [0, 0, 2, 0]\n    if n < 4:\n        return results[n]\n\n    for _ in range(4, n + 1):\n        results.append(results[-1] + results[-2] + results[-3] + results[-4])\n        results.pop(0)\n\n    return results[-1]\n", "py_summary": "The Python code defines a function `fib4` that efficiently computes the n-th element of the Fib4 number sequence without using recursion. It initializes a list `results` with the first four elements of the sequence `[0, 0, 2, 0]`. \n\nIf n is less than 4, the function directly returns the corresponding element from the `results` list. Otherwise, it iterates from 4 to n (inclusive) and calculates the next element in the sequence based on the formula `fib4(n) = fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)`. It updates the `results` list by appending the new element and removing the oldest element to maintain a window of 4 elements.\n\nFinally, the function returns the n-th element of the Fib4 sequence.\n\nThe code efficiently computes the n-th element of the Fib4 sequence in a non-recursive manner by using a sliding window approach to store and update the necessary elements."}
{"task_id": "Java/47", "generation": "import java.util.*;\n\nclass Solution {\n    public double median(List<Integer> l) {\n        Collections.sort(l);\n        int n = l.size();\n        if (n % 2 == 1) {\n            return l.get(n / 2);\n        } else {\n            return (l.get(n / 2 - 1) + l.get(n / 2)) / 2.0;\n        }\n    }\n}\n", "py_code": "def median(l: list):\n    l = sorted(l)\n    if len(l) % 2 == 1:\n        return l[len(l) // 2]\n    else:\n        return (l[len(l) // 2 - 1] + l[len(l) // 2]) / 2.0\n", "py_summary": "The Python code defines a function that calculates the median of a list of integers. The function first sorts the input list in ascending order. It then checks if the length of the list is odd or even. \n- If the length is odd, it returns the middle element of the sorted list as the median.\n- If the length is even, it calculates the average of the two middle elements and returns it as the median.\n\nThis approach ensures that the function correctly calculates the median for both odd and even-length lists."}
{"task_id": "Java/48", "generation": "import java.util.*;\n\nclass Solution {\n    public boolean is_palindrome(String text) {\n        for (int i = 0; i < text.length(); i++) {\n            if (text.charAt(i) != text.charAt(text.length() - 1 - i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n", "py_code": "def is_palindrome(text: str):\n    for i in range(len(text)):\n        if text[i] != text[len(text) - 1 - i]:\n            return False\n    return True\n", "py_summary": "The Python code defines a function that checks if a given string is a palindrome. It iterates through the characters of the string and compares the characters at symmetric positions from the start and end of the string. If at any point the characters do not match, the function returns False indicating that the string is not a palindrome. If the loop completes without finding any mismatch, the function returns True indicating that the string is a palindrome."}
{"task_id": "Java/49", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int modp(int n, int p) {\n        int ret = 1;\n        for (int i = 0; i < n; i++) {\n            ret = (2 * ret) % p;\n        }\n        return ret;\n    }\n}\n", "py_code": "def modp(n: int, p: int):\n    ret = 1\n    for i in range(n):\n        ret = (2 * ret) % p\n    return ret\n", "py_summary": "The Python code defines a function that calculates 2^n modulo p using a loop. It initializes a variable `ret` to 1 and then iterates from 0 to n-1. In each iteration, it updates `ret` by multiplying it by 2 and taking the modulo p of the result. Finally, it returns the calculated value of `ret`."}
{"task_id": "Java/50", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n    returns encoded string by shifting every character by 5 in the alphabet.\n     */\n    public String encodeShift(String s) {\n        StringBuilder sb = new StringBuilder();\n        for (char ch : s.toCharArray()) {\n            sb.append((char) ('a' + ((ch + 5 - 'a') % 26)));\n        }\n        return sb.toString();\n    }\n\n    /**\n    takes as input string encoded with encodeShift function. Returns decoded string.\n     */\n    public String decode_shift(String s) {\n        StringBuilder sb = new StringBuilder();\n        for (char ch : s.toCharArray()) {\n            sb.append((char) ('a' + ((ch - 5 - 'a' + 26) % 26)));\n        }\n        return sb.toString();\n    }\n}\n", "py_code": "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    return \"\".join([chr(((ord(ch) - 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n", "py_summary": "The Python code defines two functions, `encode_shift` and `decode_shift`, to encode and decode a string based on a simple Caesar cipher with a shift of 5 in the alphabet.\n\n1. `encode_shift` function:\n   - It takes a string `s` as input and encodes it by shifting every character by 5 in the alphabet.\n   - It iterates over each character in the input string, calculates the new character by shifting it by 5 positions in the alphabet, and appends the encoded character to the result.\n   - Finally, it returns the encoded string.\n\n2. `decode_shift` function:\n   - It takes an encoded string `s` as input and decodes it back to the original string.\n   - It iterates over each character in the encoded string, calculates the original character by shifting it back by 5 positions in the alphabet, and appends the decoded character to the result.\n   - Finally, it returns the decoded string.\n\nBoth functions use the ASCII values of characters to perform the encoding and decoding operations by applying the shift and ensuring the result stays within the range of lowercase alphabets.\n\nThe encoding and decoding logic is based on the circular nature of the alphabet, where shifting beyond 'z' wraps around to 'a'.\n\nNext, I will provide the Java solution based on this Python code and analysis."}
{"task_id": "Java/51", "generation": "import java.util.*;\n\nclass Solution {\n    public String remove_vowels(String text) {\n        StringBuilder result = new StringBuilder();\n        for (char c : text.toCharArray()) {\n            if (!\"aeiouAEIOU\".contains(String.valueOf(c))) {\n                result.append(c);\n            }\n        }\n        return result.toString();\n    }\n}\n", "py_code": "def remove_vowels(text):\n    return \"\".join([s for s in text if s.lower() not in [\"a\", \"e\", \"i\", \"o\", \"u\"]])\n", "py_summary": "The Python code defines a function `remove_vowels` that takes a string as input and returns a new string with all the vowels removed. It uses a list comprehension to iterate over each character in the input string. For each character, it checks if the lowercase version of the character is not in the list of vowels [\"a\", \"e\", \"i\", \"o\", \"u\"]. If the character is not a vowel, it is included in the new string. Finally, the function returns the new string without any vowels."}
{"task_id": "Java/52", "generation": "import java.util.*;\n\nclass Solution {\n    public boolean below_threshold(List<Integer> l, int t) {\n        for (int num : l) {\n            if (num >= t) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n", "py_code": "def below_threshold(l: list, t: int):\n    for e in l:\n        if e >= t:\n            return False\n    return True\n", "py_summary": "The Python code defines a function that takes a list of integers `l` and an integer threshold `t` as input. It iterates through each element in the list and checks if the element is greater than or equal to the threshold. If any element is found to be greater than or equal to the threshold, the function immediately returns `False`. If all elements are below the threshold, the function returns `True`."}
{"task_id": "Java/53", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int add(int x, int y) {\n        return x + y;\n    }\n}\n", "py_code": "def add(x: int, y: int):\n    return x + y\n", "py_summary": "The Python code defines a function that takes two integer inputs `x` and `y`, and returns the sum of the two numbers. The function simply adds the two input integers together and returns the result."}
{"task_id": "Java/54", "generation": "import java.util.*;\n\nclass Solution {\n    public boolean same_chars(String s0, String s1) {\n        Set<Character> set1 = new HashSet<>();\n        Set<Character> set2 = new HashSet<>();\n        \n        for (char c : s0.toCharArray()) {\n            set1.add(c);\n        }\n        \n        for (char c : s1.toCharArray()) {\n            set2.add(c);\n        }\n        \n        return set1.equals(set2);\n    }\n}\n", "py_code": "def same_chars(s0: str, s1: str):\n    return set(s0) == set(s1)\n", "py_summary": "The Python code defines a function `same_chars` that takes two strings as input and checks if the two strings have the same set of characters. It does this by converting each string into a set of characters and then comparing the sets for equality. If the sets are equal, it means both strings have the same characters, otherwise they do not. The function returns a boolean value indicating whether the two strings have the same characters or not."}
{"task_id": "Java/55", "generation": "import java.util.*;\n\nclass Solution {\n    public int fib(int n) {\n        if (n == 0) {\n            return 0;\n        }\n        if (n == 1) {\n            return 1;\n        }\n        return fib(n - 1) + fib(n - 2);\n    }\n}\n", "py_code": "def fib(n: int):\n    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    return fib(n - 1) + fib(n - 2)\n", "py_summary": "The Python code defines a recursive function `fib` that calculates the n-th Fibonacci number. If n is 0, the function returns 0. If n is 1, the function returns 1. For any other value of n, the function recursively calls itself with n-1 and n-2, then returns the sum of the results of those recursive calls. This approach follows the definition of the Fibonacci sequence where each number is the sum of the two preceding ones."}
{"task_id": "Java/56", "generation": "import java.util.*;\n\nclass Solution {\n    public boolean correct_bracketing(String brackets) {\n        int depth = 0;\n        for (char b : brackets.toCharArray()) {\n            if (b == '<') {\n                depth++;\n            } else {\n                depth--;\n            }\n            if (depth < 0) {\n                return false;\n            }\n        }\n        return depth == 0;\n    }\n}\n", "py_code": "def correct_bracketing(brackets: str):\n    depth = 0\n    for b in brackets:\n        if b == \"<\":\n            depth += 1\n        else:\n            depth -= 1\n        if depth < 0:\n            return False\n    return depth == 0\n", "py_summary": "The Python code defines a function `correct_bracketing` that takes a string of brackets as input and checks if the bracketing is correct. It uses a variable `depth` to keep track of the balance between opening and closing brackets. The function iterates through each character in the input string, incrementing the `depth` when an opening bracket `<` is encountered and decrementing it when a closing bracket `>` is encountered. \n\nIf at any point the `depth` becomes negative, it means there are more closing brackets than opening brackets, and the function returns `False` immediately. Finally, the function checks if the `depth` is back to zero at the end of the string to ensure that all opening brackets have corresponding closing brackets. If so, it returns `True`, otherwise `False`."}
{"task_id": "Java/57", "generation": "import java.util.*;\n\nclass Solution {\n    public boolean monotonic(List<Integer> l) {\n        List<Integer> increasing = new ArrayList<>(l);\n        List<Integer> decreasing = new ArrayList<>(l);\n        Collections.sort(increasing);\n        Collections.sort(decreasing, Collections.reverseOrder());\n        \n        if (l.equals(increasing) || l.equals(decreasing)) {\n            return true;\n        }\n        return false;\n    }\n}\n", "py_code": "def monotonic(l: list):\n    if l == sorted(l) or l == sorted(l, reverse=True):\n        return True\n    return False\n", "py_summary": "The Python code defines a function that takes a list of integers as input and checks if the list elements are either monotonically increasing or decreasing. It does this by comparing the input list with its sorted version in ascending order and descending order. If the input list is equal to either of the sorted versions, it returns True, indicating that the list is monotonically increasing or decreasing. Otherwise, it returns False."}
{"task_id": "Java/58", "generation": "import java.util.*;\n\nclass Solution {\n    public List<Integer> common(List<Integer> l1, List<Integer> l2) {\n        Set<Integer> set = new HashSet<>();\n        List<Integer> result = new ArrayList<>();\n        \n        for (Integer e1 : l1) {\n            for (Integer e2 : l2) {\n                if (e1.equals(e2)) {\n                    set.add(e1);\n                }\n            }\n        }\n        \n        result.addAll(set);\n        Collections.sort(result);\n        \n        return result;\n    }\n}\n", "py_code": "def common(l1: list, l2: list):\n    ret = set()\n    for e1 in l1:\n        for e2 in l2:\n            if e1 == e2:\n                ret.add(e1)\n    return sorted(list(ret))\n", "py_summary": "The Python code defines a function that takes two lists of integers as input and returns a list of sorted unique common elements between the two input lists. It initializes an empty set `ret` to store the common elements. Then, it iterates through each element in the first list and compares it with each element in the second list. If there is a match, the common element is added to the set `ret`. Finally, the function converts the set to a list, sorts it, and returns the list of common elements."}
{"task_id": "Java/59", "generation": "import java.util.*;\n\nclass Solution {\n    public int largest_prime_factor(int n) {\n        int largest = 1;\n        for (int j = 2; j <= n; j++) {\n            if (n % j == 0 && isPrime(j)) {\n                largest = Math.max(largest, j);\n            }\n        }\n        return largest;\n    }\n\n    private boolean isPrime(int k) {\n        if (k < 2) {\n            return false;\n        }\n        for (int i = 2; i < k; i++) {\n            if (k % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n", "py_code": "def largest_prime_factor(n: int):\n    def is_prime(k):\n        if k < 2:\n            return False\n        for i in range(2, k - 1):\n            if k % i == 0:\n                return False\n        return True\n    largest = 1\n    for j in range(2, n + 1):\n        if n % j == 0 and is_prime(j):\n            largest = max(largest, j)\n    return largest\n", "py_summary": "The Python code defines a function `largest_prime_factor` that takes an integer `n` as input and returns the largest prime factor of `n`. The function first defines a helper function `is_prime` to check if a number is prime. It iterates through numbers from 2 to the input number - 1 and returns True if the number is prime, otherwise False.\n\nThe main function initializes a variable `largest` to 1. It then iterates through numbers from 2 to `n` and checks if the number is a factor of `n` and if it is prime. If both conditions are met, it updates the `largest` variable to the maximum of the current `largest` and the prime factor found.\n\nFinally, the function returns the largest prime factor of `n`."}
{"task_id": "Java/60", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int sum_to_n(int n) {\n        return n * (n + 1) / 2;\n    }\n}\n", "py_code": "def sum_to_n(n: int):\n    return sum(range(n + 1))\n", "py_summary": "The Python code defines a function `sum_to_n` that takes an integer `n` as input and calculates the sum of numbers from 1 to `n` inclusive using the `sum` function and `range` function. It returns the sum as the output."}
{"task_id": "Java/61", "generation": "import java.util.*;\n\nclass Solution {\n    public boolean correct_bracketing(String brackets) {\n        int depth = 0;\n        for (char b : brackets.toCharArray()) {\n            if (b == '(') {\n                depth++;\n            } else {\n                depth--;\n            }\n            if (depth < 0) {\n                return false;\n            }\n        }\n        return depth == 0;\n    }\n}\n", "py_code": "def correct_bracketing(brackets: str):\n    depth = 0\n    for b in brackets:\n        if b == \"(\":\n            depth += 1\n        else:\n            depth -= 1\n        if depth < 0:\n            return False\n    return depth == 0\n", "py_summary": "The Python code defines a function `correct_bracketing` that takes a string of brackets as input and checks if the brackets are correctly balanced. It uses a variable `depth` to keep track of the balance of brackets. The function iterates through each character in the input string. If an opening bracket \"(\" is encountered, the depth is incremented by 1. If a closing bracket \")\" is encountered, the depth is decremented by 1. \n\nIf at any point the depth becomes negative, it means there are more closing brackets than opening brackets, and the function returns False. Finally, the function checks if the final depth is 0, which indicates that all opening brackets have a corresponding closing bracket, and returns True in that case."}
{"task_id": "Java/62", "generation": "import java.util.*;\n\nclass Solution {\n    public List<Integer> derivative(List<Integer> xs) {\n        List<Integer> result = new ArrayList<>();\n        for (int i = 1; i < xs.size(); i++) {\n            result.add(i * xs.get(i));\n        }\n        return result;\n    }\n}\n", "py_code": "def derivative(xs: list):\n    return [(i * x) for i, x in enumerate(xs)][1:]\n", "py_summary": "The Python code defines a function that takes a list of integers representing the coefficients of a polynomial as input and returns the derivative of the polynomial in the same form. It uses list comprehension to iterate over the coefficients and their indices, multiplying each coefficient by its corresponding index to calculate the derivative. Finally, it returns the derivative coefficients starting from the index 1 (as the derivative of a constant term is 0)."}
{"task_id": "Java/63", "generation": "import java.util.*;\n\nclass Solution {\n    public int fibfib(int n) {\n        if (n == 0) {\n            return 0;\n        }\n        if (n == 1) {\n            return 0;\n        }\n        if (n == 2) {\n            return 1;\n        }\n        int[] fibfib = new int[n + 1];\n        fibfib[0] = 0;\n        fibfib[1] = 0;\n        fibfib[2] = 1;\n        for (int i = 3; i <= n; i++) {\n            fibfib[i] = fibfib[i - 1] + fibfib[i - 2] + fibfib[i - 3];\n        }\n        return fibfib[n];\n    }\n}\n", "py_code": "def fibfib(n: int):\n    if n == 0:\n        return 0\n    if n == 1:\n        return 0\n    if n == 2:\n        return 1\n    return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)\n", "py_summary": "The Python code defines a recursive function `fibfib` that calculates the n-th element of the FibFib number sequence. The base cases are defined for n equal to 0, 1, and 2. For any other value of n, the function recursively calculates the n-th element using the formula `fibfib(n) = fibfib(n-1) + fibfib(n-2) + fibfib(n-3)`.\n\nThe function recursively calls itself with n-1, n-2, and n-3 until it reaches one of the base cases. This approach is not efficient for large values of n as it recalculates the same values multiple times."}
{"task_id": "Java/64", "generation": "import java.util.*;\n\nclass Solution {\n    public int vowels_count(String s) {\n        String vowels = \"aeiouAEIOU\";\n        int n_vowels = 0;\n        for (char c : s.toCharArray()) {\n            if (vowels.contains(String.valueOf(c))) {\n                n_vowels++;\n            }\n        }\n        if (s.endsWith(\"y\") || s.endsWith(\"Y\")) {\n            n_vowels++;\n        }\n        return n_vowels;\n    }\n}\n", "py_code": "FIX = \"\"\"\nAdd more test cases.\n\"\"\"\n\ndef vowels_count(s):\n    vowels = \"aeiouAEIOU\"\n    n_vowels = sum(c in vowels for c in s)\n    if s[-1] == 'y' or s[-1] == 'Y':\n        n_vowels += 1\n    return n_vowels\n", "py_summary": "The Python code defines a function `vowels_count` that takes a string `s` as input and returns the number of vowels in the string. Vowels considered are 'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'. Additionally, 'y' or 'Y' is considered a vowel only when it is at the end of the word. \n\nThe function initializes a variable `vowels` with all the vowels and their uppercase versions. It then calculates the number of vowels in the string by counting the occurrences of characters present in the `vowels` string. If the last character of the string is 'y' or 'Y', it increments the vowel count by 1. Finally, it returns the total count of vowels in the string."}
{"task_id": "Java/65", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public String circular_shift(int x, int shift) {\n        String s = String.valueOf(x);\n        if (shift > s.length()) {\n            return new StringBuilder(s).reverse().toString();\n        } else {\n            return s.substring(s.length() - shift) + s.substring(0, s.length() - shift);\n        }\n    }\n}\n", "py_code": "def circular_shift(x, shift):\n    s = str(x)\n    if shift > len(s):\n        return s[::-1]\n    else:\n        return s[len(s) - shift:] + s[:len(s) - shift]\n", "py_summary": "The Python code defines a function `circular_shift` that takes an integer `x` and an integer `shift` as input and returns a string representing the circularly shifted digits of `x`. The function first converts the integer `x` to a string `s`. \n\nIf the `shift` value is greater than the length of the string `s`, the function returns the reverse of the string `s` since shifting by more than the number of digits is equivalent to reversing the digits.\n\nIf the `shift` value is within the length of the string `s`, the function calculates the circular shift by concatenating the right shifted part and the left shifted part of the string based on the `shift` value."}
{"task_id": "Java/66", "generation": "import java.util.*;\n\nclass Solution {\n    public int digitSum(String s) {\n        if (s.isEmpty()) {\n            return 0;\n        }\n        int sum = 0;\n        for (char c : s.toCharArray()) {\n            if (Character.isUpperCase(c)) {\n                sum += (int) c;\n            }\n        }\n        return sum;\n    }\n}\n", "py_code": "def digitSum(s):\n    if s == \"\": return 0\n    return sum(ord(char) if char.isupper() else 0 for char in s)\n", "py_summary": "The Python code defines a function `digitSum` that takes a string `s` as input and calculates the sum of ASCII values of uppercase characters in the string. If the input string is empty, the function returns 0. Otherwise, it iterates over each character in the string and adds the ASCII value of the character to the sum only if the character is uppercase. Finally, the function returns the total sum of ASCII values of uppercase characters in the string."}
{"task_id": "Java/67", "generation": "import java.util.*;\n\nclass Solution {\n    public int fruit_distribution(String s, int n) {\n        List<Integer> numbers = new ArrayList<>();\n        for (String str : s.split(\" \")) {\n            if (str.matches(\"\\\\d+\")) {\n                numbers.add(Integer.parseInt(str));\n            }\n        }\n        \n        int sum = 0;\n        for (int num : numbers) {\n            sum += num;\n        }\n        \n        return n - sum;\n    }\n}\n", "py_code": "def fruit_distribution(s,n):\n    lis = list()\n    for i in s.split(' '):\n        if i.isdigit():\n            lis.append(int(i))\n    return n - sum(lis)\n", "py_summary": "The Python code defines a function `fruit_distribution` that takes a string `s` representing the number of apples and oranges in a basket and an integer `n` representing the total number of fruits in the basket. The function first splits the input string `s` based on spaces and extracts the integer values representing the number of apples and oranges. It then calculates the number of mango fruits in the basket by subtracting the sum of the extracted apple and orange counts from the total fruit count `n`. Finally, it returns the number of mango fruits."}
{"task_id": "Java/68", "generation": "import java.util.*;\n\nclass Solution {\n    public List<Integer> pluck(List<Integer> arr) {\n        List<Integer> result = new ArrayList<>();\n        if (arr.isEmpty()) {\n            return result;\n        }\n\n        List<Integer> evens = new ArrayList<>();\n        for (int num : arr) {\n            if (num % 2 == 0) {\n                evens.add(num);\n            }\n        }\n\n        if (evens.isEmpty()) {\n            return result;\n        }\n\n        int minEven = Collections.min(evens);\n        int index = arr.indexOf(minEven);\n\n        result.add(minEven);\n        result.add(index);\n\n        return result;\n    }\n}\n", "py_code": "def pluck(arr):\n    if(len(arr) == 0): return []\n    evens = list(filter(lambda x: x%2 == 0, arr))\n    if(evens == []): return []\n    return [min(evens), arr.index(min(evens))]\n", "py_summary": "The Python code defines a function that takes a list of integers representing nodes in a tree branch as input and returns the node with the smallest even value along with its index. If there are multiple nodes with the same smallest even value, the node with the smallest index is returned. If there are no even values in the list or the list is empty, an empty list is returned.\n\nThe function first checks if the input list is empty, in which case it returns an empty list. It then filters out the even numbers from the input list and stores them in the `evens` list. If there are no even numbers in the list, an empty list is returned. Otherwise, it returns a list containing the smallest even value and its index in the original list."}
{"task_id": "Java/69", "generation": "import java.util.*;\n\nclass Solution {\n    public int search(List<Integer> lst) {\n        int maxVal = Collections.max(lst);\n        int[] frq = new int[maxVal + 1];\n        \n        for (int i : lst) {\n            frq[i]++;\n        }\n\n        int ans = -1;\n        for (int i = 1; i < frq.length; i++) {\n            if (frq[i] >= i) {\n                ans = i;\n            }\n        }\n        \n        return ans;\n    }\n}\n", "py_code": "def search(lst):\n    frq = [0] * (max(lst) + 1)\n    for i in lst:\n        frq[i] += 1;\n\n    ans = -1\n    for i in range(1, len(frq)):\n        if frq[i] >= i:\n            ans = i\n    \n    return ans\n", "py_summary": "The Python code defines a function that takes a list of positive integers as input and returns the greatest integer that has a frequency greater than or equal to the value of the integer itself. The function first creates a frequency list `frq` to store the frequency of each integer in the input list. It then iterates through the input list and updates the frequency count in the `frq` list.\n\nAfter calculating the frequency of each integer, the function iterates through the frequency list starting from 1. For each frequency value, it checks if the frequency is greater than or equal to the value itself. If this condition is met, it updates the answer `ans` to the current value. Finally, the function returns the greatest integer that satisfies the frequency condition or -1 if no such value exists."}
{"task_id": "Java/70", "generation": "import java.util.*;\n\nclass Solution {\n    public List<Integer> strange_sort_list(List<Integer> lst) {\n        List<Integer> res = new ArrayList<>();\n        boolean switchVal = true;\n        \n        while (!lst.isEmpty()) {\n            if (switchVal) {\n                int minVal = Collections.min(lst);\n                res.add(minVal);\n                lst.remove(Integer.valueOf(minVal));\n            } else {\n                int maxVal = Collections.max(lst);\n                res.add(maxVal);\n                lst.remove(Integer.valueOf(maxVal));\n            }\n            switchVal = !switchVal;\n        }\n        \n        return res;\n    }\n}\n", "py_code": "def strange_sort_list(lst):\n    res, switch = [], True\n    while lst:\n        res.append(min(lst) if switch else max(lst))\n        lst.remove(res[-1])\n        switch = not switch\n    return res\n", "py_summary": "The Python code defines a function that performs a strange sorting on a list of integers. The function iterates through the input list while it is not empty. It alternates between selecting the minimum value from the remaining list and the maximum value. The selected value is then removed from the list, and the process continues until all elements are processed. The function returns the list in the strange order as described in the problem statement."}
{"task_id": "Java/71", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public double triangle_area(double a, double b, double c) {\n        if (a + b <= c || a + c <= b || b + c <= a) {\n            return -1;\n        }\n        double s = (a + b + c) / 2;\n        double area = Math.sqrt(s * (s - a) * (s - b) * (s - c));\n        area = Math.round(area * 100.0) / 100.0;\n        return area;\n    }\n}\n", "py_code": "def triangle_area(a, b, c):\n    if a + b <= c or a + c <= b or b + c <= a:\n        return -1 \n    s = (a + b + c)/2    \n    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5\n    area = round(area, 2)\n    return area\n", "py_summary": "The Python code defines a function `triangle_area` that calculates the area of a triangle given the lengths of its three sides. It first checks if the three sides can form a valid triangle by verifying the triangle inequality theorem: the sum of the lengths of any two sides of a triangle must be greater than the length of the third side. If the sides cannot form a valid triangle, the function returns -1.\n\nIf the sides form a valid triangle, the function calculates the semi-perimeter (s) of the triangle using the formula s = (a + b + c) / 2. Then, it calculates the area of the triangle using Heron's formula: area = sqrt(s * (s - a) * (s - b) * (s - c)), where sqrt represents the square root function. The area is then rounded to 2 decimal points using the `round` function before being returned."}
{"task_id": "Java/72", "generation": "import java.util.*;\n\nclass Solution {\n    public boolean will_it_fly(List<Integer> q, int w) {\n        if (q.stream().mapToInt(Integer::intValue).sum() > w) {\n            return false;\n        }\n\n        int i = 0;\n        int j = q.size() - 1;\n        while (i < j) {\n            if (!q.get(i).equals(q.get(j))) {\n                return false;\n            }\n            i++;\n            j--;\n        }\n        return true;\n    }\n}\n", "py_code": "def will_it_fly(q,w):\n    if sum(q) > w:\n        return False\n\n    i, j = 0, len(q)-1\n    while i<j:\n        if q[i] != q[j]:\n            return False\n        i+=1\n        j-=1\n    return True\n", "py_summary": "The Python code defines a function that takes a list of integers `q` and an integer `w` as input and returns `True` if the list is balanced (palindromic) and the sum of its elements is less than or equal to the maximum weight `w`. \n\nThe function first checks if the sum of the elements in the list `q` is greater than the maximum weight `w`. If it is, the function immediately returns `False`. \n\nNext, the function initializes two pointers `i` and `j` at the start and end of the list respectively. It then iterates through the list from both ends towards the center, checking if the elements at symmetric positions are equal. If at any point they are not equal, the function returns `False`. If the loop completes without finding any unequal elements, the function returns `True`, indicating that the list is balanced and the sum of its elements is within the weight limit."}
{"task_id": "Java/73", "generation": "import java.util.*;\n\nclass Solution {\n    public int smallest_change(List<Integer> arr) {\n        int ans = 0;\n        for (int i = 0; i < arr.size() / 2; i++) {\n            if (!arr.get(i).equals(arr.get(arr.size() - i - 1))) {\n                ans++;\n            }\n        }\n        return ans;\n    }\n}\n", "py_code": "def smallest_change(arr):\n    ans = 0\n    for i in range(len(arr) // 2):\n        if arr[i] != arr[len(arr) - i - 1]:\n            ans += 1\n    return ans\n", "py_summary": "The Python code defines a function that takes a list of integers as input and calculates the minimum number of elements that need to be changed to make the array palindromic. The function iterates through the array up to its midpoint and compares elements at symmetric positions. If the elements are not equal, it increments a counter `ans` by 1. Finally, the function returns the total count of changes needed to make the array palindromic."}
{"task_id": "Java/74", "generation": "import java.util.*;\n\nclass Solution {\n    public List<String> total_match(List<String> lst1, List<String> lst2) {\n        int l1 = 0;\n        for (String st : lst1) {\n            l1 += st.length();\n        }\n\n        int l2 = 0;\n        for (String st : lst2) {\n            l2 += st.length();\n        }\n\n        if (l1 <= l2) {\n            return lst1;\n        } else {\n            return lst2;\n        }\n    }\n}\n", "py_code": "def total_match(lst1, lst2):\n    l1 = 0\n    for st in lst1:\n        l1 += len(st)\n    \n    l2 = 0\n    for st in lst2:\n        l2 += len(st)\n    \n    if l1 <= l2:\n        return lst1\n    else:\n        return lst2\n", "py_summary": "The Python code defines a function that takes two lists of strings as input and compares the total number of characters in all strings of each list. It calculates the total number of characters in each list by iterating through the strings and summing up their lengths. Then, it compares the total character counts of the two lists. If the total character count of the first list is less than or equal to the total character count of the second list, it returns the first list. Otherwise, it returns the second list."}
{"task_id": "Java/75", "generation": "import java.util.*;\n\nclass Solution {\n    public boolean is_multiply_prime(int a) {\n        boolean[] isPrime = new boolean[101];\n        Arrays.fill(isPrime, true);\n        for (int i = 2; i <= 100; i++) {\n            if (isPrime[i]) {\n                for (int j = i * i; j <= 100; j += i) {\n                    isPrime[j] = false;\n                }\n            }\n        }\n\n        for (int i = 2; i <= 100; i++) {\n            if (!isPrime[i]) continue;\n            for (int j = 2; j <= 100; j++) {\n                if (!isPrime[j]) continue;\n                for (int k = 2; k <= 100; k++) {\n                    if (!isPrime[k]) continue;\n                    if (i * j * k == a) return true;\n                }\n            }\n        }\n        return false;\n    }\n}\n", "py_code": "def is_multiply_prime(a):\n    def is_prime(n):\n        for j in range(2,n):\n            if n%j == 0:\n                return False\n        return True\n\n    for i in range(2,101):\n        if not is_prime(i): continue\n        for j in range(2,101):\n            if not is_prime(j): continue\n            for k in range(2,101):\n                if not is_prime(k): continue\n                if i*j*k == a: return True\n    return False\n", "py_summary": "The Python code defines a function `is_multiply_prime(a)` that takes an integer `a` as input and checks if `a` can be expressed as the multiplication of 3 prime numbers less than 100. \n\n1. The code defines a helper function `is_prime(n)` to check if a number `n` is prime by iterating from 2 to `n` and checking if there is any number that divides `n` evenly.\n2. It then iterates through all prime numbers less than 100 (using the `is_prime` function) for three numbers `i`, `j`, and `k`. \n3. It checks if the product of these three prime numbers is equal to the input number `a`. If it finds such a combination, it returns `True`, indicating that `a` is the multiplication of 3 prime numbers. If no such combination is found, it returns `False`."}
{"task_id": "Java/76", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public boolean is_simple_power(int x, int n) {\n        if (n == 1) {\n            return x == 1;\n        }\n        int power = 1;\n        while (power < x) {\n            power = power * n;\n        }\n        return power == x;\n    }\n}\n", "py_code": "def is_simple_power(x, n):\n    if (n == 1): \n        return (x == 1) \n    power = 1\n    while (power < x): \n        power = power * n \n    return (power == x) \n", "py_summary": "The Python code defines a function that checks if a given number x is a simple power of another number n. A number x is considered a simple power of n if n raised to an integer power equals x. \n\nThe function first handles a special case where n is 1 and x is 1, in which case it returns True. Otherwise, it initializes a variable `power` to 1 and iteratively multiplies `power` by n until it exceeds x. If the final value of `power` is equal to x, then x is a simple power of n, and the function returns True; otherwise, it returns False."}
{"task_id": "Java/77", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public boolean iscube(int a) {\n        a = Math.abs(a);\n        int cubeRoot = (int) Math.round(Math.pow(a, 1.0 / 3));\n        return cubeRoot * cubeRoot * cubeRoot == a;\n    }\n}\n", "py_code": "def iscube(a):\n    a = abs(a)\n    return int(round(a ** (1. / 3))) ** 3 == a\n", "py_summary": "The Python code defines a function that takes an integer `a` as input and returns `True` if the integer is a cube of some integer number. The function first takes the absolute value of `a` to handle negative numbers. It then calculates the cube root of the absolute value of `a` using the formula `a ** (1. / 3)`. \n\nThe function then rounds the calculated cube root to the nearest integer using the `round()` function and raises it to the power of 3. If the result is equal to the original absolute value of `a`, then `a` is a cube of some integer number, and the function returns `True`. Otherwise, it returns `False`."}
{"task_id": "Java/78", "generation": "import java.util.*;\n\nclass Solution {\n    public int hex_key(String num) {\n        char[] primes = {'2', '3', '5', '7', 'B', 'D'};\n        int total = 0;\n        for (int i = 0; i < num.length(); i++) {\n            if (new String(primes).indexOf(num.charAt(i)) != -1) {\n                total++;\n            }\n        }\n        return total;\n    }\n}\n", "py_code": "def hex_key(num):\n    primes = ('2', '3', '5', '7', 'B', 'D')\n    total = 0\n    for i in range(0, len(num)):\n        if num[i] in primes:\n            total += 1\n    return total\n", "py_summary": "The Python code defines a function `hex_key` that takes a hexadecimal number as a string input and counts the number of hexadecimal digits that are prime numbers. It initializes a tuple `primes` containing the prime hexadecimal digits ('2', '3', '5', '7', 'B', 'D'). \n\nThe function then iterates through each character in the input string and checks if the character is a prime hexadecimal digit by comparing it with the elements in the `primes` tuple. If the character is found in the `primes` tuple, the count `total` is incremented. Finally, the function returns the total count of prime hexadecimal digits found in the input string."}
{"task_id": "Java/79", "generation": "import java.util.*;\n\nclass Solution {\n    public String decimal_to_binary(int decimal) {\n        String binary = Integer.toBinaryString(decimal);\n        return \"db\" + binary + \"db\";\n    }\n}\n", "py_code": "def decimal_to_binary(decimal):\n    return \"db\" + bin(decimal)[2:] + \"db\"\n", "py_summary": "The Python code defines a function that takes an integer in decimal form as input and converts it to binary format. The function uses the built-in `bin()` function to convert the decimal number to binary representation. It then concatenates the binary string with the prefix \"db\" and suffix \"db\" to match the required format. Finally, it returns the formatted binary string."}
{"task_id": "Java/80", "generation": "import java.util.*;\n\nclass Solution {\n    public boolean is_happy(String s) {\n        if (s.length() < 3) {\n            return false;\n        }\n\n        for (int i = 0; i < s.length() - 2; i++) {\n            if (s.charAt(i) == s.charAt(i + 1) || s.charAt(i + 1) == s.charAt(i + 2) || s.charAt(i) == s.charAt(i + 2)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n", "py_code": "def is_happy(s):\n    if len(s) < 3:\n      return False\n\n    for i in range(len(s) - 2):\n      \n      if s[i] == s[i+1] or s[i+1] == s[i+2] or s[i] == s[i+2]:\n        return False\n    return True\n", "py_summary": "The Python code defines a function that takes a string as input and checks if the string is happy or not. A string is considered happy if its length is at least 3 and every 3 consecutive letters are distinct. The function iterates through the string and checks every 3 consecutive characters. If any two characters are the same within the 3 consecutive characters, the function returns False indicating that the string is not happy. If all 3 consecutive characters are distinct, the function returns True indicating that the string is happy."}
{"task_id": "Java/81", "generation": "import java.util.*;\n\nclass Solution {\n    public List<String> numerical_letter_grade(List<Double> grades) {\n        List<String> letterGrades = new ArrayList<>();\n        for (Double gpa : grades) {\n            if (gpa == 4.0) {\n                letterGrades.add(\"A+\");\n            } else if (gpa > 3.7) {\n                letterGrades.add(\"A\");\n            } else if (gpa > 3.3) {\n                letterGrades.add(\"A-\");\n            } else if (gpa > 3.0) {\n                letterGrades.add(\"B+\");\n            } else if (gpa > 2.7) {\n                letterGrades.add(\"B\");\n            } else if (gpa > 2.3) {\n                letterGrades.add(\"B-\");\n            } else if (gpa > 2.0) {\n                letterGrades.add(\"C+\");\n            } else if (gpa > 1.7) {\n                letterGrades.add(\"C\");\n            } else if (gpa > 1.3) {\n                letterGrades.add(\"C-\");\n            } else if (gpa > 1.0) {\n                letterGrades.add(\"D+\");\n            } else if (gpa > 0.7) {\n                letterGrades.add(\"D\");\n            } else if (gpa > 0.0) {\n                letterGrades.add(\"D-\");\n            } else {\n                letterGrades.add(\"E\");\n            }\n        }\n        return letterGrades;\n    }\n}\n", "py_code": "def numerical_letter_grade(grades):\n\n   \n    letter_grade = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grade.append(\"A+\")\n        elif gpa > 3.7:\n            letter_grade.append(\"A\")\n        elif gpa > 3.3:\n            letter_grade.append(\"A-\")\n        elif gpa > 3.0:\n            letter_grade.append(\"B+\")\n        elif gpa > 2.7:\n            letter_grade.append(\"B\")\n        elif gpa > 2.3:\n            letter_grade.append(\"B-\")\n        elif gpa > 2.0:\n            letter_grade.append(\"C+\")\n        elif gpa > 1.7:\n            letter_grade.append(\"C\")\n        elif gpa > 1.3:\n            letter_grade.append(\"C-\")\n        elif gpa > 1.0:\n            letter_grade.append(\"D+\")\n        elif gpa > 0.7:\n            letter_grade.append(\"D\")\n        elif gpa > 0.0:\n            letter_grade.append(\"D-\")\n        else:\n            letter_grade.append(\"E\")\n    return letter_grade\n", "py_summary": "The Python code defines a function `numerical_letter_grade` that takes a list of GPAs as input and returns a list of corresponding letter grades based on the provided grading table. It iterates through each GPA in the input list and assigns the appropriate letter grade based on the GPA value according to the given criteria. The function then appends the determined letter grade to a new list and finally returns the list of letter grades corresponding to the input GPAs."}
{"task_id": "Java/82", "generation": "import java.util.*;\n\nclass Solution {\n    public boolean prime_length(String string) {\n        int length = string.length();\n        if (length == 0 || length == 1) {\n            return false;\n        }\n        for (int i = 2; i < length; i++) {\n            if (length % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n", "py_code": "def prime_length(string):\n    l = len(string)\n    if l == 0 or l == 1:\n        return False\n    for i in range(2, l):\n        if l % i == 0:\n            return False\n    return True\n", "py_summary": "The Python code defines a function `prime_length` that takes a string as input and returns `True` if the length of the string is a prime number, and `False` otherwise. It calculates the length of the input string and checks if the length is 0 or 1, in which case it returns `False` as 0 and 1 are not prime numbers. \n\nThen, it iterates from 2 to the length of the string - 1 and checks if the length is divisible by any number in that range. If it finds a divisor, it returns `False` as the length is not a prime number. If no divisor is found, it returns `True` indicating that the length is a prime number."}
{"task_id": "Java/83", "generation": "import java.util.*;\n\nclass Solution {\n    public int starts_one_ends(int n) {\n        if (n == 1) {\n            return 1;\n        }\n        return 18 * (int) Math.pow(10, n - 2);\n    }\n}\n", "py_code": "def starts_one_ends(n):\n    if n == 1: return 1\n    return 18 * (10 ** (n - 2))\n", "py_summary": "The Python code defines a function that takes a positive integer `n` as input and returns the count of `n`-digit positive integers that start or end with 1. If `n` is equal to 1, there is only one number (1-digit) that starts or ends with 1. For `n > 1`, the function calculates the count using the formula `18 * (10 ** (n - 2))`. This formula represents the count of numbers that start or end with 1 for `n`-digit positive integers, excluding the case where the number is a single digit."}
{"task_id": "Java/84", "generation": "import java.util.*;\n\nclass Solution {\n    public String solve(int N) {\n        int sum = 0;\n        int num = N;\n        while (num > 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n        return Integer.toBinaryString(sum);\n    }\n}\n", "py_code": "def solve(N):\n    return bin(sum(int(i) for i in str(N)))[2:]\n", "py_summary": "The Python code defines a function that takes a positive integer `N` as input and returns the sum of its digits in binary form. The function first converts the integer `N` to a string to iterate over each digit. It then converts each digit back to an integer, sums them up, and converts the sum to a binary representation using the `bin()` function. Finally, it returns the binary representation of the sum without the prefix '0b'."}
{"task_id": "Java/85", "generation": "import java.util.*;\n\nclass Solution {\n    public int add(List<Integer> lst) {\n        int sum = 0;\n        for (int i = 1; i < lst.size(); i += 2) {\n            if (lst.get(i) % 2 == 0) {\n                sum += lst.get(i);\n            }\n        }\n        return sum;\n    }\n}\n", "py_code": "def add(lst):\n    return sum([lst[i] for i in range(1, len(lst), 2) if lst[i]%2 == 0])\n", "py_summary": "The Python code defines a function that takes a list of integers as input and returns the sum of even elements that are at odd indices in the list. It uses list comprehension to iterate over the elements at odd indices (starting from index 1) and checks if the element is even. If the element is even, it adds it to a list. Finally, it returns the sum of all the even elements at odd indices."}
{"task_id": "Java/86", "generation": "import java.util.*;\n\nclass Solution {\n    public String anti_shuffle(String s) {\n        String[] words = s.split(\" \");\n        StringBuilder result = new StringBuilder();\n        \n        for (String word : words) {\n            char[] chars = word.toCharArray();\n            Arrays.sort(chars);\n            result.append(chars).append(\" \");\n        }\n        \n        return result.toString().trim();\n    }\n}\n", "py_code": "def anti_shuffle(s):\n    return ' '.join([''.join(sorted(list(i))) for i in s.split(' ')])\n", "py_summary": "The Python code defines a function `anti_shuffle` that takes a string as input and returns an ordered version of the string. The function splits the input string into words based on spaces, then sorts the characters of each word in ascending order based on their ASCII values. Finally, it joins the sorted characters back together to form the ordered version of the word. The function then joins all the ordered words with spaces to reconstruct the ordered version of the original string."}
{"task_id": "Java/87", "generation": "import java.util.*;\n\nclass Solution {\n    public List<List<Integer>> get_row(List<List<Integer>> lst, int x) {\n        List<List<Integer>> result = new ArrayList<>();\n        for (int i = 0; i < lst.size(); i++) {\n            for (int j = 0; j < lst.get(i).size(); j++) {\n                if (lst.get(i).get(j) == x) {\n                    List<Integer> coord = new ArrayList<>();\n                    coord.add(i);\n                    coord.add(j);\n                    result.add(coord);\n                }\n            }\n        }\n        \n        result.sort((a, b) -> {\n            if (a.get(0).equals(b.get(0))) {\n                return b.get(1) - a.get(1);\n            }\n            return a.get(0) - b.get(0);\n        });\n        \n        return result;\n    }\n}\n", "py_code": "def get_row(lst, x):\n    coords = [(i, j) for i in range(len(lst)) for j in range(len(lst[i])) if lst[i][j] == x]\n    return sorted(sorted(coords, key=lambda x: x[1], reverse=True), key=lambda x: x[0])\n", "py_summary": "The Python code defines a function `get_row` that takes a nested list `lst` and an integer `x` as input. It iterates through the nested list to find all occurrences of the integer `x` and creates a list of coordinates (row, column) for each occurrence. The coordinates are sorted initially by rows in ascending order and then by columns in descending order. Finally, the function returns the sorted list of coordinates.\n\n1. It creates a list of coordinates `(i, j)` for each occurrence of `x` in the nested list using list comprehension.\n2. It sorts the coordinates first by columns in descending order using `sorted(..., key=lambda x: x[1], reverse=True)`.\n3. It then sorts the sorted coordinates by rows in ascending order using `sorted(..., key=lambda x: x[0])`.\n4. Finally, it returns the sorted list of coordinates.\n\nThe function effectively finds all occurrences of the integer `x` in the nested list, sorts the coordinates by rows and columns as specified, and returns the sorted list of coordinates."}
{"task_id": "Java/88", "generation": "import java.util.*;\n\nclass Solution {\n    public List<Integer> sort_array(List<Integer> array) {\n        if (array.isEmpty()) {\n            return new ArrayList<>();\n        } else {\n            List<Integer> sortedArray = new ArrayList<>(array);\n            if ((array.get(0) + array.get(array.size() - 1)) % 2 == 1) {\n                Collections.sort(sortedArray);\n            } else {\n                Collections.sort(sortedArray, Collections.reverseOrder());\n            }\n            return sortedArray;\n        }\n    }\n}\n", "py_code": "def sort_array(array):\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0) \n", "py_summary": "The Python code defines a function that takes a list of integers as input and returns a sorted copy of the input list based on a specific condition. If the sum of the first and last elements of the input list is odd, the function sorts the list in ascending order. Otherwise, it sorts the list in descending order. \n\nThe function first checks if the input list is empty, in which case it returns an empty list. Otherwise, it uses the `sorted` function to sort the input list in ascending order if the sum of the first and last elements is odd (`(array[0]+array[-1]) % 2 == 1`), and in descending order if the sum is even. The `reverse` parameter of the `sorted` function is set to `True` if the sum is even, indicating a descending sort."}
{"task_id": "Java/89", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public String encrypt(String s) {\n        String alphabet = \"abcdefghijklmnopqrstuvwxyz\";\n        StringBuilder encrypted = new StringBuilder();\n        \n        for (char c : s.toCharArray()) {\n            if (Character.isLetter(c)) {\n                int index = alphabet.indexOf(c);\n                int newIndex = (index + 2 * 2) % 26;\n                encrypted.append(alphabet.charAt(newIndex));\n            } else {\n                encrypted.append(c);\n            }\n        }\n        \n        return encrypted.toString();\n    }\n}\n", "py_code": "def encrypt(s):\n    d = 'abcdefghijklmnopqrstuvwxyz'\n    out = ''\n    for c in s:\n        if c in d:\n            out += d[(d.index(c)+2*2) % 26]\n        else:\n            out += c\n    return out\n", "py_summary": "The Python code defines a function `encrypt` that takes a string as input and returns an encrypted string based on the given rotation rule. It first defines the alphabet as a string `d` containing all lowercase letters. Then, it initializes an empty string `out` to store the encrypted result. \n\nThe function iterates through each character in the input string `s`. If the character is a lowercase letter, it finds the index of the character in the alphabet string `d`, shifts the index down by two multiplied by two places, wraps around using modulo 26 to handle overflow, and retrieves the corresponding letter from the alphabet. If the character is not a lowercase letter, it appends the character as it is to the result string.\n\nFinally, the function returns the encrypted string `out`."}
{"task_id": "Java/90", "generation": "import java.util.*;\n\nclass Solution {\n    public Optional<Integer> next_smallest(List<Integer> lst) {\n        Set<Integer> set = new TreeSet<>(lst);\n        if (set.size() < 2) {\n            return Optional.empty();\n        } else {\n            Iterator<Integer> iterator = set.iterator();\n            iterator.next();\n            return Optional.of(iterator.next());\n        }\n    }\n}\n", "py_code": "def next_smallest(lst):\n    lst = sorted(set(lst))\n    return None if len(lst) < 2 else lst[1]\n", "py_summary": "The Python code defines a function `next_smallest` that takes a list of integers as input and returns the second smallest element from the list. The function first removes duplicates from the input list by converting it to a set and then sorting it. It then checks if the length of the sorted list is less than 2. If so, it returns `None` indicating that there is no second smallest element. Otherwise, it returns the element at index 1, which corresponds to the second smallest element in the sorted list."}
{"task_id": "Java/91", "generation": "import java.util.*;\n\nclass Solution {\n    public int is_bored(String S) {\n        String[] sentences = S.split(\"[.?!]\\\\s*\");\n        int count = 0;\n        for (String sentence : sentences) {\n            if (sentence.startsWith(\"I \")) {\n                count++;\n            }\n        }\n        return count;\n    }\n}\n", "py_code": "def is_bored(S):\n    import re\n    sentences = re.split(r'[.?!]\\s*', S)\n    return sum(sentence[0:2] == 'I ' for sentence in sentences)\n", "py_summary": "The Python code defines a function `is_bored` that takes a string `S` as input and counts the number of \"boredoms\" in the string. A boredom is defined as a sentence that starts with the word \"I\". \n\nThe function first splits the input string into sentences using regular expression `r'[.?!]\\s*'` to handle delimiters like '.', '?' or '!'. It then iterates through each sentence and checks if the first two characters of the sentence are 'I '. If they are, it increments the count of boredoms.\n\nFinally, the function returns the total count of boredoms found in the input string."}
{"task_id": "Java/92", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public boolean any_int(Object x, Object y, Object z) {\n        if (x instanceof Integer && y instanceof Integer && z instanceof Integer) {\n            int num1 = (int) x;\n            int num2 = (int) y;\n            int num3 = (int) z;\n            if (num1 + num2 == num3 || num1 + num3 == num2 || num2 + num3 == num1) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n", "py_code": "def any_int(x, y, z):\n    \n    if isinstance(x,int) and isinstance(y,int) and isinstance(z,int):\n        if (x+y==z) or (x+z==y) or (y+z==x):\n            return True\n        return False\n    return False\n", "py_summary": "The Python code defines a function that takes three input numbers and checks if one of the numbers is equal to the sum of the other two numbers. It first checks if all the input numbers are integers using the `isinstance()` function. If they are integers, it then checks all possible combinations of two numbers being equal to the third number. If any of these conditions are met, it returns True, indicating that one number is equal to the sum of the other two. Otherwise, it returns False."}
{"task_id": "Java/93", "generation": "import java.util.*;\n\nclass Solution {\n    public String encode(String message) {\n        String vowels = \"aeiouAEIOU\";\n        Map<Character, Character> vowelsReplace = new HashMap<>();\n        for (char c : vowels.toCharArray()) {\n            vowelsReplace.put(c, (char) (c + 2));\n        }\n        \n        StringBuilder encodedMessage = new StringBuilder();\n        for (char ch : message.toCharArray()) {\n            if (Character.isLetter(ch)) {\n                char encodedChar = vowelsReplace.getOrDefault(Character.toLowerCase(ch), ch);\n                if (Character.isUpperCase(ch)) {\n                    encodedChar = Character.toUpperCase(encodedChar);\n                }\n                encodedMessage.append(encodedChar);\n            } else {\n                encodedMessage.append(ch);\n            }\n        }\n        \n        return encodedMessage.toString();\n    }\n}\n", "py_code": "def encode(message):\n    vowels = \"aeiouAEIOU\"\n    vowels_replace = dict([(i, chr(ord(i) + 2)) for i in vowels])\n    message = message.swapcase()\n    return ''.join([vowels_replace[i] if i in vowels else i for i in message])\n", "py_summary": "The Python code defines a function that encodes a message by swapping the case of all letters and replacing vowels with the letter that appears 2 places ahead of that vowel in the English alphabet. \n1. It first defines a string `vowels` containing all lowercase and uppercase vowels.\n2. It creates a dictionary `vowels_replace` where each vowel is mapped to the letter that appears 2 places ahead of it in the alphabet.\n3. It then swaps the case of all letters in the input message using the `swapcase()` method.\n4. Finally, it iterates through each character in the message, replacing vowels with the corresponding letter from the `vowels_replace` dictionary, and returns the encoded message."}
{"task_id": "Java/94", "generation": "import java.util.*;\n\nclass Solution {\n    public int skjkasdkd(List<Integer> lst) {\n        int maxx = 0;\n        for (int num : lst) {\n            if (isPrime(num) && num > maxx) {\n                maxx = num;\n            }\n        }\n        return sumDigits(maxx);\n    }\n\n    private boolean isPrime(int n) {\n        if (n <= 1) {\n            return false;\n        }\n        for (int i = 2; i <= Math.sqrt(n); i++) {\n            if (n % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private int sumDigits(int num) {\n        int sum = 0;\n        while (num > 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n        return sum;\n    }\n}\n", "py_code": "def skjkasdkd(lst):\n    def isPrime(n):\n        for i in range(2,int(n**0.5)+1):\n            if n%i==0:\n                return False\n\n        return True\n    maxx = 0\n    i = 0\n    while i < len(lst):\n        if(lst[i] > maxx and isPrime(lst[i])):\n            maxx = lst[i]\n        i+=1\n    result = sum(int(digit) for digit in str(maxx))\n    return result\n\n", "py_summary": "The Python code defines a function `skjkasdkd` that takes a list of integers as input and finds the largest prime value from the list. It then calculates the sum of the digits of this largest prime value and returns the result.\n\nWithin the function, there is a nested function `isPrime(n)` that checks if a number `n` is prime by iterating from 2 to the square root of `n` and checking for divisibility.\n\nThe function initializes `maxx` to 0 and iterates through the input list. If a number in the list is both prime and greater than the current maximum prime value (`maxx`), it updates `maxx` to that number. After iterating through the list, it calculates the sum of the digits of `maxx` and returns the result."}
{"task_id": "Java/95", "generation": "import java.util.*;\n\nclass Solution {\n    public boolean check_dict_case(Map<Object, Object> dict) {\n        if (dict.isEmpty()) {\n            return false;\n        } else {\n            String state = \"start\";\n            for (Object key : dict.keySet()) {\n                if (!(key instanceof String)) {\n                    return false;\n                }\n                String strKey = (String) key;\n                if (state.equals(\"start\")) {\n                    if (strKey.equals(strKey.toLowerCase())) {\n                        state = \"lower\";\n                    } else if (strKey.equals(strKey.toUpperCase())) {\n                        state = \"upper\";\n                    } else {\n                        return false;\n                    }\n                } else if ((state.equals(\"upper\") && !strKey.equals(strKey.toUpperCase())) || (state.equals(\"lower\") && !strKey.equals(strKey.toLowerCase()))) {\n                    return false;\n                }\n            }\n            return state.equals(\"upper\") || state.equals(\"lower\");\n        }\n    }\n}\n", "py_code": "def check_dict_case(dict):\n    if len(dict.keys()) == 0:\n        return False\n    else:\n        state = \"start\"\n        for key in dict.keys():\n\n            if isinstance(key, str) == False:\n                state = \"mixed\"\n                break\n            if state == \"start\":\n                if key.isupper():\n                    state = \"upper\"\n                elif key.islower():\n                    state = \"lower\"\n                else:\n                    break\n            elif (state == \"upper\" and not key.isupper()) or (state == \"lower\" and not key.islower()):\n                    state = \"mixed\"\n                    break\n            else:\n                break\n        return state == \"upper\" or state == \"lower\" \n", "py_summary": "The Python code defines a function `check_dict_case` that takes a dictionary as input and checks if all the keys in the dictionary are strings and either all in lowercase or all in uppercase. If the dictionary is empty, the function returns False. \n\nThe function iterates through the keys of the dictionary and checks the case of the keys. It maintains a `state` variable to keep track of whether the keys are all in lowercase, all in uppercase, or mixed. If it encounters a key that is not a string, the function immediately returns False. \n\nThe function then checks the case of the keys and updates the `state` variable accordingly. If the keys are a mix of lowercase and uppercase, the function sets the `state` to \"mixed\" and returns False. Finally, the function returns True if all keys are either in lowercase or uppercase, and False otherwise."}
{"task_id": "Java/96", "generation": "import java.util.*;\n\nclass Solution {\n    public List<Integer> count_up_to(int n) {\n        List<Integer> primes = new ArrayList<>();\n        for (int i = 2; i < n; i++) {\n            boolean isPrime = true;\n            for (int j = 2; j < i; j++) {\n                if (i % j == 0) {\n                    isPrime = false;\n                    break;\n                }\n            }\n            if (isPrime) {\n                primes.add(i);\n            }\n        }\n        return primes;\n    }\n}\n", "py_code": "def count_up_to(n):\n    primes = []\n    for i in range(2, n):\n        is_prime = True\n        for j in range(2, i):\n            if i % j == 0:\n                is_prime = False\n                break\n        if is_prime:\n            primes.append(i)\n    return primes\n\n", "py_summary": "The Python code defines a function that takes a non-negative integer `n` as input and returns a list of the first `n` prime numbers that are less than `n`. It initializes an empty list `primes` to store the prime numbers found. Then, it iterates from 2 to `n-1` and for each number `i`, it checks if `i` is a prime number by iterating from 2 to `i-1`. If `i` is divisible by any number in this range, it is not a prime number and the loop breaks. If `i` is not divisible by any number, it is considered a prime number and added to the `primes` list. Finally, the function returns the list of prime numbers found."}
{"task_id": "Java/97", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int multiply(int a, int b) {\n        return Math.abs(a % 10) * Math.abs(b % 10);\n    }\n}\n", "py_code": "def multiply(a, b):\n    return abs(a % 10) * abs(b % 10)\n", "py_summary": "The Python code defines a function that takes two integers as input and returns the product of their unit digits. It uses the modulus operator (%) to extract the unit digit of each input integer by taking the absolute value of the remainder when divided by 10. Then, it calculates the product of the unit digits and returns the result. The absolute function is used to handle negative numbers and ensure that the result is always positive."}
{"task_id": "Java/98", "generation": "import java.util.*;\n\nclass Solution {\n    public int count_upper(String s) {\n        int count = 0;\n        for (int i = 0; i < s.length(); i += 2) {\n            char ch = s.charAt(i);\n            if (\"AEIOU\".indexOf(ch) != -1) {\n                count++;\n            }\n        }\n        return count;\n    }\n}\n", "py_code": "def count_upper(s):\n    count = 0\n    for i in range(0,len(s),2):\n        if s[i] in \"AEIOU\":\n            count += 1\n    return count\n", "py_summary": "The Python code defines a function `count_upper` that takes a string `s` as input and counts the number of uppercase vowels in even indices of the string. It initializes a counter variable `count` to 0. Then, it iterates over the characters of the string at even indices (indices 0, 2, 4, ...) using a step size of 2. For each character at an even index, it checks if it is an uppercase vowel (A, E, I, O, U) and increments the `count` if the condition is met. Finally, it returns the total count of uppercase vowels found at even indices in the string."}
{"task_id": "Java/99", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int closest_integer(String value) {\n        if (value.contains(\".\")) {\n            // remove trailing zeros\n            while (value.charAt(value.length() - 1) == '0') {\n                value = value.substring(0, value.length() - 1);\n            }\n        }\n\n        double num = Double.parseDouble(value);\n        int res;\n        if (value.endsWith(\".5\")) {\n            if (num > 0) {\n                res = (int) Math.ceil(num);\n            } else {\n                res = (int) Math.floor(num);\n            }\n        } else if (value.length() > 0) {\n            res = (int) Math.round(num);\n        } else {\n            res = 0;\n        }\n\n        return res;\n    }\n}\n", "py_code": "def closest_integer(value):\n    from math import floor, ceil\n\n    if value.count('.') == 1:\n        # remove trailing zeros\n        while (value[-1] == '0'):\n            value = value[:-1]\n\n    num = float(value)\n    if value[-2:] == '.5':\n        if num > 0:\n            res = ceil(num)\n        else:\n            res = floor(num)\n    elif len(value) > 0:\n        res = int(round(num))\n    else:\n        res = 0\n\n    return res\n\n", "py_summary": "The Python code defines a function that takes a string representing a number as input and returns the closest integer to that number. Here is a breakdown of the code:\n1. The function first checks if the input number is a decimal number by counting the occurrence of the decimal point '.' in the string.\n2. If the input number is a decimal number, it removes any trailing zeros after the decimal point.\n3. It then converts the string number to a float for further calculations.\n4. If the decimal part of the number is exactly 0.5, the function rounds the number away from zero by using the `ceil` function for positive numbers and the `floor` function for negative numbers.\n5. If the decimal part is not 0.5, the function rounds the number to the nearest integer using the `round` function.\n6. If the input string is empty, the function returns 0 as the closest integer.\n7. Finally, the function returns the closest integer to the input number.\n\nThe code handles cases where the number is a decimal, has a decimal part of 0.5, and is an empty string. It ensures that the rounding is done away from zero when the number is equidistant from two integers."}
{"task_id": "Java/100", "generation": "import java.util.*;\n\nclass Solution {\n    public List<Integer> make_a_pile(int n) {\n        List<Integer> stones = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            stones.add(n + 2*i);\n        }\n        return stones;\n    }\n}\n", "py_code": "def make_a_pile(n):\n    return [n + 2*i for i in range(n)]\n", "py_summary": "The Python code defines a function that takes a positive integer `n` as input and returns a list of integers representing the number of stones in each level of the pile. The function uses list comprehension to generate the list based on the given rules:\n- The first level has `n` stones.\n- The number of stones in the next level is determined by adding 2 for each subsequent level.\n\nFor example, if `n = 3`, the function will return `[3, 5, 7]` representing the number of stones in each level starting from level 1."}
{"task_id": "Java/101", "generation": "import java.util.*;\n\nclass Solution {\n    public List<String> words_string(String s) {\n        List<String> wordsList = new ArrayList<>();\n        if (s == null || s.isEmpty()) {\n            return wordsList;\n        }\n\n        StringBuilder sb = new StringBuilder();\n        for (char c : s.toCharArray()) {\n            if (c == ',') {\n                wordsList.add(sb.toString().trim());\n                sb.setLength(0);\n            } else if (c == ' ') {\n                if (sb.length() > 0) {\n                    wordsList.add(sb.toString().trim());\n                    sb.setLength(0);\n                }\n            } else {\n                sb.append(c);\n            }\n        }\n\n        if (sb.length() > 0) {\n            wordsList.add(sb.toString().trim());\n        }\n\n        return wordsList;\n    }\n}\n", "py_code": "def words_string(s):\n    if not s:\n        return []\n\n    s_list = []\n\n    for letter in s:\n        if letter == ',':\n            s_list.append(' ')\n        else:\n            s_list.append(letter)\n\n    s_list = \"\".join(s_list)\n    return s_list.split()\n", "py_summary": "The Python code defines a function `words_string` that takes a string `s` as input and splits the string into words based on spaces and commas. It first checks if the input string is empty and returns an empty list if it is. Then, it iterates through each character in the string, replacing commas with spaces. After replacing commas, it joins the characters back together to form a modified string where commas are replaced by spaces. Finally, it splits the modified string based on spaces using the `split()` method and returns the list of words."}
{"task_id": "Java/102", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int choose_num(int x, int y) {\n        if (x > y) {\n            return -1;\n        }\n        if (y % 2 == 0) {\n            return y;\n        }\n        if (x == y) {\n            return -1;\n        }\n        return y - 1;\n    }\n}\n", "py_code": "def choose_num(x, y):\n    if x > y:\n        return -1\n    if y % 2 == 0:\n        return y\n    if x == y:\n        return -1\n    return y - 1\n", "py_summary": "The Python code defines a function that takes two positive integers x and y as input and returns the biggest even integer number in the range [x, y] inclusive. If there is no even number in the range, the function returns -1. \n\nThe function first checks if x is greater than y, in which case it returns -1. Then, it checks if y is already an even number, if so, it returns y. If x and y are the same, it returns -1. Otherwise, it returns y-1 as the biggest even number in the range."}
{"task_id": "Java/103", "generation": "import java.util.*;\n\nclass Solution {\n    public Object rounded_avg(int n, int m) {\n        if (n > m) {\n            return -1;\n        }\n        int sum = 0;\n        for (int i = n; i <= m; i++) {\n            sum += i;\n        }\n        int average = Math.round((float) sum / (m - n + 1));\n        return Integer.toBinaryString(average);\n    }\n}\n", "py_code": "def rounded_avg(n, m):\n    if m < n:\n        return -1\n    summation = 0\n    for i in range(n, m+1):\n        summation += i\n    return bin(round(summation/(m - n + 1)))\n", "py_summary": "The Python code defines a function `rounded_avg` that takes two integers `n` and `m` as input. It calculates the sum of integers from `n` to `m`, inclusive. If `n` is greater than `m`, it returns -1. Otherwise, it calculates the average of the integers and rounds it to the nearest integer. The rounded average is then converted to binary format using the `bin()` function and returned as a string."}
{"task_id": "Java/104", "generation": "import java.util.*;\n\nclass Solution {\n    public List<Integer> unique_digits(List<Integer> x) {\n        List<Integer> oddDigitElements = new ArrayList<>();\n        for (int num : x) {\n            if (allDigitsAreOdd(num)) {\n                oddDigitElements.add(num);\n            }\n        }\n        Collections.sort(oddDigitElements);\n        return oddDigitElements;\n    }\n    \n    public boolean allDigitsAreOdd(int num) {\n        String numStr = String.valueOf(num);\n        for (char c : numStr.toCharArray()) {\n            if ((c - '0') % 2 == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n", "py_code": "def unique_digits(x):\n    odd_digit_elements = []\n    for i in x:\n        if all (int(c) % 2 == 1 for c in str(i)):\n            odd_digit_elements.append(i)\n    return sorted(odd_digit_elements)\n", "py_summary": "The Python code defines a function that takes a list of positive integers as input and returns a sorted list of elements that do not contain any even digits. It iterates through each integer in the input list and checks if all the digits in the integer are odd by converting each digit to an integer and checking if it's odd (i.e., not divisible by 2). If all digits are odd, the integer is added to a new list. Finally, the function returns the sorted list of integers without any even digits."}
{"task_id": "Java/105", "generation": "import java.util.*;\n\nclass Solution {\n    public List<String> by_length(List<Integer> arr) {\n        Map<Integer, String> map = new HashMap<>();\n        map.put(1, \"One\");\n        map.put(2, \"Two\");\n        map.put(3, \"Three\");\n        map.put(4, \"Four\");\n        map.put(5, \"Five\");\n        map.put(6, \"Six\");\n        map.put(7, \"Seven\");\n        map.put(8, \"Eight\");\n        map.put(9, \"Nine\");\n\n        List<Integer> validIntegers = new ArrayList<>();\n        for (int num : arr) {\n            if (num >= 1 && num <= 9) {\n                validIntegers.add(num);\n            }\n        }\n\n        Collections.sort(validIntegers, Collections.reverseOrder());\n\n        List<String> result = new ArrayList<>();\n        for (int num : validIntegers) {\n            result.add(map.get(num));\n        }\n\n        return result;\n    }\n}\n", "py_code": "def by_length(arr):\n    dic = {\n        1: \"One\",\n        2: \"Two\",\n        3: \"Three\",\n        4: \"Four\",\n        5: \"Five\",\n        6: \"Six\",\n        7: \"Seven\",\n        8: \"Eight\",\n        9: \"Nine\",\n    }\n    sorted_arr = sorted(arr, reverse=True)\n    new_arr = []\n    for var in sorted_arr:\n        try:\n            new_arr.append(dic[var])\n        except:\n            pass\n    return new_arr\n", "py_summary": "The Python code defines a function `by_length` that takes a list of integers as input, sorts the integers that are between 1 and 9 inclusive, reverses the resulting array, and replaces each digit by its corresponding name from \"One\" to \"Nine\". \n\n1. A dictionary `dic` is created to map integers to their corresponding names.\n2. The input array `arr` is sorted in descending order using `sorted(arr, reverse=True)`.\n3. A new list `new_arr` is initialized to store the corresponding names of the sorted integers.\n4. Iterate through the sorted array, and for each integer, try to append its corresponding name to `new_arr` using the dictionary `dic`. If the integer is not in the dictionary (not between 1 and 9), it is ignored.\n5. Finally, return the list `new_arr` containing the names of the sorted integers between 1 and 9.\n\nThis code effectively sorts the valid integers between 1 and 9, reverses the sorted array, and replaces the integers with their corresponding names.\n\n### Last step, write the Java solution according to the python solution and the python code summary."}
{"task_id": "Java/106", "generation": "import java.util.*;\n\nclass Solution {\n    public List<Integer> f(int n) {\n        List<Integer> result = new ArrayList<>();\n        for (int i = 1; i <= n; i++) {\n            if (i % 2 == 0) {\n                int factorial = 1;\n                for (int j = 1; j <= i; j++) {\n                    factorial *= j;\n                }\n                result.add(factorial);\n            } else {\n                int sum = 0;\n                for (int j = 1; j <= i; j++) {\n                    sum += j;\n                }\n                result.add(sum);\n            }\n        }\n        return result;\n    }\n}\n", "py_code": "def f(n):\n    ret = []\n    for i in range(1,n+1):\n        if i%2 == 0:\n            x = 1\n            for j in range(1,i+1): x *= j\n            ret += [x]\n        else:\n            x = 0\n            for j in range(1,i+1): x += j\n            ret += [x]\n    return ret\n", "py_summary": "The Python code defines a function `f` that takes an integer `n` as input and returns a list of size `n`. The function iterates through the range from 1 to `n` (inclusive). For each index `i`, if `i` is even, it calculates the factorial of `i` by multiplying numbers from 1 to `i` and appends the result to the list. If `i` is odd, it calculates the sum of numbers from 1 to `i` and appends the result to the list. Finally, the function returns the list containing the factorial of even indices and the sum of numbers from 1 to `i` for odd indices."}
{"task_id": "Java/107", "generation": "import java.util.*;\n\nclass Solution {\n    public List<Integer> even_odd_palindrome(int n) {\n        List<Integer> result = new ArrayList<>();\n        int evenCount = 0;\n        int oddCount = 0;\n\n        for (int i = 1; i <= n; i++) {\n            if (isPalindrome(i)) {\n                if (i % 2 == 0) {\n                    evenCount++;\n                } else {\n                    oddCount++;\n                }\n            }\n        }\n\n        result.add(evenCount);\n        result.add(oddCount);\n        return result;\n    }\n\n    private boolean isPalindrome(int num) {\n        String strNum = String.valueOf(num);\n        return strNum.equals(new StringBuilder(strNum).reverse().toString());\n    }\n}\n", "py_code": "def even_odd_palindrome(n):\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n", "py_summary": "The Python code defines a function `even_odd_palindrome` that takes a positive integer `n` as input and returns a tuple containing the count of even and odd integer palindromes within the range (1, n) inclusive. \n\nWithin the function, there is a nested function `is_palindrome` that checks if a given number is a palindrome by converting it to a string and comparing it with its reverse.\n\nThe function initializes `even_palindrome_count` and `odd_palindrome_count` to 0. It then iterates through numbers from 1 to n and checks if the number is a palindrome and whether it is even or odd. Based on these conditions, it increments the respective count variables.\n\nFinally, the function returns a tuple containing the count of even and odd palindromes found within the range (1, n)."}
{"task_id": "Java/108", "generation": "import java.util.*;\n\nclass Solution {\n    public int count_nums(List<Integer> arr) {\n        int count = 0;\n        for (int num : arr) {\n            int sum = 0;\n            int n = num < 0 ? -1 * num : num;\n            String numStr = String.valueOf(n);\n            for (char c : numStr.toCharArray()) {\n                sum += Character.getNumericValue(c);\n            }\n            if (sum > 0) {\n                count++;\n            }\n        }\n        return count;\n    }\n}\n", "py_code": "def count_nums(arr):\n    def digits_sum(n):\n        neg = 1\n        if n < 0: n, neg = -1 * n, -1 \n        n = [int(i) for i in str(n)]\n        n[0] = n[0] * neg\n        return sum(n)\n    return len(list(filter(lambda x: x > 0, [digits_sum(i) for i in arr])))\n", "py_summary": "The Python code defines a function `count_nums` that takes a list of integers as input and returns the number of elements in the list whose sum of digits is greater than 0. \n\nWithin the `count_nums` function, there is a nested function `digits_sum` that calculates the sum of digits of a given number. If the number is negative, it considers the first signed digit as negative. \n\nThe main function uses a list comprehension to apply the `digits_sum` function to each element in the input list `arr`. It then filters the results to keep only the elements whose sum of digits is greater than 0. Finally, it returns the length of the filtered list, which represents the count of elements meeting the condition."}
{"task_id": "Java/109", "generation": "import java.util.*;\n\nclass Solution {\n    public boolean move_one_ball(List<Integer> arr) {\n        if (arr.isEmpty()) {\n            return true;\n        }\n        \n        List<Integer> sortedArray = new ArrayList<>(arr);\n        Collections.sort(sortedArray);\n        \n        int minValue = Collections.min(arr);\n        int minIndex = arr.indexOf(minValue);\n        \n        List<Integer> myArr = new ArrayList<>(arr.subList(minIndex, arr.size()));\n        myArr.addAll(arr.subList(0, minIndex));\n        \n        for (int i = 0; i < arr.size(); i++) {\n            if (!myArr.get(i).equals(sortedArray.get(i))) {\n                return false;\n            }\n        }\n        \n        return true;\n    }\n}\n", "py_code": "def move_one_ball(arr):\n    if len(arr)==0:\n      return True\n    sorted_array=sorted(arr)\n    my_arr=[]\n    \n    min_value=min(arr)\n    min_index=arr.index(min_value)\n    my_arr=arr[min_index:]+arr[0:min_index]\n    for i in range(len(arr)):\n      if my_arr[i]!=sorted_array[i]:\n        return False\n    return True\n", "py_summary": "The Python code defines a function `move_one_ball` that takes a list of integers as input and determines if it is possible to obtain a sorted array in non-decreasing order by performing right shift operations on the given array. The function first checks if the input array is empty, in which case it returns True. \n\nNext, it creates a sorted version of the input array and finds the minimum value and its index in the original array. It then constructs a modified array by shifting the elements based on the minimum value index. \n\nFinally, the function compares the modified array with the sorted array element-wise. If they match for all elements, the function returns True, indicating that it is possible to obtain a sorted array. Otherwise, it returns False."}
{"task_id": "Java/110", "generation": "import java.util.*;\n\nclass Solution {\n    public String exchange(List<Integer> lst1, List<Integer> lst2) {\n        int odd = 0;\n        int even = 0;\n        for (int num : lst1) {\n            if (num % 2 == 1) {\n                odd++;\n            }\n        }\n        for (int num : lst2) {\n            if (num % 2 == 0) {\n                even++;\n            }\n        }\n        if (even >= odd) {\n            return \"YES\";\n        }\n        return \"NO\";\n    }\n}\n", "py_code": "def exchange(lst1, lst2):\n    odd = 0\n    even = 0\n    for i in lst1:\n        if i%2 == 1:\n            odd += 1\n    for i in lst2:\n        if i%2 == 0:\n            even += 1\n    if even >= odd:\n        return \"YES\"\n    return \"NO\"\n            \n", "py_summary": "The Python code defines a function that takes two lists of numbers as input and checks if it is possible to exchange elements between the two lists such that the first list (`lst1`) contains only even numbers. The function iterates through each element in `lst1` and counts the number of odd numbers. Similarly, it iterates through each element in `lst2` and counts the number of even numbers. If the count of even numbers in `lst2` is greater than or equal to the count of odd numbers in `lst1`, then it is possible to exchange elements to make all elements in `lst1` even, and the function returns \"YES\". Otherwise, it returns \"NO\"."}
{"task_id": "Java/111", "generation": "import java.util.*;\n\nclass Solution {\n    public Map<String, Integer> histogram(String test) {\n        Map<String, Integer> dict = new HashMap<>();\n        String[] letters = test.split(\" \");\n        int maxCount = 0;\n\n        for (String letter : letters) {\n            if (!letter.equals(\"\")) {\n                int count = Collections.frequency(Arrays.asList(letters), letter);\n                if (count > maxCount) {\n                    maxCount = count;\n                    dict.clear();\n                    dict.put(letter, count);\n                } else if (count == maxCount) {\n                    dict.put(letter, count);\n                }\n            }\n        }\n        return dict;\n    }\n}\n", "py_code": "def histogram(test):\n    dict1={}\n    list1=test.split(\" \")\n    t=0\n\n    for i in list1:\n        if(list1.count(i)>t) and i!='':\n            t=list1.count(i)\n    if t>0:\n        for i in list1:\n            if(list1.count(i)==t):\n                \n                dict1[i]=t\n    return dict1\n", "py_summary": "The Python code defines a function `histogram` that takes a string of space-separated lowercase letters as input and returns a dictionary containing the letter(s) with the most repetitions along with their counts. \n\nThe function first initializes an empty dictionary `dict1`, splits the input string into a list of letters `list1`, and sets a variable `t` to 0 to keep track of the maximum count found so far.\n\nIt then iterates through the list of letters and checks if the count of the current letter is greater than the current maximum count `t` and the letter is not an empty string. If the condition is met, it updates the maximum count `t`.\n\nAfter finding the maximum count `t`, the function iterates through the list of letters again and adds the letters with a count equal to `t` to the dictionary `dict1`.\n\nFinally, the function returns the dictionary `dict1` containing the letter(s) with the most repetitions and their counts."}
{"task_id": "Java/112", "generation": "import java.util.*;\n\nclass Solution {\n    public List<Object> reverse_delete(String s, String c) {\n        StringBuilder result = new StringBuilder();\n        for (char ch : s.toCharArray()) {\n            if (c.indexOf(ch) == -1) {\n                result.append(ch);\n            }\n        }\n        String modifiedString = result.toString();\n        boolean isPalindrome = checkPalindrome(modifiedString);\n        List<Object> output = new ArrayList<>();\n        output.add(modifiedString);\n        output.add(isPalindrome);\n        return output;\n    }\n\n    private boolean checkPalindrome(String str) {\n        int left = 0;\n        int right = str.length() - 1;\n        while (left < right) {\n            if (str.charAt(left) != str.charAt(right)) {\n                return false;\n            }\n            left++;\n            right--;\n        }\n        return true;\n    }\n}\n", "py_code": "def reverse_delete(s,c):\n    s = ''.join([char for char in s if char not in c])\n    return (s,s[::-1] == s)\n", "py_summary": "The Python code defines a function `reverse_delete` that takes two strings `s` and `c` as input. It removes all characters in string `s` that are present in string `c` and then checks if the resulting string is a palindrome. \n\nThe function iterates through each character in string `s` and only keeps the characters that are not present in string `c`. It then checks if the modified string is equal to its reverse to determine if it is a palindrome. The function returns a tuple containing the modified string and a boolean value indicating whether the modified string is a palindrome or not."}
{"task_id": "Java/113", "generation": "import java.util.*;\n\nclass Solution {\n    public List<String> odd_count(List<String> lst) {\n        List<String> result = new ArrayList<>();\n        for (String str : lst) {\n            int oddCount = 0;\n            for (char c : str.toCharArray()) {\n                if (Character.isDigit(c) && (c - '0') % 2 == 1) {\n                    oddCount++;\n                }\n            }\n            result.add(\"the number of odd elements \" + oddCount + \"n the str\" + oddCount + \"ng \" + oddCount + \" of the \" + oddCount + \"nput.\");\n        }\n        return result;\n    }\n}\n", "py_code": "def odd_count(lst):\n    res = []\n    for arr in lst:\n        n = sum(int(d)%2==1 for d in arr)\n        res.append(\"the number of odd elements \" + str(n) + \"n the str\"+ str(n) +\"ng \"+ str(n) +\" of the \"+ str(n) +\"nput.\")\n    return res\n", "py_summary": "The Python code defines a function that takes a list of strings as input, where each string consists of only digits. The function then calculates the number of odd digits in each string and constructs a new string based on the count of odd digits. \n\nIt iterates through each string in the input list and counts the number of odd digits by converting each digit to an integer and checking if it's odd (using the modulo operator %). It then constructs a new string using the count of odd digits to replace certain placeholders in a predefined format string. Finally, it appends the constructed string to the result list and returns the list of modified strings."}
{"task_id": "Java/114", "generation": "import java.util.*;\n\nclass Solution {\n    public int minSubArraySum(List<Integer> nums) {\n        int maxSum = 0;\n        int sum = 0;\n        for (int num : nums) {\n            sum += -num;\n            if (sum < 0) {\n                sum = 0;\n            }\n            maxSum = Math.max(sum, maxSum);\n        }\n        if (maxSum == 0) {\n            maxSum = Collections.max(nums) * -1;\n        }\n        int minSum = -maxSum;\n        return minSum;\n    }\n}\n", "py_code": "def minSubArraySum(nums):\n    max_sum = 0\n    s = 0\n    for num in nums:\n        s += -num\n        if (s < 0):\n            s = 0\n        max_sum = max(s, max_sum)\n    if max_sum == 0:\n        max_sum = max(-i for i in nums)\n    min_sum = -max_sum\n    return min_sum\n", "py_summary": "The Python code defines a function that takes a list of integers as input and finds the minimum sum of any non-empty sub-array of the input list. The function initializes variables `max_sum` and `s` to 0. It then iterates through the list of numbers, calculating the cumulative sum of negative numbers. If the cumulative sum becomes negative, it resets it to 0. The function keeps track of the maximum sum encountered during this process.\n\nAfter iterating through the list, if the `max_sum` is still 0, it means all numbers in the list are non-negative, so the function calculates the minimum sum as the maximum negative number in the list. Finally, the function returns the minimum sum of any non-empty sub-array."}
{"task_id": "Java/115", "generation": "import java.util.*;\n\nclass Solution {\n    public int max_fill(List<List<Integer>> grid, int capacity) {\n        int total = 0;\n        for (List<Integer> row : grid) {\n            int sum = 0;\n            for (int well : row) {\n                sum += well;\n            }\n            total += (int) Math.ceil((double) sum / capacity);\n        }\n        return total;\n    }\n}\n", "py_code": "def max_fill(grid, capacity):\n    import math\n    return sum([math.ceil(sum(arr)/capacity) for arr in grid])\n", "py_summary": "The Python code defines a function `max_fill` that takes a rectangular grid represented as a list of lists and a bucket capacity as input. The function calculates the number of times the buckets need to be lowered to empty all the wells in the grid. \n\nIt uses a list comprehension to iterate over each row in the grid, calculates the total units of water in each well by summing the values in the row, divides this total by the bucket capacity, and then takes the ceiling value of this division to determine the number of times the bucket needs to be lowered for that well. Finally, it sums up these values for all wells in the grid and returns the total number of times the buckets need to be lowered."}
{"task_id": "Java/116", "generation": "import java.util.*;\n\nclass Solution {\n    public List<Integer> sort_array(List<Integer> arr) {\n        Collections.sort(arr, (a, b) -> {\n            int countA = Integer.bitCount(Math.abs(a));\n            int countB = Integer.bitCount(Math.abs(b));\n            if (countA == countB) {\n                return a - b;\n            }\n            return countA - countB;\n        });\n        return arr;\n    }\n}\n", "py_code": "def sort_array(arr):\n    return sorted(sorted(arr), key=lambda x: bin(x)[2:].count('1'))\n", "py_summary": "The Python code defines a function that sorts an array of integers based on the number of ones in their binary representation in ascending order. It first sorts the array in ascending order. Then, it uses the `sorted` function with a custom key function to sort the array based on the count of ones in the binary representation of each number. The `bin(x)[2:].count('1')` expression converts the number to binary, removes the '0b' prefix, and counts the number of ones in the binary representation. This ensures that numbers with fewer ones come first."}
{"task_id": "Java/117", "generation": "import java.util.*;\n\nclass Solution {\n    public List<String> select_words(String s, int n) {\n        List<String> result = new ArrayList<>();\n        String[] words = s.split(\" \");\n        for (String word : words) {\n            int n_consonants = 0;\n            for (int i = 0; i < word.length(); i++) {\n                char c = Character.toLowerCase(word.charAt(i));\n                if (c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u') {\n                    n_consonants++;\n                }\n            }\n            if (n_consonants == n) {\n                result.add(word);\n            }\n        }\n        return result;\n    }\n}\n", "py_code": "def select_words(s, n):\n    result = []\n    for word in s.split():\n        n_consonants = 0\n        for i in range(0, len(word)):\n            if word[i].lower() not in [\"a\",\"e\",\"i\",\"o\",\"u\"]:\n                n_consonants += 1 \n        if n_consonants == n:\n            result.append(word)\n    return result\n\n", "py_summary": "The Python code defines a function that takes a string `s` and a natural number `n` as input and returns a list of words from the string `s` that contain exactly `n` consonants. The function splits the input string into words and then iterates through each word. For each word, it counts the number of consonants by checking if each character is not a vowel (a, e, i, o, u). If the count of consonants in a word matches the input `n`, the word is added to the result list. Finally, the function returns the list of words that satisfy the condition."}
{"task_id": "Java/118", "generation": "import java.util.*;\n\nclass Solution {\n    public String get_closest_vowel(String word) {\n        if (word.length() < 3) {\n            return \"\";\n        }\n\n        Set<Character> vowels = new HashSet<>(Arrays.asList('a', 'e', 'i', 'o', 'u', 'A', 'E', 'O', 'U', 'I'));\n        for (int i = word.length() - 2; i > 0; i--) {\n            if (vowels.contains(word.charAt(i))) {\n                if (!vowels.contains(word.charAt(i - 1)) && !vowels.contains(word.charAt(i + 1))) {\n                    return String.valueOf(word.charAt(i));\n                }\n            }\n        }\n        return \"\";\n    }\n}\n", "py_code": "def get_closest_vowel(word):\n    if len(word) < 3:\n        return \"\"\n\n    vowels = {\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", 'O', 'U', 'I'}\n    for i in range(len(word)-2, 0, -1):\n        if word[i] in vowels:\n            if (word[i+1] not in vowels) and (word[i-1] not in vowels):\n                return word[i]\n    return \"\"\n", "py_summary": "The Python code defines a function `get_closest_vowel` that takes a word as input and returns the closest vowel that stands between two consonants from the right side of the word. The function first checks if the length of the word is less than 3, in which case it returns an empty string. \n\nIt then creates a set `vowels` containing all the vowels (both lowercase and uppercase). The function iterates over the characters of the word from the second last character towards the second character. For each character, it checks if it is a vowel and if the characters on its left and right are not vowels. If these conditions are met, the function returns the vowel character. If no such vowel is found, it returns an empty string."}
{"task_id": "Java/119", "generation": "import java.util.*;\n\nclass Solution {\n    public String match_parens(List<String> lst) {\n        String s1 = lst.get(0) + lst.get(1);\n        String s2 = lst.get(1) + lst.get(0);\n        \n        boolean result1 = check(s1);\n        boolean result2 = check(s2);\n        \n        return (result1 || result2) ? \"Yes\" : \"No\";\n    }\n    \n    private boolean check(String s) {\n        int val = 0;\n        for (char c : s.toCharArray()) {\n            if (c == '(') {\n                val++;\n            } else {\n                val--;\n            }\n            if (val < 0) {\n                return false;\n            }\n        }\n        return val == 0;\n    }\n}\n", "py_code": "def match_parens(lst):\n    def check(s):\n        val = 0\n        for i in s:\n            if i == '(':\n                val = val + 1\n            else:\n                val = val - 1\n            if val < 0:\n                return False\n        return True if val == 0 else False\n\n    S1 = lst[0] + lst[1]\n    S2 = lst[1] + lst[0]\n    return 'Yes' if check(S1) or check(S2) else 'No'\n", "py_summary": "The Python code defines a function `match_parens` that takes a list of two strings as input and checks if it is possible to concatenate the two strings in some order to form a balanced parentheses string. The function first defines a helper function `check(s)` that iterates through a string `s` and checks if the parentheses are balanced. It returns `True` if the parentheses are balanced and `False` otherwise.\n\nThe main function concatenates the two input strings in two different orders (`S1 = lst[0] + lst[1]` and `S2 = lst[1] + lst[0]`) and then checks if either of the concatenated strings results in a balanced parentheses string by calling the `check` function. If either of the concatenated strings is balanced, the function returns \"Yes\"; otherwise, it returns \"No\"."}
{"task_id": "Java/120", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> maximum(List<Integer> arr, int k) {\n        if (k == 0) {\n            return new ArrayList<>();\n        }\n        Collections.sort(arr);\n        List<Integer> ans = new ArrayList<>(arr.subList(arr.size() - k, arr.size()));\n        return ans;\n    }\n}\n", "py_code": "def maximum(arr, k):\n    if k == 0:\n        return []\n    arr.sort()\n    ans = arr[-k:]\n    return ans\n", "py_summary": "The Python code defines a function that takes a list of integers `arr` and a positive integer `k` as input and returns a sorted list of length `k` containing the maximum `k` numbers from the input list `arr` in ascending order. \n\nThe function first checks if `k` is equal to 0, in which case it returns an empty list. It then sorts the input list `arr` in ascending order. Next, it selects the last `k` elements from the sorted list `arr` using list slicing and assigns them to the variable `ans`. Finally, it returns the list `ans` containing the maximum `k` numbers in ascending order."}
{"task_id": "Java/121", "generation": "import java.util.*;\n\nclass Solution {\n    public int solution(List<Integer> lst) {\n        int sum = 0;\n        for (int i = 0; i < lst.size(); i++) {\n            if (i % 2 == 0 && lst.get(i) % 2 == 1) {\n                sum += lst.get(i);\n            }\n        }\n        return sum;\n    }\n}\n", "py_code": "def solution(lst):\n    return sum([x for idx, x in enumerate(lst) if idx%2==0 and x%2==1])\n", "py_summary": "The Python code defines a function that takes a list of integers as input and returns the sum of all odd elements that are in even positions (0-based indexing). It uses list comprehension to iterate over the elements of the input list along with their indices. For each element at an even index with an odd value, it adds the element to a new list. Finally, it returns the sum of all such elements in the new list."}
{"task_id": "Java/122", "generation": "import java.util.*;\n\nclass Solution {\n    public int add_elements(List<Integer> arr, int k) {\n        int sum = 0;\n        for (int i = 0; i < k; i++) {\n            if (String.valueOf(arr.get(i)).length() <= 2) {\n                sum += arr.get(i);\n            }\n        }\n        return sum;\n    }\n}\n", "py_code": "def add_elements(arr, k):\n    return sum(elem for elem in arr[:k] if len(str(elem)) <= 2)\n", "py_summary": "The Python code defines a function that takes a list of integers `arr` and an integer `k` as input and returns the sum of elements from the first `k` elements of `arr` that have at most two digits. \n\nIt uses list comprehension to iterate over the first `k` elements of `arr` and filters out elements that have at most two digits by checking the length of the string representation of each element. Finally, it returns the sum of the filtered elements."}
{"task_id": "Java/123", "generation": "import java.util.*;\n\nclass Solution {\n    public List<Integer> get_odd_collatz(int n) {\n        List<Integer> oddCollatz = new ArrayList<>();\n        \n        if (n % 2 != 0) {\n            oddCollatz.add(n);\n        }\n        \n        while (n > 1) {\n            if (n % 2 == 0) {\n                n = n / 2;\n            } else {\n                n = 3 * n + 1;\n            }\n            \n            if (n % 2 == 1) {\n                oddCollatz.add(n);\n            }\n        }\n        \n        Collections.sort(oddCollatz);\n        \n        return oddCollatz;\n    }\n}\n", "py_code": "def get_odd_collatz(n):\n    if n%2==0:\n        odd_collatz = [] \n    else:\n        odd_collatz = [n]\n    while n > 1:\n        if n % 2 == 0:\n            n = n/2\n        else:\n            n = n*3 + 1\n            \n        if n%2 == 1:\n            odd_collatz.append(int(n))\n\n    return sorted(odd_collatz)\n", "py_summary": "The Python code defines a function `get_odd_collatz` that takes a positive integer `n` as input and returns a sorted list of odd numbers in the Collatz sequence starting from `n`. The function first checks if `n` is odd, and if so, initializes the `odd_collatz` list with `[n]`. Then, it enters a while loop that continues until `n` reaches 1. Within the loop, if `n` is even, it is divided by 2; if `n` is odd, it is multiplied by 3 and added 1. If the new `n` is odd, it is appended to the `odd_collatz` list. Finally, the function returns the sorted `odd_collatz` list."}
{"task_id": "Java/124", "generation": "import java.util.*;\n\nclass Solution {\n    public boolean valid_date(String date) {\n        try {\n            date = date.trim();\n            String[] parts = date.split(\"-\");\n            if (parts.length != 3) {\n                return false;\n            }\n            int month = Integer.parseInt(parts[0]);\n            int day = Integer.parseInt(parts[1]);\n            int year = Integer.parseInt(parts[2]);\n            \n            if (month < 1 || month > 12) {\n                return false;\n            }\n            \n            if ((month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) && (day < 1 || day > 31)) {\n                return false;\n            }\n            \n            if ((month == 4 || month == 6 || month == 9 || month == 11) && (day < 1 || day > 30)) {\n                return false;\n            }\n            \n            if (month == 2 && (day < 1 || day > 29)) {\n                return false;\n            }\n        } catch (Exception e) {\n            return false;\n        }\n        \n        return true;\n    }\n}\n", "py_code": "def valid_date(date):\n    try:\n        date = date.strip()\n        month, day, year = date.split('-')\n        month, day, year = int(month), int(day), int(year)\n        if month < 1 or month > 12:\n            return False\n        if month in [1,3,5,7,8,10,12] and day < 1 or day > 31:\n            return False\n        if month in [4,6,9,11] and day < 1 or day > 30:\n            return False\n        if month == 2 and day < 1 or day > 29:\n            return False\n    except:\n        return False\n\n    return True\n", "py_summary": "The Python code defines a function `valid_date` that takes a date string as input and validates whether the date is in a valid format. The function first strips any leading or trailing whitespaces from the input date string. It then attempts to split the date string into month, day, and year components using the '-' delimiter.\n\nThe function then converts the month, day, and year components into integers and checks if the month is within the range [1, 12]. It further validates the day component based on the month:\n- For months with 31 days, the day should be within [1, 31].\n- For months with 30 days, the day should be within [1, 30].\n- For February (month 2), the day should be within [1, 29].\n\nIf any of the validation conditions fail or an exception occurs during the conversion or splitting process, the function returns False. Otherwise, it returns True, indicating that the date is valid."}
{"task_id": "Java/125", "generation": "import java.util.*;\n\nclass Solution {\n    public Object split_words(String txt) {\n        List<String> result = new ArrayList<>();\n        if (txt.contains(\" \")) {\n            String[] words = txt.split(\" \");\n            for (String word : words) {\n                result.add(word);\n            }\n        } else if (txt.contains(\",\")) {\n            String[] words = txt.replace(\",\", \" \").split(\" \");\n            for (String word : words) {\n                result.add(word);\n            }\n        } else {\n            int count = 0;\n            for (char c : txt.toCharArray()) {\n                if (Character.isLowerCase(c) && (c - 'a') % 2 == 1) {\n                    count++;\n                }\n            }\n            return count;\n        }\n        return result;\n    }\n}\n", "py_code": "def split_words(txt):\n    if \" \" in txt:\n        return txt.split()\n    elif \",\" in txt:\n        return txt.replace(',',' ').split()\n    else:\n        return len([i for i in txt if i.islower() and ord(i)%2 == 0])\n", "py_summary": "The Python code defines a function `split_words` that takes a string `txt` as input and processes it based on certain conditions. \n1. If the string contains a whitespace \" \", it splits the string based on whitespaces and returns a list of words.\n2. If the string contains a comma \",\", it replaces the comma with a whitespace and then splits the string based on whitespaces, returning a list of words.\n3. If neither whitespaces nor commas are present in the string, it calculates the number of lowercase letters with an odd order in the alphabet (letters with odd ASCII values when converted to lowercase) and returns this count.\n\nThe function handles different cases based on the presence of whitespaces and commas in the input string, and returns the appropriate output as specified in the problem statement."}
{"task_id": "Java/126", "generation": "import java.util.*;\n\nclass Solution {\n    public boolean is_sorted(List<Integer> lst) {\n        Map<Integer, Integer> countDigit = new HashMap<>();\n        for (int i : lst) {\n            countDigit.put(i, countDigit.getOrDefault(i, 0) + 1);\n        }\n        \n        for (int i : lst) {\n            if (countDigit.get(i) > 2) {\n                return false;\n            }\n        }\n        \n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1) > lst.get(i)) {\n                return false;\n            }\n        }\n        \n        return true;\n    }\n}\n", "py_code": "def is_sorted(lst):\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1 \n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n    \n    \n", "py_summary": "The Python code defines a function that takes a list of integers as input and checks if the list is sorted in ascending order. It first creates a dictionary `count_digit` to count the occurrences of each number in the list. Then, it checks if any number appears more than twice in the list, in which case it returns False.\n\nNext, the code uses a list comprehension to check if all elements in the list are in non-decreasing order. If this condition is met, it returns True; otherwise, it returns False."}
{"task_id": "Java/127", "generation": "import java.util.*;\n\nclass Solution {\n    // Helper method to check if a number is prime\n    private boolean isPrime(int num) {\n        if (num == 1 || num == 0) {\n            return false;\n        }\n        if (num == 2) {\n            return true;\n        }\n        for (int i = 2; i < num; i++) {\n            if (num % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public String intersection(List<Integer> interval1, List<Integer> interval2) {\n        int l = Math.max(interval1.get(0), interval2.get(0));\n        int r = Math.min(interval1.get(1), interval2.get(1));\n        int length = r - l;\n        if (length > 0 && isPrime(length)) {\n            return \"YES\";\n        }\n        return \"NO\";\n    }\n}\n", "py_code": "def intersection(interval1, interval2):\n    def is_prime(num):\n        if num == 1 or num == 0:\n            return False\n        if num == 2:\n            return True\n        for i in range(2, num):\n            if num%i == 0:\n                return False\n        return True\n\n    l = max(interval1[0], interval2[0])\n    r = min(interval1[1], interval2[1])\n    length = r - l\n    if length > 0 and is_prime(length):\n        return \"YES\"\n    return \"NO\"\n", "py_summary": "The Python code defines a function `intersection` that takes two intervals as input, represented as lists of integers. It also defines a helper function `is_prime` to check if a number is prime. \n\nWithin the `intersection` function, it calculates the intersection of the two intervals by finding the maximum of the start points and the minimum of the end points. It then calculates the length of the intersection. If the length is greater than 0 and is a prime number, it returns \"YES\"; otherwise, it returns \"NO\"."}
{"task_id": "Java/128", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public Optional<Integer> prod_signs(List<Integer> arr) {\n        if (arr.isEmpty()) {\n            return Optional.empty();\n        }\n        \n        int prod = 0;\n        if (arr.contains(0)) {\n            prod = 0;\n        } else {\n            int negativeCount = 0;\n            for (int num : arr) {\n                if (num < 0) {\n                    negativeCount++;\n                }\n            }\n            prod = (int) Math.pow(-1, negativeCount);\n        }\n        \n        int sum = 0;\n        for (int num : arr) {\n            sum += Math.abs(num);\n        }\n        \n        return Optional.of(prod * sum);\n    }\n}\n", "py_code": "def prod_signs(arr):\n    if not arr: return None\n    prod = 0 if 0 in arr else (-1) ** len(list(filter(lambda x: x < 0, arr)))\n    return prod * sum([abs(i) for i in arr])\n", "py_summary": "The Python code defines a function that takes a list of integers as input and calculates the sum of the magnitudes of the integers multiplied by the product of all the signs of each number in the array. If the input list is empty, the function returns None. \n\nThe function first checks if the input list is empty, and if so, returns None. It then calculates the product of signs by checking if 0 is present in the list (resulting in 0) or by calculating (-1) raised to the power of the count of negative numbers in the list. \n\nNext, it calculates the sum of the magnitudes of the integers in the list by taking the absolute value of each integer and summing them up. Finally, it returns the product of signs multiplied by the sum of magnitudes."}
{"task_id": "Java/129", "generation": "import java.util.*;\n\nclass Solution {\n    public List<Integer> minPath(List<List<Integer>> grid, int k) {\n        int n = grid.size();\n        int[][] directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n        int[][] visited = new int[n][n];\n        List<Integer> path = new ArrayList<>();\n        \n        int row = 0, col = 0;\n        while (k > 0) {\n            path.add(grid.get(row).get(col));\n            visited[row][col] = 1;\n            int nextRow = -1, nextCol = -1;\n            int minVal = Integer.MAX_VALUE;\n            \n            for (int[] dir : directions) {\n                int newRow = row + dir[0];\n                int newCol = col + dir[1];\n                if (newRow >= 0 && newRow < n && newCol >= 0 && newCol < n && visited[newRow][newCol] == 0) {\n                    if (grid.get(newRow).get(newCol) < minVal) {\n                        minVal = grid.get(newRow).get(newCol);\n                        nextRow = newRow;\n                        nextCol = newCol;\n                    }\n                }\n            }\n            row = nextRow;\n            col = nextCol;\n            k--;\n        }\n        \n        return path;\n    }\n}\n", "py_code": "def minPath(grid, k):\n    n = len(grid)\n    val = n * n + 1\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                temp = []\n                if i != 0:\n                    temp.append(grid[i - 1][j])\n\n                if j != 0:\n                    temp.append(grid[i][j - 1])\n\n                if i != n - 1:\n                    temp.append(grid[i + 1][j])\n\n                if j != n - 1:\n                    temp.append(grid[i][j + 1])\n\n                val = min(temp)\n\n    ans = []\n    for i in range(k):\n        if i % 2 == 0:\n            ans.append(1)\n        else:\n            ans.append(val)\n    return ans\n", "py_summary": "The Python code defines a function `minPath` that takes a grid (2D list) and an integer `k` as input and returns an ordered list of values on the cells that the minimum path goes through. The function iterates through the grid to find the minimum value among the neighboring cells of the cell with value 1. It then constructs the path based on the minimum value found and the length `k`.\n\n1. It initializes the variable `val` to a value greater than the maximum possible value in the grid.\n2. It iterates through the grid to find the cell with value 1 and calculates the minimum value among its neighboring cells.\n3. It constructs the path by alternating between values 1 and the minimum value found based on the index.\n4. Finally, it returns the ordered list of values representing the minimum path.\n\nThe code logic is incorrect as it does not correctly find the minimum path based on the given conditions in the problem statement. The correct approach should involve finding the minimum path based on lexicographical order and not just the minimum value among neighboring cells."}
{"task_id": "Java/130", "generation": "import java.util.*;\n\nclass Solution {\n    public List<Integer> tri(int n) {\n        List<Integer> tribonacci = new ArrayList<>();\n        if (n == 0) {\n            tribonacci.add(1);\n            return tribonacci;\n        }\n        tribonacci.add(1);\n        tribonacci.add(3);\n        for (int i = 2; i <= n; i++) {\n            if (i % 2 == 0) {\n                tribonacci.add(i / 2 + 1);\n            } else {\n                tribonacci.add(tribonacci.get(i - 1) + tribonacci.get(i - 2) + (i + 3) / 2);\n            }\n        }\n        return tribonacci;\n    }\n}\n", "py_code": "def tri(n):\n    if n == 0:\n        return [1]\n    my_tri = [1, 3]\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            my_tri.append(i / 2 + 1)\n        else:\n            my_tri.append(my_tri[i - 1] + my_tri[i - 2] + (i + 3) / 2)\n    return my_tri\n", "py_summary": "The Python code defines a function `tri(n)` that calculates the Tribonacci sequence up to the (n+1)-th number and returns a list of these numbers. The function initializes the sequence with the first two elements `[1, 3]`. It then iterates from index 2 to n and calculates the next element based on the given recurrence rules for even and odd indices.\n\n- For even indices, the element is calculated as `(i / 2) + 1`.\n- For odd indices, the element is calculated as the sum of the previous two elements and the next element `(i + 3) / 2`.\n\nThe function returns the list of Tribonacci numbers up to the (n+1)-th element."}
{"task_id": "Java/131", "generation": "import java.util.*;\n\nclass Solution {\n    public int digits(int n) {\n        int product = 1;\n        int oddCount = 0;\n        String numStr = String.valueOf(n);\n        \n        for (int i = 0; i < numStr.length(); i++) {\n            int digit = Character.getNumericValue(numStr.charAt(i));\n            if (digit % 2 == 1) {\n                product *= digit;\n                oddCount++;\n            }\n        }\n        \n        if (oddCount == 0) {\n            return 0;\n        } else {\n            return product;\n        }\n    }\n}\n", "py_code": "def digits(n):\n    product = 1\n    odd_count = 0\n    for digit in str(n):\n        int_digit = int(digit)\n        if int_digit%2 == 1:\n            product= product*int_digit\n            odd_count+=1\n    if odd_count ==0:\n        return 0\n    else:\n        return product\n", "py_summary": "The Python code defines a function that takes a positive integer `n` as input and calculates the product of the odd digits present in the integer. It initializes variables `product` to 1 and `odd_count` to 0 to keep track of the product of odd digits and the count of odd digits encountered.\n\nThe function then iterates through each digit in the integer by converting it to a string. For each digit, it converts it back to an integer and checks if it is odd (i.e., not divisible by 2). If the digit is odd, it multiplies it with the current product and increments the odd_count.\n\nAfter processing all digits, if no odd digits were encountered (odd_count is 0), the function returns 0. Otherwise, it returns the calculated product of odd digits.\n\nNow, let's write the Java solution based on this Python solution and the analysis."}
{"task_id": "Java/132", "generation": "import java.util.*;\n\nclass Solution {\n    public boolean is_nested(String string) {\n        List<Integer> openingBracketIndex = new ArrayList<>();\n        List<Integer> closingBracketIndex = new ArrayList<>();\n        \n        for (int i = 0; i < string.length(); i++) {\n            if (string.charAt(i) == '[') {\n                openingBracketIndex.add(i);\n            } else {\n                closingBracketIndex.add(i);\n            }\n        }\n        \n        Collections.reverse(closingBracketIndex);\n        \n        int count = 0;\n        int i = 0;\n        int l = closingBracketIndex.size();\n        \n        for (int idx : openingBracketIndex) {\n            if (i < l && idx < closingBracketIndex.get(i)) {\n                count++;\n                i++;\n            }\n        }\n        \n        return count >= 2;\n    }\n}\n", "py_code": "def is_nested(string):\n    opening_bracket_index = []\n    closing_bracket_index = []\n    for i in range(len(string)):\n        if string[i] == '[':\n            opening_bracket_index.append(i)\n        else:\n            closing_bracket_index.append(i)\n    closing_bracket_index.reverse()\n    cnt = 0\n    i = 0\n    l = len(closing_bracket_index)\n    for idx in opening_bracket_index:\n        if i < l and idx < closing_bracket_index[i]:\n            cnt += 1\n            i += 1\n    return cnt >= 2\n\n    \n", "py_summary": "The Python code defines a function that takes a string containing only square brackets as input and determines if there is a valid subsequence of brackets where at least one bracket is nested. The function iterates through the string and stores the indices of opening and closing brackets separately. It then reverses the list of indices of closing brackets.\n\nNext, the code initializes a counter variable `cnt` to keep track of the number of nested brackets found and iterates through the opening bracket indices. For each opening bracket index, it checks if there is a corresponding closing bracket index that is positioned after the opening bracket index. If such a pair is found, the counter is incremented.\n\nFinally, the function returns `True` if the number of nested brackets found is greater than or equal to 2, indicating the presence of at least one nested bracket subsequence.\n\nThe logic behind the code is to identify pairs of opening and closing brackets where the closing bracket is positioned after the opening bracket, indicating nesting."}
{"task_id": "Java/133", "generation": "import java.util.*;\n\nclass Solution {\n    public int sum_squares(List<Double> lst) {\n        int squared = 0;\n        for (double num : lst) {\n            squared += Math.ceil(num) * Math.ceil(num);\n        }\n        return squared;\n    }\n}\n", "py_code": "def sum_squares(lst):\n    import math\n    squared = 0\n    for i in lst:\n        squared += math.ceil(i)**2\n    return squared\n", "py_summary": "The Python code defines a function that takes a list of numbers as input, rounds each number to the nearest integer towards positive infinity (ceiling), squares the rounded number, and then calculates the sum of all squared numbers in the list. \n\n1. It imports the math module to use the `ceil` function for rounding up to the nearest integer.\n2. It initializes a variable `squared` to keep track of the sum of squared numbers.\n3. It iterates through each element in the input list, rounds the element to the nearest integer using `math.ceil`, squares the rounded number, and adds it to the `squared` variable.\n4. Finally, it returns the total sum of squared numbers in the list."}
{"task_id": "Java/134", "generation": "import java.util.*;\n\nclass Solution {\n    public boolean check_if_last_char_is_a_letter(String txt) {\n        String[] words = txt.split(\" \");\n        if (words.length == 0) {\n            return false;\n        }\n        String lastWord = words[words.length - 1];\n        if (lastWord.length() == 1 && Character.isLetter(lastWord.charAt(0))) {\n            return true;\n        }\n        return false;\n    }\n}\n", "py_code": "def check_if_last_char_is_a_letter(txt):\n \n    check = txt.split(' ')[-1]\n    return True if len(check) == 1 and (97 <= ord(check.lower()) <= 122) else False\n", "py_summary": "The Python code defines a function that takes a string as input and checks if the last character of the string is an alphabetical character and not part of a word (i.e., separated by a space). \n\n1. It splits the input string by spaces and selects the last element (which is the last word in the string).\n2. It then checks if the length of the last word is 1 (i.e., a single character) and if that character is an alphabetical character by comparing its ASCII value.\n3. If the above conditions are met, it returns True; otherwise, it returns False."}
{"task_id": "Java/135", "generation": "import java.util.*;\n\nclass Solution {\n    public int can_arrange(List<Integer> arr) {\n        int ind = -1;\n        for (int i = 1; i < arr.size(); i++) {\n            if (arr.get(i) < arr.get(i - 1)) {\n                ind = i;\n            }\n        }\n        return ind;\n    }\n}\n", "py_code": "def can_arrange(arr):\n    ind=-1\n    i=1\n    while i<len(arr):\n      if arr[i]<arr[i-1]:\n        ind=i\n      i+=1\n    return ind\n", "py_summary": "The Python code defines a function that takes a list of integers as input and returns the largest index of an element that is not greater than or equal to the element immediately preceding it. If no such element exists, it returns -1. The function initializes the index variable `ind` to -1 and iterates through the list starting from the second element. \n\nFor each element, it compares it with the previous element. If the current element is less than the previous element, it updates the `ind` variable to the current index. Finally, the function returns the index of the last element that satisfies the condition or -1 if no such element exists."}
{"task_id": "Java/136", "generation": "import java.util.*;\n\nclass Solution {\n    public List<Optional<Integer>> largest_smallest_integers(List<Integer> lst) {\n        List<Optional<Integer>> result = new ArrayList<>();\n        List<Integer> smallest = new ArrayList<>();\n        List<Integer> largest = new ArrayList<>();\n\n        for (Integer num : lst) {\n            if (num < 0) {\n                smallest.add(num);\n            } else if (num > 0) {\n                largest.add(num);\n            }\n        }\n\n        if (smallest.isEmpty()) {\n            result.add(Optional.empty());\n        } else {\n            result.add(Optional.of(Collections.max(smallest)));\n        }\n\n        if (largest.isEmpty()) {\n            result.add(Optional.empty());\n        } else {\n            result.add(Optional.of(Collections.min(largest)));\n        }\n\n        return result;\n    }\n}\n", "py_code": "def largest_smallest_integers(lst):\n    smallest = list(filter(lambda x: x < 0, lst))\n    largest = list(filter(lambda x: x > 0, lst))\n    return (max(smallest) if smallest else None, min(largest) if largest else None)\n", "py_summary": "The Python code defines a function that takes a list of integers as input and returns a tuple containing the largest negative integer and the smallest positive integer in the list. It first filters the list to separate negative and positive integers. Then, it returns the maximum of the negative integers if there are any, and the minimum of the positive integers if there are any. If there are no negative or positive integers, it returns None for both values."}
{"task_id": "Java/137", "generation": "import java.util.*;\n\nclass Solution {\n    public Optional<Object> compare_one(Object a, Object b) {\n        String temp_a = a.toString();\n        String temp_b = b.toString();\n        \n        if (temp_a.contains(\",\")) {\n            temp_a = temp_a.replace(\",\", \".\");\n        }\n        if (temp_b.contains(\",\")) {\n            temp_b = temp_b.replace(\",\", \".\");\n        }\n        \n        double val_a = Double.parseDouble(temp_a);\n        double val_b = Double.parseDouble(temp_b);\n        \n        if (val_a == val_b) {\n            return Optional.empty();\n        } else {\n            if (val_a > val_b) {\n                if (a instanceof Integer) {\n                    return Optional.of((int) val_a);\n                } else if (a instanceof Float) {\n                    return Optional.of((float) val_a);\n                } else {\n                    return Optional.of(temp_a);\n                }\n            } else {\n                if (b instanceof Integer) {\n                    return Optional.of((int) val_b);\n                } else if (b instanceof Float) {\n                    return Optional.of((float) val_b);\n                } else {\n                    return Optional.of(temp_b);\n                }\n            }\n        }\n    }\n}\n", "py_code": "def compare_one(a, b):\n    temp_a, temp_b = a, b\n    if isinstance(temp_a, str): temp_a = temp_a.replace(',','.')\n    if isinstance(temp_b, str): temp_b = temp_b.replace(',','.')\n    if float(temp_a) == float(temp_b): return None\n    return a if float(temp_a) > float(temp_b) else b \n", "py_summary": "The Python code defines a function `compare_one` that takes two inputs `a` and `b`, which can be integers, floats, or strings representing real numbers. The function first creates temporary variables `temp_a` and `temp_b` to store the modified versions of `a` and `b` if they are strings (replacing ',' with '.'). \n\nThen, the function checks if the modified values of `a` and `b` are equal as floats. If they are equal, the function returns `None`. Otherwise, it compares the values and returns the larger variable in its original variable type."}
{"task_id": "Java/138", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public boolean is_equal_to_sum_even(int n) {\n        return n % 2 == 0 && n >= 8;\n    }\n}\n", "py_code": "def is_equal_to_sum_even(n):\n    return n%2 == 0 and n >= 8\n", "py_summary": "The Python code defines a function that evaluates whether a given number `n` can be written as the sum of exactly 4 positive even numbers. The function returns `True` if the number is even and greater than or equal to 8, which ensures that it can be expressed as the sum of 4 positive even numbers. Otherwise, it returns `False`."}
{"task_id": "Java/139", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public long special_factorial(int n) {\n        long fact_i = 1;\n        long special_fact = 1;\n        for (int i = 1; i <= n; i++) {\n            fact_i *= i;\n            special_fact *= fact_i;\n        }\n        return special_fact;\n    }\n}\n", "py_code": "def special_factorial(n):\n    fact_i = 1\n    special_fact = 1\n    for i in range(1, n+1):\n        fact_i *= i\n        special_fact *= fact_i\n    return special_fact\n", "py_summary": "The Python code defines a function `special_factorial` that calculates the special factorial of a given integer `n`. The special factorial is calculated as the product of factorials of numbers from `n` down to 1. \n\nThe function initializes two variables `fact_i` and `special_fact` to 1. It then iterates from 1 to `n`, updating `fact_i` in each iteration by multiplying it with the current number `i`. The `special_fact` is updated by multiplying it with the current value of `fact_i`. \n\nFinally, the function returns the calculated special factorial value."}
{"task_id": "Java/140", "generation": "import java.util.*;\n\nclass Solution {\n    public String fix_spaces(String text) {\n        StringBuilder new_text = new StringBuilder();\n        int start = 0;\n        int end = 0;\n        for (int i = 0; i < text.length(); i++) {\n            if (text.charAt(i) == ' ') {\n                end++;\n            } else {\n                if (end - start > 2) {\n                    new_text.append(\"-\");\n                    new_text.append(text.charAt(i));\n                } else if (end - start > 0) {\n                    for (int j = 0; j < end - start; j++) {\n                        new_text.append(\"_\");\n                    }\n                    new_text.append(text.charAt(i));\n                } else {\n                    new_text.append(text.charAt(i));\n                }\n                start = i + 1;\n                end = i + 1;\n            }\n        }\n        if (end - start > 2) {\n            new_text.append(\"-\");\n        } else if (end - start > 0) {\n            for (int j = 0; j < end - start; j++) {\n                new_text.append(\"_\");\n            }\n        }\n        return new_text.toString();\n    }\n}\n", "py_code": "def fix_spaces(text):\n    new_text = \"\"\n    i = 0\n    start, end = 0, 0\n    while i < len(text):\n        if text[i] == \" \":\n            end += 1\n        else:\n            if end - start > 2:\n                new_text += \"-\"+text[i]\n            elif end - start > 0:\n                new_text += \"_\"*(end - start)+text[i]\n            else:\n                new_text += text[i]\n            start, end = i+1, i+1\n        i+=1\n    if end - start > 2:\n        new_text += \"-\"\n    elif end - start > 0:\n        new_text += \"_\"\n    return new_text\n", "py_summary": "The Python code defines a function `fix_spaces` that takes a string `text` as input and replaces spaces in the text according to the given conditions. It iterates through the characters of the input text and keeps track of the start and end indices of consecutive spaces. \n\n- If the number of consecutive spaces is more than 2, it replaces all consecutive spaces with a single hyphen `-` followed by the current character.\n- If the number of consecutive spaces is between 1 and 2, it replaces them with underscores `_` followed by the current character.\n- If there are no consecutive spaces, it simply appends the current character to the new text.\n\nThe function then handles the case where the last characters in the text are consecutive spaces and appends the appropriate character(s) to the new text. Finally, it returns the modified text with spaces replaced as per the given conditions."}
{"task_id": "Java/141", "generation": "import java.util.*;\n\nclass Solution {\n    public String file_name_check(String file_name) {\n        String[] validExtensions = {\"txt\", \"exe\", \"dll\"};\n        String[] parts = file_name.split(\"\\\\.\");\n        \n        if (parts.length != 2) {\n            return \"No\";\n        }\n        \n        String fileName = parts[0];\n        String fileExtension = parts[1];\n        \n        if (!Arrays.asList(validExtensions).contains(fileExtension)) {\n            return \"No\";\n        }\n        \n        if (fileName.isEmpty() || !Character.isLetter(fileName.charAt(0))) {\n            return \"No\";\n        }\n        \n        int digitCount = 0;\n        for (char c : fileName.toCharArray()) {\n            if (Character.isDigit(c)) {\n                digitCount++;\n            }\n        }\n        \n        if (digitCount > 3) {\n            return \"No\";\n        }\n        \n        return \"Yes\";\n    }\n}\n", "py_code": "def file_name_check(file_name):\n    suf = ['txt', 'exe', 'dll']\n    lst = file_name.split(sep='.')\n    if len(lst) != 2:\n        return 'No'\n    if not lst[1] in suf:\n        return 'No'\n    if len(lst[0]) == 0:\n        return 'No'\n    if not lst[0][0].isalpha():\n        return 'No'\n    t = len([x for x in lst[0] if x.isdigit()])\n    if t > 3:\n        return 'No'\n    return 'Yes'\n", "py_summary": "The Python code defines a function `file_name_check` that takes a file name as input and checks if the file name is valid based on certain conditions. It first splits the file name into two parts using the dot separator. Then, it checks if the split results in exactly two parts. If not, it returns \"No\".\n\nNext, it checks if the second part (file extension) is one of the valid extensions 'txt', 'exe', or 'dll'. If not, it returns \"No\". Then, it checks if the first part (file name) is not empty and starts with a letter from the Latin alphabet. If not, it returns \"No\".\n\nFinally, it counts the number of digits in the first part and checks if it exceeds three. If it does, it returns \"No\". If all conditions are met, it returns \"Yes\" indicating that the file name is valid.\n\nThe function essentially validates a file name based on the specified criteria and returns \"Yes\" if it is valid, and \"No\" otherwise."}
{"task_id": "Java/142", "generation": "import java.util.*;\n\nclass Solution {\n    public int sum_squares(List<Integer> lst) {\n        List<Integer> result = new ArrayList<>();\n        for (int i = 0; i < lst.size(); i++) {\n            if (i % 3 == 0) {\n                result.add((int) Math.pow(lst.get(i), 2));\n            } else if (i % 4 == 0 && i % 3 != 0) {\n                result.add((int) Math.pow(lst.get(i), 3));\n            } else {\n                result.add(lst.get(i));\n            }\n        }\n        int sum = 0;\n        for (int num : result) {\n            sum += num;\n        }\n        return sum;\n    }\n}\n", "py_code": "def sum_squares(lst):\n    \"\n    result =[]\n    for i in range(len(lst)):\n        if i %3 == 0:\n            result.append(lst[i]**2)\n        elif i % 4 == 0 and i%3 != 0:\n            result.append(lst[i]**3)\n        else:\n            result.append(lst[i])\n    return sum(result)\n", "py_summary": "The Python code defines a function that takes a list of integers as input. It then iterates through the list and checks the index of each element. If the index is a multiple of 3, it squares the integer element. If the index is a multiple of 4 but not a multiple of 3, it cubes the integer element. Otherwise, it keeps the integer element unchanged. Finally, the function returns the sum of all the modified elements in the list."}
{"task_id": "Java/143", "generation": "import java.util.*;\n\nclass Solution {\n    public String words_in_sentence(String sentence) {\n        List<String> newWords = new ArrayList<>();\n        for (String word : sentence.split(\" \")) {\n            if (isPrime(word.length())) {\n                newWords.add(word);\n            }\n        }\n        return String.join(\" \", newWords);\n    }\n    \n    private boolean isPrime(int num) {\n        if (num <= 1) {\n            return false;\n        }\n        for (int i = 2; i <= Math.sqrt(num); i++) {\n            if (num % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n", "py_code": "def words_in_sentence(sentence):\n    new_lst = []\n    for word in sentence.split():\n        flg = 0\n        if len(word) == 1:\n            flg = 1\n        for i in range(2, len(word)):\n            if len(word)%i == 0:\n                flg = 1\n        if flg == 0 or len(word) == 2:\n            new_lst.append(word)\n    return \" \".join(new_lst)\n", "py_summary": "The Python code defines a function that takes a sentence as input and returns a new string containing only the words from the original sentence whose lengths are prime numbers. The function iterates through each word in the sentence by splitting it based on spaces. For each word, it checks if the length of the word is a prime number. To determine if a number is prime, the code checks if the length of the word is divisible by any number other than 1 and itself. If the length is a prime number, the word is added to a new list. Finally, the function returns a string created by joining the words in the new list with spaces."}
{"task_id": "Java/144", "generation": "import java.util.*;\n\nclass Solution {\n    public boolean simplify(String x, String n) {\n        String[] xParts = x.split(\"/\");\n        String[] nParts = n.split(\"/\");\n        \n        int num1 = Integer.parseInt(xParts[0]);\n        int den1 = Integer.parseInt(xParts[1]);\n        int num2 = Integer.parseInt(nParts[0]);\n        int den2 = Integer.parseInt(nParts[1]);\n        \n        int numerator = num1 * num2;\n        int denominator = den1 * den2;\n        \n        if (numerator % denominator == 0) {\n            return true;\n        }\n        return false;\n    }\n}\n", "py_code": "def simplify(x, n):\n    a, b = x.split(\"/\")\n    c, d = n.split(\"/\")\n    numerator = int(a) * int(c)\n    denom = int(b) * int(d)\n    if (numerator/denom == int(numerator/denom)):\n        return True\n    return False\n", "py_summary": "The Python code defines a function that takes two fractions as input and checks if the product of the two fractions results in a whole number. It first splits the input fractions into numerator and denominator parts. Then, it calculates the product of the numerators and denominators. If the division of the product numerator by the product denominator results in an integer value, it returns True, indicating that the product is a whole number. Otherwise, it returns False."}
{"task_id": "Java/145", "generation": "import java.util.*;\n\nclass Solution {\n    public List<Integer> order_by_points(List<Integer> nums) {\n        Collections.sort(nums, new Comparator<Integer>() {\n            @Override\n            public int compare(Integer num1, Integer num2) {\n                int sum1 = getDigitsSum(num1);\n                int sum2 = getDigitsSum(num2);\n                if (sum1 == sum2) {\n                    return nums.indexOf(num1) - nums.indexOf(num2);\n                }\n                return sum1 - sum2;\n            }\n        });\n        return nums;\n    }\n\n    private int getDigitsSum(int n) {\n        int neg = 1;\n        if (n < 0) {\n            n = -1 * n;\n            neg = -1;\n        }\n        String numStr = String.valueOf(n);\n        int sum = 0;\n        for (char c : numStr.toCharArray()) {\n            sum += Character.getNumericValue(c);\n        }\n        return sum * neg;\n    }\n}\n", "py_code": "def order_by_points(nums):\n    def digits_sum(n):\n        neg = 1\n        if n < 0: n, neg = -1 * n, -1 \n        n = [int(i) for i in str(n)]\n        n[0] = n[0] * neg\n        return sum(n)\n    return sorted(nums, key=digits_sum)\n", "py_summary": "The Python code defines a function `order_by_points` that takes a list of integers as input and sorts them in ascending order based on the sum of their digits. The function first defines a nested function `digits_sum` that calculates the sum of digits of a given integer. If the integer is negative, it considers the first digit as negative. \n\nThe `order_by_points` function then uses the `sorted` function with a custom key function `digits_sum` to sort the input list of integers based on the sum of their digits. The sorted list is returned as the output."}
{"task_id": "Java/146", "generation": "import java.util.*;\n\nclass Solution {\n    public int specialFilter(List<Integer> nums) {\n        int count = 0;\n        for (int num : nums) {\n            if (num > 10) {\n                if (isFirstAndLastDigitsOdd(num)) {\n                    count++;\n                }\n            }\n        }\n        return count;\n    }\n    \n    private boolean isFirstAndLastDigitsOdd(int num) {\n        String numStr = String.valueOf(num);\n        int firstDigit = Character.getNumericValue(numStr.charAt(0));\n        int lastDigit = Character.getNumericValue(numStr.charAt(numStr.length() - 1));\n        return (firstDigit % 2 != 0) && (lastDigit % 2 != 0);\n    }\n}\n", "py_code": "def specialFilter(nums):\n    \n    count = 0\n    for num in nums:\n        if num > 10:\n            odd_digits = (1, 3, 5, 7, 9)\n            number_as_string = str(num)\n            if int(number_as_string[0]) in odd_digits and int(number_as_string[-1]) in odd_digits:\n                count += 1\n        \n    return count \n", "py_summary": "The Python code defines a function `specialFilter` that takes a list of integers as input and returns the number of elements in the list that are greater than 10 and have both the first and last digits as odd numbers (1, 3, 5, 7, 9). \n\nThe function initializes a counter variable `count` to keep track of the number of elements that satisfy the condition. It then iterates through each number in the input list. For each number, it checks if the number is greater than 10. If it is, it extracts the first and last digits of the number by converting it to a string and then back to an integer. It then checks if both the first and last digits are odd numbers. If both conditions are met, it increments the `count` variable.\n\nFinally, the function returns the total count of numbers that satisfy the given conditions."}
{"task_id": "Java/147", "generation": "import java.util.*;\n\nclass Solution {\n    public int get_max_triples(int n) {\n        int[] A = new int[n];\n        for (int i = 0; i < n; i++) {\n            A[i] = i * i - i + 1;\n        }\n        \n        List<int[]> ans = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                for (int k = j + 1; k < n; k++) {\n                    if ((A[i] + A[j] + A[k]) % 3 == 0) {\n                        ans.add(new int[]{A[i], A[j], A[k]});\n                    }\n                }\n            }\n        }\n        \n        return ans.size();\n    }\n}\n", "py_code": "def get_max_triples(n):\n    A = [i*i - i + 1 for i in range(1,n+1)]\n    ans = []\n    for i in range(n):\n        for j in range(i+1,n):\n            for k in range(j+1,n):\n                if (A[i]+A[j]+A[k])%3 == 0:\n                    ans += [(A[i],A[j],A[k])]\n    return len(ans)\n", "py_summary": "The Python code defines a function `get_max_triples` that takes a positive integer `n` as input and creates an array `A` of length `n` where each element is calculated as `i*i - i + 1` for `i` ranging from 1 to `n`. It then initializes an empty list `ans` to store the valid triples. \n\nThe function then iterates through all possible combinations of indices `i`, `j`, and `k` (ensuring `i < j < k`) and checks if the sum of the corresponding elements in array `A` is a multiple of 3. If it is, the triple `(A[i], A[j], A[k])` is added to the `ans` list. Finally, the function returns the count of valid triples found."}
{"task_id": "Java/148", "generation": "import java.util.*;\n\nclass Solution {\n    public List<String> bf(String planet1, String planet2) {\n        String[] planetNames = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n        List<String> result = new ArrayList<>();\n        \n        if (!Arrays.asList(planetNames).contains(planet1) || !Arrays.asList(planetNames).contains(planet2) || planet1.equals(planet2)) {\n            return result;\n        }\n        \n        int planet1Index = Arrays.asList(planetNames).indexOf(planet1);\n        int planet2Index = Arrays.asList(planetNames).indexOf(planet2);\n        \n        if (planet1Index < planet2Index) {\n            for (int i = planet1Index + 1; i < planet2Index; i++) {\n                result.add(planetNames[i]);\n            }\n        } else {\n            for (int i = planet2Index + 1; i < planet1Index; i++) {\n                result.add(planetNames[i]);\n            }\n        }\n        \n        return result;\n    }\n}\n", "py_code": "def bf(planet1, planet2):\n    planet_names = (\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n    if planet1 not in planet_names or planet2 not in planet_names or planet1 == planet2:\n        return ()\n    planet1_index = planet_names.index(planet1)\n    planet2_index = planet_names.index(planet2)\n    if planet1_index < planet2_index:\n        return (planet_names[planet1_index + 1: planet2_index])\n    else:\n        return (planet_names[planet2_index + 1 : planet1_index])\n", "py_summary": "The Python code defines a function `bf` that takes two planet names as input and returns a tuple containing the planets whose orbits are located between the orbits of the two input planets. The function first defines a tuple `planet_names` containing the names of all eight planets in the solar system. \n\nIt then checks if the input planet names are valid (i.e., present in the `planet_names` tuple) and if they are not the same planet. If the input planet names are valid, it determines the indices of the two planets in the `planet_names` tuple. \n\nBased on the indices, the function extracts the planets located between the orbits of the two input planets and returns them in a tuple. If the first planet is located after the second planet in the solar system, the function adjusts the order of extraction to ensure correct ordering of planets. If the input planet names are not valid or the same, an empty tuple is returned."}
{"task_id": "Java/149", "generation": "import java.util.*;\n\nclass Solution {\n    public List<String> sorted_list_sum(List<String> lst) {\n        lst.sort((a, b) -> {\n            if (a.length() % 2 != 0 && b.length() % 2 == 0) {\n                return 1;\n            } else if (a.length() % 2 == 0 && b.length() % 2 != 0) {\n                return -1;\n            } else {\n                return a.compareTo(b);\n            }\n        });\n\n        List<String> result = new ArrayList<>();\n        for (String str : lst) {\n            if (str.length() % 2 == 0) {\n                result.add(str);\n            }\n        }\n\n        return result;\n    }\n}\n", "py_code": "def sorted_list_sum(lst):\n    lst.sort()\n    new_lst = []\n    for i in lst:\n        if len(i)%2 == 0:\n            new_lst.append(i)\n    return sorted(new_lst, key=len)\n", "py_summary": "The Python code defines a function that takes a list of strings as input, filters out the strings with odd lengths, and returns a new list containing the filtered strings sorted first by length and then alphabetically if the lengths are the same. \n\n1. The function first sorts the input list of strings in ascending order.\n2. It then initializes an empty list `new_lst` to store the filtered strings.\n3. It iterates through each string in the input list and checks if the length of the string is even (i.e., length % 2 == 0). If the length is even, the string is appended to the `new_lst`.\n4. Finally, the function returns the `new_lst` sorted first by length and then alphabetically.\n\nThe function effectively filters out strings with odd lengths and returns a sorted list of strings with even lengths, following the specified sorting rules."}
{"task_id": "Java/150", "generation": "import java.util.*;\n\nclass Solution {\n    public int x_or_y(int n, int x, int y) {\n        if (n == 1) {\n            return y;\n        }\n        for (int i = 2; i < n; i++) {\n            if (n % i == 0) {\n                return y;\n            }\n        }\n        return x;\n    }\n}\n", "py_code": "def x_or_y(n, x, y):\n    if n == 1:\n        return y\n    for i in range(2, n):\n        if n % i == 0:\n            return y\n            break\n    else:\n        return x\n", "py_summary": "The Python code defines a function that takes three integers as input: n, x, and y. The function checks if n is a prime number or not. If n is equal to 1, it returns the value of y. Otherwise, it iterates from 2 to n-1 and checks if n is divisible by any number in that range. If n is divisible by any number, it returns the value of y. If no number divides n, then n is a prime number, and the function returns the value of x."}
{"task_id": "Java/151", "generation": "import java.util.*;\n\nclass Solution {\n    public int double_the_difference(List<Object> lst) {\n        int sum = 0;\n        for (Object num : lst) {\n            if (num instanceof Integer) {\n                int n = (int) num;\n                if (n > 0 && n % 2 != 0) {\n                    sum += n * n;\n                }\n            }\n        }\n        return sum;\n    }\n}\n", "py_code": "def double_the_difference(lst):\n    return sum([i**2 for i in lst if i > 0 and i%2!=0 and \".\" not in str(i)])\n", "py_summary": "The Python code defines a function that takes a list of numbers as input and calculates the sum of squares of the numbers that are odd, positive integers. It filters out numbers that are negative or not integers by checking if the number is greater than 0, odd, and does not contain a decimal point. For each valid number, it squares the number and adds it to a list comprehension. Finally, it returns the sum of the squared odd numbers."}
{"task_id": "Java/152", "generation": "import java.util.*;\n\nclass Solution {\n    public List<Integer> compare(List<Integer> game, List<Integer> guess) {\n        List<Integer> differences = new ArrayList<>();\n        for (int i = 0; i < game.size(); i++) {\n            differences.add(Math.abs(game.get(i) - guess.get(i)));\n        }\n        return differences;\n    }\n}\n", "py_code": "def compare(game,guess):\n    return [abs(x-y) for x,y in zip(game,guess)]\n", "py_summary": "The Python code defines a function that takes two lists (`game` and `guess`) as input, where each list represents the scores and guesses for a series of matches. The function then uses a list comprehension along with the `zip` function to iterate through both lists simultaneously. For each pair of elements at the same index in the `game` and `guess` lists, it calculates the absolute difference between the two elements and creates a new list containing these absolute differences. Finally, the function returns the list of absolute differences."}
{"task_id": "Java/153", "generation": "import java.util.*;\n\nclass Solution {\n    public String Strongest_Extension(String class_name, List<String> extensions) {\n        String strongest = extensions.get(0);\n        int myVal = countStrength(extensions.get(0));\n        \n        for (String s : extensions) {\n            int val = countStrength(s);\n            if (val > myVal) {\n                strongest = s;\n                myVal = val;\n            }\n        }\n        \n        return class_name + \".\" + strongest;\n    }\n    \n    private int countStrength(String extension) {\n        int upperCount = 0;\n        int lowerCount = 0;\n        \n        for (char c : extension.toCharArray()) {\n            if (Character.isLetter(c)) {\n                if (Character.isUpperCase(c)) {\n                    upperCount++;\n                } else {\n                    lowerCount++;\n                }\n            }\n        }\n        \n        return upperCount - lowerCount;\n    }\n}\n", "py_code": "def Strongest_Extension(class_name, extensions):\n    strong = extensions[0]\n    my_val = len([x for x in extensions[0] if x.isalpha() and x.isupper()]) - len([x for x in extensions[0] if x.isalpha() and x.islower()])\n    for s in extensions:\n        val = len([x for x in s if x.isalpha() and x.isupper()]) - len([x for x in s if x.isalpha() and x.islower()])\n        if val > my_val:\n            strong = s\n            my_val = val\n\n    ans = class_name + \".\" + strong\n    return ans\n\n", "py_summary": "The Python code defines a function `Strongest_Extension` that takes the class name and a list of extensions as input and returns the strongest extension in the format \"ClassName.Strongest_Extension\". The function initializes the strongest extension as the first extension in the list and calculates its strength based on the number of uppercase and lowercase letters in the extension's name.\n\nIt then iterates through the list of extensions, calculates the strength for each extension, and compares it with the current strongest extension. If a stronger extension is found, it updates the strongest extension and its strength value.\n\nFinally, the function constructs the output string by concatenating the class name, a dot, and the strongest extension, and returns the result.\n\nThe strength of an extension is determined by the formula: CAP - SM, where CAP is the number of uppercase letters and SM is the number of lowercase letters in the extension's name."}
{"task_id": "Java/154", "generation": "import java.util.*;\n\nclass Solution {\n    public boolean cycpattern_check(String a, String b) {\n        int l = b.length();\n        String pat = b + b;\n        for (int i = 0; i < a.length() - l + 1; i++) {\n            for (int j = 0; j < l + 1; j++) {\n                if (a.substring(i, i + l).equals(pat.substring(j, j + l))) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n}\n", "py_code": "def cycpattern_check(a , b):\n    l = len(b)\n    pat = b + b\n    for i in range(len(a) - l + 1):\n        for j in range(l + 1):\n            if a[i:i+l] == pat[j:j+l]:\n                return True\n    return False\n", "py_summary": "The Python code defines a function `cycpattern_check` that takes two strings `a` and `b` as input and checks if the second string `b` or any of its rotations is a substring of the first string `a`. It concatenates the second string `b` with itself to create a pattern string `pat`. Then, it iterates through all possible substrings of length `len(b)` in the first string `a` and compares them with all possible rotations of the pattern string `pat`. If a match is found, it returns `True`, indicating that the pattern exists in the first string. If no match is found after checking all rotations, it returns `False`."}
{"task_id": "Java/155", "generation": "import java.util.*;\n\nclass Solution {\n    public List<Integer> even_odd_count(int num) {\n        List<Integer> counts = new ArrayList<>();\n        int evenCount = 0;\n        int oddCount = 0;\n        String numStr = String.valueOf(Math.abs(num));\n        \n        for (int i = 0; i < numStr.length(); i++) {\n            int digit = Character.getNumericValue(numStr.charAt(i));\n            if (digit % 2 == 0) {\n                evenCount++;\n            } else {\n                oddCount++;\n            }\n        }\n        \n        counts.add(evenCount);\n        counts.add(oddCount);\n        \n        return counts;\n    }\n}\n", "py_code": "def even_odd_count(num):\n    even_count = 0\n    odd_count = 0\n    for i in str(abs(num)):\n        if int(i)%2==0:\n            even_count +=1\n        else:\n            odd_count +=1\n    return (even_count, odd_count)\n", "py_summary": "The Python code defines a function that takes an integer as input and returns a tuple containing the count of even and odd digits in the absolute value of the integer. The function iterates through each digit of the absolute value of the input integer by converting it to a string. It then checks if the digit is even or odd by converting it back to an integer and performing a modulo operation with 2. Depending on whether the digit is even or odd, the respective count is incremented. Finally, the function returns a tuple containing the count of even and odd digits."}
{"task_id": "Java/156", "generation": "import java.util.*;\n\nclass Solution {\n    public String int_to_mini_roman(int number) {\n        int[] num = {1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000};\n        String[] sym = {\"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\", \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\"};\n        int i = 12;\n        StringBuilder res = new StringBuilder();\n        while (number > 0) {\n            int div = number / num[i];\n            number %= num[i];\n            while (div > 0) {\n                res.append(sym[i]);\n                div--;\n            }\n            i--;\n        }\n        return res.toString().toLowerCase();\n    }\n}\n", "py_code": "def int_to_mini_roman(number):\n    num = [1, 4, 5, 9, 10, 40, 50, 90,  \n           100, 400, 500, 900, 1000] \n    sym = [\"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\",  \n           \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\"] \n    i = 12\n    res = ''\n    while number: \n        div = number // num[i] \n        number %= num[i] \n        while div: \n            res += sym[i] \n            div -= 1\n        i -= 1\n    return res.lower()\n", "py_summary": "The Python code defines a function `int_to_mini_roman` that converts a given positive integer into its Roman numeral equivalent in lowercase. It uses two lists, `num` and `sym`, to store the integer values and their corresponding Roman numeral symbols. The function iterates through the `num` list in reverse order, dividing the input number by the current value in `num` to determine how many times the symbol should be added to the result string. It then appends the Roman numeral symbol to the result string `res` and moves to the next smaller value in `num`. Finally, the function returns the lowercase Roman numeral representation of the input number."}
{"task_id": "Java/157", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public boolean right_angle_triangle(int a, int b, int c) {\n        return a*a == b*b + c*c || b*b == a*a + c*c || c*c == a*a + b*b;\n    }\n}\n", "py_code": "def right_angle_triangle(a, b, c):\n    return a*a == b*b + c*c or b*b == a*a + c*c or c*c == a*a + b*b\n", "py_summary": "The Python code defines a function that takes the lengths of three sides of a triangle as input and checks if the triangle formed by those sides is a right-angled triangle. It does so by applying the Pythagorean theorem, which states that in a right-angled triangle, the square of the length of the hypotenuse is equal to the sum of the squares of the other two sides. \n\nThe function calculates this condition for all three possible combinations of sides being the hypotenuse and returns True if any of the conditions are met, indicating that the triangle is a right-angled triangle. Otherwise, it returns False."}
{"task_id": "Java/158", "generation": "import java.util.*;\n\nclass Solution {\n    public String find_max(List<String> words) {\n        Collections.sort(words, (a, b) -> {\n            if (a.chars().distinct().count() != b.chars().distinct().count()) {\n                return (int) (b.chars().distinct().count() - a.chars().distinct().count());\n            } else {\n                return a.compareTo(b);\n            }\n        });\n        return words.get(0);\n    }\n}\n", "py_code": "def find_max(words):\n    return sorted(words, key = lambda x: (-len(set(x)), x))[0]\n", "py_summary": "The Python code defines a function that takes a list of strings as input and returns the word with the maximum number of unique characters. If there are multiple words with the same maximum number of unique characters, it returns the word that comes first in lexicographical order. \n\nThe function uses the `sorted` function with a custom key to sort the words based on two criteria: first by the negative length of the set of unique characters in each word (to get the maximum unique characters first), and then by the word itself. Finally, it returns the first word after sorting."}
{"task_id": "Java/159", "generation": "import java.util.*;\n\nclass Solution {\n    public List<Integer> eat(int number, int need, int remaining) {\n        List<Integer> result = new ArrayList<>();\n        if (need <= remaining) {\n            result.add(number + need);\n            result.add(remaining - need);\n        } else {\n            result.add(number + remaining);\n            result.add(0);\n        }\n        return result;\n    }\n}\n", "py_code": "def eat(number, need, remaining):\n    if(need <= remaining):\n        return [ number + need , remaining-need ]\n    else:\n        return [ number + remaining , 0]\n", "py_summary": "The Python code defines a function that takes three integers as input: the number of carrots already eaten (`number`), the number of carrots needed to eat (`need`), and the number of remaining carrots in stock (`remaining`). \n\nIf the number of needed carrots is less than or equal to the remaining carrots in stock, the function returns a list containing the total number of eaten carrots after the meals (sum of already eaten and needed carrots) and the number of carrots left after the meals (remaining - needed).\n\nIf the number of needed carrots is greater than the remaining carrots in stock, the function returns a list containing the total number of eaten carrots after the meals (sum of already eaten and remaining carrots) and 0, indicating that all remaining carrots were eaten."}
{"task_id": "Java/160", "generation": "import java.util.*;\n\nclass Solution {\n    public int do_algebra(List<String> operator, List<Integer> operand) {\n        StringBuilder expression = new StringBuilder(String.valueOf(operand.get(0)));\n        for (int i = 0; i < operator.size(); i++) {\n            expression.append(operator.get(i)).append(operand.get(i + 1));\n        }\n        return evaluateExpression(expression.toString());\n    }\n\n    private int evaluateExpression(String expression) {\n        return (int) eval(expression);\n    }\n\n    private double eval(String expression) {\n        return new Object() {\n            int pos = -1, ch;\n\n            void nextChar() {\n                ch = (++pos < expression.length()) ? expression.charAt(pos) : -1;\n            }\n\n            boolean eat(int charToEat) {\n                while (ch == ' ') nextChar();\n                if (ch == charToEat) {\n                    nextChar();\n                    return true;\n                }\n                return false;\n            }\n\n            double parse() {\n                nextChar();\n                double x = parseExpression();\n                if (pos < expression.length()) throw new RuntimeException(\"Unexpected: \" + (char) ch);\n                return x;\n            }\n\n            double parseExpression() {\n                double x = parseTerm();\n                for (; ; ) {\n                    if (eat('+')) x += parseTerm();\n                    else if (eat('-')) x -= parseTerm();\n                    else return x;\n                }\n            }\n\n            double parseTerm() {\n                double x = parseFactor();\n                for (; ; ) {\n                    if (eat('*')) x *= parseFactor();\n                    else if (eat('/')) x /= parseFactor();\n                    else return x;\n                }\n            }\n\n            double parseFactor() {\n                if (eat('+')) return parseFactor();\n                if (eat('-')) return -parseFactor();\n\n                double x;\n                int startPos = this.pos;\n                if (eat('(')) {\n                    x = parseExpression();\n                    eat(')');\n                } else if ((ch >= '0' && ch <= '9') || ch == '.') {\n                    while ((ch >= '0' && ch <= '9') || ch == '.') nextChar();\n                    x = Double.parseDouble(expression.substring(startPos, this.pos));\n                } else {\n                    throw new RuntimeException(\"Unexpected: \" + (char) ch);\n                }\n\n                if (eat('^')) x = Math.pow(x, parseFactor());\n\n                return x;\n            }\n        }.parse();\n    }\n}\n", "py_code": "def do_algebra(operator, operand):\n    expression = str(operand[0])\n    for oprt, oprn in zip(operator, operand[1:]):\n        expression+= oprt + str(oprn)\n    return eval(expression)\n", "py_summary": "The Python code defines a function `do_algebra` that takes two input lists: `operator` containing basic algebra operations and `operand` containing integers. The function builds an algebraic expression by concatenating the integers from the `operand` list with the corresponding operators from the `operator` list. It then evaluates the expression using the `eval` function in Python and returns the result."}
{"task_id": "Java/161", "generation": "import java.util.*;\n\nclass Solution {\n    public String solve(String s) {\n        char[] chars = s.toCharArray();\n        boolean hasLetter = false;\n        \n        for (int i = 0; i < chars.length; i++) {\n            if (Character.isLetter(chars[i])) {\n                chars[i] = Character.isUpperCase(chars[i]) ? Character.toLowerCase(chars[i]) : Character.toUpperCase(chars[i]);\n                hasLetter = true;\n            }\n        }\n        \n        if (!hasLetter) {\n            StringBuilder sb = new StringBuilder(s);\n            return sb.reverse().toString();\n        } else {\n            return new String(chars);\n        }\n    }\n}\n", "py_code": "def solve(s):\n    flg = 0\n    idx = 0\n    new_str = list(s)\n    for i in s:\n        if i.isalpha():\n            new_str[idx] = i.swapcase()\n            flg = 1\n        idx += 1\n    s = \"\"\n    for i in new_str:\n        s += i\n    if flg == 0:\n        return s[len(s)::-1]\n    return s\n", "py_summary": "The Python code defines a function that takes a string as input and performs the following operations:\n1. It initializes a flag `flg` to 0 and an index `idx` to 0.\n2. It converts the input string `s` into a list of characters `new_str`.\n3. It iterates through each character in the input string:\n    - If the character is a letter, it swaps the case (lower to upper or vice versa) and updates the corresponding character in `new_str`. It also sets the flag `flg` to 1.\n    - Increments the index `idx`.\n4. It then reconstructs the modified characters in `new_str` back to a string `s`.\n5. If no letters were found (flag `flg` is still 0), it returns the reversed string `s`.\n6. Otherwise, it returns the modified string `s`.\n\nThe function essentially reverses the case of letters in the input string and reverses the entire string if no letters are present.\n\n### Last step, write the Java solution according to the python solution and the python code summary."}
{"task_id": "Java/162", "generation": "import java.math.BigInteger;\nimport java.security.*;\nimport java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public Optional<String> string_to_md5(String text) {\n        try {\n            if (text.isEmpty()) {\n                return Optional.empty();\n            }\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            byte[] hashBytes = md.digest(text.getBytes());\n            BigInteger no = new BigInteger(1, hashBytes);\n            String hashString = no.toString(16);\n            while (hashString.length() < 32) {\n                hashString = \"0\" + hashString;\n            }\n            return Optional.of(hashString);\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n            return Optional.empty();\n        }\n    }\n}\n", "py_code": "def string_to_md5(text):\n    import hashlib\n    return hashlib.md5(text.encode('ascii')).hexdigest() if text else None\n", "py_summary": "The Python code defines a function that takes a string as input and returns its MD5 hash equivalent string with a length of 32 characters. It uses the hashlib library to calculate the MD5 hash of the input text. If the input text is empty, the function returns None. The hashlib.md5() function is used to generate the MD5 hash of the input text encoded in ASCII format, and the .hexdigest() method is used to get the hexadecimal representation of the hash."}
{"task_id": "Java/163", "generation": "import java.util.*;\n\nclass Solution {\n    public List<Integer> generate_integers(int a, int b) {\n        List<Integer> result = new ArrayList<>();\n        int lower = Math.max(2, Math.min(a, b));\n        int upper = Math.min(8, Math.max(a, b));\n\n        for (int i = lower; i <= upper; i++) {\n            if (i % 2 == 0) {\n                result.add(i);\n            }\n        }\n\n        return result;\n    }\n}\n", "py_code": "def generate_integers(a, b):\n    lower = max(2, min(a, b))\n    upper = min(8, max(a, b))\n\n    return [i for i in range(lower, upper+1) if i % 2 == 0]\n", "py_summary": "The Python code defines a function that takes two positive integers `a` and `b` as input and returns a list of even digits between `a` and `b` (inclusive) in ascending order. The function first determines the lower and upper bounds for the range of numbers to consider by taking the maximum of 2 and the minimum of `a` and `b` as the lower bound, and the minimum of 8 and the maximum of `a` and `b` as the upper bound.\n\nIt then generates a list comprehension that iterates over the range from the lower bound to the upper bound (inclusive) and filters out only the even numbers by checking if the number is divisible by 2. The resulting list contains the even digits between `a` and `b` in ascending order."}
