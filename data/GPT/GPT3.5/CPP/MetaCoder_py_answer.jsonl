{"task_id": "CPP/0", "generation": "bool has_close_elements(vector<float> numbers, float threshold) {\n    for (int i = 0; i < numbers.size(); i++) {\n        for (int j = i + 1; j < numbers.size(); j++) {\n            if (abs(numbers[i] - numbers[j]) < threshold) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n", "py_code": "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    for idx, elem in enumerate(numbers):\n        for idx2, elem2 in enumerate(numbers):\n            if idx != idx2:\n                distance = abs(elem - elem2)\n                if distance < threshold:\n                    return True\n\n    return False\n", "py_summary": "The Python code defines a function that takes a list of numbers and a threshold value as input and checks if there are any two numbers in the list that are closer to each other than the given threshold. The function iterates through all pairs of numbers in the list and calculates the absolute difference between them. If the difference is less than the threshold, the function returns True. If no such pair is found after checking all combinations, the function returns False."}
{"task_id": "CPP/1", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_string;\n    int current_depth = 0;\n\n    for (char c : paren_string) {\n        if (c == '(') {\n            current_depth++;\n            current_string.push_back(c);\n        } else if (c == ')') {\n            current_depth--;\n            current_string.push_back(c);\n\n            if (current_depth == 0) {\n                result.push_back(current_string);\n                current_string.clear();\n            }\n        }\n    }\n\n    return result;\n}\n", "py_code": "from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n", "py_summary": "The Python code defines a function that takes a string containing multiple groups of nested parentheses as input and returns a list of strings where each string represents a separate group of balanced parentheses. \n\nThe function iterates through the input string character by character. It maintains a `current_string` list to store the characters of the current group being processed and a `current_depth` variable to keep track of the nesting depth of parentheses. \n\nWhen an opening parenthesis '(' is encountered, the depth is incremented, and the character is added to the `current_string`. When a closing parenthesis ')' is encountered, the depth is decremented, and the character is also added to the `current_string`. \n\nIf the depth becomes 0, it means that a complete group of balanced parentheses has been found, so the `current_string` is joined to form a string and added to the `result` list. The `current_string` is then cleared to start processing the next group.\n\nFinally, the function returns the list of strings representing separate groups of balanced parentheses found in the input string."}
{"task_id": "CPP/2", "generation": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\nfloat truncate_number(float number){\n    return fmod(number, 1.0);\n}\n", "py_code": "def truncate_number(number: float) -> float:\n    return number % 1.0\n", "py_summary": "The Python code defines a function that takes a positive floating-point number as input and returns the decimal part of the number. It uses the modulo operator (%) to calculate the remainder when dividing the input number by 1.0, which effectively extracts the decimal part of the number."}
{"task_id": "CPP/3", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\nbool below_zero(vector<int> operations){\n    int balance = 0;\n    for (int op : operations) {\n        balance += op;\n        if (balance < 0) {\n            return true;\n        }\n    }\n    return false;\n}\n", "py_code": "from typing import List\n\n\ndef below_zero(operations: List[int]) -> bool:\n    balance = 0\n\n    for op in operations:\n        balance += op\n        if balance < 0:\n            return True\n\n    return False\n", "py_summary": "The Python code defines a function `below_zero` that takes a list of integers representing deposit and withdrawal operations on a bank account. It initializes a variable `balance` to keep track of the current balance, starting from zero. \n\nThe function then iterates through each operation in the list and updates the balance accordingly. If at any point the balance falls below zero, the function immediately returns `True` indicating that the balance went negative. If the loop completes without the balance going negative, the function returns `False`."}
{"task_id": "CPP/4", "generation": "#include <stdio.h>\n#include <math.h>\n#include <vector>\n\nusing namespace std;\n\nfloat mean_absolute_deviation(vector<float> numbers) {\n    float sum = 0;\n    for (float num : numbers) {\n        sum += num;\n    }\n    float mean = sum / numbers.size();\n\n    float absolute_diff_sum = 0;\n    for (float num : numbers) {\n        absolute_diff_sum += abs(num - mean);\n    }\n\n    return absolute_diff_sum / numbers.size();\n}\n", "py_code": "from typing import List\n\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    mean = sum(numbers) / len(numbers)\n    return sum(abs(x - mean) for x in numbers) / len(numbers)\n", "py_summary": "The Python code defines a function that calculates the Mean Absolute Deviation (MAD) for a given list of numbers. The MAD is calculated as the average of the absolute differences between each number in the list and the mean of the list.\n\n1. Calculate the mean of the input numbers by summing all numbers and dividing by the total count of numbers.\n2. Calculate the absolute difference between each number and the mean, sum up all these absolute differences.\n3. Divide the sum of absolute differences by the total count of numbers to get the average absolute difference, which is the Mean Absolute Deviation.\n4. Return the Mean Absolute Deviation value as the output of the function."}
{"task_id": "CPP/5", "generation": "#include <vector>\n\nstd::vector<int> intersperse(std::vector<int> numbers, int delimiter) {\n    std::vector<int> result;\n\n    if (numbers.empty()) {\n        return result;\n    }\n\n    for (size_t i = 0; i < numbers.size() - 1; i++) {\n        result.push_back(numbers[i]);\n        result.push_back(delimiter);\n    }\n\n    result.push_back(numbers.back());\n\n    return result;\n}\n", "py_code": "from typing import List\n\n\ndef intersperse(numbers: List[int], delimeter: int) -> List[int]:\n    if not numbers:\n        return []\n\n    result = []\n\n    for n in numbers[:-1]:\n        result.append(n)\n        result.append(delimeter)\n\n    result.append(numbers[-1])\n\n    return result\n", "py_summary": "The Python code defines a function that takes a list of integers `numbers` and an integer `delimiter` as input and returns a new list where the `delimiter` is inserted between every two consecutive elements of the input list. \n\n1. It first checks if the input list `numbers` is empty, in which case it returns an empty list.\n2. It initializes an empty list `result` to store the output.\n3. It then iterates through all elements of the input list except the last one using `numbers[:-1]`.\n4. For each element `n` in the input list, it appends `n` and the `delimiter` to the `result` list.\n5. Finally, it appends the last element of the input list to the `result` list.\n6. The function returns the `result` list containing the elements interspersed with the `delimiter`."}
{"task_id": "CPP/6", "generation": "#include <vector>\n#include <string>\nusing namespace std;\n\nvector<int> parse_nested_parens(string paren_string) {\n    vector<int> depths;\n    int depth = 0;\n    int max_depth = 0;\n\n    for (char c : paren_string) {\n        if (c == '(') {\n            depth++;\n            max_depth = max(depth, max_depth);\n        } else if (c == ')') {\n            depth--;\n        } else if (c == ' ') {\n            depths.push_back(max_depth);\n            max_depth = 0;\n            depth = 0;\n        }\n    }\n\n    depths.push_back(max_depth); // Add the last max_depth value\n    return depths;\n}\n", "py_code": "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    def parse_paren_group(s):\n        depth = 0\n        max_depth = 0\n        for c in s:\n            if c == '(':\n                depth += 1\n                max_depth = max(depth, max_depth)\n            else:\n                depth -= 1\n\n        return max_depth\n\n    return [parse_paren_group(x) for x in paren_string.split(' ') if x]\n", "py_summary": "The Python code defines a function `parse_nested_parens` that takes a string `paren_string` as input and returns a list of integers representing the deepest level of nesting of parentheses for each group in the input string. \n\nWithin the function, there is a nested function `parse_paren_group` that calculates the maximum nesting depth for a single group of parentheses. It iterates through each character in the group, incrementing the depth counter for each opening parenthesis '(', and decrementing it for each closing parenthesis ')'. The function keeps track of the maximum depth encountered.\n\nThe main function `parse_nested_parens` splits the input string by spaces to extract individual groups of parentheses. It then applies the `parse_paren_group` function to each group and collects the results in a list, excluding any empty groups.\n\nFinally, the function returns the list of maximum depths for each group in the input string."}
{"task_id": "CPP/7", "generation": "#include <vector>\n#include <string>\n\nstd::vector<std::string> filter_by_substring(std::vector<std::string> strings, std::string substring) {\n    std::vector<std::string> result;\n    for (const std::string& str : strings) {\n        if (str.find(substring) != std::string::npos) {\n            result.push_back(str);\n        }\n    }\n    return result;\n}\n", "py_code": "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    return [x for x in strings if substring in x]\n", "py_summary": "The Python code defines a function that takes a list of strings and a substring as input, and filters the list to only include strings that contain the given substring. It uses list comprehension to iterate over each string in the input list and checks if the substring is present in that string. If the substring is found in a string, that string is included in the output list. Finally, the function returns the filtered list of strings."}
{"task_id": "CPP/8", "generation": "#include <vector>\n\nstd::vector<int> sum_product(std::vector<int> numbers) {\n    int sum_value = 0;\n    int prod_value = 1;\n\n    for (int n : numbers) {\n        sum_value += n;\n        prod_value *= n;\n    }\n    return {sum_value, prod_value};\n}\n", "py_code": "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    sum_value = 0\n    prod_value = 1\n\n    for n in numbers:\n        sum_value += n\n        prod_value *= n\n    return sum_value, prod_value\n", "py_summary": "The Python code defines a function that takes a list of integers as input and returns a tuple containing the sum and product of all the integers in the list. It initializes variables `sum_value` to 0 and `prod_value` to 1 to keep track of the sum and product, respectively.\n\nThe function then iterates through the input list and updates the `sum_value` by adding each integer and the `prod_value` by multiplying each integer. Finally, it returns a tuple containing the calculated sum and product of all the integers in the input list."}
{"task_id": "CPP/9", "generation": "#include <vector>\n\nstd::vector<int> rolling_max(std::vector<int> numbers) {\n    std::vector<int> result;\n    int running_max = INT_MIN;\n\n    for (int n : numbers) {\n        running_max = std::max(running_max, n);\n        result.push_back(running_max);\n    }\n\n    return result;\n}\n", "py_code": "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    running_max = None\n    result = []\n\n    for n in numbers:\n        if running_max is None:\n            running_max = n\n        else:\n            running_max = max(running_max, n)\n\n        result.append(running_max)\n\n    return result\n", "py_summary": "The Python code defines a function `rolling_max` that takes a list of integers as input and returns a list of rolling maximum elements. The function initializes variables `running_max` to None and an empty list `result` to store the rolling maximum values. \n\nIt then iterates through the input list of numbers and updates the `running_max` variable to the maximum value seen so far. For each number in the input list, it compares the number with the current `running_max` and updates `running_max` to the maximum of the two. The maximum value seen so far is then appended to the `result` list.\n\nFinally, the function returns the `result` list containing the rolling maximum values at each moment in the sequence."}
{"task_id": "CPP/10", "generation": "#include <string>\nusing namespace std;\n\nbool is_palindrome(string str) {\n    string reversed(str.rbegin(), str.rend());\n    return reversed == str;\n}\n\nstring make_palindrome(string str) {\n    if (str.empty()) {\n        return \"\";\n    }\n\n    int beginning_of_suffix = 0;\n\n    while (!is_palindrome(str.substr(beginning_of_suffix))) {\n        beginning_of_suffix++;\n    }\n\n    return str + string(str.begin(), str.begin() + beginning_of_suffix);\n}\n", "py_code": "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    if not string:\n        return ''\n\n    beginning_of_suffix = 0\n\n    while not is_palindrome(string[beginning_of_suffix:]):\n        beginning_of_suffix += 1\n\n    return string + string[:beginning_of_suffix][::-1]\n", "py_summary": "The Python code consists of two functions:\n1. `is_palindrome`: This function takes a string as input and returns a boolean indicating whether the string is a palindrome or not. It does so by comparing the string with its reverse using slicing (`[::-1]`).\n2. `make_palindrome`: This function constructs the shortest palindrome that begins with the supplied string. It iterates through the string to find the longest postfix that is a palindrome. Then, it appends the reverse of the prefix before the palindromic suffix to the end of the string.\n\nThe `make_palindrome` function first handles the edge case where the input string is empty. Then, it iterates through the string to find the longest palindromic suffix. Finally, it constructs the palindrome by appending the reverse of the prefix before the palindromic suffix to the end of the string."}
{"task_id": "CPP/11", "generation": "#include <string>\nusing namespace std;\n\nstring string_xor(string a, string b) {\n    string result = \"\";\n    for (int i = 0; i < a.size(); i++) {\n        if (a[i] == b[i]) {\n            result += '0';\n        } else {\n            result += '1';\n        }\n    }\n    return result;\n}\n", "py_code": "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    def xor(i, j):\n        if i == j:\n            return '0'\n        else:\n            return '1'\n\n    return ''.join(xor(x, y) for x, y in zip(a, b))\n", "py_summary": "The Python code defines a function `string_xor` that takes two binary strings `a` and `b` as input and performs a bitwise XOR operation on them. The function internally defines a helper function `xor` that takes two characters and returns the result of XOR operation between them. \n\nThe main function `string_xor` then uses a list comprehension with `zip` to iterate over corresponding characters in the input strings `a` and `b`, applying the `xor` function to each pair of characters. The result is a list of characters representing the XOR result for each position, which is then joined together to form the final XOR result as a string."}
{"task_id": "CPP/12", "generation": "#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string longest(std::vector<std::string> strings) {\n    if (strings.empty()) {\n        return \"\";\n    }\n\n    int maxlen = 0;\n    for (const std::string& s : strings) {\n        maxlen = std::max(maxlen, static_cast<int>(s.length()));\n    }\n\n    for (const std::string& s : strings) {\n        if (s.length() == maxlen) {\n            return s;\n        }\n    }\n\n    return \"\";\n}\n", "py_code": "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    if not strings:\n        return None\n\n    maxlen = max(len(x) for x in strings)\n    for s in strings:\n        if len(s) == maxlen:\n            return s\n", "py_summary": "The Python code defines a function that takes a list of strings as input and returns the longest string in the list. If the input list is empty, the function returns None. \n\nThe function first checks if the input list is empty, and if so, returns None. It then calculates the maximum length of the strings in the list using a generator expression. Next, it iterates through the strings in the list and returns the first string that has a length equal to the maximum length found. This ensures that if there are multiple strings with the same maximum length, the function returns the first one encountered."}
{"task_id": "CPP/13", "generation": "#include<stdio.h>\nusing namespace std;\nint greatest_common_divisor(int a, int b){\n    while (b) {\n        int temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n", "py_code": "def greatest_common_divisor(a: int, b: int) -> int:\n    while b:\n        a, b = b, a % b\n    return a\n", "py_summary": "The Python code defines a function that calculates the greatest common divisor (GCD) of two integers `a` and `b` using the Euclidean algorithm. The function iteratively updates the values of `a` and `b` until `b` becomes 0. At each iteration, the value of `a` is updated to `b`, and the value of `b` is updated to the remainder of `a` divided by the previous value of `b`. Once `b` becomes 0, the function returns the final value of `a`, which is the GCD of the original `a` and `b`."}
{"task_id": "CPP/14", "generation": "#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> all_prefixes(string str) {\n    vector<string> result;\n    string prefix = \"\";\n    for (int i = 0; i < str.size(); i++) {\n        prefix += str[i];\n        result.push_back(prefix);\n    }\n    return result;\n}\n", "py_code": "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    result = []\n\n    for i in range(len(string)):\n        result.append(string[:i+1])\n    return result\n", "py_summary": "The Python code defines a function that takes a string as input and returns a list of all prefixes of the input string from the shortest to the longest. It initializes an empty list `result` to store the prefixes. \n\nThe function then iterates over the indices of the input string and appends the substring from index 0 to the current index (inclusive) to the `result` list. This effectively generates all prefixes of the input string. Finally, the function returns the list of prefixes."}
{"task_id": "CPP/15", "generation": "#include <string>\n\nstd::string string_sequence(int n) {\n    std::string result = \"\";\n    for (int i = 0; i <= n; i++) {\n        result += std::to_string(i) + \" \";\n    }\n    return result.substr(0, result.size() - 1); // Remove the extra space at the end\n}\n", "py_code": "def string_sequence(n: int) -> str:\n    return ' '.join([str(x) for x in range(n + 1)])\n", "py_summary": "The Python code defines a function `string_sequence` that takes an integer `n` as input and returns a string containing space-delimited numbers starting from 0 up to `n` (inclusive). \n\nIt uses a list comprehension to generate a list of numbers from 0 to `n`, converts each number to a string, and then joins these strings with a space delimiter using the `join` method. Finally, it returns the resulting string."}
{"task_id": "CPP/16", "generation": "#include <string>\n#include <unordered_set>\n\nint count_distinct_characters(std::string str) {\n    std::unordered_set<char> charSet;\n    for (char c : str) {\n        charSet.insert(tolower(c));\n    }\n    return charSet.size();\n}\n", "py_code": "def count_distinct_characters(string: str) -> int:\n    return len(set(string.lower()))\n", "py_summary": "The Python code defines a function that takes a string as input and returns the count of distinct characters in the string, regardless of case. It converts the string to lowercase using the `lower()` method to ensure case insensitivity. Then, it converts the lowercase string to a set to automatically remove duplicates, and finally returns the length of the set, which represents the count of distinct characters in the string."}
{"task_id": "CPP/17", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<unordered_map>\nusing namespace std;\n\nvector<int> parse_music(string music_string) {\n    unordered_map<string, int> note_map = {{\"o\", 4}, {\"o|\", 2}, {\".|\", 1}};\n    vector<int> result;\n    string note = \"\";\n    for (char c : music_string) {\n        if (c == ' ') {\n            if (!note.empty()) {\n                result.push_back(note_map[note]);\n                note = \"\";\n            }\n        } else {\n            note += c;\n        }\n    }\n    if (!note.empty()) {\n        result.push_back(note_map[note]);\n    }\n    return result;\n}\n", "py_code": "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    note_map = {'o': 4, 'o|': 2, '.|': 1}\n    return [note_map[x] for x in music_string.split(' ') if x]\n", "py_summary": "The Python code defines a function `parse_music` that takes a string `music_string` as input and returns a list of integers representing the duration of each musical note. It first creates a dictionary `note_map` that maps each note symbol to its corresponding duration in beats. \n\nThe function then splits the input `music_string` by spaces to extract individual note symbols. For each note symbol, it looks up the corresponding duration in the `note_map` dictionary and appends it to the result list if the note symbol is not an empty string. Finally, the function returns the list of beat durations for each note symbol."}
{"task_id": "CPP/18", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\nint how_many_times(string str, string substring){\n    int count = 0;\n    for (int i = 0; i <= str.length() - substring.length(); i++) {\n        if (str.substr(i, substring.length()) == substring) {\n            count++;\n        }\n    }\n    return count;\n}\n", "py_code": "def how_many_times(string: str, substring: str) -> int:\n    times = 0\n\n    for i in range(len(string) - len(substring) + 1):\n        if string[i:i+len(substring)] == substring:\n            times += 1\n\n    return times\n", "py_summary": "The Python code defines a function that takes two strings as input: `string` and `substring`. It then iterates through the `string` using a sliding window approach to check if the substring matches the current window. If a match is found, the function increments a counter `times`. Finally, the function returns the total number of times the `substring` is found in the `string`, considering overlapping cases."}
{"task_id": "CPP/19", "generation": "#include <iostream>\n#include <string>\n#include <vector>\n#include <map>\n#include <algorithm>\n\nstd::string sort_numbers(std::string numbers) {\n    std::map<std::string, int> value_map = {\n        {\"zero\", 0},\n        {\"one\", 1},\n        {\"two\", 2},\n        {\"three\", 3},\n        {\"four\", 4},\n        {\"five\", 5},\n        {\"six\", 6},\n        {\"seven\", 7},\n        {\"eight\", 8},\n        {\"nine\", 9}\n    };\n\n    std::vector<std::string> words;\n    std::string word = \"\";\n    for (char c : numbers) {\n        if (c == ' ') {\n            if (!word.empty()) {\n                words.push_back(word);\n                word = \"\";\n            }\n        } else {\n            word += c;\n        }\n    }\n    if (!word.empty()) {\n        words.push_back(word);\n    }\n\n    std::sort(words.begin(), words.end(), [&](const std::string& a, const std::string& b) {\n        return value_map[a] < value_map[b];\n    });\n\n    std::string result = \"\";\n    for (const std::string& w : words) {\n        result += w + \" \";\n    }\n    result.pop_back(); // Remove the extra space at the end\n    return result;\n}\n", "py_code": "from typing import List\n\n\ndef sort_numbers(numbers: str) -> str:\n    value_map = {\n        'zero': 0,\n        'one': 1,\n        'two': 2,\n        'three': 3,\n        'four': 4,\n        'five': 5,\n        'six': 6,\n        'seven': 7,\n        'eight': 8,\n        'nine': 9\n    }\n    return ' '.join(sorted([x for x in numbers.split(' ') if x], key=lambda x: value_map[x]))\n", "py_summary": "The Python code defines a function `sort_numbers` that takes a space-delimited string of numbers in words as input and returns a string with the numbers sorted from smallest to largest. It first creates a dictionary `value_map` that maps each word representation of a number to its corresponding numerical value. \n\nThe function then splits the input string into words, filters out any empty strings, sorts the words based on their numerical values using the `value_map`, and finally joins the sorted words back into a string with space as the delimiter. The function effectively converts the word representations of numbers to their numerical values, sorts them, and converts them back to words for the output."}
{"task_id": "CPP/20", "generation": "#include <vector>\n#include <cmath>\n#include <utility>\n\nstd::pair<float, float> find_closest_elements(std::vector<float> numbers) {\n    std::pair<float, float> closest_pair;\n    float min_distance = std::numeric_limits<float>::max();\n\n    for (int i = 0; i < numbers.size(); i++) {\n        for (int j = i + 1; j < numbers.size(); j++) {\n            if (std::abs(numbers[i] - numbers[j]) < min_distance) {\n                min_distance = std::abs(numbers[i] - numbers[j]);\n                closest_pair = std::make_pair(std::min(numbers[i], numbers[j]), std::max(numbers[i], numbers[j]));\n            }\n        }\n    }\n\n    return closest_pair;\n}\n", "py_code": "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    closest_pair = None\n    distance = None\n\n    for idx, elem in enumerate(numbers):\n        for idx2, elem2 in enumerate(numbers):\n            if idx != idx2:\n                if distance is None:\n                    distance = abs(elem - elem2)\n                    closest_pair = tuple(sorted([elem, elem2]))\n                else:\n                    new_distance = abs(elem - elem2)\n                    if new_distance < distance:\n                        distance = new_distance\n                        closest_pair = tuple(sorted([elem, elem2]))\n\n    return closest_pair\n", "py_summary": "The Python code defines a function `find_closest_elements` that takes a list of floating-point numbers as input and returns a tuple containing the two numbers that are closest to each other in the list. \n\n1. It initializes variables `closest_pair` and `distance` to keep track of the closest pair of numbers and their distance.\n2. It then iterates through each element in the list and compares it with every other element in the list to find the pair with the smallest absolute difference.\n3. If a new pair with a smaller difference is found, it updates the `closest_pair` and `distance` variables.\n4. Finally, it returns the closest pair of numbers in sorted order.\n\nThe code has a time complexity of O(n^2) due to the nested loop, where n is the number of elements in the input list."}
{"task_id": "CPP/21", "generation": "#include <stdio.h>\n#include <math.h>\n#include <vector>\n\nusing namespace std;\n\nvector<float> rescale_to_unit(vector<float> numbers) {\n    float min_number = numbers[0];\n    float max_number = numbers[0];\n    \n    // Find the minimum and maximum numbers in the input list\n    for (float num : numbers) {\n        if (num < min_number) {\n            min_number = num;\n        }\n        if (num > max_number) {\n            max_number = num;\n        }\n    }\n    \n    vector<float> rescaled_numbers;\n    \n    // Apply linear transformation to rescale the numbers\n    for (float num : numbers) {\n        float rescaled_num = (num - min_number) / (max_number - min_number);\n        rescaled_numbers.push_back(rescaled_num);\n    }\n    \n    return rescaled_numbers;\n}\n", "py_code": "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    min_number = min(numbers)\n    max_number = max(numbers)\n    return [(x - min_number) / (max_number - min_number) for x in numbers]\n", "py_summary": "The Python code defines a function that takes a list of numbers as input and returns a new list where each number is linearly transformed to a value between 0 and 1 based on the minimum and maximum values in the input list. \n\n1. It first calculates the minimum and maximum numbers in the input list.\n2. Then, it iterates through each number in the input list and applies the linear transformation formula `(x - min_number) / (max_number - min_number)` to rescale the number.\n3. The transformed numbers are stored in a new list, which is returned as the output."}
{"task_id": "CPP/22", "generation": "#include <vector>\n#include <boost/any.hpp>\n#include <list>\n\nstd::vector<int> filter_integers(std::list<boost::any> values) {\n    std::vector<int> result;\n    for (const boost::any& val : values) {\n        if (val.type() == typeid(int)) {\n            result.push_back(boost::any_cast<int>(val));\n        }\n    }\n    return result;\n}\n", "py_code": "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    return [x for x in values if isinstance(x, int)]\n", "py_summary": "The Python code defines a function that takes a list of values of any type as input and filters out only the integer values from the list. It uses list comprehension to iterate over the input list and includes only the elements that are of type `int` in the output list. The function then returns this filtered list containing only integer values."}
{"task_id": "CPP/23", "generation": "#include <string>\nusing namespace std;\n\nint strlen(string str) {\n    return str.length();\n}\n", "py_code": "def strlen(string: str) -> int:\n    return len(string)\n", "py_summary": "The Python code defines a function that takes a string as input and returns the length of the string using the built-in `len()` function. The `len()` function returns the number of characters in the string, which represents the length of the string."}
{"task_id": "CPP/24", "generation": "#include<stdio.h>\nusing namespace std;\nint largest_divisor(int n){\n    int largest = 1;\n    for (int i = n-1; i > 1; i--) {\n        if (n % i == 0) {\n            largest = i;\n            break;\n        }\n    }\n    return largest;\n}\n", "py_code": "def largest_divisor(n: int) -> int:\n    for i in reversed(range(n)):\n        if n % i == 0:\n            return i\n", "py_summary": "The Python code defines a function that takes an integer `n` as input and iterates in reverse order from `n-1` down to `1`. For each number `i` in the iteration, it checks if `n` is divisible by `i` without any remainder. If the condition is met, it returns `i` as the largest number that evenly divides `n` and is smaller than `n`."}
{"task_id": "CPP/25", "generation": "#include <stdio.h>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\nvector<int> factorize(int n) {\n    vector<int> factors;\n    for (int i = 2; i <= sqrt(n); i++) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n    if (n > 1) {\n        factors.push_back(n);\n    }\n    return factors;\n}\n", "py_code": "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    import math\n    fact = []\n    i = 2\n    while i <= int(math.sqrt(n) + 1):\n        if n % i == 0:\n            fact.append(i)\n            n //= i\n        else:\n            i += 1\n\n    if n > 1:\n        fact.append(n)\n    return fact\n", "py_summary": "The Python code defines a function that takes an integer `n` as input and returns a list of prime factors of `n` in ascending order. The function initializes an empty list `fact` to store the prime factors. It then iterates from 2 to the square root of `n` (inclusive) and checks if `n` is divisible by the current number `i`. If it is divisible, `i` is a prime factor of `n`, and it is added to the `fact` list while updating `n` by dividing it by `i`. If `i` is not a factor, `i` is incremented by 1.\n\nAfter the loop, if `n` is greater than 1, it means that `n` itself is a prime factor, so it is added to the `fact` list. Finally, the function returns the list of prime factors `fact`."}
{"task_id": "CPP/26", "generation": "#include <stdio.h>\n#include <vector>\n#include <unordered_map>\n#include <algorithm>\nusing namespace std;\n\nvector<int> remove_duplicates(vector<int> numbers) {\n    unordered_map<int, int> countMap;\n    vector<int> result;\n    \n    for (int num : numbers) {\n        countMap[num]++;\n        if (countMap[num] == 1) {\n            result.push_back(num);\n        }\n    }\n    \n    return result;\n}\n", "py_code": "from typing import List\n\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    import collections\n    c = collections.Counter(numbers)\n    return [n for n in numbers if c[n] <= 1]\n", "py_summary": "The Python code defines a function that takes a list of integers as input and removes all elements that occur more than once in the list while maintaining the original order of elements. The function uses the `Counter` class from the `collections` module to count the occurrences of each element in the input list. \n\nIt then creates a new list by iterating through the input list and including only those elements whose count is less than or equal to 1. This ensures that only elements that occur at most once are included in the final list. The function returns the new list with duplicates removed."}
{"task_id": "CPP/27", "generation": "#include <string>\n#include <cctype>\n\nstd::string flip_case(std::string str) {\n    for (char& c : str) {\n        if (std::islower(c)) {\n            c = std::toupper(c);\n        } else if (std::isupper(c)) {\n            c = std::tolower(c);\n        }\n    }\n    return str;\n}\n", "py_code": "def flip_case(string: str) -> str:\n    return string.swapcase()\n", "py_summary": "The Python code defines a function that takes a string as input and returns a new string where the case of each character is flipped (lowercase characters become uppercase and vice versa). The `swapcase()` method of strings is used to achieve this, as it swaps the case of all characters in the string and returns the modified string."}
{"task_id": "CPP/28", "generation": "#include <vector>\n#include <string>\n\nusing namespace std;\n\nstring concatenate(vector<string> strings) {\n    string result = \"\";\n    for (const string& s : strings) {\n        result += s;\n    }\n    return result;\n}\n", "py_code": "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    return ''.join(strings)\n", "py_summary": "The Python code defines a function that takes a list of strings as input and concatenates them into a single string using the `join` method. The `join` method joins all the elements of the input list (strings) into a single string, with an empty string `''` as the separator. The function then returns the concatenated string."}
{"task_id": "CPP/29", "generation": "#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> filter_by_prefix(vector<string> strings, string prefix) {\n    vector<string> result;\n    for (const string& s : strings) {\n        if (s.find(prefix) == 0) {\n            result.push_back(s);\n        }\n    }\n    return result;\n}\n", "py_code": "from typing import List\n\n\ndef filter_by_prefix(strings: List[str], prefix: str) -> List[str]:\n    return [x for x in strings if x.startswith(prefix)]\n", "py_summary": "The Python code defines a function that takes a list of strings and a prefix as input, and filters the strings to only include those that start with the given prefix. It uses a list comprehension to iterate over each string in the input list and checks if the string starts with the specified prefix using the `startswith()` method. If the condition is met, the string is included in the output list. Finally, the function returns the filtered list of strings."}
{"task_id": "CPP/30", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\nvector<float> get_positive(vector<float> l){\n    vector<float> positive_nums;\n    for (float num : l) {\n        if (num > 0) {\n            positive_nums.push_back(num);\n        }\n    }\n    return positive_nums;\n}\n", "py_code": "def get_positive(l: list):\n    return [e for e in l if e > 0]\n", "py_summary": "The Python code defines a function that takes a list of numbers as input and returns a new list containing only the positive numbers from the input list. It uses list comprehension to iterate over the input list and filter out the elements that are greater than 0, thus creating a new list with only positive numbers."}
{"task_id": "CPP/31", "generation": "#include<stdio.h>\n#include<iostream>\nusing namespace std;\n\nbool is_prime(long long n){\n    if (n < 2) {\n        return false;\n    }\n    for (long long k = 2; k < n; k++) {\n        if (n % k == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n", "py_code": "def is_prime(n):\n    if n < 2:\n        return False\n    for k in range(2, n - 1):\n        if n % k == 0:\n            return False\n    return True\n", "py_summary": "The Python code defines a function that checks if a given number is prime or not. It first handles the cases where the number is less than 2 by returning False, as prime numbers are greater than 1. Then, it iterates from 2 to n-1 and checks if n is divisible by any number in that range. If n is divisible by any number, it returns False as it indicates that n is not a prime number. If no divisors are found, it returns True, indicating that n is a prime number."}
{"task_id": "CPP/32", "generation": "#include <vector>\n#include <cmath>\n\ndouble poly(std::vector<double> xs, double x) {\n    double sum = 0;\n    for (int i = 0; i < xs.size(); i++) {\n        sum += xs[i] * std::pow(x, i);\n    }\n    return sum;\n}\n\ndouble find_zero(std::vector<double> xs) {\n    double begin = -1.0, end = 1.0;\n    while (poly(xs, begin) * poly(xs, end) > 0) {\n        begin *= 2.0;\n        end *= 2.0;\n    }\n    while (end - begin > 1e-10) {\n        double center = (begin + end) / 2.0;\n        if (poly(xs, center) * poly(xs, begin) > 0) {\n            begin = center;\n        } else {\n            end = center;\n        }\n    }\n    return begin;\n}\n", "py_code": "import math\n\n\ndef poly(xs: list, x: float):\n    \"\"\"\n    Evaluates polynomial with coefficients xs at point x.\n    return xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n\n    \"\"\"\n    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])\n\n\ndef find_zero(xs: list):\n    begin, end = -1., 1.\n    while poly(xs, begin) * poly(xs, end) > 0:\n        begin *= 2.0\n        end *= 2.0\n    while end - begin > 1e-10:\n        center = (begin + end) / 2.0\n        if poly(xs, center) * poly(xs, begin) > 0:\n            begin = center\n        else:\n            end = center\n    return begin\n", "py_summary": "The Python code consists of two functions:\n\n1. **poly(xs: list, x: float):**\n   - This function evaluates a polynomial with coefficients `xs` at a point `x`.\n   - It iterates over the coefficients in `xs` and calculates the sum of each coefficient multiplied by `x` raised to the power of its index.\n   - The function returns the sum as the result of evaluating the polynomial at point `x`.\n\n2. **find_zero(xs: list):**\n   - This function finds a zero point of a polynomial defined by the coefficients in `xs`.\n   - It first initializes a range `[begin, end]` where the zero point is expected to lie.\n   - It then iteratively narrows down the range by checking the signs of the polynomial at the endpoints and the midpoint of the range.\n   - The function uses the binary search method to find a zero point with a precision of `1e-10`.\n   - It returns the approximate zero point found within the specified precision.\n\nOverall, the code efficiently evaluates a polynomial at a given point and finds a zero point of the polynomial using the binary search algorithm with a specified precision."}
{"task_id": "CPP/33", "generation": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> sort_third(vector<int> l) {\n    vector<int> sorted_indices;\n    for (int i = 0; i < l.size(); i++) {\n        if (i % 3 == 0) {\n            sorted_indices.push_back(i);\n        }\n    }\n    \n    sort(sorted_indices.begin(), sorted_indices.end(), [&l](int a, int b) {\n        return l[a] < l[b];\n    });\n    \n    for (int i = 0; i < sorted_indices.size(); i++) {\n        l[sorted_indices[i]] = l[sorted_indices[i]];\n    }\n    \n    return l;\n}\n", "py_code": "def sort_third(l: list):\n    l = list(l)\n    l[::3] = sorted(l[::3])\n    return l\n", "py_summary": "The Python code defines a function that takes a list of integers as input and returns a modified list where the values at indices divisible by three are sorted in ascending order, while the values at other indices remain unchanged. \n\nThe function first converts the input list to a mutable list. It then uses list slicing with a step size of 3 to access the elements at indices divisible by three and sorts them in ascending order. Finally, it returns the modified list."}
{"task_id": "CPP/34", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\n#include <set>\nusing namespace std;\n\nvector<int> unique(vector<int> l){\n    set<int> uniqueSet(l.begin(), l.end());\n    vector<int> uniqueList(uniqueSet.begin(), uniqueSet.end());\n    sort(uniqueList.begin(), uniqueList.end());\n    return uniqueList;\n}\n", "py_code": "def unique(l: list):\n    return sorted(list(set(l)))\n", "py_summary": "The Python code defines a function that takes a list of integers as input and returns a new list containing the unique elements from the input list in sorted order. \n1. It first converts the input list to a set to remove duplicates, as sets only contain unique elements.\n2. Then, it converts the set back to a list to maintain the order of elements.\n3. Finally, it sorts the list in ascending order before returning it."}
{"task_id": "CPP/35", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\nfloat max_element(vector<float> l){\n    float m = l[0];\n    for (float e : l) {\n        if (e > m) {\n            m = e;\n        }\n    }\n    return m;\n}\n", "py_code": "def max_element(l: list):\n    m = l[0]\n    for e in l:\n        if e > m:\n            m = e\n    return m\n", "py_summary": "The Python code defines a function that takes a list of floats as input and returns the maximum element in the list. It initializes a variable `m` to the first element of the list and then iterates through the list. For each element `e`, it compares `e` with the current maximum `m` and updates `m` if `e` is greater. Finally, it returns the maximum element `m`."}
{"task_id": "CPP/36", "generation": "#include <stdio.h>\n#include <string>\n\nint fizz_buzz(int n) {\n    int count = 0;\n    for (int i = 0; i < n; i++) {\n        if (i % 11 == 0 || i % 13 == 0) {\n            std::string num_str = std::to_string(i);\n            for (char c : num_str) {\n                if (c == '7') {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}\n", "py_code": "def fizz_buzz(n: int):\n    ns = []\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            ns.append(i)\n    s = ''.join(list(map(str, ns)))\n    ans = 0\n    for c in s:\n        ans += (c == '7')\n    return ans\n", "py_summary": "The Python code defines a function `fizz_buzz` that takes an integer `n` as input and returns the number of times the digit 7 appears in integers less than `n` which are divisible by 11 or 13. \n\n1. It initializes an empty list `ns` to store the numbers that are divisible by 11 or 13.\n2. It iterates through numbers from 0 to `n-1` and checks if the number is divisible by 11 or 13. If it is, the number is added to the list `ns`.\n3. It converts the list of numbers `ns` to a string `s` by joining the numbers as strings.\n4. It initializes a variable `ans` to 0 to store the count of digit 7 occurrences.\n5. It iterates through each character in the string `s` and increments `ans` by 1 if the character is '7'.\n6. Finally, it returns the total count of digit 7 occurrences.\n\nThe code effectively counts the number of times the digit 7 appears in integers less than `n` that are divisible by 11 or 13."}
{"task_id": "CPP/37", "generation": "#include <stdio.h>\n#include <math.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<float> sort_even(vector<float> l) {\n    vector<float> evens;\n    vector<float> odds;\n    vector<float> ans;\n\n    for (int i = 0; i < l.size(); i++) {\n        if (i % 2 == 0) {\n            evens.push_back(l[i]);\n        } else {\n            odds.push_back(l[i]);\n        }\n    }\n\n    sort(evens.begin(), evens.end());\n\n    for (int i = 0; i < evens.size(); i++) {\n        ans.push_back(evens[i]);\n        ans.push_back(odds[i]);\n    }\n\n    if (evens.size() > odds.size()) {\n        ans.push_back(evens.back());\n    }\n\n    return ans;\n}\n", "py_code": "def sort_even(l: list):\n    evens = l[::2]\n    odds = l[1::2]\n    evens.sort()\n    ans = []\n    for e, o in zip(evens, odds):\n        ans.extend([e, o])\n    if len(evens) > len(odds):\n        ans.append(evens[-1])\n    return ans\n", "py_summary": "The Python code defines a function `sort_even` that takes a list `l` as input and returns a new list `ans` where the values at even indices are sorted in ascending order while the values at odd indices remain the same as the input list. \n1. It extracts the elements at even indices and odd indices into separate lists `evens` and `odds` respectively.\n2. It sorts the `evens` list in ascending order.\n3. It then iterates through both `evens` and `odds` lists simultaneously using `zip`, and constructs the `ans` list by appending elements from `evens` and `odds` alternately.\n4. If the number of elements in `evens` is greater than the number of elements in `odds`, it appends the last element of `evens` to `ans`.\n5. Finally, it returns the `ans` list as the output."}
{"task_id": "CPP/38", "generation": "#include <string>\n\nstring encode_cyclic(string s) {\n    int l = s.length();\n    int num = (l + 2) / 3;\n    string output;\n    for (int i = 0; i * 3 < l; i++) {\n        string x = s.substr(i * 3, 3);\n        if (x.length() == 3) {\n            x = x.substr(1) + x[0];\n        }\n        output += x;\n    }\n    return output;\n}\n\nstring decode_cyclic(string s) {\n    return encode_cyclic(encode_cyclic(s));\n}\n", "py_code": "def encode_cyclic(s: str):\n    \"\"\"\n    returns encoded string by cycling groups of three characters.\n    \"\"\"\n    # split string to groups. Each of length 3.\n    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]\n    # cycle elements in each group. Unless group has fewer elements than 3.\n    groups = [(group[1:] + group[0]) if len(group) == 3 else group for group in groups]\n    return \"\".join(groups)\n\n\ndef decode_cyclic(s: str):\n    return encode_cyclic(encode_cyclic(s))\n", "py_summary": "The Python code defines two functions, `encode_cyclic` and `decode_cyclic`, to encode and decode a string based on a cyclic grouping of three characters. \n\n1. `encode_cyclic` function:\n   - It takes a string `s` as input and splits it into groups of three characters each.\n   - It then cycles the elements within each group, except for groups with fewer than three elements.\n   - Finally, it concatenates the modified groups and returns the encoded string.\n\n2. `decode_cyclic` function:\n   - It decodes a string that was encoded using the `encode_cyclic` function by applying the encoding function twice.\n   - This is done to reverse the cyclic encoding and retrieve the original string.\n\nOverall, the `encode_cyclic` function encodes the input string by cycling groups of three characters, and the `decode_cyclic` function decodes the encoded string to recover the original input string."}
{"task_id": "CPP/39", "generation": "#include <stdio.h>\n#include <vector>\n#include <cmath>\n\nint prime_fib(int n) {\n    auto is_prime = [](int p) {\n        if (p < 2) {\n            return false;\n        }\n        for (int k = 2; k * k <= p; k++) {\n            if (p % k == 0) {\n                return false;\n            }\n        }\n        return true;\n    };\n\n    std::vector<int> f = {0, 1};\n    while (true) {\n        f.push_back(f.back() + f[f.size() - 2]);\n        if (is_prime(f.back())) {\n            n--;\n        }\n        if (n == 0) {\n            return f.back();\n        }\n    }\n}\n", "py_code": "def prime_fib(n: int):\n    import math\n\n    def is_prime(p):\n        if p < 2:\n            return False\n        for k in range(2, min(int(math.sqrt(p)) + 1, p - 1)):\n            if p % k == 0:\n                return False\n        return True\n    f = [0, 1]\n    while True:\n        f.append(f[-1] + f[-2])\n        if is_prime(f[-1]):\n            n -= 1\n        if n == 0:\n            return f[-1]\n", "py_summary": "The Python code defines a function `prime_fib` that takes an integer `n` as input and returns the n-th number that is both a Fibonacci number and a prime number. \n\nInside the function, there is a nested function `is_prime` that checks if a given number `p` is prime. It iterates from 2 to the square root of `p` and returns `True` if `p` is divisible only by 1 and itself.\n\nThe function initializes a list `f` with the first two Fibonacci numbers [0, 1]. It then iterates indefinitely, generating the next Fibonacci number in the sequence and checking if it is prime. If a prime Fibonacci number is found, it decrements `n`. When `n` reaches 0, the function returns the last prime Fibonacci number found."}
{"task_id": "CPP/40", "generation": "#include <vector>\n\nbool triples_sum_to_zero(vector<int> l) {\n    for (int i = 0; i < l.size(); i++) {\n        for (int j = i + 1; j < l.size(); j++) {\n            for (int k = j + 1; k < l.size(); k++) {\n                if (l[i] + l[j] + l[k] == 0) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n", "py_code": "def triples_sum_to_zero(l: list):\n    for i in range(len(l)):\n        for j in range(i + 1, len(l)):\n            for k in range(j + 1, len(l)):\n                if l[i] + l[j] + l[k] == 0:\n                    return True\n    return False\n", "py_summary": "The Python code defines a function `triples_sum_to_zero` that takes a list of integers as input and returns `True` if there exist three distinct elements in the list that sum up to zero, and `False` otherwise. The function uses three nested loops to iterate over all possible combinations of three elements in the list. It then checks if the sum of the current triplet is equal to zero. If such a triplet is found, the function immediately returns `True`. If no triplet sums up to zero after checking all combinations, the function returns `False`."}
{"task_id": "CPP/41", "generation": "int car_race_collision(int n){\n    return n * n;\n}\n", "py_code": "def car_race_collision(n: int):\n    return n**2\n", "py_summary": "The Python code defines a function that calculates the number of collisions that will occur between cars moving in opposite directions on an infinitely long straight road. The function takes the number of cars (n) as input and returns the square of n, which represents the total number of collisions that will occur. This is because each car moving in one direction will collide with every car moving in the opposite direction, resulting in n collisions for each car. Therefore, the total number of collisions is n * n, which is equivalent to n squared."}
{"task_id": "CPP/42", "generation": "#include <vector>\n\nvector<int> incr_list(vector<int> l){\n    vector<int> result;\n    for (int i = 0; i < l.size(); i++) {\n        result.push_back(l[i] + 1);\n    }\n    return result;\n}\n", "py_code": "def incr_list(l: list):\n    return [(e + 1) for e in l]\n", "py_summary": "The Python code defines a function that takes a list of integers as input and returns a new list where each element is incremented by 1. It uses list comprehension to iterate over each element in the input list, add 1 to the element, and create a new list with the incremented values."}
{"task_id": "CPP/43", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nbool pairs_sum_to_zero(vector<int> l) {\n    for (int i = 0; i < l.size(); i++) {\n        for (int j = i + 1; j < l.size(); j++) {\n            if (l[i] + l[j] == 0) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n", "py_code": "def pairs_sum_to_zero(l):\n    for i, l1 in enumerate(l):\n        for j in range(i + 1, len(l)):\n            if l1 + l[j] == 0:\n                return True\n    return False\n", "py_summary": "The Python code defines a function that takes a list of integers as input and checks if there are two distinct elements in the list that sum up to zero. It iterates through the list using nested loops to compare each pair of elements. If the sum of any pair is zero, the function returns True. If no such pair is found after checking all combinations, the function returns False."}
{"task_id": "CPP/44", "generation": "#include <string>\n\nstd::string change_base(int x, int base) {\n    std::string ret = \"\";\n    while (x > 0) {\n        ret = std::to_string(x % base) + ret;\n        x /= base;\n    }\n    return ret;\n}\n", "py_code": "def change_base(x: int, base: int):\n    ret = \"\"\n    while x > 0:\n        ret = str(x % base) + ret\n        x //= base\n    return ret\n", "py_summary": "The Python code defines a function that takes an integer `x` and an integer `base` as input and converts the number `x` from its current base to the specified `base`. The function initializes an empty string `ret` to store the converted number. It then enters a while loop that continues as long as `x` is greater than 0. \n\nWithin the loop, the function calculates the remainder of `x` divided by the `base`, converts it to a string, and concatenates it to the left side of the `ret` string. It then updates `x` by performing integer division of `x` by the `base`. This process continues until `x` becomes 0, at which point the function returns the converted number as a string."}
{"task_id": "CPP/45", "generation": "float triangle_area(float a, float h) {\n    return a * h / 2.0;\n}\n", "py_code": "def triangle_area(a, h):\n    return a * h / 2.0\n", "py_summary": "The Python code defines a function that calculates the area of a triangle given the length of one of its sides (a) and the corresponding height (h) to that side. The area of a triangle is calculated using the formula: area = 0.5 * base * height. In this case, the base of the triangle is the given side length 'a' and the height is the given height 'h'. The function returns the calculated area of the triangle."}
{"task_id": "CPP/46", "generation": "#include <stdio.h>\nusing namespace std;\n\nint fib4(int n) {\n    int results[4] = {0, 0, 2, 0};\n    if (n < 4) {\n        return results[n];\n    }\n\n    for (int i = 4; i <= n; i++) {\n        int next = results[0] + results[1] + results[2] + results[3];\n        results[0] = results[1];\n        results[1] = results[2];\n        results[2] = results[3];\n        results[3] = next;\n    }\n\n    return results[3];\n}\n", "py_code": "def fib4(n: int):\n    results = [0, 0, 2, 0]\n    if n < 4:\n        return results[n]\n\n    for _ in range(4, n + 1):\n        results.append(results[-1] + results[-2] + results[-3] + results[-4])\n        results.pop(0)\n\n    return results[-1]\n", "py_summary": "The Python code defines a function `fib4` that efficiently computes the n-th element of the Fib4 number sequence. It initializes a list `results` with the first four elements of the sequence. If n is less than 4, it returns the corresponding element directly from the list. \n\nFor n greater than or equal to 4, the function iterates from 4 to n (inclusive) and calculates the next element in the sequence based on the sum of the last four elements. It then updates the `results` list by appending the new element and removing the oldest element. Finally, it returns the n-th element of the sequence."}
{"task_id": "CPP/47", "generation": "float median(vector<float> l){\n    sort(l.begin(), l.end());\n    if (l.size() % 2 == 1) {\n        return l[l.size() / 2];\n    } else {\n        return (l[l.size() / 2 - 1] + l[l.size() / 2]) / 2.0;\n    }\n}\n", "py_code": "def median(l: list):\n    l = sorted(l)\n    if len(l) % 2 == 1:\n        return l[len(l) // 2]\n    else:\n        return (l[len(l) // 2 - 1] + l[len(l) // 2]) / 2.0\n", "py_summary": "The Python code defines a function that calculates the median of a list of numbers. It first sorts the input list in ascending order. Then, it checks if the length of the list is odd or even. \n- If the length is odd, it returns the middle element of the sorted list as the median.\n- If the length is even, it calculates the average of the two middle elements and returns it as the median.\n\nThis approach works for both cases and provides the correct median value for the given list of numbers."}
{"task_id": "CPP/48", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\nbool is_palindrome(string text){\n    for (int i = 0; i < text.size(); i++) {\n        if (text[i] != text[text.size() - 1 - i]) {\n            return false;\n        }\n    }\n    return true;\n}\n", "py_code": "def is_palindrome(text: str):\n    for i in range(len(text)):\n        if text[i] != text[len(text) - 1 - i]:\n            return False\n    return True\n", "py_summary": "The Python code defines a function that checks if a given string is a palindrome. It iterates through the characters of the string and compares the character at index `i` with the character at the corresponding position from the end of the string (`len(text) - 1 - i`). If any pair of characters does not match, the function immediately returns `False`, indicating that the string is not a palindrome. If all characters match, the function returns `True`, indicating that the string is a palindrome."}
{"task_id": "CPP/49", "generation": "int modp(int n, int p) {\n    int ret = 1;\n    for (int i = 0; i < n; i++) {\n        ret = (2 * ret) % p;\n    }\n    return ret;\n}\n", "py_code": "def modp(n: int, p: int):\n    ret = 1\n    for i in range(n):\n        ret = (2 * ret) % p\n    return ret\n", "py_summary": "The Python code defines a function that calculates 2^n modulo p, where n and p are integers. The function initializes a variable `ret` to 1 and then iterates from 0 to n-1. In each iteration, it updates `ret` by multiplying it by 2 and taking the modulo p of the result. Finally, the function returns the calculated value of `ret`."}
{"task_id": "CPP/50", "generation": "#include <string>\nusing namespace std;\n\nstring encode_shift(string s) {\n    string out = \"\";\n    for (int i = 0; i < s.length(); i++) {\n        int w = ((int)s[i] + 5 - (int)'a') % 26 + (int)'a';\n        out += (char)w;\n    }\n    return out;\n}\n\nstring decode_shift(string s) {\n    string out = \"\";\n    for (int i = 0; i < s.length(); i++) {\n        int w = ((int)s[i] - 5 - (int)'a' + 26) % 26 + (int)'a';\n        out += (char)w;\n    }\n    return out;\n}\n", "py_code": "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    return \"\".join([chr(((ord(ch) - 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n", "py_summary": "The Python code defines two functions, `encode_shift` and `decode_shift`, to encode and decode a string based on a simple shift cipher where each character is shifted by 5 positions in the alphabet.\n\n1. `encode_shift` function:\n   - It takes a string `s` as input and returns the encoded string where each character is shifted by 5 positions in the alphabet.\n   - It uses list comprehension to iterate over each character in the input string.\n   - For each character, it calculates the new character by adding 5 to the ASCII value of the character after normalizing to the range of lowercase letters (a-z).\n   - The new character is then converted back to a character and joined to form the encoded string.\n\n2. `decode_shift` function:\n   - It takes a string `s` as input, which is assumed to be the result of encoding using the `encode_shift` function.\n   - It decodes the encoded string by shifting each character back by 5 positions in the alphabet.\n   - Similar to encoding, it uses list comprehension to iterate over each character in the input string.\n   - For each character, it calculates the original character by subtracting 5 from the ASCII value of the character after normalization.\n   - The original character is then converted back to a character and joined to form the decoded string.\n\nThese functions provide a simple way to encode and decode strings using a fixed shift value of 5 in the alphabet."}
{"task_id": "CPP/51", "generation": "#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\nstring remove_vowels(string text){\n    string vowels = \"aeiouAEIOU\";\n    string result = \"\";\n    for (char c : text) {\n        if (vowels.find(c) == string::npos) {\n            result += c;\n        }\n    }\n    return result;\n}\n", "py_code": "def remove_vowels(text):\n    return \"\".join([s for s in text if s.lower() not in [\"a\", \"e\", \"i\", \"o\", \"u\"]])\n", "py_summary": "The Python code defines a function `remove_vowels` that takes a string as input and removes all vowels from the string. It uses a list comprehension to iterate over each character in the input string and checks if the lowercase version of the character is not a vowel (i.e., not in [\"a\", \"e\", \"i\", \"o\", \"u\"]). If the condition is met, the character is included in the final result. Finally, the function returns the concatenated characters as a string without any vowels."}
{"task_id": "CPP/52", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\nbool below_threshold(vector<int> l, int t) {\n    for (int i = 0; i < l.size(); i++) {\n        if (l[i] >= t) {\n            return false;\n        }\n    }\n    return true;\n}\n", "py_code": "def below_threshold(l: list, t: int):\n    for e in l:\n        if e >= t:\n            return False\n    return True\n", "py_summary": "The Python code defines a function that takes a list of integers `l` and an integer `t` as input. It iterates through each element in the list and checks if the element is greater than or equal to the threshold `t`. If any element is found to be greater than or equal to `t`, the function immediately returns `False`, indicating that not all numbers are below the threshold. If the loop completes without finding any element greater than or equal to `t`, the function returns `True`, indicating that all numbers are below the threshold."}
{"task_id": "CPP/53", "generation": "int add(int x, int y) {\n    return x + y;\n}\n", "py_code": "def add(x: int, y: int):\n    return x + y\n", "py_summary": "The Python code defines a function that takes two integer inputs `x` and `y` and returns the sum of the two numbers. The function simply adds the two input numbers together and returns the result."}
{"task_id": "CPP/54", "generation": "#include<stdio.h>\n#include<string>\n#include<algorithm>\n#include<unordered_set>\nusing namespace std;\n\nbool same_chars(string s0, string s1){\n    unordered_set<char> set_s0(s0.begin(), s0.end());\n    unordered_set<char> set_s1(s1.begin(), s1.end());\n    \n    return set_s0 == set_s1;\n}\n", "py_code": "def same_chars(s0: str, s1: str):\n    return set(s0) == set(s1)\n", "py_summary": "The Python code defines a function that takes two strings as input and checks if they have the same set of characters. It does this by converting each string into a set of characters and then comparing the sets for equality. If the sets are equal, it means that both strings have the same characters, regardless of the order or frequency of those characters. The function returns a boolean value indicating whether the two strings have the same characters or not."}
{"task_id": "CPP/55", "generation": "#include <stdio.h>\nusing namespace std;\n\nint fib(int n) {\n    if (n == 0) {\n        return 0;\n    }\n    if (n == 1) {\n        return 1;\n    }\n    return fib(n - 1) + fib(n - 2);\n}\n", "py_code": "def fib(n: int):\n    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    return fib(n - 1) + fib(n - 2)\n", "py_summary": "The Python code defines a recursive function `fib` that calculates the n-th Fibonacci number. If the input `n` is 0, it returns 0. If `n` is 1, it returns 1. For any other value of `n`, it recursively calculates the Fibonacci number by summing the (n-1)th and (n-2)th Fibonacci numbers."}
{"task_id": "CPP/56", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\nbool correct_bracketing(string brackets){\n    int depth = 0;\n    for (char b : brackets) {\n        if (b == '<') {\n            depth++;\n        } else {\n            depth--;\n        }\n        if (depth < 0) {\n            return false;\n        }\n    }\n    return depth == 0;\n}\n", "py_code": "def correct_bracketing(brackets: str):\n    depth = 0\n    for b in brackets:\n        if b == \"<\":\n            depth += 1\n        else:\n            depth -= 1\n        if depth < 0:\n            return False\n    return depth == 0\n", "py_summary": "The Python code defines a function that takes a string of brackets as input and checks if the bracketing is correct. It iterates through each character in the string and maintains a `depth` variable to keep track of the balance between opening and closing brackets. \n- If an opening bracket '<' is encountered, the depth is incremented by 1.\n- If a closing bracket '>' is encountered, the depth is decremented by 1.\n- If at any point the depth becomes negative, it means there is a closing bracket without a corresponding opening bracket, so the function returns False.\n- Finally, the function returns True if the depth is back to 0, indicating that all opening brackets have a corresponding closing bracket.\n\nThis approach ensures that for correct bracketing, every opening bracket has a corresponding closing bracket."}
{"task_id": "CPP/57", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\nbool monotonic(vector<float> l){\n    bool increasing = true;\n    bool decreasing = true;\n    for (int i = 1; i < l.size(); i++) {\n        if (l[i] < l[i - 1]) {\n            increasing = false;\n        }\n        if (l[i] > l[i - 1]) {\n            decreasing = false;\n        }\n    }\n    return increasing || decreasing;\n}\n", "py_code": "def monotonic(l: list):\n    if l == sorted(l) or l == sorted(l, reverse=True):\n        return True\n    return False\n", "py_summary": "The Python code defines a function that takes a list of numbers as input and checks if the list is either monotonically increasing or monotonically decreasing. It does this by comparing the input list with its sorted version in ascending order and descending order. If the input list is equal to its sorted version in ascending order or descending order, then the function returns True, indicating that the list is monotonically increasing or decreasing. Otherwise, it returns False."}
{"task_id": "CPP/58", "generation": "#include <vector>\n#include <algorithm>\n#include <set>\n\nstd::vector<int> common(std::vector<int> l1, std::vector<int> l2) {\n    std::set<int> commonElements;\n    for (int e1 : l1) {\n        for (int e2 : l2) {\n            if (e1 == e2) {\n                commonElements.insert(e1);\n            }\n        }\n    }\n    std::vector<int> result(commonElements.begin(), commonElements.end());\n    std::sort(result.begin(), result.end());\n    return result;\n}\n", "py_code": "def common(l1: list, l2: list):\n    ret = set()\n    for e1 in l1:\n        for e2 in l2:\n            if e1 == e2:\n                ret.add(e1)\n    return sorted(list(ret))\n", "py_summary": "The Python code defines a function that takes two lists of integers as input and returns a sorted list of unique common elements between the two input lists. It initializes an empty set `ret` to store the common elements. Then, it iterates through each element in the first list and compares it with each element in the second list. If there is a match, the common element is added to the set `ret`. Finally, the function converts the set to a list, sorts it, and returns the sorted list of common elements."}
{"task_id": "CPP/59", "generation": "#include <stdio.h>\n#include <math.h>\n\nint largest_prime_factor(int n) {\n    int largest = 1;\n    for (int j = 2; j <= n; j++) {\n        if (n % j == 0) {\n            bool isPrime = true;\n            for (int i = 2; i <= sqrt(j); i++) {\n                if (j % i == 0) {\n                    isPrime = false;\n                    break;\n                }\n            }\n            if (isPrime) {\n                largest = std::max(largest, j);\n            }\n        }\n    }\n    return largest;\n}\n", "py_code": "def largest_prime_factor(n: int):\n    def is_prime(k):\n        if k < 2:\n            return False\n        for i in range(2, k - 1):\n            if k % i == 0:\n                return False\n        return True\n    largest = 1\n    for j in range(2, n + 1):\n        if n % j == 0 and is_prime(j):\n            largest = max(largest, j)\n    return largest\n", "py_summary": "The Python code defines a function `largest_prime_factor` that takes an integer `n` as input and returns the largest prime factor of `n`. It first defines a helper function `is_prime` to check if a number is prime. \n\nThe `largest_prime_factor` function initializes a variable `largest` to 1. It then iterates through numbers from 2 to `n`, checking if the number is a factor of `n` and if it is prime. If both conditions are met, it updates the `largest` variable to the maximum of the current `largest` and the prime factor found. Finally, it returns the largest prime factor of `n`."}
{"task_id": "CPP/60", "generation": "#include<stdio.h>\nusing namespace std;\nint sum_to_n(int n){\n    int sum = 0;\n    for (int i = 1; i <= n; i++) {\n        sum += i;\n    }\n    return sum;\n}\n", "py_code": "def sum_to_n(n: int):\n    return sum(range(n + 1))\n", "py_summary": "The Python code defines a function `sum_to_n` that takes an integer `n` as input and returns the sum of numbers from 1 to `n` inclusive. It achieves this by using the `range` function to generate a sequence of numbers from 1 to `n`, and then calculates the sum of this sequence using the `sum` function."}
{"task_id": "CPP/61", "generation": "bool correct_bracketing(string brackets) {\n    int depth = 0;\n    for (char b : brackets) {\n        if (b == '(') {\n            depth++;\n        } else {\n            depth--;\n        }\n        if (depth < 0) {\n            return false;\n        }\n    }\n    return depth == 0;\n}\n", "py_code": "def correct_bracketing(brackets: str):\n    depth = 0\n    for b in brackets:\n        if b == \"(\":\n            depth += 1\n        else:\n            depth -= 1\n        if depth < 0:\n            return False\n    return depth == 0\n", "py_summary": "The Python code defines a function that takes a string of brackets as input and checks if the bracketing is correct, meaning that every opening bracket has a corresponding closing bracket. The function iterates through each character in the input string and maintains a `depth` variable to keep track of the balance between opening and closing brackets. \n\nIf an opening bracket is encountered, the depth is incremented by 1. If a closing bracket is encountered, the depth is decremented by 1. If at any point the depth becomes negative, it means there is a closing bracket without a corresponding opening bracket, and the function returns False. \n\nAfter iterating through all brackets, the function checks if the final depth is zero, which indicates that all opening brackets have been closed by corresponding closing brackets. If the depth is zero, the function returns True; otherwise, it returns False."}
{"task_id": "CPP/62", "generation": "#include <stdio.h>\n#include <math.h>\n#include <vector>\nusing namespace std;\n\nvector<float> derivative(vector<float> xs) {\n    vector<float> result;\n    for (int i = 1; i < xs.size(); i++) {\n        result.push_back(i * xs[i]);\n    }\n    return result;\n}\n", "py_code": "def derivative(xs: list):\n    return [(i * x) for i, x in enumerate(xs)][1:]\n", "py_summary": "The Python code defines a function that takes a list of coefficients of a polynomial as input and returns the derivative of the polynomial in the same form. It uses list comprehension to iterate over the coefficients and multiply each coefficient by its corresponding power of x (index). The derivative is obtained by discarding the constant term (coefficient of x^0) and returning the rest of the terms."}
{"task_id": "CPP/63", "generation": "int fibfib(int n){\n    if (n == 0)\n        return 0;\n    if (n == 1)\n        return 0;\n    if (n == 2)\n        return 1;\n    return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3);\n}\n", "py_code": "def fibfib(n: int):\n    if n == 0:\n        return 0\n    if n == 1:\n        return 0\n    if n == 2:\n        return 1\n    return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)\n", "py_summary": "The Python code defines a recursive function `fibfib` that calculates the n-th element of the FibFib number sequence. The base cases are defined for n equal to 0, 1, and 2. For any other value of n, the function recursively calculates the n-th element using the formula `fibfib(n) = fibfib(n-1) + fibfib(n-2) + fibfib(n-3)`. This approach relies on recursion to build up the sequence until reaching the desired n-th element."}
{"task_id": "CPP/64", "generation": "int vowels_count(string s){\n    string vowels = \"aeiouAEIOU\";\n    int n_vowels = 0;\n    for (char c : s) {\n        if (vowels.find(c) != string::npos) {\n            n_vowels++;\n        }\n    }\n    if (s.back() == 'y' || s.back() == 'Y') {\n        n_vowels++;\n    }\n    return n_vowels;\n}\n", "py_code": "FIX = \"\"\"\nAdd more test cases.\n\"\"\"\n\ndef vowels_count(s):\n    vowels = \"aeiouAEIOU\"\n    n_vowels = sum(c in vowels for c in s)\n    if s[-1] == 'y' or s[-1] == 'Y':\n        n_vowels += 1\n    return n_vowels\n", "py_summary": "The Python code defines a function `vowels_count` that takes a string `s` as input and returns the number of vowels in the string. It first defines a string `vowels` containing all the vowels (both lowercase and uppercase). Then, it calculates the number of vowels in the input string `s` by counting the occurrences of characters that are present in the `vowels` string. \n\nAdditionally, it checks if the last character of the string is 'y' or 'Y' and increments the vowel count by 1 if the condition is met. Finally, it returns the total count of vowels in the string."}
{"task_id": "CPP/65", "generation": "#include <stdio.h>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nstring circular_shift(int x, int shift) {\n    string s = to_string(x);\n    if (shift > s.size()) {\n        reverse(s.begin(), s.end());\n        return s;\n    } else {\n        return s.substr(s.size() - shift) + s.substr(0, s.size() - shift);\n    }\n}\n", "py_code": "def circular_shift(x, shift):\n    s = str(x)\n    if shift > len(s):\n        return s[::-1]\n    else:\n        return s[len(s) - shift:] + s[:len(s) - shift]\n", "py_summary": "The Python code defines a function that takes an integer `x` and an integer `shift` as input and performs a circular shift operation on the digits of `x`. The function first converts the integer `x` to a string `s`. \n\nIf the value of `shift` is greater than the length of the string `s`, the function returns the reverse of the string `s`. Otherwise, it performs the circular shift operation by concatenating the substring of `s` starting from index `len(s) - shift` with the substring of `s` from index `0` to `len(s) - shift`.\n\nFinally, the function returns the result of the circular shift operation as a string."}
{"task_id": "CPP/66", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\nint digitSum(string s){\n    int sum = 0;\n    for (char c : s) {\n        if (isupper(c)) {\n            sum += c;\n        }\n    }\n    return sum;\n}\n", "py_code": "def digitSum(s):\n    if s == \"\": return 0\n    return sum(ord(char) if char.isupper() else 0 for char in s)\n", "py_summary": "The Python code defines a function `digitSum` that takes a string `s` as input and calculates the sum of the ASCII codes of the uppercase characters in the string. \n- If the input string is empty, the function returns 0.\n- It then uses a list comprehension to iterate over each character in the string. \n- For each character, it checks if it is uppercase using the `isupper()` method. \n- If the character is uppercase, it calculates the ASCII value using the `ord()` function, otherwise, it assigns 0. \n- Finally, it returns the sum of all the ASCII values calculated for the uppercase characters in the string."}
{"task_id": "CPP/67", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nint fruit_distribution(string s, int n) {\n    int apples = 0;\n    int oranges = 0;\n    for (int i = 0; i < s.size(); i++) {\n        if (isdigit(s[i])) {\n            int num = 0;\n            while (i < s.size() && isdigit(s[i])) {\n                num = num * 10 + (s[i] - '0');\n                i++;\n            }\n            if (s[i] == 'a') {\n                apples = num;\n            } else if (s[i] == 'o') {\n                oranges = num;\n            }\n        }\n    }\n    return n - apples - oranges;\n}\n", "py_code": "def fruit_distribution(s,n):\n    lis = list()\n    for i in s.split(' '):\n        if i.isdigit():\n            lis.append(int(i))\n    return n - sum(lis)\n", "py_summary": "The Python code defines a function that takes a string `s` representing the distribution of apples and oranges in a basket, and an integer `n` representing the total number of fruits in the basket. The function first initializes an empty list `lis` to store the counts of apples and oranges. It then splits the input string by space and iterates through the resulting list. If an element in the list is a digit, it converts it to an integer and appends it to the `lis` list. Finally, the function returns the difference between the total number of fruits `n` and the sum of counts of apples and oranges in the list."}
{"task_id": "CPP/68", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\nvector<int> pluck(vector<int> arr){\n    vector<int> result = {};\n    if(arr.empty()) return result;\n    \n    vector<int> evens;\n    for(int i=0; i<arr.size(); i++){\n        if(arr[i] % 2 == 0){\n            evens.push_back(arr[i]);\n        }\n    }\n    \n    if(evens.empty()) return result;\n    \n    int min_even = evens[0];\n    int min_index = 0;\n    for(int i=1; i<evens.size(); i++){\n        if(evens[i] < min_even){\n            min_even = evens[i];\n            min_index = i;\n        }\n    }\n    \n    for(int i=0; i<arr.size(); i++){\n        if(arr[i] == min_even){\n            min_index = i;\n            break;\n        }\n    }\n    \n    result.push_back(min_even);\n    result.push_back(min_index);\n    \n    return result;\n}\n", "py_code": "def pluck(arr):\n    if(len(arr) == 0): return []\n    evens = list(filter(lambda x: x%2 == 0, arr))\n    if(evens == []): return []\n    return [min(evens), arr.index(min(evens))]\n", "py_summary": "The Python code defines a function that takes a list of integers as input and returns a vector containing the smallest even value and its index in the input list. If the input list is empty or does not contain any even values, an empty list is returned. \n\nThe function first checks if the input list is empty, and if so, returns an empty list. It then filters the even values from the input list using the `filter` function and a lambda function that checks if a number is even. If there are no even values in the input list, an empty list is returned. \n\nFinally, the function returns a list containing the smallest even value and its index in the input list. If there are multiple occurrences of the smallest even value, the index of the first occurrence is returned."}
{"task_id": "CPP/69", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nint search(vector<int> lst) {\n    vector<int> frq(*max_element(lst.begin(), lst.end()) + 1, 0);\n    for (int i : lst) {\n        frq[i]++;\n    }\n\n    int ans = -1;\n    for (int i = 1; i < frq.size(); i++) {\n        if (frq[i] >= i) {\n            ans = i;\n        }\n    }\n\n    return ans;\n}\n", "py_code": "def search(lst):\n    frq = [0] * (max(lst) + 1)\n    for i in lst:\n        frq[i] += 1;\n\n    ans = -1\n    for i in range(1, len(frq)):\n        if frq[i] >= i:\n            ans = i\n    \n    return ans\n", "py_summary": "The Python code defines a function that takes a list of positive integers as input and returns the greatest integer that has a frequency greater than or equal to the value of the integer itself. \n\n1. It first creates a frequency list `frq` initialized with zeros, where the index represents the integer and the value represents its frequency in the input list.\n2. It then iterates through the input list and updates the frequency of each integer in the `frq` list.\n3. Next, it initializes the answer `ans` to -1 and iterates through the frequency list from 1 to the maximum integer in the input list.\n4. If the frequency of an integer is greater than or equal to the integer itself, it updates the answer to that integer.\n5. Finally, it returns the answer.\n\nThe code efficiently finds the required integer by calculating the frequency of each integer and comparing it with the integer itself."}
{"task_id": "CPP/70", "generation": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> strange_sort_list(vector<int> lst) {\n    vector<int> res;\n    bool switch_val = true;\n    while (!lst.empty()) {\n        if (switch_val) {\n            res.push_back(*min_element(lst.begin(), lst.end()));\n            lst.erase(min_element(lst.begin(), lst.end()));\n        } else {\n            res.push_back(*max_element(lst.begin(), lst.end()));\n            lst.erase(max_element(lst.begin(), lst.end()));\n        }\n        switch_val = !switch_val;\n    }\n    return res;\n}\n", "py_code": "def strange_sort_list(lst):\n    res, switch = [], True\n    while lst:\n        res.append(min(lst) if switch else max(lst))\n        lst.remove(res[-1])\n        switch = not switch\n    return res\n", "py_summary": "The Python code defines a function that takes a list of integers as input and returns a new list in a \"strange\" order. The strange order is achieved by alternately selecting the minimum and maximum values from the input list and appending them to the result list. \n\nThe function initializes an empty list `res` to store the result and a boolean variable `switch` to control whether to select the minimum or maximum value next. It then enters a loop that continues as long as the input list `lst` is not empty. \n\nWithin each iteration of the loop, the function appends either the minimum or maximum value of the remaining elements in `lst` based on the value of `switch`. It then removes the selected value from `lst` and toggles the value of `switch` for the next iteration. Finally, the function returns the resulting list `res` in the strange order."}
{"task_id": "CPP/71", "generation": "float triangle_area(float a, float b, float c) {\n    if (a + b <= c || a + c <= b || b + c <= a) {\n        return -1;\n    }\n    float s = (a + b + c) / 2;\n    float area = sqrt(s * (s - a) * (s - b) * (s - c));\n    area = round(area * 100) / 100; // rounding to 2 decimal points\n    return area;\n}\n", "py_code": "def triangle_area(a, b, c):\n    if a + b <= c or a + c <= b or b + c <= a:\n        return -1 \n    s = (a + b + c)/2    \n    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5\n    area = round(area, 2)\n    return area\n", "py_summary": "The Python code defines a function that calculates the area of a triangle given the lengths of its three sides. It first checks if the three sides form a valid triangle by verifying the triangle inequality theorem: the sum of the lengths of any two sides of a triangle must be greater than the length of the third side. If the sides do not form a valid triangle, the function returns -1.\n\nIf the sides form a valid triangle, the function calculates the semi-perimeter (s) of the triangle using the formula s = (a + b + c) / 2, where a, b, and c are the lengths of the sides. Then, it calculates the area of the triangle using Heron's formula: area = sqrt(s * (s - a) * (s - b) * (s - c)), where sqrt is the square root function. Finally, the area is rounded to 2 decimal points and returned."}
{"task_id": "CPP/72", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\nbool will_it_fly(vector<int> q,int w){\n    if (accumulate(q.begin(), q.end(), 0) > w)\n        return false;\n    \n    int i = 0, j = q.size()-1;\n    while (i < j) {\n        if (q[i] != q[j])\n            return false;\n        i++;\n        j--;\n    }\n    return true;\n}\n", "py_code": "def will_it_fly(q,w):\n    if sum(q) > w:\n        return False\n\n    i, j = 0, len(q)-1\n    while i<j:\n        if q[i] != q[j]:\n            return False\n        i+=1\n        j-=1\n    return True\n", "py_summary": "The Python code defines a function that takes a list of integers `q` and an integer `w` as input and returns a boolean value indicating whether the object can fly or not. The function first checks if the sum of elements in the list `q` is greater than the maximum weight `w`. If it is, the function immediately returns `False`.\n\nNext, the function initializes two pointers `i` and `j` to the start and end of the list respectively. It then iterates through the list from both ends towards the center. If at any point the elements at the current positions `i` and `j` are not equal, the function returns `False` indicating that the list is unbalanced. If the loop completes without finding any unbalanced elements, the function returns `True` indicating that the list is balanced and the sum of elements is within the maximum weight limit."}
{"task_id": "CPP/73", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\nint smallest_change(vector<int> arr){\n    int ans = 0;\n    for (int i = 0; i < arr.size() / 2; i++) {\n        if (arr[i] != arr[arr.size() - i - 1]) {\n            ans++;\n        }\n    }\n    return ans;\n}\n", "py_code": "def smallest_change(arr):\n    ans = 0\n    for i in range(len(arr) // 2):\n        if arr[i] != arr[len(arr) - i - 1]:\n            ans += 1\n    return ans\n", "py_summary": "The Python code defines a function that takes a list of integers as input and calculates the minimum number of elements that need to be changed to make the list palindromic. It iterates through the list up to the middle element and compares elements from the start and end of the list. If the elements are not the same, it increments the answer variable. Finally, the function returns the total number of changes needed to make the list palindromic."}
{"task_id": "CPP/74", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\nvector<string> total_match(vector<string> lst1,vector<string> lst2){\n    int l1 = 0;\n    for (string st : lst1) {\n        l1 += st.length();\n    }\n    \n    int l2 = 0;\n    for (string st : lst2) {\n        l2 += st.length();\n    }\n    \n    if (l1 <= l2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n", "py_code": "def total_match(lst1, lst2):\n    l1 = 0\n    for st in lst1:\n        l1 += len(st)\n    \n    l2 = 0\n    for st in lst2:\n        l2 += len(st)\n    \n    if l1 <= l2:\n        return lst1\n    else:\n        return lst2\n", "py_summary": "The Python code defines a function that takes two lists of strings as input and compares the total number of characters in all the strings of each list. It calculates the total number of characters in each list by iterating through the strings and summing up their lengths. Then, it compares the total character count of the two lists and returns the list with the lesser total character count. If the total character counts are equal, it returns the first list."}
{"task_id": "CPP/75", "generation": "#include <stdio.h>\n#include <vector>\n\nbool is_prime(int n) {\n    for (int j = 2; j < n; j++) {\n        if (n % j == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nbool is_multiply_prime(int a) {\n    for (int i = 2; i < 100; i++) {\n        if (!is_prime(i)) continue;\n        for (int j = 2; j < 100; j++) {\n            if (!is_prime(j)) continue;\n            for (int k = 2; k < 100; k++) {\n                if (!is_prime(k)) continue;\n                if (i * j * k == a) return true;\n            }\n        }\n    }\n    return false;\n}\n", "py_code": "def is_multiply_prime(a):\n    def is_prime(n):\n        for j in range(2,n):\n            if n%j == 0:\n                return False\n        return True\n\n    for i in range(2,101):\n        if not is_prime(i): continue\n        for j in range(2,101):\n            if not is_prime(j): continue\n            for k in range(2,101):\n                if not is_prime(k): continue\n                if i*j*k == a: return True\n    return False\n", "py_summary": "The Python code defines a function `is_multiply_prime(a)` that takes an integer `a` as input and checks if `a` can be expressed as the product of 3 prime numbers less than 100. \n\nThe function first defines a helper function `is_prime(n)` to check if a number `n` is prime by iterating from 2 to `n-1` and checking if `n` is divisible by any number in that range. \n\nThen, the main function iterates through all prime numbers less than 100 (from 2 to 100) and for each combination of 3 prime numbers, it checks if their product is equal to the input number `a`. If such a combination is found, the function returns `True`, indicating that `a` is the product of 3 prime numbers. If no such combination is found, the function returns `False`."}
{"task_id": "CPP/76", "generation": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\nbool is_simple_power(int x, int n){\n    if (n == 1) {\n        return (x == 1);\n    }\n    int power = 1;\n    while (power < x) {\n        power = power * n;\n    }\n    return (power == x);\n}\n", "py_code": "def is_simple_power(x, n):\n    if (n == 1): \n        return (x == 1) \n    power = 1\n    while (power < x): \n        power = power * n \n    return (power == x) \n", "py_summary": "The Python code defines a function that checks if a given number `x` is a simple power of another number `n`. A number `x` is considered a simple power of `n` if `n` raised to an integer power equals `x`. \n\nThe function first handles a special case where `n` is 1, in which case `x` must also be 1 to be a simple power. For other cases, the function initializes a variable `power` to 1 and iteratively multiplies `power` by `n` until `power` becomes greater than or equal to `x`. If `power` is equal to `x` at the end of the loop, then `x` is a simple power of `n`, and the function returns `True`, otherwise it returns `False`."}
{"task_id": "CPP/77", "generation": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\nbool iscube(int a){\n    a = abs(a);\n    int cube_root = round(pow(a, 1.0 / 3));\n    return cube_root * cube_root * cube_root == a;\n}\n", "py_code": "def iscube(a):\n    a = abs(a)\n    return int(round(a ** (1. / 3))) ** 3 == a\n", "py_summary": "The Python code defines a function that takes an integer `a` as input and returns `True` if the integer is a cube of some integer number. The function first takes the absolute value of `a` to handle negative numbers. It then calculates the cube root of `a` using the formula `a ** (1. / 3)` and rounds it to the nearest integer. Finally, it checks if the cube of the rounded value is equal to `a`, and returns `True` if they are equal, indicating that `a` is a cube of some integer."}
{"task_id": "CPP/78", "generation": "#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\nint hex_key(string num){\n    string primes = \"2357BD\";\n    int total = 0;\n    for (int i = 0; i < num.size(); i++) {\n        if (primes.find(num[i]) != string::npos) {\n            total++;\n        }\n    }\n    return total;\n}\n", "py_code": "def hex_key(num):\n    primes = ('2', '3', '5', '7', 'B', 'D')\n    total = 0\n    for i in range(0, len(num)):\n        if num[i] in primes:\n            total += 1\n    return total\n", "py_summary": "The Python code defines a function `hex_key` that takes a hexadecimal number as a string input and counts the number of prime hexadecimal digits present in the input. It initializes a tuple `primes` containing the prime hexadecimal digits ('2', '3', '5', '7', 'B', 'D'). Then, it initializes a variable `total` to keep track of the count of prime digits found.\n\nThe function iterates through each character in the input string using a for loop and checks if the character is present in the `primes` tuple. If the character is a prime hexadecimal digit, it increments the `total` count.\n\nFinally, the function returns the total count of prime hexadecimal digits found in the input string."}
{"task_id": "CPP/79", "generation": "#include <string>\n\nstring decimal_to_binary(int decimal) {\n    string binary = \"db\";\n    while (decimal > 0) {\n        binary = ((decimal & 1) ? '1' : '0') + binary;\n        decimal >>= 1;\n    }\n    return binary + \"db\";\n}\n", "py_code": "def decimal_to_binary(decimal):\n    return \"db\" + bin(decimal)[2:] + \"db\"\n", "py_summary": "The Python code defines a function that takes an integer `decimal` as input and converts it to its binary representation as a string. The function uses the built-in `bin()` function to convert the decimal number to binary format. It then concatenates the binary representation with the prefix \"db\" and suffix \"db\" to match the required format. The function finally returns the formatted binary string."}
{"task_id": "CPP/80", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\nbool is_happy(string s){\n    if (s.length() < 3)\n        return false;\n    \n    for (int i = 0; i < s.length() - 2; i++) {\n        if (s[i] == s[i+1] || s[i+1] == s[i+2] || s[i] == s[i+2])\n            return false;\n    }\n    return true;\n}\n", "py_code": "def is_happy(s):\n    if len(s) < 3:\n      return False\n\n    for i in range(len(s) - 2):\n      \n      if s[i] == s[i+1] or s[i+1] == s[i+2] or s[i] == s[i+2]:\n        return False\n    return True\n", "py_summary": "The Python code defines a function `is_happy` that takes a string `s` as input and checks if the string is happy or not based on the given conditions. \n1. If the length of the string is less than 3, the function immediately returns False.\n2. It then iterates through the string up to the third last character (to ensure there are at least 3 characters remaining).\n3. For each set of 3 consecutive characters, it checks if any two characters are the same. If any two characters are the same, it returns False.\n4. If the loop completes without finding any consecutive characters that are the same, it returns True, indicating that the string is happy.\n\nThe function effectively checks for the happiness condition by ensuring that every 3 consecutive characters in the string are distinct."}
{"task_id": "CPP/81", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\nvector<string> numerical_letter_grade(vector<float> grades){\n    vector<string> letter_grades;\n    for (float gpa : grades) {\n        if (gpa == 4.0)\n            letter_grades.push_back(\"A+\");\n        else if (gpa > 3.7)\n            letter_grades.push_back(\"A\");\n        else if (gpa > 3.3)\n            letter_grades.push_back(\"A-\");\n        else if (gpa > 3.0)\n            letter_grades.push_back(\"B+\");\n        else if (gpa > 2.7)\n            letter_grades.push_back(\"B\");\n        else if (gpa > 2.3)\n            letter_grades.push_back(\"B-\");\n        else if (gpa > 2.0)\n            letter_grades.push_back(\"C+\");\n        else if (gpa > 1.7)\n            letter_grades.push_back(\"C\");\n        else if (gpa > 1.3)\n            letter_grades.push_back(\"C-\");\n        else if (gpa > 1.0)\n            letter_grades.push_back(\"D+\");\n        else if (gpa > 0.7)\n            letter_grades.push_back(\"D\");\n        else if (gpa > 0.0)\n            letter_grades.push_back(\"D-\");\n        else\n            letter_grades.push_back(\"E\");\n    }\n    return letter_grades;\n}\n", "py_code": "def numerical_letter_grade(grades):\n\n   \n    letter_grade = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grade.append(\"A+\")\n        elif gpa > 3.7:\n            letter_grade.append(\"A\")\n        elif gpa > 3.3:\n            letter_grade.append(\"A-\")\n        elif gpa > 3.0:\n            letter_grade.append(\"B+\")\n        elif gpa > 2.7:\n            letter_grade.append(\"B\")\n        elif gpa > 2.3:\n            letter_grade.append(\"B-\")\n        elif gpa > 2.0:\n            letter_grade.append(\"C+\")\n        elif gpa > 1.7:\n            letter_grade.append(\"C\")\n        elif gpa > 1.3:\n            letter_grade.append(\"C-\")\n        elif gpa > 1.0:\n            letter_grade.append(\"D+\")\n        elif gpa > 0.7:\n            letter_grade.append(\"D\")\n        elif gpa > 0.0:\n            letter_grade.append(\"D-\")\n        else:\n            letter_grade.append(\"E\")\n    return letter_grade\n", "py_summary": "The Python code defines a function that takes a list of GPAs as input and returns a list of corresponding letter grades based on the GPA-to-letter grade conversion table provided. It iterates through each GPA in the input list and determines the letter grade based on the GPA value according to the specified conditions. The function then appends the corresponding letter grade to a new list and finally returns the list of letter grades."}
{"task_id": "CPP/82", "generation": "#include<stdio.h>\n#include<string>\n#include<math.h>\nusing namespace std;\n\nbool prime_length(string str){\n    int l = str.length();\n    if (l == 0 || l == 1) {\n        return false;\n    }\n    for (int i = 2; i <= sqrt(l); i++) {\n        if (l % i == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n", "py_code": "def prime_length(string):\n    l = len(string)\n    if l == 0 or l == 1:\n        return False\n    for i in range(2, l):\n        if l % i == 0:\n            return False\n    return True\n", "py_summary": "The Python code defines a function that takes a string as input and checks if the length of the string is a prime number. It first calculates the length of the input string and then iterates from 2 to the length of the string - 1. For each iteration, it checks if the length is divisible by the current number in the loop. If the length is divisible by any number other than 1 and itself, the function returns False, indicating that the length is not a prime number. If the loop completes without finding any divisors, the function returns True, indicating that the length is a prime number."}
{"task_id": "CPP/83", "generation": "int starts_one_ends(int n){\n    if (n == 1) return 1;\n    return 18 * static_cast<int>(pow(10, n - 2));\n}\n", "py_code": "def starts_one_ends(n):\n    if n == 1: return 1\n    return 18 * (10 ** (n - 2))\n", "py_summary": "The Python code defines a function that takes a positive integer `n` as input and returns the count of n-digit positive integers that start or end with 1. If n is equal to 1, there is only one number (1-digit) that starts or ends with 1. For n greater than 1, the function calculates the count using the formula 18 * (10 ** (n - 2)), which represents the number of possibilities for the remaining digits after fixing the first and last digit as 1."}
{"task_id": "CPP/84", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nstring solve(int N) {\n    int sum = 0;\n    int num = N;\n    while (num > 0) {\n        sum += num % 10;\n        num /= 10;\n    }\n    return bitset<32>(sum).to_string().substr(32 - __builtin_clz(sum));\n}\n", "py_code": "def solve(N):\n    return bin(sum(int(i) for i in str(N)))[2:]\n", "py_summary": "The Python code defines a function that takes a positive integer `N` as input and returns the sum of its digits in binary format. The function first converts the integer `N` to a string, iterates over each digit in the string, converts it back to an integer, and calculates the sum of all digits. Then, it converts the sum to a binary representation using the `bin()` function and returns the binary string starting from the index 2 to remove the '0b' prefix."}
{"task_id": "CPP/85", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\nint add(vector<int> lst){\n    int sum = 0;\n    for (int i = 1; i < lst.size(); i += 2) {\n        if (lst[i] % 2 == 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n", "py_code": "def add(lst):\n    return sum([lst[i] for i in range(1, len(lst), 2) if lst[i]%2 == 0])\n", "py_summary": "The Python code defines a function that takes a list of integers as input and returns the sum of even elements that are at odd indices in the list. It uses list comprehension to iterate over the list starting from index 1 with a step of 2 (odd indices). Within the list comprehension, it checks if the element at the current index is even and adds it to the sum. Finally, the function returns the sum of even elements at odd indices."}
{"task_id": "CPP/86", "generation": "#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\nstring anti_shuffle(string s){\n    string result = \"\";\n    string word = \"\";\n    for (char c : s) {\n        if (c == ' ') {\n            sort(word.begin(), word.end());\n            result += word + ' ';\n            word = \"\";\n        } else {\n            word += c;\n        }\n    }\n    sort(word.begin(), word.end());\n    result += word;\n    return result;\n}\n", "py_code": "def anti_shuffle(s):\n    return ' '.join([''.join(sorted(list(i))) for i in s.split(' ')])\n", "py_summary": "The Python code defines a function `anti_shuffle` that takes a string as input and returns the ordered version of the string. The function splits the input string into words using the `split(' ')` method, then iterates over each word. For each word, it converts the word into a list of characters, sorts the characters in ascending order based on their ASCII values using the `sorted` function, and then joins the sorted characters back into a string. Finally, it joins all the processed words back together with spaces using the `join` method and returns the resulting string."}
{"task_id": "CPP/87", "generation": "#include <vector>\n#include <algorithm>\n\nvector<vector<int>> get_row(vector<vector<int>> lst, int x) {\n    vector<vector<int>> coords;\n    for (int i = 0; i < lst.size(); i++) {\n        for (int j = 0; j < lst[i].size(); j++) {\n            if (lst[i][j] == x) {\n                coords.push_back({i, j});\n            }\n        }\n    }\n    \n    sort(coords.begin(), coords.end(), [](const vector<int>& a, const vector<int>& b) {\n        return a[1] > b[1];\n    });\n    \n    sort(coords.begin(), coords.end(), [](const vector<int>& a, const vector<int>& b) {\n        return a[0] < b[0];\n    });\n    \n    return coords;\n}\n", "py_code": "def get_row(lst, x):\n    coords = [(i, j) for i in range(len(lst)) for j in range(len(lst[i])) if lst[i][j] == x]\n    return sorted(sorted(coords, key=lambda x: x[1], reverse=True), key=lambda x: x[0])\n", "py_summary": "The Python code defines a function `get_row` that takes a nested list `lst` and an integer `x` as input. It then creates a list of coordinates `(i, j)` where `i` represents the row index and `j` represents the column index of integer `x` in the nested list. These coordinates are filtered based on the presence of integer `x` in the nested list.\n\nThe function then sorts the coordinates first by columns in descending order and then by rows in ascending order using lambda functions as key functions for sorting. Finally, it returns the sorted list of coordinates."}
{"task_id": "CPP/88", "generation": "vector<int> sort_array(vector<int> array){\n    if(array.empty()) return {};\n    if((array[0] + array[array.size()-1]) % 2 == 0){\n        sort(array.begin(), array.end(), greater<int>());\n    } else {\n        sort(array.begin(), array.end());\n    }\n    return array;\n}\n", "py_code": "def sort_array(array):\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0) \n", "py_summary": "The Python code defines a function that takes a list of non-negative integers as input and returns a sorted copy of the input list based on the sum of the first and last elements. If the sum is odd, the list is sorted in ascending order, and if the sum is even, the list is sorted in descending order. \n\nThe function first checks if the input list is empty, in which case it returns an empty list. Otherwise, it uses the `sorted` function with the `reverse` parameter set to True if the sum of the first and last elements is even (indicating descending order) and False if it is odd (indicating ascending order). The sorted list is then returned."}
{"task_id": "CPP/89", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nstring encrypt(string s) {\n    string alphabet = \"abcdefghijklmnopqrstuvwxyz\";\n    string output = \"\";\n    for (char c : s) {\n        if (isalpha(c)) {\n            int index = alphabet.find(tolower(c));\n            int new_index = (index + 2 * 2) % 26;\n            output += islower(c) ? alphabet[new_index] : toupper(alphabet[new_index]);\n        } else {\n            output += c;\n        }\n    }\n    return output;\n}\n", "py_code": "def encrypt(s):\n    d = 'abcdefghijklmnopqrstuvwxyz'\n    out = ''\n    for c in s:\n        if c in d:\n            out += d[(d.index(c)+2*2) % 26]\n        else:\n            out += c\n    return out\n", "py_summary": "The Python code defines a function `encrypt` that takes a string as input and returns an encrypted string based on the rotation of the alphabet. The function first initializes a string `d` with the lowercase alphabet. It then iterates through each character in the input string `s`. \n\nFor each character, if it is a letter in the alphabet, the code calculates the new index of the character after rotating down by two multiplied to two places. The new character is obtained by accessing the alphabet string `d` at the calculated index. If the character is not in the alphabet, it is directly added to the output string.\n\nFinally, the function returns the encrypted string obtained after processing each character in the input string."}
{"task_id": "CPP/90", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nint next_smallest(vector<int> lst){\n    if (lst.size() < 2) {\n        return NULL;\n    }\n    sort(lst.begin(), lst.end());\n    vector<int> unique_lst;\n    unique_lst.push_back(lst[0]);\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i] != lst[i - 1]) {\n            unique_lst.push_back(lst[i]);\n        }\n    }\n    if (unique_lst.size() < 2) {\n        return NULL;\n    }\n    return unique_lst[1];\n}\n", "py_code": "def next_smallest(lst):\n    lst = sorted(set(lst))\n    return None if len(lst) < 2 else lst[1]\n", "py_summary": "The Python code defines a function `next_smallest` that takes a list of integers as input and returns the second smallest element in the list. \n1. It first removes duplicates from the list by converting it to a set and then sorting the unique elements in ascending order.\n2. It then checks if the length of the sorted list is less than 2. If so, it returns None since there is no second smallest element.\n3. Otherwise, it returns the element at index 1, which corresponds to the second smallest element in the list."}
{"task_id": "CPP/91", "generation": "#include <string>\n#include <cctype>\n\nint is_bored(std::string S) {\n    int count = 0;\n    bool new_sentence = true;\n    for (char c : S) {\n        if (new_sentence && std::toupper(c) == 'I') {\n            count++;\n            new_sentence = false;\n        }\n        if (c == '.' || c == '?' || c == '!') {\n            new_sentence = true;\n        }\n    }\n    return count;\n}\n", "py_code": "def is_bored(S):\n    import re\n    sentences = re.split(r'[.?!]\\s*', S)\n    return sum(sentence[0:2] == 'I ' for sentence in sentences)\n", "py_summary": "The Python code defines a function that takes a string `S` as input and counts the number of \"boredoms\" in the string. A boredom is defined as a sentence that starts with the word \"I\". \n\nThe function first imports the `re` module for regular expression operations. It then splits the input string `S` into sentences using the `re.split()` function with the regular expression pattern `[.?!]\\s*`, which matches '.', '?', or '!' followed by zero or more whitespace characters.\n\nNext, the function uses a list comprehension to iterate over the sentences and checks if the first two characters of each sentence are 'I '. If the condition is met, it increments a counter. Finally, the function returns the total count of sentences that start with 'I '."}
{"task_id": "CPP/92", "generation": "bool any_int(float a, float b, float c) {\n    if (a == int(a) && b == int(b) && c == int(c)) {\n        if (a + b == c || a + c == b || b + c == a) {\n            return true;\n        }\n    }\n    return false;\n}\n", "py_code": "def any_int(x, y, z):\n    \n    if isinstance(x,int) and isinstance(y,int) and isinstance(z,int):\n        if (x+y==z) or (x+z==y) or (y+z==x):\n            return True\n        return False\n    return False\n", "py_summary": "The Python code defines a function `any_int` that takes three input numbers `x`, `y`, and `z`. It first checks if all three numbers are integers using the `isinstance` function. If they are integers, it then checks if any one of the numbers is equal to the sum of the other two numbers. If this condition is met, the function returns `True`, indicating that one number is equal to the sum of the other two. If the condition is not met or if the input numbers are not all integers, the function returns `False`."}
{"task_id": "CPP/93", "generation": "#include <stdio.h>\n#include <string>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\n\nstring encode(string message) {\n    unordered_map<char, char> vowels_replace = {\n        {'a', 'c'}, {'e', 'g'}, {'i', 'k'}, {'o', 'q'}, {'u', 'w'},\n        {'A', 'C'}, {'E', 'G'}, {'I', 'K'}, {'O', 'Q'}, {'U', 'W'}\n    };\n\n    for (char& c : message) {\n        if (isalpha(c)) {\n            c = islower(c) ? toupper(c) : tolower(c); // Swap case\n            if (vowels_replace.find(c) != vowels_replace.end()) {\n                c = vowels_replace[c]; // Replace vowel\n            }\n        }\n    }\n\n    return message;\n}\n", "py_code": "def encode(message):\n    vowels = \"aeiouAEIOU\"\n    vowels_replace = dict([(i, chr(ord(i) + 2)) for i in vowels])\n    message = message.swapcase()\n    return ''.join([vowels_replace[i] if i in vowels else i for i in message])\n", "py_summary": "The Python code defines a function that encodes a message by swapping the case of all letters and replacing vowels with the letter that appears 2 places ahead of that vowel in the English alphabet. \n1. It first creates a dictionary `vowels_replace` that maps each vowel to the letter that appears 2 places ahead of it in the alphabet.\n2. It then swaps the case of all letters in the message using the `swapcase()` method.\n3. Finally, it iterates through each character in the message, replacing vowels with the corresponding letter from the `vowels_replace` dictionary if the character is a vowel, and keeping the character unchanged if it is not a vowel.\n4. The function returns the encoded message."}
{"task_id": "CPP/94", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nint skjkasdkd(vector<int> lst){\n    int maxx = 0;\n    auto isPrime = [](int n) {\n        for (int i = 2; i * i <= n; i++) {\n            if (n % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    };\n    \n    for (int i = 0; i < lst.size(); i++) {\n        if (lst[i] > maxx && isPrime(lst[i])) {\n            maxx = lst[i];\n        }\n    }\n    \n    int sum = 0;\n    while (maxx > 0) {\n        sum += maxx % 10;\n        maxx /= 10;\n    }\n    \n    return sum;\n}\n", "py_code": "def skjkasdkd(lst):\n    def isPrime(n):\n        for i in range(2,int(n**0.5)+1):\n            if n%i==0:\n                return False\n\n        return True\n    maxx = 0\n    i = 0\n    while i < len(lst):\n        if(lst[i] > maxx and isPrime(lst[i])):\n            maxx = lst[i]\n        i+=1\n    result = sum(int(digit) for digit in str(maxx))\n    return result\n\n", "py_summary": "The Python code defines a function `skjkasdkd` that takes a list of integers as input and returns the sum of digits of the largest prime number in the list. \n1. The code first defines a helper function `isPrime` to check if a number is prime.\n2. It initializes `maxx` to 0 to keep track of the largest prime number found so far.\n3. It iterates through the input list and updates `maxx` if a larger prime number is found.\n4. Finally, it calculates the sum of digits of the largest prime number and returns the result."}
{"task_id": "CPP/95", "generation": "#include <iostream>\n#include <string>\n#include <map>\n#include <cctype>\n\nbool check_dict_case(std::map<std::string, std::string> dict) {\n    if (dict.empty()) {\n        return false;\n    } else {\n        std::string state = \"start\";\n        for (const auto& pair : dict) {\n            const std::string& key = pair.first;\n            if (!std::all_of(key.begin(), key.end(), ::isalpha)) {\n                state = \"mixed\";\n                break;\n            }\n            if (state == \"start\") {\n                if (std::all_of(key.begin(), key.end(), ::islower)) {\n                    state = \"lower\";\n                } else if (std::all_of(key.begin(), key.end(), ::isupper)) {\n                    state = \"upper\";\n                } else {\n                    break;\n                }\n            } else if ((state == \"upper\" && !std::all_of(key.begin(), key.end(), ::isupper)) || (state == \"lower\" && !std::all_of(key.begin(), key.end(), ::islower))) {\n                state = \"mixed\";\n                break;\n            } else {\n                break;\n            }\n        }\n        return state == \"upper\" || state == \"lower\";\n    }\n}\n", "py_code": "def check_dict_case(dict):\n    if len(dict.keys()) == 0:\n        return False\n    else:\n        state = \"start\"\n        for key in dict.keys():\n\n            if isinstance(key, str) == False:\n                state = \"mixed\"\n                break\n            if state == \"start\":\n                if key.isupper():\n                    state = \"upper\"\n                elif key.islower():\n                    state = \"lower\"\n                else:\n                    break\n            elif (state == \"upper\" and not key.isupper()) or (state == \"lower\" and not key.islower()):\n                    state = \"mixed\"\n                    break\n            else:\n                break\n        return state == \"upper\" or state == \"lower\" \n", "py_summary": "The Python code defines a function `check_dict_case` that takes a dictionary as input and checks if all keys in the dictionary are strings and either all in lowercase or all in uppercase. The function first checks if the dictionary is empty, in which case it returns False.\n\nThen, it iterates through the keys of the dictionary and checks the case of the keys. It maintains a `state` variable to keep track of whether the keys are all in lowercase, all in uppercase, or mixed. If it encounters a key that is not a string, it immediately sets the state to \"mixed\" and breaks out of the loop.\n\nIf the keys are strings, it checks the case of the keys. If the keys are all in lowercase, it sets the state to \"lower\". If the keys are all in uppercase, it sets the state to \"upper\". If it encounters a key that does not match the expected case based on the current state, it sets the state to \"mixed\" and breaks out of the loop.\n\nFinally, the function returns True if the state is \"upper\" or \"lower\", indicating that all keys are either in uppercase or lowercase, and returns False otherwise.\n\nThe function effectively checks if all keys in the dictionary are strings and are either all in lowercase or all in uppercase.\n\n"}
{"task_id": "CPP/96", "generation": "#include<stdio.h>\n#include<vector>\n#include<cmath>\nusing namespace std;\n\nvector<int> count_up_to(int n){\n    vector<int> primes;\n    for (int i = 2; i < n; i++) {\n        bool is_prime = true;\n        for (int j = 2; j <= sqrt(i); j++) {\n            if (i % j == 0) {\n                is_prime = false;\n                break;\n            }\n        }\n        if (is_prime) {\n            primes.push_back(i);\n        }\n    }\n    return primes;\n}\n", "py_code": "def count_up_to(n):\n    primes = []\n    for i in range(2, n):\n        is_prime = True\n        for j in range(2, i):\n            if i % j == 0:\n                is_prime = False\n                break\n        if is_prime:\n            primes.append(i)\n    return primes\n\n", "py_summary": "The Python code defines a function that takes a non-negative integer `n` as input and returns a list of the first `n` prime numbers that are less than `n`. The function initializes an empty list `primes` to store the prime numbers found. It then iterates through numbers from 2 to `n-1` and for each number, it checks if it is a prime number by dividing it by numbers from 2 to the number itself. If the number is divisible by any number other than 1 and itself, it is not a prime number. If the number is prime, it is added to the `primes` list. Finally, the function returns the list of prime numbers.\n\nThe code uses a basic approach to check for prime numbers by iterating through all numbers less than the current number. This approach has a time complexity of O(n^2) which can be optimized further."}
{"task_id": "CPP/97", "generation": "int multiply(int a, int b){\n    int unit_a = abs(a % 10);\n    int unit_b = abs(b % 10);\n    return unit_a * unit_b;\n}\n", "py_code": "def multiply(a, b):\n    return abs(a % 10) * abs(b % 10)\n", "py_summary": "The Python code defines a function that takes two integers as input and returns the product of their unit digits. It uses the modulo operator (%) to extract the unit digit of each input integer by taking the remainder when divided by 10. Then, it calculates the product of the absolute values of the unit digits and returns the result. The absolute function is used to handle negative numbers and ensure that the product is always positive."}
{"task_id": "CPP/98", "generation": "int count_upper(string s){\n    int count = 0;\n    for (int i = 0; i < s.length(); i += 2) {\n        if (i < s.length() && s[i] >= 'A' && s[i] <= 'Z' && (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U')) {\n            count++;\n        }\n    }\n    return count;\n}\n", "py_code": "def count_upper(s):\n    count = 0\n    for i in range(0,len(s),2):\n        if s[i] in \"AEIOU\":\n            count += 1\n    return count\n", "py_summary": "The Python code defines a function that takes a string as input and counts the number of uppercase vowels in the characters at even indices (0-based) in the string. It initializes a count variable to 0 and then iterates through the string using a step of 2 to access characters at even indices. For each character at an even index, it checks if it is an uppercase vowel (A, E, I, O, U) and increments the count if it is. Finally, the function returns the total count of uppercase vowels at even indices in the string."}
{"task_id": "CPP/99", "generation": "#include <stdio.h>\n#include <math.h>\n#include <string>\nusing namespace std;\n\nint closest_integer(string value) {\n    double num = stod(value);\n    int res = 0;\n\n    if (value.substr(value.size() - 2) == \".5\") {\n        if (num > 0) {\n            res = ceil(num);\n        } else {\n            res = floor(num);\n        }\n    } else if (value.size() > 0) {\n        res = round(num);\n    }\n\n    return res;\n}\n", "py_code": "def closest_integer(value):\n    from math import floor, ceil\n\n    if value.count('.') == 1:\n        # remove trailing zeros\n        while (value[-1] == '0'):\n            value = value[:-1]\n\n    num = float(value)\n    if value[-2:] == '.5':\n        if num > 0:\n            res = ceil(num)\n        else:\n            res = floor(num)\n    elif len(value) > 0:\n        res = int(round(num))\n    else:\n        res = 0\n\n    return res\n\n", "py_summary": "The Python code defines a function that takes a string representing a number as input and returns the closest integer to that number. The function first checks if the input number contains a decimal point. If it does, it removes any trailing zeros after the decimal point.\n\nThen, the code converts the string number to a float and checks if the number is equidistant from two integers (e.g., ends with '.5'). If the number is equidistant, the function rounds it away from zero by using the `ceil` function for positive numbers and the `floor` function for negative numbers. If the number is not equidistant, the function rounds it to the nearest integer using the `round` function.\n\nFinally, the function returns the closest integer to the input number based on the rounding logic described above."}
{"task_id": "CPP/100", "generation": "#include <vector>\n\nstd::vector<int> make_a_pile(int n) {\n    std::vector<int> stones;\n    for (int i = 0; i < n; i++) {\n        stones.push_back(n + 2*i);\n    }\n    return stones;\n}\n", "py_code": "def make_a_pile(n):\n    return [n + 2*i for i in range(n)]\n", "py_summary": "The Python code defines a function that takes a positive integer `n` as input and returns a list of integers representing the number of stones in each level of the pile. The function uses list comprehension to generate the list based on the given formula: the number of stones in each level is the initial number `n` plus `2*i`, where `i` ranges from 0 to `n-1`. This formula ensures that for each level, the number of stones increases by 2 compared to the previous level."}
{"task_id": "CPP/101", "generation": "#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> words_string(string s) {\n    vector<string> words;\n    string word = \"\";\n    \n    for (char c : s) {\n        if (c == ',' || c == ' ') {\n            if (!word.empty()) {\n                words.push_back(word);\n                word = \"\";\n            }\n        } else {\n            word += c;\n        }\n    }\n    \n    if (!word.empty()) {\n        words.push_back(word);\n    }\n    \n    return words;\n}\n", "py_code": "def words_string(s):\n    if not s:\n        return []\n\n    s_list = []\n\n    for letter in s:\n        if letter == ',':\n            s_list.append(' ')\n        else:\n            s_list.append(letter)\n\n    s_list = \"\".join(s_list)\n    return s_list.split()\n", "py_summary": "The Python code defines a function `words_string` that takes a string `s` as input and splits the string into words based on spaces and commas. It initializes an empty list `s_list` to store the modified string. Then, it iterates through each character in the input string `s`. If the character is a comma, it appends a space to `s_list`, otherwise, it appends the character itself. After processing all characters, it joins the characters in `s_list` to form a single string and then splits this string based on spaces using the `split()` method. Finally, it returns the list of words obtained after splitting the string."}
{"task_id": "CPP/102", "generation": "int choose_num(int x, int y) {\n    if (x > y) {\n        return -1;\n    }\n    if (y % 2 == 0) {\n        return y;\n    }\n    if (x == y) {\n        return -1;\n    }\n    return y - 1;\n}\n", "py_code": "def choose_num(x, y):\n    if x > y:\n        return -1\n    if y % 2 == 0:\n        return y\n    if x == y:\n        return -1\n    return y - 1\n", "py_summary": "The Python code defines a function `choose_num` that takes two positive integers `x` and `y` as input and returns the biggest even integer number in the range `[x, y]` inclusive. If there is no even number in the range, the function returns -1. \n\nThe function first checks if `x` is greater than `y`, in which case it immediately returns -1. Then it checks if `y` is already an even number, in which case it returns `y`. If `y` is not even, the function checks if `x` is equal to `y`, in which case it returns -1. Finally, if none of the special cases apply, the function returns the biggest even number less than `y`."}
{"task_id": "CPP/103", "generation": "#include <string>\n#include <cmath>\n\nstring rounded_avg(int n, int m) {\n    if (n > m) {\n        return \"-1\";\n    }\n    int sum = 0;\n    for (int i = n; i <= m; i++) {\n        sum += i;\n    }\n    int avg = round((double)sum / (m - n + 1));\n    return bitset<32>(avg).to_string();\n}\n", "py_code": "def rounded_avg(n, m):\n    if m < n:\n        return -1\n    summation = 0\n    for i in range(n, m+1):\n        summation += i\n    return bin(round(summation/(m - n + 1)))\n", "py_summary": "The Python code defines a function `rounded_avg` that takes two integers `n` and `m` as input and calculates the average of all integers from `n` to `m` (inclusive). If `n` is greater than `m`, the function returns \"-1\". Otherwise, it calculates the sum of integers from `n` to `m` and then calculates the average. The average is rounded to the nearest integer and converted to binary format using the `bin()` function. The function returns the binary representation of the rounded average."}
{"task_id": "CPP/104", "generation": "vector<int> unique_digits(vector<int> x){\n    vector<int> odd_digit_elements;\n    for (int i : x) {\n        bool all_odd = true;\n        string num_str = to_string(i);\n        for (char c : num_str) {\n            if ((c - '0') % 2 == 0) {\n                all_odd = false;\n                break;\n            }\n        }\n        if (all_odd) {\n            odd_digit_elements.push_back(i);\n        }\n    }\n    sort(odd_digit_elements.begin(), odd_digit_elements.end());\n    return odd_digit_elements;\n}\n", "py_code": "def unique_digits(x):\n    odd_digit_elements = []\n    for i in x:\n        if all (int(c) % 2 == 1 for c in str(i)):\n            odd_digit_elements.append(i)\n    return sorted(odd_digit_elements)\n", "py_summary": "The Python code defines a function that takes a list of positive integers as input and returns a sorted list of elements that do not contain any even digits. The function iterates through each integer in the input list and checks if all the digits in the integer are odd by converting each digit to an integer and checking if it's odd (i.e., not divisible by 2). If all digits are odd, the integer is added to the `odd_digit_elements` list. Finally, the function returns the sorted `odd_digit_elements` list."}
{"task_id": "CPP/105", "generation": "vector<string> by_length(vector<int> arr){\n    map<int, string> dic = {\n        {1, \"One\"},\n        {2, \"Two\"},\n        {3, \"Three\"},\n        {4, \"Four\"},\n        {5, \"Five\"},\n        {6, \"Six\"},\n        {7, \"Seven\"},\n        {8, \"Eight\"},\n        {9, \"Nine\"}\n    };\n    \n    sort(arr.begin(), arr.end(), greater<int>());\n    \n    vector<string> new_arr;\n    for (int var : arr) {\n        if (dic.find(var) != dic.end()) {\n            new_arr.push_back(dic[var]);\n        }\n    }\n    \n    return new_arr;\n}\n", "py_code": "def by_length(arr):\n    dic = {\n        1: \"One\",\n        2: \"Two\",\n        3: \"Three\",\n        4: \"Four\",\n        5: \"Five\",\n        6: \"Six\",\n        7: \"Seven\",\n        8: \"Eight\",\n        9: \"Nine\",\n    }\n    sorted_arr = sorted(arr, reverse=True)\n    new_arr = []\n    for var in sorted_arr:\n        try:\n            new_arr.append(dic[var])\n        except:\n            pass\n    return new_arr\n", "py_summary": "The Python code defines a function that takes a list of integers as input, sorts the integers that are between 1 and 9 inclusive, reverses the resulting list, and replaces each integer by its corresponding name from \"One\" to \"Nine\". \n\n1. A dictionary `dic` is created to map integers to their corresponding names.\n2. The input list `arr` is sorted in descending order.\n3. A new list `new_arr` is initialized to store the converted names.\n4. Iterate through the sorted list, and for each integer, try to append its corresponding name from the dictionary to `new_arr`. If the integer is not in the dictionary (i.e., not between 1 and 9), ignore it.\n5. Finally, return the list of converted names."}
{"task_id": "CPP/106", "generation": "#include <vector>\n\nstd::vector<int> f(int n) {\n    std::vector<int> result;\n    for (int i = 1; i <= n; i++) {\n        if (i % 2 == 0) {\n            int factorial = 1;\n            for (int j = 1; j <= i; j++) {\n                factorial *= j;\n            }\n            result.push_back(factorial);\n        } else {\n            int sum = 0;\n            for (int j = 1; j <= i; j++) {\n                sum += j;\n            }\n            result.push_back(sum);\n        }\n    }\n    return result;\n}\n", "py_code": "def f(n):\n    ret = []\n    for i in range(1,n+1):\n        if i%2 == 0:\n            x = 1\n            for j in range(1,i+1): x *= j\n            ret += [x]\n        else:\n            x = 0\n            for j in range(1,i+1): x += j\n            ret += [x]\n    return ret\n", "py_summary": "The Python code defines a function `f` that takes an integer `n` as input and returns a list of size `n`. The value of each element at index `i` is determined based on whether `i` is even or odd. If `i` is even, the element at index `i` is the factorial of `i`. If `i` is odd, the element at index `i` is the sum of numbers from 1 to `i`. The function iterates through the range from 1 to `n` and calculates the factorial or sum accordingly, then appends the result to the list `ret`. Finally, the function returns the list `ret` containing the desired values based on the index.\n\nThe code uses a brute-force approach to calculate factorials and sums, which may not be efficient for large values of `n`."}
{"task_id": "CPP/107", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\nvector<int> even_odd_palindrome(int n){\n    vector<int> result = {0, 0};\n    for (int i = 1; i <= n; i++) {\n        string num_str = to_string(i);\n        string reversed_num_str = string(num_str.rbegin(), num_str.rend());\n        if (num_str == reversed_num_str) {\n            if (i % 2 == 0) {\n                result[0]++;\n            } else {\n                result[1]++;\n            }\n        }\n    }\n    return result;\n}\n", "py_code": "def even_odd_palindrome(n):\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n", "py_summary": "The Python code defines a function `even_odd_palindrome` that takes a positive integer `n` as input and returns a tuple containing the count of even and odd integer palindromes within the range (1, n), inclusive. \n\nThe function first defines a helper function `is_palindrome` to check if a number is a palindrome by converting it to a string and comparing it with its reverse. \n\nIt then initializes variables `even_palindrome_count` and `odd_palindrome_count` to keep track of the counts of even and odd palindromes, respectively. \n\nNext, it iterates through numbers from 1 to n and checks if the number is a palindrome and whether it is even or odd. Based on these conditions, it increments the corresponding count variables. \n\nFinally, it returns a tuple containing the counts of even and odd palindromes found within the specified range."}
{"task_id": "CPP/108", "generation": "#include <stdio.h>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\nint count_nums(vector<int> n) {\n    int count = 0;\n    for (int num : n) {\n        int sum = 0;\n        int neg = 1;\n        if (num < 0) {\n            num *= -1;\n            neg = -1;\n        }\n        while (num != 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n        if (sum * neg > 0) {\n            count++;\n        }\n    }\n    return count;\n}\n", "py_code": "def count_nums(arr):\n    def digits_sum(n):\n        neg = 1\n        if n < 0: n, neg = -1 * n, -1 \n        n = [int(i) for i in str(n)]\n        n[0] = n[0] * neg\n        return sum(n)\n    return len(list(filter(lambda x: x > 0, [digits_sum(i) for i in arr])))\n", "py_summary": "The Python code defines a function `count_nums` that takes a list of integers as input and returns the count of elements whose sum of digits is greater than 0. The function first defines a nested function `digits_sum` that calculates the sum of digits of a number. If the number is negative, it considers the first digit as negative. \n\nWithin the `count_nums` function, a list comprehension is used to calculate the sum of digits for each element in the input list. The `filter` function is then applied to this list to keep only the elements with a sum of digits greater than 0. Finally, the function returns the length of this filtered list, which represents the count of elements satisfying the condition."}
{"task_id": "CPP/109", "generation": "bool move_one_ball(vector<int> arr){\n    if (arr.empty()) {\n        return true;\n    }\n    vector<int> sorted_arr = arr;\n    sort(sorted_arr.begin(), sorted_arr.end());\n    \n    int min_value = *min_element(arr.begin(), arr.end());\n    int min_index = find(arr.begin(), arr.end(), min_value) - arr.begin();\n    \n    vector<int> my_arr;\n    my_arr.insert(my_arr.end(), arr.begin() + min_index, arr.end());\n    my_arr.insert(my_arr.end(), arr.begin(), arr.begin() + min_index);\n    \n    for (int i = 0; i < arr.size(); i++) {\n        if (my_arr[i] != sorted_arr[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n", "py_code": "def move_one_ball(arr):\n    if len(arr)==0:\n      return True\n    sorted_array=sorted(arr)\n    my_arr=[]\n    \n    min_value=min(arr)\n    min_index=arr.index(min_value)\n    my_arr=arr[min_index:]+arr[0:min_index]\n    for i in range(len(arr)):\n      if my_arr[i]!=sorted_array[i]:\n        return False\n    return True\n", "py_summary": "The Python code defines a function `move_one_ball` that takes a list of integers as input and determines if it is possible to obtain a sorted vector in non-decreasing order by performing right shift operations on the given vector. The function first checks if the input vector is empty, in which case it returns True. \n\nIf the vector is not empty, the function creates a sorted version of the input vector and then constructs a new vector `my_arr` by shifting the elements of the input vector to the right until the minimum value in the input vector is at the beginning. It then compares each element of `my_arr` with the corresponding element in the sorted array. If all elements match, the function returns True, indicating that a non-decreasing order can be achieved. Otherwise, it returns False."}
{"task_id": "CPP/110", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\nstring exchange(vector<int> lst1,vector<int> lst2){\n    int odd = 0;\n    int even = 0;\n    for (int i=0; i<lst1.size(); i++){\n        if (lst1[i] % 2 == 1){\n            odd++;\n        }\n    }\n    for (int i=0; i<lst2.size(); i++){\n        if (lst2[i] % 2 == 0){\n            even++;\n        }\n    }\n    if (even >= odd){\n        return \"YES\";\n    }\n    return \"NO\";\n}\n", "py_code": "def exchange(lst1, lst2):\n    odd = 0\n    even = 0\n    for i in lst1:\n        if i%2 == 1:\n            odd += 1\n    for i in lst2:\n        if i%2 == 0:\n            even += 1\n    if even >= odd:\n        return \"YES\"\n    return \"NO\"\n            \n", "py_summary": "The Python code defines a function that takes two lists of integers as input and checks if it is possible to exchange elements between the two lists such that the first list (`lst1`) contains only even numbers. The function iterates through `lst1` to count the number of odd numbers and through `lst2` to count the number of even numbers. If the count of even numbers in `lst2` is greater than or equal to the count of odd numbers in `lst1`, the function returns \"YES\", indicating that it is possible to make all elements of `lst1` even by exchanging elements. Otherwise, it returns \"NO\"."}
{"task_id": "CPP/111", "generation": "#include <iostream>\n#include <string>\n#include <map>\n#include <sstream>\n\nstd::map<char, int> histogram(std::string test) {\n    std::map<char, int> result;\n    std::istringstream iss(test);\n    std::string word;\n\n    while (iss >> word) {\n        for (char c : word) {\n            result[c]++;\n        }\n    }\n\n    int maxCount = 0;\n    for (const auto& pair : result) {\n        if (pair.second > maxCount) {\n            maxCount = pair.second;\n        }\n    }\n\n    std::map<char, int> maxFrequencyChars;\n    for (const auto& pair : result) {\n        if (pair.second == maxCount) {\n            maxFrequencyChars[pair.first] = pair.second;\n        }\n    }\n\n    return maxFrequencyChars;\n}\n", "py_code": "def histogram(test):\n    dict1={}\n    list1=test.split(\" \")\n    t=0\n\n    for i in list1:\n        if(list1.count(i)>t) and i!='':\n            t=list1.count(i)\n    if t>0:\n        for i in list1:\n            if(list1.count(i)==t):\n                \n                dict1[i]=t\n    return dict1\n", "py_summary": "The Python code defines a function that takes a string of space-separated lowercase letters as input and returns a dictionary containing the letter(s) with the highest frequency and their corresponding count. \n1. It initializes an empty dictionary `dict1`, splits the input string into a list of letters `list1`, and initializes a variable `t` to 0 to keep track of the maximum frequency.\n2. It then iterates through the list of letters and counts the frequency of each letter using the `count()` method. If the count is greater than the current maximum frequency `t` and the letter is not an empty string, it updates `t` to the new count.\n3. After finding the maximum frequency `t`, it iterates through the list of letters again and adds the letter(s) with a count equal to `t` to the dictionary `dict1`.\n4. Finally, it returns the dictionary `dict1` containing the letter(s) with the highest frequency and their count."}
{"task_id": "CPP/112", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\nvector<string> reverse_delete(string s,string c){\n    string result = \"\";\n    for (char ch : s) {\n        if (c.find(ch) == string::npos) {\n            result += ch;\n        }\n    }\n    string palindrome_check = (result == string(result.rbegin(), result.rend())) ? \"True\" : \"False\";\n    return {result, palindrome_check};\n}\n", "py_code": "def reverse_delete(s,c):\n    s = ''.join([char for char in s if char not in c])\n    return (s,s[::-1] == s)\n", "py_summary": "The Python code defines a function that takes two strings `s` and `c` as input. It removes all characters from string `s` that are present in string `c` and then checks if the resulting string is a palindrome. \n\n1. It uses a list comprehension to iterate over each character in string `s` and includes the character only if it is not present in string `c`.\n2. Then, it joins the filtered characters back together to form the modified string `s`.\n3. Finally, it checks if the modified string `s` is equal to its reverse (i.e., a palindrome) and returns a tuple containing the modified string and a boolean value indicating whether it is a palindrome or not."}
{"task_id": "CPP/113", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<map>\nusing namespace std;\nvector<string> odd_count(vector<string> lst){\n    vector<string> res;\n    for (string arr : lst) {\n        int n = 0;\n        for (char c : arr) {\n            if ((c - '0') % 2 == 1) {\n                n++;\n            }\n        }\n        string new_str = \"the number of odd elements \" + to_string(n) + \"n the str\" + to_string(n) + \"ng \" + to_string(n) + \" of the \" + to_string(n) + \"nput.\";\n        res.push_back(new_str);\n    }\n    return res;\n}\n", "py_code": "def odd_count(lst):\n    res = []\n    for arr in lst:\n        n = sum(int(d)%2==1 for d in arr)\n        res.append(\"the number of odd elements \" + str(n) + \"n the str\"+ str(n) +\"ng \"+ str(n) +\" of the \"+ str(n) +\"nput.\")\n    return res\n", "py_summary": "The Python code defines a function that takes a list of strings as input, where each string consists of only digits. It then calculates the number of odd digits in each string and constructs a new string based on the count of odd digits. \n\nThe function iterates through each string in the input list and counts the number of odd digits by converting each digit to an integer and checking if it is odd (using the modulo operator %). It then constructs a new string using the count of odd digits to replace placeholders in a template string. Finally, it appends the constructed string to the result list and returns the list of constructed strings."}
{"task_id": "CPP/114", "generation": "long long minSubArraySum(vector<long long> nums){\n    long long max_sum = 0;\n    long long s = 0;\n    for (long long num : nums) {\n        s += -num;\n        if (s < 0) {\n            s = 0;\n        }\n        max_sum = max(s, max_sum);\n    }\n    if (max_sum == 0) {\n        max_sum = *max_element(nums.begin(), nums.end(), [](long long a, long long b) {\n            return a < b;\n        });\n    }\n    long long min_sum = -max_sum;\n    return min_sum;\n}\n", "py_code": "def minSubArraySum(nums):\n    max_sum = 0\n    s = 0\n    for num in nums:\n        s += -num\n        if (s < 0):\n            s = 0\n        max_sum = max(s, max_sum)\n    if max_sum == 0:\n        max_sum = max(-i for i in nums)\n    min_sum = -max_sum\n    return min_sum\n", "py_summary": "The Python code defines a function that takes a list of integers as input and finds the minimum sum of any non-empty subarray of the input list. The function initializes variables `max_sum` and `s` to 0. It then iterates through the input list and calculates the cumulative sum of the elements, but with the sign reversed.\n\nDuring the iteration, if the cumulative sum `s` becomes negative, it is reset to 0. The maximum sum encountered during this process is stored in the `max_sum` variable. If the `max_sum` remains 0 after the iteration, it means that all elements in the list are negative, so the `max_sum` is updated to the maximum negative value in the list.\n\nFinally, the function calculates the minimum sum by negating the `max_sum` value and returns it as the result."}
{"task_id": "CPP/115", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\nint max_fill(vector<vector<int>> grid, int capacity) {\n    int total = 0;\n    for (const auto& row : grid) {\n        int sum = 0;\n        for (int val : row) {\n            sum += val;\n        }\n        total += (sum + capacity - 1) / capacity;\n    }\n    return total;\n}\n", "py_code": "def max_fill(grid, capacity):\n    import math\n    return sum([math.ceil(sum(arr)/capacity) for arr in grid])\n", "py_summary": "The Python code defines a function that calculates the number of times the buckets need to be lowered to empty all the wells in the grid. It uses the `math.ceil` function to round up the division result to the nearest integer greater than or equal to the quotient. The function iterates through each row in the grid, calculates the total water units in the well, divides it by the bucket capacity, and then takes the ceiling of the result. Finally, it sums up all the results for each row and returns the total number of times the buckets need to be lowered."}
{"task_id": "CPP/116", "generation": "vector<int> sort_array(vector<int> arr){\n    sort(arr.begin(), arr.end(), [](int a, int b) {\n        int count_a = __builtin_popcount(a);\n        int count_b = __builtin_popcount(b);\n        if (count_a == count_b) {\n            return a < b;\n        }\n        return count_a < count_b;\n    });\n    return arr;\n}\n", "py_code": "def sort_array(arr):\n    return sorted(sorted(arr), key=lambda x: bin(x)[2:].count('1'))\n", "py_summary": "The Python code defines a function that sorts a list of integers based on the number of ones in their binary representation in ascending order. It first sorts the input list in ascending order. Then, it uses the `sorted()` function with a custom key function to sort the list based on the count of ones in the binary representation of each number. The `bin(x)[2:].count('1')` expression converts the number `x` to binary representation, removes the '0b' prefix, and counts the number of ones in the binary string.\n\nThis approach ensures that numbers with fewer ones in their binary representation come first, and for numbers with the same number of ones, they are sorted based on their decimal value."}
{"task_id": "CPP/117", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\nvector<string> select_words(string s, int n){\n    vector<string> result;\n    string word = \"\";\n    for (int i = 0; i < s.size(); i++) {\n        if (s[i] == ' ') {\n            int n_consonants = 0;\n            for (char c : word) {\n                if (tolower(c) != 'a' && tolower(c) != 'e' && tolower(c) != 'i' && tolower(c) != 'o' && tolower(c) != 'u') {\n                    n_consonants++;\n                }\n            }\n            if (n_consonants == n) {\n                result.push_back(word);\n            }\n            word = \"\";\n        } else {\n            word += s[i];\n        }\n    }\n    int n_consonants = 0;\n    for (char c : word) {\n        if (tolower(c) != 'a' && tolower(c) != 'e' && tolower(c) != 'i' && tolower(c) != 'o' && tolower(c) != 'u') {\n            n_consonants++;\n        }\n    }\n    if (n_consonants == n) {\n        result.push_back(word);\n    }\n    return result;\n}\n", "py_code": "def select_words(s, n):\n    result = []\n    for word in s.split():\n        n_consonants = 0\n        for i in range(0, len(word)):\n            if word[i].lower() not in [\"a\",\"e\",\"i\",\"o\",\"u\"]:\n                n_consonants += 1 \n        if n_consonants == n:\n            result.append(word)\n    return result\n\n", "py_summary": "The Python code defines a function that takes a string `s` and a natural number `n` as input and returns a list of words from the string `s` that contain exactly `n` consonants. The function splits the input string into words and then iterates through each word. For each word, it counts the number of consonants by checking if each character is not a vowel (a, e, i, o, u). If the count of consonants in a word matches the given `n`, the word is added to the result list. Finally, the function returns the list of words that satisfy the condition."}
{"task_id": "CPP/118", "generation": "#include <string>\n#include <unordered_set>\nusing namespace std;\n\nstring get_closest_vowel(string word) {\n    if (word.length() < 3) {\n        return \"\";\n    }\n\n    unordered_set<char> vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'O', 'U', 'I'};\n    for (int i = word.length() - 2; i > 0; i--) {\n        if (vowels.find(word[i]) != vowels.end() && vowels.find(word[i-1]) == vowels.end() && vowels.find(word[i+1]) == vowels.end()) {\n            return string(1, word[i]);\n        }\n    }\n    return \"\";\n}\n", "py_code": "def get_closest_vowel(word):\n    if len(word) < 3:\n        return \"\"\n\n    vowels = {\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", 'O', 'U', 'I'}\n    for i in range(len(word)-2, 0, -1):\n        if word[i] in vowels:\n            if (word[i+1] not in vowels) and (word[i-1] not in vowels):\n                return word[i]\n    return \"\"\n", "py_summary": "The Python code defines a function `get_closest_vowel` that takes a word as input and returns the closest vowel that stands between two consonants from the right side of the word. The function first checks if the length of the word is less than 3, in which case it returns an empty string.\n\nIt then creates a set `vowels` containing all the vowels in both lowercase and uppercase. The function iterates over the characters of the word from the second last character to the second character (excluding the first and last characters). For each character, it checks if it is a vowel and if the characters on its left and right are not vowels. If these conditions are met, the function returns the vowel character.\n\nIf no such vowel is found meeting the conditions, the function returns an empty string."}
{"task_id": "CPP/119", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nbool check(string s) {\n    int val = 0;\n    for (char i : s) {\n        if (i == '(') {\n            val = val + 1;\n        } else {\n            val = val - 1;\n        }\n        if (val < 0) {\n            return false;\n        }\n    }\n    return val == 0;\n}\n\nstring match_parens(vector<string> lst){\n    string S1 = lst[0] + lst[1];\n    string S2 = lst[1] + lst[0];\n    if (check(S1) || check(S2)) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\n", "py_code": "def match_parens(lst):\n    def check(s):\n        val = 0\n        for i in s:\n            if i == '(':\n                val = val + 1\n            else:\n                val = val - 1\n            if val < 0:\n                return False\n        return True if val == 0 else False\n\n    S1 = lst[0] + lst[1]\n    S2 = lst[1] + lst[0]\n    return 'Yes' if check(S1) or check(S2) else 'No'\n", "py_summary": "The Python code defines a function `match_parens` that takes a list of two strings as input and checks if it is possible to concatenate the two strings in some order to form a balanced parentheses string. The function first defines a helper function `check` that iterates through a string and checks if the parentheses are balanced. It returns `True` if the parentheses are balanced and `False` otherwise.\n\nThe main function concatenates the two input strings in two different orders (`S1 = lst[0] + lst[1]` and `S2 = lst[1] + lst[0]`) and then checks if either of the concatenated strings results in a balanced parentheses string using the `check` function. If either of the concatenated strings is balanced, the function returns \"Yes\"; otherwise, it returns \"No\"."}
{"task_id": "CPP/120", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nvector<int> maximum(vector<int> arr,int k){\n    if (k == 0)\n        return {};\n    sort(arr.begin(), arr.end());\n    vector<int> ans(arr.end() - k, arr.end());\n    return ans;\n}\n", "py_code": "def maximum(arr, k):\n    if k == 0:\n        return []\n    arr.sort()\n    ans = arr[-k:]\n    return ans\n", "py_summary": "The Python code defines a function that takes a list of integers `arr` and a positive integer `k` as input and returns a sorted list of length `k` containing the maximum `k` numbers from the input list `arr`, in ascending order. \n\nThe function first checks if `k` is equal to 0, in which case it returns an empty list. It then sorts the input list `arr` in ascending order. Next, it extracts the last `k` elements from the sorted list (which are the maximum `k` numbers) and returns them as the result."}
{"task_id": "CPP/121", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\nint solution(vector<int> lst){\n    int sum = 0;\n    for (int i = 0; i < lst.size(); i++) {\n        if (i % 2 == 0 && lst[i] % 2 == 1) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n", "py_code": "def solution(lst):\n    return sum([x for idx, x in enumerate(lst) if idx%2==0 and x%2==1])\n", "py_summary": "The Python code defines a function that takes a list of integers as input and returns the sum of all the odd elements that are in even positions (0-based indexing). It uses list comprehension to iterate over the elements of the input list along with their indices. For each element at an even index with an odd value, it adds that value to a new list. Finally, it returns the sum of all the elements in the new list, which gives the sum of odd elements at even positions."}
{"task_id": "CPP/122", "generation": "int add_elements(vector<int> arr, int k) {\n    int sum = 0;\n    for (int i = 0; i < k; i++) {\n        if (to_string(arr[i]).length() <= 2) {\n            sum += arr[i];\n        }\n    }\n    return sum;\n}\n", "py_code": "def add_elements(arr, k):\n    return sum(elem for elem in arr[:k] if len(str(elem)) <= 2)\n", "py_summary": "The Python code defines a function that takes a list of integers `arr` and an integer `k` as input and returns the sum of elements from the first `k` elements of `arr` that have at most two digits. \n\nThe function uses a list comprehension to iterate over the first `k` elements of `arr`. For each element, it checks if the length of the string representation of the element is less than or equal to 2 (i.e., the element has at most two digits). If the condition is met, the element is included in the sum. Finally, the function returns the sum of all elements that satisfy the condition."}
{"task_id": "CPP/123", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nvector<int> get_odd_collatz(int n){\n    vector<int> odd_collatz;\n    if (n%2==0){\n        return odd_collatz;\n    } else {\n        odd_collatz.push_back(n);\n    }\n    while (n > 1){\n        if (n % 2 == 0){\n            n = n/2;\n        } else {\n            n = n*3 + 1;\n        }\n        if (n%2 == 1){\n            odd_collatz.push_back(n);\n        }\n    }\n    sort(odd_collatz.begin(), odd_collatz.end());\n    return odd_collatz;\n}\n", "py_code": "def get_odd_collatz(n):\n    if n%2==0:\n        odd_collatz = [] \n    else:\n        odd_collatz = [n]\n    while n > 1:\n        if n % 2 == 0:\n            n = n/2\n        else:\n            n = n*3 + 1\n            \n        if n%2 == 1:\n            odd_collatz.append(int(n))\n\n    return sorted(odd_collatz)\n", "py_summary": "The Python code defines a function that takes a positive integer n as input and returns a sorted list of odd numbers in the Collatz sequence starting from n. The function initializes an empty list `odd_collatz` if n is even, otherwise it initializes the list with n (since n is odd). \n\nThe function then enters a while loop that continues until n reaches 1. In each iteration, it checks if n is even or odd and updates n accordingly based on the Collatz sequence rules. If the updated n is odd, it appends it to the `odd_collatz` list.\n\nFinally, the function returns the sorted `odd_collatz` list containing the odd numbers in the Collatz sequence starting from the input n."}
{"task_id": "CPP/124", "generation": "bool valid_date(string date){\n    try {\n        date.erase(0, date.find_first_not_of(' ')); // Remove leading whitespaces\n        date.erase(date.find_last_not_of(' ') + 1); // Remove trailing whitespaces\n        int month, day, year;\n        sscanf(date.c_str(), \"%d-%d-%d\", &month, &day, &year);\n        if (month < 1 || month > 12) {\n            return false;\n        }\n        if ((month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) && (day < 1 || day > 31)) {\n            return false;\n        }\n        if ((month == 4 || month == 6 || month == 9 || month == 11) && (day < 1 || day > 30)) {\n            return false;\n        }\n        if (month == 2 && (day < 1 || day > 29)) {\n            return false;\n        }\n    } catch (...) {\n        return false;\n    }\n    return true;\n}\n", "py_code": "def valid_date(date):\n    try:\n        date = date.strip()\n        month, day, year = date.split('-')\n        month, day, year = int(month), int(day), int(year)\n        if month < 1 or month > 12:\n            return False\n        if month in [1,3,5,7,8,10,12] and day < 1 or day > 31:\n            return False\n        if month in [4,6,9,11] and day < 1 or day > 30:\n            return False\n        if month == 2 and day < 1 or day > 29:\n            return False\n    except:\n        return False\n\n    return True\n", "py_summary": "The Python code defines a function `valid_date` that takes a date string as input and validates whether the date is in a valid format. The function first strips any leading or trailing whitespaces from the input date string. It then attempts to split the date string into month, day, and year components. If the splitting is successful, it converts these components into integers.\n\nThe function then checks the following conditions:\n1. If the month is not in the range [1, 12], it returns False.\n2. If the month is in [1,3,5,7,8,10,12] and the day is not in the range [1, 31], it returns False.\n3. If the month is in [4,6,9,11] and the day is not in the range [1, 30], it returns False.\n4. If the month is 2 and the day is not in the range [1, 29], it returns False.\n\nIf any exceptions occur during the conversion or splitting process, the function catches them and returns False. If all conditions are satisfied, the function returns True, indicating that the date is valid."}
{"task_id": "CPP/125", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nstd::vector<std::string> split_words(std::string txt) {\n    std::vector<std::string> result;\n    if (txt.find(\" \") != std::string::npos) {\n        size_t pos = 0;\n        std::string token;\n        while ((pos = txt.find(\" \")) != std::string::npos) {\n            token = txt.substr(0, pos);\n            result.push_back(token);\n            txt.erase(0, pos + 1);\n        }\n        result.push_back(txt);\n    } else if (txt.find(\",\") != std::string::npos) {\n        size_t pos = 0;\n        std::string token;\n        while ((pos = txt.find(\",\")) != std::string::npos) {\n            token = txt.substr(0, pos);\n            result.push_back(token);\n            txt.erase(0, pos + 1);\n        }\n        result.push_back(txt);\n    } else {\n        int count = 0;\n        for (char c : txt) {\n            if (islower(c) && (c - 'a') % 2 == 0) {\n                count++;\n            }\n        }\n        result.push_back(std::to_string(count));\n    }\n    return result;\n}\n", "py_code": "def split_words(txt):\n    if \" \" in txt:\n        return txt.split()\n    elif \",\" in txt:\n        return txt.replace(',',' ').split()\n    else:\n        return len([i for i in txt if i.islower() and ord(i)%2 == 0])\n", "py_summary": "The Python code defines a function `split_words` that takes a string `txt` as input and returns a list of words split based on whitespace or comma. If the input string contains whitespace, the function splits the string using the `split()` method and returns the resulting list of words. If the input string contains a comma, the function replaces the comma with a whitespace and then splits the string using the `split()` method to get the list of words. \n\nIf the input string does not contain any whitespace or comma, the function calculates the number of lowercase letters with an odd order in the alphabet (letters with even indices when considering 'a' as 0) and returns a list containing the count as a string.\n\nOverall, the function handles different cases based on the presence of whitespace or comma in the input string and returns the appropriate output."}
{"task_id": "CPP/126", "generation": "bool is_sorted(vector<int> lst){\n    unordered_map<int, int> count_digit;\n    for (int i : lst) {\n        count_digit[i]++;\n    }\n    for (auto& pair : count_digit) {\n        if (pair.second > 2) {\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i-1] > lst[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n", "py_code": "def is_sorted(lst):\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1 \n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n    \n    \n", "py_summary": "The Python code defines a function that takes a list of integers as input and checks if the list is sorted in ascending order and if any number appears more than twice. \n\n1. It first creates a dictionary `count_digit` to count the occurrences of each number in the input list.\n2. It then checks if any number appears more than twice in the list. If so, it returns False.\n3. Next, it checks if the list is sorted in ascending order by iterating over the list and comparing each element with the previous one. If the list is sorted, it returns True; otherwise, it returns False."}
{"task_id": "CPP/127", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <cmath>\nusing namespace std;\n\nbool is_prime(int num) {\n    if (num == 1 || num == 0) {\n        return false;\n    }\n    if (num == 2) {\n        return true;\n    }\n    for (int i = 2; i <= sqrt(num); i++) {\n        if (num % i == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nstring intersection(vector<int> interval1, vector<int> interval2) {\n    int l = max(interval1[0], interval2[0]);\n    int r = min(interval1[1], interval2[1]);\n    int length = r - l;\n    if (length > 0 && is_prime(length)) {\n        return \"YES\";\n    }\n    return \"NO\";\n}\n", "py_code": "def intersection(interval1, interval2):\n    def is_prime(num):\n        if num == 1 or num == 0:\n            return False\n        if num == 2:\n            return True\n        for i in range(2, num):\n            if num%i == 0:\n                return False\n        return True\n\n    l = max(interval1[0], interval2[0])\n    r = min(interval1[1], interval2[1])\n    length = r - l\n    if length > 0 and is_prime(length):\n        return \"YES\"\n    return \"NO\"\n", "py_summary": "The Python code defines a function `intersection` that takes two intervals as input and determines whether the length of their intersection is a prime number. It first defines a helper function `is_prime` to check if a number is prime. \n\nThen, it calculates the intersection of the two intervals by finding the maximum of the starting points and the minimum of the ending points. It calculates the length of the intersection and checks if it is greater than 0 and a prime number using the `is_prime` function. If the length is a prime number, it returns \"YES\", otherwise it returns \"NO\"."}
{"task_id": "CPP/128", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\nint prod_signs(vector<int> arr){\n    if (arr.empty()) return -32768;\n    int prod = 0;\n    bool has_zero = false;\n    int negative_count = 0;\n    for (int num : arr) {\n        if (num == 0) {\n            has_zero = true;\n            break;\n        }\n        if (num < 0) negative_count++;\n    }\n    if (has_zero) prod = 0;\n    else prod = pow(-1, negative_count);\n    \n    int sum_magnitudes = 0;\n    for (int num : arr) {\n        sum_magnitudes += abs(num);\n    }\n    \n    return prod * sum_magnitudes;\n}\n", "py_code": "def prod_signs(arr):\n    if not arr: return None\n    prod = 0 if 0 in arr else (-1) ** len(list(filter(lambda x: x < 0, arr)))\n    return prod * sum([abs(i) for i in arr])\n", "py_summary": "The Python code defines a function that calculates the sum of magnitudes of integers in a list multiplied by the product of all signs of each number in the list. If the input list is empty, the function returns None. \n\nThe function first checks if the input list is empty, and if so, it returns None. It then calculates the product of signs by checking if 0 is present in the list (which would make the product 0) or by calculating (-1) raised to the power of the count of negative numbers in the list. \n\nFinally, the function returns the product of signs multiplied by the sum of the absolute values of all integers in the list."}
{"task_id": "CPP/129", "generation": "#include <vector>\n#include <algorithm>\n\nstd::vector<int> minPath(std::vector<std::vector<int>> grid, int k) {\n    int n = grid.size();\n    int val = n * n + 1;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (grid[i][j] == 1) {\n                std::vector<int> temp;\n                if (i != 0) {\n                    temp.push_back(grid[i - 1][j]);\n                }\n\n                if (j != 0) {\n                    temp.push_back(grid[i][j - 1]);\n                }\n\n                if (i != n - 1) {\n                    temp.push_back(grid[i + 1][j]);\n                }\n\n                if (j != n - 1) {\n                    temp.push_back(grid[i][j + 1]);\n                }\n\n                val = *std::min_element(temp.begin(), temp.end());\n            }\n        }\n    }\n\n    std::vector<int> ans;\n    for (int i = 0; i < k; i++) {\n        if (i % 2 == 0) {\n            ans.push_back(1);\n        } else {\n            ans.push_back(val);\n        }\n    }\n    return ans;\n}\n", "py_code": "def minPath(grid, k):\n    n = len(grid)\n    val = n * n + 1\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                temp = []\n                if i != 0:\n                    temp.append(grid[i - 1][j])\n\n                if j != 0:\n                    temp.append(grid[i][j - 1])\n\n                if i != n - 1:\n                    temp.append(grid[i + 1][j])\n\n                if j != n - 1:\n                    temp.append(grid[i][j + 1])\n\n                val = min(temp)\n\n    ans = []\n    for i in range(k):\n        if i % 2 == 0:\n            ans.append(1)\n        else:\n            ans.append(val)\n    return ans\n", "py_summary": "The Python code defines a function `minPath` that takes a grid and an integer `k` as input and returns an ordered vector of values on the cells that the minimum path goes through. The function first calculates the size of the grid `n` and initializes a variable `val` to a value greater than the maximum value in the grid.\n\nThen, it iterates through each cell in the grid to find the cell with the value 1. For that cell, it checks the values of its neighboring cells (up, down, left, right) and updates the `val` variable to the minimum value among the neighbors.\n\nNext, the function constructs the output vector `ans` by alternating between the values 1 and the minimum value found earlier. The length of the output vector is determined by the input parameter `k`.\n\nFinally, the function returns the output vector `ans` containing the values on the cells that the minimum path goes through."}
{"task_id": "CPP/130", "generation": "#include <stdio.h>\n#include <vector>\n\nstd::vector<int> tri(int n) {\n    std::vector<int> my_tri;\n    if (n == 0) {\n        my_tri.push_back(1);\n        return my_tri;\n    }\n    my_tri.push_back(1);\n    my_tri.push_back(3);\n    for (int i = 2; i <= n; i++) {\n        if (i % 2 == 0) {\n            my_tri.push_back(i / 2 + 1);\n        } else {\n            my_tri.push_back(my_tri[i - 1] + my_tri[i - 2] + (i + 3) / 2);\n        }\n    }\n    return my_tri;\n}\n", "py_code": "def tri(n):\n    if n == 0:\n        return [1]\n    my_tri = [1, 3]\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            my_tri.append(i / 2 + 1)\n        else:\n            my_tri.append(my_tri[i - 1] + my_tri[i - 2] + (i + 3) / 2)\n    return my_tri\n", "py_summary": "The Python code defines a function `tri(n)` that calculates the Tribonacci sequence up to the nth element. It initializes the sequence with the base cases `tri(0) = 1` and `tri(1) = 3`. Then, it iterates from index 2 to n and calculates the next element based on the recurrence relation provided in the problem statement.\n\n- If the index is even, the element is calculated as `(index / 2) + 1`.\n- If the index is odd, the element is calculated as the sum of the previous two elements and the next element in the sequence.\n\nThe function returns a list containing the first n + 1 elements of the Tribonacci sequence.\n\n"}
{"task_id": "CPP/131", "generation": "#include <string>\n\nint digits(int n){\n    int product = 1;\n    int odd_count = 0;\n    std::string num_str = std::to_string(n);\n    for(char digit : num_str){\n        int int_digit = digit - '0';\n        if(int_digit % 2 == 1){\n            product *= int_digit;\n            odd_count++;\n        }\n    }\n    if(odd_count == 0){\n        return 0;\n    } else {\n        return product;\n    }\n}\n", "py_code": "def digits(n):\n    product = 1\n    odd_count = 0\n    for digit in str(n):\n        int_digit = int(digit)\n        if int_digit%2 == 1:\n            product= product*int_digit\n            odd_count+=1\n    if odd_count ==0:\n        return 0\n    else:\n        return product\n", "py_summary": "The Python code defines a function that takes a positive integer `n` as input and returns the product of the odd digits in the integer. The function initializes variables `product` to 1 and `odd_count` to 0. It then iterates through each digit in the string representation of the integer.\n\nFor each digit, it converts it to an integer and checks if it is odd by taking the modulo 2. If the digit is odd, it multiplies it with the current product and increments the odd_count. After processing all digits, if no odd digits were found (odd_count is 0), the function returns 0. Otherwise, it returns the product of the odd digits.\n\nThis approach efficiently calculates the product of odd digits and handles the case where there are no odd digits in the number."}
{"task_id": "CPP/132", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\nbool is_nested(string str){\n    vector<int> opening_bracket_index;\n    vector<int> closing_bracket_index;\n    for (int i = 0; i < str.size(); i++) {\n        if (str[i] == '[') {\n            opening_bracket_index.push_back(i);\n        } else {\n            closing_bracket_index.push_back(i);\n        }\n    }\n    reverse(closing_bracket_index.begin(), closing_bracket_index.end());\n    int cnt = 0;\n    int i = 0;\n    int l = closing_bracket_index.size();\n    for (int idx : opening_bracket_index) {\n        if (i < l && idx < closing_bracket_index[i]) {\n            cnt++;\n            i++;\n        }\n    }\n    return cnt >= 2;\n}\n", "py_code": "def is_nested(string):\n    opening_bracket_index = []\n    closing_bracket_index = []\n    for i in range(len(string)):\n        if string[i] == '[':\n            opening_bracket_index.append(i)\n        else:\n            closing_bracket_index.append(i)\n    closing_bracket_index.reverse()\n    cnt = 0\n    i = 0\n    l = len(closing_bracket_index)\n    for idx in opening_bracket_index:\n        if i < l and idx < closing_bracket_index[i]:\n            cnt += 1\n            i += 1\n    return cnt >= 2\n\n    \n", "py_summary": "The Python code defines a function that takes a string as input, which contains only square brackets. The function checks if there is a valid subsequence of brackets where at least one bracket in the subsequence is nested. \n\n1. It initializes two lists, `opening_bracket_index` and `closing_bracket_index`, to store the indices of opening and closing brackets, respectively.\n2. It iterates through the string and stores the indices of opening and closing brackets in their respective lists.\n3. The function then reverses the `closing_bracket_index` list.\n4. It initializes a counter `cnt` to keep track of the number of nested brackets found and sets the index `i` to 0.\n5. It iterates through the `opening_bracket_index` list and compares the indices with the corresponding indices in the `closing_bracket_index` list to check for nested brackets.\n6. If a nested bracket is found, the counter `cnt` is incremented.\n7. Finally, the function returns `True` if there are at least 2 nested brackets, otherwise it returns `False`."}
{"task_id": "CPP/133", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\nint sum_squares(vector<float> lst){\n    int sum = 0;\n    for (float num : lst) {\n        sum += pow(ceil(num), 2);\n    }\n    return sum;\n}\n", "py_code": "def sum_squares(lst):\n    import math\n    squared = 0\n    for i in lst:\n        squared += math.ceil(i)**2\n    return squared\n", "py_summary": "The Python code defines a function that takes a list of numbers as input and calculates the sum of the squares of each number after rounding it up to the nearest integer. The function iterates through each element in the input list, rounds it up using the `math.ceil()` function, squares the rounded value, and adds it to the running total. Finally, the function returns the total sum of the squared, rounded numbers."}
{"task_id": "CPP/134", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\nbool check_if_last_char_is_a_letter(string txt){\n    if (txt.empty()) {\n        return false;\n    }\n    string lastWord = \"\";\n    for (int i = txt.size() - 1; i >= 0; i--) {\n        if (txt[i] != ' ') {\n            lastWord = txt[i] + lastWord;\n        } else {\n            break;\n        }\n    }\n    if (lastWord.size() == 1 && (lastWord[0] >= 'a' && lastWord[0] <= 'z')) {\n        return true;\n    }\n    return false;\n}\n", "py_code": "def check_if_last_char_is_a_letter(txt):\n \n    check = txt.split(' ')[-1]\n    return True if len(check) == 1 and (97 <= ord(check.lower()) <= 122) else False\n", "py_summary": "The Python code defines a function that takes a string as input and checks if the last character of the string is an alphabetical character and not part of a word (i.e., separated by a space). \n\n1. It splits the input string by spaces and selects the last element (which is considered the last word in the string).\n2. It then checks if the length of the last word is 1 (i.e., a single character) and if that character is an alphabetical character by comparing its ASCII value.\n3. If the above conditions are met, it returns True, indicating that the last character is an alphabetical character and not part of a word. Otherwise, it returns False."}
{"task_id": "CPP/135", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\nint can_arrange(vector<int> arr){\n    int ind = -1;\n    for (int i = 1; i < arr.size(); i++) {\n        if (arr[i] < arr[i - 1]) {\n            ind = i;\n        }\n    }\n    return ind;\n}\n", "py_code": "def can_arrange(arr):\n    ind=-1\n    i=1\n    while i<len(arr):\n      if arr[i]<arr[i-1]:\n        ind=i\n      i+=1\n    return ind\n", "py_summary": "The Python code defines a function `can_arrange` that takes a list of integers as input and returns the largest index of an element that is not greater than the element immediately preceding it. If no such element exists, it returns -1. The function initializes the index variable `ind` to -1 and iterates through the list starting from the second element. If the current element is less than the previous element, it updates the `ind` variable to the current index. Finally, the function returns the index of the last element that meets the condition or -1 if no such element exists."}
{"task_id": "CPP/136", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\nvector<int> largest_smallest_integers(vector<int> lst){\n    int largest_negative = 0;\n    int smallest_positive = 0;\n    for (int num : lst) {\n        if (num < 0 && num < largest_negative) {\n            largest_negative = num;\n        }\n        if (num > 0 && (num < smallest_positive || smallest_positive == 0)) {\n            smallest_positive = num;\n        }\n    }\n    return {largest_negative, smallest_positive};\n}\n", "py_code": "def largest_smallest_integers(lst):\n    smallest = list(filter(lambda x: x < 0, lst))\n    largest = list(filter(lambda x: x > 0, lst))\n    return (max(smallest) if smallest else None, min(largest) if largest else None)\n", "py_summary": "The Python code defines a function that takes a list of integers as input and returns a tuple containing the largest negative integer and the smallest positive integer in the list. The function first filters the input list to separate negative integers and positive integers into two separate lists. Then, it uses the `max` function to find the largest negative integer and the `min` function to find the smallest positive integer. If there are no negative or positive integers in the input list, it returns `None` for the corresponding value in the tuple."}
{"task_id": "CPP/137", "generation": "#include <boost/any.hpp>\n#include <string>\n#include <algorithm>\n\nboost::any compare_one(boost::any a, boost::any b) {\n    std::string temp_a = boost::any_cast<std::string>(a);\n    std::string temp_b = boost::any_cast<std::string>(b);\n\n    if (temp_a.find(',') != std::string::npos) {\n        std::replace(temp_a.begin(), temp_a.end(), ',', '.');\n    }\n    if (temp_b.find(',') != std::string::npos) {\n        std::replace(temp_b.begin(), temp_b.end(), ',', '.');\n    }\n\n    if (std::stod(temp_a) == std::stod(temp_b)) {\n        return boost::any();\n    }\n\n    return std::stod(temp_a) > std::stod(temp_b) ? a : b;\n}\n", "py_code": "def compare_one(a, b):\n    temp_a, temp_b = a, b\n    if isinstance(temp_a, str): temp_a = temp_a.replace(',','.')\n    if isinstance(temp_b, str): temp_b = temp_b.replace(',','.')\n    if float(temp_a) == float(temp_b): return None\n    return a if float(temp_a) > float(temp_b) else b \n", "py_summary": "The Python code defines a function `compare_one` that takes two inputs `a` and `b`, which can be integers, floats, or strings representing real numbers. The function first creates temporary variables `temp_a` and `temp_b` to store the modified versions of `a` and `b` if they are strings. If the input variables are strings, the function replaces any commas with periods to handle different decimal separators. \n\nNext, the function compares the values of `temp_a` and `temp_b` as floats. If the values are equal, the function returns `None`. Otherwise, it returns the larger value between `a` and `b` based on their float representations."}
{"task_id": "CPP/138", "generation": "#include<stdio.h>\nusing namespace std;\nbool is_equal_to_sum_even(int n){\n    return n%2 == 0 && n >= 8;\n}\n", "py_code": "def is_equal_to_sum_even(n):\n    return n%2 == 0 and n >= 8\n", "py_summary": "The Python code defines a function that takes an integer `n` as input and returns a boolean value indicating whether `n` can be written as the sum of exactly 4 positive even numbers. The function checks if `n` is even and greater than or equal to 8, as any number less than 8 cannot be expressed as the sum of 4 positive even numbers. If both conditions are met, the function returns `True`, otherwise it returns `False`."}
{"task_id": "CPP/139", "generation": "#include<stdio.h>\nusing namespace std;\nlong long special_factorial(int n){\n    long long fact_i = 1;\n    long long special_fact = 1;\n    for (int i = 1; i <= n; i++) {\n        fact_i *= i;\n        special_fact *= fact_i;\n    }\n    return special_fact;\n}\n", "py_code": "def special_factorial(n):\n    fact_i = 1\n    special_fact = 1\n    for i in range(1, n+1):\n        fact_i *= i\n        special_fact *= fact_i\n    return special_fact\n", "py_summary": "The Python code defines a function that calculates the special factorial of a given integer `n`. The special factorial is calculated by multiplying the factorials of numbers from 1 to `n` together. \n\nThe function initializes two variables `fact_i` and `special_fact` to 1. It then iterates through the numbers from 1 to `n`, updating `fact_i` by calculating the factorial of the current number and updating `special_fact` by multiplying it with `fact_i`. Finally, the function returns the calculated special factorial."}
{"task_id": "CPP/140", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\nstring fix_spaces(string text){\n    string new_text = \"\";\n    int start = 0, end = 0;\n    for (int i = 0; i < text.size(); i++) {\n        if (text[i] == ' ') {\n            end++;\n        } else {\n            if (end - start > 2) {\n                new_text += \"-\";\n            } else if (end - start > 0) {\n                new_text += string(end - start, '_');\n            }\n            new_text += text[i];\n            start = i + 1;\n            end = i + 1;\n        }\n    }\n    if (end - start > 2) {\n        new_text += \"-\";\n    } else if (end - start > 0) {\n        new_text += \"_\";\n    }\n    return new_text;\n}\n", "py_code": "def fix_spaces(text):\n    new_text = \"\"\n    i = 0\n    start, end = 0, 0\n    while i < len(text):\n        if text[i] == \" \":\n            end += 1\n        else:\n            if end - start > 2:\n                new_text += \"-\"+text[i]\n            elif end - start > 0:\n                new_text += \"_\"*(end - start)+text[i]\n            else:\n                new_text += text[i]\n            start, end = i+1, i+1\n        i+=1\n    if end - start > 2:\n        new_text += \"-\"\n    elif end - start > 0:\n        new_text += \"_\"\n    return new_text\n", "py_summary": "The Python code defines a function `fix_spaces` that takes a string `text` as input and replaces spaces in the text according to the given conditions. It iterates through the characters of the input text and keeps track of the start and end indices of consecutive spaces. \n\n- If the number of consecutive spaces is more than 2, it replaces all consecutive spaces with a single hyphen `-`.\n- If the number of consecutive spaces is between 1 and 2, it replaces them with underscores `_`.\n- If there are no consecutive spaces or less than 2, it keeps the character as it is.\n\nFinally, the function returns the modified text with spaces replaced as per the conditions."}
{"task_id": "CPP/141", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\nstring file_name_check(string file_name){\n    string suffixes[] = {\"txt\", \"exe\", \"dll\"};\n    size_t dot_pos = file_name.find('.');\n    if (dot_pos == string::npos || dot_pos == 0 || dot_pos == file_name.size() - 1) {\n        return \"No\";\n    }\n    string prefix = file_name.substr(0, dot_pos);\n    string suffix = file_name.substr(dot_pos + 1);\n    if (suffix != suffixes[0] && suffix != suffixes[1] && suffix != suffixes[2]) {\n        return \"No\";\n    }\n    if (!isalpha(prefix[0])) {\n        return \"No\";\n    }\n    int digit_count = 0;\n    for (char c : prefix) {\n        if (isdigit(c)) {\n            digit_count++;\n        }\n    }\n    if (digit_count > 3) {\n        return \"No\";\n    }\n    return \"Yes\";\n}\n", "py_code": "def file_name_check(file_name):\n    suf = ['txt', 'exe', 'dll']\n    lst = file_name.split(sep='.')\n    if len(lst) != 2:\n        return 'No'\n    if not lst[1] in suf:\n        return 'No'\n    if len(lst[0]) == 0:\n        return 'No'\n    if not lst[0][0].isalpha():\n        return 'No'\n    t = len([x for x in lst[0] if x.isdigit()])\n    if t > 3:\n        return 'No'\n    return 'Yes'\n", "py_summary": "The Python code defines a function `file_name_check` that takes a file name as input and checks if it meets the specified conditions to be considered valid. Here is a step-by-step analysis of the code:\n1. It initializes a list `suf` containing the valid file extensions ('txt', 'exe', 'dll').\n2. It splits the input file name using the '.' delimiter and stores the parts in the list `lst`.\n3. It first checks if the split resulted in exactly two parts (before and after the dot). If not, it returns 'No'.\n4. It then checks if the file extension (the part after the dot) is in the list of valid extensions. If not, it returns 'No'.\n5. It checks if the part before the dot is empty. If it is, it returns 'No'.\n6. It checks if the first character of the part before the dot is an alphabet letter. If not, it returns 'No'.\n7. It counts the number of digits in the part before the dot and checks if it exceeds 3. If it does, it returns 'No'.\n8. If all the above conditions are met, it returns 'Yes' indicating that the file name is valid.\n\nThe function effectively validates the file name based on the specified criteria and returns the appropriate result."}
{"task_id": "CPP/142", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\nint sum_squares(vector<int> lst){\n    int sum = 0;\n    for (int i = 0; i < lst.size(); i++) {\n        if (i % 3 == 0) {\n            sum += lst[i] * lst[i];\n        } else if (i % 4 == 0 && i % 3 != 0) {\n            sum += lst[i] * lst[i] * lst[i];\n        } else {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n", "py_code": "def sum_squares(lst):\n    \"\n    result =[]\n    for i in range(len(lst)):\n        if i %3 == 0:\n            result.append(lst[i]**2)\n        elif i % 4 == 0 and i%3 != 0:\n            result.append(lst[i]**3)\n        else:\n            result.append(lst[i])\n    return sum(result)\n", "py_summary": "The Python code defines a function that takes a list of integers as input and performs the following operations:\n1. If the index of the element is a multiple of 3, the element is squared.\n2. If the index of the element is a multiple of 4 and not a multiple of 3, the element is cubed.\n3. If the index of the element does not satisfy the above conditions, the element remains unchanged.\n4. Finally, the function returns the sum of all the modified elements in the list."}
{"task_id": "CPP/143", "generation": "#include <stdio.h>\n#include <string>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\nbool isPrime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i <= sqrt(n); i++) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\nstring words_in_sentence(string sentence) {\n    vector<string> words;\n    string word = \"\";\n    for (char c : sentence) {\n        if (c == ' ') {\n            if (!word.empty()) {\n                words.push_back(word);\n                word = \"\";\n            }\n        } else {\n            word += c;\n        }\n    }\n    if (!word.empty()) {\n        words.push_back(word);\n    }\n\n    string result = \"\";\n    for (string w : words) {\n        if (w.length() == 1 || w.length() == 2 || isPrime(w.length())) {\n            result += w + \" \";\n        }\n    }\n    if (!result.empty()) {\n        result.pop_back(); // Remove the extra space at the end\n    }\n    return result;\n}\n", "py_code": "def words_in_sentence(sentence):\n    new_lst = []\n    for word in sentence.split():\n        flg = 0\n        if len(word) == 1:\n            flg = 1\n        for i in range(2, len(word)):\n            if len(word)%i == 0:\n                flg = 1\n        if flg == 0 or len(word) == 2:\n            new_lst.append(word)\n    return \" \".join(new_lst)\n", "py_summary": "The Python code defines a function that takes a sentence as input and returns a new string containing only the words from the original sentence whose lengths are prime numbers. The function iterates through each word in the sentence by splitting it based on spaces. For each word, it checks if the length of the word is a prime number. \n\nTo determine if the length is a prime number, the code checks if the length is 1 or 2 first, as these are prime numbers. Then, it iterates from 2 to the length of the word and if the length is divisible by any number other than 1 and itself, it is not a prime number. If the length is a prime number, the word is added to a new list.\n\nFinally, the function returns a string created by joining the words in the new list with spaces."}
{"task_id": "CPP/144", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\nbool simplify(string x, string n){\n    int a = stoi(x.substr(0, x.find(\"/\")));\n    int b = stoi(x.substr(x.find(\"/\")+1));\n    int c = stoi(n.substr(0, n.find(\"/\")));\n    int d = stoi(n.substr(n.find(\"/\")+1));\n    int numerator = a * c;\n    int denom = b * d;\n    if (numerator % denom == 0){\n        return true;\n    }\n    return false;\n}\n", "py_code": "def simplify(x, n):\n    a, b = x.split(\"/\")\n    c, d = n.split(\"/\")\n    numerator = int(a) * int(c)\n    denom = int(b) * int(d)\n    if (numerator/denom == int(numerator/denom)):\n        return True\n    return False\n", "py_summary": "The Python code defines a function that takes two fractions as input in the form of strings and checks if the product of the two fractions results in a whole number. It first splits the input strings to extract the numerators and denominators of both fractions. Then, it calculates the numerator and denominator of the product of the two fractions. \n\nNext, it checks if the division of the numerator by the denominator results in a whole number by comparing it with its integer value. If the division results in a whole number, the function returns True, indicating that the product is a whole number. Otherwise, it returns False."}
{"task_id": "CPP/145", "generation": "#include <stdio.h>\n#include <math.h>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nint digits_sum(int n) {\n    int neg = 1;\n    if (n < 0) {\n        n *= -1;\n        neg = -1;\n    }\n    string num_str = to_string(n);\n    int sum = 0;\n    for (char c : num_str) {\n        sum += c - '0';\n    }\n    return sum * neg;\n}\n\nvector<int> order_by_points(vector<int> nums) {\n    sort(nums.begin(), nums.end(), [&nums](int a, int b) {\n        if (digits_sum(a) == digits_sum(b)) {\n            return find(nums.begin(), nums.end(), a) - nums.begin() < find(nums.begin(), nums.end(), b) - nums.begin();\n        }\n        return digits_sum(a) < digits_sum(b);\n    });\n    return nums;\n}\n", "py_code": "def order_by_points(nums):\n    def digits_sum(n):\n        neg = 1\n        if n < 0: n, neg = -1 * n, -1 \n        n = [int(i) for i in str(n)]\n        n[0] = n[0] * neg\n        return sum(n)\n    return sorted(nums, key=digits_sum)\n", "py_summary": "The Python code defines a function `order_by_points` that takes a list of integers as input and sorts them in ascending order based on the sum of their digits. The function first defines a nested function `digits_sum` that calculates the sum of digits of a given integer. If the integer is negative, the function accounts for the negative sign in the sum calculation.\n\nThe `order_by_points` function then uses the `sorted` function with a custom key function `digits_sum` to sort the input list of integers based on the sum of their digits. The sorted list is returned as the output."}
{"task_id": "CPP/146", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\nint specialFilter(vector<int> nums){\n    int count = 0;\n    for (int num : nums) {\n        if (num > 10) {\n            string num_str = to_string(num);\n            if ((num_str[0] - '0') % 2 != 0 && (num_str[num_str.size() - 1] - '0') % 2 != 0) {\n                count++;\n            }\n        }\n    }\n    return count;\n}\n", "py_code": "def specialFilter(nums):\n    \n    count = 0\n    for num in nums:\n        if num > 10:\n            odd_digits = (1, 3, 5, 7, 9)\n            number_as_string = str(num)\n            if int(number_as_string[0]) in odd_digits and int(number_as_string[-1]) in odd_digits:\n                count += 1\n        \n    return count \n", "py_summary": "The Python code defines a function `specialFilter` that takes a list of numbers as input and returns the count of elements in the list that are greater than 10 and have both the first and last digits as odd numbers (1, 3, 5, 7, 9). \n\nThe function initializes a counter variable `count` to 0. It then iterates through each number in the input list. For each number, it checks if the number is greater than 10. If it is, it creates a tuple `odd_digits` containing the odd digits (1, 3, 5, 7, 9). \n\nThe function then converts the number to a string and checks if the first and last digits of the number are in the `odd_digits` tuple. If both conditions are satisfied, it increments the `count` variable. Finally, the function returns the count of numbers that meet the specified criteria."}
{"task_id": "CPP/147", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\nint get_max_triples(int n){\n    vector<int> A;\n    for (int i=1; i<=n; i++){\n        A.push_back(i*i - i + 1);\n    }\n    int count = 0;\n    for (int i=0; i<n; i++){\n        for (int j=i+1; j<n; j++){\n            for (int k=j+1; k<n; k++){\n                if ((A[i]+A[j]+A[k]) % 3 == 0){\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}\n", "py_code": "def get_max_triples(n):\n    A = [i*i - i + 1 for i in range(1,n+1)]\n    ans = []\n    for i in range(n):\n        for j in range(i+1,n):\n            for k in range(j+1,n):\n                if (A[i]+A[j]+A[k])%3 == 0:\n                    ans += [(A[i],A[j],A[k])]\n    return len(ans)\n", "py_summary": "The Python code defines a function that takes a positive integer `n` as input and creates a list `A` of length `n` where each element is calculated using the formula `i*i - i + 1` for `i` ranging from 1 to `n`. It then initializes an empty list `ans` to store the valid triples. \n\nThe function then iterates through all possible combinations of indices `i`, `j`, and `k` such that `i < j < k`. For each combination, it checks if the sum of the corresponding elements in list `A` is divisible by 3. If it is, the triple is added to the `ans` list. Finally, the function returns the count of valid triples found."}
{"task_id": "CPP/148", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> bf(string planet1, string planet2) {\n    vector<string> planet_names = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n    \n    if (find(planet_names.begin(), planet_names.end(), planet1) == planet_names.end() || find(planet_names.begin(), planet_names.end(), planet2) == planet_names.end() || planet1 == planet2) {\n        return {};\n    }\n    \n    int planet1_index = find(planet_names.begin(), planet_names.end(), planet1) - planet_names.begin();\n    int planet2_index = find(planet_names.begin(), planet_names.end(), planet2) - planet_names.begin();\n    \n    vector<string> result;\n    if (planet1_index < planet2_index) {\n        for (int i = planet1_index + 1; i < planet2_index; i++) {\n            result.push_back(planet_names[i]);\n        }\n    } else {\n        for (int i = planet2_index + 1; i < planet1_index; i++) {\n            result.push_back(planet_names[i]);\n        }\n    }\n    \n    return result;\n}\n", "py_code": "def bf(planet1, planet2):\n    planet_names = (\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n    if planet1 not in planet_names or planet2 not in planet_names or planet1 == planet2:\n        return ()\n    planet1_index = planet_names.index(planet1)\n    planet2_index = planet_names.index(planet2)\n    if planet1_index < planet2_index:\n        return (planet_names[planet1_index + 1: planet2_index])\n    else:\n        return (planet_names[planet2_index + 1 : planet1_index])\n", "py_summary": "The Python code defines a function `bf` that takes two planet names as input and returns a list of planet names located between the orbits of the two input planets. \n1. It first defines a tuple `planet_names` containing the names of all eight planets in the solar system in order.\n2. It checks if the input planet names `planet1` and `planet2` are valid planet names and not the same. If either of the planet names is invalid or they are the same, an empty tuple `()` is returned.\n3. It then finds the index of the input planets in the `planet_names` tuple.\n4. Based on the indices of the input planets, it extracts the planets located between them in the `planet_names` tuple.\n5. The function returns a tuple containing the names of planets between the orbits of the input planets.\n\nThe function correctly handles cases where the input planets are not valid planet names or if they are the same. It also considers the order of the input planets to determine the planets located between them."}
{"task_id": "CPP/149", "generation": "vector<string> sorted_list_sum(vector<string> lst){\n    sort(lst.begin(), lst.end());\n    vector<string> new_lst;\n    for (const string& s : lst) {\n        if (s.length() % 2 == 0) {\n            new_lst.push_back(s);\n        }\n    }\n    sort(new_lst.begin(), new_lst.end(), [](const string& a, const string& b) {\n        if (a.length() == b.length()) {\n            return a < b;\n        }\n        return a.length() < b.length();\n    });\n    return new_lst;\n}\n", "py_code": "def sorted_list_sum(lst):\n    lst.sort()\n    new_lst = []\n    for i in lst:\n        if len(i)%2 == 0:\n            new_lst.append(i)\n    return sorted(new_lst, key=len)\n", "py_summary": "The Python code defines a function that takes a list of strings as input, removes strings with odd lengths, and returns a new list containing the remaining strings sorted first by length and then alphabetically. \n1. The input list is sorted in ascending order.\n2. A new empty list `new_lst` is created to store strings with even lengths.\n3. Iterate through each string in the input list:\n    - If the length of the string is even (i.e., divisible by 2), add it to `new_lst`.\n4. Finally, return `new_lst` sorted first by length and then alphabetically."}
{"task_id": "CPP/150", "generation": "#include <stdio.h>\n#include <math.h>\nusing namespace std;\n\nint x_or_y(int n, int x, int y) {\n    if (n == 1) {\n        return y;\n    }\n    for (int i = 2; i < n; i++) {\n        if (n % i == 0) {\n            return y;\n            break;\n        }\n    }\n    return x;\n}\n", "py_code": "def x_or_y(n, x, y):\n    if n == 1:\n        return y\n    for i in range(2, n):\n        if n % i == 0:\n            return y\n            break\n    else:\n        return x\n", "py_summary": "The Python code defines a function that takes three integers as input: n, x, and y. The function checks if n is a prime number by iterating from 2 to n-1 and checking if n is divisible by any number in that range. If n is not prime (i.e., it has a divisor other than 1 and itself), the function returns the value of y. If n is prime, the function returns the value of x. If n is 1, the function directly returns the value of y."}
{"task_id": "CPP/151", "generation": "long long double_the_difference(vector<float> lst){\n    long long sum = 0;\n    for (float num : lst) {\n        if (num > 0 && num == (int)num && fmod(num, 2) != 0) {\n            sum += (long long)pow(num, 2);\n        }\n    }\n    return sum;\n}\n", "py_code": "def double_the_difference(lst):\n    return sum([i**2 for i in lst if i > 0 and i%2!=0 and \".\" not in str(i)])\n", "py_summary": "The Python code defines a function that calculates the sum of squares of the numbers in a list that are odd, positive integers. It iterates through the list and filters out numbers that are negative, not integers, or even. For each remaining number, it calculates the square and adds it to the sum. Finally, it returns the total sum of squares of odd, positive integers in the list."}
{"task_id": "CPP/152", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\nvector<int> compare(vector<int> game,vector<int> guess){\n    vector<int> differences;\n    for (int i = 0; i < game.size(); i++) {\n        differences.push_back(abs(game[i] - guess[i]));\n    }\n    return differences;\n}\n", "py_code": "def compare(game,guess):\n    return [abs(x-y) for x,y in zip(game,guess)]\n", "py_summary": "The Python code defines a function that takes two lists (`game` and `guess`) as input, where each list represents the scores and guesses for a series of matches. The function uses a list comprehension along with the `zip` function to iterate over corresponding elements of the `game` and `guess` lists simultaneously. \n\nFor each pair of elements, it calculates the absolute difference between the guess and the actual score using `abs(x-y)` and creates a new list containing these differences. Finally, the function returns the list of differences."}
{"task_id": "CPP/153", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring Strongest_Extension(string class_name, vector<string> extensions) {\n    string strongest = extensions[0];\n    int my_val = 0;\n    for (char c : extensions[0]) {\n        if (isalpha(c)) {\n            if (isupper(c)) {\n                my_val++;\n            } else {\n                my_val--;\n            }\n        }\n    }\n    for (const string& s : extensions) {\n        int val = 0;\n        for (char c : s) {\n            if (isalpha(c)) {\n                if (isupper(c)) {\n                    val++;\n                } else {\n                    val--;\n                }\n            }\n        }\n        if (val > my_val) {\n            strongest = s;\n            my_val = val;\n        }\n    }\n    return class_name + \".\" + strongest;\n}\n", "py_code": "def Strongest_Extension(class_name, extensions):\n    strong = extensions[0]\n    my_val = len([x for x in extensions[0] if x.isalpha() and x.isupper()]) - len([x for x in extensions[0] if x.isalpha() and x.islower()])\n    for s in extensions:\n        val = len([x for x in s if x.isalpha() and x.isupper()]) - len([x for x in s if x.isalpha() and x.islower()])\n        if val > my_val:\n            strong = s\n            my_val = val\n\n    ans = class_name + \".\" + strong\n    return ans\n\n", "py_summary": "The Python code defines a function `Strongest_Extension` that takes a class name and a list of extensions as input and returns a string in the format \"ClassName.StrongestExtensionName\". The function initializes the strongest extension as the first extension in the list and calculates its strength based on the number of uppercase and lowercase letters in the extension name.\n\nThen, the function iterates through the list of extensions, calculates the strength for each extension, and compares it with the current strongest extension. If a new extension with higher strength is found, it updates the strongest extension and its strength value.\n\nFinally, the function constructs the output string by concatenating the class name, a dot separator, and the strongest extension name, and returns the result.\n\nThe function prioritizes the extension that appears first in the list if there are multiple extensions with the same strength."}
{"task_id": "CPP/154", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\nbool cycpattern_check(string a, string b){\n    int n = a.size();\n    int m = b.size();\n    string pat = b + b;\n    for (int i = 0; i < n - m + 1; i++) {\n        for (int j = 0; j < m + 1; j++) {\n            if (a.substr(i, m) == pat.substr(j, m)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n", "py_code": "def cycpattern_check(a , b):\n    l = len(b)\n    pat = b + b\n    for i in range(len(a) - l + 1):\n        for j in range(l + 1):\n            if a[i:i+l] == pat[j:j+l]:\n                return True\n    return False\n", "py_summary": "The Python code defines a function `cycpattern_check` that takes two strings `a` and `b` as input and checks if the second string `b` or any of its rotations is a substring of the first string `a`. The function first calculates the length of string `b` and creates a pattern string `pat` by concatenating `b` with itself. \n\nThen, the function iterates through all possible starting positions in string `a` where a substring of length equal to the length of `b` can fit. For each starting position, it checks if any rotation of `b` matches the substring in `a`. If a match is found, the function returns `True`. If no match is found after checking all rotations, the function returns `False`."}
{"task_id": "CPP/155", "generation": "vector<int> even_odd_count(int num){\n    vector<int> counts = {0, 0};\n    string num_str = to_string(abs(num));\n    for(char c : num_str){\n        int digit = c - '0';\n        if(digit % 2 == 0){\n            counts[0]++;\n        } else {\n            counts[1]++;\n        }\n    }\n    return counts;\n}\n", "py_code": "def even_odd_count(num):\n    even_count = 0\n    odd_count = 0\n    for i in str(abs(num)):\n        if int(i)%2==0:\n            even_count +=1\n        else:\n            odd_count +=1\n    return (even_count, odd_count)\n", "py_summary": "The Python code defines a function that takes an integer as input and returns a tuple containing the count of even and odd digits in the absolute value of the input number. The function iterates through each digit of the absolute value of the input number by converting it to a string. For each digit, it checks if it is even or odd by converting it back to an integer and using the modulo operator. Based on whether the digit is even or odd, it increments the corresponding count. Finally, the function returns a tuple containing the count of even and odd digits."}
{"task_id": "CPP/156", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring int_to_mini_roman(int number) {\n    vector<int> num = {1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000};\n    vector<string> sym = {\"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\", \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\"};\n    int i = 12;\n    string res = \"\";\n    while (number > 0) {\n        int div = number / num[i];\n        number %= num[i];\n        while (div > 0) {\n            res += sym[i];\n            div--;\n        }\n        i--;\n    }\n    for (char &c : res) {\n        c = tolower(c);\n    }\n    return res;\n}\n", "py_code": "def int_to_mini_roman(number):\n    num = [1, 4, 5, 9, 10, 40, 50, 90,  \n           100, 400, 500, 900, 1000] \n    sym = [\"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\",  \n           \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\"] \n    i = 12\n    res = ''\n    while number: \n        div = number // num[i] \n        number %= num[i] \n        while div: \n            res += sym[i] \n            div -= 1\n        i -= 1\n    return res.lower()\n", "py_summary": "The Python code defines a function that converts a given positive integer into its Roman numeral equivalent in lowercase. It uses two lists, `num` and `sym`, to store the integer values and their corresponding Roman numeral symbols. The function iterates through the `num` list in reverse order, dividing the input number by the current value in `num` to determine how many times the symbol at that index should be added to the result string. \n\nThe function then appends the Roman numeral symbols to the result string based on the division result and decrements the index `i` to move to the next smaller Roman numeral value. Finally, the function returns the lowercase Roman numeral representation of the input number."}
{"task_id": "CPP/157", "generation": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\nbool right_angle_triangle(float a, float b, float c){\n    return a*a == b*b + c*c || b*b == a*a + c*c || c*c == a*a + b*b;\n}\n", "py_code": "def right_angle_triangle(a, b, c):\n    return a*a == b*b + c*c or b*b == a*a + c*c or c*c == a*a + b*b\n", "py_summary": "The Python code defines a function that takes the lengths of three sides of a triangle as input and checks if the triangle is a right-angled triangle. It does so by comparing the squares of the lengths of the sides to see if they satisfy the Pythagorean theorem. The function returns True if any of the three combinations of sides satisfy the theorem, indicating a right-angled triangle, and False otherwise."}
{"task_id": "CPP/158", "generation": "#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nstring find_max(vector<string> words) {\n    return *min_element(words.begin(), words.end(), [](const string& a, const string& b) {\n        if (set<char>(a.begin(), a.end()).size() == set<char>(b.begin(), b.end()).size()) {\n            return a < b;\n        }\n        return set<char>(a.begin(), a.end()).size() > set<char>(b.begin(), b.end()).size();\n    });\n}\n", "py_code": "def find_max(words):\n    return sorted(words, key = lambda x: (-len(set(x)), x))[0]\n", "py_summary": "The Python code defines a function that takes a list of strings as input and returns the string with the maximum number of unique characters. If there are multiple strings with the same maximum number of unique characters, it returns the string that comes first in lexicographical order. \n\nThe function uses the `sorted` function with a custom key function to sort the list of words based on two criteria:\n1. The length of the set of unique characters in each word (in descending order).\n2. The lexicographical order of the words.\n\nBy sorting the words in this manner, the function then returns the first word in the sorted list, which corresponds to the word with the maximum number of unique characters and comes first in lexicographical order."}
{"task_id": "CPP/159", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\nvector<int> eat(int number, int need, int remaining){\n    if(need <= remaining){\n        return { number + need , remaining - need };\n    } else {\n        return { number + remaining , 0 };\n    }\n}\n", "py_code": "def eat(number, need, remaining):\n    if(need <= remaining):\n        return [ number + need , remaining-need ]\n    else:\n        return [ number + remaining , 0]\n", "py_summary": "The Python code defines a function that takes three integers as input: `number` (the number of carrots already eaten), `need` (the number of carrots needed to eat), and `remaining` (the number of remaining carrots in stock). \n\nThe function checks if the number of needed carrots is less than or equal to the number of remaining carrots. If it is, the function returns a list containing the total number of eaten carrots (sum of already eaten and needed carrots) and the number of carrots left after eating the needed amount. If the needed carrots exceed the remaining carrots, the function returns a list containing the total number of eaten carrots (sum of already eaten and remaining carrots) and 0 as there are no carrots left after eating all the remaining ones."}
{"task_id": "CPP/160", "generation": "int do_algebra(vector<string> operato, vector<int> operand){\n    string expression = to_string(operand[0]);\n    for (int i = 0; i < operato.size(); i++) {\n        expression += operato[i] + to_string(operand[i + 1]);\n    }\n    return stoi(expression);\n}\n", "py_code": "def do_algebra(operator, operand):\n    expression = str(operand[0])\n    for oprt, oprn in zip(operator, operand[1:]):\n        expression+= oprt + str(oprn)\n    return eval(expression)\n", "py_summary": "The Python code defines a function that takes two input lists: `operator` containing basic algebra operations and `operand` containing integers. The function builds an algebraic expression by concatenating the integers from the `operand` list with the corresponding operators from the `operator` list. It then evaluates the expression using the `eval` function in Python and returns the result."}
{"task_id": "CPP/161", "generation": "#include <string>\n#include <cctype>\n\nstring solve(string s) {\n    bool hasLetter = false;\n    for (char& c : s) {\n        if (isalpha(c)) {\n            hasLetter = true;\n            c = islower(c) ? toupper(c) : tolower(c);\n        }\n    }\n    if (!hasLetter) {\n        reverse(s.begin(), s.end());\n    }\n    return s;\n}\n", "py_code": "def solve(s):\n    flg = 0\n    idx = 0\n    new_str = list(s)\n    for i in s:\n        if i.isalpha():\n            new_str[idx] = i.swapcase()\n            flg = 1\n        idx += 1\n    s = \"\"\n    for i in new_str:\n        s += i\n    if flg == 0:\n        return s[len(s)::-1]\n    return s\n", "py_summary": "The Python code defines a function that takes a string as input and performs the following operations:\n1. It initializes a flag `flg` to 0 and an index `idx` to 0.\n2. It converts the input string `s` into a list of characters to make it mutable.\n3. It iterates through each character in the input string:\n    - If the character is a letter, it swaps the case (lower to upper or vice versa) and updates the character in the list at index `idx`. It also sets the flag `flg` to 1 to indicate that at least one letter was found.\n    - It increments the index `idx`.\n4. It then reconstructs the string `s` from the modified list of characters.\n5. If no letters were found (flag `flg` is still 0), it returns the reversed string.\n6. Otherwise, it returns the modified string.\n\nThe function effectively processes the input string based on the given conditions and returns the resulting string."}
{"task_id": "CPP/162", "generation": "#include <string>\n#include <openssl/md5.h>\n\nstd::string string_to_md5(std::string text) {\n    if (text.empty()) {\n        return \"\";\n    }\n    \n    MD5_CTX ctx;\n    MD5_Init(&ctx);\n    MD5_Update(&ctx, text.c_str(), text.length());\n    \n    unsigned char result[MD5_DIGEST_LENGTH];\n    MD5_Final(result, &ctx);\n    \n    char md5_hash[MD5_DIGEST_LENGTH * 2 + 1];\n    for (int i = 0; i < MD5_DIGEST_LENGTH; i++) {\n        sprintf(&md5_hash[i * 2], \"%02x\", (unsigned int)result[i]);\n    }\n    \n    return std::string(md5_hash);\n}\n", "py_code": "def string_to_md5(text):\n    import hashlib\n    return hashlib.md5(text.encode('ascii')).hexdigest() if text else None\n", "py_summary": "The Python code defines a function that takes a string `text` as input and returns its MD5 hash equivalent string. It first checks if the input string is empty, in which case it returns `None`. If the input string is not empty, it encodes the string to ASCII and computes the MD5 hash using the `hashlib` library. Finally, it returns the hexadecimal representation of the MD5 hash."}
{"task_id": "CPP/163", "generation": "#include <vector>\n\nstd::vector<int> generate_integers(int a, int b) {\n    int lower = std::max(2, std::min(a, b));\n    int upper = std::min(8, std::max(a, b));\n\n    std::vector<int> result;\n    for (int i = lower; i <= upper; i++) {\n        if (i % 2 == 0) {\n            result.push_back(i);\n        }\n    }\n\n    return result;\n}\n", "py_code": "def generate_integers(a, b):\n    lower = max(2, min(a, b))\n    upper = min(8, max(a, b))\n\n    return [i for i in range(lower, upper+1) if i % 2 == 0]\n", "py_summary": "The Python code defines a function that takes two integers a and b as input and returns a list of even digits between the two integers in ascending order. \n1. It first determines the lower and upper bounds for the range of numbers to consider. The lower bound is set to the maximum of 2 and the smaller of the two input integers, while the upper bound is set to the minimum of 8 and the larger of the two input integers.\n2. It then generates a list comprehension that iterates over the range from the lower bound to the upper bound (inclusive) and filters out only the even numbers by checking if the number is divisible by 2.\n3. The function returns the list of even digits between the two input integers.\n\nThe code efficiently handles cases where the input integers are not in ascending order and ensures that only even digits less than 10 are considered."}
