{"task_id": "CPP/0", "generation": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nbool has_close_elements(vector<float> numbers, float threshold) {\n    if (numbers.empty()) {\n        return false;\n    }\n\n    for (int i = 0; i < numbers.size(); i++) {\n        for (int j = i + 1; j < numbers.size(); j++) {\n            if (abs(numbers[i] - numbers[j]) < threshold) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n\n"}
{"task_id": "CPP/1", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<string> separate_paren_groups(string paren_string) {\n    vector<string> result;\n    string current_group;\n\n    // Remove spaces from the input string\n    string input_string_no_spaces;\n    for (char c : paren_string) {\n        if (c != ' ') {\n            input_string_no_spaces += c;\n        }\n    }\n\n    // Extract separate groups of nested parentheses\n    int open_count = 0;\n    for (char c : input_string_no_spaces) {\n        if (c == '(') {\n            open_count++;\n        } else if (c == ')') {\n            open_count--;\n        }\n\n        current_group += c;\n\n        if (open_count == 0) {\n            result.push_back(current_group);\n            current_group = \"\";\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/2", "generation": "#include <iostream>\n#include <cmath>\n\nfloat truncate_number(float number) {\n    float integer_part = floor(number);\n    float decimal_part = number - integer_part;\n    return decimal_part;\n}\n\n"}
{"task_id": "CPP/3", "generation": "#include <vector>\n\nbool below_zero(vector<int> operations) {\n    int balance = 0;\n    \n    for (int i = 0; i < operations.size(); i++) {\n        balance += operations[i];\n        if (balance < 0) {\n            return true;\n        }\n    }\n    \n    return false;\n}\n"}
{"task_id": "CPP/4", "generation": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nfloat mean_absolute_deviation(std::vector<float> numbers) {\n    // Step 1: Calculate the mean of the input numbers\n    float sum = 0;\n    for (float num : numbers) {\n        sum += num;\n    }\n    float mean = sum / numbers.size();\n\n    // Step 2: Calculate the absolute difference between each number and the mean\n    std::vector<float> absolute_diff;\n    for (float num : numbers) {\n        absolute_diff.push_back(std::abs(num - mean));\n    }\n\n    // Step 3: Calculate the average of the absolute differences\n    float total_diff = 0;\n    for (float diff : absolute_diff) {\n        total_diff += diff;\n    }\n    float mean_absolute_deviation = total_diff / absolute_diff.size();\n\n    // Step 4: Return the mean absolute deviation\n    return mean_absolute_deviation;\n}\n\n"}
{"task_id": "CPP/5", "generation": "#include <vector>\n\nusing namespace std;\n\nvector<int> intersperse(vector<int> numbers, int delimiter) {\n    vector<int> result;\n\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        result.push_back(numbers[i]);\n        if (i != numbers.size() - 1) {\n            result.push_back(delimiter);\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/6", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<int> parse_nested_parens(string paren_string) {\n    vector<int> max_nesting_levels;\n    \n    int max_nesting = 0;\n    int current_nesting = 0;\n    \n    for (char c : paren_string) {\n        if (c == '(') {\n            current_nesting++;\n            if (current_nesting > max_nesting) {\n                max_nesting = current_nesting;\n            }\n        } else if (c == ')') {\n            current_nesting--;\n        } else if (c == ' ') {\n            max_nesting_levels.push_back(max_nesting);\n            max_nesting = 0;\n            current_nesting = 0;\n        }\n    }\n    \n    max_nesting_levels.push_back(max_nesting);\n    \n    return max_nesting_levels;\n}\n\n"}
{"task_id": "CPP/7", "generation": "#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> filter_by_substring(vector<string> strings, string substring) {\n    vector<string> filtered_strings;\n    \n    for (const string& str : strings) {\n        if (str.find(substring) != string::npos) {\n            filtered_strings.push_back(str);\n        }\n    }\n    \n    return filtered_strings;\n}\n"}
{"task_id": "CPP/8", "generation": "#include <vector>\n\nusing namespace std;\n\nvector<int> sum_product(vector<int> numbers) {\n    if (numbers.empty()) {\n        return {0, 1};\n    }\n\n    int sum = 0;\n    int product = 1;\n\n    for (int num : numbers) {\n        sum += num;\n        product *= num;\n    }\n\n    return {sum, product};\n}\n"}
{"task_id": "CPP/9", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> rolling_max(vector<int> numbers) {\n    vector<int> rollingMax;\n    int maxSoFar = numbers[0];\n    \n    for (int i = 0; i < numbers.size(); i++) {\n        maxSoFar = max(maxSoFar, numbers[i]);\n        rollingMax.push_back(maxSoFar);\n    }\n    \n    return rollingMax;\n}\n"}
{"task_id": "CPP/10", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_palindrome(string str) {\n    string s(str.rbegin(), str.rend());\n    return s == str;\n}\n\nstring find_longest_palindromic_suffix(string str) {\n    string longest_suffix = \"\";\n    for (int i = str.length() - 1; i >= 0; i--) {\n        string suffix = str.substr(i);\n        if (is_palindrome(suffix) && suffix.length() > longest_suffix.length()) {\n            longest_suffix = suffix;\n        }\n    }\n    return longest_suffix;\n}\n\nstring reverse_prefix(string str, string suffix) {\n    int prefix_length = str.length() - suffix.length();\n    string prefix = str.substr(0, prefix_length);\n    string reversed_prefix(prefix.rbegin(), prefix.rend());\n    return reversed_prefix;\n}\n\nstring make_palindrome(string str) {\n    string longest_suffix = find_longest_palindromic_suffix(str);\n    string reversed_prefix = reverse_prefix(str, longest_suffix);\n    return str + reversed_prefix;\n}\n\n"}
{"task_id": "CPP/11", "generation": "#include <string>\nusing namespace std;\n\nstring string_xor(string a, string b) {\n    // Validate input strings a and b\n    for (char c : a) {\n        if (c != '0' && c != '1') {\n            return \"Invalid input\";\n        }\n    }\n    for (char c : b) {\n        if (c != '0' && c != '1') {\n            return \"Invalid input\";\n        }\n    }\n\n    // Perform binary XOR operation\n    string result = \"\";\n    for (int i = 0; i < a.size(); i++) {\n        if (a[i] == b[i]) {\n            result += '0';\n        } else {\n            result += '1';\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/12", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring longest(vector<string> strings) {\n    if (strings.empty()) {\n        return \"None\";\n    }\n\n    string longestString = strings[0];\n    for (int i = 1; i < strings.size(); i++) {\n        if (strings[i].length() > longestString.length()) {\n            longestString = strings[i];\n        }\n    }\n\n    return longestString;\n}\n\n"}
{"task_id": "CPP/13", "generation": "#include <iostream>\n\nint greatest_common_divisor(int a, int b) {\n    int smaller = (a < b) ? a : b;\n    \n    for (int i = smaller; i >= 1; i--) {\n        if (a % i == 0 && b % i == 0) {\n            return i;\n        }\n    }\n    \n    return 1;\n}\n\n"}
{"task_id": "CPP/14", "generation": "#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> all_prefixes(string str) {\n    vector<string> prefixes;\n    for (int i = 1; i <= str.length(); i++) {\n        prefixes.push_back(str.substr(0, i));\n    }\n    return prefixes;\n}\n"}
{"task_id": "CPP/15", "generation": "#include <string>\n#include <sstream>\n\nusing namespace std;\n\nstring string_sequence(int n) {\n    stringstream ss;\n    for (int i = 0; i <= n; i++) {\n        ss << i;\n        if (i != n) {\n            ss << \" \";\n        }\n    }\n    return ss.str();\n}\n"}
{"task_id": "CPP/16", "generation": "#include <iostream>\n#include <string>\n#include <unordered_set>\n#include <cctype>\n\nint count_distinct_characters(const std::string& str) {\n    std::unordered_set<char> charSet;\n    \n    for (char c : str) {\n        charSet.insert(std::tolower(c));\n    }\n    \n    return charSet.size();\n}\n\n"}
{"task_id": "CPP/17", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<int> parse_music(string music_string) {\n    vector<int> beats;\n    string note = \"\";\n    \n    for (char c : music_string) {\n        if (c == 'o') {\n            note += 'o';\n        } else if (c == '|') {\n            if (note == \"o\") {\n                beats.push_back(4);\n            } else if (note == \"o|\") {\n                beats.push_back(2);\n            } else if (note == \".|\") {\n                beats.push_back(1);\n            }\n            note = \"\";\n        }\n    }\n    \n    if (!note.empty()) {\n        if (note == \"o\") {\n            beats.push_back(4);\n        } else if (note == \"o|\") {\n            beats.push_back(2);\n        } else if (note == \".|\") {\n            beats.push_back(1);\n        }\n    }\n    \n    return beats;\n}\n\n"}
{"task_id": "CPP/18", "generation": "#include <iostream>\n#include <string>\n\nint how_many_times(string str, string substring) {\n    if (substring.length() > str.length()) {\n        return 0;\n    }\n    \n    int count = 0;\n    for (size_t i = 0; i <= str.length() - substring.length(); i++) {\n        if (str.substr(i, substring.length()) == substring) {\n            count++;\n        }\n    }\n    \n    return count;\n}\n\n"}
{"task_id": "CPP/19", "generation": "#include <iostream>\n#include <string>\n#include <vector>\n#include <map>\n#include <algorithm>\n\nusing namespace std;\n\nstring sort_numbers(string numbers) {\n    map<string, int> numberMap = {\n        {\"zero\", 0},\n        {\"one\", 1},\n        {\"two\", 2},\n        {\"three\", 3},\n        {\"four\", 4},\n        {\"five\", 5},\n        {\"six\", 6},\n        {\"seven\", 7},\n        {\"eight\", 8},\n        {\"nine\", 9}\n    };\n\n    vector<string> numberWords;\n    string word = \"\";\n    for (char c : numbers) {\n        if (c == ' ') {\n            numberWords.push_back(word);\n            word = \"\";\n        } else {\n            word += c;\n        }\n    }\n    numberWords.push_back(word);\n\n    vector<int> numericalValues;\n    for (string num : numberWords) {\n        numericalValues.push_back(numberMap[num]);\n    }\n\n    sort(numericalValues.begin(), numericalValues.end());\n\n    string sortedNumbers = \"\";\n    for (int num : numericalValues) {\n        for (auto it : numberMap) {\n            if (it.second == num) {\n                sortedNumbers += it.first + \" \";\n                break;\n            }\n        }\n    }\n\n    sortedNumbers.pop_back(); // Remove the extra space at the end\n    return sortedNumbers;\n}\n\n"}
{"task_id": "CPP/20", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\nstd::pair<float, float> find_closest_elements(const std::vector<float>& numbers) {\n    if (numbers.size() < 2) {\n        throw std::invalid_argument(\"Input vector must have at least two elements\");\n    }\n\n    std::vector<float> sortedNumbers = numbers;\n    std::sort(sortedNumbers.begin(), sortedNumbers.end());\n\n    float minDiff = std::abs(sortedNumbers[1] - sortedNumbers[0]);\n    std::pair<float, float> closestPair(sortedNumbers[0], sortedNumbers[1]);\n\n    for (size_t i = 1; i < sortedNumbers.size() - 1; ++i) {\n        float diff = std::abs(sortedNumbers[i + 1] - sortedNumbers[i]);\n        if (diff < minDiff) {\n            minDiff = diff;\n            closestPair = {sortedNumbers[i], sortedNumbers[i + 1]};\n        }\n    }\n\n    return closestPair;\n}\n\n"}
{"task_id": "CPP/21", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nvector<float> rescale_to_unit(vector<float> numbers) {\n    if (numbers.size() < 2) {\n        return {};\n    }\n\n    float smallest = *min_element(numbers.begin(), numbers.end());\n    float largest = *max_element(numbers.begin(), numbers.end());\n    float range = largest - smallest;\n\n    vector<float> rescaled_numbers;\n    for (float num : numbers) {\n        float rescaled_num = (num - smallest) / range;\n        rescaled_numbers.push_back(rescaled_num);\n    }\n\n    return rescaled_numbers;\n}\n\n"}
{"task_id": "CPP/22", "generation": "#include <iostream>\n#include <vector>\n#include <boost/any.hpp>\n#include <list>\n\ntypedef std::list<boost::any> list_any;\n\nstd::vector<int> filter_integers(list_any values) {\n    std::vector<int> result;\n\n    for (const auto& val : values) {\n        try {\n            int num = boost::any_cast<int>(val);\n            result.push_back(num);\n        } catch (const boost::bad_any_cast&) {\n            // Ignore non-integer values\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/23", "generation": "#include <string>\n\nint strlen(string str) {\n    if (str.empty()) {\n        return 0;\n    }\n\n    int length = 0;\n    for (char c : str) {\n        length++;\n    }\n\n    return length;\n}\n"}
{"task_id": "CPP/24", "generation": "#include <iostream>\n\nint largest_divisor(int n) {\n    int largest = 1;\n    for (int i = 2; i < n; i++) {\n        if (n % i == 0) {\n            largest = i;\n        }\n    }\n    return largest;\n}\n\n"}
{"task_id": "CPP/25", "generation": "#include <vector>\n#include <cmath>\nusing namespace std;\n\nvector<int> factorize(int n) {\n    vector<int> factors;\n    \n    for (int i = 2; i <= sqrt(n); i++) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n    \n    if (n > 1) {\n        factors.push_back(n);\n    }\n    \n    return factors;\n}\n"}
{"task_id": "CPP/26", "generation": "#include <vector>\n#include <unordered_map>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> remove_duplicates(vector<int> numbers) {\n    unordered_map<int, int> countMap;\n    vector<int> result;\n\n    for (int num : numbers) {\n        countMap[num]++;\n    }\n\n    for (int num : numbers) {\n        if (countMap[num] == 1) {\n            result.push_back(num);\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/27", "generation": "#include <string>\nusing namespace std;\n\nstring flip_case(string str) {\n    string output = \"\";\n    \n    for (char c : str) {\n        if (isupper(c)) {\n            output += tolower(c);\n        } else if (islower(c)) {\n            output += toupper(c);\n        } else {\n            output += c;\n        }\n    }\n    \n    return output;\n}\n"}
{"task_id": "CPP/28", "generation": "#include <vector>\n#include <string>\nusing namespace std;\n\nstring concatenate(vector<string> strings) {\n    if (strings.empty()) {\n        return \"\";\n    }\n\n    string result = \"\";\n    for (const string& s : strings) {\n        result += s;\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/29", "generation": "#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> filter_by_prefix(vector<string> strings, string prefix) {\n    vector<string> filtered_strings;\n    \n    if (strings.empty()) {\n        return filtered_strings;\n    }\n    \n    for (const string& str : strings) {\n        if (str.find(prefix) == 0) {\n            filtered_strings.push_back(str);\n        }\n    }\n    \n    return filtered_strings;\n}\n"}
{"task_id": "CPP/30", "generation": "#include <vector>\n\nusing namespace std;\n\nvector<float> get_positive(vector<float> l) {\n    vector<float> positiveNumbers;\n\n    for (float num : l) {\n        if (num > 0) {\n            positiveNumbers.push_back(num);\n        }\n    }\n\n    return positiveNumbers;\n}\n"}
{"task_id": "CPP/31", "generation": "#include <iostream>\n#include <cmath>\n\nbool is_prime(long long n) {\n    if (n < 2) {\n        return false;\n    }\n    \n    for (int i = 2; i <= sqrt(n); i++) {\n        if (n % i == 0) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n\n"}
{"task_id": "CPP/32", "generation": "#include <stdio.h>\n#include <math.h>\n#include <vector>\nusing namespace std;\n\ndouble poly(vector<double> xs, double x){\n    double sum = 0;\n    for (int i = 0; i < xs.size(); i++){\n        sum += xs[i] * pow(x, i);\n    }\n    return sum;\n}\n\ndouble find_zero(vector<double> xs){\n    double zero_point = 0.0;\n    if (xs.size() % 2 == 0 && xs.back() != 0){\n        // Implementing a simple root finding algorithm\n        double epsilon = 0.0001; // Tolerance for convergence\n        double x0 = 0.0; // Initial guess for the root\n        double x1 = 1.0; // Another initial guess for the root\n        while (abs(poly(xs, x1)) > epsilon){\n            double temp = x1;\n            x1 = x1 - poly(xs, x1) * (x1 - x0) / (poly(xs, x1) - poly(xs, x0));\n            x0 = temp;\n        }\n        zero_point = x1;\n    }\n    return zero_point;\n}\n"}
{"task_id": "CPP/33", "generation": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> sort_third(vector<int> l) {\n    vector<int> l_prime = l;\n    vector<int> divisible_by_three_values;\n\n    for (int i = 0; i < l.size(); i++) {\n        if (i % 3 == 0) {\n            divisible_by_three_values.push_back(l[i]);\n        }\n    }\n\n    sort(divisible_by_three_values.begin(), divisible_by_three_values.end());\n\n    int j = 0;\n    for (int i = 0; i < l.size(); i++) {\n        if (i % 3 == 0) {\n            l_prime[i] = divisible_by_three_values[j];\n            j++;\n        }\n    }\n\n    return l_prime;\n}\n"}
{"task_id": "CPP/34", "generation": "vector<int> unique(vector<int> l){\n    // Remove duplicates\n    sort(l.begin(), l.end());\n    l.erase(unique(l.begin(), l.end()), l.end());\n    \n    return l;\n}\n"}
{"task_id": "CPP/35", "generation": "#include <iostream>\n#include <vector>\n\nfloat max_element(vector<float> l) {\n    if (l.empty()) {\n        return 0; // Return 0 if the vector is empty\n    }\n\n    float max_value = l[0]; // Initialize max_value with the first element of the vector\n\n    for (int i = 1; i < l.size(); i++) {\n        if (l[i] > max_value) {\n            max_value = l[i]; // Update max_value if a greater element is found\n        }\n    }\n\n    return max_value; // Return the maximum element found in the vector\n}\n\n"}
{"task_id": "CPP/36", "generation": "#include <iostream>\nusing namespace std;\n\nbool isDivisibleBy11Or13(int num) {\n    return (num % 11 == 0) || (num % 13 == 0);\n}\n\nint countDigit7(int num) {\n    int count = 0;\n    while (num > 0) {\n        if (num % 10 == 7) {\n            count++;\n        }\n        num /= 10;\n    }\n    return count;\n}\n\nint fizz_buzz(int n) {\n    int total = 0;\n    for (int i = 1; i < n; i++) {\n        if (isDivisibleBy11Or13(i)) {\n            total += countDigit7(i);\n        }\n    }\n    return total;\n}\n\n"}
{"task_id": "CPP/37", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<float> sort_even(vector<float> l) {\n    vector<float> even_indices;\n\n    for (int i = 0; i < l.size(); i++) {\n        if (i % 2 == 0) {\n            even_indices.push_back(l[i]);\n        }\n    }\n\n    sort(even_indices.begin(), even_indices.end());\n\n    for (int i = 0, j = 0; i < l.size(); i++) {\n        if (i % 2 == 0) {\n            l[i] = even_indices[j];\n            j++;\n        }\n    }\n\n    return l;\n}\n\n"}
{"task_id": "CPP/38", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring encode_cyclic(string s) {\n    int l = s.length();\n    string output;\n    \n    for (int i = 0; i * 3 < l; i++) {\n        string x = s.substr(i * 3, 3);\n        if (x.length() == 3) {\n            x = x.substr(1) + x[0];\n        }\n        output += x;\n    }\n    \n    return output;\n}\n\nstring decode_cyclic(string s) {\n    int l = s.length();\n    string output;\n    \n    for (int i = 0; i * 3 < l; i++) {\n        string x = s.substr(i * 3, 3);\n        if (x.length() == 3) {\n            x = x[2] + x.substr(0, 2);\n        }\n        output += x;\n    }\n    \n    return output;\n}\n\n"}
{"task_id": "CPP/39", "generation": "#include <iostream>\n\nbool is_prime(int num) {\n    if (num <= 1) {\n        return false;\n    }\n    for (int i = 2; i * i <= num; i++) {\n        if (num % i == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint prime_fib(int n) {\n    if (n <= 0) {\n        return -1; // Invalid input\n    }\n\n    int first = 0, second = 1, next, count = 2; // Start with 2 as we already know the first two prime Fibonacci numbers\n\n    while (count < n) {\n        next = first + second;\n        first = second;\n        second = next;\n        if (is_prime(next)) {\n            count++;\n        }\n    }\n\n    return second;\n}\n\n"}
{"task_id": "CPP/40", "generation": "#include <vector>\nusing namespace std;\n\nbool triples_sum_to_zero(vector<int> l) {\n    if (l.size() < 3) {\n        return false;\n    }\n\n    for (int i = 0; i < l.size() - 2; i++) {\n        for (int j = i + 1; j < l.size() - 1; j++) {\n            for (int k = j + 1; k < l.size(); k++) {\n                if (l[i] + l[j] + l[k] == 0) {\n                    return true;\n                }\n            }\n        }\n    }\n\n    return false;\n}\n"}
{"task_id": "CPP/41", "generation": "#include <iostream>\n#include <vector>\n\nint car_race_collision(int n) {\n    std::vector<int> left_to_right(n);\n    std::vector<int> right_to_left(n);\n    \n    // Initialize the initial positions of the cars moving left to right and right to left\n    for (int i = 0; i < n; i++) {\n        left_to_right[i] = i * 2; // Assuming cars are initially spaced 2 units apart\n        right_to_left[i] = i * 2 + 1; // Assuming cars are initially spaced 2 units apart\n    }\n    \n    int collisions = 0;\n    \n    // Calculate the time it takes for the cars to collide and count the number of collisions\n    for (int i = 0; i < n; i++) {\n        int time_to_collision = (right_to_left[i] - left_to_right[i]) / 2; // Assuming cars move at speed 1 unit per time step\n        if (time_to_collision >= 0) {\n            collisions++;\n        }\n    }\n    \n    return collisions;\n}\n\n"}
{"task_id": "CPP/42", "generation": "#include <vector>\n\nvector<int> incr_vector(vector<int> l) {\n    vector<int> result;\n    \n    for (int i = 0; i < l.size(); i++) {\n        result.push_back(l[i] + 1);\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/43", "generation": "#include <vector>\nusing namespace std;\n\nbool pairs_sum_to_zero(vector<int> l) {\n    if (l.size() < 2) {\n        return false;\n    }\n\n    for (int i = 0; i < l.size(); i++) {\n        for (int j = i + 1; j < l.size(); j++) {\n            if (l[i] + l[j] == 0) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n"}
{"task_id": "CPP/44", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nstring change_base(int x, int base) {\n    if (x < 0 || x >= base || base >= 10) {\n        return \"Invalid input parameters\";\n    }\n\n    string result = \"\";\n    while (x > 0) {\n        result = to_string(x % base) + result;\n        x /= base;\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/45", "generation": "#include <iostream>\n\nfloat triangle_area(float a, float h) {\n    return 0.5 * a * h;\n}\n\n"}
{"task_id": "CPP/46", "generation": "#include <iostream>\n\nint fib4(int n) {\n    if (n == 0) return 0;\n    if (n == 1) return 0;\n    if (n == 2) return 2;\n    if (n == 3) return 0;\n\n    int fib0 = 0, fib1 = 0, fib2 = 2, fib3 = 0, fib4 = 0;\n\n    for (int i = 4; i <= n; ++i) {\n        fib4 = fib3 + fib2 + fib1 + fib0;\n        fib0 = fib1;\n        fib1 = fib2;\n        fib2 = fib3;\n        fib3 = fib4;\n    }\n\n    return fib4;\n}\n\n"}
{"task_id": "CPP/47", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nfloat median(vector<float> l) {\n    sort(l.begin(), l.end()); // Sort the elements in the vector in ascending order\n\n    int size = l.size(); // Calculate the size of the vector\n\n    if (size % 2 != 0) { // Check if the size of the vector is odd\n        return l[size / 2]; // Return the middle element of the sorted vector\n    } else {\n        return (l[size / 2 - 1] + l[size / 2]) / 2.0; // Return the average of the two middle elements of the sorted vector\n    }\n}\n\n"}
{"task_id": "CPP/48", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nbool is_palindrome(string text) {\n    // Check if the given string is empty\n    if (text.empty()) {\n        return true;\n    }\n\n    // Check if the given string is the same forwards and backwards\n    string reversed_text;\n    for (int i = text.length() - 1; i >= 0; i--) {\n        reversed_text += text[i];\n    }\n\n    return text == reversed_text;\n}\n\n"}
{"task_id": "CPP/49", "generation": "#include <iostream>\n\nint modp(int n, int p) {\n    if (p == 1) {\n        return 0;\n    }\n\n    long long result = 1;\n    long long base = 2;\n\n    while (n > 0) {\n        if (n % 2 == 1) {\n            result = (result * base) % p;\n        }\n        n = n / 2;\n        base = (base * base) % p;\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/50", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring encode_shift(string s){\n    string out;\n    for (int i = 0; i < s.length(); i++)\n    {\n        int w = ((int)s[i] + 5 - (int)'a') % 26 + (int)'a';   \n        out += (char)w;\n    }\n    return out;\n}\n\nstring decode_shift(string s){\n    string out;\n    for (int i = 0; i < s.length(); i++)\n    {\n        int w = ((int)s[i] - 5 - (int)'a' + 26) % 26 + (int)'a';   \n        out += (char)w;\n    }\n    return out;\n}\n\n"}
{"task_id": "CPP/51", "generation": "#include <string>\n#include <algorithm>\nusing namespace std;\n\nstring remove_vowels(string text) {\n    string result = \"\";\n    for (char c : text) {\n        if (c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u' && c != 'A' && c != 'E' && c != 'I' && c != 'O' && c != 'U') {\n            result += c;\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/52", "generation": "#include <vector>\n\nbool below_threshold(vector<int> l, int t) {\n    if (l.empty()) {\n        return false;\n    }\n\n    for (int num : l) {\n        if (num >= t) {\n            return false;\n        }\n    }\n\n    return true;\n}\n"}
{"task_id": "CPP/53", "generation": "int add(int x, int y) {\n    return x + y;\n}\n"}
{"task_id": "CPP/54", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nbool same_chars(string s0, string s1) {\n    sort(s0.begin(), s0.end());\n    sort(s1.begin(), s1.end());\n    \n    if (s0.length() != s1.length()) {\n        return false;\n    }\n    \n    for (int i = 0; i < s0.length(); i++) {\n        if (s0[i] != s1[i]) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n\n"}
{"task_id": "CPP/55", "generation": "#include <iostream>\n\nint fib(int n) {\n    if (n == 0) {\n        return 0;\n    } else if (n == 1) {\n        return 1;\n    } else {\n        return fib(n - 1) + fib(n - 2);\n    }\n}\n\n"}
{"task_id": "CPP/56", "generation": "#include <stack>\n\nbool correct_bracketing(string brackets) {\n    if (brackets.empty() || brackets.length() % 2 != 0) {\n        return false;\n    }\n\n    stack<char> bracketStack;\n\n    for (char bracket : brackets) {\n        if (bracket == '<') {\n            bracketStack.push(bracket);\n        } else if (bracket == '>') {\n            if (bracketStack.empty()) {\n                return false;\n            }\n            bracketStack.pop();\n        }\n    }\n\n    return bracketStack.empty();\n}\n"}
{"task_id": "CPP/57", "generation": "#include <vector>\n\nbool monotonic(vector<float> l) {\n    bool increasing = false;\n    bool decreasing = false;\n\n    for (int i = 0; i < l.size() - 1; i++) {\n        if (l[i] < l[i + 1]) {\n            increasing = true;\n        } else if (l[i] > l[i + 1]) {\n            decreasing = true;\n        }\n\n        if (increasing && decreasing) {\n            return false;\n        }\n    }\n\n    return true;\n}\n"}
{"task_id": "CPP/58", "generation": "#include <vector>\n#include <set>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> common(vector<int> l1, vector<int> l2) {\n    set<int> unique1(l1.begin(), l1.end());\n    set<int> unique2(l2.begin(), l2.end());\n    \n    set<int> commonElements;\n    \n    for (int num : unique1) {\n        if (unique2.find(num) != unique2.end()) {\n            commonElements.insert(num);\n        }\n    }\n    \n    vector<int> result(commonElements.begin(), commonElements.end());\n    sort(result.begin(), result.end());\n    \n    return result;\n}\n"}
{"task_id": "CPP/59", "generation": "#include <iostream>\n#include <vector>\n\nbool is_prime(int num) {\n    if (num <= 1) {\n        return false;\n    }\n    for (int i = 2; i * i <= num; i++) {\n        if (num % i == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nstd::vector<int> find_factors(int num) {\n    std::vector<int> factors;\n    for (int i = 2; i <= num; i++) {\n        if (num % i == 0) {\n            factors.push_back(i);\n        }\n    }\n    return factors;\n}\n\nstd::vector<int> find_prime_factors(const std::vector<int>& factors) {\n    std::vector<int> prime_factors;\n    for (int factor : factors) {\n        if (is_prime(factor)) {\n            prime_factors.push_back(factor);\n        }\n    }\n    return prime_factors;\n}\n\nint largest_prime_factor(int n) {\n    std::vector<int> factors = find_factors(n);\n    std::vector<int> prime_factors = find_prime_factors(factors);\n    \n    int largest_prime = 0;\n    for (int prime : prime_factors) {\n        if (prime > largest_prime) {\n            largest_prime = prime;\n        }\n    }\n    \n    return largest_prime;\n}\n\n"}
{"task_id": "CPP/60", "generation": "int sum_to_n(int n){\n    int sum = 0;\n    for(int i = 1; i <= n; i++){\n        sum += i;\n    }\n    return sum;\n}\n"}
{"task_id": "CPP/61", "generation": "#include <iostream>\n#include <string>\n\nbool correct_bracketing(string brackets) {\n    if (brackets.empty()) {\n        return false;\n    }\n\n    int openCount = 0;\n    int closeCount = 0;\n\n    for (char c : brackets) {\n        if (c == '(') {\n            openCount++;\n        } else if (c == ')') {\n            closeCount++;\n            if (closeCount > openCount) {\n                return false;\n            }\n        }\n    }\n\n    return openCount == closeCount;\n}\n\n"}
{"task_id": "CPP/62", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvector<float> derivative(vector<float> xs) {\n    vector<float> result;\n    \n    for (int i = 1; i < xs.size(); i++) {\n        result.push_back(xs[i] * i);\n    }\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/63", "generation": "#include <iostream>\n\nint fibfib(int n) {\n    if (n == 0) {\n        return 0;\n    } else if (n == 1) {\n        return 0;\n    } else if (n == 2) {\n        return 1;\n    } else {\n        return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3);\n    }\n}\n\n"}
{"task_id": "CPP/64", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nint vowels_count(string s) {\n    int count = 0;\n    bool yVowel = false;\n\n    for (int i = 0; i < s.length(); i++) {\n        char c = tolower(s[i]);\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n            count++;\n            yVowel = false;\n        } else if (c == 'y' && i == s.length() - 1) {\n            if (!yVowel) {\n                count++;\n                yVowel = true;\n            }\n        } else {\n            yVowel = false;\n        }\n    }\n\n    return count;\n}\n\n"}
{"task_id": "CPP/65", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nstring circular_shift(int x, int shift) {\n    string result = \"\";\n    int numDigits = to_string(x).length();\n    int effectiveShift = shift % numDigits;\n    \n    if (effectiveShift == 0) {\n        return to_string(x);\n    }\n    \n    string strX = to_string(x);\n    string shiftedStr = strX.substr(numDigits - effectiveShift) + strX.substr(0, numDigits - effectiveShift);\n    \n    return shiftedStr;\n}\n\n"}
{"task_id": "CPP/66", "generation": "#include <iostream>\n#include <string>\n\nint digitSum(std::string s) {\n    int sum = 0;\n    for (char c : s) {\n        if (isupper(c)) {\n            sum += static_cast<int>(c);\n        }\n    }\n    return sum;\n}\n\n"}
{"task_id": "CPP/67", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\n\nint fruit_distribution(string s, int n) {\n    int totalApples = 0;\n    int totalOranges = 0;\n    \n    // Extract the number of apples and oranges from the input string\n    stringstream ss(s);\n    string fruit;\n    int quantity;\n    while (ss >> quantity >> fruit) {\n        if (fruit == \"apples\") {\n            totalApples = quantity;\n        } else if (fruit == \"oranges\") {\n            totalOranges = quantity;\n        }\n    }\n    \n    // Calculate the total number of apples and oranges\n    int totalApplesOranges = totalApples + totalOranges;\n    \n    // Subtract the total number of apples and oranges from the total number of fruits in the basket\n    int mangoFruits = n - totalApplesOranges;\n    \n    return mangoFruits;\n}\n\n"}
{"task_id": "CPP/68", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> pluck(vector<int> arr) {\n    vector<int> evenValues;\n    int smallestEvenValue = -1;\n    int smallestEvenIndex = -1;\n\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] % 2 == 0) {\n            evenValues.push_back(arr[i]);\n            if (smallestEvenValue == -1 || arr[i] < smallestEvenValue) {\n                smallestEvenValue = arr[i];\n                smallestEvenIndex = i;\n            }\n        }\n    }\n\n    if (evenValues.empty()) {\n        return {};\n    }\n\n    return {smallestEvenValue, smallestEvenIndex};\n}\n"}
{"task_id": "CPP/69", "generation": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nint search(vector<int> lst) {\n    std::unordered_map<int, int> freqMap;\n\n    for (int num : lst) {\n        freqMap[num]++;\n    }\n\n    int result = -1;\n    for (const auto& pair : freqMap) {\n        if (pair.second >= pair.first && pair.first > result) {\n            result = pair.first;\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/70", "generation": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> strange_sort_list(vector<int> lst) {\n    vector<int> result;\n    \n    while (!lst.empty()) {\n        auto min_it = min_element(lst.begin(), lst.end());\n        result.push_back(*min_it);\n        lst.erase(min_it);\n        \n        if (!lst.empty()) {\n            auto max_it = max_element(lst.begin(), lst.end());\n            result.push_back(*max_it);\n            lst.erase(max_it);\n        }\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/71", "generation": "#include <iostream>\n#include <cmath>\n#include <iomanip>\n\nfloat triangle_area(float a, float b, float c) {\n    if (a + b > c && a + c > b && b + c > a) {\n        float s = (a + b + c) / 2;\n        float area = sqrt(s * (s - a) * (s - b) * (s - c));\n        return round(area * 100) / 100; // Round to 2 decimal points\n    } else {\n        return -1;\n    }\n}\n\n"}
{"task_id": "CPP/72", "generation": "#include <iostream>\n#include <vector>\n\nbool is_palindromic(const std::vector<int>& q) {\n    int start = 0;\n    int end = q.size() - 1;\n    \n    while (start < end) {\n        if (q[start] != q[end]) {\n            return false;\n        }\n        start++;\n        end--;\n    }\n    \n    return true;\n}\n\nbool will_it_fly(const std::vector<int>& q, int w) {\n    if (!is_palindromic(q)) {\n        return false;\n    }\n    \n    int sum = 0;\n    for (int num : q) {\n        sum += num;\n    }\n    \n    return sum <= w;\n}\n\n"}
{"task_id": "CPP/73", "generation": "#include <vector>\n#include <algorithm>\n\nint smallest_change(vector<int> arr) {\n    int changes = 0;\n    int left = 0;\n    int right = arr.size() - 1;\n\n    while (left < right) {\n        if (arr[left] != arr[right]) {\n            changes++;\n        }\n        left++;\n        right--;\n    }\n\n    return changes;\n}\n"}
{"task_id": "CPP/74", "generation": "#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> total_match(vector<string> lst1, vector<string> lst2) {\n    int totalChars1 = 0;\n    int totalChars2 = 0;\n\n    for (const string& s : lst1) {\n        totalChars1 += s.size();\n    }\n\n    for (const string& s : lst2) {\n        totalChars2 += s.size();\n    }\n\n    if (totalChars1 < totalChars2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n"}
{"task_id": "CPP/75", "generation": "#include <iostream>\n#include <vector>\n\nbool is_prime(int num) {\n    if (num <= 1) {\n        return false;\n    }\n    for (int i = 2; i*i <= num; i++) {\n        if (num % i == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nbool is_multiply_prime(int a) {\n    if (a >= 100) {\n        return false;\n    }\n    \n    std::vector<int> primes;\n    for (int i = 2; i < 100; i++) {\n        if (is_prime(i)) {\n            primes.push_back(i);\n        }\n    }\n    \n    for (int i = 0; i < primes.size(); i++) {\n        for (int j = i + 1; j < primes.size(); j++) {\n            for (int k = j + 1; k < primes.size(); k++) {\n                if (primes[i] * primes[j] * primes[k] == a) {\n                    return true;\n                }\n            }\n        }\n    }\n    \n    return false;\n}\n\n"}
{"task_id": "CPP/76", "generation": "#include <iostream>\n#include <cmath>\n\nbool is_simple_power(int x, int n) {\n    if (x == 1) {\n        return true;\n    }\n    \n    if (n == 1) {\n        return false;\n    }\n    \n    int power = 1;\n    while (pow(n, power) <= x) {\n        if (pow(n, power) == x) {\n            return true;\n        }\n        power++;\n    }\n    \n    return false;\n}\n\n"}
{"task_id": "CPP/77", "generation": "#include <iostream>\n#include <cmath>\n\nbool iscube(int a) {\n    double cubeRoot = cbrt(a);\n    return (cubeRoot == int(cubeRoot));\n}\n\n"}
{"task_id": "CPP/78", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <unordered_set>\n\nbool isPrime(int n) {\n    if (n <= 1) {\n        return false;\n    }\n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint hex_key(string num) {\n    std::unordered_set<char> primeHexDigits = {'2', '3', '5', '7', 'B', 'D'};\n    std::string hexChars = \"0123456789ABCDEF\";\n    int count = 0;\n\n    for (char c : num) {\n        if (primeHexDigits.find(c) != primeHexDigits.end()) {\n            count++;\n        }\n    }\n\n    return count;\n}\n\n"}
{"task_id": "CPP/79", "generation": "#include <string>\n\nstring decimal_to_binary(int decimal) {\n    if (decimal == 0) {\n        return \"db0db\";\n    }\n\n    string binary = \"\";\n    while (decimal > 0) {\n        binary = to_string(decimal % 2) + binary;\n        decimal /= 2;\n    }\n\n    return \"db\" + binary + \"db\";\n}\n"}
{"task_id": "CPP/80", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_happy(string s) {\n    if (s.length() < 3) {\n        return false;\n    }\n    \n    for (int i = 0; i <= s.length() - 3; i++) {\n        if (s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n\n"}
{"task_id": "CPP/81", "generation": "#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> numerical_letter_grade(vector<float> grades) {\n    vector<string> letterGrades;\n    \n    for (float gpa : grades) {\n        if (gpa == 4.0) {\n            letterGrades.push_back(\"A+\");\n        } else if (gpa > 3.7) {\n            letterGrades.push_back(\"A\");\n        } else if (gpa > 3.3) {\n            letterGrades.push_back(\"A-\");\n        } else if (gpa > 3.0) {\n            letterGrades.push_back(\"B+\");\n        } else if (gpa > 2.7) {\n            letterGrades.push_back(\"B\");\n        } else if (gpa > 2.3) {\n            letterGrades.push_back(\"B-\");\n        } else if (gpa > 2.0) {\n            letterGrades.push_back(\"C+\");\n        } else if (gpa > 1.7) {\n            letterGrades.push_back(\"C\");\n        } else if (gpa > 1.3) {\n            letterGrades.push_back(\"C-\");\n        } else if (gpa > 1.0) {\n            letterGrades.push_back(\"D+\");\n        } else if (gpa > 0.7) {\n            letterGrades.push_back(\"D\");\n        } else if (gpa > 0.0) {\n            letterGrades.push_back(\"D-\");\n        } else {\n            letterGrades.push_back(\"E\");\n        }\n    }\n    \n    return letterGrades;\n}\n"}
{"task_id": "CPP/82", "generation": "#include <iostream>\n#include <string>\n\nbool isPrime(int n) {\n    if (n <= 1) {\n        return false;\n    }\n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nbool prime_length(string str) {\n    int length = str.length();\n    return isPrime(length);\n}\n\n"}
{"task_id": "CPP/83", "generation": "#include <iostream>\n\nint starts_with_one(int n) {\n    int count = 0;\n    for (int i = 1; i < 10; i++) {\n        if (i == 1) {\n            count++;\n        }\n    }\n    return count;\n}\n\nint ends_with_one(int n) {\n    int count = 0;\n    for (int i = 1; i < 10; i++) {\n        if (i == 1) {\n            count++;\n        }\n    }\n    return count;\n}\n\nint starts_one_ends(int n) {\n    int count_starts = starts_with_one(n);\n    int count_ends = ends_with_one(n);\n    return count_starts + count_ends;\n}\n\n"}
{"task_id": "CPP/84", "generation": "#include <string>\nusing namespace std;\n\nstring solve(int N) {\n    int sum = 0;\n    \n    // Extracting individual digits and calculating the sum\n    while (N > 0) {\n        sum += N % 10;\n        N /= 10;\n    }\n    \n    // Converting the sum into binary\n    string binary = \"\";\n    while (sum > 0) {\n        binary = to_string(sum % 2) + binary;\n        sum /= 2;\n    }\n    \n    // Handling the case when the sum is 0\n    if (binary == \"\") {\n        binary = \"0\";\n    }\n    \n    return binary;\n}\n"}
{"task_id": "CPP/85", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint add(vector<int> lst) {\n    int sum = 0;\n    \n    for (int i = 1; i < lst.size(); i += 2) {\n        if (lst[i] % 2 == 0) {\n            sum += lst[i];\n        }\n    }\n    \n    return sum;\n}\n\n"}
{"task_id": "CPP/86", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nstring anti_shuffle(string s) {\n    string result = \"\";\n    string word = \"\";\n    \n    for (char c : s) {\n        if (c == ' ') {\n            sort(word.begin(), word.end());\n            result += word + \" \";\n            word = \"\";\n        } else {\n            word += c;\n        }\n    }\n    \n    sort(word.begin(), word.end());\n    result += word;\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/87", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<vector<int>> get_row(vector<vector<int>> lst, int x) {\n    vector<vector<int>> result;\n    \n    for (int i = 0; i < lst.size(); i++) {\n        for (int j = 0; j < lst[i].size(); j++) {\n            if (lst[i][j] == x) {\n                result.push_back({i, j});\n            }\n        }\n    }\n    \n    sort(result.begin(), result.end(), [](const vector<int>& a, const vector<int>& b) {\n        return a[0] < b[0];\n    });\n    \n    for (auto& row : result) {\n        sort(row.begin(), row.end(), greater<int>());\n    }\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/88", "generation": "#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> sort_array(vector<int> array) {\n    if (array.empty()) {\n        return {};\n    }\n\n    int sum = array.front() + array.back();\n\n    if (sum % 2 == 1) {\n        sort(array.begin(), array.end());\n    } else {\n        sort(array.begin(), array.end(), greater<int>());\n    }\n\n    return array;\n}\n"}
{"task_id": "CPP/89", "generation": "#include <string>\n#include <iostream>\n\nstd::string encrypt(std::string s) {\n    std::string result = \"\";\n    std::string alphabet = \"abcdefghijklmnopqrstuvwxyz\";\n\n    for (char& c : s) {\n        if (isalpha(c)) {\n            int index = alphabet.find(tolower(c));\n            if (index != std::string::npos) {\n                int rotated_index = (index + 2 * 2) % 26;\n                char rotated_char = isupper(c) ? toupper(alphabet[rotated_index]) : alphabet[rotated_index];\n                result += rotated_char;\n            }\n        } else {\n            result += c;\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/90", "generation": "#include <vector>\n#include <algorithm>\n#include <iostream>\n\nint next_smallest(vector<int> lst) {\n    if (lst.empty()) {\n        return -1; // Return -1 to indicate None\n    }\n\n    sort(lst.begin(), lst.end()); // Sort the input vector in ascending order\n\n    auto last = unique(lst.begin(), lst.end()); // Remove duplicates from the sorted vector\n    lst.erase(last, lst.end());\n\n    if (lst.size() < 2) {\n        return -1; // Return -1 to indicate None\n    }\n\n    return lst[1]; // Return the second smallest element\n}\n\n"}
{"task_id": "CPP/91", "generation": "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nvector<string> extractSentences(string input) {\n    vector<string> sentences;\n    string sentence = \"\";\n    \n    for (char c : input) {\n        if (c == '.' || c == '?' || c == '!') {\n            sentences.push_back(sentence);\n            sentence = \"\";\n        } else {\n            sentence += c;\n        }\n    }\n    \n    if (!sentence.empty()) {\n        sentences.push_back(sentence);\n    }\n    \n    return sentences;\n}\n\nbool startsWithI(string sentence) {\n    if (sentence.length() == 0) {\n        return false;\n    }\n    \n    return sentence[0] == 'I';\n}\n\nint is_bored(string S) {\n    vector<string> sentences = extractSentences(S);\n    int boredomCount = 0;\n    \n    for (string sentence : sentences) {\n        if (startsWithI(sentence)) {\n            boredomCount++;\n        }\n    }\n    \n    return boredomCount;\n}\n\n"}
{"task_id": "CPP/92", "generation": "#include <iostream>\n#include <cmath>\n\nbool any_int(float a, float b, float c) {\n    if (a == static_cast<int>(a) && b == static_cast<int>(b) && c == static_cast<int>(c)) {\n        if (a == b + c || b == a + c || c == a + b) {\n            return true;\n        }\n    }\n    return false;\n}\n\n"}
{"task_id": "CPP/93", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nstring encode(string message) {\n    for (int i = 0; i < message.length(); i++) {\n        if (isalpha(message[i])) {\n            if (islower(message[i])) {\n                message[i] = toupper(message[i]);\n            } else {\n                message[i] = tolower(message[i]);\n            }\n            if (message[i] == 'A' || message[i] == 'E' || message[i] == 'I' || message[i] == 'O' || message[i] == 'U') {\n                message[i] = char(int(message[i]) + 2);\n            }\n        }\n    }\n    return message;\n}\n\n"}
{"task_id": "CPP/94", "generation": "#include <iostream>\n#include <vector>\n\nbool isPrime(int num) {\n    if (num <= 1) {\n        return false;\n    }\n    for (int i = 2; i * i <= num; i++) {\n        if (num % i == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint sumOfDigits(int num) {\n    int sum = 0;\n    while (num > 0) {\n        sum += num % 10;\n        num /= 10;\n    }\n    return sum;\n}\n\nint findLargestPrimeSum(const vector<int>& lst) {\n    vector<int> primeNumbers;\n    for (int num : lst) {\n        if (isPrime(num)) {\n            primeNumbers.push_back(num);\n        }\n    }\n\n    if (primeNumbers.empty()) {\n        return 0;\n    }\n\n    int largestPrime = primeNumbers[0];\n    for (int i = 1; i < primeNumbers.size(); i++) {\n        if (primeNumbers[i] > largestPrime) {\n            largestPrime = primeNumbers[i];\n        }\n    }\n\n    return sumOfDigits(largestPrime);\n}\n\n"}
{"task_id": "CPP/95", "generation": "#include <iostream>\n#include <string>\n#include <map>\n#include <cctype>\n\nusing namespace std;\n\nbool check_dict_case(map<string, string> dict) {\n    // Check if the given map is empty\n    if (dict.empty()) {\n        return false;\n    }\n\n    // Check if all keys in the map are strings\n    for (auto const& pair : dict) {\n        if (pair.first.find_first_not_of(\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\") != string::npos) {\n            return false;\n        }\n    }\n\n    // Check if all keys in the map are either in lower case or upper case\n    for (auto const& pair : dict) {\n        bool all_lower = true;\n        bool all_upper = true;\n        for (char c : pair.first) {\n            if (!islower(c)) {\n                all_lower = false;\n            }\n            if (!isupper(c)) {\n                all_upper = false;\n            }\n        }\n        if (!all_lower && !all_upper) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\n"}
{"task_id": "CPP/96", "generation": "#include <vector>\n#include <cmath>\n\nbool is_prime(int num) {\n    if (num <= 1) {\n        return false;\n    }\n    for (int i = 2; i <= sqrt(num); i++) {\n        if (num % i == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nvector<int> count_up_to(int n) {\n    vector<int> result;\n    if (n < 2) {\n        return result;\n    }\n    for (int i = 2; i < n; i++) {\n        if (is_prime(i)) {\n            result.push_back(i);\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/97", "generation": "#include <iostream>\n\nint multiply(int a, int b) {\n    int unitDigitA = abs(a) % 10;\n    int unitDigitB = abs(b) % 10;\n    return unitDigitA * unitDigitB;\n}\n\n"}
{"task_id": "CPP/98", "generation": "#include <iostream>\n#include <string>\n#include <cctype>\n\nint count_upper(string s) {\n    int count = 0;\n    \n    for (int i = 0; i < s.length(); i += 2) {\n        char c = s[i];\n        if (isupper(c) && (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U')) {\n            count++;\n        }\n    }\n    \n    return count;\n}\n\n"}
{"task_id": "CPP/99", "generation": "#include <iostream>\n#include <cmath>\n#include <string>\n\nusing namespace std;\n\nint closest_integer(string value) {\n    double num = stod(value); // Parse the input string value into a floating-point number\n\n    int floor_num = floor(num); // Calculate the floor value of the parsed number\n    int ceil_num = ceil(num); // Calculate the ceiling value of the parsed number\n\n    double diff_floor = abs(num - floor_num); // Calculate the absolute difference between the parsed number and its floor value\n    double diff_ceil = abs(num - ceil_num); // Calculate the absolute difference between the parsed number and its ceiling value\n\n    if (diff_floor <= diff_ceil) { // Check if the floor value is closer\n        return floor_num; // Return the floor value as the closest integer\n    } else {\n        return ceil_num; // Return the ceiling value as the closest integer\n    }\n}\n\n"}
{"task_id": "CPP/100", "generation": "#include <vector>\n\nstd::vector<int> make_a_pile(int n) {\n    std::vector<int> stones;\n    stones.push_back(n); // First level has n stones\n\n    for (int i = 1; i < n; i++) {\n        if (n % 2 == 0) {\n            n += 1; // Next even number\n        } else {\n            n += 2; // Next odd number\n        }\n        stones.push_back(n);\n    }\n\n    return stones;\n}\n"}
{"task_id": "CPP/101", "generation": "#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> words_string(string s) {\n    vector<string> words;\n    string word = \"\";\n\n    for (char c : s) {\n        if (c == ' ' || c == ',') {\n            if (!word.empty()) {\n                words.push_back(word);\n                word = \"\";\n            }\n        } else {\n            word += c;\n        }\n    }\n\n    if (!word.empty()) {\n        words.push_back(word);\n    }\n\n    return words;\n}\n"}
{"task_id": "CPP/102", "generation": "#include <iostream>\n\nint choose_num(int x, int y) {\n    if (x <= 0 || y <= 0) {\n        return -1;\n    }\n\n    int biggest_even = -1;\n    for (int i = x; i <= y; i++) {\n        if (i % 2 == 0 && i > biggest_even) {\n            biggest_even = i;\n        }\n    }\n\n    return biggest_even;\n}\n\n"}
{"task_id": "CPP/103", "generation": "#include <iostream>\n#include <string>\n#include <cmath>\n\nstring rounded_avg(int n, int m) {\n    if (n > m) {\n        return \"-1\";\n    }\n\n    int sum = 0;\n    int count = 0;\n    for (int i = n; i <= m; i++) {\n        sum += i;\n        count++;\n    }\n\n    int average = sum / count;\n    int rounded_average = floor(average);\n\n    string binary = \"\";\n    while (rounded_average > 0) {\n        binary = to_string(rounded_average % 2) + binary;\n        rounded_average /= 2;\n    }\n\n    return binary;\n}\n\n"}
{"task_id": "CPP/104", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nbool hasEvenDigit(int num) {\n    while (num > 0) {\n        if ((num % 10) % 2 == 0) {\n            return true;\n        }\n        num /= 10;\n    }\n    return false;\n}\n\nvector<int> unique_digits(vector<int> x) {\n    vector<int> result;\n    \n    for (int num : x) {\n        if (!hasEvenDigit(num)) {\n            result.push_back(num);\n        }\n    }\n    \n    sort(result.begin(), result.end());\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/105", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\n\nusing namespace std;\n\nvector<string> by_length(vector<int> arr) {\n    vector<string> result;\n    vector<int> filtered;\n    map<int, string> intToString = {\n        {1, \"One\"},\n        {2, \"Two\"},\n        {3, \"Three\"},\n        {4, \"Four\"},\n        {5, \"Five\"},\n        {6, \"Six\"},\n        {7, \"Seven\"},\n        {8, \"Eight\"},\n        {9, \"Nine\"}\n    };\n\n    // Filter out integers between 1 and 9\n    for (int num : arr) {\n        if (num >= 1 && num <= 9) {\n            filtered.push_back(num);\n        }\n    }\n\n    // Sort the filtered integers\n    sort(filtered.begin(), filtered.end());\n\n    // Reverse the sorted vector\n    reverse(filtered.begin(), filtered.end());\n\n    // Replace each digit with its corresponding name\n    for (int num : filtered) {\n        result.push_back(intToString[num]);\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/106", "generation": "#include <vector>\n\nusing namespace std;\n\nvector<int> f(int n) {\n    vector<int> result(n);\n\n    for (int i = 1; i <= n; i++) {\n        if (i % 2 == 0) {\n            int factorial = 1;\n            for (int j = 1; j <= i; j++) {\n                factorial *= j;\n            }\n            result[i - 1] = factorial;\n        } else {\n            int sum = 0;\n            for (int j = 1; j <= i; j++) {\n                sum += j;\n            }\n            result[i - 1] = sum;\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/107", "generation": "#include <vector>\n#include <string>\n#include <iostream>\n\nbool isPalindrome(int num) {\n    string str = to_string(num);\n    int left = 0;\n    int right = str.length() - 1;\n    \n    while (left < right) {\n        if (str[left] != str[right]) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n    \n    return true;\n}\n\nvector<int> even_odd_palindrome(int n) {\n    vector<int> result(2, 0); // Initialize vector with 2 zeros for even and odd counts\n    for (int i = 1; i <= n; i++) {\n        if (isPalindrome(i)) {\n            if (i % 2 == 0) {\n                result[0]++; // Increment even count\n            } else {\n                result[1]++; // Increment odd count\n            }\n        }\n    }\n    return result;\n}\n\n"}
{"task_id": "CPP/108", "generation": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nint count_nums(std::vector<int> n) {\n    if (n.empty()) {\n        return 0;\n    }\n\n    int count = 0;\n    for (int num : n) {\n        int sum = 0;\n        int temp = abs(num);\n        while (temp != 0) {\n            sum += temp % 10;\n            temp /= 10;\n        }\n        if (sum > 0) {\n            count++;\n        }\n    }\n\n    return count;\n}\n\n"}
{"task_id": "CPP/109", "generation": "#include <vector>\nusing namespace std;\n\nbool move_one_ball(vector<int> arr) {\n    // Check if the given vector is empty\n    if (arr.empty()) {\n        return true;\n    }\n    \n    // Check if the vector is already sorted in non-decreasing order\n    bool sorted = true;\n    for (int i = 1; i < arr.size(); i++) {\n        if (arr[i] < arr[i - 1]) {\n            sorted = false;\n            break;\n        }\n    }\n    if (sorted) {\n        return true;\n    }\n    \n    // Determine if it is possible to obtain a sorted vector by performing right shift operations\n    int n = arr.size();\n    for (int i = 0; i < n; i++) {\n        bool possible = true;\n        for (int j = 0; j < n; j++) {\n            if (arr[(j + i) % n] > arr[(j + i + 1) % n]) {\n                possible = false;\n                break;\n            }\n        }\n        if (possible) {\n            return true;\n        }\n    }\n    \n    return false;\n}\n"}
{"task_id": "CPP/110", "generation": "#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nstring exchange(vector<int> lst1, vector<int> lst2) {\n    // Check if all elements in lst1 are already even\n    bool allEven = all_of(lst1.begin(), lst1.end(), [](int num) { return num % 2 == 0; });\n    if (allEven) {\n        return \"YES\";\n    }\n\n    // Check if there are any odd elements in lst1 that can be exchanged with even elements in lst2\n    for (int i = 0; i < lst1.size(); i++) {\n        if (lst1[i] % 2 != 0) {\n            for (int j = 0; j < lst2.size(); j++) {\n                if (lst2[j] % 2 == 0) {\n                    swap(lst1[i], lst2[j]);\n                    break;\n                }\n            }\n        }\n    }\n\n    // Check if all elements in lst1 are even after the exchange\n    allEven = all_of(lst1.begin(), lst1.end(), [](int num) { return num % 2 == 0; });\n    if (allEven) {\n        return \"YES\";\n    }\n\n    return \"NO\";\n}\n"}
{"task_id": "CPP/111", "generation": "#include <iostream>\n#include <string>\n#include <map>\n#include <sstream>\n\nstd::map<char, int> histogram(const std::string& test) {\n    std::map<char, int> result;\n    std::istringstream iss(test);\n    std::string token;\n\n    while (iss >> token) {\n        for (char c : token) {\n            result[c]++;\n        }\n    }\n\n    int maxCount = 0;\n    for (const auto& pair : result) {\n        maxCount = std::max(maxCount, pair.second);\n    }\n\n    std::map<char, int> maxCountChars;\n    for (const auto& pair : result) {\n        if (pair.second == maxCount) {\n            maxCountChars[pair.first] = pair.second;\n        }\n    }\n\n    return maxCountChars;\n}\n\n"}
{"task_id": "CPP/112", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nvector<string> reverse_delete(string s, string c) {\n    string result = \"\";\n    for (char ch : s) {\n        if (c.find(ch) == string::npos) {\n            result += ch;\n        }\n    }\n\n    string palindromeCheck = (result == string(result.rbegin(), result.rend())) ? \"True\" : \"False\";\n\n    return {result, palindromeCheck};\n}\n\n"}
{"task_id": "CPP/113", "generation": "#include <vector>\n#include <string>\n#include <map>\n#include <iostream>\n\nusing namespace std;\n\nvector<string> odd_count(vector<string> lst) {\n    vector<string> result;\n    \n    for (string str : lst) {\n        int oddCount = 0;\n        for (char c : str) {\n            if (c >= '0' && c <= '9') {\n                int digit = c - '0';\n                if (digit % 2 != 0) {\n                    oddCount++;\n                }\n            }\n        }\n        \n        string output = \"the number of odd elements \" + to_string(oddCount) + \"n the str\" + to_string(result.size() + 1) + \"ng \" + str + \" of the \" + to_string(result.size() + 1) + \"nput.\";\n        result.push_back(output);\n    }\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/114", "generation": "#include <vector>\n#include <climits>\n\nusing namespace std;\n\nlong long minSubArraySum(vector<long long> nums) {\n    long long minSum = LLONG_MAX; // Initialize minimum sum to a large value\n    int n = nums.size();\n\n    for (int i = 0; i < n; i++) {\n        long long sum = 0;\n        for (int j = i; j < n; j++) {\n            sum += nums[j];\n            minSum = min(minSum, sum);\n        }\n    }\n\n    return minSum;\n}\n"}
{"task_id": "CPP/115", "generation": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nint max_fill(vector<vector<int>> grid, int capacity) {\n    int total_times_lowered = 0;\n    \n    for (int i = 0; i < grid.size(); i++) {\n        int total_water = 0;\n        for (int j = 0; j < grid[i].size(); j++) {\n            total_water += grid[i][j];\n        }\n        \n        int buckets_needed = ceil((double)total_water / capacity);\n        total_times_lowered += buckets_needed;\n    }\n    \n    return total_times_lowered;\n}\n\n"}
{"task_id": "CPP/116", "generation": "#include <stdio.h>\n#include <math.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint count_ones(int num) {\n    int count = 0;\n    while (num) {\n        count += num & 1;\n        num >>= 1;\n    }\n    return count;\n}\n\nbool customComparator(int a, int b) {\n    int onesA = count_ones(a);\n    int onesB = count_ones(b);\n    \n    if (onesA == onesB) {\n        return a < b;\n    }\n    \n    return onesA < onesB;\n}\n\nvector<int> sort_array(vector<int> arr) {\n    sort(arr.begin(), arr.end(), customComparator);\n    return arr;\n}\n"}
{"task_id": "CPP/117", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nbool isConsonant(char c) {\n    c = tolower(c);\n    return !(c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' || c == ' ');\n}\n\nvector<string> select_words(string s, int n) {\n    vector<string> words;\n    string word = \"\";\n    vector<string> result;\n\n    for (char c : s) {\n        if (c == ' ') {\n            if (!word.empty()) {\n                words.push_back(word);\n                word = \"\";\n            }\n        } else {\n            word += c;\n        }\n    }\n\n    if (!word.empty()) {\n        words.push_back(word);\n    }\n\n    for (string w : words) {\n        int consonantCount = count_if(w.begin(), w.end(), isConsonant);\n        if (consonantCount == n) {\n            result.push_back(w);\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/118", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nbool isVowel(char c) {\n    return c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' || c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U';\n}\n\nstring get_closest_vowel(string word) {\n    for (int i = word.size() - 2; i > 0; i--) {\n        if (!isVowel(word[i]) && isalpha(word[i])) {\n            int j = i - 1;\n            while (j >= 0 && !isVowel(word[j]) && isalpha(word[j])) {\n                j--;\n            }\n            if (j >= 0 && isVowel(word[j])) {\n                return string(1, word[j]);\n            }\n        }\n    }\n    return \"\";\n}\n\n"}
{"task_id": "CPP/119", "generation": "#include <stack>\n\nstring match_parens(vector<string> lst) {\n    // Step 1: Check if the number of open and close parentheses in each string is equal\n    int openCount1 = 0, closeCount1 = 0, openCount2 = 0, closeCount2 = 0;\n    for (char c : lst[0]) {\n        if (c == '(') openCount1++;\n        else if (c == ')') closeCount1++;\n    }\n    for (char c : lst[1]) {\n        if (c == '(') openCount2++;\n        else if (c == ')') closeCount2++;\n    }\n    if (openCount1 != closeCount1 || openCount2 != closeCount2) {\n        return \"No\";\n    }\n\n    // Step 2: Check if the parentheses in each string are balanced\n    auto isBalanced = [](const string& s) {\n        stack<char> st;\n        for (char c : s) {\n            if (c == '(') {\n                st.push(c);\n            } else if (c == ')') {\n                if (st.empty() || st.top() != '(') {\n                    return false;\n                }\n                st.pop();\n            }\n        }\n        return st.empty();\n    };\n\n    if (!isBalanced(lst[0]) || !isBalanced(lst[1])) {\n        return \"No\";\n    }\n\n    // Step 3: Concatenate the two strings in all possible orders and check if the resulting string is balanced\n    string concat = lst[0] + lst[1];\n    for (int i = 0; i < 2; i++) {\n        for (int j = 0; j < 2; j++) {\n            string temp = lst[i] + lst[1 - i];\n            if (isBalanced(temp)) {\n                return \"Yes\";\n            }\n        }\n    }\n\n    return \"No\";\n}\n"}
{"task_id": "CPP/120", "generation": "#include <vector>\n#include <algorithm>\n\nvector<int> maximum(vector<int> arr, int k) {\n    // Sort the input vector arr in descending order\n    sort(arr.begin(), arr.end(), greater<int>());\n    \n    // Take the first k elements from the sorted vector\n    vector<int> result(arr.begin(), arr.begin() + k);\n    \n    // Sort the k elements in ascending order\n    sort(result.begin(), result.end());\n    \n    return result;\n}\n"}
{"task_id": "CPP/121", "generation": "#include <vector>\n\nint solution(vector<int> lst) {\n    int sum = 0;\n    for (int i = 0; i < lst.size(); i++) {\n        if (i % 2 == 0 && lst[i] % 2 != 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n"}
{"task_id": "CPP/122", "generation": "#include <iostream>\n#include <vector>\n\nint add_elements(vector<int> arr, int k) {\n    int sum = 0;\n    \n    for (int i = 0; i < k && i < arr.size(); i++) {\n        if (arr[i] >= 10 && arr[i] <= 99) {\n            sum += arr[i];\n        }\n    }\n    \n    return sum;\n}\n\n"}
{"task_id": "CPP/123", "generation": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> generate_collatz_sequence(int n) {\n    vector<int> collatz_seq;\n    collatz_seq.push_back(n);\n    while (n != 1) {\n        if (n % 2 == 0) {\n            n = n / 2;\n        } else {\n            n = 3 * n + 1;\n        }\n        collatz_seq.push_back(n);\n    }\n    return collatz_seq;\n}\n\nvector<int> filter_odd_numbers(const vector<int>& collatz_seq) {\n    vector<int> odd_numbers;\n    for (int num : collatz_seq) {\n        if (num % 2 != 0) {\n            odd_numbers.push_back(num);\n        }\n    }\n    return odd_numbers;\n}\n\nvector<int> get_odd_collatz(int n) {\n    vector<int> collatz_seq = generate_collatz_sequence(n);\n    vector<int> odd_numbers = filter_odd_numbers(collatz_seq);\n    sort(odd_numbers.begin(), odd_numbers.end());\n    return odd_numbers;\n}\n"}
{"task_id": "CPP/124", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\n\nbool valid_date(string date) {\n    if (date.empty()) {\n        return false;\n    }\n\n    int month, day, year;\n    char dash;\n    stringstream ss(date);\n    ss >> month >> dash >> day >> dash >> year;\n\n    if (ss.fail() || ss.rdbuf()->in_avail() != 0) {\n        return false;\n    }\n\n    if (month < 1 || month > 12) {\n        return false;\n    }\n\n    if (day < 1 || day > 31) {\n        return false;\n    }\n\n    if ((month == 4 || month == 6 || month == 9 || month == 11) && day > 30) {\n        return false;\n    }\n\n    if (month == 2) {\n        if ((year % 4 == 0 && year % 100 != 0) || year % 400 == 0) {\n            if (day > 29) {\n                return false;\n            }\n        } else {\n            if (day > 28) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n\n"}
{"task_id": "CPP/125", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nvector<string> split_words(string txt) {\n    vector<string> result;\n    \n    size_t foundSpace = txt.find(\" \");\n    size_t foundComma = txt.find(\",\");\n    \n    if (foundSpace != string::npos) {\n        size_t start = 0;\n        size_t end = txt.find(\" \");\n        while (end != string::npos) {\n            result.push_back(txt.substr(start, end - start));\n            start = end + 1;\n            end = txt.find(\" \", start);\n        }\n        result.push_back(txt.substr(start));\n    } else if (foundComma != string::npos) {\n        size_t start = 0;\n        size_t end = txt.find(\",\");\n        while (end != string::npos) {\n            result.push_back(txt.substr(start, end - start));\n            start = end + 1;\n            end = txt.find(\",\", start);\n        }\n        result.push_back(txt.substr(start));\n    } else {\n        int oddCount = 0;\n        for (char c : txt) {\n            if (islower(c) && ((c - 'a') % 2 == 1)) {\n                oddCount++;\n            }\n        }\n        result.push_back(to_string(oddCount));\n    }\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/126", "generation": "#include <vector>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\n\nbool is_sorted(vector<int> lst) {\n    // Step 2: Sort the vector in ascending order\n    vector<int> sorted_lst = lst;\n    sort(sorted_lst.begin(), sorted_lst.end());\n\n    // Step 3: Check if the sorted vector is equal to the original vector\n    if (lst != sorted_lst) {\n        return false;\n    }\n\n    // Step 4: Check if any number appears more than twice in the vector\n    unordered_map<int, int> freq;\n    for (int num : lst) {\n        freq[num]++;\n        if (freq[num] > 2) {\n            return false;\n        }\n    }\n\n    // Step 5: If all conditions are met, return true\n    return true;\n}\n"}
{"task_id": "CPP/127", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n\nusing namespace std;\n\nbool isPrime(int n) {\n    if (n <= 1) {\n        return false;\n    }\n    for (int i = 2; i <= sqrt(n); i++) {\n        if (n % i == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nstring intersection(vector<int> interval1, vector<int> interval2) {\n    int start = max(interval1[0], interval2[0]);\n    int end = min(interval1[1], interval2[1]);\n    \n    if (start > end) {\n        return \"NO\";\n    }\n    \n    int length = end - start;\n    \n    if (isPrime(length)) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n\n"}
{"task_id": "CPP/128", "generation": "#include <vector>\n#include <cmath>\n\nint prod_signs(vector<int> arr) {\n    if (arr.empty()) {\n        return -32768;\n    }\n\n    int sum = 0;\n    int product = 1;\n\n    for (int num : arr) {\n        sum += abs(num);\n        if (num > 0) {\n            product *= 1;\n        } else if (num < 0) {\n            product *= -1;\n        } else {\n            product *= 0;\n        }\n    }\n\n    return sum * product;\n}\n"}
{"task_id": "CPP/129", "generation": "#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nbool isValid(int x, int y, int n) {\n    return x >= 0 && x < n && y >= 0 && y < n;\n}\n\nvoid findMinPath(vector<vector<int>>& grid, vector<int>& path, vector<int>& minPath, int k, int x, int y, int n) {\n    if (path.size() == k) {\n        if (minPath.empty() || path < minPath) {\n            minPath = path;\n        }\n        return;\n    }\n\n    int dx[] = {0, 0, 1, -1};\n    int dy[] = {1, -1, 0, 0};\n\n    for (int i = 0; i < 4; i++) {\n        int newX = x + dx[i];\n        int newY = y + dy[i];\n\n        if (isValid(newX, newY, n)) {\n            path.push_back(grid[newX][newY]);\n            findMinPath(grid, path, minPath, k, newX, newY, n);\n            path.pop_back();\n        }\n    }\n}\n\nvector<int> minPath(vector<vector<int>> grid, int k) {\n    int n = grid.size();\n    vector<int> path, minPath;\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            path.push_back(grid[i][j]);\n            findMinPath(grid, path, minPath, k, i, j, n);\n            path.pop_back();\n        }\n    }\n\n    return minPath;\n}\n"}
{"task_id": "CPP/130", "generation": "#include <vector>\n\nvector<int> tri(int n) {\n    if (n == 0) {\n        return {0};\n    } else if (n == 1) {\n        return {0, 1};\n    } else if (n == 2) {\n        return {0, 1, 1};\n    }\n\n    vector<int> result(n + 1);\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 1;\n\n    for (int i = 3; i <= n; i++) {\n        if (i % 2 == 0) {\n            result[i] = 1 + i / 2;\n        } else {\n            result[i] = result[i - 1] + result[i - 2] + result[i - 3];\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/131", "generation": "#include <iostream>\n#include <string>\n\nint digits(int n) {\n    if (n <= 0) {\n        return 0;\n    }\n\n    int product = 1;\n    std::string numStr = std::to_string(n);\n\n    for (char c : numStr) {\n        int digit = c - '0';\n        if (digit % 2 != 0) {\n            product *= digit;\n        }\n    }\n\n    if (product == 1) {\n        return 0;\n    }\n\n    return product;\n}\n\n"}
{"task_id": "CPP/132", "generation": "#include <iostream>\n#include <string>\n#include <stack>\n\nbool is_nested(std::string str) {\n    // Check if the input string contains only square brackets\n    for (char c : str) {\n        if (c != '[' && c != ']') {\n            return false;\n        }\n    }\n\n    // Generate all possible subsequence combinations of the brackets\n    int n = str.length();\n    for (int i = 0; i < (1 << n); i++) {\n        std::string subsequence = \"\";\n        for (int j = 0; j < n; j++) {\n            if (i & (1 << j)) {\n                subsequence += str[j];\n            }\n        }\n\n        // Check if the subsequence is nested\n        std::stack<char> stack;\n        for (char c : subsequence) {\n            if (c == '[') {\n                stack.push(c);\n            } else if (c == ']') {\n                if (stack.empty() || stack.top() != '[') {\n                    break;\n                }\n                stack.pop();\n            }\n        }\n\n        if (stack.empty()) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\n"}
{"task_id": "CPP/133", "generation": "#include <iostream>\n#include <cmath>\n#include <vector>\n\nusing namespace std;\n\nint sum_squares(vector<float> lst) {\n    int sum = 0;\n    \n    for (float num : lst) {\n        int rounded = ceil(num);\n        sum += rounded * rounded;\n    }\n    \n    return sum;\n}\n\n"}
{"task_id": "CPP/134", "generation": "#include <iostream>\n#include <string>\n\nbool check_if_last_char_is_a_letter(string txt) {\n    if (txt.empty()) {\n        return false;\n    }\n\n    char lastChar = txt.back();\n    if (isalpha(lastChar)) {\n        if (txt.size() == 1) {\n            return true;\n        }\n        char beforeLastChar = txt.at(txt.size() - 2);\n        if (beforeLastChar == ' ') {\n            return true;\n        }\n    }\n\n    return false;\n}\n\n"}
{"task_id": "CPP/135", "generation": "#include <vector>\nusing namespace std;\n\nint can_arrange(vector<int> arr) {\n    int largestIndex = -1;\n    \n    for (int i = 1; i < arr.size(); i++) {\n        if (arr[i] < arr[i - 1]) {\n            largestIndex = i - 1;\n        }\n    }\n    \n    return largestIndex;\n}\n"}
{"task_id": "CPP/136", "generation": "#include <vector>\n#include <climits>\n\nstd::vector<int> largest_smallest_integers(std::vector<int> lst) {\n    int largest_negative = 0;\n    int smallest_positive = 0;\n\n    for (int num : lst) {\n        if (num < 0 && num < largest_negative) {\n            largest_negative = num;\n        } else if (num > 0 && (num < smallest_positive || smallest_positive == 0)) {\n            smallest_positive = num;\n        }\n    }\n\n    return {largest_negative, smallest_positive};\n}\n"}
{"task_id": "CPP/137", "generation": "#include <iostream>\n#include <string>\n#include <boost/any.hpp>\n\nboost::any compare_one(boost::any a, boost::any b) {\n    if (a.type() == typeid(int) && b.type() == typeid(int)) {\n        int num1 = boost::any_cast<int>(a);\n        int num2 = boost::any_cast<int>(b);\n        if (num1 > num2) {\n            return num1;\n        } else if (num1 < num2) {\n            return num2;\n        } else {\n            return \"None\";\n        }\n    } else if (a.type() == typeid(float) && b.type() == typeid(float)) {\n        float num1 = boost::any_cast<float>(a);\n        float num2 = boost::any_cast<float>(b);\n        if (num1 > num2) {\n            return num1;\n        } else if (num1 < num2) {\n            return num2;\n        } else {\n            return \"None\";\n        }\n    } else if (a.type() == typeid(std::string) || b.type() == typeid(std::string)) {\n        std::string str1 = boost::any_cast<std::string>(a);\n        std::string str2 = boost::any_cast<std::string>(b);\n        float num1 = std::stof(str1);\n        float num2 = std::stof(str2);\n        if (num1 > num2) {\n            return num1;\n        } else if (num1 < num2) {\n            return num2;\n        } else {\n            return \"None\";\n        }\n    } else {\n        return \"Invalid input types\";\n    }\n}\n"}
{"task_id": "CPP/138", "generation": "#include <iostream>\n\nbool is_equal_to_sum_even(int n) {\n    // Check if the given number n is even or not\n    if (n % 2 != 0) {\n        return false;\n    }\n    \n    // Check if the given number n is greater than or equal to 8\n    if (n < 8) {\n        return false;\n    }\n    \n    // Check if the given number n can be expressed as the sum of 4 positive even numbers\n    int count = 0;\n    for (int i = 2; i <= n / 2; i++) {\n        if ((n - i) % 2 == 0 && i % 2 == 0) {\n            count++;\n        }\n    }\n    \n    if (count == 4) {\n        return true;\n    } else {\n        return false;\n    }\n}\n\n"}
{"task_id": "CPP/139", "generation": "#include <iostream>\n\nlong long factorial(int n) {\n    if (n == 0) {\n        return 1;\n    }\n    return n * factorial(n - 1);\n}\n\nlong long special_factorial(int n) {\n    long long result = 1;\n    for (int i = n; i > 0; i--) {\n        result *= factorial(i);\n    }\n    return result;\n}\n\n"}
{"task_id": "CPP/140", "generation": "#include <string>\n\nstring fix_spaces(string text) {\n    bool spaceFlag = false;\n    string result = \"\";\n    \n    for (char c : text) {\n        if (c == ' ') {\n            if (!spaceFlag) {\n                result += '_';\n                spaceFlag = true;\n            }\n        } else {\n            result += c;\n            spaceFlag = false;\n        }\n    }\n    \n    for (int i = 0; i < result.size() - 2; i++) {\n        if (result[i] == '_' && result[i + 1] == '_' && result[i + 2] == '_') {\n            result[i] = '-';\n            result.erase(i + 1, 2);\n        }\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/141", "generation": "#include <iostream>\n#include <string>\n#include <cctype>\n\nbool hasMoreThanThreeDigits(const std::string& file_name) {\n    int digitCount = 0;\n    for (char c : file_name) {\n        if (isdigit(c)) {\n            digitCount++;\n            if (digitCount > 3) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nbool hasExactlyOneDot(const std::string& file_name) {\n    int dotCount = 0;\n    for (char c : file_name) {\n        if (c == '.') {\n            dotCount++;\n            if (dotCount > 1) {\n                return false;\n            }\n        }\n    }\n    return dotCount == 1;\n}\n\nbool startsWithLetter(const std::string& file_name) {\n    return !file_name.empty() && isalpha(file_name[0]);\n}\n\nbool isValidExtension(const std::string& file_name) {\n    std::string extension = file_name.substr(file_name.find('.') + 1);\n    return extension == \"txt\" || extension == \"exe\" || extension == \"dll\";\n}\n\nstd::string file_name_check(const std::string& file_name) {\n    if (hasMoreThanThreeDigits(file_name) || !hasExactlyOneDot(file_name) || !startsWithLetter(file_name) || !isValidExtension(file_name)) {\n        return \"No\";\n    }\n    return \"Yes\";\n}\n\n"}
{"task_id": "CPP/142", "generation": "#include <vector>\n\nint sum_squares(vector<int> lst) {\n    int sum = 0;\n    \n    for (int i = 0; i < lst.size(); i++) {\n        if ((i + 1) % 3 == 0) {\n            lst[i] = lst[i] * lst[i];\n        }\n        if ((i + 1) % 4 == 0 && (i + 1) % 3 != 0) {\n            lst[i] = lst[i] * lst[i] * lst[i];\n        }\n        sum += lst[i];\n    }\n    \n    return sum;\n}\n"}
{"task_id": "CPP/143", "generation": "#include <iostream>\n#include <string>\n#include <vector>\n\nbool isPrime(int n) {\n    if (n <= 1) {\n        return false;\n    }\n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nstring words_in_sentence(string sentence) {\n    vector<string> words;\n    string word = \"\";\n    for (char c : sentence) {\n        if (c == ' ') {\n            words.push_back(word);\n            word = \"\";\n        } else {\n            word += c;\n        }\n    }\n    words.push_back(word);\n\n    string result = \"\";\n    for (string w : words) {\n        if (isPrime(w.length())) {\n            result += w + \" \";\n        }\n    }\n    if (!result.empty()) {\n        result.pop_back(); // Remove the extra space at the end\n    }\n    return result;\n}\n\n"}
{"task_id": "CPP/144", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\n\nbool simplify(string x, string n) {\n    int x_num, x_den, n_num, n_den;\n    \n    // Parse x\n    stringstream ss(x);\n    char c;\n    ss >> x_num >> c >> x_den;\n    \n    // Parse n\n    stringstream ss2(n);\n    ss2 >> n_num >> c >> n_den;\n    \n    // Calculate the product\n    int result_num = x_num * n_num;\n    int result_den = x_den * n_den;\n    \n    // Check if the result is a whole number\n    if (result_num % result_den == 0) {\n        return true;\n    } else {\n        return false;\n    }\n}\n\n"}
{"task_id": "CPP/145", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nint sumOfDigits(int num) {\n    int sum = 0;\n    while (num != 0) {\n        sum += num % 10;\n        num /= 10;\n    }\n    return sum;\n}\n\nbool customSort(int a, int b) {\n    int sumA = sumOfDigits(a);\n    int sumB = sumOfDigits(b);\n    \n    if (sumA == sumB) {\n        return a < b;\n    }\n    \n    return sumA < sumB;\n}\n\nvector<int> order_by_points(vector<int> nums) {\n    sort(nums.begin(), nums.end(), customSort);\n    return nums;\n}\n\n"}
{"task_id": "CPP/146", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nint specialFilter(vector<int> nums) {\n    int count = 0;\n    \n    for (int num : nums) {\n        string numStr = to_string(abs(num)); // Convert number to string\n        int firstDigit = numStr[0] - '0'; // Extract first digit\n        int lastDigit = numStr.back() - '0'; // Extract last digit\n        \n        if (firstDigit % 2 != 0 && lastDigit % 2 != 0 && num > 10) {\n            count++;\n        }\n    }\n    \n    return count;\n}\n\n"}
{"task_id": "CPP/147", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvector<int> generateVector(int n) {\n    vector<int> a;\n    for (int i = 1; i <= n; i++) {\n        a.push_back(i * i - i + 1);\n    }\n    return a;\n}\n\nint countTriples(const vector<int>& a) {\n    int count = 0;\n    for (int i = 0; i < a.size(); i++) {\n        for (int j = i + 1; j < a.size(); j++) {\n            for (int k = j + 1; k < a.size(); k++) {\n                if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}\n\nint get_max_triples(int n) {\n    vector<int> a = generateVector(n);\n    return countTriples(a);\n}\n\n"}
{"task_id": "CPP/148", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nvector<string> bf(string planet1, string planet2) {\n    vector<string> planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n    vector<string> result;\n\n    // Validate if planet1 and planet2 are correct planet names\n    if (find(planets.begin(), planets.end(), planet1) == planets.end() || find(planets.begin(), planets.end(), planet2) == planets.end()) {\n        return result; // Return empty vector if planet1 or planet2 are not correct planet names\n    }\n\n    // Determine the orbits of planet1 and planet2\n    int orbit1 = find(planets.begin(), planets.end(), planet1) - planets.begin();\n    int orbit2 = find(planets.begin(), planets.end(), planet2) - planets.begin();\n\n    // Identify all planets whose orbits are located between the orbit of planet1 and the orbit of planet2\n    int start = min(orbit1, orbit2) + 1;\n    int end = max(orbit1, orbit2);\n    for (int i = start; i < end; i++) {\n        result.push_back(planets[i]);\n    }\n\n    // Sort the identified planets by proximity to the sun\n    sort(result.begin(), result.end(), [&](const string &a, const string &b) {\n        return find(planets.begin(), planets.end(), a) < find(planets.begin(), planets.end(), b);\n    });\n\n    return result;\n}\n\n"}
{"task_id": "CPP/149", "generation": "#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nbool compareStrings(const string& a, const string& b) {\n    if (a.length() == b.length()) {\n        return a < b;\n    }\n    return a.length() < b.length();\n}\n\nvector<string> sorted_list_sum(vector<string> lst) {\n    vector<string> result;\n    \n    for (const string& str : lst) {\n        if (str.length() % 2 == 0) {\n            result.push_back(str);\n        }\n    }\n    \n    sort(result.begin(), result.end(), compareStrings);\n    \n    return result;\n}\n"}
{"task_id": "CPP/150", "generation": "#include <iostream>\n\nbool is_prime(int n) {\n    if (n <= 1) {\n        return false;\n    }\n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint x_or_y(int n, int x, int y) {\n    if (is_prime(n)) {\n        return x;\n    } else {\n        return y;\n    }\n}\n\n"}
{"task_id": "CPP/151", "generation": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nlong long double_the_difference(vector<float> lst) {\n    if (lst.empty()) {\n        return 0;\n    }\n\n    long long sum = 0;\n    for (float num : lst) {\n        if (num >= 0 && num == static_cast<int>(num) && static_cast<int>(num) % 2 != 0) {\n            sum += static_cast<long long>(pow(num, 2));\n        }\n    }\n\n    return sum;\n}\n\n"}
{"task_id": "CPP/152", "generation": "#include <vector>\n#include <cmath>\n\nstd::vector<int> compare(std::vector<int> game, std::vector<int> guess) {\n    std::vector<int> result;\n\n    for (size_t i = 0; i < game.size(); i++) {\n        result.push_back(std::abs(game[i] - guess[i]));\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/153", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring Strongest_Extension(string class_name, vector<string> extensions) {\n    string strongest_extension = \"\";\n    int max_strength = INT_MIN;\n\n    for (string extension : extensions) {\n        int cap_count = 0, sm_count = 0;\n        for (char c : extension) {\n            if (isupper(c)) {\n                cap_count++;\n            } else if (islower(c)) {\n                sm_count++;\n            }\n        }\n\n        int strength = cap_count - sm_count;\n        if (strength > max_strength) {\n            max_strength = strength;\n            strongest_extension = extension;\n        }\n    }\n\n    return class_name + \".\" + strongest_extension;\n}\n\n"}
{"task_id": "CPP/154", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n\nbool isRotationSubstring(const std::string& str1, const std::string& str2) {\n    if (str1.length() != str2.length()) {\n        return false;\n    }\n\n    std::string concatStr = str1 + str1;\n    return concatStr.find(str2) != std::string::npos;\n}\n\nbool cycpattern_check(const std::string& a, const std::string& b) {\n    if (b.length() > a.length()) {\n        return false;\n    }\n\n    for (int i = 0; i < b.length(); i++) {\n        if (isRotationSubstring(a, b)) {\n            return true;\n        }\n        std::rotate(b.begin(), b.begin() + 1, b.end());\n    }\n\n    return false;\n}\n"}
{"task_id": "CPP/155", "generation": "#include <iostream>\n#include <string>\n#include <vector>\n\nvector<int> even_odd_count(int num) {\n    vector<int> counts(2, 0); // Initialize vector to store counts of even and odd digits\n    string numStr = to_string(abs(num)); // Convert the absolute value of num to a string\n\n    for (char c : numStr) {\n        int digit = c - '0'; // Convert char to int\n        if (digit % 2 == 0) {\n            counts[0]++; // Increment even count if digit is even\n        } else {\n            counts[1]++; // Increment odd count if digit is odd\n        }\n    }\n\n    return counts;\n}\n\n"}
{"task_id": "CPP/156", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nstring int_to_roman(int num) {\n    vector<pair<int, string>> roman_map = {\n        {1000, \"M\"}, {900, \"CM\"}, {500, \"D\"}, {400, \"CD\"},\n        {100, \"C\"}, {90, \"XC\"}, {50, \"L\"}, {40, \"XL\"},\n        {10, \"X\"}, {9, \"IX\"}, {5, \"V\"}, {4, \"IV\"}, {1, \"I\"}\n    };\n\n    string result = \"\";\n    for (const auto& pair : roman_map) {\n        while (num >= pair.first) {\n            result += pair.second;\n            num -= pair.first;\n        }\n    }\n\n    return result;\n}\n\nstring to_lower(string str) {\n    transform(str.begin(), str.end(), str.begin(), ::tolower);\n    return str;\n}\n\nstring int_to_mini_roman(int number) {\n    string roman_numeral = int_to_roman(number);\n    return to_lower(roman_numeral);\n}\n\n"}
{"task_id": "CPP/157", "generation": "#include <iostream>\n#include <cmath>\n\nbool is_triangle(float a, float b, float c) {\n    return (a + b > c) && (b + c > a) && (a + c > b);\n}\n\nbool is_right_angle_triangle(float a, float b, float c) {\n    if (!is_triangle(a, b, c)) {\n        return false;\n    }\n    float sides[3] = {a, b, c};\n    std::sort(sides, sides + 3);\n    return (std::pow(sides[0], 2) + std::pow(sides[1], 2) == std::pow(sides[2], 2));\n}\n\n"}
{"task_id": "CPP/158", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_set>\n\nusing namespace std;\n\nstring find_max(vector<string> words) {\n    string maxWord = \"\";\n    int maxUniqueChars = 0;\n\n    for (const string& word : words) {\n        unordered_set<char> uniqueChars;\n        for (char c : word) {\n            uniqueChars.insert(c);\n        }\n\n        if (uniqueChars.size() > maxUniqueChars || (uniqueChars.size() == maxUniqueChars && word < maxWord)) {\n            maxWord = word;\n            maxUniqueChars = uniqueChars.size();\n        }\n    }\n\n    return maxWord;\n}\n\n"}
{"task_id": "CPP/159", "generation": "#include <vector>\n\nvector<int> eat(int number, int need, int remaining) {\n    int totalCarrotsEaten = number + need;\n    int carrotsLeft = remaining - totalCarrotsEaten;\n    \n    if (carrotsLeft < 0) {\n        carrotsLeft = 0;\n    }\n    \n    return {totalCarrotsEaten, carrotsLeft};\n}\n"}
{"task_id": "CPP/160", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nint do_algebra(const std::vector<std::string>& operato, const std::vector<int>& operand) {\n    if (operato.size() != operand.size() - 1) {\n        std::cerr << \"Invalid input: Operator vector size should be one less than operand vector size.\" << std::endl;\n        return 0;\n    }\n\n    int result = operand[0];\n    for (size_t i = 0; i < operato.size(); ++i) {\n        if (operato[i] == \"+\") {\n            result += operand[i + 1];\n        } else if (operato[i] == \"-\") {\n            result -= operand[i + 1];\n        } else if (operato[i] == \"*\") {\n            result *= operand[i + 1];\n        } else if (operato[i] == \"//\") {\n            if (operand[i + 1] != 0) {\n                result /= operand[i + 1];\n            } else {\n                std::cerr << \"Division by zero error.\" << std::endl;\n                return 0;\n            }\n        } else if (operato[i] == \"**\") {\n            result = pow(result, operand[i + 1]);\n        } else {\n            std::cerr << \"Invalid operator: \" << operato[i] << std::endl;\n            return 0;\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/161", "generation": "#include <string>\n#include <cctype>\n\nstring solve(string s) {\n    bool hasLetters = false;\n    \n    for (char c : s) {\n        if (isalpha(c)) {\n            hasLetters = true;\n            break;\n        }\n    }\n    \n    if (!hasLetters) {\n        reverse(s.begin(), s.end());\n        return s;\n    }\n    \n    for (char& c : s) {\n        if (isalpha(c)) {\n            if (islower(c)) {\n                c = toupper(c);\n            } else {\n                c = tolower(c);\n            }\n        }\n    }\n    \n    return s;\n}\n"}
{"task_id": "CPP/162", "generation": "#include <iostream>\n#include <string>\n#include <openssl/md5.h>\n\nstd::string string_to_md5(std::string text) {\n    if (text.empty()) {\n        return \"None\";\n    }\n\n    unsigned char digest[MD5_DIGEST_LENGTH];\n    MD5((unsigned char*)text.c_str(), text.length(), digest);\n\n    char mdString[33];\n    for(int i = 0; i < 16; i++) {\n        sprintf(&mdString[i*2], \"%02x\", (unsigned int)digest[i]);\n    }\n\n    return std::string(mdString);\n}\n"}
{"task_id": "CPP/163", "generation": "#include <vector>\n#include <algorithm>\n\nvector<int> generate_integers(int a, int b) {\n    vector<int> evenDigits;\n    \n    for (int i = a; i <= b; i++) {\n        if (i % 2 == 0 && i < 10) {\n            evenDigits.push_back(i);\n        }\n    }\n    \n    sort(evenDigits.begin(), evenDigits.end());\n    \n    return evenDigits;\n}\n"}
