{"task_id": "CPP/41", "generation": "#include <stdio.h>\n\nint car_race_collision(int n) {\n    // Each car from the left will collide with each car from the right\n    return n * n; // Total collisions = n (left cars) * n (right cars)\n}\n\n"}
{"task_id": "CPP/116", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> sort_array(vector<int> arr) {\n    // Sort the array based on the number of 1s in binary representation and then by the value itself\n    sort(arr.begin(), arr.end(), [](int a, int b) {\n        int countA = __builtin_popcount(a); // Count number of 1s in binary representation of a\n        int countB = __builtin_popcount(b); // Count number of 1s in binary representation of b\n        if (countA == countB) {\n            return a < b; // If counts are the same, sort by value\n        }\n        return countA < countB; // Otherwise, sort by number of 1s\n    });\n    return arr;\n}\n"}
{"task_id": "CPP/61", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    int balance = 0; // This will keep track of the balance of brackets\n\n    for (char ch : brackets) {\n        if (ch == '(') {\n            balance++; // Increment for an opening bracket\n        } else if (ch == ')') {\n            balance--; // Decrement for a closing bracket\n        }\n\n        // If balance goes negative, it means there's a closing bracket without a matching opening bracket\n        if (balance < 0) {\n            return false;\n        }\n    }\n\n    // At the end, balance should be zero if all brackets are matched\n    return balance == 0;\n}\n\n"}
{"task_id": "CPP/25", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> factorize(int n) {\n    vector<int> factors;\n    \n    // Check for number of 2s that divide n\n    while (n % 2 == 0) {\n        factors.push_back(2);\n        n /= 2;\n    }\n    \n    // n must be odd at this point, so we can skip even numbers\n    for (int i = 3; i * i <= n; i += 2) {\n        // While i divides n, add i and divide n\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n    \n    // This condition is to check if n is a prime number greater than 2\n    if (n > 2) {\n        factors.push_back(n);\n    }\n    \n    return factors;\n}\n\n"}
{"task_id": "CPP/137", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <boost/any.hpp>\n\nusing namespace std;\n\nfloat convert_to_float(const boost::any& value) {\n    if (value.type() == typeid(string)) {\n        string str_value = boost::any_cast<string>(value);\n        // Replace comma with dot for float conversion\n        replace(str_value.begin(), str_value.end(), ',', '.');\n        return stof(str_value);\n    } else if (value.type() == typeid(int)) {\n        return static_cast<float>(boost::any_cast<int>(value));\n    } else if (value.type() == typeid(float)) {\n        return boost::any_cast<float>(value);\n    }\n    throw invalid_argument(\"Unsupported type\");\n}\n\nboost::any compare_one(boost::any a, boost::any b) {\n    // Check if both values are of the same type and compare them\n    if (a.type() == b.type()) {\n        if (a.type() == typeid(string)) {\n            if (boost::any_cast<string>(a) == boost::any_cast<string>(b)) {\n                return \"None\";\n            }\n        } else if (a.type() == typeid(int)) {\n            if (boost::any_cast<int>(a) == boost::any_cast<int>(b)) {\n                return \"None\";\n            }\n        } else if (a.type() == typeid(float)) {\n            if (boost::any_cast<float>(a) == boost::any_cast<float>(b)) {\n                return \"None\";\n            }\n        }\n    }\n\n    // Convert both values to float for comparison\n    float a_float = convert_to_float(a);\n    float b_float = convert_to_float(b);\n\n    // Return the larger value in its original type\n    if (a_float > b_float) {\n        return a;\n    } else {\n        return b;\n    }\n}\n"}
{"task_id": "CPP/102", "generation": "#include <stdio.h>\n\nint choose_num(int x, int y) {\n    // Check if the range is valid\n    if (x > y) {\n        return -1;\n    }\n    \n    // Find the largest even number in the range\n    int largest_even;\n    if (y % 2 == 0) {\n        largest_even = y; // y is even\n    } else {\n        largest_even = y - 1; // y is odd, so take y - 1\n    }\n    \n    // Check if the largest even number is within the range [x, y]\n    if (largest_even >= x) {\n        return largest_even;\n    } else {\n        return -1; // No even number in the range\n    }\n}\n\n// Example usage\n"}
{"task_id": "CPP/10", "generation": "#include <stdio.h>\n#include <string>\n#include <algorithm> // Include for std::reverse\nusing namespace std;\n\nbool is_palindrome(string str) {\n    // Test if given string is a palindrome \n    string s(str.rbegin(), str.rend());\n    return s == str;\n}\n\nstring make_palindrome(string str) {\n    /*\n    Find the shortest palindrome that begins with a supplied string. \n    Algorithm idea is simple: - Find the longest postfix of supplied string that is a palindrome. \n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome(\"\") \n    \"\" \n    >>> make_palindrome(\"cat\") \n    \"catac\" \n    >>> make_palindrome(\"cata\") \n    \"catac\" \n    */\n    if (str.empty()) {\n        return str; // Return empty string if input is empty\n    }\n\n    // Find the longest palindromic suffix\n    for (size_t i = 0; i < str.size(); i++) {\n        if (is_palindrome(str.substr(i))) {\n            // Create a prefix string and reverse it\n            string prefix = str.substr(0, i);\n            reverse(prefix.begin(), prefix.end());\n            return str + prefix; // Append the reversed prefix\n        }\n    }\n\n    return str + string(str.rbegin(), str.rend()); // In case no palindromic suffix is found\n}\n"}
{"task_id": "CPP/76", "generation": "#include <iostream>\n#include <cmath>\n\nbool is_simple_power(int x, int n) {\n    // Handle edge cases\n    if (n <= 1) {\n        return (n == 1 && x == 1); // 1^k = 1 for any k, but 0^k is undefined\n    }\n    if (x < 1) {\n        return false; // x must be a positive integer\n    }\n\n    // Calculate the logarithm of x with base n\n    double logValue = log(x) / log(n);\n    \n    // Check if logValue is an integer\n    return (logValue == static_cast<int>(logValue));\n}\n\n"}
{"task_id": "CPP/94", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <cmath>\nusing namespace std;\n\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i <= sqrt(n); i++) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\nint sum_of_digits(int n) {\n    int sum = 0;\n    while (n > 0) {\n        sum += n % 10;\n        n /= 10;\n    }\n    return sum;\n}\n\nint skjkasdkd(vector<int> lst) {\n    int largest_prime = -1;\n    for (int num : lst) {\n        if (is_prime(num) && num > largest_prime) {\n            largest_prime = num;\n        }\n    }\n    if (largest_prime == -1) {\n        return 0; // No prime found\n    }\n    return sum_of_digits(largest_prime);\n}\n"}
{"task_id": "CPP/32", "generation": "#include <stdio.h>\n#include <math.h>\n#include <vector>\n#include <stdexcept>\n\nusing namespace std;\n\ndouble poly(vector<double> xs, double x) {\n    double sum = 0;\n    for (int i = 0; i < xs.size(); i++) {\n        sum += xs[i] * pow(x, i);\n    }\n    return sum;\n}\n\ndouble poly_derivative(vector<double> xs, double x) {\n    double sum = 0;\n    for (int i = 1; i < xs.size(); i++) {\n        sum += i * xs[i] * pow(x, i - 1);\n    }\n    return sum;\n}\n\ndouble find_zero(vector<double> xs) {\n    if (xs.size() % 2 != 0) {\n        throw invalid_argument(\"The number of coefficients must be even.\");\n    }\n\n    // Initial guess (can be adjusted based on the polynomial)\n    double x0 = 0.0;\n    double tolerance = 1e-7;\n    int max_iterations = 1000;\n\n    for (int i = 0; i < max_iterations; i++) {\n        double f_x0 = poly(xs, x0);\n        double f_prime_x0 = poly_derivative(xs, x0);\n\n        if (fabs(f_x0) < tolerance) {\n            return x0; // Found a root\n        }\n\n        if (fabs(f_prime_x0) < tolerance) {\n            throw runtime_error(\"Derivative is too small; no convergence.\");\n        }\n\n        // Newton-Raphson update\n        x0 -= f_x0 / f_prime_x0;\n    }\n\n    throw runtime_error(\"Maximum iterations reached; no convergence.\");\n}\n\n"}
{"task_id": "CPP/33", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> sort_third(vector<int> l) {\n    // Create a vector to hold the values at indices divisible by 3\n    vector<int> third_indices_values;\n\n    // Collect values at indices divisible by 3\n    for (size_t i = 0; i < l.size(); ++i) {\n        if (i % 3 == 0) {\n            third_indices_values.push_back(l[i]);\n        }\n    }\n\n    // Sort the collected values\n    sort(third_indices_values.begin(), third_indices_values.end());\n\n    // Replace the original values at indices divisible by 3 with sorted values\n    size_t sorted_index = 0;\n    for (size_t i = 0; i < l.size(); ++i) {\n        if (i % 3 == 0) {\n            l[i] = third_indices_values[sorted_index++];\n        }\n    }\n\n    return l;\n}\n\n"}
{"task_id": "CPP/88", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> sort_array(const vector<int>& array) {\n    // Step 1: Check if the input vector is empty\n    if (array.empty()) {\n        return {};\n    }\n\n    // Step 2: If the vector has only one element, return a copy of that vector\n    if (array.size() == 1) {\n        return array;\n    }\n\n    // Step 3: Calculate the sum of the first and last elements\n    int sum = array.front() + array.back();\n\n    // Step 4: Create a copy of the original array to sort\n    vector<int> sorted_array = array;\n\n    // Step 5: Sort based on the sum's parity\n    if (sum % 2 == 0) {\n        // Even sum: sort in descending order\n        sort(sorted_array.rbegin(), sorted_array.rend());\n    } else {\n        // Odd sum: sort in ascending order\n        sort(sorted_array.begin(), sorted_array.end());\n    }\n\n    // Step 6: Return the sorted vector\n    return sorted_array;\n}\n\n// Example usage\n"}
{"task_id": "CPP/15", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nstring string_sequence(int n) {\n    stringstream ss; // Create a stringstream to build the output string\n    for (int i = 0; i <= n; ++i) {\n        ss << i; // Add the current number to the stringstream\n        if (i < n) {\n            ss << \" \"; // Add a space after the number, except for the last number\n        }\n    }\n    return ss.str(); // Convert the stringstream to a string and return it\n}\n\n"}
{"task_id": "CPP/163", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // for std::sort\n\nusing namespace std;\n\nvector<int> generate_integers(int a, int b) {\n    vector<int> even_digits;\n    \n    // Determine the range\n    int start = min(a, b);\n    int end = max(a, b);\n    \n    // Check for even digits between start and end\n    for (int i = start; i <= end; i++) {\n        if (i >= 0 && i < 10 && i % 2 == 0) {\n            even_digits.push_back(i);\n        }\n    }\n    \n    // Sort the vector (though it should already be in order due to the loop)\n    sort(even_digits.begin(), even_digits.end());\n    \n    return even_digits;\n}\n\n"}
{"task_id": "CPP/1", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cctype> // for isspace\n\nusing namespace std;\n\nvector<string> separate_paren_groups(string paren_string) {\n    vector<string> result;\n    string current_group;\n    int balance = 0;\n\n    for (char ch : paren_string) {\n        if (isspace(ch)) {\n            continue; // Ignore spaces\n        }\n        \n        if (ch == '(') {\n            if (balance == 0 && !current_group.empty()) {\n                // If we are starting a new group, save the previous one\n                result.push_back(current_group);\n                current_group.clear();\n            }\n            current_group += ch; // Add the opening parenthesis\n            balance++; // Increase balance\n        } else if (ch == ')') {\n            current_group += ch; // Add the closing parenthesis\n            balance--; // Decrease balance\n        }\n\n        // If balance is zero, we have a complete group\n        if (balance == 0 && !current_group.empty()) {\n            result.push_back(current_group);\n            current_group.clear(); // Clear for the next group\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/69", "generation": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint search(vector<int> lst) {\n    unordered_map<int, int> frequencyMap;\n\n    // Count the frequency of each integer in the vector\n    for (int num : lst) {\n        frequencyMap[num]++;\n    }\n\n    int result = -1;\n\n    // Check for the greatest integer that meets the condition\n    for (const auto& pair : frequencyMap) {\n        int num = pair.first;\n        int freq = pair.second;\n\n        // Check if the frequency is greater than or equal to the integer itself\n        if (freq >= num) {\n            result = max(result, num);\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/31", "generation": "#include <iostream>\n#include <cmath>\nusing namespace std;\n\nbool is_prime(long long n) {\n    // Check if n is less than or equal to 1\n    if (n <= 1) {\n        return false;\n    }\n    // Check for factors from 2 to the square root of n\n    for (long long i = 2; i <= sqrt(n); i++) {\n        if (n % i == 0) {\n            return false; // n is divisible by i, hence not prime\n        }\n    }\n    return true; // n is prime\n}\n\n"}
{"task_id": "CPP/147", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint get_max_triples(int n) {\n    vector<int> a(n);\n    vector<int> count(3, 0); // count[0] for mod 0, count[1] for mod 1, count[2] for mod 2\n\n    // Fill the vector a and count the mod 3 values\n    for (int i = 1; i <= n; ++i) {\n        a[i - 1] = i * i - i + 1;\n        count[a[i - 1] % 3]++;\n    }\n\n    // Now count the valid triples\n    int result = 0;\n\n    // Case 1: All three are 0 mod 3\n    if (count[0] >= 3) {\n        result += (count[0] * (count[0] - 1) * (count[0] - 2)) / 6; // nC3\n    }\n\n    // Case 2: All three are 1 mod 3\n    if (count[1] >= 3) {\n        result += (count[1] * (count[1] - 1) * (count[1] - 2)) / 6; // nC3\n    }\n\n    // Case 3: All three are 2 mod 3\n    if (count[2] >= 3) {\n        result += (count[2] * (count[2] - 1) * (count[2] - 2)) / 6; // nC3\n    }\n\n    // Case 4: One from each category (0, 1, 2)\n    result += count[0] * count[1] * count[2];\n\n    return result;\n}\n\n"}
{"task_id": "CPP/105", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nvector<string> by_length(vector<int> arr) {\n    // Step 1: Filter the input vector to keep only integers between 1 and 9\n    vector<int> filtered;\n    for (int num : arr) {\n        if (num >= 1 && num <= 9) {\n            filtered.push_back(num);\n        }\n    }\n\n    // Step 2: Sort the filtered integers\n    sort(filtered.begin(), filtered.end());\n\n    // Step 3: Reverse the sorted integers\n    reverse(filtered.begin(), filtered.end());\n\n    // Step 4: Map each integer to its corresponding string name\n    vector<string> result;\n    vector<string> names = {\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"};\n    \n    for (int num : filtered) {\n        result.push_back(names[num]);\n    }\n\n    // Step 5: Return the resulting vector of strings\n    return result;\n}\n\n"}
{"task_id": "CPP/22", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <boost/any.hpp>\n#include <list>\n\ntypedef std::list<boost::any> list_any;\n\nstd::vector<int> filter_integers(list_any values) {\n    std::vector<int> integers;\n\n    for (const auto& value : values) {\n        try {\n            // Attempt to cast the boost::any to an int\n            integers.push_back(boost::any_cast<int>(value));\n        } catch (const boost::bad_any_cast&) {\n            // If the cast fails, we simply ignore this value\n        }\n    }\n\n    return integers;\n}\n\n"}
{"task_id": "CPP/52", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool below_threshold(vector<int> l, int t) {\n    for (int num : l) {\n        if (num >= t) {\n            return false; // Found a number that is not below the threshold\n        }\n    }\n    return true; // All numbers are below the threshold\n}\n\n"}
{"task_id": "CPP/154", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nbool cycpattern_check(string a, string b) {\n    // Check if the length of b is greater than a\n    if (b.length() > a.length()) {\n        return false;\n    }\n    \n    // Create a new string that is a concatenation of b with itself\n    string b_rotations = b + b;\n    \n    // Check if b is a substring of b_rotations\n    return b_rotations.find(a) != string::npos && b_rotations.find(b) < a.length();\n}\n"}
{"task_id": "CPP/115", "generation": "#include <iostream>\n#include <vector>\n#include <cmath> // for ceil function\n\nusing namespace std;\n\nint max_fill(vector<vector<int>> grid, int capacity) {\n    int total_lowerings = 0;\n\n    for (const auto& well : grid) {\n        int water_units = 0;\n\n        // Count the number of 1s in the current well (row)\n        for (int water : well) {\n            water_units += water;\n        }\n\n        // Calculate how many times we need to lower the bucket for this well\n        if (water_units > 0) {\n            total_lowerings += ceil(static_cast<double>(water_units) / capacity);\n        }\n    }\n\n    return total_lowerings;\n}\n\n"}
{"task_id": "CPP/131", "generation": "#include <stdio.h>\n\nint digits(int n) {\n    int product = 1;\n    bool foundOdd = false;\n\n    while (n > 0) {\n        int digit = n % 10; // Get the last digit\n        n /= 10;            // Remove the last digit\n\n        if (digit % 2 != 0) { // Check if the digit is odd\n            product *= digit; // Multiply the product by the odd digit\n            foundOdd = true;  // Mark that we found at least one odd digit\n        }\n    }\n\n    return foundOdd ? product : 0; // Return product if odd digits found, otherwise return 0\n}\n\n"}
{"task_id": "CPP/37", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<float> sort_even(vector<float> l) {\n    // Create a vector to hold the even indexed values\n    vector<float> even_values;\n\n    // Extract even indexed values\n    for (size_t i = 0; i < l.size(); i += 2) {\n        even_values.push_back(l[i]);\n    }\n\n    // Sort the even indexed values\n    sort(even_values.begin(), even_values.end());\n\n    // Create a new vector to hold the result\n    vector<float> result(l.size());\n\n    // Fill the result vector\n    for (size_t i = 0; i < l.size(); ++i) {\n        if (i % 2 == 0) {\n            // Even index: take from sorted even_values\n            result[i] = even_values[i / 2];\n        } else {\n            // Odd index: keep original value\n            result[i] = l[i];\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/92", "generation": "#include <iostream>\n#include <cmath>\n\nbool any_int(float a, float b, float c) {\n    // Check if all numbers are integers\n    if (std::floor(a) != a || std::floor(b) != b || std::floor(c) != c) {\n        return false;\n    }\n\n    // Convert to integers\n    int int_a = static_cast<int>(a);\n    int int_b = static_cast<int>(b);\n    int int_c = static_cast<int>(c);\n\n    // Check if one number is equal to the sum of the other two\n    return (int_a == int_b + int_c) || (int_b == int_a + int_c) || (int_c == int_a + int_b);\n}\n\n"}
{"task_id": "CPP/118", "generation": "#include <stdio.h>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nstring get_closest_vowel(string word) {\n    string vowels = \"aeiouAEIOU\";\n    int n = word.length();\n    \n    // Start from the end of the word and look for the closest vowel\n    for (int i = n - 2; i > 0; --i) {\n        if (vowels.find(word[i]) != string::npos && \n            isalpha(word[i - 1]) && isalpha(word[i + 1]) && \n            vowels.find(word[i - 1]) == string::npos && \n            vowels.find(word[i + 1]) == string::npos) {\n            return string(1, word[i]);\n        }\n    }\n    \n    return \"\";\n}\n"}
{"task_id": "CPP/6", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nvector<int> parse_nested_parens(string paren_string) {\n    vector<int> depths; // To store the maximum depth for each group\n    stringstream ss(paren_string); // Use stringstream to split the input by spaces\n    string group;\n\n    while (ss >> group) { // Read each group separated by spaces\n        int current_depth = 0; // Current depth of nesting\n        int max_depth = 0; // Maximum depth found in this group\n\n        for (char ch : group) { // Iterate through each character in the group\n            if (ch == '(') {\n                current_depth++; // Increase depth for '('\n                if (current_depth > max_depth) {\n                    max_depth = current_depth; // Update max depth if current is greater\n                }\n            } else if (ch == ')') {\n                current_depth--; // Decrease depth for ')'\n            }\n        }\n\n        depths.push_back(max_depth); // Add the maximum depth of this group to the result\n    }\n\n    return depths; // Return the vector containing maximum depths for each group\n}\n\n"}
{"task_id": "CPP/87", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<vector<int>> get_row(vector<vector<int>> lst, int x) {\n    vector<vector<int>> result;\n\n    // Iterate through each row\n    for (int i = 0; i < lst.size(); ++i) {\n        // Iterate through each column in the current row\n        for (int j = 0; j < lst[i].size(); ++j) {\n            // Check if the current element matches x\n            if (lst[i][j] == x) {\n                // Store the coordinates {row, column}\n                result.push_back({i, j});\n            }\n        }\n    }\n\n    // Sort the result by row (ascending) and then by column (descending)\n    sort(result.begin(), result.end(), [](const vector<int>& a, const vector<int>& b) {\n        if (a[0] == b[0]) {\n            return a[1] > b[1]; // Sort by column in descending order if rows are equal\n        }\n        return a[0] < b[0]; // Sort by row in ascending order\n    });\n\n    return result;\n}\n\n// Example usage\n"}
{"task_id": "CPP/2", "generation": "#include <stdio.h>\n#include <math.h>\n\nfloat truncate_number(float number) {\n    // Get the integer part using floor\n    float integer_part = floor(number);\n    // Calculate the decimal part\n    float decimal_part = number - integer_part;\n    return decimal_part;\n}\n\n"}
{"task_id": "CPP/16", "generation": "#include <iostream>\n#include <unordered_set>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nint count_distinct_characters(string str) {\n    unordered_set<char> distinct_chars; // Use a set to store distinct characters\n\n    // Convert each character to lowercase and insert into the set\n    for (char c : str) {\n        distinct_chars.insert(tolower(c)); // Convert to lowercase\n    }\n\n    // The size of the set is the number of distinct characters\n    return distinct_chars.size();\n}\n\n"}
{"task_id": "CPP/135", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint can_arrange(vector<int> arr) {\n    int n = arr.size();\n    int resultIndex = -1; // Initialize result index to -1\n\n    // Iterate through the array starting from the second element\n    for (int i = 1; i < n; i++) {\n        // Check if the current element is less than the previous element\n        if (arr[i] < arr[i - 1]) {\n            resultIndex = i; // Update result index\n        }\n    }\n\n    return resultIndex; // Return the largest index found or -1 if none found\n}\n\n"}
{"task_id": "CPP/106", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> f(int n) {\n    vector<int> result(n);\n    \n    for (int i = 1; i <= n; ++i) {\n        if (i % 2 == 0) { // i is even\n            // Calculate factorial of i\n            int factorial = 1;\n            for (int j = 1; j <= i; ++j) {\n                factorial *= j;\n            }\n            result[i - 1] = factorial; // Store in the vector\n        } else { // i is odd\n            // Calculate sum from 1 to i\n            int sum = (i * (i + 1)) / 2; // Using the formula for sum of first i natural numbers\n            result[i - 1] = sum; // Store in the vector\n        }\n    }\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/162", "generation": "#include <stdio.h>\n#include <string>\n#include <openssl/md5.h>\nusing namespace std;\n\nstring string_to_md5(string text) {\n    if (text.empty()) {\n        return \"\"; // Return an empty string to represent None\n    }\n\n    unsigned char digest[MD5_DIGEST_LENGTH];\n    MD5((unsigned char*)text.c_str(), text.length(), digest);\n\n    char md5String[33];\n    for (int i = 0; i < 16; i++) {\n        sprintf(&md5String[i * 2], \"%02x\", (unsigned int)digest[i]);\n    }\n\n    return string(md5String);\n}\n"}
{"task_id": "CPP/5", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> intersperse(vector<int> numbers, int delimiter) {\n    // If the input vector is empty, return an empty vector\n    if (numbers.empty()) {\n        return {};\n    }\n\n    vector<int> result;\n    // Reserve space for the result vector to avoid multiple allocations\n    result.reserve(numbers.size() * 2 - 1);\n\n    // Add the first element to the result\n    result.push_back(numbers[0]);\n\n    // Loop through the input vector and add the delimiter between elements\n    for (size_t i = 1; i < numbers.size(); ++i) {\n        result.push_back(delimiter); // Add the delimiter\n        result.push_back(numbers[i]); // Add the next element\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/97", "generation": "#include <iostream>\nusing namespace std;\n\nint multiply(int a, int b) {\n    // Get the unit digits\n    int unitDigitA = abs(a) % 10; // Use abs to handle negative numbers\n    int unitDigitB = abs(b) % 10; // Use abs to handle negative numbers\n    \n    // Return the product of the unit digits\n    return unitDigitA * unitDigitB;\n}\n\n"}
{"task_id": "CPP/44", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring change_base(int x, int base) {\n    if (base < 2 || base >= 10) {\n        return \"\"; // Base must be between 2 and 9\n    }\n\n    string result = \"\";\n    do {\n        int remainder = x % base;\n        result = to_string(remainder) + result; // Prepend the remainder to the result\n        x /= base; // Reduce x by dividing it by the base\n    } while (x > 0);\n\n    return result.empty() ? \"0\" : result; // Handle the case when x is 0\n}\n\n"}
{"task_id": "CPP/161", "generation": "#include <iostream>\n#include <string>\n#include <algorithm> // for std::reverse\n\nusing namespace std;\n\nstring solve(string s) {\n    bool hasLetter = false;\n\n    // Check if there's at least one letter in the string\n    for (char c : s) {\n        if (isalpha(c)) {\n            hasLetter = true;\n            break;\n        }\n    }\n\n    if (hasLetter) {\n        // Reverse case for letters\n        for (char &c : s) {\n            if (isalpha(c)) {\n                if (islower(c)) {\n                    c = toupper(c);\n                } else {\n                    c = tolower(c);\n                }\n            }\n        }\n    } else {\n        // Reverse the entire string\n        reverse(s.begin(), s.end());\n    }\n\n    return s;\n}\n\n"}
{"task_id": "CPP/38", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nstring encode_cyclic(string s) { \n    // returns encoded string by cycling groups of three characters.  \n    int l = s.length();\n    int num = (l + 2) / 3;\n    string x, output;\n    for (int i = 0; i * 3 < l; i++) {\n        // cycle elements in each group. Unless group has fewer elements than 3.\n        x = s.substr(i * 3, 3);\n        if (x.length() == 3) x = x.substr(1) + x[0];\n        output += x;\n    }\n    return output;\n}\n\nstring decode_cyclic(string s) { \n    /*\n    takes as input string encoded with encode_cyclic function. Returns decoded string. \n    */\n    int l = s.length();\n    string output;\n    for (int i = 0; i * 3 < l; i++) {\n        // Get the group of three characters\n        string x = s.substr(i * 3, 3);\n        if (x.length() == 3) {\n            // Shift the last character to the front\n            x = x[x.length() - 1] + x.substr(0, x.length() - 1);\n        }\n        output += x;\n    }\n    return output;\n}\n\n"}
{"task_id": "CPP/93", "generation": "#include <stdio.h>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nstring encode(string message) {\n    string vowels = \"aeiouAEIOU\";\n    string encoded_message;\n\n    for (char c : message) {  // Changed 'char char' to 'char c'\n        if (isalpha(c)) {  // Check if the character is a letter\n            // Swap case\n            char new_char;\n            if (islower(c)) {\n                new_char = toupper(c);\n            } else {\n                new_char = tolower(c);\n            }\n\n            // Replace vowels\n            if (vowels.find(new_char) != string::npos) {\n                // Find the new character that is 2 places ahead in the alphabet\n                if (islower(new_char) && new_char <= 'y') {\n                    new_char += 2; // For 'a' to 'y'\n                } else if (islower(new_char)) {\n                    new_char = 'a' + (new_char - 'a' + 2) % 26; // Wrap around for 'z'\n                } else if (isupper(new_char) && new_char <= 'Y') {\n                    new_char += 2; // For 'A' to 'Y'\n                } else {\n                    new_char = 'A' + (new_char - 'A' + 2) % 26; // Wrap around for 'Z'\n                }\n            }\n\n            encoded_message += new_char; // Append the transformed character\n        } else {\n            encoded_message += c; // Keep non-letter characters unchanged\n        }\n    }\n    \n    return encoded_message;\n}\n"}
{"task_id": "CPP/152", "generation": "#include <iostream>\n#include <vector>\n#include <cmath> // for abs function\n\nusing namespace std;\n\nvector<int> compare(vector<int> game, vector<int> guess) {\n    vector<int> result; // Vector to store the results\n    int n = game.size(); // Get the size of the input vectors\n\n    // Loop through each match\n    for (int i = 0; i < n; i++) {\n        // Calculate the absolute difference\n        int difference = abs(game[i] - guess[i]);\n        result.push_back(difference); // Store the result\n    }\n\n    return result; // Return the result vector\n}\n\n// Example usage\n"}
{"task_id": "CPP/62", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<float> derivative(const vector<float>& xs) {\n    vector<float> result;\n    int degree = xs.size(); // Degree of the polynomial is size - 1\n\n    for (int i = 1; i < degree; ++i) {\n        // The derivative of xs[i] * x^i is i * xs[i]\n        result.push_back(i * xs[i]);\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/7", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\n// Function to check if a string contains a given substring\nbool contains_substring(const string& str, const string& substring) {\n    return str.find(substring) != string::npos;\n}\n\n// Function to filter strings by substring\nvector<string> filter_by_substring(const vector<string>& strings, const string& substring) {\n    vector<string> filtered;\n\n    for (const string& str : strings) {\n        if (contains_substring(str, substring)) {\n            filtered.push_back(str);\n        }\n    }\n\n    return filtered;\n}\n\n// Main function for testing\n"}
{"task_id": "CPP/24", "generation": "#include <iostream>\nusing namespace std;\n\nint largest_divisor(int n) {\n    // Start from n-1 and go down to 1\n    for (int i = n - 1; i > 0; i--) {\n        if (n % i == 0) {\n            return i; // Return the first divisor found\n        }\n    }\n    return 1; // In case n is 1, the largest divisor is 1\n}\n\n"}
{"task_id": "CPP/79", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring decimal_to_binary(int decimal) {\n    // Handle the case when the input is 0\n    if (decimal == 0) {\n        return \"db0db\";\n    }\n\n    string binary = \"\";\n    \n    // Convert decimal to binary\n    while (decimal > 0) {\n        // Prepend '0' or '1' based on the least significant bit\n        binary = (decimal % 2 == 0 ? '0' : '1') + binary;\n        decimal /= 2; // Right shift the decimal number\n    }\n    \n    // Add the \"db\" prefix and suffix\n    return \"db\" + binary + \"db\";\n}\n\n"}
{"task_id": "CPP/155", "generation": "#include <iostream>\n#include <vector>\n#include <cmath> // for abs function\n\nusing namespace std;\n\nvector<int> even_odd_count(int num) {\n    // Initialize counts for even and odd digits\n    int even_count = 0;\n    int odd_count = 0;\n\n    // Work with the absolute value of the number\n    num = abs(num);\n\n    // If the number is zero, it's considered an even digit\n    if (num == 0) {\n        even_count = 1;\n    } else {\n        // Iterate through each digit\n        while (num > 0) {\n            int digit = num % 10; // Get the last digit\n            if (digit % 2 == 0) {\n                even_count++; // Increment even count\n            } else {\n                odd_count++; // Increment odd count\n            }\n            num /= 10; // Remove the last digit\n        }\n    }\n\n    // Return the counts as a vector\n    return {even_count, odd_count};\n}\n\n// Example usage\n"}
{"task_id": "CPP/4", "generation": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nfloat mean_absolute_deviation(const vector<float>& numbers) {\n    if (numbers.empty()) {\n        return 0.0; // Return 0 for empty input\n    }\n\n    // Step 1: Calculate the mean\n    float sum = 0.0;\n    for (float num : numbers) {\n        sum += num;\n    }\n    float mean = sum / numbers.size();\n\n    // Step 2: Calculate the absolute differences and their average\n    float mad_sum = 0.0;\n    for (float num : numbers) {\n        mad_sum += fabs(num - mean);\n    }\n    float mad = mad_sum / numbers.size();\n\n    return mad;\n}\n\n"}
{"task_id": "CPP/56", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    int balance = 0; // Counter for the brackets\n\n    for (char ch : brackets) {\n        if (ch == '<') {\n            balance++; // Increment for opening bracket\n        } else if (ch == '>') {\n            balance--; // Decrement for closing bracket\n        }\n\n        // If balance goes negative, there are unmatched closing brackets\n        if (balance < 0) {\n            return false;\n        }\n    }\n\n    // At the end, balance should be zero for all brackets to be matched\n    return balance == 0;\n}\n\n"}
{"task_id": "CPP/159", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> eat(int number, int need, int remaining) {\n    // Calculate how many more carrots the rabbit needs to eat\n    int totalEaten = number;\n    int carrotsToEat = min(need, remaining); // The rabbit can eat either what it needs or what is left\n    \n    // Update total eaten carrots\n    totalEaten += carrotsToEat;\n    \n    // Calculate remaining carrots after eating\n    int carrotsLeft = remaining - carrotsToEat;\n    \n    // Return the result as a vector\n    return {totalEaten, carrotsLeft};\n}\n\n// Example usage\n"}
{"task_id": "CPP/83", "generation": "#include <stdio.h>\n#include <cmath>\n\nusing namespace std;\n\nint starts_one_ends(int n) {\n    if (n == 1) {\n        // For 1-digit numbers, only the number '1' satisfies the condition.\n        return 1;\n    }\n\n    // Count of n-digit numbers starting with '1'\n    long long count_starting_with_1 = pow(10, n - 1);\n\n    // Count of n-digit numbers ending with '1'\n    long long count_ending_with_1 = 9 * pow(10, n - 2);\n\n    // Count of n-digit numbers starting and ending with '1'\n    long long count_both = pow(10, n - 2);\n\n    // Total count using inclusion-exclusion principle\n    long long total_count = count_starting_with_1 + count_ending_with_1 - count_both;\n\n    return total_count;\n}\n\n"}
{"task_id": "CPP/27", "generation": "#include <iostream>\n#include <string>\n#include <cctype> // for islower and isupper\n\nusing namespace std;\n\nstring flip_case(string str) {\n    for (char &c : str) { // Use a reference to modify the original string\n        if (islower(c)) {\n            c = toupper(c); // Convert to uppercase\n        } else if (isupper(c)) {\n            c = tolower(c); // Convert to lowercase\n        }\n    }\n    return str; // Return the modified string\n}\n\n"}
{"task_id": "CPP/146", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nbool isOdd(int digit) {\n    return digit % 2 != 0;\n}\n\nbool hasOddFirstAndLastDigits(int num) {\n    // Convert the number to a string to easily access the first and last digits\n    string numStr = to_string(num);\n    \n    // Get the first and last characters, convert them to integers\n    int firstDigit = numStr[0] - '0'; // Convert char to int\n    int lastDigit = numStr[numStr.size() - 1] - '0'; // Convert char to int\n    \n    // Check if both digits are odd\n    return isOdd(firstDigit) && isOdd(lastDigit);\n}\n\nint specialFilter(vector<int> nums) {\n    int count = 0;\n    \n    for (int num : nums) {\n        if (num > 10 && hasOddFirstAndLastDigits(num)) {\n            count++;\n        }\n    }\n    \n    return count;\n}\n\n"}
{"task_id": "CPP/81", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> numerical_letter_grade(vector<float> grades) {\n    vector<string> letter_grades;\n    for (float gpa : grades) {\n        if (gpa == 4.0) {\n            letter_grades.push_back(\"A+\");\n        } else if (gpa > 3.7) {\n            letter_grades.push_back(\"A\");\n        } else if (gpa > 3.3) {\n            letter_grades.push_back(\"A-\");\n        } else if (gpa > 3.0) {\n            letter_grades.push_back(\"B+\");\n        } else if (gpa > 2.7) {\n            letter_grades.push_back(\"B\");\n        } else if (gpa > 2.3) {\n            letter_grades.push_back(\"B-\");\n        } else if (gpa > 2.0) {\n            letter_grades.push_back(\"C+\");\n        } else if (gpa > 1.7) {\n            letter_grades.push_back(\"C\");\n        } else if (gpa > 1.3) {\n            letter_grades.push_back(\"C-\");\n        } else if (gpa > 1.0) {\n            letter_grades.push_back(\"D+\");\n        } else if (gpa > 0.7) {\n            letter_grades.push_back(\"D\");\n        } else if (gpa > 0.0) {\n            letter_grades.push_back(\"D-\");\n        } else {\n            letter_grades.push_back(\"E\");\n        }\n    }\n    return letter_grades;\n}\n"}
{"task_id": "CPP/136", "generation": "#include <iostream>\n#include <vector>\n#include <limits>\n\nusing namespace std;\n\nvector<int> largest_smallest_integers(vector<int> lst) {\n    int largest_negative = numeric_limits<int>::min(); // Initialize to the smallest possible integer\n    int smallest_positive = numeric_limits<int>::max(); // Initialize to the largest possible integer\n\n    bool found_negative = false;\n    bool found_positive = false;\n\n    for (int num : lst) {\n        if (num < 0) {\n            found_negative = true;\n            if (num > largest_negative) {\n                largest_negative = num; // Update largest negative\n            }\n        } else if (num > 0) {\n            found_positive = true;\n            if (num < smallest_positive) {\n                smallest_positive = num; // Update smallest positive\n            }\n        }\n    }\n\n    // If no negative number was found, set largest_negative to 0\n    if (!found_negative) {\n        largest_negative = 0;\n    }\n\n    // If no positive number was found, set smallest_positive to 0\n    if (!found_positive) {\n        smallest_positive = 0;\n    }\n\n    return {largest_negative, smallest_positive};\n}\n\n"}
{"task_id": "CPP/67", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nint fruit_distribution(string s, int n) {\n    int apples = 0, oranges = 0;\n\n    // Use a stringstream to parse the input string\n    stringstream ss(s);\n    string word;\n\n    // Read the number of apples\n    ss >> apples; // Read the first number (apples)\n    ss >> word;   // Read the word \"apples\"\n    ss >> word;   // Read the word \"and\"\n    ss >> oranges; // Read the second number (oranges)\n    ss >> word;   // Read the word \"oranges\"\n\n    // Calculate the number of mangoes\n    int mangoes = n - apples - oranges;\n    return mangoes;\n}\n\n"}
{"task_id": "CPP/48", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_palindrome(string text) {\n    int left = 0;\n    int right = text.length() - 1;\n\n    while (left < right) {\n        if (text[left] != text[right]) {\n            return false; // Not a palindrome\n        }\n        left++;\n        right--;\n    }\n    return true; // Is a palindrome\n}\n\n"}
{"task_id": "CPP/125", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nvector<string> split_words(string txt) {\n    vector<string> result;\n    \n    // Check for whitespace\n    size_t pos = txt.find_first_of(\" \\t\\n\\r\\f\\v\");\n    if (pos != string::npos) {\n        // Split by whitespace\n        stringstream ss(txt);\n        string word;\n        while (ss >> word) {\n            result.push_back(word);\n        }\n        return result;\n    }\n    \n    // Check for commas\n    pos = txt.find(',');\n    if (pos != string::npos) {\n        // Split by commas\n        stringstream ss(txt);\n        string word;\n        while (getline(ss, word, ',')) {\n            result.push_back(word);\n        }\n        return result;\n    }\n    \n    // If no whitespace or commas, count lowercase letters with odd order\n    int count = 0;\n    for (char c : txt) {\n        if (c >= 'a' && c <= 'z') {\n            int index = c - 'a'; // Get the index in the alphabet\n            if (index % 2 == 1) { // Check if it's odd\n                count++;\n            }\n        }\n    }\n    \n    // Return the count as a string in a vector\n    return {to_string(count)};\n}\n\n"}
{"task_id": "CPP/160", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stdexcept>\n\nusing namespace std;\n\nint do_algebra(vector<string> operato, vector<int> operand) {\n    if (operato.size() != operand.size() - 1) {\n        throw invalid_argument(\"The length of operator vector must be one less than the operand vector.\");\n    }\n\n    // First, we will handle multiplication, division, and exponentiation\n    vector<int> temp_operand = operand;\n    vector<string> temp_operator = operato;\n\n    for (size_t i = 0; i < temp_operator.size(); ) {\n        if (temp_operator[i] == \"*\" || temp_operator[i] == \"//\" || temp_operator[i] == \"**\") {\n            int result = 0;\n            if (temp_operator[i] == \"*\") {\n                result = temp_operand[i] * temp_operand[i + 1];\n            } else if (temp_operator[i] == \"//\") {\n                if (temp_operand[i + 1] == 0) {\n                    throw invalid_argument(\"Division by zero.\");\n                }\n                result = temp_operand[i] / temp_operand[i + 1];\n            } else if (temp_operator[i] == \"**\") {\n                result = pow(temp_operand[i], temp_operand[i + 1]);\n            }\n\n            // Replace the operation with the result\n            temp_operand[i] = result;\n            temp_operand.erase(temp_operand.begin() + i + 1);\n            temp_operator.erase(temp_operator.begin() + i);\n        } else {\n            i++;\n        }\n    }\n\n    // Now handle addition and subtraction\n    int final_result = temp_operand[0];\n    for (size_t i = 0; i < temp_operator.size(); i++) {\n        if (temp_operator[i] == \"+\") {\n            final_result += temp_operand[i + 1];\n        } else if (temp_operator[i] == \"-\") {\n            final_result -= temp_operand[i + 1];\n        }\n    }\n\n    return final_result;\n}\n\n"}
{"task_id": "CPP/151", "generation": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nlong long double_the_difference(vector<float> lst) {\n    long long sum_of_squares = 0;\n\n    for (float num : lst) {\n        // Check if the number is a non-negative integer\n        if (num >= 0 && floor(num) == num) {\n            int int_num = static_cast<int>(num);\n            // Check if the number is odd\n            if (int_num % 2 != 0) {\n                sum_of_squares += int_num * int_num; // Add the square of the odd number\n            }\n        }\n    }\n\n    return sum_of_squares;\n}\n\n"}
{"task_id": "CPP/117", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <cctype>\n\nusing namespace std;\n\nbool is_consonant(char c) {\n    // Check if the character is a consonant\n    c = tolower(c);\n    return isalpha(c) && !strchr(\"aeiou\", c);\n}\n\nint count_consonants(const string& word) {\n    int count = 0;\n    for (char c : word) {\n        if (is_consonant(c)) {\n            count++;\n        }\n    }\n    return count;\n}\n\nvector<string> select_words(string s, int n) {\n    vector<string> result;\n    stringstream ss(s);\n    string word;\n\n    // Split the string into words\n    while (ss >> word) {\n        // Count consonants in the current word\n        int consonant_count = count_consonants(word);\n        // If the count matches n, add the word to the result\n        if (consonant_count == n) {\n            result.push_back(word);\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/78", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint hex_key(string num) {\n    // Define the set of prime hexadecimal digits\n    const string prime_hex_digits = \"2357BD\"; // 2, 3, 5, 7, B (11), D (13)\n    int count = 0;\n\n    // Iterate through each character in the input string\n    for (char c : num) {\n        // Check if the character is in the set of prime hexadecimal digits\n        if (prime_hex_digits.find(c) != string::npos) {\n            count++;\n        }\n    }\n\n    return count;\n}\n\n"}
{"task_id": "CPP/74", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> total_match(vector<string> lst1, vector<string> lst2) {\n    int total_chars_lst1 = 0;\n    int total_chars_lst2 = 0;\n\n    // Calculate total characters in lst1\n    for (const string& str : lst1) {\n        total_chars_lst1 += str.length();\n    }\n\n    // Calculate total characters in lst2\n    for (const string& str : lst2) {\n        total_chars_lst2 += str.length();\n    }\n\n    // Return the vector with fewer total characters or lst1 if they are equal\n    if (total_chars_lst1 < total_chars_lst2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n"}
{"task_id": "CPP/53", "generation": "#include <iostream>\nusing namespace std;\n\n// Function to add two numbers\nint add(int x, int y) {\n    return x + y;\n}\n\n"}
{"task_id": "CPP/98", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint count_upper(string s) {\n    int count = 0;\n    // Define a string of uppercase vowels for easy checking\n    string vowels = \"AEIOU\";\n    \n    // Loop through the string, checking only even indices\n    for (int i = 0; i < s.length(); i += 2) {\n        // Check if the character is an uppercase vowel\n        if (vowels.find(s[i]) != string::npos) {\n            count++;\n        }\n    }\n    \n    return count;\n}\n\n"}
{"task_id": "CPP/140", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring fix_spaces(string text) {\n    string result;\n    int space_count = 0;\n\n    for (char c : text) {\n        if (c == ' ') {\n            space_count++;\n        } else {\n            if (space_count > 2) {\n                result += '-'; // Replace more than 2 spaces with '-'\n            } else if (space_count == 1) {\n                result += '_'; // Replace single space with '_'\n            } else if (space_count == 2) {\n                result += \"__\"; // Replace two spaces with '__' to maintain the count\n            }\n            result += c; // Add the current character to the result\n            space_count = 0; // Reset space count\n        }\n    }\n\n    // Handle trailing spaces\n    if (space_count > 2) {\n        result += '-';\n    } else if (space_count == 1) {\n        result += '_';\n    } else if (space_count == 2) {\n        result += \"__\";\n    }\n\n    // Remove leading and trailing underscores if they exist\n    if (!result.empty() && result[0] == '_') {\n        result.erase(result.begin());\n    }\n    if (!result.empty() && result[result.size() - 1] == '_') {\n        result.erase(result.end() - 1);\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/34", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> unique(vector<int> l) {\n    // Sort the vector\n    sort(l.begin(), l.end());\n    \n    // Use std::unique to remove duplicates\n    auto last = unique(l.begin(), l.end());\n    \n    // Resize the vector to contain only unique elements\n    l.erase(last, l.end());\n    \n    return l;\n}\n\n"}
{"task_id": "CPP/66", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint digitSum(string s) {\n    int sum = 0; // Initialize sum to 0\n    for (char c : s) { // Iterate through each character in the string\n        if (isupper(c)) { // Check if the character is uppercase\n            sum += static_cast<int>(c); // Add the ASCII value of the uppercase character to sum\n        }\n    }\n    return sum; // Return the final sum\n}\n\n"}
{"task_id": "CPP/120", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> maximum(vector<int> arr, int k) {\n    // Step 1: Sort the array in descending order\n    sort(arr.begin(), arr.end(), greater<int>());\n    \n    // Step 2: Select the first k elements\n    vector<int> maxElements(arr.begin(), arr.begin() + k);\n    \n    // Step 3: Sort the selected k elements in ascending order\n    sort(maxElements.begin(), maxElements.end());\n    \n    return maxElements;\n}\n\n"}
{"task_id": "CPP/139", "generation": "#include <iostream>\nusing namespace std;\n\n// Function to calculate factorial of a number\nlong long factorial(int n) {\n    long long result = 1;\n    for (int i = 2; i <= n; i++) {\n        result *= i;\n    }\n    return result;\n}\n\n// Function to calculate the Brazilian factorial\nlong long special_factorial(int n) {\n    long long result = 1;\n    for (int i = n; i > 0; i--) {\n        result *= factorial(i);\n    }\n    return result;\n}\n\n"}
{"task_id": "CPP/12", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring longest(vector<string> strings) {\n    if (strings.empty()) {\n        return \"\"; // Return an empty string to represent None in C++\n    }\n    \n    string longest_string = strings[0];\n    for (const string& s : strings) {\n        if (s.length() > longest_string.length()) {\n            longest_string = s;\n        }\n    }\n    return longest_string;\n}\n"}
{"task_id": "CPP/121", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint solution(vector<int> lst) {\n    int sum = 0; // Initialize sum to 0\n    for (size_t i = 0; i < lst.size(); i++) {\n        // Check if the index is even and the element is odd\n        if (i % 2 == 0 && lst[i] % 2 != 0) {\n            sum += lst[i]; // Add to sum if both conditions are met\n        }\n    }\n    return sum; // Return the final sum\n}\n\n"}
{"task_id": "CPP/35", "generation": "#include <iostream>\n#include <vector>\n#include <limits>\n\nusing namespace std;\n\nfloat max_element(vector<float> l) {\n    // Check if the vector is empty\n    if (l.empty()) {\n        // Handle the case for an empty vector\n        // You might want to throw an exception or return a special value\n        // Here, we return a special value (e.g., -infinity)\n        return -numeric_limits<float>::infinity();\n    }\n\n    // Initialize max with the first element of the vector\n    float max_val = l[0];\n\n    // Iterate through the vector to find the maximum element\n    for (size_t i = 1; i < l.size(); ++i) {\n        if (l[i] > max_val) {\n            max_val = l[i];\n        }\n    }\n\n    return max_val;\n}\n\n"}
{"task_id": "CPP/20", "generation": "#include <vector>\n#include <algorithm>\n#include <utility> // for std::pair\nusing namespace std;\n\nvector<float> find_closest_elements(vector<float> numbers) {\n    sort(numbers.begin(), numbers.end()); // Sort the numbers\n    float min_diff = numeric_limits<float>::infinity(); // Initialize min_diff to infinity\n    pair<float, float> result = {0, 0}; // Initialize result pair\n\n    for (size_t i = 0; i < numbers.size() - 1; ++i) {\n        float diff = numbers[i + 1] - numbers[i]; // Calculate the difference\n        if (diff < min_diff) { // Check if it's the smallest difference\n            min_diff = diff; // Update min_diff\n            result = {numbers[i], numbers[i + 1]}; // Update result pair\n        }\n    }\n\n    return {result.first, result.second}; // Return the closest pair\n}\n"}
{"task_id": "CPP/19", "generation": "#include <iostream>\n#include <string>\n#include <map>\n#include <vector>\n#include <sstream>\n#include <algorithm>\n\nusing namespace std;\n\nstring sort_numbers(string numbers) {\n    // Mapping from string to integer\n    map<string, int> num_map = {\n        {\"zero\", 0},\n        {\"one\", 1},\n        {\"two\", 2},\n        {\"three\", 3},\n        {\"four\", 4},\n        {\"five\", 5},\n        {\"six\", 6},\n        {\"seven\", 7},\n        {\"eight\", 8},\n        {\"nine\", 9}\n    };\n\n    // Vector to hold the integer values\n    vector<int> num_values;\n    stringstream ss(numbers);\n    string word;\n\n    // Split the input string into words and convert to integers\n    while (ss >> word) {\n        num_values.push_back(num_map[word]);\n    }\n\n    // Sort the integer values\n    sort(num_values.begin(), num_values.end());\n\n    // Convert sorted integers back to strings\n    vector<string> sorted_words;\n    for (int num : num_values) {\n        for (const auto& pair : num_map) {\n            if (pair.second == num) {\n                sorted_words.push_back(pair.first);\n                break;\n            }\n        }\n    }\n\n    // Join the sorted words into a single string\n    string result;\n    for (size_t i = 0; i < sorted_words.size(); ++i) {\n        result += sorted_words[i];\n        if (i < sorted_words.size() - 1) {\n            result += \" \"; // Add space between words\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/85", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint add(const vector<int>& lst) {\n    int sum = 0;\n    \n    // Iterate through the vector\n    for (size_t i = 1; i < lst.size(); i += 2) { // Start from index 1 and increment by 2\n        if (lst[i] % 2 == 0) { // Check if the element is even\n            sum += lst[i]; // Add to sum if it's even\n        }\n    }\n    \n    return sum; // Return the final sum\n}\n\n"}
{"task_id": "CPP/21", "generation": "#include <iostream>\n#include <vector>\n#include <limits>\n\nusing namespace std;\n\nvector<float> rescale_to_unit(vector<float> numbers) {\n    if (numbers.size() < 2) {\n        throw invalid_argument(\"The vector must contain at least two elements.\");\n    }\n\n    // Find the minimum and maximum values in the vector\n    float min_val = numeric_limits<float>::max();\n    float max_val = numeric_limits<float>::lowest();\n\n    for (float num : numbers) {\n        if (num < min_val) {\n            min_val = num;\n        }\n        if (num > max_val) {\n            max_val = num;\n        }\n    }\n\n    // Create a new vector to hold the rescaled values\n    vector<float> rescaled(numbers.size());\n\n    // Rescale each number\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        rescaled[i] = (numbers[i] - min_val) / (max_val - min_val);\n    }\n\n    return rescaled;\n}\n\n"}
{"task_id": "CPP/119", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring match_parens(vector<string> lst) {\n    string s1 = lst[0];\n    string s2 = lst[1];\n\n    // Function to check if a concatenated string is balanced\n    auto is_balanced = [](const string& str) {\n        int balance = 0;\n        for (char ch : str) {\n            if (ch == '(') {\n                balance++;\n            } else {\n                balance--;\n            }\n            // If at any point balance is negative, it's unbalanced\n            if (balance < 0) {\n                return false;\n            }\n        }\n        return balance == 0; // Must end with balance 0\n    };\n\n    // Check both concatenation orders\n    string concat1 = s1 + s2;\n    string concat2 = s2 + s1;\n\n    if (is_balanced(concat1) || is_balanced(concat2)) {\n        return \"Yes\";\n    }\n    return \"No\";\n}\n\n// Example usage\n"}
{"task_id": "CPP/30", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<float> get_positive(vector<float> l) {\n    vector<float> positive_numbers; // Vector to store positive numbers\n    for (float num : l) { // Iterate through each number in the input vector\n        if (num > 0) { // Check if the number is positive\n            positive_numbers.push_back(num); // Add positive number to the new vector\n        }\n    }\n    return positive_numbers; // Return the vector containing only positive numbers\n}\n\n"}
{"task_id": "CPP/64", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint vowels_count(string s) {\n    int count = 0;\n    int length = s.length();\n\n    for (int i = 0; i < length; i++) {\n        char c = tolower(s[i]); // Convert to lowercase for case-insensitive comparison\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n            count++;\n        }\n        // Check if 'y' is at the end of the string\n        if (c == 'y' && i == length - 1) {\n            count++;\n        }\n    }\n\n    return count;\n}\n\n"}
{"task_id": "CPP/128", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint prod_signs(vector<int> arr) {\n    // Check for empty vector\n    if (arr.empty()) {\n        return -32768;\n    }\n\n    int sum_magnitudes = 0;\n    int product_signs = 1; // Start with 1 for multiplication\n\n    for (int num : arr) {\n        if (num > 0) {\n            sum_magnitudes += num; // Add positive number\n        } else if (num < 0) {\n            sum_magnitudes += -num; // Add magnitude of negative number\n            product_signs *= -1; // Flip the sign\n        } else {\n            // If we encounter a zero, the product of signs becomes zero\n            product_signs = 0;\n            break; // No need to continue\n        }\n    }\n\n    // Return the final result\n    return sum_magnitudes * product_signs;\n}\n\n// Example usage\n"}
{"task_id": "CPP/127", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <cmath>\nusing namespace std;\n\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i <= sqrt(n); i++) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\nstring intersection(vector<int> interval1, vector<int> interval2) {\n    int start1 = interval1[0], end1 = interval1[1];\n    int start2 = interval2[0], end2 = interval2[1];\n\n    // Find the intersection\n    int start_intersection = max(start1, start2);\n    int end_intersection = min(end1, end2);\n\n    // Calculate the length of the intersection\n    int length = end_intersection - start_intersection;\n\n    // Check if the length is a prime number\n    if (length > 0 && is_prime(length)) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n"}
{"task_id": "CPP/122", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint add_elements(vector<int> arr, int k) {\n    int sum = 0; // Initialize sum to 0\n    // Iterate through the first k elements\n    for (int i = 0; i < k; i++) {\n        // Check if the element has at most two digits\n        if (arr[i] >= -99 && arr[i] <= 99) {\n            sum += arr[i]; // Add to sum if condition is met\n        }\n    }\n    return sum; // Return the final sum\n}\n\n"}
{"task_id": "CPP/59", "generation": "#include <iostream>\n#include <cmath>\nusing namespace std;\n\nint largest_prime_factor(int n) {\n    int largest_factor = 1;\n\n    // Check for number of 2s that divide n\n    while (n % 2 == 0) {\n        largest_factor = 2;\n        n /= 2;\n    }\n\n    // n must be odd at this point, so we can skip even numbers\n    for (int i = 3; i <= sqrt(n); i += 2) {\n        while (n % i == 0) {\n            largest_factor = i; // Update largest factor\n            n /= i;\n        }\n    }\n\n    // This condition is to check if n is a prime number greater than 2\n    if (n > 2) {\n        largest_factor = n;\n    }\n\n    return largest_factor;\n}\n\n"}
{"task_id": "CPP/134", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nbool check_if_last_char_is_a_letter(string txt) {\n    // Strip any trailing spaces from the string\n    size_t end = txt.find_last_not_of(' ');\n    if (end == string::npos) {\n        return false; // The string is empty after stripping\n    }\n    txt = txt.substr(0, end + 1); // Update txt to remove trailing spaces\n\n    // Check if the last character is an alphabetical character\n    if (isalpha(txt.back())) {\n        // Check if the last character is not part of a word\n        return txt.length() == 1 || txt[txt.length() - 2] == ' ';\n    }\n    return false;\n}\n"}
{"task_id": "CPP/42", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Function to increment each element of the vector by 1\nvector<int> incr_list(vector<int> l) {\n    for (size_t i = 0; i < l.size(); ++i) {\n        l[i] += 1; // Increment each element by 1\n    }\n    return l; // Return the modified vector\n}\n\n// Main function to test the incr_list function\n"}
{"task_id": "CPP/11", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring string_xor(string a, string b) {\n    // Ensure both strings are of the same length\n    if (a.length() != b.length()) {\n        throw invalid_argument(\"Strings must be of the same length\");\n    }\n\n    string result = \"\";\n    for (size_t i = 0; i < a.length(); ++i) {\n        // Perform XOR operation\n        if (a[i] == b[i]) {\n            result += '0'; // Same bits result in '0'\n        } else {\n            result += '1'; // Different bits result in '1'\n        }\n    }\n    return result;\n}\n\n"}
{"task_id": "CPP/40", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nbool triples_sum_to_zero(vector<int> l) {\n    // Sort the vector\n    sort(l.begin(), l.end());\n    \n    // Iterate through the vector\n    for (size_t i = 0; i < l.size(); ++i) {\n        // Skip duplicates for the first element\n        if (i > 0 && l[i] == l[i - 1]) {\n            continue;\n        }\n        \n        // Use two pointers to find the other two numbers\n        int left = i + 1;\n        int right = l.size() - 1;\n        \n        while (left < right) {\n            int sum = l[i] + l[left] + l[right];\n            if (sum == 0) {\n                return true; // Found a triplet\n            } else if (sum < 0) {\n                ++left; // Move left pointer to the right to increase the sum\n            } else {\n                --right; // Move right pointer to the left to decrease the sum\n            }\n        }\n    }\n    \n    return false; // No triplet found\n}\n\n// Test cases\n"}
{"task_id": "CPP/13", "generation": "#include <iostream>\nusing namespace std;\n\nint greatest_common_divisor(int a, int b) {\n    // Ensure a and b are non-negative\n    a = abs(a);\n    b = abs(b);\n\n    // Use the Euclidean algorithm\n    while (b != 0) {\n        int temp = b;\n        b = a % b; // Remainder of a divided by b\n        a = temp;  // Update a to the previous b\n    }\n    return a; // When b is 0, a is the GCD\n}\n\n"}
{"task_id": "CPP/130", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> tri(int n) {\n    vector<int> tribonacci(n + 1);\n    \n    for (int i = 0; i <= n; i++) {\n        if (i == 1) {\n            tribonacci[i] = 3; // tri(1) = 3\n        } else if (i % 2 == 0) {\n            tribonacci[i] = 1 + i / 2; // tri(n) = 1 + n / 2 for even n\n        } else {\n            // Calculate tri(n) for odd n using the recurrence relation\n            tribonacci[i] = tribonacci[i - 1] + tribonacci[i - 2] + (i + 1 <= n ? tribonacci[i + 1] : 0); // Adjusted to avoid out-of-bounds\n        }\n    }\n    \n    return tribonacci;\n}\n"}
{"task_id": "CPP/60", "generation": "#include <iostream>\nusing namespace std;\n\nint sum_to_n(int n) {\n    return n * (n + 1) / 2; // Using the formula for the sum of the first n natural numbers\n}\n\n"}
{"task_id": "CPP/23", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint strlen(string str) {\n    return str.size(); // or you can use str.length();\n}\n\n"}
{"task_id": "CPP/46", "generation": "#include <iostream>\nusing namespace std;\n\nint fib4(int n) {\n    // Handle base cases\n    if (n == 0) return 0;\n    if (n == 1) return 0;\n    if (n == 2) return 2;\n    if (n == 3) return 0;\n\n    // Initialize an array to store the last four values\n    int fib[4] = {0, 0, 2, 0};\n\n    // Compute fib4(n) iteratively\n    for (int i = 4; i <= n; ++i) {\n        int next_fib = fib[0] + fib[1] + fib[2] + fib[3];\n        // Shift the values in the array\n        fib[0] = fib[1];\n        fib[1] = fib[2];\n        fib[2] = fib[3];\n        fib[3] = next_fib;\n    }\n\n    // The result is in fib[3] after the loop\n    return fib[3];\n}\n\n"}
{"task_id": "CPP/51", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nstring remove_vowels(string text) {\n    string result;\n    for (char c : text) {\n        // Check if the character is a vowel (both lowercase and uppercase)\n        if (c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u' &&\n            c != 'A' && c != 'E' && c != 'I' && c != 'O' && c != 'U') {\n            result += c; // Append non-vowel characters to result\n        }\n    }\n    return result; // Return the result string without vowels\n}\n\n"}
{"task_id": "CPP/18", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint how_many_times(string str, string substring) {\n    if (substring.empty()) {\n        return 0; // If the substring is empty, return 0\n    }\n\n    int count = 0;\n    size_t pos = 0;\n\n    // Use a loop to find all occurrences of the substring\n    while ((pos = str.find(substring, pos)) != string::npos) {\n        count++; // Increment the count for each found occurrence\n        pos++;   // Move to the next position to allow for overlapping matches\n    }\n\n    return count;\n}\n\n"}
{"task_id": "CPP/143", "generation": "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int n) {\n    if (n <= 1) return false; // 0 and 1 are not prime numbers\n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0) return false; // Found a divisor, not prime\n    }\n    return true; // No divisors found, it's prime\n}\n\n// Function to extract words with prime lengths from a sentence\nstring words_in_sentence(string sentence) {\n    stringstream ss(sentence);\n    string word;\n    vector<string> prime_length_words;\n\n    // Split the sentence into words\n    while (ss >> word) {\n        // Check if the length of the word is prime\n        if (is_prime(word.length())) {\n            prime_length_words.push_back(word);\n        }\n    }\n\n    // Join the words with prime lengths into a single string\n    string result;\n    for (size_t i = 0; i < prime_length_words.size(); i++) {\n        result += prime_length_words[i];\n        if (i < prime_length_words.size() - 1) {\n            result += \" \"; // Add space between words\n        }\n    }\n\n    return result;\n}\n\n// Example usage\n"}
{"task_id": "CPP/108", "generation": "#include <vector>\nusing namespace std;\n\nint sum_of_digits(int num) {\n    int total = 0;\n    bool isNegative = num < 0;\n    num = abs(num); // Work with the absolute value for digit extraction\n\n    while (num > 0) {\n        total += num % 10; // Add the last digit\n        num /= 10; // Remove the last digit\n    }\n\n    // If the original number was negative, subtract 1 for the first signed digit\n    if (isNegative) {\n        total -= 1;\n    }\n\n    return total;\n}\n\nint count_nums(vector<int> n) {\n    int count = 0;\n    for (int number : n) {\n        if (sum_of_digits(number) > 0) {\n            count++;\n        }\n    }\n    return count;\n}\n"}
{"task_id": "CPP/43", "generation": "#include <iostream>\n#include <vector>\n#include <unordered_set>\nusing namespace std;\n\nbool pairs_sum_to_zero(vector<int> l) {\n    unordered_set<int> seen; // Set to store the numbers we have seen\n\n    for (int num : l) {\n        // Check if the negation of the current number exists in the set\n        if (seen.count(-num)) {\n            return true; // Found a pair that sums to zero\n        }\n        seen.insert(num); // Add the current number to the set\n    }\n    \n    return false; // No pairs found that sum to zero\n}\n\n// Test cases\n"}
{"task_id": "CPP/70", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> strange_sort_list(vector<int> lst) {\n    // Sort the input list\n    sort(lst.begin(), lst.end());\n    \n    vector<int> result;\n    int left = 0; // Pointer for the minimum values\n    int right = lst.size() - 1; // Pointer for the maximum values\n    \n    // Alternate between minimum and maximum\n    while (left <= right) {\n        if (left == right) {\n            result.push_back(lst[left]); // Add the last remaining element\n        } else {\n            result.push_back(lst[left]); // Add the minimum\n            result.push_back(lst[right]); // Add the maximum\n        }\n        left++;\n        right--;\n    }\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/63", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint fibfib(int n) {\n    // Handle base cases\n    if (n == 0) return 0;\n    if (n == 1) return 0;\n    if (n == 2) return 1;\n\n    // Create a vector to store fibfib values\n    vector<int> fibfib_values(n + 1);\n    fibfib_values[0] = 0; // fibfib(0)\n    fibfib_values[1] = 0; // fibfib(1)\n    fibfib_values[2] = 1; // fibfib(2)\n\n    // Compute fibfib values iteratively\n    for (int i = 3; i <= n; ++i) {\n        fibfib_values[i] = fibfib_values[i - 1] + fibfib_values[i - 2] + fibfib_values[i - 3];\n    }\n\n    return fibfib_values[n];\n}\n\n"}
{"task_id": "CPP/89", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring encrypt(string s) {\n    string result = \"\";\n    \n    for (char c : s) {\n        // Check if the character is a lowercase letter\n        if (c >= 'a' && c <= 'z') {\n            // Rotate the character by 4 positions\n            char newChar = c + 4;\n            // Wrap around if necessary\n            if (newChar > 'z') {\n                newChar -= 26; // Wrap around to the start of the alphabet\n            }\n            result += newChar;\n        }\n        // Check if the character is an uppercase letter\n        else if (c >= 'A' && c <= 'Z') {\n            // Rotate the character by 4 positions\n            char newChar = c + 4;\n            // Wrap around if necessary\n            if (newChar > 'Z') {\n                newChar -= 26; // Wrap around to the start of the alphabet\n            }\n            result += newChar;\n        }\n        // If it's not a letter, we can choose to ignore it or handle it differently\n        else {\n            result += c; // Just append the character as is\n        }\n    }\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/26", "generation": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nvector<int> remove_duplicates(const vector<int>& numbers) {\n    unordered_map<int, int> count_map;\n    vector<int> result;\n\n    // Count occurrences of each number\n    for (int num : numbers) {\n        count_map[num]++;\n    }\n\n    // Collect numbers that occur only once\n    for (int num : numbers) {\n        if (count_map[num] == 1) {\n            result.push_back(num);\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/104", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nbool has_even_digit(int num) {\n    while (num > 0) {\n        int digit = num % 10;\n        if (digit % 2 == 0) {\n            return true; // Found an even digit\n        }\n        num /= 10;\n    }\n    return false; // No even digits found\n}\n\nvector<int> unique_digits(vector<int> x) {\n    vector<int> result;\n\n    for (int num : x) {\n        if (!has_even_digit(num)) {\n            result.push_back(num); // Add to result if no even digits\n        }\n    }\n\n    sort(result.begin(), result.end()); // Sort the result vector\n    return result;\n}\n\n"}
{"task_id": "CPP/90", "generation": "#include <iostream>\n#include <vector>\n#include <set>\n#include <algorithm>\n\nusing namespace std;\n\nint next_smallest(vector<int> lst) {\n    // Use a set to store unique elements\n    set<int> unique_elements(lst.begin(), lst.end());\n\n    // If there are fewer than 2 unique elements, return None (or -1 to indicate no result)\n    if (unique_elements.size() < 2) {\n        return -1; // You can also use a different way to indicate no result\n    }\n\n    // Convert the set back to a vector to access the second smallest element\n    vector<int> sorted_unique(unique_elements.begin(), unique_elements.end());\n\n    // Return the second smallest element\n    return sorted_unique[1];\n}\n\n"}
{"task_id": "CPP/126", "generation": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nbool is_sorted(vector<int> lst) {\n    unordered_map<int, int> countMap; // To count occurrences of each number\n\n    for (size_t i = 0; i < lst.size(); ++i) {\n        // Check if the current number is greater than the next number\n        if (i > 0 && lst[i] < lst[i - 1]) {\n            return false; // Not sorted\n        }\n\n        // Count occurrences of the current number\n        countMap[lst[i]]++;\n        if (countMap[lst[i]] > 2) {\n            return false; // More than two occurrences\n        }\n    }\n\n    return true; // If we pass both checks, the list is sorted and valid\n}\n\n"}
{"task_id": "CPP/68", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> pluck(vector<int> arr) {\n    int smallest_even_value = -1; // To track the smallest even value\n    int smallest_index = -1; // To track the index of the smallest even value\n\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] % 2 == 0) { // Check if the number is even\n            if (smallest_even_value == -1 || arr[i] < smallest_even_value) {\n                smallest_even_value = arr[i];\n                smallest_index = i;\n            }\n        }\n    }\n\n    // If no even number was found, return an empty vector\n    if (smallest_even_value == -1) {\n        return {};\n    }\n\n    // Return the smallest even value and its index\n    return {smallest_even_value, smallest_index};\n}\n\n// Example usage\n"}
{"task_id": "CPP/58", "generation": "#include <iostream>\n#include <vector>\n#include <set>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> common(vector<int> l1, vector<int> l2) {\n    // Use sets to store unique elements\n    set<int> set1(l1.begin(), l1.end());\n    set<int> set2(l2.begin(), l2.end());\n    \n    // Set to store common elements\n    set<int> commonSet;\n\n    // Find common elements\n    for (const int& element : set1) {\n        if (set2.find(element) != set2.end()) {\n            commonSet.insert(element);\n        }\n    }\n\n    // Convert set to vector\n    vector<int> result(commonSet.begin(), commonSet.end());\n\n    // Sort the result (though sets are already sorted)\n    sort(result.begin(), result.end());\n\n    return result;\n}\n\n"}
{"task_id": "CPP/112", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_set>\n#include <algorithm>\n\nusing namespace std;\n\nvector<string> reverse_delete(string s, string c) {\n    // Create a set of characters to delete\n    unordered_set<char> chars_to_delete(c.begin(), c.end());\n    \n    // Create a new string by excluding characters in chars_to_delete\n    string result;\n    for (char ch : s) {\n        if (chars_to_delete.find(ch) == chars_to_delete.end()) {\n            result += ch;\n        }\n    }\n    \n    // Check if the result string is a palindrome\n    string reversed_result = result;\n    reverse(reversed_result.begin(), reversed_result.end());\n    bool is_palindrome = (result == reversed_result);\n    \n    // Prepare the output\n    vector<string> output;\n    output.push_back(result);\n    output.push_back(is_palindrome ? \"True\" : \"False\");\n    \n    return output;\n}\n\n"}
{"task_id": "CPP/96", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Helper function to check if a number is prime\nbool is_prime(int num) {\n    if (num <= 1) return false; // 0 and 1 are not prime numbers\n    for (int i = 2; i * i <= num; i++) {\n        if (num % i == 0) return false; // Found a divisor, not prime\n    }\n    return true; // No divisors found, it's prime\n}\n\n// Main function to count primes up to n\nvector<int> count_up_to(int n) {\n    vector<int> primes;\n    for (int i = 2; i < n; i++) {\n        if (is_prime(i)) {\n            primes.push_back(i); // Add prime number to the vector\n        }\n    }\n    return primes; // Return the vector of prime numbers\n}\n\n// Example usage\n"}
{"task_id": "CPP/157", "generation": "#include <stdio.h>\n#include <math.h>\nusing namespace std;\n\nbool right_angle_triangle(float a, float b, float c) {\n    // Sort the sides to identify the longest side\n    float x = fmax(a, fmax(b, c)); // longest side\n    float y, z;\n\n    if (x == a) {\n        y = b;\n        z = c;\n    } else if (x == b) {\n        y = a;\n        z = c;\n    } else {\n        y = a;\n        z = b;\n    }\n\n    // Check the Pythagorean theorem\n    return (y * y + z * z) == (x * x);\n}\n\n"}
{"task_id": "CPP/99", "generation": "#include <iostream>\n#include <cmath>\n#include <string>\n\nusing namespace std;\n\nint closest_integer(string value) {\n    // Convert the string to a double\n    double number = stod(value);\n    \n    // Get the floor and ceil of the number\n    int lower = static_cast<int>(floor(number));\n    int upper = static_cast<int>(ceil(number));\n    \n    // Check the distance to the lower and upper integers\n    double distanceToLower = abs(number - lower);\n    double distanceToUpper = abs(number - upper);\n    \n    // If the distances are equal, round away from zero\n    if (distanceToLower == distanceToUpper) {\n        if (number > 0) {\n            return upper; // round up for positive numbers\n        } else {\n            return lower; // round down for negative numbers\n        }\n    }\n    \n    // Return the closest integer\n    return (distanceToLower < distanceToUpper) ? lower : upper;\n}\n\n"}
{"task_id": "CPP/149", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nvector<string> sorted_list_sum(vector<string> lst) {\n    // Filter out strings with odd lengths\n    vector<string> filtered_lst;\n    for (const string& s : lst) {\n        if (s.length() % 2 == 0) {\n            filtered_lst.push_back(s);\n        }\n    }\n    \n    // Sort the remaining strings first by length, then alphabetically\n    sort(filtered_lst.begin(), filtered_lst.end(), [](const string& a, const string& b) {\n        if (a.length() == b.length()) {\n            return a < b; // Sort alphabetically if lengths are equal\n        }\n        return a.length() < b.length(); // Sort by length\n    });\n    \n    return filtered_lst;\n}\n"}
{"task_id": "CPP/86", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <sstream>\n\nusing namespace std;\n\nstring anti_shuffle(string s) {\n    stringstream ss(s);\n    string word;\n    string result;\n\n    // Process each word in the string\n    while (ss >> word) {\n        // Sort the characters of the word\n        sort(word.begin(), word.end());\n        result += word + \" \"; // Append the sorted word and a space\n    }\n\n    // Remove the trailing space if there is one\n    if (!result.empty()) {\n        result.pop_back();\n    }\n\n    // Now we need to preserve the original spaces\n    size_t pos = 0;\n    string final_result;\n    for (char c : s) {\n        if (c == ' ') {\n            final_result += ' '; // Preserve spaces\n        } else {\n            // Find the next sorted word to add\n            while (pos < result.size() && result[pos] == ' ') {\n                pos++; // Skip any spaces in the sorted result\n            }\n            if (pos < result.size()) {\n                final_result += result[pos]; // Add the next character from sorted result\n                pos++; // Move to the next character in sorted result\n            }\n        }\n    }\n\n    return final_result;\n}\n\n"}
{"task_id": "CPP/129", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n\nusing namespace std;\n\nvoid dfs(const vector<vector<int>>& grid, int x, int y, int k, vector<int>& currentPath, vector<int>& minPath) {\n    // If we have reached the desired path length\n    if (currentPath.size() == k) {\n        // Compare current path with the minimum path\n        if (minPath.empty() || currentPath < minPath) {\n            minPath = currentPath; // Update minimum path\n        }\n        return;\n    }\n\n    // Define the possible movements (up, down, left, right)\n    vector<pair<int, int>> directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n\n    // Explore all neighbors\n    for (const auto& dir : directions) {\n        int newX = x + dir.first;\n        int newY = y + dir.second;\n\n        // Check if the new position is within bounds\n        if (newX >= 0 && newX < grid.size() && newY >= 0 && newY < grid[0].size()) {\n            currentPath.push_back(grid[newX][newY]); // Add the new cell value to the path\n            dfs(grid, newX, newY, k, currentPath, minPath); // Recur for the next cell\n            currentPath.pop_back(); // Backtrack\n        }\n    }\n}\n\nvector<int> minPath(vector<vector<int>> grid, int k) {\n    vector<int> minPath; // To store the minimum path found\n    int n = grid.size();\n\n    // Try starting from each cell in the grid\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            vector<int> currentPath; // To store the current path\n            currentPath.push_back(grid[i][j]); // Start with the current cell\n            dfs(grid, i, j, k, currentPath, minPath); // Perform DFS\n            currentPath.pop_back(); // Backtrack\n        }\n    }\n\n    return minPath; // Return the minimum path found\n}\n\n"}
{"task_id": "CPP/49", "generation": "#include <iostream>\nusing namespace std;\n\nint modp(int n, int p) {\n    // Handle the case when n is 0\n    if (n == 0) {\n        return 1; // 2^0 is 1\n    }\n\n    long long result = 1; // Use long long to avoid overflow\n    long long base = 2;   // The base is 2\n\n    // Exponentiation by squaring\n    while (n > 0) {\n        if (n % 2 == 1) { // If n is odd\n            result = (result * base) % p; // Multiply the result by the base and take mod p\n        }\n        base = (base * base) % p; // Square the base and take mod p\n        n /= 2; // Divide n by 2\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/156", "generation": "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nstring int_to_mini_roman(int number) {\n    // Define the Roman numeral symbols and their corresponding values\n    vector<pair<int, string>> roman_numerals = {\n        {1000, \"m\"}, {900, \"cm\"}, {500, \"d\"}, {400, \"cd\"},\n        {100, \"c\"}, {90, \"xc\"}, {50, \"l\"}, {40, \"xl\"},\n        {10, \"x\"}, {9, \"ix\"}, {5, \"v\"}, {4, \"iv\"},\n        {1, \"i\"}\n    };\n\n    string result = \"\";\n    \n    // Iterate through the Roman numeral values\n    for (const auto& pair : roman_numerals) {\n        while (number >= pair.first) {\n            result += pair.second; // Append the Roman numeral\n            number -= pair.first;  // Decrease the number\n        }\n    }\n    \n    return result; // Return the final Roman numeral string\n}\n\n// Example usage\n"}
{"task_id": "CPP/65", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nstring circular_shift(int x, int shift) {\n    // Convert the integer to a string to manipulate the digits\n    string x_str = to_string(x);\n    int n = x_str.length();\n\n    // If shift is greater than the number of digits, reverse the string\n    if (shift > n) {\n        reverse(x_str.begin(), x_str.end());\n        return x_str;\n    }\n\n    // Perform the circular shift\n    shift = shift % n;  // In case shift is greater than n\n    return x_str.substr(n - shift) + x_str.substr(0, n - shift);\n}\n"}
{"task_id": "CPP/9", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> rolling_max(vector<int> numbers) {\n    vector<int> result; // Vector to store the rolling maximums\n    int current_max = INT_MIN; // Initialize current_max to the smallest integer\n\n    for (int num : numbers) {\n        // Update current_max if the current number is greater\n        if (num > current_max) {\n            current_max = num;\n        }\n        // Add the current_max to the result vector\n        result.push_back(current_max);\n    }\n\n    return result; // Return the vector of rolling maximums\n}\n\n"}
{"task_id": "CPP/158", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_set>\n#include <algorithm>\n\nusing namespace std;\n\nstring find_max(vector<string> words) {\n    string max_word;\n    int max_unique_count = 0;\n\n    for (const string& word : words) {\n        // Use a set to count unique characters\n        unordered_set<char> unique_chars(word.begin(), word.end());\n        int unique_count = unique_chars.size();\n\n        // Check if this word has more unique characters or is lexicographically smaller\n        if (unique_count > max_unique_count || \n            (unique_count == max_unique_count && (max_word.empty() || word < max_word))) {\n            max_word = word;\n            max_unique_count = unique_count;\n        }\n    }\n\n    return max_word;\n}\n\n"}
{"task_id": "CPP/8", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> sum_product(vector<int> numbers) {\n    int sum = 0;\n    int product = 1;\n\n    // Check if the vector is empty\n    if (numbers.empty()) {\n        return {sum, product}; // Return (0, 1) for empty vector\n    }\n\n    // Calculate sum and product\n    for (int number : numbers) {\n        sum += number;       // Add to sum\n        product *= number;   // Multiply to product\n    }\n\n    return {sum, product}; // Return the result as a vector\n}\n\n"}
{"task_id": "CPP/95", "generation": "#include <stdio.h>\n#include <string>\n#include <map>\n#include <cctype> // for islower and isupper\nusing namespace std;\n\nbool check_dict_case(map<string, string> dict) {\n    if (dict.empty()) { // Check if the dictionary is empty\n        return false;\n    }\n\n    bool all_lower = true;\n    bool all_upper = true;\n\n    for (const auto& pair : dict) {\n        const string& key = pair.first;\n        if (!key.empty()) {\n            if (!islower(key[0])) {\n                all_lower = false;\n            }\n            if (!isupper(key[0])) {\n                all_upper = false;\n            }\n        }\n    }\n\n    return all_lower || all_upper;\n}\n"}
{"task_id": "CPP/55", "generation": "#include <iostream>\nusing namespace std;\n\nint fib(int n) {\n    if (n <= 0) return 0; // Handle case for n = 0\n    if (n == 1) return 1; // Base case for n = 1\n\n    int a = 0; // F(0)\n    int b = 1; // F(1)\n    int c; // Variable to store the current Fibonacci number\n\n    for (int i = 2; i <= n; i++) {\n        c = a + b; // F(n) = F(n-1) + F(n-2)\n        a = b; // Move to the next Fibonacci number\n        b = c; // Update b to the current Fibonacci number\n    }\n\n    return b; // Return the n-th Fibonacci number\n}\n\n"}
{"task_id": "CPP/29", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<string> filter_by_prefix(const vector<string>& strings, const string& prefix) {\n    vector<string> result;\n    \n    for (const string& str : strings) {\n        // Check if the string starts with the given prefix\n        if (str.substr(0, prefix.size()) == prefix) {\n            result.push_back(str);\n        }\n    }\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/72", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool is_palindrome(const vector<int>& q) {\n    int n = q.size();\n    for (int i = 0; i < n / 2; ++i) {\n        if (q[i] != q[n - 1 - i]) {\n            return false; // Not a palindrome\n        }\n    }\n    return true; // Is a palindrome\n}\n\nbool will_it_fly(vector<int> q, int w) {\n    // Check if the vector is a palindrome\n    if (!is_palindrome(q)) {\n        return false; // Not balanced\n    }\n    \n    // Calculate the sum of the elements\n    int sum = 0;\n    for (int num : q) {\n        sum += num;\n    }\n    \n    // Check if the sum is less than or equal to the maximum weight\n    return sum <= w;\n}\n\n"}
{"task_id": "CPP/54", "generation": "#include <iostream>\n#include <string>\n#include <set>\nusing namespace std;\n\nbool same_chars(string s0, string s1) {\n    // Create sets to store unique characters from each string\n    set<char> chars0(s0.begin(), s0.end());\n    set<char> chars1(s1.begin(), s1.end());\n\n    // Compare the two sets\n    return chars0 == chars1;\n}\n\n"}
{"task_id": "CPP/91", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <vector>\n\nusing namespace std;\n\nint is_bored(string S) {\n    // Replace delimiters with a period for uniform splitting\n    for (char& c : S) {\n        if (c == '!' || c == '?') {\n            c = '.';\n        }\n    }\n\n    // Split the string into sentences\n    stringstream ss(S);\n    string sentence;\n    int boredom_count = 0;\n\n    while (getline(ss, sentence, '.')) {\n        // Trim leading whitespace\n        size_t start = sentence.find_first_not_of(\" \\t\");\n        if (start != string::npos) {\n            sentence = sentence.substr(start);\n        }\n\n        // Check if the sentence starts with \"I\"\n        if (sentence.rfind(\"I\", 0) == 0) { // rfind checks if \"I\" is at the start\n            boredom_count++;\n        }\n    }\n\n    return boredom_count;\n}\n"}
{"task_id": "CPP/77", "generation": "#include <iostream>\n#include <cmath>\n\nbool iscube(int a) {\n    // Calculate the cube root of the absolute value of a\n    int cubeRoot = round(pow(abs(a), 1.0 / 3.0));\n    \n    // Check if the cube of the rounded cube root equals a\n    return (cubeRoot * cubeRoot * cubeRoot == a) || \n           (-cubeRoot * -cubeRoot * -cubeRoot == a);\n}\n\n"}
{"task_id": "CPP/73", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint smallest_change(vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n\n    // Compare elements from the start and end moving towards the center\n    for (int i = 0; i < n / 2; ++i) {\n        if (arr[i] != arr[n - 1 - i]) {\n            changes++; // Increment changes for each mismatch\n        }\n    }\n\n    return changes; // Return the total number of changes needed\n}\n\n"}
{"task_id": "CPP/71", "generation": "#include <stdio.h>\n#include <math.h>\n\nfloat triangle_area(float a, float b, float c) {\n    // Check for valid triangle using triangle inequality theorem\n    if (a + b <= c || a + c <= b || b + c <= a) {\n        return -1; // Not a valid triangle\n    }\n\n    // Calculate the semi-perimeter\n    float s = (a + b + c) / 2;\n\n    // Calculate the area using Heron's formula\n    float area = sqrt(s * (s - a) * (s - b) * (s - c));\n\n    // Return the area rounded to 2 decimal points\n    return round(area * 100) / 100; // Rounding to 2 decimal points\n}\n\n"}
{"task_id": "CPP/82", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_prime(int n) {\n    if (n <= 1) return false; // 0 and 1 are not prime numbers\n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0) return false; // Found a divisor, not prime\n    }\n    return true; // No divisors found, it's prime\n}\n\nbool prime_length(string str) {\n    int length = str.length(); // Get the length of the string\n    return is_prime(length); // Check if the length is prime\n}\n\n"}
{"task_id": "CPP/114", "generation": "#include <iostream>\n#include <vector>\n#include <limits.h> // for INT_MAX\n\nusing namespace std;\n\nlong long minSubArraySum(vector<long long> nums) {\n    long long currentMin = 0;\n    long long overallMin = LLONG_MAX; // Use LLONG_MAX for long long type\n\n    for (long long num : nums) {\n        currentMin += num;\n        if (currentMin < overallMin) {\n            overallMin = currentMin;\n        }\n        // If currentMin becomes positive, reset it to 0\n        if (currentMin > 0) {\n            currentMin = 0;\n        }\n    }\n\n    return overallMin;\n}\n\n"}
{"task_id": "CPP/138", "generation": "#include <stdio.h>\n\nbool is_equal_to_sum_even(int n) {\n    // Check if n is less than 8\n    if (n < 8) {\n        return false;\n    }\n    // Check if n is even\n    if (n % 2 != 0) {\n        return false;\n    }\n    // If n is even and at least 8, it can be expressed as the sum of 4 positive even numbers\n    return true;\n}\n\n"}
{"task_id": "CPP/132", "generation": "#include <stdio.h>\n#include <string>\n#include <stack>\nusing namespace std;\n\nbool is_nested(string str) {\n    stack<char> s;\n    bool nested = false;\n\n    for (char ch : str) {\n        if (ch == '[') {\n            s.push(ch);\n            if (s.size() > 1) {  // More than one opening bracket means nested\n                nested = true;\n            }\n        } else if (ch == ']') {\n            if (s.empty()) {  // If stack is empty, it's an invalid closing bracket\n                return false;\n            }\n            s.pop();\n        }\n    }\n\n    return nested && s.empty();  // Must be nested and all brackets must be closed\n}\n"}
{"task_id": "CPP/3", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool below_zero(vector<int> operations) {\n    int balance = 0; // Start with a balance of zero\n\n    // Iterate through each operation in the vector\n    for (int op : operations) {\n        balance += op; // Update the balance with the current operation\n\n        // Check if the balance falls below zero\n        if (balance < 0) {\n            return true; // Return true if balance is below zero\n        }\n    }\n\n    return false; // Return false if balance never goes below zero\n}\n\n"}
{"task_id": "CPP/142", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint sum_squares(vector<int> lst) {\n    int total_sum = 0; // Initialize the sum to 0\n\n    for (size_t i = 0; i < lst.size(); ++i) {\n        if (i % 3 == 0) {\n            // If index is a multiple of 3, square the entry\n            total_sum += lst[i] * lst[i];\n        } else if (i % 4 == 0) {\n            // If index is a multiple of 4 and not a multiple of 3, cube the entry\n            total_sum += lst[i] * lst[i] * lst[i];\n        } else {\n            // If index is neither a multiple of 3 nor 4, add the entry as is\n            total_sum += lst[i];\n        }\n    }\n\n    return total_sum; // Return the total sum\n}\n\n"}
{"task_id": "CPP/50", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring encode_shift(string s) {\n    // Returns encoded string by shifting every character by 5 in the alphabet.\n    string out;\n    for (char c : s) {\n        if (isalpha(c)) { // Check if the character is an alphabet\n            char base = islower(c) ? 'a' : 'A'; // Determine the base for lowercase or uppercase\n            char shifted = (c - base + 5) % 26 + base; // Shift and wrap around\n            out += shifted; // Append the shifted character to the output\n        } else {\n            out += c; // Non-alphabet characters are added unchanged\n        }\n    }\n    return out;\n}\n\nstring decode_shift(string s) {\n    // Takes as input string encoded with encode_shift function. Returns decoded string.\n    string out;\n    for (char c : s) {\n        if (isalpha(c)) { // Check if the character is an alphabet\n            char base = islower(c) ? 'a' : 'A'; // Determine the base for lowercase or uppercase\n            char shifted = (c - base - 5 + 26) % 26 + base; // Shift back and wrap around\n            out += shifted; // Append the shifted character to the output\n        } else {\n            out += c; // Non-alphabet characters are added unchanged\n        }\n    }\n    return out;\n}\n\n"}
{"task_id": "CPP/103", "generation": "#include <iostream>\n#include <string>\n#include <cmath>\n\nusing namespace std;\n\nstring rounded_avg(int n, int m) {\n    // Check if n is greater than m\n    if (n > m) {\n        return \"-1\";\n    }\n\n    // Calculate the sum of integers from n to m\n    int count = m - n + 1; // Number of integers from n to m\n    int sum = (n + m) * count / 2; // Sum of the arithmetic series\n    int avg = sum / count; // Average (integer division)\n\n    // Round down the average\n    int rounded_avg = floor(avg);\n\n    // Convert to binary\n    string binary = \"\";\n    if (rounded_avg == 0) {\n        binary = \"0\";\n    } else {\n        while (rounded_avg > 0) {\n            binary = to_string(rounded_avg % 2) + binary;\n            rounded_avg /= 2;\n        }\n    }\n\n    return binary;\n}\n\n"}
{"task_id": "CPP/57", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nbool monotonic(vector<float> l) {\n    if (l.size() < 2) return true; // A single element or empty vector is considered monotonic\n\n    bool increasing = true;\n    bool decreasing = true;\n\n    for (size_t i = 1; i < l.size(); ++i) {\n        if (l[i] > l[i - 1]) {\n            decreasing = false; // Found an increasing pair, so not decreasing\n        } else if (l[i] < l[i - 1]) {\n            increasing = false; // Found a decreasing pair, so not increasing\n        }\n    }\n\n    return increasing || decreasing; // Return true if either is true\n}\n\n"}
{"task_id": "CPP/28", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nstring concatenate(vector<string> strings) {\n    string result; // Initialize an empty string\n    for (const string& str : strings) { // Iterate through each string in the vector\n        result += str; // Append the current string to the result\n    }\n    return result; // Return the concatenated string\n}\n\n"}
{"task_id": "CPP/39", "generation": "#include <iostream>\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int num) {\n    if (num <= 1) return false; // 0 and 1 are not prime numbers\n    if (num <= 3) return true; // 2 and 3 are prime numbers\n    if (num % 2 == 0 || num % 3 == 0) return false; // eliminate multiples of 2 and 3\n    for (int i = 5; i * i <= num; i += 6) {\n        if (num % i == 0 || num % (i + 2) == 0) return false;\n    }\n    return true;\n}\n\n// Function to return the n-th Fibonacci prime number\nint prime_fib(int n) {\n    int count = 0; // Count of prime Fibonacci numbers\n    int a = 0, b = 1; // Fibonacci numbers initialization\n    int fib; // To hold the current Fibonacci number\n\n    while (true) {\n        fib = a + b; // Generate the next Fibonacci number\n        a = b; // Move to the next Fibonacci number\n        b = fib;\n\n        // Check if the Fibonacci number is prime\n        if (is_prime(fib)) {\n            count++; // Increment the count of prime Fibonacci numbers\n            if (count == n) {\n                return fib; // Return the n-th prime Fibonacci number\n            }\n        }\n    }\n}\n\n"}
{"task_id": "CPP/45", "generation": "#include <stdio.h>\n#include <math.h>\n\nusing namespace std;\n\nfloat triangle_area(float a, float h) {\n    return 0.5 * a * h; // Calculate the area using the formula\n}\n\n"}
{"task_id": "CPP/145", "generation": "#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nint digit_sum(int n) {\n    int sum = 0;\n    // Calculate the sum of digits, ignoring the negative sign\n    n = abs(n); // Take the absolute value to sum digits\n    while (n > 0) {\n        sum += n % 10; // Add the last digit to sum\n        n /= 10; // Remove the last digit\n    }\n    return sum;\n}\n\nvector<int> order_by_points(vector<int> nums) {\n    // Create a vector of pairs to store the original index and the number\n    vector<pair<int, int>> indexed_nums;\n    for (int i = 0; i < nums.size(); ++i) {\n        indexed_nums.push_back({nums[i], i}); // Store number and its index\n    }\n\n    // Sort based on the digit sum and original index\n    sort(indexed_nums.begin(), indexed_nums.end(), [](const pair<int, int>& a, const pair<int, int>& b) {\n        int sum_a = digit_sum(a.first);\n        int sum_b = digit_sum(b.first);\n        if (sum_a == sum_b) {\n            return a.second < b.second; // Maintain original order if sums are equal\n        }\n        return sum_a < sum_b; // Sort by digit sum\n    });\n\n    // Extract the sorted numbers\n    vector<int> result;\n    for (const auto& p : indexed_nums) {\n        result.push_back(p.first);\n    }\n    return result;\n}\n"}
{"task_id": "CPP/84", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring solve(int N) {\n    // Step 1: Calculate the sum of digits\n    int sum = 0;\n    while (N > 0) {\n        sum += N % 10; // Add the last digit to sum\n        N /= 10;       // Remove the last digit\n    }\n\n    // Step 2: Convert the sum to binary\n    string binary = \"\";\n    if (sum == 0) {\n        binary = \"0\"; // Handle the case where sum is 0\n    } else {\n        while (sum > 0) {\n            binary = to_string(sum % 2) + binary; // Prepend the binary digit\n            sum /= 2; // Divide sum by 2\n        }\n    }\n\n    // Step 3: Return the binary representation\n    return binary;\n}\n\n"}
{"task_id": "CPP/113", "generation": "#include <vector>\n#include <string>\n#include <sstream>\nusing namespace std;\n\nvector<string> odd_count(vector<string> lst) {\n    vector<string> result;\n    \n    for (const string& s : lst) {\n        int odd_count = 0;\n        \n        // Count the number of odd digits in the string\n        for (char c : s) {\n            if ((c - '0') % 2 != 0) {\n                odd_count++;\n            }\n        }\n        \n        // Create the formatted output string\n        stringstream ss;\n        ss << \"the number of odd elements \" << odd_count \n           << \"n the str\" << odd_count \n           << \"ng \" << odd_count \n           << \" of the \" << odd_count << \"nput.\";\n        \n        result.push_back(ss.str());\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/36", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint count_sevens(int num) {\n    int count = 0;\n    while (num > 0) {\n        if (num % 10 == 7) {\n            count++;\n        }\n        num /= 10;\n    }\n    return count;\n}\n\nint fizz_buzz(int n) {\n    int total_count = 0;\n    for (int i = 1; i < n; i++) {\n        if (i % 11 == 0 || i % 13 == 0) {\n            total_count += count_sevens(i);\n        }\n    }\n    return total_count;\n}\n\n"}
{"task_id": "CPP/144", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nbool simplify(string x, string n) {\n    // Split the first fraction x\n    size_t pos = x.find('/');\n    int numerator_x = stoi(x.substr(0, pos));\n    int denominator_x = stoi(x.substr(pos + 1));\n\n    // Split the second fraction n\n    pos = n.find('/');\n    int numerator_n = stoi(n.substr(0, pos));\n    int denominator_n = stoi(n.substr(pos + 1));\n\n    // Calculate the product of the fractions\n    int numerator_product = numerator_x * numerator_n;\n    int denominator_product = denominator_x * denominator_n;\n\n    // Check if the product is a whole number\n    return (numerator_product % denominator_product == 0);\n}\n\n"}
{"task_id": "CPP/0", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // For std::sort\n#include <cmath>     // For std::abs\n\nusing namespace std;\n\nbool has_close_elements(vector<float> numbers, float threshold) {\n    // Sort the vector\n    sort(numbers.begin(), numbers.end());\n    \n    // Check adjacent elements for closeness\n    for (size_t i = 1; i < numbers.size(); ++i) {\n        if (fabs(numbers[i] - numbers[i - 1]) < threshold) {\n            return true; // Found two elements that are too close\n        }\n    }\n    \n    return false; // No elements found that are too close\n}\n\n"}
{"task_id": "CPP/17", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nvector<int> parse_music(string music_string) {\n    vector<int> beats;\n    stringstream ss(music_string);\n    string note;\n\n    while (ss >> note) {\n        if (note == \"o\") {\n            beats.push_back(4); // whole note\n        } else if (note == \"o|\") {\n            beats.push_back(2); // half note\n        } else if (note == \".|\") {\n            beats.push_back(1); // quarter note\n        }\n    }\n\n    return beats;\n}\n\n"}
{"task_id": "CPP/47", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nfloat median(vector<float> l) {\n    // Sort the vector\n    sort(l.begin(), l.end());\n    \n    // Get the size of the vector\n    size_t size = l.size();\n    \n    // Calculate median\n    if (size % 2 == 1) {\n        // If odd, return the middle element\n        return l[size / 2];\n    } else {\n        // If even, return the average of the two middle elements\n        return (l[size / 2 - 1] + l[size / 2]) / 2.0;\n    }\n}\n\n"}
{"task_id": "CPP/75", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\n// Function to generate a list of prime numbers less than 100\nvector<int> generate_primes() {\n    vector<int> primes;\n    for (int i = 2; i < 100; i++) {\n        if (is_prime(i)) {\n            primes.push_back(i);\n        }\n    }\n    return primes;\n}\n\n// Function to check if the number is a product of three primes\nbool is_multiply_prime(int a) {\n    vector<int> primes = generate_primes();\n    \n    // Check all combinations of three primes\n    for (size_t i = 0; i < primes.size(); i++) {\n        for (size_t j = i; j < primes.size(); j++) {\n            for (size_t k = j; k < primes.size(); k++) {\n                int product = primes[i] * primes[j] * primes[k];\n                if (product == a) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n\n"}
{"task_id": "CPP/124", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nbool valid_date(string date) {\n    // Check if the date string is empty\n    if (date.empty()) {\n        return false;\n    }\n\n    // Check if the date is in the format mm-dd-yyyy\n    if (date[2] != '-' || date[5] != '-') {\n        return false;\n    }\n\n    int month, day, year;\n    char dash1, dash2;\n\n    // Use stringstream to parse the date\n    stringstream ss(date);\n    ss >> month >> dash1 >> day >> dash2 >> year;\n\n    // Check if the parsing was successful and if the dashes are correct\n    if (ss.fail() || dash1 != '-' || dash2 != '-' || ss.peek() != EOF) {\n        return false;\n    }\n\n    // Check if month is valid\n    if (month < 1 || month > 12) {\n        return false;\n    }\n\n    // Check days based on the month\n    if (month == 2) {\n        // February: Check for leap year\n        if (year % 4 == 0 && (year % 100 != 0 || year % 400 == 0)) {\n            // Leap year: 1-29 days\n            if (day < 1 || day > 29) {\n                return false;\n            }\n        } else {\n            // Non-leap year: 1-28 days\n            if (day < 1 || day > 28) {\n                return false;\n            }\n        }\n    } else if (month == 4 || month == 6 || month == 9 || month == 11) {\n        // Months with 30 days\n        if (day < 1 || day > 30) {\n            return false;\n        }\n    } else {\n        // Months with 31 days\n        if (day < 1 || day > 31) {\n            return false;\n        }\n    }\n\n    // If all checks passed, the date is valid\n    return true;\n}\n\n"}
{"task_id": "CPP/101", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n\nusing namespace std;\n\nvector<string> words_string(string s) {\n    // Replace commas with spaces\n    replace(s.begin(), s.end(), ',', ' ');\n    \n    vector<string> words;\n    stringstream ss(s);\n    string word;\n    \n    // Split the string by whitespace\n    while (ss >> word) {\n        words.push_back(word);\n    }\n    \n    return words;\n}\n"}
{"task_id": "CPP/14", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> all_prefixes(string str) {\n    vector<string> prefixes; // Vector to store prefixes\n    for (size_t i = 1; i <= str.length(); ++i) { // Loop from 1 to length of string\n        prefixes.push_back(str.substr(0, i)); // Add the prefix to the vector\n    }\n    return prefixes; // Return the vector of prefixes\n}\n\n"}
{"task_id": "CPP/141", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nstring file_name_check(string file_name) {\n    // Check for the presence of exactly one dot\n    size_t dot_position = file_name.find('.');\n    if (dot_position == string::npos || file_name.find('.', dot_position + 1) != string::npos) {\n        return \"No\"; // No dot or more than one dot\n    }\n\n    // Split the file name into the name part and the extension part\n    string name_part = file_name.substr(0, dot_position);\n    string extension_part = file_name.substr(dot_position + 1);\n\n    // Check if the name part is empty\n    if (name_part.empty()) {\n        return \"No\"; // Name part should not be empty\n    }\n\n    // Check if the name part starts with a letter\n    if (!isalpha(name_part[0])) {\n        return \"No\"; // Name part should start with a letter\n    }\n\n    // Check for the number of digits in the name part\n    int digit_count = 0;\n    for (char c : name_part) {\n        if (isdigit(c)) {\n            digit_count++;\n        }\n    }\n    if (digit_count > 3) {\n        return \"No\"; // More than three digits\n    }\n\n    // Check if the extension part is valid\n    if (extension_part == \"txt\" || extension_part == \"exe\" || extension_part == \"dll\") {\n        return \"Yes\"; // Valid file name\n    } else {\n        return \"No\"; // Invalid extension\n    }\n}\n\n// Example usage\n"}
{"task_id": "CPP/123", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\n\nusing namespace std;\n\nvector<int> get_odd_collatz(int n) {\n    set<int> odd_numbers; // Use a set to avoid duplicates\n    while (n != 1) {\n        if (n % 2 != 0) { // Check if n is odd\n            odd_numbers.insert(n); // Insert odd number into the set\n        }\n        // Apply the Collatz rules\n        if (n % 2 == 0) {\n            n /= 2; // If n is even, divide by 2\n        } else {\n            n = 3 * n + 1; // If n is odd, apply 3n + 1\n        }\n    }\n    // Include 1 in the result since it's part of the sequence\n    odd_numbers.insert(1);\n\n    // Convert set to vector\n    vector<int> result(odd_numbers.begin(), odd_numbers.end());\n    // Sort the vector (not strictly necessary since set is sorted)\n    sort(result.begin(), result.end());\n    \n    return result;\n}\n\n// Example usage\n"}
{"task_id": "CPP/148", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n\nusing namespace std;\n\nvector<string> bf(string planet1, string planet2) {\n    // List of planets in order from the Sun\n    vector<string> planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n    \n    // Create a map for quick lookup of planet indices\n    unordered_map<string, int> planetIndex;\n    for (int i = 0; i < planets.size(); i++) {\n        planetIndex[planets[i]] = i;\n    }\n    \n    // Check if both planets are valid\n    if (planetIndex.find(planet1) == planetIndex.end() || planetIndex.find(planet2) == planetIndex.end()) {\n        return {}; // Return an empty vector if either planet is invalid\n    }\n    \n    // Get the indices of the input planets\n    int index1 = planetIndex[planet1];\n    int index2 = planetIndex[planet2];\n    \n    // Ensure index1 is less than index2 for easier processing\n    if (index1 > index2) {\n        swap(index1, index2);\n    }\n    \n    // Collect planets between index1 and index2\n    vector<string> result;\n    for (int i = index1 + 1; i < index2; i++) {\n        result.push_back(planets[i]);\n    }\n    \n    return result;\n}\n\n// Example usage\n"}
{"task_id": "CPP/133", "generation": "#include <iostream>\n#include <cmath>\n#include <vector>\nusing namespace std;\n\nint sum_squares(vector<float> lst) {\n    int sum = 0;\n    for (float num : lst) {\n        int rounded = ceil(num);  // Round to the upper integer\n        sum += rounded * rounded;  // Add the square of the rounded number to the sum\n    }\n    return sum;\n}\n\n"}
{"task_id": "CPP/109", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool move_one_ball(vector<int> arr) {\n    // If the array is empty, return true\n    if (arr.empty()) {\n        return true;\n    }\n\n    int breakCount = 0;\n    int n = arr.size();\n\n    // Check for breaks in the array\n    for (int i = 0; i < n; i++) {\n        if (arr[i] > arr[(i + 1) % n]) {\n            breakCount++;\n        }\n    }\n\n    // If there are more than one breaks, return false\n    return breakCount <= 1;\n}\n\n// Example usage\n"}
{"task_id": "CPP/100", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> make_a_pile(int n) {\n    vector<int> stones; // Vector to hold the number of stones in each level\n    int current_stones = n; // Start with n stones for the first level\n\n    for (int i = 0; i < n; ++i) {\n        stones.push_back(current_stones); // Add the current number of stones to the vector\n        // Determine the next number of stones based on whether n is odd or even\n        if (current_stones % 2 == 0) {\n            current_stones += 2; // Next even number\n        } else {\n            current_stones += 2; // Next odd number\n        }\n    }\n\n    return stones; // Return the vector of stones\n}\n\n"}
{"task_id": "CPP/150", "generation": "#include <iostream>\nusing namespace std;\n\n// Function to check if a number is prime\nbool isPrime(int n) {\n    if (n <= 1) return false; // 0 and 1 are not prime numbers\n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0) return false; // Found a divisor, not prime\n    }\n    return true; // No divisors found, it's prime\n}\n\n// Function to return x if n is prime, otherwise return y\nint x_or_y(int n, int x, int y) {\n    return isPrime(n) ? x : y;\n}\n\n"}
{"task_id": "CPP/153", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring Strongest_Extension(string class_name, vector<string> extensions) {\n    string strongest_extension;\n    int max_strength = -INT_MAX; // Initialize to a very low value\n\n    for (const string& extension : extensions) {\n        int CAP = 0;\n        int SM = 0;\n\n        // Count uppercase and lowercase letters\n        for (char c : extension) {\n            if (isupper(c)) {\n                CAP++;\n            } else if (islower(c)) {\n                SM++;\n            }\n        }\n\n        // Calculate strength\n        int strength = CAP - SM;\n\n        // Check if this extension is stronger\n        if (strength > max_strength) {\n            max_strength = strength;\n            strongest_extension = extension;\n        }\n    }\n\n    // Return the result in the required format\n    return class_name + \".\" + strongest_extension;\n}\n\n// Example usage\n"}
{"task_id": "CPP/107", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to check if a number is a palindrome\nbool isPalindrome(int num) {\n    string str = to_string(num);\n    string revStr = string(str.rbegin(), str.rend());\n    return str == revStr;\n}\n\nvector<int> even_odd_palindrome(int n) {\n    int evenCount = 0;\n    int oddCount = 0;\n\n    for (int i = 1; i <= n; ++i) {\n        if (isPalindrome(i)) {\n            if (i % 2 == 0) {\n                evenCount++;\n            } else {\n                oddCount++;\n            }\n        }\n    }\n\n    return {evenCount, oddCount};\n}\n\n"}
{"task_id": "CPP/110", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring exchange(vector<int> lst1, vector<int> lst2) {\n    int oddCount = 0;\n    int evenCountInLst2 = 0;\n\n    // Count odd numbers in lst1\n    for (int num : lst1) {\n        if (num % 2 != 0) {\n            oddCount++;\n        }\n    }\n\n    // Count even numbers in lst2\n    for (int num : lst2) {\n        if (num % 2 == 0) {\n            evenCountInLst2++;\n        }\n    }\n\n    // Check if we can replace all odd numbers in lst1 with even numbers from lst2\n    if (oddCount <= evenCountInLst2) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n\n// Example usage\n"}
{"task_id": "CPP/111", "generation": "#include <iostream>\n#include <string>\n#include <map>\n#include <sstream>\n#include <algorithm>\n\nusing namespace std;\n\nmap<string, int> histogram(string test) {\n    map<string, int> count;\n    stringstream ss(test);\n    string letter;\n\n    // Count occurrences of each letter\n    while (ss >> letter) {\n        count[letter]++;\n    }\n\n    // Find the maximum occurrence\n    int max_count = 0;\n    for (const auto& pair : count) {\n        max_count = max(max_count, pair.second);\n    }\n\n    // Create a result map for letters with the maximum occurrence\n    map<string, int> result;\n    for (const auto& pair : count) {\n        if (pair.second == max_count) {\n            result[pair.first] = pair.second;\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/80", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_happy(string s) {\n    // Check if the length of the string is at least 3\n    if (s.length() < 3) {\n        return false;\n    }\n\n    // Iterate through the string and check every 3 consecutive characters\n    for (size_t i = 0; i <= s.length() - 3; ++i) {\n        // Check if the three characters are distinct\n        if (s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]) {\n            return false;\n        }\n    }\n\n    // If all checks passed, the string is happy\n    return true;\n}\n\n"}
{"task_id": "CPP/41", "generation": "#include <iostream>\nusing namespace std;\n\nint car_race_collision(int n) {\n    // Each car moving left to right will collide with each car moving right to left\n    return n * n; // Total collisions is n squared\n}\n\n"}
{"task_id": "CPP/116", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n// Function to count the number of 1s in the binary representation of an integer\nint countOnes(int x) {\n    return __builtin_popcount(x); // Using GCC built-in function to count set bits\n}\n\nvector<int> sort_array(vector<int> arr) {\n    // Sort the array based on the number of 1s in binary representation and then by value\n    sort(arr.begin(), arr.end(), [](int a, int b) {\n        // Compare by number of ones first, then by value\n        int countA = countOnes(a);\n        int countB = countOnes(b);\n        if (countA == countB) {\n            return a < b; // If counts are equal, sort by value\n        }\n        return countA < countB; // Otherwise, sort by number of ones\n    });\n    return arr;\n}\n"}
{"task_id": "CPP/61", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    int balance = 0; // Counter for the brackets\n\n    for (char ch : brackets) {\n        if (ch == '(') {\n            balance++; // Increment for opening bracket\n        } else if (ch == ')') {\n            balance--; // Decrement for closing bracket\n        }\n\n        // If balance goes negative, there are unmatched closing brackets\n        if (balance < 0) {\n            return false;\n        }\n    }\n\n    // At the end, balance should be zero for all brackets to be matched\n    return balance == 0;\n}\n\n// Test cases\n"}
{"task_id": "CPP/25", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> factorize(int n) {\n    vector<int> factors;\n\n    // Check for number of 2s that divide n\n    while (n % 2 == 0) {\n        factors.push_back(2);\n        n /= 2;\n    }\n\n    // n must be odd at this point, so we can skip even numbers\n    for (int i = 3; i * i <= n; i += 2) {\n        // While i divides n, add i and divide n\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n\n    // This condition is to check if n is a prime number greater than 2\n    if (n > 2) {\n        factors.push_back(n);\n    }\n\n    return factors;\n}\n\n"}
{"task_id": "CPP/137", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <boost/any.hpp>\n#include <sstream>\n\nusing namespace std;\n\nfloat to_float(const boost::any& value) {\n    if (value.type() == typeid(string)) {\n        string str_value = boost::any_cast<string>(value);\n        replace(str_value.begin(), str_value.end(), ',', '.'); // Replace comma with dot\n        return stof(str_value); // Convert to float\n    } else if (value.type() == typeid(int)) {\n        return static_cast<float>(boost::any_cast<int>(value));\n    } else if (value.type() == typeid(float)) {\n        return boost::any_cast<float>(value);\n    }\n    throw invalid_argument(\"Invalid type\");\n}\n\nboost::any compare_one(boost::any a, boost::any b) {\n    float a_float, b_float;\n    \n    try {\n        a_float = to_float(a);\n        b_float = to_float(b);\n    } catch (const invalid_argument&) {\n        return \"None\"; // If conversion fails, return \"None\"\n    }\n\n    if (a_float > b_float) {\n        return a; // Return the original value of a\n    } else if (b_float > a_float) {\n        return b; // Return the original value of b\n    } else {\n        return \"None\"; // Return \"None\" if they are equal\n    }\n}\n"}
{"task_id": "CPP/102", "generation": "#include <iostream>\nusing namespace std;\n\nint choose_num(int x, int y) {\n    // Ensure x is less than or equal to y\n    if (x > y) {\n        return -1; // Return -1 if the range is invalid\n    }\n\n    // Start from the maximum of x and y\n    int largest = y;\n\n    // Check if the largest number is even\n    if (largest % 2 != 0) {\n        largest--; // If it's odd, decrement by 1 to get the largest even number\n    }\n\n    // Check if the largest even number is still within the range\n    if (largest >= x) {\n        return largest; // Return the largest even number in the range\n    } else {\n        return -1; // No even number in the range\n    }\n}\n\n"}
{"task_id": "CPP/10", "generation": "#include <stdio.h>\n#include <string>\n#include <algorithm> // Include for std::reverse\nusing namespace std;\n\nbool is_palindrome(string str) {\n    // Test if given string is a palindrome \n    string s(str.rbegin(), str.rend());\n    return s == str;\n}\n\nstring make_palindrome(string str) {\n    /*\n    Find the shortest palindrome that begins with a supplied string. \n    Algorithm idea is simple: - Find the longest postfix of supplied string that is a palindrome. \n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome(\"\") \n    \"\" \n    >>> make_palindrome(\"cat\") \n    \"catac\" \n    >>> make_palindrome(\"cata\") \n    \"catac\" \n    */\n    if (str.empty()) {\n        return str; // Return empty string if input is empty\n    }\n\n    // Find the longest palindromic suffix\n    for (size_t i = 0; i < str.length(); i++) {\n        if (is_palindrome(str.substr(i))) {\n            // Append the reverse of the prefix before the palindromic suffix\n            string prefix = string(str.begin(), str.begin() + i);\n            reverse(prefix.begin(), prefix.end()); // Reverse the prefix\n            return str + prefix;\n        }\n    }\n\n    return str + string(str.rbegin(), str.rend()); // In case no palindromic suffix is found\n}\n"}
{"task_id": "CPP/76", "generation": "#include <iostream>\n#include <cmath>\n\nbool is_simple_power(int x, int n) {\n    // Handle special cases\n    if (n <= 1) {\n        return (x == 1); // 1 is a power of any number, but n=0 or n=1 is special\n    }\n    if (x < 1) {\n        return false; // x must be a positive integer\n    }\n\n    int power = 1; // Start with n^0\n    while (power < x) {\n        power *= n; // Calculate n^k iteratively\n    }\n\n    return power == x; // Check if we found the exact power\n}\n\n"}
{"task_id": "CPP/94", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <cmath>\nusing namespace std;\n\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i <= sqrt(n); i++) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\nint sum_of_digits(int n) {\n    int sum = 0;\n    while (n > 0) {\n        sum += n % 10;\n        n /= 10;\n    }\n    return sum;\n}\n\nint skjkasdkd(vector<int> lst) {\n    int largest_prime = -1;\n    for (int number : lst) {\n        if (is_prime(number) && number > largest_prime) {\n            largest_prime = number;\n        }\n    }\n    if (largest_prime == -1) {\n        return 0; // Return 0 if no prime number is found\n    }\n    return sum_of_digits(largest_prime);\n}\n"}
{"task_id": "CPP/32", "generation": "#include <stdio.h>\n#include <math.h>\n#include <vector>\n#include <stdexcept>\n\nusing namespace std;\n\ndouble poly(const vector<double>& xs, double x) {\n    /*\n    Evaluates polynomial with coefficients xs at point x. \n    return xs[0] + xs[1] * x + xs[2] * x^2 + .... + xs[n] * x^n \n    */\n    double sum = 0;\n    for (int i = 0; i < xs.size(); i++) {\n        sum += xs[i] * pow(x, i);\n    }\n    return sum;\n}\n\ndouble poly_derivative(const vector<double>& xs, double x) {\n    /*\n    Evaluates the derivative of the polynomial at point x.\n    The derivative is calculated as: xs[1] + 2*xs[2]*x + 3*xs[3]*x^2 + ... + n*xs[n]*x^(n-1)\n    */\n    double sum = 0;\n    for (int i = 1; i < xs.size(); i++) {\n        sum += i * xs[i] * pow(x, i - 1);\n    }\n    return sum;\n}\n\ndouble find_zero(const vector<double>& xs) {\n    /*\n    Finds a root of the polynomial defined by coefficients xs.\n    This function assumes that xs has an even number of coefficients and\n    the largest non-zero coefficient guarantees a solution.\n    */\n    if (xs.size() % 2 != 0) {\n        throw invalid_argument(\"Coefficient list must have an even number of coefficients.\");\n    }\n\n    double x0 = 0.0; // Initial guess\n    double tolerance = 1e-7; // Tolerance for convergence\n    int max_iterations = 1000; // Maximum number of iterations\n\n    for (int i = 0; i < max_iterations; i++) {\n        double fx = poly(xs, x0);\n        double dfx = poly_derivative(xs, x0);\n\n        if (dfx == 0) {\n            throw runtime_error(\"Derivative is zero. No solution found.\");\n        }\n\n        double x1 = x0 - fx / dfx; // Newton-Raphson formula\n\n        if (fabs(x1 - x0) < tolerance) {\n            return x1; // Found a root\n        }\n\n        x0 = x1; // Update x0 for next iteration\n    }\n\n    throw runtime_error(\"Maximum iterations reached. No solution found.\");\n}\n\n"}
{"task_id": "CPP/33", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> sort_third(vector<int> l) {\n    // Step 1: Extract values at indices divisible by 3\n    vector<int> to_sort;\n    for (size_t i = 0; i < l.size(); ++i) {\n        if (i % 3 == 0) {\n            to_sort.push_back(l[i]);\n        }\n    }\n\n    // Step 2: Sort the extracted values\n    sort(to_sort.begin(), to_sort.end());\n\n    // Step 3: Replace the original values at indices divisible by 3 with sorted values\n    size_t sort_index = 0;\n    for (size_t i = 0; i < l.size(); ++i) {\n        if (i % 3 == 0) {\n            l[i] = to_sort[sort_index++];\n        }\n    }\n\n    return l;\n}\n\n"}
{"task_id": "CPP/88", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> sort_array(const vector<int>& array) {\n    // Step 1: Check if the input vector is empty\n    if (array.empty()) {\n        return {};\n    }\n    \n    // Step 2: If the vector has only one element, return a copy of that vector\n    if (array.size() == 1) {\n        return array;\n    }\n    \n    // Step 3: Calculate the sum of the first and last elements\n    int sum = array.front() + array.back();\n    \n    // Step 4: Create a copy of the original array to sort\n    vector<int> sorted_array = array;\n    \n    // Step 5: Sort based on the sum being odd or even\n    if (sum % 2 == 0) {\n        // Even sum: sort in descending order\n        sort(sorted_array.rbegin(), sorted_array.rend());\n    } else {\n        // Odd sum: sort in ascending order\n        sort(sorted_array.begin(), sorted_array.end());\n    }\n    \n    // Step 6: Return the sorted vector\n    return sorted_array;\n}\n\n// Example usage\n"}
{"task_id": "CPP/15", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nstring string_sequence(int n) {\n    stringstream ss; // Create a string stream to build the output string\n    for (int i = 0; i <= n; ++i) {\n        ss << i; // Add the current number to the stream\n        if (i < n) {\n            ss << \" \"; // Add a space after the number if it's not the last one\n        }\n    }\n    return ss.str(); // Convert the string stream to a string and return it\n}\n\n"}
{"task_id": "CPP/163", "generation": "#include <iostream>\n#include <vector>\n#include <set>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> generate_integers(int a, int b) {\n    // Create a set to store unique even digits\n    set<int> even_digits;\n\n    // Determine the range\n    int start = min(a, b);\n    int end = max(a, b);\n\n    // Iterate through the range\n    for (int i = start; i <= end; ++i) {\n        // Check if the number is a single digit and even\n        if (i >= 0 && i < 10 && i % 2 == 0) {\n            even_digits.insert(i);\n        }\n    }\n\n    // Convert the set to a vector for the result\n    vector<int> result(even_digits.begin(), even_digits.end());\n    return result;\n}\n\n"}
{"task_id": "CPP/1", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<string> separate_paren_groups(string paren_string) {\n    vector<string> result;\n    string current_group;\n    int balance = 0;\n\n    // Remove spaces from the input string\n    paren_string.erase(remove(paren_string.begin(), paren_string.end(), ' '), paren_string.end());\n\n    for (char ch : paren_string) {\n        if (ch == '(') {\n            if (balance == 0 && !current_group.empty()) {\n                // If we are starting a new group, save the current group\n                result.push_back(current_group);\n                current_group.clear();\n            }\n            current_group += ch; // Add the opening parenthesis\n            balance++; // Increase balance\n        } else if (ch == ')') {\n            current_group += ch; // Add the closing parenthesis\n            balance--; // Decrease balance\n            if (balance == 0) {\n                // If balance is zero, we have a complete group\n                result.push_back(current_group);\n                current_group.clear(); // Clear current group for the next one\n            }\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/69", "generation": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint search(vector<int> lst) {\n    unordered_map<int, int> frequencyMap;\n\n    // Count the frequency of each integer in the vector\n    for (int num : lst) {\n        frequencyMap[num]++;\n    }\n\n    int result = -1;\n\n    // Check for the greatest integer that meets the condition\n    for (const auto& pair : frequencyMap) {\n        int num = pair.first;\n        int freq = pair.second;\n\n        // Check if the frequency is greater than or equal to the number itself\n        if (freq >= num) {\n            result = max(result, num);\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/31", "generation": "#include <stdio.h>\n\nbool is_prime(long long n) {\n    // Check if n is less than 2\n    if (n < 2) {\n        return false;\n    }\n    // Check for factors from 2 to the square root of n\n    for (long long i = 2; i * i <= n; i++) {\n        if (n % i == 0) {\n            return false; // n is divisible by i, hence not prime\n        }\n    }\n    return true; // n is prime\n}\n\n"}
{"task_id": "CPP/147", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint get_max_triples(int n) {\n    vector<int> a(n);\n    \n    // Step 1: Calculate the values of a[i]\n    for (int i = 1; i <= n; ++i) {\n        a[i - 1] = i * i - i + 1; // a[i] corresponds to a[i-1] in 0-indexed array\n    }\n    \n    // Step 2: Count occurrences of each modulo 3 value\n    int count[3] = {0, 0, 0};\n    for (int i = 0; i < n; ++i) {\n        count[a[i] % 3]++;\n    }\n    \n    // Step 3: Count valid triples\n    int total_triples = 0;\n    \n    // Case 1: All three numbers have the same modulo\n    for (int i = 0; i < 3; ++i) {\n        if (count[i] >= 3) {\n            total_triples += (count[i] * (count[i] - 1) * (count[i] - 2)) / 6; // nC3\n        }\n    }\n    \n    // Case 2: One from each modulo\n    total_triples += count[0] * count[1] * count[2];\n    \n    return total_triples;\n}\n\n"}
{"task_id": "CPP/105", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nvector<string> by_length(vector<int> arr) {\n    // Step 1: Filter the integers between 1 and 9\n    vector<int> filtered;\n    for (int num : arr) {\n        if (num >= 1 && num <= 9) {\n            filtered.push_back(num);\n        }\n    }\n\n    // Step 2: Sort the filtered integers\n    sort(filtered.begin(), filtered.end());\n\n    // Step 3: Reverse the sorted vector\n    reverse(filtered.begin(), filtered.end());\n\n    // Step 4: Map integers to their corresponding names\n    vector<string> result;\n    vector<string> names = {\"Zero\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"};\n    \n    for (int num : filtered) {\n        result.push_back(names[num]); // num is guaranteed to be between 1 and 9\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/22", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <boost/any.hpp>\n#include <list>\n#include <typeinfo>\n\ntypedef std::list<boost::any> list_any;\n\nstd::vector<int> filter_integers(list_any values) {\n    std::vector<int> result;\n\n    for (const auto& value : values) {\n        // Check if the value is of type int\n        if (value.type() == typeid(int)) {\n            // Extract the int value and add it to the result vector\n            result.push_back(boost::any_cast<int>(value));\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/52", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool below_threshold(vector<int> l, int t) {\n    for (int num : l) {\n        if (num >= t) {\n            return false; // Found a number that is not below the threshold\n        }\n    }\n    return true; // All numbers are below the threshold\n}\n\n"}
{"task_id": "CPP/154", "generation": "#include <string>\nusing namespace std;\n\nbool cycpattern_check(string a, string b) {\n    // Create a new string by concatenating 'b' with itself\n    string b_rotations = b + b;\n    // Check if 'b' or any of its rotations is a substring of 'a'\n    return (b_rotations.find(b) != string::npos) && \n           (b_rotations.find(a) != string::npos);\n}\n"}
{"task_id": "CPP/115", "generation": "#include <iostream>\n#include <vector>\n#include <cmath> // for ceil function\n\nusing namespace std;\n\nint max_fill(vector<vector<int>> grid, int capacity) {\n    int total_operations = 0;\n\n    for (const auto& well : grid) {\n        int water_units = 0;\n\n        // Count the number of water units (1s) in the current well (row)\n        for (int water : well) {\n            if (water == 1) {\n                water_units++;\n            }\n        }\n\n        // Calculate the number of times we need to lower the bucket for this well\n        if (water_units > 0) {\n            total_operations += ceil(static_cast<double>(water_units) / capacity);\n        }\n    }\n\n    return total_operations;\n}\n\n"}
{"task_id": "CPP/131", "generation": "#include <stdio.h>\n\nint digits(int n) {\n    int product = 1;\n    bool hasOdd = false;\n\n    while (n > 0) {\n        int digit = n % 10; // Get the last digit\n        if (digit % 2 != 0) { // Check if the digit is odd\n            product *= digit; // Multiply it to the product\n            hasOdd = true; // Set the flag to true\n        }\n        n /= 10; // Remove the last digit\n    }\n\n    return hasOdd ? product : 0; // Return product if odd digits were found, otherwise return 0\n}\n\n"}
{"task_id": "CPP/37", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<float> sort_even(vector<float> l) {\n    // Create a vector to hold the even indexed values\n    vector<float> even_values;\n\n    // Extract even indexed values\n    for (size_t i = 0; i < l.size(); i += 2) {\n        even_values.push_back(l[i]);\n    }\n\n    // Sort the even indexed values\n    sort(even_values.begin(), even_values.end());\n\n    // Create a new vector to hold the result\n    vector<float> result(l.size());\n\n    // Fill the result vector\n    size_t even_index = 0;\n    for (size_t i = 0; i < l.size(); i++) {\n        if (i % 2 == 0) {\n            // Even index: use sorted value\n            result[i] = even_values[even_index++];\n        } else {\n            // Odd index: keep original value\n            result[i] = l[i];\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/92", "generation": "#include <iostream>\n#include <cmath> // For std::floor and std::ceil\n\nusing namespace std;\n\nbool any_int(float a, float b, float c) {\n    // Check if all numbers are integers\n    if (floor(a) != a || floor(b) != b || floor(c) != c) {\n        return false;\n    }\n    \n    // Check if one number is equal to the sum of the other two\n    return (a == b + c) || (b == a + c) || (c == a + b);\n}\n\n"}
{"task_id": "CPP/118", "generation": "#include <stdio.h>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nstring get_closest_vowel(string word) {\n    string vowels = \"aeiouAEIOU\";\n    int n = word.length();\n    \n    // Start from the end of the word and look for the closest vowel\n    for (int i = n - 2; i > 0; --i) {  // Start from the second last character to the second character\n        if (vowels.find(word[i]) != string::npos && \n            isalpha(word[i - 1]) && isalpha(word[i + 1]) && \n            vowels.find(word[i - 1]) == string::npos && \n            vowels.find(word[i + 1]) == string::npos) {\n            return string(1, word[i]);\n        }\n    }\n    \n    return \"\";\n}\n"}
{"task_id": "CPP/6", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nvector<int> parse_nested_parens(string paren_string) {\n    vector<int> depths; // Vector to store the maximum depths for each group\n    stringstream ss(paren_string); // Use stringstream to split the string\n    string group;\n\n    // Iterate through each group separated by spaces\n    while (ss >> group) {\n        int current_depth = 0; // Current depth of nesting\n        int max_depth = 0; // Maximum depth found in this group\n\n        // Iterate through each character in the group\n        for (char ch : group) {\n            if (ch == '(') {\n                current_depth++; // Increase depth for opening parenthesis\n                max_depth = max(max_depth, current_depth); // Update max depth\n            } else if (ch == ')') {\n                current_depth--; // Decrease depth for closing parenthesis\n            }\n        }\n\n        // Add the maximum depth found for this group to the vector\n        depths.push_back(max_depth);\n    }\n\n    return depths; // Return the vector containing maximum depths\n}\n\n// Example usage\n"}
{"task_id": "CPP/87", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<vector<int>> get_row(vector<vector<int>> lst, int x) {\n    vector<vector<int>> result;\n\n    // Iterate through each row\n    for (int i = 0; i < lst.size(); ++i) {\n        // Iterate through each column in the current row\n        for (int j = 0; j < lst[i].size(); ++j) {\n            // Check if the current element matches x\n            if (lst[i][j] == x) {\n                // Store the coordinates {row, column}\n                result.push_back({i, j});\n            }\n        }\n    }\n\n    // Sort the result by row (ascending) and then by column (descending)\n    sort(result.begin(), result.end(), [](const vector<int>& a, const vector<int>& b) {\n        if (a[0] == b[0]) {\n            return a[1] > b[1]; // Sort by column in descending order if rows are the same\n        }\n        return a[0] < b[0]; // Sort by row in ascending order\n    });\n\n    return result;\n}\n\n// Example usage\n"}
{"task_id": "CPP/2", "generation": "#include <stdio.h>\n#include <math.h>\n\nfloat truncate_number(float number) {\n    // Get the integer part of the number\n    int integer_part = floor(number);\n    \n    // Calculate the decimal part\n    float decimal_part = number - integer_part;\n    \n    return decimal_part;\n}\n\n"}
{"task_id": "CPP/16", "generation": "#include <iostream>\n#include <set>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nint count_distinct_characters(string str) {\n    set<char> distinct_chars; // Set to store distinct characters\n\n    // Iterate through each character in the string\n    for (char c : str) {\n        // Convert character to lowercase and insert into the set\n        distinct_chars.insert(tolower(c));\n    }\n\n    // The size of the set is the number of distinct characters\n    return distinct_chars.size();\n}\n\n"}
{"task_id": "CPP/135", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint can_arrange(vector<int> arr) {\n    int n = arr.size();\n    int result = -1; // Initialize result to -1\n\n    // Iterate through the array starting from the second element\n    for (int i = 1; i < n; i++) {\n        // Check if the current element is less than the previous one\n        if (arr[i] < arr[i - 1]) {\n            result = i; // Update result with the current index\n        }\n    }\n\n    return result; // Return the largest index found, or -1 if none found\n}\n\n"}
{"task_id": "CPP/106", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> f(int n) {\n    vector<int> result(n); // Create a vector of size n\n\n    for (int i = 1; i <= n; ++i) {\n        if (i % 2 == 0) {\n            // Calculate factorial for even indices\n            int factorial = 1;\n            for (int j = 1; j <= i; ++j) {\n                factorial *= j;\n            }\n            result[i - 1] = factorial; // Store in the vector (0-based index)\n        } else {\n            // Calculate sum from 1 to i for odd indices\n            int sum = (i * (i + 1)) / 2; // Using the formula for the sum of first i natural numbers\n            result[i - 1] = sum; // Store in the vector (0-based index)\n        }\n    }\n\n    return result; // Return the resulting vector\n}\n\n"}
{"task_id": "CPP/162", "generation": "#include <stdio.h>\n#include <string>\n#include <openssl/md5.h>\nusing namespace std;\n\nstring string_to_md5(string text) {\n    if (text.empty()) {\n        return \"\"; // Return an empty string to represent None\n    }\n\n    unsigned char digest[MD5_DIGEST_LENGTH];\n    MD5((unsigned char*)text.c_str(), text.length(), digest);\n\n    char md5String[33]; // MD5 produces a 32-character hexadecimal number\n    for (int i = 0; i < 16; i++) {\n        sprintf(&md5String[i * 2], \"%02x\", (unsigned int)digest[i]);\n    }\n    return string(md5String);\n}\n"}
{"task_id": "CPP/5", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvector<int> intersperse(vector<int> numbers, int delimiter) {\n    // If the input vector is empty, return an empty vector\n    if (numbers.empty()) {\n        return {};\n    }\n\n    vector<int> result;\n    // Reserve space in the result vector to optimize performance\n    result.reserve(numbers.size() + (numbers.size() - 1));\n\n    // Iterate through the input vector and insert elements and delimiters\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        result.push_back(numbers[i]); // Add the current element\n        if (i < numbers.size() - 1) { // If it's not the last element\n            result.push_back(delimiter); // Add the delimiter\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/97", "generation": "#include <iostream>\nusing namespace std;\n\nint multiply(int a, int b) {\n    // Get the unit digits\n    int unitDigitA = abs(a) % 10; // Use abs to handle negative numbers\n    int unitDigitB = abs(b) % 10; // Use abs to handle negative numbers\n    \n    // Multiply the unit digits\n    return unitDigitA * unitDigitB;\n}\n\n"}
{"task_id": "CPP/44", "generation": "#include <iostream>\n#include <string>\n#include <algorithm> // for std::reverse\n\nusing namespace std;\n\nstring change_base(int x, int base) {\n    if (x == 0) return \"0\"; // Handle the case for 0\n\n    string result;\n    \n    while (x > 0) {\n        int remainder = x % base; // Get the remainder\n        result += to_string(remainder); // Append it to the result string\n        x /= base; // Divide x by the base\n    }\n    \n    // The digits are in reverse order, so we need to reverse the string\n    reverse(result.begin(), result.end());\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/161", "generation": "#include <iostream>\n#include <string>\n#include <cctype> // for isalpha, tolower, toupper\nusing namespace std;\n\nstring solve(string s) {\n    bool hasLetter = false;\n\n    // First, check if there are any letters in the string\n    for (char c : s) {\n        if (isalpha(c)) {\n            hasLetter = true;\n            break;\n        }\n    }\n\n    if (hasLetter) {\n        // If there are letters, reverse their case\n        for (char &c : s) {\n            if (isalpha(c)) {\n                // Reverse case\n                if (islower(c)) {\n                    c = toupper(c);\n                } else {\n                    c = tolower(c);\n                }\n            }\n        }\n    } else {\n        // If there are no letters, reverse the entire string\n        reverse(s.begin(), s.end());\n    }\n\n    return s;\n}\n\n"}
{"task_id": "CPP/38", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nstring encode_cyclic(string s) { \n    // returns encoded string by cycling groups of three characters.  \n    // split string to groups. Each of length 3.\n    int l = s.length();\n    int num = (l + 2) / 3;\n    string x, output;\n    int i;\n    for (i = 0; i * 3 < l; i++) {\n        // cycle elements in each group. Unless group has fewer elements than 3.\n        x = s.substr(i * 3, 3);\n        if (x.length() == 3) x = x.substr(1) + x[0];\n        output = output + x;\n    }\n    return output;\n}\n\nstring decode_cyclic(string s) { \n    /*\n    takes as input string encoded with encode_cyclic function. Returns decoded string. \n    */\n    int l = s.length();\n    string x, output;\n    int i;\n    for (i = 0; i * 3 < l; i++) {\n        // reverse the cycling of elements in each group.\n        x = s.substr(i * 3, 3);\n        if (x.length() == 3) x = x[x.length() - 1] + x.substr(0, 2);\n        output = output + x;\n    }\n    return output;\n}\n\n"}
{"task_id": "CPP/93", "generation": "#include <iostream>\n#include <string>\n#include <cctype>\n\nusing namespace std;\n\nstring encode(string message) {\n    string encodedMessage = \"\";\n\n    for (char ch : message) {\n        // Swap case\n        if (isupper(ch)) {\n            ch = tolower(ch);\n        } else if (islower(ch)) {\n            ch = toupper(ch);\n        }\n\n        // Replace vowels\n        switch (ch) {\n            case 'a':\n                ch = 'c'; // 'a' -> 'c'\n                break;\n            case 'e':\n                ch = 'g'; // 'e' -> 'g'\n                break;\n            case 'i':\n                ch = 'k'; // 'i' -> 'k'\n                break;\n            case 'o':\n                ch = 'q'; // 'o' -> 'q'\n                break;\n            case 'u':\n                ch = 'w'; // 'u' -> 'w'\n                break;\n            case 'A':\n                ch = 'C'; // 'A' -> 'C'\n                break;\n            case 'E':\n                ch = 'G'; // 'E' -> 'G'\n                break;\n            case 'I':\n                ch = 'K'; // 'I' -> 'K'\n                break;\n            case 'O':\n                ch = 'Q'; // 'O' -> 'Q'\n                break;\n            case 'U':\n                ch = 'W'; // 'U' -> 'W'\n                break;\n            default:\n                break; // Non-vowel characters remain unchanged\n        }\n\n        encodedMessage += ch; // Append the modified character to the result\n    }\n\n    return encodedMessage;\n}\n\n"}
{"task_id": "CPP/152", "generation": "#include <iostream>\n#include <vector>\n#include <cmath> // for abs function\n\nusing namespace std;\n\nvector<int> compare(vector<int> game, vector<int> guess) {\n    // Initialize a result vector of the same size as game and guess\n    vector<int> result(game.size());\n\n    // Iterate through each match\n    for (size_t i = 0; i < game.size(); i++) {\n        // Calculate the absolute difference\n        result[i] = abs(game[i] - guess[i]);\n    }\n\n    return result; // Return the result vector\n}\n\n"}
{"task_id": "CPP/62", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<float> derivative(const vector<float>& xs) {\n    vector<float> result;\n\n    // Start from index 1 because the derivative of the constant term (index 0) is 0\n    for (size_t i = 1; i < xs.size(); ++i) {\n        // The derivative of the term is i * xs[i]\n        result.push_back(i * xs[i]);\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/7", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<string> filter_by_substring(const vector<string>& strings, const string& substring) {\n    vector<string> filtered_strings; // Vector to hold the filtered results\n\n    // Iterate through each string in the input vector\n    for (const string& str : strings) {\n        // Check if the substring is found in the current string\n        if (str.find(substring) != string::npos) {\n            filtered_strings.push_back(str); // Add to the result if found\n        }\n    }\n\n    return filtered_strings; // Return the filtered vector\n}\n\n"}
{"task_id": "CPP/24", "generation": "#include <iostream>\nusing namespace std;\n\nint largest_divisor(int n) {\n    // Start checking from n-1 down to 1\n    for (int i = n - 1; i > 0; i--) {\n        if (n % i == 0) {\n            return i; // Return the first divisor found\n        }\n    }\n    return 1; // If no divisor found (should not happen for n > 1)\n}\n\n"}
{"task_id": "CPP/79", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring decimal_to_binary(int decimal) {\n    if (decimal == 0) {\n        return \"db0db\"; // Special case for 0\n    }\n\n    string binary = \"\";\n    \n    // Convert decimal to binary\n    while (decimal > 0) {\n        binary = to_string(decimal % 2) + binary; // Prepend the remainder\n        decimal /= 2; // Divide by 2\n    }\n    \n    // Add \"db\" at the beginning and end\n    return \"db\" + binary + \"db\";\n}\n\n"}
{"task_id": "CPP/155", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> even_odd_count(int num) {\n    // Initialize counters for even and odd digits\n    int even_count = 0;\n    int odd_count = 0;\n\n    // Work with the absolute value of the number to ignore the sign\n    num = abs(num);\n\n    // Check if the number is zero\n    if (num == 0) {\n        even_count = 1; // Zero is considered an even digit\n    } else {\n        // Loop through each digit\n        while (num > 0) {\n            int digit = num % 10; // Get the last digit\n            if (digit % 2 == 0) {\n                even_count++; // Increment even count\n            } else {\n                odd_count++; // Increment odd count\n            }\n            num /= 10; // Remove the last digit\n        }\n    }\n\n    // Return the counts as a vector\n    return {even_count, odd_count};\n}\n\n"}
{"task_id": "CPP/4", "generation": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nfloat mean_absolute_deviation(vector<float> numbers) {\n    // Step 1: Calculate the mean\n    float sum = 0.0;\n    int n = numbers.size();\n    \n    for (float num : numbers) {\n        sum += num;\n    }\n    \n    float mean = sum / n;\n    \n    // Step 2: Calculate the absolute differences and their average\n    float mad_sum = 0.0;\n    \n    for (float num : numbers) {\n        mad_sum += fabs(num - mean); // fabs() computes the absolute value\n    }\n    \n    float mad = mad_sum / n; // Step 3: Average of absolute differences\n    \n    return mad;\n}\n\n"}
{"task_id": "CPP/56", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    int balance = 0; // This will keep track of the balance of brackets\n\n    for (char ch : brackets) {\n        if (ch == '<') {\n            balance++; // Increment for an opening bracket\n        } else if (ch == '>') {\n            balance--; // Decrement for a closing bracket\n        }\n\n        // If balance goes negative, we have a closing bracket without a matching opening bracket\n        if (balance < 0) {\n            return false;\n        }\n    }\n\n    // At the end, balance should be zero for all brackets to be matched\n    return balance == 0;\n}\n\n"}
{"task_id": "CPP/159", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> eat(int number, int need, int remaining) {\n    // Calculate how many more carrots the rabbit needs to eat\n    int additionalCarrots = need;\n    \n    // Check if there are enough remaining carrots\n    if (remaining >= additionalCarrots) {\n        // If enough carrots are available\n        number += additionalCarrots; // Update total eaten\n        remaining -= additionalCarrots; // Update remaining carrots\n    } else {\n        // If not enough carrots are available\n        number += remaining; // Eat all remaining carrots\n        remaining = 0; // No carrots left\n    }\n    \n    // Return the result as a vector\n    return {number, remaining};\n}\n\n// Example usage\n"}
{"task_id": "CPP/83", "generation": "#include <stdio.h>\n#include <cmath>\n\nint starts_one_ends(int n) {\n    if (n < 1) return 0; // Invalid input for n\n\n    // Count of n-digit numbers starting with '1'\n    long long count_starting_with_1 = pow(10, n - 1);\n\n    // Count of n-digit numbers ending with '1'\n    long long count_ending_with_1 = 9 * pow(10, n - 2);\n\n    // Count of n-digit numbers starting and ending with '1'\n    long long count_both = pow(10, n - 2);\n\n    // Total count using inclusion-exclusion principle\n    long long total_count = count_starting_with_1 + count_ending_with_1 - count_both;\n\n    return total_count;\n}\n\n"}
{"task_id": "CPP/27", "generation": "#include <iostream>\n#include <string>\n#include <cctype> // for islower and isupper\n\nusing namespace std;\n\nstring flip_case(string str) {\n    for (char &c : str) { // Iterate through each character in the string\n        if (islower(c)) {\n            c = toupper(c); // Convert to uppercase if it's lowercase\n        } else if (isupper(c)) {\n            c = tolower(c); // Convert to lowercase if it's uppercase\n        }\n    }\n    return str; // Return the modified string\n}\n\n"}
{"task_id": "CPP/146", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint specialFilter(vector<int> nums) {\n    int count = 0;\n\n    for (int num : nums) {\n        // Check if the number is greater than 10\n        if (num > 10) {\n            // Convert the number to a string to easily access digits\n            string numStr = to_string(num);\n            char firstDigit = numStr[0];\n            char lastDigit = numStr[numStr.length() - 1];\n\n            // Check if both first and last digits are odd\n            if ((firstDigit == '1' || firstDigit == '3' || firstDigit == '5' || firstDigit == '7' || firstDigit == '9') &&\n                (lastDigit == '1' || lastDigit == '3' || lastDigit == '5' || lastDigit == '7' || lastDigit == '9')) {\n                count++;\n            }\n        }\n    }\n\n    return count;\n}\n\n"}
{"task_id": "CPP/81", "generation": "#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> numerical_letter_grade(vector<float> grades) {\n    vector<string> letter_grades;\n    for (float gpa : grades) {\n        if (gpa == 4.0) {\n            letter_grades.push_back(\"A+\");\n        } else if (gpa > 3.7) {\n            letter_grades.push_back(\"A\");\n        } else if (gpa > 3.3) {\n            letter_grades.push_back(\"A-\");\n        } else if (gpa > 3.0) {\n            letter_grades.push_back(\"B+\");\n        } else if (gpa > 2.7) {\n            letter_grades.push_back(\"B\");\n        } else if (gpa > 2.3) {\n            letter_grades.push_back(\"B-\");\n        } else if (gpa > 2.0) {\n            letter_grades.push_back(\"C+\");\n        } else if (gpa > 1.7) {\n            letter_grades.push_back(\"C\");\n        } else if (gpa > 1.3) {\n            letter_grades.push_back(\"C-\");\n        } else if (gpa > 1.0) {\n            letter_grades.push_back(\"D+\");\n        } else if (gpa > 0.7) {\n            letter_grades.push_back(\"D\");\n        } else if (gpa > 0.0) {\n            letter_grades.push_back(\"D-\");\n        } else {\n            letter_grades.push_back(\"E\");\n        }\n    }\n    return letter_grades;\n}\n"}
{"task_id": "CPP/136", "generation": "#include <iostream>\n#include <vector>\n#include <limits>\n\nusing namespace std;\n\nvector<int> largest_smallest_integers(vector<int> lst) {\n    int largest_negative = numeric_limits<int>::min(); // Initialize to the smallest possible integer\n    int smallest_positive = numeric_limits<int>::max(); // Initialize to the largest possible integer\n\n    for (int num : lst) {\n        if (num < 0) {\n            if (num > largest_negative) {\n                largest_negative = num; // Update largest negative if found a larger one\n            }\n        } else if (num > 0) {\n            if (num < smallest_positive) {\n                smallest_positive = num; // Update smallest positive if found a smaller one\n            }\n        }\n    }\n\n    // If no negative number was found, set largest_negative to 0\n    if (largest_negative == numeric_limits<int>::min()) {\n        largest_negative = 0;\n    }\n\n    // If no positive number was found, set smallest_positive to 0\n    if (smallest_positive == numeric_limits<int>::max()) {\n        smallest_positive = 0;\n    }\n\n    return {largest_negative, smallest_positive};\n}\n\n"}
{"task_id": "CPP/67", "generation": "#include <stdio.h>\n#include <string>\n#include <sstream>\nusing namespace std;\n\nint fruit_distribution(string s, int n) {\n    int apples = 0, oranges = 0;\n    stringstream ss(s);\n    ss >> apples; // Read the number of apples\n    ss.ignore(256, ' '); // Ignore the word \"apples\"\n    ss >> oranges; // Read the number of oranges\n    ss.ignore(256, ' '); // Ignore the word \"oranges\"\n    \n    // Calculate the number of mangoes\n    int mangoes = n - apples - oranges;\n    return mangoes;\n}\n"}
{"task_id": "CPP/48", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_palindrome(string text) {\n    int left = 0;\n    int right = text.length() - 1;\n\n    while (left < right) {\n        if (text[left] != text[right]) {\n            return false; // Not a palindrome\n        }\n        left++;\n        right--;\n    }\n    return true; // It's a palindrome\n}\n\n"}
{"task_id": "CPP/125", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <cctype>\n\nusing namespace std;\n\nvector<string> split_words(string txt) {\n    vector<string> result;\n    \n    // Check for whitespace\n    if (txt.find(' ') != string::npos) {\n        stringstream ss(txt);\n        string word;\n        while (ss >> word) {\n            result.push_back(word);\n        }\n        return result;\n    }\n    \n    // Check for commas\n    if (txt.find(',') != string::npos) {\n        stringstream ss(txt);\n        string word;\n        while (getline(ss, word, ',')) {\n            result.push_back(word);\n        }\n        return result;\n    }\n    \n    // If no whitespace or commas, count lowercase letters with odd positions\n    int odd_count = 0;\n    for (char c : txt) {\n        if (islower(c)) {\n            int position = c - 'a'; // Calculate position (0 for 'a', 1 for 'b', ..., 25 for 'z')\n            if (position % 2 == 1) { // Check if the position is odd\n                odd_count++;\n            }\n        }\n    }\n    \n    // Return the count as a string in a vector\n    return {to_string(odd_count)};\n}\n\n"}
{"task_id": "CPP/160", "generation": "#include <stdio.h>\n#include <math.h>\n#include <vector>\n#include <string>\nusing namespace std;\n#include <algorithm>\n#include <stdlib.h>\n\nint do_algebra(vector<string> operato, vector<int> operand) {\n    int result = operand[0]; // Initialize result with the first operand\n    for (size_t i = 0; i < operato.size(); i++) {\n        if (operato[i] == \"+\") {\n            result += operand[i + 1];\n        } else if (operato[i] == \"-\") {\n            result -= operand[i + 1];\n        } else if (operato[i] == \"*\") {\n            result *= operand[i + 1];\n        } else if (operato[i] == \"//\") {\n            result /= operand[i + 1]; // Floor division is handled by integer division in C++\n        } else if (operato[i] == \"**\") {\n            result = pow(result, operand[i + 1]); // Use pow for exponentiation\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/151", "generation": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nlong long double_the_difference(vector<float> lst) {\n    long long sum_of_squares = 0;\n\n    for (float num : lst) {\n        // Check if the number is an integer and odd\n        if (num == static_cast<int>(num) && static_cast<int>(num) % 2 != 0 && num >= 0) {\n            sum_of_squares += static_cast<int>(num) * static_cast<int>(num);\n        }\n    }\n\n    return sum_of_squares;\n}\n\n"}
{"task_id": "CPP/117", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <cctype>\n\nusing namespace std;\n\nbool is_consonant(char c) {\n    // Check if the character is a consonant (not a vowel and is an alphabet)\n    c = tolower(c);\n    return isalpha(c) && (c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u');\n}\n\nvector<string> select_words(string s, int n) {\n    vector<string> result;\n    stringstream ss(s);\n    string word;\n\n    // If the input string is empty, return an empty vector\n    if (s.empty()) {\n        return result;\n    }\n\n    // Process each word in the string\n    while (ss >> word) {\n        int consonant_count = 0;\n\n        // Count consonants in the current word\n        for (char c : word) {\n            if (is_consonant(c)) {\n                consonant_count++;\n            }\n        }\n\n        // If the word has exactly n consonants, add it to the result\n        if (consonant_count == n) {\n            result.push_back(word);\n        }\n    }\n\n    return result;\n}\n\n// Example usage\n"}
{"task_id": "CPP/78", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint hex_key(string num) {\n    // Define the set of prime hexadecimal digits\n    const string prime_hex_digits = \"2357BD\"; // B and D are included as they are prime\n    \n    int count = 0;\n    \n    // Iterate through each character in the input string\n    for (char c : num) {\n        // Check if the character is in the set of prime hexadecimal digits\n        if (prime_hex_digits.find(c) != string::npos) {\n            count++;\n        }\n    }\n    \n    return count;\n}\n\n// Example usage\n"}
{"task_id": "CPP/74", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> total_match(vector<string> lst1, vector<string> lst2) {\n    int total_chars_lst1 = 0;\n    int total_chars_lst2 = 0;\n\n    // Calculate total characters in lst1\n    for (const string& str : lst1) {\n        total_chars_lst1 += str.length();\n    }\n\n    // Calculate total characters in lst2\n    for (const string& str : lst2) {\n        total_chars_lst2 += str.length();\n    }\n\n    // Compare total characters and return the appropriate vector\n    if (total_chars_lst1 < total_chars_lst2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n"}
{"task_id": "CPP/53", "generation": "#include <iostream>\nusing namespace std;\n\n// Function to add two numbers\nint add(int x, int y) {\n    return x + y;\n}\n\n"}
{"task_id": "CPP/98", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint count_upper(string s) {\n    int count = 0;\n    // Loop through the string, checking only even indices\n    for (int i = 0; i < s.length(); i += 2) {\n        // Check if the character is an uppercase vowel\n        if (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U') {\n            count++;\n        }\n    }\n    return count;\n}\n\n"}
{"task_id": "CPP/140", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\nusing namespace std;\n\nstring fix_spaces(string text) {\n    // Replace all spaces with underscores\n    for (char& c : text) {\n        if (c == ' ') {\n            c = '_';\n        }\n    }\n\n    // Split the text by underscores to handle consecutive spaces\n    stringstream ss(text);\n    string part;\n    string result;\n    bool lastWasEmpty = false;\n\n    while (getline(ss, part, '_')) {\n        if (!part.empty()) {\n            if (!result.empty()) {\n                result += '_'; // Add underscore before the next part\n            }\n            result += part;\n            lastWasEmpty = false;\n        } else {\n            // If we encounter an empty part, it means there were consecutive spaces\n            if (!lastWasEmpty) {\n                result += '-';\n                lastWasEmpty = true;\n            }\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/34", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> unique(vector<int> l) {\n    // Step 1: Sort the vector\n    sort(l.begin(), l.end());\n    \n    // Step 2: Use std::unique to remove duplicates\n    auto last = unique(l.begin(), l.end());\n    \n    // Step 3: Resize the vector to the new size\n    l.erase(last, l.end());\n    \n    return l;\n}\n\n"}
{"task_id": "CPP/66", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint digitSum(string s) {\n    int sum = 0; // Initialize sum to 0\n    for (char c : s) { // Iterate through each character in the string\n        if (isupper(c)) { // Check if the character is uppercase\n            sum += static_cast<int>(c); // Add the ASCII value of the uppercase character to sum\n        }\n    }\n    return sum; // Return the final sum\n}\n\n"}
{"task_id": "CPP/120", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> maximum(vector<int> arr, int k) {\n    // Step 1: Sort the array in descending order\n    sort(arr.begin(), arr.end(), greater<int>());\n    \n    // Step 2: Select the first k elements\n    vector<int> maxElements(arr.begin(), arr.begin() + k);\n    \n    // Step 3: Sort the selected k elements in ascending order\n    sort(maxElements.begin(), maxElements.end());\n    \n    // Step 4: Return the sorted vector of length k\n    return maxElements;\n}\n\n"}
{"task_id": "CPP/139", "generation": "#include <iostream>\nusing namespace std;\n\n// Function to calculate factorial of a number\nlong long factorial(int num) {\n    long long result = 1;\n    for (int i = 1; i <= num; ++i) {\n        result *= i;\n    }\n    return result;\n}\n\n// Function to calculate the Brazilian factorial\nlong long special_factorial(int n) {\n    long long result = 1;\n    for (int i = 1; i <= n; ++i) {\n        result *= factorial(i);\n    }\n    return result;\n}\n\n"}
{"task_id": "CPP/12", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nstring longest(vector<string> strings) {\n    if (strings.empty()) {\n        return \"\"; // Return an empty string to indicate None\n    }\n\n    string longestString = strings[0]; // Start with the first string\n    for (const string& str : strings) {\n        if (str.length() > longestString.length()) {\n            longestString = str; // Update longestString if a longer string is found\n        }\n    }\n    return longestString; // Return the longest string found\n}\n\n"}
{"task_id": "CPP/121", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint solution(vector<int> lst) {\n    int sum = 0; // Initialize sum to 0\n    for (size_t i = 0; i < lst.size(); i++) {\n        // Check if the index is even\n        if (i % 2 == 0) {\n            // Check if the element is odd\n            if (lst[i] % 2 != 0) {\n                sum += lst[i]; // Add to sum if both conditions are met\n            }\n        }\n    }\n    return sum; // Return the final sum\n}\n\n// Example usage\n"}
{"task_id": "CPP/35", "generation": "#include <iostream>\n#include <vector>\n#include <limits> // For std::numeric_limits\n\nusing namespace std;\n\nfloat max_element(const vector<float>& l) {\n    // Check if the vector is empty\n    if (l.empty()) {\n        // Handle the case of an empty vector (optional)\n        // You might want to throw an exception or return a special value\n        return std::numeric_limits<float>::quiet_NaN(); // Return NaN for empty vector\n    }\n\n    float max_val = l[0]; // Initialize max_val with the first element\n\n    // Iterate through the vector to find the maximum element\n    for (size_t i = 1; i < l.size(); ++i) {\n        if (l[i] > max_val) {\n            max_val = l[i]; // Update max_val if a larger element is found\n        }\n    }\n\n    return max_val; // Return the maximum value found\n}\n\n"}
{"task_id": "CPP/20", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <limits>\n\nusing namespace std;\n\nvector<float> find_closest_elements(vector<float> numbers) {\n    // Step 1: Sort the vector\n    sort(numbers.begin(), numbers.end());\n\n    // Initialize variables to keep track of the closest pair\n    float min_diff = numeric_limits<float>::max(); // Start with the maximum possible float value\n    vector<float> closest_pair;\n\n    // Step 2: Find the closest pair\n    for (size_t i = 0; i < numbers.size() - 1; ++i) {\n        float diff = numbers[i + 1] - numbers[i]; // Calculate the difference between consecutive elements\n        if (diff < min_diff) {\n            min_diff = diff; // Update the minimum difference\n            closest_pair = {numbers[i], numbers[i + 1]}; // Update the closest pair\n        }\n    }\n\n    // Step 3: Return the closest pair\n    return closest_pair;\n}\n\n"}
{"task_id": "CPP/19", "generation": "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <map>\n#include <algorithm>\n\nusing namespace std;\n\nstring sort_numbers(string numbers) {\n    // Mapping from string to integer\n    map<string, int> num_map = {\n        {\"zero\", 0}, {\"one\", 1}, {\"two\", 2}, {\"three\", 3},\n        {\"four\", 4}, {\"five\", 5}, {\"six\", 6}, {\"seven\", 7},\n        {\"eight\", 8}, {\"nine\", 9}\n    };\n\n    // Vector to hold the integer values\n    vector<int> num_values;\n    stringstream ss(numbers);\n    string word;\n\n    // Split the input string and convert to integers\n    while (ss >> word) {\n        num_values.push_back(num_map[word]);\n    }\n\n    // Sort the integer values\n    sort(num_values.begin(), num_values.end());\n\n    // Convert back to strings\n    vector<string> sorted_words;\n    for (int num : num_values) {\n        for (const auto& pair : num_map) {\n            if (pair.second == num) {\n                sorted_words.push_back(pair.first);\n                break;\n            }\n        }\n    }\n\n    // Join the sorted words into a single string\n    string result;\n    for (size_t i = 0; i < sorted_words.size(); ++i) {\n        result += sorted_words[i];\n        if (i < sorted_words.size() - 1) {\n            result += \" \"; // Add space between words\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/85", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint add(vector<int> lst) {\n    int sum = 0; // Initialize sum to 0\n    for (size_t i = 0; i < lst.size(); ++i) {\n        // Check if the index is odd and the element is even\n        if (i % 2 == 1 && lst[i] % 2 == 0) {\n            sum += lst[i]; // Add the even element at odd index to sum\n        }\n    }\n    return sum; // Return the final sum\n}\n\n"}
{"task_id": "CPP/21", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // for std::min_element and std::max_element\n\nusing namespace std;\n\nvector<float> rescale_to_unit(vector<float> numbers) {\n    // Check if the vector has at least two elements\n    if (numbers.size() < 2) {\n        throw invalid_argument(\"The vector must contain at least two elements.\");\n    }\n    \n    // Find the minimum and maximum values in the vector\n    float min_val = *min_element(numbers.begin(), numbers.end());\n    float max_val = *max_element(numbers.begin(), numbers.end());\n    \n    // Create a new vector to hold the rescaled values\n    vector<float> rescaled;\n    \n    // Rescale each number\n    for (float num : numbers) {\n        float rescaled_value = (num - min_val) / (max_val - min_val);\n        rescaled.push_back(rescaled_value);\n    }\n    \n    return rescaled;\n}\n\n"}
{"task_id": "CPP/119", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring match_parens(vector<string> lst) {\n    string s1 = lst[0], s2 = lst[1];\n\n    // Function to count the balance of parentheses\n    auto balance = [](const string& s) {\n        int open_count = 0;\n        int close_count = 0;\n        for (char c : s) {\n            if (c == '(') open_count++;\n            else if (c == ')') close_count++;\n        }\n        return make_pair(open_count, close_count);\n    };\n\n    // Get the balance of both strings\n    auto [open1, close1] = balance(s1);\n    auto [open2, close2] = balance(s2);\n\n    // Check if we can concatenate in either order to form a good string\n    // Concatenating s1 + s2\n    if (open1 >= close2) {\n        return \"Yes\";\n    }\n\n    // Concatenating s2 + s1\n    if (open2 >= close1) {\n        return \"Yes\";\n    }\n\n    return \"No\";\n}\n"}
{"task_id": "CPP/30", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<float> get_positive(vector<float> l) {\n    vector<float> positives; // Vector to store positive numbers\n    for (float num : l) {    // Iterate through each number in the input vector\n        if (num > 0) {       // Check if the number is positive\n            positives.push_back(num); // Add positive number to the positives vector\n        }\n    }\n    return positives; // Return the vector containing only positive numbers\n}\n\n"}
{"task_id": "CPP/64", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint vowels_count(string s) {\n    int count = 0;\n    int length = s.length();\n\n    for (int i = 0; i < length; i++) {\n        char c = tolower(s[i]); // Convert to lowercase for case-insensitive comparison\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n            count++;\n        }\n    }\n\n    // Check if the last character is 'y' (considered a vowel only at the end)\n    if (length > 0 && tolower(s[length - 1]) == 'y') {\n        count++;\n    }\n\n    return count;\n}\n\n"}
{"task_id": "CPP/128", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint prod_signs(vector<int> arr) {\n    if (arr.empty()) {\n        return -32768; // Return -32768 for empty array\n    }\n\n    int sum_magnitudes = 0;\n    int sign_product = 1; // Start with a neutral product\n\n    for (int num : arr) {\n        if (num > 0) {\n            sum_magnitudes += num; // Add magnitude of positive numbers\n        } else if (num < 0) {\n            sum_magnitudes += -num; // Add magnitude of negative numbers\n            sign_product *= -1; // Flip the sign product for negative numbers\n        } else {\n            return 0; // If there's a zero, return 0\n        }\n    }\n\n    return sum_magnitudes * sign_product; // Return the final result\n}\n\n"}
{"task_id": "CPP/127", "generation": "#include <vector>\n#include <string>\n#include <cmath>\nusing namespace std;\n\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i <= sqrt(n); i++) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\nstring intersection(vector<int> interval1, vector<int> interval2) {\n    int start1 = interval1[0], end1 = interval1[1];\n    int start2 = interval2[0], end2 = interval2[1];\n    \n    // Find the intersection\n    int start_intersection = max(start1, start2);\n    int end_intersection = min(end1, end2);\n    \n    // Calculate the length of the intersection\n    int length = end_intersection - start_intersection;\n    \n    // Check if the length is a prime number\n    if (length > 0 && is_prime(length)) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n"}
{"task_id": "CPP/122", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint add_elements(vector<int> arr, int k) {\n    int sum = 0; // Initialize sum to 0\n    // Iterate through the first k elements\n    for (int i = 0; i < k; i++) {\n        // Check if the element has at most two digits\n        if (arr[i] >= -99 && arr[i] <= 99) {\n            sum += arr[i]; // Add to sum if condition is met\n        }\n    }\n    return sum; // Return the final sum\n}\n\n"}
{"task_id": "CPP/59", "generation": "#include <stdio.h>\n\nint largest_prime_factor(int n) {\n    int largest_factor = 1;\n\n    // Check for number of 2s that divide n\n    while (n % 2 == 0) {\n        largest_factor = 2;\n        n /= 2;\n    }\n\n    // n must be odd at this point, so we can skip even numbers\n    for (int i = 3; i * i <= n; i += 2) {\n        while (n % i == 0) {\n            largest_factor = i;\n            n /= i;\n        }\n    }\n\n    // This condition is to check if n is a prime number greater than 2\n    if (n > 2) {\n        largest_factor = n;\n    }\n\n    return largest_factor;\n}\n\n"}
{"task_id": "CPP/134", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nbool check_if_last_char_is_a_letter(string txt) {\n    // Strip any trailing spaces\n    size_t end = txt.find_last_not_of(' ');\n    if (end == string::npos) {\n        return false; // String is empty after stripping\n    }\n    txt = txt.substr(0, end + 1); // Update txt to remove trailing spaces\n\n    // Check if the last character is an alphabetical character\n    char last_char = txt.back();\n    return isalpha(last_char) && (txt.length() == 1 || txt[txt.length() - 2] == ' ');\n}\n"}
{"task_id": "CPP/42", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> incr_list(vector<int> l) {\n    // Create a new vector to hold the incremented values\n    vector<int> incremented_list;\n    \n    // Iterate through each element in the input vector\n    for (int i = 0; i < l.size(); i++) {\n        // Increment the current element by 1 and add it to the new vector\n        incremented_list.push_back(l[i] + 1);\n    }\n    \n    // Return the new vector with incremented values\n    return incremented_list;\n}\n\n"}
{"task_id": "CPP/11", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring string_xor(string a, string b) {\n    // Ensure both strings are of the same length\n    if (a.length() != b.length()) {\n        throw invalid_argument(\"Strings must be of the same length\");\n    }\n\n    string result = \"\";\n    for (size_t i = 0; i < a.length(); i++) {\n        // Perform XOR operation\n        if (a[i] == b[i]) {\n            result += '0'; // Same bits result in '0'\n        } else {\n            result += '1'; // Different bits result in '1'\n        }\n    }\n    return result;\n}\n\n"}
{"task_id": "CPP/40", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <unordered_set>\n\nusing namespace std;\n\nbool triples_sum_to_zero(vector<int> l) {\n    // Sort the vector to use two-pointer technique\n    sort(l.begin(), l.end());\n    \n    int n = l.size();\n    \n    // Iterate through the array\n    for (int i = 0; i < n - 2; i++) {\n        // Skip duplicates for the first element\n        if (i > 0 && l[i] == l[i - 1]) {\n            continue;\n        }\n        \n        int left = i + 1;\n        int right = n - 1;\n        \n        while (left < right) {\n            int sum = l[i] + l[left] + l[right];\n            \n            if (sum == 0) {\n                return true; // Found a triplet\n            } else if (sum < 0) {\n                left++; // Move left pointer to the right to increase the sum\n            } else {\n                right--; // Move right pointer to the left to decrease the sum\n            }\n        }\n    }\n    \n    return false; // No triplet found\n}\n\n"}
{"task_id": "CPP/13", "generation": "#include <iostream>\nusing namespace std;\n\nint greatest_common_divisor(int a, int b) {\n    // Ensure a and b are non-negative\n    a = abs(a);\n    b = abs(b);\n    \n    // Euclidean algorithm\n    while (b != 0) {\n        int temp = b;\n        b = a % b; // Remainder of a divided by b\n        a = temp;  // Assign b to a\n    }\n    return a; // When b is 0, a is the GCD\n}\n\n"}
{"task_id": "CPP/130", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> tri(int n) {\n    vector<int> tribonacci(n + 1);\n    \n    for (int i = 0; i <= n; i++) {\n        if (i == 1) {\n            tribonacci[i] = 3; // Base case\n        } else if (i % 2 == 0) {\n            tribonacci[i] = 1 + i / 2; // Even case\n        } else {\n            // Odd case: tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1)\n            // We need to ensure we have calculated tri(n - 1) and tri(n - 2)\n            int tri_n_minus_1 = (i - 1 >= 0) ? tribonacci[i - 1] : 0;\n            int tri_n_minus_2 = (i - 2 >= 0) ? tribonacci[i - 2] : 0;\n            int tri_n_plus_1 = (i + 1 <= n) ? (1 + (i + 1) / 2) : 0; // Calculate tri(n + 1) directly\n            \n            tribonacci[i] = tri_n_minus_1 + tri_n_minus_2 + tri_n_plus_1; // Calculate odd case\n        }\n    }\n    \n    return tribonacci;\n}\n"}
{"task_id": "CPP/60", "generation": "#include <iostream>\nusing namespace std;\n\nint sum_to_n(int n) {\n    return n * (n + 1) / 2; // Using the formula for the sum of the first n natural numbers\n}\n\n"}
{"task_id": "CPP/23", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint strlen(const string& str) {\n    return str.size(); // or str.length();\n}\n\n"}
{"task_id": "CPP/46", "generation": "#include <iostream>\nusing namespace std;\n\nint fib4(int n) {\n    // Handle base cases\n    if (n == 0) return 0;\n    if (n == 1) return 0;\n    if (n == 2) return 2;\n    if (n == 3) return 0;\n\n    // Initialize the first four values of the sequence\n    int fib[4] = {0, 0, 2, 0};\n    int result = 0;\n\n    // Compute the sequence iteratively\n    for (int i = 4; i <= n; i++) {\n        result = fib[0] + fib[1] + fib[2] + fib[3]; // fib4(n) = fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\n        \n        // Update the array to hold the last four values\n        fib[0] = fib[1];\n        fib[1] = fib[2];\n        fib[2] = fib[3];\n        fib[3] = result; // Store the current result as the last value\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/51", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nstring remove_vowels(string text) {\n    string result;\n    for (char c : text) {\n        // Check if the character is not a vowel\n        if (c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u' &&\n            c != 'A' && c != 'E' && c != 'I' && c != 'O' && c != 'U') {\n            result += c; // Append non-vowel characters to result\n        }\n    }\n    return result; // Return the string without vowels\n}\n\n"}
{"task_id": "CPP/18", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint how_many_times(string str, string substring) {\n    if (substring.empty()) {\n        return 0; // If the substring is empty, return 0\n    }\n\n    int count = 0;\n    size_t pos = 0;\n\n    // Loop to find all occurrences of the substring\n    while ((pos = str.find(substring, pos)) != string::npos) {\n        count++;\n        pos++; // Move to the next character to allow overlapping\n    }\n\n    return count;\n}\n\n"}
{"task_id": "CPP/143", "generation": "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int n) {\n    if (n <= 1) return false; // 0 and 1 are not prime numbers\n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0) return false; // Found a divisor, not prime\n    }\n    return true; // No divisors found, it's prime\n}\n\n// Function to extract words with prime lengths from a sentence\nstring words_in_sentence(string sentence) {\n    stringstream ss(sentence);\n    string word;\n    vector<string> prime_length_words;\n\n    // Split the sentence into words\n    while (ss >> word) {\n        // Check if the length of the word is prime\n        if (is_prime(word.length())) {\n            prime_length_words.push_back(word);\n        }\n    }\n\n    // Join the words with prime lengths into a single string\n    string result;\n    for (size_t i = 0; i < prime_length_words.size(); ++i) {\n        result += prime_length_words[i];\n        if (i < prime_length_words.size() - 1) {\n            result += \" \"; // Add space between words\n        }\n    }\n\n    return result;\n}\n\n// Example usage\n"}
{"task_id": "CPP/108", "generation": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\n// Helper function to calculate the sum of digits\nint sum_of_digits(int num) {\n    int sum = 0;\n    bool is_negative = num < 0;\n    num = abs(num); // Work with the absolute value for digit extraction\n\n    while (num > 0) {\n        int digit = num % 10;\n        sum += is_negative && (num / 10 == 0) ? -digit : digit; // Apply negative sign to the first digit\n        num /= 10;\n    }\n\n    return sum;\n}\n\n// Main function to count numbers with sum of digits > 0\nint count_nums(vector<int> n) {\n    int count = 0;\n\n    for (int num : n) {\n        if (sum_of_digits(num) > 0) {\n            count++;\n        }\n    }\n\n    return count;\n}\n\n// Test cases\n"}
{"task_id": "CPP/43", "generation": "#include <iostream>\n#include <vector>\n#include <unordered_set>\nusing namespace std;\n\nbool pairs_sum_to_zero(vector<int> l) {\n    unordered_set<int> seen; // Set to store the numbers we have seen\n\n    for (int num : l) {\n        // Check if the negation of the current number exists in the set\n        if (seen.count(-num)) {\n            return true; // Found a pair that sums to zero\n        }\n        seen.insert(num); // Add the current number to the set\n    }\n    \n    return false; // No pairs found that sum to zero\n}\n\n// Test cases\n"}
{"task_id": "CPP/70", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> strange_sort_list(vector<int> lst) {\n    // Sort the input list\n    sort(lst.begin(), lst.end());\n    \n    vector<int> result;\n    int left = 0; // Pointer for the minimum values\n    int right = lst.size() - 1; // Pointer for the maximum values\n    \n    // Alternate between the minimum and maximum values\n    while (left <= right) {\n        if (left == right) {\n            result.push_back(lst[left]); // If both pointers meet, add the last element\n        } else {\n            result.push_back(lst[left]); // Add the minimum\n            result.push_back(lst[right]); // Add the maximum\n        }\n        left++;\n        right--;\n    }\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/63", "generation": "#include <iostream>\nusing namespace std;\n\nint fibfib(int n) {\n    // Base cases\n    if (n == 0) return 0;\n    if (n == 1) return 0;\n    if (n == 2) return 1;\n\n    // Variables to store the last three values of the sequence\n    int a = 0; // fibfib(0)\n    int b = 0; // fibfib(1)\n    int c = 1; // fibfib(2)\n    int result;\n\n    // Iteratively compute fibfib(n)\n    for (int i = 3; i <= n; ++i) {\n        result = a + b + c; // fibfib(n) = fibfib(n-1) + fibfib(n-2) + fibfib(n-3)\n        a = b; // Move to the next value\n        b = c; // Move to the next value\n        c = result; // Update the current value\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/89", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring encrypt(string s) {\n    string encrypted = \"\";\n    \n    for (char c : s) {\n        if (c >= 'a' && c <= 'z') {\n            // Shift character by 4 positions\n            char newChar = c + 4;\n            // Wrap around if it goes past 'z'\n            if (newChar > 'z') {\n                newChar -= 26; // Wrap around to the start of the alphabet\n            }\n            encrypted += newChar;\n        } else {\n            // If not a lowercase letter, keep it unchanged\n            encrypted += c;\n        }\n    }\n    \n    return encrypted;\n}\n\n"}
{"task_id": "CPP/26", "generation": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nvector<int> remove_duplicates(vector<int> numbers) {\n    unordered_map<int, int> count_map;\n    \n    // Count occurrences of each number\n    for (int num : numbers) {\n        count_map[num]++;\n    }\n    \n    vector<int> result;\n    \n    // Add elements that occur only once to the result\n    for (int num : numbers) {\n        if (count_map[num] == 1) {\n            result.push_back(num);\n        }\n    }\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/104", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// Helper function to check if a number contains any even digits\nbool has_even_digit(int num) {\n    while (num > 0) {\n        int digit = num % 10; // Get the last digit\n        if (digit % 2 == 0) { // Check if the digit is even\n            return true; // Found an even digit\n        }\n        num /= 10; // Remove the last digit\n    }\n    return false; // No even digits found\n}\n\nvector<int> unique_digits(vector<int> x) {\n    vector<int> result;\n\n    // Iterate through the input vector\n    for (int num : x) {\n        // If the number does not contain any even digits, add it to the result\n        if (!has_even_digit(num)) {\n            result.push_back(num);\n        }\n    }\n\n    // Sort the result vector in increasing order\n    sort(result.begin(), result.end());\n\n    return result; // Return the sorted vector\n}\n\n// Example usage\n"}
{"task_id": "CPP/90", "generation": "#include <iostream>\n#include <vector>\n#include <set>\n#include <algorithm>\n\nusing namespace std;\n\nint next_smallest(vector<int> lst) {\n    // Use a set to store unique elements\n    set<int> unique_elements(lst.begin(), lst.end());\n\n    // If there are fewer than 2 unique elements, return None (or -1)\n    if (unique_elements.size() < 2) {\n        return -1; // or you could use an optional type if using C++17 or later\n    }\n\n    // Convert the set back to a vector to access the second smallest element\n    vector<int> sorted_unique(unique_elements.begin(), unique_elements.end());\n\n    // Return the second smallest element\n    return sorted_unique[1];\n}\n\n"}
{"task_id": "CPP/126", "generation": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nbool is_sorted(vector<int> lst) {\n    // Check for duplicates\n    unordered_map<int, int> count_map;\n    for (int num : lst) {\n        count_map[num]++;\n        if (count_map[num] > 2) {\n            return false; // More than two occurrences found\n        }\n    }\n\n    // Check if the vector is sorted\n    for (size_t i = 1; i < lst.size(); i++) {\n        if (lst[i] < lst[i - 1]) {\n            return false; // Found an element that is less than the previous one\n        }\n    }\n\n    return true; // The vector is sorted and has no duplicates\n}\n\n"}
{"task_id": "CPP/68", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> pluck(vector<int> arr) {\n    int smallest_even_value = -1; // Initialize to -1 to indicate no even value found\n    int smallest_even_index = -1; // Initialize to -1 to indicate no index found\n\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] % 2 == 0) { // Check if the number is even\n            if (smallest_even_value == -1 || arr[i] < smallest_even_value) {\n                smallest_even_value = arr[i];\n                smallest_even_index = i;\n            }\n        }\n    }\n\n    // If no even value was found, return an empty vector\n    if (smallest_even_value == -1) {\n        return {};\n    }\n\n    // Return the smallest even value and its index\n    return {smallest_even_value, smallest_even_index};\n}\n\n// Example usage\n"}
{"task_id": "CPP/58", "generation": "#include <iostream>\n#include <vector>\n#include <set>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> common(vector<int> l1, vector<int> l2) {\n    // Use a set to store unique elements from both vectors\n    set<int> set1(l1.begin(), l1.end());\n    set<int> set2(l2.begin(), l2.end());\n    \n    // Vector to store the result\n    vector<int> result;\n\n    // Use set_intersection to find common elements\n    set_intersection(set1.begin(), set1.end(),\n                     set2.begin(), set2.end(),\n                     back_inserter(result));\n\n    return result; // Return the sorted unique common elements\n}\n\n"}
{"task_id": "CPP/112", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <unordered_set>\n\nusing namespace std;\n\nvector<string> reverse_delete(string s, string c) {\n    // Use an unordered_set for fast lookup of characters to delete\n    unordered_set<char> chars_to_delete(c.begin(), c.end());\n    \n    // Create a new string to store the result after deletion\n    string result;\n    \n    // Iterate through the original string and build the result\n    for (char ch : s) {\n        if (chars_to_delete.find(ch) == chars_to_delete.end()) {\n            result += ch; // Add character to result if it's not in chars_to_delete\n        }\n    }\n    \n    // Check if the result string is a palindrome\n    string reversed_result = result;\n    reverse(reversed_result.begin(), reversed_result.end());\n    bool is_palindrome = (result == reversed_result);\n    \n    // Prepare the output vector\n    vector<string> output;\n    output.push_back(result);\n    output.push_back(is_palindrome ? \"True\" : \"False\");\n    \n    return output;\n}\n\n// Example usage\n"}
{"task_id": "CPP/96", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Helper function to check if a number is prime\nbool is_prime(int num) {\n    if (num <= 1) return false; // 0 and 1 are not prime numbers\n    for (int i = 2; i * i <= num; i++) {\n        if (num % i == 0) return false; // Found a divisor, not prime\n    }\n    return true; // No divisors found, it's prime\n}\n\n// Function to count prime numbers less than n\nvector<int> count_up_to(int n) {\n    vector<int> primes;\n    for (int i = 2; i < n; i++) {\n        if (is_prime(i)) {\n            primes.push_back(i); // Add prime number to the vector\n        }\n    }\n    return primes; // Return the vector of prime numbers\n}\n\n// Main function for testing\n"}
{"task_id": "CPP/157", "generation": "#include <stdio.h>\n#include <math.h>\nusing namespace std;\n\nbool right_angle_triangle(float a, float b, float c) {\n    // Sort the sides to identify the longest side\n    float x = fmax(a, fmax(b, c)); // longest side\n    float y, z;\n\n    if (x == a) {\n        y = b;\n        z = c;\n    } else if (x == b) {\n        y = a;\n        z = c;\n    } else {\n        y = a;\n        z = b;\n    }\n\n    // Check the Pythagorean theorem\n    return (y * y + z * z) == (x * x);\n}\n\n"}
{"task_id": "CPP/99", "generation": "#include <iostream>\n#include <cmath>\n#include <string>\n\nusing namespace std;\n\nint closest_integer(string value) {\n    // Convert the string to a double\n    double num = stod(value);\n    \n    // Get the floor and ceiling of the number\n    int lower = floor(num);\n    int upper = ceil(num);\n    \n    // Check the distance to the lower and upper integers\n    double lower_distance = abs(num - lower);\n    double upper_distance = abs(num - upper);\n    \n    // If the distances are equal, round away from zero\n    if (lower_distance == upper_distance) {\n        if (num > 0) {\n            return upper; // Round up for positive numbers\n        } else {\n            return lower; // Round down for negative numbers\n        }\n    }\n    \n    // Otherwise, return the closest integer\n    return (lower_distance < upper_distance) ? lower : upper;\n}\n\n"}
{"task_id": "CPP/149", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nvector<string> sorted_list_sum(vector<string> lst) {\n    // Step 1: Remove strings with odd lengths\n    lst.erase(remove_if(lst.begin(), lst.end(), [](const string& s) {\n        return s.length() % 2 != 0; // Keep only even length strings\n    }), lst.end());\n\n    // Step 2: Sort the remaining strings by length and then alphabetically\n    sort(lst.begin(), lst.end(), [](const string& a, const string& b) {\n        if (a.length() == b.length()) {\n            return a < b; // Sort alphabetically if lengths are the same\n        }\n        return a.length() < b.length(); // Sort by length\n    });\n\n    // Step 3: Return the sorted vector\n    return lst;\n}\n\n// Example usage\n"}
{"task_id": "CPP/86", "generation": "#include <stdio.h>\n#include <string>\n#include <algorithm>\n#include <sstream>\nusing namespace std;\n\nstring anti_shuffle(string s) {\n    stringstream ss(s);\n    string word;\n    string result = \"\";\n\n    while (ss >> word) {\n        // Sort the characters in the word\n        sort(word.begin(), word.end());\n        result += word + \" \"; // Append sorted word and a space\n    }\n\n    // Remove the trailing space if there is any\n    if (!result.empty()) {\n        result.pop_back();\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/129", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvoid dfs(const vector<vector<int>>& grid, int x, int y, int k, vector<int>& currentPath, vector<int>& minPath) {\n    // If we have reached the length k, compare with the minimum path\n    if (currentPath.size() == k) {\n        if (minPath.empty() || currentPath < minPath) {\n            minPath = currentPath; // Update the minimum path\n        }\n        return;\n    }\n\n    // Directions for moving up, down, left, right\n    vector<pair<int, int>> directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n    \n    // Explore neighbors\n    for (const auto& dir : directions) {\n        int newX = x + dir.first;\n        int newY = y + dir.second;\n\n        // Check if the new position is within bounds\n        if (newX >= 0 && newX < grid.size() && newY >= 0 && newY < grid[0].size()) {\n            currentPath.push_back(grid[newX][newY]); // Add the new cell to the path\n            dfs(grid, newX, newY, k, currentPath, minPath); // Recur\n            currentPath.pop_back(); // Backtrack\n        }\n    }\n}\n\nvector<int> minPath(vector<vector<int>> grid, int k) {\n    vector<int> minPath; // To store the minimum path found\n    int n = grid.size();\n    \n    // Start DFS from every cell in the grid\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            vector<int> currentPath;\n            currentPath.push_back(grid[i][j]); // Start path with the current cell\n            dfs(grid, i, j, k, currentPath, minPath); // Explore paths\n        }\n    }\n    \n    return minPath; // Return the minimum path found\n}\n\n"}
{"task_id": "CPP/49", "generation": "#include <iostream>\nusing namespace std;\n\nint modp(int n, int p) {\n    if (p == 1) return 0; // Since any number mod 1 is 0\n    long long result = 1; // Use long long to prevent overflow\n    long long base = 2;   // The base is 2\n\n    // Exponentiation by squaring\n    while (n > 0) {\n        if (n % 2 == 1) { // If n is odd\n            result = (result * base) % p;\n        }\n        base = (base * base) % p; // Square the base\n        n /= 2; // Divide n by 2\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/156", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nstring int_to_mini_roman(int number) {\n    // Define the Roman numeral symbols and their corresponding integer values\n    vector<pair<int, string>> roman_numerals = {\n        {1000, \"m\"}, {900, \"cm\"}, {500, \"d\"}, {400, \"cd\"},\n        {100, \"c\"}, {90, \"xc\"}, {50, \"l\"}, {40, \"xl\"},\n        {10, \"x\"}, {9, \"ix\"}, {5, \"v\"}, {4, \"iv\"},\n        {1, \"i\"}\n    };\n\n    string result = \"\";\n\n    // Iterate through the defined Roman numeral pairs\n    for (const auto& pair : roman_numerals) {\n        while (number >= pair.first) {\n            result += pair.second; // Append the Roman numeral to the result\n            number -= pair.first;  // Decrease the number by the value of the Roman numeral\n        }\n    }\n\n    return result; // Return the final Roman numeral string\n}\n\n"}
{"task_id": "CPP/65", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nstring circular_shift(int x, int shift) {\n    // Convert the integer to a string to manipulate the digits\n    string x_str = to_string(x);\n    int n = x_str.length();\n    \n    // If shift is greater than the number of digits, reverse the string\n    if (shift > n) {\n        reverse(x_str.begin(), x_str.end());\n        return x_str;\n    }\n    \n    // Perform the circular shift\n    shift = shift % n;  // To handle cases where shift is greater than n\n    return x_str.substr(n - shift) + x_str.substr(0, n - shift);\n}\n"}
{"task_id": "CPP/9", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> rolling_max(const vector<int>& numbers) {\n    vector<int> result;\n    int current_max = INT_MIN; // Initialize to the smallest possible integer\n\n    for (int num : numbers) {\n        if (num > current_max) {\n            current_max = num; // Update the current maximum\n        }\n        result.push_back(current_max); // Add the current maximum to the result\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/158", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_set>\n#include <algorithm>\n\nusing namespace std;\n\nstring find_max(vector<string> words) {\n    string max_word;\n    int max_unique_count = 0;\n\n    for (const string& word : words) {\n        // Use a set to find unique characters\n        unordered_set<char> unique_chars(word.begin(), word.end());\n        int unique_count = unique_chars.size();\n\n        // Check if we found a new maximum or if we need to update for lexicographical order\n        if (unique_count > max_unique_count || \n            (unique_count == max_unique_count && (max_word.empty() || word < max_word))) {\n            max_unique_count = unique_count;\n            max_word = word;\n        }\n    }\n\n    return max_word;\n}\n\n"}
{"task_id": "CPP/8", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> sum_product(vector<int> numbers) {\n    int sum = 0;\n    int product = 1;\n\n    // Check if the vector is empty\n    if (numbers.empty()) {\n        return {sum, product}; // Return (0, 1)\n    }\n\n    // Calculate sum and product\n    for (int num : numbers) {\n        sum += num;      // Add to sum\n        product *= num;  // Multiply to product\n    }\n\n    return {sum, product}; // Return the results as a vector\n}\n\n"}
{"task_id": "CPP/95", "generation": "#include <iostream>\n#include <string>\n#include <map>\n#include <cctype>\n\nusing namespace std;\n\nbool check_dict_case(map<string, string> dict) {\n    // Check if the map is empty\n    if (dict.empty()) {\n        return false;\n    }\n\n    bool allLower = true;\n    bool allUpper = true;\n\n    // Iterate through each key in the map\n    for (const auto& pair : dict) {\n        const string& key = pair.first;\n\n        // Check if the key is a string (it is, since we are using map<string, string>)\n        // Check if the key is lower case or upper case\n        if (!key.empty()) {\n            for (char c : key) {\n                if (islower(c)) {\n                    allUpper = false; // Found a lower case letter\n                } else if (isupper(c)) {\n                    allLower = false; // Found an upper case letter\n                } else {\n                    // If the character is neither lower nor upper case, return false\n                    return false;\n                }\n            }\n        }\n    }\n\n    // Return true if all keys are either all lower or all upper case\n    return allLower || allUpper;\n}\n\n"}
{"task_id": "CPP/55", "generation": "#include <iostream>\nusing namespace std;\n\nint fib(int n) {\n    if (n <= 0) return 0; // Fibonacci(0) is 0\n    if (n == 1) return 1; // Fibonacci(1) is 1\n    return fib(n - 1) + fib(n - 2); // Recursive call\n}\n\n"}
{"task_id": "CPP/29", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<string> filter_by_prefix(const vector<string>& strings, const string& prefix) {\n    vector<string> filtered; // Vector to hold the filtered results\n\n    // Iterate through each string in the input vector\n    for (const string& str : strings) {\n        // Check if the string starts with the given prefix\n        if (str.find(prefix) == 0) { // find returns 0 if prefix is found at the start\n            filtered.push_back(str); // Add to the filtered results\n        }\n    }\n\n    return filtered; // Return the filtered vector\n}\n\n"}
{"task_id": "CPP/72", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool will_it_fly(vector<int> q, int w) {\n    // Check if the vector is palindromic\n    int n = q.size();\n    for (int i = 0; i < n / 2; i++) {\n        if (q[i] != q[n - 1 - i]) {\n            return false; // Not balanced\n        }\n    }\n\n    // Calculate the sum of the elements\n    int sum = 0;\n    for (int num : q) {\n        sum += num;\n    }\n\n    // Check the weight condition\n    return sum <= w; // Return true if the sum is less than or equal to w\n}\n\n"}
{"task_id": "CPP/54", "generation": "#include <iostream>\n#include <string>\n#include <set>\n\nusing namespace std;\n\nbool same_chars(string s0, string s1) {\n    set<char> chars0(s0.begin(), s0.end()); // Create a set from the first string\n    set<char> chars1(s1.begin(), s1.end()); // Create a set from the second string\n    \n    return chars0 == chars1; // Compare the two sets\n}\n\n"}
{"task_id": "CPP/91", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <vector>\n#include <cctype>\n\nusing namespace std;\n\nint is_bored(string S) {\n    int count = 0;\n    stringstream ss(S);\n    string sentence;\n\n    // Split the string into sentences based on '.', '?', and '!'\n    while (getline(ss, sentence, '.')) {\n        // Check for other delimiters\n        size_t pos = sentence.find_first_of(\"!?\");\n        if (pos != string::npos) {\n            sentence = sentence.substr(0, pos);\n        }\n\n        // Trim leading whitespace\n        size_t start = sentence.find_first_not_of(\" \\t\");\n        if (start != string::npos) {\n            sentence = sentence.substr(start);\n        }\n\n        // Check if the sentence starts with \"I\"\n        if (sentence.rfind(\"I \", 0) == 0 || sentence == \"I\") {\n            count++;\n        }\n    }\n\n    return count;\n}\n\n"}
{"task_id": "CPP/77", "generation": "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\nbool iscube(int a) {\n    // Calculate the cube root of the absolute value of a\n    int cubeRoot = round(pow(abs(a), 1.0 / 3.0));\n    \n    // Check if the cube of the rounded cube root equals a\n    return (cubeRoot * cubeRoot * cubeRoot == a) || \n           ((-cubeRoot) * (-cubeRoot) * (-cubeRoot) == a);\n}\n\n"}
{"task_id": "CPP/73", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint smallest_change(vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n\n    // Compare elements from the start and end moving towards the center\n    for (int i = 0; i < n / 2; i++) {\n        if (arr[i] != arr[n - 1 - i]) {\n            changes++; // Increment changes if elements do not match\n        }\n    }\n\n    return changes; // Return the total number of changes needed\n}\n\n"}
{"task_id": "CPP/71", "generation": "#include <stdio.h>\n#include <math.h>\n\nfloat triangle_area(float a, float b, float c) {\n    // Check if the sides form a valid triangle\n    if (a + b > c && a + c > b && b + c > a) {\n        // Calculate the semi-perimeter\n        float s = (a + b + c) / 2;\n        \n        // Calculate the area using Heron's formula\n        float area = sqrt(s * (s - a) * (s - b) * (s - c));\n        \n        // Return the area rounded to 2 decimal points\n        return round(area * 100) / 100; // Round to 2 decimal points\n    } else {\n        // Return -1 if the sides do not form a valid triangle\n        return -1;\n    }\n}\n\n"}
{"task_id": "CPP/82", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int num) {\n    if (num <= 1) return false; // 0 and 1 are not prime numbers\n    for (int i = 2; i * i <= num; i++) {\n        if (num % i == 0) return false; // Found a divisor, not prime\n    }\n    return true; // No divisors found, it is prime\n}\n\n// Function to check if the length of the string is prime\nbool prime_length(string str) {\n    int length = str.length(); // Get the length of the string\n    return is_prime(length); // Check if the length is prime\n}\n\n// Example usage\n"}
{"task_id": "CPP/114", "generation": "#include <iostream>\n#include <vector>\n#include <limits.h>\n\nusing namespace std;\n\nlong long minSubArraySum(vector<long long> nums) {\n    long long minSum = LLONG_MAX; // Initialize to maximum possible value\n    long long currentSum = 0; // This will hold the current subarray sum\n\n    for (long long num : nums) {\n        currentSum += num; // Add the current number to the current subarray sum\n        if (currentSum < minSum) {\n            minSum = currentSum; // Update minSum if currentSum is smaller\n        }\n        if (currentSum > 0) {\n            currentSum = 0; // Reset currentSum if it becomes positive\n        }\n    }\n\n    return minSum; // Return the minimum subarray sum found\n}\n\n"}
{"task_id": "CPP/138", "generation": "#include <stdio.h>\n\nbool is_equal_to_sum_even(int n) {\n    // Check if n is less than 8\n    if (n < 8) {\n        return false;\n    }\n    // Check if n is even\n    if (n % 2 != 0) {\n        return false;\n    }\n    // If n is even and at least 8, it can be expressed as the sum of 4 positive even numbers\n    return true;\n}\n\n"}
{"task_id": "CPP/132", "generation": "#include <stdio.h>\n#include <string>\n#include <stack>\nusing namespace std;\n\nbool is_nested(string str) {\n    stack<char> s;\n    bool nested = false;\n\n    for (char& c : str) {\n        if (c == '[') {\n            s.push(c);\n            if (s.size() > 1) {  // More than one opening bracket means nested\n                nested = true;\n            }\n        } else if (c == ']') {\n            if (!s.empty()) {\n                s.pop();\n            } else {\n                return false;  // Unmatched closing bracket\n            }\n        }\n    }\n\n    return nested && s.empty();  // Must be nested and all brackets must be matched\n}\n"}
{"task_id": "CPP/3", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool below_zero(vector<int> operations) {\n    int balance = 0; // Start with a balance of zero\n\n    for (int operation : operations) {\n        balance += operation; // Update the balance with the current operation\n        if (balance < 0) { // Check if the balance goes below zero\n            return true; // Return true if it does\n        }\n    }\n\n    return false; // Return false if the balance never goes below zero\n}\n\n"}
{"task_id": "CPP/142", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint sum_squares(vector<int> lst) {\n    int total_sum = 0; // Initialize the sum to 0\n\n    for (size_t i = 0; i < lst.size(); ++i) {\n        if (i % 3 == 0) {\n            // Index is a multiple of 3, square the entry\n            total_sum += lst[i] * lst[i];\n        } else if (i % 4 == 0) {\n            // Index is a multiple of 4 and not a multiple of 3, cube the entry\n            total_sum += lst[i] * lst[i] * lst[i];\n        } else {\n            // Index is neither a multiple of 3 nor 4, add the entry as is\n            total_sum += lst[i];\n        }\n    }\n\n    return total_sum; // Return the total sum\n}\n\n"}
{"task_id": "CPP/50", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring encode_shift(string s) {\n    // Returns encoded string by shifting every character by 5 in the alphabet.\n    string out;\n    for (char c : s) {\n        if (isalpha(c)) { // Check if the character is an alphabet\n            char base = islower(c) ? 'a' : 'A'; // Determine the base for lowercase or uppercase\n            char shifted = (c - base + 5) % 26 + base; // Shift and wrap around\n            out += shifted; // Append shifted character to output\n        } else {\n            out += c; // Non-alphabet characters are added unchanged\n        }\n    }\n    return out;\n}\n\nstring decode_shift(string s) {\n    // Takes as input string encoded with encode_shift function. Returns decoded string.\n    string out;\n    for (char c : s) {\n        if (isalpha(c)) { // Check if the character is an alphabet\n            char base = islower(c) ? 'a' : 'A'; // Determine the base for lowercase or uppercase\n            char shifted = (c - base - 5 + 26) % 26 + base; // Shift back and wrap around\n            out += shifted; // Append shifted character to output\n        } else {\n            out += c; // Non-alphabet characters are added unchanged\n        }\n    }\n    return out;\n}\n\n"}
{"task_id": "CPP/103", "generation": "#include <iostream>\n#include <string>\n#include <cmath>\n\nusing namespace std;\n\nstring rounded_avg(int n, int m) {\n    // Check if n is greater than m\n    if (n > m) {\n        return \"-1\";\n    }\n\n    // Calculate the average\n    double average = (n + m) / 2.0;\n\n    // Round down to the nearest integer\n    int rounded_average = floor(average);\n\n    // Convert the rounded average to binary\n    string binary = \"\";\n    if (rounded_average == 0) {\n        binary = \"0\";\n    } else {\n        while (rounded_average > 0) {\n            binary = to_string(rounded_average % 2) + binary;\n            rounded_average /= 2;\n        }\n    }\n\n    return binary;\n}\n\n"}
{"task_id": "CPP/57", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nbool monotonic(vector<float> l) {\n    if (l.size() < 2) return true; // A vector with less than 2 elements is trivially monotonic\n\n    bool increasing = true;\n    bool decreasing = true;\n\n    for (size_t i = 1; i < l.size(); ++i) {\n        if (l[i] > l[i - 1]) {\n            decreasing = false; // Found an increasing pair\n        } else if (l[i] < l[i - 1]) {\n            increasing = false; // Found a decreasing pair\n        }\n    }\n\n    return increasing || decreasing; // Return true if either is true\n}\n\n"}
{"task_id": "CPP/28", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nstring concatenate(vector<string> strings) {\n    string result; // Initialize an empty string to hold the concatenated result\n    for (const string& str : strings) { // Iterate through each string in the vector\n        result += str; // Append the current string to the result\n    }\n    return result; // Return the concatenated string\n}\n\n"}
{"task_id": "CPP/39", "generation": "#include <iostream>\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int num) {\n    if (num <= 1) return false; // 0 and 1 are not prime numbers\n    for (int i = 2; i * i <= num; i++) {\n        if (num % i == 0) return false; // Found a divisor, not prime\n    }\n    return true; // No divisors found, it's prime\n}\n\n// Function to return the n-th Fibonacci number\nint fibonacci(int n) {\n    if (n == 0) return 0;\n    if (n == 1) return 1;\n    int a = 0, b = 1, c;\n    for (int i = 2; i <= n; i++) {\n        c = a + b;\n        a = b;\n        b = c;\n    }\n    return b; // Return the n-th Fibonacci number\n}\n\n// Function to return the n-th Fibonacci prime\nint prime_fib(int n) {\n    int count = 0; // Count of prime Fibonacci numbers\n    int i = 0; // Fibonacci index\n    while (true) {\n        int fib_num = fibonacci(i); // Get the i-th Fibonacci number\n        if (is_prime(fib_num)) { // Check if it's prime\n            count++; // Increment count of prime Fibonacci numbers\n            if (count == n) { // If we found the n-th prime Fibonacci\n                return fib_num; // Return the number\n            }\n        }\n        i++; // Move to the next Fibonacci number\n    }\n}\n\n"}
{"task_id": "CPP/45", "generation": "#include <stdio.h>\n#include <math.h>\n\nfloat triangle_area(float a, float h) {\n    return 0.5 * a * h; // Calculate the area using the formula\n}\n\n"}
{"task_id": "CPP/145", "generation": "#include <stdio.h>\n#include <math.h>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to calculate the sum of digits of a number\nint digit_sum(int n) {\n    int sum = 0;\n    n = abs(n); // Take the absolute value to ignore the negative sign\n    while (n > 0) {\n        sum += n % 10; // Add the last digit to sum\n        n /= 10; // Remove the last digit\n    }\n    return sum;\n}\n\n// Main function to order the vector by the sum of digits\nvector<int> order_by_points(vector<int> nums) {\n    vector<int> indexed_nums = nums; // Create a copy to maintain original indices\n    sort(indexed_nums.begin(), indexed_nums.end(), [&](int a, int b) {\n        int sum_a = digit_sum(a);\n        int sum_b = digit_sum(b);\n        // Compare by digit sum, then by original index\n        return sum_a == sum_b ? (find(nums.begin(), nums.end(), a) < find(nums.begin(), nums.end(), b)) : (sum_a < sum_b);\n    });\n    return indexed_nums;\n}\n"}
{"task_id": "CPP/84", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring solve(int N) {\n    // Step 1: Calculate the sum of digits\n    int sum = 0;\n    while (N > 0) {\n        sum += N % 10; // Add the last digit to sum\n        N /= 10;       // Remove the last digit\n    }\n\n    // Step 2: Convert the sum to binary\n    string binary = \"\";\n    if (sum == 0) {\n        return \"0\"; // Handle the case where the sum is 0\n    }\n    \n    while (sum > 0) {\n        binary = to_string(sum % 2) + binary; // Prepend the binary digit\n        sum /= 2; // Divide by 2 to shift right\n    }\n\n    // Step 3: Return the binary string\n    return binary;\n}\n\n"}
{"task_id": "CPP/113", "generation": "#include <vector>\n#include <string>\n#include <sstream>\nusing namespace std;\n\nvector<string> odd_count(vector<string> lst) {\n    vector<string> result;\n    \n    for (const string& str : lst) {\n        int odd_count = 0;\n        \n        // Count odd digits\n        for (char ch : str) {\n            if ((ch - '0') % 2 != 0) {\n                odd_count++;\n            }\n        }\n        \n        // Create the formatted output string\n        stringstream ss;\n        ss << \"the number of odd elements \" << odd_count \n           << \"n the str\" << odd_count \n           << \"ng \" << odd_count \n           << \" of the \" << odd_count << \"nput.\";\n        \n        result.push_back(ss.str());\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/36", "generation": "#include <iostream>\nusing namespace std;\n\nint countDigit7(int number) {\n    int count = 0;\n    while (number > 0) {\n        if (number % 10 == 7) {\n            count++;\n        }\n        number /= 10;\n    }\n    return count;\n}\n\nint fizz_buzz(int n) {\n    int totalCount = 0;\n    for (int i = 1; i < n; i++) {\n        if (i % 11 == 0 || i % 13 == 0) {\n            totalCount += countDigit7(i);\n        }\n    }\n    return totalCount;\n}\n\n"}
{"task_id": "CPP/144", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nbool simplify(string x, string n) {\n    // Split the first fraction x\n    size_t pos = x.find('/');\n    int num1 = stoi(x.substr(0, pos)); // numerator of x\n    int den1 = stoi(x.substr(pos + 1)); // denominator of x\n\n    // Split the second fraction n\n    pos = n.find('/');\n    int num2 = stoi(n.substr(0, pos)); // numerator of n\n    int den2 = stoi(n.substr(pos + 1)); // denominator of n\n\n    // Calculate the product of the fractions\n    // (num1/den1) * (num2/den2) = (num1 * num2) / (den1 * den2)\n    int numerator = num1 * num2;\n    int denominator = den1 * den2;\n\n    // Check if the result is a whole number\n    return (numerator % denominator == 0);\n}\n\n"}
{"task_id": "CPP/0", "generation": "#include <iostream>\n#include <vector>\n#include <cmath> // for std::abs\n\nusing namespace std;\n\nbool has_close_elements(const vector<float>& numbers, float threshold) {\n    // Iterate through each pair of numbers\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        for (size_t j = i + 1; j < numbers.size(); ++j) {\n            // Check if the absolute difference is less than the threshold\n            if (fabs(numbers[i] - numbers[j]) < threshold) {\n                return true; // Found two close elements\n            }\n        }\n    }\n    return false; // No close elements found\n}\n\n"}
{"task_id": "CPP/17", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nvector<int> parse_music(string music_string) {\n    vector<int> beats;\n    stringstream ss(music_string);\n    string note;\n\n    while (ss >> note) {\n        if (note == \"o\") {\n            beats.push_back(4); // whole note\n        } else if (note == \"o|\") {\n            beats.push_back(2); // half note\n        } else if (note == \".|\") {\n            beats.push_back(1); // quarter note\n        }\n    }\n\n    return beats;\n}\n\n"}
{"task_id": "CPP/47", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nfloat median(vector<float> l) {\n    // Sort the vector\n    sort(l.begin(), l.end());\n    \n    // Get the size of the vector\n    size_t size = l.size();\n    \n    // Calculate median\n    if (size % 2 == 0) {\n        // If even, average the two middle elements\n        return (l[size / 2 - 1] + l[size / 2]) / 2.0;\n    } else {\n        // If odd, return the middle element\n        return l[size / 2];\n    }\n}\n\n"}
{"task_id": "CPP/75", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\n// Function to generate a list of prime numbers less than 100\nvector<int> generate_primes() {\n    vector<int> primes;\n    for (int i = 2; i < 100; i++) {\n        if (is_prime(i)) {\n            primes.push_back(i);\n        }\n    }\n    return primes;\n}\n\n// Function to check if the number is the multiplication of 3 prime numbers\nbool is_multiply_prime(int a) {\n    vector<int> primes = generate_primes();\n    int size = primes.size();\n    \n    // Check all combinations of three primes\n    for (int i = 0; i < size; i++) {\n        for (int j = i; j < size; j++) {\n            for (int k = j; k < size; k++) {\n                if (primes[i] * primes[j] * primes[k] == a) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n\n"}
{"task_id": "CPP/124", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nbool valid_date(string date) {\n    // Check if the date string is empty\n    if (date.empty()) {\n        return false;\n    }\n\n    // Check if the date is in the format mm-dd-yyyy\n    if (date.size() != 10 || date[2] != '-' || date[5] != '-') {\n        return false;\n    }\n\n    // Extract month, day, and year\n    int month, day, year;\n    stringstream ss(date);\n    string monthStr, dayStr, yearStr;\n\n    getline(ss, monthStr, '-');\n    getline(ss, dayStr, '-');\n    getline(ss, yearStr);\n\n    // Convert strings to integers\n    month = stoi(monthStr);\n    day = stoi(dayStr);\n    year = stoi(yearStr);\n\n    // Check if month is valid\n    if (month < 1 || month > 12) {\n        return false;\n    }\n\n    // Check if day is valid based on the month\n    if (month == 2) {\n        // February: check for leap year\n        if (day < 1 || day > 29) {\n            return false;\n        }\n        // Check for leap year\n        if (day == 29 && (year % 4 != 0 || (year % 100 == 0 && year % 400 != 0))) {\n            return false;\n        }\n    } else if (month == 4 || month == 6 || month == 9 || month == 11) {\n        // Months with 30 days\n        if (day < 1 || day > 30) {\n            return false;\n        }\n    } else {\n        // Months with 31 days\n        if (day < 1 || day > 31) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\n"}
{"task_id": "CPP/101", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nvector<string> words_string(string s) {\n    vector<string> words;\n    string word;\n    // Replace commas with spaces to simplify splitting\n    for (char& c : s) {\n        if (c == ',') {\n            c = ' ';\n        }\n    }\n    \n    // Use stringstream to split the string\n    stringstream ss(s);\n    while (ss >> word) {\n        words.push_back(word);\n    }\n    \n    return words;\n}\n\n"}
{"task_id": "CPP/14", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> all_prefixes(string str) {\n    vector<string> prefixes; // Vector to store prefixes\n    for (size_t i = 1; i <= str.length(); ++i) {\n        prefixes.push_back(str.substr(0, i)); // Add prefix from start to current index\n    }\n    return prefixes; // Return the vector of prefixes\n}\n\n"}
{"task_id": "CPP/141", "generation": "#include <iostream>\n#include <string>\n#include <cctype>\n\nusing namespace std;\n\nstring file_name_check(string file_name) {\n    // Check for exactly one dot\n    size_t dot_pos = file_name.find('.');\n    if (dot_pos == string::npos || file_name.find('.', dot_pos + 1) != string::npos) {\n        return \"No\";\n    }\n\n    // Split the file name into name and extension\n    string name = file_name.substr(0, dot_pos);\n    string extension = file_name.substr(dot_pos + 1);\n\n    // Check if the name is empty\n    if (name.empty() || !isalpha(name[0])) {\n        return \"No\";\n    }\n\n    // Check the extension\n    if (extension != \"txt\" && extension != \"exe\" && extension != \"dll\") {\n        return \"No\";\n    }\n\n    // Count the digits in the file name\n    int digit_count = 0;\n    for (char c : file_name) {\n        if (isdigit(c)) {\n            digit_count++;\n        }\n    }\n\n    // Check if there are more than three digits\n    if (digit_count > 3) {\n        return \"No\";\n    }\n\n    return \"Yes\";\n}\n\n"}
{"task_id": "CPP/123", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\n\nusing namespace std;\n\nvector<int> get_odd_collatz(int n) {\n    set<int> odd_numbers; // Use a set to avoid duplicates\n\n    // Generate the Collatz sequence\n    while (n != 1) {\n        if (n % 2 != 0) { // Check if n is odd\n            odd_numbers.insert(n); // Insert odd number into the set\n        }\n        // Apply the Collatz rules\n        if (n % 2 == 0) {\n            n /= 2; // If n is even, divide by 2\n        } else {\n            n = 3 * n + 1; // If n is odd, apply 3n + 1\n        }\n    }\n    // Include 1, which is always part of the sequence\n    odd_numbers.insert(1);\n\n    // Convert the set to a vector\n    vector<int> result(odd_numbers.begin(), odd_numbers.end());\n    // Sort the vector (though it should already be sorted due to set)\n    sort(result.begin(), result.end());\n\n    return result;\n}\n\n"}
{"task_id": "CPP/148", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n\nusing namespace std;\n\nvector<string> bf(string planet1, string planet2) {\n    // Define the order of planets\n    vector<string> planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n    \n    // Create a map for quick index lookup\n    unordered_map<string, int> planetIndex;\n    for (int i = 0; i < planets.size(); ++i) {\n        planetIndex[planets[i]] = i;\n    }\n    \n    // Check if both planets are valid\n    if (planetIndex.find(planet1) == planetIndex.end() || planetIndex.find(planet2) == planetIndex.end()) {\n        return {}; // Return empty vector if either planet is invalid\n    }\n    \n    // Get the indices of the planets\n    int index1 = planetIndex[planet1];\n    int index2 = planetIndex[planet2];\n    \n    // Ensure index1 is less than index2\n    if (index1 > index2) {\n        swap(index1, index2);\n    }\n    \n    // Collect planets in between\n    vector<string> result;\n    for (int i = index1 + 1; i < index2; ++i) {\n        result.push_back(planets[i]);\n    }\n    \n    return result;\n}\n\n// Example usage\n"}
{"task_id": "CPP/133", "generation": "#include <iostream>\n#include <cmath>\n#include <vector>\nusing namespace std;\n\nint sum_squares(vector<float> lst) {\n    int sum = 0;\n    for (float num : lst) {\n        int rounded = ceil(num); // Round to the upper integer\n        sum += rounded * rounded; // Square the rounded value and add to sum\n    }\n    return sum;\n}\n\n"}
{"task_id": "CPP/109", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool move_one_ball(vector<int> arr) {\n    int n = arr.size();\n    \n    // If the array is empty, return true\n    if (n == 0) return true;\n\n    int count = 0; // To count the number of breaks in the order\n\n    // Loop through the array to count the number of times the order breaks\n    for (int i = 0; i < n; i++) {\n        if (arr[i] > arr[(i + 1) % n]) {\n            count++;\n        }\n    }\n\n    // If there is at most one break, we can sort the array by right shifts\n    return count <= 1;\n}\n\n// Example usage\n"}
{"task_id": "CPP/100", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> make_a_pile(int n) {\n    vector<int> stones;\n    int current_stones = n; // Start with n stones for the first level\n\n    for (int i = 0; i < n; ++i) {\n        stones.push_back(current_stones); // Add the current level's stones to the vector\n        // Determine the next number of stones based on the current level's count\n        if (current_stones % 2 == 0) {\n            current_stones += 2; // If current is even, add 2 for the next even number\n        } else {\n            current_stones += 2; // If current is odd, add 2 for the next odd number\n        }\n    }\n\n    return stones;\n}\n\n"}
{"task_id": "CPP/150", "generation": "#include <stdio.h>\n\nbool is_prime(int n) {\n    if (n <= 1) return false; // 0 and 1 are not prime numbers\n    for (int i = 2; i * i <= n; i++) { // Check for factors up to the square root of n\n        if (n % i == 0) return false; // If n is divisible by i, it's not prime\n    }\n    return true; // n is prime\n}\n\nint x_or_y(int n, int x, int y) {\n    if (is_prime(n)) {\n        return x; // Return x if n is prime\n    } else {\n        return y; // Return y if n is not prime\n    }\n}\n\n"}
{"task_id": "CPP/153", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nstring Strongest_Extension(string class_name, vector<string> extensions) {\n    int max_strength = -1; // Initialize to a value lower than any possible strength\n    string strongest_extension = \"\";\n\n    for (const string& extension : extensions) {\n        int CAP = 0;\n        int SM = 0;\n\n        // Calculate CAP and SM\n        for (char c : extension) {\n            if (isupper(c)) {\n                CAP++;\n            } else if (islower(c)) {\n                SM++;\n            }\n        }\n\n        // Calculate strength\n        int strength = CAP - SM;\n\n        // Check if this extension is stronger\n        if (strength > max_strength) {\n            max_strength = strength;\n            strongest_extension = extension;\n        }\n    }\n\n    // Return the result in the specified format\n    return class_name + \".\" + strongest_extension;\n}\n\n"}
{"task_id": "CPP/107", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to check if a number is a palindrome\nbool isPalindrome(int num) {\n    string str = to_string(num);\n    int left = 0, right = str.size() - 1;\n    while (left < right) {\n        if (str[left] != str[right]) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n    return true;\n}\n\nvector<int> even_odd_palindrome(int n) {\n    int evenCount = 0;\n    int oddCount = 0;\n\n    for (int i = 1; i <= n; i++) {\n        if (isPalindrome(i)) {\n            if (i % 2 == 0) {\n                evenCount++;\n            } else {\n                oddCount++;\n            }\n        }\n    }\n\n    return {evenCount, oddCount};\n}\n\n"}
{"task_id": "CPP/110", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring exchange(vector<int> lst1, vector<int> lst2) {\n    int oddCount = 0;\n    int evenCountInLst2 = 0;\n\n    // Count odd numbers in lst1\n    for (int num : lst1) {\n        if (num % 2 != 0) {\n            oddCount++;\n        }\n    }\n\n    // Count even numbers in lst2\n    for (int num : lst2) {\n        if (num % 2 == 0) {\n            evenCountInLst2++;\n        }\n    }\n\n    // Check if we can replace all odd numbers in lst1 with even numbers from lst2\n    if (oddCount <= evenCountInLst2) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n\n// Example usage\n"}
{"task_id": "CPP/111", "generation": "#include <stdio.h>\n#include <string>\n#include <map>\n#include <sstream>\n#include <algorithm>\nusing namespace std;\n\nmap<string, int> histogram(string test) {\n    map<string, int> count_map;\n    stringstream ss(test);\n    string letter;\n\n    // Count occurrences of each letter\n    while (ss >> letter) {\n        count_map[letter]++;\n    }\n\n    // Find the maximum occurrence count\n    int max_count = 0;\n    for (const auto& pair : count_map) {\n        max_count = max(max_count, pair.second);\n    }\n\n    // Create a result map for letters with the maximum count\n    map<string, int> result;\n    for (const auto& pair : count_map) {\n        if (pair.second == max_count) {\n            result[pair.first] = pair.second;\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/80", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_happy(string s) {\n    // Check if the length of the string is at least 3\n    if (s.length() < 3) {\n        return false;\n    }\n\n    // Iterate through the string and check every 3 consecutive characters\n    for (size_t i = 0; i <= s.length() - 3; ++i) {\n        // Check if the three characters are distinct\n        if (s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]) {\n            return false;\n        }\n    }\n\n    // If all groups of three are distinct, return true\n    return true;\n}\n\n"}
{"task_id": "CPP/41", "generation": "#include <stdio.h>\n\nint car_race_collision(int n) {\n    // Each car moving left to right will collide with each car moving right to left\n    return n * n; // Total collisions = n (left to right) * n (right to left)\n}\n\n"}
{"task_id": "CPP/116", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint countOnes(int x) {\n    return __builtin_popcount(x); // Count the number of 1s in the binary representation\n}\n\nvector<int> sort_array(vector<int> arr) {\n    // Sort the array based on the number of 1s in binary representation\n    // and then by the decimal value\n    sort(arr.begin(), arr.end(), [](int a, int b) {\n        if (countOnes(a) == countOnes(b)) {\n            return a < b; // If the number of 1s is the same, sort by value\n        }\n        return countOnes(a) < countOnes(b); // Sort by number of 1s\n    });\n    return arr;\n}\n"}
{"task_id": "CPP/61", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    int balance = 0; // Initialize a balance counter\n\n    for (char ch : brackets) {\n        if (ch == '(') {\n            balance++; // Increment for an opening bracket\n        } else if (ch == ')') {\n            balance--; // Decrement for a closing bracket\n        }\n\n        // If balance goes negative, it means there's a closing bracket without a matching opening bracket\n        if (balance < 0) {\n            return false;\n        }\n    }\n\n    // At the end, balance should be zero for all brackets to be matched\n    return balance == 0;\n}\n\n"}
{"task_id": "CPP/25", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> factorize(int n) {\n    vector<int> factors;\n    \n    // Check for number of 2s that divide n\n    while (n % 2 == 0) {\n        factors.push_back(2);\n        n /= 2;\n    }\n    \n    // n must be odd at this point, so we can skip even numbers\n    for (int i = 3; i * i <= n; i += 2) {\n        // While i divides n, add i and divide n\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n    \n    // This condition is to check if n is a prime number greater than 2\n    if (n > 2) {\n        factors.push_back(n);\n    }\n    \n    return factors;\n}\n\n"}
{"task_id": "CPP/137", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <boost/any.hpp>\n#include <sstream>\n\nusing namespace std;\n\nfloat convert_to_float(const boost::any& value) {\n    if (value.type() == typeid(string)) {\n        string str_value = boost::any_cast<string>(value);\n        replace(str_value.begin(), str_value.end(), ',', '.'); // Replace ',' with '.'\n        return stof(str_value); // Convert to float\n    }\n    return boost::any_cast<float>(value); // Assume it's already a float\n}\n\nboost::any compare_one(boost::any a, boost::any b) {\n    float a_float = convert_to_float(a);\n    float b_float = convert_to_float(b);\n\n    if (a_float > b_float) {\n        return a; // Return original type of a\n    } else if (b_float > a_float) {\n        return b; // Return original type of b\n    } else {\n        return \"None\"; // Return \"None\" if equal\n    }\n}\n\n"}
{"task_id": "CPP/102", "generation": "#include <iostream>\nusing namespace std;\n\nint choose_num(int x, int y) {\n    // Ensure x is less than or equal to y\n    if (x > y) {\n        return -1; // No valid range\n    }\n\n    // Start from the maximum of x and y\n    int max_num = y;\n\n    // Check if the maximum number is even\n    if (max_num % 2 != 0) {\n        max_num--; // If it's odd, decrement to get the largest even number\n    }\n\n    // Now check if max_num is within the range [x, y]\n    if (max_num >= x) {\n        return max_num; // Return the largest even number in the range\n    }\n\n    return -1; // If no even number is found in the range\n}\n\n"}
{"task_id": "CPP/10", "generation": "#include <algorithm> // Include for std::reverse\n#include <string>    // Include for std::string\nusing namespace std;\n\nbool is_palindrome(string str); // Function prototype\n\nbool is_palindrome(string str) {\n    // Test if given string is a palindrome \n    string s(str.rbegin(), str.rend());\n    return s == str;\n}\n\nstring make_palindrome(string str) {\n    if (str.empty()) {\n        return str; // Return empty string if input is empty\n    }\n\n    // Find the longest palindromic suffix\n    for (size_t i = 0; i < str.size(); i++) {\n        if (is_palindrome(str.substr(i))) {\n            // Create a new string for the prefix and reverse it\n            string prefix = str.substr(0, i);\n            reverse(prefix.begin(), prefix.end());\n            return str + prefix; // Append the reversed prefix\n        }\n    }\n\n    return str + string(str.rbegin(), str.rend()); // In case no palindromic suffix is found\n}\n"}
{"task_id": "CPP/76", "generation": "#include <iostream>\n#include <cmath>\nusing namespace std;\n\nbool is_simple_power(int x, int n) {\n    // Handle special cases\n    if (n <= 1) {\n        return (n == 1 && x == 1); // 1^k = 1 for any k, but 0^k is not defined for k > 0\n    }\n    if (x < 1) {\n        return false; // x must be a positive integer\n    }\n\n    // Check powers of n\n    int power = 1; // Start with n^0\n    while (power < x) {\n        power *= n; // Calculate n^k\n    }\n\n    return power == x; // Check if we found a match\n}\n\n"}
{"task_id": "CPP/94", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <cmath>\nusing namespace std;\n\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i <= sqrt(n); i++) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\nint sum_of_digits(int n) {\n    int sum = 0;\n    while (n > 0) {\n        sum += n % 10;\n        n /= 10;\n    }\n    return sum;\n}\n\nint skjkasdkd(vector<int> lst) {\n    int largest_prime = -1;\n    for (int num : lst) {\n        if (is_prime(num) && num > largest_prime) {\n            largest_prime = num;\n        }\n    }\n    if (largest_prime == -1) {\n        return 0; // No prime found\n    }\n    return sum_of_digits(largest_prime);\n}\n"}
{"task_id": "CPP/32", "generation": "#include <stdio.h>\n#include <math.h>\n#include <vector>\n#include <stdexcept>\n\nusing namespace std;\n\ndouble poly(vector<double> xs, double x) {\n    double sum = 0;\n    for (int i = 0; i < xs.size(); i++) {\n        sum += xs[i] * pow(x, i);\n    }\n    return sum;\n}\n\ndouble poly_derivative(vector<double> xs, double x) {\n    double sum = 0;\n    for (int i = 1; i < xs.size(); i++) {\n        sum += i * xs[i] * pow(x, i - 1);\n    }\n    return sum;\n}\n\ndouble find_zero(vector<double> xs) {\n    // Initial guess for the root\n    double x0 = 0.0; // You can choose a better initial guess based on the polynomial\n    double tolerance = 1e-7; // Tolerance for convergence\n    int max_iterations = 1000; // Maximum number of iterations\n    int iteration = 0;\n\n    while (iteration < max_iterations) {\n        double f_x0 = poly(xs, x0);\n        double f_prime_x0 = poly_derivative(xs, x0);\n\n        if (fabs(f_prime_x0) < 1e-10) { // Avoid division by zero\n            throw runtime_error(\"Derivative is too small; no convergence.\");\n        }\n\n        double x1 = x0 - f_x0 / f_prime_x0; // Newton-Raphson update\n\n        if (fabs(x1 - x0) < tolerance) { // Check for convergence\n            return x1;\n        }\n\n        x0 = x1; // Update x0 for the next iteration\n        iteration++;\n    }\n\n    throw runtime_error(\"Maximum iterations reached; no convergence.\");\n}\n\n"}
{"task_id": "CPP/33", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> sort_third(vector<int> l) {\n    // Step 1: Extract values at indices divisible by 3\n    vector<int> to_sort;\n    for (size_t i = 0; i < l.size(); ++i) {\n        if (i % 3 == 0) {\n            to_sort.push_back(l[i]);\n        }\n    }\n\n    // Step 2: Sort the extracted values\n    sort(to_sort.begin(), to_sort.end());\n\n    // Step 3: Replace the original values at indices divisible by 3 with sorted values\n    size_t sort_index = 0;\n    for (size_t i = 0; i < l.size(); ++i) {\n        if (i % 3 == 0) {\n            l[i] = to_sort[sort_index++];\n        }\n    }\n\n    return l;\n}\n\n"}
{"task_id": "CPP/88", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> sort_array(const vector<int>& array) {\n    // Create a copy of the original array\n    vector<int> sorted_array = array;\n\n    // Check for empty or single element vector\n    if (sorted_array.empty() || sorted_array.size() == 1) {\n        return sorted_array;\n    }\n\n    // Calculate the sum of the first and last elements\n    int sum = sorted_array.front() + sorted_array.back();\n\n    // Sort based on the sum being odd or even\n    if (sum % 2 == 0) {\n        // Even sum: sort in descending order\n        sort(sorted_array.rbegin(), sorted_array.rend());\n    } else {\n        // Odd sum: sort in ascending order\n        sort(sorted_array.begin(), sorted_array.end());\n    }\n\n    return sorted_array;\n}\n\n// Example usage\n"}
{"task_id": "CPP/15", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nstring string_sequence(int n) {\n    stringstream ss; // Create a stringstream to build the output string\n    for (int i = 0; i <= n; ++i) {\n        ss << i; // Add the current number to the stringstream\n        if (i < n) {\n            ss << \" \"; // Add a space after the number if it's not the last number\n        }\n    }\n    return ss.str(); // Convert the stringstream to a string and return it\n}\n\n"}
{"task_id": "CPP/163", "generation": "#include <iostream>\n#include <vector>\n#include <set>\nusing namespace std;\n\nvector<int> generate_integers(int a, int b) {\n    // Create a set to store unique even digits\n    set<int> even_digits;\n\n    // Determine the range\n    int start = min(a, b);\n    int end = max(a, b);\n\n    // Iterate through the range\n    for (int i = start; i <= end; ++i) {\n        // Check if the number is an even digit\n        if (i >= 0 && i < 10 && i % 2 == 0) {\n            even_digits.insert(i);\n        }\n    }\n\n    // Convert the set to a vector for the result\n    vector<int> result(even_digits.begin(), even_digits.end());\n    return result;\n}\n\n"}
{"task_id": "CPP/1", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cctype> // for isspace\n\nusing namespace std;\n\nvector<string> separate_paren_groups(string paren_string) {\n    vector<string> result;\n    string current_group;\n    int balance = 0;\n\n    for (char ch : paren_string) {\n        // Ignore spaces\n        if (isspace(ch)) {\n            continue;\n        }\n        \n        // Add the character to the current group\n        current_group += ch;\n\n        // Update balance\n        if (ch == '(') {\n            balance++;\n        } else if (ch == ')') {\n            balance--;\n        }\n\n        // When balance is zero, we have a complete group\n        if (balance == 0 && !current_group.empty()) {\n            result.push_back(current_group);\n            current_group.clear(); // Reset for the next group\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/69", "generation": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint search(vector<int> lst) {\n    unordered_map<int, int> frequencyMap;\n\n    // Count the frequency of each integer\n    for (int num : lst) {\n        frequencyMap[num]++;\n    }\n\n    int result = -1;\n\n    // Check for the greatest integer with the required frequency\n    for (const auto& pair : frequencyMap) {\n        int num = pair.first;\n        int freq = pair.second;\n\n        // Check if frequency is greater than or equal to the number itself\n        if (freq >= num) {\n            result = max(result, num);\n        }\n    }\n\n    return result;\n}\n\n// Example usage\n"}
{"task_id": "CPP/31", "generation": "#include <iostream>\nusing namespace std;\n\nbool is_prime(long long n) {\n    // Check if n is less than 2\n    if (n < 2) {\n        return false;\n    }\n    // Check for factors from 2 to the square root of n\n    for (long long i = 2; i * i <= n; i++) {\n        if (n % i == 0) {\n            return false; // n is divisible by i, hence not prime\n        }\n    }\n    return true; // n is prime\n}\n\n"}
{"task_id": "CPP/147", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint get_max_triples(int n) {\n    vector<int> a(n);\n    \n    // Step 1: Generate the vector a\n    for (int i = 1; i <= n; ++i) {\n        a[i - 1] = i * i - i + 1; // a[i] = i * i - i + 1\n    }\n    \n    // Step 2: Count occurrences of each remainder when divided by 3\n    int count[3] = {0, 0, 0};\n    for (int i = 0; i < n; ++i) {\n        count[a[i] % 3]++;\n    }\n    \n    // Step 3: Count valid triples\n    int totalTriples = 0;\n    \n    // Case 1: All three numbers have remainder 0\n    if (count[0] >= 3) {\n        totalTriples += (count[0] * (count[0] - 1) * (count[0] - 2)) / 6; // nC3\n    }\n    \n    // Case 2: All three numbers have remainder 1\n    if (count[1] >= 3) {\n        totalTriples += (count[1] * (count[1] - 1) * (count[1] - 2)) / 6; // nC3\n    }\n    \n    // Case 3: All three numbers have remainder 2\n    if (count[2] >= 3) {\n        totalTriples += (count[2] * (count[2] - 1) * (count[2] - 2)) / 6; // nC3\n    }\n    \n    // Case 4: One number from each remainder\n    totalTriples += count[0] * count[1] * count[2];\n    \n    return totalTriples;\n}\n\n"}
{"task_id": "CPP/105", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nvector<string> by_length(vector<int> arr) {\n    // Step 1: Filter the vector to keep only integers between 1 and 9\n    vector<int> filtered;\n    for (int num : arr) {\n        if (num >= 1 && num <= 9) {\n            filtered.push_back(num);\n        }\n    }\n\n    // Step 2: Sort the filtered vector\n    sort(filtered.begin(), filtered.end());\n\n    // Step 3: Reverse the sorted vector\n    reverse(filtered.begin(), filtered.end());\n\n    // Step 4: Map integers to their corresponding names\n    vector<string> result;\n    vector<string> names = {\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"};\n    \n    for (int num : filtered) {\n        result.push_back(names[num]);\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/22", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <boost/any.hpp>\n#include <list>\n#include <typeinfo>\n\ntypedef std::list<boost::any> list_any;\n\nstd::vector<int> filter_integers(list_any values) {\n    std::vector<int> result;\n\n    for (const auto& value : values) {\n        // Check if the value can be cast to int\n        if (value.type() == typeid(int)) {\n            result.push_back(boost::any_cast<int>(value));\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/52", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool below_threshold(vector<int> l, int t) {\n    for (int num : l) {\n        if (num >= t) {\n            return false; // Found a number that is not below the threshold\n        }\n    }\n    return true; // All numbers are below the threshold\n}\n\n"}
{"task_id": "CPP/154", "generation": "#include <string>\nusing namespace std;\n\nbool cycpattern_check(string a, string b) {\n    // Create a new string by concatenating 'b' with itself\n    string b_rotations = b + b;\n    \n    // Check if 'b' or any of its rotations is a substring of 'a'\n    return (b_rotations.find(a) != string::npos);\n}\n"}
{"task_id": "CPP/115", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint max_fill(vector<vector<int>> grid, int capacity) {\n    int total_lowers = 0;\n\n    // Iterate through each well (row in the grid)\n    for (const auto& well : grid) {\n        int water_units = 0;\n\n        // Count the number of water units (1s) in the current well\n        for (int water : well) {\n            water_units += water;\n        }\n\n        // Calculate the number of times we need to lower the bucket\n        if (water_units > 0) {\n            total_lowers += (water_units / capacity);\n            if (water_units % capacity != 0) {\n                total_lowers += 1; // If there's a remainder, we need one more lowering\n            }\n        }\n    }\n\n    return total_lowers;\n}\n\n"}
{"task_id": "CPP/131", "generation": "#include <stdio.h>\n\nint digits(int n) {\n    int product = 1; // Initialize product to 1\n    bool hasOdd = false; // Flag to check if we found any odd digits\n\n    while (n > 0) {\n        int digit = n % 10; // Get the last digit\n        if (digit % 2 != 0) { // Check if the digit is odd\n            product *= digit; // Multiply to the product\n            hasOdd = true; // Set the flag to true\n        }\n        n /= 10; // Remove the last digit\n    }\n\n    return hasOdd ? product : 0; // Return product if odd digits were found, otherwise return 0\n}\n\n"}
{"task_id": "CPP/37", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<float> sort_even(vector<float> l) {\n    // Create a vector to hold the even indexed values\n    vector<float> even_values;\n\n    // Extract even indexed values\n    for (size_t i = 0; i < l.size(); i += 2) {\n        even_values.push_back(l[i]);\n    }\n\n    // Sort the even indexed values\n    sort(even_values.begin(), even_values.end());\n\n    // Create a new vector to hold the result\n    vector<float> result(l.size());\n\n    // Fill the result vector\n    for (size_t i = 0; i < l.size(); ++i) {\n        if (i % 2 == 0) {\n            // Even index: use sorted value\n            result[i] = even_values[i / 2];\n        } else {\n            // Odd index: keep original value\n            result[i] = l[i];\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/92", "generation": "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\nbool any_int(float a, float b, float c) {\n    // Check if all numbers are integers\n    if (floor(a) != a || floor(b) != b || floor(c) != c) {\n        return false;\n    }\n    \n    // Check if one number is equal to the sum of the other two\n    return (a == b + c) || (b == a + c) || (c == a + b);\n}\n\n"}
{"task_id": "CPP/118", "generation": "#include <iostream>\n#include <string>\n#include <cctype> // for isalpha and tolower\n\nusing namespace std;\n\nstring get_closest_vowel(string word) {\n    // Define the set of vowels\n    string vowels = \"aeiouAEIOU\";\n    int n = word.length();\n\n    // We need to check for vowels between consonants\n    for (int i = n - 2; i > 0; i--) { // Start from the second last character to the second character\n        if (isalpha(word[i])) { // Check if the character is a letter\n            // Check if the current character is a vowel\n            if (vowels.find(word[i]) != string::npos) {\n                // Check if the characters before and after are consonants\n                if (isalpha(word[i - 1]) && isalpha(word[i + 1]) &&\n                    vowels.find(word[i - 1]) == string::npos && \n                    vowels.find(word[i + 1]) == string::npos) {\n                    return string(1, word[i]); // Return the vowel as a string\n                }\n            }\n        }\n    }\n    return \"\"; // Return empty string if no vowel found\n}\n\n// Example usage\n"}
{"task_id": "CPP/6", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nvector<int> parse_nested_parens(string paren_string) {\n    vector<int> result;\n    stringstream ss(paren_string);\n    string group;\n\n    while (ss >> group) {\n        int current_level = 0;\n        int max_level = 0;\n\n        for (char ch : group) {\n            if (ch == '(') {\n                current_level++;\n                if (current_level > max_level) {\n                    max_level = current_level;\n                }\n            } else if (ch == ')') {\n                current_level--;\n            }\n        }\n\n        // Add the maximum level of nesting for the current group to the result\n        result.push_back(max_level);\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/87", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<vector<int>> get_row(vector<vector<int>> lst, int x) {\n    vector<vector<int>> result;\n\n    // Iterate through each row\n    for (int i = 0; i < lst.size(); i++) {\n        // Iterate through each column in the current row\n        for (int j = 0; j < lst[i].size(); j++) {\n            // Check if the current element matches x\n            if (lst[i][j] == x) {\n                // Store the coordinates {row, column}\n                result.push_back({i, j});\n            }\n        }\n    }\n\n    // Sort the result first by row (ascending) and then by column (descending)\n    sort(result.begin(), result.end(), [](const vector<int>& a, const vector<int>& b) {\n        if (a[0] == b[0]) {\n            return a[1] > b[1]; // Sort by column in descending order\n        }\n        return a[0] < b[0]; // Sort by row in ascending order\n    });\n\n    return result;\n}\n\n// Example usage\n"}
{"task_id": "CPP/2", "generation": "#include <stdio.h>\n#include <math.h>\n\nfloat truncate_number(float number) {\n    // Get the integer part of the number\n    float integer_part = floor(number);\n    // Calculate the decimal part\n    float decimal_part = number - integer_part;\n    return decimal_part;\n}\n\n"}
{"task_id": "CPP/16", "generation": "#include <iostream>\n#include <set>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nint count_distinct_characters(string str) {\n    set<char> distinct_chars; // Set to store distinct characters\n\n    // Iterate through each character in the string\n    for (char c : str) {\n        // Convert character to lowercase and insert into the set\n        distinct_chars.insert(tolower(c));\n    }\n\n    // The size of the set gives the number of distinct characters\n    return distinct_chars.size();\n}\n\n"}
{"task_id": "CPP/135", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint can_arrange(vector<int> arr) {\n    int n = arr.size();\n    // Start from the second last element and go backwards\n    for (int i = n - 2; i >= 0; --i) {\n        // Check if the current element is less than the next one\n        if (arr[i] > arr[i + 1]) {\n            return i + 1; // Return the index of the element\n        }\n    }\n    return -1; // If no such element exists\n}\n\n"}
{"task_id": "CPP/106", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> f(int n) {\n    vector<int> result(n);\n    \n    for (int i = 1; i <= n; ++i) {\n        if (i % 2 == 0) { // i is even\n            // Calculate factorial of i\n            int factorial = 1;\n            for (int j = 1; j <= i; ++j) {\n                factorial *= j;\n            }\n            result[i - 1] = factorial; // Store in the vector (0-based index)\n        } else { // i is odd\n            // Calculate sum from 1 to i\n            int sum = (i * (i + 1)) / 2; // Using the formula for the sum of the first i natural numbers\n            result[i - 1] = sum; // Store in the vector (0-based index)\n        }\n    }\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/162", "generation": "#include <stdio.h>\n#include <string>\n#include <openssl/md5.h>\n#include <sstream>\n#include <iomanip>\n\nusing namespace std;\n\nstring string_to_md5(string text) {\n    if (text.empty()) {\n        return \"\"; // Return empty string to represent None in Python\n    }\n\n    unsigned char digest[MD5_DIGEST_LENGTH];\n    MD5((unsigned char*)text.c_str(), text.length(), digest);\n\n    // Convert the unsigned char array to a hexadecimal string\n    stringstream ss;\n    for (int i = 0; i < MD5_DIGEST_LENGTH; i++) {\n        ss << hex << setw(2) << setfill('0') << (int)digest[i];\n    }\n\n    return ss.str();\n}\n"}
{"task_id": "CPP/5", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvector<int> intersperse(vector<int> numbers, int delimiter) {\n    vector<int> result;\n\n    // Check if the input vector is empty\n    if (numbers.empty()) {\n        return result; // Return an empty vector\n    }\n\n    // Iterate through the input vector\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        result.push_back(numbers[i]); // Add the current number to the result\n        // If it's not the last element, add the delimiter\n        if (i < numbers.size() - 1) {\n            result.push_back(delimiter);\n        }\n    }\n\n    return result; // Return the result vector\n}\n\n"}
{"task_id": "CPP/97", "generation": "#include <iostream>\nusing namespace std;\n\nint multiply(int a, int b) {\n    // Get the unit digits\n    int unit_digit_a = abs(a) % 10; // Use abs to handle negative numbers\n    int unit_digit_b = abs(b) % 10; // Use abs to handle negative numbers\n    \n    // Calculate the product of the unit digits\n    return unit_digit_a * unit_digit_b;\n}\n\n"}
{"task_id": "CPP/44", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring change_base(int x, int base) {\n    if (base < 2 || base >= 10) {\n        return \"\"; // Invalid base\n    }\n    \n    if (x == 0) {\n        return \"0\"; // Special case for zero\n    }\n\n    string result = \"\";\n    \n    while (x > 0) {\n        int remainder = x % base; // Get the remainder\n        result = to_string(remainder) + result; // Prepend the remainder to the result\n        x /= base; // Divide x by the base\n    }\n    \n    return result; // Return the final result\n}\n\n"}
{"task_id": "CPP/161", "generation": "#include <iostream>\n#include <string>\n#include <cctype> // for isalpha, toupper, tolower\n\nusing namespace std;\n\nstring solve(string s) {\n    bool hasLetter = false;\n\n    // First, check if there are any letters in the string\n    for (char c : s) {\n        if (isalpha(c)) {\n            hasLetter = true;\n            break;\n        }\n    }\n\n    if (hasLetter) {\n        // If there are letters, reverse their case\n        for (char &c : s) {\n            if (isalpha(c)) {\n                // Reverse case\n                c = islower(c) ? toupper(c) : tolower(c);\n            }\n        }\n    } else {\n        // If there are no letters, reverse the entire string\n        reverse(s.begin(), s.end());\n    }\n\n    return s;\n}\n\n"}
{"task_id": "CPP/38", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nstring encode_cyclic(string s) { \n    // returns encoded string by cycling groups of three characters.  \n    int l = s.length();\n    string output;\n    for (int i = 0; i * 3 < l; i++) {\n        string x = s.substr(i * 3, 3);\n        if (x.length() == 3) {\n            x = x.substr(1) + x[0]; // Cycle the characters\n        }\n        output += x; // Append to output\n    }\n    return output;\n}\n\nstring decode_cyclic(string s) { \n    /*\n    takes as input string encoded with encode_cyclic function. Returns decoded string. \n    */\n    int l = s.length();\n    string output;\n    for (int i = 0; i * 3 < l; i++) {\n        string x = s.substr(i * 3, 3);\n        if (x.length() == 3) {\n            x = x[x.length() - 1] + x.substr(0, 2); // Reverse the cycle\n        }\n        output += x; // Append to output\n    }\n    return output;\n}\n\n"}
{"task_id": "CPP/93", "generation": "#include <stdio.h>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nstring encode(string message) {\n    string vowels = \"aeiouAEIOU\";\n    string encoded_message = \"\";\n\n    for (char c : message) { // Changed 'char char' to 'char c'\n        if (isalpha(c)) {\n            // Swap case\n            char new_char = islower(c) ? toupper(c) : tolower(c); // Changed 'char char' to 'char c'\n            \n            // Replace vowels\n            if (vowels.find(new_char) != string::npos) {\n                new_char += 2; // Shift the vowel two places ahead\n            }\n            \n            encoded_message += new_char;\n        } else {\n            encoded_message += c; // Keep non-alphabetic characters unchanged\n        }\n    }\n    \n    return encoded_message;\n}\n"}
{"task_id": "CPP/152", "generation": "#include <iostream>\n#include <vector>\n#include <cmath> // for abs function\n\nusing namespace std;\n\nvector<int> compare(vector<int> game, vector<int> guess) {\n    vector<int> result; // Vector to store the results\n    int size = game.size(); // Get the size of the input vectors\n\n    // Iterate through each match\n    for (int i = 0; i < size; i++) {\n        // Calculate the absolute difference and add to result\n        result.push_back(abs(game[i] - guess[i]));\n    }\n\n    return result; // Return the result vector\n}\n\n// Example usage\n"}
{"task_id": "CPP/62", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvector<float> derivative(const vector<float>& xs) {\n    vector<float> result;\n\n    // Start from the first coefficient (which corresponds to x^1)\n    for (size_t i = 1; i < xs.size(); ++i) {\n        // Calculate the derivative coefficient\n        result.push_back(xs[i] * i);\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/7", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<string> filter_by_substring(const vector<string>& strings, const string& substring) {\n    vector<string> filtered_strings; // Vector to hold the filtered results\n\n    // Iterate through each string in the input vector\n    for (const string& str : strings) {\n        // Check if the substring is found in the current string\n        if (str.find(substring) != string::npos) {\n            filtered_strings.push_back(str); // Add to the filtered results\n        }\n    }\n\n    return filtered_strings; // Return the filtered vector\n}\n\n"}
{"task_id": "CPP/24", "generation": "#include <iostream>\nusing namespace std;\n\nint largest_divisor(int n) {\n    // Start from n-1 and go down to 1\n    for (int i = n - 1; i > 0; i--) {\n        if (n % i == 0) { // Check if i is a divisor of n\n            return i; // Return the first divisor found\n        }\n    }\n    return 1; // In case n is 1, the largest divisor is 1\n}\n\n"}
{"task_id": "CPP/79", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring decimal_to_binary(int decimal) {\n    // Handle the case where the input is 0\n    if (decimal == 0) {\n        return \"db0db\";\n    }\n\n    string binary = \"\";\n    \n    // Convert decimal to binary\n    while (decimal > 0) {\n        // Prepend the binary digit (0 or 1)\n        binary = to_string(decimal % 2) + binary;\n        decimal /= 2; // Divide by 2 to shift right\n    }\n    \n    // Add the \"db\" prefix and suffix\n    return \"db\" + binary + \"db\";\n}\n\n"}
{"task_id": "CPP/155", "generation": "#include <iostream>\n#include <vector>\n#include <cmath> // for abs()\n\nusing namespace std;\n\nvector<int> even_odd_count(int num) {\n    // Initialize counts for even and odd digits\n    int even_count = 0;\n    int odd_count = 0;\n\n    // Work with the absolute value of the number\n    num = abs(num);\n\n    // If the number is 0, it has one even digit\n    if (num == 0) {\n        even_count = 1;\n    } else {\n        // Iterate through each digit\n        while (num > 0) {\n            int digit = num % 10; // Get the last digit\n            if (digit % 2 == 0) {\n                even_count++; // Increment even count\n            } else {\n                odd_count++; // Increment odd count\n            }\n            num /= 10; // Remove the last digit\n        }\n    }\n\n    // Return the counts as a vector\n    return {even_count, odd_count};\n}\n\n"}
{"task_id": "CPP/4", "generation": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nfloat mean_absolute_deviation(const vector<float>& numbers) {\n    if (numbers.empty()) {\n        return 0.0; // Return 0 for empty input\n    }\n\n    // Step 1: Calculate the mean\n    float sum = 0.0;\n    for (float num : numbers) {\n        sum += num;\n    }\n    float mean = sum / numbers.size();\n\n    // Step 2: Calculate the absolute differences and their average\n    float mad_sum = 0.0;\n    for (float num : numbers) {\n        mad_sum += fabs(num - mean);\n    }\n    \n    // Step 3: Return the average of absolute differences\n    return mad_sum / numbers.size();\n}\n\n"}
{"task_id": "CPP/56", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    int count = 0; // Initialize a counter for opening brackets\n\n    for (char ch : brackets) {\n        if (ch == '<') {\n            count++; // Increment for an opening bracket\n        } else if (ch == '>') {\n            count--; // Decrement for a closing bracket\n        }\n\n        // If count goes negative, there are unmatched closing brackets\n        if (count < 0) {\n            return false;\n        }\n    }\n\n    // If count is zero, all brackets are matched\n    return count == 0;\n}\n\n"}
{"task_id": "CPP/159", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> eat(int number, int need, int remaining) {\n    // Calculate how many carrots we can eat\n    int carrotsToEat = min(need, remaining);\n    \n    // Update the total number of eaten carrots\n    int totalEaten = number + carrotsToEat;\n    \n    // Calculate remaining carrots after eating\n    int remainingAfterEat = remaining - carrotsToEat;\n    \n    // Return the result as a vector\n    return {totalEaten, remainingAfterEat};\n}\n\n"}
{"task_id": "CPP/83", "generation": "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\nint starts_one_ends(int n) {\n    if (n == 1) {\n        // For 1-digit numbers, only '1' is valid\n        return 1;\n    }\n\n    // Count of n-digit numbers starting with '1'\n    int count_starting_with_1 = pow(10, n - 1);\n\n    // Count of n-digit numbers ending with '1'\n    int count_ending_with_1 = 9 * pow(10, n - 2);\n\n    // Count of n-digit numbers starting and ending with '1'\n    int count_both = pow(10, n - 2);\n\n    // Total count using inclusion-exclusion principle\n    int total_count = count_starting_with_1 + count_ending_with_1 - count_both;\n\n    return total_count;\n}\n\n"}
{"task_id": "CPP/27", "generation": "#include <iostream>\n#include <string>\n#include <cctype> // For islower and isupper\n\nusing namespace std;\n\nstring flip_case(string str) {\n    for (char &c : str) { // Iterate through each character in the string\n        if (islower(c)) {\n            c = toupper(c); // Convert to uppercase if it's lowercase\n        } else if (isupper(c)) {\n            c = tolower(c); // Convert to lowercase if it's uppercase\n        }\n    }\n    return str; // Return the modified string\n}\n\n"}
{"task_id": "CPP/146", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint specialFilter(vector<int> nums) {\n    int count = 0;\n\n    for (int num : nums) {\n        // Check if the number is greater than 10\n        if (num > 10) {\n            // Convert the number to a string to easily access digits\n            string numStr = to_string(num);\n            char firstDigit = numStr[0];\n            char lastDigit = numStr[numStr.length() - 1];\n\n            // Check if both first and last digits are odd\n            if ((firstDigit == '1' || firstDigit == '3' || firstDigit == '5' || firstDigit == '7' || firstDigit == '9') &&\n                (lastDigit == '1' || lastDigit == '3' || lastDigit == '5' || lastDigit == '7' || lastDigit == '9')) {\n                count++;\n            }\n        }\n    }\n\n    return count;\n}\n\n"}
{"task_id": "CPP/81", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> numerical_letter_grade(vector<float> grades) {\n    vector<string> letter_grades;\n    for (float gpa : grades) {\n        if (gpa == 4.0) {\n            letter_grades.push_back(\"A+\");\n        } else if (gpa > 3.7) {\n            letter_grades.push_back(\"A\");\n        } else if (gpa > 3.3) {\n            letter_grades.push_back(\"A-\");\n        } else if (gpa > 3.0) {\n            letter_grades.push_back(\"B+\");\n        } else if (gpa > 2.7) {\n            letter_grades.push_back(\"B\");\n        } else if (gpa > 2.3) {\n            letter_grades.push_back(\"B-\");\n        } else if (gpa > 2.0) {\n            letter_grades.push_back(\"C+\");\n        } else if (gpa > 1.7) {\n            letter_grades.push_back(\"C\");\n        } else if (gpa > 1.3) {\n            letter_grades.push_back(\"C-\");\n        } else if (gpa > 1.0) {\n            letter_grades.push_back(\"D+\");\n        } else if (gpa > 0.7) {\n            letter_grades.push_back(\"D\");\n        } else if (gpa > 0.0) {\n            letter_grades.push_back(\"D-\");\n        } else {\n            letter_grades.push_back(\"E\");\n        }\n    }\n    return letter_grades;\n}\n"}
{"task_id": "CPP/136", "generation": "#include <iostream>\n#include <vector>\n#include <limits> // for numeric_limits\n\nusing namespace std;\n\nvector<int> largest_smallest_integers(vector<int> lst) {\n    int largest_negative = numeric_limits<int>::min(); // Initialize to the smallest possible integer\n    int smallest_positive = numeric_limits<int>::max(); // Initialize to the largest possible integer\n\n    bool found_negative = false;\n    bool found_positive = false;\n\n    for (int num : lst) {\n        if (num < 0) {\n            found_negative = true;\n            if (num > largest_negative) {\n                largest_negative = num; // Update largest negative\n            }\n        } else if (num > 0) {\n            found_positive = true;\n            if (num < smallest_positive) {\n                smallest_positive = num; // Update smallest positive\n            }\n        }\n    }\n\n    // If no negative was found, set to 0\n    if (!found_negative) {\n        largest_negative = 0;\n    }\n    \n    // If no positive was found, set to 0\n    if (!found_positive) {\n        smallest_positive = 0;\n    }\n\n    return {largest_negative, smallest_positive};\n}\n\n// Example usage\n"}
{"task_id": "CPP/67", "generation": "#include <stdio.h>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nint fruit_distribution(string s, int n) {\n    int apples = 0, oranges = 0;\n    stringstream ss(s);\n    ss >> apples; // Read the number of apples\n    ss.ignore(256, ' '); // Ignore the word \"apples\"\n    ss >> oranges; // Read the number of oranges\n    ss.ignore(256, ' '); // Ignore the word \"oranges\"\n    \n    // Calculate the number of mangoes\n    int mangoes = n - apples - oranges;\n    return mangoes;\n}\n"}
{"task_id": "CPP/48", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_palindrome(string text) {\n    // Check for empty string\n    if (text.empty()) {\n        return true;\n    }\n\n    int left = 0;\n    int right = text.length() - 1;\n\n    while (left < right) {\n        if (text[left] != text[right]) {\n            return false; // Characters do not match\n        }\n        left++;\n        right--;\n    }\n\n    return true; // All characters matched\n}\n\n// Test the function\n"}
{"task_id": "CPP/125", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <cctype>\n\nusing namespace std;\n\nvector<string> split_words(string txt) {\n    vector<string> result;\n\n    // Check if there are any whitespace characters\n    if (txt.find(' ') != string::npos) {\n        // Split by whitespace\n        stringstream ss(txt);\n        string word;\n        while (ss >> word) {\n            result.push_back(word);\n        }\n    } \n    // Check if there are any commas\n    else if (txt.find(',') != string::npos) {\n        // Split by commas\n        stringstream ss(txt);\n        string word;\n        while (getline(ss, word, ',')) {\n            result.push_back(word);\n        }\n    } \n    // If no whitespace or commas, count lowercase letters with odd order\n    else {\n        int count = 0;\n        for (char c : txt) {\n            if (islower(c)) {\n                int position = c - 'a'; // Get the position in the alphabet\n                if (position % 2 == 1) { // Check if it's odd\n                    count++;\n                }\n            }\n        }\n        result.push_back(to_string(count)); // Add the count as a string\n    }\n\n    return result;\n}\n\n// Example usage\n"}
{"task_id": "CPP/160", "generation": "#include <stdio.h>\n#include <math.h>\n#include <vector>\n#include <string>\nusing namespace std;\n#include <algorithm>\n#include <stdlib.h>\n\nint do_algebra(vector<string> operato, vector<int> operand) {\n    int result = operand[0]; // Initialize result with the first operand\n    for (size_t i = 0; i < operato.size(); i++) {\n        if (operato[i] == \"+\") {\n            result += operand[i + 1];\n        } else if (operato[i] == \"-\") {\n            result -= operand[i + 1];\n        } else if (operato[i] == \"*\") {\n            result *= operand[i + 1];\n        } else if (operato[i] == \"//\") {\n            result /= operand[i + 1]; // C++ uses / for integer division\n        } else if (operato[i] == \"**\") {\n            result = pow(result, operand[i + 1]); // Use pow for exponentiation\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/151", "generation": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nlong long double_the_difference(vector<float> lst) {\n    long long sum = 0; // Initialize sum to 0\n\n    for (float num : lst) {\n        // Check if the number is a non-negative integer\n        if (num >= 0 && floor(num) == num) {\n            int intNum = static_cast<int>(num); // Convert to integer\n            // Check if the integer is odd\n            if (intNum % 2 != 0) {\n                sum += intNum * intNum; // Add the square of the odd integer to the sum\n            }\n        }\n    }\n\n    return sum; // Return the total sum\n}\n\n"}
{"task_id": "CPP/117", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nbool is_consonant(char c) {\n    // Convert to lowercase for uniformity\n    c = tolower(c);\n    // Check if the character is a consonant\n    return (c >= 'a' && c <= 'z') && (c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u');\n}\n\nvector<string> select_words(string s, int n) {\n    vector<string> result;\n    stringstream ss(s);\n    string word;\n\n    // If the string is empty, return an empty vector\n    if (s.empty()) {\n        return result;\n    }\n\n    // Process each word in the string\n    while (ss >> word) {\n        int consonant_count = 0;\n\n        // Count consonants in the current word\n        for (char c : word) {\n            if (is_consonant(c)) {\n                consonant_count++;\n            }\n        }\n\n        // If the count of consonants matches n, add the word to the result\n        if (consonant_count == n) {\n            result.push_back(word);\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/78", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint hex_key(string num) {\n    // Define the set of prime hexadecimal digits\n    const string prime_hex_digits = \"2357BD\"; // B and D are included as they represent 11 and 13 respectively\n    int count = 0;\n\n    // Iterate through each character in the input string\n    for (char ch : num) {\n        // Check if the character is in the set of prime hexadecimal digits\n        if (prime_hex_digits.find(ch) != string::npos) {\n            count++; // Increment the count if it's a prime digit\n        }\n    }\n\n    return count; // Return the total count of prime hexadecimal digits\n}\n\n// Example usage\n"}
{"task_id": "CPP/74", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> total_match(vector<string> lst1, vector<string> lst2) {\n    int total_chars_lst1 = 0;\n    int total_chars_lst2 = 0;\n\n    // Calculate total characters in lst1\n    for (const string& s : lst1) {\n        total_chars_lst1 += s.length();\n    }\n\n    // Calculate total characters in lst2\n    for (const string& s : lst2) {\n        total_chars_lst2 += s.length();\n    }\n\n    // Return the vector with fewer total characters\n    if (total_chars_lst1 < total_chars_lst2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n"}
{"task_id": "CPP/53", "generation": "#include <iostream>\nusing namespace std;\n\n// Function to add two numbers\nint add(int x, int y) {\n    return x + y;\n}\n\n"}
{"task_id": "CPP/98", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint count_upper(string s) {\n    int count = 0; // Initialize counter for uppercase vowels\n    // Loop through the string, checking only even indices\n    for (int i = 0; i < s.length(); i += 2) {\n        char c = s[i]; // Get the character at the current even index\n        // Check if the character is an uppercase vowel\n        if (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n            count++; // Increment the counter if it's an uppercase vowel\n        }\n    }\n    return count; // Return the final count\n}\n\n"}
{"task_id": "CPP/140", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring fix_spaces(string text) {\n    // Replace multiple spaces with a temporary placeholder\n    size_t pos = 0;\n    while ((pos = text.find(\"  \", pos)) != string::npos) {\n        text.replace(pos, 2, \" - \");\n        pos += 3; // Move past the placeholder\n    }\n\n    // Replace all spaces with underscores\n    for (char& c : text) {\n        if (c == ' ') {\n            c = '_';\n        }\n    }\n\n    // Restore dashes\n    pos = 0;\n    while ((pos = text.find(\" - \", pos)) != string::npos) {\n        text.replace(pos, 3, \"-\");\n        pos += 1; // Move past the dash\n    }\n\n    // Trim leading and trailing underscores\n    if (!text.empty() && text[0] == '_') {\n        text.erase(0, 1);\n    }\n    if (!text.empty() && text[text.size() - 1] == '_') {\n        text.erase(text.size() - 1);\n    }\n\n    return text;\n}\n"}
{"task_id": "CPP/34", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> unique(vector<int> l) {\n    // Sort the vector\n    sort(l.begin(), l.end());\n    \n    // Use std::unique to remove duplicates\n    auto last = unique(l.begin(), l.end());\n    \n    // Resize the vector to contain only unique elements\n    l.erase(last, l.end());\n    \n    return l;\n}\n\n"}
{"task_id": "CPP/66", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint digitSum(string s) {\n    int sum = 0; // Initialize sum to 0\n    for (char c : s) { // Iterate through each character in the string\n        if (c >= 'A' && c <= 'Z') { // Check if the character is uppercase\n            sum += static_cast<int>(c); // Add the ASCII value of the uppercase character\n        }\n    }\n    return sum; // Return the total sum\n}\n\n// Example usage\n"}
{"task_id": "CPP/120", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> maximum(vector<int> arr, int k) {\n    // Step 1: Sort the array in descending order\n    sort(arr.begin(), arr.end(), greater<int>());\n    \n    // Step 2: Take the first k elements\n    vector<int> max_k_elements(arr.begin(), arr.begin() + k);\n    \n    // Step 3: Sort the k elements in ascending order\n    sort(max_k_elements.begin(), max_k_elements.end());\n    \n    // Step 4: Return the sorted k elements\n    return max_k_elements;\n}\n\n"}
{"task_id": "CPP/139", "generation": "#include <iostream>\nusing namespace std;\n\n// Function to calculate factorial of a number\nlong long factorial(int n) {\n    long long result = 1;\n    for (int i = 2; i <= n; i++) {\n        result *= i;\n    }\n    return result;\n}\n\n// Function to calculate the Brazilian factorial\nlong long special_factorial(int n) {\n    long long result = 1;\n    for (int i = n; i >= 1; i--) {\n        result *= factorial(i);\n    }\n    return result;\n}\n\n"}
{"task_id": "CPP/12", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring longest(vector<string> strings) {\n    if (strings.empty()) {\n        return \"\"; // Return an empty string to represent None in Python\n    }\n    string longest_string = strings[0];\n    for (const string& str : strings) {\n        if (str.length() > longest_string.length()) {\n            longest_string = str;\n        }\n    }\n    return longest_string;\n}\n"}
{"task_id": "CPP/121", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint solution(vector<int> lst) {\n    int sum = 0; // Initialize sum to 0\n    for (size_t i = 0; i < lst.size(); i++) {\n        // Check if the index is even and the element is odd\n        if (i % 2 == 0 && lst[i] % 2 != 0) {\n            sum += lst[i]; // Add the element to sum\n        }\n    }\n    return sum; // Return the final sum\n}\n\n"}
{"task_id": "CPP/35", "generation": "#include <iostream>\n#include <vector>\n#include <limits> // For std::numeric_limits\n\nusing namespace std;\n\nfloat max_element(const vector<float>& l) {\n    // Check if the vector is empty\n    if (l.empty()) {\n        throw invalid_argument(\"The vector is empty.\");\n    }\n\n    // Initialize max_value to the smallest possible float\n    float max_value = numeric_limits<float>::lowest();\n\n    // Iterate through the vector to find the maximum element\n    for (float num : l) {\n        if (num > max_value) {\n            max_value = num;\n        }\n    }\n\n    return max_value;\n}\n\n"}
{"task_id": "CPP/20", "generation": "#include <vector>\n#include <algorithm>\n#include <utility> // for std::pair\nusing namespace std;\n\nvector<float> find_closest_elements(vector<float> numbers) {\n    sort(numbers.begin(), numbers.end()); // Sort the numbers in ascending order\n    float min_diff = numeric_limits<float>::infinity(); // Initialize min_diff to infinity\n    pair<float, float> result = {0, 0}; // Initialize result pair\n\n    for (size_t i = 0; i < numbers.size() - 1; ++i) {\n        float diff = numbers[i + 1] - numbers[i]; // Calculate the difference between adjacent numbers\n        if (diff < min_diff) { // If the difference is smaller than the current min_diff\n            min_diff = diff; // Update min_diff\n            result = {numbers[i], numbers[i + 1]}; // Update result with the closest pair\n        }\n    }\n\n    return {result.first, result.second}; // Return the closest pair as a vector\n}\n"}
{"task_id": "CPP/19", "generation": "#include <iostream>\n#include <string>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <sstream>\n\nusing namespace std;\n\nstring sort_numbers(string numbers) {\n    // Mapping from string to integer\n    map<string, int> num_map = {\n        {\"zero\", 0},\n        {\"one\", 1},\n        {\"two\", 2},\n        {\"three\", 3},\n        {\"four\", 4},\n        {\"five\", 5},\n        {\"six\", 6},\n        {\"seven\", 7},\n        {\"eight\", 8},\n        {\"nine\", 9}\n    };\n\n    // Split the input string into words\n    stringstream ss(numbers);\n    string word;\n    vector<int> num_list;\n\n    while (ss >> word) {\n        // Convert each word to its corresponding integer value\n        num_list.push_back(num_map[word]);\n    }\n\n    // Sort the list of integers\n    sort(num_list.begin(), num_list.end());\n\n    // Convert sorted integers back to strings\n    vector<string> sorted_words;\n    for (int num : num_list) {\n        for (const auto& pair : num_map) {\n            if (pair.second == num) {\n                sorted_words.push_back(pair.first);\n                break;\n            }\n        }\n    }\n\n    // Join the sorted words into a single output string\n    string result;\n    for (size_t i = 0; i < sorted_words.size(); ++i) {\n        result += sorted_words[i];\n        if (i < sorted_words.size() - 1) {\n            result += \" \"; // Add space between words\n        }\n    }\n\n    return result;\n}\n\n// Example usage\n"}
{"task_id": "CPP/85", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint add(vector<int> lst) {\n    int sum = 0; // Initialize sum to 0\n    // Loop through the vector\n    for (size_t i = 0; i < lst.size(); i++) {\n        // Check if the index is odd and the element is even\n        if (i % 2 != 0 && lst[i] % 2 == 0) {\n            sum += lst[i]; // Add to sum\n        }\n    }\n    return sum; // Return the final sum\n}\n\n"}
{"task_id": "CPP/21", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // for std::min_element and std::max_element\n\nusing namespace std;\n\nvector<float> rescale_to_unit(vector<float> numbers) {\n    // Find the minimum and maximum values in the vector\n    float min_val = *min_element(numbers.begin(), numbers.end());\n    float max_val = *max_element(numbers.begin(), numbers.end());\n\n    // Create a new vector to hold the rescaled values\n    vector<float> rescaled_numbers;\n\n    // Rescale each number\n    for (float num : numbers) {\n        float rescaled_value = (num - min_val) / (max_val - min_val);\n        rescaled_numbers.push_back(rescaled_value);\n    }\n\n    return rescaled_numbers;\n}\n\n"}
{"task_id": "CPP/119", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring match_parens(vector<string> lst) {\n    // Count the number of open and close parentheses in both strings\n    int open_count1 = 0, close_count1 = 0;\n    int open_count2 = 0, close_count2 = 0;\n\n    for (char ch : lst[0]) {\n        if (ch == '(') open_count1++;\n        else if (ch == ')') close_count1++;\n    }\n\n    for (char ch : lst[1]) {\n        if (ch == '(') open_count2++;\n        else if (ch == ')') close_count2++;\n    }\n\n    // Check both concatenation orders\n    // First order: lst[0] + lst[1]\n    if (open_count1 + open_count2 >= close_count1 + close_count2) {\n        if (open_count1 >= close_count2) {\n            return \"Yes\";\n        }\n    }\n\n    // Second order: lst[1] + lst[0]\n    if (open_count2 + open_count1 >= close_count2 + close_count1) {\n        if (open_count2 >= close_count1) {\n            return \"Yes\";\n        }\n    }\n\n    return \"No\";\n}\n"}
{"task_id": "CPP/30", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<float> get_positive(vector<float> l) {\n    vector<float> positive_numbers; // Vector to store positive numbers\n    for (float num : l) { // Iterate through each number in the input vector\n        if (num > 0) { // Check if the number is positive\n            positive_numbers.push_back(num); // Add to the positive numbers vector\n        }\n    }\n    return positive_numbers; // Return the vector of positive numbers\n}\n\n"}
{"task_id": "CPP/64", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint vowels_count(string s) {\n    int count = 0;\n    int length = s.length();\n\n    // Convert the string to lowercase to handle case insensitivity\n    for (char &c : s) {\n        c = tolower(c);\n    }\n\n    // Check each character in the string\n    for (int i = 0; i < length; i++) {\n        char c = s[i];\n        // Check for vowels\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n            count++;\n        }\n        // Check for 'y' at the end of the string\n        if (c == 'y' && i == length - 1) {\n            count++;\n        }\n    }\n\n    return count;\n}\n\n"}
{"task_id": "CPP/128", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint prod_signs(vector<int> arr) {\n    // Check if the array is empty\n    if (arr.empty()) {\n        return -32768; // Return -32768 for empty array\n    }\n\n    int sum_of_magnitudes = 0;\n    int product_of_signs = 1; // Start with 1 since it's the multiplicative identity\n\n    for (int num : arr) {\n        if (num > 0) {\n            sum_of_magnitudes += num; // Add the magnitude\n        } else if (num < 0) {\n            sum_of_magnitudes += -num; // Add the magnitude (negative of the number)\n            product_of_signs *= -1; // Flip the sign for negative numbers\n        } else {\n            // If we encounter a zero, the product of signs becomes zero\n            product_of_signs = 0;\n        }\n    }\n\n    // Return the final result\n    return sum_of_magnitudes * product_of_signs;\n}\n\n"}
{"task_id": "CPP/127", "generation": "#include <vector>\n#include <string>\n#include <cmath>\nusing namespace std;\n\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i <= sqrt(n); i++) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\nstring intersection(vector<int> interval1, vector<int> interval2) {\n    int start1 = interval1[0], end1 = interval1[1];\n    int start2 = interval2[0], end2 = interval2[1];\n    \n    // Find the intersection\n    int start_intersection = max(start1, start2);\n    int end_intersection = min(end1, end2);\n    \n    // Calculate the length of the intersection\n    int length = end_intersection - start_intersection;\n    \n    // Check if the length is a prime number\n    if (length > 0 && is_prime(length)) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n"}
{"task_id": "CPP/122", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint add_elements(vector<int> arr, int k) {\n    int sum = 0; // Initialize sum to 0\n\n    // Iterate through the first k elements of arr\n    for (int i = 0; i < k; i++) {\n        // Check if the current element has at most two digits\n        if (arr[i] >= -99 && arr[i] <= 99) {\n            sum += arr[i]; // Add to sum if condition is met\n        }\n    }\n\n    return sum; // Return the final sum\n}\n\n"}
{"task_id": "CPP/59", "generation": "#include <iostream>\nusing namespace std;\n\nint largest_prime_factor(int n) {\n    int largest_factor = -1;\n\n    // Check for number of 2s that divide n\n    while (n % 2 == 0) {\n        largest_factor = 2;\n        n /= 2;\n    }\n\n    // n must be odd at this point, so we can skip even numbers\n    for (int i = 3; i * i <= n; i += 2) {\n        // While i divides n, update n and largest_factor\n        while (n % i == 0) {\n            largest_factor = i;\n            n /= i;\n        }\n    }\n\n    // This condition is to check if n is a prime number greater than 2\n    if (n > 2) {\n        largest_factor = n;\n    }\n\n    return largest_factor;\n}\n\n"}
{"task_id": "CPP/134", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nbool check_if_last_char_is_a_letter(string txt) {\n    // Strip any trailing spaces from the string\n    size_t end = txt.find_last_not_of(' ');\n    if (end == string::npos) {\n        return false; // The string is empty after stripping\n    }\n    \n    // Get the last character of the string\n    char last_char = txt[end];\n    \n    // Check if the last character is an alphabetical character\n    // and if it is not part of a word (i.e., it is not followed by any character)\n    return isalpha(last_char) && (end == 0 || txt[end - 1] == ' ');\n}\n"}
{"task_id": "CPP/42", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> incr_list(vector<int> l) {\n    // Create a new vector to store the incremented values\n    vector<int> incremented_list;\n    \n    // Iterate through each element in the input vector\n    for (int i = 0; i < l.size(); i++) {\n        // Increment the element by 1 and add it to the new vector\n        incremented_list.push_back(l[i] + 1);\n    }\n    \n    // Return the new vector with incremented values\n    return incremented_list;\n}\n\n"}
{"task_id": "CPP/11", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring string_xor(string a, string b) {\n    // Ensure both strings are of the same length\n    int n = a.length();\n    int m = b.length();\n    if (n != m) {\n        throw invalid_argument(\"Strings must be of the same length\");\n    }\n\n    string result = \"\";\n    for (int i = 0; i < n; i++) {\n        // Perform XOR operation\n        if (a[i] == b[i]) {\n            result += '0'; // Both are the same\n        } else {\n            result += '1'; // Different\n        }\n    }\n    return result;\n}\n\n"}
{"task_id": "CPP/40", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <unordered_set>\n\nusing namespace std;\n\nbool triples_sum_to_zero(vector<int> l) {\n    // Sort the vector to facilitate the two-pointer approach\n    sort(l.begin(), l.end());\n    \n    // Iterate through the vector\n    for (size_t i = 0; i < l.size(); i++) {\n        // To avoid using the same element, skip duplicates\n        if (i > 0 && l[i] == l[i - 1]) {\n            continue;\n        }\n        \n        // Set up two pointers\n        int left = i + 1;\n        int right = l.size() - 1;\n        \n        while (left < right) {\n            int sum = l[i] + l[left] + l[right];\n            if (sum == 0) {\n                return true; // Found a triplet that sums to zero\n            } else if (sum < 0) {\n                left++; // Need a larger sum\n            } else {\n                right--; // Need a smaller sum\n            }\n        }\n    }\n    \n    return false; // No triplet found\n}\n\n"}
{"task_id": "CPP/13", "generation": "#include <iostream>\nusing namespace std;\n\nint greatest_common_divisor(int a, int b) {\n    // Ensure a and b are non-negative\n    a = abs(a);\n    b = abs(b);\n    \n    // Use the Euclidean algorithm\n    while (b != 0) {\n        int temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n\n"}
{"task_id": "CPP/130", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nvector<int> tri(int n) {\n    vector<int> tribonacci(n + 1);\n    \n    for (int i = 0; i <= n; i++) {\n        if (i == 1) {\n            tribonacci[i] = 3; // base case\n        } else if (i % 2 == 0) {\n            tribonacci[i] = 1 + i / 2; // even case\n        } else {\n            if (i == 3) {\n                tribonacci[i] = 8; // base case for odd n\n            } else {\n                tribonacci[i] = tribonacci[i - 1] + tribonacci[i - 2] + tribonacci[i - 1]; // corrected odd case\n            }\n        }\n    }\n    \n    return tribonacci;\n}\n"}
{"task_id": "CPP/60", "generation": "#include <iostream>\nusing namespace std;\n\nint sum_to_n(int n) {\n    return n * (n + 1) / 2; // Using the formula for the sum of the first n natural numbers\n}\n\n"}
{"task_id": "CPP/23", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\n// Function to return the length of the given string\nint strlen(const string& str) {\n    return str.size(); // or str.length();\n}\n\n"}
{"task_id": "CPP/46", "generation": "#include <iostream>\nusing namespace std;\n\nint fib4(int n) {\n    // Handle base cases\n    if (n == 0) return 0;\n    if (n == 1) return 0;\n    if (n == 2) return 2;\n    if (n == 3) return 0;\n\n    // Array to store the last four computed values\n    int fib[4] = {0, 0, 2, 0}; // fib4(0), fib4(1), fib4(2), fib4(3)\n\n    // Compute fib4(n) iteratively\n    for (int i = 4; i <= n; ++i) {\n        int next_fib = fib[0] + fib[1] + fib[2] + fib[3];\n        // Shift the values in the array\n        fib[0] = fib[1];\n        fib[1] = fib[2];\n        fib[2] = fib[3];\n        fib[3] = next_fib;\n    }\n\n    return fib[3]; // Return the n-th value\n}\n\n"}
{"task_id": "CPP/51", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nstring remove_vowels(string text) {\n    string result;\n    for (char c : text) {\n        // Check if the character is not a vowel\n        if (c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u' &&\n            c != 'A' && c != 'E' && c != 'I' && c != 'O' && c != 'U') {\n            result += c; // Append non-vowel characters to the result\n        }\n    }\n    return result; // Return the result string\n}\n\n"}
{"task_id": "CPP/18", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint how_many_times(string str, string substring) {\n    if (substring.empty()) {\n        return 0; // If the substring is empty, return 0 as specified.\n    }\n\n    int count = 0;\n    size_t pos = 0;\n\n    // Loop to find all occurrences of the substring\n    while ((pos = str.find(substring, pos)) != string::npos) {\n        count++; // Increment count for each found occurrence\n        pos++;   // Move to the next character to allow overlapping\n    }\n\n    return count;\n}\n\n"}
{"task_id": "CPP/143", "generation": "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int n) {\n    if (n <= 1) return false; // 0 and 1 are not prime numbers\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0) return false; // Found a divisor, not prime\n    }\n    return true; // No divisors found, it's prime\n}\n\n// Function to extract words with prime lengths\nstring words_in_sentence(string sentence) {\n    stringstream ss(sentence);\n    string word;\n    vector<string> prime_length_words;\n\n    // Split the sentence into words\n    while (ss >> word) {\n        // Check if the length of the word is prime\n        if (is_prime(word.length())) {\n            prime_length_words.push_back(word);\n        }\n    }\n\n    // Join the words with prime lengths into a single string\n    string result;\n    for (const string& w : prime_length_words) {\n        if (!result.empty()) {\n            result += \" \"; // Add space before the next word\n        }\n        result += w;\n    }\n\n    return result;\n}\n\n// Example usage\n"}
{"task_id": "CPP/108", "generation": "#include <vector>\n#include <cmath>\nusing namespace std;\n\nint digit_sum(int num) {\n    int sum = 0;\n    bool is_negative = num < 0;\n    num = abs(num);\n    \n    while (num > 0) {\n        int digit = num % 10;\n        sum += (is_negative && num == abs(num)) ? -digit : digit;\n        num /= 10;\n    }\n    \n    return sum;\n}\n\nint count_nums(vector<int> n) {\n    int count = 0;\n    for (int number : n) {\n        if (digit_sum(number) > 0) {\n            count++;\n        }\n    }\n    return count;\n}\n"}
{"task_id": "CPP/43", "generation": "#include <iostream>\n#include <vector>\n#include <unordered_set>\nusing namespace std;\n\nbool pairs_sum_to_zero(vector<int> l) {\n    unordered_set<int> seen; // Set to store the elements we have seen\n\n    for (int num : l) {\n        // Check if the negation of the current number exists in the set\n        if (seen.count(-num)) {\n            return true; // Found a pair that sums to zero\n        }\n        seen.insert(num); // Add the current number to the set\n    }\n\n    return false; // No pairs found that sum to zero\n}\n\n// Test cases\n"}
{"task_id": "CPP/70", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> strange_sort_list(vector<int> lst) {\n    // Sort the input list\n    sort(lst.begin(), lst.end());\n    \n    vector<int> result;\n    int left = 0; // Pointer for the minimum values\n    int right = lst.size() - 1; // Pointer for the maximum values\n    \n    // Alternate between minimum and maximum\n    while (left <= right) {\n        if (left == right) {\n            // If both pointers meet, add the last element\n            result.push_back(lst[left]);\n        } else {\n            // Add the minimum value\n            result.push_back(lst[left]);\n            // Add the maximum value\n            result.push_back(lst[right]);\n        }\n        left++;\n        right--;\n    }\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/63", "generation": "#include <iostream>\nusing namespace std;\n\nint fibfib(int n) {\n    // Handle base cases\n    if (n == 0) return 0;\n    if (n == 1) return 0;\n    if (n == 2) return 1;\n\n    // Initialize the first three values\n    int a = 0; // fibfib(0)\n    int b = 0; // fibfib(1)\n    int c = 1; // fibfib(2)\n    int result = 0;\n\n    // Compute fibfib(n) iteratively\n    for (int i = 3; i <= n; ++i) {\n        result = a + b + c; // fibfib(n) = fibfib(n-1) + fibfib(n-2) + fibfib(n-3)\n        a = b; // Move to the next value\n        b = c; // Move to the next value\n        c = result; // Update the current value\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/89", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nstring encrypt(string s) {\n    string encrypted = \"\";\n    for (char c : s) {  // Changed 'char char' to 'char c'\n        if (isalpha(c)) {  // Check if the character is a letter\n            char new_char;\n            if (islower(c) ) {\n                new_char = (c - 'a' + 4) % 26 + 'a';  // For lowercase letters\n            } else {\n                new_char = (c - 'A' + 4) % 26 + 'A';  // For uppercase letters\n            }\n            encrypted += new_char;  // Append the new character to the result\n        }\n    }\n    return encrypted;\n}\n"}
{"task_id": "CPP/26", "generation": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nvector<int> remove_duplicates(const vector<int>& numbers) {\n    unordered_map<int, int> count_map;\n    \n    // Count occurrences of each number\n    for (int num : numbers) {\n        count_map[num]++;\n    }\n    \n    vector<int> result;\n    \n    // Add numbers that occur only once to the result\n    for (int num : numbers) {\n        if (count_map[num] == 1) {\n            result.push_back(num);\n        }\n    }\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/104", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// Helper function to check if a number contains any even digits\nbool has_even_digit(int num) {\n    while (num > 0) {\n        int digit = num % 10; // Get the last digit\n        if (digit % 2 == 0) { // Check if the digit is even\n            return true; // Found an even digit\n        }\n        num /= 10; // Remove the last digit\n    }\n    return false; // No even digits found\n}\n\n// Main function to filter and return sorted unique digits\nvector<int> unique_digits(vector<int> x) {\n    vector<int> result;\n\n    for (int num : x) {\n        if (!has_even_digit(num)) { // If the number has no even digits\n            result.push_back(num); // Add it to the result\n        }\n    }\n\n    sort(result.begin(), result.end()); // Sort the result in increasing order\n    return result; // Return the sorted vector\n}\n\n// Example usage\n"}
{"task_id": "CPP/90", "generation": "#include <iostream>\n#include <vector>\n#include <set>\n#include <algorithm>\n\nusing namespace std;\n\nint next_smallest(vector<int> lst) {\n    // Use a set to store unique elements\n    set<int> unique_elements(lst.begin(), lst.end());\n\n    // If there are less than 2 unique elements, return None (or -1)\n    if (unique_elements.size() < 2) {\n        return -1; // Indicating None\n    }\n\n    // Convert the set back to a vector and sort it\n    vector<int> sorted_unique(unique_elements.begin(), unique_elements.end());\n\n    // Return the second smallest element\n    return sorted_unique[1];\n}\n\n"}
{"task_id": "CPP/126", "generation": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nbool is_sorted(vector<int> lst) {\n    // Check if the vector is sorted and count occurrences\n    unordered_map<int, int> countMap;\n    \n    for (size_t i = 0; i < lst.size(); ++i) {\n        // Check for sorted order\n        if (i > 0 && lst[i] < lst[i - 1]) {\n            return false; // Not sorted\n        }\n        \n        // Count occurrences\n        countMap[lst[i]]++;\n        if (countMap[lst[i]] > 2) {\n            return false; // More than two occurrences\n        }\n    }\n    \n    return true; // The list is sorted and no number appears more than twice\n}\n\n"}
{"task_id": "CPP/68", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> pluck(vector<int> arr) {\n    int smallest_even_value = -1; // Initialize to -1 to indicate no even value found\n    int smallest_index = -1; // Initialize index to -1\n\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] % 2 == 0) { // Check if the number is even\n            if (smallest_even_value == -1 || arr[i] < smallest_even_value) {\n                smallest_even_value = arr[i];\n                smallest_index = i;\n            }\n        }\n    }\n\n    // If no even value was found, return an empty vector\n    if (smallest_even_value == -1) {\n        return {};\n    }\n\n    // Return the smallest even value and its index\n    return {smallest_even_value, smallest_index};\n}\n\n// Example usage\n"}
{"task_id": "CPP/58", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\n\nusing namespace std;\n\nvector<int> common(vector<int> l1, vector<int> l2) {\n    // Use a set to store unique elements from both vectors\n    set<int> set1(l1.begin(), l1.end());\n    set<int> set2(l2.begin(), l2.end());\n    \n    // Vector to store the common elements\n    vector<int> commonElements;\n\n    // Use set_intersection to find common elements\n    set_intersection(set1.begin(), set1.end(),\n                     set2.begin(), set2.end(),\n                     back_inserter(commonElements));\n\n    // The result is already sorted and unique due to the nature of sets\n    return commonElements;\n}\n\n"}
{"task_id": "CPP/112", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_set>\n#include <algorithm>\n\nusing namespace std;\n\nvector<string> reverse_delete(string s, string c) {\n    // Create a set of characters to delete\n    unordered_set<char> chars_to_delete(c.begin(), c.end());\n    \n    // Build the resulting string by excluding characters in chars_to_delete\n    string result;\n    for (char ch : s) {\n        if (chars_to_delete.find(ch) == chars_to_delete.end()) {\n            result += ch;\n        }\n    }\n    \n    // Check if the resulting string is a palindrome\n    string reversed_result = result;\n    reverse(reversed_result.begin(), reversed_result.end());\n    bool is_palindrome = (result == reversed_result);\n    \n    // Prepare the output\n    vector<string> output;\n    output.push_back(result);\n    output.push_back(is_palindrome ? \"True\" : \"False\");\n    \n    return output;\n}\n\n"}
{"task_id": "CPP/96", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Helper function to check if a number is prime\nbool is_prime(int num) {\n    if (num <= 1) return false; // 0 and 1 are not prime numbers\n    for (int i = 2; i * i <= num; i++) { // Check divisibility up to the square root of num\n        if (num % i == 0) return false; // If divisible, it's not prime\n    }\n    return true; // If no divisors found, it's prime\n}\n\n// Main function to count primes up to n\nvector<int> count_up_to(int n) {\n    vector<int> primes; // Vector to store prime numbers\n    for (int i = 2; i < n; i++) { // Start from 2 and go up to n-1\n        if (is_prime(i)) { // Check if i is prime\n            primes.push_back(i); // Add to the vector if it is prime\n        }\n    }\n    return primes; // Return the vector of prime numbers\n}\n\n// Example usage\n"}
{"task_id": "CPP/157", "generation": "#include <stdio.h>\n#include <math.h>\nusing namespace std;\n\nbool right_angle_triangle(float a, float b, float c) {\n    // Sort the sides to identify the longest side\n    float x, y, z;\n    if (a >= b && a >= c) {\n        x = a; y = b; z = c;\n    } else if (b >= a && b >= c) {\n        x = b; y = a; z = c;\n    } else {\n        x = c; y = a; z = b;\n    }\n\n    // Check if it satisfies the Pythagorean theorem\n    return (fabs(x * x - (y * y + z * z)) < 1e-6);\n}\n\n"}
{"task_id": "CPP/99", "generation": "#include <iostream>\n#include <string>\n#include <cmath>\n\nusing namespace std;\n\nint closest_integer(string value) {\n    // Convert the string to a double\n    double num = stod(value);\n    \n    // Get the floor and ceil values\n    int lower = static_cast<int>(floor(num));\n    int upper = static_cast<int>(ceil(num));\n    \n    // Check if the number is equidistant from lower and upper\n    if (fabs(num - lower) == 0.5) {\n        // If equidistant, round away from zero\n        if (num > 0) {\n            return upper; // round up\n        } else {\n            return lower; // round down (away from zero)\n        }\n    } else {\n        // Otherwise, return the nearest integer\n        return static_cast<int>(round(num));\n    }\n}\n\n"}
{"task_id": "CPP/149", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nvector<string> sorted_list_sum(vector<string> lst) {\n    // Filter out strings with odd lengths\n    vector<string> filtered_lst;\n    for (const string& s : lst) {\n        if (s.length() % 2 == 0) {\n            filtered_lst.push_back(s);\n        }\n    }\n    \n    // Sort the filtered list first by length, then alphabetically\n    sort(filtered_lst.begin(), filtered_lst.end(), [](const string& a, const string& b) {\n        if (a.length() == b.length()) {\n            return a < b; // Sort alphabetically if lengths are the same\n        }\n        return a.length() < b.length(); // Sort by length\n    });\n    \n    return filtered_lst;\n}\n"}
{"task_id": "CPP/86", "generation": "#include <stdio.h>\n#include <string>\n#include <algorithm>\n#include <sstream>\nusing namespace std;\n\nstring anti_shuffle(string s) {\n    stringstream ss(s);\n    string word;\n    string result;\n\n    while (ss >> word) {\n        // Sort the characters in the word\n        sort(word.begin(), word.end());\n        result += word + \" \"; // Append sorted word and a space\n    }\n\n    // Remove the trailing space if there is one\n    if (!result.empty()) {\n        result.pop_back();\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/129", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvoid dfs(const vector<vector<int>>& grid, int x, int y, int k, vector<int>& currentPath, vector<int>& minPath) {\n    // If we have reached the desired path length\n    if (currentPath.size() == k) {\n        // Compare with the current minimum path\n        if (minPath.empty() || currentPath < minPath) {\n            minPath = currentPath; // Update the minimum path\n        }\n        return;\n    }\n\n    // Directions for moving in the grid (up, down, left, right)\n    vector<pair<int, int>> directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n    \n    // Explore all neighbors\n    for (const auto& dir : directions) {\n        int newX = x + dir.first;\n        int newY = y + dir.second;\n\n        // Check if the new position is within bounds\n        if (newX >= 0 && newX < grid.size() && newY >= 0 && newY < grid[0].size()) {\n            // Add the value to the current path\n            currentPath.push_back(grid[newX][newY]);\n            // Continue DFS from the new cell\n            dfs(grid, newX, newY, k, currentPath, minPath);\n            // Backtrack\n            currentPath.pop_back();\n        }\n    }\n}\n\nvector<int> minPath(vector<vector<int>> grid, int k) {\n    vector<int> minPath; // To store the minimum path found\n    int N = grid.size();\n\n    // Start DFS from every cell in the grid\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            vector<int> currentPath;\n            currentPath.push_back(grid[i][j]); // Start with the current cell\n            dfs(grid, i, j, k, currentPath, minPath);\n        }\n    }\n\n    return minPath;\n}\n\n"}
{"task_id": "CPP/49", "generation": "#include <stdio.h>\n\nint modp(int n, int p) {\n    // Handle the case when n is 0\n    if (n == 0) {\n        return 1; // 2^0 is 1\n    }\n\n    long long result = 1; // Use long long to prevent overflow\n    long long base = 2;   // Base is 2\n\n    // Use exponentiation by squaring\n    while (n > 0) {\n        if (n % 2 == 1) { // If n is odd\n            result = (result * base) % p; // Multiply the result by the base\n        }\n        base = (base * base) % p; // Square the base\n        n /= 2; // Divide n by 2\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/156", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring int_to_mini_roman(int number) {\n    // Define the Roman numeral symbols and their corresponding values\n    vector<pair<int, string>> roman_numerals = {\n        {1000, \"m\"}, {900, \"cm\"}, {500, \"d\"}, {400, \"cd\"},\n        {100, \"c\"}, {90, \"xc\"}, {50, \"l\"}, {40, \"xl\"},\n        {10, \"x\"}, {9, \"ix\"}, {5, \"v\"}, {4, \"iv\"},\n        {1, \"i\"}\n    };\n\n    string result = \"\";\n\n    // Iterate through the Roman numeral values\n    for (const auto& pair : roman_numerals) {\n        while (number >= pair.first) {\n            result += pair.second; // Append the Roman numeral\n            number -= pair.first;  // Decrease the number\n        }\n    }\n\n    return result; // Return the final Roman numeral string\n}\n\n"}
{"task_id": "CPP/65", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nstring circular_shift(int x, int shift) {\n    // Convert the integer to a string to manipulate its digits\n    string x_str = to_string(x);\n    int n = x_str.length();\n    \n    // If shift is greater than the number of digits, reverse the string\n    if (shift > n) {\n        reverse(x_str.begin(), x_str.end());\n        return x_str;\n    }\n    \n    // Calculate the effective shift (in case shift is greater than n)\n    int effective_shift = shift % n;\n    \n    // Perform the circular shift\n    string shifted_str = x_str.substr(n - effective_shift) + x_str.substr(0, n - effective_shift);\n    \n    return shifted_str;\n}\n"}
{"task_id": "CPP/9", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> rolling_max(const vector<int>& numbers) {\n    vector<int> result;\n    int current_max = INT_MIN; // Initialize current_max to the smallest possible integer\n\n    for (int num : numbers) {\n        if (num > current_max) {\n            current_max = num; // Update current_max if the current number is greater\n        }\n        result.push_back(current_max); // Add the current_max to the result vector\n    }\n\n    return result; // Return the vector containing rolling maximums\n}\n\n"}
{"task_id": "CPP/158", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_set>\n#include <algorithm>\n\nusing namespace std;\n\n// Helper function to count unique characters in a string\nint count_unique_characters(const string& str) {\n    unordered_set<char> unique_chars(str.begin(), str.end());\n    return unique_chars.size();\n}\n\nstring find_max(vector<string> words) {\n    string max_word;\n    int max_unique_count = 0;\n\n    for (const string& word : words) {\n        int unique_count = count_unique_characters(word);\n        \n        // Check if we found a new maximum or if we need to update lexicographically\n        if (unique_count > max_unique_count || \n            (unique_count == max_unique_count && (max_word.empty() || word < max_word))) {\n            max_word = word;\n            max_unique_count = unique_count;\n        }\n    }\n\n    return max_word;\n}\n\n"}
{"task_id": "CPP/8", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> sum_product(vector<int> numbers) {\n    int sum = 0;\n    int product = 1;\n\n    // Check if the vector is empty\n    if (numbers.empty()) {\n        return {0, 1}; // Return sum as 0 and product as 1 for empty vector\n    }\n\n    // Calculate sum and product\n    for (int number : numbers) {\n        sum += number;      // Add to sum\n        product *= number;  // Multiply to product\n    }\n\n    return {sum, product}; // Return the results as a vector\n}\n\n"}
{"task_id": "CPP/95", "generation": "#include <iostream>\n#include <string>\n#include <map>\n#include <cctype> // for islower and isupper\n\nusing namespace std;\n\nbool check_dict_case(map<string, string> dict) {\n    // Check if the map is empty\n    if (dict.empty()) {\n        return false;\n    }\n\n    // Variables to track if we have seen lower case or upper case keys\n    bool hasLowerCase = false;\n    bool hasUpperCase = false;\n\n    // Iterate through the map\n    for (const auto& pair : dict) {\n        const string& key = pair.first;\n\n        // Check if the key is a string (it is, since we're using map<string, string>)\n        // Check if the key is not empty\n        if (key.empty()) {\n            return false;\n        }\n\n        // Check if the key is lower case or upper case\n        bool isLowerCase = true;\n        bool isUpperCase = true;\n\n        for (char c : key) {\n            if (!isalpha(c)) {\n                return false; // Key contains non-alphabetic characters\n            }\n            if (islower(c)) {\n                isUpperCase = false; // Found a lower case letter\n            } else if (isupper(c)) {\n                isLowerCase = false; // Found an upper case letter\n            }\n        }\n\n        // Update the flags\n        if (isLowerCase) {\n            hasLowerCase = true;\n        }\n        if (isUpperCase) {\n            hasUpperCase = true;\n        }\n    }\n\n    // Return true if all keys are either lower case or upper case\n    return (hasLowerCase && !hasUpperCase) || (!hasLowerCase && hasUpperCase);\n}\n\n// Example usage\n"}
{"task_id": "CPP/55", "generation": "#include <iostream>\nusing namespace std;\n\nint fib(int n) {\n    if (n <= 0) return 0; // Handle the case for n = 0\n    if (n == 1) return 1; // Base case for n = 1\n\n    int a = 0; // F(0)\n    int b = 1; // F(1)\n    int c; // To store the current Fibonacci number\n\n    for (int i = 2; i <= n; i++) {\n        c = a + b; // F(n) = F(n-1) + F(n-2)\n        a = b; // Move to the next Fibonacci number\n        b = c; // Update b to the current Fibonacci number\n    }\n\n    return b; // b now holds F(n)\n}\n\n"}
{"task_id": "CPP/29", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<string> filter_by_prefix(const vector<string>& strings, const string& prefix) {\n    vector<string> filtered; // Vector to hold the filtered results\n\n    // Iterate through each string in the input vector\n    for (const string& str : strings) {\n        // Check if the string starts with the given prefix\n        if (str.find(prefix) == 0) { // find returns 0 if the prefix is found at the start\n            filtered.push_back(str); // Add to the filtered results\n        }\n    }\n\n    return filtered; // Return the filtered vector\n}\n\n"}
{"task_id": "CPP/72", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool is_palindromic(const vector<int>& q) {\n    int n = q.size();\n    for (int i = 0; i < n / 2; ++i) {\n        if (q[i] != q[n - 1 - i]) {\n            return false; // Not a palindrome\n        }\n    }\n    return true; // It is a palindrome\n}\n\nbool will_it_fly(vector<int> q, int w) {\n    // Check if the vector is palindromic\n    if (!is_palindromic(q)) {\n        return false;\n    }\n    \n    // Calculate the sum of the elements\n    int sum = 0;\n    for (int num : q) {\n        sum += num;\n    }\n    \n    // Check if the sum is less than or equal to the maximum weight\n    return sum <= w;\n}\n\n// Example usage\n"}
{"task_id": "CPP/54", "generation": "#include <iostream>\n#include <string>\n#include <set>\nusing namespace std;\n\nbool same_chars(string s0, string s1) {\n    // Create sets to hold unique characters\n    set<char> chars0(s0.begin(), s0.end());\n    set<char> chars1(s1.begin(), s1.end());\n    \n    // Compare the two sets\n    return chars0 == chars1;\n}\n\n"}
{"task_id": "CPP/91", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <vector>\n#include <cctype>\n\nusing namespace std;\n\nint is_bored(string S) {\n    int boredom_count = 0;\n    string delimiters = \".!?\";\n    stringstream ss(S);\n    string sentence;\n\n    // Read sentences from the string\n    while (getline(ss, sentence, '.')) {\n        // Check for other delimiters\n        size_t pos = sentence.find_first_of(\"!?\");\n        if (pos != string::npos) {\n            sentence = sentence.substr(0, pos);\n        }\n\n        // Trim leading whitespace\n        size_t start = sentence.find_first_not_of(\" \\t\");\n        if (start != string::npos) {\n            sentence = sentence.substr(start);\n        }\n\n        // Check if the sentence starts with \"I\"\n        if (sentence == \"I\" || (sentence.size() > 1 && sentence[0] == 'I' && isspace(sentence[1]))) {\n            boredom_count++;\n        }\n    }\n\n    return boredom_count;\n}\n\n// Example usage\n"}
{"task_id": "CPP/77", "generation": "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\nbool iscube(int a) {\n    // Calculate the cube root of the absolute value of a\n    int cubeRoot = round(pow(abs(a), 1.0 / 3.0));\n    \n    // Check if the cube of the rounded cube root equals a\n    return (cubeRoot * cubeRoot * cubeRoot == a) || (-cubeRoot * -cubeRoot * -cubeRoot == a);\n}\n\n"}
{"task_id": "CPP/73", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint smallest_change(vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n\n    // Compare elements from the start and end moving towards the center\n    for (int i = 0; i < n / 2; i++) {\n        if (arr[i] != arr[n - 1 - i]) {\n            changes++; // Increment the change count if elements are not equal\n        }\n    }\n\n    return changes; // Return the total number of changes needed\n}\n\n"}
{"task_id": "CPP/71", "generation": "#include <stdio.h>\n#include <math.h>\n\nfloat triangle_area(float a, float b, float c) {\n    // Check for a valid triangle using the triangle inequality theorem\n    if (a + b > c && a + c > b && b + c > a) {\n        // Calculate the semi-perimeter\n        float s = (a + b + c) / 2;\n        // Calculate the area using Heron's formula\n        float area = sqrt(s * (s - a) * (s - b) * (s - c));\n        // Return the area rounded to 2 decimal points\n        return round(area * 100) / 100; // rounding to 2 decimal points\n    } else {\n        // Return -1 if the sides do not form a valid triangle\n        return -1;\n    }\n}\n\n"}
{"task_id": "CPP/82", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int num) {\n    if (num <= 1) return false; // 0 and 1 are not prime numbers\n    for (int i = 2; i * i <= num; i++) { // Check divisibility from 2 to sqrt(num)\n        if (num % i == 0) return false; // If divisible, it's not prime\n    }\n    return true; // If no divisors found, it's prime\n}\n\n// Function to check if the length of the string is prime\nbool prime_length(string str) {\n    int length = str.length(); // Get the length of the string\n    return is_prime(length); // Check if the length is prime\n}\n\n// Example usage\n"}
{"task_id": "CPP/114", "generation": "#include <iostream>\n#include <vector>\n#include <limits.h> // For INT_MAX\n\nusing namespace std;\n\nlong long minSubArraySum(vector<long long> nums) {\n    long long min_sum = LLONG_MAX; // Initialize to maximum possible value\n    long long current_sum = 0; // To keep track of the current subarray sum\n\n    for (long long num : nums) {\n        current_sum += num; // Add the current number to the current sum\n        if (current_sum < min_sum) {\n            min_sum = current_sum; // Update min_sum if current_sum is smaller\n        }\n        if (current_sum > 0) {\n            current_sum = 0; // Reset current_sum if it becomes positive\n        }\n    }\n\n    return min_sum; // Return the minimum sum found\n}\n\n"}
{"task_id": "CPP/138", "generation": "#include <iostream>\nusing namespace std;\n\nbool is_equal_to_sum_even(int n) {\n    // Check if n is less than 8 or if n is odd\n    if (n < 8 || n % 2 != 0) {\n        return false;\n    }\n    return true; // n is even and >= 8\n}\n\n"}
{"task_id": "CPP/132", "generation": "#include <stdio.h>\n#include <string>\n#include <stack>\nusing namespace std;\n\nbool is_nested(string str) {\n    stack<char> s;\n    bool nested = false;\n\n    for (char& c : str) {\n        if (c == '[') {\n            s.push(c);\n            if (s.size() > 1) {  // More than one opening bracket means nested\n                nested = true;\n            }\n        } else if (c == ']') {\n            if (s.empty()) {  // Closing bracket without a matching opening bracket\n                return false;\n            }\n            s.pop();\n        }\n    }\n\n    return nested && s.empty();  // Must be nested and all brackets must be closed\n}\n"}
{"task_id": "CPP/3", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool below_zero(vector<int> operations) {\n    int balance = 0; // Start with a balance of zero\n\n    for (int operation : operations) {\n        balance += operation; // Update the balance with the current operation\n        if (balance < 0) { // Check if the balance falls below zero\n            return true; // Return true if it does\n        }\n    }\n    \n    return false; // Return false if the balance never falls below zero\n}\n\n"}
{"task_id": "CPP/142", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint sum_squares(vector<int> lst) {\n    int total_sum = 0; // Initialize the sum\n\n    // Iterate through the vector\n    for (size_t i = 0; i < lst.size(); ++i) {\n        if (i % 3 == 0) {\n            // If index is a multiple of 3, square the element\n            total_sum += lst[i] * lst[i];\n        } else if (i % 4 == 0) {\n            // If index is a multiple of 4 and not a multiple of 3, cube the element\n            total_sum += lst[i] * lst[i] * lst[i];\n        } else {\n            // Otherwise, just add the element as is\n            total_sum += lst[i];\n        }\n    }\n\n    return total_sum; // Return the total sum\n}\n\n// Example usage\n"}
{"task_id": "CPP/50", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring encode_shift(string s) {\n    // Returns encoded string by shifting every character by 5 in the alphabet.\n    string out;\n    for (char c : s) {\n        if (isalpha(c)) { // Check if the character is an alphabet\n            char base = islower(c) ? 'a' : 'A'; // Determine base for lowercase or uppercase\n            char shifted = (c - base + 5) % 26 + base; // Shift character\n            out += shifted; // Append shifted character to output\n        } else {\n            out += c; // Non-alphabet characters remain unchanged\n        }\n    }\n    return out;\n}\n\nstring decode_shift(string s) {\n    // Takes as input string encoded with encode_shift function. Returns decoded string.\n    string out;\n    for (char c : s) {\n        if (isalpha(c)) { // Check if the character is an alphabet\n            char base = islower(c) ? 'a' : 'A'; // Determine base for lowercase or uppercase\n            char shifted = (c - base - 5 + 26) % 26 + base; // Shift character back\n            out += shifted; // Append shifted character to output\n        } else {\n            out += c; // Non-alphabet characters remain unchanged\n        }\n    }\n    return out;\n}\n\n"}
{"task_id": "CPP/103", "generation": "#include <iostream>\n#include <string>\n#include <cmath>\n\nusing namespace std;\n\nstring rounded_avg(int n, int m) {\n    // Step 1: Check if n is greater than m\n    if (n > m) {\n        return \"-1\";\n    }\n\n    // Step 2: Calculate the average\n    int count = m - n + 1; // Total numbers from n to m\n    int sum = (n + m) * count / 2; // Sum of the series\n    int average = sum / count; // Average\n\n    // Step 3: Round down the average\n    int rounded_average = floor(average); // Since average is already an integer, this is just average\n\n    // Step 4: Convert to binary\n    string binary = \"\";\n    while (rounded_average > 0) {\n        binary = to_string(rounded_average % 2) + binary; // Prepend the binary digit\n        rounded_average /= 2; // Divide by 2 to shift right\n    }\n\n    // If the binary string is empty, it means the average was 0\n    if (binary.empty()) {\n        return \"0\";\n    }\n\n    return binary;\n}\n\n"}
{"task_id": "CPP/57", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nbool monotonic(const vector<float>& l) {\n    if (l.size() < 2) {\n        return true; // A vector with less than 2 elements is considered monotonic\n    }\n\n    bool increasing = true;\n    bool decreasing = true;\n\n    for (size_t i = 1; i < l.size(); ++i) {\n        if (l[i] > l[i - 1]) {\n            decreasing = false; // Found an increasing pair\n        } else if (l[i] < l[i - 1]) {\n            increasing = false; // Found a decreasing pair\n        }\n    }\n\n    return increasing || decreasing; // Return true if either condition is met\n}\n\n"}
{"task_id": "CPP/28", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nstring concatenate(vector<string> strings) {\n    string result; // Initialize an empty string to hold the result\n    for (const string& str : strings) { // Iterate through each string in the vector\n        result += str; // Append the current string to the result\n    }\n    return result; // Return the concatenated string\n}\n\n"}
{"task_id": "CPP/39", "generation": "#include <iostream>\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int num) {\n    if (num <= 1) return false; // 0 and 1 are not prime numbers\n    for (int i = 2; i * i <= num; i++) {\n        if (num % i == 0) return false; // Found a divisor, not prime\n    }\n    return true; // No divisors found, it's prime\n}\n\n// Function to return the n-th Fibonacci number that is also prime\nint prime_fib(int n) {\n    int count = 0; // Count of prime Fibonacci numbers\n    int a = 0, b = 1; // Fibonacci numbers initialization\n    int fib; // Variable to hold the current Fibonacci number\n\n    while (count < n) {\n        fib = a + b; // Generate the next Fibonacci number\n        a = b; // Move to the next Fibonacci number\n        b = fib;\n\n        // Check if the Fibonacci number is prime\n        if (is_prime(fib)) {\n            count++; // Increment count if it's prime\n            if (count == n) {\n                return fib; // Return the n-th prime Fibonacci number\n            }\n        }\n    }\n    return -1; // In case n is invalid, though it shouldn't happen\n}\n\n"}
{"task_id": "CPP/45", "generation": "#include <iostream>\nusing namespace std;\n\nfloat triangle_area(float a, float h) {\n    return 0.5 * a * h; // Calculate the area using the formula\n}\n\n"}
{"task_id": "CPP/145", "generation": "#include <stdio.h>\n#include <math.h>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to calculate the sum of digits of a number\nint digit_sum(int n) {\n    int sum = 0;\n    n = abs(n); // Take the absolute value to ignore the negative sign\n    while (n > 0) {\n        sum += n % 10; // Add the last digit to the sum\n        n /= 10; // Remove the last digit\n    }\n    return sum;\n}\n\nvector<int> order_by_points(vector<int> nums) {\n    // Create a vector of pairs to store the original index and the number\n    vector<pair<int, int>> indexed_nums;\n    for (int i = 0; i < nums.size(); i++) {\n        indexed_nums.push_back({nums[i], i}); // Store the number and its original index\n    }\n\n    // Sort based on the sum of digits and original index\n    sort(indexed_nums.begin(), indexed_nums.end(), [](const pair<int, int>& a, const pair<int, int>& b) {\n        int sum_a = digit_sum(a.first);\n        int sum_b = digit_sum(b.first);\n        if (sum_a == sum_b) {\n            return a.second < b.second; // If sums are equal, sort by original index\n        }\n        return sum_a < sum_b; // Sort by sum of digits\n    });\n\n    // Extract the sorted numbers into a result vector\n    vector<int> result;\n    for (const auto& p : indexed_nums) {\n        result.push_back(p.first);\n    }\n    return result;\n}\n"}
{"task_id": "CPP/84", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring solve(int N) {\n    int sum = 0;\n\n    // Calculate the sum of digits\n    while (N > 0) {\n        sum += N % 10; // Add the last digit to sum\n        N /= 10;       // Remove the last digit\n    }\n\n    // Convert the sum to binary\n    string binary = \"\";\n    if (sum == 0) {\n        binary = \"0\"; // Special case for sum = 0\n    } else {\n        while (sum > 0) {\n            binary = to_string(sum % 2) + binary; // Prepend the binary digit\n            sum /= 2; // Divide by 2 to shift right\n        }\n    }\n\n    return binary;\n}\n\n"}
{"task_id": "CPP/113", "generation": "#include <vector>\n#include <string>\n#include <sstream>\nusing namespace std;\n\nvector<string> odd_count(vector<string> lst) {\n    vector<string> result;\n    for (const string& s : lst) {\n        int odd_count = 0;\n        for (char c : s) {\n            if ((c - '0') % 2 != 0) { // Check if the digit is odd\n                odd_count++;\n            }\n        }\n        // Create the formatted string\n        stringstream ss;\n        ss << \"the number of odd elements \" << odd_count \n           << \"n the str\" << odd_count \n           << \"ng \" << odd_count \n           << \" of the \" << odd_count << \"nput.\";\n        result.push_back(ss.str());\n    }\n    return result;\n}\n"}
{"task_id": "CPP/36", "generation": "#include <iostream>\nusing namespace std;\n\nint count_sevens(int number) {\n    int count = 0;\n    while (number > 0) {\n        if (number % 10 == 7) {\n            count++;\n        }\n        number /= 10;\n    }\n    return count;\n}\n\nint fizz_buzz(int n) {\n    int total_count = 0;\n    for (int i = 1; i < n; i++) {\n        if (i % 11 == 0 || i % 13 == 0) {\n            total_count += count_sevens(i);\n        }\n    }\n    return total_count;\n}\n\n"}
{"task_id": "CPP/144", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nbool simplify(string x, string n) {\n    // Split the first fraction x\n    size_t pos = x.find('/');\n    int num1 = stoi(x.substr(0, pos)); // numerator of x\n    int den1 = stoi(x.substr(pos + 1)); // denominator of x\n\n    // Split the second fraction n\n    pos = n.find('/');\n    int num2 = stoi(n.substr(0, pos)); // numerator of n\n    int den2 = stoi(n.substr(pos + 1)); // denominator of n\n\n    // Calculate the product of the fractions\n    // (num1/den1) * (num2/den2) = (num1 * num2) / (den1 * den2)\n    int numerator = num1 * num2;\n    int denominator = den1 * den2;\n\n    // Check if the result is a whole number\n    return (numerator % denominator == 0);\n}\n\n"}
{"task_id": "CPP/0", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // for std::sort\n#include <cmath>     // for std::abs\n\nusing namespace std;\n\nbool has_close_elements(vector<float> numbers, float threshold) {\n    // Sort the numbers\n    sort(numbers.begin(), numbers.end());\n    \n    // Check adjacent elements for closeness\n    for (size_t i = 0; i < numbers.size() - 1; ++i) {\n        if (fabs(numbers[i + 1] - numbers[i]) < threshold) {\n            return true; // Found two numbers that are too close\n        }\n    }\n    \n    return false; // No pairs found that are too close\n}\n\n// Example usage\n"}
{"task_id": "CPP/17", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nvector<int> parse_music(string music_string) {\n    vector<int> beats;\n    stringstream ss(music_string);\n    string note;\n\n    while (ss >> note) {\n        if (note == \"o\") {\n            beats.push_back(4); // whole note\n        } else if (note == \"o|\") {\n            beats.push_back(2); // half note\n        } else if (note == \".|\") {\n            beats.push_back(1); // quarter note\n        }\n    }\n\n    return beats;\n}\n\n"}
{"task_id": "CPP/47", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nfloat median(vector<float> l) {\n    // Sort the vector\n    sort(l.begin(), l.end());\n    \n    // Get the size of the vector\n    size_t size = l.size();\n    \n    // If the size is odd, return the middle element\n    if (size % 2 == 1) {\n        return l[size / 2];\n    } else {\n        // If the size is even, return the average of the two middle elements\n        return (l[size / 2 - 1] + l[size / 2]) / 2.0;\n    }\n}\n\n"}
{"task_id": "CPP/75", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\n// Function to generate all prime numbers less than 100\nvector<int> generate_primes() {\n    vector<int> primes;\n    for (int i = 2; i < 100; i++) {\n        if (is_prime(i)) {\n            primes.push_back(i);\n        }\n    }\n    return primes;\n}\n\n// Function to check if the number is a product of three primes\nbool is_multiply_prime(int a) {\n    vector<int> primes = generate_primes();\n    int size = primes.size();\n\n    // Check all combinations of three primes\n    for (int i = 0; i < size; i++) {\n        for (int j = i; j < size; j++) {\n            for (int k = j; k < size; k++) {\n                int product = primes[i] * primes[j] * primes[k];\n                if (product == a) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n\n"}
{"task_id": "CPP/124", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nbool valid_date(string date) {\n    // Check if the date string is empty\n    if (date.empty()) {\n        return false;\n    }\n\n    // Check if the date is in the correct format mm-dd-yyyy\n    if (date.size() != 10 || date[2] != '-' || date[5] != '-') {\n        return false;\n    }\n\n    // Extract month, day, and year\n    int month, day, year;\n    stringstream ss(date);\n    string monthStr, dayStr, yearStr;\n\n    getline(ss, monthStr, '-');\n    getline(ss, dayStr, '-');\n    getline(ss, yearStr);\n\n    // Convert strings to integers\n    month = stoi(monthStr);\n    day = stoi(dayStr);\n    year = stoi(yearStr);\n\n    // Validate month\n    if (month < 1 || month > 12) {\n        return false;\n    }\n\n    // Validate day based on month\n    if (day < 1) {\n        return false;\n    }\n\n    if (month == 2) {\n        // February: 1-29 days (ignoring leap years for simplicity)\n        if (day > 29) {\n            return false;\n        }\n    } else if (month == 4 || month == 6 || month == 9 || month == 11) {\n        // April, June, September, November: 1-30 days\n        if (day > 30) {\n            return false;\n        }\n    } else {\n        // January, March, May, July, August, October, December: 1-31 days\n        if (day > 31) {\n            return false;\n        }\n    }\n\n    // If all checks passed, the date is valid\n    return true;\n}\n\n"}
{"task_id": "CPP/101", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <cctype>\n\nusing namespace std;\n\nvector<string> words_string(string s) {\n    vector<string> words;\n    string word;\n    // Replace commas with spaces to simplify splitting\n    for (char &c : s) {\n        if (c == ',') {\n            c = ' ';\n        }\n    }\n    \n    // Use istringstream to split the string by spaces\n    istringstream stream(s);\n    while (stream >> word) {\n        words.push_back(word);\n    }\n    \n    return words;\n}\n\n"}
{"task_id": "CPP/14", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> all_prefixes(string str) {\n    vector<string> prefixes; // Vector to store the prefixes\n    for (size_t i = 1; i <= str.length(); ++i) { // Loop from 1 to length of the string\n        prefixes.push_back(str.substr(0, i)); // Extract prefix and add to the vector\n    }\n    return prefixes; // Return the vector of prefixes\n}\n\n"}
{"task_id": "CPP/141", "generation": "#include <iostream>\n#include <string>\n#include <cctype>\n\nusing namespace std;\n\nstring file_name_check(string file_name) {\n    // Check for exactly one dot\n    size_t dot_pos = file_name.find('.');\n    if (dot_pos == string::npos || file_name.find('.', dot_pos + 1) != string::npos) {\n        return \"No\";\n    }\n\n    // Split the file name into name and extension\n    string name_part = file_name.substr(0, dot_pos);\n    string ext_part = file_name.substr(dot_pos + 1);\n\n    // Check if the name part is empty\n    if (name_part.empty()) {\n        return \"No\";\n    }\n\n    // Check if the name part starts with a letter\n    if (!isalpha(name_part[0])) {\n        return \"No\";\n    }\n\n    // Count digits in the name part\n    int digit_count = 0;\n    for (char c : name_part) {\n        if (isdigit(c)) {\n            digit_count++;\n        }\n    }\n    if (digit_count > 3) {\n        return \"No\";\n    }\n\n    // Check if the extension is valid\n    if (ext_part == \"txt\" || ext_part == \"exe\" || ext_part == \"dll\") {\n        return \"Yes\";\n    }\n\n    return \"No\";\n}\n\n"}
{"task_id": "CPP/123", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> get_odd_collatz(int n) {\n    vector<int> odd_numbers; // Vector to store odd numbers in the Collatz sequence\n\n    // Generate the Collatz sequence\n    while (n != 1) {\n        if (n % 2 != 0) { // Check if n is odd\n            odd_numbers.push_back(n); // Add odd number to the vector\n        }\n        // Apply the Collatz rules\n        if (n % 2 == 0) {\n            n = n / 2; // If n is even, divide by 2\n        } else {\n            n = 3 * n + 1; // If n is odd, apply 3n + 1\n        }\n    }\n    \n    // Add 1 to the list since the sequence always ends with 1\n    odd_numbers.push_back(1);\n\n    // Sort the vector of odd numbers\n    sort(odd_numbers.begin(), odd_numbers.end());\n\n    return odd_numbers; // Return the sorted vector of odd numbers\n}\n\n// Example usage\n"}
{"task_id": "CPP/148", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nvector<string> bf(string planet1, string planet2) {\n    // Define the order of planets\n    vector<string> planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n    \n    // Find the indices of the given planets\n    auto it1 = find(planets.begin(), planets.end(), planet1);\n    auto it2 = find(planets.begin(), planets.end(), planet2);\n    \n    // Check if both planets are valid\n    if (it1 == planets.end() || it2 == planets.end()) {\n        return {}; // Return empty vector if either planet is invalid\n    }\n    \n    // Get the indices of the planets\n    int index1 = distance(planets.begin(), it1);\n    int index2 = distance(planets.begin(), it2);\n    \n    // Ensure index1 is less than index2\n    if (index1 > index2) {\n        swap(index1, index2);\n    }\n    \n    // Collect planets between index1 and index2\n    vector<string> result;\n    for (int i = index1 + 1; i < index2; ++i) {\n        result.push_back(planets[i]);\n    }\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/133", "generation": "#include <iostream>\n#include <cmath>\n#include <vector>\n\nusing namespace std;\n\nint sum_squares(vector<float> lst) {\n    int sum = 0;\n    for (float num : lst) {\n        int rounded = ceil(num); // Round up to the nearest integer\n        sum += rounded * rounded; // Square the rounded value and add to sum\n    }\n    return sum;\n}\n\n"}
{"task_id": "CPP/109", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool move_one_ball(vector<int> arr) {\n    if (arr.empty()) return true; // An empty vector is considered sorted.\n\n    int count = 0;\n    int n = arr.size();\n\n    for (int i = 0; i < n; i++) {\n        // Check if the current element is greater than the next element\n        if (arr[i] > arr[(i + 1) % n]) {\n            count++;\n        }\n    }\n\n    // If there is more than one point of discontinuity, return false\n    return count <= 1;\n}\n\n// Example usage\n"}
{"task_id": "CPP/100", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> make_a_pile(int n) {\n    vector<int> levels; // Vector to store the number of stones in each level\n    int current_stones = n; // Start with n stones for the first level\n\n    for (int i = 0; i < n; i++) {\n        levels.push_back(current_stones); // Add the current level's stones to the vector\n        // Determine the next number of stones based on whether n is odd or even\n        if (n % 2 == 0) {\n            // n is even, so we add 2 to get the next even number\n            current_stones += 2;\n        } else {\n            // n is odd, so we add 2 to get the next odd number\n            current_stones += 2;\n        }\n    }\n\n    return levels; // Return the vector containing the number of stones in each level\n}\n\n"}
{"task_id": "CPP/150", "generation": "#include <iostream>\nusing namespace std;\n\n// Function to check if a number is prime\nbool isPrime(int n) {\n    if (n <= 1) return false; // 0 and 1 are not prime numbers\n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0) return false; // n is divisible by i, hence not prime\n    }\n    return true; // n is prime\n}\n\n// Function to return x if n is prime, otherwise return y\nint x_or_y(int n, int x, int y) {\n    if (isPrime(n)) {\n        return x; // Return x if n is prime\n    } else {\n        return y; // Return y if n is not prime\n    }\n}\n\n"}
{"task_id": "CPP/153", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nstring Strongest_Extension(string class_name, vector<string> extensions) {\n    int max_strength = -1; // Initialize to a value lower than any possible strength\n    string strongest_extension = \"\";\n\n    for (const string& ext : extensions) {\n        int CAP = 0; // Count of uppercase letters\n        int SM = 0;  // Count of lowercase letters\n\n        // Calculate CAP and SM\n        for (char c : ext) {\n            if (isupper(c)) {\n                CAP++;\n            } else if (islower(c)) {\n                SM++;\n            }\n        }\n\n        // Calculate strength\n        int strength = CAP - SM;\n\n        // Update if this extension is stronger\n        if (strength > max_strength) {\n            max_strength = strength;\n            strongest_extension = ext;\n        }\n    }\n\n    // Return the result in the specified format\n    return class_name + \".\" + strongest_extension;\n}\n\n// Example usage\n"}
{"task_id": "CPP/107", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to check if a number is a palindrome\nbool isPalindrome(int num) {\n    string str = to_string(num);\n    string revStr = string(str.rbegin(), str.rend());\n    return str == revStr;\n}\n\n// Function to count even and odd palindromes\nvector<int> even_odd_palindrome(int n) {\n    int evenCount = 0;\n    int oddCount = 0;\n\n    for (int i = 1; i <= n; ++i) {\n        if (isPalindrome(i)) {\n            if (i % 2 == 0) {\n                evenCount++;\n            } else {\n                oddCount++;\n            }\n        }\n    }\n\n    return {evenCount, oddCount};\n}\n\n// Example usage\n"}
{"task_id": "CPP/110", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring exchange(vector<int> lst1, vector<int> lst2) {\n    int oddCount = 0; // Count of odd numbers in lst1\n    int evenCountInLst2 = 0; // Count of even numbers in lst2\n\n    // Count odd numbers in lst1\n    for (int num : lst1) {\n        if (num % 2 != 0) {\n            oddCount++;\n        }\n    }\n\n    // Count even numbers in lst2\n    for (int num : lst2) {\n        if (num % 2 == 0) {\n            evenCountInLst2++;\n        }\n    }\n\n    // Check if we can replace all odd numbers in lst1 with even numbers from lst2\n    if (oddCount <= evenCountInLst2) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n\n// Example usage\n"}
{"task_id": "CPP/111", "generation": "#include <iostream>\n#include <string>\n#include <map>\n#include <sstream>\n#include <algorithm>\nusing namespace std;\n\nmap<string, int> histogram(string test) {\n    map<string, int> countMap;\n    stringstream ss(test);\n    string letter;\n\n    // Count occurrences of each letter\n    while (ss >> letter) {\n        countMap[letter]++;\n    }\n\n    // Find the maximum occurrence\n    int maxCount = 0;\n    for (const auto& pair : countMap) {\n        maxCount = max(maxCount, pair.second);\n    }\n\n    // Create a result map for letters with the maximum occurrence\n    map<string, int> result;\n    for (const auto& pair : countMap) {\n        if (pair.second == maxCount) {\n            result[pair.first] = pair.second;\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/80", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_happy(string s) {\n    // Check if the length of the string is at least 3\n    if (s.length() < 3) {\n        return false;\n    }\n    \n    // Iterate through the string and check every 3 consecutive characters\n    for (size_t i = 0; i <= s.length() - 3; ++i) {\n        // Check if the three characters are distinct\n        if (s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]) {\n            return false;\n        }\n    }\n    \n    // If all groups of 3 characters are distinct, return true\n    return true;\n}\n\n"}
{"task_id": "CPP/41", "generation": "#include <stdio.h>\n\nint car_race_collision(int n) {\n    // Each car moving left to right will collide with each car moving right to left\n    return n * n; // Total collisions = n (left to right) * n (right to left)\n}\n\n"}
{"task_id": "CPP/116", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> sort_array(vector<int> arr) {\n    // Define a custom sorting function\n    auto sort_key = [](int x) {\n        return make_pair(__builtin_popcount(x), x); // Count of ones in binary, then the number itself\n    };\n\n    // Sort the array using the custom key\n    sort(arr.begin(), arr.end(), [&](int a, int b) {\n        return sort_key(a) < sort_key(b);\n    });\n\n    return arr;\n}\n"}
{"task_id": "CPP/61", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    int balance = 0; // This will keep track of the balance of brackets\n\n    for (char ch : brackets) {\n        if (ch == '(') {\n            balance++; // Increment balance for an opening bracket\n        } else if (ch == ')') {\n            balance--; // Decrement balance for a closing bracket\n        }\n\n        // If balance goes negative, it means there's a closing bracket without a matching opening bracket\n        if (balance < 0) {\n            return false; // Unmatched closing bracket\n        }\n    }\n\n    // At the end, balance should be zero if all brackets are matched\n    return balance == 0;\n}\n\n// Test cases\n"}
{"task_id": "CPP/25", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> factorize(int n) {\n    vector<int> factors;\n    \n    // Check for number of 2s that divide n\n    while (n % 2 == 0) {\n        factors.push_back(2);\n        n /= 2;\n    }\n    \n    // n must be odd at this point, so we can skip even numbers\n    for (int i = 3; i * i <= n; i += 2) {\n        // While i divides n, add i and divide n\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n    \n    // This condition is to check if n is a prime number greater than 2\n    if (n > 2) {\n        factors.push_back(n);\n    }\n    \n    return factors;\n}\n\n"}
{"task_id": "CPP/137", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <boost/any.hpp>\n#include <sstream>\n\nusing namespace std;\n\nfloat parse_value(const boost::any& value) {\n    if (value.type() == typeid(string)) {\n        string str_value = boost::any_cast<string>(value);\n        // Replace ',' with '.' for proper float conversion\n        replace(str_value.begin(), str_value.end(), ',', '.');\n        return stof(str_value);\n    } else if (value.type() == typeid(float)) {\n        return boost::any_cast<float>(value);\n    } else if (value.type() == typeid(int)) {\n        return static_cast<float>(boost::any_cast<int>(value));\n    }\n    throw invalid_argument(\"Invalid type\");\n}\n\nboost::any compare_one(boost::any a, boost::any b) {\n    try {\n        float a_float = parse_value(a);\n        float b_float = parse_value(b);\n\n        if (a_float > b_float) {\n            return a; // Return the original value of a\n        } else if (b_float > a_float) {\n            return b; // Return the original value of b\n        } else {\n            return \"None\"; // Return \"None\" if they are equal\n        }\n    } catch (const invalid_argument&) {\n        return \"None\"; // Return \"None\" if conversion fails\n    }\n}\n\n"}
{"task_id": "CPP/102", "generation": "#include <iostream>\nusing namespace std;\n\nint choose_num(int x, int y) {\n    // Ensure x is less than or equal to y\n    if (x > y) {\n        return -1; // If x is greater than y, return -1\n    }\n\n    // Find the largest even number in the range [x, y]\n    if (y % 2 != 0) {\n        y--; // If y is odd, decrement it to make it even\n    }\n\n    // Now check if y is still within the range [x, y]\n    if (y >= x) {\n        return y; // Return the largest even number\n    } else {\n        return -1; // No even number in the range\n    }\n}\n\n"}
{"task_id": "CPP/10", "generation": "#include <stdio.h>\n#include <string>\n#include <algorithm> // Include for std::reverse\nusing namespace std;\n\nbool is_palindrome(string str) {\n    // Test if given string is a palindrome \n    string s(str.rbegin(), str.rend());\n    return s == str;\n}\n\nstring make_palindrome(string str) {\n    /*\n    Find the shortest palindrome that begins with a supplied string. \n    Algorithm idea is simple: - Find the longest postfix of supplied string that is a palindrome. \n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome(\"\") \n    \"\" \n    >>> make_palindrome(\"cat\") \n    \"catac\" \n    >>> make_palindrome(\"cata\") \n    \"catac\" \n    */\n    if (str.empty()) {\n        return str; // Return empty string if input is empty\n    }\n\n    // Find the longest palindromic suffix\n    for (size_t i = 0; i < str.length(); i++) {\n        if (is_palindrome(str.substr(i))) {\n            // Create a reversed string from the prefix before the palindromic suffix\n            string prefix = string(str.begin(), str.begin() + i);\n            string reversed_prefix(prefix.rbegin(), prefix.rend());\n            return str + reversed_prefix;\n        }\n    }\n\n    return str + string(str.rbegin(), str.rend()); // In case no palindromic suffix is found\n}\n"}
{"task_id": "CPP/76", "generation": "#include <iostream>\n#include <cmath>\nusing namespace std;\n\nbool is_simple_power(int x, int n) {\n    // Handle special cases\n    if (n <= 1) {\n        return (n == 1 && x == 1); // 1^k = 1 for any k, and 0^k is not defined\n    }\n    if (x < 1) {\n        return false; // x must be a positive integer\n    }\n\n    int power = 1; // Start with n^0 which is 1\n    while (power < x) {\n        power *= n; // Calculate n^k\n    }\n\n    return power == x; // Check if we found n^k = x\n}\n\n"}
{"task_id": "CPP/94", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nint sum_of_digits(int n) {\n    int sum = 0;\n    while (n > 0) {\n        sum += n % 10;\n        n /= 10;\n    }\n    return sum;\n}\n\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    for (int i = 2; i * i <= num; i++) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\nint skjkasdkd(vector<int> lst) {\n    int largest_prime = -1;\n    for (int number : lst) {\n        if (is_prime(number) && number > largest_prime) {\n            largest_prime = number;\n        }\n    }\n    if (largest_prime == -1) {\n        return 0; // If no prime number is found\n    }\n    return sum_of_digits(largest_prime);\n}\n"}
{"task_id": "CPP/32", "generation": "#include <stdio.h>\n#include <math.h>\n#include <vector>\n#include <stdexcept>\n\nusing namespace std;\n\ndouble poly(vector<double> xs, double x) {\n    double sum = 0;\n    for (int i = 0; i < xs.size(); i++) {\n        sum += xs[i] * pow(x, i);\n    }\n    return sum;\n}\n\ndouble poly_derivative(vector<double> xs, double x) {\n    double sum = 0;\n    for (int i = 1; i < xs.size(); i++) {\n        sum += i * xs[i] * pow(x, i - 1);\n    }\n    return sum;\n}\n\ndouble find_zero(vector<double> xs) {\n    // Check if the input has an even number of coefficients\n    if (xs.size() % 2 != 0) {\n        throw invalid_argument(\"The number of coefficients must be even.\");\n    }\n\n    // Initial guess (can be adjusted based on the polynomial)\n    double x0 = 0.0;\n\n    // Newton-Raphson method parameters\n    const double tolerance = 1e-7;\n    const int max_iterations = 1000;\n\n    for (int i = 0; i < max_iterations; i++) {\n        double f_x0 = poly(xs, x0);\n        double f_prime_x0 = poly_derivative(xs, x0);\n\n        // Avoid division by zero\n        if (fabs(f_prime_x0) < tolerance) {\n            throw runtime_error(\"Derivative is too small; no convergence.\");\n        }\n\n        // Update x using Newton-Raphson formula\n        double x1 = x0 - f_x0 / f_prime_x0;\n\n        // Check for convergence\n        if (fabs(x1 - x0) < tolerance) {\n            return x1; // Found a root\n        }\n\n        x0 = x1; // Update x0 for the next iteration\n    }\n\n    throw runtime_error(\"Maximum iterations reached; no convergence.\");\n}\n\n"}
{"task_id": "CPP/33", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> sort_third(vector<int> l) {\n    // Create a vector to hold the values at indices divisible by 3\n    vector<int> thirdValues;\n\n    // Collect values at indices divisible by 3\n    for (size_t i = 0; i < l.size(); ++i) {\n        if (i % 3 == 0) {\n            thirdValues.push_back(l[i]);\n        }\n    }\n\n    // Sort the collected values\n    sort(thirdValues.begin(), thirdValues.end());\n\n    // Replace the values in the original vector at indices divisible by 3\n    size_t j = 0; // Index for sorted values\n    for (size_t i = 0; i < l.size(); ++i) {\n        if (i % 3 == 0) {\n            l[i] = thirdValues[j++];\n        }\n    }\n\n    return l;\n}\n\n"}
{"task_id": "CPP/88", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> sort_array(const vector<int>& array) {\n    // Step 1: Check if the vector is empty\n    if (array.empty()) {\n        return {};\n    }\n    \n    // Step 2: If the vector has only one element, return a copy of that vector\n    if (array.size() == 1) {\n        return array;\n    }\n    \n    // Step 3: Calculate the sum of the first and last elements\n    int sum = array.front() + array.back();\n    \n    // Step 4: Create a copy of the original array to sort\n    vector<int> sorted_array = array;\n    \n    // Step 5: Sort based on the sum being odd or even\n    if (sum % 2 == 0) {\n        // Even sum: sort in descending order\n        sort(sorted_array.rbegin(), sorted_array.rend());\n    } else {\n        // Odd sum: sort in ascending order\n        sort(sorted_array.begin(), sorted_array.end());\n    }\n    \n    // Step 6: Return the sorted vector\n    return sorted_array;\n}\n\n// Example usage\n"}
{"task_id": "CPP/15", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nstring string_sequence(int n) {\n    stringstream ss; // Create a stringstream to build the output string\n    for (int i = 0; i <= n; ++i) {\n        ss << i; // Add the current number to the stringstream\n        if (i < n) {\n            ss << \" \"; // Add a space if it's not the last number\n        }\n    }\n    return ss.str(); // Convert the stringstream to a string and return it\n}\n\n"}
{"task_id": "CPP/163", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> generate_integers(int a, int b) {\n    vector<int> even_digits = {2, 4, 6, 8}; // List of even digits\n    vector<int> result;\n\n    // Determine the range\n    int start = min(a, b);\n    int end = max(a, b);\n\n    // Iterate through the even digits\n    for (int digit : even_digits) {\n        if (digit >= start && digit <= end) {\n            result.push_back(digit);\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/1", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cctype> // for isspace\n\nusing namespace std;\n\nvector<string> separate_paren_groups(string paren_string) {\n    vector<string> result;\n    string current_group;\n    int balance = 0;\n\n    for (char ch : paren_string) {\n        if (isspace(ch)) {\n            continue; // Ignore spaces\n        }\n        \n        if (ch == '(') {\n            if (balance == 0 && !current_group.empty()) {\n                // If we are starting a new group and current_group is not empty,\n                // we should push the current group to the result.\n                result.push_back(current_group);\n                current_group.clear();\n            }\n            current_group += ch; // Add the opening parenthesis\n            balance++;\n        } else if (ch == ')') {\n            current_group += ch; // Add the closing parenthesis\n            balance--;\n        }\n\n        // If balance is zero, we have a complete group\n        if (balance == 0 && !current_group.empty()) {\n            result.push_back(current_group);\n            current_group.clear(); // Clear for the next group\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/69", "generation": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint search(vector<int> lst) {\n    unordered_map<int, int> frequencyMap;\n\n    // Count the frequency of each integer in the vector\n    for (int num : lst) {\n        frequencyMap[num]++;\n    }\n\n    int result = -1;\n\n    // Check for the greatest integer that meets the condition\n    for (const auto& pair : frequencyMap) {\n        int value = pair.first;\n        int frequency = pair.second;\n\n        // Check if the frequency is greater than or equal to the value\n        if (frequency >= value) {\n            result = max(result, value);\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/31", "generation": "#include <iostream>\nusing namespace std;\n\nbool is_prime(long long n) {\n    // Check for numbers less than or equal to 1\n    if (n <= 1) {\n        return false;\n    }\n    // Check for 2 and 3\n    if (n <= 3) {\n        return true;\n    }\n    // Eliminate even numbers and multiples of 3\n    if (n % 2 == 0 || n % 3 == 0) {\n        return false;\n    }\n    // Check for factors from 5 to the square root of n\n    for (long long i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\n"}
{"task_id": "CPP/147", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint get_max_triples(int n) {\n    vector<int> a(n);\n    \n    // Generate the vector a\n    for (int i = 1; i <= n; ++i) {\n        a[i - 1] = i * i - i + 1; // a[i] corresponds to a[i-1] in 0-based index\n    }\n    \n    // Count the number of valid triples\n    int count = 0;\n    \n    // Check all combinations of triples (i, j, k) with i < j < k\n    for (int i = 0; i < n - 2; ++i) {\n        for (int j = i + 1; j < n - 1; ++j) {\n            for (int k = j + 1; k < n; ++k) {\n                if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                    count++;\n                }\n            }\n        }\n    }\n    \n    return count;\n}\n\n"}
{"task_id": "CPP/105", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nvector<string> by_length(vector<int> arr) {\n    // Step 1: Filter the input vector to keep only integers between 1 and 9\n    vector<int> filtered;\n    for (int num : arr) {\n        if (num >= 1 && num <= 9) {\n            filtered.push_back(num);\n        }\n    }\n\n    // Step 2: Sort the filtered integers\n    sort(filtered.begin(), filtered.end());\n\n    // Step 3: Reverse the sorted integers\n    reverse(filtered.begin(), filtered.end());\n\n    // Step 4: Map integers to their corresponding string representations\n    vector<string> result;\n    vector<string> names = {\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"};\n\n    for (int num : filtered) {\n        result.push_back(names[num - 1]); // num - 1 to get the correct index\n    }\n\n    // Step 5: Return the resulting vector of strings\n    return result;\n}\n\n// Example usage\n"}
{"task_id": "CPP/22", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <boost/any.hpp>\n#include <list>\n#include <typeinfo>\n\ntypedef std::list<boost::any> list_any;\n\nstd::vector<int> filter_integers(list_any values) {\n    std::vector<int> result;\n\n    for (const auto& value : values) {\n        // Check if the value can be cast to an int\n        if (value.type() == typeid(int)) {\n            // Safe to cast\n            result.push_back(boost::any_cast<int>(value));\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/52", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool below_threshold(vector<int> l, int t) {\n    for (int num : l) {\n        if (num >= t) {\n            return false; // Found a number that is not below the threshold\n        }\n    }\n    return true; // All numbers are below the threshold\n}\n\n"}
{"task_id": "CPP/154", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nbool cycpattern_check(string a, string b) {\n    // Create a new string that is the concatenation of b with itself\n    string b_rotations = b + b;\n    // Check if b or any of its rotations is a substring of a\n    return (b_rotations.find(a) != string::npos) && (b.length() <= a.length());\n}\n"}
{"task_id": "CPP/115", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint max_fill(vector<vector<int>> grid, int capacity) {\n    int total_lowers = 0;\n\n    for (const auto& well : grid) {\n        int water_units = 0;\n\n        // Count the number of water units (1s) in the current well (row)\n        for (int water : well) {\n            if (water == 1) {\n                water_units++;\n            }\n        }\n\n        // Calculate how many times we need to lower the bucket for this well\n        if (water_units > 0) {\n            total_lowers += (water_units + capacity - 1) / capacity; // Equivalent to ceil(water_units / capacity)\n        }\n    }\n\n    return total_lowers;\n}\n\n"}
{"task_id": "CPP/131", "generation": "#include <stdio.h>\n\nint digits(int n) {\n    int product = 1;\n    bool foundOdd = false;\n\n    while (n > 0) {\n        int digit = n % 10; // Get the last digit\n        if (digit % 2 != 0) { // Check if the digit is odd\n            product *= digit; // Multiply to the product\n            foundOdd = true; // Mark that we found an odd digit\n        }\n        n /= 10; // Remove the last digit\n    }\n\n    return foundOdd ? product : 0; // Return product or 0 if no odd digits found\n}\n\n"}
{"task_id": "CPP/37", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<float> sort_even(vector<float> l) {\n    // Create a vector to hold the even indexed values\n    vector<float> even_values;\n\n    // Extract even indexed values\n    for (size_t i = 0; i < l.size(); i += 2) {\n        even_values.push_back(l[i]);\n    }\n\n    // Sort the even indexed values\n    sort(even_values.begin(), even_values.end());\n\n    // Create a new vector for the result\n    vector<float> result(l.size());\n\n    // Place sorted even values and original odd values into the result\n    for (size_t i = 0; i < l.size(); ++i) {\n        if (i % 2 == 0) {\n            result[i] = even_values[i / 2]; // Place sorted even value\n        } else {\n            result[i] = l[i]; // Keep original odd value\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/92", "generation": "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\nbool any_int(float a, float b, float c) {\n    // Check if all numbers are integers\n    if (floor(a) != a || floor(b) != b || floor(c) != c) {\n        return false;\n    }\n    \n    // Check if one number is equal to the sum of the other two\n    return (a == b + c) || (b == a + c) || (c == a + b);\n}\n\n"}
{"task_id": "CPP/118", "generation": "#include <stdio.h>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nstring get_closest_vowel(string word) {\n    string vowels = \"aeiouAEIOU\";\n    int n = word.length();\n    \n    // Start from the end of the word and look for consonants and vowels\n    for (int i = n - 1; i >= 2; i--) {\n        if (vowels.find(word[i]) != string::npos && \n            vowels.find(word[i - 1]) == string::npos && \n            vowels.find(word[i - 2]) == string::npos) {\n            return string(1, word[i]); // Return the vowel found\n        }\n    }\n    \n    return \"\"; // Return empty string if no valid vowel is found\n}\n"}
{"task_id": "CPP/6", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nvector<int> parse_nested_parens(string paren_string) {\n    vector<int> depths; // Vector to store the maximum depth for each group\n    stringstream ss(paren_string); // Create a string stream to split the input string\n    string group; // Variable to hold each group of parentheses\n\n    // Process each group separated by spaces\n    while (ss >> group) {\n        int current_depth = 0; // Current depth of nesting\n        int max_depth = 0; // Maximum depth found in this group\n\n        // Traverse through each character in the group\n        for (char ch : group) {\n            if (ch == '(') {\n                current_depth++; // Increase depth for opening parenthesis\n                max_depth = max(max_depth, current_depth); // Update max depth\n            } else if (ch == ')') {\n                current_depth--; // Decrease depth for closing parenthesis\n            }\n        }\n\n        depths.push_back(max_depth); // Store the maximum depth for this group\n    }\n\n    return depths; // Return the vector of maximum depths\n}\n\n// Example usage\n"}
{"task_id": "CPP/87", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<vector<int>> get_row(vector<vector<int>> lst, int x) {\n    vector<vector<int>> result;\n\n    // Iterate through each row\n    for (int i = 0; i < lst.size(); ++i) {\n        // Iterate through each column in the current row\n        for (int j = 0; j < lst[i].size(); ++j) {\n            // Check if the current element matches x\n            if (lst[i][j] == x) {\n                // Store the coordinates {row, column}\n                result.push_back({i, j});\n            }\n        }\n    }\n\n    // Sort the result first by row (ascending) and then by column (descending)\n    sort(result.begin(), result.end(), [](const vector<int>& a, const vector<int>& b) {\n        if (a[0] == b[0]) {\n            return a[1] > b[1]; // Sort by column in descending order if rows are equal\n        }\n        return a[0] < b[0]; // Sort by row in ascending order\n    });\n\n    return result;\n}\n\n// Example usage\n"}
{"task_id": "CPP/2", "generation": "#include <stdio.h>\n#include <math.h>\n\nfloat truncate_number(float number) {\n    // Get the integer part of the number\n    float integer_part = floor(number);\n    \n    // Calculate the decimal part\n    float decimal_part = number - integer_part;\n    \n    return decimal_part;\n}\n\n"}
{"task_id": "CPP/16", "generation": "#include <iostream>\n#include <unordered_set>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nint count_distinct_characters(string str) {\n    unordered_set<char> distinct_chars; // Set to store distinct characters\n\n    // Iterate through each character in the string\n    for (char c : str) {\n        // Convert character to lowercase to ensure case insensitivity\n        distinct_chars.insert(tolower(c));\n    }\n\n    // The size of the set is the number of distinct characters\n    return distinct_chars.size();\n}\n\n"}
{"task_id": "CPP/135", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint can_arrange(vector<int> arr) {\n    int largestIndex = -1; // Initialize to -1, which will be returned if no such element is found\n\n    // Iterate through the vector starting from the second element\n    for (int i = 1; i < arr.size(); i++) {\n        // Check if the current element is less than the previous element\n        if (arr[i] < arr[i - 1]) {\n            largestIndex = i; // Update the largest index\n        }\n    }\n\n    return largestIndex; // Return the largest index found, or -1 if none was found\n}\n\n"}
{"task_id": "CPP/106", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> f(int n) {\n    vector<int> result(n);\n    \n    for (int i = 1; i <= n; ++i) {\n        if (i % 2 == 0) {\n            // Calculate factorial for even index\n            int factorial = 1;\n            for (int j = 1; j <= i; ++j) {\n                factorial *= j;\n            }\n            result[i - 1] = factorial; // Store in the vector (0-based index)\n        } else {\n            // Calculate sum from 1 to i for odd index\n            result[i - 1] = (i * (i + 1)) / 2; // Sum of first i natural numbers\n        }\n    }\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/162", "generation": "#include <stdio.h>\n#include <string>\n#include <openssl/md5.h>\n#include <sstream>\n#include <iomanip>\n\nusing namespace std;\n\nstring string_to_md5(string text) {\n    if (text.empty()) {\n        return \"\"; // Return empty string to indicate None in Python\n    }\n\n    unsigned char digest[MD5_DIGEST_LENGTH];\n    MD5((unsigned char*)text.c_str(), text.length(), digest);\n\n    // Convert the unsigned char array to a hexadecimal string\n    stringstream ss;\n    for (int i = 0; i < MD5_DIGEST_LENGTH; i++) {\n        ss << hex << setw(2) << setfill('0') << (int)digest[i];\n    }\n    return ss.str();\n}\n"}
{"task_id": "CPP/5", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvector<int> intersperse(vector<int> numbers, int delimiter) {\n    // Create a new vector to hold the result\n    vector<int> result;\n\n    // Check if the input vector is empty\n    if (numbers.empty()) {\n        return result; // Return an empty vector\n    }\n\n    // Iterate through the input vector\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        // Add the current element to the result\n        result.push_back(numbers[i]);\n        \n        // If it's not the last element, add the delimiter\n        if (i < numbers.size() - 1) {\n            result.push_back(delimiter);\n        }\n    }\n\n    return result; // Return the result vector\n}\n\n"}
{"task_id": "CPP/97", "generation": "#include <stdio.h>\n\nint multiply(int a, int b) {\n    // Get the unit digits\n    int unitDigitA = abs(a) % 10; // Use abs to handle negative numbers\n    int unitDigitB = abs(b) % 10; // Use abs to handle negative numbers\n    \n    // Return the product of the unit digits\n    return unitDigitA * unitDigitB;\n}\n\n// Example usage\n"}
{"task_id": "CPP/44", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring change_base(int x, int base) {\n    // Check if the base is valid (less than 10)\n    if (base < 2 || base >= 10) {\n        return \"Invalid base\";\n    }\n\n    // Handle the case when x is 0\n    if (x == 0) {\n        return \"0\";\n    }\n\n    string result = \"\";\n    while (x > 0) {\n        int remainder = x % base; // Get the remainder\n        result = to_string(remainder) + result; // Prepend the remainder to the result\n        x /= base; // Divide x by the base\n    }\n\n    return result; // Return the final result\n}\n\n"}
{"task_id": "CPP/161", "generation": "#include <iostream>\n#include <string>\n#include <cctype> // for isalpha, tolower, toupper\n\nusing namespace std;\n\nstring solve(string s) {\n    bool hasLetter = false;\n\n    // First, check if there are any letters in the string\n    for (char c : s) {\n        if (isalpha(c)) {\n            hasLetter = true;\n            break;\n        }\n    }\n\n    // If there are letters, reverse their case\n    if (hasLetter) {\n        for (char &c : s) {\n            if (isalpha(c)) {\n                // Reverse case\n                c = islower(c) ? toupper(c) : tolower(c);\n            }\n        }\n    } else {\n        // If no letters, reverse the entire string\n        reverse(s.begin(), s.end());\n    }\n\n    return s;\n}\n\n"}
{"task_id": "CPP/38", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring encode_cyclic(string s) { \n    // returns encoded string by cycling groups of three characters.  \n    int l = s.length();\n    string output;\n    for (int i = 0; i * 3 < l; i++) {\n        // cycle elements in each group. Unless group has fewer elements than 3.\n        string x = s.substr(i * 3, 3);\n        if (x.length() == 3) {\n            x = x.substr(1) + x[0]; // Move first character to the end\n        }\n        output += x; // Append to output\n    }\n    return output;\n}\n\nstring decode_cyclic(string s) { \n    /*\n    takes as input string encoded with encode_cyclic function. Returns decoded string. \n    */\n    int l = s.length();\n    string output;\n    for (int i = 0; i * 3 < l; i++) {\n        // reverse the cycling of elements in each group.\n        string x = s.substr(i * 3, 3);\n        if (x.length() == 3) {\n            // Move last character to the front\n            x = x[x.length() - 1] + x.substr(0, 2);\n        }\n        output += x; // Append to output\n    }\n    return output;\n}\n\n"}
{"task_id": "CPP/93", "generation": "#include <iostream>\n#include <string>\n#include <cctype>\n\nusing namespace std;\n\nstring encode(string message) {\n    string encodedMessage = \"\";\n\n    for (char ch : message) {\n        // Swap case\n        if (isupper(ch)) {\n            ch = tolower(ch);\n        } else if (islower(ch)) {\n            ch = toupper(ch);\n        }\n\n        // Replace vowels\n        switch (ch) {\n            case 'a':\n                ch = 'c'; // 'a' -> 'c'\n                break;\n            case 'e':\n                ch = 'g'; // 'e' -> 'g'\n                break;\n            case 'i':\n                ch = 'k'; // 'i' -> 'k'\n                break;\n            case 'o':\n                ch = 'q'; // 'o' -> 'q'\n                break;\n            case 'u':\n                ch = 'w'; // 'u' -> 'w'\n                break;\n            case 'A':\n                ch = 'C'; // 'A' -> 'C'\n                break;\n            case 'E':\n                ch = 'G'; // 'E' -> 'G'\n                break;\n            case 'I':\n                ch = 'K'; // 'I' -> 'K'\n                break;\n            case 'O':\n                ch = 'Q'; // 'O' -> 'Q'\n                break;\n            case 'U':\n                ch = 'W'; // 'U' -> 'W'\n                break;\n            default:\n                break; // Non-vowel characters remain unchanged\n        }\n\n        encodedMessage += ch; // Append the modified character to the result\n    }\n\n    return encodedMessage;\n}\n\n"}
{"task_id": "CPP/152", "generation": "#include <iostream>\n#include <vector>\n#include <cmath> // for abs function\n\nusing namespace std;\n\nvector<int> compare(vector<int> game, vector<int> guess) {\n    vector<int> result; // Vector to store the results\n    int n = game.size(); // Get the size of the input vectors\n\n    // Iterate through each match\n    for (int i = 0; i < n; i++) {\n        // Calculate the absolute difference and add to result\n        result.push_back(abs(game[i] - guess[i]));\n    }\n\n    return result; // Return the result vector\n}\n\n"}
{"task_id": "CPP/62", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<float> derivative(vector<float> xs) {\n    vector<float> result;\n    int degree = xs.size() - 1; // The degree of the polynomial\n\n    // Loop through the coefficients, starting from the first term (x^1)\n    for (int i = 1; i <= degree; ++i) {\n        // Calculate the derivative coefficient\n        result.push_back(xs[i] * i);\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/7", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<string> filter_by_substring(const vector<string>& strings, const string& substring) {\n    vector<string> filtered_strings; // Vector to hold the filtered results\n\n    // Iterate through each string in the input vector\n    for (const string& str : strings) {\n        // Check if the substring is found in the current string\n        if (str.find(substring) != string::npos) {\n            filtered_strings.push_back(str); // Add to the result if found\n        }\n    }\n\n    return filtered_strings; // Return the filtered vector\n}\n\n"}
{"task_id": "CPP/24", "generation": "#include <iostream>\nusing namespace std;\n\nint largest_divisor(int n) {\n    // Start from n-1 and go down to 1\n    for (int i = n - 1; i > 0; i--) {\n        if (n % i == 0) {\n            return i; // Return the first divisor found\n        }\n    }\n    return 1; // If no divisors found, return 1 (since 1 divides every number)\n}\n\n"}
{"task_id": "CPP/79", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring decimal_to_binary(int decimal) {\n    // Handle the case for 0 explicitly\n    if (decimal == 0) {\n        return \"db0db\";\n    }\n\n    string binary = \"\";\n    \n    // Convert decimal to binary\n    while (decimal > 0) {\n        // Prepend the remainder (0 or 1) to the binary string\n        binary = to_string(decimal % 2) + binary;\n        decimal /= 2; // Divide the number by 2\n    }\n\n    // Add \"db\" at the beginning and end\n    return \"db\" + binary + \"db\";\n}\n\n"}
{"task_id": "CPP/155", "generation": "#include <iostream>\n#include <vector>\n#include <cmath> // for abs function\n\nusing namespace std;\n\nvector<int> even_odd_count(int num) {\n    // Initialize counts for even and odd digits\n    int even_count = 0;\n    int odd_count = 0;\n\n    // Work with the absolute value of the number\n    num = abs(num);\n\n    // If the number is 0, it has one even digit\n    if (num == 0) {\n        even_count = 1;\n    } else {\n        // Iterate through each digit\n        while (num > 0) {\n            int digit = num % 10; // Get the last digit\n            if (digit % 2 == 0) {\n                even_count++; // Increment even count\n            } else {\n                odd_count++; // Increment odd count\n            }\n            num /= 10; // Remove the last digit\n        }\n    }\n\n    // Return the counts as a vector\n    return {even_count, odd_count};\n}\n\n// Example usage\n"}
{"task_id": "CPP/4", "generation": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nfloat mean_absolute_deviation(const vector<float>& numbers) {\n    if (numbers.empty()) {\n        return 0.0; // Return 0 for empty vector\n    }\n\n    // Step 1: Calculate the mean\n    float sum = 0.0;\n    for (float num : numbers) {\n        sum += num;\n    }\n    float mean = sum / numbers.size();\n\n    // Step 2: Calculate the absolute differences and their sum\n    float mad_sum = 0.0;\n    for (float num : numbers) {\n        mad_sum += fabs(num - mean);\n    }\n\n    // Step 3: Calculate the Mean Absolute Deviation\n    float mad = mad_sum / numbers.size();\n    return mad;\n}\n\n"}
{"task_id": "CPP/56", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    int balance = 0; // Counter for the brackets\n\n    for (char ch : brackets) {\n        if (ch == '<') {\n            balance++; // Increment for opening bracket\n        } else if (ch == '>') {\n            balance--; // Decrement for closing bracket\n        }\n\n        // If balance goes negative, we have more closing than opening\n        if (balance < 0) {\n            return false;\n        }\n    }\n\n    // If balance is zero, all brackets are matched\n    return balance == 0;\n}\n\n"}
{"task_id": "CPP/159", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> eat(int number, int need, int remaining) {\n    int total_eaten = number + min(need, remaining);\n    int remaining_after_meals = max(0, remaining - need);\n    return {total_eaten, remaining_after_meals};\n}\n"}
{"task_id": "CPP/83", "generation": "#include <iostream>\n#include <cmath> // For pow function\n\nusing namespace std;\n\nint starts_one_ends(int n) {\n    if (n < 1) return 0; // Invalid input for n\n\n    // Count of n-digit numbers starting with '1'\n    long long count_starting_with_1 = pow(10, n - 1);\n\n    // Count of n-digit numbers ending with '1'\n    long long count_ending_with_1 = 9 * pow(10, n - 2);\n\n    // Count of n-digit numbers starting and ending with '1'\n    long long count_starting_and_ending_with_1 = pow(10, n - 2);\n\n    // Total count using inclusion-exclusion principle\n    long long total_count = count_starting_with_1 + count_ending_with_1 - count_starting_and_ending_with_1;\n\n    return total_count;\n}\n\n"}
{"task_id": "CPP/27", "generation": "#include <iostream>\n#include <string>\n#include <cctype> // for islower and isupper\n\nusing namespace std;\n\nstring flip_case(string str) {\n    for (char &c : str) { // Iterate through each character in the string\n        if (islower(c)) {\n            c = toupper(c); // Convert to uppercase if it's lowercase\n        } else if (isupper(c)) {\n            c = tolower(c); // Convert to lowercase if it's uppercase\n        }\n    }\n    return str; // Return the modified string\n}\n\n"}
{"task_id": "CPP/146", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nbool isOdd(int digit) {\n    return digit % 2 != 0;\n}\n\nbool hasOddFirstAndLastDigits(int num) {\n    // Convert the number to a string to easily access first and last digits\n    string numStr = to_string(abs(num)); // Use absolute value to handle negative numbers\n    int firstDigit = numStr[0] - '0'; // Convert char to int\n    int lastDigit = numStr[numStr.size() - 1] - '0'; // Convert char to int\n\n    return isOdd(firstDigit) && isOdd(lastDigit);\n}\n\nint specialFilter(vector<int> nums) {\n    int count = 0;\n    for (int num : nums) {\n        if (num > 10 && hasOddFirstAndLastDigits(num)) {\n            count++;\n        }\n    }\n    return count;\n}\n\n"}
{"task_id": "CPP/81", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> numerical_letter_grade(vector<float> grades) {\n    vector<string> letter_grades;\n    for (float gpa : grades) {\n        if (gpa == 4.0) {\n            letter_grades.push_back(\"A+\");\n        } else if (gpa > 3.7) {\n            letter_grades.push_back(\"A\");\n        } else if (gpa > 3.3) {\n            letter_grades.push_back(\"A-\");\n        } else if (gpa > 3.0) {\n            letter_grades.push_back(\"B+\");\n        } else if (gpa > 2.7) {\n            letter_grades.push_back(\"B\");\n        } else if (gpa > 2.3) {\n            letter_grades.push_back(\"B-\");\n        } else if (gpa > 2.0) {\n            letter_grades.push_back(\"C+\");\n        } else if (gpa > 1.7) {\n            letter_grades.push_back(\"C\");\n        } else if (gpa > 1.3) {\n            letter_grades.push_back(\"C-\");\n        } else if (gpa > 1.0) {\n            letter_grades.push_back(\"D+\");\n        } else if (gpa > 0.7) {\n            letter_grades.push_back(\"D\");\n        } else if (gpa > 0.0) {\n            letter_grades.push_back(\"D-\");\n        } else {\n            letter_grades.push_back(\"E\");\n        }\n    }\n    return letter_grades;\n}\n"}
{"task_id": "CPP/136", "generation": "#include <iostream>\n#include <vector>\n#include <limits> // for numeric_limits\n\nusing namespace std;\n\nvector<int> largest_smallest_integers(vector<int> lst) {\n    int largest_negative = numeric_limits<int>::min(); // Initialize to the smallest possible integer\n    int smallest_positive = numeric_limits<int>::max(); // Initialize to the largest possible integer\n\n    bool found_negative = false;\n    bool found_positive = false;\n\n    for (int num : lst) {\n        if (num < 0) {\n            found_negative = true;\n            if (num > largest_negative) {\n                largest_negative = num; // Update largest negative\n            }\n        } else if (num > 0) {\n            found_positive = true;\n            if (num < smallest_positive) {\n                smallest_positive = num; // Update smallest positive\n            }\n        }\n    }\n\n    // If no negative number was found, set to 0\n    if (!found_negative) {\n        largest_negative = 0;\n    }\n    \n    // If no positive number was found, set to 0\n    if (!found_positive) {\n        smallest_positive = 0;\n    }\n\n    return {largest_negative, smallest_positive};\n}\n\n"}
{"task_id": "CPP/67", "generation": "#include <stdio.h>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nint fruit_distribution(string s, int n) {\n    int apples = 0, oranges = 0;\n    stringstream ss(s);\n    ss >> apples; // Read the number of apples\n    ss.ignore(256, ' '); // Ignore the word \"apples\"\n    ss >> oranges; // Read the number of oranges\n    ss.ignore(256, ' '); // Ignore the word \"oranges\"\n    \n    // Calculate the number of mangoes\n    int mangoes = n - apples - oranges;\n    return mangoes;\n}\n"}
{"task_id": "CPP/48", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_palindrome(string text) {\n    int left = 0;\n    int right = text.length() - 1;\n\n    while (left < right) {\n        if (text[left] != text[right]) {\n            return false; // Not a palindrome\n        }\n        left++;\n        right--;\n    }\n    return true; // Is a palindrome\n}\n\n"}
{"task_id": "CPP/125", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nvector<string> split_words(string txt) {\n    vector<string> result;\n    \n    // Check for whitespace\n    if (txt.find(' ') != string::npos) {\n        // Split by whitespace\n        stringstream ss(txt);\n        string word;\n        while (ss >> word) {\n            result.push_back(word);\n        }\n        return result;\n    }\n    \n    // Check for commas\n    if (txt.find(',') != string::npos) {\n        // Split by commas\n        stringstream ss(txt);\n        string word;\n        while (getline(ss, word, ',')) {\n            result.push_back(word);\n        }\n        return result;\n    }\n    \n    // If no whitespace or commas, count lowercase letters with odd order\n    int count = 0;\n    for (char c : txt) {\n        if (c >= 'a' && c <= 'z') {\n            int position = c - 'a'; // Get the position in the alphabet (0-based)\n            if (position % 2 != 0) { // Check if the position is odd\n                count++;\n            }\n        }\n    }\n    \n    // Return the count as a string in a vector\n    return {to_string(count)};\n}\n\n"}
{"task_id": "CPP/160", "generation": "#include <stdio.h>\n#include <math.h>\n#include <vector>\n#include <string>\nusing namespace std;\n#include <algorithm>\n#include <stdlib.h>\n\nint do_algebra(vector<string> operato, vector<int> operand) {\n    int result = operand[0]; // Initialize result with the first operand\n    for (size_t i = 0; i < operato.size(); i++) {\n        if (operato[i] == \"+\") {\n            result += operand[i + 1];\n        } else if (operato[i] == \"-\") {\n            result -= operand[i + 1];\n        } else if (operato[i] == \"*\") {\n            result *= operand[i + 1];\n        } else if (operato[i] == \"//\") {\n            result /= operand[i + 1]; // Using integer division\n        } else if (operato[i] == \"**\") {\n            result = pow(result, operand[i + 1]); // Exponentiation\n        }\n    }\n    return result; // Return the final result\n}\n"}
{"task_id": "CPP/151", "generation": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nlong long double_the_difference(vector<float> lst) {\n    long long sum_of_squares = 0;\n\n    for (float num : lst) {\n        // Check if the number is a non-negative integer\n        if (num >= 0 && floor(num) == num) {\n            int int_num = static_cast<int>(num);\n            // Check if the number is odd\n            if (int_num % 2 != 0) {\n                sum_of_squares += int_num * int_num; // Add the square of the odd number\n            }\n        }\n    }\n\n    return sum_of_squares;\n}\n\n"}
{"task_id": "CPP/117", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <cctype>\n\nusing namespace std;\n\nbool is_consonant(char c) {\n    c = tolower(c); // Convert to lowercase for uniformity\n    return isalpha(c) && !strchr(\"aeiou\", c); // Check if it's a letter and not a vowel\n}\n\nvector<string> select_words(string s, int n) {\n    vector<string> result;\n    stringstream ss(s);\n    string word;\n\n    // Split the string into words\n    while (ss >> word) {\n        int consonant_count = 0;\n\n        // Count consonants in the word\n        for (char c : word) {\n            if (is_consonant(c)) {\n                consonant_count++;\n            }\n        }\n\n        // If the count of consonants matches n, add the word to the result\n        if (consonant_count == n) {\n            result.push_back(word);\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/78", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint hex_key(string num) {\n    // Define the set of prime hexadecimal digits\n    const string prime_hex_digits = \"2357BD\";\n    int count = 0;\n\n    // Iterate through each character in the input string\n    for (char ch : num) {\n        // Check if the character is in the set of prime hexadecimal digits\n        if (prime_hex_digits.find(ch) != string::npos) {\n            count++;\n        }\n    }\n\n    return count;\n}\n\n// Example usage\n"}
{"task_id": "CPP/74", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<string> total_match(vector<string> lst1, vector<string> lst2) {\n    // Function to calculate total number of characters in a vector of strings\n    auto total_chars = [](const vector<string>& lst) {\n        int total = 0;\n        for (const string& str : lst) {\n            total += str.size();\n        }\n        return total;\n    };\n\n    // Calculate total characters for both vectors\n    int total1 = total_chars(lst1);\n    int total2 = total_chars(lst2);\n\n    // Compare totals and return the appropriate vector\n    if (total1 < total2) {\n        return lst1;\n    } else if (total2 < total1) {\n        return lst2;\n    } else {\n        return lst1; // If equal, return the first vector\n    }\n}\n\n// Example usage\n"}
{"task_id": "CPP/53", "generation": "#include <iostream>\nusing namespace std;\n\n// Function to add two numbers\nint add(int x, int y) {\n    return x + y;\n}\n\n"}
{"task_id": "CPP/98", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint count_upper(string s) {\n    int count = 0; // Initialize counter for uppercase vowels\n    for (int i = 0; i < s.length(); i += 2) { // Iterate over even indices\n        char c = s[i]; // Get the character at the current index\n        // Check if the character is an uppercase vowel\n        if (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n            count++; // Increment counter if it is an uppercase vowel\n        }\n    }\n    return count; // Return the final count\n}\n\n"}
{"task_id": "CPP/140", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nstring fix_spaces(string text) {\n    string result;\n    int space_count = 0;\n\n    for (char c : text) {\n        if (c == ' ') {\n            space_count++;\n        } else {\n            if (space_count > 2) {\n                result += '-'; // Replace more than 2 spaces with a hyphen\n            } else if (space_count > 0) {\n                result += string(space_count, '_'); // Replace spaces with underscores\n            }\n            result += c; // Add the current character\n            space_count = 0; // Reset space count\n        }\n    }\n\n    // Handle trailing spaces\n    if (space_count > 2) {\n        result += '-';\n    } else if (space_count > 0) {\n        result += string(space_count, '_');\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/34", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> unique(vector<int> l) {\n    // Sort the vector\n    sort(l.begin(), l.end());\n    \n    // Remove duplicates\n    auto last = unique(l.begin(), l.end());\n    \n    // Resize the vector to the new size\n    l.erase(last, l.end());\n    \n    return l;\n}\n\n"}
{"task_id": "CPP/66", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint digitSum(string s) {\n    int sum = 0; // Initialize the sum to 0\n    for (char c : s) { // Iterate through each character in the string\n        if (isupper(c)) { // Check if the character is uppercase\n            sum += static_cast<int>(c); // Add the ASCII value of the uppercase character to the sum\n        }\n    }\n    return sum; // Return the final sum\n}\n\n"}
{"task_id": "CPP/120", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> maximum(vector<int> arr, int k) {\n    // Step 1: Sort the array in descending order\n    sort(arr.begin(), arr.end(), greater<int>());\n    \n    // Step 2: Select the first k elements\n    vector<int> maxElements(arr.begin(), arr.begin() + k);\n    \n    // Step 3: Sort the selected k elements in ascending order\n    sort(maxElements.begin(), maxElements.end());\n    \n    return maxElements;\n}\n\n// Example usage\n"}
{"task_id": "CPP/139", "generation": "#include <iostream>\nusing namespace std;\n\n// Function to calculate factorial of a number\nlong long factorial(int n) {\n    long long result = 1;\n    for (int i = 1; i <= n; ++i) {\n        result *= i;\n    }\n    return result;\n}\n\n// Function to calculate the Brazilian factorial\nlong long special_factorial(int n) {\n    long long result = 1;\n    for (int i = n; i >= 1; --i) {\n        result *= factorial(i);\n    }\n    return result;\n}\n\n"}
{"task_id": "CPP/12", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nstring longest(vector<string> strings) {\n    if (strings.empty()) {\n        return \"\"; // Return an empty string to represent None\n    }\n\n    string longestString = strings[0]; // Start with the first string\n    for (const string& str : strings) {\n        if (str.length() > longestString.length()) {\n            longestString = str; // Update longestString if a longer string is found\n        }\n    }\n    return longestString; // Return the longest string found\n}\n\n"}
{"task_id": "CPP/121", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint solution(vector<int> lst) {\n    int sum = 0; // Initialize sum to 0\n    for (int i = 0; i < lst.size(); i++) {\n        // Check if the index is even and the element is odd\n        if (i % 2 == 0 && lst[i] % 2 != 0) {\n            sum += lst[i]; // Add the element to the sum\n        }\n    }\n    return sum; // Return the total sum\n}\n\n"}
{"task_id": "CPP/35", "generation": "#include <iostream>\n#include <vector>\n#include <limits>\n\nusing namespace std;\n\nfloat max_element(vector<float> l) {\n    // Check if the vector is empty\n    if (l.empty()) {\n        // Return a special value or throw an exception if needed\n        // Here we return the smallest possible float value\n        return numeric_limits<float>::lowest();\n    }\n\n    // Initialize max_value with the first element of the vector\n    float max_value = l[0];\n\n    // Iterate through the vector to find the maximum element\n    for (size_t i = 1; i < l.size(); ++i) {\n        if (l[i] > max_value) {\n            max_value = l[i];\n        }\n    }\n\n    return max_value;\n}\n\n"}
{"task_id": "CPP/20", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <limits>\n\nusing namespace std;\n\nvector<float> find_closest_elements(vector<float> numbers) {\n    // Step 1: Sort the vector\n    sort(numbers.begin(), numbers.end());\n\n    // Step 2: Initialize variables to track the closest pair\n    float min_diff = numeric_limits<float>::max(); // Start with the maximum possible float value\n    pair<float, float> closest_pair;\n\n    // Step 3: Iterate through the sorted vector to find the closest pair\n    for (size_t i = 0; i < numbers.size() - 1; ++i) {\n        float diff = numbers[i + 1] - numbers[i]; // Calculate the difference between adjacent elements\n        if (diff < min_diff) {\n            min_diff = diff; // Update the minimum difference\n            closest_pair = make_pair(numbers[i], numbers[i + 1]); // Update the closest pair\n        }\n    }\n\n    // Step 4: Return the closest pair as a vector\n    return vector<float>{closest_pair.first, closest_pair.second};\n}\n\n"}
{"task_id": "CPP/19", "generation": "#include <iostream>\n#include <string>\n#include <vector>\n#include <map>\n#include <sstream>\n#include <algorithm>\n\nusing namespace std;\n\nstring sort_numbers(string numbers) {\n    // Mapping from string to integer\n    map<string, int> num_map = {\n        {\"zero\", 0},\n        {\"one\", 1},\n        {\"two\", 2},\n        {\"three\", 3},\n        {\"four\", 4},\n        {\"five\", 5},\n        {\"six\", 6},\n        {\"seven\", 7},\n        {\"eight\", 8},\n        {\"nine\", 9}\n    };\n\n    // Split the input string into words\n    stringstream ss(numbers);\n    string word;\n    vector<int> num_list;\n\n    while (ss >> word) {\n        // Convert each word to its corresponding integer value\n        num_list.push_back(num_map[word]);\n    }\n\n    // Sort the integer values\n    sort(num_list.begin(), num_list.end());\n\n    // Convert sorted integers back to strings\n    vector<string> sorted_words;\n    for (int num : num_list) {\n        for (const auto& pair : num_map) {\n            if (pair.second == num) {\n                sorted_words.push_back(pair.first);\n                break;\n            }\n        }\n    }\n\n    // Join the sorted words into a single string\n    string result;\n    for (size_t i = 0; i < sorted_words.size(); ++i) {\n        result += sorted_words[i];\n        if (i < sorted_words.size() - 1) {\n            result += \" \"; // Add space between words\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/85", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint add(const vector<int>& lst) {\n    int sum = 0; // Initialize sum to 0\n    // Iterate through the vector\n    for (size_t i = 0; i < lst.size(); ++i) {\n        // Check if the index is odd and the element is even\n        if (i % 2 != 0 && lst[i] % 2 == 0) {\n            sum += lst[i]; // Add the element to sum\n        }\n    }\n    return sum; // Return the final sum\n}\n\n"}
{"task_id": "CPP/21", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // for std::min_element and std::max_element\n\nusing namespace std;\n\nvector<float> rescale_to_unit(vector<float> numbers) {\n    // Ensure the vector has at least two elements\n    if (numbers.size() < 2) {\n        throw invalid_argument(\"Vector must contain at least two elements.\");\n    }\n\n    // Find the minimum and maximum values in the vector\n    float min_val = *min_element(numbers.begin(), numbers.end());\n    float max_val = *max_element(numbers.begin(), numbers.end());\n\n    // Create a new vector to hold the rescaled values\n    vector<float> rescaled_numbers;\n\n    // Rescale each number\n    for (float num : numbers) {\n        float rescaled_value = (num - min_val) / (max_val - min_val);\n        rescaled_numbers.push_back(rescaled_value);\n    }\n\n    return rescaled_numbers;\n}\n\n"}
{"task_id": "CPP/119", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring match_parens(vector<string> lst) {\n    string s1 = lst[0];\n    string s2 = lst[1];\n\n    // Function to check if a string can be a prefix of a balanced string\n    auto canBeBalanced = [](const string& a, const string& b) {\n        int open = 0, close = 0;\n        \n        // Count the number of open and close parentheses\n        for (char c : a) {\n            if (c == '(') open++;\n            else close++;\n            // If at any point close exceeds open, it's not valid\n            if (close > open) return false;\n        }\n        \n        // After processing a, we need to check b\n        for (char c : b) {\n            if (c == '(') open++;\n            else close++;\n            // Again, check if close exceeds open\n            if (close > open) return false;\n        }\n        \n        // Finally, check if they are balanced\n        return open == close;\n    };\n\n    // Check both concatenation orders\n    if (canBeBalanced(s1, s2) || canBeBalanced(s2, s1)) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\n\n// Example usage\n"}
{"task_id": "CPP/30", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<float> get_positive(vector<float> l) {\n    vector<float> positive_numbers; // Vector to store positive numbers\n    for (float num : l) { // Iterate through each number in the input vector\n        if (num > 0) { // Check if the number is positive\n            positive_numbers.push_back(num); // Add positive number to the new vector\n        }\n    }\n    return positive_numbers; // Return the vector containing only positive numbers\n}\n\n"}
{"task_id": "CPP/64", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint vowels_count(string s) {\n    int count = 0;\n    int length = s.length();\n\n    for (int i = 0; i < length; i++) {\n        char c = tolower(s[i]); // Convert to lowercase for uniformity\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n            count++;\n        }\n    }\n\n    // Check if 'y' is at the end of the string\n    if (length > 0 && tolower(s[length - 1]) == 'y') {\n        count++;\n    }\n\n    return count;\n}\n\n"}
{"task_id": "CPP/128", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint prod_signs(vector<int> arr) {\n    if (arr.empty()) {\n        return -32768; // Return -32768 for empty array\n    }\n\n    int sum_magnitudes = 0;\n    int product_signs = 1; // Start with 1 for multiplication\n\n    for (int num : arr) {\n        if (num > 0) {\n            sum_magnitudes += num; // Add positive number to sum\n        } else if (num < 0) {\n            sum_magnitudes += -num; // Add magnitude of negative number to sum\n            product_signs *= -1; // Flip the sign for negative numbers\n        } else { // num == 0\n            product_signs = 0; // If there's a zero, product of signs is 0\n            break; // No need to continue, we can exit the loop\n        }\n    }\n\n    return sum_magnitudes * product_signs; // Return the final result\n}\n\n// Example usage\n"}
{"task_id": "CPP/127", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <cmath>\nusing namespace std;\n\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i <= sqrt(n); i++) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\nstring intersection(vector<int> interval1, vector<int> interval2) {\n    int start1 = interval1[0], end1 = interval1[1];\n    int start2 = interval2[0], end2 = interval2[1];\n    \n    // Find the intersection\n    int start_intersection = max(start1, start2);\n    int end_intersection = min(end1, end2);\n    \n    // Calculate the length of the intersection\n    int length = end_intersection - start_intersection;\n    \n    // Check if the length is a prime number\n    if (length > 0 && is_prime(length)) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n"}
{"task_id": "CPP/122", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint add_elements(vector<int> arr, int k) {\n    int sum = 0; // Initialize sum to 0\n    \n    // Loop through the first k elements\n    for (int i = 0; i < k; i++) {\n        // Check if the element has at most two digits\n        if (arr[i] >= -99 && arr[i] <= 99) {\n            sum += arr[i]; // Add to sum if condition is met\n        }\n    }\n    \n    return sum; // Return the final sum\n}\n\n"}
{"task_id": "CPP/59", "generation": "#include <iostream>\nusing namespace std;\n\nint largest_prime_factor(int n) {\n    int largest_factor = -1;\n\n    // Check for number of 2s that divide n\n    while (n % 2 == 0) {\n        largest_factor = 2;\n        n /= 2;\n    }\n\n    // n must be odd at this point, so we can skip even numbers\n    for (int i = 3; i * i <= n; i += 2) {\n        while (n % i == 0) {\n            largest_factor = i;\n            n /= i;\n        }\n    }\n\n    // This condition is to check if n is a prime number greater than 2\n    if (n > 2) {\n        largest_factor = n;\n    }\n\n    return largest_factor;\n}\n\n"}
{"task_id": "CPP/134", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nbool check_if_last_char_is_a_letter(string txt) {\n    // Strip any trailing spaces from the string\n    size_t end = txt.find_last_not_of(' ');\n    if (end == string::npos) {\n        return false; // The string is empty after stripping\n    }\n    txt = txt.substr(0, end + 1); // Update txt to remove trailing spaces\n\n    // Get the last character\n    char last_char = txt.back();\n\n    // Check if the last character is alphabetical and not part of a word\n    if (isalpha(last_char) && (txt.length() == 1 || txt[end - 1] == ' ')) {\n        return true;\n    }\n    return false;\n}\n"}
{"task_id": "CPP/42", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> incr_list(vector<int> l) {\n    // Create a new vector to store the incremented values\n    vector<int> incremented_list;\n    \n    // Iterate through each element in the input vector\n    for (int i = 0; i < l.size(); i++) {\n        // Increment the current element by 1 and add it to the new vector\n        incremented_list.push_back(l[i] + 1);\n    }\n    \n    // Return the new vector with incremented values\n    return incremented_list;\n}\n\n"}
{"task_id": "CPP/11", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring string_xor(string a, string b) {\n    // Ensure both strings are of the same length\n    if (a.length() != b.length()) {\n        throw invalid_argument(\"Strings must be of the same length\");\n    }\n\n    string result = \"\";\n    \n    // Perform XOR operation\n    for (size_t i = 0; i < a.length(); i++) {\n        if (a[i] == b[i]) {\n            result += '0'; // Same bits result in '0'\n        } else {\n            result += '1'; // Different bits result in '1'\n        }\n    }\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/40", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nbool triples_sum_to_zero(vector<int> l) {\n    // Sort the vector\n    sort(l.begin(), l.end());\n    \n    // Iterate through the vector\n    for (size_t i = 0; i < l.size(); ++i) {\n        // Skip duplicate elements to ensure distinct elements\n        if (i > 0 && l[i] == l[i - 1]) {\n            continue;\n        }\n        \n        // Use two pointers to find the other two numbers\n        int left = i + 1;\n        int right = l.size() - 1;\n        \n        while (left < right) {\n            int sum = l[i] + l[left] + l[right];\n            if (sum == 0) {\n                return true; // Found a triplet\n            } else if (sum < 0) {\n                left++; // Move left pointer to the right to increase the sum\n            } else {\n                right--; // Move right pointer to the left to decrease the sum\n            }\n        }\n    }\n    \n    return false; // No triplet found\n}\n\n"}
{"task_id": "CPP/13", "generation": "#include <iostream>\nusing namespace std;\n\nint greatest_common_divisor(int a, int b) {\n    // Ensure a and b are non-negative\n    a = abs(a);\n    b = abs(b);\n    \n    // Euclidean algorithm\n    while (b != 0) {\n        int temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n\n"}
{"task_id": "CPP/130", "generation": "#include <vector>\nusing namespace std;\n\nvector<int> tri(int n) {\n    vector<int> tribonacci(n + 1);\n    \n    for (int i = 0; i <= n; i++) {\n        if (i == 1) {\n            tribonacci[i] = 3; // tri(1) = 3\n        } else if (i % 2 == 0) {\n            tribonacci[i] = 1 + i / 2; // tri(n) = 1 + n / 2 for even n\n        } else {\n            // For odd n, we need to ensure we have calculated the previous values\n            if (i == 3) {\n                tribonacci[i] = 8; // tri(3) = 8\n            } else {\n                // Calculate tri(n) for odd n using the previous values\n                tribonacci[i] = tribonacci[i - 1] + tribonacci[i - 2] + tribonacci[i - 1]; // Corrected to use valid indices\n            }\n        }\n    }\n    \n    return tribonacci;\n}\n"}
{"task_id": "CPP/60", "generation": "#include <iostream>\nusing namespace std;\n\nint sum_to_n(int n) {\n    return n * (n + 1) / 2; // Using the formula for the sum of the first n natural numbers\n}\n\n"}
{"task_id": "CPP/23", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\n// Function to return the length of a given string\nint strlen(const string& str) {\n    return str.size(); // or str.length();\n}\n\n"}
{"task_id": "CPP/46", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint fib4(int n) {\n    // Handle base cases\n    if (n == 0) return 0;\n    if (n == 1) return 0;\n    if (n == 2) return 2;\n    if (n == 3) return 0;\n\n    // Create a vector to store the fib4 values\n    vector<int> fib(n + 1);\n    \n    // Initialize base cases\n    fib[0] = 0;\n    fib[1] = 0;\n    fib[2] = 2;\n    fib[3] = 0;\n\n    // Compute fib4 values iteratively\n    for (int i = 4; i <= n; ++i) {\n        fib[i] = fib[i - 1] + fib[i - 2] + fib[i - 3] + fib[i - 4];\n    }\n\n    return fib[n];\n}\n\n"}
{"task_id": "CPP/51", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nstring remove_vowels(string text) {\n    string result;\n    for (char c : text) {\n        // Check if the character is a vowel (both lowercase and uppercase)\n        if (c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u' &&\n            c != 'A' && c != 'E' && c != 'I' && c != 'O' && c != 'U') {\n            result += c; // Append non-vowel characters to the result\n        }\n    }\n    return result; // Return the string without vowels\n}\n\n"}
{"task_id": "CPP/18", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint how_many_times(string str, string substring) {\n    if (substring.empty()) {\n        return 0; // If the substring is empty, return 0\n    }\n\n    int count = 0;\n    size_t pos = 0;\n\n    // Loop until we find the substring in the string\n    while ((pos = str.find(substring, pos)) != string::npos) {\n        count++; // Increment the count for each found occurrence\n        pos++; // Move to the next position to allow for overlapping matches\n    }\n\n    return count;\n}\n\n"}
{"task_id": "CPP/143", "generation": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int n) {\n    if (n <= 1) return false; // 0 and 1 are not prime numbers\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0) return false; // Found a divisor, not prime\n    }\n    return true; // No divisors found, it is prime\n}\n\n// Function to extract words with prime lengths\nstring words_in_sentence(string sentence) {\n    stringstream ss(sentence);\n    string word;\n    vector<string> prime_length_words;\n\n    // Split the sentence into words\n    while (ss >> word) {\n        // Check if the length of the word is prime\n        if (is_prime(word.length())) {\n            prime_length_words.push_back(word);\n        }\n    }\n\n    // Join the words with prime lengths into a single string\n    string result;\n    for (size_t i = 0; i < prime_length_words.size(); ++i) {\n        result += prime_length_words[i];\n        if (i < prime_length_words.size() - 1) {\n            result += \" \"; // Add space between words\n        }\n    }\n\n    return result;\n}\n\n// Example usage\n"}
{"task_id": "CPP/108", "generation": "#include <vector>\n#include <cmath>\nusing namespace std;\n\nint sum_of_digits(int num) {\n    int sum = 0;\n    bool isNegative = (num < 0);\n    num = abs(num);\n    \n    // Convert number to string to iterate over digits\n    string numStr = to_string(num);\n    for (size_t i = 0; i < numStr.size(); ++i) {\n        int digit = numStr[i] - '0'; // Convert char to int\n        if (isNegative && i == 0) {\n            sum -= digit; // First digit is negative\n        } else {\n            sum += digit; // Add positive digits\n        }\n    }\n    return sum;\n}\n\nint count_nums(vector<int> n) {\n    int count = 0;\n    for (int number : n) {\n        if (sum_of_digits(number) > 0) {\n            count++;\n        }\n    }\n    return count;\n}\n"}
{"task_id": "CPP/43", "generation": "#include <iostream>\n#include <vector>\n#include <unordered_set>\n\nusing namespace std;\n\nbool pairs_sum_to_zero(vector<int> l) {\n    unordered_set<int> seen; // Create a set to store the elements we have seen\n\n    for (int num : l) {\n        // Check if the negation of the current number exists in the set\n        if (seen.count(-num)) {\n            return true; // Found a pair that sums to zero\n        }\n        seen.insert(num); // Add the current number to the set\n    }\n    \n    return false; // No pairs found that sum to zero\n}\n\n"}
{"task_id": "CPP/70", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> strange_sort_list(vector<int> lst) {\n    // Sort the input list\n    sort(lst.begin(), lst.end());\n    \n    vector<int> result;\n    int left = 0; // Pointer for the minimum value\n    int right = lst.size() - 1; // Pointer for the maximum value\n\n    // Alternate between minimum and maximum values\n    while (left <= right) {\n        if (left == right) {\n            // If both pointers meet, add the last remaining element\n            result.push_back(lst[left]);\n        } else {\n            result.push_back(lst[left]); // Add minimum\n            result.push_back(lst[right]); // Add maximum\n        }\n        left++;\n        right--;\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/63", "generation": "#include <iostream>\nusing namespace std;\n\nint fibfib(int n) {\n    // Handle base cases\n    if (n == 0) return 0;\n    if (n == 1) return 0;\n    if (n == 2) return 1;\n\n    // Initialize an array to store the FibFib numbers\n    int fibfibArray[n + 1];\n    fibfibArray[0] = 0; // fibfib(0)\n    fibfibArray[1] = 0; // fibfib(1)\n    fibfibArray[2] = 1; // fibfib(2)\n\n    // Compute the FibFib numbers iteratively\n    for (int i = 3; i <= n; i++) {\n        fibfibArray[i] = fibfibArray[i - 1] + fibfibArray[i - 2] + fibfibArray[i - 3];\n    }\n\n    return fibfibArray[n];\n}\n\n"}
{"task_id": "CPP/89", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring encrypt(string s) {\n    string encrypted = \"\";\n    \n    for (char c : s) {\n        // Check if the character is a lowercase letter\n        if (c >= 'a' && c <= 'z') {\n            // Rotate the character by 4 positions\n            char newChar = c + 4;\n            // Wrap around if it goes past 'z'\n            if (newChar > 'z') {\n                newChar -= 26; // Wrap around\n            }\n            encrypted += newChar;\n        }\n        // Check if the character is an uppercase letter\n        else if (c >= 'A' && c <= 'Z') {\n            // Rotate the character by 4 positions\n            char newChar = c + 4;\n            // Wrap around if it goes past 'Z'\n            if (newChar > 'Z') {\n                newChar -= 26; // Wrap around\n            }\n            encrypted += newChar;\n        } else {\n            // If it's not a letter, we can choose to ignore it or handle it differently\n            // For this implementation, we will ignore non-alphabetic characters\n            // encrypted += c; // Uncomment this line if you want to keep non-alphabetic characters\n        }\n    }\n    \n    return encrypted;\n}\n\n"}
{"task_id": "CPP/26", "generation": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nvector<int> remove_duplicates(const vector<int>& numbers) {\n    unordered_map<int, int> frequency_map;\n    \n    // Count the occurrences of each number\n    for (int num : numbers) {\n        frequency_map[num]++;\n    }\n    \n    vector<int> result;\n    \n    // Add elements that occur only once to the result\n    for (int num : numbers) {\n        if (frequency_map[num] == 1) {\n            result.push_back(num);\n        }\n    }\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/104", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nbool has_even_digit(int num) {\n    while (num > 0) {\n        int digit = num % 10; // Get the last digit\n        if (digit % 2 == 0) { // Check if the digit is even\n            return true; // Found an even digit\n        }\n        num /= 10; // Remove the last digit\n    }\n    return false; // No even digits found\n}\n\nvector<int> unique_digits(vector<int> x) {\n    vector<int> result;\n\n    for (int num : x) {\n        if (!has_even_digit(num)) { // If the number has no even digits\n            result.push_back(num);\n        }\n    }\n\n    sort(result.begin(), result.end()); // Sort the result vector\n    return result;\n}\n\n"}
{"task_id": "CPP/90", "generation": "#include <iostream>\n#include <vector>\n#include <set>\n#include <algorithm>\n\nusing namespace std;\n\nint next_smallest(vector<int> lst) {\n    // Use a set to store unique elements\n    set<int> unique_elements(lst.begin(), lst.end());\n\n    // If there are less than 2 unique elements, return None (represented by -1)\n    if (unique_elements.size() < 2) {\n        return -1; // or you can use a different value to indicate None\n    }\n\n    // Convert the set back to a vector and sort it\n    vector<int> sorted_unique(unique_elements.begin(), unique_elements.end());\n\n    // Return the second smallest element\n    return sorted_unique[1];\n}\n\n"}
{"task_id": "CPP/126", "generation": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nbool is_sorted(vector<int> lst) {\n    // Create a map to count occurrences of each number\n    unordered_map<int, int> count_map;\n\n    // Check if the vector is sorted and count occurrences\n    for (size_t i = 0; i < lst.size(); ++i) {\n        // Count occurrences\n        count_map[lst[i]]++;\n\n        // Check if any number appears more than twice\n        if (count_map[lst[i]] > 2) {\n            return false;\n        }\n\n        // Check if the current element is less than the previous one\n        if (i > 0 && lst[i] < lst[i - 1]) {\n            return false;\n        }\n    }\n\n    // If we reach here, the list is sorted and no number appears more than twice\n    return true;\n}\n\n"}
{"task_id": "CPP/68", "generation": "#include <iostream>\n#include <vector>\n#include <limits>\n\nusing namespace std;\n\nvector<int> pluck(vector<int> arr) {\n    int smallest_even_value = numeric_limits<int>::max(); // Initialize to max int value\n    int smallest_index = -1; // Initialize index to -1 (indicating no even value found)\n\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] % 2 == 0) { // Check if the number is even\n            if (arr[i] < smallest_even_value) { // Check if it's smaller than the current smallest\n                smallest_even_value = arr[i];\n                smallest_index = i; // Update the index\n            }\n        }\n    }\n\n    // If no even value was found, return an empty vector\n    if (smallest_index == -1) {\n        return {};\n    }\n\n    // Return the smallest even value and its index\n    return {smallest_even_value, smallest_index};\n}\n\n// Example usage\n"}
{"task_id": "CPP/58", "generation": "#include <iostream>\n#include <vector>\n#include <set>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> common(vector<int> l1, vector<int> l2) {\n    // Create sets to store unique elements\n    set<int> set1(l1.begin(), l1.end());\n    set<int> set2(l2.begin(), l2.end());\n    \n    // Vector to store the result\n    vector<int> result;\n\n    // Use set_intersection to find common elements\n    set_intersection(set1.begin(), set1.end(),\n                     set2.begin(), set2.end(),\n                     back_inserter(result));\n\n    return result;\n}\n\n"}
{"task_id": "CPP/112", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <unordered_set>\n\nusing namespace std;\n\nvector<string> reverse_delete(string s, string c) {\n    // Use a set for fast lookup of characters to delete\n    unordered_set<char> chars_to_delete(c.begin(), c.end());\n    string result;\n\n    // Build the new string by skipping characters in chars_to_delete\n    for (char ch : s) {\n        if (chars_to_delete.find(ch) == chars_to_delete.end()) {\n            result += ch;\n        }\n    }\n\n    // Check if the result string is a palindrome\n    string reversed_result = result;\n    reverse(reversed_result.begin(), reversed_result.end());\n    bool is_palindrome = (result == reversed_result);\n\n    // Prepare the output\n    return {result, is_palindrome ? \"True\" : \"False\"};\n}\n\n"}
{"task_id": "CPP/96", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Helper function to check if a number is prime\nbool is_prime(int num) {\n    if (num <= 1) return false; // 0 and 1 are not prime numbers\n    for (int i = 2; i * i <= num; i++) {\n        if (num % i == 0) return false; // Found a divisor, not prime\n    }\n    return true; // No divisors found, it's prime\n}\n\n// Main function to count primes up to n\nvector<int> count_up_to(int n) {\n    vector<int> primes; // Vector to store prime numbers\n    for (int i = 2; i < n; i++) { // Start from 2 and go up to n-1\n        if (is_prime(i)) {\n            primes.push_back(i); // Add prime number to the vector\n        }\n    }\n    return primes; // Return the vector of prime numbers\n}\n\n// Example usage\n"}
{"task_id": "CPP/157", "generation": "#include <stdio.h>\n#include <math.h>\n\nbool right_angle_triangle(float a, float b, float c) {\n    // Sort the sides to identify the longest side\n    float x = fmax(fmax(a, b), c); // longest side\n    float y, z;\n\n    if (x == a) {\n        y = b;\n        z = c;\n    } else if (x == b) {\n        y = a;\n        z = c;\n    } else {\n        y = a;\n        z = b;\n    }\n\n    // Check the Pythagorean theorem\n    return (y * y + z * z) == (x * x);\n}\n\n"}
{"task_id": "CPP/99", "generation": "#include <iostream>\n#include <cmath>\n#include <string>\n\nusing namespace std;\n\nint closest_integer(string value) {\n    // Convert the string to a double\n    double num = stod(value);\n    \n    // Get the floor and ceil values\n    int lower = static_cast<int>(floor(num));\n    int upper = static_cast<int>(ceil(num));\n    \n    // Check the distance to the lower and upper integers\n    double lower_diff = abs(num - lower);\n    double upper_diff = abs(num - upper);\n    \n    // If the number is equidistant, round away from zero\n    if (lower_diff == upper_diff) {\n        if (num > 0) {\n            return upper; // Round up for positive numbers\n        } else {\n            return lower; // Round down for negative numbers\n        }\n    }\n    \n    // Return the closest integer\n    return (lower_diff < upper_diff) ? lower : upper;\n}\n\n"}
{"task_id": "CPP/149", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nvector<string> sorted_list_sum(vector<string> lst) {\n    // Filter out strings with odd lengths\n    vector<string> filtered_lst;\n    for (const string& s : lst) {\n        if (s.length() % 2 == 0) {\n            filtered_lst.push_back(s);\n        }\n    }\n    \n    // Sort the filtered list first by length and then alphabetically\n    sort(filtered_lst.begin(), filtered_lst.end(), [](const string& a, const string& b) {\n        if (a.length() == b.length()) {\n            return a < b; // Sort alphabetically if lengths are the same\n        }\n        return a.length() < b.length(); // Sort by length\n    });\n    \n    return filtered_lst;\n}\n"}
{"task_id": "CPP/86", "generation": "#include <stdio.h>\n#include <string>\n#include <algorithm>\n#include <sstream>\nusing namespace std;\n\nstring anti_shuffle(string s) {\n    stringstream ss(s);\n    string word;\n    string result;\n\n    while (ss >> word) {\n        // Sort the characters in the word\n        sort(word.begin(), word.end());\n        result += word + \" \"; // Append the sorted word and a space\n    }\n\n    // Remove the trailing space if there is any\n    if (!result.empty()) {\n        result.pop_back();\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/129", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvoid dfs(const vector<vector<int>>& grid, int x, int y, int k, vector<int>& currentPath, vector<int>& bestPath) {\n    // If we have reached the desired length of the path\n    if (currentPath.size() == k) {\n        // Compare with the best path found so far\n        if (bestPath.empty() || currentPath < bestPath) {\n            bestPath = currentPath; // Update best path\n        }\n        return;\n    }\n\n    // Directions for moving in the grid (up, down, left, right)\n    vector<pair<int, int>> directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n    \n    // Explore all possible directions\n    for (const auto& dir : directions) {\n        int newX = x + dir.first;\n        int newY = y + dir.second;\n\n        // Check if the new position is within bounds\n        if (newX >= 0 && newX < grid.size() && newY >= 0 && newY < grid[0].size()) {\n            // Add the value to the current path\n            currentPath.push_back(grid[newX][newY]);\n            // Recur to the next cell\n            dfs(grid, newX, newY, k, currentPath, bestPath);\n            // Backtrack\n            currentPath.pop_back();\n        }\n    }\n}\n\nvector<int> minPath(vector<vector<int>> grid, int k) {\n    vector<int> bestPath;\n    int N = grid.size();\n    \n    // Try starting from every cell in the grid\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            vector<int> currentPath;\n            currentPath.push_back(grid[i][j]); // Start from the current cell\n            dfs(grid, i, j, k, currentPath, bestPath);\n        }\n    }\n    \n    return bestPath;\n}\n\n// Example usage\n"}
{"task_id": "CPP/49", "generation": "#include <iostream>\nusing namespace std;\n\nint modp(int n, int p) {\n    if (p == 1) return 0; // Since any number mod 1 is 0\n    long long result = 1; // Use long long to prevent overflow\n    long long base = 2; // Base is 2\n\n    // Exponentiation by squaring\n    while (n > 0) {\n        if (n % 2 == 1) { // If n is odd\n            result = (result * base) % p;\n        }\n        base = (base * base) % p; // Square the base\n        n /= 2; // Divide n by 2\n    }\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/156", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring int_to_mini_roman(int number) {\n    // Define the Roman numeral symbols and their corresponding values\n    vector<pair<int, string>> roman_numerals = {\n        {1000, \"m\"},\n        {900, \"cm\"},\n        {500, \"d\"},\n        {400, \"cd\"},\n        {100, \"c\"},\n        {90, \"xc\"},\n        {50, \"l\"},\n        {40, \"xl\"},\n        {10, \"x\"},\n        {9, \"ix\"},\n        {5, \"v\"},\n        {4, \"iv\"},\n        {1, \"i\"}\n    };\n\n    string result = \"\";\n\n    // Iterate over the roman_numerals vector\n    for (const auto& pair : roman_numerals) {\n        // While the number is greater than or equal to the value\n        while (number >= pair.first) {\n            result += pair.second; // Append the corresponding Roman numeral\n            number -= pair.first;   // Decrease the number\n        }\n    }\n\n    return result; // Return the result in lowercase\n}\n\n// Example usage\n"}
{"task_id": "CPP/65", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nstring circular_shift(int x, int shift) {\n    // Convert the integer to a string to manipulate the digits\n    string x_str = to_string(x);\n    int n = x_str.length();\n    \n    // If the shift is greater than the number of digits, reverse the string\n    if (shift > n) {\n        reverse(x_str.begin(), x_str.end());\n        return x_str;\n    }\n    \n    // Calculate the effective shift (in case shift is equal to or less than n)\n    int effective_shift = shift % n;\n    \n    // Perform the circular shift\n    string shifted_str = x_str.substr(n - effective_shift) + x_str.substr(0, n - effective_shift);\n    \n    return shifted_str;\n}\n"}
{"task_id": "CPP/9", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> rolling_max(vector<int> numbers) {\n    vector<int> result;\n    int current_max = INT_MIN; // Initialize to the smallest integer\n\n    for (int num : numbers) {\n        if (num > current_max) {\n            current_max = num; // Update current_max if the current number is greater\n        }\n        result.push_back(current_max); // Add the current maximum to the result\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/158", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_set>\n#include <algorithm>\n\nusing namespace std;\n\nstring find_max(vector<string> words) {\n    string max_word;\n    int max_unique_count = 0;\n\n    for (const string& word : words) {\n        // Use a set to find unique characters\n        unordered_set<char> unique_chars(word.begin(), word.end());\n        int unique_count = unique_chars.size();\n\n        // Check if we found a new maximum or if we need to update based on lexicographical order\n        if (unique_count > max_unique_count || \n            (unique_count == max_unique_count && (max_word.empty() || word < max_word))) {\n            max_word = word;\n            max_unique_count = unique_count;\n        }\n    }\n\n    return max_word;\n}\n\n"}
{"task_id": "CPP/8", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nvector<int> sum_product(vector<int> numbers) {\n    if (numbers.empty()) {  // Check if the vector is empty\n        return {0, 1};  // Return (0, 1) for empty input\n    }\n    \n    int total_sum = 0;  // Initialize sum\n    int total_product = 1;  // Initialize product\n    \n    for (int number : numbers) {\n        total_sum += number;  // Calculate the sum\n        total_product *= number;  // Calculate the product\n    }\n    \n    return {total_sum, total_product};  // Return the sum and product as a vector\n}\n"}
{"task_id": "CPP/95", "generation": "#include <iostream>\n#include <string>\n#include <map>\n#include <cctype>\n\nusing namespace std;\n\nbool check_dict_case(map<string, string> dict) {\n    // Check if the map is empty\n    if (dict.empty()) {\n        return false;\n    }\n\n    bool hasLower = false;\n    bool hasUpper = false;\n\n    for (const auto& pair : dict) {\n        const string& key = pair.first;\n\n        // Check if the key is all lower case\n        if (all_of(key.begin(), key.end(), [](unsigned char c) { return islower(c); })) {\n            hasLower = true;\n        }\n        // Check if the key is all upper case\n        else if (all_of(key.begin(), key.end(), [](unsigned char c) { return isupper(c); })) {\n            hasUpper = true;\n        }\n        // If the key is neither all lower nor all upper, return false\n        else {\n            return false;\n        }\n\n        // If both lower and upper case keys have been found, return false\n        if (hasLower && hasUpper) {\n            return false;\n        }\n    }\n\n    // If we only found lower case or only upper case keys, return true\n    return true;\n}\n\n"}
{"task_id": "CPP/55", "generation": "#include <iostream>\nusing namespace std;\n\nint fib(int n) {\n    if (n <= 0) return 0; // Fibonacci of 0 is 0\n    if (n == 1) return 1; // Fibonacci of 1 is 1\n    return fib(n - 1) + fib(n - 2); // Recursive call\n}\n\n"}
{"task_id": "CPP/29", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<string> filter_by_prefix(const vector<string>& strings, const string& prefix) {\n    vector<string> filtered;\n\n    for (const string& str : strings) {\n        // Check if the string starts with the given prefix\n        if (str.substr(0, prefix.size()) == prefix) {\n            filtered.push_back(str);\n        }\n    }\n\n    return filtered;\n}\n\n"}
{"task_id": "CPP/72", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool will_it_fly(vector<int> q, int w) {\n    // Check if the vector is palindromic\n    int n = q.size();\n    for (int i = 0; i < n / 2; i++) {\n        if (q[i] != q[n - 1 - i]) {\n            return false; // Not balanced\n        }\n    }\n\n    // Calculate the sum of the elements\n    int sum = 0;\n    for (int num : q) {\n        sum += num;\n    }\n\n    // Check if the sum is less than or equal to the maximum weight\n    return sum <= w;\n}\n\n"}
{"task_id": "CPP/54", "generation": "#include <iostream>\n#include <string>\n#include <set>\nusing namespace std;\n\nbool same_chars(string s0, string s1) {\n    // Create sets to store unique characters\n    set<char> set0(s0.begin(), s0.end());\n    set<char> set1(s1.begin(), s1.end());\n\n    // Compare the two sets\n    return set0 == set1;\n}\n\n"}
{"task_id": "CPP/91", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <vector>\n#include <cctype>\n\nusing namespace std;\n\nint is_bored(string S) {\n    // Define delimiters\n    const string delimiters = \".!?\";\n    int boredom_count = 0;\n\n    // Use a stringstream to split the string into sentences\n    stringstream ss(S);\n    string sentence;\n\n    while (getline(ss, sentence, '.')) {\n        // Check for other delimiters\n        size_t pos = sentence.find_first_of(\"!?\");\n        if (pos != string::npos) {\n            sentence = sentence.substr(0, pos);\n        }\n\n        // Trim leading whitespace\n        size_t start = sentence.find_first_not_of(\" \\t\");\n        if (start != string::npos) {\n            sentence = sentence.substr(start);\n        }\n\n        // Check if the sentence starts with \"I\"\n        if (sentence == \"I\" || (sentence.size() > 1 && sentence[0] == 'I' && isspace(sentence[1]))) {\n            boredom_count++;\n        }\n    }\n\n    return boredom_count;\n}\n\n"}
{"task_id": "CPP/77", "generation": "#include <stdio.h>\n#include <cmath>\nusing namespace std;\n\nbool iscube(int a) {\n    if (a < 0) {\n        a = -a;  // Take the absolute value for negative numbers\n    }\n    int cube_root = round(pow(a, 1.0 / 3.0));  // Calculate the cube root and round it\n    return cube_root * cube_root * cube_root == a;  // Check if the cube of the rounded root equals the original number\n}\n"}
{"task_id": "CPP/73", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint smallest_change(vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n\n    // Compare elements from the start and end towards the center\n    for (int i = 0; i < n / 2; ++i) {\n        if (arr[i] != arr[n - 1 - i]) {\n            changes++; // Increment changes for each mismatch\n        }\n    }\n\n    return changes; // Return the total number of changes needed\n}\n\n"}
{"task_id": "CPP/71", "generation": "#include <stdio.h>\n#include <math.h>\n\nfloat triangle_area(float a, float b, float c) {\n    // Check if the sides form a valid triangle\n    if (a + b > c && a + c > b && b + c > a) {\n        // Calculate the semi-perimeter\n        float s = (a + b + c) / 2;\n\n        // Calculate the area using Heron's formula\n        float area = sqrt(s * (s - a) * (s - b) * (s - c));\n\n        // Return the area rounded to 2 decimal points\n        return round(area * 100) / 100; // rounding to 2 decimal points\n    } else {\n        // Return -1 if the sides do not form a valid triangle\n        return -1;\n    }\n}\n\n"}
{"task_id": "CPP/82", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int num) {\n    if (num <= 1) return false; // 0 and 1 are not prime numbers\n    for (int i = 2; i * i <= num; i++) { // Check divisibility up to the square root of num\n        if (num % i == 0) return false; // If num is divisible by any number other than 1 and itself\n    }\n    return true; // num is prime\n}\n\n// Function to check if the length of the string is prime\nbool prime_length(string str) {\n    int length = str.length(); // Get the length of the string\n    return is_prime(length); // Check if the length is prime\n}\n\n// Example usage\n"}
{"task_id": "CPP/114", "generation": "#include <iostream>\n#include <vector>\n#include <limits.h> // For INT_MAX\n\nusing namespace std;\n\nlong long minSubArraySum(vector<long long> nums) {\n    long long currentSum = 0;\n    long long minSum = LLONG_MAX; // Initialize to the maximum possible value\n\n    for (long long num : nums) {\n        currentSum += num; // Add the current number to the current sum\n        if (currentSum < minSum) {\n            minSum = currentSum; // Update minSum if currentSum is smaller\n        }\n        if (currentSum > 0) {\n            currentSum = 0; // Reset currentSum if it becomes positive\n        }\n    }\n\n    return minSum; // Return the minimum sum found\n}\n\n"}
{"task_id": "CPP/138", "generation": "#include <stdio.h>\n\nbool is_equal_to_sum_even(int n) {\n    // Check if n is less than 8\n    if (n < 8) {\n        return false;\n    }\n    // Check if n is even\n    return n % 2 == 0;\n}\n\n"}
{"task_id": "CPP/132", "generation": "#include <stdio.h>\n#include <string>\n#include <stack>\nusing namespace std;\n\nbool is_nested(string str) {\n    stack<char> s;\n    bool nested = false;\n\n    for (char c : str) {\n        if (c == '[') {\n            s.push(c);\n            if (s.size() > 1) {  // More than one opening bracket means nesting\n                nested = true;\n            }\n        } else if (c == ']') {\n            if (s.empty()) {  // Unmatched closing bracket\n                return false;\n            }\n            s.pop();\n        }\n    }\n\n    return nested && s.empty();  // Must be nested and all brackets must be matched\n}\n"}
{"task_id": "CPP/3", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool below_zero(vector<int> operations) {\n    int balance = 0; // Start with a balance of zero\n\n    for (int operation : operations) {\n        balance += operation; // Update the balance with the current operation\n        if (balance < 0) { // Check if the balance falls below zero\n            return true; // Return true if it does\n        }\n    }\n    \n    return false; // Return false if the balance never goes below zero\n}\n\n"}
{"task_id": "CPP/142", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint sum_squares(vector<int> lst) {\n    int total_sum = 0; // Initialize the sum to 0\n\n    for (size_t i = 0; i < lst.size(); ++i) {\n        if (i % 3 == 0) {\n            // If index is a multiple of 3, square the entry\n            total_sum += lst[i] * lst[i];\n        } else if (i % 4 == 0) {\n            // If index is a multiple of 4 and not a multiple of 3, cube the entry\n            total_sum += lst[i] * lst[i] * lst[i];\n        } else {\n            // Otherwise, just add the entry as is\n            total_sum += lst[i];\n        }\n    }\n\n    return total_sum; // Return the total sum\n}\n\n"}
{"task_id": "CPP/50", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring encode_shift(string s) {\n    // Returns encoded string by shifting every character by 5 in the alphabet.\n    string out;\n    for (char c : s) {\n        if (isalpha(c)) { // Check if the character is an alphabet\n            char base = islower(c) ? 'a' : 'A'; // Determine the base for lowercase or uppercase\n            char shifted = (c - base + 5) % 26 + base; // Shift and wrap around\n            out += shifted; // Append the shifted character to the output string\n        } else {\n            out += c; // Non-alphabet characters are added unchanged\n        }\n    }\n    return out;\n}\n\nstring decode_shift(string s) {\n    // Takes as input string encoded with encode_shift function. Returns decoded string.\n    string out;\n    for (char c : s) {\n        if (isalpha(c)) { // Check if the character is an alphabet\n            char base = islower(c) ? 'a' : 'A'; // Determine the base for lowercase or uppercase\n            char shifted = (c - base - 5 + 26) % 26 + base; // Shift back and wrap around\n            out += shifted; // Append the shifted character to the output string\n        } else {\n            out += c; // Non-alphabet characters are added unchanged\n        }\n    }\n    return out;\n}\n\n"}
{"task_id": "CPP/103", "generation": "#include <iostream>\n#include <string>\n#include <cmath>\n\nusing namespace std;\n\nstring rounded_avg(int n, int m) {\n    // Check if n is greater than m\n    if (n > m) {\n        return \"-1\";\n    }\n\n    // Calculate the sum of integers from n to m\n    int sum = 0;\n    for (int i = n; i <= m; ++i) {\n        sum += i;\n    }\n\n    // Calculate the number of integers from n to m\n    int count = m - n + 1;\n\n    // Calculate the average\n    double average = static_cast<double>(sum) / count;\n\n    // Round down to the nearest integer\n    int rounded_average = static_cast<int>(floor(average));\n\n    // Convert the rounded average to binary\n    string binary = \"\";\n    if (rounded_average == 0) {\n        binary = \"0\";\n    } else {\n        while (rounded_average > 0) {\n            binary = to_string(rounded_average % 2) + binary;\n            rounded_average /= 2;\n        }\n    }\n\n    return binary;\n}\n\n"}
{"task_id": "CPP/57", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nbool monotonic(vector<float> l) {\n    if (l.size() < 2) {\n        return true; // A single element or empty vector is considered monotonic\n    }\n\n    bool increasing = true;\n    bool decreasing = true;\n\n    for (size_t i = 1; i < l.size(); ++i) {\n        if (l[i] > l[i - 1]) {\n            decreasing = false; // Found an increasing pair\n        } else if (l[i] < l[i - 1]) {\n            increasing = false; // Found a decreasing pair\n        }\n    }\n\n    return increasing || decreasing; // Return true if either is true\n}\n\n"}
{"task_id": "CPP/28", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nstring concatenate(vector<string> strings) {\n    string result; // Initialize an empty string\n    for (const string& str : strings) { // Iterate through each string in the vector\n        result += str; // Append the current string to the result\n    }\n    return result; // Return the concatenated string\n}\n\n"}
{"task_id": "CPP/39", "generation": "#include <iostream>\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int num) {\n    if (num <= 1) return false; // 0 and 1 are not prime numbers\n    for (int i = 2; i * i <= num; i++) {\n        if (num % i == 0) return false; // Found a divisor, not prime\n    }\n    return true; // No divisors found, it's prime\n}\n\n// Function to return the n-th Fibonacci number that is also prime\nint prime_fib(int n) {\n    int count = 0; // Count of prime Fibonacci numbers found\n    int a = 0, b = 1; // Starting values for Fibonacci sequence\n    int fib; // Variable to hold the current Fibonacci number\n\n    while (true) {\n        fib = a + b; // Calculate the next Fibonacci number\n        a = b; // Update a to the next Fibonacci number\n        b = fib; // Update b to the next Fibonacci number\n\n        // Check if the Fibonacci number is prime\n        if (is_prime(fib)) {\n            count++; // Increment the count of prime Fibonacci numbers\n            if (count == n) {\n                return fib; // Return the n-th prime Fibonacci number\n            }\n        }\n    }\n}\n\n"}
{"task_id": "CPP/45", "generation": "#include <stdio.h>\n#include <math.h>\n\nfloat triangle_area(float a, float h) {\n    return 0.5 * a * h; // Calculate the area using the formula\n}\n\n"}
{"task_id": "CPP/145", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nint digit_sum(int n) {\n    int sum = 0;\n    n = abs(n); // Work with the absolute value for digit sum\n    while (n > 0) {\n        sum += n % 10; // Add the last digit\n        n /= 10; // Remove the last digit\n    }\n    return sum;\n}\n\nvector<int> order_by_points(vector<int> nums) {\n    vector<pair<int, int>> indexed_nums; // Pair to hold number and its original index\n\n    for (int i = 0; i < nums.size(); ++i) {\n        indexed_nums.push_back({nums[i], i}); // Store number with its index\n    }\n\n    // Sort based on digit sum and then by original index\n    sort(indexed_nums.begin(), indexed_nums.end(), [](const pair<int, int>& a, const pair<int, int>& b) {\n        int sum_a = digit_sum(a.first);\n        int sum_b = digit_sum(b.first);\n        if (sum_a == sum_b) {\n            return a.second < b.second; // Maintain original order if digit sums are equal\n        }\n        return sum_a < sum_b; // Sort by digit sum\n    });\n\n    vector<int> result;\n    for (const auto& p : indexed_nums) {\n        result.push_back(p.first); // Extract sorted numbers\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/84", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring solve(int N) {\n    int sum = 0;\n\n    // Calculate the sum of the digits of N\n    while (N > 0) {\n        sum += N % 10;  // Add the last digit to sum\n        N /= 10;        // Remove the last digit\n    }\n\n    // Convert the sum to binary\n    string binary = \"\";\n    if (sum == 0) {\n        return \"0\";  // Handle the case where the sum is 0\n    }\n\n    while (sum > 0) {\n        binary = to_string(sum % 2) + binary;  // Prepend the binary digit\n        sum /= 2;  // Divide sum by 2\n    }\n\n    return binary;  // Return the binary representation\n}\n\n"}
{"task_id": "CPP/113", "generation": "#include <vector>\n#include <string>\n#include <sstream>\nusing namespace std;\n\nvector<string> odd_count(vector<string> lst) {\n    vector<string> result;\n    \n    for (const string& str : lst) {\n        int odd_count = 0;\n        \n        // Count the number of odd digits in the string\n        for (char ch : str) {\n            if ((ch - '0') % 2 != 0) {\n                odd_count++;\n            }\n        }\n        \n        // Create the formatted output string\n        stringstream ss;\n        ss << \"the number of odd elements \" << odd_count \n           << \"n the str\" << odd_count \n           << \"ng \" << odd_count \n           << \" of the \" << odd_count << \"nput.\";\n        \n        result.push_back(ss.str());\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/36", "generation": "#include <iostream>\nusing namespace std;\n\nint count_sevens(int number) {\n    int count = 0;\n    while (number > 0) {\n        if (number % 10 == 7) {\n            count++;\n        }\n        number /= 10; // Remove the last digit\n    }\n    return count;\n}\n\nint fizz_buzz(int n) {\n    int total_count = 0;\n    for (int i = 1; i < n; i++) {\n        if (i % 11 == 0 || i % 13 == 0) {\n            total_count += count_sevens(i);\n        }\n    }\n    return total_count;\n}\n\n"}
{"task_id": "CPP/144", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nbool simplify(string x, string n) {\n    // Parse the first fraction x\n    size_t pos = x.find('/');\n    int a = stoi(x.substr(0, pos)); // numerator of x\n    int b = stoi(x.substr(pos + 1)); // denominator of x\n\n    // Parse the second fraction n\n    pos = n.find('/');\n    int c = stoi(n.substr(0, pos)); // numerator of n\n    int d = stoi(n.substr(pos + 1)); // denominator of n\n\n    // Calculate the product's numerator and denominator\n    int product_numerator = a * c; // a * c\n    int product_denominator = b * d; // b * d\n\n    // Check if product_numerator is divisible by product_denominator\n    return (product_numerator % product_denominator == 0);\n}\n\n"}
{"task_id": "CPP/0", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // for std::sort\n#include <cmath>     // for std::abs\n\nusing namespace std;\n\nbool has_close_elements(vector<float> numbers, float threshold) {\n    // Sort the vector\n    sort(numbers.begin(), numbers.end());\n    \n    // Check adjacent elements for closeness\n    for (size_t i = 0; i < numbers.size() - 1; ++i) {\n        if (fabs(numbers[i] - numbers[i + 1]) < threshold) {\n            return true; // Found two numbers closer than the threshold\n        }\n    }\n    \n    return false; // No such pair found\n}\n\n"}
{"task_id": "CPP/17", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nvector<int> parse_music(string music_string) {\n    vector<int> durations;\n    stringstream ss(music_string);\n    string note;\n\n    while (ss >> note) {\n        if (note == \"o\") {\n            durations.push_back(4); // Whole note\n        } else if (note == \"o|\") {\n            durations.push_back(2); // Half note\n        } else if (note == \".|\") {\n            durations.push_back(1); // Quarter note\n        }\n    }\n\n    return durations;\n}\n\n"}
{"task_id": "CPP/47", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nfloat median(vector<float> l) {\n    // Sort the vector\n    sort(l.begin(), l.end());\n    \n    // Calculate the size of the vector\n    size_t size = l.size();\n    \n    // If the size is odd, return the middle element\n    if (size % 2 == 1) {\n        return l[size / 2];\n    } else {\n        // If the size is even, return the average of the two middle elements\n        return (l[size / 2 - 1] + l[size / 2]) / 2.0;\n    }\n}\n\n"}
{"task_id": "CPP/75", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\n// Function to generate a list of prime numbers less than 100\nvector<int> generate_primes() {\n    vector<int> primes;\n    for (int i = 2; i < 100; i++) {\n        if (is_prime(i)) {\n            primes.push_back(i);\n        }\n    }\n    return primes;\n}\n\n// Function to check if a number is the product of three primes\nbool is_multiply_prime(int a) {\n    vector<int> primes = generate_primes();\n    int size = primes.size();\n\n    // Check all combinations of three primes\n    for (int i = 0; i < size; i++) {\n        for (int j = i; j < size; j++) {\n            for (int k = j; k < size; k++) {\n                int product = primes[i] * primes[j] * primes[k];\n                if (product == a) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n\n"}
{"task_id": "CPP/124", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nbool valid_date(string date) {\n    // Check if the date string is empty\n    if (date.empty()) {\n        return false;\n    }\n\n    // Check if the date is in the format mm-dd-yyyy\n    if (date.size() != 10 || date[2] != '-' || date[5] != '-') {\n        return false;\n    }\n\n    // Extract month, day, and year\n    int month, day, year;\n    stringstream ss(date);\n    string monthStr, dayStr, yearStr;\n\n    getline(ss, monthStr, '-');\n    getline(ss, dayStr, '-');\n    getline(ss, yearStr);\n\n    // Convert strings to integers\n    month = stoi(monthStr);\n    day = stoi(dayStr);\n    year = stoi(yearStr);\n\n    // Check if month is valid\n    if (month < 1 || month > 12) {\n        return false;\n    }\n\n    // Check if day is valid based on the month\n    if (day < 1) {\n        return false; // Day must be at least 1\n    }\n\n    if (month == 2) { // February\n        if (day > 29) {\n            return false; // February cannot have more than 29 days\n        }\n    } else if (month == 4 || month == 6 || month == 9 || month == 11) { // April, June, September, November\n        if (day > 30) {\n            return false; // These months cannot have more than 30 days\n        }\n    } else { // January, March, May, July, August, October, December\n        if (day > 31) {\n            return false; // These months cannot have more than 31 days\n        }\n    }\n\n    // If all checks passed, the date is valid\n    return true;\n}\n\n"}
{"task_id": "CPP/101", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <cctype>\n\nusing namespace std;\n\nvector<string> words_string(string s) {\n    vector<string> words;\n    string word;\n    // Replace commas with spaces to simplify splitting\n    for (char& c : s) {\n        if (c == ',') {\n            c = ' ';\n        }\n    }\n    \n    // Use istringstream to split the string by spaces\n    istringstream stream(s);\n    while (stream >> word) {\n        words.push_back(word);\n    }\n    \n    return words;\n}\n\n"}
{"task_id": "CPP/14", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> all_prefixes(string str) {\n    vector<string> prefixes;\n    for (size_t i = 1; i <= str.length(); ++i) {\n        prefixes.push_back(str.substr(0, i)); // Get substring from 0 to i\n    }\n    return prefixes;\n}\n\n"}
{"task_id": "CPP/141", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nstring file_name_check(string file_name) {\n    // Check for exactly one dot\n    size_t dot_pos = file_name.find('.');\n    if (dot_pos == string::npos || file_name.find('.', dot_pos + 1) != string::npos) {\n        return \"No\";\n    }\n\n    // Split the file name into name and extension\n    string name = file_name.substr(0, dot_pos);\n    string extension = file_name.substr(dot_pos + 1);\n\n    // Check if the name is empty\n    if (name.empty()) {\n        return \"No\";\n    }\n\n    // Check if the first character is a letter\n    if (!isalpha(name[0])) {\n        return \"No\";\n    }\n\n    // Count the number of digits in the name\n    int digit_count = 0;\n    for (char c : name) {\n        if (isdigit(c)) {\n            digit_count++;\n        }\n    }\n    if (digit_count > 3) {\n        return \"No\";\n    }\n\n    // Check if the extension is valid\n    if (extension == \"txt\" || extension == \"exe\" || extension == \"dll\") {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\n\n// Example usage\n"}
{"task_id": "CPP/123", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\n\nusing namespace std;\n\nvector<int> get_odd_collatz(int n) {\n    set<int> odd_numbers; // Using a set to automatically handle duplicates and keep numbers sorted\n    while (n != 1) {\n        if (n % 2 != 0) { // Check if n is odd\n            odd_numbers.insert(n); // Insert odd number into the set\n        }\n        // Apply the Collatz rules\n        if (n % 2 == 0) {\n            n = n / 2; // If n is even, divide by 2\n        } else {\n            n = 3 * n + 1; // If n is odd, apply 3n + 1\n        }\n    }\n    odd_numbers.insert(1); // Include 1 in the set since the sequence always ends with 1\n\n    // Convert set to vector\n    vector<int> result(odd_numbers.begin(), odd_numbers.end());\n    return result; // Return the sorted vector of odd numbers\n}\n\n// Example usage\n"}
{"task_id": "CPP/148", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nvector<string> bf(string planet1, string planet2) {\n    // Define the order of planets in the solar system\n    vector<string> planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n    \n    // Find the indices of the given planets\n    auto it1 = find(planets.begin(), planets.end(), planet1);\n    auto it2 = find(planets.begin(), planets.end(), planet2);\n    \n    // Check if both planets are valid\n    if (it1 == planets.end() || it2 == planets.end()) {\n        return {}; // Return an empty vector if either planet is invalid\n    }\n    \n    // Get the indices of the planets\n    int index1 = distance(planets.begin(), it1);\n    int index2 = distance(planets.begin(), it2);\n    \n    // Ensure index1 is less than index2\n    if (index1 > index2) {\n        swap(index1, index2);\n    }\n    \n    // Collect planets between index1 and index2\n    vector<string> result;\n    for (int i = index1 + 1; i < index2; ++i) {\n        result.push_back(planets[i]);\n    }\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/133", "generation": "#include <iostream>\n#include <cmath>\n#include <vector>\nusing namespace std;\n\nint sum_squares(vector<float> lst) {\n    int sum = 0;\n    for (float num : lst) {\n        int rounded = ceil(num); // Round up to the nearest integer\n        sum += rounded * rounded; // Square the rounded value and add to sum\n    }\n    return sum; // Return the total sum of squares\n}\n\n"}
{"task_id": "CPP/109", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool move_one_ball(vector<int> arr) {\n    // If the vector is empty, return true\n    if (arr.empty()) {\n        return true;\n    }\n\n    int count = 0;\n    int n = arr.size();\n\n    // Check for the number of breaks in the sorted order\n    for (int i = 0; i < n; i++) {\n        if (arr[i] > arr[(i + 1) % n]) {\n            count++;\n        }\n    }\n\n    // We can have at most one break to be able to sort the array by shifts\n    return count <= 1;\n}\n\n"}
{"task_id": "CPP/100", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> make_a_pile(int n) {\n    vector<int> stones;\n    int current_stones = n; // Start with n stones for the first level\n\n    for (int i = 0; i < n; ++i) {\n        stones.push_back(current_stones); // Add current level stones to the vector\n        // Determine the next number of stones for the next level\n        if (n % 2 == 0) {\n            // n is even, so the next number should be the next even number\n            current_stones += 2; // Increment by 2 to get the next even number\n        } else {\n            // n is odd, so the next number should be the next odd number\n            current_stones += 2; // Increment by 2 to get the next odd number\n        }\n    }\n\n    return stones; // Return the vector containing the number of stones in each level\n}\n\n"}
{"task_id": "CPP/150", "generation": "#include <iostream>\nusing namespace std;\n\n// Function to check if a number is prime\nbool isPrime(int n) {\n    if (n <= 1) return false; // 0 and 1 are not prime numbers\n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0) return false; // Found a divisor, not prime\n    }\n    return true; // No divisors found, n is prime\n}\n\n// Function to return x if n is prime, otherwise return y\nint x_or_y(int n, int x, int y) {\n    if (isPrime(n)) {\n        return x; // Return x if n is prime\n    } else {\n        return y; // Return y if n is not prime\n    }\n}\n\n"}
{"task_id": "CPP/153", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nstring Strongest_Extension(string class_name, vector<string> extensions) {\n    int max_strength = INT_MIN; // Initialize to the smallest integer\n    string strongest_extension = \"\";\n\n    for (const string& extension : extensions) {\n        int CAP = 0;\n        int SM = 0;\n\n        // Calculate CAP and SM\n        for (char c : extension) {\n            if (isupper(c)) {\n                CAP++;\n            } else if (islower(c)) {\n                SM++;\n            }\n        }\n\n        // Calculate strength\n        int strength = CAP - SM;\n\n        // Check if this extension is stronger\n        if (strength > max_strength) {\n            max_strength = strength;\n            strongest_extension = extension;\n        }\n    }\n\n    // Return the result in the required format\n    return class_name + \".\" + strongest_extension;\n}\n\n"}
{"task_id": "CPP/107", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to check if a number is a palindrome\nbool isPalindrome(int num) {\n    string str = to_string(num);\n    string revStr = string(str.rbegin(), str.rend());\n    return str == revStr;\n}\n\nvector<int> even_odd_palindrome(int n) {\n    int evenCount = 0;\n    int oddCount = 0;\n\n    for (int i = 1; i <= n; ++i) {\n        if (isPalindrome(i)) {\n            if (i % 2 == 0) {\n                evenCount++;\n            } else {\n                oddCount++;\n            }\n        }\n    }\n\n    return {evenCount, oddCount};\n}\n\n// Example usage\n"}
{"task_id": "CPP/110", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring exchange(vector<int> lst1, vector<int> lst2) {\n    int oddCount = 0; // Count of odd numbers in lst1\n    int evenCountInLst2 = 0; // Count of even numbers in lst2\n\n    // Count odd numbers in lst1\n    for (int num : lst1) {\n        if (num % 2 != 0) {\n            oddCount++;\n        }\n    }\n\n    // Count even numbers in lst2\n    for (int num : lst2) {\n        if (num % 2 == 0) {\n            evenCountInLst2++;\n        }\n    }\n\n    // Check if we can exchange enough elements\n    if (oddCount <= evenCountInLst2) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n\n// Example usage\n"}
{"task_id": "CPP/111", "generation": "#include <iostream>\n#include <string>\n#include <map>\n#include <sstream>\n#include <vector>\nusing namespace std;\n\nmap<string, int> histogram(string test) {\n    map<string, int> count_map;\n    stringstream ss(test);\n    string letter;\n\n    // Count occurrences of each letter\n    while (ss >> letter) {\n        count_map[letter]++;\n    }\n\n    // Find the maximum count\n    int max_count = 0;\n    for (const auto& pair : count_map) {\n        if (pair.second > max_count) {\n            max_count = pair.second;\n        }\n    }\n\n    // Create a result map for letters with the maximum count\n    map<string, int> result;\n    for (const auto& pair : count_map) {\n        if (pair.second == max_count) {\n            result[pair.first] = pair.second;\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/80", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_happy(string s) {\n    // Check if the length of the string is at least 3\n    if (s.length() < 3) {\n        return false;\n    }\n\n    // Iterate through the string and check every 3 consecutive characters\n    for (size_t i = 0; i <= s.length() - 3; ++i) {\n        // Check if the three characters are distinct\n        if (s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]) {\n            return false; // Not happy if any two characters are the same\n        }\n    }\n\n    return true; // All sets of 3 consecutive characters are distinct\n}\n\n"}
{"task_id": "CPP/41", "generation": "#include <stdio.h>\n\nint car_race_collision(int n) {\n    // Each car moving left to right collides with each car moving right to left\n    return n * n; // Total collisions = n (left to right) * n (right to left)\n}\n\n"}
{"task_id": "CPP/116", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> sort_array(vector<int> arr) {\n    // Sort the array based on the number of 1s in binary representation and then by value\n    sort(arr.begin(), arr.end(), [](int a, int b) {\n        int count_a = __builtin_popcount(a); // Count number of 1s in binary representation of a\n        int count_b = __builtin_popcount(b); // Count number of 1s in binary representation of b\n        if (count_a == count_b) {\n            return a < b; // If counts are the same, sort by value\n        }\n        return count_a < count_b; // Sort by number of 1s\n    });\n    return arr;\n}\n"}
{"task_id": "CPP/61", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    int balance = 0; // This will keep track of the balance of brackets\n\n    for (char ch : brackets) {\n        if (ch == '(') {\n            balance++; // Increment for an opening bracket\n        } else if (ch == ')') {\n            balance--; // Decrement for a closing bracket\n        }\n\n        // If balance goes negative, we have more closing brackets than opening ones\n        if (balance < 0) {\n            return false;\n        }\n    }\n\n    // At the end, balance should be zero for all brackets to be matched\n    return balance == 0;\n}\n\n"}
{"task_id": "CPP/25", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> factorize(int n) {\n    vector<int> factors;\n    \n    // Check for number of 2s that divide n\n    while (n % 2 == 0) {\n        factors.push_back(2);\n        n /= 2;\n    }\n    \n    // n must be odd at this point, so we can skip even numbers\n    for (int i = 3; i * i <= n; i += 2) {\n        // While i divides n, add i and divide n\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n    \n    // This condition is to check if n is a prime number greater than 2\n    if (n > 2) {\n        factors.push_back(n);\n    }\n    \n    return factors;\n}\n\n"}
{"task_id": "CPP/137", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <boost/any.hpp>\n#include <sstream>\n\nusing namespace std;\n\nfloat convert_to_float(const boost::any& value) {\n    if (value.type() == typeid(string)) {\n        string str_value = boost::any_cast<string>(value);\n        replace(str_value.begin(), str_value.end(), ',', '.'); // Replace ',' with '.'\n        return stof(str_value); // Convert string to float\n    } else if (value.type() == typeid(int)) {\n        return static_cast<float>(boost::any_cast<int>(value)); // Convert int to float\n    } else if (value.type() == typeid(float)) {\n        return boost::any_cast<float>(value); // Already a float\n    }\n    throw invalid_argument(\"Invalid type\"); // Handle unexpected types\n}\n\nboost::any compare_one(boost::any a, boost::any b) {\n    try {\n        float a_float = convert_to_float(a);\n        float b_float = convert_to_float(b);\n\n        if (a_float > b_float) {\n            return a; // Return original value of a\n        } else if (b_float > a_float) {\n            return b; // Return original value of b\n        } else {\n            return \"None\"; // Values are equal\n        }\n    } catch (const invalid_argument&) {\n        return \"None\"; // Handle conversion errors\n    }\n}\n"}
{"task_id": "CPP/102", "generation": "#include<stdio.h>\nusing namespace std;\n\nint choose_num(int x, int y) {\n    // Ensure x is less than or equal to y\n    if (x > y) {\n        return -1;\n    }\n    \n    // Find the largest even number in the range [x, y]\n    if (y % 2 == 0) {\n        return y; // y is even\n    } else {\n        return (y - 1 >= x) ? (y - 1) : -1; // y is odd, check y - 1\n    }\n}\n"}
{"task_id": "CPP/10", "generation": "#include <stdio.h>\n#include <string>\n#include <algorithm> // Include for std::reverse\nusing namespace std;\n\nbool is_palindrome(string str) {\n    // Test if given string is a palindrome \n    string s(str.rbegin(), str.rend());\n    return s == str;\n}\n\nstring make_palindrome(string str) {\n    /*\n    Find the shortest palindrome that begins with a supplied string. \n    Algorithm idea is simple: - Find the longest postfix of supplied string that is a palindrome. \n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome(\"\") \n    \"\" \n    >>> make_palindrome(\"cat\") \n    \"catac\" \n    >>> make_palindrome(\"cata\") \n    \"catac\" \n    */\n    if (str.empty()) {\n        return \"\";\n    }\n\n    // Find the longest palindromic suffix\n    for (size_t i = 0; i < str.length(); i++) {\n        if (is_palindrome(str.substr(i))) {\n            // Create a string from the prefix before the palindromic suffix\n            string prefix = str.substr(0, i);\n            reverse(prefix.begin(), prefix.end()); // Reverse the prefix\n            return str + prefix; // Append the reversed prefix to the original string\n        }\n    }\n\n    // If no palindromic suffix is found, return the original string plus its reverse\n    string reversed_str = str;\n    reverse(reversed_str.begin(), reversed_str.end());\n    return str + reversed_str;\n}\n"}
{"task_id": "CPP/76", "generation": "#include <iostream>\n#include <cmath>\nusing namespace std;\n\nbool is_simple_power(int x, int n) {\n    // Handle special cases\n    if (n <= 1) {\n        return (x == 1); // 1 is a power of any number, but n=0 or n=1 is not valid for powers\n    }\n    if (x < 1) {\n        return false; // x must be a positive integer\n    }\n\n    int power = 1; // Start with n^0\n    while (power < x) {\n        power *= n; // Calculate n^k\n    }\n    \n    return (power == x); // Check if we found n^k == x\n}\n\n"}
{"task_id": "CPP/94", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <cmath>\nusing namespace std;\n\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i <= sqrt(n); ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\nint sum_of_digits(int n) {\n    int sum = 0;\n    while (n > 0) {\n        sum += n % 10;\n        n /= 10;\n    }\n    return sum;\n}\n\nint skjkasdkd(vector<int> lst) {\n    int largest_prime = -1;\n    for (int num : lst) {\n        if (is_prime(num) && num > largest_prime) {\n            largest_prime = num;\n        }\n    }\n    if (largest_prime == -1) {\n        return 0; // If no prime number is found\n    }\n    return sum_of_digits(largest_prime);\n}\n"}
{"task_id": "CPP/32", "generation": "#include <stdio.h>\n#include <math.h>\n#include <vector>\n#include <stdexcept>\n\nusing namespace std;\n\ndouble poly(vector<double> xs, double x) {\n    double sum = 0;\n    for (int i = 0; i < xs.size(); i++) {\n        sum += xs[i] * pow(x, i);\n    }\n    return sum;\n}\n\ndouble poly_derivative(vector<double> xs, double x) {\n    double sum = 0;\n    for (int i = 1; i < xs.size(); i++) {\n        sum += i * xs[i] * pow(x, i - 1);\n    }\n    return sum;\n}\n\ndouble find_zero(vector<double> xs) {\n    if (xs.size() % 2 != 0 || xs.size() < 2) {\n        throw invalid_argument(\"The number of coefficients must be even and at least 2.\");\n    }\n\n    // Initial guess (can be adjusted based on the polynomial)\n    double x0 = 0.0; \n    double tolerance = 1e-7; // Tolerance for convergence\n    int max_iterations = 1000; // Maximum number of iterations\n    int iteration = 0;\n\n    while (iteration < max_iterations) {\n        double f_x0 = poly(xs, x0);\n        double f_prime_x0 = poly_derivative(xs, x0);\n\n        if (fabs(f_prime_x0) < tolerance) {\n            // Derivative is too small, we can't proceed\n            throw runtime_error(\"Derivative is too small, no convergence.\");\n        }\n\n        // Newton-Raphson update\n        double x1 = x0 - f_x0 / f_prime_x0;\n\n        // Check for convergence\n        if (fabs(x1 - x0) < tolerance) {\n            return x1; // Found a root\n        }\n\n        x0 = x1; // Update for next iteration\n        iteration++;\n    }\n\n    throw runtime_error(\"Maximum iterations reached, no convergence.\");\n}\n\n"}
{"task_id": "CPP/33", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> sort_third(vector<int> l) {\n    // Create a vector to hold the values at indices divisible by 3\n    vector<int> third_indices_values;\n\n    // Collect values at indices divisible by 3\n    for (size_t i = 0; i < l.size(); ++i) {\n        if (i % 3 == 0) {\n            third_indices_values.push_back(l[i]);\n        }\n    }\n\n    // Sort the collected values\n    sort(third_indices_values.begin(), third_indices_values.end());\n\n    // Replace the original values at indices divisible by 3 with sorted values\n    size_t sorted_index = 0;\n    for (size_t i = 0; i < l.size(); ++i) {\n        if (i % 3 == 0) {\n            l[i] = third_indices_values[sorted_index++];\n        }\n    }\n\n    return l;\n}\n\n"}
{"task_id": "CPP/88", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> sort_array(const vector<int>& array) {\n    // Step 1: Check if the vector is empty\n    if (array.empty()) {\n        return {};\n    }\n\n    // Step 2: If the vector has only one element, return a copy of that vector\n    if (array.size() == 1) {\n        return array;\n    }\n\n    // Step 3: Calculate the sum of the first and last elements\n    int sum = array.front() + array.back();\n\n    // Step 4: Create a copy of the original array to sort\n    vector<int> sorted_array = array;\n\n    // Step 5: Sort based on the sum\n    if (sum % 2 == 0) {\n        // Even sum: sort in descending order\n        sort(sorted_array.begin(), sorted_array.end(), greater<int>());\n    } else {\n        // Odd sum: sort in ascending order\n        sort(sorted_array.begin(), sorted_array.end());\n    }\n\n    // Step 6: Return the sorted vector\n    return sorted_array;\n}\n\n// Example usage\n"}
{"task_id": "CPP/15", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nstring string_sequence(int n) {\n    stringstream ss; // Create a stringstream object to build the string\n    for (int i = 0; i <= n; ++i) {\n        ss << i; // Add the current number to the stringstream\n        if (i < n) {\n            ss << \" \"; // Add a space if it's not the last number\n        }\n    }\n    return ss.str(); // Convert the stringstream to a string and return it\n}\n\n"}
{"task_id": "CPP/163", "generation": "#include <iostream>\n#include <vector>\n#include <set>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> generate_integers(int a, int b) {\n    // Create a set to store unique even digits\n    set<int> even_digits;\n\n    // Determine the range\n    int start = min(a, b);\n    int end = max(a, b);\n\n    // Loop through the range\n    for (int i = start; i <= end; ++i) {\n        // Check if the number is a single digit and even\n        if (i >= 0 && i < 10 && i % 2 == 0) {\n            even_digits.insert(i);\n        }\n    }\n\n    // Convert the set to a vector\n    vector<int> result(even_digits.begin(), even_digits.end());\n\n    return result;\n}\n\n"}
{"task_id": "CPP/1", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cctype> // for isspace\n\nusing namespace std;\n\nvector<string> separate_paren_groups(string paren_string) {\n    vector<string> result;\n    string current_group;\n    int balance = 0;\n\n    for (char ch : paren_string) {\n        // Ignore spaces\n        if (isspace(ch)) {\n            continue;\n        }\n\n        // Add the character to the current group\n        current_group += ch;\n\n        // Update the balance based on the character\n        if (ch == '(') {\n            balance++;\n        } else if (ch == ')') {\n            balance--;\n        }\n\n        // If balance is zero, we have a complete group\n        if (balance == 0 && !current_group.empty()) {\n            result.push_back(current_group);\n            current_group.clear(); // Reset for the next group\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/69", "generation": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint search(vector<int> lst) {\n    unordered_map<int, int> frequencyMap;\n\n    // Count the frequency of each integer in the vector\n    for (int num : lst) {\n        frequencyMap[num]++;\n    }\n\n    int result = -1;\n\n    // Iterate through the frequency map to find the greatest integer\n    for (const auto& pair : frequencyMap) {\n        int value = pair.first;\n        int frequency = pair.second;\n\n        // Check if frequency is greater than or equal to the value\n        if (frequency >= value) {\n            result = max(result, value);\n        }\n    }\n\n    return result;\n}\n\n// Example usage\n"}
{"task_id": "CPP/31", "generation": "#include <iostream>\nusing namespace std;\n\nbool is_prime(long long n) {\n    // Check if n is less than 2\n    if (n <= 1) {\n        return false; // 0, 1 and negative numbers are not prime\n    }\n    // Check for factors from 2 to the square root of n\n    for (long long i = 2; i * i <= n; i++) {\n        if (n % i == 0) {\n            return false; // Found a factor, n is not prime\n        }\n    }\n    return true; // No factors found, n is prime\n}\n\n"}
{"task_id": "CPP/147", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint get_max_triples(int n) {\n    vector<int> a(n);\n    \n    // Step 1: Generate the sequence\n    for (int i = 1; i <= n; ++i) {\n        a[i - 1] = i * i - i + 1; // a[i] = i^2 - i + 1\n    }\n\n    // Step 2: Count occurrences of each modulo 3\n    int count[3] = {0, 0, 0};\n    for (int i = 0; i < n; ++i) {\n        count[a[i] % 3]++;\n    }\n\n    // Step 3: Count valid triples\n    int total_triples = 0;\n\n    // Case 1: All three numbers have the same remainder\n    for (int i = 0; i < 3; ++i) {\n        if (count[i] >= 3) {\n            total_triples += (count[i] * (count[i] - 1) * (count[i] - 2)) / 6; // nC3\n        }\n    }\n\n    // Case 2: One number from each category\n    total_triples += count[0] * count[1] * count[2];\n\n    return total_triples;\n}\n\n"}
{"task_id": "CPP/105", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nvector<string> by_length(vector<int> arr) {\n    // Step 1: Filter the integers between 1 and 9\n    vector<int> filtered;\n    for (int num : arr) {\n        if (num >= 1 && num <= 9) {\n            filtered.push_back(num);\n        }\n    }\n\n    // Step 2: Sort the filtered integers\n    sort(filtered.begin(), filtered.end());\n\n    // Step 3: Reverse the sorted vector\n    reverse(filtered.begin(), filtered.end());\n\n    // Step 4: Map integers to their corresponding names\n    vector<string> result;\n    vector<string> names = {\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"};\n    \n    for (int num : filtered) {\n        result.push_back(names[num]);\n    }\n\n    // Step 5: Return the resulting vector of strings\n    return result;\n}\n\n"}
{"task_id": "CPP/22", "generation": "#include <iostream>\n#include <vector>\n#include <list>\n#include <boost/any.hpp>\n#include <typeinfo>\n\ntypedef std::list<boost::any> list_any;\n\nstd::vector<int> filter_integers(list_any values) {\n    std::vector<int> result;\n\n    for (const auto& value : values) {\n        // Check if the value can be cast to an int\n        if (value.type() == typeid(int)) {\n            // Safely cast and add to the result vector\n            result.push_back(boost::any_cast<int>(value));\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/52", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool below_threshold(vector<int> l, int t) {\n    for (int num : l) {\n        if (num >= t) {\n            return false; // Found a number that is not below the threshold\n        }\n    }\n    return true; // All numbers are below the threshold\n}\n\n"}
{"task_id": "CPP/154", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nbool cycpattern_check(string a, string b) {\n    // Create a new string that is the concatenation of b with itself\n    string b_rotations = b + b;\n    // Check if b or any of its rotations is a substring of a\n    return (b_rotations.find(a) != string::npos) && (b.length() <= a.length());\n}\n"}
{"task_id": "CPP/115", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint max_fill(vector<vector<int>> grid, int capacity) {\n    int total_times = 0;\n\n    for (const auto& well : grid) {\n        int water_units = 0;\n\n        // Count the number of 1s in the current well (row)\n        for (int water : well) {\n            if (water == 1) {\n                water_units++;\n            }\n        }\n\n        // Calculate the number of times we need to lower the bucket for this well\n        if (water_units > 0) {\n            total_times += (water_units + capacity - 1) / capacity; // Equivalent to ceil(water_units / capacity)\n        }\n    }\n\n    return total_times;\n}\n\n"}
{"task_id": "CPP/131", "generation": "#include <stdio.h>\n\nint digits(int n) {\n    int product = 1;\n    bool hasOdd = false;\n\n    while (n > 0) {\n        int digit = n % 10; // Get the last digit\n        n /= 10; // Remove the last digit\n\n        if (digit % 2 != 0) { // Check if the digit is odd\n            product *= digit; // Multiply the product by the odd digit\n            hasOdd = true; // Set the flag indicating we found an odd digit\n        }\n    }\n\n    return hasOdd ? product : 0; // Return product if odd digits were found, otherwise return 0\n}\n\n"}
{"task_id": "CPP/37", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<float> sort_even(vector<float> l) {\n    // Create a vector to hold the values at even indices\n    vector<float> even_values;\n\n    // Extract even indexed values\n    for (size_t i = 0; i < l.size(); i += 2) {\n        even_values.push_back(l[i]);\n    }\n\n    // Sort the even indexed values\n    sort(even_values.begin(), even_values.end());\n\n    // Create a new vector to hold the result\n    vector<float> result = l;\n\n    // Replace even indices in the result with sorted values\n    for (size_t i = 0; i < even_values.size(); ++i) {\n        result[i * 2] = even_values[i];\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/92", "generation": "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\nbool any_int(float a, float b, float c) {\n    // Check if all numbers are integers\n    if (floor(a) != a || floor(b) != b || floor(c) != c) {\n        return false;\n    }\n    \n    // Convert to integers\n    int int_a = static_cast<int>(a);\n    int int_b = static_cast<int>(b);\n    int int_c = static_cast<int>(c);\n    \n    // Check if any number is equal to the sum of the other two\n    return (int_a == int_b + int_c) || (int_b == int_a + int_c) || (int_c == int_a + int_b);\n}\n\n"}
{"task_id": "CPP/118", "generation": "#include <stdio.h>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nstring get_closest_vowel(string word) {\n    string vowels = \"aeiouAEIOU\";\n    string closest_vowel = \"\";\n\n    // Start from the end of the word and look for consonants\n    for (int i = word.length() - 1; i > 0; --i) {\n        if (vowels.find(word[i]) == string::npos && vowels.find(word[i - 1]) != string::npos) {\n            // If we find a consonant followed by a vowel\n            closest_vowel = word[i - 1];\n            break;\n        } else if (vowels.find(word[i]) != string::npos && vowels.find(word[i - 1]) == string::npos) {\n            // If we find a vowel followed by a consonant\n            closest_vowel = word[i];\n            break;\n        }\n    }\n    \n    return closest_vowel;\n}\n"}
{"task_id": "CPP/6", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nvector<int> parse_nested_parens(string paren_string) {\n    vector<int> depths; // To store the maximum depths for each group\n    stringstream ss(paren_string); // Use stringstream to split the string\n    string group;\n\n    while (ss >> group) { // Read each group separated by spaces\n        int current_depth = 0; // Current depth of nesting\n        int max_depth = 0; // Maximum depth for the current group\n\n        for (char ch : group) {\n            if (ch == '(') {\n                current_depth++; // Increase depth for '('\n                if (current_depth > max_depth) {\n                    max_depth = current_depth; // Update max depth\n                }\n            } else if (ch == ')') {\n                current_depth--; // Decrease depth for ')'\n            }\n        }\n\n        depths.push_back(max_depth); // Store the maximum depth for this group\n    }\n\n    return depths; // Return the vector of depths\n}\n\n"}
{"task_id": "CPP/87", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<vector<int>> get_row(vector<vector<int>> lst, int x) {\n    vector<vector<int>> result;\n\n    // Iterate through each row\n    for (int i = 0; i < lst.size(); ++i) {\n        // Iterate through each column in the current row\n        for (int j = 0; j < lst[i].size(); ++j) {\n            // If we find the integer x, store its coordinates\n            if (lst[i][j] == x) {\n                result.push_back({i, j});\n            }\n        }\n    }\n\n    // Sort the result by row index (ascending) and then by column index (descending)\n    sort(result.begin(), result.end(), [](const vector<int>& a, const vector<int>& b) {\n        if (a[0] == b[0]) {\n            return a[1] > b[1]; // Sort by column index in descending order\n        }\n        return a[0] < b[0]; // Sort by row index in ascending order\n    });\n\n    return result;\n}\n\n// Example usage\n"}
{"task_id": "CPP/2", "generation": "#include <stdio.h>\n#include <math.h>\n\nfloat truncate_number(float number) {\n    // Get the integer part of the number\n    float integer_part = floor(number);\n    // Calculate the decimal part\n    float decimal_part = number - integer_part;\n    return decimal_part;\n}\n\n"}
{"task_id": "CPP/16", "generation": "#include <iostream>\n#include <set>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nint count_distinct_characters(string str) {\n    // Convert the string to lowercase\n    transform(str.begin(), str.end(), str.begin(), ::tolower);\n    \n    // Use a set to store distinct characters\n    set<char> distinct_chars;\n    \n    // Iterate through the string and insert characters into the set\n    for (char c : str) {\n        distinct_chars.insert(c);\n    }\n    \n    // The size of the set is the number of distinct characters\n    return distinct_chars.size();\n}\n\n"}
{"task_id": "CPP/135", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint can_arrange(vector<int> arr) {\n    int n = arr.size();\n    int largestIndex = -1; // Initialize to -1, which indicates no such element found\n\n    // Iterate through the array starting from the second element\n    for (int i = 1; i < n; i++) {\n        // Check if the current element is less than the previous element\n        if (arr[i] < arr[i - 1]) {\n            largestIndex = i; // Update the largest index found\n        }\n    }\n\n    return largestIndex; // Return the largest index found, or -1 if none found\n}\n\n"}
{"task_id": "CPP/106", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> f(int n) {\n    vector<int> result(n);\n    \n    for (int i = 1; i <= n; ++i) {\n        if (i % 2 == 0) { // i is even\n            // Calculate factorial of i\n            int factorial = 1;\n            for (int j = 1; j <= i; ++j) {\n                factorial *= j;\n            }\n            result[i - 1] = factorial; // Store in the vector (0-based index)\n        } else { // i is odd\n            // Calculate sum of numbers from 1 to i\n            int sum = (i * (i + 1)) / 2; // Using the formula for sum of first i natural numbers\n            result[i - 1] = sum; // Store in the vector (0-based index)\n        }\n    }\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/162", "generation": "#include <stdio.h>\n#include <string>\n#include <openssl/md5.h>\nusing namespace std;\n\nstring string_to_md5(string text) {\n    if (text.empty()) {\n        return \"\"; // Return an empty string to represent None\n    }\n\n    unsigned char digest[MD5_DIGEST_LENGTH];\n    MD5((unsigned char*)text.c_str(), text.length(), digest);\n\n    char md5String[33];\n    for (int i = 0; i < 16; i++) {\n        sprintf(&md5String[i * 2], \"%02x\", (unsigned int)digest[i]);\n    }\n\n    return string(md5String);\n}\n"}
{"task_id": "CPP/5", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvector<int> intersperse(vector<int> numbers, int delimiter) {\n    vector<int> result;\n\n    // Check if the input vector is empty\n    if (numbers.empty()) {\n        return result; // Return an empty vector\n    }\n\n    // Iterate through the input vector\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        result.push_back(numbers[i]); // Add the current element to the result\n\n        // If it's not the last element, add the delimiter\n        if (i < numbers.size() - 1) {\n            result.push_back(delimiter);\n        }\n    }\n\n    return result; // Return the result vector\n}\n\n"}
{"task_id": "CPP/97", "generation": "#include <iostream>\n#include <cmath> // for abs function\nusing namespace std;\n\nint multiply(int a, int b) {\n    // Get the unit digits of both numbers\n    int unitDigitA = abs(a) % 10; // Absolute value to handle negative numbers\n    int unitDigitB = abs(b) % 10; // Absolute value to handle negative numbers\n    \n    // Return the product of the unit digits\n    return unitDigitA * unitDigitB;\n}\n\n"}
{"task_id": "CPP/44", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring change_base(int x, int base) {\n    if (x == 0) return \"0\"; // Handle the case where x is zero\n\n    string result = \"\";\n    while (x > 0) {\n        int remainder = x % base; // Get the remainder\n        result = to_string(remainder) + result; // Prepend the remainder to the result\n        x /= base; // Divide x by the base\n    }\n    return result;\n}\n\n"}
{"task_id": "CPP/161", "generation": "#include <iostream>\n#include <string>\n#include <cctype> // for isalpha, tolower, toupper\nusing namespace std;\n\nstring solve(string s) {\n    bool hasLetter = false;\n\n    // First, check if there are any letters in the string\n    for (char c : s) {\n        if (isalpha(c)) {\n            hasLetter = true;\n            break;\n        }\n    }\n\n    if (hasLetter) {\n        // If there are letters, reverse their case\n        for (char &c : s) {\n            if (isalpha(c)) {\n                // Reverse case\n                if (islower(c)) {\n                    c = toupper(c);\n                } else {\n                    c = tolower(c);\n                }\n            }\n        }\n    } else {\n        // If there are no letters, reverse the entire string\n        reverse(s.begin(), s.end());\n    }\n\n    return s;\n}\n\n"}
{"task_id": "CPP/38", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nstring encode_cyclic(string s) { \n    // returns encoded string by cycling groups of three characters.  \n    int l = s.length();\n    string output;\n    for (int i = 0; i * 3 < l; i++) {\n        string x = s.substr(i * 3, 3);\n        if (x.length() == 3) {\n            x = x.substr(1) + x[0]; // Cycle the group\n        }\n        output += x; // Append to output\n    }\n    return output;\n}\n\nstring decode_cyclic(string s) { \n    /*\n    Takes as input string encoded with encode_cyclic function. Returns decoded string. \n    */\n    int l = s.length();\n    string output;\n    for (int i = 0; i * 3 < l; i++) {\n        string x = s.substr(i * 3, 3);\n        if (x.length() == 3) {\n            x = x[x.length() - 1] + x.substr(0, x.length() - 1); // Reverse the cycle\n        }\n        output += x; // Append to output\n    }\n    return output;\n}\n\n"}
{"task_id": "CPP/93", "generation": "#include <iostream>\n#include <string>\n#include <cctype>\n\nusing namespace std;\n\nstring encode(string message) {\n    string encodedMessage = \"\";\n\n    for (char ch : message) {\n        // Swap case\n        if (isalpha(ch)) {\n            if (islower(ch)) {\n                ch = toupper(ch);\n            } else {\n                ch = tolower(ch);\n            }\n\n            // Replace vowels\n            switch (ch) {\n                case 'A': ch = 'C'; break;\n                case 'E': ch = 'G'; break;\n                case 'I': ch = 'K'; break;\n                case 'O': ch = 'Q'; break;\n                case 'U': ch = 'W'; break;\n                case 'a': ch = 'c'; break;\n                case 'e': ch = 'g'; break;\n                case 'i': ch = 'k'; break;\n                case 'o': ch = 'q'; break;\n                case 'u': ch = 'w'; break;\n                default: break; // Non-vowel characters remain unchanged\n            }\n        }\n        encodedMessage += ch; // Append the processed character to the result\n    }\n\n    return encodedMessage;\n}\n\n"}
{"task_id": "CPP/152", "generation": "#include <iostream>\n#include <vector>\n#include <cmath> // for abs function\n\nusing namespace std;\n\nvector<int> compare(const vector<int>& game, const vector<int>& guess) {\n    vector<int> result; // Vector to store the results\n    int size = game.size(); // Get the size of the input vectors\n\n    // Iterate through each match\n    for (int i = 0; i < size; i++) {\n        // Calculate the absolute difference and add it to the result vector\n        result.push_back(abs(game[i] - guess[i]));\n    }\n\n    return result; // Return the result vector\n}\n\n"}
{"task_id": "CPP/62", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<float> derivative(vector<float> xs) {\n    vector<float> result;\n    int degree = xs.size(); // The degree of the polynomial is the size of the vector\n\n    // Iterate through the coefficients, starting from the first term (index 1)\n    for (int i = 1; i < degree; i++) {\n        // The derivative of xs[i] * x^i is i * xs[i]\n        result.push_back(i * xs[i]);\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/7", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<string> filter_by_substring(const vector<string>& strings, const string& substring) {\n    vector<string> result; // Vector to hold the filtered results\n\n    // Iterate through each string in the input vector\n    for (const string& str : strings) {\n        // Check if the substring is found in the current string\n        if (str.find(substring) != string::npos) {\n            result.push_back(str); // Add to result if found\n        }\n    }\n\n    return result; // Return the filtered vector\n}\n\n"}
{"task_id": "CPP/24", "generation": "#include <iostream>\nusing namespace std;\n\nint largest_divisor(int n) {\n    // Start from n-1 and go down to 1\n    for (int i = n - 1; i > 0; i--) {\n        if (n % i == 0) { // Check if i is a divisor of n\n            return i; // Return the largest divisor found\n        }\n    }\n    return 1; // In case n is 1, the largest divisor is 1\n}\n\n"}
{"task_id": "CPP/79", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring decimal_to_binary(int decimal) {\n    // Handle the case for zero explicitly\n    if (decimal == 0) {\n        return \"db0db\";\n    }\n\n    string binary = \"\";\n    \n    // Convert decimal to binary\n    while (decimal > 0) {\n        // Prepend the remainder (0 or 1) to the binary string\n        binary = to_string(decimal % 2) + binary;\n        decimal /= 2; // Divide by 2 to shift right\n    }\n\n    // Add the \"db\" prefix and suffix\n    return \"db\" + binary + \"db\";\n}\n\n"}
{"task_id": "CPP/155", "generation": "#include <iostream>\n#include <vector>\n#include <cmath> // for abs function\n\nusing namespace std;\n\nvector<int> even_odd_count(int num) {\n    // Initialize counts for even and odd digits\n    int even_count = 0;\n    int odd_count = 0;\n\n    // Use absolute value to handle negative numbers\n    num = abs(num);\n\n    // If the number is 0, it has one even digit\n    if (num == 0) {\n        even_count = 1;\n    } else {\n        // Loop through each digit\n        while (num > 0) {\n            int digit = num % 10; // Get the last digit\n            if (digit % 2 == 0) {\n                even_count++; // Increment even count\n            } else {\n                odd_count++; // Increment odd count\n            }\n            num /= 10; // Remove the last digit\n        }\n    }\n\n    // Return the counts as a vector\n    return {even_count, odd_count};\n}\n\n"}
{"task_id": "CPP/4", "generation": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nfloat mean_absolute_deviation(const vector<float>& numbers) {\n    if (numbers.empty()) {\n        return 0.0; // Return 0 for empty vector\n    }\n\n    // Step 1: Calculate the mean\n    float sum = 0.0;\n    for (float num : numbers) {\n        sum += num;\n    }\n    float mean = sum / numbers.size();\n\n    // Step 2: Calculate the absolute differences and their average\n    float mad_sum = 0.0;\n    for (float num : numbers) {\n        mad_sum += fabs(num - mean);\n    }\n    float mad = mad_sum / numbers.size();\n\n    return mad;\n}\n\n"}
{"task_id": "CPP/56", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    int count = 0; // Initialize a counter for opening brackets\n\n    for (char ch : brackets) {\n        if (ch == '<') {\n            count++; // Increment for opening bracket\n        } else if (ch == '>') {\n            count--; // Decrement for closing bracket\n        }\n\n        // If count goes negative, there are unmatched closing brackets\n        if (count < 0) {\n            return false;\n        }\n    }\n\n    // At the end, count should be zero for all brackets to be matched\n    return count == 0;\n}\n\n"}
{"task_id": "CPP/159", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> eat(int number, int need, int remaining) {\n    // Calculate how many more carrots the rabbit needs to eat\n    int totalEaten = number; // Start with the number of carrots already eaten\n    int carrotsToEat = need; // This is how many more carrots the rabbit needs\n\n    // Check if there are enough remaining carrots\n    if (remaining >= carrotsToEat) {\n        // If there are enough carrots, eat the needed amount\n        totalEaten += carrotsToEat;\n        remaining -= carrotsToEat;\n    } else {\n        // If not enough, eat all remaining carrots\n        totalEaten += remaining;\n        remaining = 0; // All remaining carrots are eaten\n    }\n\n    // Return the result as a vector\n    return {totalEaten, remaining};\n}\n\n// Example usage\n"}
{"task_id": "CPP/83", "generation": "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\nint starts_one_ends(int n) {\n    if (n == 1) {\n        // For n = 1, the only number is '1'\n        return 1;\n    }\n    \n    // Count of n-digit numbers starting with '1'\n    long long count_start = pow(10, n - 1);\n    \n    // Count of n-digit numbers ending with '1'\n    long long count_end = 9 * pow(10, n - 2);\n    \n    // Count of n-digit numbers starting and ending with '1'\n    long long count_both = pow(10, n - 2);\n    \n    // Total count using inclusion-exclusion principle\n    long long total_count = count_start + count_end - count_both;\n    \n    return total_count;\n}\n\n"}
{"task_id": "CPP/27", "generation": "#include <iostream>\n#include <string>\n#include <cctype> // for islower and isupper\n\nusing namespace std;\n\nstring flip_case(string str) {\n    for (char &c : str) { // Iterate through each character in the string\n        if (islower(c)) {\n            c = toupper(c); // Convert to uppercase if it's lowercase\n        } else if (isupper(c)) {\n            c = tolower(c); // Convert to lowercase if it's uppercase\n        }\n    }\n    return str; // Return the modified string\n}\n\n"}
{"task_id": "CPP/146", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nint specialFilter(vector<int> nums) {\n    int count = 0;\n\n    for (int num : nums) {\n        // Check if the number is greater than 10\n        if (num > 10) {\n            // Convert the number to a string to easily access digits\n            string numStr = to_string(num);\n            char firstDigit = numStr[0];\n            char lastDigit = numStr[numStr.length() - 1];\n\n            // Check if both first and last digits are odd\n            if ((firstDigit == '1' || firstDigit == '3' || firstDigit == '5' || firstDigit == '7' || firstDigit == '9') &&\n                (lastDigit == '1' || lastDigit == '3' || lastDigit == '5' || lastDigit == '7' || lastDigit == '9')) {\n                count++;\n            }\n        }\n    }\n\n    return count;\n}\n\n"}
{"task_id": "CPP/81", "generation": "#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> numerical_letter_grade(vector<float> grades) {\n    vector<string> letter_grades;\n    for (float gpa : grades) {\n        if (gpa == 4.0) {\n            letter_grades.push_back(\"A+\");\n        } else if (gpa > 3.7) {\n            letter_grades.push_back(\"A\");\n        } else if (gpa > 3.3) {\n            letter_grades.push_back(\"A-\");\n        } else if (gpa > 3.0) {\n            letter_grades.push_back(\"B+\");\n        } else if (gpa > 2.7) {\n            letter_grades.push_back(\"B\");\n        } else if (gpa > 2.3) {\n            letter_grades.push_back(\"B-\");\n        } else if (gpa > 2.0) {\n            letter_grades.push_back(\"C+\");\n        } else if (gpa > 1.7) {\n            letter_grades.push_back(\"C\");\n        } else if (gpa > 1.3) {\n            letter_grades.push_back(\"C-\");\n        } else if (gpa > 1.0) {\n            letter_grades.push_back(\"D+\");\n        } else if (gpa > 0.7) {\n            letter_grades.push_back(\"D\");\n        } else if (gpa > 0.0) {\n            letter_grades.push_back(\"D-\");\n        } else {\n            letter_grades.push_back(\"E\");\n        }\n    }\n    return letter_grades;\n}\n"}
{"task_id": "CPP/136", "generation": "#include <iostream>\n#include <vector>\n#include <limits>\n\nusing namespace std;\n\nvector<int> largest_smallest_integers(vector<int> lst) {\n    int largest_negative = numeric_limits<int>::min(); // Initialize to the smallest possible integer\n    int smallest_positive = numeric_limits<int>::max(); // Initialize to the largest possible integer\n    \n    bool found_negative = false;\n    bool found_positive = false;\n\n    for (int num : lst) {\n        if (num < 0) {\n            found_negative = true;\n            if (num > largest_negative) {\n                largest_negative = num; // Update largest negative\n            }\n        } else if (num > 0) {\n            found_positive = true;\n            if (num < smallest_positive) {\n                smallest_positive = num; // Update smallest positive\n            }\n        }\n    }\n\n    // If no negative number was found, set largest_negative to 0\n    if (!found_negative) {\n        largest_negative = 0;\n    }\n    \n    // If no positive number was found, set smallest_positive to 0\n    if (!found_positive) {\n        smallest_positive = 0;\n    }\n\n    return {largest_negative, smallest_positive};\n}\n\n"}
{"task_id": "CPP/67", "generation": "#include <stdio.h>\n#include <string>\n#include <sstream>\nusing namespace std;\n\nint fruit_distribution(string s, int n) {\n    int apples = 0, oranges = 0;\n    stringstream ss(s);\n    ss >> apples; // Read the number of apples\n    ss.ignore(256, ' '); // Ignore the word \"apples\"\n    ss >> oranges; // Read the number of oranges\n    ss.ignore(256, ' '); // Ignore the word \"oranges\"\n    \n    // Calculate the number of mangoes\n    int mangoes = n - apples - oranges;\n    return mangoes;\n}\n"}
{"task_id": "CPP/48", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_palindrome(string text) {\n    // Get the length of the string\n    int n = text.length();\n    \n    // Compare characters from start and end moving towards the center\n    for (int i = 0; i < n / 2; i++) {\n        if (text[i] != text[n - i - 1]) {\n            return false; // Not a palindrome\n        }\n    }\n    return true; // Is a palindrome\n}\n\n"}
{"task_id": "CPP/125", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nvector<string> split_words(string txt) {\n    vector<string> result;\n    // Check for whitespace\n    if (txt.find(' ') != string::npos) {\n        // Split by whitespace\n        istringstream iss(txt);\n        string word;\n        while (iss >> word) {\n            result.push_back(word);\n        }\n    } \n    // Check for commas\n    else if (txt.find(',') != string::npos) {\n        // Split by commas\n        size_t start = 0;\n        size_t end = txt.find(',');\n        while (end != string::npos) {\n            result.push_back(txt.substr(start, end - start));\n            start = end + 1;\n            end = txt.find(',', start);\n        }\n        result.push_back(txt.substr(start)); // Add the last segment\n    } \n    // No whitespace or commas\n    else {\n        int count = 0;\n        for (char c : txt) {\n            if (c >= 'a' && c <= 'z') {\n                int position = c - 'a'; // Get the position in the alphabet\n                if (position % 2 == 1) { // Check if it's odd\n                    count++;\n                }\n            }\n        }\n        result.push_back(to_string(count)); // Convert count to string and add to result\n    }\n    return result;\n}\n\n// Example usage\n"}
{"task_id": "CPP/160", "generation": "#include <stdio.h>\n#include <math.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nint do_algebra(vector<string> operato, vector<int> operand) {\n    int result = operand[0]; // Initialize result with the first operand\n    for (size_t i = 0; i < operato.size(); i++) {\n        if (operato[i] == \"+\") {\n            result += operand[i + 1];\n        } else if (operato[i] == \"-\") {\n            result -= operand[i + 1];\n        } else if (operato[i] == \"*\") {\n            result *= operand[i + 1];\n        } else if (operato[i] == \"//\") {\n            result /= operand[i + 1]; // Using integer division\n        } else if (operato[i] == \"**\") {\n            result = pow(result, operand[i + 1]); // Exponentiation\n        }\n    }\n    return result; // Return the final result\n}\n"}
{"task_id": "CPP/151", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nlong long double_the_difference(vector<float> lst) {\n    long long sum = 0; // Initialize sum to 0\n\n    for (float num : lst) {\n        // Check if the number is a positive integer and odd\n        if (num >= 0 && num == static_cast<int>(num) && static_cast<int>(num) % 2 != 0) {\n            int oddNum = static_cast<int>(num); // Cast to int\n            sum += oddNum * oddNum; // Add the square of the odd number to the sum\n        }\n    }\n\n    return sum; // Return the final sum\n}\n\n"}
{"task_id": "CPP/117", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <cctype>\n\nusing namespace std;\n\nbool is_consonant(char c) {\n    // Check if the character is a consonant\n    c = tolower(c); // Convert to lowercase for uniformity\n    return isalpha(c) && (c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u');\n}\n\nvector<string> select_words(string s, int n) {\n    vector<string> result;\n    stringstream ss(s);\n    string word;\n\n    // If the string is empty, return an empty vector\n    if (s.empty()) {\n        return result;\n    }\n\n    // Process each word in the string\n    while (ss >> word) {\n        int consonant_count = 0;\n\n        // Count consonants in the current word\n        for (char c : word) {\n            if (is_consonant(c)) {\n                consonant_count++;\n            }\n        }\n\n        // If the word has exactly n consonants, add it to the result\n        if (consonant_count == n) {\n            result.push_back(word);\n        }\n    }\n\n    return result;\n}\n\n// Example usage\n"}
{"task_id": "CPP/78", "generation": "#include <iostream>\n#include <string>\n#include <unordered_set>\n\nusing namespace std;\n\nint hex_key(string num) {\n    // Set of prime hexadecimal digits\n    unordered_set<char> prime_hex_digits = {'2', '3', '5', '7', 'B', 'D'};\n    int count = 0;\n\n    // Iterate through each character in the string\n    for (char digit : num) {\n        // Check if the digit is in the set of prime hexadecimal digits\n        if (prime_hex_digits.find(digit) != prime_hex_digits.end()) {\n            count++;\n        }\n    }\n\n    return count;\n}\n\n"}
{"task_id": "CPP/74", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> total_match(vector<string> lst1, vector<string> lst2) {\n    int total_chars_lst1 = 0;\n    int total_chars_lst2 = 0;\n\n    // Calculate total characters in lst1\n    for (const string& s : lst1) {\n        total_chars_lst1 += s.length();\n    }\n\n    // Calculate total characters in lst2\n    for (const string& s : lst2) {\n        total_chars_lst2 += s.length();\n    }\n\n    // Return the vector with fewer total characters, or lst1 if they are equal\n    if (total_chars_lst1 < total_chars_lst2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n"}
{"task_id": "CPP/53", "generation": "#include <iostream>\nusing namespace std;\n\n// Function to add two numbers\nint add(int x, int y) {\n    return x + y;\n}\n\n"}
{"task_id": "CPP/98", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint count_upper(string s) {\n    int count = 0;\n    // Define the uppercase vowels\n    string vowels = \"AEIOU\";\n    \n    // Loop through the string, checking only even indices\n    for (int i = 0; i < s.length(); i += 2) {\n        // Check if the character is an uppercase vowel\n        if (vowels.find(s[i]) != string::npos) {\n            count++;\n        }\n    }\n    \n    return count;\n}\n\n"}
{"task_id": "CPP/140", "generation": "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nstring fix_spaces(string text) {\n    // Replace all spaces with underscores\n    for (char& c : text) {\n        if (c == ' ') {\n            c = '_';\n        }\n    }\n\n    // Split the text by underscores to handle consecutive spaces\n    vector<string> parts;\n    size_t start = 0, end = 0;\n\n    while ((end = text.find('_', start)) != string::npos) {\n        parts.push_back(text.substr(start, end - start));\n        start = end + 1;\n    }\n    parts.push_back(text.substr(start)); // Add the last part\n\n    // Create a new string to store the processed result\n    string result;\n    \n    for (const string& part : parts) {\n        if (!part.empty()) { // Only add non-empty parts\n            if (!result.empty()) {\n                result += '_'; // Add underscore before the next part if result is not empty\n            }\n            result += part;\n        } else {\n            // If the part is empty, it means there were consecutive spaces\n            if (!result.empty()) { // Only add '-' if there's already something in result\n                result += '-';\n            }\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/34", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\n\nusing namespace std;\n\nvector<int> unique(vector<int> l) {\n    // Use a set to store unique elements\n    set<int> uniqueSet(l.begin(), l.end());\n    \n    // Convert the set back to a vector\n    vector<int> uniqueVector(uniqueSet.begin(), uniqueSet.end());\n    \n    // Return the sorted unique elements\n    return uniqueVector;\n}\n\n"}
{"task_id": "CPP/66", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint digitSum(string s) {\n    int sum = 0; // Initialize sum to 0\n    for (char c : s) { // Iterate through each character in the string\n        if (isupper(c)) { // Check if the character is uppercase\n            sum += static_cast<int>(c); // Add the ASCII value of the uppercase character to the sum\n        }\n    }\n    return sum; // Return the final sum\n}\n\n"}
{"task_id": "CPP/120", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> maximum(vector<int> arr, int k) {\n    // Step 1: Sort the array in descending order\n    sort(arr.begin(), arr.end(), greater<int>());\n    \n    // Step 2: Select the first k elements\n    vector<int> maxElements(arr.begin(), arr.begin() + k);\n    \n    // Step 3: Sort the selected k elements in ascending order\n    sort(maxElements.begin(), maxElements.end());\n    \n    return maxElements;\n}\n\n"}
{"task_id": "CPP/139", "generation": "#include <iostream>\nusing namespace std;\n\n// Function to calculate factorial of a number\nlong long factorial(int num) {\n    long long result = 1;\n    for (int i = 1; i <= num; i++) {\n        result *= i;\n    }\n    return result;\n}\n\n// Function to calculate the Brazilian factorial\nlong long special_factorial(int n) {\n    long long result = 1;\n    for (int i = 1; i <= n; i++) {\n        result *= factorial(i);\n    }\n    return result;\n}\n\n"}
{"task_id": "CPP/12", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring longest(vector<string> strings) {\n    if (strings.empty()) {\n        return \"\"; // Return an empty string to indicate None in Python\n    }\n    string longest_string = strings[0];\n    for (const string& str : strings) {\n        if (str.length() > longest_string.length()) {\n            longest_string = str;\n        }\n    }\n    return longest_string;\n}\n"}
{"task_id": "CPP/121", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint solution(vector<int> lst) {\n    int sum = 0;\n    \n    // Iterate through the vector\n    for (size_t i = 0; i < lst.size(); i++) {\n        // Check if the index is even and the element is odd\n        if (i % 2 == 0 && lst[i] % 2 != 0) {\n            sum += lst[i]; // Add the odd element at even index to the sum\n        }\n    }\n    \n    return sum; // Return the final sum\n}\n\n"}
{"task_id": "CPP/35", "generation": "#include <iostream>\n#include <vector>\n#include <limits>\n\nusing namespace std;\n\nfloat max_element(const vector<float>& l) {\n    // Check if the vector is empty\n    if (l.empty()) {\n        // Handle the case of an empty vector, you can return a specific value or throw an exception\n        throw invalid_argument(\"The vector is empty.\");\n    }\n\n    // Initialize max_value to the smallest possible float\n    float max_value = numeric_limits<float>::lowest();\n\n    // Iterate through the vector to find the maximum element\n    for (float num : l) {\n        if (num > max_value) {\n            max_value = num;\n        }\n    }\n\n    return max_value;\n}\n\n"}
{"task_id": "CPP/20", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <limits>\n\nusing namespace std;\n\nvector<float> find_closest_elements(vector<float> numbers) {\n    // Step 1: Sort the vector\n    sort(numbers.begin(), numbers.end());\n    \n    // Initialize variables to track the closest pair\n    float min_diff = numeric_limits<float>::max(); // Start with the maximum possible float\n    pair<float, float> closest_pair;\n\n    // Step 2: Find the closest pair\n    for (size_t i = 0; i < numbers.size() - 1; ++i) {\n        float diff = numbers[i + 1] - numbers[i]; // Calculate the difference between consecutive elements\n        if (diff < min_diff) {\n            min_diff = diff; // Update the minimum difference\n            closest_pair = make_pair(numbers[i], numbers[i + 1]); // Update the closest pair\n        }\n    }\n\n    // Step 3: Return the closest pair as a vector\n    return vector<float>{closest_pair.first, closest_pair.second};\n}\n\n"}
{"task_id": "CPP/19", "generation": "#include <iostream>\n#include <string>\n#include <map>\n#include <vector>\n#include <sstream>\n#include <algorithm>\n\nusing namespace std;\n\nstring sort_numbers(string numbers) {\n    // Mapping from string to integer\n    map<string, int> num_map = {\n        {\"zero\", 0}, {\"one\", 1}, {\"two\", 2}, {\"three\", 3},\n        {\"four\", 4}, {\"five\", 5}, {\"six\", 6}, {\"seven\", 7},\n        {\"eight\", 8}, {\"nine\", 9}\n    };\n\n    // Vector to hold the integer values\n    vector<int> num_values;\n    stringstream ss(numbers);\n    string word;\n\n    // Split the input string and convert to integers\n    while (ss >> word) {\n        num_values.push_back(num_map[word]);\n    }\n\n    // Sort the integer values\n    sort(num_values.begin(), num_values.end());\n\n    // Convert sorted integers back to strings\n    vector<string> sorted_words;\n    for (int num : num_values) {\n        for (const auto& pair : num_map) {\n            if (pair.second == num) {\n                sorted_words.push_back(pair.first);\n                break;\n            }\n        }\n    }\n\n    // Join the sorted words into a single output string\n    string result;\n    for (size_t i = 0; i < sorted_words.size(); ++i) {\n        result += sorted_words[i];\n        if (i < sorted_words.size() - 1) {\n            result += \" \"; // Add space between words\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/85", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint add(vector<int> lst) {\n    int sum = 0; // Initialize sum to 0\n    for (size_t i = 0; i < lst.size(); ++i) { // Iterate through the vector\n        if (i % 2 != 0 && lst[i] % 2 == 0) { // Check if index is odd and element is even\n            sum += lst[i]; // Add the element to sum\n        }\n    }\n    return sum; // Return the final sum\n}\n\n"}
{"task_id": "CPP/21", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // for std::min_element and std::max_element\n\nusing namespace std;\n\nvector<float> rescale_to_unit(vector<float> numbers) {\n    // Find the minimum and maximum values in the vector\n    float min_value = *min_element(numbers.begin(), numbers.end());\n    float max_value = *max_element(numbers.begin(), numbers.end());\n    \n    // Create a new vector to hold the rescaled values\n    vector<float> rescaled_values;\n    \n    // Apply the linear transformation to each element\n    for (float number : numbers) {\n        float rescaled_value = (number - min_value) / (max_value - min_value);\n        rescaled_values.push_back(rescaled_value);\n    }\n    \n    return rescaled_values;\n}\n\n"}
{"task_id": "CPP/119", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring match_parens(vector<string> lst) {\n    string s1 = lst[0], s2 = lst[1];\n\n    // Function to count the balance of parentheses\n    auto balance = [](const string& s) {\n        int count = 0;\n        for (char ch : s) {\n            if (ch == '(') {\n                count++;\n            } else {\n                count--;\n            }\n            if (count < -1) { // More closing than opening\n                return count;\n            }\n        }\n        return count;\n    };\n\n    // Check both concatenation orders\n    int balance1 = balance(s1 + s2);\n    int balance2 = balance(s2 + s1);\n\n    // A good string must have a balance of 0 or 1 at the end\n    return (balance1 >= 0 && balance2 >= 0) ? \"Yes\" : \"No\";\n}\n"}
{"task_id": "CPP/30", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<float> get_positive(vector<float> l) {\n    vector<float> positive_numbers; // Vector to store positive numbers\n    for (float num : l) { // Iterate through each number in the input vector\n        if (num > 0) { // Check if the number is positive\n            positive_numbers.push_back(num); // Add positive number to the new vector\n        }\n    }\n    return positive_numbers; // Return the vector containing only positive numbers\n}\n\n"}
{"task_id": "CPP/64", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint vowels_count(string s) {\n    int count = 0;\n    int length = s.length();\n\n    for (int i = 0; i < length; i++) {\n        char c = tolower(s[i]); // Convert to lowercase for uniformity\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n            count++;\n        }\n        // Check if 'y' is at the end of the string\n        if (c == 'y' && i == length - 1) {\n            count++;\n        }\n    }\n    \n    return count;\n}\n\n"}
{"task_id": "CPP/128", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint prod_signs(vector<int> arr) {\n    if (arr.empty()) {\n        return -32768; // Return -32768 for empty array\n    }\n\n    int sum_magnitudes = 0;\n    int product_signs = 1; // Start with 1 since it's the multiplicative identity\n\n    for (int num : arr) {\n        if (num > 0) {\n            sum_magnitudes += num; // Add magnitude\n            product_signs *= 1; // Positive sign\n        } else if (num < 0) {\n            sum_magnitudes += -num; // Add magnitude (negative number)\n            product_signs *= -1; // Negative sign\n        } else {\n            product_signs = 0; // If zero is encountered, product of signs is 0\n            break; // No need to check further\n        }\n    }\n\n    return sum_magnitudes * product_signs; // Return the final result\n}\n\n"}
{"task_id": "CPP/127", "generation": "#include <vector>\n#include <string>\n#include <cmath>\nusing namespace std;\n\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i <= sqrt(n); i++) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\nstring intersection(vector<int> interval1, vector<int> interval2) {\n    int start1 = interval1[0], end1 = interval1[1];\n    int start2 = interval2[0], end2 = interval2[1];\n    \n    // Find the intersection of the two intervals\n    int start_intersection = max(start1, start2);\n    int end_intersection = min(end1, end2);\n    \n    // Calculate the length of the intersection\n    int length_intersection = end_intersection - start_intersection;\n    \n    // Check if the length is a prime number\n    if (length_intersection > 0 && is_prime(length_intersection)) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n"}
{"task_id": "CPP/122", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint add_elements(vector<int> arr, int k) {\n    int sum = 0; // Initialize sum to 0\n    // Iterate through the first k elements\n    for (int i = 0; i < k; i++) {\n        // Check if the element has at most two digits\n        if (arr[i] >= -99 && arr[i] <= 99) {\n            sum += arr[i]; // Add to sum if condition is met\n        }\n    }\n    return sum; // Return the final sum\n}\n\n"}
{"task_id": "CPP/59", "generation": "#include <iostream>\nusing namespace std;\n\nint largest_prime_factor(int n) {\n    int largest_factor = 1;\n\n    // Check for number of 2s that divide n\n    while (n % 2 == 0) {\n        largest_factor = 2;\n        n /= 2;\n    }\n\n    // n must be odd at this point, so we can skip even numbers\n    for (int i = 3; i * i <= n; i += 2) {\n        // While i divides n, update n and largest_factor\n        while (n % i == 0) {\n            largest_factor = i;\n            n /= i;\n        }\n    }\n\n    // This condition is to check if n is a prime number greater than 2\n    if (n > 2) {\n        largest_factor = n;\n    }\n\n    return largest_factor;\n}\n\n"}
{"task_id": "CPP/134", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nbool check_if_last_char_is_a_letter(string txt) {\n    // Strip any trailing spaces\n    size_t end = txt.find_last_not_of(' ');\n    if (end == string::npos) {\n        return false; // The string is empty after stripping\n    }\n    \n    // Check if the last character is an alphabetical character\n    if (isalpha(txt[end])) {\n        // Check if it's not part of a word\n        return end == 0 || txt[end - 1] == ' ';\n    }\n    \n    return false;\n}\n"}
{"task_id": "CPP/42", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> incr_list(vector<int> l) {\n    // Create a new vector to store the incremented values\n    vector<int> incremented_list;\n    \n    // Iterate through each element in the input vector\n    for (int i = 0; i < l.size(); i++) {\n        // Increment the current element by 1 and add it to the new vector\n        incremented_list.push_back(l[i] + 1);\n    }\n    \n    // Return the new vector with incremented values\n    return incremented_list;\n}\n\n"}
{"task_id": "CPP/11", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring string_xor(string a, string b) {\n    // Ensure both strings are of the same length\n    if (a.length() != b.length()) {\n        throw invalid_argument(\"Strings must be of the same length\");\n    }\n\n    string result = \"\";\n    for (size_t i = 0; i < a.length(); ++i) {\n        // Perform XOR operation\n        if (a[i] == b[i]) {\n            result += '0'; // Both bits are the same\n        } else {\n            result += '1'; // Bits are different\n        }\n    }\n    return result;\n}\n\n"}
{"task_id": "CPP/40", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nbool triples_sum_to_zero(vector<int> l) {\n    // Sort the vector\n    sort(l.begin(), l.end());\n    \n    int n = l.size();\n    \n    // Iterate through the vector\n    for (int i = 0; i < n - 2; i++) {\n        // Skip duplicates for the first element\n        if (i > 0 && l[i] == l[i - 1]) continue;\n\n        int left = i + 1;\n        int right = n - 1;\n\n        while (left < right) {\n            int sum = l[i] + l[left] + l[right];\n\n            if (sum == 0) {\n                return true; // Found a triplet\n            } else if (sum < 0) {\n                left++; // Move left pointer to the right to increase the sum\n            } else {\n                right--; // Move right pointer to the left to decrease the sum\n            }\n        }\n    }\n    \n    return false; // No triplet found\n}\n\n// Test cases\n"}
{"task_id": "CPP/13", "generation": "#include <iostream>\nusing namespace std;\n\nint greatest_common_divisor(int a, int b) {\n    // Ensure a and b are non-negative\n    a = abs(a);\n    b = abs(b);\n    \n    // Use the Euclidean algorithm\n    while (b != 0) {\n        int temp = b;\n        b = a % b; // Remainder of a divided by b\n        a = temp;  // Update a to b\n    }\n    return a; // When b is 0, a contains the GCD\n}\n\n"}
{"task_id": "CPP/130", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nvector<int> tri(int n) {\n    vector<int> tribonacci(n + 1);\n    \n    for (int i = 0; i <= n; i++) {\n        if (i == 1) {\n            tribonacci[i] = 3; // base case tri(1) = 3\n        } else if (i % 2 == 0) { // even\n            tribonacci[i] = 1 + i / 2; // tri(n) = 1 + n / 2\n        } else { // odd\n            if (i == 3) {\n                tribonacci[i] = 8; // base case tri(3) = 8\n            } else {\n                // Calculate tri(n) for odd n using the recurrence relation\n                tribonacci[i] = tribonacci[i - 1] + tribonacci[i - 2]; // Corrected line\n            }\n        }\n    }\n    \n    return tribonacci;\n}\n"}
{"task_id": "CPP/60", "generation": "#include <iostream>\nusing namespace std;\n\nint sum_to_n(int n) {\n    return n * (n + 1) / 2; // Using the formula for the sum of the first n natural numbers\n}\n\n"}
{"task_id": "CPP/23", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\n// Function to return the length of the given string\nint strlen(const string& str) {\n    return str.size(); // or str.length();\n}\n\n"}
{"task_id": "CPP/46", "generation": "#include <iostream>\nusing namespace std;\n\nint fib4(int n) {\n    // Handle base cases\n    if (n == 0) return 0;\n    if (n == 1) return 0;\n    if (n == 2) return 2;\n    if (n == 3) return 0;\n\n    // Initialize the first four values of the sequence\n    int a = 0; // fib4(0)\n    int b = 0; // fib4(1)\n    int c = 2; // fib4(2)\n    int d = 0; // fib4(3)\n    int result;\n\n    // Compute fib4(n) iteratively\n    for (int i = 4; i <= n; ++i) {\n        result = a + b + c + d; // fib4(n) = fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\n        // Update the last four values\n        a = b;\n        b = c;\n        c = d;\n        d = result;\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/51", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nstring remove_vowels(string text) {\n    string result;\n    for (char c : text) {\n        // Check if the character is a vowel (both uppercase and lowercase)\n        if (c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u' &&\n            c != 'A' && c != 'E' && c != 'I' && c != 'O' && c != 'U') {\n            result += c; // Append non-vowel characters to result\n        }\n    }\n    return result; // Return the string without vowels\n}\n\n"}
{"task_id": "CPP/18", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint how_many_times(string str, string substring) {\n    if (substring.empty()) {\n        return 0; // If the substring is empty, return 0\n    }\n\n    int count = 0;\n    size_t pos = 0;\n\n    // Loop to find all occurrences of the substring\n    while ((pos = str.find(substring, pos)) != string::npos) {\n        count++; // Increment the count for each found occurrence\n        pos++; // Move to the next character to allow overlapping matches\n    }\n\n    return count;\n}\n\n"}
{"task_id": "CPP/143", "generation": "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to check if a number is prime\nbool isPrime(int num) {\n    if (num <= 1) return false; // 0 and 1 are not prime numbers\n    for (int i = 2; i * i <= num; i++) {\n        if (num % i == 0) return false; // Found a divisor, not prime\n    }\n    return true; // No divisors found, it's prime\n}\n\n// Function to extract words with prime lengths from a sentence\nstring words_in_sentence(string sentence) {\n    stringstream ss(sentence);\n    string word;\n    vector<string> primeWords;\n\n    // Split the sentence into words\n    while (ss >> word) {\n        // Check if the length of the word is prime\n        if (isPrime(word.length())) {\n            primeWords.push_back(word);\n        }\n    }\n\n    // Join the prime length words into a single string\n    string result;\n    for (size_t i = 0; i < primeWords.size(); i++) {\n        result += primeWords[i];\n        if (i < primeWords.size() - 1) {\n            result += \" \"; // Add space between words\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/108", "generation": "#include <vector>\n#include <cmath>\nusing namespace std;\n\nint sum_of_digits(int num) {\n    int sum = 0;\n    bool isNegative = num < 0;\n    num = abs(num);\n    \n    while (num > 0) {\n        int digit = num % 10;\n        sum += (isNegative && num == abs(num)) ? -digit : digit;\n        num /= 10;\n    }\n    \n    return sum;\n}\n\nint count_nums(vector<int> n) {\n    int count = 0;\n    for (int number : n) {\n        if (sum_of_digits(number) > 0) {\n            count++;\n        }\n    }\n    return count;\n}\n"}
{"task_id": "CPP/43", "generation": "#include <iostream>\n#include <vector>\n#include <unordered_set>\nusing namespace std;\n\nbool pairs_sum_to_zero(vector<int> l) {\n    unordered_set<int> seen; // Set to store the numbers we have seen\n\n    for (int num : l) {\n        // Check if the negation of the current number exists in the set\n        if (seen.count(-num)) {\n            return true; // Found a pair that sums to zero\n        }\n        seen.insert(num); // Add the current number to the set\n    }\n\n    return false; // No pairs found that sum to zero\n}\n\n"}
{"task_id": "CPP/70", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> strange_sort_list(vector<int> lst) {\n    // Step 1: Sort the input list\n    sort(lst.begin(), lst.end());\n    \n    vector<int> result;\n    int left = 0; // Pointer for the minimum values\n    int right = lst.size() - 1; // Pointer for the maximum values\n    \n    // Step 2: Alternate between minimum and maximum\n    while (left <= right) {\n        // Add the minimum value\n        if (left <= right) {\n            result.push_back(lst[left]);\n            left++;\n        }\n        // Add the maximum value\n        if (left <= right) {\n            result.push_back(lst[right]);\n            right--;\n        }\n    }\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/63", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint fibfib(int n) {\n    // Handle base cases\n    if (n == 0) return 0;\n    if (n == 1) return 0;\n    if (n == 2) return 1;\n\n    // Create a vector to store the FibFib numbers\n    vector<int> fibfib_sequence(n + 1);\n    \n    // Initialize the base cases\n    fibfib_sequence[0] = 0;\n    fibfib_sequence[1] = 0;\n    fibfib_sequence[2] = 1;\n\n    // Compute the FibFib numbers iteratively\n    for (int i = 3; i <= n; ++i) {\n        fibfib_sequence[i] = fibfib_sequence[i - 1] + fibfib_sequence[i - 2] + fibfib_sequence[i - 3];\n    }\n\n    // Return the n-th FibFib number\n    return fibfib_sequence[n];\n}\n\n"}
{"task_id": "CPP/89", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring encrypt(string s) {\n    string encrypted = \"\";\n    \n    for (char c : s) {\n        if (c >= 'a' && c <= 'z') {\n            // Shift character by 4 positions\n            char newChar = c + 4;\n            // Wrap around if it goes past 'z'\n            if (newChar > 'z') {\n                newChar -= 26; // Wrap around to the start of the alphabet\n            }\n            encrypted += newChar;\n        } else {\n            // If it's not a lowercase letter, we can choose to leave it unchanged\n            encrypted += c; // or handle it differently if needed\n        }\n    }\n    \n    return encrypted;\n}\n\n"}
{"task_id": "CPP/26", "generation": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nvector<int> remove_duplicates(const vector<int>& numbers) {\n    unordered_map<int, int> frequency;\n    \n    // Count the frequency of each number\n    for (int num : numbers) {\n        frequency[num]++;\n    }\n    \n    vector<int> result;\n    \n    // Add elements that occur only once to the result\n    for (int num : numbers) {\n        if (frequency[num] == 1) {\n            result.push_back(num);\n        }\n    }\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/104", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nbool has_even_digit(int num) {\n    while (num > 0) {\n        int digit = num % 10;\n        if (digit % 2 == 0) {\n            return true; // Found an even digit\n        }\n        num /= 10; // Remove the last digit\n    }\n    return false; // No even digits found\n}\n\nvector<int> unique_digits(vector<int> x) {\n    vector<int> result;\n\n    for (int num : x) {\n        if (!has_even_digit(num)) {\n            result.push_back(num); // Add to result if no even digits\n        }\n    }\n\n    sort(result.begin(), result.end()); // Sort the result vector\n    return result;\n}\n\n"}
{"task_id": "CPP/90", "generation": "#include <iostream>\n#include <vector>\n#include <set>\n#include <algorithm>\n\nusing namespace std;\n\nint next_smallest(vector<int> lst) {\n    // Use a set to store unique elements\n    set<int> unique_elements(lst.begin(), lst.end());\n    \n    // If there are fewer than 2 unique elements, return -1 (or any other indicator)\n    if (unique_elements.size() < 2) {\n        return -1; // or you can use a different value to indicate \"None\"\n    }\n    \n    // Convert the set back to a vector to access elements by index\n    vector<int> sorted_unique(unique_elements.begin(), unique_elements.end());\n    \n    // Return the second smallest element\n    return sorted_unique[1];\n}\n\n"}
{"task_id": "CPP/126", "generation": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nbool is_sorted(vector<int> lst) {\n    // Check for duplicates\n    unordered_map<int, int> count_map;\n    for (int num : lst) {\n        count_map[num]++;\n        if (count_map[num] > 2) {\n            return false; // More than two occurrences\n        }\n    }\n\n    // Check if the vector is sorted in ascending order\n    for (size_t i = 1; i < lst.size(); i++) {\n        if (lst[i] < lst[i - 1]) {\n            return false; // Not sorted\n        }\n    }\n\n    return true; // Passed both checks\n}\n\n"}
{"task_id": "CPP/68", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> pluck(vector<int> arr) {\n    int smallest_even_value = -1; // Initialize to -1 to indicate no even number found\n    int smallest_even_index = -1; // Initialize index to -1\n\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] % 2 == 0) { // Check if the number is even\n            if (smallest_even_value == -1 || arr[i] < smallest_even_value) {\n                smallest_even_value = arr[i];\n                smallest_even_index = i;\n            }\n        }\n    }\n\n    // If no even number was found, return an empty vector\n    if (smallest_even_index == -1) {\n        return {};\n    }\n\n    // Return the smallest even value and its index\n    return {smallest_even_value, smallest_even_index};\n}\n\n// Example usage\n"}
{"task_id": "CPP/58", "generation": "#include <iostream>\n#include <vector>\n#include <set>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> common(vector<int> l1, vector<int> l2) {\n    // Use a set to store unique elements from both vectors\n    set<int> set1(l1.begin(), l1.end());\n    set<int> set2(l2.begin(), l2.end());\n    \n    // Vector to store the result\n    vector<int> result;\n    \n    // Find the intersection of the two sets\n    for (const int& element : set1) {\n        if (set2.find(element) != set2.end()) {\n            result.push_back(element);\n        }\n    }\n    \n    // Sort the result (although sets are inherently sorted, this is just to ensure)\n    sort(result.begin(), result.end());\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/112", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <unordered_set>\n\nusing namespace std;\n\nvector<string> reverse_delete(string s, string c) {\n    // Create a set of characters to delete for faster lookup\n    unordered_set<char> chars_to_delete(c.begin(), c.end());\n    \n    // Create a new string to hold the result\n    string result;\n    \n    // Iterate through the original string and build the result\n    for (char ch : s) {\n        if (chars_to_delete.find(ch) == chars_to_delete.end()) {\n            result += ch; // Add character to result if not in chars_to_delete\n        }\n    }\n    \n    // Check if the result is a palindrome\n    string reversed_result = result;\n    reverse(reversed_result.begin(), reversed_result.end());\n    bool is_palindrome = (result == reversed_result);\n    \n    // Prepare the output\n    vector<string> output;\n    output.push_back(result);\n    output.push_back(is_palindrome ? \"True\" : \"False\");\n    \n    return output;\n}\n\n"}
{"task_id": "CPP/96", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Helper function to check if a number is prime\nbool is_prime(int num) {\n    if (num <= 1) return false; // 0 and 1 are not prime numbers\n    for (int i = 2; i * i <= num; i++) {\n        if (num % i == 0) return false; // Found a divisor, not prime\n    }\n    return true; // No divisors found, it's prime\n}\n\n// Function to count prime numbers less than n\nvector<int> count_up_to(int n) {\n    vector<int> primes;\n    for (int i = 2; i < n; i++) { // Start from 2, as it's the first prime\n        if (is_prime(i)) {\n            primes.push_back(i); // Add prime number to the vector\n        }\n    }\n    return primes; // Return the vector of primes\n}\n\n// Example usage\n"}
{"task_id": "CPP/157", "generation": "#include <stdio.h>\n#include <math.h>\n\nbool right_angle_triangle(float a, float b, float c) {\n    // Sort the sides to identify the longest side\n    float x = fmax(a, fmax(b, c)); // longest side\n    float y, z;\n\n    if (x == a) {\n        y = b;\n        z = c;\n    } else if (x == b) {\n        y = a;\n        z = c;\n    } else {\n        y = a;\n        z = b;\n    }\n\n    // Check the Pythagorean theorem\n    return (y * y + z * z) == (x * x);\n}\n\n"}
{"task_id": "CPP/99", "generation": "#include <iostream>\n#include <string>\n#include <cmath>\n\nusing namespace std;\n\nint closest_integer(string value) {\n    // Convert the string to a double\n    double num = stod(value);\n    \n    // Use floor and ceil to determine the two closest integers\n    int lower = static_cast<int>(floor(num));\n    int upper = static_cast<int>(ceil(num));\n    \n    // Check if the number is equidistant from lower and upper\n    if (fabs(num - lower) == 0.5) {\n        // If equidistant, round away from zero\n        if (num > 0) {\n            return upper; // Round up\n        } else {\n            return lower; // Round down (away from zero)\n        }\n    } else {\n        // Otherwise, return the nearest integer\n        return static_cast<int>(round(num));\n    }\n}\n\n"}
{"task_id": "CPP/149", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nvector<string> sorted_list_sum(vector<string> lst) {\n    // Filter out strings with odd lengths\n    vector<string> filtered_lst;\n    for (const string& s : lst) {\n        if (s.length() % 2 == 0) {\n            filtered_lst.push_back(s);\n        }\n    }\n    \n    // Sort the remaining strings first by length, then alphabetically\n    sort(filtered_lst.begin(), filtered_lst.end(), [](const string& a, const string& b) {\n        if (a.length() == b.length()) {\n            return a < b; // Sort alphabetically if lengths are the same\n        }\n        return a.length() < b.length(); // Sort by length\n    });\n    \n    return filtered_lst;\n}\n"}
{"task_id": "CPP/86", "generation": "#include <stdio.h>\n#include <string>\n#include <algorithm>\n#include <sstream>\nusing namespace std;\n\nstring anti_shuffle(string s) {\n    stringstream ss(s);\n    string word;\n    string result = \"\";\n\n    while (ss >> word) {\n        // Sort the characters in the word\n        sort(word.begin(), word.end());\n        result += word + \" \"; // Append the sorted word and a space\n    }\n\n    // Remove the trailing space if there is one\n    if (!result.empty()) {\n        result.pop_back();\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/129", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvoid dfs(const vector<vector<int>>& grid, int x, int y, int k, vector<int>& currentPath, vector<int>& minPath) {\n    // If the current path length is k, check if it's the minimum path\n    if (currentPath.size() == k) {\n        if (minPath.empty() || currentPath < minPath) {\n            minPath = currentPath; // Update the minimum path\n        }\n        return;\n    }\n\n    // Directions for moving up, down, left, right\n    vector<pair<int, int>> directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n    \n    // Explore all 4 possible directions\n    for (const auto& dir : directions) {\n        int newX = x + dir.first;\n        int newY = y + dir.second;\n\n        // Check if the new position is within bounds\n        if (newX >= 0 && newX < grid.size() && newY >= 0 && newY < grid[0].size()) {\n            currentPath.push_back(grid[newX][newY]); // Add the new cell to the path\n            dfs(grid, newX, newY, k, currentPath, minPath); // Recur for the new cell\n            currentPath.pop_back(); // Backtrack\n        }\n    }\n}\n\nvector<int> minPath(vector<vector<int>> grid, int k) {\n    vector<int> minPath; // To store the minimum path\n    int n = grid.size();\n\n    // Start DFS from each cell in the grid\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            vector<int> currentPath = {grid[i][j]}; // Start path with the current cell\n            dfs(grid, i, j, k, currentPath, minPath); // Perform DFS\n        }\n    }\n\n    return minPath; // Return the minimum path found\n}\n\n// Example usage\n"}
{"task_id": "CPP/49", "generation": "#include <iostream>\nusing namespace std;\n\nint modp(int n, int p) {\n    // Handle the case when n is 0\n    if (n == 0) {\n        return 1; // 2^0 is 1\n    }\n\n    long long result = 1; // Use long long to prevent overflow\n    long long base = 2;   // Base is 2\n    n = n % (p - 1);      // Fermat's Little Theorem optimization\n\n    while (n > 0) {\n        // If n is odd, multiply the base with result\n        if (n % 2 == 1) {\n            result = (result * base) % p;\n        }\n        // Square the base\n        base = (base * base) % p;\n        // Divide n by 2\n        n /= 2;\n    }\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/156", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nstring int_to_mini_roman(int number) {\n    // Define the Roman numeral symbols and their corresponding values\n    vector<pair<int, string>> roman_numerals = {\n        {1000, \"m\"},\n        {900, \"cm\"},\n        {500, \"d\"},\n        {400, \"cd\"},\n        {100, \"c\"},\n        {90, \"xc\"},\n        {50, \"l\"},\n        {40, \"xl\"},\n        {10, \"x\"},\n        {9, \"ix\"},\n        {5, \"v\"},\n        {4, \"iv\"},\n        {1, \"i\"}\n    };\n\n    string result = \"\";\n    \n    // Iterate through the roman_numerals vector\n    for (const auto& pair : roman_numerals) {\n        while (number >= pair.first) {\n            result += pair.second; // Append the Roman numeral\n            number -= pair.first;  // Decrease the number\n        }\n    }\n    \n    return result; // Return the final Roman numeral string\n}\n\n"}
{"task_id": "CPP/65", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nstring circular_shift(int x, int shift) {\n    // Convert the integer to a string to manipulate the digits\n    string x_str = to_string(x);\n    int n = x_str.length();\n\n    // If shift is greater than the number of digits, reverse the string\n    if (shift > n) {\n        reverse(x_str.begin(), x_str.end());\n        return x_str;\n    }\n\n    // Calculate the effective shift (in case shift is equal to or less than n)\n    int effective_shift = shift % n;\n\n    // Perform the circular shift\n    string shifted_str = x_str.substr(n - effective_shift) + x_str.substr(0, n - effective_shift);\n\n    return shifted_str;\n}\n"}
{"task_id": "CPP/9", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> rolling_max(const vector<int>& numbers) {\n    vector<int> result;\n    int current_max = INT_MIN; // Initialize to the smallest possible integer\n\n    for (int num : numbers) {\n        if (num > current_max) {\n            current_max = num; // Update current_max if num is greater\n        }\n        result.push_back(current_max); // Add the current_max to the result\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/158", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_set>\n#include <algorithm>\n\nusing namespace std;\n\nstring find_max(vector<string> words) {\n    string max_word;\n    int max_unique_count = 0;\n\n    for (const string& word : words) {\n        // Use a set to find unique characters\n        unordered_set<char> unique_chars(word.begin(), word.end());\n        int unique_count = unique_chars.size();\n\n        // Check if this word has more unique characters or is lexicographically smaller\n        if (unique_count > max_unique_count || \n            (unique_count == max_unique_count && (max_word.empty() || word < max_word))) {\n            max_word = word;\n            max_unique_count = unique_count;\n        }\n    }\n\n    return max_word;\n}\n\n"}
{"task_id": "CPP/8", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> sum_product(vector<int> numbers) {\n    int sum = 0;\n    int product = 1;\n\n    // Check if the vector is empty\n    if (numbers.empty()) {\n        return {sum, product}; // Return (0, 1)\n    }\n\n    // Calculate sum and product\n    for (int num : numbers) {\n        sum += num;\n        product *= num;\n    }\n\n    return {sum, product};\n}\n\n"}
{"task_id": "CPP/95", "generation": "#include <iostream>\n#include <string>\n#include <map>\n#include <cctype> // For islower and isupper\n\nusing namespace std;\n\nbool check_dict_case(map<string, string> dict) {\n    // Check if the map is empty\n    if (dict.empty()) {\n        return false;\n    }\n\n    bool allLower = true;\n    bool allUpper = true;\n\n    // Iterate through the keys in the map\n    for (const auto& pair : dict) {\n        const string& key = pair.first;\n\n        // Check if the key is a string (it is, since the map uses string as key type)\n        // Check if the key is lower case or upper case\n        if (!key.empty()) {\n            if (islower(key[0])) {\n                allUpper = false; // If we find a lower case letter, set allUpper to false\n            } else if (isupper(key[0])) {\n                allLower = false; // If we find an upper case letter, set allLower to false\n            } else {\n                return false; // If the key is not a letter, return false\n            }\n\n            // Check the rest of the characters in the key\n            for (size_t i = 1; i < key.size(); ++i) {\n                if (islower(key[i])) {\n                    allUpper = false;\n                } else if (isupper(key[i])) {\n                    allLower = false;\n                } else {\n                    return false; // If any character is not a letter, return false\n                }\n            }\n        }\n    }\n\n    // Return true if all keys are either all lower case or all upper case\n    return allLower || allUpper;\n}\n\n"}
{"task_id": "CPP/55", "generation": "#include <stdio.h>\n\nint fib(int n) {\n    if (n <= 0) return 0; // Handle the case for n = 0\n    if (n == 1) return 1; // Base case for n = 1\n\n    int a = 0, b = 1, c;\n    for (int i = 2; i <= n; i++) {\n        c = a + b; // Calculate the next Fibonacci number\n        a = b;     // Move to the next pair\n        b = c;\n    }\n    return b; // b will be the n-th Fibonacci number\n}\n\n"}
{"task_id": "CPP/29", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<string> filter_by_prefix(const vector<string>& strings, const string& prefix) {\n    vector<string> filtered; // Vector to hold the filtered results\n\n    // Iterate through each string in the input vector\n    for (const string& str : strings) {\n        // Check if the string starts with the given prefix\n        if (str.find(prefix) == 0) { // find returns 0 if the prefix is found at the start\n            filtered.push_back(str); // Add to the filtered results\n        }\n    }\n\n    return filtered; // Return the filtered vector\n}\n\n"}
{"task_id": "CPP/72", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool is_palindrome(const vector<int>& q) {\n    int n = q.size();\n    for (int i = 0; i < n / 2; ++i) {\n        if (q[i] != q[n - 1 - i]) {\n            return false; // Not a palindrome\n        }\n    }\n    return true; // Is a palindrome\n}\n\nbool will_it_fly(vector<int> q, int w) {\n    // Check if the vector is a palindrome\n    if (!is_palindrome(q)) {\n        return false; // Not balanced\n    }\n    \n    // Calculate the sum of the elements in the vector\n    int sum = 0;\n    for (int num : q) {\n        sum += num;\n    }\n    \n    // Check if the sum is less than or equal to the maximum weight\n    return sum <= w;\n}\n\n"}
{"task_id": "CPP/54", "generation": "#include <iostream>\n#include <string>\n#include <unordered_set>\nusing namespace std;\n\nbool same_chars(string s0, string s1) {\n    unordered_set<char> set0(s0.begin(), s0.end());\n    unordered_set<char> set1(s1.begin(), s1.end());\n    \n    return set0 == set1; // Compare the two sets\n}\n\n"}
{"task_id": "CPP/91", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <vector>\n#include <cctype>\n\nusing namespace std;\n\nint is_bored(string S) {\n    int count = 0;\n    // Define the delimiters\n    char delimiters[] = {'.', '?', '!'};\n    \n    // Create a string stream from the input string\n    stringstream ss(S);\n    string sentence;\n    \n    // Read sentences until we reach the end of the string\n    while (getline(ss, sentence, '.')) {\n        // Check for other delimiters in the same sentence\n        size_t pos = sentence.find_first_of(\"?!\");\n        if (pos != string::npos) {\n            sentence = sentence.substr(0, pos);\n        }\n        \n        // Trim leading whitespace\n        size_t start = sentence.find_first_not_of(\" \\t\\n\");\n        if (start != string::npos) {\n            sentence = sentence.substr(start);\n        }\n        \n        // Check if the sentence starts with \"I\"\n        if (sentence.rfind(\"I \", 0) == 0 || sentence == \"I\") {\n            count++;\n        }\n    }\n    \n    return count;\n}\n\n"}
{"task_id": "CPP/77", "generation": "#include <cmath>\nusing namespace std;\n\nbool iscube(int a) {\n    if (a < 0) {\n        a = -a;  // Take the absolute value for negative numbers\n    }\n    int cube_root = round(pow(a, 1.0 / 3.0));  // Calculate the cube root and round it\n    return cube_root * cube_root * cube_root == a;  // Check if the cube of the rounded root equals the original number\n}\n"}
{"task_id": "CPP/73", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint smallest_change(vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n\n    // Compare elements from the start and end moving towards the center\n    for (int i = 0; i < n / 2; i++) {\n        if (arr[i] != arr[n - 1 - i]) {\n            changes++; // Increment changes for each mismatch\n        }\n    }\n\n    return changes; // Return the total number of changes needed\n}\n\n"}
{"task_id": "CPP/71", "generation": "#include <stdio.h>\n#include <math.h>\n\nfloat triangle_area(float a, float b, float c) {\n    // Check if the sides form a valid triangle\n    if (a + b > c && a + c > b && b + c > a) {\n        // Calculate the semi-perimeter\n        float s = (a + b + c) / 2;\n\n        // Calculate the area using Heron's formula\n        float area = sqrt(s * (s - a) * (s - b) * (s - c));\n\n        // Return the area rounded to 2 decimal points\n        return round(area * 100) / 100;\n    } else {\n        // Return -1 if the sides do not form a valid triangle\n        return -1;\n    }\n}\n\n"}
{"task_id": "CPP/82", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int num) {\n    if (num <= 1) return false; // 0 and 1 are not prime numbers\n    for (int i = 2; i * i <= num; i++) {\n        if (num % i == 0) return false; // Found a divisor, not prime\n    }\n    return true; // No divisors found, it's prime\n}\n\n// Function to check if the length of the string is prime\nbool prime_length(string str) {\n    int length = str.length(); // Get the length of the string\n    return is_prime(length); // Check if the length is prime\n}\n\n// Example usage\n"}
{"task_id": "CPP/114", "generation": "#include <iostream>\n#include <vector>\n#include <limits.h> // For INT_MAX\n\nusing namespace std;\n\nlong long minSubArraySum(vector<long long> nums) {\n    long long min_sum = LLONG_MAX; // Initialize to maximum possible value\n    long long current_sum = 0; // To keep track of the current subarray sum\n\n    for (size_t i = 0; i < nums.size(); ++i) {\n        current_sum += nums[i]; // Add current element to current sum\n        min_sum = min(min_sum, current_sum); // Update min_sum if current_sum is smaller\n\n        // If current_sum becomes positive, reset it to 0\n        if (current_sum > 0) {\n            current_sum = 0;\n        }\n    }\n\n    return min_sum; // Return the minimum subarray sum found\n}\n\n"}
{"task_id": "CPP/138", "generation": "#include <iostream>\nusing namespace std;\n\nbool is_equal_to_sum_even(int n) {\n    // Check if n is less than 8 or if n is odd\n    if (n < 8 || n % 2 != 0) {\n        return false;\n    }\n    // If n is even and at least 8, it can be expressed as the sum of 4 positive even numbers\n    return true;\n}\n\n"}
{"task_id": "CPP/132", "generation": "#include <stdio.h>\n#include <string>\n#include <vector>\nusing namespace std;\n\nbool is_nested(string str) {\n    vector<char> stack;\n    bool nested = false;\n\n    for (char& ch : str) {\n        if (ch == '[') {\n            stack.push_back(ch);\n            if (stack.size() > 1) {  // More than one opening bracket means nested\n                nested = true;\n            }\n        } else if (ch == ']') {\n            if (!stack.empty()) {\n                stack.pop_back();\n            } else {\n                return false;  // Unmatched closing bracket\n            }\n        }\n    }\n\n    return nested && stack.empty();  // Must be nested and all brackets must be matched\n}\n"}
{"task_id": "CPP/3", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool below_zero(vector<int> operations) {\n    int balance = 0; // Start with a balance of zero\n\n    // Iterate through each operation in the vector\n    for (int operation : operations) {\n        balance += operation; // Update the balance with the current operation\n\n        // Check if the balance falls below zero\n        if (balance < 0) {\n            return true; // Return true if balance is below zero\n        }\n    }\n\n    return false; // Return false if balance never goes below zero\n}\n\n"}
{"task_id": "CPP/142", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint sum_squares(vector<int> lst) {\n    int total_sum = 0; // Initialize the sum to 0\n\n    for (size_t i = 0; i < lst.size(); ++i) {\n        if (i % 3 == 0) {\n            // If index is a multiple of 3, square the entry\n            total_sum += lst[i] * lst[i];\n        } else if (i % 4 == 0) {\n            // If index is a multiple of 4 and not a multiple of 3, cube the entry\n            total_sum += lst[i] * lst[i] * lst[i];\n        } else {\n            // Otherwise, just add the entry as is\n            total_sum += lst[i];\n        }\n    }\n\n    return total_sum; // Return the total sum\n}\n\n"}
{"task_id": "CPP/50", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring encode_shift(string s) {\n    // Returns encoded string by shifting every character by 5 in the alphabet.\n    string out;\n    for (char c : s) {\n        if (isalpha(c)) { // Check if the character is an alphabet\n            char base = islower(c) ? 'a' : 'A'; // Determine the base for lowercase or uppercase\n            char shifted = (c - base + 5) % 26 + base; // Shift and wrap around\n            out += shifted; // Append the shifted character to output\n        } else {\n            out += c; // Non-alphabet characters are added unchanged\n        }\n    }\n    return out;\n}\n\nstring decode_shift(string s) {\n    // Takes as input string encoded with encode_shift function. Returns decoded string.\n    string out;\n    for (char c : s) {\n        if (isalpha(c)) { // Check if the character is an alphabet\n            char base = islower(c) ? 'a' : 'A'; // Determine the base for lowercase or uppercase\n            char shifted = (c - base - 5 + 26) % 26 + base; // Shift back and wrap around\n            out += shifted; // Append the shifted character to output\n        } else {\n            out += c; // Non-alphabet characters are added unchanged\n        }\n    }\n    return out;\n}\n\n"}
{"task_id": "CPP/103", "generation": "#include <iostream>\n#include <cmath>\n#include <string>\nusing namespace std;\n\nstring rounded_avg(int n, int m) {\n    // Check if n is greater than m\n    if (n > m) {\n        return \"-1\";\n    }\n    \n    // Calculate the sum of integers from n to m\n    int count = m - n + 1; // Number of integers from n to m\n    int sum = (count * (n + m)) / 2; // Sum of integers from n to m\n    \n    // Calculate the average\n    double average = static_cast<double>(sum) / count;\n    \n    // Round down to the nearest integer\n    int rounded_average = static_cast<int>(floor(average));\n    \n    // Convert the rounded average to binary\n    string binary = \"\";\n    if (rounded_average == 0) {\n        binary = \"0\";\n    } else {\n        while (rounded_average > 0) {\n            binary = to_string(rounded_average % 2) + binary;\n            rounded_average /= 2;\n        }\n    }\n    \n    return binary;\n}\n\n// Example usage\n"}
{"task_id": "CPP/57", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nbool monotonic(vector<float> l) {\n    if (l.size() < 2) {\n        return true; // A vector with less than 2 elements is considered monotonic\n    }\n\n    bool increasing = true;\n    bool decreasing = true;\n\n    for (size_t i = 1; i < l.size(); ++i) {\n        if (l[i] > l[i - 1]) {\n            decreasing = false; // Found an increasing pair\n        } else if (l[i] < l[i - 1]) {\n            increasing = false; // Found a decreasing pair\n        }\n    }\n\n    return increasing || decreasing; // Return true if either increasing or decreasing\n}\n\n"}
{"task_id": "CPP/28", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring concatenate(vector<string> strings) {\n    string result; // Initialize an empty string to hold the concatenated result\n    for (const string& str : strings) { // Iterate through each string in the vector\n        result += str; // Append the current string to the result\n    }\n    return result; // Return the concatenated string\n}\n\n"}
{"task_id": "CPP/39", "generation": "#include <iostream>\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int num) {\n    if (num <= 1) return false; // 0 and 1 are not prime numbers\n    for (int i = 2; i * i <= num; i++) {\n        if (num % i == 0) return false; // Found a divisor, not prime\n    }\n    return true; // No divisors found, it's prime\n}\n\n// Function to return the n-th Fibonacci number that is also prime\nint prime_fib(int n) {\n    int a = 0, b = 1; // Starting values for Fibonacci sequence\n    int count = 0; // Count of prime Fibonacci numbers found\n    int prime_fib_num = 0; // The n-th prime Fibonacci number\n\n    while (count < n) {\n        int next_fib = a + b; // Generate next Fibonacci number\n        a = b; // Move to the next Fibonacci number\n        b = next_fib;\n\n        // Check if the Fibonacci number is prime\n        if (is_prime(next_fib)) {\n            count++; // Increment count of prime Fibonacci numbers\n            prime_fib_num = next_fib; // Update the last found prime Fibonacci number\n        }\n    }\n    \n    return prime_fib_num; // Return the n-th prime Fibonacci number\n}\n\n// Example usage\n"}
{"task_id": "CPP/45", "generation": "#include <stdio.h>\n#include <math.h>\n\nfloat triangle_area(float a, float h) {\n    return 0.5 * a * h; // Calculate the area using the formula\n}\n\n"}
{"task_id": "CPP/145", "generation": "#include <vector>\n#include <string>\n#include <algorithm>\n#include <numeric>\n\nusing namespace std;\n\nint digit_sum(int n) {\n    // Calculate the sum of digits, ignoring the negative sign\n    n = abs(n);\n    int sum = 0;\n    while (n > 0) {\n        sum += n % 10;\n        n /= 10;\n    }\n    return sum;\n}\n\nvector<int> order_by_points(vector<int> nums) {\n    // Create a vector of indices\n    vector<int> indices(nums.size());\n    iota(indices.begin(), indices.end(), 0); // Fill indices with 0, 1, ..., n-1\n\n    // Sort indices based on the digit sum and original index\n    sort(indices.begin(), indices.end(), [&nums](int a, int b) {\n        int sum_a = digit_sum(nums[a]);\n        int sum_b = digit_sum(nums[b]);\n        if (sum_a == sum_b) {\n            return a < b; // Maintain original order if sums are equal\n        }\n        return sum_a < sum_b; // Sort by digit sum\n    });\n\n    // Create the sorted result based on the sorted indices\n    vector<int> result;\n    for (int index : indices) {\n        result.push_back(nums[index]);\n    }\n    return result;\n}\n"}
{"task_id": "CPP/84", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring solve(int N) {\n    // Step 1: Calculate the sum of the digits\n    int sum = 0;\n    while (N > 0) {\n        sum += N % 10; // Add the last digit to sum\n        N /= 10;       // Remove the last digit\n    }\n\n    // Step 2: Convert the sum to binary\n    string binary = \"\";\n    if (sum == 0) {\n        binary = \"0\"; // Handle the case where sum is 0\n    } else {\n        while (sum > 0) {\n            binary = to_string(sum % 2) + binary; // Prepend the binary digit\n            sum /= 2; // Divide sum by 2\n        }\n    }\n\n    // Step 3: Return the binary representation\n    return binary;\n}\n\n"}
{"task_id": "CPP/113", "generation": "#include <vector>\n#include <string>\n#include <sstream>\nusing namespace std;\n\nvector<string> odd_count(vector<string> lst) {\n    vector<string> result;\n    for (const string& s : lst) {\n        int odd_count = 0;\n        for (char c : s) {\n            if ((c - '0') % 2 != 0) { // Check if the digit is odd\n                odd_count++;\n            }\n        }\n        // Create the formatted string\n        stringstream ss;\n        ss << \"the number of odd elements \" << odd_count \n           << \"n the str\" << odd_count \n           << \"ng \" << odd_count \n           << \" of the \" << odd_count << \"nput.\";\n        result.push_back(ss.str());\n    }\n    return result;\n}\n"}
{"task_id": "CPP/36", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint count_sevens(int number) {\n    int count = 0;\n    while (number > 0) {\n        if (number % 10 == 7) {\n            count++;\n        }\n        number /= 10;\n    }\n    return count;\n}\n\nint fizz_buzz(int n) {\n    int total_count = 0;\n    \n    for (int i = 1; i < n; i++) {\n        if (i % 11 == 0 || i % 13 == 0) {\n            total_count += count_sevens(i);\n        }\n    }\n    \n    return total_count;\n}\n\n"}
{"task_id": "CPP/144", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nbool simplify(string x, string n) {\n    // Parse the first fraction x\n    size_t pos = x.find('/');\n    int numerator_x = stoi(x.substr(0, pos));\n    int denominator_x = stoi(x.substr(pos + 1));\n\n    // Parse the second fraction n\n    pos = n.find('/');\n    int numerator_n = stoi(n.substr(0, pos));\n    int denominator_n = stoi(n.substr(pos + 1));\n\n    // Calculate the product of the fractions\n    int product_numerator = numerator_x * numerator_n;\n    int product_denominator = denominator_x * denominator_n;\n\n    // Check if the product is a whole number\n    return product_numerator % product_denominator == 0;\n}\n\n"}
{"task_id": "CPP/0", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // for std::sort\n#include <cmath>     // for std::abs\n\nusing namespace std;\n\nbool has_close_elements(vector<float> numbers, float threshold) {\n    // Sort the vector\n    sort(numbers.begin(), numbers.end());\n\n    // Check consecutive elements for closeness\n    for (size_t i = 1; i < numbers.size(); ++i) {\n        if (fabs(numbers[i] - numbers[i - 1]) < threshold) {\n            return true; // Found two elements that are too close\n        }\n    }\n\n    return false; // No close elements found\n}\n\n"}
{"task_id": "CPP/17", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nvector<int> parse_music(string music_string) {\n    vector<int> durations;\n    stringstream ss(music_string);\n    string note;\n\n    // Read each note from the string stream\n    while (ss >> note) {\n        if (note == \"o\") {\n            durations.push_back(4); // Whole note\n        } else if (note == \"o|\") {\n            durations.push_back(2); // Half note\n        } else if (note == \".|\") {\n            durations.push_back(1); // Quarter note\n        }\n    }\n\n    return durations;\n}\n\n"}
{"task_id": "CPP/47", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nfloat median(vector<float> l) {\n    // Step 1: Sort the vector\n    sort(l.begin(), l.end());\n    \n    // Step 2: Calculate the median\n    size_t size = l.size();\n    if (size % 2 == 1) {\n        // If odd, return the middle element\n        return l[size / 2];\n    } else {\n        // If even, return the average of the two middle elements\n        return (l[size / 2 - 1] + l[size / 2]) / 2.0;\n    }\n}\n\n"}
{"task_id": "CPP/75", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    for (int i = 2; i * i <= num; i++) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\n// Function to generate a list of prime numbers less than 100\nvector<int> generate_primes() {\n    vector<int> primes;\n    for (int i = 2; i < 100; i++) {\n        if (is_prime(i)) {\n            primes.push_back(i);\n        }\n    }\n    return primes;\n}\n\n// Function to check if a number is the product of three prime numbers\nbool is_multiply_prime(int a) {\n    vector<int> primes = generate_primes();\n    int size = primes.size();\n\n    // Check all combinations of three primes\n    for (int i = 0; i < size; i++) {\n        for (int j = i; j < size; j++) {\n            for (int k = j; k < size; k++) {\n                int product = primes[i] * primes[j] * primes[k];\n                if (product == a) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n\n"}
{"task_id": "CPP/124", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nbool valid_date(string date) {\n    // Check if the date string is empty\n    if (date.empty()) {\n        return false;\n    }\n\n    // Check if the format is correct (mm-dd-yyyy)\n    if (date.size() != 10 || date[2] != '-' || date[5] != '-') {\n        return false;\n    }\n\n    // Extract month, day, and year\n    int month, day, year;\n    stringstream ss(date);\n    string monthStr, dayStr, yearStr;\n\n    getline(ss, monthStr, '-');\n    getline(ss, dayStr, '-');\n    getline(ss, yearStr);\n\n    // Convert strings to integers\n    month = stoi(monthStr);\n    day = stoi(dayStr);\n    year = stoi(yearStr);\n\n    // Check if month is valid\n    if (month < 1 || month > 12) {\n        return false;\n    }\n\n    // Check if day is valid based on the month\n    if (month == 2) { // February\n        if (day < 1 || day > 29) {\n            return false;\n        }\n    } else if (month == 4 || month == 6 || month == 9 || month == 11) { // April, June, September, November\n        if (day < 1 || day > 30) {\n            return false;\n        }\n    } else { // January, March, May, July, August, October, December\n        if (day < 1 || day > 31) {\n            return false;\n        }\n    }\n\n    // If all checks passed, the date is valid\n    return true;\n}\n\n"}
{"task_id": "CPP/101", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <cctype>\n\nusing namespace std;\n\nvector<string> words_string(string s) {\n    vector<string> words;\n    string word;\n    // Replace commas with spaces to simplify splitting\n    for (char &c : s) {\n        if (c == ',') {\n            c = ' ';\n        }\n    }\n    \n    // Use istringstream to split the string by spaces\n    istringstream stream(s);\n    while (stream >> word) {\n        words.push_back(word);\n    }\n    \n    return words;\n}\n\n"}
{"task_id": "CPP/14", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<string> all_prefixes(string str) {\n    vector<string> prefixes; // Vector to store prefixes\n    for (size_t i = 1; i <= str.length(); ++i) {\n        prefixes.push_back(str.substr(0, i)); // Add prefix from start to current index\n    }\n    return prefixes; // Return the vector of prefixes\n}\n\n"}
{"task_id": "CPP/141", "generation": "#include <iostream>\n#include <string>\n#include <cctype>\n\nusing namespace std;\n\nstring file_name_check(string file_name) {\n    // Check for exactly one dot\n    size_t dot_pos = file_name.find('.');\n    if (dot_pos == string::npos || file_name.find('.', dot_pos + 1) != string::npos) {\n        return \"No\";\n    }\n\n    // Split the file name into name and extension\n    string name_part = file_name.substr(0, dot_pos);\n    string ext_part = file_name.substr(dot_pos + 1);\n\n    // Check if the name part is empty\n    if (name_part.empty() || !isalpha(name_part[0])) {\n        return \"No\";\n    }\n\n    // Check for valid extension\n    if (ext_part != \"txt\" && ext_part != \"exe\" && ext_part != \"dll\") {\n        return \"No\";\n    }\n\n    // Count digits in the name part\n    int digit_count = 0;\n    for (char c : name_part) {\n        if (isdigit(c)) {\n            digit_count++;\n        }\n    }\n\n    // Check for the digit count\n    if (digit_count > 3) {\n        return \"No\";\n    }\n\n    // If all checks passed, return \"Yes\"\n    return \"Yes\";\n}\n\n"}
{"task_id": "CPP/123", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> get_odd_collatz(int n) {\n    vector<int> odd_numbers; // Vector to store odd numbers\n    while (n != 1) {\n        if (n % 2 != 0) { // Check if n is odd\n            odd_numbers.push_back(n); // Add to the vector\n        }\n        // Apply the Collatz rules\n        if (n % 2 == 0) {\n            n /= 2; // If even, divide by 2\n        } else {\n            n = 3 * n + 1; // If odd, calculate 3n + 1\n        }\n    }\n    // Add 1 to the list since the sequence ends with 1\n    odd_numbers.push_back(1);\n    \n    // Sort the vector of odd numbers\n    sort(odd_numbers.begin(), odd_numbers.end());\n    \n    return odd_numbers; // Return the sorted vector\n}\n\n// Example usage\n"}
{"task_id": "CPP/148", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nvector<string> bf(string planet1, string planet2) {\n    // Define the order of planets\n    vector<string> planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n    \n    // Find the indices of the input planets\n    auto it1 = find(planets.begin(), planets.end(), planet1);\n    auto it2 = find(planets.begin(), planets.end(), planet2);\n    \n    // Check if both planets are valid\n    if (it1 == planets.end() || it2 == planets.end()) {\n        return {}; // Return empty vector if either planet is invalid\n    }\n    \n    // Get the indices of the planets\n    int index1 = distance(planets.begin(), it1);\n    int index2 = distance(planets.begin(), it2);\n    \n    // Ensure index1 is less than index2\n    if (index1 > index2) {\n        swap(index1, index2);\n    }\n    \n    // Collect planets between index1 and index2\n    vector<string> result;\n    for (int i = index1 + 1; i < index2; ++i) {\n        result.push_back(planets[i]);\n    }\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/133", "generation": "#include <iostream>\n#include <cmath>\n#include <vector>\n\nusing namespace std;\n\nint sum_squares(vector<float> lst) {\n    int sum = 0;\n    for (float num : lst) {\n        int rounded = ceil(num); // Round up to the nearest integer\n        sum += rounded * rounded; // Square the rounded value and add to sum\n    }\n    return sum;\n}\n\n"}
{"task_id": "CPP/109", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool move_one_ball(vector<int> arr) {\n    // If the array is empty, return true\n    if (arr.empty()) return true;\n\n    int count = 0; // To count the number of times the order breaks\n    int n = arr.size();\n\n    // Loop through the array to find the number of breaks in order\n    for (int i = 0; i < n; i++) {\n        // If the current element is greater than the next element\n        if (arr[i] > arr[(i + 1) % n]) {\n            count++;\n        }\n    }\n\n    // If there is more than one break, it's not possible to sort by right shifts\n    return count <= 1;\n}\n\n// Example usage\n"}
{"task_id": "CPP/100", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> make_a_pile(int n) {\n    vector<int> stones;\n    int current_stones = n; // Start with n stones for the first level\n\n    for (int i = 0; i < n; ++i) {\n        stones.push_back(current_stones); // Add the current level's stones to the vector\n        // Determine the next number of stones based on whether n is odd or even\n        if (n % 2 == 0) {\n            current_stones += 2; // If n is even, add 2 for the next even number\n        } else {\n            current_stones += 2; // If n is odd, add 2 for the next odd number\n        }\n    }\n\n    return stones;\n}\n\n"}
{"task_id": "CPP/150", "generation": "#include <iostream>\nusing namespace std;\n\n// Function to check if a number is prime\nbool isPrime(int n) {\n    if (n <= 1) return false; // 0 and 1 are not prime numbers\n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0) return false; // n is divisible by i, so it's not prime\n    }\n    return true; // n is prime\n}\n\n// Function to return x if n is prime, otherwise return y\nint x_or_y(int n, int x, int y) {\n    if (isPrime(n)) {\n        return x; // Return x if n is prime\n    } else {\n        return y; // Return y if n is not prime\n    }\n}\n\n// Main function to test the x_or_y function\n"}
{"task_id": "CPP/153", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring Strongest_Extension(string class_name, vector<string> extensions) {\n    int max_strength = INT_MIN; // Initialize to the smallest integer\n    string strongest_extension = \"\";\n\n    for (const string& extension : extensions) {\n        int CAP = 0, SM = 0;\n\n        // Calculate CAP and SM\n        for (char c : extension) {\n            if (isupper(c)) {\n                CAP++;\n            } else if (islower(c)) {\n                SM++;\n            }\n        }\n\n        // Calculate strength\n        int strength = CAP - SM;\n\n        // Check if this extension is stronger\n        if (strength > max_strength) {\n            max_strength = strength;\n            strongest_extension = extension;\n        }\n    }\n\n    // Return the result in the required format\n    return class_name + \".\" + strongest_extension;\n}\n\n"}
{"task_id": "CPP/107", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to check if a number is a palindrome\nbool isPalindrome(int num) {\n    string str = to_string(num);\n    string revStr = string(str.rbegin(), str.rend());\n    return str == revStr;\n}\n\nvector<int> even_odd_palindrome(int n) {\n    int evenCount = 0;\n    int oddCount = 0;\n\n    for (int i = 1; i <= n; i++) {\n        if (isPalindrome(i)) {\n            if (i % 2 == 0) {\n                evenCount++;\n            } else {\n                oddCount++;\n            }\n        }\n    }\n\n    return {evenCount, oddCount};\n}\n\n"}
{"task_id": "CPP/110", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring exchange(vector<int> lst1, vector<int> lst2) {\n    int oddCount = 0;\n    int evenCountInLst2 = 0;\n\n    // Count odd numbers in lst1\n    for (int num : lst1) {\n        if (num % 2 != 0) {\n            oddCount++;\n        }\n    }\n\n    // Count even numbers in lst2\n    for (int num : lst2) {\n        if (num % 2 == 0) {\n            evenCountInLst2++;\n        }\n    }\n\n    // Check if we can replace all odd numbers in lst1 with even numbers from lst2\n    if (evenCountInLst2 >= oddCount) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n\n// Example usage\n"}
{"task_id": "CPP/111", "generation": "#include <stdio.h>\n#include <string>\n#include <map>\n#include <sstream>\nusing namespace std;\n\nmap<string, int> histogram(string test) {\n    map<string, int> count_map;\n    if (test.empty()) {\n        return count_map; // Return empty map if input is empty\n    }\n\n    // Use stringstream to split the input string\n    stringstream ss(test);\n    string letter;\n\n    // Count occurrences of each letter\n    while (ss >> letter) {\n        count_map[letter]++;\n    }\n\n    // Find the maximum occurrence count\n    int max_count = 0;\n    for (const auto& pair : count_map) {\n        if (pair.second > max_count) {\n            max_count = pair.second;\n        }\n    }\n\n    // Create result map for letters with the maximum count\n    map<string, int> result;\n    for (const auto& pair : count_map) {\n        if (pair.second == max_count) {\n            result[pair.first] = pair.second;\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/80", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_happy(string s) {\n    // Check if the length of the string is at least 3\n    if (s.length() < 3) {\n        return false;\n    }\n\n    // Iterate through the string and check every 3 consecutive characters\n    for (size_t i = 0; i <= s.length() - 3; ++i) {\n        // Check if the three characters are distinct\n        if (s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]) {\n            return false; // Found a set of 3 consecutive characters that are not distinct\n        }\n    }\n\n    return true; // All sets of 3 consecutive characters are distinct\n}\n\n"}
