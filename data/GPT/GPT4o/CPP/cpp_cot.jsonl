{"task_id": "CPP/0", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\n#include <math.h>\nusing namespace std;\n\nbool has_close_elements(vector<float> numbers, float threshold) {\n    // Sort the numbers\n    sort(numbers.begin(), numbers.end());\n    \n    // Check adjacent elements for closeness\n    for (size_t i = 0; i < numbers.size() - 1; i++) {\n        if (fabs(numbers[i] - numbers[i + 1]) < threshold) {\n            return true; // Found two numbers closer than the threshold\n        }\n    }\n    \n    return false; // No such pair found\n}\n"}
{"task_id": "CPP/1", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> separate_paren_groups(string paren_string) {\n    vector<string> result;\n    string processed_string = \"\";\n\n    // Step 1: Remove spaces\n    for (char c : paren_string) {\n        if (c != ' ') {\n            processed_string += c;\n        }\n    }\n\n    // Step 2: Extract groups\n    int counter = 0;\n    string current_group = \"\";\n\n    for (char c : processed_string) {\n        if (c == '(') {\n            counter++;\n            current_group += c;\n        } else if (c == ')') {\n            current_group += c;\n            counter--;\n        }\n\n        // Check if we have a complete group\n        if (counter == 0) {\n            result.push_back(current_group);\n            current_group = \"\";\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/2", "generation": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n\nfloat truncate_number(float number) {\n    // Get the integer part of the number\n    int integerPart = floor(number);\n    // Calculate the decimal part\n    float decimalPart = number - integerPart;\n    // Return the decimal part\n    return decimalPart;\n}\n"}
{"task_id": "CPP/3", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nbool below_zero(vector<int> operations) {\n    int balance = 0; // Start with a zero balance\n    for (int operation : operations) {\n        balance += operation; // Update the balance\n        if (balance < 0) { // Check if balance goes below zero\n            return true; // Return true if it does\n        }\n    }\n    return false; // Return false if balance never goes below zero\n}\n"}
{"task_id": "CPP/4", "generation": "#include <stdio.h>\n#include <math.h>\n#include <vector>\nusing namespace std;\n\nfloat mean_absolute_deviation(vector<float> numbers) {\n    float sum = 0.0;\n    int n = numbers.size();\n    \n    // Step 1: Calculate the mean\n    for (float num : numbers) {\n        sum += num;\n    }\n    float mean = sum / n;\n\n    // Step 2: Calculate the sum of absolute deviations\n    float mad_sum = 0.0;\n    for (float num : numbers) {\n        mad_sum += fabs(num - mean);\n    }\n\n    // Step 3: Calculate the Mean Absolute Deviation\n    float mad = mad_sum / n;\n    return mad;\n}\n"}
{"task_id": "CPP/5", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nvector<int> intersperse(vector<int> numbers, int delimeter) { \n    vector<int> result; // Create a result vector\n    int n = numbers.size(); // Get the size of the input vector\n\n    // If the input vector is empty, return an empty vector\n    if (n == 0) {\n        return result;\n    }\n\n    // Iterate through the input vector\n    for (int i = 0; i < n; i++) {\n        result.push_back(numbers[i]); // Add the current element to the result\n        // If it's not the last element, add the delimiter\n        if (i < n - 1) {\n            result.push_back(delimeter);\n        }\n    }\n    \n    return result; // Return the result vector\n}\n"}
{"task_id": "CPP/6", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <sstream>\nusing namespace std;\n\nvector<int> parse_nested_parens(string paren_string) {\n    vector<int> depths;\n    stringstream ss(paren_string);\n    string group;\n\n    while (ss >> group) { // Read each group separated by spaces\n        int current_depth = 0;\n        int max_depth = 0;\n\n        for (char ch : group) {\n            if (ch == '(') {\n                current_depth++;\n                if (current_depth > max_depth) {\n                    max_depth = current_depth;\n                }\n            } else if (ch == ')') {\n                current_depth--;\n            }\n        }\n\n        depths.push_back(max_depth); // Store the maximum depth for the current group\n    }\n\n    return depths;\n}\n"}
{"task_id": "CPP/7", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> filter_by_substring(vector<string> strings, string substring) {\n    vector<string> result; // Initialize an empty vector to hold the filtered strings\n    for (const string& str : strings) { // Iterate through each string in the input vector\n        if (str.find(substring) != string::npos) { // Check if the substring is found in the string\n            result.push_back(str); // If found, add the string to the result vector\n        }\n    }\n    return result; // Return the filtered vector\n}\n"}
{"task_id": "CPP/8", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> sum_product(vector<int> numbers) {\n    // Initialize sum and product\n    int sum = 0;\n    int product = 1;\n\n    // Check if the vector is empty\n    if (numbers.empty()) {\n        return {0, 1}; // Return (0, 1) for empty vector\n    }\n\n    // Calculate sum and product\n    for (int number : numbers) {\n        sum += number; // Add to sum\n        product *= number; // Multiply to product\n    }\n\n    return {sum, product}; // Return the results\n}\n"}
{"task_id": "CPP/9", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nvector<int> rolling_max(vector<int> numbers) {\n    vector<int> rollingMax;\n    int currentMax = INT_MIN; // Initialize to the smallest integer\n\n    for (int number : numbers) {\n        if (number > currentMax) {\n            currentMax = number; // Update currentMax if the current number is greater\n        }\n        rollingMax.push_back(currentMax); // Append the current maximum to the result\n    }\n\n    return rollingMax; // Return the vector of rolling maximums\n}\n"}
{"task_id": "CPP/10", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nbool is_palindrome(string str) {\n    string s(str.rbegin(), str.rend());\n    return s == str;\n}\n\nstring make_palindrome(string str) {\n    int n = str.length();\n    int i;\n\n    // Find the longest palindromic suffix\n    for (i = n; i >= 0; --i) {\n        if (is_palindrome(str.substr(i))) {\n            break;\n        }\n    }\n\n    // Create the palindrome by appending the reversed prefix\n    string prefix = str.substr(0, i);\n    string reversed_prefix(prefix.rbegin(), prefix.rend());\n    return str + reversed_prefix;\n}\n"}
{"task_id": "CPP/11", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nstring string_xor(string a, string b) {\n    string result = \"\";\n    for (int i = 0; i < a.length(); i++) {\n        if (a[i] == b[i]) {\n            result += \"0\";\n        } else {\n            result += \"1\";\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/12", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring longest(vector<string> strings) {\n    if (strings.empty()) {\n        return \"None\"; // Return \"None\" if the vector is empty\n    }\n    \n    string longestString = strings[0]; // Start with the first string\n    for (const string& str : strings) {\n        if (str.length() > longestString.length()) {\n            longestString = str; // Update longest string if current is longer\n        }\n    }\n    \n    return longestString; // Return the longest string found\n}\n"}
{"task_id": "CPP/13", "generation": "#include<stdio.h>\nusing namespace std;\n\nint greatest_common_divisor(int a, int b) {\n    while (b != 0) {\n        int temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n"}
{"task_id": "CPP/14", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> all_prefixes(string str) {\n    vector<string> prefixes;\n    for (int i = 1; i <= str.length(); i++) {\n        prefixes.push_back(str.substr(0, i));\n    }\n    return prefixes;\n}\n"}
{"task_id": "CPP/15", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nstring string_sequence(int n) {\n    string result = \"\";\n    for (int i = 0; i <= n; i++) {\n        if (i != 0) {\n            result += \" \"; // Add space before the number if it's not the first number\n        }\n        result += to_string(i); // Convert the number to string and append\n    }\n    return result;\n}\n"}
{"task_id": "CPP/16", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <set>\n#include <algorithm>\nusing namespace std;\n\nint count_distinct_characters(string str) {\n    set<char> distinctChars; // Set to store distinct characters\n    // Convert the string to lowercase and add characters to the set\n    for (char c : str) {\n        distinctChars.insert(tolower(c)); // Insert lowercase character\n    }\n    return distinctChars.size(); // Return the number of distinct characters\n}\n"}
{"task_id": "CPP/17", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <sstream>\nusing namespace std;\n\nvector<int> parse_music(string music_string) { \n    vector<int> beats;\n    stringstream ss(music_string);\n    string note;\n\n    while (ss >> note) {\n        if (note == \"o\") {\n            beats.push_back(4);\n        } else if (note == \"o|\") {\n            beats.push_back(2);\n        } else if (note == \".|\") {\n            beats.push_back(1);\n        }\n    }\n\n    return beats;\n}\n"}
{"task_id": "CPP/18", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nint how_many_times(string str, string substring) {\n    // Check if the substring is empty\n    if (substring.empty()) {\n        return 0;\n    }\n    \n    int count = 0;\n    int strLength = str.length();\n    int subLength = substring.length();\n    \n    // Iterate through the string\n    for (int i = 0; i <= strLength - subLength; i++) {\n        // Check for the substring\n        if (str.substr(i, subLength) == substring) {\n            count++;\n        }\n    }\n    \n    return count;\n}\n"}
{"task_id": "CPP/19", "generation": "#include <iostream>\n#include <string>\n#include <vector>\n#include <map>\n#include <sstream>\n#include <algorithm>\n\nusing namespace std;\n\nstring sort_numbers(string numbers) {\n    // Step 1: Create a map for number words to their integer values\n    map<string, int> numMap = {\n        {\"zero\", 0}, {\"one\", 1}, {\"two\", 2}, {\"three\", 3},\n        {\"four\", 4}, {\"five\", 5}, {\"six\", 6}, {\"seven\", 7},\n        {\"eight\", 8}, {\"nine\", 9}\n    };\n\n    // Step 2: Split the input string into words\n    stringstream ss(numbers);\n    vector<string> words;\n    string word;\n    while (ss >> word) {\n        words.push_back(word);\n    }\n\n    // Step 3: Sort the words based on their integer values\n    sort(words.begin(), words.end(), [&](const string &a, const string &b) {\n        return numMap[a] < numMap[b];\n    });\n\n    // Step 4: Join the sorted words into a single string\n    string result;\n    for (const string &w : words) {\n        if (!result.empty()) {\n            result += \" \";\n        }\n        result += w;\n    }\n\n    // Step 5: Return the resulting string\n    return result;\n}\n"}
{"task_id": "CPP/20", "generation": "#include <vector>\n#include <algorithm>\n#include <iostream>\nusing namespace std;\n\nvector<float> find_closest_elements(vector<float> numbers) {\n    // Sort the numbers\n    sort(numbers.begin(), numbers.end());\n    \n    float min_diff = numeric_limits<float>::max(); // Initialize to a large value\n    vector<float> closest_pair; // To store the closest pair\n    \n    // Iterate through the sorted numbers\n    for (size_t i = 0; i < numbers.size() - 1; ++i) {\n        float diff = numbers[i + 1] - numbers[i]; // Calculate difference\n        if (diff < min_diff) { // Check if it's the smallest difference\n            min_diff = diff;\n            closest_pair = {numbers[i], numbers[i + 1]}; // Update closest pair\n        }\n    }\n    \n    return closest_pair; // Return the closest pair\n}\n"}
{"task_id": "CPP/21", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<float> rescale_to_unit(vector<float> numbers) {\n    // Step 1: Find the minimum and maximum values\n    float min_value = *min_element(numbers.begin(), numbers.end());\n    float max_value = *max_element(numbers.begin(), numbers.end());\n    \n    // Step 2: Create a vector to hold the rescaled values\n    vector<float> rescaled_numbers;\n    \n    // Step 3: Apply the linear transformation\n    for (float number : numbers) {\n        float rescaled_value = (number - min_value) / (max_value - min_value);\n        rescaled_numbers.push_back(rescaled_value);\n    }\n    \n    // Step 4: Return the rescaled vector\n    return rescaled_numbers;\n}\n"}
{"task_id": "CPP/22", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <boost/any.hpp>\n#include <list>\n#include <typeinfo>\n\ntypedef std::list<boost::any> list_any;\n\nstd::vector<int> filter_integers(list_any values) {\n    std::vector<int> result;\n    for (const auto& value : values) {\n        // Check if the value is of type int\n        if (value.type() == typeid(int)) {\n            // Extract the integer and add it to the result vector\n            result.push_back(boost::any_cast<int>(value));\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/23", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nint strlen(string str) {\n    return str.length(); // Use the length() method to get the length of the string\n}\n"}
{"task_id": "CPP/24", "generation": "#include <stdio.h>\nusing namespace std;\n\nint largest_divisor(int n) {\n    // Edge case: if n is less than or equal to 1, return -1\n    if (n <= 1) {\n        return -1; // No valid divisor\n    }\n    \n    // Start from n-1 and go downwards\n    for (int i = n - 1; i >= 1; i--) {\n        if (n % i == 0) {\n            return i; // Found the largest divisor\n        }\n    }\n    \n    return -1; // This line will never be reached due to the loop\n}\n"}
{"task_id": "CPP/25", "generation": "#include <stdio.h>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\nvector<int> factorize(int n) {\n    vector<int> result;\n    // Check for number of 2s that divide n\n    while (n % 2 == 0) {\n        result.push_back(2);\n        n /= 2;\n    }\n    \n    // n must be odd at this point, so we can skip even numbers\n    for (int i = 3; i <= sqrt(n); i += 2) {\n        while (n % i == 0) {\n            result.push_back(i);\n            n /= i;\n        }\n    }\n    \n    // This condition is to check if n is a prime number greater than 2\n    if (n > 2) {\n        result.push_back(n);\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/26", "generation": "#include <stdio.h>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nvector<int> remove_duplicates(vector<int> numbers) {\n    unordered_map<int, int> countMap;\n    \n    // Count occurrences of each number\n    for (int num : numbers) {\n        countMap[num]++;\n    }\n    \n    vector<int> result;\n    \n    // Add numbers that occur exactly once to the result\n    for (int num : numbers) {\n        if (countMap[num] == 1) {\n            result.push_back(num);\n        }\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/27", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nstring flip_case(string str) {\n    string result = \"\"; // Initialize an empty string for the result\n    for (char c : str) { // Loop through each character in the input string\n        if (islower(c)) { // Check if the character is lowercase\n            result += toupper(c); // Convert to uppercase and append to result\n        } else if (isupper(c)) { // Check if the character is uppercase\n            result += tolower(c); // Convert to lowercase and append to result\n        } else {\n            result += c; // Append unchanged character (like digits or symbols)\n        }\n    }\n    return result; // Return the final result string\n}\n"}
{"task_id": "CPP/28", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring concatenate(vector<string> strings) {\n    string result; // Initialize an empty string\n    for (const string& str : strings) { // Iterate through each string in the vector\n        result += str; // Append the current string to the result\n    }\n    return result; // Return the concatenated string\n}\n"}
{"task_id": "CPP/29", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> filter_by_prefix(vector<string> strings, string prefix) {\n    vector<string> result; // Vector to store filtered strings\n    for (const string& str : strings) { // Iterate through each string\n        if (str.substr(0, prefix.size()) == prefix) { // Check if it starts with the prefix\n            result.push_back(str); // Add to result if it matches\n        }\n    }\n    return result; // Return the filtered vector\n}\n"}
{"task_id": "CPP/30", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nvector<float> get_positive(vector<float> l) {\n    vector<float> out; // Initialize an empty vector to store positive numbers\n    for (float number : l) { // Loop through each number in the input vector\n        if (number > 0) { // Check if the number is positive\n            out.push_back(number); // Add the positive number to the output vector\n        }\n    }\n    return out; // Return the vector containing only positive numbers\n}\n"}
{"task_id": "CPP/31", "generation": "#include <stdio.h>\n#include <cmath>\n\nusing namespace std;\n\nbool is_prime(long long n) {\n    if (n < 2) return false; // 0 and 1 are not prime numbers\n    if (n == 2) return true;  // 2 is a prime number\n    if (n % 2 == 0) return false; // Exclude even numbers greater than 2\n\n    // Check for factors from 3 to sqrt(n)\n    for (long long i = 3; i <= sqrt(n); i += 2) {\n        if (n % i == 0) {\n            return false; // Found a divisor, not prime\n        }\n    }\n    return true; // No divisors found, n is prime\n}\n"}
{"task_id": "CPP/32", "generation": "#include <stdio.h>\n#include <math.h>\n#include <vector>\nusing namespace std;\n\ndouble poly(vector<double> xs, double x) {\n    double sum = 0;\n    for (int i = 0; i < xs.size(); i++) {\n        sum += xs[i] * pow(x, i);\n    }\n    return sum;\n}\n\ndouble find_zero(vector<double> xs) {\n    double low = -1000.0;\n    double high = 1000.0;\n    double mid;\n    double tolerance = 1e-7; // Define a tolerance for convergence\n\n    // Ensure that the function changes sign over the interval\n    while (poly(xs, low) * poly(xs, high) > 0) {\n        low -= 1000; // Expand the interval if necessary\n        high += 1000;\n    }\n\n    // Bisection method\n    while (high - low > tolerance) {\n        mid = (low + high) / 2.0;\n        if (poly(xs, mid) == 0) {\n            return mid; // Found exact zero\n        } else if (poly(xs, low) * poly(xs, mid) < 0) {\n            high = mid; // Root is in the left half\n        } else {\n            low = mid; // Root is in the right half\n        }\n    }\n    \n    return (low + high) / 2.0; // Return the midpoint as the root\n}\n"}
{"task_id": "CPP/33", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> sort_third(vector<int> l) {\n    vector<int> collection; // To hold values at indices divisible by 3\n\n    // Collect values at indices divisible by 3\n    for (int i = 0; i < l.size(); i++) {\n        if (i % 3 == 0) {\n            collection.push_back(l[i]);\n        }\n    }\n\n    // Sort the collected values\n    sort(collection.begin(), collection.end());\n\n    vector<int> result(l.size()); // Result vector of the same size as l\n    int sortedIndex = 0; // Index for sorted values\n\n    // Construct the result vector\n    for (int i = 0; i < l.size(); i++) {\n        if (i % 3 == 0) {\n            result[i] = collection[sortedIndex]; // Place sorted value\n            sortedIndex++; // Move to the next sorted value\n        } else {\n            result[i] = l[i]; // Keep original value\n        }\n    }\n\n    return result; // Return the modified vector\n}\n"}
{"task_id": "CPP/34", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\n#include <set>\nusing namespace std;\n\nvector<int> unique(vector<int> l) {\n    // Step 1: Use a set to store unique elements\n    set<int> uniqueElements(l.begin(), l.end());\n    \n    // Step 2: Convert the set back to a vector\n    vector<int> result(uniqueElements.begin(), uniqueElements.end());\n    \n    // Step 3: Sort the vector (set is already sorted, but we ensure it)\n    sort(result.begin(), result.end());\n    \n    // Step 4: Return the sorted unique elements\n    return result;\n}\n"}
{"task_id": "CPP/35", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nfloat max_element(vector<float> l) {\n    if (l.empty()) {\n        return -1; // or handle the empty case as needed\n    }\n    \n    float max_value = l[0]; // Initialize max_value with the first element\n    for (float element : l) {\n        if (element > max_value) {\n            max_value = element; // Update max_value if current element is greater\n        }\n    }\n    return max_value; // Return the maximum value found\n}\n"}
{"task_id": "CPP/36", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint fizz_buzz(int n) {\n    int count = 0;\n    for (int i = 1; i < n; i++) {\n        if (i % 11 == 0 || i % 13 == 0) {\n            // Convert the number to string to count '7's\n            string str = to_string(i);\n            // Count occurrences of '7'\n            for (char c : str) {\n                if (c == '7') {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}\n"}
{"task_id": "CPP/37", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<float> sort_even(vector<float> l) {\n    vector<float> even_values;\n    \n    // Extract even indexed values\n    for (int i = 0; i < l.size(); i++) {\n        if (i % 2 == 0) {\n            even_values.push_back(l[i]);\n        }\n    }\n    \n    // Sort the even indexed values\n    sort(even_values.begin(), even_values.end());\n    \n    // Create the result vector\n    vector<float> result(l.size());\n    \n    // Fill the result vector\n    int even_index = 0;\n    for (int i = 0; i < l.size(); i++) {\n        if (i % 2 == 0) {\n            result[i] = even_values[even_index++];\n        } else {\n            result[i] = l[i];\n        }\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/38", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nstring decode_cyclic(string s) { \n    string output = \"\";\n    int l = s.length();\n    \n    for (int i = 0; i < l; i += 3) {\n        string x = s.substr(i, 3);\n        if (x.length() == 3) {\n            output += x[2];  // last character\n            output += x[0];  // first character\n            output += x[1];  // second character\n        } else {\n            output += x;  // append as is\n        }\n    }\n    \n    return output;\n}\n"}
{"task_id": "CPP/39", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    if (num <= 3) return true;\n    if (num % 2 == 0 || num % 3 == 0) return false;\n    for (int i = 5; i * i <= num; i += 6) {\n        if (num % i == 0 || num % (i + 2) == 0) return false;\n    }\n    return true;\n}\n\n// Function to find the n-th Fibonacci prime\nint prime_fib(int n) {\n    int fib1 = 0, fib2 = 1;\n    int count = 0;\n    vector<int> fib_primes;\n\n    while (count < n) {\n        int fib_next = fib1 + fib2;\n        fib1 = fib2;\n        fib2 = fib_next;\n\n        if (is_prime(fib_next)) {\n            fib_primes.push_back(fib_next);\n            count++;\n        }\n    }\n    \n    return fib_primes.back(); // Return the n-th Fibonacci prime\n}\n\n// Example usage\n"}
{"task_id": "CPP/40", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nbool triples_sum_to_zero(vector<int> l) {\n    sort(l.begin(), l.end()); // Step 1: Sort the vector\n    int n = l.size();\n    \n    for (int i = 0; i < n - 2; i++) { // Step 2: Iterate through the vector\n        int left = i + 1; // Initialize left pointer\n        int right = n - 1; // Initialize right pointer\n        \n        while (left < right) { // Step 3: Use two pointers\n            int sum = l[i] + l[left] + l[right];\n            if (sum == 0) {\n                return true; // Found a triplet\n            } else if (sum < 0) {\n                left++; // Move left pointer to the right\n            } else {\n                right--; // Move right pointer to the left\n            }\n        }\n    }\n    return false; // No triplet found\n}\n"}
{"task_id": "CPP/41", "generation": "#include<stdio.h>\nusing namespace std;\n\nint car_race_collision(int n) {\n    return n * n; // Each car from the left set collides with each car from the right set\n}\n"}
{"task_id": "CPP/42", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> incr_list(vector<int> l) {\n    vector<int> result; // Initialize an empty vector to store the results\n    for (int i = 0; i < l.size(); i++) { // Loop through each element in the input vector\n        result.push_back(l[i] + 1); // Increment the element by 1 and add to the result vector\n    }\n    return result; // Return the result vector\n}\n"}
{"task_id": "CPP/43", "generation": "#include <stdio.h>\n#include <vector>\n#include <unordered_set> // Include unordered_set for using a set\nusing namespace std;\n\nbool pairs_sum_to_zero(vector<int> l) {\n    unordered_set<int> seen; // Create a set to store seen numbers\n    for (int number : l) {\n        if (seen.count(-number)) { // Check if the negation is in the set\n            return true; // Found a pair that sums to zero\n        }\n        seen.insert(number); // Add the current number to the set\n    }\n    return false; // No pairs found\n}\n"}
{"task_id": "CPP/44", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nstring change_base(int x, int base) {\n    // Check if base is valid\n    if (base >= 10) {\n        return \"Invalid base\";\n    }\n    \n    // Handle the case when x is 0\n    if (x == 0) {\n        return \"0\";\n    }\n    \n    string result = \"\";\n    while (x > 0) {\n        int remainder = x % base; // Get the remainder\n        result = to_string(remainder) + result; // Prepend the remainder to the result\n        x = x / base; // Update x by dividing it by the base\n    }\n    \n    return result; // Return the final result\n}\n"}
{"task_id": "CPP/45", "generation": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n\nfloat triangle_area(float a, float h) {\n    return (0.5 * a * h);\n}\n"}
{"task_id": "CPP/46", "generation": "#include <stdio.h>\nusing namespace std;\n\nint fib4(int n) {\n    if (n == 0) return 0;\n    if (n == 1) return 0;\n    if (n == 2) return 2;\n    if (n == 3) return 0;\n\n    // Initialize an array to hold the last four values\n    int fib[4] = {0, 0, 2, 0};\n\n    // Compute values from 4 to n\n    for (int i = 4; i <= n; i++) {\n        int next_value = fib[0] + fib[1] + fib[2] + fib[3];\n        // Shift the values\n        fib[0] = fib[1];\n        fib[1] = fib[2];\n        fib[2] = fib[3];\n        fib[3] = next_value;\n    }\n\n    // Return the last computed value\n    return fib[3];\n}\n"}
{"task_id": "CPP/47", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nfloat median(vector<float> l) {\n    // Step 1: Sort the vector\n    sort(l.begin(), l.end());\n    \n    // Step 2: Get the size of the vector\n    int n = l.size();\n    \n    // Step 3: Determine if the size is odd or even\n    if (n % 2 == 1) {\n        // Odd size: return the middle element\n        return l[n / 2];\n    } else {\n        // Even size: return the average of the two middle elements\n        return (l[n / 2 - 1] + l[n / 2]) / 2.0;\n    }\n}\n"}
{"task_id": "CPP/48", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nbool is_palindrome(string text) {\n    if (text.empty()) {\n        return true; // An empty string is a palindrome\n    }\n    \n    int left = 0;\n    int right = text.length() - 1;\n    \n    while (left < right) {\n        if (text[left] != text[right]) {\n            return false; // Characters do not match\n        }\n        left++;\n        right--;\n    }\n    \n    return true; // All characters matched\n}\n"}
{"task_id": "CPP/49", "generation": "#include<stdio.h>\nusing namespace std;\n\nint modp(int n, int p) {\n    if (n == 0) return 1; // 2^0 = 1\n    long long result = 1; // Use long long to avoid overflow\n    long long base = 2;   // Base is 2\n\n    while (n > 0) {\n        if (n % 2 == 1) { // If n is odd\n            result = (result * base) % p; // Multiply and take modulo\n        }\n        base = (base * base) % p; // Square the base and take modulo\n        n /= 2; // Divide n by 2\n    }\n    \n    return result; // Return the final result\n}\n"}
{"task_id": "CPP/50", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring encode_shift(string s) {\n    // returns encoded string by shifting every character by 5 in the alphabet.\n    string out;\n    for (int i = 0; i < s.length(); i++) {\n        int w = ((int)s[i] + 5 - (int)'a') % 26 + (int)'a';   \n        out += (char)w;\n    }\n    return out;\n}\n\nstring decode_shift(string s) {\n    // takes as input string encoded with encode_shift function. Returns decoded string.\n    string out;\n    for (int i = 0; i < s.length(); i++) {\n        int w = ((int)s[i] - 5 - (int)'a' + 26) % 26 + (int)'a'; // Wrap around if necessary\n        out += (char)w;\n    }\n    return out;\n}\n"}
{"task_id": "CPP/51", "generation": "#include <stdio.h>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nstring remove_vowels(string text) {\n    string result = \"\"; // Initialize an empty string to store the result\n    string vowels = \"aeiouAEIOU\"; // Define a string containing all vowels\n\n    // Iterate through each character in the input text\n    for (char c : text) {\n        // If the character is not a vowel, append it to the result\n        if (vowels.find(c) == string::npos) {\n            result += c;\n        }\n    }\n    return result; // Return the result string without vowels\n}\n"}
{"task_id": "CPP/52", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nbool below_threshold(vector<int> l, int t) {\n    for (int i = 0; i < l.size(); i++) {\n        if (l[i] >= t) {\n            return false; // Found an element that is not below the threshold\n        }\n    }\n    return true; // All elements are below the threshold\n}\n"}
{"task_id": "CPP/53", "generation": "#include<stdio.h>\n#include<stdlib.h>\nusing namespace std;\n\nint add(int x, int y) {\n    return x + y; // Return the sum of x and y\n}\n"}
{"task_id": "CPP/54", "generation": "#include <stdio.h>\n#include <string>\n#include <algorithm>\n#include <set>\nusing namespace std;\n\nbool same_chars(string s0, string s1) {\n    // Create sets to store unique characters\n    set<char> uniqueChars0(s0.begin(), s0.end());\n    set<char> uniqueChars1(s1.begin(), s1.end());\n    \n    // Compare the sets\n    return uniqueChars0 == uniqueChars1;\n}\n"}
{"task_id": "CPP/55", "generation": "#include<stdio.h>\nusing namespace std;\n\nint fib(int n) {\n    if (n == 0) return 0;\n    if (n == 1) return 1;\n\n    int a = 0; // fib(0)\n    int b = 1; // fib(1)\n\n    for (int i = 2; i <= n; i++) {\n        int c = a + b; // fib(i) = fib(i-1) + fib(i-2)\n        a = b;         // move to the next Fibonacci number\n        b = c;         // update b to the current Fibonacci number\n    }\n    \n    return b; // b now holds fib(n)\n}\n"}
{"task_id": "CPP/56", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    int counter = 0;\n    for (char ch : brackets) {\n        if (ch == '<') {\n            counter++;\n        } else if (ch == '>') {\n            counter--;\n        }\n        // If counter goes negative, we have more closing brackets\n        if (counter < 0) {\n            return false;\n        }\n    }\n    // If counter is zero, all brackets are matched\n    return counter == 0;\n}\n"}
{"task_id": "CPP/57", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nbool monotonic(vector<float> l) {\n    if (l.size() <= 1) {\n        return true; // A single element or empty vector is considered monotonic\n    }\n    \n    bool isIncreasing = true;\n    bool isDecreasing = true;\n\n    for (size_t i = 0; i < l.size() - 1; i++) {\n        if (l[i] < l[i + 1]) {\n            isDecreasing = false; // Found an increasing pair\n        }\n        if (l[i] > l[i + 1]) {\n            isIncreasing = false; // Found a decreasing pair\n        }\n    }\n\n    return isIncreasing || isDecreasing; // Return true if either condition holds\n}\n"}
{"task_id": "CPP/58", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\n#include <set>\nusing namespace std;\n\nvector<int> common(vector<int> l1, vector<int> l2) {\n    // Sort both vectors\n    sort(l1.begin(), l1.end());\n    sort(l2.begin(), l2.end());\n    \n    // Set to store unique common elements\n    set<int> commonSet;\n    \n    // Pointers for both vectors\n    int i = 0, j = 0;\n    \n    // Traverse both vectors\n    while (i < l1.size() && j < l2.size()) {\n        if (l1[i] == l2[j]) {\n            commonSet.insert(l1[i]); // Add to set for uniqueness\n            i++;\n            j++;\n        } else if (l1[i] < l2[j]) {\n            i++;\n        } else {\n            j++;\n        }\n    }\n    \n    // Convert set to vector\n    vector<int> result(commonSet.begin(), commonSet.end());\n    \n    return result; // Return the sorted unique common elements\n}\n"}
{"task_id": "CPP/59", "generation": "#include <stdio.h>\n#include <cmath>\nusing namespace std;\n\nint largest_prime_factor(int n) {\n    int largest_factor = 1;\n\n    // Check for number of 2s that divide n\n    while (n % 2 == 0) {\n        largest_factor = 2;\n        n = n / 2;\n    }\n\n    // n must be odd at this point, check for odd factors from 3 to sqrt(n)\n    for (int i = 3; i <= sqrt(n); i += 2) {\n        while (n % i == 0) {\n            largest_factor = i;\n            n = n / i;\n        }\n    }\n\n    // If n is still greater than 2, then n itself is prime\n    if (n > 2) {\n        largest_factor = n;\n    }\n\n    return largest_factor;\n}\n"}
{"task_id": "CPP/60", "generation": "#include<stdio.h>\nusing namespace std;\n\nint sum_to_n(int n) {\n    // Using the formula for the sum of the first n natural numbers\n    return n * (n + 1) / 2;\n}\n"}
{"task_id": "CPP/61", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    int counter = 0;\n    for (char c : brackets) {\n        if (c == '(') {\n            counter++;\n        } else if (c == ')') {\n            counter--;\n        }\n        if (counter < 0) {\n            return false; // More closing brackets than opening\n        }\n    }\n    return counter == 0; // Check if all opening brackets are matched\n}\n"}
{"task_id": "CPP/62", "generation": "#include <vector>\nusing namespace std;\n\nvector<float> derivative(vector<float> xs) {\n    vector<float> result;\n    for (int i = 1; i < xs.size(); i++) {\n        result.push_back(i * xs[i]);\n    }\n    return result;\n}\n"}
{"task_id": "CPP/63", "generation": "#include <stdio.h>\nusing namespace std;\n\nint fibfib(int n) {\n    if (n == 0) return 0;\n    if (n == 1) return 0;\n    if (n == 2) return 1;\n\n    int a = 0; // fibfib(0)\n    int b = 0; // fibfib(1)\n    int c = 1; // fibfib(2)\n    int result;\n\n    for (int i = 3; i <= n; i++) {\n        result = a + b + c; // fibfib(n) = fibfib(n-1) + fibfib(n-2) + fibfib(n-3)\n        a = b; // Move to the next\n        b = c; // Move to the next\n        c = result; // Update the current\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/64", "generation": "#include <stdio.h>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nint vowels_count(string s) {\n    int count = 0;\n    int length = s.length();\n    \n    for (int i = 0; i < length; i++) {\n        char c = tolower(s[i]); // Convert to lowercase for case-insensitivity\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n            count++;\n        }\n        // Check if 'y' is the last character\n        if (c == 'y' && i == length - 1) {\n            count++;\n        }\n    }\n    \n    return count;\n}\n"}
{"task_id": "CPP/65", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nstring circular_shift(int x, int shift) {\n    string str_x = to_string(x); // Convert integer to string\n    int len = str_x.length(); // Get the length of the string\n\n    if (shift > len) {\n        // If shift is greater than the number of digits, return reversed string\n        reverse(str_x.begin(), str_x.end());\n        return str_x;\n    } else {\n        // Calculate effective shift\n        int effective_shift = shift % len;\n        // Perform circular shift\n        return str_x.substr(len - effective_shift) + str_x.substr(0, len - effective_shift);\n    }\n}\n"}
{"task_id": "CPP/66", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nint digitSum(string s) {\n    int total = 0; // Initialize total to 0\n    for (char c : s) { // Iterate through each character in the string\n        if (c >= 'A' && c <= 'Z') { // Check if the character is uppercase\n            total += (int)c; // Add the ASCII value of the uppercase character to total\n        }\n    }\n    return total; // Return the total sum of ASCII values\n}\n"}
{"task_id": "CPP/67", "generation": "#include <stdio.h>\n#include <string>\n#include <sstream>\n#include <iostream>\nusing namespace std;\n\nint fruit_distribution(string s, int n) {\n    int apples = 0, oranges = 0;\n    \n    // Find the number of apples\n    size_t pos = s.find(\"apples\");\n    if (pos != string::npos) {\n        // Extract the number before \"apples\"\n        stringstream ss(s.substr(0, pos));\n        ss >> apples; // Read the integer value\n    }\n    \n    // Find the number of oranges\n    pos = s.find(\"oranges\");\n    if (pos != string::npos) {\n        // Extract the number before \"oranges\"\n        stringstream ss(s.substr(0, pos));\n        ss >> oranges; // Read the integer value\n    }\n    \n    // Calculate the number of mangoes\n    int mangoes = n - (apples + oranges);\n    return mangoes;\n}\n"}
{"task_id": "CPP/68", "generation": "#include <stdio.h>\n#include <vector>\n#include <limits.h> // For INT_MAX\nusing namespace std;\n\nvector<int> pluck(vector<int> arr) {\n    vector<int> result;\n    int smallest_even = INT_MAX;\n    int smallest_index = -1;\n\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] % 2 == 0) { // Check if the number is even\n            if (arr[i] < smallest_even) { // Check if it's the smallest even found\n                smallest_even = arr[i];\n                smallest_index = i;\n            }\n        }\n    }\n\n    if (smallest_index == -1) {\n        return result; // Return empty vector if no even number was found\n    } else {\n        result.push_back(smallest_even);\n        result.push_back(smallest_index);\n        return result; // Return the smallest even number and its index\n    }\n}\n"}
{"task_id": "CPP/69", "generation": "#include <stdio.h>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint search(vector<int> lst) {\n    unordered_map<int, int> frequencyMap;\n\n    // Count the frequency of each integer\n    for (int num : lst) {\n        frequencyMap[num]++;\n    }\n\n    int greatestValidInteger = -1;\n\n    // Check for the greatest integer with the required frequency\n    for (const auto& entry : frequencyMap) {\n        int num = entry.first;\n        int freq = entry.second;\n\n        if (freq >= num) {\n            greatestValidInteger = max(greatestValidInteger, num);\n        }\n    }\n\n    return greatestValidInteger;\n}\n"}
{"task_id": "CPP/70", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> strange_sort_list(vector<int> lst) {\n    // Step 1: Sort the list\n    sort(lst.begin(), lst.end());\n    \n    // Step 2: Initialize pointers and result vector\n    int left = 0;\n    int right = lst.size() - 1;\n    vector<int> result;\n    \n    // Step 3: Build the result vector\n    while (left <= right) {\n        // Add the minimum\n        result.push_back(lst[left]);\n        left++;\n        \n        // Add the maximum if there are still elements left\n        if (left <= right) {\n            result.push_back(lst[right]);\n            right--;\n        }\n    }\n    \n    // Step 4: Return the result\n    return result;\n}\n"}
{"task_id": "CPP/71", "generation": "#include <stdio.h>\n#include <math.h>\n#include <iomanip> // for std::setprecision\nusing namespace std;\n\nfloat triangle_area(float a, float b, float c) {\n    // Check if the sides form a valid triangle\n    if ((a + b > c) && (a + c > b) && (b + c > a)) {\n        // Calculate semi-perimeter\n        float s = (a + b + c) / 2;\n        // Calculate area using Heron's formula\n        float area = sqrt(s * (s - a) * (s - b) * (s - c));\n        // Return area rounded to 2 decimal points\n        return round(area * 100) / 100; // rounding to 2 decimal points\n    } else {\n        return -1; // Not a valid triangle\n    }\n}\n"}
{"task_id": "CPP/72", "generation": "#include <stdio.h>\n#include <vector>\n#include <numeric> // for std::accumulate\nusing namespace std;\n\nbool will_it_fly(vector<int> q, int w) {\n    // Check if the vector is empty\n    if (q.empty()) {\n        return false;\n    }\n\n    // Calculate the sum of elements in the vector\n    int sum = accumulate(q.begin(), q.end(), 0);\n\n    // Check if the sum exceeds the maximum weight\n    if (sum > w) {\n        return false;\n    }\n\n    // Check if the vector is a palindrome\n    int n = q.size();\n    for (int i = 0; i < n / 2; i++) {\n        if (q[i] != q[n - 1 - i]) {\n            return false;\n        }\n    }\n\n    // If both conditions are satisfied, return true\n    return true;\n}\n"}
{"task_id": "CPP/73", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nint smallest_change(vector<int> arr) {\n    int change_count = 0;\n    int n = arr.size();\n    for (int i = 0; i < n / 2; i++) {\n        if (arr[i] != arr[n - 1 - i]) {\n            change_count++;\n        }\n    }\n    return change_count;\n}\n"}
{"task_id": "CPP/74", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> total_match(vector<string> lst1, vector<string> lst2) {\n    int total1 = 0, total2 = 0;\n\n    // Calculate total characters in lst1\n    for (const string& str : lst1) {\n        total1 += str.length();\n    }\n\n    // Calculate total characters in lst2\n    for (const string& str : lst2) {\n        total2 += str.length();\n    }\n\n    // Compare totals and return the appropriate vector\n    if (total1 < total2) {\n        return lst1;\n    } else if (total2 < total1) {\n        return lst2;\n    } else {\n        return lst1; // If equal, return the first vector\n    }\n}\n"}
{"task_id": "CPP/75", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nbool is_multiply_prime(int a) {\n    // List of prime numbers less than 100\n    vector<int> primes = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, \n                          31, 37, 41, 43, 47, 53, 59, 61, \n                          67, 71, 73, 79, 83, 89, 97};\n    \n    // Check all combinations of three primes\n    for (int i = 0; i < primes.size(); i++) {\n        for (int j = 0; j < primes.size(); j++) {\n            for (int k = 0; k < primes.size(); k++) {\n                if (primes[i] * primes[j] * primes[k] == a) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n"}
{"task_id": "CPP/76", "generation": "#include <stdio.h>\n#include <math.h>\nusing namespace std;\n\nbool is_simple_power(int x, int n) {\n    // Handle special cases\n    if (n == 1) {\n        return x == 1; // 1^k = 1 for any k\n    }\n    if (x < 1 || n < 1) {\n        return false; // x must be >= 1 and n must be >= 1\n    }\n    \n    int power = 1; // Start with n^0\n    while (power <= x) {\n        if (power == x) {\n            return true; // Found a match\n        }\n        power *= n; // Move to the next power of n\n    }\n    return false; // No match found\n}\n"}
{"task_id": "CPP/77", "generation": "#include <cmath>\n#include <iostream>\nusing namespace std;\n\nbool iscube(int a) {\n    if (a == 0) return true; // 0 is a cube (0^3 = 0)\n    \n    int cubeRoot = round(cbrt(abs(a))); // Calculate the cube root and round it\n    return (cubeRoot * cubeRoot * cubeRoot == a); // Check if the cube of the cube root equals a\n}\n\n// Example usage\n"}
{"task_id": "CPP/78", "generation": "#include <stdio.h>\n#include <string>\n#include <unordered_set>\nusing namespace std;\n\nint hex_key(string num) {\n    // Set of prime hexadecimal digits\n    unordered_set<char> prime_hex_digits = {'2', '3', '5', '7', 'B', 'D'};\n    int counter = 0;\n\n    // Iterate through each character in the string\n    for (char c : num) {\n        // Check if the character is a prime hexadecimal digit\n        if (prime_hex_digits.find(c) != prime_hex_digits.end()) {\n            counter++;\n        }\n    }\n    \n    return counter;\n}\n"}
{"task_id": "CPP/79", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nstring decimal_to_binary(int decimal) {\n    if (decimal == 0) {\n        return \"db0db\"; // Special case for 0\n    }\n    \n    string binary = \"\";\n    \n    while (decimal > 0) {\n        // Prepend the remainder (0 or 1) to the binary string\n        binary = to_string(decimal % 2) + binary;\n        // Divide the decimal number by 2\n        decimal /= 2;\n    }\n    \n    // Add \"db\" at the beginning and end\n    return \"db\" + binary + \"db\";\n}\n"}
{"task_id": "CPP/80", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nbool is_happy(string s) {\n    // Check if the length of the string is less than 3\n    if (s.length() < 3) {\n        return false;\n    }\n    \n    // Iterate through the string to check every three consecutive characters\n    for (int i = 0; i <= s.length() - 3; i++) {\n        // Check if any of the three characters are the same\n        if (s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]) {\n            return false;\n        }\n    }\n    \n    // If all checks passed, the string is happy\n    return true;\n}\n"}
{"task_id": "CPP/81", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> numerical_letter_grade(vector<float> grades) {\n    vector<string> letter_grades;\n    for (float grade : grades) {\n        if (grade == 4.0) {\n            letter_grades.push_back(\"A+\");\n        } else if (grade > 3.7) {\n            letter_grades.push_back(\"A\");\n        } else if (grade > 3.3) {\n            letter_grades.push_back(\"A-\");\n        } else if (grade > 3.0) {\n            letter_grades.push_back(\"B+\");\n        } else if (grade > 2.7) {\n            letter_grades.push_back(\"B\");\n        } else if (grade > 2.3) {\n            letter_grades.push_back(\"B-\");\n        } else if (grade > 2.0) {\n            letter_grades.push_back(\"C+\");\n        } else if (grade > 1.7) {\n            letter_grades.push_back(\"C\");\n        } else if (grade > 1.3) {\n            letter_grades.push_back(\"C-\");\n        } else if (grade > 1.0) {\n            letter_grades.push_back(\"D+\");\n        } else if (grade > 0.7) {\n            letter_grades.push_back(\"D\");\n        } else if (grade > 0.0) {\n            letter_grades.push_back(\"D-\");\n        } else {\n            letter_grades.push_back(\"E\");\n        }\n    }\n    return letter_grades;\n}\n"}
{"task_id": "CPP/82", "generation": "#include <stdio.h>\n#include <string>\n#include <cmath>\nusing namespace std;\n\nbool prime_length(string str) {\n    int length = str.length();\n    \n    // Check if length is less than 2\n    if (length < 2) {\n        return false;\n    }\n    \n    // Check for factors from 2 to sqrt(length)\n    for (int i = 2; i <= sqrt(length); i++) {\n        if (length % i == 0) {\n            return false; // Not a prime number\n        }\n    }\n    \n    return true; // It is a prime number\n}\n"}
{"task_id": "CPP/83", "generation": "#include <cmath>\nusing namespace std;\n\nint starts_one_ends(int n) {\n    if (n == 1) {\n        return 1; // Only the number '1' is valid\n    } else {\n        int count_starting_with_1 = pow(10, n - 1);\n        int count_ending_with_1 = 9 * pow(10, n - 2);\n        int count_both_starting_and_ending_with_1 = pow(10, n - 2);\n        int total_count = count_starting_with_1 + count_ending_with_1 - count_both_starting_and_ending_with_1;\n        return total_count;\n    }\n}\n"}
{"task_id": "CPP/84", "generation": "#include <stdio.h>\n#include <string>\n#include <bitset>\nusing namespace std;\n\nstring solve(int N) {\n    int sum_of_digits = 0;\n    \n    // Calculate the sum of digits\n    while (N > 0) {\n        sum_of_digits += N % 10; // Add the last digit\n        N /= 10; // Remove the last digit\n    }\n    \n    // Convert the sum of digits to binary\n    return std::bitset<32>(sum_of_digits).to_string().substr(32 - (sum_of_digits ? (int)log2(sum_of_digits) + 1 : 1));\n}\n"}
{"task_id": "CPP/85", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nint add(vector<int> lst) {\n    int sum = 0; // Initialize sum to 0\n    for (int i = 0; i < lst.size(); i++) { // Loop through the vector\n        if (i % 2 == 1) { // Check if the index is odd\n            if (lst[i] % 2 == 0) { // Check if the element is even\n                sum += lst[i]; // Add to sum\n            }\n        }\n    }\n    return sum; // Return the final sum\n}\n"}
{"task_id": "CPP/86", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <sstream>\n#include <vector>\n\nusing namespace std;\n\nstring anti_shuffle(string s) {\n    string result;\n    stringstream ss(s);\n    string word;\n\n    // Iterate through each word in the string\n    while (ss >> word) {\n        // Sort the characters of the word\n        sort(word.begin(), word.end());\n        // Append the sorted word to the result\n        result += word + \" \";\n    }\n\n    // Remove the trailing space if there is one\n    if (!result.empty()) {\n        result.pop_back();\n    }\n\n    // Handle spaces and punctuation\n    size_t pos = 0;\n    for (char c : s) {\n        if (isspace(c)) {\n            result.insert(pos, 1, ' ');\n            pos++;\n        } else {\n            // Move the position forward by the length of the sorted word\n            pos += result.find_first_not_of(' ', pos) + 1;\n        }\n    }\n\n    return result;\n}\n\n// Example usage\n"}
{"task_id": "CPP/87", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<vector<int>> get_row(vector<vector<int>> lst, int x) {\n    vector<vector<int>> result;\n\n    // Iterate through each row\n    for (int i = 0; i < lst.size(); i++) {\n        // Iterate through each column in the current row\n        for (int j = 0; j < lst[i].size(); j++) {\n            // Check if the current element is equal to x\n            if (lst[i][j] == x) {\n                // Store the coordinates\n                result.push_back({i, j});\n            }\n        }\n    }\n\n    // Sort the result by row index ascending and column index descending\n    sort(result.begin(), result.end(), [](const vector<int>& a, const vector<int>& b) {\n        if (a[0] == b[0]) {\n            return a[1] > b[1]; // Sort by column index descending if rows are equal\n        }\n        return a[0] < b[0]; // Sort by row index ascending\n    });\n\n    return result;\n}\n"}
{"task_id": "CPP/88", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> sort_array(vector<int> array) {\n    // Check for empty or single element vector\n    if (array.empty() || array.size() == 1) {\n        return array;\n    }\n    \n    // Calculate the sum of the first and last elements\n    int sum = array[0] + array[array.size() - 1];\n    \n    // Sort based on the sum being odd or even\n    if (sum % 2 == 0) {\n        // Even sum: sort in descending order\n        sort(array.begin(), array.end(), greater<int>());\n    } else {\n        // Odd sum: sort in ascending order\n        sort(array.begin(), array.end());\n    }\n    \n    return array;\n}\n"}
{"task_id": "CPP/89", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nstring encrypt(string s) {\n    string result = \"\";\n    for (char c : s) {\n        if (c >= 'a' && c <= 'z') {\n            char newChar = c + 4; // Shift down by 4\n            if (newChar > 'z') {\n                newChar -= 26; // Wrap around if it exceeds 'z'\n            }\n            result += newChar; // Append new character to result\n        } else {\n            result += c; // Append unchanged character (if any)\n        }\n    }\n    return result; // Return the encrypted string\n}\n"}
{"task_id": "CPP/90", "generation": "#include <stdio.h>\n#include <vector>\n#include <set>\n#include <algorithm>\n\nusing namespace std;\n\nint next_smallest(vector<int> lst) {\n    if (lst.empty()) {\n        return -1; // Using -1 to represent None in this context\n    }\n\n    set<int> unique_elements(lst.begin(), lst.end()); // Store unique elements\n    if (unique_elements.size() < 2) {\n        return -1; // Not enough unique elements for a second smallest\n    }\n\n    vector<int> sorted_unique(unique_elements.begin(), unique_elements.end());\n    sort(sorted_unique.begin(), sorted_unique.end()); // Sort the unique elements\n\n    return sorted_unique[1]; // Return the second smallest element\n}\n"}
{"task_id": "CPP/91", "generation": "#include <stdio.h>\n#include <string>\n#include <sstream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint is_bored(string S) {\n    int boredomCount = 0;\n    // Replace delimiters with a space to split sentences easily\n    for (char& c : S) {\n        if (c == '.' || c == '?' || c == '!') {\n            c = ' ';\n        }\n    }\n    \n    // Use stringstream to split the string into sentences\n    stringstream ss(S);\n    string sentence;\n    \n    while (getline(ss, sentence, ' ')) {\n        // Trim leading whitespace\n        sentence.erase(0, sentence.find_first_not_of(\" \\t\\n\\r\"));\n        \n        // Check if the sentence starts with \"I\"\n        if (sentence.rfind(\"I\", 0) == 0) { // rfind checks if \"I\" is at index 0\n            boredomCount++;\n        }\n    }\n    \n    return boredomCount;\n}\n"}
{"task_id": "CPP/92", "generation": "#include <stdio.h>\n#include <cmath>\nusing namespace std;\n\nbool any_int(float a, float b, float c) {\n    // Check if all numbers are integers\n    if (floor(a) == a && floor(b) == b && floor(c) == c) {\n        // Check if any number is equal to the sum of the other two\n        return (a == b + c || b == a + c || c == a + b);\n    }\n    return false; // Return false if any number is not an integer\n}\n"}
{"task_id": "CPP/93", "generation": "#include <stdio.h>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nstring encode(string message) {\n    string result = \"\";\n    for (char c : message) {\n        if (isalpha(c)) { // Check if the character is a letter\n            // Swap case\n            if (c == 'a') result += 'c';\n            else if (c == 'e') result += 'g';\n            else if (c == 'i') result += 'k';\n            else if (c == 'o') result += 'q';\n            else if (c == 'u') result += 'w';\n            else if (c == 'A') result += 'C';\n            else if (c == 'E') result += 'G';\n            else if (c == 'I') result += 'K';\n            else if (c == 'O') result += 'Q';\n            else if (c == 'U') result += 'W';\n            else {\n                // Swap case for consonants\n                if (islower(c)) result += toupper(c);\n                else result += tolower(c);\n            }\n        } else {\n            result += c; // Non-letter characters are added unchanged\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/94", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <cmath>\nusing namespace std;\n\n// Function to check if a number is prime\nbool isPrime(int num) {\n    if (num <= 1) return false;\n    for (int i = 2; i <= sqrt(num); i++) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\n// Function to find the largest prime and return the sum of its digits\nint skjkasdkd(vector<int> lst) {\n    int largestPrime = -1;\n\n    // Find the largest prime number in the list\n    for (int num : lst) {\n        if (isPrime(num) && num > largestPrime) {\n            largestPrime = num;\n        }\n    }\n\n    // If no prime number was found, return 0\n    if (largestPrime == -1) return 0;\n\n    // Calculate the sum of the digits of the largest prime\n    int sumOfDigits = 0;\n    while (largestPrime > 0) {\n        sumOfDigits += largestPrime % 10; // Add the last digit\n        largestPrime /= 10; // Remove the last digit\n    }\n\n    return sumOfDigits;\n}\n"}
{"task_id": "CPP/95", "generation": "#include <stdio.h>\n#include <string>\n#include <map>\n#include <cctype> // for isupper and islower\nusing namespace std;\n\nbool check_dict_case(map<string, string> dict) {\n    // Check if the map is empty\n    if (dict.empty()) {\n        return false;\n    }\n    \n    bool allLower = true;\n    bool allUpper = true;\n\n    // Iterate through each key in the map\n    for (const auto& pair : dict) {\n        const string& key = pair.first; // Get the key\n\n        // Check if the key has any uppercase letter\n        for (char c : key) {\n            if (isupper(c)) {\n                allLower = false; // Found an uppercase letter\n            }\n            if (islower(c)) {\n                allUpper = false; // Found a lowercase letter\n            }\n        }\n    }\n\n    // Return true if all keys are either all lower or all upper\n    return allLower || allUpper;\n}\n"}
{"task_id": "CPP/96", "generation": "#include <stdio.h>\n#include <vector>\n#include <cmath> // for sqrt\nusing namespace std;\n\nvector<int> count_up_to(int n) {\n    vector<int> primes;\n    if (n < 2) {\n        return primes; // Return empty vector if n < 2\n    }\n    \n    for (int i = 2; i < n; i++) {\n        bool is_prime = true;\n        for (int j = 2; j <= sqrt(i); j++) {\n            if (i % j == 0) {\n                is_prime = false;\n                break; // Not a prime number\n            }\n        }\n        if (is_prime) {\n            primes.push_back(i); // Add prime number to the vector\n        }\n    }\n    return primes; // Return the vector of prime numbers\n}\n"}
{"task_id": "CPP/97", "generation": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n\nint multiply(int a, int b) {\n    int unit_digit_a = abs(a) % 10; // Get the unit digit of a\n    int unit_digit_b = abs(b) % 10; // Get the unit digit of b\n    return unit_digit_a * unit_digit_b; // Return the product of the unit digits\n}\n"}
{"task_id": "CPP/98", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nint count_upper(string s) {\n    int count = 0; // Initialize the count of uppercase vowels\n    for (int i = 0; i < s.length(); i += 2) { // Iterate over even indices\n        char ch = s[i]; // Get the character at the current index\n        // Check if the character is an uppercase vowel\n        if (ch == 'A' || ch == 'E' || ch == 'I' || ch == 'O' || ch == 'U') {\n            count++; // Increment the count if it is an uppercase vowel\n        }\n    }\n    return count; // Return the final count\n}\n"}
{"task_id": "CPP/99", "generation": "#include <stdio.h>\n#include <math.h>\n#include <string>\n#include <cstdlib> // for atof\nusing namespace std;\n\nint closest_integer(string value) {\n    double float_value = atof(value.c_str()); // Convert string to double\n    int integer_part = floor(float_value); // Get the integer part\n    double decimal_part = float_value - integer_part; // Get the decimal part\n\n    if (decimal_part < 0.5) {\n        return integer_part; // Round down\n    } else if (decimal_part > 0.5) {\n        return integer_part + 1; // Round up\n    } else {\n        // If decimal_part is exactly 0.5\n        if (integer_part >= 0) {\n            return integer_part + 1; // Round away from zero\n        } else {\n            return integer_part - 1; // Round away from zero\n        }\n    }\n}\n"}
{"task_id": "CPP/100", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> make_a_pile(int n) {\n    vector<int> stones;\n    for (int i = 0; i < n; i++) {\n        // Calculate the number of stones for the current level\n        stones.push_back(n + 2 * i);\n    }\n    return stones;\n}\n"}
{"task_id": "CPP/101", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n\nusing namespace std;\n\nvector<string> words_string(string s) {\n    // Replace commas with spaces\n    replace(s.begin(), s.end(), ',', ' ');\n\n    vector<string> words;\n    istringstream iss(s);\n    string word;\n\n    // Extract words from the string stream\n    while (iss >> word) {\n        words.push_back(word);\n    }\n\n    return words;\n}\n"}
{"task_id": "CPP/102", "generation": "#include<stdio.h>\nusing namespace std;\n\nint choose_num(int x, int y) {\n    // Check if the range is valid\n    if (y < x) {\n        return -1;\n    }\n    \n    // Determine the largest even number in the range\n    int largest_even;\n    if (y % 2 == 0) {\n        largest_even = y; // y is even\n    } else {\n        largest_even = y - 1; // y is odd, so take y - 1\n    }\n    \n    // Check if the largest even number is within the range [x, y]\n    if (largest_even >= x) {\n        return largest_even;\n    } else {\n        return -1; // No even number in the range\n    }\n}\n"}
{"task_id": "CPP/103", "generation": "#include <stdio.h>\n#include <string>\n#include <cmath>\nusing namespace std;\n\nstring toBinary(int num) {\n    if (num == 0) return \"0\";\n    string binary = \"\";\n    while (num > 0) {\n        binary = to_string(num % 2) + binary;\n        num /= 2;\n    }\n    return binary;\n}\n\nstring rounded_avg(int n, int m) {\n    if (n > m) {\n        return \"-1\";\n    }\n    \n    // Calculate the sum from n to m\n    int sum = (m * (m + 1) / 2) - ((n - 1) * n / 2);\n    // Count of numbers from n to m\n    int count = m - n + 1;\n    // Calculate the average and round down\n    int average = sum / count;\n    \n    // Convert the average to binary\n    return toBinary(average);\n}\n"}
{"task_id": "CPP/104", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\n#include <string>\n\nusing namespace std;\n\nvector<int> unique_digits(vector<int> x) {\n    vector<int> result;\n\n    for (int number : x) {\n        string str_num = to_string(number);\n        bool has_even_digit = false;\n\n        for (char digit : str_num) {\n            if (digit == '0' || digit == '2' || digit == '4' || digit == '6' || digit == '8') {\n                has_even_digit = true;\n                break;\n            }\n        }\n\n        if (!has_even_digit) {\n            result.push_back(number);\n        }\n    }\n\n    sort(result.begin(), result.end());\n    return result;\n}\n"}
{"task_id": "CPP/105", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\nvector<string> by_length(vector<int> arr) {\n    // Map for number to word conversion\n    map<int, string> numToWord = {\n        {1, \"One\"}, {2, \"Two\"}, {3, \"Three\"}, {4, \"Four\"},\n        {5, \"Five\"}, {6, \"Six\"}, {7, \"Seven\"}, {8, \"Eight\"}, {9, \"Nine\"}\n    };\n    \n    // Temporary vector to hold valid numbers\n    vector<int> temp;\n    \n    // Filter numbers between 1 and 9\n    for (int number : arr) {\n        if (number >= 1 && number <= 9) {\n            temp.push_back(number);\n        }\n    }\n    \n    // Sort the filtered numbers\n    sort(temp.begin(), temp.end());\n    \n    // Reverse the sorted numbers\n    reverse(temp.begin(), temp.end());\n    \n    // Prepare the result vector\n    vector<string> result;\n    \n    // Map numbers to their corresponding words\n    for (int number : temp) {\n        result.push_back(numToWord[number]);\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/106", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> f(int n) {\n    vector<int> result(n);\n    \n    for (int i = 1; i <= n; i++) {\n        if (i % 2 == 0) { // i is even\n            // Calculate factorial of i\n            int factorial = 1;\n            for (int j = 1; j <= i; j++) {\n                factorial *= j;\n            }\n            result[i - 1] = factorial;\n        } else { // i is odd\n            // Calculate sum from 1 to i\n            result[i - 1] = (i * (i + 1)) / 2;\n        }\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/107", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nbool isPalindrome(int num) {\n    string str = to_string(num);\n    string rev_str = string(str.rbegin(), str.rend());\n    return str == rev_str;\n}\n\nvector<int> even_odd_palindrome(int n) {\n    int even_count = 0;\n    int odd_count = 0;\n    \n    for (int i = 1; i <= n; i++) {\n        if (isPalindrome(i)) {\n            if (i % 2 == 0) {\n                even_count++;\n            } else {\n                odd_count++;\n            }\n        }\n    }\n    \n    return {even_count, odd_count};\n}\n"}
{"task_id": "CPP/108", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nint count_nums(vector<int> n) {\n    int count = 0;\n    \n    for (int num : n) {\n        int sum = 0;\n        int temp = abs(num);\n        bool isNegative = (num < 0);\n        \n        // Calculate the sum of digits\n        while (temp > 0) {\n            sum += temp % 10;\n            temp /= 10;\n        }\n        \n        // If the number is negative, adjust the sum\n        if (isNegative) {\n            sum -= 2 * (num / abs(num)); // Adjust for the first signed digit\n        }\n        \n        // Count if the sum of digits is greater than zero\n        if (sum > 0) {\n            count++;\n        }\n    }\n    \n    return count;\n}\n"}
{"task_id": "CPP/109", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nbool move_one_ball(vector<int> arr) {\n    // If the array is empty, return true\n    if (arr.empty()) {\n        return true;\n    }\n\n    int count_breaks = 0;\n    int n = arr.size();\n\n    // Check for breaks in the order\n    for (int i = 0; i < n; i++) {\n        if (arr[i] > arr[(i + 1) % n]) {  // Circular check\n            count_breaks++;\n        }\n    }\n\n    // If there are more than one breaks, return false\n    return count_breaks <= 1;\n}\n"}
{"task_id": "CPP/110", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring exchange(vector<int> lst1, vector<int> lst2) {\n    bool found_odd = false;\n\n    // Check if lst1 has any odd numbers\n    for (int num : lst1) {\n        if (num % 2 != 0) { // num is odd\n            found_odd = true;\n            break;\n        }\n    }\n\n    // If there are no odd numbers in lst1, return \"YES\"\n    if (!found_odd) {\n        return \"YES\";\n    }\n\n    // Check if lst2 has at least one even number\n    for (int num : lst2) {\n        if (num % 2 == 0) { // num is even\n            return \"YES\";\n        }\n    }\n\n    // If lst1 has odd numbers and lst2 has no even numbers\n    return \"NO\";\n}\n"}
{"task_id": "CPP/111", "generation": "#include <stdio.h>\n#include <string>\n#include <map>\n#include <sstream>\n#include <vector>\nusing namespace std;\n\nmap<string, int> histogram(string test) {\n    map<string, int> countMap;\n    stringstream ss(test);\n    string letter;\n\n    // Count occurrences of each letter\n    while (ss >> letter) {\n        countMap[letter]++;\n    }\n\n    // Find the maximum count\n    int maxCount = 0;\n    for (const auto& pair : countMap) {\n        if (pair.second > maxCount) {\n            maxCount = pair.second;\n        }\n    }\n\n    // Create result map for letters with the maximum count\n    map<string, int> resultMap;\n    for (const auto& pair : countMap) {\n        if (pair.second == maxCount) {\n            resultMap[pair.first] = pair.second;\n        }\n    }\n\n    return resultMap;\n}\n"}
{"task_id": "CPP/112", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <unordered_set>\n#include <algorithm>\nusing namespace std;\n\nvector<string> reverse_delete(string s, string c) {\n    unordered_set<char> charsToRemove(c.begin(), c.end());\n    string result;\n\n    // Build the result string by skipping characters in charsToRemove\n    for (char ch : s) {\n        if (charsToRemove.find(ch) == charsToRemove.end()) {\n            result += ch;\n        }\n    }\n\n    // Check if the result string is a palindrome\n    string reversedResult = result;\n    reverse(reversedResult.begin(), reversedResult.end());\n    bool isPalindrome = (result == reversedResult);\n\n    // Prepare the output\n    return {result, isPalindrome ? \"True\" : \"False\"};\n}\n"}
{"task_id": "CPP/113", "generation": "#include <vector>\n#include <string>\n#include <iostream>\n\nusing namespace std;\n\nvector<string> odd_count(vector<string> lst) {\n    vector<string> output; // Vector to hold the output strings\n    for (int i = 0; i < lst.size(); i++) {\n        int oddCount = 0; // Counter for odd digits\n        for (char c : lst[i]) { // Loop through each character in the string\n            if (c == '1' || c == '3' || c == '5' || c == '7' || c == '9') {\n                oddCount++; // Increment the counter for odd digits\n            }\n        }\n        // Create the formatted output string\n        string formattedString = \"the number of odd elements \" + to_string(oddCount) + \n                                  \"n the str\" + to_string(i) + \n                                  \"ng \" + to_string(i) + \n                                  \" of the \" + to_string(i) + \n                                  \"nput.\";\n        output.push_back(formattedString); // Add the formatted string to the output vector\n    }\n    return output; // Return the output vector\n}\n"}
{"task_id": "CPP/114", "generation": "#include <stdio.h>\n#include <vector>\n#include <limits.h> // for INT_MAX\nusing namespace std;\n\nlong long minSubArraySum(vector<long long> nums) {\n    long long min_sum = LLONG_MAX; // Initialize to maximum possible value\n    int n = nums.size();\n    \n    for (int i = 0; i < n; i++) {\n        long long current_sum = 0; // Reset current sum for each starting index\n        for (int j = i; j < n; j++) {\n            current_sum += nums[j]; // Add the current element to the sum\n            if (current_sum < min_sum) {\n                min_sum = current_sum; // Update min_sum if current_sum is smaller\n            }\n        }\n    }\n    \n    return min_sum; // Return the minimum sum found\n}\n"}
{"task_id": "CPP/115", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nint max_fill(vector<vector<int>> grid, int capacity) {\n    int total_water = 0;\n\n    // Count total units of water in the grid\n    for (const auto& row : grid) {\n        for (int cell : row) {\n            if (cell == 1) {\n                total_water++;\n            }\n        }\n    }\n\n    // If there is no water, return 0\n    if (total_water == 0) {\n        return 0;\n    }\n\n    // Calculate the number of times to lower the buckets\n    int times_to_lower = (total_water + capacity - 1) / capacity;\n    return times_to_lower;\n}\n"}
{"task_id": "CPP/116", "generation": "#include <vector>\n#include <algorithm>\n#include <iostream>\n\nusing namespace std;\n\n// Function to count the number of ones in the binary representation of an integer\nint count_ones_in_binary(int n) {\n    return __builtin_popcount(n);\n}\n\n// Custom comparator for sorting\nbool custom_compare(int x, int y) {\n    int count_x = count_ones_in_binary(x);\n    int count_y = count_ones_in_binary(y);\n    if (count_x != count_y) {\n        return count_x < count_y; // Sort by number of ones\n    }\n    return x < y; // Sort by decimal value if counts are equal\n}\n\nvector<int> sort_array(vector<int> arr) {\n    sort(arr.begin(), arr.end(), custom_compare);\n    return arr;\n}\n\n// Example usage\n"}
{"task_id": "CPP/117", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <cctype>\n\nusing namespace std;\n\nint count_consonants(const string& word) {\n    int count = 0;\n    for (char c : word) {\n        if (isalpha(c) && !strchr(\"aeiouAEIOU\", c)) {\n            count++;\n        }\n    }\n    return count;\n}\n\nvector<string> select_words(string s, int n) {\n    vector<string> result;\n    if (s.empty()) {\n        return result; // return empty vector if input string is empty\n    }\n    \n    // Split the string into words\n    stringstream ss(s);\n    string word;\n    \n    while (ss >> word) {\n        if (count_consonants(word) == n) {\n            result.push_back(word); // add word to result if it has exactly n consonants\n        }\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/118", "generation": "#include <stdio.h>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nstring get_closest_vowel(string word) {\n    // Define the set of vowels\n    string vowels = \"aeiouAEIOU\";\n    int length = word.length();\n    \n    // Iterate from the second last character to the second character\n    for (int i = length - 2; i >= 1; i--) {\n        // Check if the current character is a vowel\n        if (vowels.find(word[i]) != string::npos) {\n            // Check if the characters before and after are consonants\n            if (!isalpha(word[i - 1]) || vowels.find(word[i - 1]) == string::npos) {\n                if (!isalpha(word[i + 1]) || vowels.find(word[i + 1]) == string::npos) {\n                    return string(1, word[i]); // Return the vowel as a string\n                }\n            }\n        }\n    }\n    return \"\"; // Return empty string if no vowel found\n}\n"}
{"task_id": "CPP/119", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring match_parens(vector<string> lst) {\n    string s1 = lst[0];\n    string s2 = lst[1];\n\n    // Function to check if a concatenated string is balanced\n    auto isBalanced = [](const string& s) {\n        int balance = 0;\n        for (char c : s) {\n            if (c == '(') {\n                balance++;\n            } else {\n                balance--;\n            }\n            if (balance < 0) {\n                return false; // More closing than opening\n            }\n        }\n        return balance == 0; // Must end balanced\n    };\n\n    // Check both concatenation orders\n    if (isBalanced(s1 + s2) || isBalanced(s2 + s1)) {\n        return \"Yes\";\n    }\n    return \"No\";\n}\n"}
{"task_id": "CPP/120", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> maximum(vector<int> arr, int k) {\n    // Edge case: if k is 0, return an empty vector\n    if (k == 0) {\n        return {};\n    }\n    \n    // Sort the array in descending order\n    sort(arr.begin(), arr.end(), greater<int>());\n    \n    // Take the first k elements\n    vector<int> maxElements(arr.begin(), arr.begin() + k);\n    \n    // Sort these k elements in ascending order\n    sort(maxElements.begin(), maxElements.end());\n    \n    return maxElements;\n}\n"}
{"task_id": "CPP/121", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nint solution(vector<int> lst) {\n    int sum = 0; // Initialize sum to 0\n    for (int i = 0; i < lst.size(); i += 2) { // Loop through even indices\n        if (lst[i] % 2 != 0) { // Check if the element is odd\n            sum += lst[i]; // Add to sum if it is odd\n        }\n    }\n    return sum; // Return the final sum\n}\n"}
{"task_id": "CPP/122", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nint add_elements(vector<int> arr, int k) {\n    int sum = 0; // Initialize sum to 0\n    for (int i = 0; i < k; i++) { // Loop through the first k elements\n        if (abs(arr[i]) < 100) { // Check if the element has at most two digits\n            sum += arr[i]; // Add to sum if condition is met\n        }\n    }\n    return sum; // Return the final sum\n}\n"}
{"task_id": "CPP/123", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> get_odd_collatz(int n) {\n    vector<int> odd_numbers;\n    \n    // Generate the Collatz sequence\n    while (n != 1) {\n        if (n % 2 != 0) { // Check if n is odd\n            odd_numbers.push_back(n);\n        }\n        // Apply the Collatz rules\n        if (n % 2 == 0) {\n            n = n / 2; // Even case\n        } else {\n            n = 3 * n + 1; // Odd case\n        }\n    }\n    \n    // Add 1 to the list since the sequence ends with 1\n    odd_numbers.push_back(1);\n    \n    // Sort the odd numbers\n    sort(odd_numbers.begin(), odd_numbers.end());\n    \n    return odd_numbers;\n}\n"}
{"task_id": "CPP/124", "generation": "#include <stdio.h>\n#include <string>\n#include <sstream>\n#include <vector>\nusing namespace std;\n\nbool valid_date(string date) {\n    // Check if the date string is empty\n    if (date.empty()) {\n        return false;\n    }\n\n    // Check the format mm-dd-yyyy\n    if (date.length() != 10 || date[2] != '-' || date[5] != '-') {\n        return false;\n    }\n\n    // Extract month, day, year\n    int month, day, year;\n    stringstream ss(date);\n    string monthStr, dayStr, yearStr;\n\n    getline(ss, monthStr, '-');\n    getline(ss, dayStr, '-');\n    getline(ss, yearStr);\n\n    month = stoi(monthStr);\n    day = stoi(dayStr);\n    year = stoi(yearStr);\n\n    // Validate month\n    if (month < 1 || month > 12) {\n        return false;\n    }\n\n    // Validate day based on month\n    if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {\n        if (day < 1 || day > 31) {\n            return false;\n        }\n    } else if (month == 4 || month == 6 || month == 9 || month == 11) {\n        if (day < 1 || day > 30) {\n            return false;\n        }\n    } else if (month == 2) {\n        if (day < 1 || day > 29) {\n            return false;\n        }\n    }\n\n    return true;\n}\n"}
{"task_id": "CPP/125", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <cctype>\n\nusing namespace std;\n\nvector<string> split_words(string txt) {\n    vector<string> result;\n    \n    // Check for whitespace\n    if (txt.find(' ') != string::npos) {\n        istringstream iss(txt);\n        string word;\n        while (iss >> word) {\n            result.push_back(word);\n        }\n        return result;\n    }\n    \n    // Check for commas\n    if (txt.find(',') != string::npos) {\n        istringstream iss(txt);\n        string word;\n        while (getline(iss, word, ',')) {\n            result.push_back(word);\n        }\n        return result;\n    }\n    \n    // If no whitespace or commas, count lowercase letters with odd indices\n    int count = 0;\n    for (char c : txt) {\n        if (islower(c)) {\n            int index = c - 'a'; // Get the index of the letter\n            if (index % 2 == 1) { // Check if the index is odd\n                count++;\n            }\n        }\n    }\n    \n    // Return the count as a string in a vector\n    result.push_back(to_string(count));\n    return result;\n}\n"}
{"task_id": "CPP/126", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nbool is_sorted(vector<int> lst) {\n    if (lst.size() == 0 || lst.size() == 1) {\n        return true; // An empty or single-element list is sorted\n    }\n    \n    int previous = lst[0];\n    int count = 1; // Count occurrences of the current number\n    \n    for (size_t i = 1; i < lst.size(); i++) {\n        if (lst[i] < previous) {\n            return false; // Not sorted in ascending order\n        }\n        \n        if (lst[i] == previous) {\n            count++;\n            if (count > 2) {\n                return false; // A number appears more than twice\n            }\n        } else {\n            previous = lst[i]; // Update previous to current number\n            count = 1; // Reset count for the new number\n        }\n    }\n    \n    return true; // The list is sorted and no number appears more than twice\n}\n"}
{"task_id": "CPP/127", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <cmath>\nusing namespace std;\n\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i <= sqrt(n); i++) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\nstring intersection(vector<int> interval1, vector<int> interval2) {\n    int start1 = interval1[0], end1 = interval1[1];\n    int start2 = interval2[0], end2 = interval2[1];\n    \n    int intersection_start = max(start1, start2);\n    int intersection_end = min(end1, end2);\n    \n    if (intersection_start > intersection_end) {\n        return \"NO\";\n    }\n    \n    int length = intersection_end - intersection_start + 1;\n    \n    if (is_prime(length)) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n"}
{"task_id": "CPP/128", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nint prod_signs(vector<int> arr) {\n    if (arr.empty()) {\n        return -32768;\n    }\n    \n    int sum_magnitudes = 0;\n    int product_signs = 1;\n\n    for (int number : arr) {\n        if (number == 0) {\n            return 0;\n        }\n        if (number > 0) {\n            sum_magnitudes += number;\n        } else {\n            sum_magnitudes += -number; // Add the absolute value\n            product_signs *= -1; // Flip the sign\n        }\n    }\n    \n    return sum_magnitudes * product_signs;\n}\n"}
{"task_id": "CPP/129", "generation": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvoid dfs(int x, int y, int k, vector<vector<int>>& grid, vector<int>& currentPath, vector<int>& bestPath) {\n    if (currentPath.size() == k) {\n        if (bestPath.empty() || currentPath < bestPath) {\n            bestPath = currentPath; // Update best path if current is better\n        }\n        return;\n    }\n    \n    // Directions for moving in the grid (up, down, left, right)\n    vector<pair<int, int>> directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n    \n    for (auto& dir : directions) {\n        int newX = x + dir.first;\n        int newY = y + dir.second;\n        \n        // Check if new coordinates are within bounds\n        if (newX >= 0 && newX < grid.size() && newY >= 0 && newY < grid[0].size()) {\n            currentPath.push_back(grid[newX][newY]); // Move to the new cell\n            dfs(newX, newY, k, grid, currentPath, bestPath); // Recursive DFS\n            currentPath.pop_back(); // Backtrack\n        }\n    }\n}\n\nvector<int> minPath(vector<vector<int>> grid, int k) {\n    vector<int> bestPath;\n    int n = grid.size();\n    \n    // Start DFS from each cell in the grid\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            vector<int> currentPath = {grid[i][j]};\n            dfs(i, j, k, grid, currentPath, bestPath);\n        }\n    }\n    \n    return bestPath;\n}\n"}
{"task_id": "CPP/130", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nvector<int> tri(int n) {\n    vector<int> result(n + 1);\n    \n    // Base cases\n    if (n == 0) {\n        return {1}; // Only tri(0) = 1\n    }\n    \n    result[0] = 1; // tri(0)\n    result[1] = 3; // tri(1)\n    \n    // Calculate tribonacci values\n    for (int i = 2; i <= n; i++) {\n        if (i % 2 == 0) {\n            result[i] = 1 + i / 2; // Even case\n        } else {\n            result[i] = result[i - 1] + result[i - 2] + (i + 1 <= n ? result[i + 1] : 0); // Odd case\n        }\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/131", "generation": "#include <stdio.h>\n\nint digits(int n) {\n    int product = 1;\n    bool foundOdd = false;\n\n    while (n > 0) {\n        int digit = n % 10;  // Get the last digit\n        if (digit % 2 != 0) { // Check if the digit is odd\n            product *= digit;  // Multiply to the product\n            foundOdd = true;   // Mark that we found an odd digit\n        }\n        n /= 10;  // Remove the last digit\n    }\n\n    if (foundOdd) {\n        return product;  // Return the product of odd digits\n    } else {\n        return 0;  // Return 0 if no odd digits were found\n    }\n}\n"}
{"task_id": "CPP/132", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nbool is_nested(string str) {\n    int openCount = 0;\n    int closeCount = 0;\n    bool nested = false;\n\n    for (char ch : str) {\n        if (ch == '[') {\n            openCount++;\n            if (openCount > 1) {\n                nested = true; // We have more than one opening bracket\n            }\n        } else if (ch == ']') {\n            closeCount++;\n            if (closeCount > openCount) {\n                return false; // More closing brackets than opening\n            }\n        }\n    }\n\n    // Check if all brackets are balanced and if we found a nested structure\n    return (openCount == closeCount) && nested;\n}\n"}
{"task_id": "CPP/133", "generation": "#include <stdio.h>\n#include <math.h>\n#include <vector>\nusing namespace std;\n\nint sum_squares(vector<float> lst) {\n    int sum = 0; // Initialize sum to 0\n    for (float num : lst) { // Iterate through each number in the vector\n        int rounded = ceil(num); // Round up to the nearest integer\n        sum += rounded * rounded; // Square the rounded number and add to sum\n    }\n    return sum; // Return the final sum\n}\n"}
{"task_id": "CPP/134", "generation": "#include <iostream>\n#include <string>\n#include <cctype> // for isalpha\nusing namespace std;\n\nbool check_if_last_char_is_a_letter(string txt) {\n    // Trim trailing spaces\n    size_t end = txt.find_last_not_of(' ');\n    if (end == string::npos) {\n        return false; // String is empty after trimming\n    }\n    txt = txt.substr(0, end + 1); // Trimmed string\n\n    // Check if the last character is an alphabetical character\n    char lastChar = txt[txt.size() - 1];\n    if (!isalpha(lastChar)) {\n        return false; // Last character is not alphabetical\n    }\n\n    // Check if the last character is part of a word\n    if (txt.size() > 1 && txt[txt.size() - 2] != ' ') {\n        return false; // Last character is part of a word\n    }\n\n    return true; // Last character is an alphabetical character and not part of a word\n}\n\n// Example usage\n"}
{"task_id": "CPP/135", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nint can_arrange(vector<int> arr) {\n    int largest_index = -1; // Initialize to -1\n    for (int i = 1; i < arr.size(); i++) { // Start from the second element\n        if (arr[i] < arr[i - 1]) { // Check if current element is less than the previous one\n            largest_index = i; // Update the largest index\n        }\n    }\n    return largest_index; // Return the result\n}\n"}
{"task_id": "CPP/136", "generation": "#include <stdio.h>\n#include <vector>\n#include <limits.h> // For INT_MIN and INT_MAX\nusing namespace std;\n\nvector<int> largest_smallest_integers(vector<int> lst) {\n    int largest_negative = INT_MIN; // Start with the smallest possible integer\n    int smallest_positive = INT_MAX; // Start with the largest possible integer\n\n    for (int number : lst) {\n        if (number < 0) {\n            if (number > largest_negative) {\n                largest_negative = number; // Update largest negative\n            }\n        } else if (number > 0) {\n            if (number < smallest_positive) {\n                smallest_positive = number; // Update smallest positive\n            }\n        }\n    }\n\n    // Check if we found any valid negative or positive integers\n    if (largest_negative == INT_MIN) {\n        largest_negative = 0; // No negative found\n    }\n    if (smallest_positive == INT_MAX) {\n        smallest_positive = 0; // No positive found\n    }\n\n    return {largest_negative, smallest_positive};\n}\n"}
{"task_id": "CPP/137", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <boost/any.hpp>\n\nusing namespace std;\n\nboost::any compare_one(boost::any a, boost::any b) {\n    float valueA, valueB;\n\n    // Function to convert boost::any to float\n    auto to_float = [](boost::any value) -> float {\n        if (value.type() == typeid(int)) {\n            return boost::any_cast<int>(value);\n        } else if (value.type() == typeid(float)) {\n            return boost::any_cast<float>(value);\n        } else if (value.type() == typeid(string)) {\n            string strValue = boost::any_cast<string>(value);\n            replace(strValue.begin(), strValue.end(), ',', '.'); // Replace ',' with '.'\n            return stof(strValue); // Convert string to float\n        }\n        throw invalid_argument(\"Unsupported type\");\n    };\n\n    // Convert both values to float\n    valueA = to_float(a);\n    valueB = to_float(b);\n\n    // Compare the float values\n    if (valueA == valueB) {\n        return \"None\";\n    } else if (valueA > valueB) {\n        return a; // Return original value of a\n    } else {\n        return b; // Return original value of b\n    }\n}\n\n// Example usage\n"}
{"task_id": "CPP/138", "generation": "#include<stdio.h>\nusing namespace std;\n\nbool is_equal_to_sum_even(int n) {\n    if (n < 8) {\n        return false;\n    }\n    if (n % 2 == 0) {\n        return true;\n    }\n    return false;\n}\n"}
{"task_id": "CPP/139", "generation": "#include <stdio.h>\n\nusing namespace std;\n\nlong long special_factorial(int n) {\n    long long result = 1; // To hold the final result\n    for (int i = 1; i <= n; i++) {\n        long long factorial = 1; // To calculate i!\n        for (int j = 1; j <= i; j++) {\n            factorial *= j; // Calculate factorial of i\n        }\n        result *= factorial; // Multiply the current factorial to the result\n    }\n    return result; // Return the final result\n}\n"}
{"task_id": "CPP/140", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nstring fix_spaces(string text) {\n    string result = \"\";\n    int spaceCount = 0;\n\n    for (char c : text) {\n        if (c == ' ') {\n            spaceCount++;\n        } else {\n            if (spaceCount > 0) {\n                if (spaceCount == 1) {\n                    result += '_'; // Replace single space with underscore\n                } else {\n                    result += '-'; // Replace multiple spaces with hyphen\n                }\n                spaceCount = 0; // Reset space count\n            }\n            result += c; // Append the current character\n        }\n    }\n\n    // Handle any trailing spaces at the end of the string\n    if (spaceCount > 0) {\n        if (spaceCount == 1) {\n            result += '_'; // Replace single space with underscore\n        } else {\n            result += '-'; // Replace multiple spaces with hyphen\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/141", "generation": "#include <stdio.h>\n#include <string>\n#include <cctype> // for isalpha\nusing namespace std;\n\nstring file_name_check(string file_name) {\n    int count_digits = 0;\n    int dot_count = 0;\n    size_t dot_position = file_name.find('.');\n\n    // Count digits and check for the dot\n    for (char c : file_name) {\n        if (isdigit(c)) {\n            count_digits++;\n        }\n        if (c == '.') {\n            dot_count++;\n        }\n    }\n\n    // Check conditions\n    if (count_digits > 3) {\n        return \"No\";\n    }\n    if (dot_count != 1) {\n        return \"No\";\n    }\n\n    // Split the file name into name and extension\n    string name_part = file_name.substr(0, dot_position);\n    string extension_part = file_name.substr(dot_position + 1);\n\n    // Check if name_part is empty or does not start with a letter\n    if (name_part.empty() || !isalpha(name_part[0])) {\n        return \"No\";\n    }\n\n    // Check if the extension is valid\n    if (extension_part != \"txt\" && extension_part != \"exe\" && extension_part != \"dll\") {\n        return \"No\";\n    }\n\n    return \"Yes\";\n}\n"}
{"task_id": "CPP/142", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nint sum_squares(vector<int> lst) {\n    int sum = 0; // Initialize sum to 0\n    for (int i = 0; i < lst.size(); i++) { // Loop through each index\n        if (i % 3 == 0) { // Check if index is a multiple of 3\n            lst[i] = lst[i] * lst[i]; // Square the element\n        } else if (i % 4 == 0) { // Check if index is a multiple of 4\n            lst[i] = lst[i] * lst[i] * lst[i]; // Cube the element\n        }\n        sum += lst[i]; // Add the modified element to sum\n    }\n    return sum; // Return the total sum\n}\n"}
{"task_id": "CPP/143", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i <= sqrt(n); i++) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\n// Function to filter words with prime lengths\nstring words_in_sentence(string sentence) {\n    stringstream ss(sentence);\n    string word;\n    vector<string> result;\n\n    // Split the sentence into words\n    while (ss >> word) {\n        // Check if the length of the word is prime\n        if (is_prime(word.length())) {\n            result.push_back(word);\n        }\n    }\n\n    // Join the result into a single string\n    string output;\n    for (size_t i = 0; i < result.size(); i++) {\n        output += result[i];\n        if (i < result.size() - 1) {\n            output += \" \"; // Add space between words\n        }\n    }\n\n    return output;\n}\n\n// Example usage\n"}
{"task_id": "CPP/144", "generation": "#include <stdio.h>\n#include <string>\n#include <sstream>\n#include <vector>\n\nusing namespace std;\n\nbool simplify(string x, string n) {\n    // Split the first fraction\n    size_t pos = x.find('/');\n    int numerator_x = stoi(x.substr(0, pos));\n    int denominator_x = stoi(x.substr(pos + 1));\n\n    // Split the second fraction\n    pos = n.find('/');\n    int numerator_n = stoi(n.substr(0, pos));\n    int denominator_n = stoi(n.substr(pos + 1));\n\n    // Calculate the products\n    int numerator_product = numerator_x * numerator_n;\n    int denominator_product = denominator_x * denominator_n;\n\n    // Check if the product is a whole number\n    return (numerator_product % denominator_product == 0);\n}\n"}
{"task_id": "CPP/145", "generation": "#include <vector>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\n// Function to calculate the sum of digits\nint digit_sum(int n) {\n    int sum = 0;\n    bool is_negative = (n < 0);\n    n = abs(n);\n    \n    while (n > 0) {\n        sum += n % 10;\n        n /= 10;\n    }\n    \n    if (is_negative) {\n        sum = -sum; // If the number was negative, make the sum negative\n    }\n    \n    return sum;\n}\n\n// Main function to order by points\nvector<int> order_by_points(vector<int> nums) {\n    stable_sort(nums.begin(), nums.end(), [](int a, int b) {\n        return digit_sum(a) < digit_sum(b);\n    });\n    return nums;\n}\n"}
{"task_id": "CPP/146", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nint specialFilter(vector<int> nums) {\n    int count = 0;\n    for (int number : nums) {\n        if (number > 10) {\n            string numStr = to_string(number);\n            char first_digit = numStr[0];\n            int last_digit = number % 10;\n\n            // Check if both first and last digits are odd\n            if ((first_digit == '1' || first_digit == '3' || first_digit == '5' || first_digit == '7' || first_digit == '9') &&\n                (last_digit % 2 != 0)) {\n                count++;\n            }\n        }\n    }\n    return count;\n}\n"}
{"task_id": "CPP/147", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint get_max_triples(int n) {\n    vector<int> a(n);\n    for (int i = 1; i <= n; i++) {\n        a[i - 1] = i * i - i + 1; // Fill the vector using the given formula\n    }\n    \n    int count0 = 0, count1 = 0, count2 = 0;\n    \n    // Count occurrences of each modulo category\n    for (int value : a) {\n        if (value % 3 == 0) {\n            count0++;\n        } else if (value % 3 == 1) {\n            count1++;\n        } else {\n            count2++;\n        }\n    }\n    \n    int total_triples = 0;\n    \n    // Count combinations of (0, 0, 0)\n    if (count0 >= 3) {\n        total_triples += (count0 * (count0 - 1) * (count0 - 2)) / 6;\n    }\n    \n    // Count combinations of (1, 1, 1)\n    if (count1 >= 3) {\n        total_triples += (count1 * (count1 - 1) * (count1 - 2)) / 6;\n    }\n    \n    // Count combinations of (2, 2, 2)\n    if (count2 >= 3) {\n        total_triples += (count2 * (count2 - 1) * (count2 - 2)) / 6;\n    }\n    \n    // Count combinations of (0, 1, 2)\n    total_triples += count0 * count1 * count2;\n    \n    return total_triples;\n}\n"}
{"task_id": "CPP/148", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nvector<string> bf(string planet1, string planet2) {\n    vector<string> planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n    \n    // Check if planet1 and planet2 are valid\n    auto it1 = find(planets.begin(), planets.end(), planet1);\n    auto it2 = find(planets.begin(), planets.end(), planet2);\n    \n    if (it1 == planets.end() || it2 == planets.end()) {\n        return {}; // Return empty vector if either planet is invalid\n    }\n    \n    // Get the indices of the planets\n    int index1 = distance(planets.begin(), it1);\n    int index2 = distance(planets.begin(), it2);\n    \n    // Ensure index1 is less than index2\n    if (index1 > index2) {\n        swap(index1, index2);\n    }\n    \n    // Collect planets in between\n    vector<string> result;\n    for (int i = index1 + 1; i < index2; i++) {\n        result.push_back(planets[i]);\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/149", "generation": "#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nvector<string> sorted_list_sum(vector<string> lst) {\n    vector<string> filtered;\n\n    // Filter out strings with odd lengths\n    for (const string& str : lst) {\n        if (str.length() % 2 == 0) {\n            filtered.push_back(str);\n        }\n    }\n\n    // Sort the filtered vector\n    sort(filtered.begin(), filtered.end(), [](const string& a, const string& b) {\n        if (a.length() != b.length()) {\n            return a.length() < b.length(); // Sort by length\n        }\n        return a < b; // Sort alphabetically if lengths are equal\n    });\n\n    return filtered;\n}\n"}
{"task_id": "CPP/150", "generation": "#include <stdio.h>\n#include <cmath> // For sqrt function\nusing namespace std;\n\nint x_or_y(int n, int x, int y) {\n    if (n <= 1) {\n        return y; // Not prime\n    }\n    for (int i = 2; i <= sqrt(n); i++) {\n        if (n % i == 0) {\n            return y; // Not prime\n        }\n    }\n    return x; // Prime\n}\n"}
{"task_id": "CPP/151", "generation": "#include <vector>\n#include <cmath>\nusing namespace std;\n\nlong long double_the_difference(vector<float> lst) {\n    long long sum_of_squares = 0; // To hold the sum of squares\n    if (lst.empty()) {\n        return 0; // Return 0 if the input vector is empty\n    }\n    \n    for (float number : lst) {\n        // Check if the number is a non-negative integer and odd\n        if (number >= 0 && floor(number) == number && static_cast<int>(number) % 2 != 0) {\n            sum_of_squares += static_cast<int>(number) * static_cast<int>(number); // Add the square of the number\n        }\n    }\n    \n    return sum_of_squares; // Return the final sum\n}\n"}
{"task_id": "CPP/152", "generation": "#include <vector>\n#include <cmath> // for abs function\nusing namespace std;\n\nvector<int> compare(vector<int> game, vector<int> guess) {\n    vector<int> result; // Initialize the result vector\n    for (size_t i = 0; i < game.size(); i++) { // Loop through each match\n        int difference = abs(game[i] - guess[i]); // Calculate the absolute difference\n        result.push_back(difference); // Append the difference to the result vector\n    }\n    return result; // Return the result vector\n}\n"}
{"task_id": "CPP/153", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <cctype> // for isupper and islower\nusing namespace std;\n\nstring Strongest_Extension(string class_name, vector<string> extensions) {\n    int max_strength = -1e9; // Initialize to a very low value\n    string strongest_extension = \"\";\n\n    for (const string& extension : extensions) {\n        int CAP = 0, SM = 0;\n\n        // Count uppercase and lowercase letters\n        for (char c : extension) {\n            if (isupper(c)) {\n                CAP++;\n            } else if (islower(c)) {\n                SM++;\n            }\n        }\n\n        // Calculate strength\n        int strength = CAP - SM;\n\n        // Update strongest extension if current one is stronger\n        if (strength > max_strength) {\n            max_strength = strength;\n            strongest_extension = extension;\n        }\n    }\n\n    // Return the formatted result\n    return class_name + \".\" + strongest_extension;\n}\n"}
{"task_id": "CPP/154", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nbool cycpattern_check(string a, string b) {\n    // Concatenate b with itself\n    string b_rotated = b + b;\n    // Check if a is a substring of b_rotated\n    return b_rotated.find(a) != string::npos;\n}\n"}
{"task_id": "CPP/155", "generation": "#include <stdio.h>\n#include <string>\n#include <vector>\n#include <cstdlib> // for abs\nusing namespace std;\n\nvector<int> even_odd_count(int num) {\n    vector<int> counts(2, 0); // counts[0] for even, counts[1] for odd\n    num = abs(num); // Take the absolute value of the number\n    string numStr = to_string(num); // Convert the number to a string\n\n    for (char digit : numStr) {\n        int digitValue = digit - '0'; // Convert character to integer\n        if (digitValue % 2 == 0) {\n            counts[0]++; // Increment even count\n        } else {\n            counts[1]++; // Increment odd count\n        }\n    }\n    \n    return counts; // Return the counts\n}\n"}
{"task_id": "CPP/156", "generation": "#include <string>\n#include <vector>\nusing namespace std;\n\nstring int_to_mini_roman(int number) {\n    // Define the Roman numeral mappings\n    vector<pair<int, string>> romanMappings = {\n        {1000, \"m\"}, {900, \"cm\"}, {500, \"d\"}, {400, \"cd\"},\n        {100, \"c\"}, {90, \"xc\"}, {50, \"l\"}, {40, \"xl\"},\n        {10, \"x\"}, {9, \"ix\"}, {5, \"v\"}, {4, \"iv\"},\n        {1, \"i\"}\n    };\n    \n    string result = \"\";\n    \n    // Iterate through the mappings\n    for (const auto& mapping : romanMappings) {\n        while (number >= mapping.first) {\n            result += mapping.second; // Append the Roman numeral\n            number -= mapping.first;   // Decrease the number\n        }\n    }\n    \n    return result; // Return the result in lowercase\n}\n"}
{"task_id": "CPP/157", "generation": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n\nbool right_angle_triangle(float a, float b, float c) {\n    // Identify the longest side\n    float longest = max(a, max(b, c));\n    float side1, side2;\n\n    // Assign the other two sides\n    if (longest == a) {\n        side1 = b;\n        side2 = c;\n    } else if (longest == b) {\n        side1 = a;\n        side2 = c;\n    } else {\n        side1 = a;\n        side2 = b;\n    }\n\n    // Check the Pythagorean theorem\n    return (pow(side1, 2) + pow(side2, 2) == pow(longest, 2));\n}\n"}
{"task_id": "CPP/158", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <set>\n#include <algorithm>\nusing namespace std;\n\nstring find_max(vector<string> words) {\n    string maxWord = \"\";\n    int maxUniqueCount = 0;\n\n    for (const string& word : words) {\n        set<char> uniqueChars(word.begin(), word.end());\n        int uniqueCount = uniqueChars.size();\n\n        if (uniqueCount > maxUniqueCount || \n            (uniqueCount == maxUniqueCount && word < maxWord)) {\n            maxUniqueCount = uniqueCount;\n            maxWord = word;\n        }\n    }\n    \n    return maxWord;\n}\n"}
{"task_id": "CPP/159", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nvector<int> eat(int number, int need, int remaining) {\n    int total_eaten;\n    int remaining_after;\n\n    if (remaining >= need) {\n        total_eaten = number + need;\n        remaining_after = remaining - need;\n    } else {\n        total_eaten = number + remaining;\n        remaining_after = 0;\n    }\n\n    return {total_eaten, remaining_after};\n}\n"}
{"task_id": "CPP/160", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath> // For pow function\nusing namespace std;\n\nint do_algebra(vector<string> operato, vector<int> operand) {\n    int result = operand[0];\n    for (size_t i = 0; i < operato.size(); i++) {\n        if (operato[i] == \"**\") {\n            result = pow(result, operand[i + 1]); // Exponentiation\n        } else {\n            int temp_result = operand[i + 1];\n            if (operato[i] == \"*\") {\n                result *= temp_result; // Multiplication\n            } else if (operato[i] == \"//\") {\n                result /= temp_result; // Floor division\n            } else if (operato[i] == \"+\") {\n                result += temp_result; // Addition\n            } else if (operato[i] == \"-\") {\n                result -= temp_result; // Subtraction\n            }\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/161", "generation": "#include <stdio.h>\n#include <string>\n#include <cctype> // for isalpha, toupper, tolower\nusing namespace std;\n\nstring solve(string s) {\n    string result = \"\";\n    bool hasLetter = false;\n\n    for (char c : s) {\n        if (isalpha(c)) {\n            hasLetter = true;\n            // Reverse case\n            if (islower(c)) {\n                result += toupper(c);\n            } else {\n                result += tolower(c);\n            }\n        } else {\n            result += c; // Keep the character as it is\n        }\n    }\n\n    // If no letters were found, reverse the original string\n    if (!hasLetter) {\n        reverse(s.begin(), s.end());\n        return s;\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/162", "generation": "#include <stdio.h>\n#include <string>\n#include <openssl/md5.h>\nusing namespace std;\n\nstring string_to_md5(string text) {\n    if (text.empty()) {\n        return \"\"; // Returning empty string to represent None\n    }\n\n    unsigned char digest[MD5_DIGEST_LENGTH];\n    MD5((unsigned char*)text.c_str(), text.length(), digest);\n\n    char md5String[33]; // 32 characters + null terminator\n    for (int i = 0; i < 16; i++) {\n        sprintf(&md5String[i * 2], \"%02x\", (unsigned int)digest[i]);\n    }\n    return string(md5String);\n}\n"}
{"task_id": "CPP/163", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm> // for std::min and std::max\nusing namespace std;\n\nvector<int> generate_integers(int a, int b) {\n    vector<int> result;\n    int min_val = min(a, b);\n    int max_val = max(a, b);\n    \n    for (int i = min_val; i <= max_val; i++) {\n        if (i % 2 == 0 && i < 10) { // Check if it's an even digit\n            result.push_back(i);\n        }\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/0", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\nbool has_close_elements(vector<float> numbers, float threshold) {\n    // Sort the numbers\n    sort(numbers.begin(), numbers.end());\n    \n    // Check adjacent elements\n    for (size_t i = 0; i < numbers.size() - 1; i++) {\n        if (fabs(numbers[i + 1] - numbers[i]) < threshold) {\n            return true; // Found two numbers closer than threshold\n        }\n    }\n    \n    return false; // No such pair found\n}\n"}
{"task_id": "CPP/1", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nvector<string> separate_paren_groups(string paren_string) {\n    // Remove spaces from the input string\n    paren_string.erase(remove(paren_string.begin(), paren_string.end(), ' '), paren_string.end());\n\n    vector<string> result;\n    string current_group;\n    int balance = 0;\n\n    for (char ch : paren_string) {\n        if (ch == '(') {\n            if (balance == 0) {\n                current_group = \"\";  // Start a new group\n            }\n            current_group += ch;\n            balance++;\n        } else if (ch == ')') {\n            current_group += ch;\n            balance--;\n            if (balance == 0) {\n                result.push_back(current_group);  // Add the completed group to the result\n                current_group = \"\";  // Reset for the next group\n            }\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/2", "generation": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n\nfloat truncate_number(float number) {\n    // Get the integer part of the number\n    int integer_part = floor(number);\n    // Calculate the decimal part\n    float decimal_part = number - integer_part;\n    // Return the decimal part\n    return decimal_part;\n}\n"}
{"task_id": "CPP/3", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nbool below_zero(vector<int> operations) {\n    int balance = 0; // Initialize balance to zero\n    for (int operation : operations) {\n        balance += operation; // Update balance with the current operation\n        if (balance < 0) { // Check if balance goes below zero\n            return true; // Return true if balance is below zero\n        }\n    }\n    return false; // Return false if balance never goes below zero\n}\n"}
{"task_id": "CPP/4", "generation": "#include <stdio.h>\n#include <math.h>\n#include <vector>\nusing namespace std;\n\nfloat mean_absolute_deviation(vector<float> numbers) {\n    float sum = 0.0;\n    int n = numbers.size();\n\n    // Step 1: Calculate the mean\n    for (float number : numbers) {\n        sum += number;\n    }\n    float mean = sum / n;\n\n    // Step 2: Calculate the Mean Absolute Deviation\n    float mad_sum = 0.0;\n    for (float number : numbers) {\n        mad_sum += fabs(number - mean);\n    }\n\n    // Step 3: Calculate the final Mean Absolute Deviation\n    float mad = mad_sum / n;\n    return mad;\n}\n"}
{"task_id": "CPP/5", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nvector<int> intersperse(vector<int> numbers, int delimeter) { \n    vector<int> result; // Initialize an empty result vector\n    if (numbers.empty()) { // Check if the input vector is empty\n        return result; // Return empty vector\n    }\n    \n    for (size_t i = 0; i < numbers.size(); ++i) { // Loop through the input vector\n        result.push_back(numbers[i]); // Add the current element to the result\n        if (i < numbers.size() - 1) { // If it's not the last element\n            result.push_back(delimeter); // Add the delimiter\n        }\n    }\n    \n    return result; // Return the result vector\n}\n"}
{"task_id": "CPP/6", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <sstream>\nusing namespace std;\n\nvector<int> parse_nested_parens(string paren_string) {\n    vector<int> result;\n    stringstream ss(paren_string);\n    string group;\n\n    while (ss >> group) {\n        int max_depth = 0;\n        int current_depth = 0;\n\n        for (char ch : group) {\n            if (ch == '(') {\n                current_depth++;\n                if (current_depth > max_depth) {\n                    max_depth = current_depth;\n                }\n            } else if (ch == ')') {\n                current_depth--;\n            }\n        }\n        result.push_back(max_depth);\n    }\n    return result;\n}\n"}
{"task_id": "CPP/7", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> filter_by_substring(vector<string> strings, string substring) {\n    vector<string> result; // Initialize an empty vector for results\n    for (const string& str : strings) { // Loop through each string in the input vector\n        if (str.find(substring) != string::npos) { // Check if substring is found\n            result.push_back(str); // Add the string to the results vector\n        }\n    }\n    return result; // Return the filtered results\n}\n"}
{"task_id": "CPP/8", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> sum_product(vector<int> numbers) {\n    // Initialize sum and product\n    int sum = 0;\n    int product = 1;\n\n    // Check if the vector is empty\n    if (numbers.empty()) {\n        return {0, 1}; // Return (0, 1) for empty vector\n    }\n\n    // Calculate sum and product\n    for (int number : numbers) {\n        sum += number;      // Add to sum\n        product *= number;  // Multiply to product\n    }\n\n    return {sum, product}; // Return the results as a vector\n}\n"}
{"task_id": "CPP/9", "generation": "#include <stdio.h>\n#include <vector>\n#include <limits.h> // for INT_MIN\nusing namespace std;\n\nvector<int> rolling_max(vector<int> numbers) {\n    vector<int> result; // to store the rolling maximums\n    int current_max = INT_MIN; // initialize current_max to the smallest integer\n\n    for (int number : numbers) {\n        if (number > current_max) {\n            current_max = number; // update current_max if the current number is greater\n        }\n        result.push_back(current_max); // append the current maximum to the result\n    }\n\n    return result; // return the result vector\n}\n"}
{"task_id": "CPP/10", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nbool is_palindrome(string str) {\n    string s(str.rbegin(), str.rend());\n    return s == str;\n}\n\nstring make_palindrome(string str) {\n    int n = str.length();\n    int i;\n    \n    // Find the longest palindromic suffix\n    for (i = n; i >= 0; --i) {\n        if (is_palindrome(str.substr(i))) {\n            break;\n        }\n    }\n    \n    // Create the prefix that needs to be reversed\n    string prefix = str.substr(0, i);\n    string reversed_prefix(prefix.rbegin(), prefix.rend());\n    \n    // Concatenate the original string with the reversed prefix\n    return str + reversed_prefix;\n}\n"}
{"task_id": "CPP/11", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nstring string_xor(string a, string b) {\n    string result = \"\";\n    for (int i = 0; i < a.length(); i++) {\n        if (a[i] == b[i]) {\n            result += \"0\";\n        } else {\n            result += \"1\";\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/12", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring longest(vector<string> strings) {\n    if (strings.empty()) {\n        return \"None\"; // Return \"None\" if the vector is empty\n    }\n    \n    string longestString = strings[0]; // Initialize with the first string\n    for (const string& str : strings) {\n        if (str.length() > longestString.length()) {\n            longestString = str; // Update longest string if current is longer\n        }\n    }\n    \n    return longestString; // Return the longest string found\n}\n"}
{"task_id": "CPP/13", "generation": "#include<stdio.h>\nusing namespace std;\n\nint greatest_common_divisor(int a, int b) {\n    while (b != 0) {\n        int temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n"}
{"task_id": "CPP/14", "generation": "#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> all_prefixes(string str) {\n    vector<string> prefixes;\n    for (int i = 0; i < str.length(); i++) {\n        prefixes.push_back(str.substr(0, i + 1));\n    }\n    return prefixes;\n}\n"}
{"task_id": "CPP/15", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nstring string_sequence(int n) {\n    string result = \"\";\n    for (int i = 0; i <= n; i++) {\n        if (i != 0) {\n            result += \" \"; // Add space before the number if it's not the first number\n        }\n        result += to_string(i); // Convert integer to string and append\n    }\n    return result; // Return the final string\n}\n"}
{"task_id": "CPP/16", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <set>\n#include <algorithm>\nusing namespace std;\n\nint count_distinct_characters(string str) {\n    set<char> distinctChars; // Set to store distinct characters\n    // Convert the string to lowercase and add to the set\n    for (char c : str) {\n        distinctChars.insert(tolower(c)); // Insert lowercase character into the set\n    }\n    return distinctChars.size(); // Return the size of the set\n}\n"}
{"task_id": "CPP/17", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nvector<int> parse_music(string music_string) {\n    vector<int> beats;\n    stringstream ss(music_string);\n    string note;\n\n    while (ss >> note) {\n        if (note == \"o\") {\n            beats.push_back(4);\n        } else if (note == \"o|\") {\n            beats.push_back(2);\n        } else if (note == \".|\") {\n            beats.push_back(1);\n        }\n    }\n    \n    return beats;\n}\n"}
{"task_id": "CPP/18", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nint how_many_times(string str, string substring) {\n    // Step 1: Input validation\n    if (substring.empty()) {\n        return 0;\n    }\n    \n    int count = 0;\n    int length_of_substring = substring.length();\n    int length_of_str = str.length();\n    \n    // Step 3: Loop through the string\n    for (int i = 0; i <= length_of_str - length_of_substring; i++) {\n        // Step 4: Check for a match\n        if (str.substr(i, length_of_substring) == substring) {\n            count++;\n        }\n    }\n    \n    // Step 5: Return the count\n    return count;\n}\n"}
{"task_id": "CPP/19", "generation": "#include <iostream>\n#include <string>\n#include <map>\n#include <vector>\n#include <sstream>\n#include <algorithm>\n\nusing namespace std;\n\nstring sort_numbers(string numbers) {\n    // Step 1: Create a mapping from words to their corresponding integer values\n    map<string, int> wordToNumber = {\n        {\"zero\", 0}, {\"one\", 1}, {\"two\", 2}, {\"three\", 3},\n        {\"four\", 4}, {\"five\", 5}, {\"six\", 6}, {\"seven\", 7},\n        {\"eight\", 8}, {\"nine\", 9}\n    };\n\n    // Step 2: Split the input string into words\n    stringstream ss(numbers);\n    vector<string> words;\n    string word;\n    while (ss >> word) {\n        words.push_back(word);\n    }\n\n    // Step 3: Sort the words based on their numerical values\n    sort(words.begin(), words.end(), [&](const string &a, const string &b) {\n        return wordToNumber[a] < wordToNumber[b];\n    });\n\n    // Step 4: Join the sorted words into a single output string\n    string result;\n    for (const string &w : words) {\n        if (!result.empty()) {\n            result += \" \";\n        }\n        result += w;\n    }\n\n    // Step 5: Return the output string\n    return result;\n}\n"}
{"task_id": "CPP/20", "generation": "#include <vector>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\nvector<float> find_closest_elements(vector<float> numbers) {\n    // Sort the numbers\n    sort(numbers.begin(), numbers.end());\n    \n    float min_diff = numeric_limits<float>::infinity(); // Initialize min_diff to a large value\n    vector<float> closest_pair; // To store the closest pair\n\n    // Iterate through the sorted numbers\n    for (size_t i = 0; i < numbers.size() - 1; ++i) {\n        float current_diff = abs(numbers[i] - numbers[i + 1]);\n        // Check if the current difference is smaller than the minimum difference found so far\n        if (current_diff < min_diff) {\n            min_diff = current_diff; // Update min_diff\n            closest_pair = {numbers[i], numbers[i + 1]}; // Update closest pair\n        }\n    }\n\n    return closest_pair; // Return the closest pair\n}\n"}
{"task_id": "CPP/21", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<float> rescale_to_unit(vector<float> numbers) {\n    // Find the minimum and maximum values in the vector\n    float min_value = *min_element(numbers.begin(), numbers.end());\n    float max_value = *max_element(numbers.begin(), numbers.end());\n    \n    vector<float> result;\n    \n    // Apply the linear transformation\n    for (float number : numbers) {\n        float transformed_value = (number - min_value) / (max_value - min_value);\n        result.push_back(transformed_value);\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/22", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <boost/any.hpp>\n#include <list>\n#include <iostream>\n\ntypedef std::list<boost::any> list_any;\nusing namespace std;\n\nvector<int> filter_integers(list_any values) {\n    vector<int> result; // Vector to store the filtered integers\n    for (const auto& value : values) { // Iterate through each element in the list\n        if (value.type() == typeid(int)) { // Check if the type is int\n            result.push_back(boost::any_cast<int>(value)); // Cast and add to the result\n        }\n    }\n    return result; // Return the vector of integers\n}\n\n// Example usage\n"}
{"task_id": "CPP/23", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nint strlen(string str) {\n    return str.length(); // or str.size();\n}\n"}
{"task_id": "CPP/24", "generation": "#include<stdio.h>\nusing namespace std;\n\nint largest_divisor(int n) {\n    for (int i = n - 1; i >= 1; i--) {\n        if (n % i == 0) {\n            return i; // Return the largest divisor found\n        }\n    }\n    return 1; // This case is for n = 1, where the only divisor is 1\n}\n"}
{"task_id": "CPP/25", "generation": "#include <stdio.h>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\nvector<int> factorize(int n) {\n    vector<int> factors;\n    \n    // Check for number of 2s that divide n\n    while (n % 2 == 0) {\n        factors.push_back(2);\n        n /= 2;\n    }\n    \n    // n must be odd at this point, so we can skip even numbers\n    for (int i = 3; i <= sqrt(n); i += 2) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n    \n    // This condition is to check if n is a prime number greater than 2\n    if (n > 2) {\n        factors.push_back(n);\n    }\n    \n    return factors;\n}\n"}
{"task_id": "CPP/26", "generation": "#include <stdio.h>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nvector<int> remove_duplicates(vector<int> numbers) {\n    unordered_map<int, int> countMap;\n    \n    // Count occurrences of each number\n    for (int num : numbers) {\n        countMap[num]++;\n    }\n    \n    vector<int> result;\n    \n    // Filter numbers that occur exactly once\n    for (int num : numbers) {\n        if (countMap[num] == 1) {\n            result.push_back(num);\n        }\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/27", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nstring flip_case(string str) {\n    string result = \"\"; // Initialize an empty string for the result\n    for (char c : str) { // Loop through each character in the input string\n        if (islower(c)) { // Check if the character is lowercase\n            result += toupper(c); // Convert to uppercase and append to result\n        } else if (isupper(c)) { // Check if the character is uppercase\n            result += tolower(c); // Convert to lowercase and append to result\n        } else {\n            result += c; // Append unchanged character (like digits or symbols)\n        }\n    }\n    return result; // Return the final result string\n}\n"}
{"task_id": "CPP/28", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring concatenate(vector<string> strings) {\n    string result = \"\"; // Initialize an empty string\n    for (const string& str : strings) { // Loop through each string in the vector\n        result += str; // Concatenate the string to the result\n    }\n    return result; // Return the final concatenated string\n}\n"}
{"task_id": "CPP/29", "generation": "#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> filter_by_prefix(vector<string> strings, string prefix) {\n    vector<string> result; // Vector to store filtered results\n    for (const string& str : strings) { // Iterate through each string\n        if (str.find(prefix) == 0) { // Check if the string starts with the prefix\n            result.push_back(str); // Add to result if it matches\n        }\n    }\n    return result; // Return the filtered results\n}\n"}
{"task_id": "CPP/30", "generation": "#include <vector>\nusing namespace std;\n\nvector<float> get_positive(vector<float> l) {\n    vector<float> out; // Create an empty vector to store positive numbers\n    for (float number : l) { // Iterate through each number in the input vector\n        if (number > 0) { // Check if the number is positive\n            out.push_back(number); // Add the positive number to the output vector\n        }\n    }\n    return out; // Return the vector containing only positive numbers\n}\n"}
{"task_id": "CPP/31", "generation": "#include <stdio.h>\n#include <cmath>\n\nusing namespace std;\n\nbool is_prime(long long n) {\n    // Handle special cases\n    if (n < 2) return false; // Numbers less than 2 are not prime\n    if (n == 2) return true;  // 2 is prime\n    if (n % 2 == 0) return false; // Exclude all even numbers greater than 2\n\n    // Check for factors from 3 to sqrt(n)\n    for (long long i = 3; i <= sqrt(n); i += 2) {\n        if (n % i == 0) {\n            return false; // Found a divisor, not prime\n        }\n    }\n    return true; // No divisors found, n is prime\n}\n"}
{"task_id": "CPP/32", "generation": "#include <stdio.h>\n#include <math.h>\n#include <vector>\nusing namespace std;\n\ndouble poly(vector<double> xs, double x) {\n    double sum = 0;\n    for (int i = 0; i < xs.size(); i++) {\n        sum += xs[i] * pow(x, i);\n    }\n    return sum;\n}\n\ndouble find_zero(vector<double> xs) {\n    double lower = -10.0; // Starting lower bound\n    double upper = 10.0;  // Starting upper bound\n    double epsilon = 1e-7; // Precision for the zero finding\n    double mid;\n\n    while (upper - lower > epsilon) {\n        mid = (lower + upper) / 2.0;\n        double f_mid = poly(xs, mid);\n\n        if (fabs(f_mid) < epsilon) {\n            return mid; // Found a zero\n        } else if (poly(xs, lower) * f_mid < 0) {\n            upper = mid; // Zero is in the left half\n        } else {\n            lower = mid; // Zero is in the right half\n        }\n    }\n    return mid; // Return the midpoint as the zero\n}\n"}
{"task_id": "CPP/33", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> sort_third(vector<int> l) {\n    vector<int> divisibleByThreeValues;\n\n    // Collect values at indices divisible by 3\n    for (int i = 0; i < l.size(); i++) {\n        if (i % 3 == 0) {\n            divisibleByThreeValues.push_back(l[i]);\n        }\n    }\n\n    // Sort the collected values\n    sort(divisibleByThreeValues.begin(), divisibleByThreeValues.end());\n\n    vector<int> output(l.size());\n    int sortedIndex = 0;\n\n    // Fill the output vector\n    for (int i = 0; i < l.size(); i++) {\n        if (i % 3 == 0) {\n            output[i] = divisibleByThreeValues[sortedIndex];\n            sortedIndex++;\n        } else {\n            output[i] = l[i];\n        }\n    }\n\n    return output;\n}\n"}
{"task_id": "CPP/34", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\n#include <set>\nusing namespace std;\n\nvector<int> unique(vector<int> l) {\n    // Step 1: Use a set to store unique elements\n    set<int> uniqueElements(l.begin(), l.end());\n    \n    // Step 2: Convert the set back to a vector\n    vector<int> result(uniqueElements.begin(), uniqueElements.end());\n    \n    // Step 3: Sort the vector (set is already sorted, but we ensure it)\n    sort(result.begin(), result.end());\n    \n    // Step 4: Return the sorted unique elements\n    return result;\n}\n"}
{"task_id": "CPP/35", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nfloat max_element(vector<float> l) {\n    // Check if the vector is empty\n    if (l.empty()) {\n        throw std::invalid_argument(\"Vector is empty\");\n    }\n    \n    // Initialize maxValue with the first element\n    float maxValue = l[0];\n    \n    // Iterate through the vector to find the maximum\n    for (size_t i = 1; i < l.size(); i++) {\n        if (l[i] > maxValue) {\n            maxValue = l[i];\n        }\n    }\n    \n    return maxValue;\n}\n"}
{"task_id": "CPP/36", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint fizz_buzz(int n) {\n    int count = 0;\n    for (int i = 0; i < n; i++) {\n        if (i % 11 == 0 || i % 13 == 0) {\n            // Convert integer to string to count '7's\n            string numStr = to_string(i);\n            for (char c : numStr) {\n                if (c == '7') {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}\n"}
{"task_id": "CPP/37", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<float> sort_even(vector<float> l) {\n    vector<float> even_values;\n    \n    // Extract even indexed values\n    for (int i = 0; i < l.size(); i += 2) {\n        even_values.push_back(l[i]);\n    }\n    \n    // Sort the even indexed values\n    sort(even_values.begin(), even_values.end());\n    \n    vector<float> result(l.size());\n    \n    // Fill the result vector\n    int even_index = 0;\n    for (int i = 0; i < l.size(); i++) {\n        if (i % 2 == 0) {\n            result[i] = even_values[even_index++];\n        } else {\n            result[i] = l[i];\n        }\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/38", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nstring decode_cyclic(string s) {\n    string output = \"\";\n    int length = s.length();\n    \n    for (int i = 0; i < length; i += 3) {\n        string group = s.substr(i, 3);\n        if (group.length() == 3) {\n            // Rotate back: last character + first two characters\n            output += group[2]; // last character\n            output += group[0]; // first character\n            output += group[1]; // second character\n        } else {\n            // If less than 3 characters, just append as is\n            output += group;\n        }\n    }\n    \n    return output;\n}\n"}
{"task_id": "CPP/39", "generation": "#include <iostream>\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    for (int i = 2; i * i <= num; i++) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\n// Function to find the n-th prime Fibonacci number\nint prime_fib(int n) {\n    int a = 0, b = 1; // Starting values for Fibonacci sequence\n    int count = 0; // Count of prime Fibonacci numbers\n    int prime_fib_num = 0; // To store the n-th prime Fibonacci number\n\n    while (count < n) {\n        int next_fib = a + b; // Generate the next Fibonacci number\n        a = b; // Move to the next Fibonacci number\n        b = next_fib;\n\n        // Check if the Fibonacci number is prime\n        if (is_prime(next_fib)) {\n            count++; // Increment the count of prime Fibonacci numbers\n            prime_fib_num = next_fib; // Update the last found prime Fibonacci number\n        }\n    }\n    return prime_fib_num; // Return the n-th prime Fibonacci number\n}\n"}
{"task_id": "CPP/40", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nbool triples_sum_to_zero(vector<int> l) {\n    sort(l.begin(), l.end());\n    int n = l.size();\n    \n    for (int i = 0; i < n - 2; i++) {\n        int left = i + 1;\n        int right = n - 1;\n        \n        while (left < right) {\n            int sum = l[i] + l[left] + l[right];\n            if (sum == 0) {\n                return true;\n            } else if (sum < 0) {\n                left++;\n            } else {\n                right--;\n            }\n        }\n    }\n    return false;\n}\n"}
{"task_id": "CPP/41", "generation": "#include<stdio.h>\nusing namespace std;\n\nint car_race_collision(int n) {\n    return n * n; // Each car from the left collides with each car from the right\n}\n"}
{"task_id": "CPP/42", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nvector<int> incr_vector(vector<int> l) {\n    vector<int> result; // Create an empty vector to store the results\n    for (int i = 0; i < l.size(); i++) { // Iterate through each element in the input vector\n        result.push_back(l[i] + 1); // Increment the element by 1 and add it to the result vector\n    }\n    return result; // Return the result vector\n}\n"}
{"task_id": "CPP/43", "generation": "#include <stdio.h>\n#include <vector>\n#include <unordered_set>\nusing namespace std;\n\nbool pairs_sum_to_zero(vector<int> l) {\n    unordered_set<int> seen; // Set to store the numbers we have seen\n    for (int number : l) {\n        if (seen.find(-number) != seen.end()) {\n            return true; // Found a pair that sums to zero\n        }\n        seen.insert(number); // Add the current number to the set\n    }\n    return false; // No pairs found that sum to zero\n}\n"}
{"task_id": "CPP/44", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nstring change_base(int x, int base) {\n    if (x == 0) {\n        return \"0\";\n    }\n    \n    string result = \"\";\n    while (x > 0) {\n        int remainder = x % base;\n        result = to_string(remainder) + result; // prepend the remainder\n        x = x / base; // integer division\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/45", "generation": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n\nfloat triangle_area(float a, float h) {\n    return (0.5 * a * h);\n}\n"}
{"task_id": "CPP/46", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint fib4(int n) {\n    if (n == 0) return 0;\n    if (n == 1) return 0;\n    if (n == 2) return 2;\n    if (n == 3) return 0;\n\n    vector<int> fib(n + 1);\n    fib[0] = 0;\n    fib[1] = 0;\n    fib[2] = 2;\n    fib[3] = 0;\n\n    for (int i = 4; i <= n; i++) {\n        fib[i] = fib[i - 1] + fib[i - 2] + fib[i - 3] + fib[i - 4];\n    }\n\n    return fib[n];\n}\n"}
{"task_id": "CPP/47", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nfloat median(vector<float> l) {\n    // Step 1: Sort the vector\n    sort(l.begin(), l.end());\n    \n    // Step 2: Determine the size of the vector\n    int n = l.size();\n    \n    // Step 3: Calculate the median\n    if (n % 2 == 1) {\n        // If odd, return the middle element\n        return l[n / 2];\n    } else {\n        // If even, return the average of the two middle elements\n        return (l[n / 2 - 1] + l[n / 2]) / 2.0;\n    }\n}\n"}
{"task_id": "CPP/48", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nbool is_palindrome(string text) {\n    if (text.empty()) {\n        return true; // An empty string is a palindrome\n    }\n    \n    int left = 0;\n    int right = text.length() - 1;\n    \n    while (left < right) {\n        if (text[left] != text[right]) {\n            return false; // Characters do not match\n        }\n        left++;\n        right--;\n    }\n    \n    return true; // All characters matched\n}\n"}
{"task_id": "CPP/49", "generation": "#include<stdio.h>\nusing namespace std;\n\nint modp(int n, int p) {\n    if (p == 1) return 1; // Special case: any number mod 1 is 0, but we return 1 for this problem.\n    \n    long long result = 1; // Use long long to avoid overflow\n    long long base = 2 % p; // Base is 2 mod p\n    \n    while (n > 0) {\n        if (n % 2 == 1) { // If n is odd\n            result = (result * base) % p; // Multiply result by base and take mod p\n        }\n        n /= 2; // Divide n by 2\n        base = (base * base) % p; // Square the base and take mod p\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/50", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nstring encode_shift(string s) {\n    // returns encoded string by shifting every character by 5 in the alphabet.\n    string out;\n    for (int i = 0; i < s.length(); i++) {\n        int w = ((int)s[i] + 5 - (int)'a') % 26 + (int)'a';   \n        out = out + (char)w;\n    }\n    return out;\n}\n\nstring decode_shift(string s) {\n    // takes as input string encoded with encode_shift function. Returns decoded string.\n    string out;\n    for (int i = 0; i < s.length(); i++) {\n        int new_char = (int)s[i] - 5;\n        if (new_char < (int)'a') {\n            new_char += 26; // wrap around\n        }\n        out = out + (char)new_char;\n    }\n    return out;\n}\n"}
{"task_id": "CPP/51", "generation": "#include <stdio.h>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nstring remove_vowels(string text) {\n    string result = \"\"; // Initialize an empty string to store the result\n    for (char c : text) { // Iterate through each character in the input string\n        // Check if the character is a vowel (both lowercase and uppercase)\n        if (c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u' &&\n            c != 'A' && c != 'E' && c != 'I' && c != 'O' && c != 'U') {\n            result += c; // Append non-vowel characters to the result\n        }\n    }\n    return result; // Return the final string without vowels\n}\n"}
{"task_id": "CPP/52", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nbool below_threshold(vector<int> l, int t) {\n    for (int num : l) {\n        if (num >= t) {\n            return false; // Found a number that is not below the threshold\n        }\n    }\n    return true; // All numbers are below the threshold\n}\n"}
{"task_id": "CPP/53", "generation": "#include<stdio.h>\n#include<stdlib.h>\nusing namespace std;\n\nint add(int x, int y) {\n    return x + y; // Return the sum of x and y\n}\n"}
{"task_id": "CPP/54", "generation": "#include <stdio.h>\n#include <string>\n#include <set>\n#include <algorithm>\nusing namespace std;\n\nbool same_chars(string s0, string s1) {\n    // Create sets to hold unique characters\n    set<char> unique_chars_s0(s0.begin(), s0.end());\n    set<char> unique_chars_s1(s1.begin(), s1.end());\n    \n    // Convert sets to sorted vectors\n    vector<char> sorted_s0(unique_chars_s0.begin(), unique_chars_s0.end());\n    vector<char> sorted_s1(unique_chars_s1.begin(), unique_chars_s1.end());\n    \n    // Compare the sorted vectors\n    return sorted_s0 == sorted_s1;\n}\n"}
{"task_id": "CPP/55", "generation": "#include<stdio.h>\nusing namespace std;\n\nint fib(int n) {\n    if (n == 0) return 0;\n    if (n == 1) return 1;\n    \n    int a = 0, b = 1; // F(0) and F(1)\n    for (int i = 2; i <= n; i++) {\n        int temp = b; // Store the current Fibonacci number\n        b = a + b;    // Calculate the next Fibonacci number\n        a = temp;     // Update a to the previous Fibonacci number\n    }\n    return b; // Return the n-th Fibonacci number\n}\n"}
{"task_id": "CPP/56", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    int count = 0; // Initialize the counter for opening brackets\n    for (char ch : brackets) { // Iterate through each character in the string\n        if (ch == '<') {\n            count++; // Increment for opening bracket\n        } else if (ch == '>') {\n            count--; // Decrement for closing bracket\n        }\n        if (count < 0) {\n            return false; // More closing brackets than opening ones\n        }\n    }\n    return count == 0; // Return true if all brackets are matched\n}\n"}
{"task_id": "CPP/57", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nbool monotonic(vector<float> l) {\n    bool isIncreasing = true;\n    bool isDecreasing = true;\n\n    for (int i = 0; i < l.size() - 1; i++) {\n        if (l[i] < l[i + 1]) {\n            isDecreasing = false;\n        } else if (l[i] > l[i + 1]) {\n            isIncreasing = false;\n        }\n    }\n\n    return isIncreasing || isDecreasing;\n}\n"}
{"task_id": "CPP/58", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\n#include <set>\nusing namespace std;\n\nvector<int> common(vector<int> l1, vector<int> l2) {\n    // Create a set from the second vector to store unique elements\n    set<int> unique_elements(l2.begin(), l2.end());\n    vector<int> common_elements;\n\n    // Loop through the first vector\n    for (int element : l1) {\n        // Check if the element exists in the set\n        if (unique_elements.find(element) != unique_elements.end()) {\n            common_elements.push_back(element);\n        }\n    }\n\n    // Sort the common elements\n    sort(common_elements.begin(), common_elements.end());\n    // Remove duplicates by using a set\n    common_elements.erase(unique(common_elements.begin(), common_elements.end()), common_elements.end());\n\n    return common_elements;\n}\n"}
{"task_id": "CPP/59", "generation": "#include <stdio.h>\n#include <cmath>\nusing namespace std;\n\nint largest_prime_factor(int n) {\n    int largest_prime = 0;\n\n    // Check for number of 2s that divide n\n    while (n % 2 == 0) {\n        largest_prime = 2;\n        n /= 2;\n    }\n\n    // n must be odd at this point, check for odd factors from 3 to sqrt(n)\n    for (int i = 3; i <= sqrt(n); i += 2) {\n        while (n % i == 0) {\n            largest_prime = i;\n            n /= i;\n        }\n    }\n\n    // This condition is to check if n is a prime number greater than 2\n    if (n > 2) {\n        largest_prime = n;\n    }\n\n    return largest_prime;\n}\n"}
{"task_id": "CPP/60", "generation": "#include<stdio.h>\nusing namespace std;\n\nint sum_to_n(int n) {\n    return n * (n + 1) / 2; // Using the formula for the sum of the first n natural numbers\n}\n"}
{"task_id": "CPP/61", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    int count = 0; // Initialize the counter for opening brackets\n    for (char ch : brackets) { // Loop through each character in the string\n        if (ch == '(') {\n            count++; // Increment for opening bracket\n        } else if (ch == ')') {\n            count--; // Decrement for closing bracket\n        }\n        if (count < 0) {\n            return false; // If count goes negative, return false\n        }\n    }\n    return count == 0; // Return true if all brackets are matched\n}\n"}
{"task_id": "CPP/62", "generation": "#include <vector>\nusing namespace std;\n\nvector<float> derivative(vector<float> xs) {\n    vector<float> result;\n    for (int i = 1; i < xs.size(); i++) {\n        result.push_back(i * xs[i]);\n    }\n    return result;\n}\n"}
{"task_id": "CPP/63", "generation": "#include <stdio.h>\nusing namespace std;\n\nint fibfib(int n) {\n    if (n == 0 || n == 1) return 0;\n    if (n == 2) return 1;\n\n    int a = 0; // fibfib(0)\n    int b = 0; // fibfib(1)\n    int c = 1; // fibfib(2)\n    int fibfib_n = 0;\n\n    for (int i = 3; i <= n; i++) {\n        fibfib_n = a + b + c; // fibfib(n) = fibfib(n-1) + fibfib(n-2) + fibfib(n-3)\n        a = b; // Update for next iteration\n        b = c; // Update for next iteration\n        c = fibfib_n; // Update for next iteration\n    }\n\n    return fibfib_n;\n}\n"}
{"task_id": "CPP/64", "generation": "#include <stdio.h>\n#include <string>\n#include <set>\nusing namespace std;\n\nint vowels_count(string s) {\n    set<char> vowels_set = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'};\n    int count = 0;\n    \n    for (int i = 0; i < s.length(); i++) {\n        char c = s[i];\n        if (vowels_set.count(c)) {\n            count++;\n        } else if (c == 'y' || c == 'Y') {\n            if (i == s.length() - 1) { // Check if 'y' is the last character\n                count++;\n            }\n        }\n    }\n    \n    return count;\n}\n"}
{"task_id": "CPP/65", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nstring circular_shift(int x, int shift) {\n    string str_x = to_string(x);\n    int len = str_x.length();\n    \n    if (shift > len) {\n        // Reverse the string\n        reverse(str_x.begin(), str_x.end());\n        return str_x;\n    } else {\n        // Calculate effective shift\n        int effective_shift = shift % len;\n        // Perform circular shift\n        return str_x.substr(len - effective_shift) + str_x.substr(0, len - effective_shift);\n    }\n}\n"}
{"task_id": "CPP/66", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nint digitSum(string s) {\n    int sum = 0; // Initialize sum to 0\n    for (char c : s) { // Iterate through each character in the string\n        if (c >= 'A' && c <= 'Z') { // Check if the character is uppercase\n            sum += int(c); // Add ASCII value of uppercase character to sum\n        }\n    }\n    return sum; // Return the final sum\n}\n"}
{"task_id": "CPP/67", "generation": "#include <stdio.h>\n#include <string>\n#include <sstream>\nusing namespace std;\n\nint fruit_distribution(string s, int n) {\n    int apples = 0, oranges = 0;\n    stringstream ss(s);\n    string word;\n\n    // Extract the number of apples\n    ss >> apples; // Read the number before \"apples\"\n    ss >> word;   // Skip the word \"apples\"\n    ss >> word;   // Skip the word \"and\"\n    ss >> oranges; // Read the number before \"oranges\"\n\n    // Calculate the number of mangoes\n    int mangoes = n - apples - oranges;\n    return mangoes;\n}\n"}
{"task_id": "CPP/68", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nvector<int> pluck(vector<int> arr) {\n    int smallest_even = INT_MAX; // Initialize to maximum integer value\n    int smallest_index = -1; // Initialize index to -1 (indicating no even number found)\n\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] % 2 == 0) { // Check if the number is even\n            if (arr[i] < smallest_even) { // Check if it's the smallest even number found\n                smallest_even = arr[i];\n                smallest_index = i; // Update the index of the smallest even number\n            }\n        }\n    }\n\n    if (smallest_index == -1) { // No even number found\n        return {};\n    } else {\n        return {smallest_even, smallest_index}; // Return the smallest even number and its index\n    }\n}\n"}
{"task_id": "CPP/69", "generation": "#include <stdio.h>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint search(vector<int> lst) {\n    unordered_map<int, int> frequencyMap;\n\n    // Count the frequency of each number\n    for (int num : lst) {\n        frequencyMap[num]++;\n    }\n\n    int max_value = -1;\n\n    // Check for the greatest integer that meets the condition\n    for (const auto& pair : frequencyMap) {\n        int number = pair.first;\n        int frequency = pair.second;\n\n        if (frequency >= number) {\n            max_value = max(max_value, number);\n        }\n    }\n\n    return max_value;\n}\n"}
{"task_id": "CPP/70", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> strange_sort_list(vector<int> lst) {\n    // Sort the input list\n    sort(lst.begin(), lst.end());\n    \n    vector<int> result;\n    int left = 0; // Pointer for the minimum\n    int right = lst.size() - 1; // Pointer for the maximum\n    \n    // Alternate between the smallest and largest remaining elements\n    while (left <= right) {\n        // Add the minimum element\n        result.push_back(lst[left]);\n        left++;\n        \n        // Add the maximum element if there are still elements left\n        if (left <= right) {\n            result.push_back(lst[right]);\n            right--;\n        }\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/71", "generation": "#include <stdio.h>\n#include <math.h>\n#include <iomanip> // for std::setprecision\nusing namespace std;\n\nfloat triangle_area(float a, float b, float c) {\n    // Check if the sides form a valid triangle\n    if ((a + b <= c) || (a + c <= b) || (b + c <= a)) {\n        return -1;\n    }\n    \n    // Calculate the semi-perimeter\n    float s = (a + b + c) / 2;\n    \n    // Calculate the area using Heron's formula\n    float area = sqrt(s * (s - a) * (s - b) * (s - c));\n    \n    // Return the area rounded to 2 decimal points\n    return round(area * 100) / 100; // rounding to 2 decimal points\n}\n"}
{"task_id": "CPP/72", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nbool will_it_fly(vector<int> q, int w) {\n    int n = q.size();\n    int sum = 0;\n\n    // Calculate the sum of elements\n    for (int i = 0; i < n; i++) {\n        sum += q[i];\n    }\n\n    // Check if the vector is palindromic\n    for (int i = 0; i < n / 2; i++) {\n        if (q[i] != q[n - 1 - i]) {\n            return false; // Not palindromic\n        }\n    }\n\n    // Check the conditions\n    return (sum <= w);\n}\n"}
{"task_id": "CPP/73", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nint smallest_change(vector<int> arr) {\n    int changes = 0;\n    int left = 0;\n    int right = arr.size() - 1;\n\n    while (left < right) {\n        if (arr[left] != arr[right]) {\n            changes++;\n        }\n        left++;\n        right--;\n    }\n    \n    return changes;\n}\n"}
{"task_id": "CPP/74", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> total_match(vector<string> lst1, vector<string> lst2) {\n    int total1 = 0;\n    int total2 = 0;\n\n    // Calculate total characters in lst1\n    for (const string& str : lst1) {\n        total1 += str.length();\n    }\n\n    // Calculate total characters in lst2\n    for (const string& str : lst2) {\n        total2 += str.length();\n    }\n\n    // Compare totals and return the appropriate vector\n    if (total1 < total2) {\n        return lst1;\n    } else if (total2 < total1) {\n        return lst2;\n    } else {\n        return lst1; // If they are equal, return lst1\n    }\n}\n"}
{"task_id": "CPP/75", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nbool is_multiply_prime(int a) {\n    // List of prime numbers less than 100\n    std::vector<int> primes = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, \n                                31, 37, 41, 43, 47, 53, 59, \n                                61, 67, 71, 73, 79, 83, 89, 97};\n    \n    int n = primes.size();\n    \n    // Check all combinations of three primes\n    for (int i = 0; i < n; ++i) {\n        for (int j = i; j < n; ++j) {\n            for (int k = j; k < n; ++k) {\n                int product = primes[i] * primes[j] * primes[k];\n                if (product == a) {\n                    return true;\n                }\n            }\n        }\n    }\n    \n    return false;\n}\n\n// Example usage\n"}
{"task_id": "CPP/76", "generation": "#include <stdio.h>\n#include <math.h>\nusing namespace std;\n\nbool is_simple_power(int x, int n) {\n    // Handle special case when n is 1\n    if (n == 1) {\n        return x == 1;\n    }\n    // Handle case when n is less than or equal to 0\n    if (n <= 0) {\n        return false;\n    }\n    \n    int power = 1; // Start with n^0\n    while (power < x) {\n        power *= n; // Calculate n^k\n    }\n    \n    return power == x; // Check if we found the exact power\n}\n"}
{"task_id": "CPP/77", "generation": "#include <cmath>\nusing namespace std;\n\nbool iscube(int a) {\n    if (a == 0) {\n        return true; // 0 is a cube (0^3 = 0)\n    }\n    int n = round(cbrt(a)); // Calculate the cube root and round it\n    return n * n * n == a; // Check if n cubed equals a\n}\n"}
{"task_id": "CPP/78", "generation": "#include <stdio.h>\n#include <string>\n#include <unordered_set>\nusing namespace std;\n\nint hex_key(string num) {\n    // Set of prime hexadecimal digits\n    unordered_set<char> prime_hex_digits = {'2', '3', '5', '7', 'B', 'D'};\n    int count = 0;\n\n    // Iterate through each character in the input string\n    for (char c : num) {\n        // Check if the character is a prime hexadecimal digit\n        if (prime_hex_digits.find(c) != prime_hex_digits.end()) {\n            count++;\n        }\n    }\n    return count;\n}\n"}
{"task_id": "CPP/79", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nstring decimal_to_binary(int decimal) {\n    string binaryString = \"\";\n    \n    // Handle the case for 0\n    if (decimal == 0) {\n        binaryString = \"0\";\n    } else {\n        while (decimal > 0) {\n            // Prepend the remainder (0 or 1) to the binary string\n            binaryString = to_string(decimal % 2) + binaryString;\n            // Update decimal\n            decimal /= 2;\n        }\n    }\n    \n    // Return the formatted string\n    return \"db\" + binaryString + \"db\";\n}\n"}
{"task_id": "CPP/80", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nbool is_happy(string s) {\n    // Check if the length of the string is less than 3\n    if (s.length() < 3) {\n        return false;\n    }\n    \n    // Iterate through the string to check every 3 consecutive characters\n    for (int i = 0; i <= s.length() - 3; i++) {\n        // Check if any of the three characters are the same\n        if (s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]) {\n            return false;\n        }\n    }\n    \n    // If all checks passed, the string is happy\n    return true;\n}\n"}
{"task_id": "CPP/81", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> numerical_letter_grade(vector<float> grades) {\n    vector<string> result;\n    \n    for (float grade : grades) {\n        if (grade == 4.0) {\n            result.push_back(\"A+\");\n        } else if (grade > 3.7) {\n            result.push_back(\"A\");\n        } else if (grade > 3.3) {\n            result.push_back(\"A-\");\n        } else if (grade > 3.0) {\n            result.push_back(\"B+\");\n        } else if (grade > 2.7) {\n            result.push_back(\"B\");\n        } else if (grade > 2.3) {\n            result.push_back(\"B-\");\n        } else if (grade > 2.0) {\n            result.push_back(\"C+\");\n        } else if (grade > 1.7) {\n            result.push_back(\"C\");\n        } else if (grade > 1.3) {\n            result.push_back(\"C-\");\n        } else if (grade > 1.0) {\n            result.push_back(\"D+\");\n        } else if (grade > 0.7) {\n            result.push_back(\"D\");\n        } else if (grade > 0.0) {\n            result.push_back(\"D-\");\n        } else {\n            result.push_back(\"E\");\n        }\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/82", "generation": "#include <stdio.h>\n#include <string>\n#include <cmath>\nusing namespace std;\n\nbool prime_length(string str) {\n    int length = str.length();\n    \n    // Check if length is less than 2\n    if (length < 2) {\n        return false;\n    }\n    \n    // Check for factors from 2 to sqrt(length)\n    for (int i = 2; i <= sqrt(length); i++) {\n        if (length % i == 0) {\n            return false; // Not a prime number\n        }\n    }\n    \n    return true; // It's a prime number\n}\n"}
{"task_id": "CPP/83", "generation": "#include <cmath>\nusing namespace std;\n\nint starts_one_ends(int n) {\n    if (n == 1) {\n        return 2; // The only numbers are 1\n    }\n    int count_starting_with_1 = pow(10, n - 1);\n    int count_ending_with_1 = 9 * pow(10, n - 2);\n    int count_both = pow(10, n - 2);\n    int total_count = count_starting_with_1 + count_ending_with_1 - count_both;\n    return total_count;\n}\n"}
{"task_id": "CPP/84", "generation": "#include <stdio.h>\n#include <string>\n#include <bitset>\nusing namespace std;\n\nstring solve(int N) {\n    int sum = 0;\n    \n    // Calculate the sum of digits\n    while (N > 0) {\n        sum += N % 10; // Add the last digit to sum\n        N = N / 10;    // Remove the last digit\n    }\n    \n    // Convert the sum to binary\n    return std::bitset<32>(sum).to_string().substr(32 - (sum ? (int)log2(sum) + 1 : 1));\n}\n"}
{"task_id": "CPP/85", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nint add(vector<int> lst) {\n    int sum = 0; // Initialize sum to 0\n    for (int i = 0; i < lst.size(); i++) { // Loop through the vector\n        if (i % 2 == 1) { // Check if the index is odd\n            if (lst[i] % 2 == 0) { // Check if the element is even\n                sum += lst[i]; // Add to sum\n            }\n        }\n    }\n    return sum; // Return the final sum\n}\n"}
{"task_id": "CPP/86", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <algorithm>\n\nusing namespace std;\n\nstring anti_shuffle(string s) {\n    string result;\n    string current_word;\n    \n    for (char c : s) {\n        if (c != ' ') {\n            current_word += c; // Build the current word\n        } else {\n            if (!current_word.empty()) {\n                sort(current_word.begin(), current_word.end()); // Sort the current word\n                result += current_word; // Append sorted word to result\n                current_word.clear(); // Clear current word for next\n            }\n            result += ' '; // Preserve space\n        }\n    }\n    \n    // Handle the last word if it exists\n    if (!current_word.empty()) {\n        sort(current_word.begin(), current_word.end());\n        result += current_word;\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/87", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<vector<int>> get_row(vector<vector<int>> lst, int x) {\n    vector<vector<int>> result;\n\n    // Collecting coordinates of x\n    for (int i = 0; i < lst.size(); i++) {\n        for (int j = 0; j < lst[i].size(); j++) {\n            if (lst[i][j] == x) {\n                result.push_back({i, j});\n            }\n        }\n    }\n\n    // Sorting the result\n    sort(result.begin(), result.end(), [](const vector<int>& a, const vector<int>& b) {\n        if (a[0] == b[0]) {\n            return a[1] > b[1]; // Sort by column in descending order if rows are equal\n        }\n        return a[0] < b[0]; // Sort by row in ascending order\n    });\n\n    return result;\n}\n"}
{"task_id": "CPP/88", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> sort_array(vector<int> array) {\n    // Handle edge cases\n    if (array.empty()) {\n        return {};\n    }\n    if (array.size() == 1) {\n        return array;\n    }\n    \n    // Calculate the sum of the first and last elements\n    int sum = array[0] + array[array.size() - 1];\n    \n    // Create a copy of the original array to sort\n    vector<int> sorted_array = array;\n    \n    // Sort based on the sum being odd or even\n    if (sum % 2 == 0) {\n        // Even sum: sort in descending order\n        sort(sorted_array.begin(), sorted_array.end(), greater<int>());\n    } else {\n        // Odd sum: sort in ascending order\n        sort(sorted_array.begin(), sorted_array.end());\n    }\n    \n    return sorted_array;\n}\n"}
{"task_id": "CPP/89", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nstring encrypt(string s) {\n    string result = \"\";\n    for (char c : s) {\n        if (c >= 'a' && c <= 'z') { // Check if the character is a lowercase letter\n            char newChar = c + 4; // Shift the character by 4 positions\n            if (newChar > 'z') { // Wrap around if it goes past 'z'\n                newChar -= 26; // Wrap around to the start of the alphabet\n            }\n            result += newChar; // Append the new character to the result\n        }\n    }\n    return result; // Return the encrypted string\n}\n"}
{"task_id": "CPP/90", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <iostream>\nusing namespace std;\n\nint next_smallest(vector<int> lst) {\n    if (lst.empty()) {\n        return -1; // Using -1 to represent None in this context\n    }\n    \n    // Use a set to remove duplicates\n    set<int> unique_elements(lst.begin(), lst.end());\n    \n    // Convert the set back to a vector\n    vector<int> sorted_unique(unique_elements.begin(), unique_elements.end());\n    \n    // Check if there are at least two unique elements\n    if (sorted_unique.size() < 2) {\n        return -1; // Using -1 to represent None in this context\n    }\n    \n    // Return the second smallest element\n    return sorted_unique[1];\n}\n\n// Example usage\n"}
{"task_id": "CPP/91", "generation": "#include <stdio.h>\n#include <string>\n#include <vector>\n#include <sstream>\n#include <cctype>\n\nusing namespace std;\n\nint is_bored(string S) {\n    int count = 0;\n    // Define delimiters\n    char delimiters[] = {'.', '?', '!'};\n    \n    // Create a string stream to split sentences\n    stringstream ss(S);\n    string sentence;\n    \n    // Read until we find a delimiter\n    while (getline(ss, sentence, '.')) {\n        // Check if the sentence starts with \"I\"\n        if (sentence.empty()) continue; // Skip empty sentences\n        // Trim leading whitespace\n        size_t start = sentence.find_first_not_of(\" \\t\");\n        if (start != string::npos && sentence[start] == 'I') {\n            count++;\n        }\n    }\n    \n    // Reset stringstream to split by other delimiters\n    ss.clear();\n    ss.str(S);\n    \n    // Repeat for '?' and '!'\n    while (getline(ss, sentence, '?')) {\n        if (sentence.empty()) continue;\n        size_t start = sentence.find_first_not_of(\" \\t\");\n        if (start != string::npos && sentence[start] == 'I') {\n            count++;\n        }\n    }\n    \n    ss.clear();\n    ss.str(S);\n    \n    while (getline(ss, sentence, '!')) {\n        if (sentence.empty()) continue;\n        size_t start = sentence.find_first_not_of(\" \\t\");\n        if (start != string::npos && sentence[start] == 'I') {\n            count++;\n        }\n    }\n    \n    return count;\n}\n"}
{"task_id": "CPP/92", "generation": "#include <stdio.h>\n#include <math.h>\nusing namespace std;\n\nbool any_int(float a, float b, float c) {\n    // Check if all numbers are integers\n    if (floor(a) != a || floor(b) != b || floor(c) != c) {\n        return false;\n    }\n    \n    // Check if any number is equal to the sum of the other two\n    if (a == b + c || b == a + c || c == a + b) {\n        return true;\n    }\n    \n    return false;\n}\n"}
{"task_id": "CPP/93", "generation": "#include <stdio.h>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nstring encode(string message) {\n    string result = \"\";\n    for (char ch : message) {\n        if (isalpha(ch)) { // Check if the character is a letter\n            // Swap case\n            if (islower(ch)) {\n                ch = toupper(ch);\n            } else {\n                ch = tolower(ch);\n            }\n            // Replace vowels\n            switch (ch) {\n                case 'a': ch = 'c'; break;\n                case 'e': ch = 'g'; break;\n                case 'i': ch = 'k'; break;\n                case 'o': ch = 'q'; break;\n                case 'u': ch = 'w'; break;\n                case 'A': ch = 'C'; break;\n                case 'E': ch = 'G'; break;\n                case 'I': ch = 'K'; break;\n                case 'O': ch = 'Q'; break;\n                case 'U': ch = 'W'; break;\n                default: break; // No change for non-vowel letters\n            }\n        }\n        result += ch; // Append the modified character to the result\n    }\n    return result; // Return the final encoded message\n}\n"}
{"task_id": "CPP/94", "generation": "#include <stdio.h>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\n// Function to check if a number is prime\nbool isPrime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i <= sqrt(n); i++) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\n// Function to find the largest prime and return the sum of its digits\nint skjkasdkd(vector<int> lst) {\n    int largestPrime = -1;\n\n    // Find the largest prime number in the list\n    for (int num : lst) {\n        if (isPrime(num) && num > largestPrime) {\n            largestPrime = num;\n        }\n    }\n\n    // If no prime number was found, return 0\n    if (largestPrime == -1) return 0;\n\n    // Calculate the sum of the digits of the largest prime\n    int sum = 0;\n    while (largestPrime > 0) {\n        sum += largestPrime % 10; // Add the last digit\n        largestPrime /= 10;        // Remove the last digit\n    }\n\n    return sum;\n}\n"}
{"task_id": "CPP/95", "generation": "#include <stdio.h>\n#include <string>\n#include <map>\n#include <cctype> // for isupper and islower\nusing namespace std;\n\nbool check_dict_case(map<string, string> dict) {\n    // Check if the map is empty\n    if (dict.empty()) {\n        return false;\n    }\n    \n    bool allLower = true;\n    bool allUpper = true;\n    \n    // Iterate through each key in the map\n    for (const auto& pair : dict) {\n        const string& key = pair.first;\n        \n        // Check each character in the key\n        for (char c : key) {\n            if (isupper(c)) {\n                allLower = false; // Found an uppercase letter\n            }\n            if (islower(c)) {\n                allUpper = false; // Found a lowercase letter\n            }\n        }\n    }\n    \n    // Return true if all keys are either all lower or all upper\n    return allLower || allUpper;\n}\n"}
{"task_id": "CPP/96", "generation": "#include <stdio.h>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int num) {\n    if (num <= 1) return false; // 0 and 1 are not prime\n    for (int i = 2; i <= sqrt(num); i++) {\n        if (num % i == 0) return false; // Found a divisor, not prime\n    }\n    return true; // No divisors found, it is prime\n}\n\n// Function to count prime numbers up to n\nvector<int> count_up_to(int n) {\n    vector<int> primes; // Vector to store prime numbers\n    for (int i = 2; i < n; i++) { // Start from 2 to n-1\n        if (is_prime(i)) {\n            primes.push_back(i); // Add prime number to the vector\n        }\n    }\n    return primes; // Return the vector of prime numbers\n}\n"}
{"task_id": "CPP/97", "generation": "#include<stdio.h>\nusing namespace std;\n\nint multiply(int a, int b) {\n    // Get the unit digits\n    int unitDigitA = abs(a) % 10; // Use abs to handle negative numbers\n    int unitDigitB = abs(b) % 10; // Use abs to handle negative numbers\n    \n    // Calculate the product of the unit digits\n    return unitDigitA * unitDigitB;\n}\n"}
{"task_id": "CPP/98", "generation": "#include <stdio.h>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nint count_upper(string s) {\n    int count = 0; // Initialize the counter for uppercase vowels\n    for (int i = 0; i < s.length(); i += 2) { // Iterate over even indices\n        char c = s[i]; // Get the character at the current index\n        // Check if the character is an uppercase vowel\n        if (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n            count++; // Increment the count if it is an uppercase vowel\n        }\n    }\n    return count; // Return the final count\n}\n"}
{"task_id": "CPP/99", "generation": "#include <stdio.h>\n#include <math.h>\n#include <string>\n#include <cstdlib> // for std::stoi\nusing namespace std;\n\nint closest_integer(string value) {\n    // Convert string to float\n    float number = stof(value);\n    \n    // Check if the number is an integer\n    if (number - floor(number) == 0.5) {\n        return ceil(number); // Round away from zero\n    } else if (number - floor(number) == -0.5) {\n        return floor(number); // Round away from zero\n    } else {\n        return round(number); // Regular rounding\n    }\n}\n"}
{"task_id": "CPP/100", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> make_a_pile(int n) {\n    vector<int> stones;\n    for (int i = 0; i < n; i++) {\n        stones.push_back(n + 2 * i);\n    }\n    return stones;\n}\n"}
{"task_id": "CPP/101", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <sstream>\nusing namespace std;\n\nvector<string> words_string(string s) {\n    vector<string> words;\n    stringstream ss(s);\n    string word;\n    \n    // Read words separated by spaces or commas\n    while (getline(ss, word, ',')) { // Split by comma first\n        stringstream wordStream(word);\n        while (wordStream >> word) { // Split by spaces\n            words.push_back(word);\n        }\n    }\n    \n    return words;\n}\n"}
{"task_id": "CPP/102", "generation": "#include<stdio.h>\nusing namespace std;\n\nint choose_num(int x, int y) {\n    // Check if the range is valid\n    if (y < x) {\n        return -1;\n    }\n    \n    // Determine the largest even number in the range\n    int largest_even;\n    if (y % 2 == 0) {\n        largest_even = y; // y is even\n    } else {\n        largest_even = y - 1; // y is odd, take y - 1\n    }\n    \n    // Check if the largest even number is within the range\n    if (largest_even < x) {\n        return -1; // No even number in the range\n    }\n    \n    return largest_even; // Return the largest even number\n}\n"}
{"task_id": "CPP/103", "generation": "#include <stdio.h>\n#include <math.h>\n#include <string>\nusing namespace std;\n\nstring rounded_avg(int n, int m) {\n    if (n > m) {\n        return \"-1\";\n    }\n    \n    // Calculate the sum from n to m\n    int sum = (m * (m + 1) / 2) - ((n - 1) * n / 2);\n    int count = m - n + 1;\n    \n    // Calculate the average and round it down\n    int average = sum / count;\n    \n    // Convert the rounded average to binary\n    string binary_string = \"\";\n    if (average == 0) {\n        return \"0\"; // Handle the case where average is 0\n    }\n    \n    while (average > 0) {\n        binary_string = to_string(average % 2) + binary_string;\n        average /= 2;\n    }\n    \n    return binary_string;\n}\n"}
{"task_id": "CPP/104", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> unique_digits(vector<int> x) {\n    vector<int> result;\n\n    for (int number : x) {\n        bool has_even_digit = false;\n        int temp = number;\n\n        // Check each digit of the number\n        while (temp > 0) {\n            int digit = temp % 10; // Get the last digit\n            if (digit % 2 == 0) { // Check if the digit is even\n                has_even_digit = true;\n                break; // No need to check further\n            }\n            temp /= 10; // Remove the last digit\n        }\n\n        // If no even digit was found, add the number to the result\n        if (!has_even_digit) {\n            result.push_back(number);\n        }\n    }\n\n    // Sort the result in increasing order\n    sort(result.begin(), result.end());\n    return result;\n}\n"}
{"task_id": "CPP/105", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\nvector<string> by_length(vector<int> arr) {\n    vector<int> temp; // Temporary vector to hold valid numbers\n    vector<string> result; // Resultant vector of strings\n\n    // Map for number to string conversion\n    map<int, string> numToStr = {\n        {1, \"One\"}, {2, \"Two\"}, {3, \"Three\"}, {4, \"Four\"},\n        {5, \"Five\"}, {6, \"Six\"}, {7, \"Seven\"}, {8, \"Eight\"}, {9, \"Nine\"}\n    };\n\n    // Filter numbers between 1 and 9\n    for (int number : arr) {\n        if (number >= 1 && number <= 9) {\n            temp.push_back(number);\n        }\n    }\n\n    // Sort the valid numbers\n    sort(temp.begin(), temp.end());\n\n    // Reverse the sorted numbers\n    reverse(temp.begin(), temp.end());\n\n    // Convert numbers to strings using the map\n    for (int number : temp) {\n        result.push_back(numToStr[number]);\n    }\n\n    return result; // Return the final result\n}\n"}
{"task_id": "CPP/106", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nint factorial(int i) {\n    int result = 1;\n    for (int j = 1; j <= i; j++) {\n        result *= j;\n    }\n    return result;\n}\n\nvector<int> f(int n) {\n    vector<int> result(n);\n    for (int i = 1; i <= n; i++) {\n        if (i % 2 == 0) {\n            result[i - 1] = factorial(i);\n        } else {\n            result[i - 1] = (i * (i + 1)) / 2; // Sum from 1 to i\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/107", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<int> even_odd_palindrome(int n) {\n    int even_count = 0;\n    int odd_count = 0;\n\n    for (int i = 1; i <= n; i++) {\n        // Convert number to string\n        string str_num = to_string(i);\n        // Check if it is a palindrome\n        string reversed_num = string(str_num.rbegin(), str_num.rend());\n        \n        if (str_num == reversed_num) {\n            // It's a palindrome, check if it's even or odd\n            if (i % 2 == 0) {\n                even_count++;\n            } else {\n                odd_count++;\n            }\n        }\n    }\n\n    return {even_count, odd_count};\n}\n"}
{"task_id": "CPP/108", "generation": "#include <vector>\n#include <cmath>\nusing namespace std;\n\nint count_nums(vector<int> n) {\n    int count = 0;\n    \n    for (int number : n) {\n        int sum_of_digits = 0;\n        int original_number = number; // Store the original number for checking the sign\n        number = abs(number); // Work with the absolute value\n        \n        // Calculate the sum of digits\n        while (number > 0) {\n            sum_of_digits += number % 10; // Add the last digit\n            number /= 10; // Remove the last digit\n        }\n        \n        // If the original number was negative, adjust the sum of digits\n        if (original_number < 0) {\n            sum_of_digits -= (original_number % 10); // Subtract the first signed digit\n        }\n        \n        // Check if the sum of digits is greater than zero\n        if (sum_of_digits > 0) {\n            count++;\n        }\n    }\n    \n    return count;\n}\n"}
{"task_id": "CPP/109", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nbool move_one_ball(vector<int> arr) {\n    // If the array is empty, return true\n    if (arr.empty()) {\n        return true;\n    }\n\n    int count = 0;\n    int n = arr.size();\n\n    // Loop through the array to count the number of decreases\n    for (int i = 0; i < n - 1; i++) {\n        if (arr[i] > arr[i + 1]) {\n            count++;\n        }\n    }\n\n    // Check the last element with the first element\n    if (arr[n - 1] > arr[0]) {\n        count++;\n    }\n\n    // If there is more than one decrease, return false\n    return count <= 1;\n}\n"}
{"task_id": "CPP/110", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring exchange(vector<int> lst1, vector<int> lst2) {\n    bool found_odd = false;\n\n    // Check for odd numbers in lst1\n    for (int num : lst1) {\n        if (num % 2 != 0) { // num is odd\n            found_odd = true;\n            break;\n        }\n    }\n\n    // If no odd numbers found in lst1, return \"YES\"\n    if (!found_odd) {\n        return \"YES\";\n    }\n\n    // Check for even numbers in lst2\n    for (int num : lst2) {\n        if (num % 2 == 0) { // num is even\n            return \"YES\";\n        }\n    }\n\n    // If we found odd numbers in lst1 and no even numbers in lst2\n    return \"NO\";\n}\n"}
{"task_id": "CPP/111", "generation": "#include <stdio.h>\n#include <string>\n#include <map>\n#include <sstream>\n#include <vector>\nusing namespace std;\n\nmap<string, int> histogram(string test) {\n    map<string, int> countMap;\n    stringstream ss(test);\n    string letter;\n\n    // Count occurrences of each letter\n    while (ss >> letter) {\n        countMap[letter]++;\n    }\n\n    // Find the maximum count\n    int maxCount = 0;\n    for (const auto& pair : countMap) {\n        if (pair.second > maxCount) {\n            maxCount = pair.second;\n        }\n    }\n\n    // Create a result map for letters with the maximum count\n    map<string, int> resultMap;\n    for (const auto& pair : countMap) {\n        if (pair.second == maxCount) {\n            resultMap[pair.first] = pair.second;\n        }\n    }\n\n    return resultMap;\n}\n"}
{"task_id": "CPP/112", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <unordered_set>\n#include <algorithm>\nusing namespace std;\n\nvector<string> reverse_delete(string s, string c) {\n    unordered_set<char> charsToRemove(c.begin(), c.end());\n    string result;\n\n    // Build the result string by excluding characters in charsToRemove\n    for (char ch : s) {\n        if (charsToRemove.find(ch) == charsToRemove.end()) {\n            result += ch;\n        }\n    }\n\n    // Check if the result string is a palindrome\n    string reversedResult = result;\n    reverse(reversedResult.begin(), reversedResult.end());\n    bool isPalindrome = (result == reversedResult);\n\n    // Prepare the output vector\n    return {result, isPalindrome ? \"True\" : \"False\"};\n}\n"}
{"task_id": "CPP/113", "generation": "#include <vector>\n#include <string>\n#include <iostream>\n\nusing namespace std;\n\nvector<string> odd_count(vector<string> lst) {\n    vector<string> result; // Vector to store the result strings\n\n    for (int i = 0; i < lst.size(); i++) {\n        int oddCount = 0; // Counter for odd digits\n        string currentString = lst[i];\n\n        // Count odd digits in the current string\n        for (char c : currentString) {\n            if (c == '1' || c == '3' || c == '5' || c == '7' || c == '9') {\n                oddCount++;\n            }\n        }\n\n        // Construct the output string\n        string output = \"the number of odd elements \" + to_string(oddCount) + \n                        \" in the string \" + to_string(i) + \n                        \" of the input.\";\n        result.push_back(output); // Add to result vector\n    }\n\n    return result; // Return the result vector\n}\n"}
{"task_id": "CPP/114", "generation": "#include <stdio.h>\n#include <vector>\n#include <limits.h> // For INT_MAX\nusing namespace std;\n\nlong long minSubArraySum(vector<long long> nums) {\n    long long currentSum = 0;\n    long long minSum = LLONG_MAX; // Use LLONG_MAX for long long type\n\n    for (long long number : nums) {\n        currentSum += number;\n        if (currentSum < minSum) {\n            minSum = currentSum;\n        }\n        if (currentSum > 0) {\n            currentSum = 0; // Reset currentSum if it becomes positive\n        }\n    }\n    \n    return minSum;\n}\n"}
{"task_id": "CPP/115", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nint max_fill(vector<vector<int>> grid, int capacity) {\n    int total_lowers = 0;\n    \n    for (const auto& row : grid) {\n        int count_of_water = 0;\n        \n        for (int cell : row) {\n            if (cell == 1) {\n                count_of_water++;\n            }\n        }\n        \n        // Calculate lowers needed for this row\n        int lowers_for_this_row = count_of_water / capacity;\n        if (count_of_water % capacity != 0) {\n            lowers_for_this_row++;\n        }\n        \n        total_lowers += lowers_for_this_row;\n    }\n    \n    return total_lowers;\n}\n"}
{"task_id": "CPP/116", "generation": "#include <vector>\n#include <algorithm>\n#include <bitset>\n\nusing namespace std;\n\n// Function to count the number of 1s in the binary representation of an integer\nint countOnes(int n) {\n    return bitset<32>(n).count(); // Using bitset to count the number of 1s\n}\n\nvector<int> sort_array(vector<int> arr) {\n    // Custom comparator for sorting\n    sort(arr.begin(), arr.end(), [](int a, int b) {\n        int countA = countOnes(a);\n        int countB = countOnes(b);\n        if (countA == countB) {\n            return a < b; // If counts are equal, sort by value\n        }\n        return countA < countB; // Sort by number of 1s\n    });\n    return arr;\n}\n"}
{"task_id": "CPP/117", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <cctype>\n\nusing namespace std;\n\nvector<string> select_words(string s, int n) {\n    vector<string> result;\n    stringstream ss(s);\n    string word;\n\n    while (ss >> word) { // Split the string into words\n        int consonantCount = 0;\n        for (char c : word) {\n            // Check if the character is a consonant\n            if (isalpha(c) && !strchr(\"aeiouAEIOU\", c)) {\n                consonantCount++;\n            }\n        }\n        // If the number of consonants matches n, add the word to the result\n        if (consonantCount == n) {\n            result.push_back(word);\n        }\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/118", "generation": "#include <stdio.h>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nstring get_closest_vowel(string word) {\n    string vowels = \"aeiouAEIOU\";\n    int length = word.length();\n    \n    // Start from the end of the string and look for vowels\n    for (int i = length - 1; i > 0; i--) {\n        if (vowels.find(word[i]) != string::npos) { // Check if it's a vowel\n            // Check if the characters before and after are consonants\n            if (i > 0 && i < length - 1 && \n                isalpha(word[i - 1]) && !vowels.find(word[i - 1]) != string::npos &&\n                isalpha(word[i + 1]) && !vowels.find(word[i + 1]) != string::npos) {\n                return string(1, word[i]); // Return the vowel as a string\n            }\n        }\n    }\n    return \"\"; // Return empty string if no suitable vowel is found\n}\n"}
{"task_id": "CPP/119", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring match_parens(vector<string> lst) {\n    string s1 = lst[0];\n    string s2 = lst[1];\n    \n    int open1 = 0, close1 = 0;\n    int open2 = 0, close2 = 0;\n    \n    // Count parentheses in s1\n    for (char c : s1) {\n        if (c == '(') open1++;\n        else close1++;\n    }\n    \n    // Count parentheses in s2\n    for (char c : s2) {\n        if (c == '(') open2++;\n        else close2++;\n    }\n    \n    // Check for s1 + s2\n    if (open1 >= close2 && (open1 - close2) + open2 >= close1) {\n        return \"Yes\";\n    }\n    \n    // Check for s2 + s1\n    if (open2 >= close1 && (open2 - close1) + open1 >= close2) {\n        return \"Yes\";\n    }\n    \n    return \"No\";\n}\n"}
{"task_id": "CPP/120", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> maximum(vector<int> arr, int k) {\n    // Step 2: Handle the case when k is 0\n    if (k == 0) {\n        return {};\n    }\n\n    // Step 3: Sort the array in descending order\n    sort(arr.begin(), arr.end(), greater<int>());\n\n    // Step 4: Select the first k elements\n    vector<int> result(arr.begin(), arr.begin() + k);\n\n    // Step 5: Sort the result in ascending order\n    sort(result.begin(), result.end());\n\n    // Step 6: Return the result\n    return result;\n}\n"}
{"task_id": "CPP/121", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nint solution(vector<int> lst) {\n    int sum = 0; // Initialize sum to 0\n    for (int i = 0; i < lst.size(); i++) { // Iterate through the vector\n        if (i % 2 == 0) { // Check if the index is even\n            if (lst[i] % 2 != 0) { // Check if the element is odd\n                sum += lst[i]; // Add to sum\n            }\n        }\n    }\n    return sum; // Return the final sum\n}\n"}
{"task_id": "CPP/122", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nint add_elements(vector<int> arr, int k) {\n    int sum = 0;\n    for (int i = 0; i < k; i++) {\n        if (arr[i] >= -99 && arr[i] <= 99) {\n            sum += arr[i];\n        }\n    }\n    return sum;\n}\n"}
{"task_id": "CPP/123", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> get_odd_collatz(int n) {\n    vector<int> odd_numbers;\n    \n    while (n != 1) {\n        if (n % 2 != 0) { // Check if n is odd\n            odd_numbers.push_back(n);\n        }\n        // Apply Collatz rules\n        if (n % 2 == 0) {\n            n = n / 2; // Even case\n        } else {\n            n = 3 * n + 1; // Odd case\n        }\n    }\n    odd_numbers.push_back(1); // Add the last number 1 to the list\n    sort(odd_numbers.begin(), odd_numbers.end()); // Sort the vector\n    return odd_numbers;\n}\n"}
{"task_id": "CPP/124", "generation": "#include <stdio.h>\n#include <string>\n#include <cstdlib> // for atoi\nusing namespace std;\n\nbool valid_date(string date) {\n    // Check if the date string is empty\n    if (date.empty()) {\n        return false;\n    }\n    \n    // Check the length of the date string\n    if (date.length() != 10) {\n        return false;\n    }\n    \n    // Check the format of the date\n    if (date[2] != '-' || date[5] != '-') {\n        return false;\n    }\n    \n    // Extract month, day, and year\n    int month = atoi(date.substr(0, 2).c_str());\n    int day = atoi(date.substr(3, 2).c_str());\n    int year = atoi(date.substr(6, 4).c_str());\n    \n    // Validate the month\n    if (month < 1 || month > 12) {\n        return false;\n    }\n    \n    // Validate the day based on the month\n    if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {\n        if (day < 1 || day > 31) {\n            return false;\n        }\n    } else if (month == 4 || month == 6 || month == 9 || month == 11) {\n        if (day < 1 || day > 30) {\n            return false;\n        }\n    } else if (month == 2) {\n        if (day < 1 || day > 29) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n"}
{"task_id": "CPP/125", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <cctype>\n\nusing namespace std;\n\nvector<string> split_words(string txt) {\n    vector<string> result;\n    // Check for whitespace\n    if (txt.find(' ') != string::npos) {\n        stringstream ss(txt);\n        string word;\n        while (ss >> word) {\n            result.push_back(word);\n        }\n    }\n    // Check for commas\n    else if (txt.find(',') != string::npos) {\n        stringstream ss(txt);\n        string word;\n        while (getline(ss, word, ',')) {\n            result.push_back(word);\n        }\n    }\n    // If no whitespace or commas, count lowercase letters in odd positions\n    else {\n        int count = 0;\n        for (char c : txt) {\n            if (islower(c)) {\n                int position = c - 'a'; // Get position in alphabet\n                if (position % 2 == 1) { // Check if position is odd\n                    count++;\n                }\n            }\n        }\n        result.push_back(to_string(count)); // Convert count to string and add to result\n    }\n    return result;\n}\n"}
{"task_id": "CPP/126", "generation": "#include <stdio.h>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nbool is_sorted(vector<int> lst) {\n    if (lst.empty()) {\n        return true; // An empty list is considered sorted\n    }\n    \n    unordered_map<int, int> countMap; // To count occurrences of each number\n    int previous = lst[0];\n    \n    for (int number : lst) {\n        if (number < previous) {\n            return false; // Not sorted\n        }\n        countMap[number]++; // Increment count of the number\n        if (countMap[number] > 2) {\n            return false; // More than two occurrences\n        }\n        previous = number; // Update previous\n    }\n    \n    return true; // List is sorted and no number appears more than twice\n}\n"}
{"task_id": "CPP/127", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <cmath>\nusing namespace std;\n\nbool isPrime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i <= sqrt(n); i++) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\nstring intersection(vector<int> interval1, vector<int> interval2) {\n    int start = max(interval1[0], interval2[0]);\n    int end = min(interval1[1], interval2[1]);\n    \n    if (start > end) {\n        return \"NO\";\n    }\n    \n    int length = end - start + 1;\n    \n    if (isPrime(length)) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n"}
{"task_id": "CPP/128", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nint prod_signs(vector<int> arr) {\n    if (arr.empty()) {\n        return -32768;\n    }\n    \n    int product_signs = 1;\n    int sum_magnitudes = 0;\n\n    for (int number : arr) {\n        if (number == 0) {\n            product_signs = 0;\n            break;\n        } else if (number > 0) {\n            product_signs *= 1;\n        } else {\n            product_signs *= -1;\n        }\n        sum_magnitudes += abs(number);\n    }\n    \n    return sum_magnitudes * product_signs;\n}\n"}
{"task_id": "CPP/129", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvoid dfs(int x, int y, int k, vector<vector<int>>& grid, vector<int>& path, vector<int>& minPath) {\n    // If we have reached the desired path length\n    if (path.size() == k) {\n        if (minPath.empty() || path < minPath) {\n            minPath = path; // Update minPath if current path is smaller\n        }\n        return;\n    }\n\n    // Directions for moving in the grid (up, down, left, right)\n    vector<pair<int, int>> directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n    \n    // Explore all four directions\n    for (auto& dir : directions) {\n        int newX = x + dir.first;\n        int newY = y + dir.second;\n        \n        // Check if the new position is within bounds\n        if (newX >= 0 && newX < grid.size() && newY >= 0 && newY < grid[0].size()) {\n            path.push_back(grid[newX][newY]); // Add the value to the path\n            dfs(newX, newY, k, grid, path, minPath); // Recur\n            path.pop_back(); // Backtrack\n        }\n    }\n}\n\nvector<int> minPath(vector<vector<int>> grid, int k) {\n    vector<int> minPath; // To store the minimum path found\n    int N = grid.size();\n    \n    // Try starting from each cell in the grid\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            vector<int> path = {grid[i][j]}; // Start path with the current cell\n            dfs(i, j, k, grid, path, minPath); // Start DFS from the current cell\n        }\n    }\n    \n    return minPath; // Return the minimum path found\n}\n\n// Example usage\n"}
{"task_id": "CPP/130", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nvector<int> tri(int n) {\n    vector<int> result(n + 1);\n    \n    for (int i = 0; i <= n; i++) {\n        if (i == 1) {\n            result[i] = 3; // Base case\n        } else if (i % 2 == 0) {\n            result[i] = 1 + i / 2; // Even case\n        } else {\n            // Odd case requires previous values\n            result[i] = result[i - 1] + result[i - 2] + (i + 1 <= n ? result[i + 1] : 0);\n        }\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/131", "generation": "#include<stdio.h>\n\nint digits(int n) {\n    int product = 1;\n    bool hasOddDigit = false;\n\n    while (n > 0) {\n        int digit = n % 10;  // get the last digit\n        if (digit % 2 != 0) {  // check if the digit is odd\n            product *= digit;\n            hasOddDigit = true;\n        }\n        n /= 10;  // remove the last digit\n    }\n\n    if (!hasOddDigit) {\n        return 0;  // return 0 if no odd digits were found\n    } else {\n        return product;  // return the product of odd digits\n    }\n}\n"}
{"task_id": "CPP/132", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nbool is_nested(string str) {\n    int openCount = 0; // To count the number of '['\n    bool isNested = false; // To track if we have a nested structure\n\n    for (char ch : str) {\n        if (ch == '[') {\n            openCount++; // Increment for every opening bracket\n        } else if (ch == ']') {\n            if (openCount > 0) { // There is a matching opening bracket\n                openCount--; // Decrease the count of open brackets\n                if (openCount > 0) { // If there were already open brackets, we have nesting\n                    isNested = true;\n                }\n            } else {\n                return false; // More closing brackets than opening ones\n            }\n        }\n    }\n\n    return isNested; // Return true if nesting was found, otherwise false\n}\n"}
{"task_id": "CPP/133", "generation": "#include <stdio.h>\n#include <math.h>\n#include <vector>\nusing namespace std;\n\nint sum_squares(vector<float> lst) {\n    int sum = 0; // Initialize sum to 0\n    for (float num : lst) { // Iterate through each number in the vector\n        int rounded = ceil(num); // Round up to the nearest integer\n        sum += rounded * rounded; // Square the rounded number and add to sum\n    }\n    return sum; // Return the final sum\n}\n"}
{"task_id": "CPP/134", "generation": "#include <stdio.h>\n#include <string>\n#include <cctype> // for isalpha\nusing namespace std;\n\nbool check_if_last_char_is_a_letter(string txt) {\n    // Check if the string is empty\n    if (txt.empty()) {\n        return false;\n    }\n\n    // Trim trailing spaces\n    size_t end = txt.find_last_not_of(' ');\n    if (end == string::npos) {\n        return false; // All spaces\n    }\n    txt = txt.substr(0, end + 1); // Trimmed string\n\n    // Get the last character\n    char lastChar = txt.back();\n\n    // Check if the last character is an alphabetical character\n    if (isalpha(lastChar)) {\n        // Check if it's not part of a word\n        if (txt.length() == 1 || txt[end - 1] == ' ') {\n            return true;\n        }\n    }\n    \n    return false;\n}\n"}
{"task_id": "CPP/135", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nint can_arrange(vector<int> arr) {\n    int last_index = -1; // Initialize last_index to -1\n    for (int i = 1; i < arr.size(); i++) { // Start from the second element\n        if (arr[i] < arr[i - 1]) { // Check if current element is less than the previous one\n            last_index = i; // Update last_index\n        }\n    }\n    return last_index; // Return the largest index found or -1 if none found\n}\n"}
{"task_id": "CPP/136", "generation": "#include <stdio.h>\n#include <vector>\n#include <limits.h> // for INT_MIN and INT_MAX\nusing namespace std;\n\nvector<int> largest_smallest_integers(vector<int> lst) {\n    int largest_negative = INT_MIN;\n    int smallest_positive = INT_MAX;\n\n    for (int number : lst) {\n        if (number < 0) {\n            if (number > largest_negative) {\n                largest_negative = number;\n            }\n        } else if (number > 0) {\n            if (number < smallest_positive) {\n                smallest_positive = number;\n            }\n        }\n    }\n\n    if (largest_negative == INT_MIN) {\n        largest_negative = 0;\n    }\n    if (smallest_positive == INT_MAX) {\n        smallest_positive = 0;\n    }\n\n    return {largest_negative, smallest_positive};\n}\n"}
{"task_id": "CPP/137", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <boost/any.hpp>\n\nusing namespace std;\n\nboost::any compare_one(boost::any a, boost::any b) {\n    // Function to convert string to float considering both '.' and ','\n    auto string_to_float = [](const string& s) {\n        string modified = s;\n        replace(modified.begin(), modified.end(), ',', '.');\n        return stof(modified);\n    };\n\n    // Check if both are equal\n    if (a.type() == b.type()) {\n        if (a == b) {\n            return \"None\";\n        }\n    } else {\n        // Handle different types\n        float val_a, val_b;\n\n        if (a.type() == typeid(int)) {\n            val_a = boost::any_cast<int>(a);\n        } else if (a.type() == typeid(float)) {\n            val_a = boost::any_cast<float>(a);\n        } else if (a.type() == typeid(string)) {\n            val_a = string_to_float(boost::any_cast<string>(a));\n        }\n\n        if (b.type() == typeid(int)) {\n            val_b = boost::any_cast<int>(b);\n        } else if (b.type() == typeid(float)) {\n            val_b = boost::any_cast<float>(b);\n        } else if (b.type() == typeid(string)) {\n            val_b = string_to_float(boost::any_cast<string>(b));\n        }\n\n        // Compare and return the larger one\n        if (val_a > val_b) {\n            return a;\n        } else {\n            return b;\n        }\n    }\n\n    // If we reach here, it means they are not equal and of the same type\n    return (boost::any_cast<int>(a) > boost::any_cast<int>(b)) ? a : b;\n}\n\n"}
{"task_id": "CPP/138", "generation": "#include<stdio.h>\nusing namespace std;\n\nbool is_equal_to_sum_even(int n) {\n    if (n < 8) {\n        return false; // Cannot be expressed as the sum of 4 positive even numbers\n    }\n    return n % 2 == 0; // Return true if n is even, false if odd\n}\n"}
{"task_id": "CPP/139", "generation": "#include <stdio.h>\n\nusing namespace std;\n\nlong long special_factorial(int n) {\n    long long result = 1; // To hold the final result\n    for (int i = n; i >= 1; i--) {\n        long long factorial = 1; // To calculate i!\n        for (int j = 1; j <= i; j++) {\n            factorial *= j; // Calculate factorial of i\n        }\n        result *= factorial; // Multiply the current factorial to the result\n    }\n    return result; // Return the final result\n}\n"}
{"task_id": "CPP/140", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nstring fix_spaces(string text) {\n    string result = \"\";\n    int consecutiveSpaces = 0;\n\n    for (char c : text) {\n        if (c == ' ') {\n            consecutiveSpaces++;\n        } else {\n            if (consecutiveSpaces > 0) {\n                if (consecutiveSpaces > 2) {\n                    result += '-'; // More than 2 spaces\n                } else {\n                    result += string(consecutiveSpaces, '_'); // 1 or 2 spaces\n                }\n                consecutiveSpaces = 0; // Reset counter\n            }\n            result += c; // Append the non-space character\n        }\n    }\n\n    // Handle any remaining spaces at the end of the string\n    if (consecutiveSpaces > 0) {\n        if (consecutiveSpaces > 2) {\n            result += '-';\n        } else {\n            result += string(consecutiveSpaces, '_');\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/141", "generation": "#include <stdio.h>\n#include <string>\n#include <cctype> // for isalpha\nusing namespace std;\n\nstring file_name_check(string file_name) {\n    int digit_count = 0;\n    int dot_position = -1;\n\n    // Loop through the file name to check conditions\n    for (int i = 0; i < file_name.length(); i++) {\n        if (isdigit(file_name[i])) {\n            digit_count++;\n        }\n        if (file_name[i] == '.') {\n            if (dot_position != -1) {\n                // More than one dot found\n                return \"No\";\n            }\n            dot_position = i;\n        }\n    }\n\n    // Check if there is exactly one dot\n    if (dot_position == -1) {\n        return \"No\"; // No dot found\n    }\n\n    // Check digit count\n    if (digit_count > 3) {\n        return \"No\"; // More than three digits\n    }\n\n    // Check the substring before the dot\n    string before_dot = file_name.substr(0, dot_position);\n    if (before_dot.empty() || !isalpha(before_dot[0])) {\n        return \"No\"; // Empty or does not start with a letter\n    }\n\n    // Check the substring after the dot\n    string after_dot = file_name.substr(dot_position + 1);\n    if (after_dot != \"txt\" && after_dot != \"exe\" && after_dot != \"dll\") {\n        return \"No\"; // Invalid file extension\n    }\n\n    return \"Yes\"; // All checks passed\n}\n"}
{"task_id": "CPP/142", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nint sum_squares(vector<int> lst) {\n    int sum = 0; // Initialize sum to 0\n    for (int i = 0; i < lst.size(); i++) { // Loop through each element\n        if (i % 3 == 0) { // Check if index is a multiple of 3\n            lst[i] = lst[i] * lst[i]; // Square the element\n        } else if (i % 4 == 0) { // Check if index is a multiple of 4 but not 3\n            lst[i] = lst[i] * lst[i] * lst[i]; // Cube the element\n        }\n        sum += lst[i]; // Add the modified element to the sum\n    }\n    return sum; // Return the total sum\n}\n"}
{"task_id": "CPP/143", "generation": "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <string>\n#include <cmath>\n\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i <= sqrt(n); i++) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\n// Function to extract words with prime lengths from a sentence\nstring words_in_sentence(string sentence) {\n    stringstream ss(sentence);\n    string word;\n    vector<string> result;\n\n    // Split the sentence into words\n    while (ss >> word) {\n        // Check if the length of the word is prime\n        if (is_prime(word.length())) {\n            result.push_back(word);\n        }\n    }\n\n    // Join the result into a single string\n    string output;\n    for (size_t i = 0; i < result.size(); i++) {\n        output += result[i];\n        if (i < result.size() - 1) {\n            output += \" \"; // Add space between words\n        }\n    }\n\n    return output;\n}\n"}
{"task_id": "CPP/144", "generation": "#include <stdio.h>\n#include <string>\n#include <sstream>\n#include <vector>\n\nusing namespace std;\n\nbool simplify(string x, string n) {\n    // Split the first fraction\n    size_t pos = x.find('/');\n    int numerator_x = stoi(x.substr(0, pos));\n    int denominator_x = stoi(x.substr(pos + 1));\n\n    // Split the second fraction\n    pos = n.find('/');\n    int numerator_n = stoi(n.substr(0, pos));\n    int denominator_n = stoi(n.substr(pos + 1));\n\n    // Calculate the products\n    int product_numerator = numerator_x * numerator_n;\n    int product_denominator = denominator_x * denominator_n;\n\n    // Check if the product of numerators is divisible by the product of denominators\n    return (product_numerator % product_denominator == 0);\n}\n"}
{"task_id": "CPP/145", "generation": "#include <vector>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\n// Function to calculate the digit sum of an integer\nint digit_sum(int n) {\n    int sum = 0;\n    bool is_negative = (n < 0);\n    n = abs(n);\n    while (n > 0) {\n        sum += n % 10;\n        n /= 10;\n    }\n    if (is_negative) {\n        sum = -sum;\n    }\n    return sum;\n}\n\n// Function to sort the vector based on the digit sum\nvector<int> order_by_points(vector<int> nums) {\n    stable_sort(nums.begin(), nums.end(), [](int a, int b) {\n        int sum_a = digit_sum(a);\n        int sum_b = digit_sum(b);\n        return sum_a < sum_b; // Sort by digit sum\n    });\n    return nums;\n}\n"}
{"task_id": "CPP/146", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nint specialFilter(vector<int> nums) {\n    int count = 0;\n    \n    for (int num : nums) {\n        if (num > 10) {\n            string numStr = to_string(num);\n            char first_digit = numStr[0];\n            char last_digit = numStr[numStr.size() - 1];\n            \n            // Check if both first and last digits are odd\n            if ((first_digit - '0') % 2 != 0 && (last_digit - '0') % 2 != 0) {\n                count++;\n            }\n        }\n    }\n    \n    return count;\n}\n"}
{"task_id": "CPP/147", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint get_max_triples(int n) {\n    vector<int> a(n);\n    for (int i = 1; i <= n; ++i) {\n        a[i - 1] = i * i - i + 1; // Fill the vector a\n    }\n    \n    int count[3] = {0}; // Count for residues 0, 1, 2\n    \n    // Count occurrences of each residue modulo 3\n    for (int i = 0; i < n; ++i) {\n        int residue = a[i] % 3;\n        count[residue]++;\n    }\n    \n    int total_triples = 0;\n    \n    // Count combinations of residues\n    // C(count[0], 3)\n    if (count[0] >= 3) {\n        total_triples += (count[0] * (count[0] - 1) * (count[0] - 2)) / 6;\n    }\n    // C(count[1], 3)\n    if (count[1] >= 3) {\n        total_triples += (count[1] * (count[1] - 1) * (count[1] - 2)) / 6;\n    }\n    // C(count[2], 3)\n    if (count[2] >= 3) {\n        total_triples += (count[2] * (count[2] - 1) * (count[2] - 2)) / 6;\n    }\n    // count[0] * count[1] * count[2]\n    total_triples += count[0] * count[1] * count[2];\n    \n    return total_triples;\n}\n\n// Example usage\n"}
{"task_id": "CPP/148", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nvector<string> bf(string planet1, string planet2) {\n    vector<string> planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n    \n    // Check if planet1 and planet2 are valid\n    auto it1 = find(planets.begin(), planets.end(), planet1);\n    auto it2 = find(planets.begin(), planets.end(), planet2);\n    \n    if (it1 == planets.end() || it2 == planets.end()) {\n        return {}; // Return empty vector if either planet is invalid\n    }\n    \n    // Get indices of the planets\n    int index1 = distance(planets.begin(), it1);\n    int index2 = distance(planets.begin(), it2);\n    \n    // Ensure index1 is less than index2\n    if (index1 > index2) {\n        swap(index1, index2);\n    }\n    \n    // Collect planets between index1 and index2\n    vector<string> result;\n    for (int i = index1 + 1; i < index2; ++i) {\n        result.push_back(planets[i]);\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/149", "generation": "#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nvector<string> sorted_list_sum(vector<string> lst) {\n    vector<string> filtered;\n\n    // Filter out strings with odd lengths\n    for (const string& str : lst) {\n        if (str.length() % 2 == 0) {\n            filtered.push_back(str);\n        }\n    }\n\n    // Sort the filtered vector\n    sort(filtered.begin(), filtered.end(), [](const string& a, const string& b) {\n        if (a.length() != b.length()) {\n            return a.length() < b.length(); // Sort by length\n        }\n        return a < b; // Sort alphabetically if lengths are equal\n    });\n\n    return filtered;\n}\n"}
{"task_id": "CPP/150", "generation": "#include <stdio.h>\n#include <cmath>\n\nusing namespace std;\n\nbool is_prime(int n) {\n    if (n < 2) return false; // 0 and 1 are not prime numbers\n    for (int i = 2; i <= sqrt(n); i++) {\n        if (n % i == 0) return false; // n is divisible by i, hence not prime\n    }\n    return true; // n is prime\n}\n\nint x_or_y(int n, int x, int y) {\n    if (is_prime(n)) {\n        return x; // n is prime\n    } else {\n        return y; // n is not prime\n    }\n}\n"}
{"task_id": "CPP/151", "generation": "#include <stdio.h>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\nlong long double_the_difference(vector<float> lst) {\n    long long sum_of_squares = 0; // Initialize sum of squares\n    for (float number : lst) {\n        // Check if the number is a non-negative integer and odd\n        if (number >= 0 && floor(number) == number && static_cast<int>(number) % 2 != 0) {\n            sum_of_squares += static_cast<int>(number) * static_cast<int>(number); // Add square of the number\n        }\n    }\n    return sum_of_squares; // Return the final sum\n}\n"}
{"task_id": "CPP/152", "generation": "#include <vector>\n#include <cmath> // for abs function\nusing namespace std;\n\nvector<int> compare(vector<int> game, vector<int> guess) {\n    vector<int> result; // Initialize the result vector\n    for (size_t i = 0; i < game.size(); i++) {\n        if (game[i] == guess[i]) {\n            result.push_back(0); // Correct guess\n        } else {\n            result.push_back(abs(game[i] - guess[i])); // Absolute difference\n        }\n    }\n    return result; // Return the result vector\n}\n"}
{"task_id": "CPP/153", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <cctype> // for isupper and islower\nusing namespace std;\n\nstring Strongest_Extension(string class_name, vector<string> extensions) {\n    string strongest_extension = \"\";\n    int max_strength = -1000; // A very small number to start with\n\n    for (const string& extension : extensions) {\n        int CAP = 0, SM = 0;\n\n        // Count uppercase and lowercase letters\n        for (char c : extension) {\n            if (isupper(c)) {\n                CAP++;\n            } else if (islower(c)) {\n                SM++;\n            }\n        }\n\n        // Calculate strength\n        int strength = CAP - SM;\n\n        // Update strongest extension if current is stronger\n        if (strength > max_strength) {\n            max_strength = strength;\n            strongest_extension = extension;\n        }\n    }\n\n    return class_name + \".\" + strongest_extension;\n}\n"}
{"task_id": "CPP/154", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nbool cycpattern_check(string a, string b) {\n    // If b is empty, return false\n    if (b.empty()) {\n        return false;\n    }\n    \n    // Create the concatenated string of b\n    string concatenated_b = b + b;\n    \n    // Check if any rotation of b is a substring of a\n    return concatenated_b.find(a) != string::npos;\n}\n\n// Example usage\n#include <iostream>\n"}
{"task_id": "CPP/155", "generation": "#include <stdio.h>\n#include <vector>\n#include <cmath> // for abs function\nusing namespace std;\n\nvector<int> even_odd_count(int num) {\n    vector<int> counts(2, 0); // counts[0] for even, counts[1] for odd\n    num = abs(num); // consider absolute value\n\n    while (num > 0) {\n        int digit = num % 10; // get the last digit\n        if (digit % 2 == 0) {\n            counts[0]++; // increment even count\n        } else {\n            counts[1]++; // increment odd count\n        }\n        num /= 10; // remove the last digit\n    }\n    \n    return counts; // return the counts\n}\n"}
{"task_id": "CPP/156", "generation": "#include <string>\n#include <vector>\nusing namespace std;\n\nstring int_to_mini_roman(int number) {\n    // Mapping of integer values to Roman numeral symbols\n    vector<pair<int, string>> romanMapping = {\n        {1000, \"m\"}, {900, \"cm\"}, {500, \"d\"}, {400, \"cd\"},\n        {100, \"c\"}, {90, \"xc\"}, {50, \"l\"}, {40, \"xl\"},\n        {10, \"x\"}, {9, \"ix\"}, {5, \"v\"}, {4, \"iv\"},\n        {1, \"i\"}\n    };\n    \n    string result = \"\";\n    \n    // Iterate through the mapping\n    for (const auto& [value, symbol] : romanMapping) {\n        while (number >= value) {\n            result += symbol; // Append the Roman numeral symbol\n            number -= value;  // Subtract the value from the number\n        }\n    }\n    \n    return result; // Return the result in lowercase\n}\n"}
{"task_id": "CPP/157", "generation": "#include <stdio.h>\n#include <math.h>\nusing namespace std;\n\nbool right_angle_triangle(float a, float b, float c) {\n    // Identify the longest side\n    float longest = max(max(a, b), c);\n    float side1, side2;\n\n    // Determine the other two sides\n    if (longest == a) {\n        side1 = b;\n        side2 = c;\n    } else if (longest == b) {\n        side1 = a;\n        side2 = c;\n    } else {\n        side1 = a;\n        side2 = b;\n    }\n\n    // Check the Pythagorean theorem\n    return (longest * longest == side1 * side1 + side2 * side2);\n}\n"}
{"task_id": "CPP/158", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <set>\n#include <algorithm>\nusing namespace std;\n\nstring find_max(vector<string> words) {\n    string maxWord = \"\";\n    int maxUniqueCount = 0;\n\n    for (const string& word : words) {\n        set<char> uniqueChars(word.begin(), word.end());\n        int uniqueCount = uniqueChars.size();\n\n        if (uniqueCount > maxUniqueCount) {\n            maxUniqueCount = uniqueCount;\n            maxWord = word;\n        } else if (uniqueCount == maxUniqueCount) {\n            if (maxWord.empty() || word < maxWord) {\n                maxWord = word;\n            }\n        }\n    }\n\n    return maxWord;\n}\n"}
{"task_id": "CPP/159", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> eat(int number, int need, int remaining) {\n    int total_eaten;\n    int remaining_after;\n\n    if (remaining >= need) {\n        total_eaten = number + need;\n        remaining_after = remaining - need;\n    } else {\n        total_eaten = number + remaining;\n        remaining_after = 0;\n    }\n\n    return {total_eaten, remaining_after};\n}\n"}
{"task_id": "CPP/160", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <stdexcept>\nusing namespace std;\n\nint do_algebra(vector<string> operato, vector<int> operand) {\n    if (operand.size() < 2 || operato.size() != operand.size() - 1) {\n        throw invalid_argument(\"Invalid input sizes.\");\n    }\n\n    // Step 1: Handle exponentiation first\n    vector<int> tempOperands;\n    vector<string> tempOperators;\n\n    tempOperands.push_back(operand[0]);\n    \n    for (size_t i = 0; i < operato.size(); i++) {\n        if (operato[i] == \"**\") {\n            int result = pow(tempOperands.back(), operand[i + 1]);\n            tempOperands.pop_back();\n            tempOperands.push_back(result);\n        } else {\n            tempOperators.push_back(operato[i]);\n            tempOperands.push_back(operand[i + 1]);\n        }\n    }\n\n    // Step 2: Handle multiplication and floor division\n    vector<int> finalOperands;\n    vector<string> finalOperators;\n\n    finalOperands.push_back(tempOperands[0]);\n    \n    for (size_t i = 0; i < tempOperators.size(); i++) {\n        if (tempOperators[i] == \"*\" || tempOperators[i] == \"//\") {\n            int result = (tempOperators[i] == \"*\") ? \n                         finalOperands.back() * tempOperands[i + 1] : \n                         finalOperands.back() / tempOperands[i + 1];\n            finalOperands.pop_back();\n            finalOperands.push_back(result);\n        } else {\n            finalOperators.push_back(tempOperators[i]);\n            finalOperands.push_back(tempOperands[i + 1]);\n        }\n    }\n\n    // Step 3: Handle addition and subtraction\n    int result = finalOperands[0];\n    for (size_t i = 0; i < finalOperators.size(); i++) {\n        if (finalOperators[i] == \"+\") {\n            result += finalOperands[i + 1];\n        } else if (finalOperators[i] == \"-\") {\n            result -= finalOperands[i + 1];\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/161", "generation": "#include <stdio.h>\n#include <string>\n#include <algorithm> // for std::reverse\nusing namespace std;\n\nstring solve(string s) {\n    bool hasLetter = false;\n    string result;\n\n    for (char c : s) {\n        if (isalpha(c)) {\n            hasLetter = true;\n            // Change case\n            if (islower(c)) {\n                result += toupper(c);\n            } else {\n                result += tolower(c);\n            }\n        } else {\n            result += c; // Keep non-letter characters unchanged\n        }\n    }\n\n    // If no letters were found, reverse the string\n    if (!hasLetter) {\n        reverse(result.begin(), result.end());\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/162", "generation": "#include <stdio.h>\n#include <string>\n#include <openssl/md5.h>\n#include <sstream>\n#include <iomanip>\n\nusing namespace std;\n\nstring string_to_md5(string text) {\n    if (text.empty()) {\n        return \"None\"; // Return \"None\" as a string since C++ does not have a None type\n    }\n\n    unsigned char digest[MD5_DIGEST_LENGTH];\n    MD5((unsigned char*)text.c_str(), text.length(), digest);\n\n    stringstream ss;\n    for (int i = 0; i < MD5_DIGEST_LENGTH; i++) {\n        ss << hex << setw(2) << setfill('0') << (int)digest[i];\n    }\n\n    return ss.str();\n}\n"}
{"task_id": "CPP/163", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm> // for std::min and std::max\nusing namespace std;\n\nvector<int> generate_integers(int a, int b) {\n    vector<int> even_digits;\n    int min_val = min(a, b);\n    int max_val = max(a, b);\n    \n    for (int i = min_val; i <= max_val; i++) {\n        if (i == 0 || i == 2 || i == 4 || i == 6 || i == 8) {\n            even_digits.push_back(i);\n        }\n    }\n    \n    return even_digits;\n}\n"}
{"task_id": "CPP/0", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\nbool has_close_elements(vector<float> numbers, float threshold) {\n    // Sort the numbers\n    sort(numbers.begin(), numbers.end());\n    \n    // Check adjacent elements for closeness\n    for (size_t i = 0; i < numbers.size() - 1; ++i) {\n        if (fabs(numbers[i] - numbers[i + 1]) < threshold) {\n            return true; // Found two numbers closer than the threshold\n        }\n    }\n    \n    return false; // No such pair found\n}\n"}
{"task_id": "CPP/1", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <sstream>\nusing namespace std;\n\nvector<string> separate_paren_groups(string paren_string) {\n    // Remove spaces from the input string\n    paren_string.erase(remove(paren_string.begin(), paren_string.end(), ' '), paren_string.end());\n    \n    vector<string> result;\n    string temp;\n    int balance = 0;\n\n    for (char c : paren_string) {\n        temp += c; // Add current character to temp\n        \n        if (c == '(') {\n            balance++; // Increment balance for '('\n        } else if (c == ')') {\n            balance--; // Decrement balance for ')'\n        }\n\n        // When balance is zero, we have a complete group\n        if (balance == 0) {\n            result.push_back(temp); // Add the complete group to result\n            temp.clear(); // Reset temp for the next group\n        }\n    }\n\n    return result; // Return the vector of separated groups\n}\n"}
{"task_id": "CPP/2", "generation": "#include <stdio.h>\n#include <math.h>\nusing namespace std;\n\nfloat truncate_number(float number) {\n    // Get the integer part of the number\n    int integer_part = floor(number);\n    // Calculate the decimal part\n    float decimal_part = number - integer_part;\n    // Return the decimal part\n    return decimal_part;\n}\n"}
{"task_id": "CPP/3", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nbool below_zero(vector<int> operations) {\n    int balance = 0; // Initialize balance to zero\n    for (int operation : operations) { // Iterate through each operation\n        balance += operation; // Update balance\n        if (balance < 0) { // Check if balance falls below zero\n            return true; // Return true if it does\n        }\n    }\n    return false; // Return false if balance never goes below zero\n}\n"}
{"task_id": "CPP/4", "generation": "#include <stdio.h>\n#include <math.h>\n#include <vector>\nusing namespace std;\n\nfloat mean_absolute_deviation(vector<float> numbers) {\n    // Step 1: Calculate the mean\n    float sum = 0.0;\n    for (float number : numbers) {\n        sum += number;\n    }\n    float mean = sum / numbers.size();\n\n    // Step 2: Calculate the sum of absolute deviations\n    float mad_sum = 0.0;\n    for (float number : numbers) {\n        mad_sum += fabs(number - mean);\n    }\n\n    // Step 3: Calculate the Mean Absolute Deviation\n    float mad = mad_sum / numbers.size();\n    return mad;\n}\n"}
{"task_id": "CPP/5", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> intersperse(vector<int> numbers, int delimeter) { \n    vector<int> result; // Create a result vector\n    int n = numbers.size(); // Get the size of the input vector\n    \n    // If the input vector is empty, return an empty vector\n    if (n == 0) {\n        return result;\n    }\n    \n    // Iterate through the input vector\n    for (int i = 0; i < n; i++) {\n        result.push_back(numbers[i]); // Add the current element to the result\n        // If it's not the last element, add the delimiter\n        if (i < n - 1) {\n            result.push_back(delimeter);\n        }\n    }\n    \n    return result; // Return the result vector\n}\n"}
{"task_id": "CPP/6", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <sstream>\nusing namespace std;\n\nvector<int> parse_nested_parens(string paren_string) {\n    vector<int> result;\n    stringstream ss(paren_string);\n    string group;\n\n    while (ss >> group) {\n        int max_depth = 0;\n        int current_depth = 0;\n\n        for (char ch : group) {\n            if (ch == '(') {\n                current_depth++;\n                if (current_depth > max_depth) {\n                    max_depth = current_depth;\n                }\n            } else if (ch == ')') {\n                current_depth--;\n            }\n        }\n\n        result.push_back(max_depth);\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/7", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> filter_by_substring(vector<string> strings, string substring) {\n    vector<string> result; // Vector to hold the filtered results\n    for (const string& str : strings) { // Iterate through each string in the input vector\n        if (str.find(substring) != string::npos) { // Check if substring is found\n            result.push_back(str); // Add to result if found\n        }\n    }\n    return result; // Return the filtered results\n}\n"}
{"task_id": "CPP/8", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> sum_product(vector<int> numbers) {\n    int sum = 0;\n    int product = 1;\n\n    // Check if the vector is empty\n    if (numbers.empty()) {\n        return {0, 1};\n    }\n\n    // Calculate sum and product\n    for (int number : numbers) {\n        sum += number;\n        product *= number;\n    }\n\n    return {sum, product};\n}\n"}
{"task_id": "CPP/9", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nvector<int> rolling_max(vector<int> numbers) {\n    vector<int> rollingMax;\n    int currentMax = numbers.empty() ? INT_MIN : numbers[0]; // Initialize with the first element or a very small number\n\n    for (int number : numbers) {\n        if (number > currentMax) {\n            currentMax = number; // Update current maximum\n        }\n        rollingMax.push_back(currentMax); // Append the current maximum to the result\n    }\n\n    return rollingMax; // Return the vector of rolling maximums\n}\n"}
{"task_id": "CPP/10", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nbool is_palindrome(string str) {\n    // Test if given string is a palindrome \n    string s(str.rbegin(), str.rend());\n    return s == str;\n}\n\nstring make_palindrome(string str) {\n    int n = str.length();\n    int i;\n    \n    // Find the longest palindromic suffix\n    for (i = n; i >= 0; --i) {\n        if (is_palindrome(str.substr(i))) {\n            break;\n        }\n    }\n    \n    // Create the prefix that needs to be reversed and appended\n    string prefix = str.substr(0, i);\n    string reversed_prefix = string(prefix.rbegin(), prefix.rend());\n    \n    // Return the shortest palindrome\n    return str + reversed_prefix;\n}\n"}
{"task_id": "CPP/11", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nstring string_xor(string a, string b) {\n    string result = \"\";\n    for (int i = 0; i < a.length(); i++) {\n        if (a[i] == b[i]) {\n            result += \"0\";\n        } else {\n            result += \"1\";\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/12", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring longest(vector<string> strings) {\n    if (strings.empty()) {\n        return \"None\"; // Return \"None\" as a string since C++ does not have a None type\n    }\n    \n    string longest_string = \"\"; // Initialize the longest string as empty\n    for (const string& str : strings) {\n        if (str.length() > longest_string.length()) {\n            longest_string = str; // Update longest string if current string is longer\n        }\n    }\n    \n    return longest_string; // Return the longest string found\n}\n"}
{"task_id": "CPP/13", "generation": "#include<stdio.h>\nusing namespace std;\n\nint greatest_common_divisor(int a, int b) {\n    if (b == 0) {\n        return a;\n    } else {\n        return greatest_common_divisor(b, a % b);\n    }\n}\n"}
{"task_id": "CPP/14", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> all_prefixes(string str) {\n    vector<string> prefixes;\n    for (int i = 1; i <= str.length(); i++) {\n        prefixes.push_back(str.substr(0, i));\n    }\n    return prefixes;\n}\n"}
{"task_id": "CPP/15", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nstring string_sequence(int n) {\n    string result = \"\";\n    for (int i = 0; i <= n; i++) {\n        result += to_string(i) + \" \"; // Append number and a space\n    }\n    if (!result.empty()) {\n        result.pop_back(); // Remove the last space\n    }\n    return result;\n}\n"}
{"task_id": "CPP/16", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <set>\n#include <algorithm>\nusing namespace std;\n\nint count_distinct_characters(string str) {\n    set<char> distinctChars; // Set to store distinct characters\n    // Convert the string to lower case\n    transform(str.begin(), str.end(), str.begin(), ::tolower);\n    \n    // Loop through each character in the string\n    for (char c : str) {\n        distinctChars.insert(c); // Add character to the set\n    }\n    \n    // Return the number of distinct characters\n    return distinctChars.size();\n}\n"}
{"task_id": "CPP/17", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <sstream>\nusing namespace std;\n\nvector<int> parse_music(string music_string) {\n    vector<int> beats;\n    stringstream ss(music_string);\n    string note;\n\n    while (ss >> note) {\n        if (note == \"o\") {\n            beats.push_back(4);\n        } else if (note == \"o|\") {\n            beats.push_back(2);\n        } else if (note == \".|\") {\n            beats.push_back(1);\n        }\n    }\n\n    return beats;\n}\n"}
{"task_id": "CPP/18", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nint how_many_times(string str, string substring) {\n    // Edge case: if either string is empty\n    if (str.empty() || substring.empty()) {\n        return 0;\n    }\n    \n    int count = 0;\n    int strLength = str.length();\n    int subLength = substring.length();\n    \n    // Loop through the string\n    for (int i = 0; i <= strLength - subLength; i++) {\n        // Check if the substring matches\n        if (str.substr(i, subLength) == substring) {\n            count++;\n        }\n    }\n    \n    return count;\n}\n"}
{"task_id": "CPP/19", "generation": "#include <iostream>\n#include <string>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <sstream>\n\nusing namespace std;\n\nstring sort_numbers(string numbers) {\n    // Step 1: Create a map for word to number mapping\n    map<string, int> wordToNum = {\n        {\"zero\", 0},\n        {\"one\", 1},\n        {\"two\", 2},\n        {\"three\", 3},\n        {\"four\", 4},\n        {\"five\", 5},\n        {\"six\", 6},\n        {\"seven\", 7},\n        {\"eight\", 8},\n        {\"nine\", 9}\n    };\n\n    // Step 2: Split the input string into words\n    stringstream ss(numbers);\n    vector<string> numWords;\n    string word;\n    while (ss >> word) {\n        numWords.push_back(word);\n    }\n\n    // Step 3: Sort the words based on their numerical values\n    sort(numWords.begin(), numWords.end(), [&](const string& a, const string& b) {\n        return wordToNum[a] < wordToNum[b];\n    });\n\n    // Step 4: Join the sorted words into a single output string\n    string result;\n    for (const string& w : numWords) {\n        result += w + \" \";\n    }\n\n    // Remove the trailing space\n    if (!result.empty()) {\n        result.pop_back();\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/20", "generation": "#include <vector>\n#include <algorithm>\n#include <iostream>\nusing namespace std;\n\nvector<float> find_closest_elements(vector<float> numbers) {\n    // Ensure the vector has at least two elements\n    if (numbers.size() < 2) {\n        return {}; // or handle error\n    }\n    \n    // Sort the numbers\n    sort(numbers.begin(), numbers.end());\n    \n    // Initialize variables to find the closest pair\n    float min_diff = numeric_limits<float>::max();\n    vector<float> closest_pair;\n    \n    // Iterate through the sorted numbers to find the closest pair\n    for (size_t i = 0; i < numbers.size() - 1; ++i) {\n        float diff = numbers[i + 1] - numbers[i];\n        if (diff < min_diff) {\n            min_diff = diff;\n            closest_pair = {numbers[i], numbers[i + 1]};\n        }\n    }\n    \n    return closest_pair;\n}\n\n// Example usage\n"}
{"task_id": "CPP/21", "generation": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<float> rescale_to_unit(vector<float> numbers) {\n    float min_value = *min_element(numbers.begin(), numbers.end());\n    float max_value = *max_element(numbers.begin(), numbers.end());\n    \n    // Handle edge case where all numbers are the same\n    if (min_value == max_value) {\n        return vector<float>(numbers.size(), 0.0f);\n    }\n    \n    vector<float> rescaled_numbers;\n    for (float number : numbers) {\n        float rescaled_value = (number - min_value) / (max_value - min_value);\n        rescaled_numbers.push_back(rescaled_value);\n    }\n    \n    return rescaled_numbers;\n}\n"}
{"task_id": "CPP/22", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <boost/any.hpp>\n#include <list>\n\ntypedef std::list<boost::any> list_any;\nusing namespace std;\n\nvector<int> filter_integers(list_any values) {\n    vector<int> result; // Vector to store the filtered integers\n\n    for (const auto& value : values) { // Iterate through each value in the list\n        if (value.type() == typeid(int)) { // Check if the value is of type int\n            result.push_back(boost::any_cast<int>(value)); // Add the integer to the result vector\n        }\n    }\n\n    return result; // Return the vector containing only integers\n}\n"}
{"task_id": "CPP/23", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nint strlen(string str) {\n    return str.size(); // or str.length();\n}\n"}
{"task_id": "CPP/24", "generation": "#include<stdio.h>\nusing namespace std;\n\nint largest_divisor(int n) {\n    for (int i = n - 1; i > 0; i--) {\n        if (n % i == 0) {\n            return i; // Found the largest divisor smaller than n\n        }\n    }\n    return 1; // This will only be reached if n is 1\n}\n"}
{"task_id": "CPP/25", "generation": "#include <stdio.h>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\nvector<int> factorize(int n) {\n    vector<int> factors;\n    // Check for factors from 2 to sqrt(n)\n    for (int i = 2; i <= sqrt(n); i++) {\n        // While i divides n, add i to factors and divide n\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n    // If n is still greater than 1, then it is a prime factor\n    if (n > 1) {\n        factors.push_back(n);\n    }\n    return factors;\n}\n"}
{"task_id": "CPP/26", "generation": "#include <stdio.h>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nvector<int> remove_duplicates(vector<int> numbers) {\n    unordered_map<int, int> countMap;\n    \n    // Count occurrences of each number\n    for (int num : numbers) {\n        countMap[num]++;\n    }\n    \n    vector<int> result;\n    \n    // Add unique numbers to the result\n    for (int num : numbers) {\n        if (countMap[num] == 1) {\n            result.push_back(num);\n        }\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/27", "generation": "#include <stdio.h>\n#include <string>\n#include <cctype> // for islower, isupper, tolower, toupper\nusing namespace std;\n\nstring flip_case(string str) {\n    string result = \"\"; // Initialize an empty string for the result\n    for (char c : str) { // Loop through each character in the input string\n        if (islower(c)) { // Check if the character is lowercase\n            result += toupper(c); // Convert to uppercase and append to result\n        } else if (isupper(c)) { // Check if the character is uppercase\n            result += tolower(c); // Convert to lowercase and append to result\n        } else {\n            result += c; // Append unchanged if it's neither\n        }\n    }\n    return result; // Return the final result string\n}\n"}
{"task_id": "CPP/28", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring concatenate(vector<string> strings) {\n    string result = \"\"; // Initialize an empty string\n    for (const string& str : strings) { // Iterate through each string in the vector\n        result += str; // Append the current string to the result\n    }\n    return result; // Return the concatenated string\n}\n"}
{"task_id": "CPP/29", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> filter_by_prefix(vector<string> strings, string prefix) {\n    vector<string> filtered; // Vector to hold the filtered results\n    for (const string& str : strings) { // Iterate through each string\n        if (str.substr(0, prefix.size()) == prefix) { // Check if it starts with the prefix\n            filtered.push_back(str); // Add to filtered vector if it matches\n        }\n    }\n    return filtered; // Return the filtered vector\n}\n"}
{"task_id": "CPP/30", "generation": "#include <vector>\nusing namespace std;\n\nvector<float> get_positive(vector<float> l) {\n    vector<float> out; // Create an empty vector to store positive numbers\n    for (float number : l) { // Iterate through each number in the input vector\n        if (number > 0) { // Check if the number is positive\n            out.push_back(number); // Add the positive number to the output vector\n        }\n    }\n    return out; // Return the vector containing only positive numbers\n}\n"}
{"task_id": "CPP/31", "generation": "#include <cmath>\n#include <stdio.h>\nusing namespace std;\n\nbool is_prime(long long n) {\n    // Handle edge cases\n    if (n <= 1) return false; // 0 and 1 are not prime\n    if (n == 2) return true;  // 2 is prime\n    if (n % 2 == 0) return false; // Other even numbers are not prime\n\n    // Check for factors from 3 to sqrt(n)\n    for (long long i = 3; i * i <= n; i += 2) {\n        if (n % i == 0) {\n            return false; // Found a factor, not prime\n        }\n    }\n    return true; // No factors found, it's prime\n}\n"}
{"task_id": "CPP/32", "generation": "#include <stdio.h>\n#include <math.h>\n#include <vector>\nusing namespace std;\n\ndouble poly(vector<double> xs, double x) {\n    double sum = 0;\n    for (int i = 0; i < xs.size(); i++) {\n        sum += xs[i] * pow(x, i);\n    }\n    return sum;\n}\n\ndouble find_zero(vector<double> xs) {\n    // Step 1: Find an interval [a, b] where poly(a) and poly(b) have opposite signs\n    double a = -1000; // Start with a large negative number\n    double b = 1000;  // Start with a large positive number\n\n    while (poly(xs, a) * poly(xs, b) > 0) {\n        a *= 2; // Expand the interval if no sign change is found\n        b *= 2;\n    }\n\n    // Step 2: Apply the Bisection Method\n    double mid;\n    while (b - a > 1e-7) { // Continue until the interval is sufficiently small\n        mid = (a + b) / 2;\n        if (poly(xs, mid) == 0) {\n            return mid; // Found exact zero\n        } else if (poly(xs, mid) * poly(xs, a) < 0) {\n            b = mid; // Zero is in the left half\n        } else {\n            a = mid; // Zero is in the right half\n        }\n    }\n    return mid; // Return the midpoint as the approximate zero\n}\n"}
{"task_id": "CPP/33", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> sort_third(vector<int> l) {\n    vector<int> sorted_values;\n    \n    // Collect values at indices divisible by 3\n    for (int i = 0; i < l.size(); i++) {\n        if (i % 3 == 0) {\n            sorted_values.push_back(l[i]);\n        }\n    }\n    \n    // Sort the collected values\n    sort(sorted_values.begin(), sorted_values.end());\n    \n    // Create the result vector\n    vector<int> result(l.size());\n    \n    // Fill the result vector\n    int sorted_index = 0;\n    for (int i = 0; i < l.size(); i++) {\n        if (i % 3 == 0) {\n            result[i] = sorted_values[sorted_index++];\n        } else {\n            result[i] = l[i];\n        }\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/34", "generation": "#include <stdio.h>\n#include <vector>\n#include <set>\n#include <algorithm>\nusing namespace std;\n\nvector<int> unique(vector<int> l) {\n    set<int> uniqueElements; // Step 1: Create a set to store unique elements\n    for (int num : l) { // Step 2: Iterate through the vector\n        uniqueElements.insert(num); // Insert each element into the set\n    }\n    vector<int> result(uniqueElements.begin(), uniqueElements.end()); // Step 3: Convert set to vector\n    return result; // Step 4: Return the sorted vector of unique elements\n}\n"}
{"task_id": "CPP/35", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nfloat max_element(vector<float> l) {\n    // Check if the vector is empty\n    if (l.empty()) {\n        throw std::invalid_argument(\"Vector is empty\");\n    }\n\n    // Initialize maxValue with the first element\n    float maxValue = l[0];\n\n    // Iterate through the vector to find the maximum element\n    for (int i = 1; i < l.size(); i++) {\n        if (l[i] > maxValue) {\n            maxValue = l[i];\n        }\n    }\n\n    return maxValue;\n}\n"}
{"task_id": "CPP/36", "generation": "#include <stdio.h>\n#include <string>\n\nusing namespace std;\n\nint fizz_buzz(int n) {\n    int count = 0;\n    \n    for (int i = 1; i < n; i++) {\n        if (i % 11 == 0 || i % 13 == 0) {\n            // Convert the number to string to count '7's\n            string numStr = to_string(i);\n            for (char c : numStr) {\n                if (c == '7') {\n                    count++;\n                }\n            }\n        }\n    }\n    \n    return count;\n}\n"}
{"task_id": "CPP/37", "generation": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<float> sort_even(vector<float> l) {\n    vector<float> even_values;\n    vector<float> result(l.size());\n\n    // Extract even indexed values\n    for (int i = 0; i < l.size(); i++) {\n        if (i % 2 == 0) {\n            even_values.push_back(l[i]);\n        }\n    }\n\n    // Sort the even indexed values\n    sort(even_values.begin(), even_values.end());\n\n    // Reconstruct the result vector\n    int index = 0;\n    for (int i = 0; i < l.size(); i++) {\n        if (i % 2 == 0) {\n            result[i] = even_values[index++];\n        } else {\n            result[i] = l[i];\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/38", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nstring decode_cyclic(string s) { \n    string output = \"\";\n    int l = s.length();\n    for (int i = 0; i < l; i += 3) {\n        string group = s.substr(i, 3);\n        if (group.length() == 3) {\n            // Move the last character to the front\n            output += group[2]; // last character\n            output += group[0]; // first character\n            output += group[1]; // second character\n        } else {\n            // If the group has fewer than 3 characters, keep it as is\n            output += group;\n        }\n    }\n    return output;\n}\n"}
{"task_id": "CPP/39", "generation": "#include <iostream>\n#include <cmath>\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    for (int i = 2; i <= sqrt(num); i++) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\n// Function to find the n-th prime Fibonacci number\nint prime_fib(int n) {\n    int fib1 = 0, fib2 = 1;\n    int count = 0;\n    int fib_next;\n\n    while (count < n) {\n        fib_next = fib1 + fib2;\n        fib1 = fib2;\n        fib2 = fib_next;\n\n        if (is_prime(fib_next)) {\n            count++;\n            if (count == n) {\n                return fib_next;\n            }\n        }\n    }\n    return -1; // In case n is invalid, though the problem guarantees n >= 1\n}\n\n// Example usage\n"}
{"task_id": "CPP/40", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nbool triples_sum_to_zero(vector<int> l) {\n    sort(l.begin(), l.end());\n    int n = l.size();\n    \n    for (int i = 0; i < n - 2; i++) {\n        int left = i + 1;\n        int right = n - 1;\n        \n        while (left < right) {\n            int sum = l[i] + l[left] + l[right];\n            if (sum == 0) {\n                return true;\n            } else if (sum < 0) {\n                left++;\n            } else {\n                right--;\n            }\n        }\n    }\n    return false;\n}\n"}
{"task_id": "CPP/41", "generation": "#include<stdio.h>\nusing namespace std;\n\nint car_race_collision(int n) {\n    return n * n; // Total collisions are n squared\n}\n"}
{"task_id": "CPP/42", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> incr_vector(vector<int> l) {\n    vector<int> result; // Create an empty vector to store the results\n    for (int i = 0; i < l.size(); i++) {\n        result.push_back(l[i] + 1); // Increment each element by 1 and add to result\n    }\n    return result; // Return the result vector\n}\n"}
{"task_id": "CPP/43", "generation": "#include <stdio.h>\n#include <vector>\n#include <unordered_set>\nusing namespace std;\n\nbool pairs_sum_to_zero(vector<int> l) {\n    unordered_set<int> seen; // Using an unordered set for O(1) average time complexity\n    for (int number : l) {\n        if (seen.find(-number) != seen.end()) {\n            return true; // Found a pair that sums to zero\n        }\n        seen.insert(number); // Add the current number to the set\n    }\n    return false; // No pairs found\n}\n"}
{"task_id": "CPP/44", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nstring change_base(int x, int base) {\n    // Validate base\n    if (base < 2 || base >= 10) {\n        return \"Invalid base\";\n    }\n    \n    // Handle the case for zero\n    if (x == 0) {\n        return \"0\";\n    }\n    \n    string result = \"\";\n    while (x > 0) {\n        int remainder = x % base;\n        result = to_string(remainder) + result; // Prepend the remainder\n        x = x / base; // Integer division\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/45", "generation": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n\nfloat triangle_area(float a, float h) {\n    float area = (1.0 / 2.0) * a * h; // Calculate area using the formula\n    return area; // Return the calculated area\n}\n"}
{"task_id": "CPP/46", "generation": "#include <stdio.h>\nusing namespace std;\n\nint fib4(int n) {\n    if (n == 0) return 0;\n    if (n == 1) return 0;\n    if (n == 2) return 2;\n    if (n == 3) return 0;\n\n    int fib[4] = {0, 0, 2, 0}; // Initialize the first four values\n\n    for (int i = 4; i <= n; i++) {\n        fib[i % 4] = fib[(i - 1) % 4] + fib[(i - 2) % 4] + fib[(i - 3) % 4] + fib[(i - 4) % 4];\n    }\n\n    return fib[n % 4]; // Return the result\n}\n"}
{"task_id": "CPP/47", "generation": "#include <stdio.h>\n#include <math.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nfloat median(vector<float> l) {\n    // Step 1: Sort the vector\n    sort(l.begin(), l.end());\n    \n    // Step 2: Determine the size of the vector\n    int n = l.size();\n    \n    // Step 3: Calculate the median based on the size\n    if (n % 2 == 1) {\n        // If odd, return the middle element\n        return l[n / 2];\n    } else {\n        // If even, return the average of the two middle elements\n        return (l[n / 2 - 1] + l[n / 2]) / 2.0;\n    }\n}\n"}
{"task_id": "CPP/48", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nbool is_palindrome(string text) {\n    // Base case: empty string is a palindrome\n    if (text.empty()) {\n        return true;\n    }\n    \n    int left = 0;\n    int right = text.length() - 1;\n    \n    while (left < right) {\n        if (text[left] != text[right]) {\n            return false; // Not a palindrome\n        }\n        left++;\n        right--;\n    }\n    \n    return true; // It's a palindrome\n}\n"}
{"task_id": "CPP/49", "generation": "#include<stdio.h>\nusing namespace std;\n\nint modp(int n, int p) {\n    if (n == 0) return 1; // 2^0 = 1\n    if (p == 1) return 0; // Any number mod 1 is 0, but we return 1 for n = 0 case\n\n    long long result = 1; // Use long long to prevent overflow\n    long long base = 2;   // Base is 2\n\n    while (n > 0) {\n        if (n % 2 == 1) { // If n is odd\n            result = (result * base) % p; // Multiply result by base and take mod p\n        }\n        base = (base * base) % p; // Square the base and take mod p\n        n /= 2; // Divide n by 2\n    }\n    \n    return result; // Return the final result\n}\n"}
{"task_id": "CPP/50", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nstring encode_shift(string s) {\n    // returns encoded string by shifting every character by 5 in the alphabet.\n    string out;\n    for (int i = 0; i < s.length(); i++) {\n        int w = ((int)s[i] + 5 - (int)'a') % 26 + (int)'a';   \n        out = out + (char)w;\n    }\n    return out;\n}\n\nstring decode_shift(string s) {\n    // takes as input string encoded with encode_shift function. Returns decoded string.\n    string out;\n    for (int i = 0; i < s.length(); i++) {\n        int w = ((int)s[i] - 5 - (int)'a' + 26) % 26 + (int)'a'; // Wrap around if necessary\n        out = out + (char)w;\n    }\n    return out;\n}\n"}
{"task_id": "CPP/51", "generation": "#include <stdio.h>\n#include <string>\n#include <algorithm>\n#include <unordered_set>\nusing namespace std;\n\nstring remove_vowels(string text) {\n    string result = \"\";\n    unordered_set<char> vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'};\n    \n    for (char c : text) {\n        if (vowels.find(c) == vowels.end()) { // If c is not a vowel\n            result += c; // Append to result\n        }\n    }\n    \n    return result; // Return the string without vowels\n}\n"}
{"task_id": "CPP/52", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nbool below_threshold(vector<int> l, int t) {\n    for (int num : l) {\n        if (num >= t) {\n            return false; // Found a number that is not below the threshold\n        }\n    }\n    return true; // All numbers are below the threshold\n}\n"}
{"task_id": "CPP/53", "generation": "#include<stdio.h>\n#include<stdlib.h>\nusing namespace std;\n\nint add(int x, int y) {\n    return x + y; // Return the sum of x and y\n}\n"}
{"task_id": "CPP/54", "generation": "#include <stdio.h>\n#include <string>\n#include <set>\n#include <algorithm>\nusing namespace std;\n\nbool same_chars(string s0, string s1) {\n    // Create sets to hold unique characters\n    set<char> unique_chars_s0(s0.begin(), s0.end());\n    set<char> unique_chars_s1(s1.begin(), s1.end());\n    \n    // If the sizes of the unique character sets are different, return false\n    if (unique_chars_s0.size() != unique_chars_s1.size()) {\n        return false;\n    }\n    \n    // Convert sets to sorted vectors for comparison\n    vector<char> sorted_s0(unique_chars_s0.begin(), unique_chars_s0.end());\n    vector<char> sorted_s1(unique_chars_s1.begin(), unique_chars_s1.end());\n    \n    // Compare the sorted vectors\n    return sorted_s0 == sorted_s1;\n}\n"}
{"task_id": "CPP/55", "generation": "#include<stdio.h>\nusing namespace std;\n\nint fib(int n) {\n    if (n == 0) return 0; // Base case for fib(0)\n    if (n == 1) return 1; // Base case for fib(1)\n\n    int a = 0; // fib(0)\n    int b = 1; // fib(1)\n    for (int i = 2; i <= n; i++) {\n        int temp = b; // Store current fib(n-1)\n        b = a + b;    // Calculate fib(n)\n        a = temp;     // Update a to fib(n-1)\n    }\n    return b; // Return fib(n)\n}\n"}
{"task_id": "CPP/56", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    int count = 0; // Initialize the counter for opening brackets\n    for (char ch : brackets) {\n        if (ch == '<') {\n            count++; // Increment for opening bracket\n        } else if (ch == '>') {\n            count--; // Decrement for closing bracket\n        }\n        // If count goes negative, return false\n        if (count < 0) {\n            return false;\n        }\n    }\n    // Return true if all opening brackets are matched\n    return count == 0;\n}\n"}
{"task_id": "CPP/57", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nbool monotonic(vector<float> l) {\n    if (l.size() < 2) {\n        return true; // A single element or empty vector is trivially monotonic\n    }\n    \n    bool isIncreasing = false;\n    bool isDecreasing = false;\n    \n    for (size_t i = 0; i < l.size() - 1; i++) {\n        if (l[i] < l[i + 1]) {\n            isIncreasing = true;\n        } else if (l[i] > l[i + 1]) {\n            isDecreasing = true;\n        }\n        \n        // If both flags are true, the sequence is neither increasing nor decreasing\n        if (isIncreasing && isDecreasing) {\n            return false;\n        }\n    }\n    \n    return true; // The sequence is either increasing or decreasing\n}\n"}
{"task_id": "CPP/58", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> common(vector<int> l1, vector<int> l2) {\n    // Sort both vectors\n    sort(l1.begin(), l1.end());\n    sort(l2.begin(), l2.end());\n    \n    vector<int> result;\n    int i = 0, j = 0;\n\n    // Use two pointers to find common elements\n    while (i < l1.size() && j < l2.size()) {\n        if (l1[i] == l2[j]) {\n            // Check if the element is already in the result\n            if (result.empty() || result.back() != l1[i]) {\n                result.push_back(l1[i]);\n            }\n            i++;\n            j++;\n        } else if (l1[i] < l2[j]) {\n            i++;\n        } else {\n            j++;\n        }\n    }\n\n    // The result is already sorted due to the nature of the algorithm\n    return result;\n}\n"}
{"task_id": "CPP/59", "generation": "#include <stdio.h>\n#include <cmath>\nusing namespace std;\n\nint largest_prime_factor(int n) {\n    int largest_factor = 0;\n\n    // Check for number of 2s that divide n\n    while (n % 2 == 0) {\n        largest_factor = 2;\n        n = n / 2;\n    }\n\n    // n must be odd at this point, so we can skip even numbers\n    for (int i = 3; i <= sqrt(n); i += 2) {\n        while (n % i == 0) {\n            largest_factor = i;\n            n = n / i;\n        }\n    }\n\n    // This condition is to check if n is a prime number greater than 2\n    if (n > 2) {\n        largest_factor = n;\n    }\n\n    return largest_factor;\n}\n"}
{"task_id": "CPP/60", "generation": "#include<stdio.h>\nusing namespace std;\n\nint sum_to_n(int n) {\n    return (n * (n + 1)) / 2;\n}\n"}
{"task_id": "CPP/61", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    int counter = 0;\n    for (char ch : brackets) {\n        if (ch == '(') {\n            counter++;\n        } else if (ch == ')') {\n            counter--;\n        }\n        if (counter < 0) {\n            return false; // More closing brackets than opening\n        }\n    }\n    return counter == 0; // Check if all opening brackets are matched\n}\n"}
{"task_id": "CPP/62", "generation": "#include <vector>\nusing namespace std;\n\nvector<float> derivative(vector<float> xs) {\n    vector<float> result;\n    for (int i = 1; i < xs.size(); i++) {\n        result.push_back(i * xs[i]);\n    }\n    return result;\n}\n"}
{"task_id": "CPP/63", "generation": "#include <stdio.h>\nusing namespace std;\n\nint fibfib(int n) {\n    // Base cases\n    if (n == 0) return 0;\n    if (n == 1) return 0;\n    if (n == 2) return 1;\n\n    // Variables to store the last three FibFib numbers\n    int a = 0; // fibfib(0)\n    int b = 0; // fibfib(1)\n    int c = 1; // fibfib(2)\n    int result;\n\n    // Iteratively calculate fibfib(n)\n    for (int i = 3; i <= n; i++) {\n        result = a + b + c; // fibfib(n) = fibfib(n-1) + fibfib(n-2) + fibfib(n-3)\n        a = b; // Move to the next number\n        b = c; // Move to the next number\n        c = result; // Update the last number\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/64", "generation": "#include <stdio.h>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nint vowels_count(string s) {\n    int count = 0;\n    int length = s.length();\n    \n    for (int i = 0; i < length; i++) {\n        char ch = tolower(s[i]); // Convert to lowercase for uniformity\n        if (ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u') {\n            count++;\n        } else if (ch == 'y' && i == length - 1) { // Check if 'y' is at the end\n            count++;\n        }\n    }\n    \n    return count;\n}\n"}
{"task_id": "CPP/65", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nstring circular_shift(int x, int shift) {\n    string str_x = to_string(x); // Convert integer to string\n    int len = str_x.length(); // Get the length of the string\n    \n    if (shift > len) {\n        // If shift is greater than the number of digits, return reversed string\n        reverse(str_x.begin(), str_x.end());\n        return str_x;\n    } else {\n        // Calculate effective shift\n        int effective_shift = shift % len;\n        // Perform circular shift\n        return str_x.substr(len - effective_shift) + str_x.substr(0, len - effective_shift);\n    }\n}\n"}
{"task_id": "CPP/66", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nint digitSum(string s) {\n    int sum = 0; // Initialize sum to 0\n    for (char c : s) { // Iterate through each character in the string\n        if (c >= 'A' && c <= 'Z') { // Check if the character is uppercase\n            sum += static_cast<int>(c); // Add the ASCII value of the uppercase character to sum\n        }\n    }\n    return sum; // Return the total sum\n}\n"}
{"task_id": "CPP/67", "generation": "#include <stdio.h>\n#include <string>\n#include <sstream>\n#include <iostream>\nusing namespace std;\n\nint fruit_distribution(string s, int n) {\n    int apples = 0, oranges = 0;\n    \n    // Find the number of apples\n    size_t apple_pos = s.find(\"apples\");\n    if (apple_pos != string::npos) {\n        // Extract the number before \"apples\"\n        stringstream ss(s.substr(0, apple_pos));\n        ss >> apples;\n    }\n    \n    // Find the number of oranges\n    size_t orange_pos = s.find(\"oranges\");\n    if (orange_pos != string::npos) {\n        // Extract the number before \"oranges\"\n        stringstream ss(s.substr(0, orange_pos));\n        ss >> oranges;\n    }\n    \n    // Calculate the number of mangoes\n    int mangoes = n - apples - oranges;\n    \n    return mangoes;\n}\n"}
{"task_id": "CPP/68", "generation": "#include <stdio.h>\n#include <vector>\n#include <limits.h> // for INT_MAX\nusing namespace std;\n\nvector<int> pluck(vector<int> arr) {\n    int smallest_even_value = INT_MAX;\n    int smallest_even_index = -1;\n\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] % 2 == 0) { // Check if the number is even\n            if (arr[i] < smallest_even_value) { // Check if it's the smallest even\n                smallest_even_value = arr[i];\n                smallest_even_index = i;\n            }\n        }\n    }\n\n    if (smallest_even_index == -1) {\n        return {}; // Return empty vector if no even number found\n    } else {\n        return {smallest_even_value, smallest_even_index}; // Return the result\n    }\n}\n"}
{"task_id": "CPP/69", "generation": "#include <stdio.h>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint search(vector<int> lst) {\n    unordered_map<int, int> frequencyMap;\n    \n    // Count the frequency of each integer\n    for (int num : lst) {\n        frequencyMap[num]++;\n    }\n    \n    int greatestValidInteger = -1;\n    \n    // Check for the greatest integer that meets the criteria\n    for (const auto& entry : frequencyMap) {\n        int number = entry.first;\n        int frequency = entry.second;\n        \n        // Check if the frequency is greater than or equal to the number\n        if (number > 0 && frequency >= number) {\n            greatestValidInteger = max(greatestValidInteger, number);\n        }\n    }\n    \n    return greatestValidInteger;\n}\n"}
{"task_id": "CPP/70", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> strange_sort_list(vector<int> lst) {\n    if (lst.empty()) {\n        return {};\n    }\n    \n    // Sort the list in ascending order\n    sort(lst.begin(), lst.end());\n    \n    vector<int> result;\n    int left = 0;\n    int right = lst.size() - 1;\n    \n    // Alternate between minimum and maximum\n    while (left <= right) {\n        result.push_back(lst[left]); // Add minimum\n        left++;\n        if (left <= right) {\n            result.push_back(lst[right]); // Add maximum\n            right--;\n        }\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/71", "generation": "#include <stdio.h>\n#include <math.h>\n#include <iomanip> // for std::setprecision\nusing namespace std;\n\nfloat triangle_area(float a, float b, float c) {\n    // Check for valid triangle\n    if ((a + b <= c) || (a + c <= b) || (b + c <= a)) {\n        return -1;\n    }\n    \n    // Calculate semi-perimeter\n    float s = (a + b + c) / 2;\n    \n    // Calculate area using Heron's formula\n    float area = sqrt(s * (s - a) * (s - b) * (s - c));\n    \n    // Return area rounded to 2 decimal points\n    return round(area * 100) / 100; // rounding to 2 decimal points\n}\n"}
{"task_id": "CPP/72", "generation": "#include <stdio.h>\n#include <vector>\n#include <numeric> // for std::accumulate\nusing namespace std;\n\nbool will_it_fly(vector<int> q, int w) {\n    int n = q.size();\n    \n    // Check if the vector is a palindrome\n    for (int i = 0; i < n / 2; i++) {\n        if (q[i] != q[n - i - 1]) {\n            return false; // Not a palindrome\n        }\n    }\n    \n    // Calculate the sum of the elements\n    int total_sum = accumulate(q.begin(), q.end(), 0);\n    \n    // Check if the sum is less than or equal to w\n    return total_sum <= w;\n}\n"}
{"task_id": "CPP/73", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nint smallest_change(vector<int> arr) {\n    int n = arr.size();\n    int change_count = 0;\n    \n    for (int i = 0; i < n / 2; i++) {\n        if (arr[i] != arr[n - 1 - i]) {\n            change_count++;\n        }\n    }\n    \n    return change_count;\n}\n"}
{"task_id": "CPP/74", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> total_match(vector<string> lst1, vector<string> lst2) {\n    int total1 = 0;\n    int total2 = 0;\n\n    // Calculate total characters in lst1\n    for (const string& str : lst1) {\n        total1 += str.length();\n    }\n\n    // Calculate total characters in lst2\n    for (const string& str : lst2) {\n        total2 += str.length();\n    }\n\n    // Compare totals and return the appropriate vector\n    if (total1 < total2) {\n        return lst1;\n    } else if (total2 < total1) {\n        return lst2;\n    } else {\n        return lst1; // If equal, return lst1\n    }\n}\n"}
{"task_id": "CPP/75", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nbool is_multiply_prime(int a) {\n    vector<int> primes = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97};\n    \n    for (int i = 0; i < primes.size(); i++) {\n        for (int j = 0; j < primes.size(); j++) {\n            for (int k = 0; k < primes.size(); k++) {\n                int product = primes[i] * primes[j] * primes[k];\n                if (product == a) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n"}
{"task_id": "CPP/76", "generation": "#include <stdio.h>\n#include <math.h>\nusing namespace std;\n\nbool is_simple_power(int x, int n) {\n    if (n == 1) {\n        return x == 1; // 1^k = 1 only if k is 0\n    }\n    if (x == 1) {\n        return true; // n^0 = 1 for any n\n    }\n    \n    int power = 1; // Start with n^0\n    while (power < x) {\n        power *= n; // Multiply by n to get the next power\n        if (power == x) {\n            return true; // Found the exact power\n        }\n    }\n    return false; // No power of n equals x\n}\n"}
{"task_id": "CPP/77", "generation": "#include <cmath>\nusing namespace std;\n\nbool iscube(int a) {\n    if (a == 0) {\n        return true;\n    }\n    int n = round(cbrt(a));\n    return n * n * n == a;\n}\n"}
{"task_id": "CPP/78", "generation": "#include <stdio.h>\n#include <string>\n#include <unordered_set>\nusing namespace std;\n\nint hex_key(string num) {\n    // Set of prime hexadecimal digits\n    unordered_set<char> primeHexDigits = {'2', '3', '5', '7', 'B', 'D'};\n    int count = 0;\n\n    // Iterate through each character in the string\n    for (char c : num) {\n        // Check if the character is a prime hexadecimal digit\n        if (primeHexDigits.find(c) != primeHexDigits.end()) {\n            count++;\n        }\n    }\n\n    return count; // Return the count of prime hexadecimal digits\n}\n"}
{"task_id": "CPP/79", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nstring decimal_to_binary(int decimal) {\n    string binaryString = \"\";\n    \n    // Handle the case for 0\n    if (decimal == 0) {\n        binaryString = \"0\";\n    } else {\n        while (decimal > 0) {\n            // Prepend the remainder (0 or 1) to the binary string\n            binaryString = to_string(decimal % 2) + binaryString;\n            // Update decimal to the quotient\n            decimal /= 2;\n        }\n    }\n    \n    // Return the formatted string with \"db\" at both ends\n    return \"db\" + binaryString + \"db\";\n}\n"}
{"task_id": "CPP/80", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nbool is_happy(string s) {\n    // Check if the length of the string is less than 3\n    if (s.length() < 3) {\n        return false;\n    }\n    \n    // Iterate through the string to check every group of three characters\n    for (int i = 0; i <= s.length() - 3; i++) {\n        // Check if any of the three consecutive characters are the same\n        if (s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]) {\n            return false;\n        }\n    }\n    \n    // If all groups of three are distinct, return true\n    return true;\n}\n"}
{"task_id": "CPP/81", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> numerical_letter_grade(vector<float> grades) {\n    vector<string> result;\n    for (float grade : grades) {\n        if (grade == 4.0) {\n            result.push_back(\"A+\");\n        } else if (grade > 3.7) {\n            result.push_back(\"A\");\n        } else if (grade > 3.3) {\n            result.push_back(\"A-\");\n        } else if (grade > 3.0) {\n            result.push_back(\"B+\");\n        } else if (grade > 2.7) {\n            result.push_back(\"B\");\n        } else if (grade > 2.3) {\n            result.push_back(\"B-\");\n        } else if (grade > 2.0) {\n            result.push_back(\"C+\");\n        } else if (grade > 1.7) {\n            result.push_back(\"C\");\n        } else if (grade > 1.3) {\n            result.push_back(\"C-\");\n        } else if (grade > 1.0) {\n            result.push_back(\"D+\");\n        } else if (grade > 0.7) {\n            result.push_back(\"D\");\n        } else if (grade > 0.0) {\n            result.push_back(\"D-\");\n        } else {\n            result.push_back(\"E\");\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/82", "generation": "#include <stdio.h>\n#include <string>\n#include <cmath>\nusing namespace std;\n\nbool prime_length(string str) {\n    int length = str.length();\n    \n    // Check if length is less than 2\n    if (length < 2) {\n        return false;\n    }\n    \n    // Check for factors from 2 to sqrt(length)\n    for (int i = 2; i <= sqrt(length); i++) {\n        if (length % i == 0) {\n            return false; // Not a prime number\n        }\n    }\n    \n    return true; // It's a prime number\n}\n"}
{"task_id": "CPP/83", "generation": "#include <cmath>\nusing namespace std;\n\nint starts_one_ends(int n) {\n    if (n == 1) {\n        return 1; // Only the number '1'\n    }\n    if (n == 2) {\n        return 1; // Only the number '11'\n    }\n    \n    int count_start_with_1 = pow(10, n - 1);\n    int count_end_with_1 = 9 * pow(10, n - 2);\n    int count_both_start_and_end_with_1 = pow(10, n - 2);\n    \n    int total_count = count_start_with_1 + count_end_with_1 - count_both_start_and_end_with_1;\n    return total_count;\n}\n"}
{"task_id": "CPP/84", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nstring solve(int N) {\n    int sum = 0;\n    \n    // Calculate the sum of digits\n    while (N > 0) {\n        sum += N % 10; // Add the last digit to sum\n        N /= 10;       // Remove the last digit\n    }\n    \n    // Convert sum to binary\n    string binary = \"\";\n    if (sum == 0) {\n        return \"0\"; // Special case for sum = 0\n    }\n    \n    while (sum > 0) {\n        binary = to_string(sum % 2) + binary; // Prepend the binary digit\n        sum /= 2; // Divide sum by 2\n    }\n    \n    return binary; // Return the binary representation of the sum\n}\n"}
{"task_id": "CPP/85", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nint add(vector<int> lst) {\n    int sum = 0; // Initialize sum to 0\n    for (int i = 1; i < lst.size(); i += 2) { // Loop through odd indices\n        if (lst[i] % 2 == 0) { // Check if the element is even\n            sum += lst[i]; // Add to sum\n        }\n    }\n    return sum; // Return the total sum\n}\n"}
{"task_id": "CPP/86", "generation": "#include <stdio.h>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nstring anti_shuffle(string s) {\n    string result = \"\";\n    string currentWord = \"\";\n    \n    for (char c : s) {\n        if (c != ' ') {\n            currentWord += c; // Build the current word\n        } else {\n            if (!currentWord.empty()) {\n                sort(currentWord.begin(), currentWord.end()); // Sort the current word\n                result += currentWord; // Append sorted word to result\n                currentWord = \"\"; // Reset current word\n            }\n            result += ' '; // Append space to result\n        }\n    }\n    \n    // Handle the last word if it exists\n    if (!currentWord.empty()) {\n        sort(currentWord.begin(), currentWord.end());\n        result += currentWord;\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/87", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<vector<int>> get_row(vector<vector<int>> lst, int x) {\n    vector<vector<int>> result;\n\n    // Iterate through each row\n    for (int i = 0; i < lst.size(); i++) {\n        // Iterate through each column in the current row\n        for (int j = 0; j < lst[i].size(); j++) {\n            // Check if the current element matches x\n            if (lst[i][j] == x) {\n                result.push_back({i, j}); // Store the coordinates\n            }\n        }\n    }\n\n    // Sort the result: first by row (ascending), then by column (descending)\n    sort(result.begin(), result.end(), [](const vector<int>& a, const vector<int>& b) {\n        if (a[0] == b[0]) {\n            return a[1] > b[1]; // Sort by column in descending order\n        }\n        return a[0] < b[0]; // Sort by row in ascending order\n    });\n\n    return result;\n}\n"}
{"task_id": "CPP/88", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> sort_array(vector<int> array) {\n    // Handle edge cases\n    if (array.empty()) {\n        return {};\n    }\n    if (array.size() == 1) {\n        return array;\n    }\n\n    // Calculate the sum of the first and last elements\n    int sum = array[0] + array[array.size() - 1];\n\n    // Sort based on the parity of the sum\n    if (sum % 2 == 0) {\n        // Even sum: sort in descending order\n        vector<int> sorted_array = array; // Create a copy\n        sort(sorted_array.begin(), sorted_array.end(), greater<int>());\n        return sorted_array;\n    } else {\n        // Odd sum: sort in ascending order\n        vector<int> sorted_array = array; // Create a copy\n        sort(sorted_array.begin(), sorted_array.end());\n        return sorted_array;\n    }\n}\n"}
{"task_id": "CPP/89", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nstring encrypt(string s) {\n    string result = \"\";\n    for (char c : s) {\n        if (c >= 'a' && c <= 'z') {\n            char new_char = (c - 'a' + 4) % 26 + 'a';\n            result += new_char;\n        } else {\n            result += c; // Keep non-alphabet characters unchanged\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/90", "generation": "#include <stdio.h>\n#include <vector>\n#include <set>\n#include <algorithm>\nusing namespace std;\n\nint next_smallest(vector<int> lst) {\n    if (lst.empty()) {\n        return -1; // Using -1 to represent None in this context\n    }\n    \n    set<int> unique_elements(lst.begin(), lst.end()); // Store unique elements\n    if (unique_elements.size() < 2) {\n        return -1; // Not enough unique elements\n    }\n    \n    vector<int> sorted_unique(unique_elements.begin(), unique_elements.end());\n    return sorted_unique[1]; // Return the second smallest element\n}\n"}
{"task_id": "CPP/91", "generation": "#include <stdio.h>\n#include <string>\n#include <cctype> // for isspace\nusing namespace std;\n\nint is_bored(string S) {\n    int count = 0;\n    size_t start = 0;\n    size_t end;\n\n    while (start < S.length()) {\n        // Find the next delimiter\n        end = S.find_first_of(\".!?\", start);\n        \n        // If no delimiter is found, set end to the length of the string\n        if (end == string::npos) {\n            end = S.length();\n        }\n\n        // Extract the sentence\n        string sentence = S.substr(start, end - start);\n        \n        // Trim leading spaces\n        size_t first_non_space = sentence.find_first_not_of(\" \");\n        if (first_non_space != string::npos) {\n            sentence = sentence.substr(first_non_space);\n        }\n\n        // Check if the sentence starts with \"I\"\n        if (sentence.rfind(\"I\", 0) == 0) { // rfind checks if \"I\" is at the start\n            count++;\n        }\n\n        // Move start to the character after the delimiter\n        start = end + 1;\n    }\n\n    return count;\n}\n"}
{"task_id": "CPP/92", "generation": "#include <stdio.h>\n#include <math.h>\nusing namespace std;\n\nbool any_int(float a, float b, float c) {\n    // Check if all numbers are integers\n    if (floor(a) == a && floor(b) == b && floor(c) == c) {\n        // Check the sum conditions\n        return (a == b + c) || (b == a + c) || (c == a + b);\n    }\n    return false; // Return false if any number is not an integer\n}\n"}
{"task_id": "CPP/93", "generation": "#include <stdio.h>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nstring encode(string message) {\n    string result = \"\";\n    for (char c : message) {\n        // Check if the character is a vowel and replace accordingly\n        if (c == 'a') result += 'c';\n        else if (c == 'e') result += 'g';\n        else if (c == 'i') result += 'k';\n        else if (c == 'o') result += 'q';\n        else if (c == 'u') result += 'w';\n        else if (c == 'A') result += 'C';\n        else if (c == 'E') result += 'G';\n        else if (c == 'I') result += 'K';\n        else if (c == 'O') result += 'Q';\n        else if (c == 'U') result += 'W';\n        // If it's a letter but not a vowel, swap the case\n        else if (isalpha(c)) result += islower(c) ? toupper(c) : tolower(c);\n        // If it's not a letter, keep it unchanged\n        else result += c;\n    }\n    return result;\n}\n"}
{"task_id": "CPP/94", "generation": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\n// Function to check if a number is prime\nbool isPrime(int num) {\n    if (num <= 1) return false;\n    for (int i = 2; i <= sqrt(num); i++) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\n// Function to calculate the sum of digits of a number\nint sumOfDigits(int num) {\n    int sum = 0;\n    while (num > 0) {\n        sum += num % 10;\n        num /= 10;\n    }\n    return sum;\n}\n\n// Main function to find the largest prime and return the sum of its digits\nint largestPrimeSum(vector<int> lst) {\n    int largestPrime = -1;\n    for (int number : lst) {\n        if (isPrime(number)) {\n            if (number > largestPrime) {\n                largestPrime = number;\n            }\n        }\n    }\n    if (largestPrime == -1) {\n        return 0; // No prime found\n    }\n    return sumOfDigits(largestPrime);\n}\n\n// Example usage\n"}
{"task_id": "CPP/95", "generation": "#include <stdio.h>\n#include <string>\n#include <map>\n#include <cctype> // for islower and isupper\nusing namespace std;\n\nbool check_dict_case(map<string, string> dict) {\n    // Check if the map is empty\n    if (dict.empty()) {\n        return false;\n    }\n\n    bool hasLower = false;\n    bool hasUpper = false;\n\n    for (const auto& pair : dict) {\n        const string& key = pair.first;\n\n        // Check if the key is lowercase\n        bool isLower = true;\n        bool isUpper = true;\n\n        for (char c : key) {\n            if (!islower(c)) {\n                isLower = false;\n            }\n            if (!isupper(c)) {\n                isUpper = false;\n            }\n        }\n\n        // Update the flags based on the current key\n        if (isLower) {\n            hasLower = true;\n        }\n        if (isUpper) {\n            hasUpper = true;\n        }\n\n        // If both lower and upper case keys are found, return false\n        if (hasLower && hasUpper) {\n            return false;\n        }\n    }\n\n    // If we only have lower or only upper case keys, return true\n    return hasLower || hasUpper;\n}\n"}
{"task_id": "CPP/96", "generation": "#include <stdio.h>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\nbool is_prime(int x) {\n    if (x <= 1) return false; // 0 and 1 are not prime\n    for (int j = 2; j <= sqrt(x); j++) {\n        if (x % j == 0) return false; // Found a divisor, not prime\n    }\n    return true; // No divisors found, it's prime\n}\n\nvector<int> count_up_to(int n) {\n    vector<int> primes;\n    if (n < 2) return primes; // No primes less than 2\n    for (int i = 2; i < n; i++) {\n        if (is_prime(i)) {\n            primes.push_back(i); // Add prime to the list\n        }\n    }\n    return primes; // Return the list of primes\n}\n"}
{"task_id": "CPP/97", "generation": "#include<stdio.h>\nusing namespace std;\n\nint multiply(int a, int b) {\n    int unit_digit_a = abs(a) % 10; // Get the unit digit of a\n    int unit_digit_b = abs(b) % 10; // Get the unit digit of b\n    int product = unit_digit_a * unit_digit_b; // Calculate the product\n    return product; // Return the result\n}\n"}
{"task_id": "CPP/98", "generation": "#include <stdio.h>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nint count_upper(string s) {\n    int count = 0;\n    for (int i = 0; i < s.length(); i += 2) { // Iterate through even indices\n        char c = s[i];\n        if (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') { // Check for uppercase vowels\n            count++; // Increment count if it's an uppercase vowel\n        }\n    }\n    return count; // Return the final count\n}\n"}
{"task_id": "CPP/99", "generation": "#include <stdio.h>\n#include <math.h>\n#include <string>\n#include <cstdlib> // for std::atof\nusing namespace std;\n\nint closest_integer(string value) {\n    // Convert string to float\n    float num = atof(value.c_str());\n    \n    // Find the two closest integers\n    int lower = floor(num);\n    int upper = ceil(num);\n    \n    // Calculate distances\n    float lowerDistance = abs(num - lower);\n    float upperDistance = abs(num - upper);\n    \n    // Determine which integer to return\n    if (lowerDistance < upperDistance) {\n        return lower;\n    } else if (upperDistance < lowerDistance) {\n        return upper;\n    } else { // They are equal\n        if (num > 0) {\n            return upper; // Round away from zero\n        } else {\n            return lower; // Round away from zero\n        }\n    }\n}\n"}
{"task_id": "CPP/100", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> make_a_pile(int n) {\n    vector<int> stones;\n    for (int i = 0; i < n; i++) {\n        stones.push_back(n + 2 * i); // Calculate the number of stones for each level\n    }\n    return stones;\n}\n"}
{"task_id": "CPP/101", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> words_string(string s) {\n    vector<string> words;\n    string current_word;\n    \n    for (char c : s) {\n        if (c != ' ' && c != ',') {\n            current_word += c; // Build the current word\n        } else {\n            if (!current_word.empty()) {\n                words.push_back(current_word); // Add the word to the vector\n                current_word.clear(); // Reset for the next word\n            }\n        }\n    }\n    \n    // Check if there's a word left to add after the loop\n    if (!current_word.empty()) {\n        words.push_back(current_word);\n    }\n    \n    return words;\n}\n"}
{"task_id": "CPP/102", "generation": "#include<stdio.h>\nusing namespace std;\n\nint choose_num(int x, int y) {\n    // Check if x is greater than y\n    if (x > y) {\n        return -1;\n    }\n    \n    // Determine the largest even number in the range\n    int largest_even;\n    if (y % 2 == 0) {\n        largest_even = y; // y is even\n    } else {\n        largest_even = y - 1; // y is odd, so take y - 1\n    }\n    \n    // Check if the largest even number is within the range [x, y]\n    if (largest_even >= x) {\n        return largest_even;\n    } else {\n        return -1; // No even number in the range\n    }\n}\n"}
{"task_id": "CPP/103", "generation": "#include <stdio.h>\n#include <math.h>\n#include <string>\n#include <bitset>\nusing namespace std;\n\nstring rounded_avg(int n, int m) {\n    if (n > m) {\n        return \"-1\";\n    }\n    \n    // Calculate the sum from n to m\n    long long sum = (m - n + 1) * (n + m) / 2; // Use long long to avoid overflow\n    int count = m - n + 1;\n    \n    // Calculate the average\n    double average = static_cast<double>(sum) / count;\n    \n    // Round down to the nearest integer\n    int rounded_average = static_cast<int>(floor(average));\n    \n    // Convert to binary\n    return bitset<32>(rounded_average).to_string().substr(32 - (rounded_average ? log2(rounded_average) + 1 : 1));\n}\n"}
{"task_id": "CPP/104", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<int> unique_digits(vector<int> x) {\n    vector<int> result;\n\n    for (int num : x) {\n        int temp = num;\n        bool hasEvenDigit = false;\n\n        // Check each digit of the number\n        while (temp > 0) {\n            int digit = temp % 10; // Get the last digit\n            if (digit % 2 == 0) { // Check if it's even\n                hasEvenDigit = true;\n                break; // No need to check further\n            }\n            temp /= 10; // Remove the last digit\n        }\n\n        // If no even digit was found, add to result\n        if (!hasEvenDigit) {\n            result.push_back(num);\n        }\n    }\n\n    // Sort the result vector\n    sort(result.begin(), result.end());\n    return result;\n}\n"}
{"task_id": "CPP/105", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <map>\nusing namespace std;\n\nvector<string> by_length(vector<int> arr) {\n    vector<int> validNumbers;\n    // Filter numbers between 1 and 9\n    for (int num : arr) {\n        if (num >= 1 && num <= 9) {\n            validNumbers.push_back(num);\n        }\n    }\n    \n    // Sort the valid numbers\n    sort(validNumbers.begin(), validNumbers.end());\n    \n    // Reverse the sorted numbers\n    reverse(validNumbers.begin(), validNumbers.end());\n    \n    // Map of integers to their corresponding string names\n    map<int, string> numToString = {\n        {1, \"One\"}, {2, \"Two\"}, {3, \"Three\"}, {4, \"Four\"},\n        {5, \"Five\"}, {6, \"Six\"}, {7, \"Seven\"}, {8, \"Eight\"}, {9, \"Nine\"}\n    };\n    \n    vector<string> result;\n    // Convert numbers to their string names\n    for (int num : validNumbers) {\n        result.push_back(numToString[num]);\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/106", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nvector<int> f(int n) {\n    vector<int> result(n);\n    \n    for (int i = 1; i <= n; i++) {\n        if (i % 2 == 0) { // i is even\n            // Calculate factorial\n            int factorial = 1;\n            for (int j = 1; j <= i; j++) {\n                factorial *= j;\n            }\n            result[i - 1] = factorial;\n        } else { // i is odd\n            // Calculate sum from 1 to i\n            result[i - 1] = (i * (i + 1)) / 2; // Using the formula for sum\n        }\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/107", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nbool is_palindrome(int num) {\n    string str = to_string(num);\n    string rev_str = string(str.rbegin(), str.rend());\n    return str == rev_str;\n}\n\nvector<int> even_odd_palindrome(int n) {\n    int even_count = 0;\n    int odd_count = 0;\n\n    for (int i = 1; i <= n; i++) {\n        if (is_palindrome(i)) {\n            if (i % 2 == 0) {\n                even_count++;\n            } else {\n                odd_count++;\n            }\n        }\n    }\n\n    return {even_count, odd_count};\n}\n"}
{"task_id": "CPP/108", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nint count_nums(vector<int> n) {\n    int count = 0;\n\n    for (int num : n) {\n        int sum = 0;\n        int original_num = num;\n        bool is_negative = num < 0;\n        num = abs(num);\n\n        // Calculate the sum of digits\n        while (num > 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n\n        // If the original number was negative, adjust the sum\n        if (is_negative) {\n            // Subtract twice the first digit (which is negative)\n            int first_digit = original_num / abs(original_num); // This will give -1 for negative numbers\n            sum += first_digit; // Add the first digit as negative\n        }\n\n        // Check if the sum of digits is greater than 0\n        if (sum > 0) {\n            count++;\n        }\n    }\n\n    return count;\n}\n"}
{"task_id": "CPP/109", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nbool move_one_ball(vector<int> arr) {\n    // Check for empty array\n    if (arr.empty()) {\n        return true;\n    }\n    \n    int count_breaks = 0;\n    int n = arr.size();\n    \n    // Count the number of breaks in the order\n    for (int i = 0; i < n - 1; i++) {\n        if (arr[i] > arr[i + 1]) {\n            count_breaks++;\n        }\n    }\n    \n    // If there are more than one breaks, return false\n    if (count_breaks > 1) {\n        return false;\n    }\n    \n    return true;\n}\n"}
{"task_id": "CPP/110", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring exchange(vector<int> lst1, vector<int> lst2) {\n    bool hasOdd = false;\n    bool hasEvenInLst2 = false;\n\n    // Check if lst1 has any odd numbers\n    for (int num : lst1) {\n        if (num % 2 != 0) {\n            hasOdd = true;\n            break;\n        }\n    }\n\n    // If there are no odd numbers in lst1, return \"YES\"\n    if (!hasOdd) {\n        return \"YES\";\n    }\n\n    // Check if lst2 has any even numbers\n    for (int num : lst2) {\n        if (num % 2 == 0) {\n            hasEvenInLst2 = true;\n            break;\n        }\n    }\n\n    // If lst1 has odd numbers and lst2 has even numbers, return \"YES\"\n    if (hasEvenInLst2) {\n        return \"YES\";\n    }\n\n    // Otherwise, return \"NO\"\n    return \"NO\";\n}\n"}
{"task_id": "CPP/111", "generation": "#include <stdio.h>\n#include <string>\n#include <map>\n#include <sstream>\n#include <vector>\n\nusing namespace std;\n\nmap<string, int> histogram(string test) {\n    map<string, int> letterCount;\n    \n    // Check for empty input\n    if (test.empty()) {\n        return {};\n    }\n\n    // Split the string into words\n    stringstream ss(test);\n    string word;\n    while (ss >> word) {\n        letterCount[word]++;\n    }\n\n    // Find the maximum count\n    int maxCount = 0;\n    for (const auto& entry : letterCount) {\n        if (entry.second > maxCount) {\n            maxCount = entry.second;\n        }\n    }\n\n    // Collect all letters with the maximum count\n    map<string, int> result;\n    for (const auto& entry : letterCount) {\n        if (entry.second == maxCount) {\n            result[entry.first] = entry.second;\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/112", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <unordered_set>\n#include <algorithm>\nusing namespace std;\n\nvector<string> reverse_delete(string s, string c) {\n    unordered_set<char> charSet(c.begin(), c.end()); // Create a set of characters to delete\n    string result = \"\"; // Initialize the result string\n\n    // Build the result string by skipping characters in charSet\n    for (char ch : s) {\n        if (charSet.find(ch) == charSet.end()) {\n            result += ch; // Append character if not in charSet\n        }\n    }\n\n    // Check if the result string is a palindrome\n    string reversedResult = result;\n    reverse(reversedResult.begin(), reversedResult.end());\n    bool isPalindrome = (result == reversedResult);\n\n    // Prepare the output\n    return {result, isPalindrome ? \"True\" : \"False\"};\n}\n"}
{"task_id": "CPP/113", "generation": "#include <vector>\n#include <string>\n#include <unordered_set>\nusing namespace std;\n\nvector<string> odd_count(vector<string> lst) {\n    vector<string> output;\n    unordered_set<char> odd_digits = {'1', '3', '5', '7', '9'};\n\n    for (int i = 0; i < lst.size(); i++) {\n        int odd_count = 0;\n        for (char c : lst[i]) {\n            if (odd_digits.find(c) != odd_digits.end()) {\n                odd_count++;\n            }\n        }\n        // Create the output string\n        string result = \"the number of odd elements \" + to_string(odd_count) + \n                        \" in the string \" + to_string(i) + \n                        \" of the \" + to_string(i) + \" input.\";\n        output.push_back(result);\n    }\n    return output;\n}\n"}
{"task_id": "CPP/114", "generation": "#include <stdio.h>\n#include <vector>\n#include <limits.h> // For INT_MAX\nusing namespace std;\n\nlong long minSubArraySum(vector<long long> nums) {\n    long long min_sum = LLONG_MAX; // Initialize to maximum possible value\n    for (size_t i = 0; i < nums.size(); i++) {\n        long long current_sum = 0; // Reset current sum for each starting index\n        for (size_t j = i; j < nums.size(); j++) {\n            current_sum += nums[j]; // Add the current element to the current sum\n            if (current_sum < min_sum) {\n                min_sum = current_sum; // Update min_sum if current_sum is smaller\n            }\n        }\n    }\n    return min_sum; // Return the minimum sum found\n}\n"}
{"task_id": "CPP/115", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nint max_fill(vector<vector<int>> grid, int capacity) {\n    int total_lowers = 0;\n\n    for (const auto& row : grid) {\n        int water_units = 0;\n        // Count the number of 1s in the current row\n        for (int cell : row) {\n            if (cell == 1) {\n                water_units++;\n            }\n        }\n        // Calculate the number of lowers needed for this row\n        if (water_units > 0) {\n            total_lowers += (water_units + capacity - 1) / capacity; // Ceiling division\n        }\n    }\n\n    return total_lowers;\n}\n"}
{"task_id": "CPP/116", "generation": "#include <vector>\n#include <algorithm>\n#include <iostream>\n\nusing namespace std;\n\nint countOnes(int n) {\n    return __builtin_popcount(n); // Count ones for non-negative integers\n}\n\nvector<int> sort_array(vector<int> arr) {\n    // Custom comparator\n    auto compare = [](int x, int y) {\n        int count_x = countOnes(x);\n        int count_y = countOnes(y);\n        if (count_x != count_y) {\n            return count_x < count_y; // Sort by number of ones\n        } else {\n            return x < y; // Sort by value if counts are equal\n        }\n    };\n\n    // Sort the array using the custom comparator\n    sort(arr.begin(), arr.end(), compare);\n    return arr;\n}\n\n// Example usage\n"}
{"task_id": "CPP/117", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <cctype>\n\nusing namespace std;\n\nvector<string> select_words(string s, int n) {\n    vector<string> result;\n    stringstream ss(s);\n    string word;\n\n    // Split the string into words\n    while (ss >> word) {\n        int consonant_count = 0;\n\n        // Count consonants in the word\n        for (char c : word) {\n            // Convert to lowercase for uniformity\n            c = tolower(c);\n            if (isalpha(c) && !(c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u')) {\n                consonant_count++;\n            }\n        }\n\n        // If the count of consonants matches n, add the word to the result\n        if (consonant_count == n) {\n            result.push_back(word);\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/118", "generation": "#include <string>\n#include <set>\nusing namespace std;\n\nstring get_closest_vowel(string word) {\n    set<char> vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'};\n    char last_consonant = '\\0';\n    string closest_vowel = \"\";\n\n    for (int i = word.length() - 1; i >= 0; --i) {\n        if (vowels.count(word[i])) {\n            if (last_consonant != '\\0') {\n                closest_vowel = word[i];\n                break;\n            }\n        } else {\n            last_consonant = word[i];\n        }\n    }\n\n    return closest_vowel;\n}\n"}
{"task_id": "CPP/119", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nbool is_balanced(const string& s) {\n    int balance = 0;\n    for (char c : s) {\n        if (c == '(') {\n            balance++;\n        } else {\n            balance--;\n        }\n        if (balance < 0) {\n            return false; // More ')' than '(' at some point\n        }\n    }\n    return balance == 0; // Must be balanced at the end\n}\n\nstring match_parens(vector<string> lst) {\n    string s1 = lst[0];\n    string s2 = lst[1];\n    \n    // Check both concatenation orders\n    if (is_balanced(s1 + s2) || is_balanced(s2 + s1)) {\n        return \"Yes\";\n    }\n    return \"No\";\n}\n"}
{"task_id": "CPP/120", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> maximum(vector<int> arr, int k) {\n    // Step 1: Handle the case where k is 0\n    if (k == 0) {\n        return {};\n    }\n    \n    // Step 2: Sort the array in descending order\n    sort(arr.begin(), arr.end(), greater<int>());\n    \n    // Step 3: Select the top k elements\n    vector<int> result(arr.begin(), arr.begin() + k);\n    \n    // Step 4: Sort the result in ascending order\n    sort(result.begin(), result.end());\n    \n    // Step 5: Return the result\n    return result;\n}\n"}
{"task_id": "CPP/121", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nint solution(vector<int> lst) {\n    int sum = 0;\n    for (int i = 0; i < lst.size(); i += 2) { // Loop through even indices\n        if (lst[i] % 2 != 0) { // Check if the element is odd\n            sum += lst[i]; // Add to sum if it's odd\n        }\n    }\n    return sum; // Return the final sum\n}\n"}
{"task_id": "CPP/122", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nint add_elements(vector<int> arr, int k) {\n    int sum = 0;\n    for (int i = 0; i < k; i++) {\n        if (arr[i] >= -99 && arr[i] <= 99) {\n            sum += arr[i];\n        }\n    }\n    return sum;\n}\n"}
{"task_id": "CPP/123", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> get_odd_collatz(int n) {\n    vector<int> odd_numbers;\n    \n    while (n != 1) {\n        if (n % 2 != 0) { // Check if n is odd\n            odd_numbers.push_back(n);\n        }\n        // Generate the next term in the Collatz sequence\n        if (n % 2 == 0) {\n            n = n / 2; // n is even\n        } else {\n            n = 3 * n + 1; // n is odd\n        }\n    }\n    \n    odd_numbers.push_back(1); // Add the last term which is always 1\n    sort(odd_numbers.begin(), odd_numbers.end()); // Sort the vector\n    return odd_numbers;\n}\n"}
{"task_id": "CPP/124", "generation": "#include <stdio.h>\n#include <string>\n#include <sstream>\nusing namespace std;\n\nbool valid_date(string date) {\n    // Check if the date string is empty\n    if (date.empty()) return false;\n    \n    // Check if the length is correct\n    if (date.length() != 10) return false;\n\n    // Check for the correct format \"mm-dd-yyyy\"\n    if (date[2] != '-' || date[5] != '-') return false;\n\n    // Extract month, day, and year\n    int month = stoi(date.substr(0, 2));\n    int day = stoi(date.substr(3, 2));\n    \n    // Validate month\n    if (month < 1 || month > 12) return false;\n\n    // Validate day based on month\n    if ((month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) && (day < 1 || day > 31)) {\n        return false;\n    } else if ((month == 4 || month == 6 || month == 9 || month == 11) && (day < 1 || day > 30)) {\n        return false;\n    } else if (month == 2 && (day < 1 || day > 29)) {\n        return false;\n    }\n\n    // If all checks pass, return true\n    return true;\n}\n"}
{"task_id": "CPP/125", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <cctype>\n\nusing namespace std;\n\nvector<string> split_words(string txt) {\n    // Check for whitespace\n    if (txt.find(' ') != string::npos) {\n        // Split by whitespace\n        istringstream iss(txt);\n        vector<string> words((istream_iterator<string>(iss)), istream_iterator<string>());\n        return words;\n    }\n    // Check for commas\n    else if (txt.find(',') != string::npos) {\n        // Split by commas\n        istringstream iss(txt);\n        vector<string> words;\n        string token;\n        while (getline(iss, token, ',')) {\n            words.push_back(token);\n        }\n        return words;\n    }\n    // Count lowercase letters in odd positions\n    else {\n        int count = 0;\n        for (char c : txt) {\n            if (islower(c) && (c - 'a') % 2 == 1) {\n                count++;\n            }\n        }\n        return vector<string>{to_string(count)};\n    }\n}\n"}
{"task_id": "CPP/126", "generation": "#include <stdio.h>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nbool is_sorted(vector<int> lst) {\n    if (lst.size() <= 1) {\n        return true; // An empty or single element list is sorted\n    }\n\n    unordered_map<int, int> frequency;\n\n    for (size_t i = 0; i < lst.size(); i++) {\n        // Check if the current element is greater than the next element\n        if (i < lst.size() - 1 && lst[i] > lst[i + 1]) {\n            return false; // Not sorted\n        }\n        \n        // Count the frequency of each element\n        frequency[lst[i]]++;\n        \n        // If any number appears more than twice, return false\n        if (frequency[lst[i]] > 2) {\n            return false;\n        }\n    }\n\n    return true; // If we reach here, the list is sorted and no number appears more than twice\n}\n"}
{"task_id": "CPP/127", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <cmath>\nusing namespace std;\n\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i <= sqrt(n); i++) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\nstring intersection(vector<int> interval1, vector<int> interval2) {\n    int start1 = interval1[0];\n    int end1 = interval1[1];\n    int start2 = interval2[0];\n    int end2 = interval2[1];\n    \n    int intersection_start = max(start1, start2);\n    int intersection_end = min(end1, end2);\n    \n    if (intersection_start > intersection_end) {\n        return \"NO\";\n    }\n    \n    int length = intersection_end - intersection_start + 1;\n    \n    if (is_prime(length)) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n"}
{"task_id": "CPP/128", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nint prod_signs(vector<int> arr) {\n    if (arr.empty()) {\n        return -32768;\n    }\n    \n    int sum = 0;\n    int sign_product = 1;\n    \n    for (int number : arr) {\n        if (number > 0) {\n            sum += number; // Add magnitude of positive number\n        } else if (number < 0) {\n            sum += -number; // Add magnitude of negative number\n            sign_product *= -1; // Flip sign for negative number\n        } else {\n            sign_product = 0; // If zero is present, product of signs is 0\n        }\n    }\n    \n    return sum * sign_product; // Return the final result\n}\n"}
{"task_id": "CPP/129", "generation": "#include <vector>\n#include <algorithm>\n#include <limits.h>\n\nusing namespace std;\n\nvector<int> bestPath;\n\nvoid dfs(const vector<vector<int>>& grid, int x, int y, vector<int>& currentPath, int k) {\n    if (currentPath.size() == k) {\n        if (bestPath.empty() || currentPath < bestPath) {\n            bestPath = currentPath; // Update bestPath if currentPath is better\n        }\n        return;\n    }\n\n    // Directions for moving in the grid (up, down, left, right)\n    vector<pair<int, int>> directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n    \n    for (const auto& dir : directions) {\n        int nx = x + dir.first;\n        int ny = y + dir.second;\n        \n        // Check if the new position is within bounds\n        if (nx >= 0 && nx < grid.size() && ny >= 0 && ny < grid[0].size()) {\n            currentPath.push_back(grid[nx][ny]); // Move to the neighbor\n            dfs(grid, nx, ny, currentPath, k); // Recur\n            currentPath.pop_back(); // Backtrack\n        }\n    }\n}\n\nvector<int> minPath(vector<vector<int>> grid, int k) {\n    bestPath.clear(); // Clear the bestPath before starting\n    int N = grid.size();\n    \n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            vector<int> currentPath = {grid[i][j]}; // Start path with the current cell\n            dfs(grid, i, j, currentPath, k); // Start DFS from the current cell\n        }\n    }\n    \n    return bestPath; // Return the best path found\n}\n"}
{"task_id": "CPP/130", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nvector<int> tri(int n) {\n    vector<int> result(n + 1);\n    \n    // Base cases\n    if (n >= 0) result[0] = 1; // tri(0)\n    if (n >= 1) result[1] = 3; // tri(1)\n    \n    // Calculate the Tribonacci sequence\n    for (int i = 2; i <= n; i++) {\n        if (i % 2 == 0) {\n            result[i] = 1 + i / 2; // Even case\n        } else {\n            // Odd case\n            result[i] = result[i - 1] + result[i - 2]; // Only previous two\n        }\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/131", "generation": "#include<stdio.h>\nusing namespace std;\n\nint digits(int n) {\n    int product = 1;\n    bool hasOdd = false;\n\n    while (n > 0) {\n        int digit = n % 10; // Get the last digit\n        if (digit % 2 != 0) { // Check if the digit is odd\n            hasOdd = true;\n            product *= digit; // Multiply the product by the odd digit\n        }\n        n /= 10; // Remove the last digit\n    }\n\n    return hasOdd ? product : 0; // Return product if odd digits exist, otherwise return 0\n}\n"}
{"task_id": "CPP/132", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nbool is_nested(string str) {\n    int openCount = 0; // Counter for opening brackets\n    bool hasNested = false; // Flag to check if there's a nested bracket\n\n    for (char ch : str) {\n        if (ch == '[') {\n            openCount++;\n        } else if (ch == ']') {\n            if (openCount > 0) {\n                openCount--; // Match found for an opening bracket\n                if (openCount > 0) {\n                    hasNested = true; // We have at least one nested bracket\n                }\n            } else {\n                // Unmatched closing bracket, return false\n                return false;\n            }\n        }\n    }\n\n    // We need at least one nested bracket to return true\n    return hasNested;\n}\n"}
{"task_id": "CPP/133", "generation": "#include <stdio.h>\n#include <math.h>\n#include <vector>\nusing namespace std;\n\nint sum_squares(vector<float> lst) {\n    int sum = 0; // Initialize sum to 0\n    for (float number : lst) {\n        int rounded_number = ceil(number); // Round up to the nearest integer\n        sum += rounded_number * rounded_number; // Add the square of the rounded number to sum\n    }\n    return sum; // Return the final sum\n}\n"}
{"task_id": "CPP/134", "generation": "#include <iostream>\n#include <string>\n#include <cctype>\n\nusing namespace std;\n\nbool check_if_last_char_is_a_letter(string txt) {\n    // Trim trailing spaces\n    size_t end = txt.find_last_not_of(' ');\n    if (end == string::npos) {\n        return false; // String is empty or consists only of spaces\n    }\n    \n    // Get the trimmed string\n    txt = txt.substr(0, end + 1);\n    \n    // Check the last character\n    char lastChar = txt.back();\n    \n    // Check if the last character is alphabetical\n    if (!isalpha(lastChar)) {\n        return false;\n    }\n    \n    // Check if the last character is part of a word\n    if (txt.size() > 1 && txt[end - 1] == ' ') {\n        return false; // Last character is preceded by a space\n    }\n    \n    return true; // Last character is an alphabetical character and not part of a word\n}\n\n// Example usage\n"}
{"task_id": "CPP/135", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nint can_arrange(vector<int> arr) {\n    int largestIndex = -1; // Initialize to -1\n    for (int i = 1; i < arr.size(); i++) { // Start from the second element\n        if (arr[i] < arr[i - 1]) { // Check if current element is less than the previous one\n            largestIndex = i; // Update largestIndex\n        }\n    }\n    return largestIndex; // Return the largest index found or -1\n}\n"}
{"task_id": "CPP/136", "generation": "#include <stdio.h>\n#include <vector>\n#include <limits.h> // for INT_MIN and INT_MAX\nusing namespace std;\n\nvector<int> largest_smallest_integers(vector<int> lst) {\n    int largest_negative = INT_MIN;\n    int smallest_positive = INT_MAX;\n\n    for (int number : lst) {\n        if (number < 0) {\n            largest_negative = max(largest_negative, number);\n        } else if (number > 0) {\n            smallest_positive = min(smallest_positive, number);\n        }\n    }\n\n    if (largest_negative == INT_MIN) {\n        largest_negative = 0;\n    }\n    if (smallest_positive == INT_MAX) {\n        smallest_positive = 0;\n    }\n\n    return {largest_negative, smallest_positive};\n}\n"}
{"task_id": "CPP/137", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <boost/any.hpp>\n#include <sstream>\n\nboost::any compare_one(boost::any a, boost::any b) {\n    // Helper function to convert string to float\n    auto string_to_float = [](const std::string& str) {\n        std::string normalized = str;\n        std::replace(normalized.begin(), normalized.end(), ',', '.');\n        return std::stof(normalized);\n    };\n\n    // Check types and compare\n    if (a.type() == b.type()) {\n        if (a.type() == typeid(int)) {\n            int int_a = boost::any_cast<int>(a);\n            int int_b = boost::any_cast<int>(b);\n            if (int_a == int_b) return \"None\";\n            return (int_a > int_b) ? a : b;\n        } else if (a.type() == typeid(float)) {\n            float float_a = boost::any_cast<float>(a);\n            float float_b = boost::any_cast<float>(b);\n            if (float_a == float_b) return \"None\";\n            return (float_a > float_b) ? a : b;\n        } else if (a.type() == typeid(std::string)) {\n            std::string str_a = boost::any_cast<std::string>(a);\n            std::string str_b = boost::any_cast<std::string>(b);\n            float float_a = string_to_float(str_a);\n            float float_b = string_to_float(str_b);\n            if (float_a == float_b) return \"None\";\n            return (float_a > float_b) ? a : b;\n        }\n    } else {\n        // Handle mixed types\n        if (a.type() == typeid(std::string)) {\n            std::string str_a = boost::any_cast<std::string>(a);\n            float float_b = boost::any_cast<float>(b);\n            float float_a = string_to_float(str_a);\n            if (float_a == float_b) return \"None\";\n            return (float_a > float_b) ? a : b;\n        } else if (b.type() == typeid(std::string)) {\n            std::string str_b = boost::any_cast<std::string>(b);\n            float float_a = boost::any_cast<float>(a);\n            float float_b = string_to_float(str_b);\n            if (float_a == float_b) return \"None\";\n            return (float_a > float_b) ? b : a;\n        }\n    }\n    return \"None\"; // Fallback case\n}\n\n"}
{"task_id": "CPP/138", "generation": "#include<stdio.h>\nusing namespace std;\n\nbool is_equal_to_sum_even(int n) {\n    if (n < 8) {\n        return false; // Cannot be expressed as the sum of 4 positive even numbers\n    }\n    return n % 2 == 0; // Return true if n is even, false if odd\n}\n"}
{"task_id": "CPP/139", "generation": "#include <stdio.h>\n\nusing namespace std;\n\nlong long special_factorial(int n) {\n    long long result = 1; // To store the final result\n    for (int i = 1; i <= n; i++) {\n        long long factorial = 1; // To calculate i!\n        for (int j = 1; j <= i; j++) {\n            factorial *= j; // Calculate factorial of i\n        }\n        result *= factorial; // Multiply the current factorial to the result\n    }\n    return result; // Return the final result\n}\n"}
{"task_id": "CPP/140", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nstring fix_spaces(string text) {\n    string result = \"\";\n    int spaceCount = 0;\n\n    for (char c : text) {\n        if (c == ' ') {\n            spaceCount++;\n        } else {\n            if (spaceCount > 0) {\n                if (spaceCount == 1) {\n                    result += '_'; // Replace single space with underscore\n                } else {\n                    result += '-'; // Replace more than 2 spaces with hyphen\n                }\n                spaceCount = 0; // Reset space count\n            }\n            result += c; // Append the non-space character\n        }\n    }\n\n    // Handle trailing spaces\n    if (spaceCount > 0) {\n        if (spaceCount == 1) {\n            result += '_'; // Replace single space with underscore\n        } else {\n            result += '-'; // Replace more than 2 spaces with hyphen\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/141", "generation": "#include <stdio.h>\n#include <string>\n#include <cctype> // for isalpha\nusing namespace std;\n\nstring file_name_check(string file_name) {\n    int digit_count = 0;\n    size_t dot_position = file_name.find('.');\n\n    // Check for exactly one dot\n    if (dot_position == string::npos || file_name.find('.', dot_position + 1) != string::npos) {\n        return \"No\";\n    }\n\n    // Split into two parts\n    string name_part = file_name.substr(0, dot_position);\n    string extension_part = file_name.substr(dot_position + 1);\n\n    // Check if the name part is empty or does not start with a letter\n    if (name_part.empty() || !isalpha(name_part[0])) {\n        return \"No\";\n    }\n\n    // Check if the extension is valid\n    if (extension_part != \"txt\" && extension_part != \"exe\" && extension_part != \"dll\") {\n        return \"No\";\n    }\n\n    // Count digits in the entire file name\n    for (char c : file_name) {\n        if (isdigit(c)) {\n            digit_count++;\n        }\n    }\n\n    // Check if there are more than three digits\n    if (digit_count > 3) {\n        return \"No\";\n    }\n\n    // If all checks pass\n    return \"Yes\";\n}\n"}
{"task_id": "CPP/142", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nint sum_squares(vector<int> lst) {\n    int total = 0;\n    for (int i = 0; i < lst.size(); i++) {\n        if (i % 3 == 0) {\n            total += lst[i] * lst[i];  // square the element\n        } else if (i % 4 == 0) {\n            total += lst[i] * lst[i] * lst[i];  // cube the element\n        } else {\n            total += lst[i];  // leave unchanged\n        }\n    }\n    return total;\n}\n"}
{"task_id": "CPP/143", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i <= sqrt(n); i++) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\n// Function to extract words with prime lengths from a sentence\nstring words_in_sentence(string sentence) {\n    stringstream ss(sentence);\n    string word;\n    vector<string> result;\n\n    // Split the sentence into words\n    while (ss >> word) {\n        // Check if the length of the word is prime\n        if (is_prime(word.length())) {\n            result.push_back(word);\n        }\n    }\n\n    // Join the result into a single string\n    string output;\n    for (size_t i = 0; i < result.size(); i++) {\n        output += result[i];\n        if (i < result.size() - 1) {\n            output += \" \"; // Add space between words\n        }\n    }\n    return output;\n}\n"}
{"task_id": "CPP/144", "generation": "#include <stdio.h>\n#include <string>\n#include <sstream>\n#include <vector>\n\nusing namespace std;\n\nbool simplify(string x, string n) {\n    // Split the first fraction\n    size_t pos = x.find('/');\n    int num1 = stoi(x.substr(0, pos));\n    int den1 = stoi(x.substr(pos + 1));\n    \n    // Split the second fraction\n    pos = n.find('/');\n    int num2 = stoi(n.substr(0, pos));\n    int den2 = stoi(n.substr(pos + 1));\n    \n    // Calculate the product's numerator and denominator\n    int num_product = num1 * num2;\n    int den_product = den1 * den2;\n    \n    // Check if the product is a whole number\n    return (num_product % den_product == 0);\n}\n"}
{"task_id": "CPP/145", "generation": "#include <vector>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\n// Helper function to calculate the sum of digits\nint digitSum(int num) {\n    int sum = 0;\n    bool isNegative = num < 0;\n    num = abs(num); // Work with positive value for digit extraction\n    \n    while (num > 0) {\n        sum += num % 10; // Add last digit\n        num /= 10; // Remove last digit\n    }\n    \n    // If the number was negative, we need to account for the first digit\n    if (isNegative) {\n        sum = -sum; // Make the sum negative\n    }\n    \n    return sum;\n}\n\nvector<int> order_by_points(vector<int> nums) {\n    vector<pair<int, int>> indexedNums; // Pair of (digit sum, original index)\n    \n    // Populate the vector with digit sums and original indices\n    for (int i = 0; i < nums.size(); i++) {\n        indexedNums.push_back({digitSum(nums[i]), i});\n    }\n    \n    // Sort based on digit sum and original index\n    sort(indexedNums.begin(), indexedNums.end(), [](const pair<int, int>& a, const pair<int, int>& b) {\n        if (a.first == b.first) {\n            return a.second < b.second; // Maintain original order if digit sums are equal\n        }\n        return a.first < b.first; // Sort by digit sum\n    });\n    \n    // Prepare the result vector\n    vector<int> result;\n    for (const auto& p : indexedNums) {\n        result.push_back(nums[p.second]); // Push the original number based on sorted indices\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/146", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nint specialFilter(vector<int> nums) {\n    int count = 0;\n    for (int number : nums) {\n        if (number > 10) {\n            string numStr = to_string(number);\n            char first_digit = numStr[0];\n            int last_digit = number % 10;\n\n            // Check if both first and last digits are odd\n            if ((first_digit == '1' || first_digit == '3' || first_digit == '5' || first_digit == '7' || first_digit == '9') &&\n                (last_digit % 2 != 0)) {\n                count++;\n            }\n        }\n    }\n    return count;\n}\n"}
{"task_id": "CPP/147", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nint get_max_triples(int n) {\n    vector<int> a(n);\n    for (int i = 1; i <= n; i++) {\n        a[i - 1] = i * i - i + 1; // Fill the vector a\n    }\n\n    int count[3] = {0, 0, 0}; // To count occurrences of a[i] % 3\n    for (int i = 0; i < n; i++) {\n        count[a[i] % 3]++;\n    }\n\n    int total_triples = 0;\n\n    // Count combinations\n    // C(count[0], 3)\n    if (count[0] >= 3) {\n        total_triples += count[0] * (count[0] - 1) * (count[0] - 2) / 6;\n    }\n    // C(count[1], 3)\n    if (count[1] >= 3) {\n        total_triples += count[1] * (count[1] - 1) * (count[1] - 2) / 6;\n    }\n    // C(count[2], 3)\n    if (count[2] >= 3) {\n        total_triples += count[2] * (count[2] - 1) * (count[2] - 2) / 6;\n    }\n    // count[0] * count[1] * count[2]\n    total_triples += count[0] * count[1] * count[2];\n\n    return total_triples;\n}\n"}
{"task_id": "CPP/148", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nvector<string> bf(string planet1, string planet2) {\n    vector<string> planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n    \n    // Check if planet1 and planet2 are valid\n    auto it1 = find(planets.begin(), planets.end(), planet1);\n    auto it2 = find(planets.begin(), planets.end(), planet2);\n    \n    // If either planet is not found, return an empty vector\n    if (it1 == planets.end() || it2 == planets.end()) {\n        return {};\n    }\n    \n    // Get the indices of the planets\n    int index1 = distance(planets.begin(), it1);\n    int index2 = distance(planets.begin(), it2);\n    \n    // Ensure index1 is less than index2\n    if (index1 > index2) {\n        swap(index1, index2);\n    }\n    \n    // Collect planets in between\n    vector<string> result;\n    for (int i = index1 + 1; i < index2; ++i) {\n        result.push_back(planets[i]);\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/149", "generation": "#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nvector<string> sorted_list_sum(vector<string> lst) {\n    vector<string> result;\n\n    // Filter out strings with odd lengths\n    for (const string& str : lst) {\n        if (str.length() % 2 == 0) {\n            result.push_back(str);\n        }\n    }\n\n    // Sort the result vector\n    sort(result.begin(), result.end(), [](const string& a, const string& b) {\n        if (a.length() == b.length()) {\n            return a < b; // Sort alphabetically if lengths are equal\n        }\n        return a.length() < b.length(); // Sort by length\n    });\n\n    return result;\n}\n"}
{"task_id": "CPP/150", "generation": "#include <stdio.h>\n#include <cmath>\n\nusing namespace std;\n\n// Helper function to check if a number is prime\nbool is_prime(int n) {\n    if (n <= 1) return false; // 0 and 1 are not prime numbers\n    for (int i = 2; i <= sqrt(n); i++) {\n        if (n % i == 0) return false; // Found a divisor, not prime\n    }\n    return true; // No divisors found, it is prime\n}\n\n// Main function to return x or y based on the primality of n\nint x_or_y(int n, int x, int y) {\n    if (is_prime(n)) {\n        return x; // n is prime\n    } else {\n        return y; // n is not prime\n    }\n}\n"}
{"task_id": "CPP/151", "generation": "#include <vector>\n#include <cmath>\nusing namespace std;\n\nlong long double_the_difference(vector<float> lst) {\n    long long sum_of_squares = 0; // Initialize sum of squares\n    for (float number : lst) {\n        // Check if number is a positive integer and odd\n        if (number > 0 && floor(number) == number && static_cast<int>(number) % 2 != 0) {\n            sum_of_squares += static_cast<int>(number) * static_cast<int>(number); // Square and add to sum\n        }\n    }\n    return sum_of_squares; // Return the final sum\n}\n"}
{"task_id": "CPP/152", "generation": "#include <vector>\n#include <cmath> // for abs function\nusing namespace std;\n\nvector<int> compare(vector<int> game, vector<int> guess) {\n    vector<int> result; // Initialize the result vector\n    for (size_t i = 0; i < game.size(); i++) {\n        int difference = abs(game[i] - guess[i]); // Calculate absolute difference\n        result.push_back(difference); // Append the difference to the result\n    }\n    return result; // Return the result vector\n}\n"}
{"task_id": "CPP/153", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <cctype> // for isupper and islower\nusing namespace std;\n\nstring Strongest_Extension(string class_name, vector<string> extensions) {\n    int max_strength = -1e9; // Start with a very low strength\n    string strongest_extension = \"\";\n\n    for (const string& extension : extensions) {\n        int CAP = 0;\n        int SM = 0;\n\n        // Count uppercase and lowercase letters\n        for (char c : extension) {\n            if (isupper(c)) {\n                CAP++;\n            } else if (islower(c)) {\n                SM++;\n            }\n        }\n\n        // Calculate strength\n        int strength = CAP - SM;\n\n        // Update if this extension is stronger\n        if (strength > max_strength) {\n            max_strength = strength;\n            strongest_extension = extension;\n        }\n    }\n\n    // Return the result in the required format\n    return class_name + \".\" + strongest_extension;\n}\n"}
{"task_id": "CPP/154", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nbool cycpattern_check(string a, string b) {\n    // Concatenate b with itself to get all rotations\n    string b_rotated = b + b;\n    // Check if a is a substring of b_rotated\n    return b_rotated.find(a) != string::npos;\n}\n"}
{"task_id": "CPP/155", "generation": "#include <stdio.h>\n#include <vector>\n#include <cmath> // for abs function\nusing namespace std;\n\nvector<int> even_odd_count(int num) {\n    vector<int> counts(2, 0); // counts[0] for even, counts[1] for odd\n    num = abs(num); // consider absolute value of num\n\n    while (num > 0) {\n        int digit = num % 10; // extract the last digit\n        if (digit % 2 == 0) {\n            counts[0]++; // increment even count\n        } else {\n            counts[1]++; // increment odd count\n        }\n        num /= 10; // remove the last digit\n    }\n    \n    return counts; // return the counts vector\n}\n"}
{"task_id": "CPP/156", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nstring int_to_mini_roman(int number) {\n    // Mapping of values to Roman numeral symbols\n    vector<pair<int, string>> romanMapping = {\n        {1000, \"m\"}, {900, \"cm\"}, {500, \"d\"}, {400, \"cd\"},\n        {100, \"c\"}, {90, \"xc\"}, {50, \"l\"}, {40, \"xl\"},\n        {10, \"x\"}, {9, \"ix\"}, {5, \"v\"}, {4, \"iv\"},\n        {1, \"i\"}\n    };\n\n    string result = \"\";\n    \n    // Iterate through the mapping\n    for (const auto& [value, symbol] : romanMapping) {\n        while (number >= value) {\n            result += symbol; // Append the symbol\n            number -= value;  // Subtract the value from the number\n        }\n    }\n    \n    return result; // Return the result in lowercase\n}\n"}
{"task_id": "CPP/157", "generation": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n\nbool right_angle_triangle(float a, float b, float c) {\n    // Identify the longest side\n    float hypotenuse, side1, side2;\n    \n    if (a >= b && a >= c) {\n        hypotenuse = a;\n        side1 = b;\n        side2 = c;\n    } else if (b >= a && b >= c) {\n        hypotenuse = b;\n        side1 = a;\n        side2 = c;\n    } else {\n        hypotenuse = c;\n        side1 = a;\n        side2 = b;\n    }\n    \n    // Check the Pythagorean theorem\n    return (pow(side1, 2) + pow(side2, 2) == pow(hypotenuse, 2));\n}\n"}
{"task_id": "CPP/158", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <set>\n#include <algorithm>\nusing namespace std;\n\nstring find_max(vector<string> words) {\n    string bestWord = \"\";\n    int maxUniqueCount = 0;\n\n    for (const string& word : words) {\n        set<char> uniqueChars(word.begin(), word.end()); // Create a set of unique characters\n        int uniqueCount = uniqueChars.size(); // Count of unique characters\n\n        // Check if we found a better word\n        if (uniqueCount > maxUniqueCount) {\n            maxUniqueCount = uniqueCount;\n            bestWord = word;\n        } else if (uniqueCount == maxUniqueCount) {\n            // If counts are the same, check lexicographical order\n            if (word < bestWord) {\n                bestWord = word;\n            }\n        }\n    }\n\n    return bestWord;\n}\n"}
{"task_id": "CPP/159", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nvector<int> eat(int number, int need, int remaining) {\n    int total_eaten = number + need;\n    int remaining_after;\n\n    if (remaining >= need) {\n        remaining_after = remaining - need;\n    } else {\n        total_eaten += remaining; // Eat all remaining carrots\n        remaining_after = 0; // No carrots left\n    }\n\n    return {total_eaten, remaining_after};\n}\n"}
{"task_id": "CPP/160", "generation": "#include <vector>\n#include <string>\n#include <stdexcept>\nusing namespace std;\n\nint do_algebra(vector<string> operato, vector<int> operand) {\n    if (operand.size() < 2 || operato.size() != operand.size() - 1) {\n        throw invalid_argument(\"Invalid input sizes.\");\n    }\n\n    // Step 1: Handle exponentiation first\n    int result = operand[0];\n    for (size_t i = 0; i < operato.size(); ++i) {\n        if (operato[i] == \"**\") {\n            result = pow(result, operand[i + 1]);\n        }\n    }\n\n    // Step 2: Handle multiplication and floor division\n    vector<int> newOperands;\n    newOperands.push_back(result);\n    for (size_t i = 0; i < operato.size(); ++i) {\n        if (operato[i] == \"*\" || operato[i] == \"//\") {\n            if (operato[i] == \"*\") {\n                newOperands.back() *= operand[i + 1];\n            } else if (operato[i] == \"//\") {\n                newOperands.back() /= operand[i + 1];\n            }\n        } else {\n            newOperands.push_back(operand[i + 1]);\n        }\n    }\n\n    // Step 3: Handle addition and subtraction\n    result = newOperands[0];\n    for (size_t i = 0; i < operato.size(); ++i) {\n        if (operato[i] == \"+\") {\n            result += newOperands[i + 1];\n        } else if (operato[i] == \"-\") {\n            result -= newOperands[i + 1];\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/161", "generation": "#include <stdio.h>\n#include <string>\n#include <algorithm> // for std::reverse\nusing namespace std;\n\nstring solve(string s) {\n    bool hasLetter = false;\n    string result;\n\n    for (char c : s) {\n        if (isalpha(c)) {\n            hasLetter = true;\n            if (islower(c)) {\n                result += toupper(c);\n            } else {\n                result += tolower(c);\n            }\n        } else {\n            result += c;\n        }\n    }\n\n    if (!hasLetter) {\n        reverse(result.begin(), result.end());\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/162", "generation": "#include <stdio.h>\n#include <string>\n#include <openssl/md5.h>\n#include <sstream>\n#include <iomanip>\n\nusing namespace std;\n\nstring string_to_md5(string text) {\n    if (text.empty()) {\n        return \"None\"; // Return \"None\" as a string representation\n    }\n\n    unsigned char digest[MD5_DIGEST_LENGTH];\n    MD5((unsigned char*)text.c_str(), text.length(), digest);\n\n    stringstream ss;\n    for (int i = 0; i < MD5_DIGEST_LENGTH; i++) {\n        ss << hex << setw(2) << setfill('0') << (int)digest[i];\n    }\n\n    return ss.str();\n}\n"}
{"task_id": "CPP/163", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nvector<int> generate_integers(int a, int b) {\n    vector<int> result;\n    int min_value = min(a, b);\n    int max_value = max(a, b);\n    \n    // List of even digits\n    int even_digits[] = {0, 2, 4, 6, 8};\n    \n    for (int even_digit : even_digits) {\n        if (even_digit >= min_value && even_digit <= max_value) {\n            result.push_back(even_digit);\n        }\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/0", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\nbool has_close_elements(vector<float> numbers, float threshold) {\n    // Sort the numbers\n    sort(numbers.begin(), numbers.end());\n    \n    // Check adjacent pairs for closeness\n    for (size_t i = 0; i < numbers.size() - 1; ++i) {\n        if (fabs(numbers[i] - numbers[i + 1]) < threshold) {\n            return true; // Found a pair closer than the threshold\n        }\n    }\n    \n    return false; // No pairs found that are closer than the threshold\n}\n"}
{"task_id": "CPP/1", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> separate_paren_groups(string paren_string) {\n    vector<string> result;\n    string current_group;\n    int balance = 0;\n\n    for (char ch : paren_string) {\n        if (ch == ' ') {\n            continue; // Ignore spaces\n        }\n        current_group += ch; // Add current character to the group\n\n        if (ch == '(') {\n            balance++; // Increase balance for '('\n        } else if (ch == ')') {\n            balance--; // Decrease balance for ')'\n        }\n\n        // If balance is zero, we have a complete group\n        if (balance == 0 && !current_group.empty()) {\n            result.push_back(current_group); // Add the group to the result\n            current_group.clear(); // Clear the current group for the next one\n        }\n    }\n\n    return result; // Return the vector of groups\n}\n"}
{"task_id": "CPP/2", "generation": "#include <stdio.h>\n#include <math.h>\nusing namespace std;\n\nfloat truncate_number(float number) {\n    // Get the integer part using floor\n    int integer_part = floor(number);\n    // Calculate the decimal part\n    float decimal_part = number - integer_part;\n    // Return the decimal part\n    return decimal_part;\n}\n"}
{"task_id": "CPP/3", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nbool below_zero(vector<int> operations) {\n    int balance = 0; // Initialize balance to zero\n    for (int operation : operations) { // Iterate through each operation\n        balance += operation; // Update balance\n        if (balance < 0) { // Check if balance is below zero\n            return true; // Return true if it is\n        }\n    }\n    return false; // Return false if balance never goes below zero\n}\n"}
{"task_id": "CPP/4", "generation": "#include <stdio.h>\n#include <vector>\n#include <cmath> // for abs function\nusing namespace std;\n\nfloat mean_absolute_deviation(vector<float> numbers) {\n    if (numbers.empty()) {\n        return 0.0; // Handle empty vector case\n    }\n\n    // Step 1: Calculate the mean\n    float sum = 0.0;\n    for (float number : numbers) {\n        sum += number;\n    }\n    float mean = sum / numbers.size();\n\n    // Step 2: Calculate absolute deviations\n    float total_deviation = 0.0;\n    for (float number : numbers) {\n        total_deviation += abs(number - mean);\n    }\n\n    // Step 3: Calculate the Mean Absolute Deviation\n    float mad = total_deviation / numbers.size();\n    return mad;\n}\n"}
{"task_id": "CPP/5", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nvector<int> intersperse(vector<int> numbers, int delimeter) {\n    vector<int> result;\n    \n    // Check if the input vector is empty\n    if (numbers.empty()) {\n        return result; // Return empty vector\n    }\n    \n    // Loop through the numbers vector\n    for (size_t i = 0; i < numbers.size(); i++) {\n        result.push_back(numbers[i]); // Add the current number\n        if (i < numbers.size() - 1) { // If it's not the last element\n            result.push_back(delimeter); // Add the delimiter\n        }\n    }\n    \n    return result; // Return the result vector\n}\n"}
{"task_id": "CPP/6", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <sstream>\nusing namespace std;\n\nvector<int> parse_nested_parens(string paren_string) {\n    vector<int> result;\n    stringstream ss(paren_string);\n    string group;\n\n    while (ss >> group) {\n        int current_depth = 0;\n        int max_depth = 0;\n\n        for (char ch : group) {\n            if (ch == '(') {\n                current_depth++;\n                max_depth = max(max_depth, current_depth);\n            } else if (ch == ')') {\n                current_depth--;\n            }\n        }\n\n        result.push_back(max_depth);\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/7", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> filter_by_substring(vector<string> strings, string substring) {\n    vector<string> result; // Initialize an empty vector to store results\n    for (const string& str : strings) { // Iterate through each string in the input vector\n        if (str.find(substring) != string::npos) { // Check if substring is found in the string\n            result.push_back(str); // Add the string to the result if it contains the substring\n        }\n    }\n    return result; // Return the filtered results\n}\n"}
{"task_id": "CPP/8", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> sum_product(vector<int> numbers) {\n    int sum = 0;\n    int product = 1;\n\n    // Check if the vector is empty\n    if (numbers.empty()) {\n        return {sum, product}; // Return (0, 1)\n    }\n\n    // Calculate sum and product\n    for (int number : numbers) {\n        sum += number;\n        product *= number;\n    }\n\n    return {sum, product};\n}\n"}
{"task_id": "CPP/9", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nvector<int> rolling_max(vector<int> numbers) {\n    vector<int> rolling_max_list;\n    int current_max = INT_MIN; // Initialize to the smallest integer\n\n    for (int number : numbers) {\n        if (number > current_max) {\n            current_max = number; // Update current_max if the current number is greater\n        }\n        rolling_max_list.push_back(current_max); // Append the current_max to the result list\n    }\n\n    return rolling_max_list; // Return the rolling maximums\n}\n"}
{"task_id": "CPP/10", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nbool is_palindrome(string str) {\n    string s(str.rbegin(), str.rend());\n    return s == str;\n}\n\nstring make_palindrome(string str) {\n    if (str.empty()) return \"\"; // Handle empty string case\n\n    int n = str.length();\n    int i;\n\n    // Find the longest palindromic suffix\n    for (i = n; i >= 0; --i) {\n        if (is_palindrome(str.substr(i))) {\n            break; // Found the longest palindromic suffix\n        }\n    }\n\n    // Create the palindrome by appending the reverse of the prefix\n    string prefix = str.substr(0, i); // Get the non-palindromic prefix\n    string reversed_prefix(prefix.rbegin(), prefix.rend()); // Reverse the prefix\n    return str + reversed_prefix; // Append reversed prefix to original string\n}\n"}
{"task_id": "CPP/11", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nstring string_xor(string a, string b) {\n    string result = \"\"; // Initialize an empty result string\n    for (size_t i = 0; i < a.length(); i++) { // Loop through each character\n        // Perform XOR operation and append to result\n        if (a[i] == b[i]) {\n            result += '0'; // Both are the same\n        } else {\n            result += '1'; // They are different\n        }\n    }\n    return result; // Return the result string\n}\n"}
{"task_id": "CPP/12", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring longest(vector<string> strings) {\n    if (strings.empty()) {\n        return \"None\"; // Return \"None\" if the vector is empty\n    }\n    \n    string longestString = strings[0]; // Initialize with the first string\n    for (const string& str : strings) {\n        if (str.length() > longestString.length()) {\n            longestString = str; // Update longest string if current is longer\n        }\n    }\n    \n    return longestString; // Return the longest string found\n}\n"}
{"task_id": "CPP/13", "generation": "#include<stdio.h>\nusing namespace std;\n\nint greatest_common_divisor(int a, int b) {\n    if (b == 0) {\n        return a;\n    } else {\n        return greatest_common_divisor(b, a % b);\n    }\n}\n"}
{"task_id": "CPP/14", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> all_prefixes(string str) {\n    vector<string> prefixes; // Vector to hold prefixes\n    for (int i = 0; i < str.length(); i++) {\n        string prefix = str.substr(0, i + 1); // Get the prefix from start to current index\n        prefixes.push_back(prefix); // Add the prefix to the vector\n    }\n    return prefixes; // Return the vector of prefixes\n}\n"}
{"task_id": "CPP/15", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nstring string_sequence(int n) {\n    string result = \"\";\n    for (int i = 0; i <= n; i++) {\n        result += to_string(i) + \" \";\n    }\n    // Remove the last space if result is not empty\n    if (!result.empty()) {\n        result.pop_back(); // Remove the last space\n    }\n    return result;\n}\n"}
{"task_id": "CPP/16", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <set>\n#include <algorithm>\nusing namespace std;\n\nint count_distinct_characters(string str) { \n    set<char> distinctChars; // Set to store distinct characters\n    for (char c : str) {\n        distinctChars.insert(tolower(c)); // Convert to lowercase and insert into the set\n    }\n    return distinctChars.size(); // Return the number of distinct characters\n}\n"}
{"task_id": "CPP/17", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <sstream>\nusing namespace std;\n\nvector<int> parse_music(string music_string) {\n    vector<int> beats;\n    stringstream ss(music_string);\n    string note;\n\n    while (ss >> note) {\n        if (note == \"o\") {\n            beats.push_back(4);\n        } else if (note == \"o|\") {\n            beats.push_back(2);\n        } else if (note == \".|\") {\n            beats.push_back(1);\n        }\n    }\n\n    return beats;\n}\n"}
{"task_id": "CPP/18", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nint how_many_times(string str, string substring) {\n    // Edge case: if the substring is empty\n    if (substring.empty()) {\n        return 0;\n    }\n    \n    int count = 0;\n    int length_of_substring = substring.length();\n    int length_of_str = str.length();\n    \n    // Loop through the string\n    for (int i = 0; i <= length_of_str - length_of_substring; i++) {\n        // Check for a match\n        if (str.substr(i, length_of_substring) == substring) {\n            count++;\n        }\n    }\n    \n    return count;\n}\n"}
{"task_id": "CPP/19", "generation": "#include <iostream>\n#include <string>\n#include <map>\n#include <vector>\n#include <sstream>\n#include <algorithm>\n\nusing namespace std;\n\nstring sort_numbers(string numbers) {\n    // Step 1: Create a mapping of number words to their integer values\n    map<string, int> num_map = {\n        {\"zero\", 0}, {\"one\", 1}, {\"two\", 2}, {\"three\", 3},\n        {\"four\", 4}, {\"five\", 5}, {\"six\", 6}, {\"seven\", 7},\n        {\"eight\", 8}, {\"nine\", 9}\n    };\n    \n    // Step 2: Split the input string into words\n    stringstream ss(numbers);\n    vector<string> num_words;\n    string word;\n    \n    while (ss >> word) {\n        num_words.push_back(word);\n    }\n    \n    // Step 3: Sort the words based on their integer values\n    sort(num_words.begin(), num_words.end(), [&](const string &a, const string &b) {\n        return num_map[a] < num_map[b];\n    });\n    \n    // Step 4: Join the sorted words into a single output string\n    string result;\n    for (const string &num : num_words) {\n        if (!result.empty()) {\n            result += \" \";\n        }\n        result += num;\n    }\n    \n    // Step 5: Return the output string\n    return result;\n}\n"}
{"task_id": "CPP/20", "generation": "#include <vector>\n#include <algorithm>\n#include <limits>\nusing namespace std;\n\nvector<float> find_closest_elements(vector<float> numbers) {\n    // Ensure there are at least two elements\n    if (numbers.size() < 2) {\n        return {};\n    }\n\n    // Sort the numbers\n    sort(numbers.begin(), numbers.end());\n\n    float min_diff = numeric_limits<float>::infinity();\n    vector<float> closest_pair;\n\n    // Find the closest pair\n    for (size_t i = 0; i < numbers.size() - 1; ++i) {\n        float diff = numbers[i + 1] - numbers[i];\n        if (diff < min_diff) {\n            min_diff = diff;\n            closest_pair = {numbers[i], numbers[i + 1]};\n        }\n    }\n\n    return closest_pair;\n}\n"}
{"task_id": "CPP/21", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<float> rescale_to_unit(vector<float> numbers) {\n    // Step 1: Find the minimum and maximum values\n    float min_value = *min_element(numbers.begin(), numbers.end());\n    float max_value = *max_element(numbers.begin(), numbers.end());\n    \n    // Step 2: Create a vector to hold the rescaled values\n    vector<float> rescaled_numbers;\n    \n    // Step 3: Apply the linear transformation\n    for (float number : numbers) {\n        float rescaled_value = (number - min_value) / (max_value - min_value);\n        rescaled_numbers.push_back(rescaled_value);\n    }\n    \n    // Step 4: Return the rescaled numbers\n    return rescaled_numbers;\n}\n"}
{"task_id": "CPP/22", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <boost/any.hpp>\n#include <list>\n#include <iostream>\n\ntypedef std::list<boost::any> list_any;\n\nstd::vector<int> filter_integers(list_any values) {\n    std::vector<int> result; // Vector to store the filtered integers\n    for (const auto& value : values) {\n        try {\n            // Attempt to cast the value to an int\n            int intValue = boost::any_cast<int>(value);\n            result.push_back(intValue); // If successful, add to result\n        } catch (const boost::bad_any_cast& e) {\n            // If casting fails, we simply ignore this value\n            continue;\n        }\n    }\n    return result; // Return the vector of integers\n}\n"}
{"task_id": "CPP/23", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nint strlen(string str) {\n    return str.length(); // Using the length() method to get the length of the string\n}\n"}
{"task_id": "CPP/24", "generation": "#include<stdio.h>\nusing namespace std;\n\nint largest_divisor(int n) {\n    for (int i = n - 1; i > 0; i--) {\n        if (n % i == 0) {\n            return i;\n        }\n    }\n    return -1; // This line is technically unreachable since n > 0\n}\n"}
{"task_id": "CPP/25", "generation": "#include <stdio.h>\n#include <vector>\n#include <cmath> // for sqrt\nusing namespace std;\n\nvector<int> factorize(int n) {\n    vector<int> result;\n    // Check for number of 2s that divide n\n    while (n % 2 == 0) {\n        result.push_back(2);\n        n /= 2;\n    }\n    \n    // n must be odd at this point, so we can skip even numbers\n    for (int i = 3; i <= sqrt(n); i += 2) {\n        while (n % i == 0) {\n            result.push_back(i);\n            n /= i;\n        }\n    }\n    \n    // This condition is to check if n is a prime number greater than 2\n    if (n > 2) {\n        result.push_back(n);\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/26", "generation": "#include <stdio.h>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nvector<int> remove_duplicates(vector<int> numbers) {\n    unordered_map<int, int> countMap;\n    \n    // Count occurrences of each number\n    for (int num : numbers) {\n        countMap[num]++;\n    }\n    \n    vector<int> result;\n    \n    // Collect numbers that occur only once\n    for (int num : numbers) {\n        if (countMap[num] == 1) {\n            result.push_back(num);\n        }\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/27", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nstring flip_case(string str) {\n    string result = \"\"; // Initialize an empty string for the result\n    for (char c : str) { // Loop through each character in the input string\n        if (islower(c)) { // Check if the character is lowercase\n            result += toupper(c); // Convert to uppercase and append to result\n        } else if (isupper(c)) { // Check if the character is uppercase\n            result += tolower(c); // Convert to lowercase and append to result\n        } else {\n            result += c; // Append unchanged character (if it's neither)\n        }\n    }\n    return result; // Return the resulting string\n}\n"}
{"task_id": "CPP/28", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring concatenate(vector<string> strings) {\n    string result = \"\"; // Initialize an empty string\n    for (const string& str : strings) { // Iterate through each string in the vector\n        result += str; // Append the current string to the result\n    }\n    return result; // Return the concatenated string\n}\n"}
{"task_id": "CPP/29", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> filter_by_prefix(vector<string> strings, string prefix) {\n    vector<string> result; // Initialize an empty vector for results\n    for (const string& str : strings) { // Loop through each string in the input vector\n        if (str.substr(0, prefix.size()) == prefix) { // Check if the string starts with the prefix\n            result.push_back(str); // Add the string to the result vector\n        }\n    }\n    return result; // Return the filtered results\n}\n"}
{"task_id": "CPP/30", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nvector<float> get_positive(vector<float> l) {\n    vector<float> positive_numbers; // Initialize an empty vector to store positive numbers\n    for (float number : l) { // Loop through each number in the input vector\n        if (number > 0) { // Check if the number is positive\n            positive_numbers.push_back(number); // Append to the positive numbers vector\n        }\n    }\n    return positive_numbers; // Return the vector containing only positive numbers\n}\n"}
{"task_id": "CPP/31", "generation": "#include <stdio.h>\n#include <cmath> // for sqrt function\nusing namespace std;\n\nbool is_prime(long long n) {\n    if (n < 2) {\n        return false; // 0 and 1 are not prime\n    }\n    if (n == 2) {\n        return true; // 2 is prime\n    }\n    if (n % 2 == 0) {\n        return false; // other even numbers are not prime\n    }\n    for (long long i = 3; i <= sqrt(n); i += 2) { // check odd numbers only\n        if (n % i == 0) {\n            return false; // found a divisor\n        }\n    }\n    return true; // no divisors found, n is prime\n}\n"}
{"task_id": "CPP/32", "generation": "#include <vector>\n#include <cmath>\n#include <iostream>\n\nusing namespace std;\n\ndouble poly(vector<double> xs, double x) {\n    double sum = 0;\n    for (int i = 0; i < xs.size(); i++) {\n        sum += xs[i] * pow(x, i);\n    }\n    return sum;\n}\n\ndouble poly_derivative(vector<double> xs, double x) {\n    double sum = 0;\n    for (int i = 1; i < xs.size(); i++) {\n        sum += i * xs[i] * pow(x, i - 1);\n    }\n    return sum;\n}\n\ndouble find_zero(vector<double> xs) {\n    double x = 0; // Initial guess\n    double tolerance = 1e-7; // Tolerance for convergence\n    double fx, dfx;\n\n    while (true) {\n        fx = poly(xs, x);\n        dfx = poly_derivative(xs, x);\n        \n        if (fabs(fx) < tolerance) {\n            break; // Found a root\n        }\n        \n        if (dfx == 0) {\n            throw runtime_error(\"Derivative is zero, no solution found.\");\n        }\n        \n        x = x - fx / dfx; // Newton-Raphson update\n    }\n    \n    return x;\n}\n"}
{"task_id": "CPP/33", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> sort_third(vector<int> l) {\n    vector<int> divisibleValues;\n\n    // Collect values at indices divisible by 3\n    for (int i = 0; i < l.size(); i++) {\n        if (i % 3 == 0) {\n            divisibleValues.push_back(l[i]);\n        }\n    }\n\n    // Sort the collected values\n    sort(divisibleValues.begin(), divisibleValues.end());\n\n    vector<int> result(l.size());\n    int index = 0;\n\n    // Fill the result vector\n    for (int i = 0; i < l.size(); i++) {\n        if (i % 3 == 0) {\n            result[i] = divisibleValues[index];\n            index++;\n        } else {\n            result[i] = l[i];\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/34", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\n#include <set>\nusing namespace std;\n\nvector<int> unique(vector<int> l) {\n    // Step 1: Use a set to store unique elements\n    set<int> uniqueElements(l.begin(), l.end());\n    \n    // Step 2: Convert the set back to a vector\n    vector<int> result(uniqueElements.begin(), uniqueElements.end());\n    \n    // Step 3: Sort the vector (set is already sorted, but we ensure it)\n    sort(result.begin(), result.end());\n    \n    // Step 4: Return the sorted vector\n    return result;\n}\n"}
{"task_id": "CPP/35", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nfloat max_element(vector<float> l) {\n    if (l.empty()) {\n        throw std::invalid_argument(\"Vector is empty\");\n    }\n    \n    float maxValue = l[0]; // Initialize maxValue with the first element\n    for (int i = 1; i < l.size(); i++) { // Start from the second element\n        if (l[i] > maxValue) { // Compare with maxValue\n            maxValue = l[i]; // Update maxValue if current element is larger\n        }\n    }\n    return maxValue; // Return the maximum value found\n}\n"}
{"task_id": "CPP/36", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint fizz_buzz(int n) {\n    int count = 0;\n    \n    for (int i = 0; i < n; i++) {\n        if (i % 11 == 0 || i % 13 == 0) {\n            // Convert integer to string\n            string numStr = to_string(i);\n            // Count occurrences of '7'\n            for (char c : numStr) {\n                if (c == '7') {\n                    count++;\n                }\n            }\n        }\n    }\n    \n    return count;\n}\n\n// Example usage\n"}
{"task_id": "CPP/37", "generation": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<float> sort_even(vector<float> l) {\n    vector<float> even_values;\n    vector<float> result = l; // Create a copy of l\n\n    // Extract even indexed values\n    for (int i = 0; i < l.size(); i++) {\n        if (i % 2 == 0) {\n            even_values.push_back(l[i]);\n        }\n    }\n\n    // Sort the even indexed values\n    sort(even_values.begin(), even_values.end());\n\n    // Replace even indexed values in result with sorted values\n    int index = 0;\n    for (int i = 0; i < l.size(); i++) {\n        if (i % 2 == 0) {\n            result[i] = even_values[index];\n            index++;\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/38", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nstring decode_cyclic(string s) { \n    string output = \"\";\n    int l = s.length();\n    for (int i = 0; i * 3 < l; i++) {\n        string x = s.substr(i * 3, 3);\n        if (x.length() == 3) {\n            // Move the last character to the front\n            string decoded_group = x[2] + x.substr(0, 2);\n            output += decoded_group;\n        } else {\n            // If the group has fewer than 3 characters, keep it as is\n            output += x;\n        }\n    }\n    return output;\n}\n"}
{"task_id": "CPP/39", "generation": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    for (int i = 2; i <= sqrt(num); i++) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\n// Function to return the n-th prime Fibonacci number\nint prime_fib(int n) {\n    int fib1 = 0, fib2 = 1;\n    vector<int> prime_fibs;\n\n    while (prime_fibs.size() < n) {\n        int fib_next = fib1 + fib2;\n        fib1 = fib2;\n        fib2 = fib_next;\n\n        if (is_prime(fib_next)) {\n            prime_fibs.push_back(fib_next);\n        }\n    }\n    return prime_fibs[n - 1];\n}\n\n// Example usage\n"}
{"task_id": "CPP/40", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nbool triples_sum_to_zero(vector<int> l) {\n    sort(l.begin(), l.end());\n    int n = l.size();\n    \n    for (int i = 0; i < n - 2; i++) {\n        int left = i + 1;\n        int right = n - 1;\n        \n        while (left < right) {\n            int sum = l[i] + l[left] + l[right];\n            if (sum == 0) {\n                return true;\n            } else if (sum < 0) {\n                left++;\n            } else {\n                right--;\n            }\n        }\n    }\n    return false;\n}\n"}
{"task_id": "CPP/41", "generation": "#include<stdio.h>\nusing namespace std;\n\nint car_race_collision(int n) {\n    return n * n; // Each car from the left collides with each car from the right\n}\n"}
{"task_id": "CPP/42", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nvector<int> incr_list(vector<int> l) {\n    vector<int> result; // Create an empty vector to store the results\n    for (int i = 0; i < l.size(); i++) { // Loop through each element in the input vector\n        result.push_back(l[i] + 1); // Increment the element by 1 and add to result\n    }\n    return result; // Return the new vector\n}\n"}
{"task_id": "CPP/43", "generation": "#include <stdio.h>\n#include <vector>\n#include <unordered_set>\nusing namespace std;\n\nbool pairs_sum_to_zero(vector<int> l) {\n    unordered_set<int> seen; // Create an empty set to store seen numbers\n    for (int number : l) { // Iterate through each number in the vector\n        if (seen.count(-number)) { // Check if the negation of the number is in the set\n            return true; // Found a pair that sums to zero\n        }\n        seen.insert(number); // Add the current number to the set\n    }\n    return false; // No pairs found that sum to zero\n}\n"}
{"task_id": "CPP/44", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nstring change_base(int x, int base) {\n    if (base >= 10) {\n        return \"Invalid base\"; // Handle invalid base\n    }\n    \n    if (x == 0) {\n        return \"0\"; // Handle the case for zero\n    }\n    \n    string result = \"\";\n    while (x > 0) {\n        int remainder = x % base; // Get the remainder\n        result = to_string(remainder) + result; // Prepend the remainder\n        x = x / base; // Update x for the next iteration\n    }\n    \n    return result; // Return the final result\n}\n"}
{"task_id": "CPP/45", "generation": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n\nfloat triangle_area(float a, float h) {\n    float area = (1.0 / 2.0) * a * h; // Calculate area using the formula\n    return area; // Return the calculated area\n}\n"}
{"task_id": "CPP/46", "generation": "#include <stdio.h>\nusing namespace std;\n\nint fib4(int n) {\n    if (n == 0) return 0;\n    if (n == 1) return 0;\n    if (n == 2) return 2;\n    if (n == 3) return 0;\n\n    // Initialize an array to store the last four values\n    int fib[4] = {0, 0, 2, 0};\n\n    // Iterate from 4 to n\n    for (int i = 4; i <= n; i++) {\n        // Calculate the current fib4 value\n        int current = fib[0] + fib[1] + fib[2] + fib[3];\n        // Shift the last four values\n        fib[0] = fib[1];\n        fib[1] = fib[2];\n        fib[2] = fib[3];\n        fib[3] = current;\n    }\n\n    return fib[3];\n}\n"}
{"task_id": "CPP/47", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nfloat median(vector<float> l) {\n    // Step 1: Sort the vector\n    sort(l.begin(), l.end());\n    \n    // Step 2: Determine the size of the vector\n    int n = l.size();\n    \n    // Step 3: Calculate the median\n    if (n % 2 == 1) {\n        // If odd, return the middle element\n        return l[n / 2];\n    } else {\n        // If even, return the average of the two middle elements\n        return (l[n / 2 - 1] + l[n / 2]) / 2.0;\n    }\n}\n"}
{"task_id": "CPP/48", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nbool is_palindrome(string text) {\n    int left = 0;\n    int right = text.length() - 1;\n\n    while (left < right) {\n        if (text[left] != text[right]) {\n            return false; // Not a palindrome\n        }\n        left++;\n        right--;\n    }\n    return true; // Is a palindrome\n}\n"}
{"task_id": "CPP/49", "generation": "#include<stdio.h>\nusing namespace std;\n\nint modp(int n, int p) {\n    if (p == 1) return 0; // Any number mod 1 is 0\n    long long result = 1; // Use long long to prevent overflow\n    long long base = 2;   // Base is 2\n\n    while (n > 0) {\n        if (n % 2 == 1) { // If n is odd\n            result = (result * base) % p; // Multiply result by base and take mod p\n        }\n        base = (base * base) % p; // Square the base and take mod p\n        n /= 2; // Divide n by 2\n    }\n    return result;\n}\n"}
{"task_id": "CPP/50", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nstring encode_shift(string s) {\n    string out;\n    for (int i = 0; i < s.length(); i++) {\n        int w = ((int)s[i] + 5 - (int)'a') % 26 + (int)'a';   \n        out = out + (char)w;\n    }\n    return out;\n}\n\nstring decode_shift(string s) {\n    string out;\n    for (int i = 0; i < s.length(); i++) {\n        int w = ((int)s[i] - 5 - (int)'a' + 26) % 26 + (int)'a'; // Adding 26 to handle negative wrap-around\n        out = out + (char)w;\n    }\n    return out;\n}\n"}
{"task_id": "CPP/51", "generation": "#include <stdio.h>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nstring remove_vowels(string text) {\n    string result = \"\";\n    string vowels = \"aeiouAEIOU\"; // Define the vowels\n    for (char c : text) { // Iterate through each character in the input string\n        if (vowels.find(c) == string::npos) { // Check if the character is not a vowel\n            result += c; // Append non-vowel characters to result\n        }\n    }\n    return result; // Return the final result string\n}\n"}
{"task_id": "CPP/52", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nbool below_threshold(vector<int> l, int t) {\n    for (int i = 0; i < l.size(); i++) {\n        if (l[i] >= t) {\n            return false; // Found an element that is not below the threshold\n        }\n    }\n    return true; // All elements are below the threshold\n}\n"}
{"task_id": "CPP/53", "generation": "#include<stdio.h>\n#include<stdlib.h>\nusing namespace std;\n\nint add(int x, int y) {\n    return x + y;\n}\n"}
{"task_id": "CPP/54", "generation": "#include <stdio.h>\n#include <string>\n#include <algorithm>\n#include <set>\n#include <vector>\nusing namespace std;\n\nbool same_chars(string s0, string s1) {\n    // Create sets to hold unique characters\n    set<char> uniqueChars0(s0.begin(), s0.end());\n    set<char> uniqueChars1(s1.begin(), s1.end());\n    \n    // Convert sets to vectors\n    vector<char> vec0(uniqueChars0.begin(), uniqueChars0.end());\n    vector<char> vec1(uniqueChars1.begin(), uniqueChars1.end());\n    \n    // Sort the vectors\n    sort(vec0.begin(), vec0.end());\n    sort(vec1.begin(), vec1.end());\n    \n    // Compare the sorted vectors\n    return vec0 == vec1;\n}\n"}
{"task_id": "CPP/55", "generation": "#include<stdio.h>\nusing namespace std;\n\nint fib(int n) {\n    if (n == 0) return 0;\n    if (n == 1) return 1;\n    \n    int a = 0; // fib(0)\n    int b = 1; // fib(1)\n    \n    for (int i = 2; i <= n; i++) {\n        int c = a + b; // fib(i) = fib(i-1) + fib(i-2)\n        a = b;         // move to the next Fibonacci number\n        b = c;         // update b to the new Fibonacci number\n    }\n    \n    return b; // b now holds fib(n)\n}\n"}
{"task_id": "CPP/56", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    int counter = 0; // Initialize counter\n    for (char ch : brackets) { // Loop through each character\n        if (ch == '<') {\n            counter++; // Increment for opening bracket\n        } else if (ch == '>') {\n            counter--; // Decrement for closing bracket\n        }\n        if (counter < 0) {\n            return false; // More closing brackets than opening\n        }\n    }\n    return counter == 0; // Check if all brackets are matched\n}\n"}
{"task_id": "CPP/57", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nbool monotonic(vector<float> l) {\n    if (l.size() < 2) {\n        return true; // A single element or empty vector is considered monotonic\n    }\n    \n    bool isIncreasing = true;\n    bool isDecreasing = true;\n    \n    for (size_t i = 0; i < l.size() - 1; i++) {\n        if (l[i] < l[i + 1]) {\n            isDecreasing = false; // Found an increasing pair\n        } else if (l[i] > l[i + 1]) {\n            isIncreasing = false; // Found a decreasing pair\n        }\n    }\n    \n    return isIncreasing || isDecreasing; // Return true if either condition is met\n}\n"}
{"task_id": "CPP/58", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\n#include <set>\nusing namespace std;\n\nvector<int> common(vector<int> l1, vector<int> l2) {\n    // Create sets from the input vectors to eliminate duplicates\n    set<int> set1(l1.begin(), l1.end());\n    set<int> set2(l2.begin(), l2.end());\n    \n    // Create a vector to store the result\n    vector<int> result;\n    \n    // Find the intersection of the two sets\n    for (const int& num : set1) {\n        if (set2.count(num)) {\n            result.push_back(num);\n        }\n    }\n    \n    // Sort the result (though sets are already sorted)\n    sort(result.begin(), result.end());\n    \n    return result;\n}\n"}
{"task_id": "CPP/59", "generation": "#include <stdio.h>\n#include <cmath>\nusing namespace std;\n\nint largest_prime_factor(int n) {\n    int largest_factor = 1;\n\n    // Check for number of 2s that divide n\n    while (n % 2 == 0) {\n        largest_factor = 2;\n        n = n / 2;\n    }\n\n    // n must be odd at this point, so we can skip even numbers\n    for (int i = 3; i <= sqrt(n); i += 2) {\n        // While i divides n, update n and largest_factor\n        while (n % i == 0) {\n            largest_factor = i;\n            n = n / i;\n        }\n    }\n\n    // This condition is to check if n is a prime number greater than 2\n    if (n > 2) {\n        largest_factor = n;\n    }\n\n    return largest_factor;\n}\n"}
{"task_id": "CPP/60", "generation": "#include<stdio.h>\nusing namespace std;\n\nint sum_to_n(int n) {\n    return (n * (n + 1)) / 2;\n}\n"}
{"task_id": "CPP/61", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    int counter = 0;\n    for (char ch : brackets) {\n        if (ch == '(') {\n            counter++;\n        } else if (ch == ')') {\n            counter--;\n        }\n        if (counter < 0) {\n            return false; // More closing brackets than opening\n        }\n    }\n    return counter == 0; // Check if all opening brackets are matched\n}\n"}
{"task_id": "CPP/62", "generation": "#include <vector>\nusing namespace std;\n\nvector<float> derivative(vector<float> xs) {\n    vector<float> result;\n    for (int i = 1; i < xs.size(); i++) {\n        result.push_back(i * xs[i]);\n    }\n    return result;\n}\n"}
{"task_id": "CPP/63", "generation": "#include <stdio.h>\nusing namespace std;\n\nint fibfib(int n) {\n    if (n == 0) return 0;\n    if (n == 1) return 0;\n    if (n == 2) return 1;\n\n    int a = 0; // fibfib(0)\n    int b = 0; // fibfib(1)\n    int c = 1; // fibfib(2)\n    int result = 0;\n\n    for (int i = 3; i <= n; i++) {\n        result = a + b + c; // fibfib(n) = fibfib(n-1) + fibfib(n-2) + fibfib(n-3)\n        a = b; // move to the next\n        b = c; // move to the next\n        c = result; // update the last value\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/64", "generation": "#include <stdio.h>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nint vowels_count(string s) {\n    int count = 0;\n    int length = s.length();\n    \n    for (int i = 0; i < length; i++) {\n        char c = tolower(s[i]); // Convert to lowercase for uniformity\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n            count++;\n        }\n        // Check for 'y' only if it's the last character\n        if (c == 'y' && i == length - 1) {\n            count++;\n        }\n    }\n    \n    return count;\n}\n"}
{"task_id": "CPP/65", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nstring circular_shift(int x, int shift) {\n    string str_x = to_string(x); // Convert integer to string\n    int num_digits = str_x.length(); // Get the number of digits\n\n    if (shift > num_digits) {\n        // If shift is greater than number of digits, return reversed string\n        reverse(str_x.begin(), str_x.end());\n        return str_x;\n    } else {\n        // Calculate effective shift\n        int effective_shift = shift % num_digits;\n        // Split the string into two parts\n        string part1 = str_x.substr(num_digits - effective_shift); // Last effective_shift digits\n        string part2 = str_x.substr(0, num_digits - effective_shift); // Remaining digits\n        return part1 + part2; // Concatenate parts\n    }\n}\n"}
{"task_id": "CPP/66", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nint digitSum(string s) {\n    int sum = 0; // Initialize sum to 0\n    for (char c : s) { // Iterate through each character in the string\n        if (c >= 'A' && c <= 'Z') { // Check if the character is uppercase\n            sum += (int)c; // Add the ASCII value of the uppercase character to sum\n        }\n    }\n    return sum; // Return the final sum\n}\n"}
{"task_id": "CPP/67", "generation": "#include <stdio.h>\n#include <string>\n#include <sstream>\n#include <iostream>\nusing namespace std;\n\nint fruit_distribution(string s, int n) {\n    int apples = 0, oranges = 0;\n    \n    // Use stringstream to parse the string\n    stringstream ss(s);\n    string word;\n    \n    // Extract the number of apples\n    ss >> apples; // Read the first number (apples)\n    ss >> word;   // Read the word \"apples\"\n    ss >> word;   // Read the word \"and\"\n    ss >> oranges; // Read the second number (oranges)\n    ss >> word;   // Read the word \"oranges\"\n    \n    // Calculate the number of mangoes\n    int mangoes = n - apples - oranges;\n    \n    return mangoes;\n}\n"}
{"task_id": "CPP/68", "generation": "#include <stdio.h>\n#include <vector>\n#include <limits.h> // For INT_MAX\nusing namespace std;\n\nvector<int> pluck(vector<int> arr) {\n    vector<int> result;\n    int smallest_even = INT_MAX;\n    int smallest_index = -1;\n\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] % 2 == 0) { // Check if the number is even\n            if (arr[i] < smallest_even) { // Check if it's the smallest even found\n                smallest_even = arr[i];\n                smallest_index = i;\n            }\n        }\n    }\n\n    if (smallest_index == -1) {\n        return result; // Return empty vector if no even number was found\n    } else {\n        result.push_back(smallest_even);\n        result.push_back(smallest_index);\n        return result; // Return the smallest even and its index\n    }\n}\n"}
{"task_id": "CPP/69", "generation": "#include <stdio.h>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint search(vector<int> lst) {\n    unordered_map<int, int> frequencyMap;\n\n    // Count the frequency of each integer\n    for (int num : lst) {\n        frequencyMap[num]++;\n    }\n\n    int maxValidInteger = -1;\n\n    // Check for the greatest integer with the required frequency\n    for (const auto& entry : frequencyMap) {\n        int value = entry.first;\n        int frequency = entry.second;\n\n        if (frequency >= value) {\n            maxValidInteger = max(maxValidInteger, value);\n        }\n    }\n\n    return maxValidInteger;\n}\n"}
{"task_id": "CPP/70", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> strange_sort_list(vector<int> lst) {\n    // Step 1: Sort the input list\n    sort(lst.begin(), lst.end());\n    \n    vector<int> result;\n    int left = 0;\n    int right = lst.size() - 1;\n\n    // Step 4: Build the result vector\n    while (left <= right) {\n        // Append the minimum\n        result.push_back(lst[left]);\n        left++;\n        \n        // Append the maximum if there's still an element left\n        if (left <= right) {\n            result.push_back(lst[right]);\n            right--;\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/71", "generation": "#include <stdio.h>\n#include <math.h>\n#include <iomanip> // for std::setprecision\nusing namespace std;\n\nfloat triangle_area(float a, float b, float c) {\n    // Check for valid triangle\n    if ((a + b <= c) || (a + c <= b) || (b + c <= a)) {\n        return -1;\n    }\n    \n    // Calculate semi-perimeter\n    float s = (a + b + c) / 2;\n    \n    // Calculate area using Heron's formula\n    float area = sqrt(s * (s - a) * (s - b) * (s - c));\n    \n    // Return area rounded to 2 decimal points\n    return round(area * 100) / 100; // rounding to 2 decimal points\n}\n"}
{"task_id": "CPP/72", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nbool will_it_fly(vector<int> q, int w) {\n    int n = q.size();\n    \n    // Check if the vector is a palindrome\n    for (int i = 0; i < n / 2; i++) {\n        if (q[i] != q[n - 1 - i]) {\n            return false; // Not a palindrome\n        }\n    }\n    \n    // Calculate the sum of the elements\n    int sum = 0;\n    for (int num : q) {\n        sum += num;\n    }\n    \n    // Check if the sum is less than or equal to w\n    return sum <= w;\n}\n"}
{"task_id": "CPP/73", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nint smallest_change(vector<int> arr) {\n    int change_count = 0;\n    int left = 0;\n    int right = arr.size() - 1;\n\n    while (left < right) {\n        if (arr[left] != arr[right]) {\n            change_count++;\n        }\n        left++;\n        right--;\n    }\n\n    return change_count;\n}\n"}
{"task_id": "CPP/74", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> total_match(vector<string> lst1, vector<string> lst2) {\n    int total1 = 0;\n    int total2 = 0;\n\n    // Calculate total characters in lst1\n    for (const string& str : lst1) {\n        total1 += str.length();\n    }\n\n    // Calculate total characters in lst2\n    for (const string& str : lst2) {\n        total2 += str.length();\n    }\n\n    // Compare totals and return the appropriate vector\n    if (total1 < total2) {\n        return lst1;\n    } else if (total2 < total1) {\n        return lst2;\n    } else {\n        return lst1; // If equal, return lst1\n    }\n}\n"}
{"task_id": "CPP/75", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nbool is_multiply_prime(int a) {\n    vector<int> primes = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97};\n    \n    for (int i = 0; i < primes.size(); i++) {\n        for (int j = 0; j < primes.size(); j++) {\n            for (int k = 0; k < primes.size(); k++) {\n                if (primes[i] * primes[j] * primes[k] == a) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n"}
{"task_id": "CPP/76", "generation": "#include <stdio.h>\n#include <math.h>\nusing namespace std;\n\nbool is_simple_power(int x, int n) {\n    // Handle edge cases\n    if (n <= 1) {\n        if (n == 1) {\n            return x == 1; // 1^k = 1 for any k\n        } else {\n            return false; // n < 1 cannot produce positive powers\n        }\n    }\n\n    int k = 0;\n    int power = 1; // n^0 = 1\n    while (power < x) {\n        k++;\n        power = pow(n, k); // Calculate n^k\n    }\n    \n    return power == x; // Check if we found x\n}\n"}
{"task_id": "CPP/77", "generation": "#include <cmath>\nusing namespace std;\n\nbool iscube(int a) {\n    if (a == 0) {\n        return true; // 0 is a perfect cube (0^3 = 0)\n    }\n    int n = round(cbrt(a)); // Calculate the cube root and round it\n    return n * n * n == a; // Check if n^3 equals a\n}\n"}
{"task_id": "CPP/78", "generation": "#include <stdio.h>\n#include <string>\n#include <unordered_set>\nusing namespace std;\n\nint hex_key(string num) {\n    // Set of prime hexadecimal digits\n    unordered_set<char> prime_digits = {'2', '3', '5', '7', 'B', 'D'};\n    int count = 0;\n\n    // Iterate through each character in the string\n    for (char c : num) {\n        // Check if the character is a prime hexadecimal digit\n        if (prime_digits.find(c) != prime_digits.end()) {\n            count++;\n        }\n    }\n\n    return count; // Return the count of prime hexadecimal digits\n}\n"}
{"task_id": "CPP/79", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nstring decimal_to_binary(int decimal) {\n    string binaryString = \"\";\n    \n    // Handle the case for 0\n    if (decimal == 0) {\n        binaryString = \"0\";\n    } else {\n        // Convert decimal to binary\n        while (decimal > 0) {\n            binaryString = to_string(decimal % 2) + binaryString; // Prepend the remainder\n            decimal = decimal / 2; // Update decimal\n        }\n    }\n    \n    // Format the output with \"db\" at the beginning and end\n    return \"db\" + binaryString + \"db\";\n}\n"}
{"task_id": "CPP/80", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nbool is_happy(string s) {\n    // Check if the length of the string is less than 3\n    if (s.length() < 3) {\n        return false;\n    }\n    \n    // Iterate through the string to check every three consecutive characters\n    for (int i = 0; i <= s.length() - 3; i++) {\n        // Check if any of the three characters are the same\n        if (s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]) {\n            return false;\n        }\n    }\n    \n    // If all checks passed, the string is happy\n    return true;\n}\n"}
{"task_id": "CPP/81", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> numerical_letter_grade(vector<float> grades) {\n    vector<string> result;\n    for (float grade : grades) {\n        if (grade == 4.0) {\n            result.push_back(\"A+\");\n        } else if (grade > 3.7) {\n            result.push_back(\"A\");\n        } else if (grade > 3.3) {\n            result.push_back(\"A-\");\n        } else if (grade > 3.0) {\n            result.push_back(\"B+\");\n        } else if (grade > 2.7) {\n            result.push_back(\"B\");\n        } else if (grade > 2.3) {\n            result.push_back(\"B-\");\n        } else if (grade > 2.0) {\n            result.push_back(\"C+\");\n        } else if (grade > 1.7) {\n            result.push_back(\"C\");\n        } else if (grade > 1.3) {\n            result.push_back(\"C-\");\n        } else if (grade > 1.0) {\n            result.push_back(\"D+\");\n        } else if (grade > 0.7) {\n            result.push_back(\"D\");\n        } else if (grade > 0.0) {\n            result.push_back(\"D-\");\n        } else {\n            result.push_back(\"E\");\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/82", "generation": "#include <stdio.h>\n#include <string>\n#include <cmath>\nusing namespace std;\n\nbool prime_length(string str) {\n    int length = str.length();\n    \n    // Check if the length is less than 2\n    if (length < 2) {\n        return false;\n    }\n    \n    // Check for factors from 2 to the square root of length\n    for (int i = 2; i <= sqrt(length); i++) {\n        if (length % i == 0) {\n            return false; // Not a prime number\n        }\n    }\n    \n    return true; // It's a prime number\n}\n"}
{"task_id": "CPP/83", "generation": "#include <cmath>\nusing namespace std;\n\nint starts_one_ends(int n) {\n    if (n == 1) {\n        return 2; // The only numbers are 1\n    }\n    \n    int count_start = pow(10, n - 1); // Count of n-digit numbers starting with 1\n    int count_end = 9 * pow(10, n - 2); // Count of n-digit numbers ending with 1\n    int count_both = pow(10, n - 2); // Count of n-digit numbers starting and ending with 1\n    \n    return count_start + count_end - count_both; // Total count using inclusion-exclusion\n}\n"}
{"task_id": "CPP/84", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nstring solve(int N) {\n    int sum = 0;\n    \n    // Calculate the sum of digits\n    while (N > 0) {\n        sum += N % 10; // Add the last digit to sum\n        N /= 10;       // Remove the last digit\n    }\n    \n    // Convert sum to binary\n    string binary = \"\";\n    if (sum == 0) {\n        return \"0\"; // Edge case for sum being 0\n    }\n    \n    while (sum > 0) {\n        binary = to_string(sum % 2) + binary; // Prepend the binary digit\n        sum /= 2; // Divide by 2 to shift right\n    }\n    \n    return binary; // Return the binary representation\n}\n"}
{"task_id": "CPP/85", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nint add(vector<int> lst) {\n    int sum = 0; // Initialize sum to 0\n    for (int i = 0; i < lst.size(); i++) { // Loop through the vector\n        if (i % 2 == 1) { // Check if the index is odd\n            if (lst[i] % 2 == 0) { // Check if the element is even\n                sum += lst[i]; // Add to sum\n            }\n        }\n    }\n    return sum; // Return the final sum\n}\n"}
{"task_id": "CPP/86", "generation": "#include <stdio.h>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nstring anti_shuffle(string s) {\n    string result = \"\";\n    string currentWord = \"\";\n    \n    for (char c : s) {\n        if (c == ' ') {\n            // If we encounter a space, sort the current word and add to result\n            if (!currentWord.empty()) {\n                sort(currentWord.begin(), currentWord.end());\n                result += currentWord;\n                currentWord = \"\"; // Reset current word\n            }\n            result += ' '; // Add the space to the result\n        } else {\n            currentWord += c; // Collect characters for the current word\n        }\n    }\n    \n    // Sort and add the last word if exists\n    if (!currentWord.empty()) {\n        sort(currentWord.begin(), currentWord.end());\n        result += currentWord;\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/87", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<vector<int>> get_row(vector<vector<int>> lst, int x) {\n    vector<vector<int>> result;\n\n    // Collecting coordinates\n    for (int i = 0; i < lst.size(); i++) {\n        for (int j = 0; j < lst[i].size(); j++) {\n            if (lst[i][j] == x) {\n                result.push_back({i, j});\n            }\n        }\n    }\n\n    // Sorting the result\n    sort(result.begin(), result.end(), [](const vector<int>& a, const vector<int>& b) {\n        if (a[0] == b[0]) {\n            return a[1] > b[1]; // Sort by column in descending order if rows are the same\n        }\n        return a[0] < b[0]; // Sort by row in ascending order\n    });\n\n    return result;\n}\n"}
{"task_id": "CPP/88", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> sort_array(vector<int> array) {\n    // Handle edge cases\n    if (array.empty()) {\n        return {};\n    }\n    if (array.size() == 1) {\n        return array;\n    }\n\n    // Calculate the sum of the first and last elements\n    int sum = array[0] + array[array.size() - 1];\n\n    // Sort based on the parity of the sum\n    if (sum % 2 == 0) {\n        // Even sum: sort in descending order\n        sort(array.begin(), array.end(), greater<int>());\n    } else {\n        // Odd sum: sort in ascending order\n        sort(array.begin(), array.end());\n    }\n\n    return array; // Return the sorted array\n}\n"}
{"task_id": "CPP/89", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nstring encrypt(string s) {\n    string result = \"\";\n    for (char c : s) {\n        if (c >= 'a' && c <= 'z') {\n            // Shift lowercase letters\n            char new_char = (c - 'a' + 4) % 26 + 'a';\n            result += new_char;\n        } else if (c >= 'A' && c <= 'Z') {\n            // Shift uppercase letters\n            char new_char = (c - 'A' + 4) % 26 + 'A';\n            result += new_char;\n        } else {\n            // Non-alphabetic characters remain unchanged\n            result += c;\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/90", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <iostream>\nusing namespace std;\n\nint next_smallest(vector<int> lst) {\n    if (lst.empty()) {\n        return -1; // Using -1 to represent None in this context\n    }\n    \n    // Use a set to remove duplicates\n    set<int> unique_elements(lst.begin(), lst.end());\n    \n    // If there are less than 2 unique elements, return None\n    if (unique_elements.size() < 2) {\n        return -1; // Using -1 to represent None in this context\n    }\n    \n    // Convert the set back to a vector\n    vector<int> sorted_unique(unique_elements.begin(), unique_elements.end());\n    \n    // Return the second smallest element\n    return sorted_unique[1];\n}\n\n// Example usage\n"}
{"task_id": "CPP/91", "generation": "#include <stdio.h>\n#include <string>\n#include <vector>\n#include <sstream>\n#include <algorithm>\n\nusing namespace std;\n\nint is_bored(string S) {\n    int count = 0;\n    // Define delimiters\n    char delimiters[] = {'.', '?', '!'};\n    \n    // Create a string stream from the input string\n    stringstream ss(S);\n    string sentence;\n    \n    // Read sentences based on delimiters\n    while (getline(ss, sentence, '.')) {\n        // Check for other delimiters in the same sentence\n        size_t pos;\n        while ((pos = sentence.find_first_of(\"?!\" )) != string::npos) {\n            sentence.erase(pos, 1);\n        }\n        \n        // Trim leading whitespace\n        sentence.erase(0, sentence.find_first_not_of(\" \\n\\r\\t\"));\n        \n        // Check if the sentence starts with \"I\"\n        if (sentence.rfind(\"I \", 0) == 0 || sentence == \"I\") {\n            count++;\n        }\n    }\n    \n    return count;\n}\n"}
{"task_id": "CPP/92", "generation": "#include <iostream>\n#include <cmath>\nusing namespace std;\n\nbool any_int(float a, float b, float c) {\n    // Check if all numbers are integers\n    if (a != static_cast<int>(a) || b != static_cast<int>(b) || c != static_cast<int>(c)) {\n        return false;\n    }\n    \n    // Check if any number is equal to the sum of the other two\n    if (a == b + c || b == a + c || c == a + b) {\n        return true;\n    }\n    \n    return false;\n}\n\n// Example usage\n"}
{"task_id": "CPP/93", "generation": "#include <stdio.h>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nstring encode(string message) {\n    string result = \"\";\n    for (char c : message) {\n        if (c == 'a') result += 'c';\n        else if (c == 'e') result += 'g';\n        else if (c == 'i') result += 'k';\n        else if (c == 'o') result += 'q';\n        else if (c == 'u') result += 'w';\n        else if (c == 'A') result += 'C';\n        else if (c == 'E') result += 'G';\n        else if (c == 'I') result += 'K';\n        else if (c == 'O') result += 'Q';\n        else if (c == 'U') result += 'W';\n        else if (isalpha(c)) result += islower(c) ? toupper(c) : tolower(c);\n        else result += c; // Non-letter characters remain unchanged\n    }\n    return result;\n}\n"}
{"task_id": "CPP/94", "generation": "#include <stdio.h>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\nbool isPrime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i <= sqrt(n); i++) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\nint sumOfDigits(int n) {\n    int sum = 0;\n    while (n > 0) {\n        sum += n % 10;\n        n /= 10;\n    }\n    return sum;\n}\n\nint skjkasdkd(vector<int> lst) {\n    int largestPrime = -1;\n    for (int number : lst) {\n        if (isPrime(number)) {\n            largestPrime = max(largestPrime, number);\n        }\n    }\n    \n    if (largestPrime == -1) {\n        return 0; // No prime found\n    }\n    \n    return sumOfDigits(largestPrime);\n}\n"}
{"task_id": "CPP/95", "generation": "#include <stdio.h>\n#include <string>\n#include <map>\n#include <cctype> // for islower and isupper\nusing namespace std;\n\nbool check_dict_case(map<string, string> dict) {\n    // Check if the map is empty\n    if (dict.empty()) {\n        return false;\n    }\n\n    bool allLower = true;\n    bool allUpper = true;\n\n    // Iterate through each key in the map\n    for (const auto& pair : dict) {\n        const string& key = pair.first;\n\n        // Check if the key is all lowercase\n        for (char c : key) {\n            if (!islower(c)) {\n                allLower = false;\n                break;\n            }\n        }\n\n        // Check if the key is all uppercase\n        for (char c : key) {\n            if (!isupper(c)) {\n                allUpper = false;\n                break;\n            }\n        }\n\n        // If both flags are false, we can return false\n        if (!allLower && !allUpper) {\n            return false;\n        }\n    }\n\n    // Return true if either allLower or allUpper is true\n    return allLower || allUpper;\n}\n"}
{"task_id": "CPP/96", "generation": "#include <stdio.h>\n#include <vector>\n#include <cmath> // for sqrt\nusing namespace std;\n\nbool is_prime(int num) {\n    if (num <= 1) return false; // 0 and 1 are not prime\n    for (int j = 2; j <= sqrt(num); j++) {\n        if (num % j == 0) return false; // found a divisor\n    }\n    return true; // no divisors found, it's prime\n}\n\nvector<int> count_up_to(int n) {\n    vector<int> primes;\n    if (n < 2) return primes; // return empty vector for n < 2\n    for (int i = 2; i < n; i++) {\n        if (is_prime(i)) {\n            primes.push_back(i); // add prime number to the vector\n        }\n    }\n    return primes; // return the vector of primes\n}\n"}
{"task_id": "CPP/97", "generation": "#include<stdio.h>\nusing namespace std;\n\nint multiply(int a, int b) {\n    int unitA = abs(a) % 10; // Get the unit digit of a\n    int unitB = abs(b) % 10; // Get the unit digit of b\n    return unitA * unitB;     // Return the product of the unit digits\n}\n"}
{"task_id": "CPP/98", "generation": "#include <stdio.h>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nint count_upper(string s) {\n    int count = 0; // Initialize the counter for uppercase vowels\n    for (int i = 0; i < s.length(); i += 2) { // Loop through even indices\n        char ch = s[i]; // Get the character at the current index\n        // Check if the character is an uppercase vowel\n        if (ch == 'A' || ch == 'E' || ch == 'I' || ch == 'O' || ch == 'U') {\n            count++; // Increment the count if it's an uppercase vowel\n        }\n    }\n    return count; // Return the total count of uppercase vowels found\n}\n"}
{"task_id": "CPP/99", "generation": "#include <stdio.h>\n#include <math.h>\n#include <string>\n#include <cstdlib> // for std::atof\nusing namespace std;\n\nint closest_integer(string value) {\n    double num = atof(value.c_str()); // Convert string to double\n    int lower = floor(num); // Get the lower integer\n    int upper = ceil(num); // Get the upper integer\n\n    // Calculate distances\n    double distanceLower = abs(num - lower);\n    double distanceUpper = abs(num - upper);\n\n    // Determine which integer to return\n    if (distanceLower < distanceUpper) {\n        return lower;\n    } else if (distanceUpper < distanceLower) {\n        return upper;\n    } else {\n        // If equidistant, round away from zero\n        if (num > 0) {\n            return upper; // Round up\n        } else {\n            return lower; // Round down\n        }\n    }\n}\n"}
{"task_id": "CPP/100", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nvector<int> make_a_pile(int n) {\n    vector<int> stones;\n    for (int i = 0; i < n; i++) {\n        stones.push_back(n + 2 * i);\n    }\n    return stones;\n}\n"}
{"task_id": "CPP/101", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <sstream>\nusing namespace std;\n\nvector<string> words_string(string s) {\n    // Replace commas with spaces\n    for (char& c : s) {\n        if (c == ',') {\n            c = ' ';\n        }\n    }\n    \n    vector<string> words;\n    istringstream stream(s);\n    string word;\n    \n    // Extract words from the stream\n    while (stream >> word) {\n        words.push_back(word);\n    }\n    \n    return words;\n}\n"}
{"task_id": "CPP/102", "generation": "#include<stdio.h>\nusing namespace std;\n\nint choose_num(int x, int y) {\n    // Check if the range is valid\n    if (x > y) {\n        return -1;\n    }\n    \n    // Determine the largest even number in the range\n    if (y % 2 == 0) {\n        return y; // y is even\n    } else {\n        int largest_even = y - 1; // y is odd, so the largest even is y - 1\n        if (largest_even >= x) {\n            return largest_even; // Check if it's within the range\n        } else {\n            return -1; // No even number in the range\n        }\n    }\n}\n"}
{"task_id": "CPP/103", "generation": "#include <stdio.h>\n#include <math.h>\n#include <string>\n#include <bitset>\nusing namespace std;\n\nstring rounded_avg(int n, int m) {\n    if (n > m) {\n        return \"-1\";\n    }\n    // Calculate the average\n    double average = (n + m) / 2.0;\n    // Round down to the nearest integer\n    int rounded_average = floor(average);\n    // Convert to binary\n    string binary_representation = bitset<32>(rounded_average).to_string();\n    // Remove leading zeros\n    size_t pos = binary_representation.find('1');\n    if (pos != string::npos) {\n        return binary_representation.substr(pos);\n    }\n    return \"0\"; // In case the rounded average is 0\n}\n"}
{"task_id": "CPP/104", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> unique_digits(vector<int> x) {\n    vector<int> result;\n\n    for (int number : x) {\n        int temp = number;\n        bool isValid = true;\n\n        while (temp > 0) {\n            int digit = temp % 10;\n            if (digit % 2 == 0) { // Check if the digit is even\n                isValid = false;\n                break;\n            }\n            temp /= 10; // Remove the last digit\n        }\n\n        if (isValid) {\n            result.push_back(number); // Add the number to result if valid\n        }\n    }\n\n    sort(result.begin(), result.end()); // Sort the result vector\n    return result;\n}\n"}
{"task_id": "CPP/105", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\nvector<string> by_length(vector<int> arr) {\n    vector<int> valid_numbers;\n    \n    // Filter numbers between 1 and 9\n    for (int number : arr) {\n        if (number >= 1 && number <= 9) {\n            valid_numbers.push_back(number);\n        }\n    }\n    \n    // Sort the valid numbers\n    sort(valid_numbers.begin(), valid_numbers.end());\n    \n    // Reverse the sorted numbers\n    reverse(valid_numbers.begin(), valid_numbers.end());\n    \n    // Mapping from integers to their corresponding string names\n    map<int, string> numberToString = {\n        {1, \"One\"}, {2, \"Two\"}, {3, \"Three\"}, {4, \"Four\"},\n        {5, \"Five\"}, {6, \"Six\"}, {7, \"Seven\"}, {8, \"Eight\"}, {9, \"Nine\"}\n    };\n    \n    vector<string> result;\n    \n    // Convert numbers to their corresponding string names\n    for (int number : valid_numbers) {\n        result.push_back(numberToString[number]);\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/106", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nvector<int> f(int n) {\n    vector<int> result(n);\n    \n    for (int i = 1; i <= n; i++) {\n        if (i % 2 == 0) { // i is even\n            // Calculate factorial\n            int factorial = 1;\n            for (int j = 1; j <= i; j++) {\n                factorial *= j;\n            }\n            result[i - 1] = factorial;\n        } else { // i is odd\n            // Calculate sum from 1 to i\n            result[i - 1] = (i * (i + 1)) / 2;\n        }\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/107", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nbool is_palindrome(int num) {\n    string str = to_string(num);\n    string rev_str = string(str.rbegin(), str.rend());\n    return str == rev_str;\n}\n\nvector<int> even_odd_palindrome(int n) {\n    int even_count = 0;\n    int odd_count = 0;\n\n    for (int i = 1; i <= n; i++) {\n        if (is_palindrome(i)) {\n            if (i % 2 == 0) {\n                even_count++;\n            } else {\n                odd_count++;\n            }\n        }\n    }\n\n    return {even_count, odd_count};\n}\n"}
{"task_id": "CPP/108", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nint count_nums(vector<int> n) {\n    int count = 0;\n\n    for (int num : n) {\n        int sum_of_digits = 0;\n        int abs_num = abs(num);\n        \n        // If the number is negative, we will subtract the first digit\n        if (num < 0) {\n            sum_of_digits -= (abs_num % 10); // First digit is negative\n            abs_num /= 10;\n        }\n        \n        // Calculate the sum of the remaining digits\n        while (abs_num > 0) {\n            sum_of_digits += (abs_num % 10);\n            abs_num /= 10;\n        }\n        \n        // Check if the sum of digits is greater than 0\n        if (sum_of_digits > 0) {\n            count++;\n        }\n    }\n    \n    return count;\n}\n"}
{"task_id": "CPP/109", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nbool move_one_ball(vector<int> arr) {\n    // Step 1: Check for empty array\n    if (arr.empty()) {\n        return true;\n    }\n    \n    int breaks = 0;\n    int n = arr.size();\n    \n    // Step 2: Count the number of breaks\n    for (int i = 0; i < n; i++) {\n        if (arr[i] > arr[(i + 1) % n]) { // Use modulo to wrap around\n            breaks++;\n        }\n    }\n    \n    // Step 3: Determine if sorting is possible\n    return breaks <= 1;\n}\n"}
{"task_id": "CPP/110", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring exchange(vector<int> lst1, vector<int> lst2) {\n    int odd_count = 0;\n    \n    // Count odd numbers in lst1\n    for (int number : lst1) {\n        if (number % 2 != 0) {\n            odd_count++;\n        }\n    }\n    \n    // If there are no odd numbers in lst1, return \"YES\"\n    if (odd_count == 0) {\n        return \"YES\";\n    }\n    \n    // Check if there is at least one even number in lst2\n    for (int number : lst2) {\n        if (number % 2 == 0) {\n            return \"YES\";\n        }\n    }\n    \n    // If we have odd numbers in lst1 and no even numbers in lst2\n    return \"NO\";\n}\n"}
{"task_id": "CPP/111", "generation": "#include <stdio.h>\n#include <string>\n#include <map>\n#include <sstream>\n#include <vector>\nusing namespace std;\n\nmap<string, int> histogram(string test) {\n    map<string, int> countMap;\n    stringstream ss(test);\n    string letter;\n\n    // Count occurrences of each letter\n    while (ss >> letter) {\n        countMap[letter]++;\n    }\n\n    // Find the maximum count\n    int maxCount = 0;\n    for (const auto& pair : countMap) {\n        if (pair.second > maxCount) {\n            maxCount = pair.second;\n        }\n    }\n\n    // Create a result map for letters with the maximum count\n    map<string, int> resultMap;\n    for (const auto& pair : countMap) {\n        if (pair.second == maxCount) {\n            resultMap[pair.first] = pair.second;\n        }\n    }\n\n    return resultMap;\n}\n"}
{"task_id": "CPP/112", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <unordered_set>\n#include <algorithm>\nusing namespace std;\n\nvector<string> reverse_delete(string s, string c) {\n    unordered_set<char> charsToRemove(c.begin(), c.end());\n    string result;\n\n    // Build the result string by skipping characters in charsToRemove\n    for (char ch : s) {\n        if (charsToRemove.find(ch) == charsToRemove.end()) {\n            result += ch;\n        }\n    }\n\n    // Check if the result string is a palindrome\n    string reversedResult = result;\n    reverse(reversedResult.begin(), reversedResult.end());\n    bool isPalindrome = (result == reversedResult);\n\n    // Prepare the output\n    return {result, isPalindrome ? \"True\" : \"False\"};\n}\n"}
{"task_id": "CPP/113", "generation": "#include <vector>\n#include <string>\n#include <iostream>\n\nusing namespace std;\n\nvector<string> odd_count(vector<string> lst) {\n    vector<string> result; // To store the output strings\n    for (int i = 0; i < lst.size(); i++) {\n        int odd_count = 0; // Counter for odd digits\n        for (char c : lst[i]) {\n            // Check if the character is an odd digit\n            if (c == '1' || c == '3' || c == '5' || c == '7' || c == '9') {\n                odd_count++;\n            }\n        }\n        // Create the output string\n        string output = \"the number of odd elements \" + to_string(odd_count) + \n                        \" in the string \" + to_string(i) + \n                        \" of the input.\";\n        result.push_back(output); // Add to the result vector\n    }\n    return result; // Return the result\n}\n"}
{"task_id": "CPP/114", "generation": "#include <stdio.h>\n#include <vector>\n#include <limits.h> // for INT_MAX\nusing namespace std;\n\nlong long minSubArraySum(vector<long long> nums) {\n    long long minSum = LLONG_MAX; // Initialize to maximum possible value\n    long long currentSum = 0; // Initialize current sum to 0\n    \n    for (long long num : nums) {\n        currentSum += num; // Add current number to current sum\n        \n        // Update minSum if currentSum is less\n        if (currentSum < minSum) {\n            minSum = currentSum;\n        }\n        \n        // Reset currentSum if it becomes positive\n        if (currentSum > 0) {\n            currentSum = 0;\n        }\n    }\n    \n    return minSum; // Return the minimum sub-array sum\n}\n"}
{"task_id": "CPP/115", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nint max_fill(vector<vector<int>> grid, int capacity) {\n    int total_water = 0;\n    \n    // Count total units of water in the grid\n    for (const auto& row : grid) {\n        for (int cell : row) {\n            if (cell == 1) {\n                total_water++;\n            }\n        }\n    }\n    \n    // Calculate the number of times we need to lower the buckets\n    int times_to_lower = total_water / capacity;\n    if (total_water % capacity != 0) {\n        times_to_lower++;\n    }\n    \n    return times_to_lower;\n}\n"}
{"task_id": "CPP/116", "generation": "#include <vector>\n#include <algorithm>\n#include <bitset>\n#include <iostream>\n\nusing namespace std;\n\n// Helper function to count the number of 1s in the binary representation of a number\nint countOnes(int n) {\n    return bitset<32>(n).count(); // Using bitset to count the number of 1s\n}\n\nvector<int> sort_array(vector<int> arr) {\n    // Custom comparator for sorting\n    sort(arr.begin(), arr.end(), [](int a, int b) {\n        int countA = countOnes(a);\n        int countB = countOnes(b);\n        if (countA == countB) {\n            return a < b; // If counts are the same, sort by value\n        }\n        return countA < countB; // Otherwise, sort by count of 1s\n    });\n    return arr;\n}\n\n// Example usage\n"}
{"task_id": "CPP/117", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <cctype>\n\nusing namespace std;\n\nvector<string> select_words(string s, int n) {\n    vector<string> result;\n    stringstream ss(s);\n    string word;\n\n    // Split the string into words\n    while (ss >> word) {\n        int consonant_count = 0;\n\n        // Count consonants in the word\n        for (char c : word) {\n            // Check if the character is a consonant\n            if (isalpha(c) && !strchr(\"aeiouAEIOU\", c)) {\n                consonant_count++;\n            }\n        }\n\n        // If the consonant count matches n, add the word to result\n        if (consonant_count == n) {\n            result.push_back(word);\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/118", "generation": "#include <stdio.h>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nstring get_closest_vowel(string word) {\n    // Define the set of vowels\n    string vowels = \"aeiouAEIOU\";\n    \n    // Length of the word\n    int n = word.length();\n    \n    // Check for edge case where the word is too short\n    if (n < 3) {\n        return \"\";\n    }\n    \n    // Iterate from the end to the beginning of the string\n    for (int i = n - 2; i > 0; i--) {\n        // Check if the current character is a vowel\n        if (vowels.find(word[i]) != string::npos) {\n            // Check if the characters before and after are consonants\n            if (isalpha(word[i - 1]) && vowels.find(word[i - 1]) == string::npos &&\n                isalpha(word[i + 1]) && vowels.find(word[i + 1]) == string::npos) {\n                return string(1, word[i]); // Return the vowel as a string\n            }\n        }\n    }\n    \n    // If no vowel found, return an empty string\n    return \"\";\n}\n"}
{"task_id": "CPP/119", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring match_parens(vector<string> lst) {\n    string s1 = lst[0];\n    string s2 = lst[1];\n    \n    int open1 = 0, close1 = 0;\n    int open2 = 0, close2 = 0;\n\n    // Count parentheses in the first string\n    for (char c : s1) {\n        if (c == '(') open1++;\n        else close1++;\n    }\n\n    // Count parentheses in the second string\n    for (char c : s2) {\n        if (c == '(') open2++;\n        else close2++;\n    }\n\n    // Check the conditions for both concatenation orders\n    bool firstOrderGood = (open1 + open2 >= close1 + close2) && (open1 >= close2);\n    bool secondOrderGood = (open2 + open1 >= close2 + close1) && (open2 >= close1);\n\n    return (firstOrderGood || secondOrderGood) ? \"Yes\" : \"No\";\n}\n"}
{"task_id": "CPP/120", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> maximum(vector<int> arr, int k) {\n    // If k is 0, return an empty vector\n    if (k == 0) {\n        return {};\n    }\n    \n    // Sort the array in descending order\n    sort(arr.begin(), arr.end(), greater<int>());\n    \n    // Select the first k elements\n    vector<int> maxElements(arr.begin(), arr.begin() + k);\n    \n    // Sort the selected k elements in ascending order\n    sort(maxElements.begin(), maxElements.end());\n    \n    return maxElements;\n}\n"}
{"task_id": "CPP/121", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nint solution(vector<int> lst) {\n    int sum = 0; // Initialize sum to 0\n    for (int i = 0; i < lst.size(); i++) { // Iterate through the vector\n        if (i % 2 == 0) { // Check if the index is even\n            if (lst[i] % 2 != 0) { // Check if the element is odd\n                sum += lst[i]; // Add the odd element to sum\n            }\n        }\n    }\n    return sum; // Return the final sum\n}\n"}
{"task_id": "CPP/122", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nint add_elements(vector<int> arr, int k) {\n    int sum = 0; // Initialize sum\n    for (int i = 0; i < k; i++) { // Iterate through the first k elements\n        if (abs(arr[i]) < 100) { // Check if the element has at most two digits\n            sum += arr[i]; // Add to sum\n        }\n    }\n    return sum; // Return the final sum\n}\n"}
{"task_id": "CPP/123", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> get_odd_collatz(int n) {\n    vector<int> odd_numbers;\n    \n    while (n != 1) {\n        if (n % 2 != 0) { // Check if n is odd\n            odd_numbers.push_back(n);\n        }\n        // Generate the next term in the Collatz sequence\n        if (n % 2 == 0) {\n            n = n / 2; // If n is even\n        } else {\n            n = 3 * n + 1; // If n is odd\n        }\n    }\n    \n    // Add 1 to the list since the sequence ends at 1\n    odd_numbers.push_back(1);\n    \n    // Sort the vector of odd numbers\n    sort(odd_numbers.begin(), odd_numbers.end());\n    \n    return odd_numbers;\n}\n"}
{"task_id": "CPP/124", "generation": "#include <stdio.h>\n#include <string>\n#include <sstream>\nusing namespace std;\n\nbool valid_date(string date) {\n    // Check if the string is empty\n    if (date.empty()) {\n        return false;\n    }\n    \n    // Check the length and format\n    if (date.length() != 10 || date[2] != '-' || date[5] != '-') {\n        return false;\n    }\n    \n    // Extract month, day, year\n    int month = stoi(date.substr(0, 2));\n    int day = stoi(date.substr(3, 2));\n    int year = stoi(date.substr(6, 4));\n    \n    // Validate month\n    if (month < 1 || month > 12) {\n        return false;\n    }\n    \n    // Validate day based on month\n    if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {\n        if (day < 1 || day > 31) {\n            return false;\n        }\n    } else if (month == 4 || month == 6 || month == 9 || month == 11) {\n        if (day < 1 || day > 30) {\n            return false;\n        }\n    } else if (month == 2) {\n        if (day < 1 || day > 29) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n"}
{"task_id": "CPP/125", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <cctype>\n\nusing namespace std;\n\nvector<string> split_words(string txt) {\n    // Check for whitespace\n    if (txt.find(' ') != string::npos) {\n        // Split by whitespace\n        istringstream iss(txt);\n        vector<string> words((istream_iterator<string>(iss)), istream_iterator<string>());\n        return words;\n    }\n    // Check for commas\n    else if (txt.find(',') != string::npos) {\n        // Split by commas\n        vector<string> words;\n        size_t pos = 0;\n        while ((pos = txt.find(',')) != string::npos) {\n            words.push_back(txt.substr(0, pos));\n            txt.erase(0, pos + 1);\n        }\n        words.push_back(txt); // Add the last segment\n        return words;\n    }\n    // If neither whitespace nor commas exist\n    else {\n        int count = 0;\n        for (char c : txt) {\n            if (islower(c)) {\n                int position = c - 'a'; // Get the position in the alphabet\n                if (position % 2 == 1) { // Check if it's odd\n                    count++;\n                }\n            }\n        }\n        return vector<string>{to_string(count)}; // Return count as string in a vector\n    }\n}\n"}
{"task_id": "CPP/126", "generation": "#include <stdio.h>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nbool is_sorted(vector<int> lst) {\n    unordered_map<int, int> countMap; // To count occurrences of each number\n    if (lst.empty()) return true; // An empty list is considered sorted\n\n    for (size_t i = 0; i < lst.size(); ++i) {\n        // Check if the current number is less than the previous number\n        if (i > 0 && lst[i] < lst[i - 1]) {\n            return false; // Not sorted\n        }\n        \n        // Count occurrences\n        countMap[lst[i]]++;\n        if (countMap[lst[i]] > 2) {\n            return false; // More than two occurrences\n        }\n    }\n    \n    return true; // The list is sorted and no number appears more than twice\n}\n"}
{"task_id": "CPP/127", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <cmath>\nusing namespace std;\n\nbool isPrime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i <= sqrt(n); i++) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\nstring intersection(vector<int> interval1, vector<int> interval2) {\n    int start1 = interval1[0];\n    int end1 = interval1[1];\n    int start2 = interval2[0];\n    int end2 = interval2[1];\n\n    int intersectionStart = max(start1, start2);\n    int intersectionEnd = min(end1, end2);\n\n    if (intersectionStart > intersectionEnd) {\n        return \"NO\";\n    }\n\n    int length = intersectionEnd - intersectionStart + 1;\n    if (isPrime(length)) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n"}
{"task_id": "CPP/128", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nint prod_signs(vector<int> arr) {\n    if (arr.empty()) {\n        return -32768;\n    }\n    \n    int sum_magnitudes = 0;\n    int product_signs = 1;\n    \n    for (int number : arr) {\n        if (number > 0) {\n            sum_magnitudes += number;\n        } else if (number < 0) {\n            sum_magnitudes += -number; // add the absolute value\n            product_signs *= -1;\n        } else {\n            product_signs = 0; // if there's a zero, product of signs becomes 0\n        }\n    }\n    \n    return sum_magnitudes * product_signs;\n}\n"}
{"task_id": "CPP/129", "generation": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> bestPath; // To store the best path found\n\nvoid dfs(int x, int y, vector<int>& currentPath, int length, const vector<vector<int>>& grid, int k) {\n    if (length == k) {\n        if (bestPath.empty() || currentPath < bestPath) {\n            bestPath = currentPath; // Update best path if current is better\n        }\n        return;\n    }\n\n    // Directions for moving in the grid (right, down, left, up)\n    vector<pair<int, int>> directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n    \n    for (const auto& dir : directions) {\n        int newX = x + dir.first;\n        int newY = y + dir.second;\n\n        // Check bounds\n        if (newX >= 0 && newX < grid.size() && newY >= 0 && newY < grid[0].size()) {\n            currentPath.push_back(grid[newX][newY]);\n            dfs(newX, newY, currentPath, length + 1, grid, k);\n            currentPath.pop_back(); // Backtrack\n        }\n    }\n}\n\nvector<int> minPath(vector<vector<int>> grid, int k) {\n    bestPath.clear(); // Clear the best path before starting\n    int n = grid.size();\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            vector<int> currentPath = {grid[i][j]};\n            dfs(i, j, currentPath, 1, grid, k); // Start DFS from each cell\n        }\n    }\n\n    return bestPath; // Return the best path found\n}\n"}
{"task_id": "CPP/130", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nvector<int> tri(int n) {\n    vector<int> result(n + 1);\n    for (int i = 0; i <= n; i++) {\n        if (i == 0) {\n            result[i] = 1; // Assuming tri(0) = 1\n        } else if (i == 1) {\n            result[i] = 3; // tri(1) = 3\n        } else if (i % 2 == 0) {\n            result[i] = 1 + i / 2; // Even case\n        } else {\n            // Odd case\n            result[i] = result[i - 1] + result[i - 2] + (i - 3 >= 0 ? result[i - 3] : 0);\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/131", "generation": "#include<stdio.h>\n\nint digits(int n) {\n    int product = 1;\n    bool hasOdd = false;\n\n    while (n > 0) {\n        int digit = n % 10; // Get the last digit\n        if (digit % 2 != 0) { // Check if the digit is odd\n            hasOdd = true;\n            product *= digit; // Multiply the product by the odd digit\n        }\n        n /= 10; // Remove the last digit\n    }\n\n    return hasOdd ? product : 0; // Return product if odd digits were found, otherwise return 0\n}\n"}
{"task_id": "CPP/132", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nbool is_nested(string str) {\n    int open_count = 0;\n    bool nested_found = false;\n\n    for (char ch : str) {\n        if (ch == '[') {\n            open_count++;\n        } else if (ch == ']') {\n            open_count--;\n        }\n\n        // If at any point open_count is negative, it's invalid\n        if (open_count < 0) {\n            return false;\n        }\n\n        // Check if we have more than one open bracket at any point\n        if (open_count > 1) {\n            nested_found = true;\n        }\n    }\n\n    // Valid if all brackets are matched and at least one nested pair was found\n    return open_count == 0 && nested_found;\n}\n"}
{"task_id": "CPP/133", "generation": "#include <stdio.h>\n#include <math.h>\n#include <vector>\nusing namespace std;\n\nint sum_squares(vector<float> lst) {\n    int sum = 0; // Initialize sum to 0\n    for (float num : lst) { // Loop through each number in the vector\n        int rounded = ceil(num); // Round the number up to the nearest integer\n        sum += rounded * rounded; // Square the rounded number and add to sum\n    }\n    return sum; // Return the final sum\n}\n"}
{"task_id": "CPP/134", "generation": "#include <iostream>\n#include <string>\n#include <cctype> // for isalpha function\nusing namespace std;\n\nbool check_if_last_char_is_a_letter(string txt) {\n    // Trim trailing spaces\n    size_t end = txt.find_last_not_of(' ');\n    if (end == string::npos) {\n        return false; // String is empty or only spaces\n    }\n    \n    // Get the last character\n    char lastChar = txt[end];\n    \n    // Check if the last character is an alphabetical character\n    if (isalpha(lastChar)) {\n        // Check if it's not part of a word (i.e., followed by a space or at the end of the string)\n        if (end == txt.length() - 1 || txt[end + 1] == ' ') {\n            return true;\n        }\n    }\n    \n    return false;\n}\n\n// Example usage\n"}
{"task_id": "CPP/135", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nint can_arrange(vector<int> arr) {\n    int largest_index = -1; // Initialize to -1\n    for (int i = 1; i < arr.size(); i++) { // Start from the second element\n        if (arr[i] < arr[i - 1]) { // Check if current element is less than the previous\n            largest_index = i; // Update largest_index\n        }\n    }\n    return largest_index; // Return the largest index found or -1\n}\n"}
{"task_id": "CPP/136", "generation": "#include <stdio.h>\n#include <vector>\n#include <limits.h> // For INT_MIN and INT_MAX\nusing namespace std;\n\nvector<int> largest_smallest_integers(vector<int> lst) {\n    int largest_negative = INT_MIN;\n    int smallest_positive = INT_MAX;\n\n    for (int number : lst) {\n        if (number < 0) {\n            if (number > largest_negative) {\n                largest_negative = number;\n            }\n        } else if (number > 0) {\n            if (number < smallest_positive) {\n                smallest_positive = number;\n            }\n        }\n    }\n\n    if (largest_negative == INT_MIN) {\n        largest_negative = 0;\n    }\n    if (smallest_positive == INT_MAX) {\n        smallest_positive = 0;\n    }\n\n    return {largest_negative, smallest_positive};\n}\n"}
{"task_id": "CPP/137", "generation": "#include <iostream>\n#include <string>\n#include <boost/any.hpp>\n#include <sstream>\n\nboost::any compare_one(boost::any a, boost::any b) {\n    // Helper function to convert string to float\n    auto string_to_float = [](const std::string& str) {\n        std::string cleaned = str;\n        // Replace comma with dot for decimal conversion\n        std::replace(cleaned.begin(), cleaned.end(), ',', '.');\n        return std::stof(cleaned);\n    };\n\n    // Check types and compare\n    if (a.type() == b.type()) {\n        if (a.type() == typeid(int)) {\n            int int_a = boost::any_cast<int>(a);\n            int int_b = boost::any_cast<int>(b);\n            if (int_a == int_b) return \"None\";\n            return (int_a > int_b) ? a : b;\n        } else if (a.type() == typeid(float)) {\n            float float_a = boost::any_cast<float>(a);\n            float float_b = boost::any_cast<float>(b);\n            if (float_a == float_b) return \"None\";\n            return (float_a > float_b) ? a : b;\n        } else if (a.type() == typeid(std::string)) {\n            std::string str_a = boost::any_cast<std::string>(a);\n            std::string str_b = boost::any_cast<std::string>(b);\n            float float_a = string_to_float(str_a);\n            float float_b = string_to_float(str_b);\n            if (float_a == float_b) return \"None\";\n            return (float_a > float_b) ? a : b;\n        }\n    } else {\n        // Different types, convert to float for comparison\n        float float_a, float_b;\n\n        if (a.type() == typeid(int)) {\n            float_a = boost::any_cast<int>(a);\n            float_b = string_to_float(boost::any_cast<std::string>(b));\n        } else if (b.type() == typeid(int)) {\n            float_a = string_to_float(boost::any_cast<std::string>(a));\n            float_b = boost::any_cast<int>(b);\n        } else if (a.type() == typeid(float)) {\n            float_a = boost::any_cast<float>(a);\n            float_b = string_to_float(boost::any_cast<std::string>(b));\n        } else {\n            float_a = string_to_float(boost::any_cast<std::string>(a));\n            float_b = boost::any_cast<float>(b);\n        }\n\n        if (float_a == float_b) return \"None\";\n        return (float_a > float_b) ? a : b;\n    }\n\n    return \"None\"; // Fallback case, should not reach here\n}\n\n"}
{"task_id": "CPP/138", "generation": "#include<stdio.h>\nusing namespace std;\n\nbool is_equal_to_sum_even(int n) {\n    if (n < 8) {\n        return false; // Not enough to form the sum of 4 positive even numbers\n    }\n    return n % 2 == 0; // Return true if n is even, false if odd\n}\n"}
{"task_id": "CPP/139", "generation": "#include <stdio.h>\nusing namespace std;\n\nlong long special_factorial(int n) {\n    long long result = 1; // To store the final result\n    for (int i = 1; i <= n; i++) {\n        long long fact = 1; // To calculate i!\n        for (int j = 1; j <= i; j++) {\n            fact *= j; // Calculate factorial of i\n        }\n        result *= fact; // Multiply the current factorial to the result\n    }\n    return result; // Return the final result\n}\n"}
{"task_id": "CPP/140", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nstring fix_spaces(string text) {\n    string result = \"\";\n    int spaceCount = 0;\n\n    for (char c : text) {\n        if (c == ' ') {\n            spaceCount++;\n        } else {\n            if (spaceCount > 2) {\n                result += '-';\n            } else if (spaceCount == 1) {\n                result += '_';\n            }\n            result += c; // Append the current non-space character\n            spaceCount = 0; // Reset space count\n        }\n    }\n\n    // Handle trailing spaces\n    if (spaceCount > 2) {\n        result += '-';\n    } else if (spaceCount == 1) {\n        result += '_';\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/141", "generation": "#include <stdio.h>\n#include <string>\n#include <cctype> // for isdigit and isalpha\n#include <set> // for set to store valid extensions\nusing namespace std;\n\nstring file_name_check(string file_name) {\n    int digit_count = 0;\n    int dot_count = 0;\n    int dot_index = -1;\n\n    // Count digits and dots\n    for (int i = 0; i < file_name.length(); i++) {\n        if (isdigit(file_name[i])) {\n            digit_count++;\n        }\n        if (file_name[i] == '.') {\n            dot_count++;\n            dot_index = i; // Store the index of the dot\n        }\n    }\n\n    // Check conditions\n    if (digit_count > 3) {\n        return \"No\";\n    }\n    if (dot_count != 1) {\n        return \"No\";\n    }\n\n    // Extract substrings\n    string before_dot = file_name.substr(0, dot_index);\n    string after_dot = file_name.substr(dot_index + 1);\n\n    // Check if before_dot is empty or does not start with a letter\n    if (before_dot.empty() || !isalpha(before_dot[0])) {\n        return \"No\";\n    }\n\n    // Check if after_dot is one of the valid extensions\n    set<string> valid_extensions = {\"txt\", \"exe\", \"dll\"};\n    if (valid_extensions.find(after_dot) == valid_extensions.end()) {\n        return \"No\";\n    }\n\n    return \"Yes\";\n}\n"}
{"task_id": "CPP/142", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nint sum_squares(vector<int> lst) {\n    int sum = 0; // Initialize sum\n    for (int index = 0; index < lst.size(); index++) {\n        if (index % 3 == 0) {\n            sum += lst[index] * lst[index]; // Square the integer\n        } else if (index % 4 == 0) {\n            sum += lst[index] * lst[index] * lst[index]; // Cube the integer\n        } else {\n            sum += lst[index]; // Keep the integer as is\n        }\n    }\n    return sum; // Return the final sum\n}\n"}
{"task_id": "CPP/143", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <cmath>\n#include <vector>\n\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i <= sqrt(n); i++) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\n// Function to filter words with prime lengths\nstring words_in_sentence(string sentence) {\n    stringstream ss(sentence);\n    string word;\n    string result;\n    \n    while (ss >> word) {\n        if (is_prime(word.length())) {\n            if (!result.empty()) {\n                result += \" \"; // Add space before the next word\n            }\n            result += word; // Append the word to the result\n        }\n    }\n    \n    return result;\n}\n\n// Example usage\n"}
{"task_id": "CPP/144", "generation": "#include <stdio.h>\n#include <string>\n#include <sstream>\n#include <vector>\n\nusing namespace std;\n\nbool simplify(string x, string n) {\n    // Split the fraction x\n    size_t pos = x.find('/');\n    int numerator_x = stoi(x.substr(0, pos));\n    int denominator_x = stoi(x.substr(pos + 1));\n\n    // Split the fraction n\n    pos = n.find('/');\n    int numerator_n = stoi(n.substr(0, pos));\n    int denominator_n = stoi(n.substr(pos + 1));\n\n    // Calculate the products\n    int product_numerator = numerator_x * numerator_n;\n    int product_denominator = denominator_x * denominator_n;\n\n    // Check if product_numerator is divisible by product_denominator\n    return product_numerator % product_denominator == 0;\n}\n"}
{"task_id": "CPP/145", "generation": "#include <vector>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\n// Helper function to calculate the sum of digits\nint digitSum(int num) {\n    int sum = 0;\n    bool isNegative = num < 0;\n    num = abs(num);\n    \n    while (num > 0) {\n        sum += num % 10;\n        num /= 10;\n    }\n    \n    // If the number was negative, subtract twice the first digit\n    if (isNegative) {\n        sum -= 2 * (abs(num) % 10);\n    }\n    \n    return sum;\n}\n\n// Main function to sort the vector based on the sum of digits\nvector<int> order_by_points(vector<int> nums) {\n    sort(nums.begin(), nums.end(), [](int a, int b) {\n        int sumA = digitSum(a);\n        int sumB = digitSum(b);\n        return sumA < sumB; // Sort by digit sum\n    });\n    \n    return nums;\n}\n"}
{"task_id": "CPP/146", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nint specialFilter(vector<int> nums) {\n    int count = 0;\n    for (int num : nums) {\n        if (num > 10) {\n            int last_digit = num % 10;\n            int first_digit = num;\n            while (first_digit >= 10) {\n                first_digit /= 10;\n            }\n            if (last_digit % 2 != 0 && first_digit % 2 != 0) {\n                count++;\n            }\n        }\n    }\n    return count;\n}\n"}
{"task_id": "CPP/147", "generation": "#include <vector>\nusing namespace std;\n\nint get_max_triples(int n) {\n    vector<int> a(n);\n    for (int i = 1; i <= n; ++i) {\n        a[i - 1] = i * i - i + 1; // Fill the vector using the given formula\n    }\n\n    int count0 = 0, count1 = 0, count2 = 0;\n\n    // Count the occurrences of each remainder when divided by 3\n    for (int i = 0; i < n; ++i) {\n        if (a[i] % 3 == 0) count0++;\n        else if (a[i] % 3 == 1) count1++;\n        else count2++;\n    }\n\n    int totalTriples = 0;\n\n    // Count combinations of three from each category\n    // C(count0, 3)\n    if (count0 >= 3) {\n        totalTriples += (count0 * (count0 - 1) * (count0 - 2)) / 6;\n    }\n    // C(count1, 3)\n    if (count1 >= 3) {\n        totalTriples += (count1 * (count1 - 1) * (count1 - 2)) / 6;\n    }\n    // C(count2, 3)\n    if (count2 >= 3) {\n        totalTriples += (count2 * (count2 - 1) * (count2 - 2)) / 6;\n    }\n    \n    // Count combinations of one from each category\n    totalTriples += count0 * count1 * count2;\n\n    return totalTriples;\n}\n"}
{"task_id": "CPP/148", "generation": "#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nvector<string> bf(string planet1, string planet2) {\n    vector<string> planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n    \n    // Check if planet1 and planet2 are valid\n    auto it1 = find(planets.begin(), planets.end(), planet1);\n    auto it2 = find(planets.begin(), planets.end(), planet2);\n    \n    if (it1 == planets.end() || it2 == planets.end()) {\n        return {}; // Return empty vector if either planet is invalid\n    }\n    \n    // Get indices of the planets\n    int index1 = distance(planets.begin(), it1);\n    int index2 = distance(planets.begin(), it2);\n    \n    // Ensure index1 is less than index2\n    if (index1 > index2) {\n        swap(index1, index2);\n    }\n    \n    // Collect planets in between\n    vector<string> result;\n    for (int i = index1 + 1; i < index2; ++i) {\n        result.push_back(planets[i]);\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/149", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to check if the length of a string is odd\nbool isOddLength(const string& str) {\n    return str.length() % 2 != 0;\n}\n\n// Comparator for sorting\nbool compare(const string& a, const string& b) {\n    if (a.length() == b.length()) {\n        return a < b; // Sort alphabetically if lengths are the same\n    }\n    return a.length() < b.length(); // Sort by length\n}\n\nvector<string> sorted_list_sum(vector<string> lst) {\n    // Step 1: Remove strings with odd lengths\n    lst.erase(remove_if(lst.begin(), lst.end(), isOddLength), lst.end());\n    \n    // Step 2: Sort the remaining strings\n    sort(lst.begin(), lst.end(), compare);\n    \n    // Step 3: Return the sorted list\n    return lst;\n}\n"}
{"task_id": "CPP/150", "generation": "#include <stdio.h>\n#include <cmath>\n\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int n) {\n    if (n < 2) return false; // 0 and 1 are not prime numbers\n    for (int i = 2; i <= sqrt(n); i++) {\n        if (n % i == 0) return false; // Found a divisor, not prime\n    }\n    return true; // No divisors found, it is prime\n}\n\n// Main function to return x or y based on the primality of n\nint x_or_y(int n, int x, int y) {\n    if (is_prime(n)) {\n        return x; // n is prime\n    } else {\n        return y; // n is not prime\n    }\n}\n"}
{"task_id": "CPP/151", "generation": "#include <stdio.h>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\nlong long double_the_difference(vector<float> lst) {\n    long long sum_of_squares = 0; // Initialize sum of squares\n    for (float number : lst) {\n        // Check if the number is a non-negative integer\n        if (number >= 0 && floor(number) == number) {\n            // Check if the number is odd\n            if (static_cast<int>(number) % 2 != 0) {\n                sum_of_squares += static_cast<int>(number) * static_cast<int>(number); // Add square of the odd number\n            }\n        }\n    }\n    return sum_of_squares; // Return the final sum\n}\n"}
{"task_id": "CPP/152", "generation": "#include <vector>\n#include <cmath> // for abs function\nusing namespace std;\n\nvector<int> compare(vector<int> game, vector<int> guess) {\n    vector<int> result; // Initialize the result vector\n    for (size_t i = 0; i < game.size(); i++) { // Loop through each match\n        int difference = abs(game[i] - guess[i]); // Calculate absolute difference\n        result.push_back(difference); // Append the difference to the result\n    }\n    return result; // Return the result vector\n}\n"}
{"task_id": "CPP/153", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cctype> // for isupper and islower\n\nusing namespace std;\n\nstring Strongest_Extension(string class_name, vector<string> extensions) {\n    int max_strength = -INT_MAX; // Initialize to a very small number\n    string strongest_extension = \"\";\n\n    for (const string& extension : extensions) {\n        int CAP = 0;\n        int SM = 0;\n\n        // Count uppercase and lowercase letters\n        for (char ch : extension) {\n            if (isupper(ch)) {\n                CAP++;\n            } else if (islower(ch)) {\n                SM++;\n            }\n        }\n\n        // Calculate strength\n        int strength = CAP - SM;\n\n        // Update if this extension is stronger\n        if (strength > max_strength) {\n            max_strength = strength;\n            strongest_extension = extension;\n        }\n    }\n\n    return class_name + \".\" + strongest_extension;\n}\n"}
{"task_id": "CPP/154", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nbool cycpattern_check(string a, string b) {\n    // Concatenate b with itself\n    string concatenated_b = b + b;\n    // Check if a is a substring of concatenated_b\n    return concatenated_b.find(a) != string::npos;\n}\n"}
{"task_id": "CPP/155", "generation": "#include <stdio.h>\n#include <vector>\n#include <cmath> // for abs function\nusing namespace std;\n\nvector<int> even_odd_count(int num) {\n    vector<int> counts(2, 0); // counts[0] for even, counts[1] for odd\n    num = abs(num); // consider absolute value\n\n    while (num > 0) {\n        int digit = num % 10; // get the last digit\n        if (digit % 2 == 0) {\n            counts[0]++; // even\n        } else {\n            counts[1]++; // odd\n        }\n        num /= 10; // remove the last digit\n    }\n    \n    return counts; // return the counts\n}\n"}
{"task_id": "CPP/156", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring int_to_mini_roman(int number) {\n    // Mapping of integer values to Roman numeral symbols\n    vector<pair<int, string>> roman_numerals = {\n        {1000, \"m\"}, {900, \"cm\"}, {500, \"d\"}, {400, \"cd\"},\n        {100, \"c\"}, {90, \"xc\"}, {50, \"l\"}, {40, \"xl\"},\n        {10, \"x\"}, {9, \"ix\"}, {5, \"v\"}, {4, \"iv\"},\n        {1, \"i\"}\n    };\n\n    string result = \"\";\n    \n    // Convert the number to Roman numeral\n    for (const auto& [value, symbol] : roman_numerals) {\n        while (number >= value) {\n            number -= value;\n            result += symbol;\n        }\n    }\n    \n    return result; // The result is already in lowercase\n}\n"}
{"task_id": "CPP/157", "generation": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n\nbool right_angle_triangle(float a, float b, float c) {\n    // Identify the longest side\n    float max_side = max(a, max(b, c));\n    float side1, side2;\n\n    // Assign the other two sides\n    if (max_side == a) {\n        side1 = b;\n        side2 = c;\n    } else if (max_side == b) {\n        side1 = a;\n        side2 = c;\n    } else {\n        side1 = a;\n        side2 = b;\n    }\n\n    // Check the Pythagorean theorem\n    return (side1 * side1 + side2 * side2 == max_side * max_side);\n}\n"}
{"task_id": "CPP/158", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <set>\n#include <algorithm>\nusing namespace std;\n\nstring find_max(vector<string> words) {\n    string maxWord = \"\";\n    int maxUniqueCount = 0;\n\n    for (const string& word : words) {\n        set<char> uniqueChars(word.begin(), word.end()); // Create a set of unique characters\n        int uniqueCount = uniqueChars.size(); // Count of unique characters\n\n        // Check if we found a new maximum or if we need to update for lexicographical order\n        if (uniqueCount > maxUniqueCount || (uniqueCount == maxUniqueCount && word < maxWord)) {\n            maxUniqueCount = uniqueCount;\n            maxWord = word;\n        }\n    }\n\n    return maxWord;\n}\n"}
{"task_id": "CPP/159", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> eat(int number, int need, int remaining) {\n    // Calculate total eaten carrots\n    int totalEaten = number + need;\n    \n    // Determine how many carrots can be eaten now\n    int eatenNow;\n    if (remaining >= need) {\n        eatenNow = need; // Eat the needed amount\n    } else {\n        eatenNow = remaining; // Eat all remaining carrots\n    }\n    \n    // Calculate remaining carrots after eating\n    int remainingAfterEat = remaining - eatenNow;\n    \n    // Return the result as a vector\n    return {totalEaten, remainingAfterEat};\n}\n"}
{"task_id": "CPP/160", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <iostream>\n\nusing namespace std;\n\nint do_algebra(vector<string> operato, vector<int> operand) {\n    // Step 1: Handle multiplication and division first\n    vector<int> intermediate;\n    intermediate.push_back(operand[0]); // Start with the first operand\n\n    for (size_t i = 0; i < operato.size(); i++) {\n        if (operato[i] == \"*\" || operato[i] == \"//\") {\n            int last = intermediate.back();\n            int current = operand[i + 1];\n            if (operato[i] == \"*\") {\n                intermediate.back() = last * current; // Perform multiplication\n            } else if (operato[i] == \"//\") {\n                intermediate.back() = last / current; // Perform floor division\n            }\n        } else {\n            intermediate.push_back(operand[i + 1]); // Push the next operand\n            intermediate.push_back(operato[i]); // Push the operator\n        }\n    }\n\n    // Step 2: Handle addition and subtraction\n    int result = intermediate[0]; // Start with the first number\n    for (size_t i = 1; i < intermediate.size(); i += 2) {\n        string op = intermediate[i]; // Get the operator\n        int num = intermediate[i + 1]; // Get the next number\n        if (op == \"+\") {\n            result += num; // Perform addition\n        } else if (op == \"-\") {\n            result -= num; // Perform subtraction\n        }\n    }\n\n    return result; // Return the final result\n}\n\n// Example usage\n"}
{"task_id": "CPP/161", "generation": "#include <stdio.h>\n#include <string>\n#include <algorithm> // for std::reverse\n#include <cctype>    // for std::isalpha, std::toupper, std::tolower\nusing namespace std;\n\nstring solve(string s) {\n    bool hasLetter = false;\n    \n    // First pass to check for letters and change case\n    for (char &c : s) {\n        if (isalpha(c)) {\n            hasLetter = true;\n            // Change case\n            if (islower(c)) {\n                c = toupper(c);\n            } else {\n                c = tolower(c);\n            }\n        }\n    }\n    \n    // If no letters were found, reverse the string\n    if (!hasLetter) {\n        reverse(s.begin(), s.end());\n    }\n    \n    return s;\n}\n"}
{"task_id": "CPP/162", "generation": "#include <stdio.h>\n#include <string>\n#include <openssl/md5.h>\n#include <sstream>\n#include <iomanip>\n\nusing namespace std;\n\nstring string_to_md5(string text) {\n    if (text.empty()) {\n        return \"None\"; // Return \"None\" as a string representation\n    }\n\n    unsigned char digest[MD5_DIGEST_LENGTH];\n    MD5((unsigned char*)text.c_str(), text.size(), digest);\n\n    stringstream ss;\n    for (int i = 0; i < MD5_DIGEST_LENGTH; i++) {\n        ss << hex << setw(2) << setfill('0') << (int)digest[i];\n    }\n\n    return ss.str();\n}\n"}
{"task_id": "CPP/163", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm> // for std::min and std::max\nusing namespace std;\n\nvector<int> generate_integers(int a, int b) {\n    vector<int> result;\n    int min_val = min(a, b);\n    int max_val = max(a, b);\n    \n    // Check for even digits in the range\n    for (int i = min_val; i <= max_val; i++) {\n        if (i % 2 == 0 && (i == 2 || i == 4 || i == 6 || i == 8)) {\n            result.push_back(i);\n        }\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/0", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\nbool has_close_elements(vector<float> numbers, float threshold) {\n    // Sort the vector\n    sort(numbers.begin(), numbers.end());\n    \n    // Check adjacent elements\n    for (size_t i = 0; i < numbers.size() - 1; i++) {\n        if (fabs(numbers[i + 1] - numbers[i]) < threshold) {\n            return true; // Found two numbers closer than threshold\n        }\n    }\n    \n    return false; // No such pair found\n}\n"}
{"task_id": "CPP/1", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> separate_paren_groups(string paren_string) {\n    vector<string> result; // To store the groups of parentheses\n    string current_group; // To build the current group\n    int balance = 0; // To track the balance of parentheses\n\n    for (char ch : paren_string) {\n        if (ch == ' ') {\n            continue; // Ignore spaces\n        }\n        current_group += ch; // Add the character to the current group\n        if (ch == '(') {\n            balance++; // Increment balance for '('\n        } else if (ch == ')') {\n            balance--; // Decrement balance for ')'\n        }\n        // If balance is zero, we have a complete group\n        if (balance == 0) {\n            result.push_back(current_group); // Add the group to the result\n            current_group.clear(); // Clear current group for the next one\n        }\n    }\n    return result; // Return the vector of groups\n}\n"}
{"task_id": "CPP/2", "generation": "#include <stdio.h>\n#include <math.h>\nusing namespace std;\n\nfloat truncate_number(float number) {\n    // Get the integer part of the number\n    int integer_part = floor(number);\n    // Calculate the decimal part\n    float decimal_part = number - integer_part;\n    // Return the decimal part\n    return decimal_part;\n}\n"}
{"task_id": "CPP/3", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nbool below_zero(vector<int> operations) {\n    int balance = 0; // Start with zero balance\n    for (int operation : operations) {\n        balance += operation; // Update the balance\n        if (balance < 0) { // Check if balance goes below zero\n            return true; // Return true if it does\n        }\n    }\n    return false; // Return false if balance never goes below zero\n}\n"}
{"task_id": "CPP/4", "generation": "#include <stdio.h>\n#include <math.h>\n#include <vector>\nusing namespace std;\n\nfloat mean_absolute_deviation(vector<float> numbers) {\n    // Step 1: Calculate the mean\n    float sum = 0;\n    for (float number : numbers) {\n        sum += number;\n    }\n    float mean = sum / numbers.size();\n\n    // Step 2: Calculate the Mean Absolute Deviation\n    float mad_sum = 0;\n    for (float number : numbers) {\n        mad_sum += fabs(number - mean); // Absolute deviation\n    }\n    \n    // Step 3: Calculate the average of absolute deviations\n    float mad = mad_sum / numbers.size();\n    \n    return mad;\n}\n"}
{"task_id": "CPP/5", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nvector<int> intersperse(vector<int> numbers, int delimeter) { \n    vector<int> result; // Create an empty vector to store the result\n    if (numbers.empty()) { // Check if the input vector is empty\n        return result; // Return the empty result\n    }\n    \n    for (size_t i = 0; i < numbers.size(); i++) { // Iterate through the input vector\n        result.push_back(numbers[i]); // Add the current element to the result\n        if (i < numbers.size() - 1) { // If not the last element\n            result.push_back(delimeter); // Add the delimiter\n        }\n    }\n    \n    return result; // Return the final result vector\n}\n"}
{"task_id": "CPP/6", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nvector<int> parse_nested_parens(string paren_string) {\n    vector<int> depths;\n    stringstream ss(paren_string);\n    string group;\n\n    while (ss >> group) { // Split by spaces\n        int current_depth = 0;\n        int max_depth = 0;\n\n        for (char ch : group) {\n            if (ch == '(') {\n                current_depth++;\n                if (current_depth > max_depth) {\n                    max_depth = current_depth;\n                }\n            } else if (ch == ')') {\n                current_depth--;\n            }\n        }\n        depths.push_back(max_depth); // Store the max depth for the current group\n    }\n\n    return depths;\n}\n"}
{"task_id": "CPP/7", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> filter_by_substring(vector<string> strings, string substring) {\n    vector<string> result; // Initialize an empty vector to store results\n    for (const string& str : strings) { // Iterate through each string\n        if (str.find(substring) != string::npos) { // Check if substring is found\n            result.push_back(str); // Add to result if found\n        }\n    }\n    return result; // Return the filtered results\n}\n"}
{"task_id": "CPP/8", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> sum_product(vector<int> numbers) {\n    int sum = 0;\n    int product = 1;\n\n    // Check if the vector is empty\n    if (numbers.empty()) {\n        return {0, 1};\n    }\n\n    // Calculate sum and product\n    for (int number : numbers) {\n        sum += number;\n        product *= number;\n    }\n\n    return {sum, product};\n}\n"}
{"task_id": "CPP/9", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> rolling_max(vector<int> numbers) {\n    vector<int> result;\n    int current_max = numbers.empty() ? INT_MIN : numbers[0]; // Handle empty input case\n\n    for (int num : numbers) {\n        current_max = max(current_max, num); // Update current_max\n        result.push_back(current_max); // Append the current maximum to the result\n    }\n    \n    return result; // Return the result vector\n}\n"}
{"task_id": "CPP/10", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nbool is_palindrome(string str) {\n    string s(str.rbegin(), str.rend());\n    return s == str;\n}\n\nstring make_palindrome(string str) {\n    if (str.empty()) {\n        return \"\";\n    }\n    \n    int n = str.length();\n    int i;\n    \n    // Find the longest palindromic suffix\n    for (i = n; i >= 0; --i) {\n        if (is_palindrome(str.substr(i))) {\n            break;\n        }\n    }\n    \n    // Create the shortest palindrome\n    string prefix = str.substr(0, i);\n    string reversed_prefix(prefix.rbegin(), prefix.rend());\n    \n    return str + reversed_prefix;\n}\n"}
{"task_id": "CPP/11", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nstring string_xor(string a, string b) {\n    string result = \"\";\n    for (int i = 0; i < a.length(); i++) {\n        if (a[i] == b[i]) {\n            result += \"0\";\n        } else {\n            result += \"1\";\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/12", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring longest(vector<string> strings) {\n    if (strings.empty()) {\n        return \"None\"; // Return \"None\" as a string representation\n    }\n    \n    string longest_string = strings[0];\n    \n    for (const string& str : strings) {\n        if (str.length() > longest_string.length()) {\n            longest_string = str;\n        }\n    }\n    \n    return longest_string;\n}\n"}
{"task_id": "CPP/13", "generation": "#include<stdio.h>\nusing namespace std;\n\nint greatest_common_divisor(int a, int b) {\n    while (b != 0) {\n        int temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n"}
{"task_id": "CPP/14", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> all_prefixes(string str) {\n    vector<string> prefixes; // Vector to store prefixes\n    for (int i = 0; i < str.length(); i++) {\n        prefixes.push_back(str.substr(0, i + 1)); // Add prefix from 0 to i\n    }\n    return prefixes; // Return the vector of prefixes\n}\n"}
{"task_id": "CPP/15", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nstring string_sequence(int n) {\n    string result = \"\";\n    for (int i = 0; i <= n; i++) {\n        result += to_string(i); // Convert integer to string and append\n        if (i != n) {\n            result += \" \"; // Append space if it's not the last number\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/16", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <set>\n#include <algorithm>\nusing namespace std;\n\nint count_distinct_characters(string str) {\n    set<char> distinctChars; // Set to store distinct characters\n    for (char c : str) {\n        distinctChars.insert(tolower(c)); // Convert to lowercase and insert into the set\n    }\n    return distinctChars.size(); // Return the number of distinct characters\n}\n"}
{"task_id": "CPP/17", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <sstream>\nusing namespace std;\n\nvector<int> parse_music(string music_string) {\n    vector<int> beats;\n    stringstream ss(music_string);\n    string note;\n\n    while (ss >> note) {\n        if (note == \"o\") {\n            beats.push_back(4); // whole note\n        } else if (note == \"o|\") {\n            beats.push_back(2); // half note\n        } else if (note == \".|\") {\n            beats.push_back(1); // quarter note\n        }\n    }\n    \n    return beats;\n}\n"}
{"task_id": "CPP/18", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nint how_many_times(string str, string substring) {\n    int count = 0;\n    int strLength = str.length();\n    int subLength = substring.length();\n    \n    // Edge case: if substring is empty, return 0\n    if (subLength == 0) return 0;\n\n    // Loop through the main string\n    for (int i = 0; i <= strLength - subLength; i++) {\n        // Check if the substring matches\n        if (str.substr(i, subLength) == substring) {\n            count++; // Increment count for a match\n        }\n    }\n    \n    return count;\n}\n"}
{"task_id": "CPP/19", "generation": "#include <iostream>\n#include <string>\n#include <vector>\n#include <map>\n#include <sstream>\n#include <algorithm>\n\nusing namespace std;\n\nstring sort_numbers(string numbers) {\n    // Step 1: Create a map for word to number conversion\n    map<string, int> wordToNumber = {\n        {\"zero\", 0}, {\"one\", 1}, {\"two\", 2}, {\"three\", 3},\n        {\"four\", 4}, {\"five\", 5}, {\"six\", 6}, {\"seven\", 7},\n        {\"eight\", 8}, {\"nine\", 9}\n    };\n\n    // Step 2: Split the input string into words\n    istringstream iss(numbers);\n    vector<string> words;\n    string word;\n    while (iss >> word) {\n        words.push_back(word);\n    }\n\n    // Step 3: Sort the words based on their numerical values\n    sort(words.begin(), words.end(), [&](const string &a, const string &b) {\n        return wordToNumber[a] < wordToNumber[b];\n    });\n\n    // Step 4: Join the sorted words into a single output string\n    string result;\n    for (const string &w : words) {\n        if (!result.empty()) {\n            result += \" \";\n        }\n        result += w;\n    }\n\n    // Step 5: Return the output string\n    return result;\n}\n"}
{"task_id": "CPP/20", "generation": "#include <vector>\n#include <algorithm>\n#include <iostream>\n\nusing namespace std;\n\nvector<float> find_closest_elements(vector<float> numbers) {\n    // Sort the numbers\n    sort(numbers.begin(), numbers.end());\n    \n    // Initialize variables to track the minimum difference and the closest pair\n    float minDiff = numeric_limits<float>::max();\n    vector<float> closestPair;\n\n    // Iterate through the sorted numbers to find the closest pair\n    for (size_t i = 0; i < numbers.size() - 1; ++i) {\n        float diff = numbers[i + 1] - numbers[i];\n        if (diff < minDiff) {\n            minDiff = diff;\n            closestPair = {numbers[i], numbers[i + 1]};\n        }\n    }\n\n    return closestPair;\n}\n\n// Example usage\n"}
{"task_id": "CPP/21", "generation": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<float> rescale_to_unit(vector<float> numbers) {\n    // Step 1: Find the minimum and maximum values\n    float min_value = *min_element(numbers.begin(), numbers.end());\n    float max_value = *max_element(numbers.begin(), numbers.end());\n    \n    // Step 2: Create a vector to hold the scaled values\n    vector<float> scaled_numbers;\n    \n    // Step 3: Apply the linear transformation\n    for (float number : numbers) {\n        float scaled_value = (number - min_value) / (max_value - min_value);\n        scaled_numbers.push_back(scaled_value);\n    }\n    \n    // Step 4: Return the result\n    return scaled_numbers;\n}\n"}
{"task_id": "CPP/22", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <boost/any.hpp>\n#include <list>\n\ntypedef std::list<boost::any> list_any;\n\nstd::vector<int> filter_integers(list_any values) {\n    std::vector<int> result;\n    \n    for (const auto& value : values) {\n        try {\n            // Attempt to cast the value to an int\n            int intValue = boost::any_cast<int>(value);\n            result.push_back(intValue); // If successful, add to result\n        } catch (const boost::bad_any_cast&) {\n            // If the cast fails, we simply ignore this value\n        }\n    }\n    \n    return result;\n}\n\n// Example usage\n"}
{"task_id": "CPP/23", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nint strlen(string str) {\n    return str.size();  // or str.length();\n}\n"}
{"task_id": "CPP/24", "generation": "#include <stdio.h>\nusing namespace std;\n\nint largest_divisor(int n) {\n    for (int i = n - 1; i > 0; i--) {\n        if (n % i == 0) {\n            return i;\n        }\n    }\n    return -1; // This case should not happen for n > 1\n}\n"}
{"task_id": "CPP/25", "generation": "#include <stdio.h>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\nvector<int> factorize(int n) {\n    vector<int> result;\n    // Check for factors from 2 to sqrt(n)\n    for (int i = 2; i <= sqrt(n); i++) {\n        // While i divides n, add i to result and divide n\n        while (n % i == 0) {\n            result.push_back(i);\n            n /= i;\n        }\n    }\n    // If n is still greater than 1, it is a prime factor\n    if (n > 1) {\n        result.push_back(n);\n    }\n    return result;\n}\n"}
{"task_id": "CPP/26", "generation": "#include <stdio.h>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nvector<int> remove_duplicates(vector<int> numbers) {\n    unordered_map<int, int> countMap;\n    \n    // Count occurrences of each number\n    for (int num : numbers) {\n        countMap[num]++;\n    }\n    \n    vector<int> result;\n    \n    // Collect numbers that occur exactly once\n    for (int num : numbers) {\n        if (countMap[num] == 1) {\n            result.push_back(num);\n        }\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/27", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nstring flip_case(string str) {\n    string result = \"\"; // Initialize an empty string for the result\n    for (char c : str) { // Loop through each character in the input string\n        if (islower(c)) { // Check if the character is lowercase\n            result += toupper(c); // Convert to uppercase and append to result\n        } else if (isupper(c)) { // Check if the character is uppercase\n            result += tolower(c); // Convert to lowercase and append to result\n        } else {\n            result += c; // Append unchanged character (if it's neither)\n        }\n    }\n    return result; // Return the final result string\n}\n"}
{"task_id": "CPP/28", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring concatenate(vector<string> strings) {\n    string result = \"\"; // Initialize an empty string\n    for (const string& str : strings) { // Iterate through each string in the vector\n        result += str; // Append the current string to the result\n    }\n    return result; // Return the concatenated string\n}\n"}
{"task_id": "CPP/29", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> filter_by_prefix(vector<string> strings, string prefix) {\n    vector<string> result; // Create an empty result vector\n    for (const string& str : strings) { // Iterate through each string\n        if (str.find(prefix) == 0) { // Check if the string starts with the prefix\n            result.push_back(str); // Add to result if it matches\n        }\n    }\n    return result; // Return the filtered result\n}\n"}
{"task_id": "CPP/30", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nvector<float> get_positive(vector<float> l) {\n    vector<float> positive_numbers; // Initialize an empty vector to store positive numbers\n    for (float number : l) { // Iterate through each number in the input vector\n        if (number > 0) { // Check if the number is positive\n            positive_numbers.push_back(number); // Add it to the positive_numbers vector\n        }\n    }\n    return positive_numbers; // Return the vector containing only positive numbers\n}\n"}
{"task_id": "CPP/31", "generation": "#include <stdio.h>\n#include <cmath>\n\nusing namespace std;\n\nbool is_prime(long long n) {\n    if (n < 2) return false; // Numbers less than 2 are not prime\n    if (n == 2) return true;  // 2 is the only even prime number\n    if (n % 2 == 0) return false; // Other even numbers are not prime\n\n    // Check for factors from 3 to sqrt(n), only odd numbers\n    for (long long i = 3; i * i <= n; i += 2) {\n        if (n % i == 0) {\n            return false; // Found a divisor, not prime\n        }\n    }\n    return true; // No divisors found, n is prime\n}\n"}
{"task_id": "CPP/32", "generation": "#include <stdio.h>\n#include <math.h>\n#include <vector>\nusing namespace std;\n\ndouble poly(vector<double> xs, double x) {\n    double sum = 0;\n    for (int i = 0; i < xs.size(); i++) {\n        sum += xs[i] * pow(x, i);\n    }\n    return sum;\n}\n\ndouble find_zero(vector<double> xs) {\n    double a = -1000; // Start with a large negative number\n    double b = 1000;  // Start with a large positive number\n\n    // Find a valid interval [a, b]\n    while (poly(xs, a) * poly(xs, b) > 0) {\n        a += 1; // Increment a\n        b -= 1; // Decrement b\n    }\n\n    // Bisection method\n    while (b - a > 1e-7) { // Continue until the interval is sufficiently small\n        double mid = (a + b) / 2;\n        if (poly(xs, mid) == 0) {\n            return mid; // Found exact root\n        } else if (poly(xs, mid) * poly(xs, a) < 0) {\n            b = mid; // Root is in the left half\n        } else {\n            a = mid; // Root is in the right half\n        }\n    }\n    return (a + b) / 2; // Return the midpoint as the root\n}\n"}
{"task_id": "CPP/33", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> sort_third(vector<int> l) {\n    vector<int> sorted_values;\n    \n    // Collect values at indices divisible by 3\n    for (int i = 0; i < l.size(); i++) {\n        if (i % 3 == 0) {\n            sorted_values.push_back(l[i]);\n        }\n    }\n    \n    // Sort the collected values\n    sort(sorted_values.begin(), sorted_values.end());\n    \n    // Create the result vector\n    vector<int> result(l.size());\n    int index = 0;\n    \n    // Fill the result vector\n    for (int i = 0; i < l.size(); i++) {\n        if (i % 3 == 0) {\n            result[i] = sorted_values[index];\n            index++;\n        } else {\n            result[i] = l[i];\n        }\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/34", "generation": "#include <stdio.h>\n#include <vector>\n#include <set>\n#include <algorithm>\nusing namespace std;\n\nvector<int> unique(vector<int> l) {\n    set<int> uniqueSet; // Step 1: Create a set to store unique elements\n    for (int num : l) { // Step 2: Insert each number into the set\n        uniqueSet.insert(num);\n    }\n    \n    vector<int> result(uniqueSet.begin(), uniqueSet.end()); // Step 3: Convert set to vector\n    return result; // Step 4: Return the sorted unique elements\n}\n"}
{"task_id": "CPP/35", "generation": "#include <stdio.h>\n#include <vector>\n#include <limits>\n\nusing namespace std;\n\nfloat max_element(vector<float> l) {\n    // Initialize maxValue to the smallest possible float\n    float maxValue = -std::numeric_limits<float>::infinity();\n    \n    // Iterate through the vector to find the maximum element\n    for (float num : l) {\n        if (num > maxValue) {\n            maxValue = num; // Update maxValue if current number is greater\n        }\n    }\n    \n    return maxValue; // Return the maximum value found\n}\n"}
{"task_id": "CPP/36", "generation": "#include <stdio.h>\n#include <string>\n\nusing namespace std;\n\nint fizz_buzz(int n) {\n    int count = 0;\n    for (int i = 1; i < n; i++) {\n        if (i % 11 == 0 || i % 13 == 0) {\n            // Convert integer to string to count '7's\n            string str = to_string(i);\n            // Count occurrences of '7'\n            count += count_if(str.begin(), str.end(), [](char c) { return c == '7'; });\n        }\n    }\n    return count;\n}\n"}
{"task_id": "CPP/37", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<float> sort_even(vector<float> l) {\n    vector<float> even_values;\n\n    // Extract even indexed values\n    for (int i = 0; i < l.size(); i++) {\n        if (i % 2 == 0) {\n            even_values.push_back(l[i]);\n        }\n    }\n\n    // Sort the even indexed values\n    sort(even_values.begin(), even_values.end());\n\n    // Create the output vector\n    vector<float> result = l;\n    int index = 0;\n\n    // Replace even indexed positions with sorted values\n    for (int i = 0; i < l.size(); i++) {\n        if (i % 2 == 0) {\n            result[i] = even_values[index];\n            index++;\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/38", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nstring encode_cyclic(string s){ \n    int l = s.length();\n    int num = (l + 2) / 3;\n    string x, output;\n    for (int i = 0; i * 3 < l; i++) {\n        x = s.substr(i * 3, 3);\n        if (x.length() == 3) x = x.substr(1) + x[0];\n        output = output + x;\n    }\n    return output;\n}\n\nstring decode_cyclic(string s){ \n    string output = \"\";\n    for (int i = 0; i * 3 < s.length(); i++) {\n        string group = s.substr(i * 3, 3);\n        if (group.length() == 3) {\n            // Reverse the cycling\n            string decoded_group = group[2] + group[0] + group[1];\n            output += decoded_group;\n        } else {\n            output += group; // Append unchanged if less than 3 characters\n        }\n    }\n    return output;\n}\n"}
{"task_id": "CPP/39", "generation": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int num) {\n    if (num < 2) return false;\n    for (int i = 2; i <= sqrt(num); i++) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\n// Function to return the n-th prime Fibonacci number\nint prime_fib(int n) {\n    vector<int> prime_fibs; // To store prime Fibonacci numbers\n    int a = 0, b = 1; // First two Fibonacci numbers\n\n    while (prime_fibs.size() < n) {\n        int next_fib = a + b; // Calculate the next Fibonacci number\n        a = b; // Move to the next Fibonacci number\n        b = next_fib;\n\n        // Check if the Fibonacci number is prime\n        if (is_prime(next_fib)) {\n            prime_fibs.push_back(next_fib); // Store it if it's prime\n        }\n    }\n\n    return prime_fibs[n - 1]; // Return the n-th prime Fibonacci number\n}\n\n// Example usage\n"}
{"task_id": "CPP/40", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nbool triples_sum_to_zero(vector<int> l) {\n    sort(l.begin(), l.end()); // Step 1: Sort the vector\n    int n = l.size();\n    \n    for (int i = 0; i < n - 2; i++) { // Step 2: Iterate through the vector\n        int left = i + 1; // Left pointer\n        int right = n - 1; // Right pointer\n        \n        while (left < right) { // Step 3: Two-pointer approach\n            int sum = l[i] + l[left] + l[right];\n            if (sum == 0) {\n                return true; // Found a triplet\n            } else if (sum < 0) {\n                left++; // Increase sum\n            } else {\n                right--; // Decrease sum\n            }\n        }\n    }\n    return false; // No triplet found\n}\n"}
{"task_id": "CPP/41", "generation": "#include<stdio.h>\nusing namespace std;\n\nint car_race_collision(int n) {\n    return n * n; // Each car from the left set collides with each car from the right set\n}\n"}
{"task_id": "CPP/42", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> incr_list(vector<int> l) {\n    vector<int> result; // Initialize an empty vector to store results\n    for (int i = 0; i < l.size(); i++) { // Iterate through each element in the input vector\n        result.push_back(l[i] + 1); // Increment the element by 1 and add to result\n    }\n    return result; // Return the result vector\n}\n"}
{"task_id": "CPP/43", "generation": "#include <stdio.h>\n#include <vector>\n#include <unordered_set>\nusing namespace std;\n\nbool pairs_sum_to_zero(vector<int> l) {\n    unordered_set<int> seen; // Create a set to store seen numbers\n    for (int num : l) {\n        // Check if the negative of the current number is in the set\n        if (seen.count(-num)) {\n            return true; // Found a pair that sums to zero\n        }\n        seen.insert(num); // Add the current number to the set\n    }\n    return false; // No pairs found that sum to zero\n}\n"}
{"task_id": "CPP/44", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nstring change_base(int x, int base) {\n    if (x == 0) return \"0\"; // Handle the case where x is 0\n    \n    string result = \"\";\n    while (x > 0) {\n        int remainder = x % base; // Get the remainder\n        result = char(remainder + '0') + result; // Convert to character and prepend\n        x /= base; // Update x by dividing by base\n    }\n    return result; // Return the final result\n}\n"}
{"task_id": "CPP/45", "generation": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n\nfloat triangle_area(float a, float h) {\n    float area = (0.5) * a * h; // Calculate area using the formula\n    return area; // Return the calculated area\n}\n"}
{"task_id": "CPP/46", "generation": "#include <stdio.h>\nusing namespace std;\n\nint fib4(int n) {\n    // Handle base cases\n    if (n == 0) return 0;\n    if (n == 1) return 0;\n    if (n == 2) return 2;\n    if (n == 3) return 0;\n\n    // Create an array to store the fib4 values\n    int fib[n + 1];\n    fib[0] = 0;\n    fib[1] = 0;\n    fib[2] = 2;\n    fib[3] = 0;\n\n    // Compute fib4 values iteratively\n    for (int i = 4; i <= n; i++) {\n        fib[i] = fib[i - 1] + fib[i - 2] + fib[i - 3] + fib[i - 4];\n    }\n\n    return fib[n];\n}\n"}
{"task_id": "CPP/47", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nfloat median(vector<float> l) {\n    // Step 1: Sort the vector\n    sort(l.begin(), l.end());\n    \n    // Step 2: Determine the size of the vector\n    int size = l.size();\n    \n    // Step 3: Calculate the median\n    if (size % 2 == 1) {\n        // Odd size: return the middle element\n        return l[size / 2];\n    } else {\n        // Even size: return the average of the two middle elements\n        return (l[size / 2 - 1] + l[size / 2]) / 2.0;\n    }\n}\n"}
{"task_id": "CPP/48", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nbool is_palindrome(string text) {\n    // Base case: an empty string is a palindrome\n    if (text.empty()) {\n        return true;\n    }\n    \n    int left = 0;\n    int right = text.length() - 1;\n    \n    // Use two pointers to check for palindrome\n    while (left < right) {\n        if (text[left] != text[right]) {\n            return false; // Not a palindrome\n        }\n        left++;\n        right--;\n    }\n    \n    return true; // It's a palindrome\n}\n"}
{"task_id": "CPP/49", "generation": "#include<stdio.h>\nusing namespace std;\n\nint modp(int n, int p) {\n    if (p == 1) return 1; // Special case: any number mod 1 is 0, but we return 1 as per problem statement.\n    \n    long long result = 1; // Use long long to prevent overflow\n    long long base = 2 % p; // Base is 2 mod p\n    \n    while (n > 0) {\n        if (n % 2 == 1) { // If n is odd\n            result = (result * base) % p; // Multiply result by base and take mod p\n        }\n        base = (base * base) % p; // Square the base and take mod p\n        n /= 2; // Divide n by 2\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/50", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring encode_shift(string s){\n    // returns encoded string by shifting every character by 5 in the alphabet.\n    string out;\n    int i;\n    for (i=0; i<s.length(); i++) {\n        int w = ((int)s[i] + 5 - (int)'a') % 26 + (int)'a';   \n        out = out + (char)w;\n    }\n    return out;\n}\n\nstring decode_shift(string s){\n    // takes as input string encoded with encode_shift function. Returns decoded string.\n    string out;\n    for (int i = 0; i < s.length(); i++) {\n        int w = ((int)s[i] - 5 - (int)'a' + 26) % 26 + (int)'a'; // Adding 26 to ensure positive wrap-around\n        out = out + (char)w;\n    }\n    return out;\n}\n"}
{"task_id": "CPP/51", "generation": "#include <stdio.h>\n#include <string>\n#include <algorithm>\n#include <unordered_set>\nusing namespace std;\n\nstring remove_vowels(string text) {\n    string result = \"\";\n    unordered_set<char> vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'};\n    \n    for (char c : text) {\n        if (vowels.find(c) == vowels.end()) { // If c is not a vowel\n            result += c; // Append to result\n        }\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/52", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nbool below_threshold(vector<int> l, int t) {\n    for (int num : l) {\n        if (num >= t) {\n            return false; // Found a number that is not below the threshold\n        }\n    }\n    return true; // All numbers are below the threshold\n}\n"}
{"task_id": "CPP/53", "generation": "#include<stdio.h>\n#include<stdlib.h>\nusing namespace std;\n\nint add(int x, int y) {\n    return x + y;\n}\n"}
{"task_id": "CPP/54", "generation": "#include <stdio.h>\n#include <string>\n#include <set>\n#include <algorithm>\nusing namespace std;\n\nbool same_chars(string s0, string s1) {\n    // Use a set to extract unique characters\n    set<char> unique_chars_s0(s0.begin(), s0.end());\n    set<char> unique_chars_s1(s1.begin(), s1.end());\n    \n    // Convert sets to vectors for sorting and comparison\n    vector<char> sorted_s0(unique_chars_s0.begin(), unique_chars_s0.end());\n    vector<char> sorted_s1(unique_chars_s1.begin(), unique_chars_s1.end());\n    \n    // Sort the vectors (though sets are already sorted)\n    sort(sorted_s0.begin(), sorted_s0.end());\n    sort(sorted_s1.begin(), sorted_s1.end());\n    \n    // Compare the sorted unique characters\n    return sorted_s0 == sorted_s1;\n}\n"}
{"task_id": "CPP/55", "generation": "#include<stdio.h>\nusing namespace std;\n\nint fib(int n) {\n    if (n == 0) return 0;\n    if (n == 1) return 1;\n\n    int a = 0, b = 1; // F(0) and F(1)\n    for (int i = 2; i <= n; i++) {\n        int next = a + b; // Calculate next Fibonacci number\n        a = b; // Move to the next pair\n        b = next; // Update b to the new Fibonacci number\n    }\n    return b; // Return the n-th Fibonacci number\n}\n"}
{"task_id": "CPP/56", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    int counter = 0; // Initialize counter\n    for (char ch : brackets) { // Loop through each character\n        if (ch == '<') {\n            counter++; // Increment for opening bracket\n        } else if (ch == '>') {\n            counter--; // Decrement for closing bracket\n        }\n        if (counter < 0) {\n            return false; // More closing than opening brackets\n        }\n    }\n    return counter == 0; // Check if all brackets are matched\n}\n"}
{"task_id": "CPP/57", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nbool monotonic(vector<float> l) {\n    bool isIncreasing = true;\n    bool isDecreasing = true;\n\n    for (int i = 0; i < l.size() - 1; i++) {\n        if (l[i] > l[i + 1]) {\n            isIncreasing = false;\n        }\n        if (l[i] < l[i + 1]) {\n            isDecreasing = false;\n        }\n    }\n    \n    return isIncreasing || isDecreasing;\n}\n"}
{"task_id": "CPP/58", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\n#include <set>\nusing namespace std;\n\nvector<int> common(vector<int> l1, vector<int> l2) {\n    // Sort both vectors\n    sort(l1.begin(), l1.end());\n    sort(l2.begin(), l2.end());\n    \n    // Use a set to store unique common elements\n    set<int> result;\n    \n    // Initialize pointers for both vectors\n    int i = 0, j = 0;\n    \n    // Find common elements\n    while (i < l1.size() && j < l2.size()) {\n        if (l1[i] == l2[j]) {\n            result.insert(l1[i]); // Insert into set for uniqueness\n            i++;\n            j++;\n        } else if (l1[i] < l2[j]) {\n            i++;\n        } else {\n            j++;\n        }\n    }\n    \n    // Convert set to vector\n    vector<int> commonElements(result.begin(), result.end());\n    return commonElements;\n}\n"}
{"task_id": "CPP/59", "generation": "#include <stdio.h>\nusing namespace std;\n\nint largest_prime_factor(int n) {\n    int largest_factor = 1;\n    int factor = 2;\n\n    while (n > 1) {\n        while (n % factor == 0) {\n            n = n / factor;\n            largest_factor = factor;\n        }\n        factor++;\n    }\n\n    return largest_factor;\n}\n"}
{"task_id": "CPP/60", "generation": "#include<stdio.h>\nusing namespace std;\n\nint sum_to_n(int n) {\n    return n * (n + 1) / 2;\n}\n"}
{"task_id": "CPP/61", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    int balance = 0; // Initialize balance counter\n    for (char ch : brackets) {\n        if (ch == '(') {\n            balance++; // Increment for opening bracket\n        } else if (ch == ')') {\n            balance--; // Decrement for closing bracket\n        }\n        if (balance < 0) {\n            return false; // More closing brackets than opening\n        }\n    }\n    return balance == 0; // Check if all opening brackets are matched\n}\n"}
{"task_id": "CPP/62", "generation": "#include <vector>\nusing namespace std;\n\nvector<float> derivative(vector<float> xs) {\n    vector<float> result;\n    for (int i = 1; i < xs.size(); i++) {\n        result.push_back(i * xs[i]);\n    }\n    return result;\n}\n"}
{"task_id": "CPP/63", "generation": "#include <stdio.h>\nusing namespace std;\n\nint fibfib(int n) {\n    if (n == 0) return 0;\n    if (n == 1) return 0;\n    if (n == 2) return 1;\n\n    int a = 0; // fibfib(0)\n    int b = 0; // fibfib(1)\n    int c = 1; // fibfib(2)\n    int result = 0;\n\n    for (int i = 3; i <= n; i++) {\n        result = a + b + c; // fibfib(n) = fibfib(n-1) + fibfib(n-2) + fibfib(n-3)\n        a = b; // move to the next\n        b = c; // move to the next\n        c = result; // update to the latest result\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/64", "generation": "#include <stdio.h>\n#include <string>\n#include <set>\nusing namespace std;\n\nint vowels_count(string s) {\n    int count = 0;\n    set<char> vowels = {'a', 'e', 'i', 'o', 'u'};\n    \n    for (int i = 0; i < s.length(); i++) {\n        char c = tolower(s[i]); // Convert to lowercase for case-insensitive comparison\n        if (vowels.find(c) != vowels.end()) {\n            count++;\n        }\n        if (c == 'y' && i == s.length() - 1) {\n            count++;\n        }\n    }\n    \n    return count;\n}\n"}
{"task_id": "CPP/65", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nstring circular_shift(int x, int shift) {\n    string str_x = to_string(x);\n    int len = str_x.length();\n    \n    if (shift > len) {\n        // Reverse the string if shift is greater than the number of digits\n        reverse(str_x.begin(), str_x.end());\n        return str_x;\n    } else {\n        // Calculate effective shift\n        int effective_shift = shift % len;\n        // Perform the circular shift\n        string shifted = str_x.substr(len - effective_shift) + str_x.substr(0, len - effective_shift);\n        return shifted;\n    }\n}\n"}
{"task_id": "CPP/66", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nint digitSum(string s) {\n    int sum = 0; // Initialize sum to 0\n    for (char c : s) { // Iterate through each character in the string\n        if (c >= 'A' && c <= 'Z') { // Check if the character is uppercase\n            sum += int(c); // Add ASCII value of the uppercase character to sum\n        }\n    }\n    return sum; // Return the final sum\n}\n"}
{"task_id": "CPP/67", "generation": "#include <stdio.h>\n#include <string>\n#include <sstream>\nusing namespace std;\n\nint fruit_distribution(string s, int n) {\n    int apples = 0, oranges = 0;\n\n    // Find the number of apples\n    size_t pos = s.find(\"apples\");\n    if (pos != string::npos) {\n        // Extract the number before \"apples\"\n        stringstream ss(s.substr(0, pos));\n        ss >> apples;\n    }\n\n    // Find the number of oranges\n    pos = s.find(\"oranges\");\n    if (pos != string::npos) {\n        // Extract the number before \"oranges\"\n        stringstream ss(s.substr(0, pos));\n        ss >> oranges;\n    }\n\n    // Calculate the number of mangoes\n    int mangoes = n - apples - oranges;\n    return mangoes;\n}\n"}
{"task_id": "CPP/68", "generation": "#include <stdio.h>\n#include <vector>\n#include <limits.h> // For INT_MAX\nusing namespace std;\n\nvector<int> pluck(vector<int> arr) {\n    int smallest_even = INT_MAX;\n    int smallest_index = -1;\n\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] % 2 == 0) { // Check if the number is even\n            if (arr[i] < smallest_even) { // Check if it's the smallest even number\n                smallest_even = arr[i];\n                smallest_index = i;\n            }\n        }\n    }\n\n    if (smallest_index == -1) {\n        return {}; // Return empty vector if no even number found\n    } else {\n        return {smallest_even, smallest_index}; // Return the smallest even number and its index\n    }\n}\n"}
{"task_id": "CPP/69", "generation": "#include <stdio.h>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint search(vector<int> lst) {\n    unordered_map<int, int> frequencyMap;\n\n    // Count the frequency of each integer\n    for (int num : lst) {\n        frequencyMap[num]++;\n    }\n\n    int greatest = -1;\n\n    // Check for the greatest integer that meets the criteria\n    for (const auto& entry : frequencyMap) {\n        int num = entry.first;\n        int freq = entry.second;\n\n        if (num > 0 && freq >= num) {\n            greatest = max(greatest, num);\n        }\n    }\n\n    return greatest;\n}\n"}
{"task_id": "CPP/70", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> strange_sort_list(vector<int> lst) {\n    // Handle the empty list case\n    if (lst.empty()) {\n        return {};\n    }\n    \n    // Sort the list in ascending order\n    sort(lst.begin(), lst.end());\n    \n    vector<int> result;\n    int left = 0; // Pointer for the minimum\n    int right = lst.size() - 1; // Pointer for the maximum\n    \n    // Alternate between minimum and maximum\n    while (left <= right) {\n        if (left <= right) {\n            result.push_back(lst[left]);\n            left++;\n        }\n        if (left <= right) {\n            result.push_back(lst[right]);\n            right--;\n        }\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/71", "generation": "#include <stdio.h>\n#include <math.h>\n#include <iomanip> // for std::setprecision\nusing namespace std;\n\nfloat triangle_area(float a, float b, float c) {\n    // Check if the sides form a valid triangle\n    if ((a + b <= c) || (a + c <= b) || (b + c <= a)) {\n        return -1;\n    }\n    \n    // Calculate the semi-perimeter\n    float s = (a + b + c) / 2;\n    \n    // Calculate the area using Heron's formula\n    float area = sqrt(s * (s - a) * (s - b) * (s - c));\n    \n    // Return the area rounded to 2 decimal points\n    return round(area * 100) / 100; // rounding to 2 decimal points\n}\n"}
{"task_id": "CPP/72", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nbool will_it_fly(vector<int> q, int w) {\n    int sum = 0;\n    int n = q.size();\n    \n    // Calculate the sum of the elements\n    for (int i = 0; i < n; i++) {\n        sum += q[i];\n    }\n    \n    // Check if the vector is palindromic\n    for (int i = 0; i < n / 2; i++) {\n        if (q[i] != q[n - 1 - i]) {\n            return false; // Not palindromic\n        }\n    }\n    \n    // Check the conditions for flying\n    return (sum <= w);\n}\n"}
{"task_id": "CPP/73", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nint smallest_change(vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n    \n    // Iterate through the first half of the array\n    for (int i = 0; i < n / 2; i++) {\n        // Check if the elements are not equal\n        if (arr[i] != arr[n - i - 1]) {\n            changes++; // Increment the change count\n        }\n    }\n    \n    return changes; // Return the total number of changes needed\n}\n"}
{"task_id": "CPP/74", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> total_match(vector<string> lst1, vector<string> lst2) {\n    int total1 = 0;\n    int total2 = 0;\n\n    // Calculate total characters in lst1\n    for (const string& str : lst1) {\n        total1 += str.length();\n    }\n\n    // Calculate total characters in lst2\n    for (const string& str : lst2) {\n        total2 += str.length();\n    }\n\n    // Compare totals and return the appropriate vector\n    if (total1 < total2) {\n        return lst1;\n    } else if (total2 < total1) {\n        return lst2;\n    } else {\n        return lst1; // If equal, return lst1\n    }\n}\n"}
{"task_id": "CPP/75", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// Function to generate all prime numbers less than 100\nvector<int> generatePrimes() {\n    vector<int> primes;\n    bool isPrime[100];\n    \n    // Initialize all numbers as prime\n    fill(begin(isPrime), end(isPrime), true);\n    isPrime[0] = isPrime[1] = false; // 0 and 1 are not prime numbers\n\n    for (int i = 2; i < 100; i++) {\n        if (isPrime[i]) {\n            primes.push_back(i);\n            for (int j = 2 * i; j < 100; j += i) {\n                isPrime[j] = false; // Mark multiples of i as non-prime\n            }\n        }\n    }\n    return primes;\n}\n\n// Function to check if a number is the multiplication of 3 prime numbers\nbool is_multiply_prime(int a) {\n    vector<int> primes = generatePrimes();\n    \n    // Check all combinations of three primes\n    for (int i = 0; i < primes.size(); i++) {\n        for (int j = 0; j < primes.size(); j++) {\n            for (int k = 0; k < primes.size(); k++) {\n                if (primes[i] * primes[j] * primes[k] == a) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n\n// Example usage\n"}
{"task_id": "CPP/76", "generation": "#include <stdio.h>\nusing namespace std;\n\nbool is_simple_power(int x, int n) {\n    // Edge case: if n is 1, it can only be true if x is also 1\n    if (n == 1) {\n        return x == 1;\n    }\n    // Edge case: if x is less than 1 or n is less than 1\n    if (x < 1 || n < 1) {\n        return false;\n    }\n    \n    int power = 1; // Start with n^0\n    while (power < x) {\n        power *= n; // Calculate n^k iteratively\n    }\n    return power == x; // Check if we found the exact power\n}\n"}
{"task_id": "CPP/77", "generation": "#include <cmath>\nusing namespace std;\n\nbool iscube(int a) {\n    if (a == 0) return true; // 0 is a cube (0^3 = 0)\n    \n    // Calculate the cube root and round it to the nearest integer\n    int n = round(cbrt(a));\n    \n    // Check if n^3 equals a\n    return (n * n * n == a);\n}\n"}
{"task_id": "CPP/78", "generation": "#include <stdio.h>\n#include <string>\n#include <unordered_set>\nusing namespace std;\n\nint hex_key(string num) {\n    // Set of prime hexadecimal digits\n    unordered_set<char> prime_hex_digits = {'2', '3', '5', '7', 'B', 'D'};\n    int count = 0;\n\n    // Iterate through each character in the string\n    for (char c : num) {\n        // Check if the character is a prime hexadecimal digit\n        if (prime_hex_digits.find(c) != prime_hex_digits.end()) {\n            count++;\n        }\n    }\n    \n    return count;\n}\n"}
{"task_id": "CPP/79", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nstring decimal_to_binary(int decimal) {\n    string binaryString = \"\";\n    \n    // Handle the case for 0\n    if (decimal == 0) {\n        binaryString = \"0\";\n    } else {\n        while (decimal > 0) {\n            // Prepend the remainder (0 or 1) to the binary string\n            binaryString = to_string(decimal % 2) + binaryString;\n            // Update decimal to be the quotient\n            decimal /= 2;\n        }\n    }\n    \n    // Return the formatted string\n    return \"db\" + binaryString + \"db\";\n}\n"}
{"task_id": "CPP/80", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nbool is_happy(string s) {\n    // Check if the length of the string is less than 3\n    if (s.length() < 3) {\n        return false;\n    }\n    \n    // Iterate through the string to check every 3 consecutive characters\n    for (int i = 0; i <= s.length() - 3; i++) {\n        // Check if the three characters are distinct\n        if (s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]) {\n            return false; // Found non-distinct characters\n        }\n    }\n    \n    // All sets of three characters are distinct\n    return true;\n}\n"}
{"task_id": "CPP/81", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> numerical_letter_grade(vector<float> grades) {\n    vector<string> letterGrades;\n    \n    for (float gpa : grades) {\n        if (gpa == 4.0) {\n            letterGrades.push_back(\"A+\");\n        } else if (gpa > 3.7) {\n            letterGrades.push_back(\"A\");\n        } else if (gpa > 3.3) {\n            letterGrades.push_back(\"A-\");\n        } else if (gpa > 3.0) {\n            letterGrades.push_back(\"B+\");\n        } else if (gpa > 2.7) {\n            letterGrades.push_back(\"B\");\n        } else if (gpa > 2.3) {\n            letterGrades.push_back(\"B-\");\n        } else if (gpa > 2.0) {\n            letterGrades.push_back(\"C+\");\n        } else if (gpa > 1.7) {\n            letterGrades.push_back(\"C\");\n        } else if (gpa > 1.3) {\n            letterGrades.push_back(\"C-\");\n        } else if (gpa > 1.0) {\n            letterGrades.push_back(\"D+\");\n        } else if (gpa > 0.7) {\n            letterGrades.push_back(\"D\");\n        } else if (gpa > 0.0) {\n            letterGrades.push_back(\"D-\");\n        } else {\n            letterGrades.push_back(\"E\");\n        }\n    }\n    \n    return letterGrades;\n}\n"}
{"task_id": "CPP/82", "generation": "#include <stdio.h>\n#include <string>\n#include <cmath>\nusing namespace std;\n\nbool prime_length(string str) {\n    int len = str.length();\n    if (len < 2) return false; // 0 and 1 are not prime numbers\n\n    for (int i = 2; i <= sqrt(len); i++) {\n        if (len % i == 0) {\n            return false; // Found a divisor, not a prime\n        }\n    }\n    return true; // No divisors found, it's a prime\n}\n"}
{"task_id": "CPP/83", "generation": "#include <stdio.h>\n#include <cmath>\nusing namespace std;\n\nint starts_one_ends(int n) {\n    if (n == 1) {\n        return 1;  // Only the number '1'\n    }\n    \n    int count_starting_with_1 = pow(10, n - 1);\n    int count_ending_with_1 = 9 * pow(10, n - 2);\n    int count_both_starting_and_ending_with_1 = pow(10, n - 2);\n    \n    int total_count = count_starting_with_1 + count_ending_with_1 - count_both_starting_and_ending_with_1;\n    return total_count;\n}\n"}
{"task_id": "CPP/84", "generation": "#include <stdio.h>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nstring solve(int N) {\n    int sum_of_digits = 0;\n\n    // Calculate the sum of digits\n    while (N > 0) {\n        sum_of_digits += N % 10; // Get the last digit\n        N /= 10; // Remove the last digit\n    }\n\n    // Convert the sum to binary\n    string binary_representation = \"\";\n    if (sum_of_digits == 0) {\n        return \"0\"; // Handle the case when sum is 0\n    }\n    \n    while (sum_of_digits > 0) {\n        binary_representation += (sum_of_digits % 2) ? '1' : '0'; // Append '1' or '0'\n        sum_of_digits /= 2; // Divide by 2 to shift right\n    }\n\n    // The binary representation is in reverse order, so reverse it\n    reverse(binary_representation.begin(), binary_representation.end());\n\n    return binary_representation;\n}\n"}
{"task_id": "CPP/85", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nint add(vector<int> lst) {\n    int sum = 0; // Initialize sum to 0\n    for (int i = 0; i < lst.size(); i++) { // Iterate through the vector\n        if (i % 2 == 1 && lst[i] % 2 == 0) { // Check if index is odd and element is even\n            sum += lst[i]; // Add to sum\n        }\n    }\n    return sum; // Return the final sum\n}\n"}
{"task_id": "CPP/86", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <sstream>\nusing namespace std;\n\nstring anti_shuffle(string s) {\n    string result;\n    stringstream ss(s);\n    string word;\n\n    while (ss >> word) {\n        // Sort the characters of the word\n        sort(word.begin(), word.end());\n        // Append the sorted word to the result\n        result += word + \" \";\n    }\n\n    // Remove the trailing space if exists\n    if (!result.empty()) {\n        result.pop_back();\n    }\n\n    // Now we need to handle the spaces in the original string\n    size_t pos = 0;\n    for (char c : s) {\n        if (c == ' ') {\n            result.insert(pos, \" \");\n            pos++;\n        } else {\n            // Move the position forward for each non-space character\n            pos++;\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/87", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<vector<int>> get_row(vector<vector<int>> lst, int x) {\n    vector<vector<int>> coordinates;\n\n    // Collecting coordinates of occurrences of x\n    for (int i = 0; i < lst.size(); i++) {\n        for (int j = 0; j < lst[i].size(); j++) {\n            if (lst[i][j] == x) {\n                coordinates.push_back({i, j});\n            }\n        }\n    }\n\n    // Sorting coordinates: first by row (ascending), then by column (descending)\n    sort(coordinates.begin(), coordinates.end(), [](const vector<int>& a, const vector<int>& b) {\n        if (a[0] == b[0]) {\n            return a[1] > b[1]; // Sort by column descending if rows are the same\n        }\n        return a[0] < b[0]; // Sort by row ascending\n    });\n\n    return coordinates;\n}\n"}
{"task_id": "CPP/88", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> sort_array(vector<int> array) {\n    // Handle edge cases\n    if (array.empty()) {\n        return {};\n    }\n    if (array.size() == 1) {\n        return array;\n    }\n\n    // Calculate the sum of the first and last elements\n    int sum = array[0] + array[array.size() - 1];\n\n    // Create a copy of the original array to sort\n    vector<int> sortedArray = array;\n\n    // Sort based on the sum\n    if (sum % 2 == 0) {\n        // Even sum: sort in descending order\n        sort(sortedArray.begin(), sortedArray.end(), greater<int>());\n    } else {\n        // Odd sum: sort in ascending order\n        sort(sortedArray.begin(), sortedArray.end());\n    }\n\n    return sortedArray;\n}\n"}
{"task_id": "CPP/89", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nstring encrypt(string s) {\n    string result = \"\";\n    for (char c : s) {\n        if (c >= 'a' && c <= 'z') {\n            // Rotate lowercase letters\n            char newChar = c + 4;\n            if (newChar > 'z') {\n                newChar -= 26; // Wrap around\n            }\n            result += newChar;\n        } else if (c >= 'A' && c <= 'Z') {\n            // Rotate uppercase letters\n            char newChar = c + 4;\n            if (newChar > 'Z') {\n                newChar -= 26; // Wrap around\n            }\n            result += newChar;\n        } else {\n            // Non-alphabetic characters remain unchanged\n            result += c;\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/90", "generation": "#include <stdio.h>\n#include <vector>\n#include <set>\n#include <algorithm>\nusing namespace std;\n\nint next_smallest(vector<int> lst) {\n    if (lst.empty()) {\n        return -1; // Using -1 to indicate None, as per C++ conventions\n    }\n    \n    set<int> unique_elements(lst.begin(), lst.end()); // Store unique elements\n    if (unique_elements.size() < 2) {\n        return -1; // Return -1 to indicate None\n    }\n    \n    vector<int> sorted_elements(unique_elements.begin(), unique_elements.end());\n    sort(sorted_elements.begin(), sorted_elements.end());\n    \n    return sorted_elements[1]; // Return the second smallest element\n}\n"}
{"task_id": "CPP/91", "generation": "#include <stdio.h>\n#include <string>\n#include <cctype> // for isspace\nusing namespace std;\n\nint is_bored(string S) {\n    int count = 0;\n    int start = 0;\n    \n    for (int i = 0; i < S.length(); i++) {\n        // Check for sentence delimiters\n        if (S[i] == '.' || S[i] == '?' || S[i] == '!') {\n            // Extract the sentence\n            string sentence = S.substr(start, i - start);\n            // Trim leading spaces\n            while (isspace(sentence[0]) && !sentence.empty()) {\n                sentence.erase(0, 1);\n            }\n            // Check if the sentence starts with \"I\"\n            if (sentence.rfind(\"I\", 0) == 0) { // Check if \"I\" is at the start\n                count++;\n            }\n            // Update start index for the next sentence\n            start = i + 1;\n        }\n    }\n    \n    return count;\n}\n"}
{"task_id": "CPP/92", "generation": "#include <iostream>\n#include <cmath>\nusing namespace std;\n\nbool any_int(float a, float b, float c) {\n    // Check if all numbers are integers\n    if (a != static_cast<int>(a) || b != static_cast<int>(b) || c != static_cast<int>(c)) {\n        return false;\n    }\n    \n    // Check if any number is equal to the sum of the other two\n    return (a == b + c) || (b == a + c) || (c == a + b);\n}\n\n// Example usage\n"}
{"task_id": "CPP/93", "generation": "#include <stdio.h>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nstring encode(string message) {\n    string result = \"\";\n    for (char c : message) {\n        if (c == 'a') result += 'c';\n        else if (c == 'e') result += 'g';\n        else if (c == 'i') result += 'k';\n        else if (c == 'o') result += 'q';\n        else if (c == 'u') result += 'w';\n        else if (c == 'A') result += 'C';\n        else if (c == 'E') result += 'G';\n        else if (c == 'I') result += 'K';\n        else if (c == 'O') result += 'Q';\n        else if (c == 'U') result += 'W';\n        else if (isalpha(c)) {\n            // Swap case\n            if (islower(c)) result += toupper(c);\n            else result += tolower(c);\n        } else {\n            // Keep spaces unchanged\n            result += c;\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/94", "generation": "#include <stdio.h>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\n// Function to check if a number is prime\nbool isPrime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i <= sqrt(n); i++) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\n// Function to calculate the sum of digits of a number\nint sumOfDigits(int n) {\n    int sum = 0;\n    while (n > 0) {\n        sum += n % 10;\n        n /= 10;\n    }\n    return sum;\n}\n\n// Main function to find the largest prime and return the sum of its digits\nint skjkasdkd(vector<int> lst) {\n    int largestPrime = -1;\n    for (int number : lst) {\n        if (isPrime(number)) {\n            if (number > largestPrime) {\n                largestPrime = number;\n            }\n        }\n    }\n    if (largestPrime == -1) {\n        return 0; // No prime found\n    }\n    return sumOfDigits(largestPrime);\n}\n"}
{"task_id": "CPP/95", "generation": "#include <stdio.h>\n#include <string>\n#include <map>\n#include <cctype> // for islower and isupper\nusing namespace std;\n\nbool check_dict_case(map<string, string> dict) {\n    // Check if the map is empty\n    if (dict.empty()) {\n        return false;\n    }\n\n    bool all_lower = true;\n    bool all_upper = true;\n\n    // Iterate through each key in the map\n    for (const auto& pair : dict) {\n        const string& key = pair.first;\n\n        // Check if the key is lowercase\n        if (!std::all_of(key.begin(), key.end(), ::islower)) {\n            all_lower = false;\n        }\n\n        // Check if the key is uppercase\n        if (!std::all_of(key.begin(), key.end(), ::isupper)) {\n            all_upper = false;\n        }\n\n        // If both flags are false, we can return false early\n        if (!all_lower && !all_upper) {\n            return false;\n        }\n    }\n\n    // Return true if all keys are either all lower or all upper\n    return all_lower || all_upper;\n}\n"}
{"task_id": "CPP/96", "generation": "#include <stdio.h>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    for (int j = 2; j <= sqrt(num); j++) {\n        if (num % j == 0) return false;\n    }\n    return true;\n}\n\nvector<int> count_up_to(int n) {\n    vector<int> primes;\n    if (n < 2) return primes; // Return empty vector if n < 2\n    for (int i = 2; i < n; i++) {\n        if (is_prime(i)) {\n            primes.push_back(i);\n        }\n    }\n    return primes;\n}\n"}
{"task_id": "CPP/97", "generation": "#include<stdio.h>\nusing namespace std;\n\nint multiply(int a, int b) {\n    int unit_digit_a = a % 10; // Get the unit digit of a\n    int unit_digit_b = b % 10; // Get the unit digit of b\n    int product = unit_digit_a * unit_digit_b; // Calculate the product\n    return product; // Return the product\n}\n"}
{"task_id": "CPP/98", "generation": "#include <stdio.h>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nint count_upper(string s) {\n    int count = 0;\n    for (int i = 0; i < s.length(); i += 2) { // Iterate over even indices\n        if (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U') {\n            count++; // Increment count if the character is an uppercase vowel\n        }\n    }\n    return count; // Return the total count\n}\n"}
{"task_id": "CPP/99", "generation": "#include <stdio.h>\n#include <math.h>\n#include <string>\n#include <cstdlib> // for std::atof\nusing namespace std;\n\nint closest_integer(string value) {\n    double num = atof(value.c_str()); // Convert string to double\n    int integer_part = floor(num); // Get the integer part\n    double decimal_part = num - integer_part; // Get the decimal part\n\n    // Determine rounding based on the decimal part\n    if (decimal_part > 0.5) {\n        return ceil(num); // Round up\n    } else if (decimal_part < -0.5) {\n        return floor(num); // Round down\n    } else {\n        // If exactly .5 or -0.5, round away from zero\n        if (num > 0) {\n            return ceil(num); // Round up for positive\n        } else {\n            return floor(num); // Round down for negative\n        }\n    }\n}\n"}
{"task_id": "CPP/100", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> make_a_pile(int n) {\n    vector<int> stones;\n    for (int i = 0; i < n; i++) {\n        stones.push_back(n + 2 * i);\n    }\n    return stones;\n}\n"}
{"task_id": "CPP/101", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n\nusing namespace std;\n\nvector<string> words_string(string s) {\n    // Replace commas with spaces\n    replace(s.begin(), s.end(), ',', ' ');\n\n    vector<string> words;\n    stringstream ss(s);\n    string word;\n\n    // Read words from the stringstream\n    while (ss >> word) {\n        words.push_back(word);\n    }\n\n    return words;\n}\n"}
{"task_id": "CPP/102", "generation": "#include<stdio.h>\nusing namespace std;\n\nint choose_num(int x, int y) {\n    // Step 1: Check if x is greater than y\n    if (x > y) {\n        return -1;\n    }\n    \n    // Step 2: Determine the largest even number in the range\n    int largest_even;\n    if (y % 2 == 0) {\n        largest_even = y; // y is even\n    } else {\n        largest_even = y - 1; // y is odd, so the largest even is y - 1\n    }\n    \n    // Step 4: Check if the largest even number is less than x\n    if (largest_even < x) {\n        return -1; // No even number in the range\n    }\n    \n    // Step 5: Return the largest even number\n    return largest_even;\n}\n"}
{"task_id": "CPP/103", "generation": "#include <stdio.h>\n#include <math.h>\n#include <string>\n#include <bitset>\nusing namespace std;\n\nstring rounded_avg(int n, int m) {\n    // Check if n is greater than m\n    if (n > m) {\n        return \"-1\";\n    }\n    \n    // Calculate the sum of integers from n to m\n    long long sum = (long long)(m - n + 1) * (n + m) / 2; // Use long long to prevent overflow\n    int count = m - n + 1;\n    \n    // Calculate the average\n    double average = (double)sum / count;\n    \n    // Round down the average\n    int rounded_average = floor(average);\n    \n    // Convert the rounded average to binary\n    return bitset<32>(rounded_average).to_string().substr(32 - (rounded_average ? log2(rounded_average) + 1 : 1));\n}\n"}
{"task_id": "CPP/104", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> unique_digits(vector<int> x) {\n    vector<int> result;\n    \n    for (int number : x) {\n        int temp = number;\n        bool isValid = true;\n        \n        while (temp > 0) {\n            int digit = temp % 10;\n            if (digit % 2 == 0) { // Check if the digit is even\n                isValid = false;\n                break;\n            }\n            temp /= 10; // Remove the last digit\n        }\n        \n        if (isValid) {\n            result.push_back(number); // Add to result if all digits are odd\n        }\n    }\n    \n    sort(result.begin(), result.end()); // Sort the result vector\n    return result;\n}\n"}
{"task_id": "CPP/105", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\nvector<string> by_length(vector<int> arr) {\n    vector<int> valid_numbers;\n\n    // Filter valid numbers (between 1 and 9)\n    for (int number : arr) {\n        if (number >= 1 && number <= 9) {\n            valid_numbers.push_back(number);\n        }\n    }\n\n    // Sort the valid numbers\n    sort(valid_numbers.begin(), valid_numbers.end());\n\n    // Reverse the sorted numbers\n    reverse(valid_numbers.begin(), valid_numbers.end());\n\n    // Mapping from number to word\n    map<int, string> number_to_word = {\n        {1, \"One\"}, {2, \"Two\"}, {3, \"Three\"},\n        {4, \"Four\"}, {5, \"Five\"}, {6, \"Six\"},\n        {7, \"Seven\"}, {8, \"Eight\"}, {9, \"Nine\"}\n    };\n\n    vector<string> result;\n\n    // Convert numbers to words\n    for (int number : valid_numbers) {\n        result.push_back(number_to_word[number]);\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/106", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nvector<int> f(int n) {\n    vector<int> result(n);\n    \n    for (int i = 1; i <= n; i++) {\n        if (i % 2 == 0) { // i is even\n            // Calculate factorial\n            int factorial = 1;\n            for (int j = 1; j <= i; j++) {\n                factorial *= j;\n            }\n            result[i - 1] = factorial;\n        } else { // i is odd\n            // Calculate sum from 1 to i\n            result[i - 1] = (i * (i + 1)) / 2;\n        }\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/107", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nbool is_palindrome(int num) {\n    string str_num = to_string(num);\n    string reversed_str = string(str_num.rbegin(), str_num.rend());\n    return str_num == reversed_str;\n}\n\nvector<int> even_odd_palindrome(int n) {\n    int even_count = 0;\n    int odd_count = 0;\n\n    for (int i = 1; i <= n; i++) {\n        if (is_palindrome(i)) {\n            if (i % 2 == 0) {\n                even_count++;\n            } else {\n                odd_count++;\n            }\n        }\n    }\n\n    return {even_count, odd_count};\n}\n"}
{"task_id": "CPP/108", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nint count_nums(vector<int> n) {\n    int count = 0;\n    \n    for (int number : n) {\n        int sum_of_digits = 0;\n        bool is_negative = number < 0;\n        \n        if (is_negative) {\n            sum_of_digits -= abs(number % 10); // Start with the first digit as negative\n            number = abs(number); // Work with the absolute value for the rest\n        }\n        \n        while (number > 0) {\n            sum_of_digits += (number % 10);\n            number /= 10;\n        }\n        \n        if (sum_of_digits > 0) {\n            count++;\n        }\n    }\n    \n    return count;\n}\n"}
{"task_id": "CPP/109", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nbool move_one_ball(vector<int> arr) {\n    // If the array is empty, return true\n    if (arr.empty()) {\n        return true;\n    }\n\n    int disruptionCount = 0;\n    int n = arr.size();\n\n    // Check for disruptions in the order\n    for (int i = 0; i < n; i++) {\n        if (arr[i] > arr[(i + 1) % n]) {\n            disruptionCount++;\n        }\n    }\n\n    // If there is at most one disruption, return true\n    return disruptionCount <= 1;\n}\n"}
{"task_id": "CPP/110", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring exchange(vector<int> lst1, vector<int> lst2) {\n    int oddCount = 0;\n    int evenCount = 0;\n\n    // Count odd numbers in lst1\n    for (int num : lst1) {\n        if (num % 2 != 0) {\n            oddCount++;\n        }\n    }\n\n    // Count even numbers in lst2\n    for (int num : lst2) {\n        if (num % 2 == 0) {\n            evenCount++;\n        }\n    }\n\n    // Check if we can replace all odd numbers in lst1 with even numbers from lst2\n    if (oddCount <= evenCount) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n"}
{"task_id": "CPP/111", "generation": "#include <stdio.h>\n#include <string>\n#include <map>\n#include <sstream>\n#include <vector>\nusing namespace std;\n\nmap<string, int> histogram(string test) {\n    map<string, int> countMap;\n    stringstream ss(test);\n    string letter;\n\n    // Count occurrences of each letter\n    while (ss >> letter) {\n        countMap[letter]++;\n    }\n\n    // Determine the maximum count\n    int maxCount = 0;\n    for (const auto& pair : countMap) {\n        if (pair.second > maxCount) {\n            maxCount = pair.second;\n        }\n    }\n\n    // Create a result map for letters with the maximum count\n    map<string, int> resultMap;\n    for (const auto& pair : countMap) {\n        if (pair.second == maxCount) {\n            resultMap[pair.first] = pair.second;\n        }\n    }\n\n    return resultMap;\n}\n"}
{"task_id": "CPP/112", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <unordered_set>\n#include <algorithm>\nusing namespace std;\n\nvector<string> reverse_delete(string s, string c) {\n    unordered_set<char> charsToRemove(c.begin(), c.end());\n    string result;\n\n    // Build the result string by excluding characters in charsToRemove\n    for (char ch : s) {\n        if (charsToRemove.find(ch) == charsToRemove.end()) {\n            result += ch;\n        }\n    }\n\n    // Check if the result string is a palindrome\n    string reversedResult = result;\n    reverse(reversedResult.begin(), reversedResult.end());\n    bool isPalindrome = (result == reversedResult);\n\n    // Prepare the output\n    return {result, isPalindrome ? \"True\" : \"False\"};\n}\n"}
{"task_id": "CPP/113", "generation": "#include <vector>\n#include <string>\n#include <iostream>\n\nusing namespace std;\n\nvector<string> odd_count(vector<string> lst) {\n    vector<string> result;\n    \n    for (int i = 0; i < lst.size(); i++) {\n        int odd_count = 0;\n        for (char c : lst[i]) {\n            if (c == '1' || c == '3' || c == '5' || c == '7' || c == '9') {\n                odd_count++;\n            }\n        }\n        // Create the formatted string\n        string formatted_string = \"the number of odd elements \" + to_string(odd_count) + \n                                   \"n the str\" + to_string(i) + \n                                   \"ng \" + to_string(i) + \n                                   \" of the \" + to_string(i) + \n                                   \"nput.\";\n        result.push_back(formatted_string);\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/114", "generation": "#include<stdio.h>\n#include<vector>\n#include<limits.h> // for INT_MAX\nusing namespace std;\n\nlong long minSubArraySum(vector<long long> nums) {\n    long long min_sum = LLONG_MAX; // Initialize to maximum possible value\n    long long current_sum = 0; // Initialize current sum to 0\n\n    for (long long num : nums) {\n        current_sum += num; // Add current number to the current sum\n\n        // Update min_sum if current_sum is less than min_sum\n        if (current_sum < min_sum) {\n            min_sum = current_sum;\n        }\n\n        // If current_sum becomes positive, reset it to 0\n        if (current_sum > 0) {\n            current_sum = 0;\n        }\n    }\n\n    return min_sum; // Return the minimum sum found\n}\n"}
{"task_id": "CPP/115", "generation": "#include <stdio.h>\n#include <vector>\n#include <cmath> // For ceil function\nusing namespace std;\n\nint max_fill(vector<vector<int>> grid, int capacity) {\n    int total_operations = 0;\n    \n    for (const auto& row : grid) {\n        int count_of_water = 0;\n        \n        // Count the number of 1's in the current row\n        for (int water : row) {\n            count_of_water += water;\n        }\n        \n        // If there is water, calculate the number of buckets needed\n        if (count_of_water > 0) {\n            int buckets_needed = ceil(static_cast<double>(count_of_water) / capacity);\n            total_operations += buckets_needed;\n        }\n    }\n    \n    return total_operations;\n}\n"}
{"task_id": "CPP/116", "generation": "#include <vector>\n#include <algorithm>\n#include <iostream>\n\nusing namespace std;\n\nint countOnes(int n) {\n    return __builtin_popcount(n < 0 ? -n : n);\n}\n\nvector<int> sort_array(vector<int> arr) {\n    sort(arr.begin(), arr.end(), [](int a, int b) {\n        int countA = countOnes(a);\n        int countB = countOnes(b);\n        if (countA != countB) {\n            return countA < countB; // Sort by number of ones\n        }\n        return a < b; // Sort by value if number of ones is the same\n    });\n    return arr;\n}\n\n// Example usage\n"}
{"task_id": "CPP/117", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <cctype>\n\nusing namespace std;\n\nvector<string> select_words(string s, int n) {\n    vector<string> result;\n    stringstream ss(s);\n    string word;\n\n    while (ss >> word) {\n        int consonant_count = 0;\n        for (char c : word) {\n            // Check if the character is a consonant\n            if (isalpha(c) && !strchr(\"aeiouAEIOU\", c)) {\n                consonant_count++;\n            }\n        }\n        // If the consonant count matches n, add the word to the result\n        if (consonant_count == n) {\n            result.push_back(word);\n        }\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/118", "generation": "#include <stdio.h>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nstring get_closest_vowel(string word) {\n    // Define the set of vowels\n    const string vowels = \"aeiouAEIOU\";\n    int length = word.length();\n    \n    // If the word is too short to have a vowel between consonants\n    if (length < 3) {\n        return \"\";\n    }\n\n    // Iterate from the second last character to the second character\n    for (int i = length - 2; i >= 1; i--) {\n        // Check if the current character is a vowel\n        if (vowels.find(word[i]) != string::npos) {\n            // Check if the characters before and after are consonants\n            if (!isalpha(word[i - 1]) || vowels.find(word[i - 1]) == string::npos) {\n                if (!isalpha(word[i + 1]) || vowels.find(word[i + 1]) == string::npos) {\n                    return string(1, word[i]); // Return the vowel as a string\n                }\n            }\n        }\n    }\n    return \"\"; // Return empty string if no vowel found\n}\n"}
{"task_id": "CPP/119", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nbool check_balance(const string& s) {\n    int balance = 0;\n    for (char c : s) {\n        if (c == '(') {\n            balance++;\n        } else {\n            balance--;\n        }\n        // If balance goes negative, we have more ')' than '(' at some point\n        if (balance < 0) {\n            return false;\n        }\n    }\n    // At the end, balance must be zero for a fully balanced string\n    return balance == 0;\n}\n\nstring match_parens(vector<string> lst) {\n    string s1 = lst[0];\n    string s2 = lst[1];\n\n    // Check both concatenation orders\n    if (check_balance(s1 + s2) || check_balance(s2 + s1)) {\n        return \"Yes\";\n    }\n    return \"No\";\n}\n"}
{"task_id": "CPP/120", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> maximum(vector<int> arr, int k) {\n    // If k is 0, return an empty vector\n    if (k == 0) {\n        return {};\n    }\n    \n    // Sort the array in descending order\n    sort(arr.begin(), arr.end(), greater<int>());\n    \n    // Create a vector to hold the top k elements\n    vector<int> result(arr.begin(), arr.begin() + k);\n    \n    // Sort the result in ascending order\n    sort(result.begin(), result.end());\n    \n    return result;\n}\n"}
{"task_id": "CPP/121", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nint solution(vector<int> lst) {\n    int sum = 0; // Initialize sum to 0\n    for (int i = 0; i < lst.size(); i++) { // Iterate through the vector\n        if (i % 2 == 0) { // Check if the index is even\n            if (lst[i] % 2 != 0) { // Check if the element is odd\n                sum += lst[i]; // Add to sum if both conditions are met\n            }\n        }\n    }\n    return sum; // Return the final sum\n}\n"}
{"task_id": "CPP/122", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nint add_elements(vector<int> arr, int k) {\n    int sum = 0; // Initialize sum to 0\n    for (int i = 0; i < k; i++) { // Loop through the first k elements\n        if (abs(arr[i]) < 100) { // Check if the element has at most two digits\n            sum += arr[i]; // Add to sum if condition is met\n        }\n    }\n    return sum; // Return the computed sum\n}\n"}
{"task_id": "CPP/123", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> get_odd_collatz(int n) {\n    vector<int> odd_numbers;\n    int current = n;\n\n    while (current != 1) {\n        if (current % 2 != 0) { // Check if current is odd\n            odd_numbers.push_back(current);\n        }\n        if (current % 2 == 0) { // If current is even\n            current /= 2;\n        } else { // If current is odd\n            current = 3 * current + 1;\n        }\n    }\n    odd_numbers.push_back(1); // Add 1 to the list since the sequence ends with 1\n\n    sort(odd_numbers.begin(), odd_numbers.end()); // Sort the vector\n    return odd_numbers;\n}\n"}
{"task_id": "CPP/124", "generation": "#include <stdio.h>\n#include <string>\n#include <sstream>\n#include <vector>\nusing namespace std;\n\nbool valid_date(string date) {\n    // Check if the date string is empty\n    if (date.empty()) {\n        return false;\n    }\n\n    // Check for the correct format with exactly two dashes\n    int dashCount = 0;\n    for (char c : date) {\n        if (c == '-') {\n            dashCount++;\n        }\n    }\n    if (dashCount != 2) {\n        return false;\n    }\n\n    // Split the date into parts\n    stringstream ss(date);\n    string monthStr, dayStr, yearStr;\n    getline(ss, monthStr, '-');\n    getline(ss, dayStr, '-');\n    getline(ss, yearStr);\n\n    // Convert parts to integers\n    int month = stoi(monthStr);\n    int day = stoi(dayStr);\n    int year = stoi(yearStr);\n\n    // Validate the month\n    if (month < 1 || month > 12) {\n        return false;\n    }\n\n    // Validate the day based on the month\n    if (day < 1) {\n        return false;\n    }\n    if (month == 2) {\n        if (day > 29) {\n            return false;\n        }\n    } else if (month == 4 || month == 6 || month == 9 || month == 11) {\n        if (day > 30) {\n            return false;\n        }\n    } else {\n        if (day > 31) {\n            return false;\n        }\n    }\n\n    return true;\n}\n"}
{"task_id": "CPP/125", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <cctype>\n\nusing namespace std;\n\nvector<string> split_words(string txt) {\n    vector<string> result;\n\n    // Check for whitespace\n    if (txt.find(' ') != string::npos) {\n        istringstream iss(txt);\n        string word;\n        while (iss >> word) {\n            result.push_back(word);\n        }\n        return result;\n    }\n\n    // Check for commas\n    if (txt.find(',') != string::npos) {\n        istringstream iss(txt);\n        string word;\n        while (getline(iss, word, ',')) {\n            result.push_back(word);\n        }\n        return result;\n    }\n\n    // If no whitespace or commas, count lowercase letters in odd positions\n    int count = 0;\n    for (char c : txt) {\n        if (islower(c)) {\n            int position = c - 'a'; // Get the position of the letter\n            if (position % 2 == 1) { // Check if it's in an odd position\n                count++;\n            }\n        }\n    }\n\n    // Convert count to string and return in a vector\n    result.push_back(to_string(count));\n    return result;\n}\n"}
{"task_id": "CPP/126", "generation": "#include <stdio.h>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nbool is_sorted(vector<int> lst) {\n    if (lst.size() <= 1) {\n        return true; // An empty or single element list is sorted\n    }\n    \n    unordered_map<int, int> countMap; // To count occurrences of each number\n    int previous_number = lst[0];\n    countMap[previous_number] = 1; // Initialize count for the first number\n    \n    for (size_t i = 1; i < lst.size(); i++) {\n        if (lst[i] < previous_number) {\n            return false; // Not sorted\n        }\n        \n        // Count occurrences\n        if (lst[i] == previous_number) {\n            countMap[previous_number]++;\n            if (countMap[previous_number] > 2) {\n                return false; // More than two occurrences\n            }\n        } else {\n            previous_number = lst[i];\n            countMap[previous_number] = 1; // Reset count for new number\n        }\n    }\n    \n    return true; // Passed all checks\n}\n"}
{"task_id": "CPP/127", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <cmath>\nusing namespace std;\n\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i <= sqrt(n); i++) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\nstring intersection(vector<int> interval1, vector<int> interval2) {\n    int start1 = interval1[0];\n    int end1 = interval1[1];\n    int start2 = interval2[0];\n    int end2 = interval2[1];\n    \n    int intersection_start = max(start1, start2);\n    int intersection_end = min(end1, end2);\n    \n    if (intersection_start > intersection_end) {\n        return \"NO\"; // No intersection\n    }\n    \n    int intersection_length = intersection_end - intersection_start + 1;\n    \n    if (is_prime(intersection_length)) {\n        return \"YES\"; // Length is prime\n    } else {\n        return \"NO\"; // Length is not prime\n    }\n}\n"}
{"task_id": "CPP/128", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nint prod_signs(vector<int> arr) {\n    if (arr.empty()) {\n        return -32768;\n    }\n    \n    int sum_magnitudes = 0;\n    int product_sign = 1;\n    \n    for (int number : arr) {\n        if (number == 0) {\n            product_sign = 0;\n            break;\n        } else if (number > 0) {\n            sum_magnitudes += number;\n        } else {\n            sum_magnitudes += -number;\n            product_sign *= -1;  // flip the sign for negative numbers\n        }\n    }\n    \n    return product_sign * sum_magnitudes;\n}\n"}
{"task_id": "CPP/129", "generation": "#include <vector>\n#include <algorithm>\n#include <limits.h>\n\nusing namespace std;\n\nvector<int> minPath;\nvector<int> currentPath;\n\nvoid backtrack(const vector<vector<int>>& grid, int x, int y, int k, int length) {\n    if (length == k) {\n        if (minPath.empty() || currentPath < minPath) {\n            minPath = currentPath;\n        }\n        return;\n    }\n\n    int N = grid.size();\n    // Possible directions to move: up, down, left, right\n    vector<pair<int, int>> directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n\n    for (auto& dir : directions) {\n        int nx = x + dir.first;\n        int ny = y + dir.second;\n        if (nx >= 0 && nx < N && ny >= 0 && ny < N) {\n            currentPath.push_back(grid[nx][ny]);\n            backtrack(grid, nx, ny, k, length + 1);\n            currentPath.pop_back();  // backtrack\n        }\n    }\n}\n\nvector<int> minPathInGrid(vector<vector<int>> grid, int k) {\n    minPath.clear();\n    currentPath.clear();\n    int N = grid.size();\n\n    // Start from each cell in the grid\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            currentPath.push_back(grid[i][j]);\n            backtrack(grid, i, j, k, 1);\n            currentPath.pop_back();  // backtrack\n        }\n    }\n    return minPath;\n}\n"}
{"task_id": "CPP/130", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nvector<int> tri(int n) {\n    vector<int> result(n + 1);\n    \n    if (n >= 0) {\n        result[0] = 1; // tri(0)\n    }\n    if (n >= 1) {\n        result[1] = 3; // tri(1)\n    }\n    \n    for (int i = 2; i <= n; i++) {\n        if (i % 2 == 0) {\n            result[i] = 1 + i / 2; // Even index\n        } else {\n            // Odd index: we need to calculate tri(i + 1) first\n            // Since we are calculating in order, we can use result[i + 1]\n            result[i] = result[i - 1] + result[i - 2] + (i + 1 <= n ? result[i + 1] : 0);\n        }\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/131", "generation": "#include<stdio.h>\nusing namespace std;\n\nint digits(int n) {\n    int product = 1;\n    bool hasOdd = false;\n\n    while (n > 0) {\n        int digit = n % 10; // Get the last digit\n        if (digit % 2 != 0) { // Check if the digit is odd\n            hasOdd = true;\n            product *= digit; // Multiply the product by the odd digit\n        }\n        n /= 10; // Remove the last digit\n    }\n\n    return hasOdd ? product : 0; // Return product if odd digits found, else return 0\n}\n"}
{"task_id": "CPP/132", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nbool is_nested(string str) {\n    int balance = 0;\n    bool nested = false;\n\n    for (char ch : str) {\n        if (ch == '[') {\n            balance++;\n        } else if (ch == ']') {\n            balance--;\n        }\n\n        // Check for nested condition\n        if (balance > 1) {\n            nested = true;\n        }\n\n        // If balance goes negative, it's unbalanced\n        if (balance < 0) {\n            return false;\n        }\n    }\n\n    // Return true if balanced and nested\n    return (balance == 0 && nested);\n}\n"}
{"task_id": "CPP/133", "generation": "#include <stdio.h>\n#include <math.h>\n#include <vector>\nusing namespace std;\n\nint sum_squares(vector<float> lst) {\n    int sum = 0; // Initialize sum to 0\n    for (float number : lst) { // Iterate through each number in the vector\n        int rounded = ceil(number); // Round the number up to the nearest integer\n        sum += rounded * rounded; // Square the rounded number and add to sum\n    }\n    return sum; // Return the final sum\n}\n"}
{"task_id": "CPP/134", "generation": "#include <iostream>\n#include <string>\n#include <cctype> // for isalpha function\nusing namespace std;\n\nbool check_if_last_char_is_a_letter(string txt) {\n    // Trim trailing spaces\n    size_t end = txt.find_last_not_of(' ');\n    if (end == string::npos) {\n        return false; // String is empty after trimming\n    }\n    txt = txt.substr(0, end + 1); // Trimmed string\n\n    // Get the last character\n    char last_char = txt.back();\n\n    // Check if the last character is an alphabetical character\n    return isalpha(last_char);\n}\n\n// Example usage\n"}
{"task_id": "CPP/135", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nint can_arrange(vector<int> arr) {\n    int last_index = -1; // Initialize last_index to -1\n    for (int i = 1; i < arr.size(); i++) { // Start from the second element\n        if (arr[i] < arr[i - 1]) { // Check if current element is less than the previous one\n            last_index = i; // Update last_index\n        }\n    }\n    return last_index; // Return the last found index or -1 if none found\n}\n"}
{"task_id": "CPP/136", "generation": "#include <stdio.h>\n#include <vector>\n#include <limits.h> // For INT_MIN and INT_MAX\nusing namespace std;\n\nvector<int> largest_smallest_integers(vector<int> lst) {\n    int largest_negative = INT_MIN; // Initialize to the smallest possible integer\n    int smallest_positive = INT_MAX; // Initialize to the largest possible integer\n    \n    for (int number : lst) {\n        if (number < 0) {\n            if (number > largest_negative) {\n                largest_negative = number; // Update largest negative\n            }\n        } else if (number > 0) {\n            if (number < smallest_positive) {\n                smallest_positive = number; // Update smallest positive\n            }\n        }\n    }\n    \n    // Check if we found any valid negative or positive integers\n    if (largest_negative == INT_MIN) {\n        largest_negative = 0; // No negative found\n    }\n    if (smallest_positive == INT_MAX) {\n        smallest_positive = 0; // No positive found\n    }\n    \n    return {largest_negative, smallest_positive};\n}\n"}
{"task_id": "CPP/137", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <boost/any.hpp>\n#include <sstream>\n\nusing namespace std;\n\nboost::any compare_one(boost::any a, boost::any b) {\n    float numA, numB;\n\n    // Function to convert string to float\n    auto string_to_float = [](const string& str) {\n        string cleaned = str;\n        replace(cleaned.begin(), cleaned.end(), ',', '.'); // Replace ',' with '.'\n        return stof(cleaned);\n    };\n\n    // Check types and convert to float for comparison\n    if (a.type() == typeid(int)) {\n        numA = boost::any_cast<int>(a);\n    } else if (a.type() == typeid(float)) {\n        numA = boost::any_cast<float>(a);\n    } else if (a.type() == typeid(string)) {\n        numA = string_to_float(boost::any_cast<string>(a));\n    } else {\n        throw invalid_argument(\"Unsupported type for a\");\n    }\n\n    if (b.type() == typeid(int)) {\n        numB = boost::any_cast<int>(b);\n    } else if (b.type() == typeid(float)) {\n        numB = boost::any_cast<float>(b);\n    } else if (b.type() == typeid(string)) {\n        numB = string_to_float(boost::any_cast<string>(b));\n    } else {\n        throw invalid_argument(\"Unsupported type for b\");\n    }\n\n    // Compare the two numbers\n    if (numA == numB) {\n        return \"None\";\n    } else if (numA > numB) {\n        return a; // Return the original type of a\n    } else {\n        return b; // Return the original type of b\n    }\n}\n\n// Example usage\n"}
{"task_id": "CPP/138", "generation": "#include<stdio.h>\nusing namespace std;\n\nbool is_equal_to_sum_even(int n) {\n    if (n < 8) {\n        return false; // Cannot be expressed as the sum of 4 positive even numbers\n    }\n    return n % 2 == 0; // Return true if n is even, false if odd\n}\n"}
{"task_id": "CPP/139", "generation": "#include<stdio.h>\n\nusing namespace std;\n\n// Helper function to calculate factorial of a number\nlong long factorial(int k) {\n    long long result = 1;\n    for (int i = 1; i <= k; i++) {\n        result *= i;\n    }\n    return result;\n}\n\n// Function to calculate Brazilian factorial\nlong long special_factorial(int n) {\n    long long result = 1;\n    for (int i = 1; i <= n; i++) {\n        result *= factorial(i);\n    }\n    return result;\n}\n"}
{"task_id": "CPP/140", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nstring fix_spaces(string text) {\n    string result = \"\";\n    int spaceCount = 0;\n\n    for (char ch : text) {\n        if (ch == ' ') {\n            spaceCount++;\n        } else {\n            if (spaceCount > 0) {\n                if (spaceCount == 1) {\n                    result += '_'; // Replace single space with underscore\n                } else {\n                    result += '-'; // Replace more than 2 spaces with hyphen\n                }\n                spaceCount = 0; // Reset space count after handling\n            }\n            result += ch; // Append the current non-space character\n        }\n    }\n\n    // Handle any trailing spaces\n    if (spaceCount > 0) {\n        if (spaceCount == 1) {\n            result += '_'; // Replace single space with underscore\n        } else {\n            result += '-'; // Replace more than 2 spaces with hyphen\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/141", "generation": "#include <stdio.h>\n#include <string>\n#include <cctype>\n#include <unordered_set>\nusing namespace std;\n\nstring file_name_check(string file_name) {\n    int count_digits = 0;\n    bool has_dot = false;\n    int dot_index = -1;\n    \n    for (int i = 0; i < file_name.length(); i++) {\n        if (isdigit(file_name[i])) {\n            count_digits++;\n        }\n        if (file_name[i] == '.') {\n            has_dot = true;\n            dot_index = i;\n        }\n    }\n    \n    if (count_digits > 3) {\n        return \"No\";\n    }\n    if (!has_dot || dot_index == 0 || dot_index == file_name.length() - 1) {\n        return \"No\";\n    }\n    \n    string before_dot = file_name.substr(0, dot_index);\n    string after_dot = file_name.substr(dot_index + 1);\n    \n    if (before_dot.empty() || !isalpha(before_dot[0])) {\n        return \"No\";\n    }\n    \n    unordered_set<string> valid_extensions = {\"txt\", \"exe\", \"dll\"};\n    if (valid_extensions.find(after_dot) == valid_extensions.end()) {\n        return \"No\";\n    }\n    \n    return \"Yes\";\n}\n"}
{"task_id": "CPP/142", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nint sum_squares(vector<int> lst) {\n    int sum = 0; // Initialize sum to 0\n    for (int index = 0; index < lst.size(); index++) {\n        if (index % 3 == 0) {\n            lst[index] = lst[index] * lst[index]; // Square the element\n        } else if (index % 4 == 0) {\n            lst[index] = lst[index] * lst[index] * lst[index]; // Cube the element\n        }\n        sum += lst[index]; // Add the modified element to sum\n    }\n    return sum; // Return the total sum\n}\n"}
{"task_id": "CPP/143", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i <= sqrt(n); i++) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\n// Function to extract words with prime lengths from a sentence\nstring words_in_sentence(string sentence) {\n    stringstream ss(sentence);\n    string word;\n    vector<string> result;\n\n    // Split the sentence into words\n    while (ss >> word) {\n        // Check if the length of the word is prime\n        if (is_prime(word.length())) {\n            result.push_back(word);\n        }\n    }\n\n    // Join the result into a single string\n    string output;\n    for (size_t i = 0; i < result.size(); i++) {\n        output += result[i];\n        if (i < result.size() - 1) {\n            output += \" \"; // Add space between words\n        }\n    }\n    return output;\n}\n"}
{"task_id": "CPP/144", "generation": "#include <stdio.h>\n#include <string>\n#include <sstream>\n#include <vector>\nusing namespace std;\n\nbool simplify(string x, string n) {\n    // Split the first fraction\n    size_t pos = x.find('/');\n    int a = stoi(x.substr(0, pos)); // numerator of x\n    int b = stoi(x.substr(pos + 1)); // denominator of x\n\n    // Split the second fraction\n    pos = n.find('/');\n    int c = stoi(n.substr(0, pos)); // numerator of n\n    int d = stoi(n.substr(pos + 1)); // denominator of n\n\n    // Calculate the product's numerator and denominator\n    int product_numerator = a * c;\n    int product_denominator = b * d;\n\n    // Check if the product is a whole number\n    return (product_numerator % product_denominator == 0);\n}\n"}
{"task_id": "CPP/145", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\n// Function to calculate the sum of digits\nint digit_sum(int num) {\n    int sum = 0;\n    bool isNegative = num < 0;\n    num = abs(num); // Work with absolute value for digit extraction\n\n    // Add the first digit as negative if the number is negative\n    if (isNegative) {\n        sum -= (num / (int)pow(10, (int)log10(num))); // First digit\n    }\n\n    // Calculate the sum of the remaining digits\n    while (num > 0) {\n        sum += num % 10; // Add last digit\n        num /= 10;       // Remove last digit\n    }\n    return sum;\n}\n\n// Main function to sort the vector based on digit sums\nvector<int> order_by_points(vector<int> nums) {\n    sort(nums.begin(), nums.end(), [](int a, int b) {\n        int sumA = digit_sum(a);\n        int sumB = digit_sum(b);\n        return sumA < sumB; // Sort by digit sum\n    });\n    return nums;\n}\n"}
{"task_id": "CPP/146", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nint specialFilter(vector<int> nums) {\n    int count = 0;\n    for (int num : nums) {\n        if (num > 10) {\n            string numStr = to_string(num);\n            char first_digit = numStr[0];\n            char last_digit = numStr[numStr.length() - 1];\n            if ((first_digit - '0') % 2 != 0 && (last_digit - '0') % 2 != 0) {\n                count++;\n            }\n        }\n    }\n    return count;\n}\n"}
{"task_id": "CPP/147", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nint get_max_triples(int n) {\n    vector<int> a(n);\n    \n    // Step 1: Generate the vector a\n    for (int i = 1; i <= n; i++) {\n        a[i - 1] = i * i - i + 1;\n    }\n    \n    // Step 2: Count occurrences of each modulo 3\n    int count[3] = {0, 0, 0};\n    for (int i = 0; i < n; i++) {\n        count[a[i] % 3]++;\n    }\n    \n    // Step 3: Calculate the number of valid triples\n    int totalTriples = 0;\n\n    // Combinations of 3 from the same category\n    for (int i = 0; i < 3; i++) {\n        if (count[i] >= 3) {\n            totalTriples += (count[i] * (count[i] - 1) * (count[i] - 2)) / 6; // nC3\n        }\n    }\n\n    // One from each category\n    totalTriples += count[0] * count[1] * count[2];\n\n    return totalTriples;\n}\n"}
{"task_id": "CPP/148", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nvector<string> bf(string planet1, string planet2) {\n    vector<string> planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n    \n    // Find the indices of the given planets\n    auto it1 = find(planets.begin(), planets.end(), planet1);\n    auto it2 = find(planets.begin(), planets.end(), planet2);\n    \n    // Check if both planets are valid\n    if (it1 == planets.end() || it2 == planets.end()) {\n        return {}; // Return empty vector if either planet is invalid\n    }\n    \n    // Get the indices\n    int index1 = distance(planets.begin(), it1);\n    int index2 = distance(planets.begin(), it2);\n    \n    // Ensure index1 is less than index2\n    if (index1 > index2) {\n        swap(index1, index2);\n    }\n    \n    // Collect planets in between\n    vector<string> result;\n    for (int i = index1 + 1; i < index2; ++i) {\n        result.push_back(planets[i]);\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/149", "generation": "#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nvector<string> sorted_list_sum(vector<string> lst) {\n    vector<string> filtered;\n\n    // Filter out strings with odd lengths\n    for (const string& str : lst) {\n        if (str.length() % 2 == 0) {\n            filtered.push_back(str);\n        }\n    }\n\n    // Sort the filtered vector\n    sort(filtered.begin(), filtered.end(), [](const string& a, const string& b) {\n        if (a.length() == b.length()) {\n            return a < b; // Sort alphabetically if lengths are equal\n        }\n        return a.length() < b.length(); // Sort by length\n    });\n\n    return filtered;\n}\n"}
{"task_id": "CPP/150", "generation": "#include <cmath>\n#include <stdio.h>\nusing namespace std;\n\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i <= sqrt(n); i++) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\nint x_or_y(int n, int x, int y) {\n    if (is_prime(n)) {\n        return x;\n    } else {\n        return y;\n    }\n}\n"}
{"task_id": "CPP/151", "generation": "#include <stdio.h>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\nlong long double_the_difference(vector<float> lst) {\n    long long sum_of_squares = 0; // Initialize sum of squares\n    for (float number : lst) {\n        // Check if the number is an integer and non-negative\n        if (number >= 0 && floor(number) == number) {\n            int int_number = static_cast<int>(number); // Convert to integer\n            // Check if the integer is odd\n            if (int_number % 2 != 0) {\n                sum_of_squares += int_number * int_number; // Add square to sum\n            }\n        }\n    }\n    return sum_of_squares; // Return the final sum\n}\n"}
{"task_id": "CPP/152", "generation": "#include <vector>\n#include <cmath> // for abs function\nusing namespace std;\n\nvector<int> compare(vector<int> game, vector<int> guess) {\n    vector<int> result; // Initialize the result vector\n    for (size_t i = 0; i < game.size(); i++) { // Loop through each match\n        if (game[i] == guess[i]) {\n            result.push_back(0); // Correct guess\n        } else {\n            result.push_back(abs(game[i] - guess[i])); // Incorrect guess, store the absolute difference\n        }\n    }\n    return result; // Return the result vector\n}\n"}
{"task_id": "CPP/153", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring Strongest_Extension(string class_name, vector<string> extensions) {\n    int max_strength = -1e9; // A very small number to start with\n    string strongest_extension = \"\";\n    \n    for (const string& extension : extensions) {\n        int CAP = 0;\n        int SM = 0;\n        \n        for (char c : extension) {\n            if (isupper(c)) {\n                CAP++;\n            } else if (islower(c)) {\n                SM++;\n            }\n        }\n        \n        int strength = CAP - SM;\n        \n        if (strength > max_strength) {\n            max_strength = strength;\n            strongest_extension = extension;\n        }\n    }\n    \n    return class_name + \".\" + strongest_extension;\n}\n"}
{"task_id": "CPP/154", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nbool cycpattern_check(string a, string b) {\n    // Create the concatenated string of b with itself\n    string b_rotations = b + b;\n    // Check if a is a substring of b_rotations\n    return b_rotations.find(a) != string::npos;\n}\n"}
{"task_id": "CPP/155", "generation": "#include <stdio.h>\n#include <string>\n#include <vector>\n#include <cmath> // for abs function\nusing namespace std;\n\nvector<int> even_odd_count(int num) {\n    vector<int> counts(2, 0); // counts[0] for even, counts[1] for odd\n    num = abs(num); // Get the absolute value of the number\n    string numStr = to_string(num); // Convert the number to string\n\n    for (char digitChar : numStr) {\n        int digit = digitChar - '0'; // Convert character to integer\n        if (digit % 2 == 0) {\n            counts[0]++; // Increment even count\n        } else {\n            counts[1]++; // Increment odd count\n        }\n    }\n    \n    return counts; // Return the counts vector\n}\n"}
{"task_id": "CPP/156", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring int_to_mini_roman(int number) {\n    // Define the mapping of values to Roman numeral symbols\n    vector<pair<int, string>> romanMapping = {\n        {1000, \"m\"}, {900, \"cm\"}, {500, \"d\"}, {400, \"cd\"},\n        {100, \"c\"}, {90, \"xc\"}, {50, \"l\"}, {40, \"xl\"},\n        {10, \"x\"}, {9, \"ix\"}, {5, \"v\"}, {4, \"iv\"},\n        {1, \"i\"}\n    };\n    \n    string result = \"\";\n    \n    // Iterate through the mapping\n    for (const auto& [value, symbol] : romanMapping) {\n        while (number >= value) {\n            result += symbol; // Append the symbol\n            number -= value;  // Subtract the value\n        }\n    }\n    \n    return result; // Return the final Roman numeral string\n}\n"}
{"task_id": "CPP/157", "generation": "#include <stdio.h>\n#include <math.h>\nusing namespace std;\n\nbool right_angle_triangle(float a, float b, float c) {\n    // Identify the longest side\n    float longest = max(max(a, b), c);\n    \n    // Check the Pythagorean theorem based on which side is the longest\n    if (longest == a) {\n        return (b * b + c * c) == (a * a);\n    } else if (longest == b) {\n        return (a * a + c * c) == (b * b);\n    } else {\n        return (a * a + b * b) == (c * c);\n    }\n}\n"}
{"task_id": "CPP/158", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <set>\n#include <algorithm>\nusing namespace std;\n\nstring find_max(vector<string> words) {\n    string maxWord = \"\";\n    int maxUniqueCount = 0;\n\n    for (const string& word : words) {\n        set<char> uniqueChars(word.begin(), word.end()); // Create a set of unique characters\n        int uniqueCount = uniqueChars.size(); // Count of unique characters\n\n        // Check if we found a new maximum or if we need to update lexicographically\n        if (uniqueCount > maxUniqueCount || (uniqueCount == maxUniqueCount && word < maxWord)) {\n            maxUniqueCount = uniqueCount;\n            maxWord = word;\n        }\n    }\n    \n    return maxWord;\n}\n"}
{"task_id": "CPP/159", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nvector<int> eat(int number, int need, int remaining) {\n    int total_needed = number + need;\n    int total_eaten;\n    int remaining_after;\n\n    if (remaining >= need) {\n        total_eaten = total_needed;\n        remaining_after = remaining - need;\n    } else {\n        total_eaten = total_needed - (need - remaining);\n        remaining_after = 0;\n    }\n\n    return {total_eaten, remaining_after};\n}\n"}
{"task_id": "CPP/160", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath> // For pow function\nusing namespace std;\n\nint do_algebra(vector<string> operato, vector<int> operand) {\n    int result = operand[0]; // Start with the first operand\n\n    for (size_t i = 0; i < operato.size(); i++) {\n        string op = operato[i];\n        int next_operand = operand[i + 1];\n\n        if (op == \"+\") {\n            result += next_operand;\n        } else if (op == \"-\") {\n            result -= next_operand;\n        } else if (op == \"*\") {\n            result *= next_operand;\n        } else if (op == \"//\") {\n            result /= next_operand; // Assuming integer division\n        } else if (op == \"**\") {\n            result = static_cast<int>(pow(result, next_operand)); // Exponentiation\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/161", "generation": "#include <stdio.h>\n#include <string>\n#include <cctype> // for isalpha, toupper, tolower\nusing namespace std;\n\nstring solve(string s) {\n    string result = \"\";\n    bool hasLetter = false;\n\n    for (char c : s) {\n        if (isalpha(c)) {\n            hasLetter = true;\n            // Reverse case\n            if (islower(c)) {\n                result += toupper(c);\n            } else {\n                result += tolower(c);\n            }\n        } else {\n            result += c; // Keep non-letter characters as is\n        }\n    }\n\n    // If no letters were found, reverse the result string\n    if (!hasLetter) {\n        reverse(result.begin(), result.end());\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/162", "generation": "#include <stdio.h>\n#include <string>\n#include <openssl/md5.h>\n#include <sstream>\n#include <iomanip>\n\nusing namespace std;\n\nstring string_to_md5(string text) {\n    if (text.empty()) {\n        return \"None\"; // Return \"None\" as a string for empty input\n    }\n\n    unsigned char digest[MD5_DIGEST_LENGTH];\n    MD5((unsigned char*)text.c_str(), text.length(), digest);\n\n    // Convert the digest to a hexadecimal string\n    stringstream ss;\n    for (int i = 0; i < MD5_DIGEST_LENGTH; i++) {\n        ss << hex << setw(2) << setfill('0') << (int)digest[i];\n    }\n\n    return ss.str();\n}\n"}
{"task_id": "CPP/163", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> generate_integers(int a, int b) {\n    vector<int> result;\n    int min_val = min(a, b);\n    int max_val = max(a, b);\n    \n    // Check even digits from 2 to 8\n    for (int even_digit : {2, 4, 6, 8}) {\n        if (even_digit >= min_val && even_digit <= max_val) {\n            result.push_back(even_digit);\n        }\n    }\n    \n    return result;\n}\n"}
